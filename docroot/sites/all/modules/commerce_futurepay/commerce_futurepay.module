<?php

/**
 * @file
 * Implements FuturePay payment services for use with Drupal Commerce.
 */

// Private constants
define('COMMERCE_FUTUREPAY_PMID', '41b453589dabd05c9dc4e889d7b7fea60e7b9817FPM889255345');
define('COMMERCE_FUTUREPAY_PAYMENT_STATUS_REFUND', 'fp_refund');
define('COMMERCE_FUTUREPAY_PAYMENT_STATUS_REFUND_FAILS', 'fp_refund_fails');

/**
 * Implements hook_menu().
 */
function commerce_futurepay_menu() {
  $items = array();

  $items['commerce-futurepay/validate-transaction/%'] = array(
    'title' => 'FuturePay validation route',
    'page callback' => 'commerce_futurepay_api_complete_transaction',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_commerce_payment_method_info().
 */
function commerce_futurepay_commerce_payment_method_info() {
  $payment_methods = array();

  $payment_methods['futurepay'] = array(
    'base' => 'commerce_futurepay',
    'title' => t('FuturePay Payment Gateway'),
    'short_title' => t('FuturePay'),
    'description' => t('FuturePay Payment Gateway for Drupal Commerce.'),
    'display_title' => t('FuturePay'),
  );

  return $payment_methods;
}

/**
 * Implement hook_commerce_payment_transaction_status_info().
 */
function commerce_futurepay_commerce_payment_transaction_status_info() {
  $statuses = array();

  $statuses[COMMERCE_FUTUREPAY_PAYMENT_STATUS_REFUND] = array(
    'status' => COMMERCE_FUTUREPAY_PAYMENT_STATUS_REFUND,
    'title' => t('Refund'),
    'icon' => drupal_get_path('module', 'commerce_futurepay') . '/theme/icon-refund.png',
    'total' => FALSE,
  );

  $statuses[COMMERCE_FUTUREPAY_PAYMENT_STATUS_REFUND_FAILS] = array(
    'status' => COMMERCE_FUTUREPAY_PAYMENT_STATUS_REFUND_FAILS,
    'title' => t('Refund fails'),
    'icon' => drupal_get_path('module', 'commerce_futurepay') . '/theme/icon-refund-fails.png',
    'total' => FALSE,
  );

  return $statuses;
}

/**
 * Payment method callback: settings form.
 */
function commerce_futurepay_settings_form($settings = array()) {
  $form = array();

  $form['fp_settings_help_text'] = array(
    '#markup' => t('Please, fill out the information below to activate the FuturePay payment gateway on your website.'),
  );

  $form['fp_gmid'] = array(
    '#type' => 'textfield',
    '#title' => t('Merchant API Key'),
    '#description' => t('Identifier provided to the merchant by FuturePay'),
    '#default_value' => isset($settings['fp_gmid']) ? $settings['fp_gmid'] : '',
    '#required' => TRUE,
  );

  $form['fp_server'] = array(
    '#type' => 'radios',
    '#title' => t('FuturePay environment'),
    '#options' => array(
      'live' => t('live'),
      'sandbox' => t('sandbox'),
    ),
    '#default_value' => isset($settings['fp_server']) ? $settings['fp_server'] : 'live',
  );

  return $form;
}

/**
 * Implements hook_form_alter().
 *
 * Hide the "continue to next step" button when choosing FuturePay payment
 * gateway.
 */
function commerce_futurepay_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'commerce_checkout_form_review') {
    $form['#attached']['js'][] = drupal_get_path('module', 'commerce_futurepay') . '/theme/commerce_futurepay.ux.js';
  }
}

/**
 * Payment method callback: payment gateway form.
 */
function commerce_futurepay_submit_form($payment_method, $pane_values, $checkout_pane, $order) {
  $form = array();

  // Add a proceed button.
  $form['futurepay_proceed'] = array(
    '#type' => 'submit',
    '#value' => t('Proceed with FuturePay'),
    '#weight' => 100,
    '#action_name' => 'proceed',
    '#name' => 'commerce-futurepay-proceed',
    '#validate' => array('commerce_futurepay_payment_method_validate'),
    '#executes_submit_callback' => FALSE,
    '#prefix' => '<div id="futurepay-container">',
    '#suffix' => '</div>',
    '#ajax' => array(
      'callback' => 'commerce_futurepay_payment_method_ajax_callback',
      'wrapper' => 'payment-details',
    ),
  );

  return $form;
}

/**
 * Validation callback: payment method element.
 *
 * Validation of required information for FuturePay services.
 *
 * @param array $form
 *   The form array.
 * @param array $form_state
 *   The form state element.
 */
function commerce_futurepay_payment_method_validate($form, &$form_state) {
  // Initialize the API Call to retrieve the order token from FuturePay
  // services.
  $token = commerce_futurepay_api_get_order_token($form_state['order'], isset($form_state['values']['amount']) ? $form_state['values']['amount'] : FALSE);

  if (is_string($token) && strpos($token, 'FP_') === FALSE) {
    // Now we have a correct token, we save the token in the form state values.
    $form_state['values']['futurepay_transaction_token'] = $token;
  }
  else {
    form_set_error('payment_details', _commerce_futurepay_transaction_error_codes($token));
  }
}


/**
 * Element callback; Returns the results after a ajax call.
 *
 * If the validation is ok, we display the FuturePay payment form trough a
 * javascript script.
 */
function commerce_futurepay_payment_method_ajax_callback($form, &$form_state) {
  $element_parents = array_slice($form_state['triggering_element']['#array_parents'], 0, -1);
  $element = drupal_array_get_nested_value($form, $element_parents);

  if (isset($form_state['values']['futurepay_transaction_token'])) {
    // Use the right domain.
    $service_domain = _commerce_futurepay_service_domain();
    $element['#attached']['js'][$service_domain . '/remote/cart-integration/' . $form_state['values']['futurepay_transaction_token']] = array('type' => 'external');
    $element['#attached']['js'][] = drupal_get_path('module', 'commerce_futurepay') . '/theme/commerce_futurepay.main.js';
  }

  return $element;
}

function commerce_futurepay_ajax_render_alter(&$commands) {
  if (isset($commands[0]['settings']['ajax'])) {
    $settings = reset($commands[0]['settings']['ajax']);
    if ($settings['submit']['_triggering_element_name'] == 'commerce-futurepay-proceed') {
      $commands[] = ajax_command_append(NULL, '<script type="text/javascript">if (typeof(FuturePayIntialiseForm) != "undefined") {FuturePayIntialiseForm();}</script>');
    }
  }
}

/**
 * Payment method callback: submit form validation.
 *
 * Ensure the transaction has been successfully recorded.
 */
function commerce_futurepay_submit_form_validate($payment_method, $pane_form, $pane_values, $order, $form_parents = array()) {
  if (isset($order->data['commerce_payment_order_paid_in_full_invoked']) && $order->data['commerce_payment_order_paid_in_full_invoked'] === TRUE) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Implements hook_commerce_payment_totals_row_info().
 */
function commerce_futurepay_commerce_payment_totals_row_info($totals, $order) {
  $rows = array();

  $refund_amount = commerce_futurepay_order_refund_balance($order->order_id);

  if (count($totals) == 1 && key($totals) == 'USD' && $refund_amount['amount'] > 0) {
    $currency_code = key($totals);

    // Add a row for the total amount paid.
    $rows[] = array(
      'data' => array(
        array('data' => t('Total refunded'), 'class' => array('label')),
        array(
          'data' => commerce_currency_format($refund_amount['amount'], $currency_code),
          'class' => array('total')
        ),
      ),
      'class' => array('total-refunded'),
      'weight' => 1,
    );
  }

  return $rows;
}

/**
 * Return the total refund amount for the passed order ID.
 *
 * @param string|int $order_id
 *   The order identifier.
 *
 * @return array.
 *   A price array (amount, currency_code).
 */
function commerce_futurepay_order_refund_balance($order_id) {
  $amount = 0;
  $transactions = commerce_payment_transaction_load_multiple(
    array(), array(
                  'order_id' => array($order_id),
                  'status' => array(COMMERCE_FUTUREPAY_PAYMENT_STATUS_REFUND)
             )
  );

  if (!empty($transactions)) {
    // Calculating the total refund amount.
    foreach ($transactions as $transaction) {
      $amount += $transaction->amount;
    }
  }

  return array('amount' => $amount, 'currency_code' => 'USD');
}

/**
 * Perform an API call to get the futurepay order token.
 *
 * @param object $order
 *   A fully qualified order object.
 * @param int|bool $amount
 *   Force the payment amount for the transaction.
 *
 * @return string|bool
 *   The response returned by cURL. Return FALSE if is something went wrong.
 */
function commerce_futurepay_api_get_order_token($order, $amount = FALSE) {
  $instance = commerce_payment_method_instance_load('futurepay|commerce_payment_futurepay');

  // Return FALSE if fp_gmip is not set or empty.
  if (!isset($instance['settings']['fp_gmid']) || empty($instance['settings']['fp_gmid'])) {
    return FALSE;
  }

  $wrapper_order = entity_metadata_wrapper('commerce_order', $order);

  $postDataArray = array(
    'gmid' => $instance['settings']['fp_gmid'],
    'pmid' => COMMERCE_FUTUREPAY_PMID,
    'reference' => $order->order_id,
  );

  // FuturePay API services doesn't handle the negative prices, so we have to
  // pass the order total amount as unique purchased product.
  $postDataArray['sku'][] = $wrapper_order->order_id->value();
  $postDataArray['price'][] = commerce_currency_amount_to_decimal(is_int($amount) ? $amount : $wrapper_order->commerce_order_total->amount->value(), 'USD');
  $postDataArray['tax_amount'][] = 0.00;
  $postDataArray['quantity'][] = 1;
  $postDataArray['description'][] = 'Total order amount';

  // Set the billing information.
  $billing_profile = $wrapper_order->commerce_customer_billing->commerce_customer_address->value();

  $postDataArray['email'] = substr($wrapper_order->mail->value(), 0, 85);

  if (isset($billing_profile['name_line'])) {
    // FuturePay services require a first name and a last name. In order to not
    // force the website owner the changer the billing profile layout, we are
    // splitting the name line in two.
    list($billing_profile['first_name'], $billing_profile['last_name']) = explode(" ", trim($billing_profile['name_line']), 2);
  }

  $postDataArray['first_name'] = substr($billing_profile['first_name'], 0, 45);
  $postDataArray['last_name'] = substr($billing_profile['last_name'], 0, 45);
  $postDataArray['address_line_1'] = substr($billing_profile['thoroughfare'] . $billing_profile['premise'], 0, 800);
  $postDataArray['address_line_2'] = substr($billing_profile['premise'], 0, 800);
  $postDataArray['city'] = substr($billing_profile['locality'], 0, 45);
  $postDataArray['state'] = $billing_profile['administrative_area'];
  $postDataArray['country'] = $billing_profile['country'];
  $postDataArray['zip'] = substr(filter_var($billing_profile['postal_code'], FILTER_SANITIZE_NUMBER_INT), 0, 5);
  $postDataArray['phone'] = empty($billing_profile['phone_number']) ? '111-111-1111' : substr($billing_profile['phone_number'], 0, 45);

  return _commerce_futurepay_build_curl_request(_commerce_futurepay_service_url('order_token'), $postDataArray);
}

/**
 * Perform an API call to complete a FuturePay transaction
 *
 * @param string $transaction_id
 *   A transaction Identifier sent by the FuturePay services.
 *
 * @return string
 *   A JSON formatted response.
 */
function commerce_futurepay_api_complete_transaction($transaction_id) {
  // Prepare the post parameters.
  $instance = commerce_payment_method_instance_load('futurepay|commerce_payment_futurepay');

  $postDataArray = array(
    'gmid' => $instance['settings']['fp_gmid'],
    'otxnid' => $transaction_id,
  );

  // Set response header to "application/json".
  drupal_add_http_header('Content-Type', 'application/json');

  // Get the response from FuturePay services.
  $response = _commerce_futurepay_build_curl_request(_commerce_futurepay_service_url('complete_order'), $postDataArray);
  $decoded_response = json_decode($response, TRUE);

  if (isset($decoded_response['OrderStatusCode'])) {
    $transaction = commerce_payment_transaction_new('futurepay|commerce_payment_futurepay', $decoded_response['OrderReference']);
    $transaction->instance_id = $instance['instance_id'];
    $transaction->remote_id = $decoded_response['FPCSRFTK'];
    $transaction->currency_code = 'USD';
    $transaction->payment_method = $instance['method_id'];
    $transaction->amount = commerce_currency_decimal_to_amount($decoded_response['t.TotalPrice'], 'USD');
    if ($decoded_response['OrderStatusCode'] == 'ACCEPTED') {
      $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
    }
    elseif ($decoded_response['OrderStatusCode'] == 'DECLINED') {
      $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
    }
    $transaction->remote_status = $decoded_response['OrderStatusCode'];

    commerce_payment_transaction_save($transaction);

    echo $response;
    drupal_exit();
  }

  echo '';
  drupal_exit();
}

/**
 * Performs an API call to partially/fully refund a FuturePay transaction.
 *
 * @param string|int $order_id
 *   A order identifier used as the reference number.
 * @param float $total_price
 *   The total amount to be refunded to the customer.
 * @param string $notes
 *   Used for notes about the return. This will show on the customers statement.
 *
 * @return mixed
 *   Return the saved transaction. Otherwise returns FALSE.
 */
function commerce_futurepay_api_refund_transaction($order_id, $total_price, $notes = '') {
  $instance = commerce_payment_method_instance_load('futurepay|commerce_payment_futurepay');

  // Return FALSE if fp_gmip is not set or empty.
  if (!isset($instance['settings']['fp_gmid']) || empty($instance['settings']['fp_gmid'])) {
    return FALSE;
  }

  $postDataArray = array(
    'gmid' => $instance['settings']['fp_gmid'],
    'pmid' => COMMERCE_FUTUREPAY_PMID,
    'reference' => $order_id,
    'total_price' => $total_price,
    'notes' => $notes,
  );

  $response = _commerce_futurepay_build_curl_request(_commerce_futurepay_service_url('refund_order'), $postDataArray);
  $decoded_response = json_decode($response, TRUE);

  if (isset($decoded_response['status'])) {
    $transaction = commerce_payment_transaction_new('futurepay|commerce_payment_futurepay', $order_id);
    $transaction->instance_id = $instance['instance_id'];
    $transaction->payment_method = $instance['method_id'];
    $transaction->remote_id = isset($decoded_response['TransactionReference']) ? $decoded_response['TransactionReference'] : "";
    $transaction->currency_code = 'USD';
    $transaction->remote_status = $decoded_response['status'];
    $transaction->amount = commerce_currency_decimal_to_amount($total_price, 'USD');
    if ($decoded_response['status'] == 'FP_REFUND_SUCCESSFUL') {
      $transaction->status = COMMERCE_FUTUREPAY_PAYMENT_STATUS_REFUND;
      $transaction->message = t('Refund Successful');
    }
    else {
      $transaction->status = COMMERCE_FUTUREPAY_PAYMENT_STATUS_REFUND_FAILS;
      $transaction->message = _commerce_futurepay_refund_error_codes($decoded_response['status']);
    }

    if (commerce_payment_transaction_save($transaction)) {
      return $transaction;
    }
  }

  return FALSE;
}

/**
 * Initialize a cURL request to access FuturePay services.
 *
 * Only POST.
 *
 * @param string $url
 *   The url to the service.
 * @param array $postDataArray
 *   An array of parameters passed with post method.
 *
 * @return string
 *   A json formatted response.
 */
function _commerce_futurepay_build_curl_request($url, $postDataArray) {
  //create CURL request to the server
  $ch = curl_init();

  curl_setopt($ch, CURLOPT_URL, $url);
  curl_setopt($ch, CURLOPT_POST, 1);
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
  curl_setopt($ch, CURLOPT_POSTFIELDS, http_build_query($postDataArray));
  curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, FALSE);
  curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, FALSE);


  //receive response from FuturePay
  $server_output = trim(curl_exec($ch));

  //close the connection socket
  curl_close($ch);

  return $server_output;
}

/**
 * Return the human message of the passed error code.
 *
 * @param string $code
 *   The error code message.
 *
 * @return string|bool
 *   The human error message. Otherwise return a generic error message.
 */
function _commerce_futurepay_transaction_error_codes($code) {
  $error_code_list = array(
    'FP_EXISTING_INVALID_CUSTOMER_STATUS' => t('Your purchase was not successful because your account is not in an active state. Please contact FuturePay at support@futurepay.com'),
    'FP_INVALID_ID_REQUEST' => t('The GMID could not be validated – either missing or not valid format – Contact FuturePay'),
    'FP_INVALID_SERVER_REQUEST' => t('Either the Merchant Server is not on our IP Whitelist or the Order Reference was Missing'),
    'FP_PRE_ORDER_EXCEEDS_MAXIMUM' => t('The Maximum Amount for a FuturePay order has been exceeded: Currently $500.00'),
    'FP_MISSING_REFERENCE' => t('Reference was not detected in the Query String'),
    'FP_INVALID_REFERENCE' => t('Reference is invalid'),
    'FP_ORDER_EXISTS' => t('The reference exists with an order that has completed sales attached'),
    'FP_MISSING_REQUIRED_FIRST_NAME' => t('First Name was not detected in the Query String'),
    'FP_MISSING_REQUIRED_LAST_NAME' => t('Last Name was not detected in the Query String'),
    'FP_MISSING_REQUIRED_PHONE' => t('Phone Name was not detected in the Query String'),
    'FP_MISSING_REQUIRED_CITY' => t('City was not detected in the Query String'),
    'FP_MISSING_REQUIRED_STATE' => t('State was not detected in the Query String'),
    'FP_MISSING_REQUIRED_ADDRESS' => t('Address was not detected in the Query String'),
    'FP_MISSING_REQUIRED_COUNTRY' => t('Country was not detected in the Query String'),
    'FP_COUNTRY_US_ONLY' => t('The Country was not US'),
    'FP_MISSING_EMAIL' => t('Email was not detected in the Query String'),
    'FP_INVALID_EMAIL_SIZE' => t('Email Size was greater than 85'),
    'FP_INVALID_EMAIL_FORMAT' => t('Email Format was not valid'),
    'FP_MISSING_REQUIRED_ZIP' => t('Zip was not detected in the Query String'),
    'FP_NO_ZIP_FOUND' => t('The Zip code you entered for your billing address corresponds to a Military (APO/FPO/DPO), PO Box or other non-physical address. To approve your application we require a Zip code associated with a physical address in the U.S.'),
    'FP_FAILED_ZIP_LOOKUP' => t('FuturePay failed to lookup the Zip Code – FuturePay needs to investigate the cause'),
    'FP_MISSING_ORDER_ITEM_FIELDS' => t('At least one order item must exist and for each order item all of the fields must exist for price, quantity, sku, description, tax_amount'),
    'FP_INVALID_PRICE' => t('Price must be a non-negative float value'),
    'FP_INVALID_TAX' => t('Tax must be a non-negative float value'),
    'FP_INVALID_QUANTITY' => t('Quantity must be an integer'),
    'FP_INVALID_SHIPPING_DATE' => t('The Shipping date could not be parsed'),
    'FP_SHIPPING_IN_PAST' => t('The Shipping date must be today or in the Future'),
    'FP_PRE_ORDER_FAILED' => t('An Error occurred in trying to save the Order – FuturePay needs to investigate the cause'),
    'FP_INVALID_STATE_ZIP_COMBINATION' => t('An invalid zip code has been provided'),
  );

  return isset($error_code_list[$code]) ? $error_code_list[$code] : t('An unknown error has been raised. Please contact the FuturePay services.');
}

/**
 * Return the human message of the passed error code.
 *
 * @param string $code
 *   The FuturePay error code.
 *
 * @return string
 *   A translatable human message.
 */
function _commerce_futurepay_refund_error_codes($code) {
  $error_code_list = array(
    'FP_ INVALID_SERVER_ORDER_ST' => t('Invalid Order Status, the order exists in FuturePay but is not accepted.'),
    'FP_INVALID_SERVER_REQUEST' => t('The GMID could not be validated – either missing or not valid format – Contact FuturePay.'),
    'FP_INVALID_SERVER_REQUEST_WL' => t('Either the Merchant Server is not on our IP Whitelist.'),
    'FP_INVALID_TOTAL' => t('Invalid Total Amount Maybe negative or not a number.'),
    'FP_REFUNDS_GREATER_THAN_ORDER_TOTAL' => t('The entered refund amount is greater than the total refundable.'),
    'FP_INVALID_SERVER_ORDER_ST' => t("The order can't be found in the FuturePay databases."),
  );

  return isset($error_code_list[$code]) ? $error_code_list[$code] : t('An unknown error has been raised. Please contact the FuturePay services.');
}

/**
 * Return the correct FuturePay service URL by environment mode.
 * @TODO allow instance to be passed into here.
 * 
 * @param string $service
 *   {'order_token', 'complete_order', 'refund_order'}
 *
 * @return string|bool
 *   The complete URL. Otherwise return FALSE.
 */
function _commerce_futurepay_service_url($service) {
  $services = array(
    'order_token' => '/remote/merchant-request-order-token',
    'complete_order' => '/remote/merchant-order-verification',
    'refund_order' => '/remote/merchant-returns',
  );

  if (isset($services[$service])) {
    return _commerce_futurepay_service_domain() . $services[$service];
  }

  return FALSE;
}

/**
 * Get the correct domain for a futurepay method instance.
 * 
 * @param type $instance_id
 * @return type
 */
function _commerce_futurepay_service_domain($instance_id = 'futurepay|commerce_payment_futurepay') {
  $instance = commerce_payment_method_instance_load($instance_id);
  
  $environments = array(
    'live' => 'https://api.futurepay.com',
    'sandbox' => 'https://sandbox.futurepay.com',
  );
  
  return isset($environments[$instance['settings']['fp_server']]) ? $environments[$instance['settings']['fp_server']] : $environments['live'];
}

/**
 * Implements hook_views_api().
 */
function commerce_futurepay_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'commerce_futurepay') . '/includes/views',
  );
}
