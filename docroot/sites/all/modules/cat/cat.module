<?php

/**
 * @file The Context Actions and Tasks (CAT) module provide the showing or
 * hiding local actions and local tasks for existing menu path.
 *
 * @author Oleksiy Kalinichenko <aexchecker@gmail.com>
 */

/**
 * Implements hook_menu_local_tasks_alter().
 */
function cat_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  // Use the advanced drupal_static() pattern.

  //prepare cache ID
  $current_path = current_path();
  $args = $_GET;
  if (!empty($args['destination']))
    unset($args['destination']);

  $current_path_md5 = md5(serialize($args)); //create a unique cache key that respects the full path including the get parameters

  $data_alter = &drupal_static(__FUNCTION__);
  if (!empty($data_alter[$current_path_md5])) {
    $data = $data_alter[$current_path_md5];
    return;
  }

  // Generate a cache ID (cid) specific for this $root_path and $language.
  $cache_cat_items = variable_get('cat_cache_cat_items', FALSE);

  $cache = false;
  if ($cache_cat_items) {
    $cid = 'cat_items:' . $current_path_md5 . ':' . $GLOBALS['language']->language;

    //@TODO we may invalidate this cache if a related cat item was changed.
    $cache = cache_get($cid, 'cache_cat_items');
  }

  if ($cache && isset($cache->data)) {
    // Get alternative $data with CAT items
    $data = $cache->data;
  }
  else {
    $data = _cat_menu_local_tasks_alter($data, $router_item, $root_path);

    // Store $data in cache for future use.
    if ($cache_cat_items) {
      cache_set($cid, $data, 'cache_cat_items');
    }
  }

  // Call alter functions to prepare view $data
  drupal_alter('cat_local_task_view', $data);

  // Save static cache.
  $data_alter[$current_path_md5] = $data;

}

/**
 * Implements hook_preprocess_menu_link(&$variables).
 */
function cat_preprocess_menu_link(&$variables) {
  static $init;

  if (!isset($init)) {
    // Start initilization.
    $init = TRUE;

    // Gets a router item.
    $router_item = menu_get_item();

    // If this router item points to its parent, start from the parents to
    // compute tabs and actions.
    if ($router_item && ($router_item['type'] & MENU_LINKS_TO_PARENT)) {
      $router_item = menu_get_item($router_item['tab_parent_href']);
    }

    // If we succeed to fetch a router item and the current
    // user has access to it.
    if (!empty($router_item['access'])) {
      $root_path = $router_item['path'];
      $menu_local_tasks = array(
        'tabs' => array('count' => 0, 'output' => array()),
        'actions' => array('count' => 0, 'output' => array()),
        'root_path' => $router_item['path'],
      );

      // Get active-trail from CAT items.
      $menu_local_tasks = _cat_menu_local_tasks_alter($menu_local_tasks, $router_item, $root_path);
      // Call alter functions to prepare view $data
      drupal_alter('cat_local_task_view', $menu_local_tasks);

      // Set the active-trail for each menu containing one of the candidates
      if (!empty($menu_local_tasks['active_trail_path'])) {
        foreach ($menu_local_tasks['active_trail_path'] as $menu_name => $menu_link) {
          menu_tree_set_path($menu_name, $menu_link);
          cat_set_active_trail($menu_link);
        }
      }
    }
  }

  $element = &$variables['element'];
  $active_trail = cat_get_active_trail();

  if ($active_trail && in_array($element['#href'], $active_trail)) {
    if (!in_array('active-trail', $element['#attributes']['class'])) {
      $element['#attributes']['class'][] = 'active-trail';
    }
    if (empty($element['#localized_options']['attributes']['class']) || !in_array('active-trail', $element['#localized_options']['attributes']['class'])) {
      $element['#localized_options']['attributes']['class'][] = 'active-trail';
    }
  }
}

/**
 * Return alternative local tasks with CAT items for router path.
 *
 * @param array $data
 * @param array $router_item
 * @param string $root_path
 *
 * @return array
 */
function _cat_menu_local_tasks_alter($data, $router_item, $root_path) {
  if (!($cat_items = cat_load_by_path($router_item['path']))) {
    return $data;
  }

  // Check and prepare multilevel tabs and actions.
  if (!isset($data['tabs'][0])) {
    if (isset($data['tabs']['count']) && isset($data['tabs']['output'])) {
      $data['tabs'] = array(
        0 => array(
          'output' => $data['tabs']['output'],
          'count' => $data['tabs']['count'],
        ),
      );
    }
  }

  foreach ($cat_items as $cat_item) {
    if (!isset($cat_item->path_router)) {
      continue;
    }

    // Load CAT item's CTools contexts
    $contexts = array();
    if (!empty($cat_item->arguments)) {
      $contexts = cat_get_contexts_from_arguments($cat_item->arguments);
      // If CAT item contains broken context it means that unable to load context from URL.
      if (isset($contexts['broken_context'])) {
        continue;
      }
    }

    // Check if CAT item is accessible for current page
    ctools_include('context');
    if (!empty($cat_item->access) && !ctools_access($cat_item->access, $contexts)) {
      continue;
    }

    // Remove existed Tabs and Actions
    if (!empty($cat_item->cat_remove)) {
      foreach ($cat_item->cat_remove as $remove_delta => $cat_remove) {
        // remove tabs and actions that match the path of remove cat items
        foreach ($data['tabs'] as $tab_delta => &$output) {
          foreach ($output['output'] as $output_delta => $a_output) {
            if (!empty($a_output['#link']['path'])) {
              if ($cat_remove['path'] == $a_output['#link']['path'] && !empty($cat_remove['remove_settings']['tab'])) {
                // remove this this one
                unset($output['output'][$output_delta]);
              }
            }
          }

          // update the counter
          $data['tabs'][$tab_delta]['count'] = count($data['tabs'][$tab_delta]['output']);
        }

        // now remove tasks
        foreach ($data['actions'] as $tab_delta => &$output) {
          if (is_array($output)) {
            foreach ($output as $output_delta => $a_output) {
              if (!empty($a_output['#link']['path'])) {
                if ($cat_remove['path'] == $a_output['#link']['path'] && !empty($cat_remove['remove_settings']['action'])) {
                  // remove this this one
                  unset($output[$output_delta]);
                }
              }
            }
          }
        }

        // update the counter for actions
        $data['actions']['count'] = count($data['actions']['output']);
      }
    }

    // Prepare Token replacers
    $token_fast_replacers = array();
    if (!empty($contexts)) {
      foreach ($contexts as &$context) {
        if (!empty($context->argument_name)) {
          if ($context->plugin === 'entity:node') {
            $token_fast_replacers["%{$context->argument_name}"] = $context->data->nid;
            $token_fast_replacers["[{$context->argument_name}:nid]"] = $context->data->nid;
          }
        }
      }
    }

    // Add new Tabs
    if (!empty($cat_item->cat_tabs)) {
      // prepare new tabs
      if (empty($data['tabs'][0])) {
        $data['tabs'][0] = array(
          'count' => 0,
          'output' => array(),
        );
      }

      // add new tabs
      foreach ($cat_item->cat_tabs as $key => $cat_tab) {
        $path = $cat_tab['path_original'];
        if ($token_fast_replacers) {
          $path = strtr($path, $token_fast_replacers);
        }
        if (cat_token_exists($path)) {
          $path = _cat_token_replace($path, $contexts);
        }

        if (!($tab_item = menu_get_item($path))) {
          // @TODO add/show error messages about wrong path
          continue;
        }

        //only show items with access
        if (!$tab_item['access']) {
          continue;
        }

        $tab_item['title'] = $cat_tab['title'];

        if (module_exists('cat_i18n') && !empty($cat_item->translatable)) {
          $tab_item['title'] = cat_i18n_string($tab_item['title'], $cat_item, $key);
        }

        if (cat_token_exists($tab_item['title'])) {
          $tab_item['title'] = _cat_token_replace($tab_item['title'], $contexts);
        }

        if (!isset($tab_item['localized_options'])) {
          $tab_item['localized_options'] = array();
        }

        $tab_item['localized_options'] += array(
          'query' => array(),
          'attributes' => array(
            'class' => array(),
          ),
        );

        $tab_item['cat_item'] = $cat_tab;

        // add css class
        if (!empty($cat_tab['css_class'])) {
          $class = array_filter(explode(' ', $cat_tab['css_class']));
          $class = array_merge($tab_item['localized_options']['attributes']['class'], $class);
          $tab_item['localized_options']['attributes']['class'] = array_unique($class);
        }

        // add css id
        if (!empty($cat_tab['id_class'])) {
          $tab_item['localized_options']['attributes']['id'] = $cat_tab['id_class'];
        }

        // add path query
        if (!empty($cat_tab['path_query'])) {
          foreach ($cat_tab['path_query'] as &$path_query_val) {
            if ($token_fast_replacers) {
              $path_query_val = strtr($path_query_val, $token_fast_replacers);
            }
            if (cat_token_exists($path_query_val)) {
              $path_query_val = _cat_token_replace($path_query_val, $contexts);
            }
          }
          $tab_item['localized_options']['query'] += $cat_tab['path_query'];
        }

        // add path destination
        if (!empty($cat_tab['path_destination'])) {
          $tab_item['localized_options']['query'] += drupal_get_destination();
        }

        if (!empty($tab_item['access'])) {
          $data['tabs'][0]['output'][$cat_tab['path']] = array(
            '#theme' => 'menu_local_task',
            '#link' => $tab_item,
            '#active' => $cat_tab['active'],
          );
        }
      }
    }

    // Add new Actions
    if (!empty($cat_item->cat_actions)) {
      foreach ($cat_item->cat_actions as $key => $cat_action) {
        $path = $cat_action['path_original'];
        if ($token_fast_replacers) {
          $path = strtr($path, $token_fast_replacers);
        }
        if (cat_token_exists($path)) {
          $path = _cat_token_replace($path, $contexts);
        }

        if (!($action_item = menu_get_item($path))) {
          // @TODO add/show error messages about wrong path
          continue;
        }

        //only show items with access
        if (!$action_item['access']) {
          continue;
        }

        $action_item['title'] = $cat_action['title'];

        if (module_exists('cat_i18n') && !empty($cat_item->translatable)) {
          $action_item['title'] = cat_i18n_string($action_item['title'], $cat_item, $key, 'cat_actions');
        }

        if (cat_token_exists($action_item['title'])) {
          $action_item['title'] = _cat_token_replace($action_item['title'], $contexts);
        }

        if (!isset($action_item['localized_options'])) {
          $action_item['localized_options'] = array();
        }

        $action_item['localized_options'] += array(
          'query' => array(),
          'attributes' => array(
            'class' => array(),
          ),
        );

        $action_item['cat_item'] = $cat_action;

        // add css class
        if (!empty($cat_action['css_class'])) {
          $class = array_filter(explode(' ', $cat_action['css_class']));
          $class = array_merge($action_item['localized_options']['attributes']['class'], $class);
          $action_item['localized_options']['attributes']['class'] = array_unique($class);
        }

        // add css id
        if (!empty($cat_action['id_class'])) {
          $action_item['localized_options']['attributes']['id'] = $cat_action['id_class'];
        }

        // add path query
        if (!empty($cat_action['path_query'])) {
          foreach ($cat_action['path_query'] as &$path_query_val) {
            if ($token_fast_replacers) {
              $path_query_val = strtr($path_query_val, $token_fast_replacers);
            }
            if (cat_token_exists($path_query_val)) {
              $path_query_val = _cat_token_replace($path_query_val, $contexts);
            }
          }
          $action_item['localized_options']['query'] += $cat_action['path_query'];
        }

        // add path destination
        if (!empty($cat_action['path_destination'])) {
          $action_item['localized_options']['query'] += drupal_get_destination();
        }

        if (!empty($action_item['access'])) {
          $data['actions']['output'][$cat_action['path']] = array( //add the path as key to avoid duplicates
            '#theme' => 'menu_local_action',
            '#link' => $action_item,
            '#active' => $cat_action['active'],
          );
        }
      }
    }

    // Add active trail path
    if (!empty($cat_item->active_trail_path)) {
      // Find paths
      $results = db_select('menu_links','ml')
        ->fields('ml', array('menu_name', 'link_path'))
        ->condition('link_path', $cat_item->active_trail_path)
        ->execute();

      foreach ($results as $record) {
        if (empty($matched_menus[$record->menu_name])) {
          $data['active_trail_path'][$record->menu_name] = $record->link_path;
        }
      }
    }
  }

  //update counters
  if (!empty($data['tabs'][0]['output'])) {
    $data['tabs'][0]['output'] = array_values($data['tabs'][0]['output']);
    $data['tabs'][0]['count'] = count($data['tabs'][0]['output']);
  }

  // update counts
  if (!empty($data['actions']['output'])) {
    $data['actions']['output'] = array_values($data['actions']['output']);
    $data['actions']['count'] = count($data['actions']['output']);
  }

  drupal_alter('cat_local_task', $data, $cat_items);

  if (variable_get('cat_show_single_tab', TRUE) && !empty($data['tabs'])) {
    foreach ($data['tabs'] as &$tabs) {
      if (!empty($tabs['output']) && ($tab_count = count($tabs['output'])) == 1) {
        $tabs['count'] = ++ $tab_count;
      }
    }
  }

  return $data;
}

/**
 * Implements hook_flush_caches().
 */
function cat_flush_caches() {
  return array(
    'cache_cat_items',
  );
}

/**
 * Load CAT item object.
 *
 * @param string $machine_name
 *
 * @return bool object
 */
function cat_load($machine_name) {
  $cat_item = cat_object_cache_get($machine_name);

  if (empty($cat_item)) {
    $cat_item = cat_load_by_name($machine_name);
    if (empty($cat_item)) {
      return FALSE;
    }
  }

  return $cat_item;
}

/**
 * Load all CAT items from database and code.
 *
 * @return array Array of CAT items objects.
 */
function cat_load_all() {
  ctools_include('export');

  $cat_items = ctools_export_load_object('cat_items', 'all');
  $cat_items = array_map('cat_load_prepare', $cat_items);
  uasort($cat_items, '_cat_sort_weight');

  return $cat_items;
}

/**
 * Load enabled CAT items by path.
 *
 * @param string $path
 *          Drupal router path.
 *
 * @return array Array of CAT items sorted by weight.
 */
function cat_load_by_path($path) {
  // Use the advanced drupal_static() pattern, since this is called very often.
  static $drupal_static_fast;
  if (!isset($drupal_static_fast)) {
    $drupal_static_fast['cat_items'] = &drupal_static(__FUNCTION__, array());
  }

  $cat_items = &$drupal_static_fast['cat_items'];

  // Get $cat_items by router path
  if (!isset($cat_items[$path])) {
    $cat_items[$path] = array();

    $cid = 'cat_items:path:' . $path;
    $cache = cache_get($cid, 'cache_cat_items');
    if ($cache && isset($cache->data)) {
      // Get $cat_items from cache
      $cat_items[$path] = $cache->data;
    }
    else {
      $cat_items[$path] = _cat_load_by_path($path);
      // Store $cat_items in cache for future use
      cache_set($cid, $cat_items[$path], 'cache_cat_items');
    }
  }

  return $cat_items[$path];
}

/**
 * Load CAT item by name.
 *
 * @param string $machine_name
 *          CAT item machine name.
 *
 * @return object
 */
function cat_load_by_name($machine_name) {
  // Use the advanced drupal_static() pattern.
  static $drupal_static_fast;
  if (!isset($drupal_static_fast)) {
    $drupal_static_fast['cat_items'] = &drupal_static(__FUNCTION__, array());
  }

  $cat_items = &$drupal_static_fast['cat_items'];

  if (!isset($cat_items[$machine_name])) {
    $cat_items[$machine_name] = FALSE;

    ctools_include('export');
    $result = ctools_export_load_object('cat_items', 'names', array($machine_name));

    if (!empty($result[$machine_name])) {
      $cat_items[$machine_name] = cat_load_prepare($result[$machine_name]);
    }
  }

  return $cat_items[$machine_name];
}

/**
 * Prepare raw object from Ctools to normal CAT item object
 *
 * @param object $cat_item_raw
 *          CAT item loaded from database or ctools_export_load_object().
 *
 * @return object $cat_items.
 */
function cat_load_prepare($cat_item_raw) {
  // Prepare $cat_item
  $cat_item = (object) array_merge((array) $cat_item_raw, $cat_item_raw->data);
  $cat_item->disabled = isset($cat_item->disabled) ? $cat_item->disabled : FALSE;
  $cat_item->is_overwritten = ($cat_item->export_type == (EXPORT_IN_DATABASE | EXPORT_IN_CODE));

  // Remove $cat_item->data property
  if (variable_get('cat_load_prepare_unset_data', TRUE)) {
    unset($cat_item->data);
  }

  return $cat_item;
}

/**
 * Load multiple CAT items objects by names.
 *
 * @param string $machine_names
 *
 * @return array
 */
function cat_load_by_name_multiple($machine_names) {
  ctools_include('export');

  if ($result = ctools_export_load_object('cat_items', 'names', $machine_names)) {
    $result = array_map('cat_load_prepare', $result);
  }

  return $result;
}

/**
 * Return list of tab/actions, which avalable for the reusing.
 *
 * @return array
 */
function cat_get_reusable() {
  $reusable = array();

  foreach (cat_load_all() as $cat_item) {
    // tabs
    $reusable_cat_items = array(
      'reusable' => !empty($cat_item->reusable),
      'cat_tabs' => array(),
      'cat_actions' => array(),
    );

    if (!empty($cat_item->cat_tabs)) {
      foreach ($cat_item->cat_tabs as $cat_path => $cat_tab) {
        if (!empty($cat_tab['reusable']) && !empty($cat_tab['machine_name'])) {
          $reusable_cat_items['cat_tabs'][$cat_path] = $cat_tab;
        }
      }
    }

    if ($reusable_cat_items) {
      $reusable[$cat_item->machine_name] = $reusable_cat_items;
    }

    // actions
    $reusable_cat_items = array();

    if (!empty($cat_item->cat_actions)) {
      foreach ($cat_item->cat_actions as $cat_path => $cat_action) {
        if (!empty($cat_action['reusable']) && !empty($cat_action['machine_name'])) {
          $reusable_cat_items['cat_actions'][$cat_path] = $cat_action;
        }
      }
    }

    if ($reusable_cat_items) {
      $reusable[$cat_item->machine_name] = $reusable_cat_items;
    }
  }

  return $reusable;
}

/**
 * Ctools export callback.
 *
 * @param object $cat_item
 * @param int $indent
 *
 * @return string
 */
function cat_export($cat_item, $indent) {
  // Structure object according to schema.
  if (empty($cat_item->access)) {
    $cat_item->access = array();
  }
  if (!empty($cat_item->access) && !empty($cat_item->logic)) {
    $cat_item->access['logic'] = $cat_item->logic;
  }

  $data = array();
  $data_raw = (array) $cat_item;
  $data_fields = array_keys(cat_get_info('fields'));

  unset($data_raw['data']);
  foreach ($data_fields as $data_field) {
    if (isset($data_raw[$data_field])) {
      $data[$data_field] = $data_raw[$data_field];
    }
  }

  $cat_item->data = $data;

  return ctools_export_object('cat_items', $cat_item, $indent);
}

/**
 * Ctools list callback of all avalible cat_item objects.
 *
 * @return array
 */
function cat_export_list() {
  $export_list = array();
  $cat_items = cat_load_all();

  // uksort($cat_items, 'strnatcmp');

  foreach ($cat_items as $cat_item) {
    $string = "{$cat_item->name} ({$cat_item->machine_name})";
    $export_list[$cat_item->machine_name] = check_plain($string);
  }

  return $export_list;
}

/**
 * Save cat_item.
 *
 * @param object $cat_item
 *          CAT item object
 *
 * @return int SAVED_NEW or SAVED_UPDATED.
 */
function cat_save($cat_item) {
  ctools_include('export');

  if (empty($cat_item->access)) {
    $cat_item->access = array();
  }
  if (!empty($cat_item->access) && !empty($cat_item->logic)) {
    $cat_item->access['logic'] = $cat_item->logic;
  }

  $data = array();
  $data_raw = (array) $cat_item;
  $data_fields = array_keys(cat_get_info('fields'));

  unset($data_raw['data']);
  foreach ($data_fields as $data_field) {
    if (isset($data_raw[$data_field])) {
      $data[$data_field] = $data_raw[$data_field];
    }
  }

  $cat_item->data = $data;

  $save_result = ctools_export_crud_save('cat_items', $cat_item);

  // FALSE means error while saving.
  if ($save_result) {
    cat_object_cache_clear($cat_item->machine_name);
    $cat_item->is_new = $save_result == SAVED_NEW;
    module_invoke_all('cat_save', $cat_item);
    cat_clear_cache();
  }

  return $save_result;
}

/**
 * Delete CAT item.
 *
 * @param string $machine_name
 *          CAT item machine name.
 * @return void
 */
function cat_delete($machine_name) {
  $cat_item = cat_load_by_name($machine_name);
  module_invoke_all('cat_delete', $cat_item);
  ctools_export_crud_delete('cat_items', $cat_item);

  cat_object_cache_clear($machine_name);
  cat_clear_cache();
}

/**
 * Get path CAT item data from cache.
 *
 * @param string $machine_name
 *          Machine name of CAT item that should be loaded.
 * @param bool $skip_cache
 *          Skip current cache or not.
 *
 * @return object Return cached object.
 */
function cat_object_cache_get($machine_name, $skip_cache = FALSE) {
  ctools_include('object-cache');
  return ctools_object_cache_get('cat_items', $machine_name, $skip_cache);
}

/**
 * Cache CAT item data.
 *
 * @param string $machine_name
 *          Machine name of CAT item.
 * @param array $data
 *          Data to store.
 *
 * @return void
 */
function cat_object_cache_set($machine_name, $data) {
  ctools_include('object-cache');
  $data = (object) $data;
  ctools_object_cache_set('cat_items', $machine_name, $data);
}

/**
 * Clear ctools object cache.
 *
 * @param string $machine_name
 *          Machine name of CAT item.
 *
 * @return void
 */
function cat_object_cache_clear($machine_name) {
  ctools_include('object-cache');
  ctools_object_cache_clear('cat_items', $machine_name);
}

/**
 * Create sql pattern from url.
 * Replaces all path arguments except the 1st one with %-symbol.
 *
 * @param string $path
 * @return string pattern
 */
function cat_path_pattern($path) {
  static $paths = array();
  if (empty($paths[$path])) {
    // Example: 'node/%node/view' -> 'node/%/%.
    $paths[$path] = preg_replace('
      /\/     # start with slash
      [^\/]+  # all symbols except for the slash
      /x', '/%', $path);
  }
  return $paths[$path];
}

/**
 * Return sub-paths for a Drupal path.
 *
 * @param string $drupal_path
 * @param bool $all_subpath
 * @param bool $with_argument_type if FALSE node/%node for example will be returned as node/% only.
 *
 * @return array
 */
function cat_get_subpaths($drupal_path, $all_subpath = FALSE, $with_argument_type = TRUE) {
  // Use the advanced drupal_static() pattern.
  static $drupal_static_fast;
  if (!isset($drupal_static_fast)) {
    $drupal_static_fast['paths'] = &drupal_static(__FUNCTION__, array());
  }

  $paths = &$drupal_static_fast['paths'];

  $real_path = cat_path_router($drupal_path);

  if (!isset($paths[$real_path])) {
    $paths[$real_path] = array();

    // Select drupal paths
    $result = db_select('menu_router', 'mr')
      ->fields('mr', array('path', 'load_functions'))
      ->condition('mr.path', db_like($real_path . '/') . '%', 'LIKE')
      ->execute();

    $path_parts = count(explode('/', $real_path)) + 1; // $real_path and '/subpath'

    // collect drupal paths
    foreach ($result as $path) {
      if (!empty($path->load_functions) && $with_argument_type) {
        $load_functions = unserialize($path->load_functions);
        $load_path = explode('/', $path->path);
        foreach ($load_functions as $arg => $load_function) {
          if (is_array($load_function)) {
            $load_function = array_keys($load_functions[$arg]);
            $load_function = array_shift($load_function);
            if ($load_function === 'pm_arg_load') {
              // try replace path keywords.
              if ($load_path[0] === 'node' && $arg == 1) {
                $load_function = 'node_load';
              }
            }
          }
          if (is_string($load_function)) {
            $load_path[$arg] = '%' . substr($load_function, 0, -5); // remove '_load'
          }
        }
        $path->path = implode('/', $load_path);
      }

      if ($all_subpath) {
        $paths[$real_path][] = $path->path;
      }
      else {
        $path->path = implode('/', array_slice(explode('/', $path->path), 0, $path_parts));
        if (!in_array($path->path, $paths[$real_path])) {
          $paths[$real_path][] = $path->path;
        }
      }
    }
  }

  return $paths[$real_path];
}

/**
 * Clear CAT caches and static variables.
 */
function cat_clear_cache() {
  if (db_table_exists('cache_cat_items')) {
    cache_clear_all('*', 'cache_cat_items', TRUE);
  }

  drupal_static_reset('cat_load_by_path');
  drupal_static_reset('cat_load_all');
}

/**
 * Load ctools contexts from path arguments.
 *
 * @param array $arguments
 *          URL arguments.
 * @param bool $empty
 *          Define load context for empty arguments or not
 * @return array CTools context array.
 */
function cat_get_contexts_from_arguments($arguments, $empty = FALSE) {
  $contexts = array();

  ctools_include('context');

  if (!empty($arguments)) {
    foreach ($arguments as $keyword => $arg) {
      if (!empty($arg['argument']) && !empty($arg['argument_type'])) {
        $argument = ctools_get_argument($arg['argument']);

        if (isset($arg['settings'])) {
          $argument = array_merge($argument, $arg['settings']);
        }

        $arg_by_position = NULL;
        if (!empty($arg['argument_type'])) {
          if ($arg['argument_type'] === 'path') {
            if (is_numeric($arg['position'])) {
              $arg_by_position = arg($arg['position']);
            }
          }
          elseif ($arg['argument_type'] === 'query') {
            if (isset($_GET[$arg['position']])) {
              $arg_by_position = $_GET[$arg['position']];
            }
          }
        }
        else {
          $arg_by_position = arg($arg['position']);
        }

        $argument['argument'] = $empty ? NULL : $arg_by_position;
        $context = call_user_func($argument['context'], $argument['argument'], $argument, $empty);

        if (!$context) {
          $contexts['broken_context'] = $arg;
          break;
        }

        $context->argument_name = !empty($arg['argument_name']) ? $arg['argument_name'] : '';
        $context->identifier = $argument['identifier'];

        if (empty($context->keyword)) {
          if (variable_get('cat_item_with_keywords', FALSE)) {
            $context->keyword = $keyword;
          }
          else {
            $context->keyword = $context->argument_name;
          }
        }

        $contexts[$context->argument_name ? $context->argument_name : $keyword] = $context;
      }
    }
  }

  return $contexts;
}

/**
 * Return Drupal router path, this function convert 'node/%node/edit' in
 * 'node/%/edit'.
 *
 * @param string $path
 *
 * @return string
 */
function cat_path_router($path) {
  // Use the advanced drupal_static() pattern.
  static $drupal_static_fast;
  if (!isset($drupal_static_fast)) {
    $drupal_static_fast['paths'] = &drupal_static(__FUNCTION__, array());
  }

  $paths = &$drupal_static_fast['paths'];

  if (!isset($paths[$path])) {
    $router_path = str_replace('%25', '%', $path); // decode '%' character
    $router_path = trim($router_path, '/');

    while (strpos($router_path, '//')) {
      $router_path = str_replace('//', '/', $router_path);
    }

    if (strpos($router_path, '%')) {
      $tmp_path = explode('/', $router_path);
      foreach ($tmp_path as &$sub_path) {
        if (substr($sub_path, 0, 1) === '%') {
          $sub_path = '%';
        }
      }
      $router_path = implode('/', $tmp_path);
    }

    $paths[$path] = $router_path;
  }

  return $paths[$path];
}

/**
 * Returns metadata describing supported CAT properties.
 *
 * The metadata array contains CAT field, name, and description data.
 *
 * For example:
 * @code
 * $data['fields']['titles'] = array(
 *   'name' => t('Titles'),
 *   'description' => t('CAT titles for tabs and local actions.'),
 *   'module' => 'cat',
 * );
 * $data['fields']['paths'] = array(
 *   'name' => t('Paths'),
 *   'description' => t('Tab/Action paths of CAT item.'),
 *   'module' => 'cat',
 * );
 * @endcode
 *
 * @see cat_cat_info()
 *
 * @return An associative array of token information, grouped by token type.
 */
function cat_info() {
  // Use the advanced drupal_static() pattern.
  static $drupal_static_fast;
  if (!isset($drupal_static_fast)) {
    $drupal_static_fast['data'] = &drupal_static(__FUNCTION__);
  }

  $data = &$drupal_static_fast['data'];

  if (!isset($data)) {
    $data = module_invoke_all('cat_info');
    drupal_alter('cat_info', $data);
  }

  return $data;
}

/**
 * Retrieve, sort, store CAT info from the cache.
 *
 * @param string $property_type
 *          The optional CAT property type that if specified will return
 *          $info[$property_type].
 * @param string $property
 *          The optional CAT property name if specified will return
 *          $info[$property_type][$property].
 *
 * @return An array of all CAT information from hook_cat_info(), or the array
 *         of a CAT propertis or specific CAT property.
 *
 * @see hook_cat_info()
 * @see hook_cat_info_alter()
 */
function cat_get_info($property_type = NULL, $property = NULL) {
  // Use the advanced drupal_static() pattern, since this is called very often.
  static $drupal_static_fast;
  if (!isset($drupal_static_fast)) {
    $drupal_static_fast['cat_info'] = &drupal_static(__FUNCTION__);
  }

  $cat_info = &$drupal_static_fast['cat_info'];

  if (!isset($cat_info)) {
    $cid = 'cat_info:' . $GLOBALS['language']->language;

    $cache = cache_get($cid);
    if ($cache && isset($cache->data)) {
      $cat_info = $cache->data;
    }
    else {
      $cat_info = cat_info();

      if (!isset($cat_info['fields'])) {
        $cat_info['fields'] = array();
      }
      else {
        // Pre-sort CAT properties.
        uasort($cat_info['fields'], 'cat_asort_cat_properties');
      }

      // Store info in cache for future use.
      cache_set($cid, $cat_info);
    }
  }

  if (isset($property_type)) {
    if (isset($property)) {
      return isset($cat_info[$property_type][$property]) ? $cat_info[$property_type][$property] : NULL;
    }
    return isset($cat_info[$property_type]) ? $cat_info[$property_type] : NULL;
  }

  return $cat_info;
}

/**
 * uasort() callback to sort CAT properties by the 'name' of a property.
 */
function cat_asort_cat_properties($cat_property_a, $cat_property_b) {
  return strnatcmp($cat_property_a['name'], $cat_property_b['name']);
}

/**
 * Provide default CAT fields.
 *
 * @return array CAT info.
 */
function cat_cat_info() {
  $cat_info['fields']['api_version'] = array(
    'name' => t('API version'),
    'description' => t('API version of the CAT module.'),
    'module' => 'cat',
  );

  $cat_info['fields']['machine_name'] = array(
    'name' => t('Machine name'),
    'description' => t('Machine name of CAT item.'),
    'module' => 'cat',
  );

  $cat_info['fields']['machine_name'] = array(
    'name' => t('Machine name'),
    'description' => t('Machine name of CAT item.'),
    'module' => 'cat',
  );

  $cat_info['fields']['category'] = array(
    'name' => t('Category'),
    'description' => t('The category that this cat-item will be grouped into on the CAT list form.'),
    'module' => 'cat',
  );

  $cat_info['fields']['name'] = array(
    'name' => t('CAT item name'),
    'description' => t('Human-readable name of CAT item.'),
    'module' => 'cat',
  );

  $cat_info['fields']['path'] = array(
    'name' => t('CAT item path'),
    'description' => t('Drupal path for CAT item.'),
    'module' => 'cat',
  );

  $cat_info['fields']['path_pattern'] = array(
    'name' => t('Path pattern'),
    'description' => t('CAT Path pattern.'),
    'module' => 'cat',
  );

  $cat_info['fields']['path_router'] = array(
    'name' => t('Path router'),
    'description' => t('Drupal path router.'),
    'module' => 'cat',
  );

  $cat_info['fields']['path_original'] = array(
    'name' => t('Path original'),
    'description' => t('User enteried Drupal path.'),
    'module' => 'cat',
  );

  $cat_info['fields']['path_query'] = array(
    'name' => t('Path query'),
    'description' => t('The query part of the Drupal path.'),
    'module' => 'cat',
  );

  $cat_info['fields']['path_destination'] = array(
    'name' => t('Path destination'),
    'description' => t('The destination part of the Drupal path.'),
    'module' => 'cat',
  );

  $cat_info['fields']['cat_remove'] = array(
    'name' => t('Tabs/Action'),
    'description' => t('Drupal local tabs which will hide.'),
    'module' => 'cat',
  );

  $cat_info['fields']['cat_tabs'] = array(
    'name' => t('Drupal Tabs'),
    'description' => t('Drupal local tabs.'),
    'module' => 'cat',
  );

  $cat_info['fields']['cat_actions'] = array(
    'name' => t('Drupal Actions'),
    'description' => t('Drupal local actions.'),
    'module' => 'cat',
  );

  $cat_info['fields']['active_trail_path'] = array(
    'name' => t('Active trail path'),
    'description' => t('The path for determining the active trail.'),
    'module' => 'cat',
  );

  $cat_info['fields']['translatable'] = array(
    'name' => t('Translatable'),
    'description' => t('CAT item can be available for translation.'),
    'module' => 'cat',
  );

  $cat_info['fields']['reusable'] = array(
    'name' => t('Reusable'),
    'description' => t('Provide the reusing of local tabs and actions in others CAT items.'),
    'module' => 'cat',
  );

  $cat_info['fields']['arguments'] = array(
    'name' => t('Arguments'),
    'description' => t('CTools context arguments.'),
    'module' => 'ctools',
  );

  $cat_info['fields']['arguments'] = array(
    'name' => t('Arguments'),
    'description' => t('CTools context arguments.'),
    'module' => 'ctools',
  );

  $cat_info['fields']['access'] = array(
    'name' => t('Access'),
    'description' => t('CTools access arguments.'),
    'module' => 'ctools',
  );

  $cat_info['fields']['custom'] = array(
    'name' => t('Custom data'),
    'description' => t('Custom data of CAT item.'),
    'module' => 'cat',
  );

  return $cat_info;
}

/**
 * Return TRUE if token replacers exists.
 * This function is simple and fast implamentation for token_scan().
 *
 * @param string $text
 *          The text to be scanned for possible tokens.
 *
 * @return bool
 */
function cat_token_exists($text) {
  static $texts = array();

  if (!isset($texts[$text])) {
    $texts[$text] = FALSE;

    if ($text) {
      // We need check existence "[" and "]" chars before call
      // cat_token_replace(), this simple check provide high performance for
      // string functions.
      if (($p = strpos($text, '[')) !== FALSE) {
        if (($p = strpos($text, ']', $p)) !== FALSE) {
          $texts[$text] = TRUE;
        }
      }
    }
  }

  return $texts[$text];
}

/**
 * Replaces all tokens in a given path with appropriate values.
 *
 * @param strint $str
 *   A string potentially containing replaceable tokens.
 * @param array $context
 *
 * @return string
 *   Text with tokens replaced.
 */
function _cat_token_replace($str, array &$context = array()) {
  // Use the advanced drupal_static() pattern, since this is called very often.
  static $drupal_static_fast;
  if (!isset($drupal_static_fast)) {
    $drupal_static_fast['tokens'] = &drupal_static(__FUNCTION__, array(
      'token_types' => array(),
      'strings' => array(),
    ));
  }
  $token_types = &$drupal_static_fast['tokens']['token_types'];
  $strings = &$drupal_static_fast['tokens']['strings'];

  if (!$token_types) {
    $token_types = token_info();
    $token_types = $token_types['tokens'];
  }

  // High performance checking for existining tokens in path.
  if (!cat_token_exists($str)) {
    return $str;
  }

  // Return value from fast static cache
  if (isset($strings[$str])) {
    return $strings[$str];
  }

  // Iterate through the matches, building an associative array containing
  // $tokens grouped by $types, pointing to the version of the token found in
  // the source text. For example, $results['node']['title'] = '[node:title]';
  if (!($results = token_scan($str))) {
    $strings[$str] = $str;
    return $str;
  }

  $replacements = array();
  foreach ($results as $type => $tokens) {
    // Use standard token replacer like '[node:title]'
    if (!empty($token_types[$type])) {
      foreach ($context as $keyword => $data) {
        if ($keyword == $type
          || (!empty($data->keyword) && $data->keyword == $type)
          || (!empty($data->argument_name) && $data->argument_name == $type)) {
          $data = array($type => $data->data);
          $replacements += token_generate($type, $tokens, $data);
        }
      }
    }
    // Try find original token replacer for example '[cat_node:title]'
    // and replace it on '[node:title]'
    elseif (!empty($context[$type]->keyword)) {
      $_type = $context[$type]->keyword;
      $data = array($_type => $context[$type]->data);
      foreach ($tokens as &$token) {
        $token = str_replace("[{$type}", "[{$_type}", $token);
      }
      foreach (token_generate($_type, $tokens, $data) as $token => $value) {
        $token = str_replace("[{$_type}", "[{$type}", $token);
        $replacements += array($token => $value);
      }
    }
  }

  // Save fast static cache
  $strings[$str] = strtr($str, $replacements);

  return $strings[$str];
}

/**
 * This is version of drupal_sort_weight() for objects.
 * Function used by uasort to sort array of objects by weight.
 *
 * @param object $a
 * @param object $b
 *
 * @return int
 */
function _cat_sort_weight($a, $b) {
  $a_weight = isset($a->weight) ? $a->weight : 0;
  $b_weight = isset($b->weight) ? $b->weight : 0;

  if ($a_weight == $b_weight) {
    return 0;
  }
  else {
    return ($a_weight < $b_weight) ? -1 : 1;
  }
}

/**
 * Load enabled CAT items by path.
 *
 * @param string $path
 *          Drupal router path.
 *
 * @return array Array of CAT items sorted by weight.
 */
function _cat_load_by_path($path) {
  $cat_items = array();

  foreach (cat_load_all() as $cat_item) {
    if (!$cat_item->disabled && _cat_cat_item_match_path($cat_item, $path)) {
      $cat_items[] = $cat_item;
    }
  }

  return $cat_items;
}

/**
 * Parses the query string into variables.
 *
 * @param string $str
 *
 * @return array
 */
function cat_parse_url_query($str) {
  $arr = array();

  if ($str) {
    parse_str($str, $arr);
  }

  return $arr;
}

/**
 * Sets the path for determining the active trail.
 */
function cat_set_active_trail($path = NULL) {
  static $paths = array();

  if (isset($path)) {
    $paths[$path] = $path;
  }

  return $paths;
}

/**
 * Gets the path for determining the active trail.
 */
function cat_get_active_trail() {
  return cat_set_active_trail();
}

/**
 * Checks whether the given path is a subpath of the path or not
 */
function _cat_is_subpath($path, $subpath) {
  $subpaths = cat_get_subpaths($path, TRUE, FALSE);
  return in_array($subpath, $subpaths);
}

/**
 * matches a path. Either exactly, or, if the cat item is supposed to include sub paths, as the parent path.
 */
function _cat_cat_item_match_path($cat_item, $root_path) {
  $catch_subpaths = !empty($cat_item->catch_subpaths) ? $cat_item->catch_subpaths : false;
  return ($root_path == $cat_item->path_router || ($catch_subpaths && _cat_is_subpath($cat_item->path_router, $root_path)));
}

