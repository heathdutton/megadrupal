<?php

/**
 * @file
 * InstaLogin module file.
 */

/**
 * Implements hook_menu().
 */
function instalogin_menu() {
  $items = array();

  $items['admin/config/services/instalogin'] = array(
    'title' => 'InstaLogin',
    'description' => 'Configure InstaLogin settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('instalogin_admin_settings_form'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'instalogin.pages.inc',
  );

  $items['instalogin/service'] = array(
    'title' => 'InstaLogin',
    'page callback' => 'instalogin_service_page',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
    'file' => 'instalogin.pages.inc',
  );

  return $items;
}

/**
 * Generates a secret key to be used for InstaLogin authentication.
 */
function instalogin_generate_secret_key() {
  // Generate random bytes to be used as the key.
  // AES128 key is 16 bytes. We need 2 - one for encryption and one for hmac.
  $key = mcrypt_create_iv(32, MCRYPT_RAND);
  variable_set('instalogin_secret_key', base64_encode($key));
}

/**
 * Encrypts data using the site's secret key.
 * Returns base64 encoded data in the following format:
 *   Bytes 0-31  : HMAC-SHA256 calculated over the IV+encrypted plaintext.
 *   Bytes 32-47 : IV.
 *   Bytes 48-   : AES128 encrypted plaintext.
 *
 * @param $data
 *   Data as string to encrypt.
 *
 * @return
 *   Base64 encoded encrypted data; or FALSE on error.
 */
function instalogin_encrypt_data($data) {

  $key = base64_decode(variable_get('instalogin_secret_key', ''));

  // First half of the key is the encryption key, second half is the hmac key.
  $key_size = 16;
  $encryption_key = substr($key, 0, $key_size);
  $hmac_key = substr($key, $key_size, $key_size);
  if (!$encryption_key || !$hmac_key) {
    return FALSE;
  }

  // Add padding to the input data.
  $block_size = 16;
  $padding = $block_size - (strlen($data) % $block_size);
  $data .= str_repeat(chr($padding), $padding);

  // Create random iv and prepend it to the cipher.
  $iv = mcrypt_create_iv(16, MCRYPT_RAND);

  $cipher = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $encryption_key, $data, MCRYPT_MODE_CBC, $iv);
  if (!$cipher) {
    return FALSE;
  }

  $cipher = $iv . $cipher;

  $hmac = hash_hmac('sha256', $cipher, $hmac_key, TRUE);

  return base64_encode($hmac . $cipher);
}

/**
 * Decrypts data using the site's secret key.
 *
 * @param $data
 *   Base64 encoded data to decrypt (as returned by instalogin_encrypt_data()).
 *
 * @return
 *   Decrypted data; or FALSE if HMAC check fails and on error.
 */
function instalogin_decrypt_data($data) {
  $data = base64_decode($data);
  if (!$data) {
    return FALSE;
  }

  $key = base64_decode(variable_get('instalogin_secret_key', ''));

  $key_size = 16;
  $encryption_key = substr($key, 0, $key_size);
  $hmac_key = substr($key, $key_size, $key_size);
  if (!$encryption_key || !$hmac_key) {
    return FALSE;
  }

  // First 32 bytes are the hmac; next 16 bytes are the iv.
  $hmac = substr($data, 0, 32);
  $iv = substr($data, 32, 16);
  $data = substr($data, 48);

  $calculated_hmac = hash_hmac('sha256', $iv . $data, $hmac_key, TRUE);

  if (strcmp($hmac, $calculated_hmac) !== 0) {
    return FALSE;
  }

  $plaintext = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $encryption_key, $data, MCRYPT_MODE_CBC, $iv);

  // Remove padding.
  if ($plaintext) {
    $padding = ord($plaintext[strlen($plaintext) - 1]);
    $plaintext = substr($plaintext, 0, -$padding);
  }

  return $plaintext;
}
