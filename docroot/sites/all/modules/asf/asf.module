<?php

/**
 * @file
 * Advanced sheduler field module.
 */

define('ASF_STATUS_PENDING', 'PEN');
define('ASF_STATUS_EXECUTED', 'EXE');
define('ASF_STATUS_DELETED', 'DEL');
define('ASF_ACTION_PUBLISH', 'publish');
define('ASF_ACTION_UNPUBLISH', 'unpublish');

define('ASF_TYPE_START', 'start_date');
define('ASF_TYPE_START_END', 'start_to_end_date');
define('ASF_TYPE_ITERATE', 'iterate');
define('ASF_TYPE_INHERIT', 'inherit');

define('ASF_ITERATION_ENDDATE', 0);
define('ASF_ITERATION_MAX', 1);
define('ASF_ITERATION_FIRST', 2);
define('ASF_ITERATION_INFINITE', 3);
define('ASF_ITERATION_INHERIT', 4);

include 'asf.schema.inc';
$_asf_disable_scheme_regeneration = FALSE;

/**
 * Implements hook_permission().
 */
function asf_permission() {
  return array(
    'administer asf' => array(
      'title' => t('Administer advanced sheduling'),
      'description' => t('See the publication schema'),
    ),
  );
}


/**
 *  Implements hook_cron().
 *
 *  This is where the asf magic happens.
 *  For optimal usage this cron hook should be activated every 2minutes or so.
 *  the more you run this hook, the more fine grained publishing you have.
 *  use a module like elisya cron to have more control over your cron runnings.
 */
function asf_cron() {
  _asf_publish_unpublish();
  _asf_recalculate_infinite();
}

/**
 * Recalculate the infinite publisheable nodes.
 */
function _asf_recalculate_infinite() {
  global $_asf_disable_scheme_regeneration;
  if ($_asf_disable_scheme_regeneration) {
    return;
  }
  // Find all nodes that have a asf_field.
  $fields = _field_info_collate_fields(FALSE);
  foreach ($fields['fields'] as $field) {
    if ($field['type'] == 'asf') {
      $field_name = $field['field_name'];
      $table_data = $field['storage']['details']['sql']['FIELD_LOAD_CURRENT'];
      $eids = array();
      foreach ($table_data as $table => $columns) {
        $result = db_select($table, 'f')
          ->fields('f', array('entity_id', 'entity_type'))
          ->condition($columns['iteration_end'], ASF_ITERATION_INFINITE, '=')
          ->execute()
          ->fetchAll();
        $eids = array_merge($result, $eids);
      }
    }
  }
  global $_asf_disable_scheme_regeneration;
  $_asf_disable_scheme_regeneration = FALSE;
  foreach ($eids as $entity) {
    $node = node_load($entity->entity_id);
    asf_delete_node_future_schedule($node->nid);
    _asf_generate($node, 'node');
  }
}

/**
 * The function that does the publishing and unpublishing on the requested time.
 */
function _asf_publish_unpublish() {
  global $_asf_disable_scheme_regeneration;
  $actions = asf_select_actions(array(
    'time' => array(
      'value' => REQUEST_TIME,
      'operator' => '<'),
    'status' => ASF_STATUS_PENDING));
  $nids = array();
  $todos = array();
  foreach ($actions as $action) {
    $todos[$action->nid] = array('nid' => $action->nid, 'action' => $action->action);
    $nids[$action->nid] = $action->nid;
    _asf_dismiss_action($action);
  }
  if (!empty($todos)) {
    watchdog('advanced scheduling field', 'actions that took place: %actions', array('%actions' => print_r($todos, TRUE)));
  }

  $_asf_disable_scheme_regeneration = TRUE;
  foreach ($nids as $nid) {
    $node = node_load($nid);
    switch ($todos[$node->nid]['action']) {
      case ASF_ACTION_PUBLISH:
        if ($node->status != NODE_PUBLISHED) {
          $node->status = NODE_PUBLISHED;
          node_save($node);
          watchdog('advanced scheduling field', '%actions published', array('%actions' => print_r($nid, TRUE)));
        }
        break;

      case ASF_ACTION_UNPUBLISH:
        if ($node->status != 0) {
          $node->status = 0;
          node_save($node);
          watchdog('advanced scheduling field', '%actions unpublished', array('%actions' => print_r($nid, TRUE)));
        }
        break;
    }
    module_invoke_all('asf_action', $node, $todos[$node->nid]['action']);
  }
  $_asf_disable_scheme_regeneration = FALSE;
}

/**
 * Implements hook_cronapi().
 */
function asf_cronapi($op, $job = NULL) {
  $items = array();

  $items['asf_cleanup_cron'] = array(
    'description' => 'Cleanup db',
    'rule' => '1 1 * * *',
    'callback' => '_asf_delete_old',
  );

  $items['asf_publish_cron'] = array(
    'description' => 'Do the publication actions.',
    'rule' => '* * * * *',
    'callback' => '_asf_publish_unpublish',
    'arguments' => array(),
  );

  $items['asf_recalculate_infinite_cron'] = array(
    'description' => 'Recalculate the infinite published nodes.',
    'rule' => '1 1 1 * *',
    // Every month.
    'callback' => '_asf_recalculate_infinite',
    'arguments' => array(),
  );

  return $items;
}

/**
 * Implements hook_field_info().
 */
function asf_field_info() {
  return array(
    'asf' => array(
      'label' => t('Advanced scheduling field'),
      'description' => t('Advanced scheduling field'),
      'default_widget' => 'asf_asf_form',
      'default_formatter' => 'asf_default',
    ),
  );
}

/**
 * Implements hook_menu().
 */
function asf_menu() {
  $items['asf/entityreference/autocomplete/%/%'] = array(
    'title' => 'Entity Reference Autocomplete for elements',
    'page callback' => 'asf_entityreference_autocomplete_callback',
    'page arguments' => array(3, 4, 5),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implements hook_element_info().
 */
function asf_element_info() {
  $types['asf_entityreference'] = array(
    '#input' => TRUE,
    '#size' => 60,
    '#process' => array('asf_entityreference_process_element', 'ajax_process_form'),
    '#theme' => 'textfield',
    '#theme_wrappers' => array('form_element'),
    '#maxlength' => 1024,
    '#element_validate' => array('_entityreference_autocomplete_validate'),
    '#entityreference_type' => 'single',
    '#handler' => 'base',
    '#handler_settings' => array(
      'sort' => array('type' => 'none'),
    ),
    '#target_type' => 'node',
    '#match_operator' => 'CONTAINS',
  );
  return $types;
}

/**
 * Process callback for the asf entityreference element.
 */
function asf_entityreference_process_element($element, $form_state, $form) {
  $element['#autocomplete_path'] = 'asf/entityreference/autocomplete/' . $element['#target_type'] . '/' . implode('-', $element['#handler_settings']['target_bundles']);
  return $element;
}

/**
 * The entityreference autocomplete callback.
 */
function asf_entityreference_autocomplete_callback($target, $bundles, $search = '') {
  $element = asf_element_info();
  $element = $element['asf_entityreference'];
  $element['#target_type'] = $target;
  $element['#handler_settings']['target_bundles'] = explode('-', $bundles);

  $type = $element['#entityreference_type'];
  $field['settings']['handler'] = $element['#handler'];
  $field['settings']['target_type'] = $element['#target_type'];
  $field['settings']['handler_settings'] = $element['#handler_settings'];
  $instance['widget']['settings']['match_operator'] = $element['#match_operator'];
  $entity_type = $element['#target_type'];
  return entityreference_autocomplete_callback_get_matches($type, $field, $instance, $entity_type, 'NULL', $search);
}

/**
 * Implements of hook_field_formatter_info().
 */
function asf_field_formatter_info() {
  return array(
    'asf_default' => array(
      'label' => t('Publication scheme'),
      'field types' => array('asf'),
      'multiple values' => FIELD_BEHAVIOR_DEFAULT,
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function asf_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  switch ($display['type']) {
    case 'asf_default':
      if (user_access('administer asf')) {
        foreach ($items as $delta => $item) {
          switch ($item['publication_type']) {
            case ASF_TYPE_START:
              $schema = asf_formatter_display_schema($entity, $items);
              $element[$delta]['#markup'] = render($schema);
              break;

            case ASF_TYPE_START_END:
              $schema = asf_formatter_display_schema($entity, $items);
              $element[$delta]['#markup'] = render($schema);
              break;

            case ASF_TYPE_ITERATE:
              $element[$delta]['#markup'] = 'Publication_type: ' . asf_get_textual_representation($item['publication_type']);
              $element[$delta]['#markup'] .= render(asf_formatter_display_schema($entity, $items));
              break;

            case ASF_TYPE_INHERIT:
              $element[$delta]['#markup'] .= 'Publication_type: ' . asf_get_textual_representation($item['publication_type']);
              $element[$delta]['#markup'] .= '<br /> Source node : ' . $item['inherit_nid'];
              $element[$delta]['#markup'] .= render(asf_formatter_display_schema($entity, $items));
              break;
          }
        }
      }
  }
  return $element;
}

/**
 * Display formatter for the schema, so people can inspect it in the frontend.
 */
function asf_formatter_display_schema($entity, $items) {
  $actions = asf_select_actions(array(
    'nid' => $entity->nid,
    'time' => array(
      'value' => REQUEST_TIME,
      'operator' => '>',
    ),
  ));
  $format = variable_get('asf_default_format', 'Y-m-d H:i:s');
  $rows = array();
  foreach ($actions as $action) {
    $rows[] = array(
      'action' => array(
        'data' => asf_get_textual_representation($action->action),
      ),
      'time' => array(
        'data' => date($format, $action->time),
      ),
      'status' => array(
        'data' => asf_get_textual_representation($action->status),
      ),
      'created' => array(
        'data' => date($format, $action->created),
      ),
      'field' =>array(
        'data' =>  $action->nfid,
      ),
    );
  }
  if (!empty($rows)) {
    $header = array(
      'action' => t('Action'),
      'time' => t('Date'),
      'status' => t('Status'),
      'created' => t('Created'),
      'field' => t('Field'),
    );
    return array(
      '#theme' => 'table',
      '#header' => $header,
      '#rows' => $rows,
    );
  }
  else {
    return '';
  }

}

/**
 * Get textual representation of a publication schema.
 */
function asf_get_textual_representation($code) {
  $strings = array(
    ASF_STATUS_EXECUTED => t('Executed'),
    ASF_STATUS_PENDING => t('Pending'),
    ASF_STATUS_DELETED => t('Deleted'),

    ASF_ACTION_PUBLISH => t('Publish'),
    ASF_ACTION_UNPUBLISH => t('unpublish'),

    ASF_TYPE_START => t('From start date'),
    ASF_TYPE_START_END => t('From start to end date'),
    ASF_TYPE_ITERATE => t('every day from start time to end until end date.'),
    ASF_TYPE_INHERIT => t('Inherit from other node.'),

  );
  return $strings[$code];
}

/**
 * Implements hook_field_is_empty().
 */
function asf_field_is_empty($item, $field) {
  if ($field['type'] == 'asf') {
    if (empty($item['startdate'])) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Implements hook_field_widget_info().
 */
function asf_field_widget_info() {
  return array(
    'asf_asf_form' => array(
      'label' => t('Advanced scheduler form'),
      'field types' => array('asf'),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_DEFAULT,
        'default value' => FIELD_BEHAVIOR_NONE,
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_form().
 */
function asf_field_widget_form(&$form, &$form_state, $field, $instance,
                               $langcode, $items, $delta, $element) {

  if ($instance['widget']['type'] == 'asf_asf_form') {
    // Require nice date/time picking as this is important to the module.
    drupal_add_library('system', 'ui.datepicker');
    drupal_add_library('system', 'ui.slider');
    drupal_add_library('timepicker', 'jquery-ui-timepicker');

    $widget = $element;
    $settings = $instance['settings'];

    $widget += array(
      '#type' => 'fieldset',
      '#delta' => $delta,
    );
    $options = array(
      ASF_TYPE_START => 'publish from a DATE.',
      ASF_TYPE_START_END => 'publish on DATE, unpublish on end DATE',
      ASF_TYPE_ITERATE => 'publish from start TIME to end TIME, repeat multiple days',
      ASF_TYPE_INHERIT => 'inherit publication schema from other node.',
    );

    $widget['publication_type'] = array(
      '#type' => 'select',
      '#title' => t('How do you want this node to be published.'),
      '#default_value' => isset($items[$delta]['publication_type']) ? $items[$delta]['publication_type'] : 'start_date',
      '#options' => $options,
      '#attributes' => array('class' => array('iteration_toggler')),
    );

    if ((isset($items[$delta]['publication_type']) && $items[$delta]['publication_type'] =='start_date') || (isset($items[$delta]['publication_type']) && $items[$delta]['publication_type'] == 'start_to_end_date')) {
      $collapsed = FALSE;
    }
    else {
      $collapsed = TRUE;
    }

    $widget['startdate'] = array(
      '#type' => 'textfield',
      '#title' => t('Start date/time of the publishing.'),
      '#default_value' => isset($items[$delta]['startdate']) ? date('Y-m-d H:i', $items[$delta]['startdate']) : date('Y-m-d H:i', REQUEST_TIME),
      '#element_validate' => array('_asf_field_validate_ISO_date'),
      '#attributes' => array(
        'class' => array(
          'timepicker',
          ASF_TYPE_START,
          ASF_TYPE_START_END,
          ASF_TYPE_ITERATE,
        ),
      ),
    );
    $widget['enddate'] = array(
      '#type' => 'textfield',
      '#title' => t('End date/time of the publishing.'),
      '#default_value' => isset($items[$delta]['enddate']) ? date('Y-m-d H:i', $items[$delta]['enddate']) : '',
      '#attributes' => array(
        'class' => array(
          'timepicker',
          ASF_TYPE_START_END,
          ASF_TYPE_ITERATE,
        ),
      ),
    );

    $widget['iteration_end'] = array(
      '#type' => 'select',
      '#title' => t('Type of iteration'),
      '#default_value' => isset($items[$delta]['iteration_end']) ? $items[$delta]['iteration_end'] : 0,
      '#attributes' => array('class' => array('interation_end', ASF_TYPE_ITERATE)),
      '#options' => array(
        ASF_ITERATION_ENDDATE => t('Loop until end date'),
        ASF_ITERATION_MAX => t('Loop until amount of iterations reached'),
        ASF_ITERATION_FIRST => t('Loop until first of both reached'),
        ASF_ITERATION_INFINITE => t('Loop until the end of times'),
      ),
    );

    $widget['start_time'] = array(
      '#type' => 'textfield',
      '#title' => t('Publish at'),
      '#default_value' => isset($items[$delta]['start_time']) ? $items[$delta]['start_time'] : '',
      '#attributes' => array(
        'class' => array(
          'timepicker_time',
          ASF_TYPE_ITERATE,
        ),
      ),
      '#size' =>  6,
    );

    $widget['end_time'] = array(
      '#type' => 'textfield',
      '#title' => t('Unpublish at'),
      '#default_value' => isset($items[$delta]['end_time']) ? $items[$delta]['end_time'] : '',
      '#attributes' => array(
        'class' => array(
          'timepicker_time',
          ASF_TYPE_ITERATE,
        ),
      ),
      '#size' =>  6,
    );
    $widget['iteration_day'] = array(
      '#type' => 'textfield',
      '#title' => t('Calender days to iterate on.'),
      '#description' => t('Use the days of the mont you want to iterate on: e.g. every first of the month : 1. Every first and second of the month: 1,2. Use *for every day.'),
      '#default_value' => isset($items[$delta]['iteration_day']) ? $items[$delta]['iteration_day'] : '*',
      '#size' => 5,
      '#element_validate' => array('_asf_field_validate_iteration_integer_list'),
      '#attributes' => array(
        'class' => array(
          ASF_TYPE_ITERATE,
        ),
      ),
    );

    $widget['iteration_weekday'] = array(
      '#type' => 'textfield',
      '#title' => t('Week day'),
      '#description' => t('If you want every monday, type 1, if you want every wednesday and sunday, type 3,7. Use * for every day.'),
      '#default_value' => isset($items[$delta]['iteration_weekday']) ? $items[$delta]['iteration_weekday'] : '*',
      '#size' => 5,
      '#element_validate' => array('_asf_field_validate_iteration_integer_list'),
      '#attributes' => array(
        'class' => array(
          ASF_TYPE_ITERATE,
        ),
      ),
    );

    $widget['iteration_week'] = array(
      '#type' => 'textfield',
      '#title' => t('Week of the year'),
      '#description'=> t('use the number of the week of the year: 1 only week 1. * every week.'),
      '#default_value' => isset($items[$delta]['iteration_week']) ? $items[$delta]['iteration_week'] : '*',
      '#size' => 5,
      '#element_validate' => array('_asf_field_validate_iteration_integer_list'),
      '#attributes' => array(
        'class' => array(
          ASF_TYPE_ITERATE,
        ),
      ),
    );

    $widget['iteration_month'] = array(
      '#type' => 'textfield',
      '#title' => t('Month of the year'),
      '#description'=> t('use the number of the month of the year: 1 only January 1. * every month.'),
      '#default_value' => isset($items[$delta]['iteration_month']) ? $items[$delta]['iteration_month'] : '*',
      '#size' => 5,
      '#element_validate' => array('_asf_field_validate_iteration_integer_list'),
      '#attributes' => array(
        'class' => array(
          ASF_TYPE_ITERATE,
        ),
      ),
    );

    $widget['iteration_year'] = array(
      '#type' => 'textfield',
      '#title' => t('Year'),
      '#description'=> t('only iterate in year: 2012,2013 only in those years. "*" every year.'),
      '#default_value' => isset($items[$delta]['iteration_year']) ? $items[$delta]['iteration_year'] : '*',
      '#size' => 5,
      '#element_validate' => array('_asf_field_validate_iteration_integer_list'),
      '#attributes' => array(
        'class' => array(
          ASF_TYPE_ITERATE,
        ),
      ),
    );

    $widget['iteration_max'] = array(
      '#type' => 'textfield',
      '#title' => t('Max iterations'),
      '#description' => t('Max amount of iterations'),
      '#default_value' => isset($items[$delta]['iteration_max']) ? $items[$delta]['iteration_max'] : NULL,
      '#size' => 5,
      '#attributes' => array(
        'class' => array(
          ASF_TYPE_ITERATE,
        ),
      ),
    );

    if (!empty($instance['widget']['settings']['path'])) {
      $autocomplete_path = $instance['widget']['settings']['path'];
    }
    else {
      $autocomplete_path = $instance['widget']['type'] == 'entityreference_autocomplete' ? 'entityreference/autocomplete/single' : 'entityreference/autocomplete/tags';
    }

    $default = NULL;
    if (!empty($items[$delta]['inherit_nid'])) {
      $node = node_load($items[$delta]['inherit_nid']);
      $default = "{$node->title} ({$node->nid})";
    }
    $widget['inherit_nid'] = array(
      '#title' => t('Inherit from other node'),
      '#default_value' => $default,
      '#type' => 'asf_entityreference',
      // TODO make this a setting in the field settings interface.
      // These are the contenttypes you want to show up in your selector.
      '#handler_settings' => array(
        'target_bundles' => array(
          'action' => 'action',
          'autopromo' => 'autopromo',
          'news' => 'news',
        ),
      ),
      '#attributes' => array('class' => array(ASF_TYPE_INHERIT)),
    );
  }
  return $widget;
}


/**
 * Make unix datetimes from the date fields for easier db handling.
 */
function asf_field_presave($entity_type, $entity, $field, $instance, $langcode, &$items) {
  global $_asf_disable_scheme_regeneration;
  if ($_asf_disable_scheme_regeneration||isset($entity->asf_disable_scheme_regeneration)) {
    return;
  }

  foreach ($items as &$item) {
    if(!is_numeric($item['startdate'])) {
      $item['startdate'] = strtotime($item['startdate']);
    }

    $item['enddate'] = !empty($item['enddate']) ? strtotime($item['enddate']) : '';
    if ($item['inherit_nid'] == '') {
      $item['inherit_nid'] = NULL;
    }
    if ($item['iteration_max'] == '') {
      $item['iteration_max'] = NULL;
    }
    if ($item['enddate'] == '') {
      $item['enddate'] = NULL;
    }
  }
}

/**
 * Validate an iso date.
 */
function _asf_field_validate_ISO_date($element, &$form_state, $form) {
  $value = $element['#value'];
  if (!preg_match("/([0-9]{4})-([0-9]{1,2})-([0-9]{1,2}\s[0-9]{1,2}\:[0-9]{1,2})/", $value)) {
    form_error($element, t('Invalid date/time value.'));
  }
}

/**
 * Validate a unix timestamp.
 */
function _asf_field_validate_unixdate($element, &$form_state, $form) {
  $value = $element['#value'];
  if (!is_numeric($value) && $value < REQUEST_TIME) {
    form_error($element, t('Invalid date/time value.'));
  }
}

/**
 * Validate a positive integer.
 */
function _asf_field_validate_iteration_integer_positive($element, &$form_state, $form) {
  $value = $element['#value'];
  if (!is_numeric($value) && $value != 0) {
    form_error($element, t('Invalid value.'));
  }
}

/**
 * Validate an comma separated integer list.
 */
function _asf_field_validate_iteration_integer_list($element, &$form_state, $form) {
  $value = $element['#value'];
  $list = explode(',', check_plain($value));
  foreach ($list as $item) {
    if (!is_numeric($item) && $item != 0) {
      form_error($element, t('Invalid value.'));
    }
  }
}

/**
 * Implements hook_node_insert().
 */
function asf_entity_insert($entity, $entity_type) {
  _asf_generate($entity, $entity_type);
}

/**
 * Implements_node_update().
 */
function asf_entity_update($entity, $entity_type) {
  _asf_generate($entity, $entity_type);
}

/**
 * Calculate scheme from node.
 */
function _asf_generate($entity, $entity_type) {
  global $_asf_disable_scheme_regeneration;
  if ($_asf_disable_scheme_regeneration || isset($entity->asf_disable_scheme_regeneration)) {
    return;
  }
  $asf_field = FALSE;
  $fields = _field_info_collate_fields(FALSE);
  foreach ($fields['fields'] as $field) {
    if ($field['type'] == 'asf') {
      $asf_field = TRUE;
      $field_name = $field['field_name'];
      if (isset($entity->$field_name)) {
        $items = field_get_items($entity_type, $entity, $field_name);
        asf_field_generate($entity_type, $entity, $items, $field_name);
      }
    }
  }
  if ($asf_field && isset($entity->nid)) {
    $inheriters = _asf_find_inheriters($entity_type, $entity->nid);
    foreach ($inheriters as $inheriter) {
      asf_delete_node_future_schedule($inheriter->nid);
      _asf_inherit_publication_schema($entity->nid, $inheriter->nid);
    }
  }
}

/**
 * Find inheriting nodes.
 */
function _asf_find_inheriters($entity_type, $entity_id) {
  $key = 'dependency:' . $entity_type . ':' . $entity_id;
  return asf_select_actions(array(
    'nfid' => $key,
  ));
}

/**
 * Implements hook_entity_presave().
 */
function asf_entity_presave($entity, $entity_type) {
  global $_asf_disable_scheme_regeneration;
  if ($_asf_disable_scheme_regeneration|| isset($entity->asf_disable_scheme_regeneration)) {
    return;
  }
  if ($entity_type == 'node' && isset($entity->nid)) {
    $fields = _field_info_collate_fields(FALSE);
    foreach ($fields['fields'] as $field) {
      if ($field['type'] == 'asf') {
        $field_name = $field['field_name'];
        if (isset($entity->$field_name)) {
          asf_delete_node_future_schedule($entity->nid);
        }
      }
    }
  }
}

/**
 * Generate a schema for one field.
 */
function asf_field_generate($entity_type, $entity, &$items, $field_name) {
  $result = asf_create_future_schedule($entity, $items, $field_name);
}

/**
 * Delete pending actions of this node so the newer version can override it.
 */
function asf_delete_node_future_schedule($nid) {
  // Select and delete future actions.
  $options = array(
    'nid' => $nid,
    'status' => ASF_STATUS_PENDING,
  );
  $existing_actions = asf_select_actions($options);
  foreach ($existing_actions as $action) {
    asf_delete_action($action->aid);
  }
}

/**
 * Create future schedule.
 */
function asf_create_future_schedule($node, $schedules, $field_name) {
  foreach ($schedules as $key => $mod_set) {
    $field_id = $field_name . ':' . $key;
    switch ($mod_set['publication_type']) {
      case ASF_TYPE_START:
        $start_time = $mod_set['startdate'];
        _asf_create_action($node->nid, $start_time, ASF_ACTION_PUBLISH, $field_id);
        break;

      case ASF_TYPE_START_END:
        $start_time = $mod_set['startdate'];
        _asf_create_action($node->nid, $start_time, ASF_ACTION_PUBLISH, $field_id);
        $end_time = $mod_set['enddate'];
        _asf_create_action($node->nid, $end_time, ASF_ACTION_UNPUBLISH, $field_id);
        break;

      case ASF_TYPE_ITERATE:
        _asf_expand_modalities($mod_set);
        $scheme = _asf_translate_mods_scheme($mod_set);
        foreach ($scheme as $action => $item) {
          _asf_create_action($node->nid, $item['time'], $item['action'], $field_id);
        }
        break;

      case ASF_TYPE_INHERIT:
        _asf_inherit_publication_schema($mod_set['inherit_nid'], $node->nid);
        break;
    }
  }
}
/**
 * Inherit publication schema from related node.
 *
 * @param int $source_entity_nid
 *   The source nid witgh publication actions.
 * @param int $target_entity_nid
 *   The node to o the actions for.
 */
function _asf_inherit_publication_schema($source_entity_nid, $target_entity_nid) {
  $actions = asf_select_actions(array(
    'nid' => $source_entity_nid,
  ));
  foreach ($actions as $action) {
    $new_action = clone $action;
    unset($new_action->aid);
    unset($new_action->created);
    unset($new_action->changed);
    $new_action->nfid = 'dependency:node:' . $source_entity_nid;
    $new_action->nid = $target_entity_nid;
    asf_insert_action($new_action);
  }
}

/**
 * Translate modalities to publish/unpublish scheme.
 */
function _asf_translate_mods_scheme($mods) {
  $day = $mods['startdate'];
  $iteration_count = 0;
  $scheme = array();
  // Infinite means do it for 1 month and then recalculate.
  // Doing 2 days extra for if tha cron is held: taking some reserve.
  $infinity_end = strtotime('+ 33 days', REQUEST_TIME);
  while (_asf_continue_iteration($day, $mods, $iteration_count, $infinity_end)) {
    $start_time = mktime(intval($mods['start_hour']), intval($mods['start_min']), 0, date('m', $day), date('d', $day), date('Y', $day));
    $end_time = mktime(intval($mods['end_hour']), intval($mods['end_min']), 0, date('m', $day), date('d', $day), date('Y', $day));
    $h_start_time = date("Y-m-d H:i:s", $start_time);
    $h_end_time = date("Y-m-d H:i:s", $end_time);
    if ($meet = _asf_meets_requirements($start_time, $end_time, $mods)) {
      $scheme[] = array(
        'time' => $start_time,
        'action' => ASF_ACTION_PUBLISH,
      );
      $scheme[] = array(
        'time' => $end_time,
        'action' => ASF_ACTION_UNPUBLISH,
      );
    }
    $day = strtotime('+1 day', $day);
    $iteration_count++;
  }
  return $scheme;
}

/**
 * Determine if we can keep looping.
 *
 * @param string $day
 *   the generated day to test.
 * @param array $mods
 *   the modalities (filters)
 * @param int $iteration_count
 *   count the iteration count.
 *
 * @return boolean
 *   TRUE = continue iterating.
 */
function _asf_continue_iteration($day, $mods, $iteration_count, $infinity_end) {
  if ($mods['iteration_end'] == ASF_ITERATION_ENDDATE) {
    return ($day < $mods['enddate']);
  }
  elseif ($mods['iteration_end'] == ASF_ITERATION_MAX) {
    if ($mods['iteration_max'] == '') {
      return TRUE;
    }
    return ($iteration_count < intval($mods['iteration_max']));
  }
  elseif ($mods['iteration_end'] == ASF_ITERATION_FIRST) {
    return (($day < $mods['enddate']) && ($iteration_count < $mods['iteration_max']));
  }
  elseif ($mods['iteration_end'] == ASF_ITERATION_INFINITE) {
    return ($day < $infinity_end);
  }
  return FALSE;
}

/**
 * Test if a date meeths the requirements.
 */
function _asf_meets_requirements($date, $date2, $mods) {
  if ($date == $date2) {
    // Publish and unpublish on the same time is useless.
    return FALSE;
  }
  foreach ($mods as $mod => $mod_data) {
    switch ($mod) {
      case 'iteration_days':
        if (!empty($mods['iteration_days'])) {
          $dayint = trim(date('d', $date), '0');
          if (!in_array($dayint, $mods['iteration_days']) && $mods['iteration_day'] != '*') {
            return FALSE;
          }
        }
        break;

      case 'iteration_weekdays':
        if (!empty($mods['iteration_weekdays'])) {
          $dayint = trim(date('w', $date), '0');
          if (!in_array($dayint, $mods['iteration_weekdays']) && $mods['iteration_weekday'] != '*') {
            return FALSE;
          }
        }
        break;

      case 'iteration_weeks':
        if (!empty($mods['iteration_weeks'])) {
          $dayint = trim(date('W', $date), '0');
          if (!in_array($dayint, $mods['iteration_weeks']) && $mods['iteration_week'] != '*') {
            return FALSE;
          }
        }
        break;

      case 'iteration_months':
        if (!empty($mods['iteration_months'])) {
          $dayint = trim(date('n', $date), '0');
          if (!in_array($dayint, $mods['iteration_months']) && $mods['iteration_month'] != '*') {
            return FALSE;
          }
        }
        break;

      case 'iteration_years':
        if (!empty($mods['iteration_years'])) {
          $dayint = date('Y', $date);
          if (!in_array($dayint, $mods['iteration_years']) && $mods['iteration_year'] != '*') {
            return FALSE;
          }
        }
        break;

    }
  }
  return TRUE;
}

/**
 * This expands the modalities with calculated data.
 */
function _asf_expand_modalities(&$mod_set) {
  $time_format = 'H:i';
  $mod_set['iteration_days'] = _asf_split_field($mod_set['iteration_day']);
  $mod_set['iteration_weekdays'] = _asf_split_field($mod_set['iteration_weekday']);
  $mod_set['iteration_weeks'] = _asf_split_field($mod_set['iteration_week']);
  $mod_set['iteration_months'] = _asf_split_field($mod_set['iteration_month']);
  $mod_set['iteration_years'] = _asf_split_field($mod_set['iteration_year']);

  $mod_set['start_time'] = $mod_set['start_time'];
  $mod_set['start_hour'] = substr($mod_set['start_time'], 0, 2);
  $mod_set['start_min'] = substr($mod_set['start_time'], 3, 2);

  $mod_set['end_time'] = $mod_set['end_time'];
  $mod_set['end_hour'] = substr($mod_set['end_time'], 0, 2);
  $mod_set['end_min'] = substr($mod_set['end_time'], 3, 2);
  $mod_set['iteration_max'] = $mod_set['iteration_max'];
}

/**
 * Explode the field.
 */
function _asf_split_field($field) {
  $items = explode(',', $field);
  if (count($items) == 1 && $items[0] == '') {
    return NULL;
  }
  return $items;
}

/**
 * Create an action in the DB.
 */
function _asf_create_action($nid, $time, $publish_action, $nfid = 0) {
  $action = new stdClass();
  $action->nid = $nid;
  $action->nfid = $nfid;
  $action->action = $publish_action;
  $action->time = $time;
  $action->status = ASF_STATUS_PENDING;
  return asf_insert_action($action);
}


/**
 * Dismiss an action object.
 *
 * @param object $action
 *   the action
 */
function _asf_dismiss_action($action) {
  $action->status = ASF_STATUS_EXECUTED;
  asf_update_action($action);
}

/**
 * Delete publications for nid.
 */
function _asf_delete_publication_for_nid($nid) {
  $actions = asf_select_actions(array(
    'nid' => $nid,
    'action' => 'publish',
    'status' => 'PEN',
  ));
  foreach ($actions as $action) {
    asf_delete_action($action->aid);
  }
}

/**
 * Delete the outdated publishing entries in the table.
 */
function _asf_delete_old() {
  $threshold = variable_get('asf_consider_outdated', 'NOW - 1 MONTH');
  $time = strtotime($threshold);
  $actions = asf_select_actions(array(
    'status' => ASF_STATUS_EXECUTED,
    'time' => array('value' => $time, 'operator' => '<'),
  ));
  foreach ($actions as $action) {
    asf_delete_action($action->aid);
  }
}
