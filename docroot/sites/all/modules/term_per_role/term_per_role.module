<?php

/**
 * @file
 * Allows restricting access to term page per role.
 */

/**
 * Implements hook_menu().
 */
function term_per_role_menu() {
  $items = array();
  $items['admin/config/content/term-per-role'] = array(
    'title' => 'Term per role settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('term_per_role_admin_settings'),
    'access callback' => 'user_access',
    'access arguments' => array('administer term_per_role'),
    'description' => 'Global configuration of term per role functionality.',
    'file' => 'includes/term_per_role.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  return $items;
}

/**
 * Implements hook_permission().
 */
function term_per_role_permission() {
  return array(
    'administer term_per_role' => array(
      'title' => t("Administer term per role"),
      'description' => t("Permission for who can access the term per role forms."),
    )
  );
}

/**
 * Implements hook_form_ID_alter().
 */
function term_per_role_form_taxonomy_form_term_alter(&$form, &$form_state, $form_id) {
  if (!user_access('administer term_per_role')) {
    return;
  }
  // Checks for confirmation forms.
  if (isset($form_state['input']['op']) && $form_state['input']['op'] == 'Delete') {
    return;
  }

  $form['#submit'][] = 'term_per_role_term_form_submit';
  if (isset($form_state['term'])) {
    $tid = $form_state['term']->tid;
  }
  else {
    $tid = arg(2);
  }
  $settings = term_per_role_get_term_settings($tid);
  $form['term_per_role'] = array(
    '#type' => 'fieldset',
    '#title' => t('Restrict item visibility'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#weight' => 5,
    '#description' => t('Check to know whether the user has proper visibility permissions to see this term page. Note that both checks are always performed.'),
  );
  $form['term_per_role']['term_per_role_hide_all'] = array(
    '#type' => 'radios',
    '#options' => array(t('Select roles'), t('Close term page for all roles')),
    '#title' => t('Select behavior'),
    '#default_value' => isset($settings->hide_all) ? $settings->hide_all : 0
  );
  $form['term_per_role']['term_per_role_roles'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Show term page only to selected roles'),
    '#options' => user_roles(),
    '#default_value' => isset($settings->rids) ? $settings->rids : array(),
    '#description' => t('Check no role to leave the access permission to the default. A user who is not part of at least one of the selected roles will not see this term page.'),
    '#states' => array(
      'visible' => array(
        ':input[name="term_per_role_hide_all"]' => array('value' => 0),
      )
    )
  );
  $form['term_per_role']['term_per_role_hide_from_roles'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Close term page from selected roles'),
    '#options' => user_roles(),
    '#default_value' => isset($settings->hrids) ? $settings->hrids : array(),
    '#description' => t('Check no role to leave the access permission to the default. A user who is part of any one of these roles will not see this term page.'),
    '#states' => array(
      'visible' => array(
        ':input[name="term_per_role_hide_all"]' => array('value' => 0),
      )
    )
  );
}

/**
 * Internal function to save the data in our table.
 *
 * @see term_per_role_form_taxonomy_form_term_alter().
 * @ingroup forms
 */
function term_per_role_term_form_submit($form, &$form_state) {
  $values = $form_state['values'];

  $settings = term_per_role_get_term_settings($values['tid']);
  if (isset($settings->tid)) { // update
    $settings->hide_all = $values['term_per_role_hide_all'];
    $rids = array();
    $hrids = array();
    if ($values['term_per_role_hide_all'] == 0) {
      foreach ($values['term_per_role_roles'] as $key => $val) {
        if ($val > 0) {
          $rids[] = $val;
        }
      }
      foreach ($values['term_per_role_hide_from_roles'] as $key => $val) {
        if ($val > 0) {
          $hrids[] = $val;
        }
      }
    }

    $settings->rids = implode(',', $rids);
    $settings->hrids = implode(',', $hrids);
    db_update('term_per_role')
    ->fields((array) $settings)
    ->condition('tid', $values['tid'])
    ->execute();
  }
  else { // insert
    $insert = FALSE;
    $fields = array(
      'tid' => $values['tid'],
      'hide_all' => $values['term_per_role_hide_all'],
      'rids' => '',
      'hrids' => ''
    );
    if ($values['term_per_role_hide_all'] == 0) {
      $rids = array();
      foreach ($values['term_per_role_roles'] as $key => $val) {
        if ($val > 0) {
          $rids[] = $val;
        }
      }
      $hrids = array();
      foreach ($values['term_per_role_hide_from_roles'] as $key => $val) {
        if ($val > 0) {
          $hrids[] = $val;
        }
      }
      if (count($rids) || count($hrids)) {
        $fields['rids'] = implode(',', $rids);
        $fields['hrids'] = implode(',', $hrids);
        $insert = TRUE;
      }
    }
    else {
      $insert = TRUE;
    }
    if ($insert) {
      db_insert('term_per_role')
      ->fields($fields)
      ->execute();
    }
  }
}

/**
 * Get settings for term
 *
 * @param $tid
 *  Term id
 * @return
 *  Settings
 */
function term_per_role_get_term_settings($tid) {
  $tids = &drupal_static(__FUNCTION__, array());
  if (isset($tids[$tid])) {
    return $tids[$tid];
  }

  $tids[$tid] = NULL;
  if (!empty($tid)) {
    $settings = db_select('term_per_role', 'tpr')
    ->fields('tpr')
    ->condition('tid', $tid, '=')
    ->execute()->fetchObject();
    if (isset($settings->tid)) {
      if ($settings->hide_all == 0) {
        if (!empty($settings->rids)) {
          $settings->rids = explode(',', $settings->rids);
        }
        else {
          $settings->rids = array();
        }
        if (!empty($settings->hrids)) {
          $settings->hrids = explode(',', $settings->hrids);
        }
        else {
          $settings->hrids = array();
        }
      }
      else {
        $settings->rids = array();
        $settings->hrids = array();
      }
      $tids[$tid] = $settings;
    }
  }
  return $tids[$tid];
}

/**
 * Implements hook_taxonomy_term_delete().
 */
function term_per_role_taxonomy_term_delete($term) {
  if (isset($term->tid)) {
    db_delete('term_per_role')
    ->condition('tid', $term->tid, '=')
    ->execute();
  }
}

/**
 * Implements hook_menu_alter().
 */
function term_per_role_menu_alter(&$items) {
  $path = 'taxonomy/term/%taxonomy_term';
  if (isset($items[$path])) {
    $items[$path]['page arguments'] = array_merge($items[$path]['page arguments'], array($items[$path]['page callback']));
    $items[$path]['page callback'] = 'term_per_role_taxonomy_term_page';
  }
}

/**
 * Menu callback; displays all nodes associated with a term.
 *
 * @param $term
 *   The taxonomy term.
 * @return
 *   The page content.
 */
function term_per_role_taxonomy_term_page($term) {
  if (!isset($term->tid) || !term_per_role_access($term->tid)) {
    $behavior = variable_get('term_per_role_access_behavior');
    switch ($behavior) {
      default:
      case 403:
        return drupal_access_denied();
        break;

      case 404:
        return drupal_not_found();
        break;
    }
  }
  $args = func_get_args();
  $function = 'taxonomy_term_page';
  foreach ($args as $callback) {
    if (is_string($callback) && function_exists($callback)) {
      $function = $callback;
    }
  }
  // Otherwise, fall back.
  if ($function == 'taxonomy_term_page') {
    module_load_include('inc', 'taxonomy', 'taxonomy.pages');
  }
  return $function($term);
}

/**
 * Determines access to page for a give term id.
 *
 * @param $tid
 *  The term identifier
 * @return
 *  Bool TRUE OR FALSE
 */
function term_per_role_access($tid) {
  global $user;
  if (empty($tid)) {
    return FALSE;
  }
  $settings = term_per_role_get_term_settings($tid);
  if (!isset($settings->tid)) {
    return TRUE;
  }
  if ($settings->hide_all != 0) {
    return FALSE;
  }
  if (count($settings->rids) > 0 && count(array_intersect($settings->rids, array_keys($user->roles))) == 0) {
    // not permitted by the rids...
    return FALSE;
  }
  if (count($settings->hrids) > 0 && count(array_intersect($settings->hrids, array_keys($user->roles))) > 0) {
    // not permitted by the hrids...
    return FALSE;
  }
  return TRUE;
}