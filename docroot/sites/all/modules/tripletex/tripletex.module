<?php
/**
 * @file
 * Provides an API for creating orders and invoices in Tripletex.
 */

/* Constants declarations */
define('TRIPLETEX_JSON_URL', 'https://tripletex.no/JSON-RPC');
define('TRIPLETEX_SESSION_LIFETIME', '55');   // Session lifetime in seconds Issue #1468430: Session is created for every operation
define('TRIPLETEX_DEFAULT_DUE_DAYS', '14');
define('TRIPLETEX_DEFAULT_CURRENCY_CODE', 'NOK');
define('TRIPLETEX_DEFAULT_LANGUAGE_CODE', 'NO');
define('TRIPLETEX_DEFAULT_COUNTRY_CODE', 'NO');
define('TRIPLETEX_DEFAULT_PAYMENT_CODE', 'BANK');
define('TRIPLETEX_DEFAULT_INVOICE_RANGE_START', '20000');
define('TRIPLETEX_DEFAULT_CUSTOMER_CATEGORY', '2');
define('DEFAULT_SYNC_SYSTEM', '');
define('DEFAULT_SYNC_SYSTEM_PWD', 'pwd');
define('TRIPLETEX_LOGIN_DELAY', '10');  // Default delay between automatic login attempts (seconds)
define('TRIPLETEX_LOGIN_RETRIES', '5');  // Default number of retries of automatic login attempts

// Tripletex vatType codes
define('TRIPLETEX_VATTYPE_HIGH', 3);
define('TRIPLETEX_VATTYPE_MED', 31);
define('TRIPLETEX_VATTYPE_LOW', 32);
define('TRIPLETEX_VATTYPE_NO_INSIDE', 5);
define('TRIPLETEX_VATTYPE_NO_OUTSIDE', 6);
define('TRIPLETEX_DEFAULT_VAT_CODE', TRIPLETEX_VATTYPE_NO_OUTSIDE);    // 3: High vat. 31: Medium vat. 32: Low vat. 5: No vat (inside). 6: No vat (outside).

// 3: High vat. 31: Medium vat. 32: Low vat. 5: No vat (inside). 6: No vat (outside).
define('TRIPLETEX_MVA_RATE_3',  25.0); // 3: High vat.
define('TRIPLETEX_MVA_RATE_31', 15.0); // 31: Medium vat.
define('TRIPLETEX_MVA_RATE_32',  8.0); // 32: Low vat.
define('TRIPLETEX_MVA_RATE_5',   0.0); // 5: No vat (inside).
define('TRIPLETEX_MVA_RATE_6',   0.0); // 6: No vat (outside).

// Invoice status
define('TRIPLETEX_INV_STATUS_PENDING', 		'pending');
define('TRIPLETEX_INV_STATUS_OVERDUE', 		'overdue');
define('TRIPLETEX_INV_STATUS_SETTLED', 		'settled');
define('TRIPLETEX_INV_STATUS_CANCELLED', 	'cancelled');

define('TRIPLETEX_ENABLE_TEST_FUNCTIONS', TRUE); // Change to TRUE for enabling test functions

if (TRIPLETEX_ENABLE_TEST_FUNCTIONS) {
	include_once 'tripletex_test.php';
}

/************************************************************************************************
* Module API
*/

/**
 * Adds and create and invoice and registrers it with your online Tripletex account
 * See tripletex.api.php for more information
 *
 * @param array $customer
 *   Structured array containing customer information. This is a customer structure as defined in tripletex_create_customer()
 *
 * @param array $products
 *   Array of structured arrays containing product details. Product contains minimum:
 *     'obj'	: Object - The product object as defined by tripletex_create_product()
 *     'count'	: Integer, Number of items
 *     'option_name' : String - Optional line item description
 *
 * @param array $extra
 *   Structured array containing additional information for an invoice. Contains optional:
 *     'uid'	: Integer - User id of invoice creator or owner
 *     'nid'	: Integer - Node id if this invoice is attached to a node (per item content purchase)
 *     'oid'	: Integer - Order id if this is created
 *     'payment_type'	:	Payment type if invoice is already paid for. Refers to an existing payment type. This field is mandatory if the paid amount is specified.
 *     'payment_amount'	:	Paid amount on an already paid invoice
 *
 * @return int invocie_id
 *   New invoice id if success, 0 if creation failed
 */
function tripletex_add_invoice($customer, $products, $extra) {

  $invoice_no = NULL;                   // No invoice created yet
  $order_line = array(
	'Invoice-number' => $invoice_no,	// Create an order line adding placeholder for invoice number
  );

  $order_total = 0;                     // Keep track of the order totalt

  // Find the customer or create a new one if not already existing
  $updated_customer = tripletex_create_update_customer($customer);
  // Prefill invoice array with customer information and product details
  $invoice_customer = tripletex_map_customer_invoice($updated_customer);

  // Verify neccessary minimums
  if (!trim($invoice_customer['Customer-name'])) {
    // Need as a minimum a name of the customer
    $error = new stdClass;
    $error->msg = t("Tripletex invoice: Need a name of the invoice receipient. Invoice not sendt.");
    _tripletex_write_error($error);
    return 0;
  }

  if (!trim($invoice_customer['Customer-email'])) {
    // Need as a minimum an email of the customer
    $error = new stdClass;
    $error->msg = t("Tripletex invoice: Need an e-mail of the invoice receipient. Invoice not sendt.");
    _tripletex_write_error($error);
    return 0;
  }

  // Add extra invoice information
  $invoice_extra = tripletex_map_extra_invoice($extra);
  $order_lines = array();               // empty array of orders

  foreach($products as $product) {
    // Add item to invoice
    $p = $product['obj'];
	$invoice_product = tripletex_map_product_invoice($p, $product['count'], $product['option_name']);

    // Add user and other (extra) information
    $invoice_params = array_merge(
      $invoice_customer,
      $invoice_product,
      $invoice_extra
    );

    // See if product already exists in Tripletex account
    $found = tripletex_search_product(trim($p->name), FALSE, NULL, 1);

    if ($found && $product['option_name'] == '') {
      // Product already registered
      $invoice_params['Order-line-description'] = '';
    }

    $order_line = tripletex_create_invoice_structure($invoice_params, $invoice_no);   // Create invoice structure

    $invoice_no = $order_line['Invoice-number'];               // Save the newly created invoice number

    // Currently we are creating an invoice for each product line and merging them all into one big invoice at the
    // end that is passed through to the web interface
    $order_lines[] = implode(';', $order_line) . ";\r\n";      // Add this invoice structure to a
    $order_total += $product['count']*$p->priceCurrency;

  }

  // Get tripletex session
  $session = tripletex_login();
  if (!$session) {
    $error = array('tripletex_msg' => t('Tripletex: Login failed'));
    module_invoke_all('tripletex_add_invoice_failed', $order_line, $error);  // Call hook for error reporting
    return 0;  // If we cannot login, return 0
  }

  $output = implode('', $order_lines);

  if (!isset($extra['nid'])) $extra['nid'] = 0;

  $result = tripletex_api_request('Invoice.importInvoicesTripletexCSV', $output, $session);
  if ($result == '') {
      module_invoke_all('tripletex_add_invoice_success', $order_line, array());  // Call hook for invoice success
      _tripletex_add_invoice_log($order_line, $extra['nid'], $extra['uid'], $order_total);
  }
  else {

  	$error = array('error_msg' => t('Tripletex: Invoice creation failed'));
    module_invoke_all('tripletex_add_invoice_failed', $order_line, $error);  // Call hook for error reporting
    return 0;  // If we cannot login, return 0

  }


  return $invoice_no;  // Return the invoice number created


}

function tripletex_cancel_invoice($invoice_id) {
  // Not implemented yet
}


/**
 * Returns the invoice document as BASE64 pdf bytes.
 *
 */
function tripletex_get_invoice_document($invoice_id) {

  $param = array($invoice_id);

  $result = tripletex_api_request('Invoice.getDocumentBase64PdfBytes', $param, tripletex_login());

  if (!$result) return NULL;

  // Convert stream to file
  $pdf_decoded = base64_decode ($result);
  //Write data back to pdf file
  $path = drupal_realpath(file_unmanaged_save_data($pdf_decoded, 'public://invoice-'.$invoice_id.'.pdf', $replace = FILE_EXISTS_REPLACE));

  return str_replace(DRUPAL_ROOT, '', $path);
}

/**
 * Redirects to
 * @param unknown $invoice_id
 * @return NULL
 */
function tripletex_redirect_invoice_document($invoice_id) {

	$filepath = tripletex_get_invoice_document($invoice_id);

	if ($filepath) {
		drupal_goto($filepath);
		return NULL;
	}
	else
		drupal_goto($_SERVER['HTTP_REFERER']);

	return t('PDF found at @path', array('@path' => $filepath));
}


/**
 * Returns the invoice status
 *
 *
 * @param int $invoice_id
 * @return struct array result
 *   float balance
 *   enum	status
 */
function tripletex_get_invoice_status($invoice_id) {

  $session = tripletex_login();
  $balance = _tripletex_get_outstanding_balance($invoice_id, $session);
  _tripletex_update_invoice_balance($invoice_id, $balance);

  // Call hooks to handle invoices that are updated and not entirely settled before this call
  module_invoke_all('tripletex_invoice_update', $id);

  $invoice = _tripletex_load_invoice($invoice_id);

  $result = array(
    'balance' => $balance,
    'status'	=> TRIPLETEX_INV_STATUS_PENDING,

  );

  if ($invoice->settled_date) {
    $result['status'] = TRIPLETEX_INV_STATUS_SETTLED;
  }
  else if ($invoice->due_date < mktime()) {
    $result['status'] = TRIPLETEX_INV_STATUS_OVERDUE;
  }

  // TODO: Handle canceled invoices

  return $result;

}

/**
 * Implements hook_tripletex_add_invoice()
 *
 * @param unknown_type $invoice
 */
function tripletex_tripletex_add_invoice(&$invoice) {

  // called by: drupal_alter('tripletex_add_invoice', $invoice);
}

/**
 * Implementation of hook_tripletex_create_invoice_success()
 */
function tripletex_tripletex_add_invoice_success($invoice, $result) {

}

/**
 * Implementation of hook_tripletex_add_invoice_failed()
 *
 * @param array $error
 *   error_msg
 */
function tripletex_tripletex_add_invoice_failed($error) {
  drupal_set_message(t(check_plain($error['error_msg'])), 'error');
}

/************************************************************************************************
 * Module implementations
 */


/**
 * Implements hook_help().
 *
 * Display help and module information
 *
 * @param path
 *   which path of the site we're displaying help
 * @param arg
 *   array that holds the current path as would be returned from arg() function
 *
 * @return
 *   help text for the path
 */
function tripletex_help($path, $arg) {

  $output = '';
  // The line above outputs in ALL admin/module pages
  switch ($path) {
    case "admin/help#tripletex":
      $output = '<p>' . t("tripletex provides an API to Create Orders and Invoices in <a href='http://tripletex.no'>Tripletex</a> from Drupal") . '</p>';
      break;
  }

  return $output;

} // function tripletex_help

/**
 * Valid permissions for this module
 *
 * @return array
 *   An array of valid permissions for the tripletex module
 */
function tripletex_permission() {
  return array(
    'administer tripletex' => array(
      'title' => t('Administer Tripletex settings'),
      'description' => t('Permits access to settings for how the Tripletex module is configured'),
    ),
    'access tripletex content' => array(
      'title' => t('Access Tripletex content'),
      'description' => t('Allow access to invoices'),
    ),
    'access own tripletex content' => array(
      'title' => t('Access Own Tripletex content'),
      'description' => t('Allow access to own invoices'),
    ),
    'create tripletex invoice' => array(
      'title' => t('create tripletex invoice'),
      'description' => t('Enable creating manual invoice'),
    ),
  );
} // function tripletex_perm()

/**
 * Implements hook_menu().
 *
 * Menu for this module
 *
 * @return
 *   An array with this module's settings.
 */
function tripletex_menu() {

  $items = array();

  //Link to the tripletex admin page:
  $items['admin/config/services/tripletex'] = array(
    'title' => 'Tripletex',
    'description' => 'Administer Tripletex Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tripletex_settings'),
    'access arguments' => array('administer tripletex'),
    'type' => MENU_NORMAL_ITEM,
  );

  $items['admin/config/services/tripletex/settings'] = array(
    'title' => 'Settings',
    'description' => 'Administer Tripletex Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tripletex_settings'),
    'access arguments' => array('administer tripletex'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/config/services/tripletex/credentials'] = array(
    'title' => 'Credentials',
    'description' => 'Configure the Tripletex API login credentials',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tripletex_credentials_settings'),
    'access arguments' => array('administer tripletex'),
    'type' => MENU_LOCAL_TASK,
  );

  if (TRIPLETEX_ENABLE_TEST_FUNCTIONS) {
  $items['admin/config/services/tripletex/test'] = array(
    'title' => 'Tripletex test',
    'description' => 'Testing the Tripletex API',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tripletex_testing'),
    'access arguments' => array('administer tripletex'),
    'type' => MENU_LOCAL_TASK,
  );
  }

  $items['admin/content/invoice/add'] = array(
    'title' => 'Create invoice',
    'description' => 'Create a manual invoice',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tripletex_create_invoice_form'),
    'access arguments' => array('create tripletex invoice'),
    'type' => MENU_NORMAL_ITEM,
  );

  $items['user/%/invoice/add'] = array(
    'title' => 'Create invoice',
    'description' => 'Create a manual invoice',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tripletex_create_invoice_form', 1),
    'access arguments' => array('create tripletex invoice'),
    'type' => MENU_LOCAL_TASK,
  );

  // path with autocomplete function for products
  $items['invoice/display/%'] = array(
  	'title' => 'Display invoice PDF',
    'description' => 'Display a given invoice PDF',
  	'page callback' => 'tripletex_redirect_invoice_document',
    'page arguments' => array(2),
  	'access arguments' => array('access own tripletex content'),
  	'type' => MENU_LOCAL_TASK,
  );


  // path with autocomplete function for products
  $items['invoices/products/autocomplete'] = array(
    'title' => 'Autocomplete for products',
    'page callback' => '_tripletex_products_autocomplete',
    'access arguments' => array('create tripletex invoice'),
    'type' => MENU_CALLBACK,
  );

  // path with autocomplete function for products
  $items['invoices/customer/autocomplete'] = array(
    'title' => 'Autocomplete for customers',
    'page callback' => '_tripletex_customer_autocomplete',
    'access arguments' => array('create tripletex invoice'),
    'type' => MENU_CALLBACK,
  );

  // path with autocomplete fuction for price
  $items['invoices/prices/autocomplete'] = array(
    'title' => 'Autocomplete for prices',
    'page callback' => '_tripletex_products_price_autocomplete',
    'access arguments' => array('create tripletex invoice'),
    'type' => MENU_CALLBACK,
  );

  // path with ajax function for product
  $items['invoices/product/details'] = array(
    'title' => 'Product item details',
    'page callback' => '_tripletex_product_details',
    'access arguments' => array('create tripletex invoice'),
    'type' => MENU_CALLBACK,
  );

  // path with ajax fuction for customer
  $items['invoices/customer/details'] = array(
    'title' => 'Customer details',
    'page callback' => '_tripletex_customer_details',
    'access arguments' => array('create tripletex invoice'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Provides the menu structure for the settings page.
 *
 * @return
 *   array Form structure
 */
function tripletex_settings($form, &$form_state) {

  // Cheating: Updating the payment codes array and the default payment code upon loading of this form as the form submit is done by system function
  $new_code = variable_get('tripletex_new_payment_code', '');
  $payment_codes = tripletex_payment_types();
  if (!isset($payment_codes[$new_code]) && $new_code) {

    if (is_numeric($new_code) && $new_code > 999 && $new_code < 10000) {
      $payment_codes[$new_code] = 'Account ' . $new_code;
      $payment_codes = tripletex_payment_types($payment_codes);
    }
    elseif (is_string($new_code) && strlen($new_code) > 2) {
      $payment_codes[$new_code] = 'Customer ' . $new_code;
      $payment_codes = tripletex_payment_types($payment_codes);
    }

  }
  else {
    $new_code = variable_get('tripletex_default_payment_code', TRIPLETEX_DEFAULT_PAYMENT_CODE);
  }

  $form = array();

  $form['settings'] = array(
    '#type' => 'fieldset',
    '#title' => t('Default settings'),
    '#description' => t('Enter the default settings for the Tripletex API'),
  );

  $form['settings']['tripletex_handle_own_invoices'] = array(
    '#type' => 'checkbox',
    '#title' => t('Handle and create own invoice series?'),
    '#default_value' => variable_get('tripletex_handle_own_invoices', FALSE),
    '#description' => t('This is needed if you want to track payment status on generated invoices.'),
  );

  if (variable_get('tripletex_handle_own_invoices', FALSE)) { // This is only displayed if we're keeping track of the invoices ourselves
    $invoice_no = _tripletex_get_invoice_num();
    $form['settings']['tripletex_invoice_start_number'] = array(
      '#type' => 'textfield',
      '#title' => t('Invoice number range start'),
      '#default_value' => variable_get('tripletex_invoice_start_number', TRIPLETEX_DEFAULT_INVOICE_RANGE_START),
      '#size' => 20,
      '#maxlength' => 80,
      '#description' => t("The invoice numbers are generated and kept by the module and separate from the invoice number range used by Tripletex. Choose a start number that is not already in use."),
      '#required' => FALSE,
      '#states' => array(
        'visible' => array(':input[name="tripletex_handle_own_invoices"]' => array('checked' => TRUE))),

    );

    if ($invoice_no > 0) {
      $form['settings']['tripletex_invoice_start_number']['#description'] = t("The invoice number can no longer be changed as there are invoices created already. The field above is disabled and the number displayed is the highest/latest invoice number created.");
      $form['settings']['tripletex_invoice_start_number']['#default_value'] = $invoice_no;
      $form['settings']['tripletex_invoice_start_number']['#disabled'] = TRUE;
    }
  }

  $form['settings']['tripletex_default_vat_code'] = array(
    '#type' => 'radios',
    '#title' => t('Default VAT code'),
    '#options' => array(
      TRIPLETEX_VATTYPE_HIGH => '3: High vat.',
      TRIPLETEX_VATTYPE_MED => '31: Medium vat.',
      TRIPLETEX_VATTYPE_LOW => '32: Low vat.',
      TRIPLETEX_VATTYPE_NO_INSIDE => '5: No vat (inside).',
      TRIPLETEX_VATTYPE_NO_OUTSIDE => '6: No vat (outside).',
    ),
    '#default_value' => variable_get('tripletex_default_vat_code', TRIPLETEX_DEFAULT_VAT_CODE),
    '#size' => 20,
    '#maxlength' => 80,
    '#description' => t("3: High vat. 31: Medium vat. 32: Low vat. 5: No vat (inside). 6: No vat (outside)."),
    '#required' => FALSE,
  );

  $form['settings']['tripletex_default_due_days'] = array(
    '#type' => 'textfield',
    '#title' => t('Default Due days'),
    '#default_value' => variable_get('tripletex_default_due_days', TRIPLETEX_DEFAULT_DUE_DAYS),
    '#size' => 20,
    '#maxlength' => 80,
    '#description' => t("Default number of days the invoice genereated is due."),
    '#required' => FALSE,
  );

  $form['settings']['tripletex_default_currency_code'] = array(
    '#type' => 'select',
    '#title' => t('Default currency code'),
    '#default_value' => variable_get('tripletex_default_currency_code', TRIPLETEX_DEFAULT_CURRENCY_CODE),
    '#options' => array_combine(tripletex_currencies(), tripletex_currencies()),
    '#description' => t("Default currency code for the invoice. May be NOK, EUR, USD etc."),
    '#required' => FALSE,
  );
//Add Category id1 number
/*
  $form['settings']['tripletex_default_category_id1'] = array(
  	'#type' => 'select',
  	'#title' => t('Default language code'),
  	'#default_value' => variable_get('tripletex_default_language_code', TRIPLETEX_DEFAULT_LANGUAGE_CODE),
  	'#options' => array('NO' => 'NO', 'SV' => 'SV', 'EN' => 'EN'),
  	'#description' => t("Default language code for new customers. May be NO, SV, EN, etc."),
  	'#required' => FALSE,
  );
  */
  $form['settings']['tripletex_default_language_code'] = array(
    '#type' => 'select',
    '#title' => t('Default language code'),
    '#default_value' => variable_get('tripletex_default_language_code', TRIPLETEX_DEFAULT_LANGUAGE_CODE),
    '#options' => array('NO' => 'NO', 'SV' => 'SV', 'EN' => 'EN'),
    '#description' => t("Default language code for new customers. May be NO, SV, EN, etc."),
    '#required' => FALSE,
  );

  $form['settings']['tripletex_default_country_code'] = array(
    '#type' => 'select',
    '#title' => t('Default country code'),
    '#default_value' => variable_get('tripletex_default_country_code', TRIPLETEX_DEFAULT_COUNTRY_CODE),
    '#options' => _tripletex_country_codes(),
    '#description' => t("Default country code for new customers. May be NO, SE, GB, etc."),
    '#required' => FALSE,
  );

  $form['settings']['payment_codes'] = array(
    '#type' => 'fieldset',
    '#title' => t('Payment codes'),
    '#description' => t('Select and add payment codes for pre-paid invoices in Tripletex API'),
  );

  // Issue #1466078: Create paid invoices
  $form['settings']['payment_codes']['tripletex_default_payment_code'] = array(
    '#type' => 'select',
    '#title' => t('Default payment code'),
    '#default_value' => $new_code,
    '#options' => $payment_codes,
    '#description' => t("Default payment code for registering paid invoice."),
    '#required' => FALSE,
  );

  $form['settings']['payment_codes']['tripletex_paid_payment_codes'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Enabled payment codes'),
    '#description' => t('Payment codes available on invoice creation form'),
    '#options' => $payment_codes,
    '#default_value' => variable_get('tripletex_paid_payment_codes', array(variable_get('tripletex_default_payment_code', TRIPLETEX_DEFAULT_PAYMENT_CODE))),
  );

  $form['settings']['payment_codes']['tripletex_new_payment_code'] = array(
    '#type' => 'textfield',
    '#title' => t('New account number or customer'),
    '#default_value' => variable_get('tripletex_default_payment_code', TRIPLETEX_DEFAULT_PAYMENT_CODE),
    '#size' => 20,
    '#maxlength' => 80,
    '#description' => t("Enter account no or Customer name for new default"),
    '#required' => FALSE,
  );

  return system_settings_form($form);

}

/**
 * Validation of the tripletex settings form
 *
 * Verifies that a valid payment code is selected
 */
function tripletex_settings_validate($form, &$form_state) {
  if ($form_state['values']['tripletex_default_payment_code'] == 'XXXX') {
    form_set_error("tripletex_new_payment_code", t('Default payment code cannot be XXXX. Please type in your account number.'));
  }
  elseif ($form_state['values']['tripletex_default_payment_code'] == 'XYZ') {
    form_set_error("tripletex_new_payment_code", t('Default payment code cannot be XYZ. Please type in your Customer name.'));
  }

  // Remove empty payment codes
  foreach ($form_state['values']['tripletex_paid_payment_codes'] as $key => $value) {
    if (!$value) {
      unset($form_state['values']['tripletex_paid_payment_codes'][$key]);
    }
  }

}

/**
 * Form to set the Tripletex API credentials
 *
 * @return
 *   Form array
 */
function tripletex_credentials_settings($form, &$form_state) {

  $form = array();

  $form['credentials'] = array(
    '#type' => 'fieldset',
    '#title' => t('Login credentials'),
    '#description' => t('Enter your login credentials for the Tripletex JSON backend.'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );

  $form['credentials']['tripletex_user'] = array(
    '#type' => 'textfield',
    '#title' => t('Tripletex user name (e-mail)'),
    '#default_value' => variable_get('tripletex_user', 'json@test.no'),
    '#size' => 20,
    '#maxlength' => 80,
    '#description' => t("The user name used to log onto Tripletex JSON backend."),
    '#required' => TRUE,
  );

  $form['credentials']['tripletex_pass'] = array(
    '#type' => 'password',
    '#title' => t('Tripletex password'),
    '#default_value' => variable_get('tripletex_pass', 'pwd'),
    '#size' => 20,
    '#maxlength' => 80,
    '#description' => t("The password used to log onto Tripletex JSON backend."),
    //'#required' => TRUE,
  );

  $form['syncsystem'] = array(
    '#type' => 'fieldset',
    '#title' => t('Sync System identification'),
    '#description' => t('Enter Sync System identification for the Tripletex JSON backend.'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );

  $form['syncsystem']['tripletex_syncsyst'] = array(
    '#type' => 'textfield',
    '#title' => t('Tripletex syncSystem ID'),
    '#default_value' => variable_get('tripletex_syncsyst', DEFAULT_SYNC_SYSTEM),
    '#size' => 20,
    '#maxlength' => 80,
    '#description' => t("The syncSystem ID used to connect to Tripletex JSON backend."),
    '#required' => FALSE,
  );

  $form['syncsystem']['tripletex_syncsyst_pass'] = array(
    '#type' => 'password',
    '#title' => t('Tripletex syncSystem password'),
    '#default_value' => variable_get('tripletex_syncsyst_pass', DEFAULT_SYNC_SYSTEM_PWD),
    '#size' => 20,
    '#maxlength' => 80,
    '#description' => t("The syncSystem password used to connect to Tripletex JSON backend."),
    '#required' => FALSE,
  );

  $form['#submit'][] = 'tripletex_credentials_settings_submit';

  return system_settings_form($form);

}

/**
 * Make sure the blank password fields are not cleared in storage. One should be able
 * to save the credentials form without blanking the passwords
 *
 * @param array $form
 * @param array $form_state
 */
function tripletex_credentials_settings_validate(&$form, &$form_state) {

  if ($form_state['values']['tripletex_pass'] == '') {
    $form_state['values']['tripletex_pass'] = variable_get('tripletex_pass', '');
  }

  if ($form_state['values']['tripletex_syncsyst_pass'] == '') {
    $form_state['values']['tripletex_syncsyst_pass'] = variable_get('tripletex_syncsyst_pass', '');
  }

  unset($form['#submit']['1']);  // remove the system settings form submit call
                                 // Remember to call system_settings_form_submit()
}

/**
 * Resetting the Tripletex logintimer so that we can attempt with a new set of credentials
 * and displays the result of the login attempt
 *
 * @param array $form
 *   Changing the submit array if called before system_settings_form_submit()
 *
 * @param array $form_state
 */
function tripletex_credentials_settings_submit(&$form, &$form_state) {

  // Make sure the new values are saved before the login attempt
  // The system_settings_form_submit function runs form_state_values_clean()
  // that removes the form id from the values array. If the form_id is still
  // set then the systm_settings_form_submit() is not yet called
  if ( isset($form_state['values']['form_id'])) {
    // Save the changed vars
    system_settings_form_submit($form, $form_state);
  }

  // Try logging in with the new credentials
  if ($result = tripletex_login(TRUE)) {
    // Login succeeded
    drupal_set_message(t('Login succeeded!<br/>@session', array('@session' => $result)));
  }
  else {
    // Login failed
    drupal_set_message(t('Login failed!'), 'error');
  }
}


/**
 * Form to create a manual invoice
 *
 * @return
 *   Form array
 */
function tripletex_create_invoice_form($form, $form_state, $uid = NULL) {

  $u = NULL;
  if (is_numeric($uid)) {
    $u = user_load($uid);
  }

  $form = array();

  $form['invoice'] = array(
    '#description' => t('Create and send a invoice to Tripletex.'),
  );

  // Receipient details
  $form['invoice']['receipient'] = array(
    '#type' => "fieldset",
    '#title' => t("Recepient details"),
    '#description' => t("Enter receipient details of the customer."),
    '#collapsible' => TRUE,
  );

  $form['invoice']['receipient']['uid'] = array(
    '#type' => 'value',
    '#value' => (isset($u->uid) ? $u->uid : 0),
  );

  $form['invoice']['receipient']['name'] = array(
    "#type" => "textfield",
    "#title" => "Name of customer",
    '#size' => 20,
    '#maxlength' => 80,
    '#default_value' => (isset($form_state['post']['name']) ? $form_state['post']['name'] : (isset($u->name) ? $u->name : '')),
    '#autocomplete_path' => 'invoices/customer/autocomplete',

  );

  $form['invoice']['receipient']['address'] = array(
    "#type" => "textfield",
    "#title" => t("Customer address"),
    '#size' => 20,
    '#maxlength' => 80,
    '#default_value' => (isset($form_state['post']['address']) ? $form_state['post']['address'] : ''),
  );

  $form['invoice']['receipient']['address2'] = array(
    "#type" => "textfield",
    "#title" => t("Customer address 2"),
    '#size' => 20,
    '#maxlength' => 80,
    '#default_value' => (isset($form_state['post']['address2']) ? $form_state['post']['address2'] : ''),
  );

  $form['invoice']['receipient']['postcode'] = array(
    "#type" => "textfield",
    "#title" => t("Postcode"),
    '#size' => 4,
    '#maxlength' => 6,
    '#default_value' => (isset($form_state['post']['postcode']) ? $form_state['post']['postcode'] : ''),
  );

  $form['invoice']['receipient']['city'] = array(
    "#type" => "textfield",
    "#title" => t("City"),
    '#size' => 20,
    '#maxlength' => 80,
    '#default_value' => (isset($form_state['post']['city']) ? $form_state['post']['city'] : ''),
  );

  $form['invoice']['receipient']['phone'] = array(
    "#type" => "textfield",
    "#title" => t("Phone"),
    '#size' => 10,
    '#maxlength' => 12,
    '#default_value' => (isset($form_state['post']['city']) ? $form_state['post']['city'] : ''),
  );

  $form['invoice']['receipient']['mobile'] = array(
    "#type" => "textfield",
    "#title" => t("Mobile"),
    '#size' => 10,
    '#maxlength' => 12,
    '#default_value' => (isset($form_state['post']['city']) ? $form_state['post']['city'] : ''),
  );

  $form['invoice']['receipient']['email'] = array(
    "#type" => "textfield",
    "#title" => t("Customer e-mail"),
    '#size' => 20,
    '#maxlength' => 80,
    '#default_value' => (isset($form_state['post']['address']) ? $form_state['post']['address'] : (isset($u->mail) ? $u->mail : '')),
  );

  // Product details
  $form['invoice']['product-details'] = array(
    '#type' => 'fieldset',
    '#title' => t("Product details"),
    '#description' => t("Enter product details."),
    '#prefix' => '<div class="product-line">',
    '#suffix' => '</div>',
  );

  $form['invoice']['product-details']['count'] = array(
    "#type" => "textfield",
    "#title" => "Number of items",
    '#size' => 3,
    '#maxlength' => 3,
    '#default_value' => 1,
  );

  $form['invoice']['product-details']['product-id'] = array(
    '#type' => 'hidden',
    '#value' => '',
  );

  $form['invoice']['product-details']['product-number'] = array(
    '#type' => 'hidden',
    '#value' => '',
  );

  $form['invoice']['product-details']['product-vat-type'] = array(
    '#type' => 'hidden',
    '#value' => '',
  );

  $form['invoice']['product-details']['product'] = array(
    "#type" => "textfield",
    "#title" => "Product description",
    '#size' => 40,
    '#maxlength' => 120,
    '#default_value' => (isset($form_state['post']['product']) ? $form_state['post']['product'] : ''),
    '#autocomplete_path' => 'invoices/products/autocomplete',
  );

  $form['invoice']['product-details']['price'] = array(
    "#type" => 'textfield',
    "#title" => t("Unit price"),
    '#size' => 8,
    '#maxlength' => 8,
    '#default_value' => (isset($form_state['post']['price']) ? $form_state['post']['price'] : ''),
  );

  $payment_codes = array('0' => 'Not paid') + variable_get('tripletex_paid_payment_codes', array(variable_get('tripletex_default_payment_code', TRIPLETEX_DEFAULT_PAYMENT_CODE)));

  $form['invoice']['product-details']['paid'] = array(
    "#type" => 'select',
    "#title" => t("Invoice is already paid for"),
    '#description' => t('Select payment code if the invoice is already paid for'),
    '#options' => $payment_codes,
    '#default_value' => 0,
  );

  // Buttons
  $form['submit'] = array(
    "#type" => "submit",
    "#value" => t("Create invoice"),
  );

  // Issue #1532516 by stenjo: Manual invoice is created when Clear form is hit
  $form['cancel'] = array(
    '#type' => 'submit',
    '#value' => t("Clear form"),
    '#validate' => array('tripletex_create_invoice_form_clear'),
  );

  return $form;

}

/**
 * Clears the invoice form
 *
 * @param array $form
 * @param array $form_state
 */
function tripletex_create_invoice_form_clear($form, &$form_state) {
  $form_state['rebuild'] = TRUE;
}


/**
 * Validate the invoice creation form submission
 *
 * @param array $form
 * @param array $form_state
 *
 */
function tripletex_create_invoice_form_validate($form, $form_state) {
  // Make sure we have a receipient name
  if ($form_state['values']['name'] == '') {
    form_set_error('invoice][receipient][name', t('You must select a name for the invoice'));
  }

  // If we have an e-mail, check if it looks valid
  if ($form_state['values']['email'] != '') {
    if (!preg_match("/^[A-Z0-9._%-]+@[A-Z0-9][A-Z0-9.-]{0,61}[A-Z0-9]\.[A-Z]{2,6}$/i", $form_state['values']['email'])) {
      form_set_error('invoice][receipient][email', t('The email specified does not look right'));
    }
  }

  // Check that we have a number of products

  if (!is_numeric($form_state['values']['count']) || $form_state['values']['count'] <= 0) {
    form_set_error('invoice][product-details][count', t('You must set a minimum numer of items.'));
  }

  // Product description must also be in place

  if ($form_state['values']['product'] == '') {
    form_set_error('invoice][product-details][product', t('You must set a product description.'));
  }

  // And a product price

  if (!is_numeric($form_state['values']['price']) || $form_state['values']['price'] <= 0) {
    form_set_error('invoice][product-details][price', t('You must set a product price.'));
  }

}

/**
 * Send the invoice via the Tripletex API after manual invoice form
 *
 * @param array $form
 * @param array $form_state
 */
function tripletex_create_invoice_form_submit($form, $form_state) {

  global $user;

  // Get values
  $data = $form_state['values'];

  // Make sure customer exists before creation of invoice
  $created_cust = array('name' => $data['name'], 'customerAccountNumber' => $user->uid);
  // Initialize some parameters from the form state
  foreach ($data as $key => $value) {
    if (isset($value)) {
      switch ($key) {
  	    case 'phone':    $created_cust['phoneNumber'] = $value; break;
  	    case 'mobile':   $created_cust['mobileNumber'] = $value; break;
  	    case 'email':    $created_cust['invoiceEmail'] = $value; break;
  	    case 'address':  $created_cust['postalAddress1'] = $value; break;
  	    case 'address2': $created_cust['postalAddress2'] = $value; break;
  	    case 'postcode': $created_cust['postalNumber'] = $value; break;
  	    case 'city':     $created_cust['postalCity'] = $value; break;
  	    default: break;
      }
  	}
  }


  // Map info from a tripletex customer structure to a invoice receipient structure
//  $invoice_receipient = tripletex_map_customer_invoice($created_cust);

  // Add extra product information
  $product = tripletex_create_product(array('name' => $data['product'], 'unit_price' => $data['price']));
//  $invoice_product = tripletex_map_product_invoice($product, $data['count'], 'standard');

  if (isset($data['product-id'])) {
    $product->number = $data['product-id'];
	//$invoice_product['Product-id'] = $data['product-id'];
  }

  if (isset($data['product-number'])) {
    $product->number = $data['product-number'];
    // $invoice_product['Product-number'] = $data['product-number'];
  }

  $products[] = array(		// Array of product structures - each structure containing:
    'obj' 	=> 	$product,			// The product object
  	'count' => 	$data['count'], 	// Number of items
  	'option_name' => 'standard',	// Extra product line info
  );

  $extra = array('uid' => $user->uid);

  if ($data['paid']) {
	$extra['payment_type'] = $data['paid'];
	$extra['payment_amount'] = $data['count'] * $data['price'];

    // TODO: Handle VAT in some way?
  }

  $invoice = tripletex_add_invoice($created_cust, $products, $extra);

  /*
  $invoice = tripletex_create_invoice_structure(array_merge($invoice_product, $invoice_receipient));

  $output = implode(';', $invoice) . ";\r\n";

  $session = tripletex_login();

  if ($session) { // If login is OK
    $result = tripletex_api_request('Invoice.importInvoicesTripletexCSV', $output, $session);
    if ($result === NULL) { // If no problems sending invoice
      _tripletex_add_invoice_log($invoice, 0, $data['uid']); // Add to internal log
    }
  }
  */

}


/**
 * Search through Tripletex API for a customer matching the search_string
 *
 * @param string $search_string
 *   String fragment to search for
 *
 * @param boolean $objects
 *   Return an array of objects rather than strings
 *
 * @return array
 *   set of matches keyed by customer id
 */
function tripletex_search_customer($search_string, $objects = FALSE) {

  $search = array(
    'customerVendorType' => 1, // Customers only. 0 = All, 2 = Vendors only
    'isActive' => 1, // Active only. -1 = All, 0 = Inactive only
    'searchString' => $search_string,           // Required
  );

  $login_result = tripletex_login();
  $result = tripletex_api_request('Company.searchForCustomersAndVendors', $search, $login_result);

  $customers = array();

  if (!$result) return array();

  foreach ($result as $key => $object) {
    $customers[$object->id] = ($objects?$object:$object->name);
  }

  return $customers;
}



/**
 * Search through Tripletex API for a product matching the search_string
 *
 * @param string $search_string
 *   String fragment to search for
 *
 * @param boolean $objects
 *   Return an array of objects rather than strings
 *
 * @param array $keys
 *   An array of product fields to return
 *
 * @param int $isActive
 *   Search parameter
 *   'isActive' => 1 = Active only, -1 = All, 0 = Inactive only
 *
 * @return array
 *   set of matches keyed by product id
 */
function tripletex_search_product($search_string, $objects = FALSE, $keys = NULL, $isActive = 1) {

  static $last_product = NULL;

  // If keys array is set, we are after details of the last product we searched for
  if (count($keys)) {
    $last_product = variable_get('tripletex_last_product_saved', NULL);
    if (!$last_product) {
      return array();
    }

    $product = array();
    foreach ($keys as $value) {

      if ($value == 'all') {
        $obj = array($last_product);
        return array_shift($obj);
      }

      if (isset($last_product->{$value})) {
        $product[$value] = $last_product->{$value};
      }
    }

    return $product;
  }

  // If no keys array, then just do a normals search
  $products= array();

  $search = array(
        'isActive' => $isActive, // Active only. -1 = All, 0 = Inactive only
        'searchString' => $search_string,           // Required
  );

  $login_result = tripletex_login();
  $result = tripletex_api_request('Product.searchForProducts', $search, $login_result);

  if (!$result) return array();

  foreach ($result as $key => $object) {
    $products[$object->id] = ($objects?$object:$object->name);
    // If only one item found, save the product object for later
    if (count($result) == 1) {
      variable_set('tripletex_last_product_saved', $object);
    }
  }

  return $products;
}

/**
 * Login function to Tripletex using set values for username and system variables
 * Will make sure there is a 10 minute delay between failing login attempts to avoid
 * jamming down the Tripletex API monitoring system at remote end.
 *
 * @param boolean $reset
 *   TRUE if the login blocking timer is to be reset, FALSE if in timer mode
 *
 * @return: array  Session ID if successful login. NULL otherwise
 *
 */
function tripletex_login($reset = FALSE) {

  $session = '';

  // Issue #1468430: Session is created for every operation
  // Get the saved session if it has not timed out
  $stored_session = variable_get('tripletex_stored_session', array('timestamp' => 0, 'session' => ''));
  if (($stored_session['timestamp'] > (REQUEST_TIME - TRIPLETEX_SESSION_LIFETIME)) && !$reset) {
    $stored_session['timestamp'] = REQUEST_TIME;     // Renew session timeout
    variable_set('tripletex_stored_session', $stored_session); // Save new session data

    $session = $stored_session['session'];
    return $session;
  }

  // Issue #1784358 by stenjo: Too frequent login attempt
  if ($reset) {
    variable_set('tripletex_logintimer', 0);    // Clear the timer for login
    variable_set('tripletex_loginretries', 0);  // Forced reset - so reset number of login retries
  }

  // Get current timer set
  $login_timer = variable_get('tripletex_logintimer', time());  // Get last saved login attempt
  if ($login_timer > time()) {                                  // If the timer has not run out
    drupal_set_message(t("timer run out: @login_time > @time", array('@login_time' => $login_timer, '@time' => time())));
    return NULL;                                                // Assume login failed and return with unaltered timer
  }

  // Check if retries is more than enough
  $retries = variable_get('tripletex_loginretries', 0);
  if ($retries > TRIPLETEX_LOGIN_RETRIES) {
    drupal_set_message(t("Tripletex: Too many login attempts with incorrect credentials."));
    return NULL;                                                // Do not attempt another login as there have been too many failed auto attempts
  }

  // Log in to Sync system
  $json = new stdClass;

  $json->method = 'Sync.login';
  $json->params = array(
    variable_get('tripletex_syncsyst', DEFAULT_SYNC_SYSTEM),
    variable_get('tripletex_syncsyst_pass', DEFAULT_SYNC_SYSTEM_PWD),
    variable_get('tripletex_user', 'json@test.no'),
    variable_get('tripletex_pass', 'pwd'),
  );

  $headers = array();

  $data = json_encode($json);

  // See if the dummy API is enabled and active
  $result = module_invoke('tripletex_dummy_api', 'tripletex_api_request_call', $headers, $data);

  if (!count($result)) {              // If no dummy api response
    $result = drupal_http_request(    // Call the real api
      TRIPLETEX_JSON_URL, array(
        'headers' => $headers,
        'method' => 'POST',
        'data' => $data
      ));
  }

  if (!isset($result->data)) {
    $params = array(
      '@code' => $result->code,
      '@msg' => check_plain($result->error),
    );

    $message = "HTTP Request error @code : @msg";

    drupal_set_message(t(check_plain($message), $params), 'error');

    return NULL;
  }


  $json = json_decode($result->data);
  if (isset($json->error)) {
    $retries++;            // Failed login - keep track of the number of retries
    _tripletex_write_error($json->error);
    variable_set('tripletex_logintimer', time() + TRIPLETEX_LOGIN_DELAY); // Set next attempt time
    variable_set('tripletex_loginretries', $retries);
    return NULL;
  }

  // SUCCESS! We've logged inn successfully
  variable_set('tripletex_loginretries', 0);    // Clear retries counter

  $session = _tripletex_get_session_id($result->headers['set-cookie']);

  // Issue #1468430: Session is created for every operation
  $data = array(
    'timestamp' => REQUEST_TIME, // Renew session timeout
    'session' => $session,
  );

  variable_set('tripletex_stored_session', $data); // Save new session data

  return $session;

}

/**
 * Log out from the Tripletex API
 *
 * @param string $session:  Sessionstring
 */
function tripletex_logout(&$session) {

  $result = tripletex_api_request('Sync.logout', array(), $session);
  variable_set('stored_session', array('timestamp' => 0, 'session' => ''));

  // Handle errors?

}

/**
 * Add or update customer details in Tripletex
 *
 * @param array $params
 *   Keyed array of customer details. See tripletex_create_customer() for details
 *
 * @param boolean $unique
 *   Returns unique response if true (default), returns first result if false.
 *
 * @return array $customer
 *   Customer structure with tripletex assigned customer number if this was an update
 */
function tripletex_create_update_customer($params, $unique = TRUE) {

  $customer = tripletex_create_customer($params);		// Get clean customer structure initialized with $params

  if ($customer['name'] == '') return $customer;		// If empty customer name - just return default structure

  // Find customer in remote Tripletex API
  $found = tripletex_search_customer($customer['name'], TRUE);

  // Depending on how many results do
  if (count($found) == 1) {  // Found exactly one customer -> Unique result

    $customerObj = array_shift($found);  // Get the object

    // Update Tripletex with added information if different than stored

    $login_result = tripletex_login();
    $customer = tripletex_save_customer(array_merge($customer, (array)$customerObj), $login_result);

    return $customer;
  }
  else if (count($found) > 1) {	// If found more than one customer - loop through them and see if we are able to identify
  	/*
  	drupal_set_message(t("Found more than one customer with Tripletex"));

  	foreach ($found as $id => $customerObj) {
  	  if (strcmp($customerObj->postalAddress1, $customer['postalAddress1']) == 0) {
  	  	// We have a match and returns this one
  	  	return tripletex_create_customer(array_merge($customer, (array)$customerObj));
  	  }
  	}
     */
    if (!$unique) {
      // Return first found customer
      $customerObj = array_shift($found);  // Get the object
      return tripletex_create_customer(array_merge($customer, (array)$customerObj));
    }
  }
  else if (count($found) == 0) {	// New customer?

    $login_result = tripletex_login();
    $customer = tripletex_save_customer($customer, $login_result);
  }

  return $customer;		// Return prefilled customer structure
}

/**
 * Create a customer structure with all the parameters defined
 *
 * @param array $params
 *   Customer details to fill in the customer array. Could be from a search result or from another customer structure.
 *
 * @return array customer
 *   Customer array
 */
function tripletex_create_customer($params) {

  $customer = array(
  // Type Parameter Required Comment
  'name' => '',                     // String
  'customerAccountNumber' => '',    // String, The customer account number is generated if not provided.
  'vendorAccountNumber' => '',      // String, The vendor account number is generated if not provided.
  'organizationNumber' => '',       // String,
  'phoneNumber' => '',              // String,
  'mobileNumber' => '',             // String,
  'faxNumber' => '',                // String,
  'email' => '',                    // String,
  'invoiceEmail' => '',             // String,
  'postalAddress1' => '',           // String,
  'postalAddress2' => '',           // String,
  'postalNumber' => '',             // String,
  'postalCity' => '',               // String,
  'postalCountryCode' => variable_get('tripletex_default_country_code', TRIPLETEX_DEFAULT_COUNTRY_CODE),   // NO, SE etc.
  'physicalAddress1' => '',         // String,
  'physicalAddress2' => '',         // String,
  'physicalPostalNumber' => '',     // String,
  'physicalCity' => '',             // String,
  'physicalCountryCode' => variable_get('tripletex_default_country_code', TRIPLETEX_DEFAULT_COUNTRY_CODE), // NO, SE etc.
  'accountManagerId' => '',         // Integer, Internal id (employee).
  'customerCategoryId1' => '',      // Integer, Internal id (customer category).
  'customerCategoryId2' => '',      // Integer, Internal id (customer category).
  'customerCategoryId3' => '',      // Integer, Internal id (customer category).
  'languageCode' => variable_get('tripletex_default_language_code', TRIPLETEX_DEFAULT_LANGUAGE_CODE),      // NO, SV, EN
  'currencyCode' => variable_get('tripletex_default_currency_code', TRIPLETEX_DEFAULT_CURRENCY_CODE),      // NOK, EUR etc.
  );


  // Update fields according to params
  foreach ($params as $key => $value) {
  	if ($value) {
      if (in_array($key, array_keys($customer))) { // If params has a matching key with customer
        $customer[$key] = $value;			// Do the update into the customer structure directly
      }
      else {	// If keys are from search result customer details, update individually
    	switch ($key) {
          case 'postalcode'  : $customer['postalNumber'] = $value; break;
          case 'countryCode' : $customer['postalCountryCode'] = $value; break;
          case 'address1'    : $customer['postalAddress1'] = $value; break;
          case 'address2'    : $customer['postalAddress2'] = $value; break;
          case 'number'      : $customer['organizationNumber'] = $value; break;
          case 'city'        : $customer['postalCity'] = $value; break;
          default:break;
        }
      }
    }
  }


  // Make sure there is an invoice e-mail if this is not filled in and set this to customer email in lack of a better option
  if ($customer['invoiceEmail'] == '') {
  	$customer['invoiceEmail'] = $customer['email'];
  }

  return $customer;

}

/**
 * Maps a customer structure to a an invoice receiver structure
 *
 * @param array $customer
 * 		Structure containing fields according to tripletex_create_customer
 *
 * @return array $invoice_part
 * 		Structure containing fields according to invoice structure
 */
function tripletex_map_customer_invoice($customer) {

	$invoice_part = array();

	// Update fields according to params.
	foreach ($customer as $key => $value) {
		if (isset($value)) {
			switch ($key) {
			  case 'name'	: 	$invoice_part['Customer-name'] = trim($value);break;
			  case 'customerAccountNumber'	: 	$invoice_part['Customer-number'] = trim($value);break;
			  case 'postalAddress1'	: 	$invoice_part['Customer-address1'] = trim($value);break;
			  case 'postalAddress2'	: 	$invoice_part['Customer-address2'] = trim($value);break;
			  case 'postalNumber'	: 	$invoice_part['Customer-postal-number'] = trim($value);break;
			  case 'postalCity'		: 	$invoice_part['Customer-city'] = trim($value);break;
			  case 'invoiceEmail'	: 	$invoice_part['Customer-email'] = trim($value);break;
	          default:	// Unhandled field
			    break;

			}
		}
	}

	return $invoice_part;
}

/**
 * Maps a customer structure to a an invoice product structure
 *
 * @param object $product
 * 	 Object containing product details
 *
 * @param integer $count
 * 	 Number of products added to the invoice
 *
 * @param String $option_name
 *   Option description for the product
 *
 * @return array $invoice_part
 * 		Structure containing fields according to invoice structure
 */
function tripletex_map_product_invoice($product, $count = 1, $option_name = '') {

	$invoice_part = array();

	// Update fields according to params.
	foreach ((array)$product as $key => $value) {
		if (isset($value)) {
			switch ($key) {
				//  Mandatory if the product number is provided and if the product doesn’t exist.
				case 'name'		: 	$invoice_part['Product-name'] = trim($value);break;

				//  Refers to an existing product. If the product doesn’t exist, the product will be created.
				case 'number'	: 	$invoice_part['Product-number'] = trim($value);break;

				// case 'cost'		: 	$invoice_part[''] = trim($value);break;

				//  NOK, EUR, USD etc. If not specified, the default currency will be used.
				case 'currencyCode'	: 	$invoice_part['Currency-code'] = trim($value);break;

				//  3: High vat. 31: Medium vat. 32: Low vat. 5: No vat (inside). 6: No vat (outside).
				case 'vatType'	: 	$invoice_part['Vat-type'] = trim($value);break;

				// Required
				case 'priceCurrency'		: 	$invoice_part['Unit-price'] = trim($value);break;

				// case 'priceIncVatCurrency'	: 	$invoice_part[''] = trim($value);break;

				default:	// Unhandled field
					break;
			}
		}
	}

	$invoice_part['Order-line-description'] = trim($option_name);  	// Required Price component name
	$invoice_part['Count'] = $count; 								// Required

	return $invoice_part;
}

/**
 * Maps extra invoice information passed as in the $extra structure to invoice variables
 *
 * @param array $extra
 *   Array containing additional invoice information.
 *   'uid' : Integer - User id of user to be attached to the invoice. Usually the customer
 *   'nid' : Integer - Node id of the node attached to the invoice. Usually a content sold if any
 *   'oid' : Integer - Order number of order creating this invoice if any.
 *   'payment_type'	:	Payment type if invoice is already paid for. Refers to an existing payment type. This field is mandatory if the paid amount is specified.
 *   'payment_amount'	:	Paid amount on an already paid invoice
 *
 * @return array
 */
function tripletex_map_extra_invoice($extra) {


	$invoice_part = array();

	// Update fields according to params.
	foreach ($extra as $key => $value) {
		if (isset($value)) {
			switch ($key) {
				case 'uid'	: break;	// No place in the invoice for user id at the moment

				// Add node title to the ordre comment field of the invoice
				case 'nid'	: $invoice_part['Order-comment'] = trim(_tripletex_get_node_title($value));break;

				// Add order number to the invoice
				case 'oid'	: $invoice_part['Order-number'] = trim($value);break;

				// Add payment type to the invoice. Must be a value if paid amount is specified
				case 'payment_type'	  : $invoice_part['Payment-type'] = trim($value);break;

				// Add paid amount to a paid invoice
				case 'payment_amount' : $invoice_part['Paid-amount'] = trim($value);break;
				default:	// Unhandled field
					break;
			}
		}
	}

	return $invoice_part;

}

/**
 * Create and return invoice array. Defaults to todays date
 *
 * @param array $params
 *   Keyed array with parameters
 *     'Customer-name':     Required name of invoice receipient
 *     'Unit-price':        Required unit price of item.
 *     'Order-line-description':  Required item description
 *     'Customer-email':    Required E-mail address to customer
 *     'Count':             Opional number of items. Defaults to 1
 *     'Vat-type':          Optional VAT code. One of 3, 31, 32, 5 or 6. Defaults to 6
 * @param integer $invoice_number
 *   The existing invoice number if we have multiple order lines.
 *
 * @return
 *   array Containing column headers and and empty order array
 */
function tripletex_create_invoice_structure($params, $invoice_number = NULL) {

  $duedays = variable_get('tripletex_default_due_days', TRIPLETEX_DEFAULT_DUE_DAYS);
  $vat = variable_get('tripletex_default_vat_code', TRIPLETEX_DEFAULT_VAT_CODE);
  $currency = variable_get('tripletex_default_currency_code', TRIPLETEX_DEFAULT_CURRENCY_CODE);

  $invoice = array(
    'Invoice-number' => '',           // If not provided, the invoice number will be generated.
    'Invoice-date' => date("Y-m-d"),  // Required X YYYY-MM-DD
    'Due-date' => date("Y-m-d", mktime(0, 0, 0, date("m")  , date("d") + $duedays, date("Y"))), // Required X YYYY-MM-DD
    'KID' => '',                      // If not specified, the KID will be generated if an OCR agreement exists.
    'Payment-type' => '',             // Refers to an existing payment type.  This field is mandatory if the paid  amount is specified.
    'Paid-amount' => '',              // Amount paid by customer.
    'Order-number' => '',             // If not provided, each line will be considered as a separate order.
    'Order-date' => date("Y-m-d"),    // Required YYYY-MM-DD
    'Customer-number' => '',          // If the customer is registered, the customer information will be updated.
    'Customer-name' => '',            // Required
    'Customer-address1' => '',        //
    'Customer-address2' => '',        //
    'Customer-postal-number' => '',   //
    'Customer-city' => '',            //
    'Customer-email' => '',           // Company preference: If this order is included in an invoice (see importInvoicesCSV), the invoice will be sent to the customer by email.
    'Contact-first-name' => '',       //
    'Contact-last-name' => '',        //
    'Attn-first-name' => '',          //
    'Attn-last-name' => '',           //
    'Reference-number' => '',         //
    'Delivery-date' => '',            // If not provided, the order date will be  used.
    'Delivery-location' => '',        //
    'Order-comment' => '',            //
    'Subscription-unit-price-period' => '',       // Number of months/years.
    'Subscription-unit-price-period-unit' => '',  // 0: Months. 2: Years.
    'Subscription-invoice-period' => '',          // Number of months.
    'Subscription-invoicing-type' => '',          // 0: In advance. 1: In arrears.
    'Subscription-invoicing-period count' => '',  // Number of months/days in advance or in arrears.
    'Subscription-invoicing-period' => '',        // 0: Months. 1: Days. unit
    'Subscription-start-date' => '',              // YYYY-MM-DD
    'Count' => '',                    // Required
    'Unit-price' => '',               // Required
    'Discount-percentage' => '',      //
    'Vat-type' => $vat,               //  3: High vat. 31: Medium vat. 32: Low vat. 5: No vat (inside). 6: No vat (outside).
    'Order-line-description' => '',   //  Required
    'Product-number' => '',           //  Refers to an existing product. If the product doesn’t exist, the product will be created.
    'Product-name' => '',             //  Mandatory if the product number is provided and if the product doesn’t exist.
    'Department-number' => '',        //  Refers to existing department.
    'Department-name' => '',          //  Refers to existing department.
    'Project-number' => '',           //  If the project doesn’t exist, the project will be created.
    'Project-name' => '',             //  If the project doesn’t exist, the project will be created. Name is mandatory if the project number is provided and if the project doesn’t exist.
    'Currency-code' => $currency,     //  NOK, EUR, USD etc. If not specified, the default currency will be used.
    'Warehouse-number' => '',         //  Refers to existing warehouse.
    'Warehouse-name' => '',           //
  );

  /**
   * Payment type
   * Tripletex supports multiple invoice payment types e.g. cash, credit card, bank debit card. A
   * payment type is mapped to an account (1900, 1920 etc.) or a customer. When a new payment
   * type is referred to, the payment rule will be created on the fly. The following payment types
   * are defined:
   *   KONTANT. Account 1900.
   *   BANK. Account 1920
   *   KLARNA. Customer “Klarna”.
   *   POSTEN. Customer “Posten”.
   *   TELLER. Customer “Teller”.
   *   PAYPAL. Customer “Paypal”.
   *   DIBS. Customer “DIBS”.
   *   VISA. Customer “Visa”.
   *   KORT. Customer “Kortselskap”.
   *   XXXX (account number). Account XXXX.
   *   XYZ (any name). Customer “XYZ”
   *
   */

  // Update fields according to params.
  foreach ($params as $key => $value) {
    if (isset($params[$key])) {
      $invoice[$key] = $value;
    }
  }

  // Add order number if set in extra params
  if (isset($params['oid'])) {
  	$invoice['Order-number'] = $params['oid'];
  }
  // Check if we're handling invoice numbers ourselves.
  if (variable_get('tripletex_handle_own_invoices', FALSE)) {
    if (!_tripletex_get_invoice_num()) {
      // If this is first invoice.
      $invoice['Invoice-number'] = variable_get('tripletex_invoice_start_number', TRIPLETEX_DEFAULT_INVOICE_RANGE_START);
    }
    elseif ($invoice_number == NULL) {
      if ($invoice['Order-number'] == '') {
        $invoice['Order-number'] = _tripletex_get_invoice_num();
      }
      // Get available invoice number.
      // Update invoice with number.
      $invoice['Invoice-number'] = _tripletex_get_invoice_num();
    }
    else {
      // Use the same invoice number for multiple order lines.
      if ($invoice['Order-number'] == '') {
        $invoice['Order-number'] = $invoice_number;
      }
      $invoice['Invoice-number'] = $invoice_number;
    }
  }

  return $invoice;

}

/**
 * Create a complete order structure with all fields defined in the right sequence
 *
 *
 * @param unknown_type $params
 *   Array of parameters to fill the order
 *
 * @return array
 *   Compete order structure
 */
function tripletex_create_order($params) {

  static $order;

  $vat = variable_get('tripletex_default_vat_code', TRIPLETEX_DEFAULT_VAT_CODE);
  $currency = variable_get('tripletex_default_currency_code', TRIPLETEX_DEFAULT_CURRENCY_CODE);

  $order = array(
    'Order-number' => '',            // If not provided, each line will be considered as a separate order.
    'Order-date' => date("Y-m-d"),   // Required YYYY-MM-DD
    'Customer-number' => '',         // If the customer is registered, the customer information will be updated.
    'Customer-name' => '',           // Required
    'Customer-address1' => '',       //
    'Customer-address2' => '',       //
    'Customer-postal-number' => '',  //
    'Customer-city' => '',           //
    'Customer-email' => '',          //  Company preference: If this order is included in an invoice (see importInvoicesCSV), the invoice will be sent to the customer by email.
    'Contact-first-name' => '',      //
    'Contact-last-name' => '',       //
    'Attn-first-name' => '',         //
    'Attn-last-name' => '',          //
    'Reference-number' => '',        //
    'Delivery-date' => '',           // If not provided, the order date will be  used.
    'Delivery-location' => '',       //
    'Order-comment' => '',           //
    'Subscription-unit-price-period' => '',      // Number of months/years.
    'Subscription-unit-price-period-unit' => '', // 0: Months. 2: Years.
    'Subscription-invoice-period' => '',         // Number of months.
    'Subscription-invoicing-type' => '',         // 0: In advance. 1: In arrears.
    'Subscription-invoicing-period count' => '', // Number of months/days in advance or in arrears.
    'Subscription-invoicing-period' => '',       // 0: Months. 1: Days. unit
    'Subscription-start-date' => '',             //  YYYY-MM-DD
    'Count' => '',                   // Required
    'Unit-price' => '',              // Required
    'Discount-percentage' => '',     //
    'Vat-type' => $vat,              //  3: High vat. 31: Medium vat. 32: Low vat. 5: No vat (inside). 6: No vat (outside).
    'Order-line-description' => '',  //  Required
    'Product-number' => '',          //  Refers to an existing product. If the product doesn’t exist, the product will be created.
    'Product-name' => '',            //  Mandatory if the product number is provided and if the product doesn’t exist.
    'Department-number' => '',       //  Refers to existing department.
    'Department-name' => '',         //  Refers to existing department.
    'Project-number' => '',          //  If the project doesn’t exist, the project will be created.
    'Project-name' => '',            //  If the project doesn’t exist, the project will be created. Name is mandatory if the project number is provided and if the project doesn’t exist.
    'Currency-code' => $currency,    //  NOK, EUR, USD etc. If not specified, the default currency will be used.
    'Warehouse-number' => '',        //  Refers to existing warehouse.
    'Warehouse-name' => '',          //
  );


  // Update fields according to params

  foreach ($params as $key => $value) {
    if (isset($params[$key])) {
      $order[$key] = $value;
    }
  }

  return $order;

}

/**
 * Creates a product object and returns this with some fields updated already
 *
 * @param array $fields
 *   Structured array containing product details. Product contains minimum:
 *     'name'			: String, Name of the product	-	Mandatory
 *     'option_name'	: String, Option description of the product
 *     'unit_price'		: Float, Price per item
 *     'unit_price_vat'	: Float, Price per item including VAT
 *     'sku'			: Product number
 *     'cost'			: Product production cost
 *
 * @return stdClass	:	Product object
 *   Returns NULL object if there is no name for the product
 */
function tripletex_create_product($fields) {

	$product = new stdClass;
	$product->name = $fields['name'];
	$product->number = '';
	$product->cost = '';
	$product->currencyCode = variable_get('tripletex_default_currency_code', TRIPLETEX_DEFAULT_CURRENCY_CODE);
	$product->vatType = variable_get('tripletex_default_vat_code', TRIPLETEX_DEFAULT_VAT_CODE);
	$product->priceCurrency = '';
	$product->priceIncVatCurrency = '';

	foreach ($fields as $key => $value) {
		if ($value) {
			switch ($key) {
				case 'sku'            : $product->number = $value; break;
				case 'cost'           : $product->cost = $value; break;
				case 'title'          : $product->name = $value; break;
				case 'option_name'    : $product->name = $fields['name'] . ' (' . $value . ')'; break;
				case 'unit_price'     : $product->priceCurrency = $value; break;
				case 'unit_price_vat' : $product->priceIncVatCurrency = $value; break;
				case 'vat_type'       : $product->vatType = $value; break;
				case 'currency_code'  : $product->currencyCode = $value; break;
				default: break;
			}
		}
	}

	if (!$product->name) {
		_tripletex_write_error("Product created with no name field set");
		return NULL;
	}

	return $product;
}

/**
 * Do a method request to the Tripletex API. Handles error and returns NULL when error has occurred.
 *
 * @param unknown_type $method  The method idenitifier to the API
 * @param unknown_type $data  Data field accompanied with the method sent in the "params" field
 * @param unknown_type $session  Session identifier
 * @return array  keyed associative array containing the returned data.
 */
function tripletex_api_request($method, $data, &$session) {

  $json = new stdClass;

  $request_id = rand(1, 99);

  $json->method = $method;
  switch ($method) {
    case 'Invoice.importInvoicesTripletexCSV':
    case 'Project.importOrdersTripletexCSV':
      $json->params = array(
        $data,   // CSV Bytestring
        'ISO-8859-1', // Encoding
        FALSE,   // Order amounts including VAT?
        FALSE,   // Ignore first (heading) row
      );
      break;

    default:
      $json->params = array_values($data);
      break;

  }

  $json->id = $request_id;

  $headers = array('cookie' => $session); // Add session ID

  $data = json_encode($json);

  // See if the dummy API is enabled and active
  $result = module_invoke('tripletex_dummy_api', 'tripletex_api_request_call', $headers, $data);

  if (!count($result)) {
    $result = drupal_http_request(
      TRIPLETEX_JSON_URL, array(
        'headers' => $headers,
        'method' => 'POST',
        'data' => $data,
      ));
  }

  $json = json_decode($result->data);
  if (isset($json->id) && $json->id != $request_id) {
    drupal_set_message(t('Wrong id returned! Tripletex API might not be available.'), 'error');
    return NULL;
  }

  if (isset($json->error)) {
    _tripletex_write_error($json->error);
    return NULL; // TODO: Remove for production

  }

  $result = json_decode($result->data);

  return $result->result;

} /* tripletex_api_request() */

/**
 * Create a new customer with Tripletex accounting system.
 *
 * @return array containing the customer ID
 */
function tripletex_save_customer($params, &$session) {

  $customer = tripletex_create_customer($params);

  $customerId = tripletex_api_request('Company.saveCustomerVendor', array_values($customer), $session);
  // Expected to return {"id":1,"result":279128} where result is customer ID

  $customers = tripletex_search_customer($customer['name'], true);
  if (count($customers) == 1) {
  	$customer = tripletex_create_customer(array_merge($customer, (array)array_shift($customers)));
  }
  else if (count($customers) > 1) {
  	foreach ($customers as $c) {
  	  if ($c->postalcode == $customer['postalNumber']) {
  	    return tripletex_create_customer((array)$c);
   	  }
  	}
  }

  return $customer;

} /* tripletex_save_customer() */

/**
 * Log in to Tripletex and update payment status on all invoices not closed
 *
 */
function tripletex_check_payment() {

  $session = tripletex_login();

  $invoice_nos = _tripletex_get_open_invoices(); // Get all invoices from log where there is outstanding amount

  $result = array();

  if (!empty($invoice_nos) && $session) {
    foreach ($invoice_nos as $id) {
      $balance = _tripletex_get_outstanding_balance($id, $session);
      _tripletex_update_invoice_balance($id, $balance);
      $result[$id] = $balance;

      // Call hooks to handle invoices that are updated and not entirely settled before this call
      module_invoke_all('tripletex_invoice_update', $id);
    }
  }

  return $result;

}

/**
 * Function returns the currencies available by the Tripletex module
 *
 * @return multitype:string  Array of currency codes
 */
function tripletex_currencies() {

  return array(
    'DKK', // Danish Krone.
    'EUR', // Euro.
    'NOK', // Norwegian Krone.
    'GBP', // Pound Sterling.
    'SEK', // Swedish Krona.
    'CHF', // Swiss Franc.
    'USD', // U.S. Dollar.
  );
}

/**
 * Returns a list of the predefined payment types accepted by Tripletex
 * Implements issue #1466078: Create paid invoices
 *
 * @return array
 *   List of payment types keyed by the payment type kode
 *   XXXX are to be understood as wildcard and is not a kode in it self, but any 4-digit account number for accounting
 */
function tripletex_payment_types($types = array()) {
  /**
   * Payment type
   * Tripletex supports multiple invoice payment types e.g. cash, credit card, bank debit card. A
   * payment type is mapped to an account (1900, 1920 etc.) or a customer. When a new payment
   * type is referred to, the payment rule will be created on the fly. The following payment types
   * are defined:
   *   KONTANT. Account 1900.
   *   BANK. Account 1920
   *   KLARNA. Customer “Klarna”.
   *   POSTEN. Customer “Posten”.
   *   TELLER. Customer “Teller”.
   *   PAYPAL. Customer “Paypal”.
   *   DIBS. Customer “DIBS”.
   *   VISA. Customer “Visa”.
   *   KORT. Customer “Kortselskap”.
   *   XXXX (account number). Account XXXX.
   *   XYZ (any name). Customer “XYZ”
   *
   */

  $default_types = array(
    'KONTANT' => 'KONTANT. Account 1900',
    'BANK' => 'BANK. Account 1920',
    'KLARNA' => 'KLARNA. Customer “Klarna”',
    'POSTEN' => 'POSTEN. Customer “Posten”.',
    'TELLER' => 'TELLER. Customer “Teller”.',
    'PAYPAL' => 'PAYPAL. Customer “Paypal”.',
    'DIBS' => 'DIBS. Customer “DIBS”.',
    'VISA' => 'VISA. Customer “Visa”.',
    'KORT' => 'KORT. Customer “Kortselskap”.',
    'XXXX' => 'XXXX (account number). Account XXXX.',
    'XYZ' => 'XYZ (any name). Customer “XYZ”',
  );

  $payment_types = variable_get('tripletex_payment_codes', $default_types);

  if (!empty($types)) {
    $payment_types = $types + $payment_types;  // Union of arrays. Left array is kept where the right has same key
    variable_set('tripletex_payment_codes', $payment_types);
//    drupal_set_message('payment_types: <pre>' . print_r($payment_types, TRUE) . '</pre>');
  }
  return $payment_types;
}

/**
 * Implements hook_cron().
 *
 */
function tripletex_cron() {

  // Do stuff to check frequently


  // Check for payment updates on logged invoices

  tripletex_check_payment();

}

/**
 * Implements hook_views_api().
 * Tell views that there is an integration here
 *
 * @return multitype:number string
 */
function tripletex_views_api() {
  return array('api' => 2.0, 'path' => drupal_get_path('module', 'tripletex') . '/views');
}


//---------------------------------------------------------------------------------
// *** Helper functions ***


/**
 * Retrieves the outstanding balance on a given invoice via Tripletex API
 *
 * @param int $invoice_no:  Invoice id
 * @param string $session:  Session id to use
 *
 * @return float:  amount still remaining to be paid according to the Tripletex status
 */
function _tripletex_get_outstanding_balance($invoice_no, $session) {

  return tripletex_api_request('Invoice.getHistoryAmountCurrencyOutstanding', array($invoice_no), $session);
}

/**
 * Get Tripletex Session ID from cookiestring
 *
 * @param str $cookiestring  String containing the session id
 */
function _tripletex_get_session_id($cookiestring) {

  $cookie = explode(',', $cookiestring);  // Get session ID
  if (count($cookie) > 1) {        // If there are more entries in cookiestring
    $cookie = $cookie[1];          // Get second occurrence
  }
  else {
    $cookie = $cookie[0];
  }

  $cookie = explode(';', $cookie);      // Filter out the session ID

  return $cookie[0];

}

/**
 * Write out the error message from Tripletex API to message area and watchdog.
 *
 * @param object $error   Error object as returned from Tripletex API
 */
function _tripletex_write_error($error) {
  $params = array(
    '@code' => $error->code,
    '@msg' => check_plain($error->msg),
    '@class' => isset($error->javaClass)?$error->javaClass:'',
  );

  $message = "Tripletex Error code @code : @msg (@class)";

  drupal_set_message(t(check_plain($message), $params), 'error');
  watchdog('Tripletex', $message,  $params, WATCHDOG_ERROR);

}

/**
 * Post status message to watchdog and status area
 *
 * @param string $string
 *   Message string to be written
 * @param array $params
 *   Parameters to the message string
 */
function _tripletex_set_message($string, $params) {

  watchdog('Tripletex', $string, $params);
  drupal_set_message(t($string, $params));
}

/**
 * Add an invoice entry to the invoice table list
 *
 * @param invoice structure $invoice
 *     'Customer-name':  Required name of invoice receipient
 *     'Unit-price':     Required unit price of item.
 *     'Customer-email': Required E-mail address to customer
 *     'Count':          Opional number of items. Defaults to 1
 *     'Currency-code':  Currency code of the order line items. NOK default but may be USD, SEK, DKK etc.
 *
 * @param int $nid
 *   Node id of form where the invoice is created from if exists.
 * @param int $uid
 *   If not specified, current user is used, otherwise user id expected
 * @param float $invoice_total
 *   The bottom amount on the invoice. If no value, the function tries
 *   to calculate the value
 *
 * @return int:
 *   Last inserted invoice id if any. NULL otherwise
 */
function _tripletex_add_invoice_log($invoice, $nid = 0, $uid = NULL, $invoice_total = NULL) {

  global $user;

  if (!$invoice_total) {
    // Issue #1553410 by stenjo: Invoice total is incorrect in confirmation message
    $invoice_total = $invoice['Unit-price']*$invoice['Count'];
  }

  if ($uid == NULL) {
    $uid = $user->uid;
  }

  $values = array(
    'nid'       => $nid,
    'uid'       => $uid,
    'mail'      => $invoice['Customer-email'],
    'name'      => $invoice['Customer-name'],
    'currency'  => $invoice['Currency-code'],
    'total_amount' => $invoice_total,
    'remaining_amount' => $invoice_total - $invoice['Paid-amount'],
  );

  $informat = '%Y-%m-%d'; // Format in invoice structure is 2012-02-23

  $ftime = strptime($invoice['Invoice-date'], $informat);
  $values['invoice_date'] = time();  // Use now for invoice time as we are creating it right now

  $ftime = strptime($invoice['Due-date'], $informat);
  $values['due_date'] = mktime(
    $ftime['tm_hour'],
    $ftime['tm_min'],
    $ftime['tm_sec'],
    1,
    $ftime['tm_yday'] + 1,
    $ftime['tm_year'] + 1900
    );

  if (!_tripletex_get_invoice_num()) { // If no invoices there from before and start value is set
    $start_value = variable_get('tripletex_invoice_start_number', TRIPLETEX_DEFAULT_INVOICE_RANGE_START);
    $start_value = (int)$start_value; // Make sure it's an integer

    // Build the query string and run it
    $sql = "ALTER TABLE {tripletex_invoice} AUTO_INCREMENT = $start_value";
    db_query($sql);
  }

  $result = drupal_write_record('tripletex_invoice', $values);
  $id = $values['id'];

  _tripletex_set_message('Invoice no @id created for @name. Total of @currency @amount',
    array(
      '@id' => $id,
      '@name' => $values['name'],
      '@currency' => $values['currency'],
      '@amount' => number_format($values['total_amount'], 2, ',', '.'),
    )
  );

  if ($result) {
    return $id;
  }
  else {
    return '';
  }

}

/**
 * Loads an invoice from the database given by the invoice id
 *
 * @param int $iid
 *   Invoice id to retrieve
 */
function _tripletex_load_invoice($iid) {

  return db_select('tripletex_invoice', 'ti')->fields('ti')->condition('ti.id', $iid)->execute()->fetchObject();
}

/**
 * Update the invoice record with a new balance amount
 *
 * @param int $invoice_id
 * @param float $balance
 * @return string:  Last updated record
 */
function _tripletex_update_invoice_balance($invoice_id, $balance) {

  $values = array('remaining_amount' => $balance);
  $result = '';

  if (_tripletex_get_invoice_balance($invoice_id)) { // If the existing balance is non-zero
    if ($balance == 0) { // And the balance to be set is 0
      $values['settled_date'] = mktime(); // Update settled date

      db_update('tripletex_invoice')
        ->fields(array(
          'settled_date' => mktime(),
          ))
        ->condition('id', $invoice_id)
        ->execute();

      if ( module_exists('rules') ) {
        rules_invoke_event('tripletex_invoice_paid', _tripletex_load_invoice($invoice_id)); // Signal event that invoice is paid

      }
    }
    else {
      db_update('tripletex_invoice')
        ->fields(array(
          'settled_date' => 0,
          ))
        ->condition('id', $invoice_id)
        ->execute();
    }

    db_update('tripletex_invoice')
      ->fields(array(
          'remaining_amount' => $balance,
        ))
      ->condition('id', $invoice_id)
      ->execute();

    if ( module_exists('rules') ) {
      rules_invoke_event('tripletex_invoice_updated', _tripletex_load_invoice($invoice_id)); // Signal event that invoice is updated

    }
  }
  else { // Existing balance is zero
    if ($balance) {
      db_update('tripletex_invoice')
        ->fields(array(
              'settled_date' => 0,
            ))
        ->condition('id', $invoice_id)
        ->execute();
            db_update('tripletex_invoice')
        ->fields(array(
              'remaining_amount' => $balance,
            ))
        ->condition('id', $invoice_id)
        ->execute();

      if ( module_exists('rules') ) {
        rules_invoke_event('tripletex_invoice_updated', _tripletex_load_invoice($invoice_id)); // Signal event that invoice is updated

      }
    }
  }

  if ($result) {
    return $invoice_id;
  }
  else {
    return '';
  }
}

/**
 * Retrieve the logged outstanding invoice amount
 *
 * @param int $invoice_id
 * @return float: Logged outstanding invoice amount
 */
function _tripletex_get_invoice_balance($invoice_id) {

  $result = db_select('tripletex_invoice', 'ti')->condition('ti.id', $invoice_id)->fields('ti', array('remaining_amount'))->execute();

  return $result->fetchField();
}

/**
 * Returns the logged invoices where the remaining amount to be paid is non-zero
 *
 * @return array:  invoice ids of invoices that are not paid
 *
 */
function _tripletex_get_open_invoices() {

  $invoices = db_select('tripletex_invoice', 'ti')->fields('ti')->condition('remaining_amount', 0, '>')->execute()->fetchAllAssoc('id');

  return array_keys($invoices);
}

/**
 * Return keyed by invoice id all invoices as objects
 *
 */
function _tripletex_get_all_invoices() {
  return db_select('tripletex_invoice', 'ti')->fields('ti')->execute()->fetchAllAssoc('id');
}

/**
 * Retrieves the next available invoice number. If there are no entries, returns 0
 *
 */
function _tripletex_get_invoice_num() {

  if (!variable_get('tripletex_handle_own_invoices', FALSE)) {
    return NULL;
  }
  $inv_no = db_query("SELECT MAX(id) FROM {tripletex_invoice}")->fetchField();

  if ($inv_no == NULL) {
    return 0;
  }
  else {
    return $inv_no + 1;
  }
}

/**
 * Get invoices based on user id - either email or uid
 *
 * @param int $uid
 *   User id associated with the invoices to fetch
 * @param string $email
 *   Email address associated with the invoices to fetch
 *
 * @return array $invoices
 *   Keyed (by invoice number) array of invoice objects assocoiated with the user or email
 */
function tripletex_get_user_invoices($uid = 0, $email = FALSE) {

  if ($uid) {
    return tripletex_get_invoices(array('uid' => $uid));
  }
  elseif ($email) {
    return tripletex_get_invoices(array('mail' => $email));
  }
  else {

    return array();
  }

}

/**
 * Get invoices attached to a node
 *
 * @param int $nid
 *   Node id of the node to find the invoices
 *
 * @return array $invoices
 *   Keyed (by invoice id) array of invoices attached to the node
 */
function tripletex_get_node_invoices($nid) {

  if (!$nid) {
    return array();
  }
  else {
    return tripletex_get_invoices(array('nid' => $nid));
  }
}

/**
 * Get invoices filtered by params
 * Generic invoice retrieval function that returns an array of invoice objects
 * based on the key=>value pair fields in the passed params array
 *
 * @param array $params
 *   Key=>Value pairs filtering the invoices being searched for
 */
function tripletex_get_invoices($params) {

  $query = array();
  $values = array();

  foreach ($params as $key => $value) {
    if (is_int($value)) {
      $query[] = "$key = %d";
      $values[] = $value;
    }
    elseif (is_string($value)) {
      $query[] = "$key  = '%s'";
      $values[] = $value;
    }
  }

  $result = db_query('SELECT * FROM {tripletex_invoice} ti WHERE ' . implode(' AND ', $query), $values);

  $invoices = array();

  foreach ($result as $row) {
    $invoices[$invoice->id] = $row->id;
  }

  return $invoices;

}
/**
 * Get first invoice that matches params
 *
 * @param array $params
 *   Key=>Value pairs filtering the invoices being searched for
 */
function tripletex_get_invoice($params) {

  return array_shift(tripletex_get_invoices($params));
}

/**
 * Autocomplete products while typing product name
 *
 * @param string $string
 *
 * @return js array
 */
function _tripletex_products_autocomplete($string) {

  $matches = array();

  // Searches the Tripletex account for products matching $string

  $result =  tripletex_search_product($string, TRUE);
  foreach ($result as $key => $obj) {
    // Key in this array is what is left in the field, value is displayed when autocompleting.
    $matches[$obj->name] = check_plain($obj->name);
  }

  // return for JS
  print drupal_json_encode($matches);
  exit();
}

function _tripletex_customer_autocomplete($string) {

  $matches = array();

  // Searches the Tripletex account for products matching $string

  $result =  tripletex_search_customer($string, TRUE);
  foreach ($result as $key => $obj) {
  // Key in this array is what is left in the field, value is displayed when autocompleting
    $matches[$obj->name] = check_plain($obj->name);
  }

  // return for JS
  print drupal_json_encode($matches);
  exit();

}

function _tripletex_products_price_autocomplete($string) {

  $price =  tripletex_search_product('', FALSE, array('priceIncVatCurrency'));

  if (count($price)) {
    $result = array($price['priceIncVatCurrency'] => check_plain($price['priceIncVatCurrency']));
    // return for JS
    print drupal_json_encode($result);
  }
  exit();
}

/**
 * Return json AJAX product details of the first product
 * that matches the passed search string
 *
 * @param string $var
 *   String fragment to search for
 */
function _tripletex_product_details($var) {

  // Search for products using passed search string and return array of objects
  $product =  tripletex_search_product($var, TRUE);

  // Use only the firs product found
  $product = array_shift($product);

  // create a JSON object.
  return drupal_json_output(array('product' => $product));

  exit;

}

/**
 * Helper fuction called by ajax call when on invoice creation page
 * Function returns the customer details for the first customer found
 * when searching the Tripletex API for customers
 *
 * @param string $var
 *   String fragment to search for
 */
function _tripletex_customer_details($var) {

  $customer =  tripletex_search_customer($var, TRUE);

  $customer = array_shift($customer);

  // create a JSON object.
  return drupal_json_output(array('customer' => $customer));

  exit;

}

/**
 * Implements hook_theme().
 * Loads javascript for this modul.
 */
function tripletex_theme() {
  return array(
    'tripletex_javascript' => array(
      'variables' => array(),
    ),
  );
}

/**
 * Implmentation of hook_init()
 * Makes sure the javascript is loaded on page
 */
function tripletex_init() {
  theme('tripletex_javascript');
}

/**
 * Loads the javascript on page
 */
function theme_tripletex_javascript() {
  drupal_add_js(drupal_get_path('module', 'tripletex') . '/tripletex.js');
}

// Get titles for published nodes only.
function _tripletex_get_node_title($nid) {
	return db_result(db_query('SELECT title FROM {node} WHERE nid = %d AND status = 1',$nid));
}

// Get country codes as an array
function _tripletex_country_codes() {
  return array(
    'AD' => 'Andorra',
    'AE' => 'United Arab Emirates',
    'AF' => 'Afghanistan',
    'AG' => 'Antigua and Barbuda',
    'AI' => 'Anguilla',
    'AL' => 'Albania',
    'AM' => 'Armenia',
    'AN' => 'Netherlands Antilles',
    'AO' => 'Angola',
    'AQ' => 'Antarctica',
    'AR' => 'Argentina',
    'AS' => 'American Samoa',
    'AT' => 'Austria',
    'AU' => 'Australia',
    'AW' => 'Aruba',
    'AX' => 'Aland Islands',
    'AZ' => 'Azerbaijan',
    'BA' => 'Bosnia and Herzegovina',
    'BB' => 'Barbados',
    'BD' => 'Bangladesh',
    'BE' => 'Belgium',
    'BF' => 'Burkina Faso',
    'BG' => 'Bulgaria',
    'BH' => 'Bahrain',
    'BI' => 'Burundi',
    'BJ' => 'Benin',
    'BM' => 'Bermuda',
    'BN' => 'Brunei Darussalam',
    'BO' => 'Bolivia',
    'BR' => 'Brazil',
    'BS' => 'Bahamas',
    'BT' => 'Bhutan',
    'BV' => 'Bouvet Island',
    'BW' => 'Botswana',
    'BY' => 'Belarus',
    'BZ' => 'Belize',
    'CA' => 'Canada',
    'CC' => 'Cocos (Keeling) Islands',
    'CD' => 'Democratic Republic of the Congo',
    'CF' => 'Central African Republic',
    'CG' => 'Congo',
    'CH' => 'Switzerland',
    'CI' => 'Cote D\'Ivoire (Ivory Coast)',
    'CK' => 'Cook Islands',
    'CL' => 'Chile',
    'CM' => 'Cameroon',
    'CN' => 'China',
    'CO' => 'Colombia',
    'CR' => 'Costa Rica',
    'CS' => 'Serbia and Montenegro',
    'CU' => 'Cuba',
    'CV' => 'Cape Verde',
    'CX' => 'Christmas Island',
    'CY' => 'Cyprus',
    'CZ' => 'Czech Republic',
    'DE' => 'Germany',
    'DJ' => 'Djibouti',
    'DK' => 'Denmark',
    'DM' => 'Dominica',
    'DO' => 'Dominican Republic',
    'DZ' => 'Algeria',
    'EC' => 'Ecuador',
    'EE' => 'Estonia',
    'EG' => 'Egypt',
    'EH' => 'Western Sahara',
    'ER' => 'Eritrea',
    'ES' => 'Spain',
    'ET' => 'Ethiopia',
    'FI' => 'Finland',
    'FJ' => 'Fiji',
    'FK' => 'Falkland Islands (Malvinas)',
    'FM' => 'Federated States of Micronesia',
    'FO' => 'Faroe Islands',
    'FR' => 'France',
    'FX' => 'France, Metropolitan',
    'GA' => 'Gabon',
    'GB' => 'Great Britain (UK)',
    'GD' => 'Grenada',
    'GE' => 'Georgia',
    'GF' => 'French Guiana',
    'GH' => 'Ghana',
    'GI' => 'Gibraltar',
    'GL' => 'Greenland',
    'GM' => 'Gambia',
    'GN' => 'Guinea',
    'GP' => 'Guadeloupe',
    'GQ' => 'Equatorial Guinea',
    'GR' => 'Greece',
    'GS' => 'S. Georgia and S. Sandwich Islands',
    'GT' => 'Guatemala',
    'GU' => 'Guam',
    'GW' => 'Guinea-Bissau',
    'GY' => 'Guyana',
    'HK' => 'Hong Kong',
    'HM' => 'Heard Island and McDonald Islands',
    'HN' => 'Honduras',
    'HR' => 'Croatia (Hrvatska)',
    'HT' => 'Haiti',
    'HU' => 'Hungary',
    'ID' => 'Indonesia',
    'IE' => 'Ireland',
    'IL' => 'Israel',
    'IN' => 'India',
    'IO' => 'British Indian Ocean Territory',
    'IQ' => 'Iraq',
    'IR' => 'Iran',
    'IS' => 'Iceland',
    'IT' => 'Italy',
    'JM' => 'Jamaica',
    'JO' => 'Jordan',
    'JP' => 'Japan',
    'KE' => 'Kenya',
    'KG' => 'Kyrgyzstan',
    'KH' => 'Cambodia',
    'KI' => 'Kiribati',
    'KM' => 'Comoros',
    'KN' => 'Saint Kitts and Nevis',
    'KP' => 'Korea (North)',
    'KR' => 'Korea (South)',
    'KW' => 'Kuwait',
    'KY' => 'Cayman Islands',
    'KZ' => 'Kazakhstan',
    'LA' => 'Laos',
    'LB' => 'Lebanon',
    'LC' => 'Saint Lucia',
    'LI' => 'Liechtenstein',
    'LK' => 'Sri Lanka',
    'LR' => 'Liberia',
    'LS' => 'Lesotho',
    'LT' => 'Lithuania',
    'LU' => 'Luxembourg',
    'LV' => 'Latvia',
    'LY' => 'Libya',
    'MA' => 'Morocco',
    'MC' => 'Monaco',
    'MD' => 'Moldova',
    'MG' => 'Madagascar',
    'MH' => 'Marshall Islands',
    'MK' => 'Macedonia',
    'ML' => 'Mali',
    'MM' => 'Myanmar',
    'MN' => 'Mongolia',
    'MO' => 'Macao',
    'MP' => 'Northern Mariana Islands',
    'MQ' => 'Martinique',
    'MR' => 'Mauritania',
    'MS' => 'Montserrat',
    'MT' => 'Malta',
    'MU' => 'Mauritius',
    'MV' => 'Maldives',
    'MW' => 'Malawi',
    'MX' => 'Mexico',
    'MY' => 'Malaysia',
    'MZ' => 'Mozambique',
    'NA' => 'Namibia',
    'NC' => 'New Caledonia',
    'NE' => 'Niger',
    'NF' => 'Norfolk Island',
    'NG' => 'Nigeria',
    'NI' => 'Nicaragua',
    'NL' => 'Netherlands',
    'NO' => 'Norway',
    'NP' => 'Nepal',
    'NR' => 'Nauru',
    'NU' => 'Niue',
    'NZ' => 'New Zealand (Aotearoa)',
    'OM' => 'Oman',
    'PA' => 'Panama',
    'PE' => 'Peru',
    'PF' => 'French Polynesia',
    'PG' => 'Papua New Guinea',
    'PH' => 'Philippines',
    'PK' => 'Pakistan',
    'PL' => 'Poland',
    'PM' => 'Saint Pierre and Miquelon',
    'PN' => 'Pitcairn',
    'PR' => 'Puerto Rico',
    'PS' => 'Palestinian Territory',
    'PT' => 'Portugal',
    'PW' => 'Palau',
    'PY' => 'Paraguay',
    'QA' => 'Qatar',
    'RE' => 'Reunion',
    'RO' => 'Romania',
    'RU' => 'Russian Federation',
    'RW' => 'Rwanda',
    'SA' => 'Saudi Arabia',
    'SB' => 'Solomon Islands',
    'SC' => 'Seychelles',
    'SD' => 'Sudan',
    'SE' => 'Sweden',
    'SG' => 'Singapore',
    'SH' => 'Saint Helena',
    'SI' => 'Slovenia',
    'SJ' => 'Svalbard and Jan Mayen',
    'SK' => 'Slovakia',
    'SL' => 'Sierra Leone',
    'SM' => 'San Marino',
    'SN' => 'Senegal',
    'SO' => 'Somalia',
    'SR' => 'Suriname',
    'ST' => 'Sao Tome and Principe',
    'SU' => 'USSR (former)',
    'SV' => 'El Salvador',
    'SY' => 'Syria',
    'SZ' => 'Swaziland',
    'TC' => 'Turks and Caicos Islands',
    'TD' => 'Chad',
    'TF' => 'French Southern Territories',
    'TG' => 'Togo',
    'TH' => 'Thailand',
    'TJ' => 'Tajikistan',
    'TK' => 'Tokelau',
    'TL' => 'Timor-Leste',
    'TM' => 'Turkmenistan',
    'TN' => 'Tunisia',
    'TO' => 'Tonga',
    'TP' => 'East Timor',
    'TR' => 'Turkey',
    'TT' => 'Trinidad and Tobago',
    'TV' => 'Tuvalu',
    'TW' => 'Taiwan',
    'TZ' => 'Tanzania',
    'UA' => 'Ukraine',
    'UG' => 'Uganda',
    'UK' => 'United Kingdom',
    'UM' => 'United States Minor Outlying Islands',
    'US' => 'United States',
    'UY' => 'Uruguay',
    'UZ' => 'Uzbekistan',
    'VA' => 'Vatican City State (Holy See)',
    'VC' => 'Saint Vincent and the Grenadines',
    'VE' => 'Venezuela',
    'VG' => 'Virgin Islands (British)',
    'VI' => 'Virgin Islands (U.S.)',
    'VN' => 'Viet Nam',
    'VU' => 'Vanuatu',
    'WF' => 'Wallis and Futuna',
    'WS' => 'Samoa',
    'YE' => 'Yemen',
    'YT' => 'Mayotte',
    'YU' => 'Yugoslavia (former)',
    'ZA' => 'South Africa',
    'ZM' => 'Zambia',
    'ZR' => 'Zaire (former)',
    'ZW' => 'Zimbabwe',
  );
}
