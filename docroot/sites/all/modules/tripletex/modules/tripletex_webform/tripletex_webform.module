<?php
/**
* @file: Webform integration module
*   Provides an integration between the webform module and the Tripletex module
*   so that invoices can be created using data entered in webform.
*/

/**
* Respond to a Webform submission being inserted.
*
* Note that this hook is called after a submission has already been saved to
* the database. If needing to modify the submission prior to insertion, use
* hook_webform_submission_presave().
*
* @param $node
*   The Webform node on which this submission was made.
* @param $submission
*   The Webform submission that was just inserted into the database.
*/
function tripletex_webform_webform_submission_insert($node, $submission) {
  $invoice_cid = $node->tripletex_webform_cid;
  $invoice_comp = $node->webform['components'][$invoice_cid];
  $data = $submission->data;

  $price = $invoice_comp['extra']['price_components'];
  $other = $invoice_comp['extra']['other_components'];
  $components = $node->webform['components'];

  $customer = array(
    'first_name'	=>  ($other['first_name']?$data[$other['first_name']]['0']:''),  //if there is a first_name CID return the data for it
  	'last_name'	  =>  ($other['last_name']?$data[$other['last_name']]['0']:''),    //if there is a last_name CID return the data for it
    'street1'			=>  (is_integer($other['street1'])?$data[$other['street1']]['value']['0']:''),
    'street2'			=>  ($other['street1'] != $other['street2']?(is_integer($other['street2'])?$data[$other['street2']]['value']['0']:''):''),
    'zip'					=>  (is_integer($other['zip'])?$data[$other['zip']]['value']['0']:''),
    'city'				=>  (is_integer($other['city'])?$data[$other['city']]['value']['0']:''),
    'mail'				=>  ($other['mail']?$data[$other['mail']]['0']:''),              //if there is an email CID return the data for it
  );

  $extra = array('nid' => $node->nid, 'uid' => $submission->uid);
  $products = array();
//dvm($submission);
  $order_lines = array();
  $order_line = array('Invoice-number' => NULL);
//  dvm($price);

  foreach($price as $cid => $comp) {
    if ($comp) {      // If this is a component with a price, Add item to invoice

      $items = array();    // Create an array with value=>description maps
      $details = explode("\n", $components[$cid]['extra']['items']);  // Get all the options from string "200|Expensive\n30|Cheap" -> array('200|Expensive', '30|Cheap')
      foreach ($details as $detail) {
        list($value, $description) = explode("|", $detail);
        $items[$value] = $description;  // Results in array(200=>"Expensive", 30=>"Cheap")
      }

      $value = array_shift($data[$cid]);
      while ($value != NULL) {  // While there are selected options (may have multiple)
        $products[] = array(                              // Add product to the produc list
            'unit_price'   => $value,                     // Get the first item off the data array (should also be the only one)
            'option_name'  => $items[$value],             // Price component option description
            'name'         => $components[$cid]['name'],  // Price component name
            'count'        => '1',
        );
        $value = array_shift($data[$cid]);
      }
    }
  }

  $invoice_no = tripletex_webform_send_invoice($customer, $products, $extra);
//dvm($invoice_no,'invoice_no');
  if (is_integer($invoice_no)) {
    // Save invoice with the submission data
    $values = array(
      'nid' 	=>  $node->nid,
      'sid'		=>  $submission->sid,
      'cid'		=>  $invoice_cid,
      'no'		=>  'invid',
      'data'	=>  $invoice_no,
    );
    $result = drupal_write_record('webform_submitted_data', $values);
  }
}

/**
 * Define components to Webform.
 *
 * @return
 *   An array of components, keyed by machine name. Required properties are
 *   "label" and "description". The "features" array defines which capabilities
 *   the component has, such as being displayed in e-mails or csv downloads.
 *   A component like "markup" for example would not show in these locations.
 *   The possible features of a component include:
 *
 *     - csv
 *     - email
 *     - email_address
 *     - email_name
 *     - required
 *     - conditional
 *     - spam_analysis
 *     - group
 *
 *   Note that most of these features do not indicate the default state, but
 *   determine if the component can have this property at all. Setting
 *   "required" to TRUE does not mean that a component's fields will always be
 *   required, but instead give the option to the administrator to choose the
 *   requiredness. See the example implementation for details on how these
 *   features may be set.
 *
 *   An optional "file" may be specified to be loaded when the component is
 *   needed. A set of callbacks will be established based on the name of the
 *   component. All components follow the pattern:
 *
 *   _webform_[callback]_[component]
 *
 *   Where [component] is the name of the key of the component and [callback] is
 *   any of the following:
 *
 *     - defaults
 *     - edit
 *     - render
 *     - display
 *     - submit
 *     - delete
 *     - help
 *     - theme
 *     - analysis
 *     - table
 *     - csv_headers
 *     - csv_data
 *
 * See the sample component implementation for details on each one of these
 * callbacks.
 *
 * @see webform_components()
 */
 function tripletex_webform_webform_component_info() {
  $components = array();

  $components['invoice'] = array(
    'label' => t('Invoice'),
    'description' => t('Invoice generated on submission.'),
    'features' => array(

      // This component has a title that can be displayed inline.
      'title_inline' => FALSE,

      // If this component can be used as a conditional SOURCE. All components
      // may always be displayed conditionally, regardless of this setting.
      // Defaults to TRUE.
      'conditional' => FALSE,

      // This component has a title that can be toggled as displayed or not.
      'title_display' => TRUE,

  ),
    'file' => 'tripletex_webform.component.inc',
  );

  return $components;
}

/**
 * Alter the list of available Webform components.
 *
 * @param $components
 *   A list of existing components as defined by hook_webform_component_info().
 *
 * @see hook_webform_component_info()
 */
 function tripletex_webform_webform_component_info_alter(&$components) {
  // Allow components of these types to be used as a price field.
  $components['textfield']['features']['price'] = TRUE;
  $components['select']['features']['price'] = TRUE;
  $components['hidden']['features']['price'] = TRUE;
 }


/**
 * Implements hook_node_load().
 */
function tripletex_webform_node_load($nodes, $types) {

  $result = db_query('SELECT nid, cid FROM {webform_component} WHERE nid IN(:nids) AND type IN(:types)', array(':nids' => array_keys($nodes), ':types' => array('invoice')));

  foreach ($result as $record) {
    $nodes[$record->nid]->tripletex_webform_cid = $record->cid;
  }

}

/**
 * Implements hook_form_alter().
 */
function tripletex_webform_form_alter(&$form, &$form_state, $form_id) {

  if (preg_match('/^webform_client_form_\d+$/', $form_id) && isset($form['#node']->tripletex_webform_cid)) {

    $node = $form['#node'];
    if (empty($node->tripletex_webform_cid)) {
      return;
    }
    $invoice_cid = $node->tripletex_webform_cid;
    $component = $node->webform['components'][$invoice_cid];

    // Check if the pay component is on this page of the webform.
    $parent_keys = webform_component_parent_keys($node, $component);
    $element = $form['submitted'];
    foreach ($parent_keys as $form_key) {
      if (isset($element[$form_key])) {
        $element = $element[$form_key];
      }
      else {
        $element = FALSE;
        break;
      }
    }

    // Initialize the form for the selected payment method.
    if ($element) {
      $form['#pre_render'][] = 'tripletex_webform_prerender';
      $form['#validate'][] = 'tripletex_webform_validate';
      $form['#after_build'][] = 'tripletex_webform_after_build';
    }
  }
}

/**
 * After build function for webform pay fields.
 *
 * Remove the extra fields that are not collected by Pay module directly.
 */
function tripletex_webform_after_build($form) {
  $node = $form['#node'];
  $invoice_cid = $node->tripletex_webform_cid;
  $component = $node->webform['components'][$invoice_cid];

  // If editing a submission, do NOT reprocess payment information. This
  // information becomes display-only.
  if (!empty($form['#submission']->sid)) {
    $submit_index = array_search('invoice_submit', $form['#submit']);
    $validate_index = array_search('invoice_validate', $form['#validate']);
    if ($submit_index !== FALSE) {
      unset($form['#submit'][$submit_index]);
    }
    if ($validate_index !== FALSE) {
      unset($form['#validate'][$validate_index]);
    }
  }

  return $form;
}

/**
 * Pre-render function for webform pay fields.
 *
 * Move the payment form from the form root to the proper component location.
 */
function tripletex_webform_prerender($form) {
  $node = $form['#node'];
  $invoice_cid = $node->tripletex_webform_cid;
  $component = $node->webform['components'][$invoice_cid];

  // Drill down to the element.
  $parent_keys = webform_component_parent_keys($node, $component);
  $element = &$form['submitted'];
  foreach ($parent_keys as $form_key) {
    $element = &$element[$form_key];
  }

  // Pre-render functions may get called twice if theming the form, prevent
  // attempts to move the pay form twice.
  if (!isset($element['#tripletex_webform_moved'])) {
    // Get the pay form information.

    // Prepopulate basic payment information if editing a submission.
    // Payments cannot be charged by editing a submission.
    if (!empty($form['#submission']->sid)) {
      if (!empty($element['#value']['pmid'])) {
        $pmid = $element['#value']['pmid'];
        $value = $element['#value'];
      }
    }

    // Move the pay form from the root level to the appropriate location.
    $element['#tripletex_webform_moved'] = TRUE;
    $element['#value'] = NULL;
  }

  return $form;
}

/**
 * Validation function for webforms that accept payment information.
 *
 * This is responsible for finding all the price fields within the webform and
 * adding up all the totals. Currently either textfields or select lists may
 * be used for prices.
 */
function tripletex_webform_validate(&$form, &$form_state) {
  $node = $form['#node'];
  $invoice_cid = $node->tripletex_webform_cid;
  $component = $node->webform['components'][$invoice_cid];

  // Add up all the components that contain price values.
  $total = NULL;
  foreach ($component['extra']['price_components'] as $cid => $enabled) {
    if ($enabled && isset($node->webform['components'][$cid])) {
      $price_component = $node->webform['components'][$cid];

      // Find the price value if on the current page.
      $price_value = _tripletex_webform_component_value($node, $price_component, $form_state['values']['submitted'], TRUE);
      // Find the price value from any previous pages.
      if ($price_value === FALSE && isset($form_state['storage']['submitted'])) {
        $price_value = _tripletex_webform_component_value($node, $price_component, $form_state['storage']['submitted']);
      }
      $price_parents = webform_component_parent_keys($node, $price_component);

      // If the value is an array, add up the values.
      if (is_array($price_value)) {
        $price_value = array_filter($price_value);
        $component_total = 0;
        foreach ($price_value as $sub_value) {
          if (is_numeric($sub_value)) {
            $component_total += $sub_value;
          }
          else {
            // Exit the for loop if we get a non-numeric value in the array.
            // Set the total back to the original value.
            $component_total = $price_value;
            break;
          }
        }
        $price_value = $component_total;
      }
      if (!empty($price_value) && !is_numeric($price_value)) {
        form_set_error('submitted][' . implode('][', $price_parents), t('The value for @name needs to be a valid amount.', array('@name' => $price_component['name'])));
      }
      else {
        $total += (float) $price_value;
      }
    }
  }

  // Loop through extra components and collect their information.
  $other_values = array();
  foreach ($component['extra']['other_components'] as $key => $cid) {
    if (isset($node->webform['components'][$cid])) {
      $other_component = $node->webform['components'][$cid];
      // Find the component value from the current page.
      $other_value = _tripletex_webform_component_value($node, $other_component, $form_state['values']['submitted'], TRUE);
      // Find the component value from any previous pages.
      if ($other_value === FALSE && isset($form_state['storage']['submitted'])) {
        $other_value = _tripletex_webform_component_value($node, $other_component, $form_state['storage']['submitted']);
      }
      // TODO: Find a cleaner way of separating out billing information?
      if (in_array($key, array('street1', 'street2', 'city', 'state', 'zip', 'country', 'phone'))) {
        $other_values['billto'][$key] = $other_value;
      }
      else {
        $other_values[$key] = $other_value;
      }
    }
  }


  // Set the total for the payment. This total is the grand total of all payment
  // systems together. The pay_form class may validate this total.
  $form_state['values']['tripletex']['total'] = $total;

  // Set the total for the payment method. This total is validated by the
  // payment method handler.
  $form_state['values']['tripletex']['pay_method']['invoice']['total'] = $total;
  $form_state['values']['tripletex']['pay_method']['invoice']['pmid'] = 'invoice';

  // Add in extra properties for the payment handler from other components.
  $form_state['values']['tripletex']['pay_method']['invoice'] = array_merge($form_state['values']['tripletex']['pay_method']['invoice'], $other_values);

  // Drill down to the pay form element.
  $parent_keys = webform_component_parent_keys($node, $component);
  $element = &$form['submitted'];
  foreach ($parent_keys as $form_key) {
    $element = &$element[$form_key];
  }

  // Set the component value so that it gets saved into the Webform table.
  form_set_value($element, $form_state['values']['tripletex']['pay_method']['invoice'], $form_state);
}

/**
 * Helper function to return the value of a component if it exists.
 *
 * @param $node
 *   The Webform node.
 * @param $component
 *   The Webform component to check for.
 * @param $values
 *   An array of webform values keyed by component ID.
 * @param $nested_tree
 *   Whether or not this function should treat the $values parameter as a tree.
 *   On same-page validation the form value is in a tree. On multiple page forms
 *   or on submission, the values are flattened by Webform.
 *
 * @return
 *   The submitted value of the component, or FALSE if the component was not
 *   contained in $values.
 */
function _tripletex_webform_component_value($node, $component, $values, $nested_tree = FALSE) {

  $component_value = FALSE;
  if ($nested_tree) {
    $parent_keys = webform_component_parent_keys($node, $component);
    $component_value = $values;
    foreach ($parent_keys as $form_key) {
      if (isset($component_value[$form_key])) {
        $component_value = $component_value[$form_key];
      }
      else {
        $component_value = FALSE;
        break;
      }
    }
  }
  else {
    $cid = $component['cid'];
    $component_value = isset($values[$cid]) ? $values[$cid] : FALSE;
  }

  return $component_value;
}


/**
 * =======================================================================================
 */

/**
* Retrieve Webform component id's for specified field keys from the
* webform_component database table.
*
* @param int $node_id
*   The node id of the Webform node on which this submission was made.
* @param array $field_keys
*   An array of form field keys for which we need component id's.
* @return array
*   A list of component id's in cid sequence.
*/
function tripletex_webform_get_cids($node_id, $field_keys) {
  $cids = db_select('webform_component', 'wc')
    ->fields('wc', array('cid'))
    ->condition('nid', $node_id)
    ->condition('form_key', $field_keys, 'IN')
    ->orderBy('cid')
    ->execute()
    ->fetchCol();
  return $cids;
}

/**
 * Helper function to send an invoice passing the neccessary data. Includes
 * verification that all neccessary fields are present.
 *
 * @param array $customer
 * 		Structured array containing:
 *      'mail'				Customer email	*
        'first_name'	First name			*
        'last_name'		Last name
        'billto' 			Billing address
        'street1'			First street name	*
        'street2'			Second street name
        'city'				City	*
        'state'				State or region
        'zip'					Zip code
        'country'			Country *
        'phone'				Phone number
        (* = required)

 * @param array $products
 *    Sructured array containing all products to be invoiced
 *    array(
 *    	array(
 *    		name,
 *    		count,
 *    		unit_price
 *    	)
 *    )
 *
 *  @param array $extra
 *     node and user id's of connected to the submission causing this invoice.
 */
function tripletex_webform_send_invoice($customer, $products, $extra) {

  return tripletex_add_invoice($customer, $products, $extra);

  $order_lines = array();
  $order_line = array('Invoice-number' => NULL);
  $invoice_no = NULL;

  $order_total = 0;

  // Add user information
  $params = array(
              'Customer-name' =>          trim($customer['first_name'] . ' ' . $customer['last_name']),
              'Customer-address1' =>      trim($customer['street1']),
              'Customer-address2' =>      trim($customer['street2']),
              'Customer-postal-number' => trim($customer['zip']),
              'Customer-city' =>          trim($customer['city']),
              'Customer-email' =>         trim($customer['mail']),
              'Unit-price' =>             '',
              'Order-line-description' => '',
              'Product-name' =>           '',
              'Count' => 									'',
  );

  // Verify neccessary minimums
  if (!trim($params['Customer-name'])) {
    // Need as a minimum a name of the customer
    drupal_set_message(t("Webform invoice: Need a name of the invoice receipient. Invoice not sendt."), 'error');
    return;
  }

  if (!trim($params['Customer-email'])) {
    // Need as a minimum an email of the customer
    drupal_set_message(t("Webform invoice: Need an e-mail of the invoice receipient. Invoice not sendt."), 'error');
    return;
  }

//  dpm($customer, 'customer');    // DEBUG
//  dpm($extra, 'extra');    // DEBUG
//  dpm($products, 'products');

  foreach($products as $product) {
      // Add item to invoice
      $invoice_params = array();

      // See if product already loaded
      $found = tripletex_search_product(trim($product['name']), FALSE, NULL, -1);
      //dpm($found);
      // Add user information
      $params = array_merge($params, array(
              'Unit-price' =>             $product['unit_price'],
              'Order-line-description' => trim($product['option_name']),  //$components[$cid]['name'],  // Price component name
              'Product-name' =>           trim($product['name']),  // Price component name
              'Count' => 									$product['count'],
            )
        );

      //      dpm($params);
      if ($found) {
        // Product already registered
//        unset($params['Order-line-description']);
      }

      $order_line = tripletex_create_invoice_structure($params, $order_line['Invoice-number']);
      $invoice_no = $order_line['Invoice-number'];          // Save the newly created invoice number
      $order_lines[] = implode(';', $order_line) . ";\r\n";
      $order_total += $product['count']*$product['unit_price'];
//  dpm($order_line, 'order_line');
  }

  $session = tripletex_login();
  if (!$session) return NULL;
//  dpm($order_lines, 'order_lines');

  $output = implode('', $order_lines);
//  dpm($output, 'output');
//  return; // Debug
  $result = tripletex_api_request('Invoice.importInvoicesTripletexCSV', $output, $session);
    dpm($result, 'result');

  _tripletex_add_invoice_log($order_line, $extra['nid'], $extra['uid'], $order_total);

  return $invoice_no;  // Return the invoice number created

}


function tripletex_webform_select_options_info() {

  $items = array();

  $items['titles'] = array (
    'title' => t('Tripletex options'),
    'options callback' => '_tripletex_webform_options',
  );

  return $items;

}

function _tripletex_webform_options() {
  $options = array (
    '14d' => '14 days',
    '7d' => '7 days',
    '30d' => '30 days',
  );

  return $options;
}