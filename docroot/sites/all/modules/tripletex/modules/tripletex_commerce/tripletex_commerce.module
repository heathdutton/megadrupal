<?php

/**
 * @file
 * Provides and option of sending electronic invoices to customer
 * for bank payments and payment tracking
 */

/**
* Implements hook_menu().
*
* Menu for this module
*
* @return array
*   An array with this module's menu settings.
*/
function tripletex_commerce_menu() {

  $items = array();

  $items['admin/config/services/tripletex/commerce'] = array(
    'title' => 'Commerce',
    'description' => 'Administer Tripletex commerce Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tripletex_commerce_admin'),
    'access arguments' => array('administer tripletex'),
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

function tripletex_commerce_admin() {
  $form['explanation'] = array(
      '#type' => 'item',
      '#title' => t('Tripletex Commerce integration admin'),
      '#markup' => t('This page enables various settings and synchronisation between Tripletex and this Commerce installation')
  );

  $form['product_sync'] = array(
        '#type' => 'fieldset',
        '#title' => t('Synchronise products from Tripletex'),
        '#description' => t('If there are products defined in Tripletex that you want to keep a copy of here, you can use this feature to copy or update products from Tripletex.')
  );

  $types = commerce_product_types();
  $form['product_sync']['product_type'] = array(
        '#type' => 'select',
        '#title' => t('Product type for product to be imported'),
        '#options' => drupal_map_assoc(array_keys($types)),
        '#default_value' => isset($types['product'])?'product':reset(array_keys($types)),
  );

  $form['product_sync']['product_sync_submit'] = array(
        '#type' => 'submit',
        '#value' => t('Import products'),
        '#submit' => array('tripletex_commerce_product_sync_submit')
  );

/*
  $form['product_creation']['product_creation_submit'] = array(
        '#type' => 'submit',
        '#value' => t('Create product'),
        '#submit' => array('product_example_product_creation_submit')
  );

  $form['customer_sync'] = array(
        '#type' => 'fieldset',
        '#title' => t('Synchronise customers from Tripletex'),
        '#description' => t('If there are customers defined in Tripletex that you want to keep a copy of here, you can use this feature to copy or update products from Tripletex.')
  );
  $form['customer_sync']['customer_creation_submit'] = array(
          '#type' => 'submit',
          '#value' => t('Create customer'),
          '#submit' => array('tripletex_commerce_customer'),
  );

*/
  return $form;

}

/**
 * Implements hook_commerce_payment_method_info().
 * The payment method data structure is as follows:
 *  method_id - string identifying the payment method, lowercase using alphanumerics, -, and _
 *  base - string used as the base for the magically constructed callback names, each of which
 *    will be defaulted to [base]_[callback] unless explicitly set; defaults to the method_id
 *  title - the translatable full title of the payment method, used in administrative interfaces
 *  display_title - the title to display on forms where the payment method is selected and may
 *    include HTML for methods that require images and special descriptions; defaults to the title
 *  short_title - an abbreviated title that may simply include the payment provider’s name as it
 *    makes sense to the customer (i.e. you would display PayPal, not PayPal WPS to a customer);
 *    also defaults to the title
 *  description - a translatable description of the payment method, including the nature of the
 *    payment and the payment gateway that actually captures the payment
 *  active - TRUE of FALSE indicating whether or not the default payment method rule
 *    configuration for this payment method should be enabled by default
 *  terminal - TRUE or FALSE indicating whether or not payments can be processed via this payment
 *    method through the administrative payment terminal on an order’s Payment tab
 *  offsite - TRUE or FALSE indicating whether or not the customer must be redirected offsite to
 *    put in their payment information; used specifically by the Off-site payment redirect checkout
 *    pane
 *  offsite_autoredirect - TRUE or FALSE indicating whether or not the customer should be
 *    automatically redirected to an offsite payment site on the payment step of checkout
 *  callbacks - an array of callback function names for the various types of callback required
 *    for all the payment method operations, arguments per callback in parentheses:
 *  settings_form - ($settings = NULL) - returns form elements for the payment method’s settings
 *    form included as part of the payment method’s enabling action in Rules
 *  submit_form - ($payment_method, $pane_values, $checkout_pane, $order) - returns form elements
 *    to collect details from the customer required to process the payment
 *  submit_form_validate - ($payment_method, $pane_form, $pane_values, $order, $form_parents = array())
 *    - validates data inputted via the payment details form elements and returns TRUE or FALSE
 *    indicating whether or not all the data passed validation
 *  submit_form_submit - ($payment_method, $pane_form, $pane_values, $order, $charge) - processes
 *    payment as necessary using data inputted via the payment details form elements on the form,
 *    resulting in the creation of a payment transaction
 *  redirect_form - ($form, &$form_state, $order, $payment_method) - returns form elements that
 *    should be submitted to the redirected payment service; because of the array merge that happens
 *    upon return, the service’s URL that should receive the POST variables should be set in
 *    the #action property of the returned form array
 *  redirect_form_validate - ($order, $payment_method) - upon return from a redirected payment
 *    service, this callback provides the payment method an opportunity to validate any returned
 *    data before proceeding to checkout completion; should return TRUE or FALSE indicating whether
 *    or not the customer should proceed to checkout completion or go back a step in the checkout
 *    process from the payment page
 *  redirect_form_submit - ($order, $payment_method) - upon return from a redirected payment service,
 *    this callback provides the payment method an opportunity to perform any submission functions
 *    necessary before the customer is redirected to checkout completion
 *  file - the filepath of an include file relative to the method's module containing the callback
 *    functions for this method, allowing modules to store payment method code in include files that
 *    only get loaded when necessary (like the menu item file property)
 */
function tripletex_commerce_commerce_payment_method_info() {
  $payment_methods = array();

  $payment_methods['tripletex_commerce'] = array(
    'title' => t('Electronic invoice via Tripletex'),
	'display_title' => t('Electronic invoice'),
    'description' => t('Send and electronic invoice for bank payment. The invoice must be paid and the status of that payment is used when verifying completed status of the order.'),
    'active' => TRUE,
  	'terminal' => TRUE,
  	'callbacks' => array(
	  	'submit_form' => 'tripletex_commerce_submit_form',
	  	'submit_form_validate' => 'tripletex_commerce_submit_form_validate',
  		'submit_form_submit' => 'tripletex_commerce_submit_form_submit',
  		// processes payment as necessary using data inputted via the payment details form elements on the form,
	  	// resulting in the creation of a payment transaction
  		'settings_form' => 'tripletex_commerce_settings_form',
  	),
  );

  return $payment_methods;
}

/**
 * Payment method callback: submit form.
 */
function tripletex_commerce_submit_form($payment_method, $pane_values, $checkout_pane, $order) {
  $form = array();

  $order_user = user_load($order->uid);

  // Merge in values from the order.
  if (!empty($order->data['tripletex_commerce'])) {
    $pane_values += $order->data['tripletex_commerce'];
  }

  $billing = array_shift($order->commerce_customer_billing['und']);  // Get $billing['profile_id'] and load the address
  $customer = commerce_customer_profile_load($billing['profile_id']);
  $receipient = array_shift($customer->commerce_customer_address['und']);

  $name = $receipient['name_line'];
  if (isset($receipient['first_name']) && isset($receipient['last_name'])) {
    $name = $receipient['first_name'] . ' ' . $receipient['last_name'];
  }

  // Merge in default values.
  $pane_values += array(
    'name' => $name,
    'email' => '',
  );

  $form['description'] = array(
  	'#type' => 'fieldset',
  	'#description' => t('An invoice will be sent to you via e-mail. To settle payment for this order you will have to pay the outstanding amount according to the information stated in the invoice within the due date. If you fail to do so, the purchase is invalid and the products sold will be revoked or legal process might be initiatet.'),
  );

  $form['name'] = array(
    '#type' => 'textfield',
    '#title' => t('Name'),
    '#description' => t('Enter or change the invoice receipient as needed.'),
    '#default_value' => $pane_values['name'],
    '#required' => TRUE,
  );

  $form['email'] = array(
    '#type' => 'textfield',
    '#title' => t('E-mail'),
    '#description' => t('To what e-mail address should the invoice be sent?'),
    '#default_value' => $order->mail?$order->mail:(isset($order_user)?$order_user->mail:''),
    '#required' => TRUE,
  );

  return $form;
}

/**
 * Payment method callback: submit form validation.
 */
function tripletex_commerce_submit_form_validate($payment_method, $pane_form, $pane_values, $order, $form_parents = array()) {
  // Throw an error if a long enough name was not provided.
  if (strlen($pane_values['name']) < 2) {
    form_set_error(implode('][', array_merge($form_parents, array('name'))), t('You must enter a name two or more characters long.'));

    // Even though the form error is enough to stop the submission of the form,
    // it's not enough to stop it from a Commerce standpoint because of the
    // combined validation / submission going on per-pane in the checkout form.
    return FALSE;
  }


  // Throw an error if the e-mail does not seem to be a valid one.
  if (!valid_email_address($pane_values['email'])) {
    form_set_error(implode('][', array_merge($form_parents, array('email'))), t('The e-mail address you entered does not seem to be a valid one.'));
    return FALSE;
  }

}

/**
 * Payment method callback: submit form submission.
 */
function tripletex_commerce_submit_form_submit($payment_method, $pane_form, $pane_values, $order, $charge) {

  $order->data['tripletex_commerce'] = $pane_values;
  $email = $pane_values['email'];
  if (!$email) {
  	$email = $order->mail;
  }
  return tripletex_commerce_send_invoice($payment_method, $order, $charge, $email);

}


/**
 * Implements hook_field_attach_form().
 *
 * When loading the customer profile information form elements, it should set
 * default values if user is logged in and user has address information.
 *
 */
function tripletex_commerce_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode) {

//	return;
	// Ensure, we're attaching field into right entity type
	if ($entity_type == 'commerce_customer_profile') {


		$langcode = is_null($langcode) ? LANGUAGE_NONE : $langcode;
		$user_array = tripletex_search_customer('', TRUE);
//		$customer_id = tripletex_create_update_customer($params);

		// User must be logged in, so default values can be read
		if (false) {//user_is_logged_in()) {

			// Get user address field which contains default values
			$settings = variable_get('commerce_extra_address_populate_settings', array());
			$user_address_field = isset($settings[$form['#parents'][0]]) ? $settings[$form['#parents'][0]] : '';
			if (!empty($user_address_field)) {
				global $user;
				$user_fields = user_load($user->uid);
				if (isset($user_fields->{$user_address_field}) && !empty($user_fields->{$user_address_field})) {

					// Loop thru user address values and add them as default values
					$langcode = is_null($langcode) ? LANGUAGE_NONE : $langcode;
					foreach ($user_fields->{$user_address_field}[$langcode][0] as $key => $value) {
						if (isset($form['commerce_customer_address'][$langcode][0]['#address'][$key])) {
							$form['commerce_customer_address'][$langcode][0]['#address'][$key] = $value;
						}
					}
				}
			}

		}

	}

}

/**
 * Creates and sends the electronic invoice through the Tripletex API
 *
 * @param $payment_method
 *   The payment method instance object used to charge this payment.
 * @param $order
 *   The order object the payment applies to.
 * @param $charge
 *   An array indicating the amount and currency code to charge.
 * @param $email
 *   The e-mail entered on the submission form.
 */
function tripletex_commerce_send_invoice($payment_method, $order, $charge, $email) {

  global $user;

  if ($payment_method['method_id'] == 'tripletex_commerce') {

  	// Check if this order is already invoiced
  	if ($invoice_id = _tripletex_commerce_get_invoice_mapping($order->order_number)) {
  		// Display error message and return
  		$error = new stdClass;
  		$error->msg = t("Tripletex invoice: This order already invoiced with invoice # @id. Invoice not sendt.",array('@id' => $invoice_id));
  		_tripletex_write_error($error);
  		return $invoice_id;
  	}

    $lang = is_null($order->commerce_customer_billing['#language']) ? LANGUAGE_NONE : $order->commerce_customer_billing['#language'];

    $billing = $order->commerce_customer_billing[$lang][0];  // Get $billing['profile_id'] and load the address
    $total = $order->commerce_order_total[$lang][0];

    $receipient = array();

    if (!$billing) {
      // If no billing address
      $name = $order->data['tripletex_commerce']['name'];
      // Create customer array
      $receipient = tripletex_create_update_customer(array('name' => $name, 'email' => $email));
    }
    else {
	    $cust_profile = commerce_customer_profile_load($billing['profile_id']);
	  	$address = array_shift($cust_profile->commerce_customer_address[$lang]);
	  	$address['email'] = $user->mail;		// User profile e-mail for the customer e-mail
	  	$receipient = tripletex_commerce_map_commerce_customer($address, $email);
    }

    // create product array
    $products = array();

    $lines = $order->commerce_line_items[$lang];  // Array of line item id's
    $total_order_sum = 0.0;

    // TODO: Only the fist order line needs all this information.
    foreach ($lines as $line) {
      if ($product = tripletex_commerce_map_line_item($line, $lang)) {
      	  $products[] = $product;
      	  $total_order_sum += $product['obj']->priceCurrency * (float)$product['count'];
      }
    }

    // Get the order total
    $order_total = (float)($charge['amount'])/100;

    // Get the discounts if any
    $discounts = $order->commerce_discounts[$lang];
    // Handling only one
    if (!empty($discounts) && !empty($products)) {
    	$discount = array_shift($discounts);
    	$discount_object = entity_load_single('commerce_discount', $discount['target_id']);
    	$last_prod = $products[count($products)-1];
    	$currency = $last_prod['obj']->currencyCode;
    	$products[] = tripletex_commerce_map_discount($discount_object, $order_total - $total_order_sum, $currency);
    }

    // Create extra information
    $extra = array(
    	'uid' => $user->uid,
    	'oid' => $order->order_number,
    );

    $invoice_id = tripletex_add_invoice($receipient, $products, $extra);    // Call the API and add the invoice

    // If no problems sending invoice, add to internal log.
    if ($invoice_id) {
    	tripletex_commerce_transaction(
    	  $payment_method,
    	  $order,
    	  $charge,
    	  'Invoice # @invoice sent to: @name (@email)',
    	  array('@name' => $receipient['name'], '@email' => $email, '@invoice' => $invoice_id)
    	);
      _tripletex_commerce_map_order_invoice(array($order->order_id => $invoice_id));
    }

    return $invoice_id;

  }

}
/**
 * Maps commerce customer profile to a tripletex customer structure
 *
 * @param array $commerce_address
 *   Commerce customer billing address structure
 *
 * @param string $customer_email
 *   Invoicing e-mail address. Defaults to empty string
 *
 * @param string $customer_no
 *   Customer identification if used.
 *
 * @return array $customer
 */
function tripletex_commerce_map_commerce_customer($commerce_address, $customer_email = '', $customer_no = '') {

	// Handle name mapping
	$name = '';
	if ($commerce_address['first_name'] || $commerce_address['last_name']) {
		$name = $commerce_address['first_name'] . ' ' . $commerce_address['last_name'];
	}
	else if ($commerce_address['name_line']) {
		$name = $commerce_address['name_line'];
	}

	$commerce_address['customerAccountNumber'] = $customer_no;
	$commerce_address['invoiceEmail'] = $customer_email;

	// Create initial tripletex customer
	$customer = tripletex_create_update_customer(array('name'=>$name, 'address1' => $commerce_address['thoroughfare']));

	// Update fields according to params.
	foreach ($commerce_address as $key => $value) {
		if ($value) {
			switch ($key) {
				case 'customerAccountNumber'  :	$customer['customerAccountNumber'] = trim($value);break;
				case 'invoiceEmail'           :	$customer['invoiceEmail'] = trim($value);break;

				case 'country'                :	$customer['postalCountryCode'] = trim($value);break;
				case 'administrative_area'    :	break;	// Fylke
				case 'sub_administrative_area':	break;	// Kommune
				case 'locality'               :	$customer['postalCity'] = trim($value);break;	// By - poststed
				case 'dependent_locality'     :	break;
				case 'postal_code'            :	$customer['postalNumber'] = trim($value);break;
				case 'thoroughfare'           :	$customer['postalAddress1'] = trim($value);break;
				case 'premise'                :	$customer['postalAddress2'] = trim($value);break;
				case 'sub_premise'            :	break;
				case 'organisation_name'      :	break;
				case 'name_line'              :	break;
				case 'first_name'             :	break;
				case 'last_name'              :	break;
				case 'email'                  :	$customer['email'] = trim($value);break;

				default:	// Unhandled field
					break;
			}
		}
	}

  return $customer;

}

/**
 * Map a commerce product line array to a tripletex product object
 *
 * @param array $line
 * @param string $lang
 * @return multitype:Ambigous <stdClass, NULL> Ambigous <number, NULL, unknown>
 */
function tripletex_commerce_map_line_item($line, $lang) {

  $line_item = commerce_line_item_load($line['line_item_id']);
  if (!is_array($line_item->commerce_product[$lang]) || empty($line_item->commerce_product[$lang])) {
  	return NULL;
  }
  // Load the commerce product
  $commerce_product = array_shift($line_item->commerce_product[$lang]);
  $prod = commerce_product_load($commerce_product['product_id']);
  $unit_price = array_shift($line_item->commerce_unit_price[$lang]);
  // Find product language
  $lang = is_null($prod->language)?LANGUAGE_NONE:$prod->language;

  $fields = array(
	'name'          => $prod->title,
  	'sku'           => $prod->sku,
	'count'         => $line_item->quantity,
	'unit_price'    => (float)($unit_price['amount'])/100,
	'currency_code' => $unit_price['currency_code'],
  );

  $p = tripletex_create_product($fields);
  $product = array('obj' => $p, 'count' => $fields['count']);

  return $product;

}

/**
 * Maps a discount line item onto a Tripletex product structure.
 *
 * @param Object $discount_object	Discount line item structure. Object type
 * @param float $amount	Amount discounted. Must be negative if the amount is subtracted from the total
 * @param String $currency	Typically 'NOK'
 *
 * @return NULL|multitype:Ambigous <number, unknown, NULL> Ambigous <stdClass, NULL>
 */
function tripletex_commerce_map_discount($discount_object, $amount, $currency) {

	if (!$discount_object) return NULL;

	$fields = array(
	  'name'          => $discount_object->component_title,
	  'count'         => 1,
	  'unit_price'    => $amount,
	  'currency_code' => $currency,
	);

	$p = tripletex_create_product($fields);
	$product = array('obj' => $p, 'count' => $fields['count']);

	return $product;

}


/**
 * Creates an successful payment transaction for the specified charge amount.
 *
 * @param $payment_method
 *   The payment method instance object used to charge this payment.
 * @param $order
 *   The order object the payment applies to.
 * @param $charge
 *   An array indicating the amount and currency code to charge.
 * @param $comment
 *   Payment comment
 * @param $params
 *   Array of params to the comment string.
 */
function tripletex_commerce_transaction($payment_method, $order, $charge, $comment, $params) {

  $transaction = commerce_payment_transaction_new('tripletex_commerce', $order->order_id);
  $transaction->instance_id = 'tripletex_commerce';
  $transaction->amount = $charge['amount'];
  $transaction->currency_code = $charge['currency_code'];
  $transaction->remote_id = $params['@invoice'];
  $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
  $transaction->message = $comment;
  $transaction->message_variables = $params;

  commerce_payment_transaction_save($transaction);
}

/**
* Implements hook_tripletex_invoice_update()
* Called when an invoice is updated
*
* @param int $invoice_id
*/
function tripletex_commerce_tripletex_invoice_update($invoice_id) {

  $invoice = _tripletex_load_invoice($invoice_id);
  $order_id = (int) _tripletex_commerce_get_order_mapping($invoice_id);

  if ($order_id && is_int($order_id)) {
    // If there is an Commerce order with this invoice
    $order = commerce_order_load($order_id);
    $method = array_shift(tripletex_commerce_commerce_payment_method_info());

    // Check if already paid if neccessary?
    $balance = commerce_payment_order_balance($order);
    if ($invoice->remaining_amount == 0) {
      // If the order still has a balance - this is now settled
      if ($balance && $balance['amount'] > 0) {
        $charge = array('amount' => $balance['amount'], 'currency_code' => $invoice->currency);
        tripletex_commerce_transaction($method, $order, $charge, t('Invoice #@invoice paid in full via bank.'), array('@invoice' => $invoice_id));
      }
    }
    else {  // Still remaining on this invoice. Check if balance is same
      if ($balance && ($invoice->remaining_amount * 100 < $balance['amount'])) {
        $charge = array('amount' => ($balance['amount'] - ($invoice->remaining_amount * 100)), 'currency_code' => $invoice->currency);
        tripletex_commerce_transaction($method, $order, $charge, t('Invoice #@invoice paid in part via bank.'), array('@invoice' => $invoice_id));
      }
    }
  }
}

/**
 * Product handling
 */

function tripletex_commerce_product_sync_submit($form, &$form_state) {

  $product_type = $form_state['values']['product_type'];
  $result = tripletex_search_product('', TRUE);

  foreach ($result as $prod) {
    tripletex_commerce_product_import($prod, $product_type);
  }

  $products = entity_load('commerce_product');  // Load all products

  foreach ($products as $p) {
    tripletex_commerce_product_export($p, $p->sku);
  }
}

/**
 * Import products from Tripletex account to commerce products
 *
 * Product object structure:
 *   id                  (Integer)   2692603
 *   revision            (Integer)   1
 *   currencyCode        (String)    NOK
 *   vatType             (Integer)   3
 *   name                (String)    Testprodukt
 *   priceCurrency       (Integer)   1000
 *   priceIncVatCurrency (Integer)   1250
 *   number              (String)    1002
 *   cost                (Integer)   400
 *
 * @param object $product_obj	Object received from Tripletex
 * @param string $product_type	Product type category for product to be imported into
 *
 */
function tripletex_commerce_product_import($product_obj, $product_type = '') {

  // Check if product already exists
  if ($prod = commerce_product_load_by_sku($product_obj->number)) {

    // Update product
    $prod->title  = $product_obj->name;
    $prod->cost  = $product_obj->cost;

    $price = array(LANGUAGE_NONE => array(0 => array(
      'amount' => $product_obj->priceIncVatCurrency * 100,
      'currency_code' => $product_obj->currencyCode,
      'data' => array('include_tax' => tripletex_commerce_tax_type_id($product_obj->vatType)),
      'include_tax' => tripletex_commerce_tax_type_id($product_obj->vatType),
    )));
    $form = array();
    $form['#parents'] = array();
    $form_state = array();
    $form_state['values'] = array();
    $form_state['values']['commerce_price'] = $price;

    // Notify field widgets to save their field data
    field_attach_submit('commerce_product', $prod, $form, $form_state);

    commerce_product_save($prod);
    drupal_set_message(t('Product id: !id, SKU: !sku updated!', array('!id' => $prod->product_id, '!sku' => $prod->sku)));

  }
  else {

    $extras = array();
    $extras['status'] = TRUE;
    $extras['uid'] = $GLOBALS['user']->uid;
    $extras['sku'] = $product_obj->number;
    $extras['title'] = $product_obj->name;
    $extras['tax'] = tripletex_commerce_tax_type_id($product_obj->vatType);
    $extras['currency_code'] = $product_obj->currencyCode;
    $extras['cost'] = $product_obj->cost;

    if ($extras['sku']) {
      $id = tripletex_commerce_create_product($product_type, $product_obj->priceIncVatCurrency, $extras);
    }
  }
}

/**
 * Export product defined in Commerce to Tripletex
 *
 * @param object $ep
 *   Product object to export
 */
function tripletex_commerce_product_export($ep, $sku) {

  // As this function is requested once for every product - make static to limit requests
  static $products = NULL;
  // Get all products from Tripletex
  if (!$products) {
    // Return array of objects, no keys and all products (including inactive ones)
    $products = tripletex_search_product('', TRUE, array(), -1);
  }

//  $tp = new stdClass;

  $found = false;
  $tp = tripletex_create_product((array)$ep);
  // Get product with same number
  foreach ($products as $key => $obj) {
    if ($obj->number == $ep->sku && $ep->sku != '') {
    	$found = true;
      break;
    }
  }

  $lang = $ep->language?$ep->language:LANGUAGE_NONE;
  $tp->currencyCode = $ep->commerce_price[$lang][0]['currency_code'];

  // If tax module is loaded and
  if (isset($ep->commerce_price[$lang][0]['data']['include_tax'])) {
    $tax_rates = tripletex_commerce_commerce_tax_rate_info();
    $tp->vatType = $tax_rates[$ep->commerce_price[$lang][0]['data']['include_tax']]['vatType'];
    $tp->priceCurrency = ((float)$ep->commerce_price[$lang][0]['amount']/100) / (1.0 + (float)$tax_rates[$ep->commerce_price[$lang][0]['data']['include_tax']]['rate']);
  }
  $tp->priceIncVatCurrency = $ep->commerce_price[$lang][0]['amount']/100;

  $result = tripletex_api_request('Product.saveProduct', (array)$tp, tripletex_login());
  drupal_set_message(t('Product id: !id, SKU: !sku exported to Tripletex!', array('!id' => $ep->product_id, '!sku' => $ep->sku)));

}


/**
* Create a product programmatically.
*
* This is stolen shamelessly from commerce_bpc. Thanks for the help here!
*
* @param $product_type
*   (string) The name of the product type for which products should be created.
* @param $price
*   Decimal amount of price. If additional fields need to be populated they
*   can be populated in exactly the same way as the commerce_price field.
* @param $extras
*   An array for the values of  'extra fields' defined for the product type
*   entity, or patterns for these. Recognized keys are:
*   - status
*   - uid
*   - sku
*   - title
*   Note that the values do NOT come in the form of complex arrays (as they
*   are not translatable, and can only have single values).
* @return
*   The ID of the created product.
*/
function tripletex_commerce_create_product($product_type, $price, $extras) {
  $form_state = array();
  $form_state['values'] = array();
  $form = array();
  $form['#parents'] = array();

  // Generate a new product object
  $new_product = commerce_product_new($product_type);

  $new_product->status = $extras['status'];
  $new_product->uid = $extras['uid'];
//  $new_product->product_id = $extras['product_id'];   // (String, 0 characters )
//  $new_product->revision_id = $extras['revision_id'];  // (NULL)

  $new_product->sku = $extras['sku'];
  $new_product->title = $extras['title'];
  $new_product->created = $new_product->changed = time();

  $new_product->cost = $extras['cost'];
  //commerce_price[und][0][amount]
  $price = array(LANGUAGE_NONE => array(0 => array(
    'amount' => $price * 100,
    'currency_code' => $extras['currency_code']?$extras['currency_code']:commerce_default_currency(),
    'data' => array('include_tax' => $extras['tax']),
    'include_tax' => $extras['tax'],
  )));
  $form_state['values']['commerce_price'] = $price;

  // Notify field widgets to save their field data
  field_attach_submit('commerce_product', $new_product, $form, $form_state);

  commerce_product_save($new_product);

  drupal_set_message(t('Product id: !id, SKU: !sku created!', array('!id' => $new_product->product_id, '!sku' => $new_product->sku)));

  return $new_product->product_id;
}


/**
* Defines tax types used to categorize tax rates.
*
* @return
*   An array of information about tax types available for use by rates. The
*   returned array should be an associative array of tax type arrays keyed by
*   the tax type name. Each tax type array can include the following keys:
*   - title: the title of the tax type
*   - display_title: a display title for the tax type suitable for presenting
*     to customers if necessary; defaults to the title
*   - description: a short description of the tax type
*   - display_inclusive: boolean indicating whether or not prices containing
*     this tax will include the tax amount in the displayed price; defaults
*     to FALSE
*   - rule: name to use for a default product pricing rule that calculates
*     taxes of this type for line items; defaults to 'commerce_tax_type_[name]'
*     but can be set to NULL to not create any default Rule
*   - admin_list: boolean defined by the Tax UI module determining whether or
*     not the tax type should appear in the admin list
*/
function tripletex_commerce_commerce_tax_type_info() {
  $tax_types = array();

  $tax_types['MVA'] = array(
    'title' => t('MVA'),
    'display_inclusive' => TRUE,
  );

  return $tax_types;
}

/**
 * Mapping function between tax rate codes defined by Tripletex and the actual rate mapping
 *
 * @param string $tripletex_vat_code
 *   The VAT code received from Tripletex
 */
function tripletex_commerce_tax_type_mapping($tripletex_vat_code) {

  switch ($tripletex_vat_code) {
    case '3':
      return (float)(TRIPLETEX_MVA_RATE_3) / 100; // 3: High vat.
    case '31':
      return (float)(TRIPLETEX_MVA_RATE_31) / 100; // 31: Medium vat.
    case '32':
      return (float)(TRIPLETEX_MVA_RATE_32) / 100; // 32: Low vat.
    case '5':
      return (float)(TRIPLETEX_MVA_RATE_5) / 100; // 5: No vat (inside).
    case '6':
      return (float)(TRIPLETEX_MVA_RATE_6) / 100; // 6: No vat (outside).
    default:
      return 0.0;
  }

}

function tripletex_commerce_tax_type_id($tripletex_vat_code) {

  // Get tax type information
  $info = tripletex_commerce_commerce_tax_rate_info();

  foreach ($info as $key => $value) {
    if ($tripletex_vat_code == $value['vatType']) {
      return $key;
    }
  }

  return NULL;

}
/**
 * Defines tax rates that may be applied to line items.
 *
 * @return
 *   An array of information about available tax rates. The returned array
 *   should be an associative array of tax rate arrays keyed by the tax rate
 *   name. Each tax rate array can include the following keys:
 *   - title: the title of the tax rate
 *   - display_title: a display title for the tax type suitable for presenting
 *     to customers if necessary; defaults to the title
 *   - description: a short description of the tax rate
 *   - rate: the percentage used to calculate this tax expressed as a decimal
 *   - type: the name of the tax type this rate belongs to
 *   - rules_component: name of the Rules component (if any) defined for
 *     determining the applicability of the tax to a line item; defaults to
 *     'commerce_tax_rate_[name]'.
 *   - default_rules_component: boolean indicating whether or not the Tax module
 *     should define a default default Rules component using the specified name;
 *     defaults to TRUE.
 *   - price_component: name of the price component defined for this tax rate
 *     used when the tax is added to a line item; if set to FALSE, no price
 *     component will be defined for this tax rate
 *   - admin_list: boolean defined by the Tax UI module determining whether or
 *     not the tax rate should appear in the admin list
 *   - calculation_callback: name of the function used to calculate the tax rate
 *     for a given line item, returning either a tax price array to be added as
 *     a component to the line item's unit price or FALSE to not include
 *     anything; defaults to 'commerce_tax_rate_calculate'.
 */
function tripletex_commerce_commerce_tax_rate_info() {
  $tax_rates = array();

  // TRIPLETEX_MVA_RATE_3; // 3: High vat.
  $tax_rates['MVA_hoy'] = array(
    'title' => t('MVA Høy sats'),
    'description' => t('Merverdiavgift, høy sats - @rate%.', array('@rate' => TRIPLETEX_MVA_RATE_3)),
    'rate' => (float)(TRIPLETEX_MVA_RATE_3)/100,
    'type' => 'MVA',
    'vatType' => '3',
  );

  // TRIPLETEX_MVA_RATE_31; // 31: Medium vat.
  $tax_rates['MVA_medium'] = array(
    'title' => t('MVA Medium sats'),
    'description' => t('Merverdiavgift, medium sats - @rate%. (Matvarer).', array('@rate' => TRIPLETEX_MVA_RATE_31)),
    'rate' => (float)(TRIPLETEX_MVA_RATE_31)/100,
    'type' => 'MVA',
    'vatType' => '31',
  );

  // TRIPLETEX_MVA_RATE_32; // 32: Low vat.
  $tax_rates['MVA_lav'] = array(
    'title' => t('MVA Lav sats'),
    'description' => t('Merverdiavgift, lav sats - @rate%. (Persontransport).', array('@rate' => TRIPLETEX_MVA_RATE_32)),
    'rate' => (float)(TRIPLETEX_MVA_RATE_32)/100,
    'type' => 'MVA',
    'vatType' => '32',
  );

  // TRIPLETEX_MVA_RATE_5; // 5: No vat (inside).
  $tax_rates['MVA_fritt'] = array(
    'title' => t('MVA fritt (inne)'),
    'description' => t('Unntatt merverdiavgift (avgiftsfritt)'),
    'rate' => (float)(TRIPLETEX_MVA_RATE_5)/100,
    'type' => 'MVA',
    'vatType' => '5',
  );

  // TRIPLETEX_MVA_RATE_6; // 6: No vat (outside).
  $tax_rates['MVA_fritt_outside'] = array(
    'title' => t('MVA fritt'),
    'description' => t('Unntatt merverdiavgift (utenfor MVA-loven)'),
    'rate' => (float)(TRIPLETEX_MVA_RATE_6)/100,
    'type' => 'MVA',
    'vatType' => '6',
  );



  return $tax_rates;
}


function tripletex_commerce_customer() {

  $cust = commerce_customer_profile_load(13);

  $form_state = array();
  $form_state['values'] = array();
  $form = array();
  $form['#parents'] = array();

  $profile = commerce_customer_profile_new();

  // Save default parameters back into the $profile object.
  $profile->status = $form_state['values']['status'];

  // Set the profile's owner uid based on the supplied name.
  if (!empty($form_state['values']['name']) && $account = user_load_by_name($form_state['values']['name'])) {
    $profile->uid = $account->uid;
  }
  else {
    $profile->uid = 0;
  }

  $form_state['values']['country'] = 'SE';
  $form_state['values']['administrative_area'] = 'SE';
  $form_state['values']['sub_administrative_area'] = 'SE';
  $form_state['values']['locality'] = 'SE';
  $form_state['values']['dependent_locality'] = 'SE';
  $form_state['values']['postal_code'] = 'SE';
  $form_state['values']['thoroughfare'] = 'SE';
  $form_state['values']['premise'] = 'SE';
  $form_state['values']['sub_premise'] = 'SE';
  $form_state['values']['organisation_name'] = 'SE';
  $form_state['values']['name_line'] = 'SE';
  $form_state['values']['first_name'] = 'SE';
  $form_state['values']['last_name'] = 'SE';

  // Notify field widgets.
  field_attach_submit('commerce_customer_profile', $profile, $form, $form_state);

  // Save the profile.
  commerce_customer_profile_save($profile);
}

/*******************************************************************************************
 * Helper functions
*/


function _tripletex_commerce_get_invoice_mapping($order_id) {

//  $result = db_query("SELECT iid FROM {tripletex_commerce_invoice} WHERE oid = '" . $order_id . "'");
  return db_select('tripletex_commerce_invoice', 't')
    ->fields('t', array('iid'))
    ->condition('t.oid', $order_id)
    ->execute()
    ->fetchField();
}

function _tripletex_commerce_get_order_mapping($invoice_id) {

  //$result = db_query("SELECT oid FROM {tripletex_commerce_invoice} WHERE iid = '" . $invoice_id . "'");
  return db_select('tripletex_commerce_invoice', 't')
    ->fields('t', array('oid'))
    ->condition('t.iid', $invoice_id)
    ->execute()
    ->fetchField();
  }

/**
 * Inserts a Ubercart order id to invoice mapping
 *
 * @param array $map
 *   Set of order (key) to invoice (value) mappings
 */
function _tripletex_commerce_map_order_invoice($map, $nid = 0) {

  $values = array();

  foreach ($map as $key => $value) {
    $values['oid'] = $key;
    $values['iid'] = $value;
    $values['nid'] = $nid;
    drupal_write_record('tripletex_commerce_invoice', $values);
  }
}

