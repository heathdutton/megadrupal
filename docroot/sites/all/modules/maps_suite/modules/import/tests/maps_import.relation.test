<?php

/**
 * @file
 * Tests suite for the MaPS Import relations.
 */

use Drupal\maps_import\Relation\Relation;
use Drupal\maps_import\Mapping\Mapper\Object as ObjectMapper;

/**
 * Performs functional tests on MaPS Import relations.
 *
 * @see DrupalWebTestCase
 */
class MapsImportRelationWebTestCase extends MapsImportWebTestCase {

  /**
   * SimpleTest getInfo.
   * @inheritdoc
   */
  public static function getInfo() {
    return array(
      'name' => 'MaPS Import Relation',
      'description' => 'Tests the relation functionnalities.',
      'group' => MapsSuiteTestInterface::TEST_GROUP,
    );
  }

  /**
   * SimpleTest setUp.
   * @inheritdoc
   */
  public function setUp(array $modules = array(), array $permissions = array()) {
    $modules[] = 'relation';
    $permissions[] = 'access site in maintenance mode';
    parent::setUp($modules, $permissions);
  }

  /**
   * Base init for the following tests.
   */
  protected function init() {
    $return = array();
    $return['profile'] = $this->createProfile();
    $this->createLanguages($return['profile']);
    $return['converter'] = $this->createConverter($return['profile'], 'object');

    return $return;
  }

  /**
   * Test the relation overview.
   */
  public function testOverview() {
    extract($this->init());

    $this->drupalGet("admin/maps-suite/profiles/{$profile->getName()}/object/{$converter->getCid()}/converter_relation");
    $this->assertResponse(200, t('User can access the relation overview tab.'));
    $this->assertRaw(t('There is no relation mapping yet.'));

    $relation_type = $this->createRelationType();
    $relation = $this->createConverterRelation($converter, $relation_type->relation_type);

    $this->drupalGet("admin/maps-suite/profiles/{$profile->getName()}/object/{$converter->getCid()}/converter_relation");
    $this->assertResponse(200, t('User can access the relation overview tab.'));
    $this->assertRaw($relation->getRelationType(), t('Relation found for the relation type %relation_type', array('%relation_type' => $relation->getRelationType())));
    $this->assertLink('endpoints', 0, t('Endpoints link found'));
    $this->assertLink('mapping', 0, t('Mapping link found'));
    $this->assertLink('delete', 0, t('Delete link found'));
  }

  /**
   * Test add form no access.
   * 
   * Test that the user can't reach the relation add form if there is no
   * relation type corresponding with the current converter.
   */
  public function testAddNoAccess() {
    extract($this->init());

    $relation_type = $this->createRelationType();
    $this->drupalGet("admin/maps-suite/profiles/{$profile->getName()}/object/{$converter->getCid()}/converter_relation/add");
    $this->assertRaw(t('No relation available for the converter bundle.'));
  }

  /**
   * Test the relation add form.
   */
  public function testAdd() {
    extract($this->init());

    // Make the relation type available for the current converter.
    $info = array(
      'source_bundles' => array(
        0 => "{$converter->getEntityType()}:*",
      ),
    );
    $relation_type = $this->createRelationType($info);

    $this->drupalGet("admin/maps-suite/profiles/{$profile->getName()}/object/{$converter->getCid()}/converter_relation/add");
    $this->assertResponse(200, t('User can access the relation add form (first step).'));

    // Assert that the relation type select has values.
    $this->assertRaw('<option value="' . $relation_type->relation_type . '">' . $relation_type->relation_type . '</option>');
    $this->drupalPost("admin/maps-suite/profiles/{$profile->getName()}/object/{$converter->getCid()}/converter_relation/add", array('relation_type' => $relation_type->relation_type), t('Continue'));
    $this->assertResponse(200, t('User can submit the relation add form (first step).'));

    $available_endpoints = Relation::getAvailableEndpoints();
    $edit = array();

    for ($i = 0; $i < $relation_type->max_arity; $i++) {
      $this->assertFieldByName("endpoints[$i]");
      $edit["endpoints[$i]"] = array_rand($available_endpoints);
    }

    $this->drupalPost("admin/maps-suite/profiles/{$profile->getName()}/object/{$converter->getCid()}/converter_relation/add/$relation_type->relation_type", $edit, t('Finish'));
    $this->assertResponse(200, t('User can submit the relation add form (last step).'));

    $this->drupalGet("admin/maps-suite/profiles/{$profile->getName()}/object/{$converter->getCid()}/converter_relation");
    $this->assertRaw($relation_type->relation_type);
  }

  /**
   * Test the relation delete form.
   */
  public function testDelete() {
    extract($this->init());

    $relation_type = $this->createRelationType();
    $relation = $this->createConverterRelation($converter, $relation_type->relation_type);

    $this->drupalGet("admin/maps-suite/profiles/{$profile->getName()}/object/{$converter->getCid()}/converter_relation/{$relation->getId()}/delete");
    $this->assertResponse(200, t('User can access the relation delete form.'));

    $this->drupalPost("admin/maps-suite/profiles/{$profile->getName()}/object/{$converter->getCid()}/converter_relation/{$relation->getId()}/delete", array(), t('Delete'));
    $this->assertResponse(200, t('User can submit the relation delete form.'));

    $this->drupalGet("admin/maps-suite/profiles/{$profile->getName()}/object/{$converter->getCid()}/converter_relation");
    $this->assertNoRaw($relation->getRelationType(), t('Relation successfully deleted'));
    $this->assertRaw(t('There is no relation mapping yet.'));

    // @todo Delete generated entities.
  }

  /**
   * Tests the endpoints edition form.
   */
  public function testEndpointsEdit() {
    extract($this->init());

    $relation_type = $this->createRelationType();

    $endpoints = array();
    for ($i = 0; $i < $relation_type->min_arity; $i++) {
      $endpoints[] = array_rand(Relation::getAvailableEndpoints());
    }

    $relation = $this->createConverterRelation($converter, $relation_type->relation_type, $endpoints);

    $this->drupalGet("admin/maps-suite/profiles/{$profile->getName()}/object/{$converter->getCid()}/converter_relation/{$relation->getId()}/endpoints");
    $this->assertResponse(200, t('User can access the endpoints edit form.'));

    $edit = array();
    foreach ($endpoints as $i => $endpoint) {
      $this->assertOptionSelected("edit-endpoints-$i", $endpoint);
      $edit["endpoints[$i]"] = array_rand(Relation::getAvailableEndpoints());
    }

    $this->drupalPost("admin/maps-suite/profiles/{$profile->getName()}/object/{$converter->getCid()}/converter_relation/{$relation->getId()}/endpoints", $edit, t('Edit'));
    $this->assertResponse(200, t('User can submit the endpoints edit form.'));

    $this->drupalGet("admin/maps-suite/profiles/{$profile->getName()}/object/{$converter->getCid()}/converter_relation/{$relation->getId()}/endpoints");
    $index = 0;
    foreach ($edit as $endpoint) {
      $this->assertOptionSelected("edit-endpoints-$index", $endpoint);
      $index++;
    }
  }


  /**
   * Test the relation mapping.
   *
   * We only have to test the access to this form, because it has the same
   * behaviors as the classic mapping form.
   */
  public function testMapping() {
    extract($this->init());

    $relation_type = $this->createRelationType();
    $relation = $this->createConverterRelation($converter, $relation_type->relation_type);

    $this->drupalGet("admin/maps-suite/profiles/{$profile->getName()}/object/{$relation->getMappingConverter()->getCid()}/mapping");
    $this->assertResponse(200, t('User can access the mapping form.'));
    $this->assertRaw(t('There is no defined mapping yet.'));
  }

  /**
   * Test the mapping process.
   */
  public function testMapper() {
    include drupal_get_path('module', 'maps_import') . '/tests/files/maps_import_configuration.php';
    include drupal_get_path('module', 'maps_import') . '/tests/files/maps_import_objects.php';

    variable_set('maintenance_mode', 1);

    extract($this->init());
    $this->initProfileStatuses($profile);

    // For this one, we will use a concret case of use.
    // We want to link products to several categories, which different weights.
    $maps_import_configuration = $maps_import_configuration;
    $maps_import_objects = $maps_import_objects;

    // Define the operations.
    $configuration_fetcher = new MapsImportConfigurationFetcherMock($profile);
    $objects_fetcher = new MapsImportObjectsFetcherMock($profile);

    // Process with objects fetch operation.
    $configuration_fetcher->process();
    $objects_fetcher->process();

    $this->initProfileMediaSettings($profile);

    $category_vocabulary = $this->createVocabulary('vocabulary');
    $flat_product_node_type = $this->createNodeType('flat_product');
    $marketing_product_node_type = $this->createNodeType('marketing_product');
    $product_vocabulary = $this->createVocabulary('product');

    // Create our converters.
    $category_converter = $this->createCategoryConverter($profile, $category_vocabulary->machine_name);
    $flat_product_converter = $this->createFlatProductConverter($profile, $flat_product_node_type);
    $marketing_product_converter = $this->createMarketingProductConverter($profile, $marketing_product_node_type);
    $product_converter = $this->createProductConverter($profile, $product_vocabulary->machine_name);

    // Create the converter relation between Marketing products and Categories.
    $info = array(
      'source_bundles' => array(
        'node:*',
      ),
      'target_bundles' => array(
        'taxonomy_term:*',
      ),
    );
    $relation_type = $this->createRelationType($info);

    // Add a field to the relation type.
    $field = array(
      'field_name' => 'seq',
      'type' => 'number_integer',
      'cardinality' => 1,
    );
    field_create_field($field);
    $instance = array(
      'field_name' => 'seq',
      'entity_type' => 'relation',
      'bundle' => $relation_type->relation_type,
    );
    field_create_instance($instance);

    $endpoints = array(
      'current_entity',
      'property:parent_id',
    );
    $relation = $this->createConverterRelation($marketing_product_converter, $relation_type->relation_type, $endpoints);

    // Add item to the relation mapping.
    $this->createMappingItem($relation->getMappingConverter(), array(
      'property' => 'property:weight',
      'field' => 'seq',
    ));

    $mapper = new ObjectMapper($profile);
    $mapper->process();

    $relations = entity_load('relation');
    $this->assertTrue(count($relations) == 1, t('One relation created.'));

    $created_relation = reset($relations);
    $this->assertTrue($created_relation->relation_type == $relation_type->relation_type, t('Right relation type.'));
    $this->assertTrue(count($created_relation->endpoints['und']) == 2, t('Right count of endpoints.'));
    $this->assertTrue(
      $created_relation->endpoints['und'][0]['entity_type'] == 'node' &&
      $created_relation->endpoints['und'][0]['r_index'] == 0 &&
      $created_relation->endpoints['und'][1]['entity_type'] == 'taxonomy_term' &&
      $created_relation->endpoints['und'][1]['r_index'] == 1
    );

    $id_relation = $created_relation->rid;

    // Re-process the mapping.
    $mapper->process();

    // Assert that there is the same count of relation.
    $relations = entity_load('relation');
    $this->assertTrue(count($relations) == 1, t('One relation created.'));

    // Assert that the old created relation has been replaced by the newest one.
    $created_relation = reset($relations);

    $this->assertFalse($id_relation != $created_relation->rid);
    $this->assertTrue(!empty($created_relation->seq['und'][0]), t('Property weight successfully mapped.'));
  }

}
