<?php

/**
 * @file
 * Tests suite for MaPS Import module.
 */

use Drupal\maps_import\Cache\Data\MappingItems as CacheMappingItems;
use Drupal\maps_import\Converter\ConverterInterface;
use Drupal\maps_import\Mapping\Source\MapsSystem\Attribute\DefaultAttribute;
use Drupal\maps_import\Profile\Profile;
use Drupal\maps_import\Relation\Relation as ConverterRelation;
use Drupal\maps_import\Request\Request;
use Drupal\maps_import\Fetcher\Fetcher;
use Drupal\maps_import\Cache\Object\Profile as CacheProfile;
use Drupal\maps_import\Mapping\Validator\Type as TypeValidator;
use Drupal\maps_import\Mapping\Mapper\Object as ObjectMapper;
use Drupal\maps_import\Mapping\Mapper\Media as MediaMapper;

/**
 * This class exposes some shared methods for extending classes that
 * represents each a specific functionality.
 *
 * @see DrupalWebTestCase
 */
class MapsImportWebTestCase extends \MapsSuiteWebTestCase {

  /**
   * The maximum of converters to create in a same test function.
   */
  const MAX_CONVERTERS = 5;

  /**
   * The converters type.
   */
  protected $converterTypes = array(
    'object' => 'Drupal\\maps_import\\Converter\\Object',
    'media' => 'Drupal\\maps_import\\Converter\\Media',
  );

  /**
   * The converters mock classes.
   */
  protected $converterMock = array(
    'media' => 'MapsImportMediaConverterMock',
  );

  /**
   * The filters operators.
   */
  protected $filterOperators = array(
    'and',
    'or',
  );

  /**
   * The filters condition types.
   */
  protected $conditionTypes = array(
    'object' => array(
      'object_type' => 'Type',
      'object_nature' => 'Nature',
      'class' => 'ObjectClass',
      'config_type' => 'ConfigurationType',
    ),
    'media' => array(
      'media_type' => 'Type',
    ),
  );

  /**
   * SimpleTest setUp.
   * @inheritdoc
   */
  public function setUp(array $modules = array(), array $permissions = array()) {
    $modules[] = 'maps_import';
    parent::setUp($modules, $permissions);
  }

  /**
   * @defgroup MaPS System® content creation.
   * @{
   */

  /**
   * Creates a random profile and store it in the database.
   */
  protected function createProfile() {
    $profile = $this->randomProfileData();
    drupal_write_record('maps_import_profile', $profile);

    // For debugging, we might output the profile structure
    // with $this->verbose()
    // It would only be output if the testing settings has 'verbose' set.
    $this->verbose('Profile created: $profile', array('$profile' => $profile));

    CacheProfile::getInstance()->clearBinCache();
    return maps_import_profile_load($profile->pid);
  }

  /**
   * Create MaPS System® configuration for languages.
   */
  protected function createLanguages(Profile $profile, $number = 4) {
    $languages = parent::createLanguages($profile, $number);
    $id = 0;

    foreach ($languages as $langcode => $title) {
      $save = array(
        'id' => ++$id,
        'code' => drupal_strtoupper($langcode),
        'title' => $title,
        'pid' => $profile->getPid(),
        'type' => 'language',
        'id_language' => 1,
      );
      drupal_write_record('maps_import_configuration', $save);
    }

    return $languages;
  }

  /**
   * Create statuses and write them in database (maps_import_configuration).
   */
  protected function createStatuses($pid) {
    $statuses_code = array(
      1 => 'deleted',
      2 => 'inactive',
      3 => 'active',
      4 => 'published',
    );

    // Create the statuses array.
    $statuses = array();
    foreach ($statuses_code as $id => $status_code) {
      $status = array(
        'code' => $status_code,
        'title' => ucfirst($status_code),
        'pid' => $pid,
        'id' => $id,
        'type' => 'status',
      );

      $statuses[$id] = $status;
      drupal_write_record('maps_import_configuration', $status);
    }

    return $statuses;
  }

  /**
   * Create media types and write them in database (maps_import_configuration).
   */
  protected function createMediaTypes($pid) {
    $maps_types = array(
      1 => 'image',
      2 => 'document',
      3 => 'video',
      4 => 'son',
    );

    $types = array();
    foreach ($maps_types as $id => $maps_type) {
      $record = array(
        'code' => $maps_type,
        'title' => ucfirst($maps_type),
        'pid' => $pid,
        'id' => $id,
        'type' => 'media_type',
        'id_language' => 1,
      );

      $types[$id] = $record;

      // If the media type already exists,
      // we just catch the exception and continue.
      try {
        drupal_write_record('maps_import_configuration', $record);
      }
      catch (\PDOException $e) {
        continue;
      }
    }

    return $types;
  }

  /**
   * Create a random Converter and save it in database.
   *
   * @param Profile $profile
   *   The MaPS profile.
   * @param string $type
   *   The type of converter.
   * @param array $options
   *   An associative array defining some options for the converter:
   *   - entity_type: (optional) The converter entity type.
   *   - bundle: (optional) The converter bundle.
   *   - uid: (optional The unique identifier property ID.
   *   - parent_id: (optional) The parent converter ID.
   *   - options: (optional) An associative array of options.
   *
   * @return ConverterInterface
   *   The newly created converter object.
   */
  protected function createConverter(Profile $profile, $type, array $options = array(), $mock = FALSE) {
    $name = $this->randomName(8);

    $converter = array(
      'pid' => $profile->getPid(),
      'uid_scope' => 1,
      'title' => ucfirst($name),
      'name' => strtolower($name),
      'weight' => rand(-50, 50),
    ) + $options;

    $converter += array(
      'class' => $mock ? $this->converterMock[$type] : $this->converterTypes[$type],
      'entity_type' => $this->randomEntityType($profile, $type),
      'uid' => $this->randomConverterUid($profile, $type),
      'parent_id' => 0,
      'options' => array(),
    );

    $converter += array(
      'bundle' => $this->randomBundle($converter['entity_type']),
    );

    $converter['options'] = serialize($converter['options']);

    $cid = db_insert('maps_import_converter')
      ->fields($converter)
      ->execute();

    return maps_import_converter_load($cid, $profile->getPid());
  }

  /**
   * Create a random Filter operator and save it in database.
   *
   * @param ConverterInterface $converter
   *   The onverter object.
   */
  protected function createFilterOperator(ConverterInterface $converter, $parent_id = 0) {
    $operator = $this->filterOperators[array_rand($this->filterOperators)];

    $filter = array(
      'cid' => $converter->getCid(),
      'parent_id' => $parent_id,
      'type' => $operator,
      'class' => 'Drupal\\maps_import\\Filter\\Condition\\Operator\\Operator' . ucfirst($operator),
    );

    $cid = db_insert('maps_import_converter_conditions')
      ->fields($filter)
      ->execute();

    return maps_import_condition_load($cid, $converter->getProfile()->getPid(), $converter->getCid());
  }

  /**
   * Create a random Filter condition and save it in database.
   *
   * @param Converter $converter
   *   The onverter object.
   */
  protected function createFilterCondition(ConverterInterface $converter, $parent_id = 0, $condition_type = NULL, $criteria = array()) {
    $condition_types = $this->conditionTypes[$converter->getType()];

    if (is_null($condition_type)) {
      $condition_type = array_rand($condition_types);
    }

    $condition_type_class = $condition_types[$condition_type];

    $type = ucfirst($converter->getType());
    $filter = array(
      'cid' => $converter->getCid(),
      'parent_id' => $parent_id,
      'type' => $condition_type,
      'class' => "Drupal\\maps_import\\Filter\\Condition\\Leaf\\$type\\$condition_type_class",
      'extra' => serialize(array(
        'criteria' => $criteria,
        'negate' => NULL,
      )),
    );

    $cid = db_insert('maps_import_converter_conditions')
      ->fields($filter)
      ->execute();

    return maps_import_condition_load($cid, $converter->getProfile()->getPid(), $converter->getCid());
  }

  /**
   * Create a random mapping item and save it in database.
   */
  protected function createMappingItem($converter, $definition = array()) {
    $attributes = $converter->getMapping()->getSourceProperties() + $converter->getMapping()->getSourceAttributes();
    $fields = $converter->getMapping()->getTargetFields();

    $item = array(
      'cid' => $converter->getCid(),
      'property_id' => isset($definition['property']) ? $definition['property'] : array_rand($attributes),
      'field_name' => isset($definition['field']) ? $definition['field'] : array_rand($fields),
      'static' => 0,
      'required' => isset($definition['required']) ? $definition['required'] : 0,
      'weight' => 0,
      'options' => serialize(isset($definition['options']) ? $definition['options'] : array()),
      'type' => isset($definition['type']) ? $definition['type'] : 'object',
    );

    $id = db_insert('maps_import_mapping_item')
      ->fields($item)
      ->execute();

    CacheMappingItems::getInstance()->clearBinCache();

    return $converter->getMapping()->getItem($id);
  }

  /**
   * Create a random library item in {maps_import_libraries} table.
   *
   * @param Profile $profile
   *   The related profile.
   * @param int $attribute
   *   The attribute id.
   * @param int $id
   *   The item id.
   *
   * @return array
   *   An array containing the recorded data.
   */
  protected function createLibraryItem(Profile $profile, $attribute, $id = NULL) {
    if (is_null($id)) {
      $id = rand(1, 100);
    }

    $code = strtoupper($this->randomName(8));

    $library_item = array(
      'pid' => $profile->getPid(),
      'id' => $id,
      'code' => $code,
      'id_attribute' => $attribute,
      'id_language' => 1,
      'value' => ucfirst(strtolower($code)),
    );

    drupal_write_record('maps_import_libraries', $library_item);
    return $library_item;
  }

  /**
   * Create entity entry.
   * 
   * Create entity entry in {maps_import_entities} table,
   * and the corresponding entry in either
   * {maps_import_object_ids} or {maps_import_media_ids}
   *
   * @param int $pid
   *   The profile id.
   * @param int $cid
   *   The converter id.
   * @param string $entity_type
   *   The entity type.
   * @param string $bundle
   *   The entity bundle.
   * @param string $uid
   *   The source object unique ID.
   * @param string $entity_id
   *   The target entity id.
   * @param string $type
   *   The MaPS System® entity type (object or media).
   */
  protected function createEntityEntry($pid, $cid, $entity_type, $bundle, $uid, $entity_id, $type = 'object') {
    $record = array(
      'entity_type' => $entity_type,
      'bundle' => $bundle,
      'uid' => $uid,
      'uid_scope' => 1,
      'entity_id' => $entity_id,
      'id_language' => 1,
      'pid' => $pid,
      'cid' => $cid,
    );

    drupal_write_record('maps_import_entities', $record);
    $id = $record['id'];

    $record = array(
      'maps_id' => $uid,
      'correspondence_id' => $id,
    );

    drupal_write_record('maps_import_' . $type . '_ids', $record);
  }

  /**
   * @} End of "defgroup MaPS System® content creation".
   *
   * @defgroup Random data generation .
   * @{
   */

  /**
   * Generates random data for a profile.
   *
   * @param Profile $pid
   *   If set, the 'pid' property.
   *
   * @return object
   *   A random generated profile.
   */
  protected function randomProfileData($pid = NULL) {
    $max_objects_per_request = Profile::getMaxObjectOptions('request', FALSE, FALSE);
    $max_objects_per_mapping = Profile::getMaxObjectOptions('mapping', FALSE, FALSE);

    $profile = new stdClass();

    if (!is_null($pid)) {
      $profile->pid = $pid;
    }
    $profile->title = $this->randomName(8);
    $profile->name = strtolower($profile->title);
    $profile->token = sha1(microtime());
    $profile->publication_id = rand(1, 1000);
    $profile->root_object_id = rand(1, 1000);
    $profile->preset_group_id = rand(1, 1000);
    $profile->url = $this->randomUrl();
    $profile->media_directory = '';
    $profile->max_objects_per_request = $max_objects_per_request[array_rand($max_objects_per_request)];
    $profile->max_objects_per_op = $max_objects_per_mapping[array_rand($max_objects_per_mapping)];
    $profile->format = Request::FORMAT_XML;
    $profile->enabled = 1;
    $profile->weight = rand(-50, 50);
    $profile->web_template = Fetcher::TEMPLATE_EXPORT_WEB;
    $profile->options = array();

    return $profile;
  }

  /**
   * Generates a random converter uid.
   *
   * @param Profile $profile
   *   The related MaPS System® profile.
   * @param string $type
   *   The converter type.
   *
   * @return string
   *   The generated uid.
   */
  public function randomConverterUid($profile, $type) {
    $uids = array();
    $class = $this->converterTypes[$type];
    $converter = new $class($profile);

    foreach ($converter->getMapping()->getSourceProperties() as $key => $value) {
      $uids[] = $key;
    }

    return $uids[array_rand($uids)];
  }

  /**
   * Generates a random entity type.
   *
   * @return string
   *   The generated entity type.
   */
  public function randomEntityType($profile, $type) {
    $class = $this->converterTypes[$type];
    $converter = new $class($profile);

    $entity_info = $converter->entityInfo();

    // Remove some entity type that may have no defined bundle.
    if (module_exists('relation')) {
      unset($entity_info['relation']);
    }

    return array_rand($entity_info);
  }

  /**
   * Generates a random bundle for the given entity type.
   *
   * @param string $entity_type
   *   The entity type.
   *
   * @return string
   *   The generated bundle.
   */
  public function randomBundle($entity_type) {
    $info_bundles = field_info_bundles($entity_type);
    return array_rand($info_bundles);
  }

  /**
   * Generates a random DefaultAttribute.
   *
   * @param array $definition
   *   The attribute definition.
   *
   * @return DefaultAttribute
   *   The Default Attribute.
   */
  public function randomDefaultAttribute($definition = array()) {
    $param = array();

    // Set random values if necessary.
    $param['id'] = isset($definition['id']) ? $definition['id'] : rand(0, 100);
    $param['title'] = isset($definition['title']) ? $definition['title'] : $this->randomName(8);
    $param['code'] = isset($definition['code']) ? $definition['code'] : $this->randomName(8);
    $param['multiple'] = isset($definition['multiple']) ? $definition['multiple'] : $this->randomName(8);
    $param['localisable'] = isset($definition['localisable']) ? $definition['localisable'] : $this->randomName(8);
    $param['attribute_type_code'] = isset($definition['attribute_type_code']) ? $definition['attribute_type_code'] : $this->randomName(8);

    return new DefaultAttribute($param);
  }

  /**
   * Generates a random DefaultField.
   *
   * @param array $definition
   *   The field definition.
   *
   * @return DefaultField
   *   The Default field.
   */
  public function randomDefaultField($definition = array()) {
    $param = array();

    // Set random values if necessary.
    $param['id'] = isset($definition['id']) ? $definition['id'] : rand(0, 100);
    $param['title'] = isset($definition['title']) ? $definition['title'] : $this->randomName(8);
    $param['translatable'] = isset($definition['translatable']) ? $definition['translatable'] : $this->randomName(8);
    $param['type'] = isset($definition['type']) ? $definition['type'] : $this->randomName(8);

    return new DefaultFieldMock($param);
  }

  /**
   * @} End of "defgroup Random data generation".
   */

  /**
   * Create a new entry in database in {maps_import_configuration} table.
   *
   * @param Profile $profile
   *   The related profile.
   * @param string  $type
   *   The type of configuration data (e.g. attribute).
   * @param int $id
   *   The MaPS System® ID.
   * @param string $code
   *   The MaPS System® object code.
   * @param array $data
   *   Additional data.
   *
   * @return array
   *   An array containing the recorded configuration.
   */
  protected function createConfigurationEntry(Profile $profile, $type, $id = NULL, $code = NULL, $data = array()) {
    if (is_null($code)) {
      $code = strtoupper($this->randomName(8));
    }

    $configuration = array(
      'pid' => $profile->getPid(),
      'type' => $type,
      'id' => isset($id) ? $id : rand(1, 100),
      'code' => $code,
      'id_language' => 1,
      'title' => ucfirst(strtolower($code)),
      'data' => serialize($data),
    );

    drupal_write_record('maps_import_configuration', $configuration);
    return $configuration;
  }

  /**
   * Get a random entry in database in {maps_import_configuration} table.
   *
   * @param Profile $profile
   *   The MaPS Import profile.
   * @param string $type
   *   The configuration item type.
   *
   * @return stdObject
   *   The random row.
   */
  protected function getRandomConfigurationEntry(Profile $profile, $type) {
    $result = db_query('
      SELECT *
      FROM {maps_import_configuration}
      WHERE pid = :pid
      AND type = :type
      ORDER BY RAND()
      LIMIT 1
    ', array(
      ':pid' => $profile->getPid(),
      ':type' => $type,
    ))->fetch();

    return $result;
  }

  /**
   * Initialize the profile statuses.
   *
   * @param Profile $profile
   *   The related profile.
   * @param array $statuses
   *   The statuses.
   */
  protected function initProfileStatuses(Profile $profile, $statuses = NULL) {
    if (is_null($statuses)) {
      $statuses = array(
        1 => array('status' => 0),
        2 => array('status' => 0),
        4 => array('status' => 0),
        8 => array('status' => 1),
      );
    }

    variable_set("maps_import:statuses:{$profile->getPid()}", $statuses);
  }

  /**
   * Initialize the profile media settings.
   *
   * @param Profile $profile
   *   The related profile.
   * @param array $settings
   *   The media types.
   */
  protected function initProfileMediaSettings(Profile $profile, $settings = NULL) {
    if (is_null($settings)) {
      $presets = maps_import_image_presets($profile);
      $media_types = maps_import_get_maps_media_types($profile);
      $settings = array();

      foreach ($media_types as $key => $media_type) {
        $settings[$key] = array(
          'path' => strtolower($media_type) . 's',
          'preset' => array_rand($presets),
        );
      }
    }

    $save = array(
      'pid' => $profile->getPid(),
      'media_directory' => 'simpletest',
      'options' => array('media_settings' => $settings),
    );

    drupal_write_record('maps_import_profile', $save, array('pid'));

    // Create related path.
    foreach ($settings as $media_type) {
      mkdir("public://simpletest/{$media_type['path']}", 0777, TRUE);
    }
  }

  /**
   * Create a random vocabulary.
   */
  protected function createVocabulary($name = NULL) {
    if (is_null($name)) {
      $name = $this->randomName(8) . '_taxonomy';
    }

    $vocabulary = new stdClass();
    $vocabulary->name = $name;
    $vocabulary->machine_name = strtolower($name);

    taxonomy_vocabulary_save($vocabulary);

    return $vocabulary;
  }

  /**
   * Create a random Drupal Relation type.
   */
  protected function createRelationType($info = array()) {
    $name = $this->randomName(8);

    $relation_type = array(
      'disabled' => FALSE,
      'relation_type' => $name,
      'label' => $name,
      'directional' => 1,
      'transitive' => 0,
      'r_unique' => 1,
      'min_arity' => 2,
      'max_arity' => 2,
      'source_bundles' => isset($info['source_bundles']) ? $info['source_bundles'] : array(),
      'target_bundles' => isset($info['target_bundles']) ? $info['target_bundles'] : array(),
    );

    $relation_type = relation_type_create($relation_type);
    relation_type_save($relation_type);

    return $relation_type;
  }

  /**
   * Create a random converter relation.
   */
  protected function createConverterRelation(ConverterInterface $converter, $relation_type = NULL, $endpoints = array()) {
    if (is_null($relation_type)) {
      $relation_types = relation_get_types();
      $relation_type = array_rand($relation_types);
    }

    $relation = new ConverterRelation(array(
      'converter' => $converter,
      'relation_type' => $relation_type,
      'endpoints' => $endpoints,
    ));

    $id = $relation->save();

    // Create the related converter.
    $record = array(
      'pid' => $relation->getConverter()->getProfile()->getPid(),
      'uid' => NULL,
      'uid_scope' => 3,
      'entity_type' => 'relation',
      'bundle' => $relation->getRelationType(),
      'options' => array('relation_id' => $id),
      'class' => 'Drupal\\maps_import\\Converter\\Child\\Relation\\' . ucfirst($relation->getConverter()->getType()),
      'name' => "relation_{$id}",
    );

    drupal_write_record('maps_import_converter', $record);

    $relation->setId($id);

    return $relation;
  }

  /**
   * Create a random node type.
   */
  protected function createNodeType($name = NULL) {
    if (is_null($name)) {
      $name = $this->randomName(8) . '_node';
    }

    $node_type = new stdClass();
    $node_type->type = strtolower($name);
    $node_type->name = $name;

    node_type_save($node_type);

    return $node_type;
  }

  /**
   * Create a library mapping.
   *
   * @param Profile $profile
   *   The related profile.
   * @param object $vocabulary
   *   The vocabulary object.
   * @param array $library
   *   The library array.
   *
   * @return array
   *   The created mapping.
   *   An array with a "vocabulary" and a "library" key.
   */
  protected function createLibraryMapping(Profile $profile, $vocabulary = NULL, $library = NULL) {
    if (is_null($vocabulary)) {
      $vocabulary = $this->createVocabulary();
    }

    if (is_null($library)) {
      $library = $this->createConfigurationEntry($profile, 'attribute', NULL, NULL, array('attribute_type_code' => 'library'));
    }

    // Create some items.
    for ($i = 1; $i <= rand(1, 5); $i++) {
      $this->createLibraryItem($profile, $library['id'], $i);
    }

    // Create the library mapping.
    $record = array(
      'pid' => $profile->getPid(),
      'id_attribute' => $library['id'],
      'vocabulary' => $vocabulary->vid,
    );
    drupal_write_record('maps_import_library_map', $record);

    return array(
      'vocabulary' => $vocabulary,
      'library' => $library,
    );
  }

  /**
   * Get the count of row for the selected table of the database.
   *
   * @param string $table
   *   The name of the table.
   * @param array $conditions
   *   The conditions for the query.
   */
  protected function getCount($table, $conditions = array()) {
    $query = db_select($table, 't')
      ->fields('t');

    if (!empty($conditions)) {
      foreach ($conditions as $field => $condition) {
        $query->condition($field, $condition);
      }
    }

    return $query->execute()->rowCount();
  }

  /**
   * Allow all validators.
   *
   * Submit the validator settings form so that
   * all Drupal Field types are enabled for each MaPS System® type.
   */
  protected function allowAllValidators() {
    $this->drupalGet('admin/maps-suite/settings/fields');
    $this->assertResponse(200, 'User can access the validator settings form.');

    $maps_types = TypeValidator::getMapsTypes();
    foreach ($maps_types as $maps_type) {
      $drupal_types = TypeValidator::getDrupalTypes();

      foreach ($drupal_types as $drupal_type) {
        $edit['types[' . $maps_type . '][validation][]'][] = $drupal_type;
      }
    }

    $this->drupalPost('admin/maps-suite/settings/fields', $edit, t('Save'));
    $this->assertRaw('Fields validation updated.', 'Save succesfull.');
  }

  /**
   * Create category converter.
   * 
   * Private function for creating a vocabulary
   * converter and related filters and mapping items.
   * Its only purpose is to clean the test function.
   */
  protected function createCategoryConverter(Profile $profile, $vocabulary) {
    // Create a taxonomy term converter.
    $category_converter = $this->createConverter($profile, 'object', array(
      'entity_type' => 'taxonomy_term',
      'bundle' => $vocabulary,
      'uid' => 'property:code',
    ));
    $this->createFilterCondition($category_converter, 0, 'object_nature', '2');
    $this->createMappingItem($category_converter, array(
      'property' => 'attribute:1',
      'field' => 'name',
      'required' => 1,
    ));
    $this->createMappingItem($category_converter, array(
      'property' => 'property:parent_id',
      'field' => 'parent',
    ));

    return $category_converter;
  }

  /**
   * Create flat product converter.
   * 
   * Private function for creating a flat product
   * converter and related filters and mapping items.
   * Its only purpose is to clean the test function.
   */
  protected function createFlatProductConverter(Profile $profile, $flat_product_node_type) {
    $field = array(
      'field_name' => 'sku',
      'type' => 'text',
      'cardinality' => 1,
    );
    field_create_field($field);
    $instance = array(
      'field_name' => 'sku',
      'entity_type' => 'taxonomy_term',
      'bundle' => 'product',
    );
    field_create_instance($instance);

    // Create a product reference field for flat products.
    $field = array(
      'field_name' => 'product_reference',
      'type' => 'taxonomy_term_reference',
    );
    field_create_field($field);
    $instance = array(
      'field_name' => 'product_reference',
      'entity_type' => 'node',
      'bundle' => 'flat_product',
    );
    field_create_instance($instance);

    // Create the node converter.
    $flat_product_converter = $this->createConverter($profile, 'object', array(
      'entity_type' => 'node',
      'bundle' => $flat_product_node_type->type,
      'uid' => 'property:code',
    ));
    $this->createFilterCondition($flat_product_converter, 0, 'object_nature', '6');
    $this->createMappingItem($flat_product_converter, array(
      'property' => 'attribute:1',
      'field' => 'title',
      'required' => 1,
    ));

    // Add a related entity mapping.
    $related_entity_converter = $this->createConverter($profile, 'object', array(
      'entity_type' => 'taxonomy_term',
      'bundle' => 'product',
      'parent_id' => $flat_product_converter->getCid(),
      'class' => 'Drupal\\maps_import\\Converter\\Child\\Object',
    ));
    $this->createMappingItem($flat_product_converter, array(
      'property' => $flat_product_converter->getUid() . ':' . $related_entity_converter->getCid(),
      'field' => 'product_reference',
      'options' => array(
        'id' => $related_entity_converter->getCid(),
        'parent_id' => $flat_product_converter->getCid(),
      ),
    ));
    $this->createMappingItem($related_entity_converter, array(
      'property' => 'attribute:1',
      'field' => 'name',
      'required' => 1,
    ));
    $this->createMappingItem($related_entity_converter, array(
      'property' => 'property:parent_id',
      'field' => 'parent',
      'required' => 1,
    ));
    $this->createMappingItem($related_entity_converter, array(
      'property' => 'property:code',
      'field' => 'sku',
    ));

    return $flat_product_converter;
  }

  /**
   * Create marketing product converter.
   * 
   * Private function for creating a marketing product
   * converter and related filters and mapping items.
   * Its only purpose is to clean the test function.
   */
  protected function createMarketingProductConverter(Profile $profile, $marketing_product_node_type) {
    // Create a list of products references field for marketing products.
    $field = array(
      'field_name' => 'products_reference',
      'type' => 'taxonomy_term_reference',
      'cardinality' => FIELD_CARDINALITY_UNLIMITED,
    );
    field_create_field($field);
    $instance = array(
      'field_name' => 'products_reference',
      'entity_type' => 'node',
      'bundle' => 'marketing_product',
    );
    field_create_instance($instance);

    $marketing_product_converter = $this->createConverter($profile, 'object', array(
      'entity_type' => 'node',
      'bundle' => $marketing_product_node_type->type,
      'uid' => 'property:code',
    ));
    $this->createFilterCondition($marketing_product_converter, 0, 'object_nature', '3');
    $this->createMappingItem($marketing_product_converter, array(
      'property' => 'attribute:1',
      'field' => 'title',
      'required' => 1,
    ));

    return $marketing_product_converter;
  }

  /**
   * Create product converter.
   * 
   * Private function for creating a product
   * converter and related filters and mapping items.
   * Its only purpose is to clean the test function.
   */
  protected function createProductConverter(Profile $profile, $bundle) {
    // Create a commerce product converter.
    $product_converter = $this->createConverter($profile, 'object', array(
      'entity_type' => 'taxonomy_term',
      'bundle' => $bundle,
      'uid' => 'property:code',
    ));

    $this->createFilterCondition($product_converter, 0, 'object_nature', '4');
    $this->createMappingItem($product_converter, array(
      'property' => 'attribute:1',
      'field' => 'name',
      'required' => 1,
    ));
    $this->createMappingItem($product_converter, array(
      'property' => 'property:parent_id',
      'field' => 'parent',
    ));
    $this->createMappingItem($product_converter, array(
      'property' => 'property:code',
      'field' => 'sku',
    ));

    // Add a delayed entity mapping.
    $this->createMappingItem($product_converter, array(
      'property' => 'property:parent_id',
      'field' => 'products_reference',
      'options' => array(
        'post_save' => 1,
        'entity_type' => 'node',
        'bundle' => 'marketing_product',
        'update_mode' => 'add',
      ),
    ));

    return $product_converter;
  }

  /**
   * Create image converter.
   * 
   * Private function for creating a marketing product converter.
   * Its only purpose is to clean the test function.
   */
  protected function createImageConverter(Profile $profile) {
    $image_converter = $this->createConverter($profile, 'media', array(
      'entity_type' => 'file',
      'bundle' => 'image',
      'uid' => 'property:id',
    ), TRUE);
    $this->createFilterCondition($image_converter, 0, 'media_type', '1');

    return $image_converter;
  }

  /**
   * Initalize mapping.
   * 
   * Initialize the mapping by launching the import process, creating the
   * converters, ...
   *
   * @param bool $mapper
   *   Whether we have to launch the mapper process.
   *
   * @return array
   *   An array containing all necessaring variables.
   */
  protected function initMapping($mapper = TRUE) {
    include drupal_get_path('module', 'maps_import') . '/tests/files/maps_import_configuration.php';
    include drupal_get_path('module', 'maps_import') . '/tests/files/maps_import_objects.php';

    $return = array();
    $return['maps_import_configuration'] = $maps_import_configuration;
    $return['maps_import_objects'] = $maps_import_objects;

    $profile = $this->createProfile();
    $this->initProfileStatuses($profile);
    $this->createLanguages($profile);

    // Define the operations.
    $return['configuration_fetcher'] = new MapsImportConfigurationFetcherMock($profile);
    $return['objects_fetcher'] = new MapsImportObjectsFetcherMock($profile);

    // Process with objects fetch operation.
    $return['configuration_fetcher']->process();
    $return['objects_fetcher']->process();

    $this->initProfileMediaSettings($profile);

    // Create some Drupal entity types.
    $return['category_vocabulary'] = $this->createVocabulary('vocabulary');
    $return['flat_product_node_type'] = $this->createNodeType('flat_product');
    $return['marketing_product_node_type'] = $this->createNodeType('marketing_product');
    $return['product_vocabulary'] = $this->createVocabulary('product');

    // Create our converters.
    $return['category_converter'] = $this->createCategoryConverter($profile, $return['category_vocabulary']->machine_name);
    $return['flat_product_converter'] = $this->createFlatProductConverter($profile, $return['flat_product_node_type']);
    $return['marketing_product_converter'] = $this->createMarketingProductConverter($profile, $return['marketing_product_node_type']);
    $return['product_converter'] = $this->createProductConverter($profile, $return['product_vocabulary']->machine_name);

    $return['image_converter'] = $this->createImageConverter($profile);

    if ($mapper) {
      // Process with the object mapping operation.
      $return['mapper'] = new ObjectMapper($profile);
      $return['mapper']->process();

      $return['media_mapper'] = new MediaMapper($profile);
      $return['media_mapper']->process();
    }

    $return['profile'] = $profile;

    return $return;
  }


}
