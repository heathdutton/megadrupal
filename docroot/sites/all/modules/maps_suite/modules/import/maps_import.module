<?php

/**
 * @file
 * The MaPS Import module processes the import operations from MaPS System®
 * to Drupal, according to the specified settings.
 */

use Drupal\maps_import\Cache\Data\DrupalFields as CacheDrupalFields;
use Drupal\maps_import\Converter\ConverterInterface;
use Drupal\maps_import\Profile\Profile;
use Drupal\maps_import\Cache\Object\Profile as CacheProfile;
use Drupal\maps_import\Cache\Object\Converter as CacheConverter;
use Drupal\maps_import\Fetcher\Fetcher;
use Drupal\maps_import\Mapping\MappingInterface;
use Drupal\maps_import\Mapping\Source\MapsSystem\Attribute\Library;

/**
 * @defgroup Drupal hooks
 * @{
 */

/**
 * Implements hook_entity_delete().
 */
function maps_import_entity_delete($entity, $type) {
  $info = entity_get_info($type);
  list($id) = entity_extract_ids($type, $entity);

  $condition = db_and()
    ->condition('entity_type', $type)
    ->condition('entity_id', $id);

  $correpondence_ids = array();
  $result = db_select(MappingInterface::DB_ENTITIES_TABLE)
    ->fields(MappingInterface::DB_ENTITIES_TABLE, array(
      'id',
      'entity_id',
      'entity_type',
      'pid',
      'cid',
      'uid',
    ))
    ->condition($condition)
    ->execute();

  while ($row = $result->fetch()) {
    $correpondence_ids[] = $row->id;

    if ($row->entity_type === 'taxonomy_term') {
      db_delete('maps_import_library_index')
        ->condition('pid', $row->pid)
        ->condition('tid', $row->entity_id)
        ->execute();
    }

    // Get child cids in order to delete child products.
    $cid = $row->cid;
    $cids = db_select('maps_import_converter')
      ->fields('maps_import_converter', array(
        'cid',
        ))
      ->condition('parent_id', $cid)
      ->execute()
      ->fetchCol();

    // Remove child entities of each converter.
    foreach ($cids as $child_cid) {
      // Get objects linked in this converter.
      $res_entity_ids = db_select(MappingInterface::DB_ENTITIES_TABLE)
        ->fields(MappingInterface::DB_ENTITIES_TABLE, array(
          'entity_id',
          'entity_type',
        ))
        ->condition('cid', $child_cid)
        ->condition('uid', $row->uid)
        ->execute();

      // Delete child entities.
      while($e = $res_entity_ids->fetch()) {
        entity_delete($e->entity_type, $e->entity_id);
      }
    }
  }

  if ($correpondence_ids) {
    // Delete in entities table.
    db_delete(MappingInterface::DB_ENTITIES_TABLE)
      ->condition($condition)
      ->execute();

    $condition = db_and()->condition('correspondence_id', $correpondence_ids);
    db_delete('maps_import_object_ids')->condition($condition)->execute();
    db_delete('maps_import_media_ids')->condition($condition)->execute();
  }
}

/**
 * Implements hook_entity_info_alter().
 */
function maps_import_entity_info_alter(&$entity_info) {
  if (isset($entity_info['taxonomy_term'])) {
    $entity_info['taxonomy_term']['maps_import_handler'] = 'Drupal\\maps_import\\Mapping\\Target\\Drupal\\TaxonomyTerm';
  }
  if (isset($entity_info['node'])) {
    $entity_info['node']['maps_import_handler'] = 'Drupal\\maps_import\\Mapping\\Target\\Drupal\\Node';
  }
  if (isset($entity_info['file'])) {
    $entity_info['file']['maps_import_handler'] = 'Drupal\\maps_import\\Mapping\\Target\\Drupal\\File';
  }
  if (isset($entity_info['commerce_product'])) {
    $entity_info['commerce_product']['maps_import_handler'] = 'Drupal\\maps_import\\Mapping\\Target\\Drupal\\Product';
  }
  if (isset($entity_info['user'])) {
    $entity_info['user']['maps_import_handler'] = 'Drupal\\maps_import\\Mapping\\Target\\Drupal\\User';
  }
}

/**
 * Implements hook_theme().
 */
function maps_import_theme($existing, $type, $theme, $path) {
  return array(
    'maps_import_settings_languages_form' => array(
      'render element' => 'form',
      'file' => 'admin/maps_import.language.inc',
    ),
    'maps_import_settings_statuses_form' => array(
      'render element' => 'form',
      'file' => 'admin/maps_import.status.inc',
    ),
    'maps_import_converters_overview_form' => array(
      'render element' => 'form',
      'file' => 'admin/maps_import.converter.inc',
    ),
    'maps_import_converter_conditions_overview_form' => array(
      'render element' => 'form',
      'file' => 'admin/maps_import.condition.inc',
    ),
    'maps_import_converter_mapping_form' => array(
      'render element' => 'form',
      'file' => 'admin/maps_import.mapping.inc',
    ),
    'maps_import_converter_media_settings_form' => array(
      'render element' => 'form',
      'file' => 'admin/maps_import.converter.inc',
    ),
    'maps_import_settings_media_types_form' => array(
      'render element' => 'form',
      'file' => 'admin/maps_import.media_types.inc',
    ),
    'maps_import_libraries_overview' => array(
      'render element' => 'form',
      'file' => 'admin/maps_import.library.inc',
    ),
  );
}

/**
 * Implements hook_menu().
 */
function maps_import_menu() {
  module_load_include('inc', 'maps_import', 'includes/maps_import.menu');
  return _maps_import_menu();
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function maps_import_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  if (empty($router_item['fake']) && array_shift($router_item['page_arguments']) === 'maps_import_converters_overview_form') {
    $profile = array_shift($router_item['page_arguments']);
    $converter_type = array_shift($router_item['page_arguments']);

    $data['actions']['count']++;
    $data['actions']['output'][] = array(
      '#theme' => 'menu_local_action',
      '#link' => array(
        'title' => t('Add a new converter'),
        'href' => 'admin/maps-suite/profiles/' . $profile->getName() . '/add/' . $converter_type,
      ),
    );
    $data['actions']['output'][] = array(
      '#theme' => 'menu_local_action',
      '#link' => array(
        'title' => t('Media settings'),
        'href' => 'admin/maps-suite/profiles/' . $profile->getName() . '/settings/media',
      ),
    );
  }
}

/**
 * Implements hook_hook_info().
 */
function maps_import_hook_info() {
  return array_fill_keys(
    array(
      'maps_import_entity_presave',
      'maps_import_operations',
      'maps_import_operations_alter',
      'maps_import_operation_finished',
      'maps_import_profile_delete',
      'maps_import_profile_action_links',
      'maps_import_entity_mapping_finished',
      'maps_import_mapping_finished',
      'maps_import_converter_actions',
    ),
    array('group' => 'maps_suite')
  );
}

/**
 * Implements hook_element_info_alter().
 */
function maps_import_element_info_alter(&$type) {
  $type['checkboxes']['#process'][] = 'maps_import_process_checkboxes';
}

/**
 * Processes a checkboxes form element.
 *
 * Allow to disable some options inside a group of checkboxes.
 */
function maps_import_process_checkboxes($element) {
  if (!empty($element['#disabled_options'])) {
    foreach ($element['#disabled_options'] as $key) {
      $element[$key]['#disabled'] = TRUE;
    }
  }

  return $element;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * @see entity_translation_admin_form()
 */
function maps_import_form_entity_translation_admin_form_alter(&$form, $form_state) {
  $form['#validate'][] = 'maps_import_entity_translation_admin_form_validate';
  $form['enabled']['entity_translation_entity_types']['#disabled_options'] = maps_import_entity_translation_default();
  // @todo Find a better way to manage this.
  $default = drupal_map_assoc(maps_import_entity_translation_default());

  if (!empty($form['enabled']['entity_translation_entity_types']['#default_value'])) {
    $default += $form['enabled']['entity_translation_entity_types']['#default_value'];
  }

  $form['enabled']['entity_translation_entity_types']['#default_value'] = $default;
  $form['enabled']['entity_translation_entity_types']['#suffix'] = theme('html_tag', array(
    'element' => array(
      '#tag' => 'div',
      '#value' => t('MaPS Import module needs some entity types to be enabled for entity translation, so the related checkboxes are disabled.'),
      '#attributes' => array('class' => array('messages warning')),
    ),
  ));
}

/**
 * Form validation handler.
 *
 * Ensure required options are enabled for
 * entity translation.
 *
 * @see entity_translation_admin_form()
 * @see maps_import_form_entity_translation_admin_form_alter()
 */
function maps_import_entity_translation_admin_form_validate($form, &$form_state) {
  $values = drupal_map_assoc(maps_import_entity_translation_default()) + $form_state['values']['entity_translation_entity_types'];
  form_set_value($form['enabled']['entity_translation_entity_types'], $values, $form_state);
}

/**
 * Implements hook_mail().
 */
function maps_import_mail($key, &$message, $params) {
  switch ($key) {
    case 'log_dispatch':
      $message['subject'] = token_replace($params['subject'], $params['data']);
      $message['body'][] = token_replace($params['message'], $params['data']);
      break;
  }
}

/**
 * @} End of "defgroup Drupal hooks".
 *
 * @defgroup Admin Menu hooks
 * @{
 */

/**
 * Implements hook_admin_menu_map().
 */
function maps_import_admin_menu_map() {
  $map = array();

  if (!user_access('administer menu')) {
    return $map;
  }

  if ($profiles = CacheProfile::getInstance()->loadAll()) {
    $profiles = array_map(function (Profile $profile) {
      return $profile->getName();
    }, $profiles);

    $map = array(
      'admin/maps-suite/profiles/%maps_import_profile' => array(
        'parent' => 'admin/maps-suite/profiles',
        'arguments' => array(
          array('%maps_import_profile' => array_values($profiles)),
        ),
      ),
    );
  }

  return $map;
}

/**
 * @} End of "defgroup Admin Menu hooks".
 *
 * @defgroup CTools hooks
 * @{
 */

/**
 * Implments hook_ctools_plugin_directory().
 */
function maps_import_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && $plugin == 'export_ui') {
    return 'plugins/' . $module . '/' . $plugin;
  }
}

/**
 * @} End of "defgroup CTools hooks".
 *
 * @defgroup Features hooks
 * @{
 */

/**
 * @} End of "defgroup Features hooks".
 */
/**
 * Implements hook_features_api_alter().
 */
function maps_import_features_api_alter(&$components) {
  $components['maps_import_profile']['file'] = drupal_get_path('module', 'maps_import') . '/includes/maps_import.ctools.inc';
}

/**
 * Implements hook_features_enable_feature().
 *
 * In behalf of maps_import_profile.
 */
function maps_import_profile_features_enable_feature($module) {
  maps_import_profile_features_revert($module, 'maps_import_profile');
}

/**
 * Custom implementation of hook_features_revert() for MaPS Import profile.
 */
function maps_import_profile_features_revert($module, $component) {
  module_load_include('inc', 'maps_import', 'includes/maps_import.ctools');

  if ($objects = features_get_default($component, $module)) {
    foreach ($objects as $name => $original_object) {
      // Some things (like views) do not use the machine name as key
      // and need to be loaded explicitly in order to be deleted.
      $object = ctools_export_crud_load($component, $name);
      if ($object && ($object->export_type & EXPORT_IN_DATABASE)) {
        _ctools_features_export_crud_delete($component, $object);
      }

      maps_import_profile_export_save($original_object);
    }
  }
}

/**
 * Define default entity types that use entity translation.
 *
 * @return array
 *   The entity types.
 */
function maps_import_entity_translation_default() {
  return array(
    'file',
    'node',
    'commerce_product',
  );
}

/**
 * Get an array of all presets for a Profile.
 *
 * @param Profile $profile
 *   The profile instance.
 *
 * @return array
 *   An array of presets keyed by ID.
 */
function maps_import_image_presets(Profile $profile) {
  $presets = &drupal_static(__FUNCTION__);

  if (!isset($presets[$profile->getPid()])) {
    $presets[$profile->getPid()] = maps_suite_reduce_array($profile->getConfigurationTypes('image_preset'), 'title');
  }

  return $presets[$profile->getPid()];
}

/**
 * Returns the MaPS Import profile object matching given id or name.
 *
 * @param mixed $identifier
 *   Either a MaPS Import profile's ID or its machine name.
 *
 * @return Profile
 *   A MaPS Import profile object
 */
function maps_import_profile_load($identifier) {
  if (is_numeric($identifier)) {
    return CacheProfile::getInstance()->loadSingle($identifier);
  }
  elseif (is_string($identifier)) {
    return CacheProfile::getInstance()->loadSingle($identifier, 'name');
  }

  return FALSE;
}

/**
 * Get the profile title.
 *
 * @param Profile $profile
 *   The profile object.
 * @param string $text
 *   The text that will be translated. This text should contain the
 *   variable "@profile".
 *
 * @return string
 *   The processed text with profile title replacement.
 */
function maps_import_profile_title(Profile $profile, $text = '@profile') {
  // @todo use maps_suite_user_t() to translate the profile title.
  return t($text, array('@profile' => $profile->getTitle()));
}

/**
 * Returns whether a profile name already exists.
 *
 * @see maps_import_admin_profile_form()
 * @see form_validate_machine_name()
 */
function maps_import_profile_name_exists($value, $element, &$form_state) {
  return (bool) db_query_range('SELECT 1 FROM {maps_import_profile} WHERE name = :name', 0, 1, array(':name' => $value))->fetchField();
}

/**
 * Check menu access using fetched configuration.
 *
 * @param Profile $profile
 *   The Profile object.
 * @param string $type
 *   The optional filter on the configuration type.
 * @param int $id_language
 *   The MaPS System® language ID. If set to TRUE, the condition will use
 *   the MaPS language that match current user language.
 * @param string $permission
 *   The additional permission to check for access.
 *
 * @return bool
 *   TRUE if the user is granted access, otherwise FALSE.
 */
function maps_import_access(Profile $profile, $type = NULL, $id_language = FALSE, $permission = 'administer maps suite') {
  $conditions = array();

  if ($type) {
    $conditions[] = array('type', $type);
  }

  if ($id_language === TRUE) {
    $conditions[] = array('id_language', $profile->getLanguage());
  }
  elseif (is_numeric($id_language)) {
    $conditions[] = array('id_language', $id_language);
  }

  if (!$profile->getConfiguration($conditions)) {
    return FALSE;
  }

  return user_access($permission);
}

/**
 * Manage various access for parent and child converters.
 *
 * @return bool
 *   TRUE if the user is granted access, FALSE otherwise.
 */
function maps_import_converter_access(ConverterInterface $converter, $operation, $type = NULL, $id_language = FALSE, $permission = 'administer maps suite') {
  if (!maps_import_access($converter->getProfile(), $type, $id_language, $permission)) {
    return FALSE;
  }

  if ($converter->getParentId() > 0) {
    return TRUE;
  }

  return in_array($operation, array(
    'mapping',
    'filters',
    'delete',
    'edit',
    'relation',
  ));
}

/**
 * Its purpose is to define the possible nested mapping.
 */
function maps_import_get_maps_object_types() {
  return array(
    'object' => array(),
    'media' => array(),
    'link' => array(),
  );
}

/**
 * Return an array containing the MaPS System® media types.
 *
 * @return array
 *   The media types.
 */
function maps_import_get_maps_media_types(Profile $profile) {
  $return = array();
  $types = $profile->getConfigurationTypes('media_type', $profile->getDefaultLanguage());

  if (!empty($types)) {
    foreach ($types as $type) {
      $return[$type['id']] = $type['title'];
    }
  }

  return $return;
}

/**
 * Loads a converter from the database.
 *
 * This function returns FALSE in some edge case to deny access to the menu
 * item, when this function is called by the menu API.
 *
 * @param int $cid
 *   The converter ID or the class name of the converter.
 * @param int $pid
 *   The MaPS Import profile ID. This parameter is mainly used by the menu
 *   system when loading a converter from the URI data.
 *
 * @return Drupal\maps_import\Converter\ConverterInterface
 *   A converter object if exists, otherwise FALSE.
 */
function maps_import_converter_load($cid, $pid = NULL) {
  if (empty($cid)) {
    return FALSE;
  }

  if (is_numeric($cid)) {
    return CacheConverter::getInstance()->loadSingle($cid);
  }

  if (is_string($cid)) {
    if (!class_exists($cid) || !is_subclass_of($cid, 'Drupal\\maps_import\\Converter\\ConverterInterface')) {
      watchdog('maps_suite', 'The converter class @class does not exist or does not extend the converter interface.', array('@class' => $cid), WATCHDOG_ERROR);
    }
    elseif (!isset($pid)) {
      watchdog('maps_suite', 'The profile object is required to create en empty converter.', array(), WATCHDOG_ERROR);
    }
    elseif (!$profile = CacheProfile::getInstance()->loadSingle($pid)) {
      watchdog('maps_suite', 'There is no profile with a pid of @pid.', array('@pid' => $pid), WATCHDOG_ERROR);
    }
    else {
      return new $cid($profile);
    }
  }

  return FALSE;
}

/**
 * Get the title of the given converter.
 *
 * @param ConverterInterface $converter
 *   The converter object
 * @param string $text
 *   The text that will be translated. This text should contain the
 *   variable "@converter".
 *
 * @return string
 *   The processed text with converter title replacement.
 */
function maps_import_converter_title(ConverterInterface $converter, $text = '@converter') {
  // @todo use maps_suite_user_t() to translate the profile title.
  return t($text, array('@converter' => $converter->getTitle()));
}

/**
 * Returns whether a converter name already exists.
 *
 * @see maps_import_converter_edit_form()
 * @see form_validate_machine_name()
 */
function maps_import_converter_name_exists($value, $element, &$form_state) {
  return (bool) db_query_range('SELECT 1 FROM {maps_import_converter} WHERE name = :name and pid = :pid', 0, 1, array(':name' => $value, ':pid' => $element['#machine_name']['pid']))->fetchField();
}

/**
 * Load a condition from a converter.
 *
 * @param int $condition_id
 *   The id of the condition to load.
 * @param int $pid
 *   The profile id.
 * @param int $cid
 *   The converter id.
 *
 * @return MapsImportFilterCondition
 *   The condition.
 */
function maps_import_condition_load($condition_id, $pid, $cid) {
  $converter = maps_import_converter_load($cid);
  if ($condition = $converter->getCondition($condition_id)) {
    return $condition;
  }

  return FALSE;
}

/**
 * Get a converters list from a profile ID.
 *
 * @param int $pid
 *   The MaPS Import Profile ID.
 */
function maps_import_get_converters($pid) {
  return CacheConverter::getInstance()->load(array($pid), 'pid');
}

/**
 * Build a list of object properties options for a select element.
 *
 * @param array $properties
 *   An array of properties.
 */
function maps_import_properties_select(array $properties) {
  $options = array();

  foreach ($properties as $group => &$_properties) {
    foreach ($_properties as &$property) {
      $options[$group][$property->getKey()] = $property->getSelectLabel();
    }

    if (!empty($options[$group])) {
      asort($options[$group]);
    }
  }

  return $options;
}

/**
 * Build a list of drupal fields options for a select element.
 *
 * @param array $fields
 *   An array of fields.
 */
function maps_import_fields_select(ConverterInterface $converter, array $fields, $exclude_mapped = TRUE) {
  $options = array();

  if (empty($fields)) {
    return $options;
  }

  // Get entity informations.
  $entity_info = entity_get_info($converter->getEntityType());
  $group = t('Main entity: @label', array('@label' => isset($entity_info['label']) ? $entity_info['label'] : ''));

  $mapped = db_select('maps_import_mapping_item')
    ->fields('maps_import_mapping_item', array('field_name'))
    ->condition('cid', $converter->getCid())
    ->execute()
    ->fetchAllAssoc('field_name', \PDO::FETCH_ASSOC);

  foreach ($fields as $field) {
    if (!isset($mapped[$field->getKey()]) || !$exclude_mapped) {
      $options[$group][$field->getKey()] = $field->getDescription(array(
        'label',
        'type',
        'translatable',
        'multiple',
      ));
    }
  }

  // Sort results.
  foreach ($options as &$option) {
    asort($option);
  }

  return $options;
}

/**
 * Get import operation information.
 *
 * @param Profile $profile
 *   The MaPS Import Profile instance.
 * @param string $op
 *   The name of the process for which return information. If NULL,
 *   an array containing all possible operations is returned.
 * @param array $info
 *   If specified, only the specified information is returned. Possible
 *   values are:
 *   - title: The process title.
 *   - class: The process related class.
 *
 * @return array
 *   An array containing the requested information about import operations.
 */
function maps_import_get_import_operations(Profile $profile, $op = NULL, $info = NULL) {
  static $drupal_static_fast;

  if (!isset($drupal_static_fast)) {
    $drupal_static_fast['operations'] = &drupal_static(__FUNCTION__);
  }

  $operations = &$drupal_static_fast['operations'];
  $pid = $profile->getPid();

  if (!isset($operations[$pid])) {
    $operations[$pid] = module_invoke_all('maps_import_operations', $profile);
    drupal_alter('maps_import_operations', $operations[$pid], $profile);
  }

  if (!$op) {
    return $info ? maps_suite_reduce_array($operations[$pid], $info) : $operations[$pid];
  }

  if (array_key_exists($op, $operations[$pid])) {
    if ($info) {
      return array_key_exists($info, $operations[$pid][$op]) ? $operations[$pid][$op][$info] : NULL;
    }

    return $operations[$pid][$op];
  }

  return array();
}

/**
 * Get a mapping plugin class.
 *
 * @return MapsImportMapping
 *   The mapping object.
 */
function maps_import_mapping_plugin(Converter $converter) {
  $plugins = maps_import_mapping_plugins();

  if (isset($plugins[$converter->getEntityType()])) {
    $class = !empty($plugins[$converter->getEntityType()]['mapping class']) ? $plugins[$converter->getEntityType()]['mapping class'] : 'MapsImportMappingDefault';

    if (class_exists($class) && @is_subclass_of($class, 'MapsImportMapping')) {
      return new $class($converter);
    }
  }
}

/**
 * Loads a mapping item from the database.
 *
 * @param int $id
 *   The processor ID.
 * @param int $pid
 *   The MaPS WS profile ID.
 * @param int $cid
 *   The converter ID.
 *
 * @return Converter
 *   A converter object if exists, otherwise FALSE.
 */
function maps_import_mapping_item_load($id, $pid, $cid) {
  $converter = maps_import_converter_load($cid, $pid);
//  $items = $converter->getMapping()->getItems(FALSE) + $converter->getMapping()->getItems(TRUE);
  $items = $converter->getMapping()->getItems('all');
  return !empty($items[$id]) ? $items[$id] : FALSE;
}

/**
 * Retrieve allowes Drupal file types.
 *
 * @return array
 *   An array with Drupal file types.
 */
function maps_import_get_drupal_file_types() {
  $types = array();

  // In case of a beta version of the File entity module.
  $function_name = function_exists('file_type_get_all_types') ? 'file_type_get_all_types' : 'file_type_load_all';

  foreach (call_user_func($function_name) as $type) {
    $types[] = $type->label;
  }

  return $types;
}

/**
 * Return a profile related MaPS System® libraries.
 *
 * @param Profile $profile
 *   The MaPS profile object.
 */
function maps_import_libraries(Profile $profile) {
  static $drupal_static_fast;

  if (!isset($drupal_static_fast)) {
    $drupal_static_fast['libraries'] = &drupal_static(__FUNCTION__);
  }

  $libraries = &$drupal_static_fast['libraries'];
  $key = 'library:' . $profile->getPid();

  if (!isset($libraries[$key])) {
    if ($cached = cache_get($key, 'cache_maps_suite') && !empty($cached)) {
      $libraries[$key] = $cached->data;
    }
    else {
      $libraries[$key] = array();

      foreach (maps_suite_get_records(Fetcher::DB_LIBRARY_TABLE, NULL, array('pid' => $profile->getPid())) as $library) {
        $libraries[$key][$library->id_attribute][$library->id][$library->id_language] = $library->value;
      }

      cache_set($key, $libraries[$key], 'cache_maps_suite');
    }
  }

  return $libraries[$key];
}

/**
 * Check if the given attribute exists in configuration.
 *
 * @param Profile $profile
 *   The related profile.
 * @param Library $library
 *   The library to check.
 *
 * @return bool
 *   Whether the attribute exists.
 */
function maps_import_library_access(Profile $profile, Library $library) {
  if (!maps_import_access($profile)) {
    return FALSE;
  }

  $attributes = $profile->getConfigurationTypes('attribute', $profile->getDefaultLanguage());

  if (empty($attributes[$library->getId()])) {
    return FALSE;
  }
  return TRUE;
}

/**
 * Construct a Library object from the given attribute id.
 *
 * @param int $id_attribute
 *   The attribute id.
 *
 * @return Library
 *   The library object.
 */
function maps_import_library_load($id_attribute) {
  return new Library(array('id' => $id_attribute));
}

/**
 * Break the MaPS Import lock.
 */
function maps_import_break_lock() {
  variable_set('maps_import_lock', 0);
  drupal_set_message(t('The MaPS Import lock has been removed.'), 'status');
  drupal_goto($_SERVER['HTTP_REFERER']);
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Add specifig log parameters for MaPS Import.
 */
function maps_import_form_maps_suite_admin_log_form_alter(&$form, $form_state) {
  $form['maps_import'] = array(
    '#type' => 'fieldset',
    '#title' => t('MaPS Import'),
  );

  // Notifications.
  $form['maps_import']['notifications'] = array(
    '#type' => 'fieldset',
    '#title' => t('Log notifications'),
  );

  $form['maps_import']['notifications']['maps_import_log_emails'] = array(
    '#title' => t('Email adresses'),
    '#type' => 'textfield',
    '#default_value' => variable_get('maps_import_log_emails', ''),
    '#description' => t('Define the email adresses that will receive the logs notifications (separated by commas).'),
  );

  $form['maps_import']['notifications']['maps_import_log_subject'] = array(
    '#title' => t('Email Subject'),
    '#type' => 'textfield',
    '#default_value' => variable_get('maps_import_log_subject', 'Log report'),
    '#description' => t('Define the subject of the log notification email.'),
  );

  $form['maps_import']['notifications']['maps_import_log_message'] = array(
    '#title' => t('Email Message'),
    '#type' => 'textarea',
    '#default_value' => variable_get('maps_import_log_message', 'MaPS System® operation  for profile "[maps_import_profile:title]" (ID [maps_import_profile:pid]) is finished. The full log may be found here: [maps_import_log:url]'),
    '#description' => t('Define the message that will appears in the log notification email.'),
  );

  $form['maps_import']['notifications']['tokens'] = array(
    '#theme' => 'token_tree',
    '#global_types' => TRUE,
    '#token_types' => array('maps_import'),
    '#click_insert' => TRUE,
  );

  // Options.
  $form['maps_import']['options'] = array(
    '#type' => 'fieldset',
    '#title' => t('Options'),
  );

  $form['maps_import']['options']['maps_import_log_manual'] = array(
    '#type' => 'checkbox',
    '#default_value' => variable_get('maps_import_log_manual', 0),
    '#title' => t('Receive email notifications for manual operations.'),
  );

  $form['maps_import']['options']['maps_import_log_drush'] = array(
    '#type' => 'checkbox',
    '#default_value' => variable_get('maps_import_log_drush', 0),
    '#title' => t('Receive email notifications for Drush operations.'),
  );

  // Drush options.
  $form['maps_import']['drush_options'] = array(
    '#type' => 'fieldset',
    '#title' => t('Drush options'),
    '#states' => array(
      'invisible' => array(
        ':input[name="maps_import_log_drush"]' => array('checked' => FALSE),
      ),
    ),
  );

  $form['maps_import']['drush_options']['maps_import_log_drush_global_notifications'] = array(
    '#type' => 'checkbox',
    '#default_value' => variable_get('maps_import_log_drush_global_notifications', 0),
    '#title' => t('Do not send email notifications for each log but gather all log in a single email.'),
  );

  $form['#validate'][] = 'maps_import_form_maps_suite_admin_log_form_validate';
}

/**
 * Form API; validate the email addresses if any.
 */
function maps_import_form_maps_suite_admin_log_form_validate($form, &$form_state) {
  $emails = array_map('trim', explode(',', $form_state['values']['maps_import_log_emails']));
  form_set_value($form['maps_import']['notifications']['maps_import_log_emails'], implode(',', $emails), $form_state);

  if ($invalid = array_diff($emails, array_filter($emails, 'valid_email_address'))) {
    form_set_error('maps_import][notifications][maps_import_log_emails', format_plural(count($invalid), 'The e-mail address @list is not valid.', 'The following e-mail addresses are not valid: @list.', array('@list' => implode(', ', $invalid))));
  }
}

/**
 * Manage access for mapping item's options.
 *
 * @return bool
 *   TRUE if the user is granted access, FALSE otherwise.
 */
function maps_import_item_options_acess(ConverterInterface $converter, $operation, $item) {
  if (maps_import_converter_access($converter, $operation)) {
    return $item->hasOptions();
  }

  return FALSE;
}

/**
 * Implements hook_field_create_instance().
 */
function maps_import_field_create_instance($instance) {
  CacheDrupalFields::getInstance()->clearBinCache();
}

/**
 * Implements hook_field_update_instance().
 */
function maps_import_field_update_instance($instance, $prior_instance) {
  CacheDrupalFields::getInstance()->clearBinCache();
}

/**
 * Implements hook_field_delete_instance().
 */
function maps_import_field_delete_instance($instance) {
  CacheDrupalFields::getInstance()->clearBinCache();
}

/**
 * Implements hook_field_update().
 */
function maps_import_update($entity_type, $entity, $field, $instance, $langcode, &$items) {
  CacheDrupalFields::getInstance()->clearBinCache();
}

/**
 * Implements hook_field_delete().
 */
function maps_import_field_delete($entity_type, $entity, $field, $instance, $langcode, &$items) {
  CacheDrupalFields::getInstance()->clearBinCache();
}

/**
 * Implements hook_field_insert().
 */
function maps_import_field_insert($entity_type, $entity, $field, $instance, $langcode, &$items) {
  CacheDrupalFields::getInstance()->clearBinCache();
}

/**
 * Implements hook_maps_import_converter_actions().
 */
function maps_import_maps_import_converter_actions(ConverterInterface $converter) {
  $replace = array(
    '%maps_import_profile' => $converter->getProfile()->getName(),
    '%maps_import_converter' => $converter->getCid(),
    '%type' => $converter->getType(),
  );

  return array(
    'converter-edit' => array(
      'href' => strtr('admin/maps-suite/profiles/%maps_import_profile/%type/%maps_import_converter/edit', $replace),
      'title' => t('edit'),
    ),
    'converter-delete' => array(
      'href' => strtr('admin/maps-suite/profiles/%maps_import_profile/%type/%maps_import_converter/delete', $replace),
      'title' => t('delete'),
    ),
    'converter-filters' => array(
      'href' => strtr('admin/maps-suite/profiles/%maps_import_profile/%type/%maps_import_converter/filters', $replace),
      'title' => t('filters'),
    ),
    'converter-mapping' => array(
      'href' => strtr('admin/maps-suite/profiles/%maps_import_profile/%type/%maps_import_converter/mapping', $replace),
      'title' => t('mapping'),
    ),
  );
}
