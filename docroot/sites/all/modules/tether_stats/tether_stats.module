<?php
/**
 * @file
 * Drupal Module: Tether Stats.
 *
 * This module defines a suite of statistics gathering and managing tools.
 */

/**
 * Implements hook_help().
 */
function tether_stats_help($path, $arg) {

  $help = NULL;

  switch ($path) {

    case 'admin/config/system/tether_stats':
    case 'admin/config/system/tether_stats/settings':
      $help = '<p>' . t('Configure your Tether Stats settings here. Stat collection is not initially turned on.') . '</p>';
      break;

    case 'admin/config/system/tether_stats/elements':
      $help = '<p>' . t('Use the form below to find a specific Tether Stats element. Please refer to the README.txt file for more detail on elements and other general concepts related to Tether Stats.') . '</p>' .
        '<p>' . t('If the Tether Stats Charts module is installed, you will get a link to a chart report page for any found element.') . '</p>';
      break;

    case 'admin/config/system/tether_stats/derivatives':
      $help = '<p>' . t('Derivatives are used to create additional stat elements which relate to other basic elements. Please refer to the README.txt file for more detail on derivatives and other general concepts related to Tether Stats.') . '</p>';
      break;

  }
  return $help;
}

/**
 * Implements hook_menu().
 */
function tether_stats_menu() {

  $items['admin/config/system/tether_stats'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tether_stats_settings_form'),
    'file' => 'tether_stats.forms.inc',
    'access arguments' => array('administer tether stats'),
    'title' => 'Tether Statistics',
    'description' => 'Manage Tether Stats',
    'type' => MENU_NORMAL_ITEM,
  );

  $items['admin/config/system/tether_stats/settings'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tether_stats_settings_form'),
    'file' => 'tether_stats.forms.inc',
    'access arguments' => array('administer tether stats'),
    'title' => 'Tether Statistics Settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/config/system/tether_stats/elements'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tether_stats_element_finder_form'),
    'file' => 'tether_stats.forms.inc',
    'access arguments' => array('administer tether stats'),
    'title' => 'Element Finder',
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/config/system/tether_stats/derivatives'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tether_stats_admin_manage_derivatives_form'),
    'access arguments' => array('administer tether stats'),
    'file' => 'tether_stats.forms.inc',
    'title' => 'Derivative Settings',
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/config/system/tether_stats/derivatives/add'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tether_stats_admin_derivatives_add_form'),
    'file' => 'tether_stats.forms.inc',
    'access arguments' => array('administer tether stats'),
    'title' => 'Add a New Derivative',
    'type' => MENU_LOCAL_ACTION,
  );

  $items['admin/config/system/tether_stats/derivatives/delete/%tether_stats_derivative'] = array(
    'page callback' => 'tether_stats_admin_derivative_delete_callback',
    'page arguments' => array(6),
    'file' => 'tether_stats.callbacks.inc',
    'access arguments' => array('administer tether stats'),
    'title' => 'Delete a Derivative',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/system/tether_stats/derivatives/disable/%tether_stats_derivative'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tether_stats_admin_derivatives_disable_confirm_form', 6),
    'file' => 'tether_stats.forms.inc',
    'access arguments' => array('administer tether stats'),
    'title' => 'Disable a Derivative',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/system/tether_stats/derivatives/enable/%tether_stats_derivative'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tether_stats_admin_derivatives_enable_confirm_form', 6),
    'file' => 'tether_stats.forms.inc',
    'access arguments' => array('administer tether stats'),
    'title' => 'Disable a Derivative',
    'type' => MENU_CALLBACK,
  );

  $items['tether_stats/track'] = array(
    'title' => 'Track Activity',
    'page callback' => 'tether_stats_track',
    'file' => 'tether_stats.callbacks.inc',
    'access arguments' => array('access content'),
    'description' => 'Track an activity.',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function tether_stats_permission() {

  return array(
    'administer tether stats' => array(
      'title' => t('Administer Tether Stats'),
      'description' => t('Managing all settings for the Tether Stats module.'),
    ),
  );
}

/**
 * Loads an element by elid. Called by the menu system.
 *
 * @param int $elid
 *   The elid of the element to load.
 *
 * @return object
 *   A Tether Stats element object.
 */
function tether_stats_element_load($elid) {

  $element = NULL;

  if (is_numeric($elid)) {

    $old_db = db_set_active(tether_stats_set_db());
    $element = db_select('tether_stats_element', 'd')->fields('d')->condition('elid', $elid, '=')->execute()->fetch();
    db_set_active($old_db);
  }
  return $element;
}

/**
 * Loads a derivate by id. Called by the menu system.
 *
 * @param int $id
 *   The id of the derivative to load.
 *
 * @return object
 *   A Tether Stats derivative object.
 */
function tether_stats_derivative_load($id) {

  $derivative = NULL;

  if (is_numeric($id)) {

    $old_db = db_set_active(tether_stats_set_db());
    $derivative = db_select('tether_stats_derivative', 'd')->fields('d')->condition('id', $id, '=')->execute()->fetch();
    db_set_active($old_db);
  }
  return $derivative;
}


/**
 * Loads a derivative from the derivative table.
 *
 * A dervative may correspond to an entity type and specific bundle, or it may
 * correspond to just an entity type and match with any bundle. If $bundle is
 * equal to '*', then the derivative that matches with any bundle will be
 * loaded.
 *
 * @param string $name
 *   The string identifier for the derivative.
 * @param string $database_id
 *   (Optional) Database Id to use instead of the default stats database.
 * @param bool $load_disabled
 *   (Optional) If set to TRUE, this method will also load disabled derivatives.
 * @param bool $reset
 *   Reset the static cache.
 *
 * @return object|false
 *   Derivative object or FALSE if it does not exist.
 */
function tether_stats_derivative_key_load($name, $database_id = NULL, $load_disabled = FALSE, $reset = FALSE) {
  $derivatives =& drupal_static(__FUNCTION__, array());

  if (!isset($derivatives[$name]) || $reset) {

    if (!isset($database_id)) {

      $database_id = tether_stats_set_db();
    }

    $old_db = db_set_active($database_id);
    $query = db_select('tether_stats_derivative', 'd')
      ->fields('d')
      ->condition('name', $name);

    if (!$load_disabled) {

      $query->condition('disabled', 0);
    }

    $results = $query->execute()->fetchAll();
    db_set_active($old_db);

    if (!empty($results)) {

      $derivatives[$name] = $results[0];
    }
  }

  return isset($derivatives[$name]) ? $derivatives[$name] : FALSE;
}

/**
 * Save a derivative object to the database.
 *
 * @param object $derivative
 *   The derivative object.
 */
function tether_stats_derivative_save($derivative) {

  $fields = array(
    'entity_type',
    'name',
    'description',
    'entity_bundle',
  );

  $values = array();

  foreach ($fields as $field) {

    if (isset($derivative->{$field})) {

      $values[$field] = $derivative->{$field};
    }
  }

  $old_db = db_set_active(tether_stats_set_db());
  if (!empty($derivative->id)) {

    db_update('tether_stats_derivative')->fields($values)
      ->condition('id', $derivative->id)
      ->execute();
  }
  else {

    $options = array('return' => Database::RETURN_INSERT_ID);

    $derivative->id = db_insert('tether_stats_derivative', $options)->fields($values)->execute();
  }
  db_set_active($old_db);
}

/**
 * Implements hook_theme().
 */
function tether_stats_theme() {

  module_load_include('inc', 'tether_stats', 'tether_stats.theme');

  return _tether_stats_theme();
}

/**
 * Implements hook_page_build().
 *
 * Loads the stats element for the current page and adds that information to
 * the javascript settings. No actual stats are collected at this point, but
 * element data is made ready.
 */
function tether_stats_page_build(&$page) {

  if (variable_get('tether_stats_active', FALSE)) {

    // Do not generate stat elements and track activity on pages which do
    // not exist if the configuration indicates it.
    if (variable_get('tether_stats_track_404', FALSE) || strpos(drupal_get_http_header('status'), '404 ') !== 0) {

      $path = current_path();

      $identifiers = array();
      $identifiers['url'] = $path;

      $query = NULL;

      if (!empty($_SERVER['argv'])) {
        $query = $_SERVER['argv'][0];
      }
      elseif (!empty($_SERVER['QUERY_STRING'])) {
        $query = $_SERVER['QUERY_STRING'];
      }

      if (variable_get('tether_stats_allow_query_string_to_define_new_elements', FALSE)) {

        $identifiers['query'] = $query;
      }

      $ignore = FALSE;

      $path_matches_rules = _tether_stats_match_filter_rules($path);
      $exclusion_mode = variable_get('tether_stats_exclusion_mode', 'exclude');

      if (($exclusion_mode == 'exclude' && $path_matches_rules) ||
        ($exclusion_mode == 'include' && !$path_matches_rules)) {

        $ignore = TRUE;
      }

      if (!$ignore) {

        // Invoke the hook_tether_stats_url hook.
        tether_stats_alter_identity_set($identifiers, $query);

        $element = tether_stats_get_element($identifiers);

        if ($element !== FALSE) {

          $module_path = drupal_get_path('module', 'tether_stats');

          $page['content']['#attached']['js'] = array(
            "{$module_path}/js/tether_stats.js",
          );

          $page['content']['#attached']['js'][] = array(
            'data' => array(
              'tether_stats' => array(
                'elid' => $element->elid,
                'impressions' => array(),
              ),
            ),
            'type' => 'setting',
          );
        }
      }
    }
  }
}

/**
 * Allows other modules to alter the identity set for the page.
 *
 * Modules may alter the identity set for the current page by invoking
 * the hook_tether_stats_url hook. in this way, modules can map the
 * page to a different stats element.
 *
 * @param array $identifiers
 *   The identity set to alter.
 * @param string $query
 *   The query string of the request.
 */
function tether_stats_alter_identity_set(array &$identifiers, $query) {

  $modules = module_implements('tether_stats_url');

  // Loop through all the modules which implement hook_tether_stats_url().
  // If one of them provides a match for our url path, then we will use
  // that to determine which corresponding element to load.
  foreach ($modules as $module) {

    $function = "{$module}_tether_stats_url";

    $match = $function($identifiers['url'], $query);

    if ($match !== FALSE) {

      $entity = NULL;

      if (isset($match['entity_type']) || isset($match['entity_id'])) {

        if (!empty($match['entity_id']) && !empty($match['entity_type'])) {

          $entities = entity_load($match['entity_type'], array($match['entity_id']));

          if (!empty($entities)) {

            $entity = reset($entities);
          }
        }

        if (!isset($entity)) {

          // An entity_id or entity_type was specified but no matching entity
          // exists.
          watchdog('tether_stats', 'An entity bound identity set was provided but no matching entity exists. Entity type: %entity_type, Entity id: %entity_id',
            array(
              '%entity_type' => empty($match['entity_type']) ? $match['entity_type'] : 'no type provided',
              '%entity_id' => empty($match['entity_id']) ? $match['entity_id'] : 'no id provided',
            ), WATCHDOG_WARNING);

          return FALSE;
        }
      }

      // If a derivative was specified as part of the matching condition,
      // then we must apply it to our element search as derivatives define
      // new elements.
      if (isset($match['derivative'])) {

        $entity_type = NULL;
        $entity_bundle = NULL;

        if (isset($entity)) {

          $entity_type = $match['entity_type'];
          list(, , $entity_bundle) = entity_extract_ids($match['entity_type'], $entity);
        }

        if (!_tether_stats_validate_derivative($match['derivative'], $entity_type, $entity_bundle)) {

          return FALSE;
        }
      }

      $identifiers = $match;
      break;
    }
  }
}

/**
 * Sets or gets the database id to be used by the tether_stats module.
 *
 * This only persists for the duration of this call as it is stored as a
 * static variable, but you can use this function to force the use of a
 * different database temporarily.
 *
 * The database that tether_stats will use, if one is not specified here, is
 * by the 'tether_stats_db' drupal variable.
 *
 * If all else fails, the default database will be used.
 *
 * @param string $database_id
 *   (Optional) Set the database identifier of the database to use when
 *   saving and loading stats.
 *
 * @return string
 *   The database id being used by Tether Stats.
 */
function tether_stats_set_db($database_id = NULL) {
  $dbid =& drupal_static(__FUNCTION__);

  if (isset($database_id)) {

    $dbid = $database_id;
  }
  elseif (!isset($dbid)) {

    $dbid = variable_get('tether_stats_db', 'default');
  }

  return $dbid;
}

/**
 * Takes a url and determines if it matches the current set of filter rules.
 *
 * Page filter rules are used to either include or exclude a page from stats
 * collection and element generation.
 *
 * @param string $path
 *   The url path.
 *
 * @return bool
 *   Returns TRUE if the $path matches the filter rules.
 */
function _tether_stats_match_filter_rules($path) {

  // Assume not a match unless discovered otherwise.
  $ret_value = FALSE;
  $raw_filter_rules = _tether_stats_filter_rules();

  if (!empty($raw_filter_rules)) {

    // Add the stat tracking pages for this module as a default rule.
    $raw_filter_rules[] = 'tether_stats';

    $url_parts = explode('/', trim($path), MENU_MAX_PARTS);

    foreach ($raw_filter_rules as $rule) {

      $rule_parts = explode('/', trim($rule));

      $rule_match = FALSE;

      // If the rule is longer than the url, we automatically fail to match.
      if (!empty($rule_parts) && count($url_parts) >= count($rule_parts)) {

        for ($i = 0; $i < count($rule_parts); $i++) {

          switch ($rule_parts[$i]) {

            case '%':
              $rule_match = TRUE;
              break;

            case '#':
              $rule_match = is_numeric($url_parts[$i]);
              break;

            default:
              $rule_match = (strcasecmp($url_parts[$i], $rule_parts[$i]) == 0);
              break;

          }

          if (!$rule_match) {

            break;
          }
        }
      }

      if ($rule_match) {

        $ret_value = TRUE;
        break;
      }
    }
  }
  return $ret_value;
}

/**
 * Get a stat element object matching the identifiers.
 *
 * Takes an array of identifiers. May be a combination of 'name', 'url',
 * 'query', 'entity_id', 'entity_type' or 'derivative' and retrieves, or
 * constructs if non-existent, a row from the tether_stats_element table.
 *
 * The 'name' identifier uniquely matches to the 'name' as a string identifier
 * and 'url', 'entity', or 'entity_type' become irrelevant.
 *
 * If an 'entity_id' is specified, an 'entity_type' must also be specified.
 *
 * A 'derivative' can be added to identify an element unique from the element
 * matched by the other identifiers. It cannot be used on its own as it only
 * identifies elements "derived" from other elements.
 *
 * A 'query' can be added to identify a new unique element if and only if the
 * drupal variable "tether_stats_allow_query_string_to_define_new_elements" is
 * TRUE.
 *
 * @param array $identifiers
 *   Associative array of identifiers which uniquely describe an element. That
 *   is, a combination of 'name', 'url', 'query', 'entity_id', 'entity_type'
 *   or 'derivative'.
 * @param bool $allow_creation
 *   Set to FALSE to prevent this method from automatically creating a new
 *   element when a match fails.
 * @param string $database_id
 *   (Optional) Set this value to use an alternative database to the default
 *   stats database.
 *
 * @return object|false
 *   The element object or FALSE if the element could not be found or created.
 */
function tether_stats_get_element(array $identifiers, $allow_creation = TRUE, $database_id = NULL) {

  $element = FALSE;
  $allowed_identifiers = array(
    'name',
    'entity_id',
    'entity_type',
    'url',
    'query',
  );

  if (!isset($database_id)) {

    $database_id = tether_stats_set_db();
  }

  $conditions = _tether_stats_process_conditions_from_identity_set($identifiers, $allowed_identifiers, $allow_creation);

  $old_db = db_set_active($database_id);

  if (!empty($conditions)) {

    $query = db_select('tether_stats_element', 'e');

    if (!empty($identifiers['query'])) {

      $conditions['query'] = $identifiers['query'];
    }

    // If a derivative was specified  then we should try to match the
    // derived element.
    if (!empty($identifiers['derivative'])) {

      db_set_active($old_db);
      $derivative_conditions = _tether_stats_process_derivative_conditions_from_identity_set($identifiers, $database_id, $allow_creation);

      if ($derivative_conditions !== FALSE) {

        $conditions += $derivative_conditions;
        $old_db = db_set_active($database_id);
      }
      else {

        return FALSE;
      }
    }
    elseif (empty($conditions['derivative_id'])) {

      $query->isNull('e.derivative_id');
    }

    $query = $query->fields('e');

    foreach ($conditions as $field => $value) {

      $query = $query->condition($field, $value, '=');
    }

    // The query string may define new elements like a derivative would
    // so we need this condition in the case where there is no query string.
    if (empty($conditions['query'])) {

      $query->isNull('e.query');
    }

    $element = $query->execute()->fetchAssoc();

    if (!$element || (REQUEST_TIME - $element['changed'] >= variable_get('tether_stats_element_ttl', 432000))) {

      if (!$element) {

        $element = array(
          'count' => 0,
        );
      }

      foreach ($allowed_identifiers as $id_type) {

        if (isset($identifiers[$id_type])) {

          $element[$id_type] = $identifiers[$id_type];
        }
        else {

          unset($element[$id_type]);
        }
      }

      // If we have found a matching derivative either with the identifiers or
      // by other modules through hook_tether_stats_url, then we must apply it
      // to the element.
      if (!empty($conditions['derivative_id'])) {

        $element['derivative_id'] = $conditions['derivative_id'];
      }

      if (empty($element['entity_id'])) {

        // Make sure the entity_type is NULL if there is no id.
        $element['entity_type'] = NULL;
      }
      elseif (empty($element['url']) && $allow_creation) {

        // Try to set the url based off the entity if it doesn't have one.
        db_set_active($old_db);
        $entity_info = entity_get_info($identifiers['entity_type']);
        $results = array();

        // Make sure we support this entity_type before we try to load it in
        // the off chance we are reading a foreign stats database.
        if (isset($entity_info)) {

          $results = entity_load($element['entity_type'], array($element['entity_id']));
        }

        if (!empty($results)) {
          $entity = reset($results);
          $uri = entity_uri($element['entity_type'], $entity);

          if (isset($uri)) {
            $element['url'] = $uri['path'];
          }
        }
        $old_db = db_set_active($database_id);
      }

      $element['changed'] = REQUEST_TIME;

      if (empty($element['created'])) {

        $element['created'] = REQUEST_TIME;
      }

      if (!empty($element['elid'])) {

        db_update('tether_stats_element')->fields($element)->condition('elid', $element['elid'], '=')
          ->execute();
        $element = (object) $element;

      }
      elseif ($allow_creation) {

        $element['elid'] = db_insert('tether_stats_element')->fields($element)
          ->execute();
        $element = (object) $element;

      }
      else {
        $element = FALSE;
      }
    }
    else {

      $element = (object) $element;
    }
  }
  db_set_active($old_db);

  return ($element);
}

/**
 * Builds an array of database conditions from an identity set.
 *
 * Loops through the set of identifiers and builds a corresponding
 * array of database conditions.
 *
 * @param array $identifiers
 *   The identity set for the element.
 * @param array $allowed_identifiers
 *   The list of allowed identifiers to use from the identifying set.
 * @param bool $allow_creation
 *   Set to FALSE if no element is to be created after processing these
 *   conditions. Some validation checks are not required if there is
 *   no chance of element creation.
 *
 * @return array
 *   An array of database conditions for use in querying an element
 *   defined by the identity set in the $identifiers parameter.
 */
function _tether_stats_process_conditions_from_identity_set(array $identifiers, array $allowed_identifiers, $allow_creation) {

  $conditions = array();
  $end_loop = FALSE;

  foreach ($allowed_identifiers as $id_type) {

    if (isset($identifiers[$id_type])) {

      $value = $identifiers[$id_type];

      switch ($id_type) {

        case 'name':
          // The name is a unique identifier so add no more conditions after
          // this.
          $conditions['name'] = $value;
          $end_loop = TRUE;
          break;

        case 'entity_id':
          if (!empty($identifiers['entity_type'])) {

            $conditions['entity_id'] = $value;
            $conditions['entity_type'] = $identifiers['entity_type'];

            // Test the existence of the entity if a new element can be created.
            // For queries that are simply reading old data this check is
            // invalid.
            if ($allow_creation) {
              $entity = NULL;
              $entity_entries = entity_load($conditions['entity_type'], array($conditions['entity_id']));

              if (!empty($entity_entries)) {

                $entity = reset($entity_entries);
              }

              if (!isset($entity)) {

                // Nonexistent entity specified, so return false.
                watchdog('tether_stats', "Attempted to create an element for a nonexistent entity with entity_id %entity_id and entity_type %entity_type.",
                  array(
                    '%entity_id' => $identifiers['entity_id'],
                    '%entity_id' => $identifiers['entity_type'],
                  ), WATCHDOG_WARNING);
                return FALSE;
              }
            }
          }
          else {

            // Invalid entity_id specified with no entity_type, so return false.
            watchdog('tether_stats', "Attempted to create an element for the entity_id %entity_id but no entity_type was specified.",
              array(
                '%entity_id' => $identifiers['entity_id'],
              ), WATCHDOG_WARNING);

            return FALSE;
          }
          break;

        case 'url':
          if (empty($conditions)) {

            // The url is a loose identifier so any previous identifiers negate
            // this requirement.
            $conditions['url'] = $value;
          }
          break;

      }

      if ($end_loop) {

        break;
      }
    }
  }
  return $conditions;
}

/**
 * Builds a dervative database condition from an identity set.
 *
 * Given an identity set with a derivative condition, finds the derivative_id
 * and adds it to an array of database conditions.
 *
 * @param array $identifiers
 *   The identity set of an element.
 * @param string $database_id
 *   The id of the database to use when accessing the stats tables.
 * @param bool $allow_creation
 *   Set to FALSE if no element is to be created after processing these
 *   conditions. Some validation checks are not required if there is
 *   no chance of element creation.
 *
 * @return array|false
 *   An array of database conditions to match the derivative defined from the
 *   identity set. If no derivative is defined in the identity set, then the
 *   array will be empty. Returns FALSE if an error occurred.
 */
function _tether_stats_process_derivative_conditions_from_identity_set(array $identifiers, $database_id, $allow_creation) {

  $conditions = array();

  $entity = NULL;
  $entity_type = NULL;
  $entity_bundle = NULL;

  // No validation checks are required if this process will not result in
  // a new element entry in the database.
  if (!$allow_creation) {

    $derivative = tether_stats_derivative_key_load($identifiers['derivative'], $database_id);
    $conditions['derivative_id'] = $derivative->id;
  }
  else {
    // The derivative field requires at least one other identifier as it is
    // not a unique identifier on its own.
    if (!empty($identifiers['entity_type'])) {

      $entity = NULL;
      $entity_entries = entity_load($identifiers['entity_type'], array($identifiers['entity_id']));

      if (!empty($entity_entries)) {

        $entity = reset($entity_entries);

        $entity_type = $identifiers['entity_type'];
        list(, , $entity_bundle) = entity_extract_ids($identifiers['entity_type'], $entity);
      }
    }

    if (_tether_stats_validate_derivative($identifiers['derivative'], $entity_type, $entity_bundle, $database_id)) {

      $derivative = tether_stats_derivative_key_load($identifiers['derivative'], $database_id);
      $conditions['derivative_id'] = $derivative->id;
    }
    else {

      return FALSE;
    }
  }
  return $conditions;
}

/**
 * Determines if the given derivative name is valid and applicable.
 *
 * @param string $derivative_name
 *   The name of the derivative.
 * @param string|null $entity_type
 *   The entity_type the derivative is to be applied to.
 * @param string|null $entity_bundle
 *   The bundle type the derivative is to be applied to.
 * @param string $database_id
 *   (Optional) Database Id to use instead of the default stats database.
 *
 * @return bool
 *   Returns TRUE if the derivative exists and can be applied to
 *   the given $entity_type and 4entity_bundle.
 */
function _tether_stats_validate_derivative($derivative_name, $entity_type = NULL, $entity_bundle = NULL, $database_id = NULL) {

  $is_valid = TRUE;
  $derivative = tether_stats_derivative_key_load($derivative_name, $database_id);

  if ($derivative !== FALSE) {

    if (isset($derivative->entity_type)) {

      if (isset($entity_type) && $derivative->entity_type == $entity_type) {

        if (isset($derivative->entity_bundle) && (!isset($entity_bundle) || $derivative->entity_bundle != $entity_bundle)) {

          // This derivative cannot be applied to this element due
          // to constraints.
          watchdog('tether_stats', 'Attempted to apply derivative %id_derivative to an entity bound stats element but the derivative may only be applied for entities with bundle type %entity_bundle.',
            array(
              '%id_derivative' => $derivative->name,
              '%entity_bundle' => $derivative->entity_bundle,
            ), WATCHDOG_WARNING);

          $is_valid = FALSE;
        }
      }
      else {

        // This derivative cannot be applied to this element due
        // to constraints.
        watchdog('tether_stats', 'Attempted to apply derivative %id_derivative to an entity bound stats element but the derivative may only be applied for %entity_type entities.',
          array(
            '%id_derivative' => $derivative->name,
            '%entity_type' => $derivative->entity_type,
          ), WATCHDOG_WARNING);

        $is_valid = FALSE;
      }
    }
  }
  else {

    // Invalid derivative.
    watchdog('tether_stats', 'The derivative %id_derivative was specified but no matching derivative could be found.',
      array(
        '%id_derivative' => $derivative_name,
      ), WATCHDOG_WARNING);

    $is_valid = FALSE;
  }

  return $is_valid;
}

/**
 * Implements hook_tether_stats_url().
 *
 * Set entity mapping for the url pages of node, user, and taxonomy_term
 * entities.
 */
function tether_stats_tether_stats_url(&$url, &$query) {

  $ret_value = FALSE;
  $base_uri = strtok($url, '?');
  $src = drupal_get_normal_path($base_uri);

  if ($src) {

    $parts = explode('/', $src);

    if (count($parts) == 2 && is_numeric($parts[1])) {

      switch ($parts[0]) {

        case 'node':

          $ret_value = array(
            'entity_type' => $parts[0],
            'entity_id' => (int) $parts[1],
            'url' => $url,
          );

          if (variable_get('tether_stats_allow_query_string_to_define_new_elements', FALSE)) {

            $ret_value['query'] = $query;
          }
          break;

        case 'term':
          $url = $base_uri;

          $ret_value = array(
            'entity_type' => 'taxonomy_term',
            'entity_id' => (int) $parts[1],
            'url' => $url,
          );

          if (variable_get('tether_stats_allow_query_string_to_define_new_elements', FALSE)) {

            $ret_value['query'] = $query;
          }
          break;

      }
    }
  }
  return $ret_value;
}

/**
 * Track an activity.
 *
 * @param array $params
 *   An associative array which contains the activity "type" as well as an
 *   identifying set for the element being tracked.
 * @param int $event_time
 *   (Optional) This parameter may be specified in place of the current
 *   request time. This allows you to backdate the activity to be tracked
 *   and is only useful for generating test data.
 *
 * @return array
 *   An associative array containing:
 *     - elid: The element id of the element identified by $params.
 *     - alid: The activity log id if the event was tracked.
 *     - status: Boolean indicating success of the event tracking.
 */
function _tether_stats_track_element(array $params, $event_time = REQUEST_TIME) {
  global $user;
  static $impressed_elements = array();

  $allowed_types = array('hit', 'impression', 'click');

  $type = $params['type'] ? $params['type'] : 'hit';
  $output_data = array(
    'status' => FALSE,
  );

  if (!empty($params['elid'])) {

    $element = tether_stats_element_load($params['elid']);
  }
  else {

    $element = tether_stats_get_element($params);
  }

  if (in_array($type, $allowed_types) && $element) {

    $output_data['elid'] = $element->elid;

    $hour = strtotime(date("Y-m-d H:00:00", $event_time));
    $day = strtotime(date("Y-m-d", $event_time));
    $month = strtotime(date("Y-m-01", $event_time));
    $year = strtotime(date("Y-01-01", $event_time));

    $old_db = db_set_active(tether_stats_set_db());

    $transaction = db_transaction();

    try {

      $hour_count = db_select('tether_stats_hour_count', 'c')->fields('c')->condition('elid', $element->elid, '=')
        ->condition('type', $type, '=')->condition('hour', $hour, '=')->execute()->fetchAssoc();

      if ($hour_count !== FALSE) {

        db_update('tether_stats_hour_count')->fields(array('timestamp' => $event_time))
          ->expression('count', 'count + 1')
          ->condition('hcid', $hour_count['hcid'], '=')->execute();
      }
      else {

        db_insert('tether_stats_hour_count')->fields(array(
          'elid' => $element->elid,
          'type' => $type,
          'count' => 1,
          'hour' => $hour,
          'day' => $day,
          'month' => $month,
          'year' => $year,
          'timestamp' => $event_time,
        ))->execute();
      }

      switch ($type) {

        case 'hit':
        case 'click':
          db_update('tether_stats_element')->fields(array('last_activity' => $event_time))
            ->expression('count', 'count + 1')
            ->condition('elid', $element->elid, '=')->execute();

          $activity = array();

          $activity['elid'] = $element->elid;
          $activity['type'] = $type;
          $activity['ip_address'] = ip_address();
          $activity['sid'] = session_id();
          $activity['browser'] = $_SERVER['HTTP_USER_AGENT'];
          $activity['created'] = $event_time;
          $activity['hour'] = $hour;
          $activity['day'] = $day;
          $activity['month'] = $month;
          $activity['year'] = $year;

          if ($user) {

            $activity['uid'] = $user->uid;
          }

          if ($params['referrer']) {

            $activity['referrer'] = $params['referrer'];
          }

          $output_data['alid'] = db_insert('tether_stats_activity_log')->fields($activity)->execute();
          break;

        case 'impression':
          if (is_numeric($params['alid'])) {

            if (!isset($impressed_elements[$params['alid']])) {

              $impressed_elements[$params['alid']] = array();
            }

            if (!in_array($element->elid, $impressed_elements[$params['alid']])) {

              $impression = array();

              $impression['alid'] = $params['alid'];
              $impression['elid'] = $element->elid;

              $impressed_elements[$params['alid']][] = $element->elid;
              db_insert('tether_stats_impression_log')->fields($impression)->execute();
            }
          }
          break;

      }
      $output_data['status'] = TRUE;

    }
    catch (Exception $e) {

      $transaction->rollback();
      watchdog_exception('tether_stats', $e);
    }
    db_set_active($old_db);
  }
  return ($output_data);
}

/**
 * Tests whether the derivative name already exists for the given entity type.
 *
 * @param string $name
 *   The machine_name of the derivative.
 *
 * @return bool
 *   Returns TRUE of FALSE depending on whether a derivative with the name
 *   already exists.
 */
function tether_stats_derivative_name_exists($name) {

  $derivative = tether_stats_derivative_key_load($name);
  return $derivative !== FALSE;
}

/**
 * Generates a link that will record click events.
 *
 * Uses the l function but adds additional options that will make the link
 * record click events.
 *
 * @param array $identifying_set
 *   Array of identifer => value entries which uniquely define an element for
 *   this stat.
 * @param string $text
 *   The translated link text for the anchor tag.
 * @param string $path
 *   The url of the path to pass into the l() function.
 * @param array $options
 *   An array of options to pass into the l() function.
 *
 * @return string
 *   The html string of the link as returned by the l() function.
 */
function tether_stats_l(array $identifying_set, $text, $path, array $options = array()) {

  if (!isset($options['attributes'])) {

    $options['attributes'] = array();
  }

  $options['attributes']['class'] = 'tether_stats-track-link';

  foreach ($identifying_set as $identifier => $value) {

    $options['attributes']["data-{$identifier}"] = $value;
  }

  return l($text, $path, $options);
}

/**
 * Get an array of all derivatives.
 *
 * @param bool $reset
 *   If TRUE, forces the static cache to reset.
 *
 * @return array
 *   An associative array  of the following form:
 *     array(
 *       {entity_type or '*'} => array(
 *         {bundle or '*'} => array(
 *           {derivative name} => {derivative object},
 *           ...
 *         ),
 *         ...
 *       ),
 *       ...
 *     )
 */
function _tether_stats_get_derivatives($reset = FALSE) {
  $derivatives =& drupal_static(__FUNCTION__);

  if (!isset($derivatives) || $reset) {

    $derivatives = array();

    $old_db = db_set_active(tether_stats_set_db());
    $result = db_select('tether_stats_derivative', 'd')->fields('d')
      ->orderBy('weight')->orderBy('entity_type')->orderBy('entity_bundle')->orderBy('name')->execute()->fetchAllAssoc('id');
    db_set_active($old_db);

    foreach ($result as $entry) {

      $bundle = isset($entry->entity_bundle) ? $entry->entity_bundle : '*';
      $type = isset($entry->entity_type) ? $entry->entity_type : '*';

      $derivatives[$type][$bundle][$entry->name] = $entry;
    }
  }

  return $derivatives;
}

/**
 * Gets all entity types as an options array.
 *
 * @return array
 *   An associative array of the following form:
 *     array(
 *       {entity_type label} => array(
 *         {bundle id string} => {bundle label},
 *         ...
 *       ),
 *       ...
 *     )
 *   The {bundle id string} is a string of the form "{entity_type}:{bundle}"
 *   or "*:*" to represent non-entity type or bundle specific derivatives.
 */
function _tether_stats_get_entity_type_options() {

  $options = array();

  $entity_types = entity_get_info();

  foreach ($entity_types as $entity_type => $info) {

    $options[$info['label']]["{$entity_type}:*"] = t("any !entity_type bundle", array('!entity_type' => $info['label']));

    if (!empty($info['bundles']) && count($info['bundles']) > 1) {

      foreach ($info['bundles'] as $bundle_id => $bundle) {

        $options[$info['label']]["{$entity_type}:{$bundle_id}"] = $bundle['label'];
      }
    }
  }
  return $options;
}

/**
 * Gets an array of human readable descriptors of a given stats element.
 *
 * @param object $element
 *   The Tether Stats element object.
 *
 * @return string[]
 *   An array of html string descriptors.
 */
function tether_stats_describe_element($element) {

  $descriptors = array('<label>' . t('Element Id') . "</label> {$element->elid}");

  if (isset($element->name)) {

    $name = check_plain($element->name);
    $descriptors[] = '<label>' . t('Has unique identifier') . "</label> {$name}";
  }
  elseif (isset($element->entity_type)) {

    $entity_types = entity_get_info();

    if (!isset($element->entity_type)) {

      $url = check_url($element->url);
      $descriptors[] = '<label>' . t('Page of path') . "</label> {$url}";

    }
    elseif (isset($entity_types[$element->entity_type])) {

      $descriptors[] = '<label>' . t('Entity of type') . "</label> {$element->entity_type}";
      $descriptors[] = '<label>' . t('Entity Id') . "</label> {$element->entity_id}";

      $entity_info = $entity_types[$element->entity_type];
      $entity = FALSE;

      if (function_exists($entity_info['load hook'])) {

        $entity = call_user_func($entity_info['load hook'], $element->entity_id);
      }

      if ($entity === FALSE) {

        $descriptors[] = '<em>' . t('Entity does not exist. It may have been deleted.') . '</em>';
      }

      switch ($element->entity_type) {

        case 'node':
          if ($entity !== FALSE) {

            $title = check_plain($entity->title);
            $descriptors[] = '<label>' . t('Title') . "</label> {$title}";

            if (isset($entity->path)) {

              $path = check_url($entity->path);
              $descriptors[] = '<label>' . t('Path') . "</label> {$path}";
            }
          }
          break;

        case 'user':
          $user = user_load($element->entity_id);

          if ($user !== FALSE) {

            $name = check_plain($user->name);
            $descriptors[] = '<label>' . t('Name') . "</label> {$name}";
          }
          break;

        case 'term':
          $term = taxonomy_term_load($element->entity_id);

          if ($term !== FALSE) {

            $name = check_plain($term->name);
            $descriptors[] = '<label>' . t('Name') . "</label> {$name}";
          }
          break;

        default:
          $descriptors[] = '<label>' . t('Entity of type') . "</label> {$element->entity_type}";
          $descriptors[] = '<label>' . t('Entity Id') . "</label> {$element->entity_id}";
          break;

      }
    }
    else {

      $descriptors[] = '<label>' . t('Entity of type') . "</label> {$element->entity_type}";
      $descriptors[] = '<label>' . t('Entity Id') . "</label> {$element->entity_id}";

      $descriptors[] = '<em>' . t('Matching entity type cannot be found. It may have been removed.') . '</em>';
    }
  }
  return $descriptors;
}

/**
 * Get or set the set of path filter rules from cache.
 *
 * Sets the filter_rule cache with the param $filters as an array
 * of filter rules if $filters is not NULL.
 *
 * @param array $filters
 *   (Optional) An array of filter rules to set to the cache.
 *
 * @return array
 *   A set of filter rules from cache or a default set if the cache does
 *   not exist.
 */
function _tether_stats_filter_rules(array $filters = NULL) {

  $default_filters = array(
    'admin',
    'sites/default/files',
    'node/add',
    'node/#/delete',
    'node/#/edit',
    'system',
    'tether_stats',
  );

  if (isset($filters) && is_array($filters)) {

    $default_filters = $filters;
    cache_set('tether_stats_filter', $default_filters);

  }
  elseif ($cache = cache_get('tether_stats_filter')) {

    $default_filters = $cache->data;
  }
  return $default_filters;
}
