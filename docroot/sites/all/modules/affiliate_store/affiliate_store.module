<?php

/**
 * @file
 * Set up web store for selling products from merchants via affiliate
 * relationship.
 */

/**
 * Hub name.
 * @var string
 */
define('AFFILIATE_STORE_HUB', 'EarnHighway');
/**
 * Hub URL.
 * @var string
 */
define('AFFILIATE_STORE_HUB_URL', 'http://hub.earnhighway.com');
/**
 * Service endpoint URL.
 * @var string
 */
define('AFFILIATE_STORE_API_URL', 'http://api.earnhighway.com');
/**
 * Affiliate link endpoint URL.
 * @var string
 */
define('AFFILIATE_STORE_GO_API_URL', AFFILIATE_STORE_API_URL . '/go');
/**
 * Maximum batch error count before giving up a batch.
 * @var int
 */
define('AFFILIATE_STORE_BATCH_MAX_ERROR', 10);

/**
 * Implements hook_block_info().
 */
function affiliate_store_block_info() {
  $blocks['categories'] = array(
    'info' => t('Affiliate store categories'),
    'cache' => DRUPAL_CACHE_PER_PAGE,
  );
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function affiliate_store_block_view($delta = '') {
  $block = array();
  if (($delta === 'categories')
    && user_access('access affiliate store product')
  ) {
    $block['subject'] = l(affiliate_store_title(t('Store')), 'affiliate-store');
    $block['content'] = array(
      '#theme' => 'affiliate_store_menu',
      '#tree' => affiliate_store_get_category_tree(),
    );
  }
  return $block;
}

/**
 * Implements hook_cron().
 *
 * Update affiliate store.
 */
function affiliate_store_cron() {
  affiliate_store_include('common');

  // Skip if automatic update is disabled or there is error in affiliate store
  // setup.
  if (!variable_get('affiliate_store_auto_update', TRUE)
    || affiliate_store_setup_error()
  ) {
    return;
  }

  affiliate_store_cron_update();
}

/**
 * Implements hook_node_info().
 */
function affiliate_store_node_info() {
  return array(
    'affiliate_store_product' => array(
      'name' => t('Affiliate store product'),
      'base' => 'affiliate_store',
      'description' => t(
        'Product that will be shown in affiliate store for sale.'
      ),
      'help' => t(
        'Affiliate Store module currently does not support overriding ' .
        'individual fields with custom content, so changes you made to ' .
        'product imported from Hub will be lost in the next update.'
      ),
    ),
  );
}

/**
 * Implements hook_field_extra_fields().
 */
function affiliate_store_field_extra_fields() {
  $extra['node']['affiliate_store_product'] = array(
    'form' => array(
      'pid' => array(
        'label' => t('Product ID'),
        'description' => t('Affiliate store product ID textfield'),
        'weight' => 1,
      ),
      'price' => array(
        'label' => t('Price'),
        'description' => t('Affiliate store product price textfield'),
        'weight' => 2,
      ),
      'currency' => array(
        'label' => t('Currency'),
        'description' => t('Affiliate store product currency code textfield'),
        'weight' => 3,
      ),
      'url' => array(
        'label' => t('URL'),
        'description' => t('Affiliate store product URL textfield'),
        'weight' => 4,
      ),
      'thumb_url' => array(
        'label' => t('Thumbnail URL'),
        'description' => t('Affiliate store product thumbnail URL textfield'),
        'weight' => 5,
      ),
      'image_url' => array(
        'label' => t('Image URL'),
        'description' => t('Affiliate store product image URL textfield'),
        'weight' => 6,
      ),
    ),
  );
  return $extra;
}

/**
 * Implements hook_form().
 */
function affiliate_store_form($node, &$form_state) {
  $type = node_type_get_type($node);
  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => check_plain($type->title_label),
    '#maxlength' => 255,
    '#default_value' => $node->title,
    '#required' => TRUE,
    '#weight' => -5,
  );
  $form['pid'] = array(
    '#type' => 'textfield',
    '#title' => t('Product ID'),
    '#description' => t('Product unique ID assigned by merchant.'),
    '#maxlength' => 255,
    '#default_value' => isset($node->pid) ? $node->pid : '',
    '#required' => TRUE,
  );
  $form['price'] = array(
    '#type' => 'textfield',
    '#title' => t('Price'),
    '#default_value' => isset($node->price) ? $node->price : '',
  );
  $form['currency'] = array(
    '#type' => 'textfield',
    '#title' => t('Currency'),
    '#description' => t(
      'Standard 3-letter currency code. Default to USD if not specified.'
    ),
    '#maxlength' => 3,
    '#default_value' => isset($node->currency) ? $node->currency : '',
  );
  $form['url'] = array(
    '#type' => 'textfield',
    '#title' => t('URL'),
    '#description' => t('Product URL assigned by Hub.'),
    '#maxlength' => 255,
    '#default_value' => isset($node->url) ? $node->url : '',
    '#required' => TRUE,
  );
  $form['thumb_url'] = array(
    '#type' => 'textfield',
    '#title' => t('Thumbnail URL'),
    '#maxlength' => 255,
    '#default_value' => isset($node->thumb_url) ? $node->thumb_url : '',
  );
  $form['image_url'] = array(
    '#type' => 'textfield',
    '#title' => t('Image URL'),
    '#maxlength' => 255,
    '#default_value' => isset($node->image_url) ? $node->image_url : '',
  );
  return $form;
}

/**
 * Implements hook_validate().
 */
function affiliate_store_validate($node, &$form) {
  if (!empty($node->price) && !is_numeric($node->price)) {
    form_set_error('price', t('Price must be numeric.'));
  }
  if (!empty($node->currency) && (drupal_strlen($node->currency) != 3)) {
    form_set_error(
      'currency', t('Price currency must be standard 3-letter currency code.')
    );
  }
  if (!valid_url($node->url, TRUE)) {
    form_set_error('url', t('Invalid product URL.'));
  }
  if (!empty($node->thumb_url) && !valid_url($node->thumb_url, TRUE)) {
    form_set_error('thumb_url', t('Invalid product thumbnail URL.'));
  }
  if (!empty($node->image_url) && !valid_url($node->image_url, TRUE)) {
    form_set_error('image_url', t('Invalid product image URL.'));
  }
}

/**
 * Implements hook_load().
 */
function affiliate_store_load($nodes) {
  $vids = array();
  foreach ($nodes as $node) {
    $vids[] = $node->vid;
  }

  $result = db_query(
    "SELECT * FROM {affiliate_store_product} WHERE vid IN (:vids)",
    array(':vids' => $vids),
    array('fetch' => PDO::FETCH_ASSOC)
  );
  foreach ($result as $record) {
    foreach ($record as $field => $value) {
      $nodes[$record['nid']]->$field = $value;
    }
  }
}

/**
 * Implements hook_insert().
 */
function affiliate_store_insert($node) {
  $fields = array(
    'vid', 'nid', 'pid', 'price', 'currency', 'url', 'thumb_url', 'image_url',
  );
  $fields = array_intersect_key((array) $node, array_flip($fields));
  // If field is set but empty, database default value will be used instead.
  $fields = array_filter($fields);
  // Get term IDs from node.
  foreach (affiliate_store_vocabularies() as $vocab => $info) {
    $tid = affiliate_store_get_data('node', $node, "_$vocab");
    if ($tid) {
      $fields[$info['as'] . 'tid'] = $tid[0]['tid'];
    }
  }

  db_insert('affiliate_store_product')
    ->fields($fields)
    ->execute();
}

/**
 * Implements hook_update().
 */
function affiliate_store_update($node) {
  // Insert as new record if this is new revision.
  if (!empty($node->revision)) {
    affiliate_store_insert($node);
    return;
  }

  $fields = array('pid', 'price', 'currency', 'url', 'thumb_url', 'image_url');
  $fields = array_intersect_key((array) $node, array_flip($fields));
  // Get term IDs from node.
  foreach (affiliate_store_vocabularies() as $vocab => $info) {
    $tid = affiliate_store_get_data('node', $node, "_$vocab");
    $fields[$info['as'] . 'tid'] = $tid ? $tid[0]['tid'] : 0;
  }

  db_update('affiliate_store_product')
    ->fields($fields)
    ->condition('vid', $node->vid)
    ->execute();
}

/**
 * Implements hook_delete().
 */
function affiliate_store_delete($node) {
  db_delete('affiliate_store_product')
    ->condition('nid', $node->nid)
    ->execute();
}

/**
 * Implements hook_view().
 */
function affiliate_store_view($node, $view_mode) {
  $categories = array('category', 'subcategory', 'subsubcategory');
  $use_general = variable_get('affiliate_store_product_use_general', FALSE);
  $vocabs = affiliate_store_vocabularies();
  foreach (array_keys($vocabs) as $vocab) {
    $tid = affiliate_store_get_data('node', $node, "_$vocab");
    // Hide pseudo general categories if not used. Actually this also hides
    // unknown network and merchant.
    if ($tid
      && !$use_general
      && ($tid[0]['tid'] == affiliate_store_get_term_id('', $vocab))
    ) {
      affiliate_store_delete_data('node', $node, "_$vocab");
    }
    // Substitute category term with its synonym if defined.
    elseif (!empty($tid[0]['taxonomy_term'])
      && in_array($vocab, $categories, TRUE)
    ) {
      $term = $tid[0]['taxonomy_term'];
      $term->name = affiliate_store_get_term_synonym($term, $term->name);
      $vocabs[$vocab]['term'] = $term;
    }
  }

  if (($view_mode === 'full') && node_is_page($node)) {
    // Build breadcrumb with trail of product categories.
    $breadcrumb = array(l(t('Home'), NULL));
    $breadcrumb[] = l(affiliate_store_title(t('Store')), 'affiliate-store');
    $parent = '';
    foreach ($vocabs as $info) {
      if (isset($info['term'])) {
        $term = $info['term'];
        $tids = affiliate_store_get_term_ids($term->name, $term->vid);
        $tids = implode('+', $tids);
        $breadcrumb[] = l($term->name, "affiliate-store/term/{$tids}{$parent}");
        $parent = ",{$tids}{$parent}";
      }
    }
    drupal_set_breadcrumb($breadcrumb);
  }

  // Make product URL site friendly.
  $node->url = affiliate_store_convert_product_url($node->url);
  return $node;
}

/**
 * Implements hook_node_access().
 */
function affiliate_store_node_access($node, $op, $account) {
  // $node can be node type string or node object.
  $type = is_string($node) ? $node : $node->type;
  if ($type !== 'affiliate_store_product') {
    // Ignore if node type is not managed by this module.
    return NODE_ACCESS_IGNORE;
  }
  elseif (!in_array($type, node_permissions_get_configured_types(), TRUE)) {
    // Ignore if permission checking is decidedly skip by some other modules.
    return NODE_ACCESS_IGNORE;
  }

  if ($op === 'view') {
    // Deny access if this permission is absent because Drupal defaults to
    // grant view access if no any rules deny it.
    return user_access('access affiliate store product', $account) ?
      NODE_ACCESS_ALLOW : NODE_ACCESS_DENY;
  }
  return NODE_ACCESS_IGNORE;
}

/**
 * Implements hook_node_revision_delete().
 */
function affiliate_store_node_revision_delete($node) {
  if ($node->type === 'affiliate_store_product') {
    db_delete('affiliate_store_product')
      ->condition('vid', $node->vid)
      ->execute();
  }
}

/**
 * Get categories and their associated subcategories as a tree based on current
 * path.
 *
 * Category mapping will be taken into account when building out the tree.
 *
 * @return array
 *   A associative array of category items keyed by category name. Each
 *   category item is an associative array with the following keys:
 *   - name: Name of category. Synonym will be used instead if it is defined.
 *   - description: Description of category. If several categories are merged
 *     together, the first non-empty description will be used.
 *   - vocabulary: Vocabulary logical name that contains the category.
 *   - vid: Vocabulary ID that contains the category.
 *   - tids: An array of term IDs associated with this category possibly
 *     through category mapping.
 *   - path: Internal path to category term page.
 *   - active: (optional) TRUE if the category term page is currently being
 *     viewed.
 *   - children: (optional) Subcategories as nested tree if any.
 *   - parent: (optional) A reference to parent tree of the category if any.
 *
 * @see affiliate_store_vocabularies()
 */
function affiliate_store_get_category_tree() {
  $tree = &drupal_static(__FUNCTION__);

  if (isset($tree)) {
    return $tree;
  }

  // Mark currently viewed terms as active.
  $active = array();
  // By convention, additional group of term IDs are parent term IDs.
  $has_parent = FALSE;
  // Get currently viewed term IDs from URL.
  if (preg_match('#^/?affiliate-store/term/(.*)$#', $_GET['q'], $matches)) {
    $terms = affiliate_store_terms_parse_string($matches[1]);
    $has_parent = (count($terms) > 1);
    foreach ($terms as $group) {
      $active = array_merge($active, $group);
    }
  }

  // Mapping of category, subcategory, and subsubcategory to their parent term
  // IDs, needed for JOIN decomposition.
  $map = array();
  $result = db_query(
    "SELECT DISTINCT ctid, sctid, ssctid FROM {affiliate_store_product}"
  );
  foreach ($result as $term) {
    // The array key is used to prevent duplicate entry of parents.
    $map['category'][$term->ctid][0] = array();
    $map['subcategory'][$term->sctid][$term->ctid] = array($term->ctid);
    $map['subsubcategory'][$term->ssctid]["$term->ctid:$term->sctid"] = array(
      $term->ctid, $term->sctid,
    );
  }

  // Create tree branches based on relationship between categories.
  $tree = array();
  // Store term names after synonyms substitution.
  $names = array();
  $use_general = variable_get('affiliate_store_product_use_general', FALSE);
  foreach ($map as $vocab => $relation) {
    $miss_tid = affiliate_store_get_term_id('', $vocab);
    $vid = affiliate_store_get_vocabulary_id($vocab);
    $tids = db_query(
      "SELECT tid FROM {taxonomy_term_data}
      WHERE vid = :vid
      ORDER BY weight, name",
      array(':vid' => $vid)
    )->fetchCol();
    // Filter out terms that are not in product database.
    $tids = array_intersect($tids, array_keys($relation));
    $terms = taxonomy_term_load_multiple($tids);
    foreach ($terms as $tid => $term) {
      // Hide pseudo general categories if not used.
      if (!$use_general && ($tid == $miss_tid)) {
        continue;
      }

      $names[$tid] = affiliate_store_get_term_synonym($term, $term->name);
      $name = $names[$tid];

      foreach ($relation[$tid] as $parents) {
        // Search for the branch on which the term should lives.
        $branch = &$tree;
        unset($parent);
        $skip = FALSE;
        foreach ($parents as $ptid) {
          if (!isset($names[$ptid])) {
            // Parent tree may not exists if it is a pseudo general category.
            // But this situation should not happens as pseudo general
            // category does not have children.
            $skip = TRUE;
            break;
          }
          $parent = &$branch[$names[$ptid]];
          $branch = &$parent['children'];
        }
        if ($skip) {
          continue;
        }
        $branch = &$branch[$name];

        // Create or update existing branch.
        if (!$branch) {
          $branch = array(
            'name' => $name,
            'vocabulary' => $vocab,
            'vid' => $term->vid,
            'tids' => array(),
          );
          if (isset($parent)) {
            $branch['parent'] = &$parent;
          }
        }
        if (empty($branch['description'])) {
          // Use the 1st non-empty description.
          $branch['description'] = $term->description;
        }
        $branch['tids'][] = $tid;
      }
    }
  }

  // Build term paths.
  // Parent path will be appended to the right of its immediate child.
  // If there is no term parent in currently viewed terms, all found parents
  // will be marked as active.
  foreach (array_keys($tree) as $cname) {
    $category = &$tree[$cname];
    $category['path'] = implode('+', $category['tids']);
    $category['active'] = (bool) array_intersect($category['tids'], $active);
    if (!empty($category['children'])) {
      foreach (array_keys($category['children']) as $scname) {
        $subcategory = &$category['children'][$scname];
        $subcategory['path'] = implode('+', $subcategory['tids']);
        if (array_intersect($subcategory['tids'], $active)) {
          $subcategory['active'] = TRUE;
          $category['active'] = $has_parent ? $category['active'] : TRUE;
        }
        if (!empty($subcategory['children'])) {
          foreach (array_keys($subcategory['children']) as $sscname) {
            $subsubcategory = &$subcategory['children'][$sscname];
            $subsubcategory['path'] = 'affiliate-store/term/';
            $subsubcategory['path'] .= implode('+', $subsubcategory['tids']);
            $subsubcategory['path'] .= ',' . $subcategory['path'];
            $subsubcategory['path'] .= ',' . $category['path'];
            if (array_intersect($subsubcategory['tids'], $active)) {
              $subsubcategory['active'] = TRUE;
              if (!$has_parent) {
                $category['active'] = TRUE;
                $subcategory['active'] = TRUE;
              }
            }
          }
        }
        $subcategory['path'] = 'affiliate-store/term/' . $subcategory['path'];
        $subcategory['path'] .= ',' . $category['path'];
      }
    }
    $category['path'] = 'affiliate-store/term/' . $category['path'];
  }

  return $tree;
}

/**
 * Get module managed term ID from permanent name.
 *
 * Specify empty $name to get the ID of vocabulary missing term default value.
 *
 * Term will be created if not exists.
 *
 * @param string $name
 *   Term permanent name.
 * @param string $vocabulary
 *   Vocabulary logical name of term.
 *
 * @return int
 *   Term ID if successful, 0 otherwise.
 *
 * @see affiliate_store_vocabularies()
 * @see affiliate_store_get_term_name()
 * @see affiliate_store_save_term()
 */
function affiliate_store_get_term_id($name, $vocabulary) {
  $cache = &drupal_static(__FUNCTION__, array());

  if (isset($cache["$name:$vocabulary"])) {
    return $cache["$name:$vocabulary"];
  }
  $cache_name = $name;

  $vocabs = affiliate_store_vocabularies();
  if (!isset($vocabs[$vocabulary])) {
    return 0;
  }
  // Assign vocabulary missing term default value if name is empty.
  if (!$name) {
    $name = affiliate_store_get_term_name(0, $vocabulary);
  }

  $tid = (int) db_query(
    "SELECT {$vocabs[$vocabulary]['as']}tid FROM {affiliate_store_$vocabulary}
    WHERE title = :title",
    array(':title' => drupal_strtolower($name))
  )->fetchField();
  // Create the term if not exists.
  if (!$tid) {
    affiliate_store_include('common');
    $tid = affiliate_store_save_term($name, $vocabulary);
  }
  $cache["$cache_name:$vocabulary"] = $tid;
  return $tid;
}

/**
 * Get module managed term IDs from name or synonym.
 *
 * @param string $search
 *   Search string. Exact matching is used.
 * @param mixed $vocabulary
 *   Vocabulary ID or vocabulary logical name of terms to search.
 *
 * @return array
 *   IDs of term whose name or synonym matches the search string.
 *
 * @see affiliate_store_vocabularies()
 */
function affiliate_store_get_term_ids($search, $vocabulary) {
  $cache = &drupal_static(__FUNCTION__, array());

  if (isset($cache["$search:$vocabulary"])) {
    return $cache["$search:$vocabulary"];
  }

  $terms = array();
  $vid = (
    is_numeric($vocabulary) ?
    (int) $vocabulary : affiliate_store_get_vocabulary_id($vocabulary)
  );
  $terms += db_query(
    "SELECT tid FROM {taxonomy_term_data} WHERE vid = :vid AND name = :name",
    array(':vid' => $vid, ':name' => $search)
  )->fetchAllKeyed(0, 0);

  // Also find terms with synonym that matches the search string.
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'taxonomy_term');
  $query->propertyCondition('vid', $vid);
  $query->fieldCondition('affiliate_store_synonym', 'value', $search);
  $result = $query->execute();
  if (!empty($result['taxonomy_term'])) {
    $terms += drupal_map_assoc(array_keys($result['taxonomy_term']));
  }

  sort($terms);
  $cache["$search:$vocabulary"] = $terms;
  return $terms;
}

/**
 * Get term permanent name from term ID.
 *
 * Specify $tid = 0 and $default = NULL to get the vocabulary missing term
 * default value.
 *
 * @param int $tid
 *   Term ID.
 * @param string $vocabulary
 *   Vocabulary logical name of term.
 * @param mixed $default
 *   (optional) Default value to return if term ID not found. Default to NULL
 *   meaning use value as configured at settings page for case when product
 *   vocabulary term is missing.
 *
 * @return string
 *   Term permanent name of the specified term ID, or default value if term ID
 *   not found. Return empty string if vocabulary is not managed by affiliate
 *   store.
 *
 * @see affiliate_store_vocabularies()
 * @see affiliate_store_get_term_id()
 */
function affiliate_store_get_term_name($tid, $vocabulary, $default = NULL) {
  $vocabs = affiliate_store_vocabularies();
  if (!isset($vocabs[$vocabulary])) {
    return '';
  }

  $name = NULL;
  if ($tid > 0) {
    $name = db_query(
      "SELECT title FROM {affiliate_store_$vocabulary}
      WHERE {$vocabs[$vocabulary]['as']}tid = :tid",
      array(':tid' => $tid)
    )->fetchField();
  }
  if (!$name) {
    $name = ($default === NULL) ? $vocabs[$vocabulary]['miss'] : $default;
  }
  return $name;
}

/**
 * Get module managed term synonym.
 *
 * @param mixed $tid
 *   Term object (preferable) or ID.
 * @param mixed $default
 *   (optional) Default value to return if term synonym not found. Default to
 *   empty string.
 *
 * @return mixed
 *   Term synonym, or default value if term synonym not found.
 */
function affiliate_store_get_term_synonym($tid, $default = '') {
  $cache = &drupal_static(__FUNCTION__, array());
  $id = is_numeric($tid) ? $tid : $tid->tid;

  if (!isset($cache[$id])) {
    $term = is_numeric($tid) ? taxonomy_term_load($tid) : $tid;
    $synonym = affiliate_store_get_data('taxonomy_term', $term, '_synonym');
    $cache[$id] = $synonym ? $synonym[0]['value'] : FALSE;
  }
  // Make sure default value is not cached.
  return ($cache[$id] !== FALSE) ? $cache[$id] : $default;
}

/**
 * Get module managed vocabulary ID from logical name.
 *
 * Vocabulary will be created if not exists.
 *
 * @param string $name
 *   Vocabulary logical name.
 *
 * @return int
 *   Vocabulary ID if successful, 0 otherwise.
 *
 * @see affiliate_store_vocabularies()
 * @see affiliate_store_get_vocabulary_name()
 * @see affiliate_store_save_vocabulary()
 */
function affiliate_store_get_vocabulary_id($name) {
  $vid = variable_get("affiliate_store_vid_$name", 0);
  if (!$vid || !taxonomy_vocabulary_load($vid)) {
    affiliate_store_include('common');
    return affiliate_store_save_vocabulary($name);
  }
  return $vid;
}

/**
 * Get vocabulary logical name from vocabulary ID.
 *
 * @param int $vid
 *   Vocabulary ID.
 *
 * @return string
 *   Vocabulary logical name, or empty string if vocabulary ID is not managed
 *   by affiliate store.
 *
 * @see affiliate_store_vocabularies()
 * @see affiliate_store_get_vocabulary_id()
 */
function affiliate_store_get_vocabulary_name($vid) {
  $cache = &drupal_static(__FUNCTION__);

  if (!$cache) {
    $cache = array();
    foreach (array_keys(affiliate_store_vocabularies()) as $vocab) {
      $cache[variable_get("affiliate_store_vid_$vocab", 0)] = $vocab;
    }
  }
  return (($vid > 0) && isset($cache[$vid])) ? $cache[$vid] : '';
}

/**
 * Get entity field data.
 *
 * @param string $type
 *   Entity type.
 * @param object $entity
 *   Entity containing the field data.
 * @param string $field
 *   Entity field name. Can be shortened by using underscore prefix to use
 *   module namespace.
 * @param string $langcode
 *   (optional) The language code of entity field to select. Default to NULL
 *   meaning use current language.
 *
 * @return mixed
 *   An array of field data keyed by delta if available, FALSE otherwise.
 *
 * @see field_get_items()
 * @see _affiliate_store_prefix()
 */
function affiliate_store_get_data($type, $entity, $field, $lang = NULL) {
  $field = _affiliate_store_prefix($field);
  return field_get_items($type, $entity, $field, $lang);
}

/**
 * Save entity field data.
 *
 * Data will be saved for matching deltas only. Unrelated deltas won't be
 * affected.
 *
 * @param mixed $data
 *   A delta indexed array of items, each item is an associative array of field
 *   column and value pairs. Column names are dependent on field type. If item
 *   is scalar, it is assumed to be the value of column 'value'. If $data is
 *   scalar, it is assumed to have delta of 0 and a single item that is $data.
 *
 * @see affiliate_store_get_data()
 * @see _affiliate_store_prefix()
 */
function affiliate_store_save_data($type, $entity, $field, $data,
$lang = NULL) {
  $field = _affiliate_store_prefix($field);
  $data = is_array($data) ? $data : array($data);
  $lang = field_language($type, $entity, $field, $lang);

  foreach ($data as $delta => $items) {
    $items = is_array($items) ? $items : array('value' => $items);
    foreach ($items as $column => $value) {
      $entity->{$field}[$lang][$delta][$column] = $value;
    }
  }
}

/**
 * Delete entity field data.
 *
 * @param mixed $data
 *   (optional) A delta indexed array of items, each item is an array of column
 *   names whose value to delete. Column names are dependent on field type. If
 *   item is scalar, it is assumed to be the only column name. If $data is
 *   scalar, it is assumed to have delta of 0 and a single item that is $data.
 *   Default to NULL meaning delete all field deltas.
 *
 * @see affiliate_store_get_data()
 * @see _affiliate_store_prefix()
 */
function affiliate_store_delete_data($type, $entity, $field, $data = NULL,
$lang = NULL) {
  $field = _affiliate_store_prefix($field);
  $lang = field_language($type, $entity, $field, $lang);
  if ($data === NULL) {
    unset($entity->{$field}[$lang]);
  }
  else {
    $data = is_array($data) ? $data : array($data);
    foreach ($data as $delta => $items) {
      $items = is_array($items) ? $items : array($items);
      foreach ($items as $column) {
        unset($entity->{$field}[$lang][$delta][$column]);
      }
    }
  }
}

/**
 * Implements hook_form_taxonomy_form_term_alter().
 *
 * Warn user of risk when modify terms managed by affiliate store.
 */
function affiliate_store_form_taxonomy_form_term_alter(&$form, &$form_state) {
  if (isset($form['#vocabulary'])
    && ($form['#vocabulary']->module === 'affiliate_store')
  ) {
    drupal_set_message(
      '<p>' .
      t('This vocabulary is managed by Affiliate Store module.') .
      '</p><p>' .
      t(
        'If you delete a term from this vocabulary, all affiliate store ' .
        'subscriptions and products associated with the term will also be ' .
        'deleted.'
      ) .
      '</p>',
      'warning', FALSE
    );
  }
}

// TODO: This only add validation for core taxonomy interface, user can still
// bypass validation through contrib module.
/**
 * Implements hook_form_taxonomy_form_vocabulary_alter().
 *
 * Warn user of risk when modify vocabularies managed by affiliate store, and
 * add validation function to prevent misconfiguration.
 */
function affiliate_store_form_taxonomy_form_vocabulary_alter(&$form,
&$form_state) {
  if (isset($form['module']['#value'])
    && ($form['module']['#value'] === 'affiliate_store')
  ) {
    drupal_set_message(
      '<p>' .
      t('This vocabulary is managed by Affiliate Store module.') .
      '</p><p>' .
      t(
        'If you delete this vocabulary, all affiliate store subscriptions ' .
        'and products associated with it will also be deleted.'
      ) .
      '</p>',
      'warning', FALSE
    );
  }
}

/**
 * Implements hook_taxonomy_term_delete().
 *
 * Delete affiliate store products when their associated terms are deleted.
 */
function affiliate_store_taxonomy_term_delete($term) {
  $vocab = affiliate_store_get_vocabulary_name($term->vid);
  if (!$vocab) {
    // Skip if the term is not managed by affiliate store.
    return;
  }

  $vocabs = affiliate_store_vocabularies();
  $col = $vocabs[$vocab]['as'] . 'tid';

  $txn = db_transaction();
  try {
    // Delete term from permanent name table.
    db_delete("affiliate_store_$vocab")
      ->condition($col, $term->tid)
      ->execute();

    // Delete subscriptions related to the term.
    db_delete('affiliate_store_subscription')
      ->condition($col, $term->tid)
      ->execute();

    // Delete nodes associated with term.
    $nids = db_query(
      "SELECT DISTINCT nid FROM {affiliate_store_product} WHERE $col = :tid",
      array(':tid' => $term->tid)
    )->fetchCol();
    node_delete_multiple($nids);
  }
  catch (Exception $e) {
    $txn->rollback();
    watchdog_exception('affiliate store', $e);
    throw $e;
  }
}

/**
 * Implements hook_taxonomy_vocabulary_delete().
 *
 * Clean up variable so that vocabulary can be created anew when accessed next
 * time.
 *
 * Nodes will be deleted properly because term deletion will occurs before
 * vocabulary deletion.
 */
function affiliate_store_taxonomy_vocabulary_delete($vocabulary) {
  if ($vocabulary->module !== 'affiliate_store') {
    // Skip if the vocabulary is not managed by affiliate store.
    return;
  }

  $vocab = affiliate_store_get_vocabulary_name($vocabulary->vid);
  if ($vocab) {
    variable_del("affiliate_store_vid_$vocab");
  }
}

/**
 * Parse comma and plus separated string of term IDs.
 *
 * This function differs from taxonomy_terms_parse_string() by allowing
 * mixing of comma and plus separated term IDs. However comma is parsed before
 * plus so that the end result is ANDed groups of ORed term IDs.
 *
 * @param string $str_tids
 *   A string of term IDs, separated by comma and plus.
 *   comma (,) means AND
 *   plus (+) means OR
 *
 * @return array
 *   An array of term ID groups that are ANDed together. Each group is an array
 *   of term IDs that are ORed together.
 *
 * @see taxonomy_terms_parse_string()
 */
function affiliate_store_terms_parse_string($str_tids) {
  $terms = array();
  foreach (explode(',', $str_tids) as $group) {
    if (preg_match('/^[0-9]+([+ ][0-9]+)*$/', $group)) {
      // The '+' character in a query string may be parsed as ' '.
      $terms[] = preg_split('/[+ ]/', $group);
    }
  }
  return $terms;
}

/**
 * Implements hook_url_outbound_alter().
 */
function affiliate_store_url_outbound_alter(&$path, &$options, $original_path) {
  // Replace URLs of terms managed by module so that they point to affiliate
  // store pages.
  if (preg_match('#^taxonomy/term/(\d+)$#', $path, $matches)) {
    $term = taxonomy_term_load($matches[1]);
    if (affiliate_store_in_vocabularies($term->vid)) {
      $name = affiliate_store_get_term_synonym($term, $term->name);
      $tids = affiliate_store_get_term_ids($name, $term->vid);
      $path = 'affiliate-store/term/' . implode('+', $tids);
    }
  }
}

/**
 * Determine whether a vocabulary is managed by affiliate store.
 *
 * @param mixed $vid
 *   Vocabulary logical name (preferable) or ID to check.
 * @param array $filter
 *   (optional) Vocabulary logical names to check against. Default to empty
 *   meaning check against all affiliate store managed vocabularies.
 *
 * @return boolean
 *   TRUE if the vocabulary is managed by affiliate store, FALSE otherwise.
 *
 * @see affiliate_store_vocabularies()
 */
function affiliate_store_in_vocabularies($vid, $filter = array()) {
  $vocab = is_numeric($vid) ? affiliate_store_get_vocabulary_name($vid) : $vid;
  $filter = $filter ? $filter : array_keys(affiliate_store_vocabularies());
  return in_array($vocab, $filter, TRUE);
}

/**
 * Get module managed vocabularies' information.
 *
 * Vocabularies managed by module are given logical names as below:
 * - network: Affiliate store networks.
 * - merchant: Affiliate store merchants.
 * - category: Affiliate store categories.
 * - subcategory: Affiliate store subcategories.
 * - subsubcategory: Affiliate store subsubcategories.
 *
 * @param array $filter
 *   (optional) Vocabulary logical names whose information to return. The
 *   returned vocabularies will also be reordered using the order in the
 *   filter. Default to empty meaning returns all.
 *
 * @return array
 *   An associative array keyed by vocabulary logical name, each value is also
 *   an associative array with the following keys:
 *   - as: Vocabulary alias. The alias is used mostly as prefix to database
 *     column name.
 *   - miss: Vocabulary missing term default value, used when an empty term is
 *     to be created in this vocabulary.
 *   Default order of returned vocabulary is network, merchant, category,
 *   subcategory, and subsubcategory.
 */
function affiliate_store_vocabularies($filter = array()) {
  $vocabs = array(
    'network' => array('as' => 'nw', 'miss' => '<unknown>'),
    'merchant' => array('as' => 'm', 'miss' => '<unknown>'),
    'category' => array('as' => 'c', 'miss' => '<general>'),
    'subcategory' => array('as' => 'sc', 'miss' => '<general>'),
    'subsubcategory' => array('as' => 'ssc', 'miss' => '<general>'),
  );
  if ($filter) {
    $ordered_vocabs = array();
    foreach ($filter as $vocab) {
      if (isset($vocabs[$vocab])) {
        $ordered_vocabs[$vocab] = $vocabs[$vocab];
      }
    }
    return $ordered_vocabs;
  }
  return $vocabs;
}

/**
 * Make product URL site friendly.
 *
 * @param string $url
 *   Original product URL.
 *
 * @return string
 *   Site friendly product URL, or the original URL with store ID appended if
 *   conversion failed.
 */
function affiliate_store_convert_product_url($url) {
  $match = preg_match(
    '#^' . preg_quote(AFFILIATE_STORE_GO_API_URL, '#') . '/([0-9a-f]{32,})$#',
    $url, $matches
  );
  if ($match) {
    return 'affiliate-store/go/' . $matches[1];
  }

  // Fall back to original URL with store ID appended if pattern not matched.
  return url($url, array('query' => array('store' => affiliate_store_id())));
}

/**
 * Menu callback; Redirect site URL friendly affiliate store product link.
 *
 * @param string $lid
 *   Product link ID.
 * @param boolean $return
 *   (optional) TRUE to return the final URL without redirect. Default to FALSE.
 *
 * @return mixed
 *   Original product URL assigned by Hub, or NULL if link ID is invalid.
 */
function affiliate_store_go($lid = NULL, $return = FALSE) {
  if (!preg_match('/^[0-9a-f]{32,}$/', $lid)) {
    return $return ? NULL : drupal_not_found();
  }

  $path = AFFILIATE_STORE_GO_API_URL . "/$lid";
  $query = array('store' => affiliate_store_id());
  if ($return) {
    return url($path, array('query' => $query));
  }
  else {
    drupal_goto($path, array('query' => $query));
  }
}

/**
 * Get affiliate store ID.
 *
 * @return string
 *   Affiliate store ID, which is the site host name.
 */
function affiliate_store_id() {
  global $base_url;
  $url = parse_url($base_url) + array('host' => '');
  // Canonicalize by removing www prefix.
  return preg_replace('/^www\./', '', $url['host']);
}

/**
 * Menu title callback; Return affiliate store title.
 *
 * @param string $title
 *   Default title to return if there is no custom title set in settings.
 *
 * @return string
 *   Affiliate store title.
 */
function affiliate_store_title($title) {
  return variable_get('affiliate_store_title', $title);
}

/**
 * Implements hook_views_api().
 */
function affiliate_store_views_api() {
  $path = drupal_get_path('module', 'affiliate_store');
  return array(
    'api' => 3.0,
    'path' => "$path/views",
    'template path' => "$path/theme",
  );
}

/**
 * Implements hook_menu().
 */
function affiliate_store_menu() {
  $menu = array();
  $menu['affiliate-store/go'] = array(
    'title' => 'Redirect product link',
    'page callback' => 'affiliate_store_go',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  _affiliate_store_passthrough($menu, 'menu');
  return $menu;
}

/**
 * Preprocess affiliate store product content type.
 *
 * @see node--affiliate-store-product.tpl.php
 */
function affiliate_store_preprocess_node(&$variables) {
  if ($variables['type'] !== 'affiliate_store_product') {
    // Skip if the node is not affiliate store product.
    return;
  }

  affiliate_store_add_css('affiliate_store_product');
  $title = $variables['node']->title;
  $pid = &$variables['pid'];
  $price = &$variables['price'];
  $currency = &$variables['currency'];
  $url = &$variables['url'];
  $thumb_url = &$variables['thumb_url'];
  $image_url = &$variables['image_url'];
  $call_to_action = &$variables['call_to_action'];
  $currency_symbol = &$variables['currency_symbol'];
  $thumbnail = &$variables['thumbnail'];
  $image = &$variables['image'];
  $go = &$variables['go'];

  // Manually group affiliate store term reference fields as field group is not
  // supported in core. Make sure the display order is preserved.
  $fields = array();
  foreach (array_keys(affiliate_store_vocabularies()) as $vocab) {
    $fields[] = "affiliate_store_$vocab";
  }
  foreach ($variables['content'] as $field => $content) {
    if (in_array($field, $fields, TRUE)) {
      $variables['content']['affiliate_store_terms'][$field] = $content;
      unset($variables['content'][$field]);
    }
  }

  $call_to_action = variable_get(
    'affiliate_store_product_call_to_action', t('Buy now')
  );
  $currency_symbol = theme(
    'affiliate_store_currency', array('code' => $currency)
  );
  $go = theme(
    'affiliate_store_go', array('text' => $call_to_action, 'url' => $url)
  );
  // Make sure price of '0.00' string is regarded as empty by converting to 0.
  $price = floatval($price) ? $price : 0;

  $thumbnail = '';
  if ($thumb_url) {
    $options = array('path' => $thumb_url, 'alt' => $title, 'title' => $title);
    $thumbnail = theme('image', $options);
    // Open full image (if available) when thumbnail is clicked.
    if ($image_url) {
      $thumbnail = theme(
        'affiliate_store_image',
        array(
          'element' => $thumbnail,
          'url' => $image_url,
          'title' => $title,
        )
      );
    }
  }
  $image = '';
  if ($image_url) {
    $options = array('path' => $image_url, 'alt' => $title, 'title' => $title);
    $image = theme('image', $options);
  }

  // Sanitize all product fields.
  $pid = check_plain($pid);
  $currency = check_plain($currency);
  $url = check_url($url);
  $thumb_url = check_url($thumb_url);
  $image_url = check_url($image_url);
  $call_to_action = check_plain($call_to_action);
}

/**
 * Implements hook_theme().
 */
function affiliate_store_theme() {
  $theme = array();
  _affiliate_store_passthrough($theme, 'theme');
  _affiliate_store_passthrough($theme, 'theme', 'theme');
  return $theme;
}

/**
 * Implements hook_theme_registry_alter().
 *
 * Make sure module's default template is applied if user's theme does not
 * provides one.
 */
function affiliate_store_theme_registry_alter(&$theme_registry) {
  // NOTE: Not sure this is the correct way.
  // Let theme engine discovers module template files.
  $path = drupal_get_path('module', 'affiliate_store');
  $temp = $theme_registry;
  _theme_process_registry($temp, 'phptemplate', 'theme_engine', '', $path);
  $theme_registry += $temp;
}

/**
 * Implements hook_help().
 */
function affiliate_store_help($path) {
  switch ($path) {
    case 'admin/structure/affiliate-store/map':
    case 'admin/structure/affiliate-store/map/category':
    case 'admin/structure/affiliate-store/map/subcategory':
    case 'admin/structure/affiliate-store/map/subsubcategory':
      return (
        '<p>' .
        t(
          "You can define custom category mapping by assigning synonym to " .
          "category term. Synonym will also be case converted using your " .
          "configured case conversion settings."
        ) .
        '</p><p>' .
        t(
          "Rename a category by assigning it a synonym. Merge several " .
          "categories by assigning all of them with the same synonym."
        ) .
        '</p>'
      );
    case 'admin/structure/affiliate-store/settings/advanced':
      return (
        '<p>' .
        t(
          "Your affiliate store should works by just configuring basic " .
          "settings. The advanced settings are provided for flexibility."
        ) .
        '</p>'
      );
    case 'admin/structure/affiliate-store/subscriptions':
      return (
        '<p>' .
        t(
          "Here are your affiliate store subscriptions that have been " .
          "imported from Hub. Subscriptions in pending update are not shown."
        ) .
        '</p><p>' .
        t(
          "You can refetch subscription's products if needed, e.g. to fix " .
          "broken update."
        ) .
        '</p>'
      );
    case 'admin/structure/affiliate-store/update':
      return (
        '<p>' .
        t(
          "Your affiliate store will be kept up to date automatically when " .
          "cron run. You can update manually, however, to see immediate " .
          "update after making changes to your affiliate store subscriptions."
        ) .
        '</p><p>' .
        t(
          "The update process can takes a long time to finish depending on " .
          "your settings and number of subscriptions."
        ) .
        '</p>'
      );
    case 'admin/help#affiliate_store':
      // Return a line-break version of the README file.
      return check_markup(file_get_contents(dirname(__FILE__) . '/README.txt'));
  }
}

/**
 * Implements hook_permission().
 */
function affiliate_store_permission() {
  return array(
    // Administrator can configures affiliate store module settings.
    'administer affiliate store' => array(
      'title' => t('Administer affiliate store'),
    ),
    // Affiliate store product create, update, and delete permissions will be
    // defined and enforced by Node module automatically.
    'access affiliate store product' => array(
      'title' => t('View affiliate store product'),
    ),
  );
}

/**
 * Add affiliate store module CSS file.
 *
 * @param string $file
 *   Name of file to add without the .css extension.
 * @param string $dir
 *   (optional) The directory to add the file from. Default to 'css'.
 *
 * @return array
 *   Queued cascading stylesheets.
 *
 * @see drupal_add_css()
 */
function affiliate_store_add_css($file, $dir = 'css', $options = NULL) {
  $path = drupal_get_path('module', 'affiliate_store') . "/$dir/$file.css";
  return drupal_add_css($path, $options);
}

/**
 * Include affiliate store module include file.
 *
 * @param string $file
 *   Name of file to include without the .inc extension.
 * @param string $dir
 *   (optional) The directory to include the file from. Default to 'includes'.
 */
function affiliate_store_include($file, $dir = 'includes') {
  $path = drupal_get_path('module', 'affiliate_store') . "/$dir/$file.inc";
  include_once DRUPAL_ROOT . '/' . $path;
}

/**
 * Provide a hook passthrough to included files.
 *
 * To organize things neatly, each tool gets its own toolname.$type.inc
 * file. If it exists, it's loaded and affiliate_hub_$tool_$type() is executed.
 * Code modified from CTools.
 *
 * @param array &$items
 *   Mixed items to pass through hooks and collect return values.
 * @param string $type
 *   (optional) Type of hook to invoke. Default to 'theme'.
 * @param string $dir
 *   (optional) Directory to search for include files. Default to 'includes'.
 *
 * @return array
 *   Populated items according to type of hook.
 */
function _affiliate_store_passthrough(&$items, $type = 'theme',
$dir = 'includes') {
  $files = drupal_system_listing(
    "/\.$type\.inc$/",
    drupal_get_path('module', 'affiliate_store') . "/$dir",
    'name', 0
  );
  foreach ($files as $file) {
    include_once DRUPAL_ROOT . '/' . $file->uri;
    list($tool) = explode('.', $file->name, 2);

    $function = '_affiliate_store_' . str_replace('-', '_', $tool) . "_$type";
    if (function_exists($function)) {
      $function($items);
    }
  }
}

/**
 * Prefix a field with affiliate store namespace if it starts with underscore.
 *
 * Allow use of shorter field string and still correctly translate field
 * variable that may cross module namespaces.
 *
 * @param string $field
 *   Any field string.
 *
 * @return string
 *   Field prefixed with affiliate store namepace if it starts with underscore,
 *   original value otherwise.
 */
function _affiliate_store_prefix($field) {
  return (strpos($field, '_') === 0) ? "affiliate_store$field" : $field;
}
