<?php

/**
 * @file
 * Defines a field type for referencing a comment - 80 % Based on user and node reference module.
 *
 * @author Kristof De Jaeger - http://drupal.org/user/107403 - http://realize.be
 * @version this is the drupal 5.x version
 */

/**
 * Implementation of hook_menu().
 */
function commentreference_menu($may_cache) {
  $items = array();

  if ($may_cache) {
    $items[] = array('path' => 'commentreference/autocomplete', 'title' => t('comment reference autocomplete'),
      'callback' => 'commentreference_autocomplete', 'access' => user_access('access comments'), 'type' => MENU_CALLBACK);
  }

  return $items;
}

/**
 * Implementation of hook_field_info().
 */
function commentreference_field_info() {
  return array(
    'commentreference' => array('label' => 'Comment Reference'),
  );
}

/**
 * Implementation of hook_field_settings().
 */
function commentreference_field_settings($op, $field) {
  switch ($op) {
    case 'database columns':
      $columns = array(
        'cid' => array('type' => 'int', 'not null' => FALSE, 'default' => NULL),
      );
      return $columns;
  }
}

/**
 * Implementation of hook_field().
 */
function commentreference_field($op, &$node, $field, &$items, $teaser, $page) {
  if ($field['widget']['type'] == 'commentreference_autocomplete') {
    switch ($op) {
      case 'validate':
        foreach ($items as $delta => $item) {
          $error_field = isset($item['error_field']) ? $item['error_field'] : '';
          unset($item['error_field']);
          if (!empty($item['cid']) && !in_array($item['cid'], array_keys(_commentreference_potential_references($field)))) {
            form_set_error($error_field, t('%name : Invalid comment.', array('%name' => t($field['widget']['label']))));
          }
        }
      return;
    }
  }
}

/**
 * Implementation of hook_field_formatter_info().
 */
function commentreference_field_formatter_info() {
  return array(
    'default' => array(
      'label' => 'Default',
      'field types' => array('commentreference'),
    ),
    'plain' => array(
      'label' => 'Plain text',
      'field types' => array('commentreference'),
    ),
  );
}

/**
 * Implementation of hook_field_formatter().
 */
function commentreference_field_formatter($field, $item, $formatter, $node) {
  $text = '';
  if (isset($item['cid'])) {
    $referenced_comment = _comment_load($item['cid']);
    if ($referenced_comment) {
      // we don't use the theme function because theme_comment_view uses $_GET['q']
      // variable, and we need the nid of the node where this comment belongs to,
      // not the one we are looking at.
      // If anyone really thinks our own theme option is necessary, add a patch
      // to the issue queue, for now, just passing on a link and the timestamp of the comment.
      $text = l($referenced_comment->subject, 'node/'. $referenced_comment->nid, NULL, NULL, 'comment-'. $referenced_comment->cid) .' - '. t('@time ago', array('@time' => format_interval(time() - $referenced_comment->timestamp)));
    }
  }

  switch ($formatter) {
    case 'plain':
      return strip_tags($text);

    default:
      return $text;
  }
}

/**
 * Implementation of hook_widget_info().
 */
function commentreference_widget_info() {
  return array(
    'commentreference_select' => array(
      'label' => 'Select List',
      'field types' => array('commentreference'),
    ),
    'commentreference_autocomplete' => array(
      'label' => 'Autocomplete Text Field',
      'field types' => array('commentreference'),
    ),
  );
}

/**
 * Implementation of hook_widget().
 */
function commentreference_widget($op, &$node, $field, &$items) {
  if ($field['widget']['type'] == 'commentreference_select') {
    switch ($op) {
      case 'prepare form values':
        $items_transposed = content_transpose_array_rows_cols($items);
        // get rid of null values
        $items['default cids'] = array_filter((array) $items_transposed['cid']);
        break;

      case 'form':
        $form = array();

        $options = _commentreference_potential_references($field, NULL, FALSE, FALSE);
        if (!$field['required']) {
          $options = array('none' => t('<none>')) + $options;
        }
        if (empty($items['default cids'])) {
          $items['default cids'][] = 'none';
        }
        $form[$field['field_name']] = array('#tree' => TRUE);
        $form[$field['field_name']]['cids'] = array(
          '#type' => 'select',
          '#title' => t($field['widget']['label']),
          '#default_value' => $items['default cids'],
          '#multiple' => $field['multiple'],
          '#size' => $field['multiple'] ? min(count($options), 6) : 0,
          '#options' => $options,
          '#required' => $field['required'],
          '#description' => t($field['widget']['description']),
        );

        return $form;

      case 'process form values':
        if ($field['multiple']) {
          // drop the 'none' option
          unset($items['cids']['none']);
          if (!empty($items['cids'])) {
            $items = array_values(content_transpose_array_rows_cols(array('cid' => $items['cids'])));
          }
          else {
            $items[0]['cid'] = '';
          }
        }
        else {
          $items[0]['cid'] = ($items['cids'] != 'none') ? $items['cids'] : '';
        }
        // Remove the widget's data representation so it isn't saved.
        unset($items['cids']);
        foreach ($items as $delta => $item) {
          $items[$delta]['error_field'] =  $field['field_name'] .'][cids';
        }
    }
  }
  else {
    switch ($op) {
      case 'prepare form values':
        foreach ($items as $delta => $item) {
          if (!empty($items[$delta]['cid'])) {
            $items[$delta]['default subject'] = db_result(db_query(db_rewrite_sql("SELECT subject FROM {comments} WHERE cid = '%d'", 'c', 'cid', $items[$delta]['cid']), $items[$delta]['cid']));
            $items[$delta]['default subject'] .= ' [cid:'. $items[$delta]['cid'] .']';
          }
        }
        break;

      case 'form':
        $form = array();
        $form[$field['field_name']] = array('#tree' => TRUE);

        if ($field['multiple']) {
          $form[$field['field_name']]['#type'] = 'fieldset';
          $form[$field['field_name']]['#description'] = t($field['widget']['description']);
          $delta = 0;
          foreach ($items as $item) {
            if ($item['cid']) {
              $form[$field['field_name']][$delta]['subject'] = array(
                '#type' => 'textfield',
                '#title' => ($delta == 0) ? t($field['widget']['label']) : '',
                '#autocomplete_path' => 'commentreference/autocomplete/'. $field['field_name'],
                '#default_value' => $item['default subject'],
                '#required' => ($delta == 0) ? $field['required'] : FALSE,
              );
              $delta++;
            }
          }
          foreach (range($delta, $delta + 2) as $delta) {
            $form[$field['field_name']][$delta]['subject'] = array(
              '#type' => 'textfield',
              '#title' => ($delta == 0) ? t($field['widget']['label']) : '',
              '#autocomplete_path' => 'commentreference/autocomplete/'. $field['field_name'],
              '#default_value' => '',
              '#required' => ($delta == 0) ? $field['required'] : FALSE,
            );
          }
        }
        else {
          $form[$field['field_name']][0]['subject'] = array(
            '#type' => 'textfield',
            '#title' => t($field['widget']['label']),
            '#autocomplete_path' => 'commentreference/autocomplete/'. $field['field_name'],
            '#default_value' => $items[0]['default subject'],
            '#required' => $field['required'],
            '#description' => t($field['widget']['description']),
          );
        }
        return $form;

      case 'process form values':
        foreach ($items as $delta => $item) {
          $cid = 0;
          if (!empty($item['subject'])) {
            preg_match('/^(?:\s*|(.*) )?\[\s*cid\s*:\s*(\d+)\s*\]$/', $item['subject'], $matches);
            if (!empty($matches)) {
              // explicit cid
              $cid = $matches[2];
            }
            else {
              // no explicit cid
              // TODO :
              // the best thing would be to present the user with an additional form,
              // allowing the user to choose between valid candidates with the same title
              // ATM, we pick the first matching candidate...
              $cids = _comment_potential_references($field, $item['subject'], TRUE);
              $cid = (!empty($cids)) ? array_shift(array_keys($cids)) : 0;
            }
          }
          // Remove the widget's data representation so it isn't saved.
          unset($items[$delta]['subject']);
          $items[$delta]['cid'] = $cid;
          $items[$delta]['error_field'] = $field['field_name'] .']['. $delta .'][subject';
          // Don't save empty fields except the first value
          if (empty($cid) && $delta > 0) {
            unset($items[$delta]);
          }
        }
    }
  }
}

/**
 * Fetch an array of all candidate referenced comments, for use in presenting the selection form to the user.
 */
function _commentreference_potential_references($field, $string = '', $exact_string = FALSE, $full_comment = TRUE) {

  $args = array();

  // Is status needed ? Should this be 0 always ?
  $string_clause = ' WHERE c.status = 0 ';
  if (isset($string)) {
    $string_clause .= $exact_string ? " AND c.subject LIKE '%s%'" : " AND c.subject LIKE '%%%s%'";
    $args[] = $string;
  }

  $result = db_query(db_rewrite_sql('SELECT c.subject, c.cid FROM {comments} c '. $string_clause .' ORDER BY c.subject ASC', 'c', 'cid', $args), $args);
  if (db_num_rows($result) == 0) {
    return array();
  }

  $comments = array();
  while ($comment = db_fetch_object($result)) {
    if ($full_comment == TRUE)
      $comments[$comment->cid] = $comment;
    else
      $comments[$comment->cid] = $comment->subject;
  }
  return $comments;
}

/**
 * Retrieve a pipe delimited string of autocomplete suggestions
 */
function commentreference_autocomplete($field_name, $string = '') {
  $fields = content_fields();
  $field = $fields[$field_name];
  $matches = array();

  foreach (_commentreference_potential_references($field, $string) as $row) {
    $matches[$row->subject .' [cid:'. $row->cid .']'] = check_plain($row->subject);
  }
  print drupal_to_js($matches);
  exit();
}

