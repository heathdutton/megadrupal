<?php

/**
 * @file
 * Main file for Menu Item Attach module.
 */

/**
 * Implements hook_help().
 */
function menu_item_attach_help($path, $arg) {
  if ($path == 'admin/help#menu_item_attach') {
    $output = '<p>' . t('This module allows to add some menu items <strong>inside</strong> another menu item. This is very useful for creating mega menus.') . '</p>';
    $output .= '<h2>' . t('Usage') . '</h2>';
    $output .= '<ol>';
    $output .= '<li>' . t('Go to edit page of menu item you wish to attach inside another.') . '</li>';
    $output .= '<li>' . t('Select in "Attach to" needed item.') . '</li>';
    $output .= '</ol>';
    return $output;
  }
}

/**
 * Implements hook_form_alter() for menu_edit_item().
 */
function menu_item_attach_form_alter(&$form, &$form_state, $form_id) {
  // Add addition select on menu item edit page.
  if ($form_id == 'menu_edit_item') {
    // Current editing menu item.
    $item = menu_link_load($form['mlid']['#value']);
    $default = ($item['menu_item_attach']) ? $item['menu_name'] . ':' . $item['menu_item_attach'] : 'menu_item_attach:0';

    // Generate a list of possible attached items
    // (not including this link or descendants).
    // Same as parent option.
    $options = menu_parent_options(menu_get_menus(), $item);
    $none = array('menu_item_attach:0' => t('None'));
    $options = array_merge($none, $options);

    $form['menu_item_attach'] = array(
      '#type' => 'select',
      '#title' => t('Attach to'),
      '#description' => t('Attach this menu item inside another item.'),
      '#default_value' => $default,
      '#options' => $options,
    );

    $form['#submit'][] = 'menu_item_attach_submit';
  }

  // Add information about attached items on menu overview page.
  if ($form_id == 'menu_overview_form') {
    $elements = element_children($form);
    foreach ($elements as $attached_to) {
      // Menu item.
      $element = &$form[$attached_to];
      // Only process menu items attached to another.
      if (isset($element['#item']) && ($element['#item']['menu_item_attach'])) {
        $attached_mlid = $element['#item']['menu_item_attach'];
        $attached_to = menu_link_load($attached_mlid);
        $attached = l(check_plain($attached_to['link_title']), 'admin/structure/menu/item/' . $attached_mlid . '/edit');
        $element['title']['#markup'] .= '<div class="messages status menu-item-attach-overview">' . t('Attached to:') . ' ' .  $attached . '</div>';
        $form['#attached']['css'][] = drupal_get_path('module', 'menu_item_attach') . '/menu_item_attach.css';
      }
    }
  }

}

/**
 * Submit handler for menu item edit page.
 */
function menu_item_attach_submit(&$form, &$form_state) {
  // Find menu id.
  $menu_item_attach = explode(':', $form_state['values']['menu_item_attach']);
  $menu_item_attach = end($menu_item_attach);
  // Save selected attach id into database.
  db_update('menu_links')
    ->fields(array(
      'menu_item_attach' => $menu_item_attach,
    ))
    ->condition('mlid', $form_state['values']['mlid'])
    ->execute();
}

/**
 * Implements hook_theme_registry_alter().
 */
function menu_item_attach_theme_registry_alter(&$theme_registry) {
  $theme_registry['menu_link']['function'] = 'menu_item_attach_menu_link';
}

/**
 * Returns HTML for a menu link and submenu.
 *
 * @param array $variables
 *   An associative array containing:
 *   - element: Structured array data for a menu link.
 *
 * @ingroup themeable
 */
function menu_item_attach_menu_link(array $variables) {
  $element = $variables['element'];
  $sub_menu = '';
  $menu_item_attach = '';

  $output = l($element['#title'], $element['#href'], $element['#localized_options']);

  if ($element['#menu_item_attach']) {
    // Remove <ul> wrapper from sub menu.
    // TODO: change to custom empty theme function.
    unset($element['#menu_item_attach']['#theme_wrappers']);
    $menu_item_attach = drupal_render($element['#menu_item_attach']);
  }

  if ($element['#below']) {
    $sub_menu = drupal_render($element['#below']);
  }

  // Do not wrap menu in <li> for attached items.
  if (!empty($element['#original_link']['menu_item_attach'])) {
    if (!empty($element['#original_link']['menu_item_attach_used'])) {
      return $output . $sub_menu . $menu_item_attach;
    }
    else {
      return '';
    }
  }

  return '<li' . drupal_attributes($element['#attributes']) . '>' . $output . $sub_menu . $menu_item_attach . "</li>\n";
}

/**
 * Preprocess function of menu_link() theme.
 *
 * @param array $variables
 *   An associative array containing:
 *   - element: Structured array data for a menu link.
 */
function menu_item_attach_preprocess_menu_link(array &$variables) {
  $element = &$variables['element'];
  $element['#menu_item_attach'] = array();

  // Current menu id.
  $mlid = $element['#original_link']['mlid'];

  $params_parent = array(
    'conditions' => array('hidden' => 0, 'menu_item_attach' => $mlid),
  );
  // Find all menu items where should be attached items.
  $parents = menu_build_tree($element['#original_link']['menu_name'], $params_parent);

  if (!empty($parents)) {
    // menu_build_tree function return data in strange format.
    // Some items are in 'below' array. Fix it here.
    $below = array();
    foreach ($parents as $key => $value) {
      if (!empty($value['below'])) {
        $below = $value['below'];
        $parents[$key]['below'] = array();
      }
      $parents = array_merge($parents, $below);
    }
    // Sort items by original weight.
    uasort($parents, '_menu_item_attach_sort');

    // Find all children items for selected attached items.
    $parents_with_children = array();
    foreach ($parents as $key => $value) {
      $parent = reset($value);
      $mlib_parent = $parent['mlid'];
      $children = _menu_item_attach_get_all_menu_children($element['#original_link']['menu_name'], $mlib_parent);
      $parents_with_children[$key] = $children;
      $parents_with_children[$key]['link']['menu_item_attach_used'] = TRUE;
    }
    // Add all attached items into sub array '#menu_item_attach'.
    $element['#menu_item_attach'] = menu_tree_output($parents_with_children);
  }

}

/**
 * Sort menu items by weight.
 */
function _menu_item_attach_sort($a, $b) {
  return $a['link']['weight'] > $b['link']['weight'] ? TRUE : FALSE;
}

/**
 * Get all menu children of a given menu ID.
 *
 * @param string $menu_name
 *   Name of menu.
 * @param int $mlid
 *   Menu ID.
 *
 * @return array
 *   Children menus for given menu ID.
 */
function _menu_item_attach_get_all_menu_children($menu_name, $mlid) {
  $all = menu_tree_all_data($menu_name);
  $children = '';
  if ($mlid) {
    foreach ($all as $branch) {
      $check = _menu_item_attach_find_mlid_in_menu($mlid, $branch);
      if ($check) {
        $children = $check;
      }
    }
  }
  return $children;
}

/**
 * Helper function that recursively search an menu.
 *
 * Used by _menu_item_attach_get_all_menu_children().
 *
 * @param int $mlid
 *   Menu ID.
 * @param array $link
 *   Menu array.
 *
 * @return mixed
 *   Menu array or sub menu for recursively search.
 */
function _menu_item_attach_find_mlid_in_menu($mlid, array $link) {
  if ($mlid == $link['link']['mlid']) {
    return $link;
  }
  else {
    foreach ($link['below'] as $item) {
      $response = _menu_item_attach_find_mlid_in_menu($mlid, $item);
      if ($response) {
        return $response;
      }
    }
  }
}
