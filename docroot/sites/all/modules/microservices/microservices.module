<?php
/**
 * @file
 *
 * @TODO Service action and events description.
 * @TODO Clear table with action result markers (uuid). If no result - send an error.
 * @TODO Allow specify timeout for action.
 */

define('MICROSERVICES_SERVICE', 'manager');
define('MICROSERVICES_QUEUE_REQUEST', 'request');
define('MICROSERVICES_QUEUE_REPLY', 'reply');
define('MICROSERVICES_MESSAGE_ACTION', 'action');
define('MICROSERVICES_MESSAGE_EVENT', 'event');
define('MICROSERVICES_MESSAGE_RESULT', 'result');

/*
 * Implements hook_microservices_info().
 */
function microservices_microservices_info() {
  $events = array();

  if (module_exists('microservices_cron')) {
    $events[] = MICROSERVICES_CRON_EVENT_CRON;
  }

  return array(
    MICROSERVICES_SERVICE => array(
      'title' => t('Microservices queue manager'),
      'events' => $events,
    ),
  );
}

/**
 * Implements hook_microservices_event().
 */
function microservices_microservices_event($message) {
  if ($message->event == 'cron' && in_array('every1m', $message->params->expressions)) {
    $db_transaction = db_transaction();
    try {
      $expired_actions = db_select('microservices_actions', 'actions')
        ->fields('actions')
        ->condition('expiration', time(), '>')
        ->execute()
        ->fetchAll();

      foreach ($expired_actions as $action) {
        // Send error result.
        microservices_send_result(unserialize($expired_actions->message), NULL, new Exception('Message expired'));

        // Remove record from actions registry.
        db_delete('microservices_actions')
          ->condition('id', $action->id)
          ->execute();
      }
    }
    catch (Exception $e) {
      $db_transaction->rollback();
      throw $e;
    }
  }
}

/**
 * Implements hook_hook_info();
 */
function microservices_hook_info() {
  return array(
    'microservices_info' => array(
      'group' => 'microservices',
    ),
    'microservices_action' => array(
      'group' => 'microservices',
    ),
    'microservices_result' => array(
      'group' => 'microservices',
    ),
    'microservices_event' => array(
      'group' => 'microservices',
    ),
  );
}

/**
 * @param $service
 *
 * @throws \Exception
 */
function microservices_assert_service($service) {
  $info = microservices_info();
  if (!isset($info['services'][$service])) {
    throw new Exception("Unknown service: '$service''");
  }
}

function microservices_assert_context($context) {
  if (!is_null($context)) {
    if (!(is_array($context) || is_object($context))) {
      throw new Exception('Invalid context data type');
    }
  }
}

/**
 * @param $service
 * @param $action
 *
 * @throws \Exception
 */
function microservices_assert_action($service, $action) {
  microservices_assert_service($service);
  $info = microservices_info();
  if (!isset($info['services'][$service]['actions'])
      || array_search($action, $info['services'][$service]['actions']) === FALSE) {
    throw new Exception("Unknown action: $action@$service");
  }
}

function microservices_assert_event($event) {
  $info = microservices_info();
  if (!isset($info['events'][$event])) {
    throw new Exception("Unknown event: $event");
  }
}

/**
 * @param $service
 *
 * @return mixed
 * @throws \Exception
 */
function microservices_get_module_by_service($service) {
  microservices_assert_service($service);
  $info = microservices_info();
  return $info['services'][$service]['module'];
}

/**
 * @param $type
 *
 * @throws \Exception
 */
function microservices_assert_queue_type($type) {
  if (!in_array($type, array(MICROSERVICES_QUEUE_REQUEST, MICROSERVICES_QUEUE_REPLY))) {
    throw new Exception("Wrong queue type: $type");
  }
}

/**
 * @param $event
 *
 * @return array
 * @throws \Exception
 */
function microservices_get_event_binders($event) {
  microservices_assert_event($event);
  $info = microservices_info();
  return isset($info['bind events'][$event]) ? $info['bind events'][$event] : array();
}

/**
 * @return array
 * @throws \Exception
 */
function microservices_info($reset = FALSE) {
  $cache = &drupal_static(__FUNCTION__);

  if ($reset || !isset($cache)) {
    if (!$reset && ($cache = variable_get('microservices_schema'))) {
      return $cache;
    }

    $services = array();
    $hook = 'microservices_info';
    foreach (module_implements($hook) as $module) {
      $function = $module . '_' . $hook;
      if (function_exists($function)) {
        $result = call_user_func($function);
        if (($module != 'microservices')
            && (isset($result[MICROSERVICES_SERVICE]))) {
          throw new Exception('Microservices manager should not been overridden');
        }
        foreach($result as &$item) {
          $item['module'] = $module;
        }
        if (isset($result) && is_array($result)) {
          $services = array_merge_recursive($services, $result);
        }
        elseif (isset($result)) {
          $services[] = $result;
        }
      }
    }
    drupal_alter($hook, $services);

    $cache = array(
      'services' => $services,
      'events' => array(),
      'bind events' => array(),
    );

    foreach ($services as $service => $service_info) {
      if (isset($service_info['events'])) {
        foreach ($service_info['events'] as $event) {
          if (!isset($cache['events'][$event])) {
            $cache['events'][$event] = array();
          }
          if (array_search($service, $cache['events'][$event]) === FALSE) {
            $cache['events'][$event][] = $service;
          }
        }
      }
      if (isset($service_info['bind events'])) {
        foreach ($service_info['bind events'] as $event) {
          if (!isset($cache['bind events'][$event])) {
            $cache['bind events'][$event] = array();
          }
          if (array_search($service, $cache['bind events'][$event]) === FALSE) {
            $cache['bind events'][$event][] = $service;
          }
        }
      }
    }

    // Validate event binding.
    foreach (array_keys($cache['bind events']) as $event) {
      if (!isset($cache['events'][$event])) {
        throw new Exception("Event '$event' not exists");
      }
    }
  }

  return $cache;
}

/**
 * @param      $event
 * @param      $params
 *
 * @param null $context
 *
 * @throws \Exception
 */
function microservices_send_event($event, $params, $context = NULL) {
  microservices_assert_event($event);
  microservices_assert_context($context);
  $message = new stdClass();
  $message->type = MICROSERVICES_MESSAGE_EVENT;
  $message->event = $event;
  $message->params = $params;
  $message->context = $context;
  microservices_queue_send($message, MICROSERVICES_QUEUE_REQUEST);
}

/**
 * @param      $service
 * @param      $action
 * @param      $params
 * @param null $sender
 * @param null $context
 * @param int  $ttl
 *
 * @throws \Exception
 */
function microservices_send_action($service, $action, $params = NULL, $sender = NULL, $context = NULL, $ttl = 3600) {
  microservices_assert_action($service, $action);
  microservices_assert_context($context);
  $sender && microservices_assert_service($sender);
  $message = new stdClass();
  $message->type = MICROSERVICES_MESSAGE_ACTION;
  $message->recipient = $service;
  $message->action = $action;
  $message->params = $params;
  $message->sender = $sender;
  $message->context = $context;
  $message->expiration = time() + $ttl;
  microservices_queue_send($message, MICROSERVICES_QUEUE_REQUEST);
}

/**
 * @param            $request
 * @param            $result
 * @param \Exception $error
 *
 *
 * @throws \Exception
 */
function microservices_send_result($request, $result, $error = NULL) {
  if (!isset($request->sender)) {
    // If sender was not defined, just do nothing without exception.
    // Because sender is not required argument in microservices_send_action().
    return;
  }
  $message = new stdClass();
  $message->type = MICROSERVICES_MESSAGE_RESULT;
  $message->sender = $request->recipient;
  $message->recipient = $request->sender;
  $message->action = $request->action;
  $message->context = $request->context;
  $message->uuid = $request->uuid;
  // Prepare params object.
  $params = new stdClass();
  $params->result = $result;
  if ($error) {
    $params->error = new stdClass();
    if (is_a($error, 'stdClass')) {
      /* @var $error stdClass */
      $params->error->code = is_int($error->code) ? $error->code : NULL;
      $params->error->message = $error->message;
    }
    elseif (is_a($error, 'Exception')) {
      /* @var $error Exception */
      $params->error->code = is_int($error->getCode()) ? $error->getCode() : NULL;
      $params->error->message = $error->getMessage();
    }
    else {
      $params->error->code = NULL;
      $params->error->message = 'Unknown exception was specified';
    }
    $params->error->class = get_class($error);
  }
  else {
    $params->error = NULL;
  }
  $message->params = $params;
  microservices_queue_send($message, MICROSERVICES_QUEUE_REPLY);
}

/**
 * @param $service
 * @param $type
 *
 * @return mixed
 * @throws \Exception
 */
function microservices_queue($service, $type) {
  $cache = &drupal_static(__FUNCTION__);

  microservices_assert_service($service);
  microservices_assert_queue_type($type);

  $service_machine_name = microservices_machine_name($service);
  $cache_key = "{$service_machine_name}_$type";

  if (!isset($cache) || !isset($cache[$cache_key])) {
    $class = NULL;
    $info = microservices_info();
    if (!empty($info['services']['queue class'])) {
      $class = $info['services']['queue class'];
    }
    else {
      $class = variable_get("microservices_queue_{$service_machine_name}_class", 'SystemQueue');
    }
    $queue = new $class("microservices_{$service_machine_name}_$type");
    /* @var $queue DrupalReliableQueueInterface */
    $queue->createQueue();
    $cache[$cache_key] = $queue;
  }

  return $cache[$cache_key];
}

/**
 * @param $message
 * @param $type
 *
 * @throws \Exception
 */
function microservices_queue_send($message, $type) {
  microservices_assert_queue_type($type);
  $queue = microservices_queue(MICROSERVICES_SERVICE, $type);
  $queue->createItem(json_encode($message));
}

function microservices_machine_name($name) {
  return str_replace(' ', '_', drupal_strtolower($name));
}

/**
 * @param $service
 * @param $type
 *
 * @return bool
 */
function microservices_queue_process($service, $type) {
  $result = FALSE;
  $queue = microservices_queue($service, $type);
  if ($item = $queue->claimItem()) {
    try {
      $message = json_decode($item->data);
      if ($service == MICROSERVICES_SERVICE) {
        microservices_queue_process_message_manager($message);
      }
      else {
        microservices_queue_process_message_service($message, $service);
      }
      $queue->deleteItem($item);
    }
    catch (Exception $e) {
      watchdog('microservices', 'Failed to process message \'%message\'', array('%message' => json_encode($message)), WATCHDOG_ERROR);
      $queue->deleteItem($item);
      throw $e;
    }
    $result = TRUE;
  }

  return $result;
}

/**
 * @param $message
 */
function microservices_queue_process_message_manager($message) {
    switch ($message->type) {

      case MICROSERVICES_MESSAGE_ACTION:
        // Register message to avoid of double sending of results.
        // If sender was not specified, there is no need to generate UUID,
        //   because returns the result does not make sense if sender was not specified.
        if (isset($message->sender)) {
          $message->uuid = microservices_uuid();
          db_insert('microservices_actions')
            ->fields(array(
              'uuid' => $message->uuid,
              'message' => serialize($message),
              'created' => time(),
              'expiration' => $message->expiration,
            ))
            ->execute();
        }
        $queue = microservices_queue($message->recipient, MICROSERVICES_QUEUE_REQUEST);
        $queue->createItem(json_encode($message));
        break;

      case MICROSERVICES_MESSAGE_RESULT:
        // Find action in registry by UUID.
        $action = db_select('microservices_actions', 'actions')
          ->fields('actions', array('id', 'expiration'))
          ->condition('uuid', $message->uuid)
          ->execute()
          ->fetchObject();

        if ($action) {
          if ($action->expiration < time()) {
            watchdog('microservices', 'Message expired \'%message\'', array('%id' => $action->id, '%action' => $message->action, '%message' => json_encode($message)), WATCHDOG_ERROR);
          }
          else {
            $queue = microservices_queue($message->recipient, MICROSERVICES_QUEUE_REPLY);
            $queue->createItem(json_encode($message));
          }

          // Remove record from actions registry.
          db_delete('microservices_actions')
            ->condition('id', $action->id)
            ->execute();
        }
        else {
          watchdog('microservices', 'Action \'%action\' not found or lost', array('%action' => $message->action), WATCHDOG_WARNING);
        }
        break;

      case MICROSERVICES_MESSAGE_EVENT:
        foreach (microservices_get_event_binders($message->event) as $service) {
          $queue = microservices_queue($service, MICROSERVICES_QUEUE_REQUEST);
          $queue->createItem(json_encode($message));
        }
        break;
    }
}

/**
 * @param $message
 * @param $service
 */
function microservices_queue_process_message_service($message, $service) {
  $module = microservices_get_module_by_service($service);
  switch ($message->type) {

    case MICROSERVICES_MESSAGE_ACTION:
      try {
        $sender = isset($message->sender) ? $message->sender : NULL;
        watchdog('microservices', 'Action called %service.%action by \'%sender\'', array('%service' => $service, '%action' => $message->action, '%sender' => $sender), WATCHDOG_DEBUG);
        module_invoke($module, 'microservices_action', $message);
      }
      catch (Exception $e) {
        if ($message->sender) {
          microservices_send_result($message, NULL, $e);
          watchdog_exception('microservices', $e, NULL, NULL, WATCHDOG_ERROR);
        }
        else {
          throw $e;
        }
      }
      break;

    case MICROSERVICES_MESSAGE_RESULT:
      watchdog('microservices', 'Action result %service.%action', array('%service' => $message->sender, '%action' => $message->action), WATCHDOG_DEBUG);
      module_invoke($module, 'microservices_result', $message);
      break;

    case MICROSERVICES_MESSAGE_EVENT:
      watchdog('microservices', 'Event %service.%event', array('%service' => $service, '%event' => $message->event), WATCHDOG_DEBUG);
      module_invoke($module, 'microservices_event', $message);
      break;
  }
}

/**
 * @return string
 */
function microservices_uuid() {
  // The field names refer to RFC 4122 section 4.1.2.
  return sprintf('%04x%04x-%04x-4%03x-%04x-%04x%04x%04x',
    // 32 bits for "time_low".
    mt_rand(0, 65535), mt_rand(0, 65535),
    // 16 bits for "time_mid".
    mt_rand(0, 65535),
    // 12 bits after the 0100 of (version) 4 for "time_hi_and_version".
    mt_rand(0, 4095),
    bindec(substr_replace(sprintf('%016b', mt_rand(0, 65535)), '10', 0, 2)),
    // 8 bits, the last two of which (positions 6 and 7) are 01, for "clk_seq_hi_res"
    // (hence, the 2nd hex digit after the 3rd hyphen can only be 1, 5, 9 or d)
    // 8 bits for "clk_seq_low" 48 bits for "node".
    mt_rand(0, 65535), mt_rand(0, 65535), mt_rand(0, 65535)
  );
}
