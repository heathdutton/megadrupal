<?php
/**
 * @file
 * Integration module for FirstData Connect payment gateway.
 */

define('COMMERCE_FIRSTDATA_CONNECT_CAPTURED', 'CAPTURED');
define('COMMERCE_FIRSTDATA_CONNECT_REFUND', 'REFUNDED');
define('COMMERCE_FIRSTDATA_CONNECT_CANCELED', 'CANCELED');

/**
 * Implements hook_commerce_payment_method_info().
 *
 * This hook will define the firstdata connect payment method
 */
function commerce_firstdata_connect_commerce_payment_method_info() {
  $payment_methods = array();

  $payment_methods['commerce_firstdata_connect_hosted'] = array(
    'base' => 'commerce_firstdata_connect',
    'title' => t('First Data EMEA Connect - Hosted Payment Page'),
    'short_title' => t('First Data EMEA Connect'),
    'display_title' => t('First Data EMEA Connect - Hosted Payment Page'),
    'description' => t('By using this module your customer will be redirected to the First Data secure hosted page to enter card details- please contact First Data if you want to add your corporate logo/brand to the hosted payment page'),
    'terminal' => FALSE,
    'offsite' => TRUE,
    'offsite_autoredirect' => TRUE,
    'active' => FALSE,
    'file' => 'includes/commerce_firstdata_connect_direct.inc',
    'cardonfile' => array(
      'update callback' => 'commerce_firstdata_connect_cardonfile_update',
      'delete callback' => 'commerce_firstdata_connect_cardonfile_delete',
      'create callback' => 'commerce_firstdata_connect_cardonfile_create',
    ),
  );

  $payment_methods['commerce_firstdata_connect_full_payment'] = array(
    'base' => 'commerce_firstdata_connect',
    'title' => t('First Data EMEA Connect - Merchant Payment Page'),
    'short_title' => t('First Data EMEA Connect'),
    'display_title' => t('First Data EMEA Connect - Merchant Payment Page'),
    'description' => t('By using this module your customer will stay on your Drupal page to enter card details - All payment information is encrypted and transmitted only via a secure 128bit SSL (Secure Socket layer) connection; we strongly recommend you install SSL Certificate (https) for the comfort of your customers'),
    'terminal' => FALSE,
    'offsite' => FALSE,
    'offsite_autoredirect' => FALSE,
    'file' => 'includes/commerce_firstdata_connect_direct.inc',
    'active' => FALSE,
    'cardonfile' => array(
      'update callback' => 'commerce_firstdata_connect_cardonfile_update',
      'delete callback' => 'commerce_firstdata_connect_cardonfile_delete',
      'create callback' => 'commerce_firstdata_connect_cardonfile_create',
    ),
  );

  return $payment_methods;
}

/**
 * Updates card on file.
 */
function commerce_firstdata_connect_cardonfile_update() {
  foreach ($_POST as $key => $value) {
    if ($key == 'credit_card') {
      foreach ($value as $c_key => $c_val) {
        $k = check_plain($c_key);
        $v = check_plain($c_val);
        $params['credit_card'][$k] = $v;
      }
    }
    else {
      $k = check_plain($key);
      $v = check_plain($value);
      $params[$k] = $v;
    }
  }
  // Initial transaction.
  global $user;
  $api = commerce_firstdata_connect_api_object();
  $order = commerce_order_new($user->uid, 'pending', 'commerce_order');
  $order->commerce_order_total[LANGUAGE_NONE][0]['amount'] = 10;
  $order->commerce_order_total[LANGUAGE_NONE][0]['data']['components'][0]['price']['amount'] = 10;
  commerce_order_save($order);
  $order = commerce_firstdata_connect_load_user_last_order();
  if (is_array($order) == TRUE) {
    $order = reset($order);
  }
  $customer_profile = commerce_customer_profile_load($order->commerce_customer_billing[LANGUAGE_NONE][0]['profile_id']);
  $customer_profile->commerce_customer_address[LANGUAGE_NONE][0]['name_line'] = $params['credit_card']['owner'];
  commerce_customer_profile_save($customer_profile);
  $amount = new stdClass();
  $amount->amount = 10;
  $amount->currency = $order->commerce_order_total[LANGUAGE_NONE][0]['currency_code'];
  $payment_method = commerce_payment_method_instance_load('commerce_firstdata_connect_full_payment|commerce_payment_commerce_firstdata_connect_full_payment');
  $result = $api->crossPayment($order, '', 'preauth', $amount, $params['hidden_cardid'], $params['code'], $params['hidden_expmonth'], $params['hidden_expyear'], TRUE);

  $response = commerce_firstdata_connect_get_response_data($result);
  $respond_codes = commerce_firstdata_connect_get_response_code($response);
  if ($result->status_message == 'OK' && $result->code == '200' and $respond_codes['approval_code_status'] == 'Y') {
    $transaction = commerce_payment_transaction_new($payment_method['method_id'], $order->order_id);
    $transaction->instance_id = $payment_method['instance_id'];
    $transaction->remote_id = !empty($respond_codes['remote_id']) ? $respond_codes['remote_id'] : '';
    $transaction->amount = $order->commerce_order_total[LANGUAGE_NONE][0]['amount'];
    $transaction->currency_code = $order->commerce_order_total[LANGUAGE_NONE][0]['currency_code'];
    $transaction->status = COMMERCE_PAYMENT_STATUS_PENDING;
    $transaction->message_variables = array('@name' => $customer_profile->commerce_customer_address[LANGUAGE_NONE][0]['name_line']);
    $transaction->message = 'Authorised';
    $transaction->remote_status = $response['status'];
    $transaction->order_id = $order->order_id;
    $transaction->payload = $response;
    $transaction->data['tdate'] = $response['tdate'];
    commerce_payment_transaction_save($transaction);
  }
  $last_saved_transaction = commerce_firstdata_connect_load_last_saved_transaction();
  if (is_array($last_saved_transaction) == TRUE) {
    $last_saved_transaction = reset($last_saved_transaction);
  }

  $amount = new stdClass();
  $amount->currency = $order->commerce_order_total[LANGUAGE_NONE][0]['currency_code'];
  $amount->amount = 10;
  // Capture.
  $result = $api->crossPayment($order, $last_saved_transaction, 'postauth', $amount);
  $response = commerce_firstdata_connect_get_response_data($result);
  $respond_codes = commerce_firstdata_connect_get_response_code($response);
  if ($result->status_message == 'OK' && $result->code == '200' and $respond_codes['approval_code_status'] == 'Y') {
    $last_saved_transaction->amount = $amount->amount;
    if (!empty($respond_codes['remote_id'])) {
      $last_saved_transaction->remote_id = $last_saved_transaction->remote_id . '/' . $respond_codes['remote_id'];
    }
    $last_saved_transaction->status = COMMERCE_FIRSTDATA_CONNECT_CAPTURED;
    $last_saved_transaction->message .= '<br />' . t('Captured: @date', array('@date' => format_date(REQUEST_TIME, 'short')));
    if (!empty($response['tdate'])) {
      $last_saved_transaction->data['tdate'] = $response['tdate'];
    }
    commerce_payment_transaction_save($last_saved_transaction);
    $order->status = 'pending';
    commerce_order_save($order);
  }
  $last_saved_transaction = commerce_firstdata_connect_load_last_saved_transaction();
  if (is_array($last_saved_transaction) == TRUE) {
    $last_saved_transaction = reset($last_saved_transaction);
  }
  $amount = new stdClass();
  $amount->currency = $order->commerce_order_total[LANGUAGE_NONE][0]['currency_code'];
  $amount->amount = 10;

  // Void.
  $result = $api->crossPayment($order, $last_saved_transaction, 'void', $amount);
  $response = commerce_firstdata_connect_get_response_data($result);
  $respond_codes = commerce_firstdata_connect_get_response_code($response);
  if ($result->status_message == 'OK' && $result->code == '200' and !empty($respond_codes['approval_code_status']) and $respond_codes['approval_code_status'] == 'Y') {
    $last_saved_transaction->amount = $amount->amount;
    $last_saved_transaction->status = COMMERCE_FIRSTDATA_CONNECT_CANCELED;
    $last_saved_transaction->message .= '<br />' . t('Voided: @date', array('@date' => format_date(REQUEST_TIME, 'short')));
    $last_saved_transaction->message .= '<br />' . t('Adding new card for customer: @user_mail', array('@user_mail' => $user->mail));
    if (!empty($response['tdate'])) {
      $last_saved_transaction->data['tdate'] = $response['tdate'];
    }
    commerce_payment_transaction_save($last_saved_transaction);

    $card = commerce_cardonfile_load($params['hidden_cardid']);
    if (is_array($card)) {
      $card = reset($card);
    }
    return $card;
  }
  else {
    drupal_set_message(t('Error occur, the card was not saved.'), 'error');
    $instance = commerce_payment_method_instance_load($payment_method['instance_id']);
    if ($instance['settings']['logs'] == 0) {
      if (empty($response['fail_reason_details'])) {
        $response['fail_reason_details'] = t('An error occur during the transaction process card has been decline.');
      }
      watchdog('commerce_firstdata_connect', "Your card was not saved, an error occur: @error . @error_details", array('@error' => $response['fail_reason'], '@error_details' => $response['fail_reason_details']), WATCHDOG_ERROR);
    }
    commerce_cardonfile_delete($params['hidden_cardid']);
    return FALSE;
  }
  $result->order = $order;
  $result->transaction = $last_saved_transaction;
  $result->amount = $amount;
  return TRUE;
}

/**
 * Implements hook_form_alter().
 */
function commerce_firstdata_connect_form_alter(&$form, &$form_state, $form_id = 'commerce_cardonfile_card_form') {
  if ($form_id == 'commerce_cardonfile_card_form' and strstr(current_path(), 'edit')) {
    $form['code'] = array(
      '#type' => 'textfield',
      '#title' => t('CVV/CV2'),
      '#default_value' => '',
      '#required' => TRUE,
      '#attributes' => array(
        'autocomplete' => 'off',
      ),
      '#maxlength' => 4,
      '#size' => 4,
    );

    $form['hidden_cardid'] = array(
      '#type' => 'hidden',
      '#title' => t('Card id.'),
      '#default_value' => $form_state['build_info']['args'][1]->card_id,
    );

    $form['hidden_expmonth'] = array(
      '#type' => 'hidden',
      '#title' => t('Expiration month.'),
      '#default_value' => $form_state['build_info']['args'][1]->card_exp_month,
    );

    $form['hidden_expyear'] = array(
      '#type' => 'hidden',
      '#title' => t('Expiration year.'),
      '#default_value' => $form_state['build_info']['args'][1]->card_exp_year,
    );

    $form['credit_card']['cardonfile_instance_default']['#weight'] = 90;
    $form['submit']['#weight'] = 100;

    return $form;
  }
}

/**
 * Deletes card on file.
 */
function commerce_firstdata_connect_cardonfile_delete() {
  return TRUE;
}

/**
 * Implements hook_menu().
 */
function commerce_firstdata_connect_menu() {
  $items = array();

  // Add a menu item for capturing.
  $items['admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/firstdata_connect-capture'] = array(
    'title' => 'Capture',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_firstdata_connect_capture_form', 3, 5),
    'access callback' => 'commerce_firstdata_connect_capture_access',
    'access arguments' => array(3, 5),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'file' => 'includes/commerce_firstdata_connect.admin.inc',
    'weight' => 1,
  );

  // Add a menu item for refund.
  $items['admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/firstdata_connect-refund'] = array(
    'title' => 'Refund',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_firstdata_connect_refund_form', 3, 5),
    'access callback' => 'commerce_firstdata_connect_refund_access',
    'access arguments' => array(3, 5),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'file' => 'includes/commerce_firstdata_connect.admin.inc',
    'weight' => 2,
  );

  // Add a menu item for cancel.
  $items['admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/cancel'] = array(
    'title' => 'Void',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_firstdata_connect_cancel_form', 3, 5),
    'access callback' => 'commerce_firstdata_connect_cancel_access',
    'access arguments' => array(3, 5),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'file' => 'includes/commerce_firstdata_connect.admin.inc',
    'weight' => 2,
  );

  $items['admin/commerce/orders/batch'] = array(
    'title' => 'Firstdata Connect Capture',
    'description' => 'Capture all pending transactions with batch process',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_firstdata_connect_batch_form'),
    'access callback' => TRUE,
    'type' => MENU_LOCAL_TASK,
    'weight' => 100,
  );

  // Define a path to receive 3D Secure callback.
  $items['firstdata_connect/3ds/callback'] = array(
    'page callback' => 'commerce_firstdata_connect_3d_secure_callback',
    'page arguments' => array(3),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  // Define a path to redirect to 3D secure authentication page.
  $items['firstdata_connect/3d_secure/callback'] = array(
    'page callback' => 'commerce_firstdata_connect_3d_secure',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  // Callback menu item for the hosted payment method.
  $items['firstdata_connect/hosted/callback'] = array(
    'page callback' => 'commerce_firstdata_hosted_callback',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  // Callback menu item for redirecting to
  // Hosted payment method with card on file.
  $items['firstdata_connect/hosted/saved_cards'] = array(
    'page callback' => 'commerce_firstdata_connect_redirect_for_hosted_saved_cards',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['firstdata_connect/hosted/fail'] = array(
    'page callback' => 'commerce_firstdata_connect_hosted_fail_callback',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['firstdata_connect/hosted/success'] = array(
    'page callback' => 'commerce_firstdata_connect_hosted_callback',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Callback for the fail response.
 */
function commerce_firstdata_connect_hosted_fail_callback() {
  if (!empty($_POST)) {
    $result = $_POST;
  }
  else {
    $result = $_GET;
  }
  module_load_include('inc', 'commerce_payment', 'includes/commerce_payment.credit_card');
  $api = commerce_firstdata_connect_api_object();
  $cardonfile_capable = module_exists('commerce_cardonfile') && !empty($api->cardonfile);
  if (is_array($result) == TRUE and !empty($result['data']) and strstr($result['data'], '<html') == FALSE) {
    $result = base64_decode($result['data']);
  }
  elseif (is_array($result) == TRUE and !empty($result['data']) and strstr($result['data'], '<html') != FALSE) {
    $result = base64_decode($result['data']);
    $result_object = new stdClass();
    $result_object->data = $result;
    $result = commerce_firstdata_connect_get_response_data($result_object);
    $order_id = explode('-', $result['oid']);
    $order = commerce_order_load($order_id[0]);
    if (is_array($order) == TRUE) {
      $order = reset($order);
    }
    $order->status = 'pending';
    commerce_order_save($order);
  }

  drupal_set_message(t('The transaction has failed, because: @fail_reason.', array('@fail_reason' => $result['fail_reason'])), 'error');
  if (empty($result['oid'])) {
    $order_id = $result['order_id'];
  }
  drupal_set_message(t('To go to cart again click <a href="@url">here</a> page', array('@url' => url(t('/checkout/@order_id/review', array('@order_id' => $order_id))))), 'error');

  // Delete cof if there is any.
  if ($cardonfile_capable) {
    $card = commerce_cardonfile_load($result['hosteddataid']);
    if (is_array($card) == TRUE) {
      $card = reset($card);
    }
    if (!empty($card) and $card->card_number == 'XXXX' and is_object($card) == TRUE) {
      commerce_cardonfile_delete($card->card_id);
    }
  }
  if (!empty($result['data'])) {
    print ($result['data']);
    return !empty($result['data']) ? $result['data'] : $result;
  }
  else {
    return !empty($result['fail_reason']) ? $result['fail_reason'] : t('Error.');
  }
}

/**
 * Callback from the redirect hosted payment method.
 */
function commerce_firstdata_connect_hosted_callback() {
  global $user;
  $payment_method = commerce_payment_method_instance_load('commerce_firstdata_connect_hosted|commerce_payment_commerce_firstdata_connect_hosted');
  module_load_include('inc', 'commerce_payment', 'includes/commerce_payment.credit_card');
  $cardonfile_capable = module_exists('commerce_cardonfile') && !empty($payment_method['settings']['cardonfile']);
  $result = $_POST;
  $order_id = explode('-', $result['oid']);
  $api = commerce_firstdata_connect_api_object();
  if (!empty($result['response_hash']) and !empty($result['chargetotal']) and !empty($result['currency']) and !empty($order_id[0]) and !empty($result['approval_code'])) {
    $result_hash = $api->calculateResponseHash($result['response_hash'], $result['approval_code'], $result['chargetotal'], $result['currency'], $order_id[0]);
    $flag = 1;
  }

  $order = commerce_order_load($order_id[0]);
  $respond_codes = commerce_firstdata_connect_get_response_code($result);
  if ($respond_codes['approval_code_status'] == 'Y' and ($flag == 1 and ($result_hash == 'Parameter txndatetime was not stored.' or $result_hash == TRUE))) {
    $order->status = 'pending';
    commerce_order_save($order);
    $customer_profile = commerce_customer_profile_load($order->commerce_customer_billing[LANGUAGE_NONE][0]['profile_id']);
    $transaction = commerce_payment_transaction_new('commerce_firstdata_connect_hosted', $order_id[0]);
    $transaction->instance_id = $payment_method['instance_id'];
    $transaction->remote_id = !empty($respond_codes['remote_id']) ? $respond_codes['remote_id'] : '';
    $transaction->amount = $order->commerce_order_total[LANGUAGE_NONE][0]['amount'];
    $transaction->currency_code = $order->commerce_order_total[LANGUAGE_NONE][0]['currency_code'];
    $transaction->status = ($payment_method['settings']['transaction_type_process'] == 'preauth') ? COMMERCE_PAYMENT_STATUS_PENDING : COMMERCE_FIRSTDATA_CONNECT_CAPTURED;
    $transaction->message_variables = array('@name' => $customer_profile->commerce_customer_address[LANGUAGE_NONE][0]['name_line']);
    $transaction->message = ($payment_method['settings']['transaction_type_process'] == 'preauth') ? 'Authorised' : COMMERCE_FIRSTDATA_CONNECT_CAPTURED;
    $transaction->remote_status = $result['status'];
    $transaction->data['tdate'] = $result['tdate'];
    $transaction->payload = $result;
    if (!empty($transaction->uid)) {
      commerce_payment_transaction_save($transaction);
    }
    if ($cardonfile_capable) {
      $card = commerce_firstdata_connect_card_on_file_load_by_date($user->uid);
      if (is_array($card) == TRUE) {
        $card = reset($card);
      }

      if (!empty($card) and $card->card_number == 'XXXX' and is_object($card) == TRUE) {
        $card->card_number = substr($result['cardnumber'], -4, 4);
        $card->card_exp_month = $result['expmonth'];
        $card->card_exp_year = $result['expyear'];
        $card->type = strtolower($result['ccbrand']);
        $card->remote_id = !empty($result['hosteddataid']) ? $result['hosteddataid'] : $card->card_id;
        commerce_cardonfile_save($card);
      }
    }
    return drupal_goto(t('checkout/@order/complete', array('@order' => $order->order_id)));
  }
  else {
    if (!empty($flag) and empty($result_hash) or $result_hash == FALSE) {
      drupal_set_message(t('The response is not valid! It might be a fraud attempt!'), 'error');
      return FALSE;
    }
    // Delete card.
    $card = commerce_firstdata_connect_card_on_file_load_by_date($user->uid);
    if (is_array($card) == TRUE) {
      $card = reset($card);
    }
    if (!empty($card) and is_object($card) == TRUE) {
      commerce_cardonfile_delete($card->card_id);
    }
    if ($payment_method['settings']['logs'] == 0) {
      watchdog('commerce_firstdata_connect', 'An error occur, the transaction was not successful: %status_message', array('%status_message' => $result->status_message), WATCHDOG_ERROR);
    }
    $order->status = 'checkout_review';
    commerce_order_save($order);

    // Display the errors.
    return drupal_goto('firstdata_connect/hosted/fail', array(
      'query' => array(
        'dsta' => base64_encode($result['data']),
        'status_message' => $result['status_message'],
        'code' => $result['code'],
        'order_id' => $order->order_id,
      ),
    ));
  }
}

/**
 * Callback from the 3D secure.
 */
function commerce_firstdata_connect_3d_secure_callback() {
  $result = $_POST;
  global $user;
  $order_id = explode('-', $result['oid']);
  $order = commerce_order_load($order_id[0]);
  $order->status = 'pending';
  commerce_order_save($order);
  $order_id_all = $result['oid'];
  $order_id = explode('-', $order_id_all);

  $api = commerce_firstdata_connect_api_object();
  if (!empty($result['response_hash']) and !empty($result['chargetotal']) and !empty($result['currency']) and !empty($order_id[0]) and !empty($result['approval_code'])) {
    $result_hash = $api->calculateResponseHash($result['response_hash'], $result['approval_code'], $result['chargetotal'], $result['currency'], $order_id[0]);
    $flag = 1;
  }

  // Direct payment.
  $api = commerce_firstdata_connect_api_object();
  $respond_codes = commerce_firstdata_connect_get_response_code($result);

  if ($respond_codes['approval_code_status'] == 'Y' && $result['response_code_3dsecure'] == 1 && ($result_hash == TRUE or $result_hash == 'Parameter txndatetime was not stored.')) {
    $payment_method = commerce_payment_method_instance_load('commerce_firstdata_connect_full_payment|commerce_payment_commerce_firstdata_connect_full_payment');
    $customer_profile = commerce_customer_profile_load($order->commerce_customer_billing[LANGUAGE_NONE][0]['profile_id']);
    $transaction = commerce_payment_transaction_new('commerce_firstdata_connect_full_payment', $order_id[0]);
    $transaction->instance_id = $payment_method['instance_id'];
    $transaction->remote_id = !empty($respond_codes['remote_id']) ? $respond_codes['remote_id'] : '';
    $transaction->amount = $order->commerce_order_total[LANGUAGE_NONE][0]['amount'];
    $transaction->uid = $user->uid;
    if (!empty($respond_codes['tdate'])) {
      $transaction->data['tdate'] = $respond_codes['tdate'];
    }

    $transaction->currency_code = $order->commerce_order_total[LANGUAGE_NONE][0]['currency_code'];
    $transaction->status = ($payment_method['settings']['transaction_type_process'] == 'preauth') ? COMMERCE_PAYMENT_STATUS_PENDING : COMMERCE_FIRSTDATA_CONNECT_CAPTURED;
    $transaction->message_variables = array('@name' => $customer_profile->commerce_customer_address[LANGUAGE_NONE][0]['name_line']);
    $transaction->message = ($payment_method['settings']['transaction_type_process'] == 'preauth') ? 'Authorised' : COMMERCE_FIRSTDATA_CONNECT_CAPTURED;
    $transaction->remote_status = $result['status'];
    $transaction->payload = $result;
    if (!empty($transaction->uid)) {
      commerce_payment_transaction_save($transaction);
    }

    // Save and update the card.
    if (!empty($result['hosteddataid'])) {
      $card_data = commerce_firstdata_connect_card_on_file_load_by_date($user->uid, $result['hosteddataid']);
      $card = reset($card_data);
      $card->remote_id = !empty($result['hosteddataid']) ? $result['hosteddataid'] : $card->card_id;
      commerce_cardonfile_save($card);
    }
    drupal_goto(t('checkout/@order/complete', array('@order' => $order->order_id)));
  }
  else {
    if (!empty($flag) and empty($result_hash) or $result_hash == FALSE) {
      drupal_set_message(t('The response is not valid! It might be a fraud attempt!'), 'error');
      return FALSE;
    }
    if (!empty($api->logs) and $api->logs == 0) {
      watchdog('commerce_firstdata_connect', "Your transaction failed,  your card was not 3D secure authenticated!.", array(), WATCHDOG_ERROR);
    }
    drupal_set_message(t('Your transaction failed,  your card was not 3D secure authenticated!'), 'error');
    if (!empty($result['response_code_3dsecure'])) {
      $result['data'] = $result['fail_reason'];
      $result['code'] = $result['approval_code'];
      $result['status_message'] = $result['status'];
      $order->status = 'checkout_review';
      commerce_order_save($order);
      return drupal_goto('firstdata_connect/hosted/fail', array(
          'query' => array(
            'dsta' => base64_encode($result['data']),
            'status_message' => $result['status'],
            'code' => $result['code'],
            'fail_reason' => $result['fail_reason'],
            'order_id' => $order->order_id,
          ),
         ));
    }
  }
}

/**
 * Proceed with 3D secure authentication.
 */
function commerce_firstdata_connect_3d_secure() {
  $result = base64_decode($_GET['result']);
  return $result;
}

/**
 * Mimic batch trigger so it can be triggered when cron runs.
 */
function commerce_firstdata_connect_batch_rule($date) {
  $_SESSION['http_request_count'] = 0;
  $form_state = array();
  $form_state['values']['hidden_value'] = 1;
  $form_state['values']['op'] = 'Capture';
  $form_state['values']['submit'] = 'Capture';
  $form_state['values']['date'] = $date;
  drupal_form_submit('commerce_firstdata_connect_batch_form', $form_state);
}

/**
 * Form for the batch process.
 */
function commerce_firstdata_connect_batch_form($form, &$form_state) {
  $form['capture_fieldset'] = array(
    '#type' => 'fieldset',
    '#description' => t('Capture all pending transactions'),
    '#title' => t('Capture'),
  );

  $form['date'] = array(
    '#type' => 'textfield',
    '#description' => t('Enter date (like: 16 June 2013), time stamp or days in the past (by giving negative values) like -1 day, -2 days, -3 days … (this will capture all pending transactions from the previous day, 2 days before today or 3 days before today)
                       or just use “now” to capture all pending transactions from this moment. May use the following format as well: YYYY-MM-DD HH:MM:SS'),
    '#title' => t('Chose a date from which to start capturing transactions.'),
    '#default_value' => 'now',
    '#required' => TRUE,
  );

  $form['hidden_value'] = array(
    '#type' => 'hidden',
    '#value' => 1,
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#description' => t('Capture all pending transactions'),
    '#value' => 'Capture',
  );

  return $form;
}

/**
 * If the form is submited start the batch process.
 */
function commerce_firstdata_connect_batch_form_submit($form, &$form_state) {
  $date = $form_state['values']['date'];
  if (is_numeric($form_state['values']['date']) != TRUE) {
    $date = strtotime($date);
  }

  if ($form_state['values']['hidden_value'] == 1) {
    $batch = commerce_firstdata_connect_batch_process($date);
    batch_set($batch);
  }
}

/**
 * Batch process.
 */
function commerce_firstdata_connect_batch_process($date = '') {
  if (!empty($date)) {
    $all_transactions = commerce_firstdata_connect_load_all_pending_transactions($date);
  }
  else {
    $all_transactions = commerce_firstdata_connect_load_all_pending_transactions();
  }
  $operations = array();
  foreach ($all_transactions as $key => $value) {
    $transaction_id = $value->transaction_id;

    $operations[] = array(
      'commerce_firstdata_connect_batch_operation',
      array(
        $transaction_id,
        t('(Operation @operation)', array('@operation' => $key)),
      ),
    );
  }

  $batch = array(
    'operations' => $operations,
    'finished' => 'commerce_firstdata_connect_batchs_finished',
  );

  return $batch;
}

/**
 * Batch operation process.
 */
function commerce_firstdata_connect_batch_operation($transaction_id, $operation_details, &$context) {
  $transaction = commerce_firstdata_connect_load_all_pending_transactions('', $transaction_id);
  if (is_array($transaction)) {
    $transaction = reset($transaction);
  }
  $order = commerce_order_load($transaction->order_id);

  $context['message'] = t('Process transactions "@title"', array('@title' => $transaction->payment_method)) . ' ' . $operation_details;
  $payment_method = commerce_payment_method_instance_load($transaction->instance_id);
  $api = commerce_firstdata_connect_api_object('', $payment_method['instance_id']);
  if (!empty($order)) {
    $result = $api->crossPayment($order, $transaction, 'postauth');
  }
  $context['results'][] = !empty($result) ? $result : '';
}

/**
 * Batch 'finished' callback.
 */
function commerce_firstdata_connect_batchs_finished($success, $results, $operations) {

  if ($success and !empty($results)) {
    foreach ($results as $single_result) {
      if (!empty($single_result)) {
        if (strstr($single_result->data, '"APPROVED" name="status"') != FALSE) {
          // Update database.
          if (empty($single_result->approval_code)) {
            $data = commerce_firstdata_connect_get_response_data($single_result);
          }
          else {
            $data = $single_result->data;
          }
          $respond_codes = commerce_firstdata_connect_get_response_code($data);
          $order_ids = $data['oid'];
          $order_id = explode('-', $order_ids);
          $transaction = commerce_firstdata_connect_load_all_pending_transactions('', '', $order_id[0]);
          if (is_array($transaction) == TRUE) {
            $transaction = reset($transaction);
          }
          $order = commerce_order_load($order_id[0]);
          if (is_array($order) == TRUE) {
            $order = reset($order);
          }
          if ($single_result->status_message == 'OK' and $single_result->code == 200 and $respond_codes['approval_code_status'] == 'Y' and !empty($transaction->transaction_id)) {
            $transaction->status = COMMERCE_FIRSTDATA_CONNECT_CAPTURED;
            $transaction->message .= '<br />' . t('Captured: @date', array('@date' => format_date(REQUEST_TIME, 'short')));
            commerce_payment_transaction_save($transaction);
            drupal_set_message(t('Transactions were captured successfully.'), 'status');
          }
          elseif ($respond_codes['message'] == 'PostAuth already performed' and !empty($transaction->transaction_id)) {
            $transaction->status = COMMERCE_FIRSTDATA_CONNECT_CAPTURED;
            $transaction->message .= '<br />' . t('Captured: @date', array('@date' => format_date(REQUEST_TIME, 'short')));
            commerce_payment_transaction_save($transaction);
            drupal_set_message(t('This order has been captured previously.'), 'status');
          }
        }
      }
    }
  }
  else {
    // An error occurred.
    $error_operation = reset($operations);
    drupal_set_message(
      t('An error occurred while processing @operation with arguments : @args',
        array(
          '@operation' => $error_operation[0],
          '@args' => print_r($error_operation[0], TRUE),
        )
      )
    );
  }
}

/**
 * Loads transactions by date, transaction_id or order_id.
 */
function commerce_firstdata_connect_load_all_pending_transactions($date = '', $transaction_id = '', $order_id = '') {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_payment_transaction')
  ->propertyCondition('status', 'pending');
  if (!empty($transaction_id)) {
    $query->propertyCondition('transaction_id', $transaction_id);
  }
  elseif (!empty($order_id)) {
    $query->propertyCondition('order_id', $order_id);
  }
  elseif (!empty($date)) {
    $query->propertyCondition('created', $date, '<=');
  }
  $query->propertyOrderBy('transaction_id', 'DESC');
  $return = array();
  $result = $query->execute();
  if (!empty($result['commerce_payment_transaction'])) {
    foreach ($result['commerce_payment_transaction'] as $transaction_id) {
      $return[] = entity_load_single('commerce_payment_transaction', $transaction_id->transaction_id);
    }
  }
  return $return;
}


/**
 * Determine whether the user has permissions to perform capture.
 */
function commerce_firstdata_connect_capture_access($order, $transaction) {
  // Return FALSE if the transaction isn't for Ogone or isn't
  // awaiting capture.
  if (($transaction->payment_method !== 'commerce_firstdata_connect_full_payment' and $transaction->payment_method !== 'commerce_firstdata_connect_hosted') || empty($transaction->remote_id) || $transaction->status !== COMMERCE_PAYMENT_STATUS_PENDING) {
    return FALSE;
  }
  // Allow access if the user can update this transaction.
  return commerce_payment_transaction_access('update', $transaction);
}

/**
 * Determine whether the user has permissions to perform cancel.
 */
function commerce_firstdata_connect_cancel_access($order, $transaction) {
  if (($transaction->payment_method !== 'commerce_firstdata_connect_full_payment' and $transaction->payment_method !== 'commerce_firstdata_connect_hosted') || empty($transaction->remote_id) || $transaction->status != COMMERCE_FIRSTDATA_CONNECT_CAPTURED || empty($transaction->data['tdate'])) {
    return FALSE;
  }
  return commerce_payment_transaction_access('update', $transaction);
}

/**
 * Determine whether the user has permissions to perform deletion.
 */
function commerce_firstdata_connect_delete_access($order, $transaction) {
  if (($transaction->payment_method !== 'commerce_firstdata_connect_full_payment' and $transaction->payment_method !== 'commerce_firstdata_connect_hosted') || empty($transaction->remote_id) || $transaction->status !== COMMERCE_PAYMENT_STATUS_PENDING) {
    return FALSE;
  }
  return commerce_payment_transaction_access('update', $transaction);
}

/**
 * Redirection for card on file for hosted payment.
 */
function commerce_firstdata_connect_redirect_for_hosted_saved_cards() {
  module_load_include('inc', 'commerce_payment', 'includes/commerce_payment.credit_card');
  module_load_include('inc', 'commerce_payment', 'includes/commerce_payment.checkout_pane');

  $form_param = base64_decode($_GET['form_param']);
  $action = base64_decode($_GET['action']);
  $all = explode('&', $form_param);

  foreach ($all as $value) {
    if (!empty($value)) {
      $new_str = explode('=', $value);
      $new_arr[$new_str[0]] = $new_str[1];
    }
  }

  $form_redirect = commerce_payment_post_redirect_form($action, $new_arr);
  // Temp solution because commerce_payment_post_redirect_form doesn't
  // Add all the urls.
  $form_redirect['form']['#attached']['js'][] = drupal_get_path('module', 'commerce_payment') . '/commerce_payment.js';
  $form_redirect['form']['#prefix'] = '<div class="payment-redirect-form">';
  $form_redirect['form']['#suffix'] = '</div>';
  return $form_redirect;
}

/**
 * Redirect form for hosted payment.
 */
function commerce_firstdata_connect_commerce_payment_post_redirect_form($action, array $values = array()) {
  $form = array(
    '#type' => 'form',
    '#action' => $action,
    '#method' => 'POST',
    '#id' => '',
    '#attributes' => array(),
  );
  $i = 0;
  foreach ($values as $key => $value) {
    $form[$value] = array(
      '#type' => 'hidden',
      '#name' => $key,
      '#value' => $value,
      '#id' => '',
      '#attributes' => array(),
    );

    $i++;
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#id' => '',
    '#value' => t('Proceed to payment'),
  );

  return array(
    'form' => array(
      '#type' => 'markup',
      '#markup' => $form,
    ),
  );
}

/**
 * Creates an array from the http response which is HTML.
 */
function commerce_firstdata_connect_get_response_data($result) {
  // Strips everything in the incoming html, but the input tags.
  if (!empty($result->data)) {
    $input_data = strip_tags($result->data, '<input>');
  }
  else {
    return;
  }
  // Removes the extra irrelevant data.
  $input_data = str_replace('&#9;', '', $input_data);
  $exp = explode('>', $input_data);
  foreach ($exp as $value) {
    if (!empty($value)) {
      $data[] = explode(' ', $value);
    }
  }
  // Extracts the value and names' values of input elements.
  foreach ($data as $val) {
    foreach ($val as $v) {
      if (strstr($v, 'value') != FALSE) {
        $values = str_replace('value=', '', $v);
        $values = str_replace('"', '', $values);
        $values_array[] = $values;
      }
      elseif (strstr($v, 'name') != FALSE) {
        $names = str_replace('name=', '', $v);
        $names = str_replace('"', '', $names);
        $names_array[] = $names;
      }
    }
  }
  // Simply combines the names and values from an input element.
  $new_array = array_combine($names_array, $values_array);
  return $new_array;
}

/**
 * Extract response codes from the returned data.
 */
function commerce_firstdata_connect_get_response_code($incoming_data) {
  $data = $incoming_data['approval_code'];
  $result_array = explode(':', $data);
  // The received approval code is split in it's consistent parts.
  foreach ($result_array as $key => $value) {
    switch ($key) {
      case '0':
        $result['approval_code_status'] = $value;
        break;

      case '1':
        $result['reference_number'] = $value;
        break;

      case '2':
        $result['external_id'] = $value;
        break;

      case '3':
        $result['message'] = $value;
        break;

      case '4':
        $result['remote_id'] = $value;
        break;
    }
  }
  // Adds a message for each code.
  if (!empty($result['message']) and strstr($result['message'], 'PPX') != FALSE) {
    $message = t('No address data provided or Address not checked by the Card Issuer.');
  }
  if (!empty($result['message']) and strstr($result['message'], 'YYY') != FALSE) {
    $message = t('Card Issuer confirmed that street and postcode match with their records.');
  }
  if (!empty($result['message']) and strstr($result['message'], 'YNA') != FALSE) {
    $message = t('Card Issuer confirmed that street matches with their records but postcode does not match.');
  }
  if (!empty($result['message']) and strstr($result['message'], 'NYZ') != FALSE) {
    $message = t('Card Issuer confirmed that postcode matches with their records but street does not match.');
  }
  if (!empty($result['message']) and strstr($result['message'], 'NNN') != FALSE) {
    $message = t('Both street and postcode do not match with the Card Issuer’s records.');
  }
  if (!empty($result['message']) and strstr($result['message'], 'YPX') != FALSE) {
    $message = t('Card Issuer confirmed that street matches with their records. The Issuer did not check the postcode.');
  }
  if (!empty($result['message']) and strstr($result['message'], 'PYX') != FALSE) {
    $message = t('Card Issuer confirmed that postcode matches with their records. The Issuer did not check the street.');
  }
  if (!empty($result['message']) and strstr($result['message'], 'XXU') != FALSE) {
    $message = t('Card Issuer did not check the AVS information.');
  }

  if (!empty($result['message']) and strrchr($result['message'], 'M') != FALSE) {
    $message_second = t('Security code status: Card Security Code match.');
  }
  if (!empty($result['message']) and strrchr($result['message'], 'N') != FALSE) {
    $message_second = t('Security code status: Card Security Code does not match.');
  }
  if (!empty($result['message']) and strrchr($result['message'], 'P') != FALSE) {
    $message_second = t('Security code status: Not processed.');
  }
  if (!empty($result['message']) and strrchr($result['message'], 'S') != FALSE) {
    $message_second = t('Security code status: Merchant has indicated that the card security code is not present on the card.');
  }
  if (!empty($result['message']) and strrchr($result['message'], 'U') != FALSE) {
    $message_second = t('Security code status: Issuer is not certified and/or has not provided encryption keys.');
  }
  if (!empty($result['message']) and strrchr($result['message'], 'X') != FALSE) {
    $message_second = t('Security code status: No response from the credit card association was received.');
  }
  if (!empty($result['message']) and strlen($result['message']) == 3) {
    $message_second = t('Security code status: No code was sent.');
  }
  // Combine the code with specific response message.
  $response_message = !empty($message) ? $message : '' . !empty($message_second) ? $message_second : '';
  $result['message'] = $response_message;
  if (count($result_array) == 3 and is_numeric($result_array[2]) == FALSE) {
    $result['message'] = $result_array[2];
  }

  return $result;
}

/**
 * Payment method callback: settings form.
 *
 * Returns form elements for the payment method's settings form included
 * as part of the payment method's enabling action in Rules
 */
function commerce_firstdata_connect_settings_form($settings = NULL) {
  global $base_root;

  $form = array();
  if (strstr(current_path(), 'commerce_payment_commerce_firstdata_connect_full_payment') != FALSE) {
    $description = t('By using this module your customer will stay on your Drupal page to enter card details - All payment information is encrypted and transmitted only via a secure 128bit SSL (Secure Socket layer) connection; we strongly recommend you install SSL Certificate (https) for the comfort of your customers');
  }
  else {
    $description = t('By using this module your customer will be redirected to the First Data secure hosted page to enter card details- please contact First Data if you want to add your corporate logo/brand to the hosted payment page');
  }
  $form['method_description'] = array(
    '#type' => 'item',
    '#markup' => '<h3>' . $description . '</h3>',
  );

  // Basic settings.
  $form['url'] = array(
    '#type' => 'radios',
    '#title' => t('Url transaction modes'),
    '#options' => array(
      'test' => ('Test url - for testing purposes only'),
      'prod' => ('Production url - use for processing real transactions'),
    ),
    '#default_value' => !empty($settings['url']) ? $settings['url'] : 'test',
    '#required' => TRUE,
    '#description' => t('Choose mode that will correspond to the test or production url used for the requests.'),
  );

  $form['storename'] = array(
    '#type' => 'textfield',
    '#title' => t('Store number.'),
    '#description' => t('Please enter your store id. For more information, visit <a href= "@url_info"> firstdata web site </a>', array('@url_info' => 'https://www.firstdatams.co.uk/fdms/en_gb/home.html')),
    '#default_value' => !empty($settings['storename']) ? $settings['storename'] : '',
    '#required' => TRUE,
  );

  $form['sharedsecret'] = array(
    '#type' => 'textfield',
    '#title' => t('Secret.'),
    '#description' => t('Please enter your shared secret. For more information, visit <a href= "@url_info"> firstdata web site </a>', array('@url_info' => 'https://www.firstdatams.co.uk/fdms/en_gb/home.html')),
    '#default_value' => !empty($settings['sharedsecret']) ? $settings['sharedsecret'] : '',
    '#required' => TRUE,
  );

  $form['transaction_type_process'] = array(
    '#type' => 'radios',
    '#prefix' => '<br />',
    '#title' => t('Transaction capture method'),
    '#description' => t('Select transaction type (sale or preauth), sale type will complete the transaction process, preauth will leave open the transaction giving a chance to capture it later.'),
    '#default_value' => empty($settings['transaction_type_process']) ? 'sale' : $settings['transaction_type_process'],
    '#options' => array(
      'sale' => t('Sale'),
      'preauth' => t('Pre-Auth'),
    ),
    '#required' => TRUE,
  );

  $payment_type_options = array(
    'payonly' => t('PayOnly mode'),
    'payplus' => t('PayPlus mode'),
    'fullpay' => t('Full mode'),
  );

  $form['payment_mode'] = array(
    '#type' => 'radios',
    '#prefix' => '<br />',
    '#title' => t('Select payment mode'),
    '#description' => t('Select payment mode'),
    '#options' => $payment_type_options,
    '#default_value' => !empty($settings['payment_mode']) ? $settings['payment_mode'] : 'payonly',
    '#required' => TRUE,
  );

  $form['extended_hash'] = array(
    '#type' => 'checkbox',
    '#title' => t('Apply extended hash.'),
    '#prefix' => '<br />',
    '#description' => t('The extended Hash is an optional security feature that allows you to include all parameters of the transaction request.'),
    '#default_value' => !empty($settings['extended_hash']) ? $settings['extended_hash'] : '',
  );

  $time_zone = variable_get('date_default_timezone');
  foreach (timezone_abbreviations_list() as $key => $value) {
    if (strlen($key) > 1) {
      foreach ($value as $v) {
        if ($v['timezone_id'] == $time_zone) {
          $timezone_abriviation = strtoupper($key);
          $time_zone_string = $timezone_abriviation . '-' . $time_zone . ' ' . ((round($v['offset'] / 3600, 0) > 0) ? ' +' . round($v['offset'] / 3600, 0) : round($v['offset'] / 3600, 0)) . ' hours';
        }
      }
    }
  }

  $form['time_zone'] = array(
    '#type' => 'item',
    '#title' => t('Default timezone'),
    '#markup' => '<p>' . t('@timezone', array('@timezone' => $time_zone_string)) . '</p>',
    '#description' => t('To change the server time zone go to: @link', array('@link' => l(t('regional settings'), $base_root . '/admin/config/regional/settings'))),
    '#suffix' => '<br /><br />',
  );

  // Card on File module support.
  if (module_exists('commerce_cardonfile')) {
    $form['cardonfile'] = array(
      '#type' => 'checkbox',
      '#title' => t('Enable Card on File functionality with this payment method.'),
      '#description' => t('Stores tokenised value for card data.'),
      '#default_value' => !empty($settings['cardonfile']) ? $settings['cardonfile'] : '',
    );
  }
  else {
    $form['cardonfile'] = array(
      '#type' => 'markup',
      '#markup' => t('To enable Card on File funcitionality download and install the Card on File module.'),
    );
  }

  // Language selection.
  $languages = array(
    'en_US' => t('English (USA)'),
    'en_GB' => t('English (UK)'),
    'fi_FI' => t('Finnish'),
    'fr_FR' => t('French'),
    'de_DE' => t('German'),
    'it_IT' => t('Italian'),
  );

  $form['language'] = array(
    '#type' => 'select',
    '#title' => t('Language'),
    '#description' => t('Select language from the list.'),
    '#options' => $languages,
    '#default_value' => !empty($settings['language']) ? $settings['language'] : '',
  );

  $form['logs'] = array(
    '#type' => 'select',
    '#title' => t('Log issues.'),
    '#description' => t('Log issues when they appear from http requests or other failure.'),
    '#options' => array(
      '0' => t('Always log issues.'),
      '1' => t('Never log issues.'),
    ),
    '#default_value' => empty($settings['logs']) ? 0 : $settings['logs'],
  );

  $form['validate'] = array(
    '#type' => 'hidden',
    '#title' => t('validate'),
    '#description' => t('validate'),
    '#element_validate' => array('commerce_firstdata_connect_validate_element'),
  );

  return $form;
}

/**
 * Gives more weight to the direct payment to reorder the methods display.
 */
function commerce_firstdata_connect_validate_element($element, $form, &$form_state) {
  $direct_payment = rules_config_load('commerce_payment_commerce_firstdata_connect_full_payment');
  $direct_payment->weight = 10;
  $direct_payment->save();
  $hosted_payment = rules_config_load('commerce_payment_commerce_firstdata_connect_hosted');
  $hosted_payment->weight = -10;
  $hosted_payment->save();
  rules_clear_cache();

  // Sync the main credential settings for both of the methods.
  // Change the settings for the direct payment if the offsite was set.
  if (strstr(current_path(), 'commerce_payment_commerce_firstdata_connect_hosted') != FALSE) {
    // Load the configuration for the direct payment.
    $rule = rules_config_load('commerce_payment_commerce_firstdata_connect_full_payment');
    // Loop through all elements of the rule.
    foreach ($rule->actions() as $action) {
      if (empty($action->settings['payment_method']['settings'])) {
        // Url account.
        $action->settings['payment_method'] = array(
          'settings' => array(
            // Url account.
            'url' => $form_state['parameter']['payment_method']['settings']['payment_method']['settings']['url']['#value'],
            // Storename.
            'storename' => $form_state['parameter']['payment_method']['settings']['payment_method']['settings']['storename']['#value'],
            // Sharedsecret.
            'sharedsecret' => $form_state['parameter']['payment_method']['settings']['payment_method']['settings']['sharedsecret']['#value'],
          ));
        $action->save();
      }
      else {
        // Url account.
        $action->settings['payment_method']['settings']['url'] = $form_state['parameter']['payment_method']['settings']['payment_method']['settings']['url']['#value'];
        // Storename.
        $action->settings['payment_method']['settings']['storename'] = $form_state['parameter']['payment_method']['settings']['payment_method']['settings']['storename']['#value'];
        // Sharedsecret.
        $action->settings['payment_method']['settings']['sharedsecret'] = $form_state['parameter']['payment_method']['settings']['payment_method']['settings']['sharedsecret']['#value'];
        // Save the settings for the direct payment method.
        $action->save();
      }
    }
  }
  elseif (strstr(current_path(), 'commerce_payment_commerce_firstdata_connect_full_payment') != FALSE) {
    // Load the configuration for the direct payment.
    $rule = rules_config_load('commerce_payment_commerce_firstdata_connect_hosted');

    // Loop through all elements of the rule.
    foreach ($rule->actions() as $action) {
      if (empty($action->settings['payment_method']['settings'])) {
        $action->settings['payment_method'] = array(
          'settings' => array(
            // Url account.
            'url' => $form_state['parameter']['payment_method']['settings']['payment_method']['settings']['url']['#value'],
            // Storename.
            'storename' => $form_state['parameter']['payment_method']['settings']['payment_method']['settings']['storename']['#value'],
            // Sharedsecret.
            'sharedsecret' => $form_state['parameter']['payment_method']['settings']['payment_method']['settings']['sharedsecret']['#value'],
          ));
        $action->save();
      }
      else {
        // Url account.
        $action->settings['payment_method']['settings']['url'] = $form_state['parameter']['payment_method']['settings']['payment_method']['settings']['url']['#value'];
        // Storename.
        $action->settings['payment_method']['settings']['storename'] = $form_state['parameter']['payment_method']['settings']['payment_method']['settings']['storename']['#value'];
        // Userid.
        $action->settings['payment_method']['settings']['sharedsecret'] = $form_state['parameter']['payment_method']['settings']['payment_method']['settings']['sharedsecret']['#value'];
        // Save the settings for the direct payment method.
        $action->save();
      }
    }
  }

}

/**
 * Calculates the hash needed for the transaction.
 */
function commerce_firstdata_connect_createHash($chargetotal, $currency, $time, $all_params = '') {
  $payment_method = commerce_payment_method_instance_load('commerce_firstdata_connect_full_payment|commerce_payment_commerce_firstdata_connect_full_payment');
  $storename = $payment_method['settings']['storename'];
  $shared_secret = $payment_method['settings']['sharedsecret'];
  $string_to_hash = $storename . $time . $chargetotal . $currency . $shared_secret;
  $ascii = bin2hex($string_to_hash);
  if (!empty($all_params)) {
    $all_params['sharedsecret'] = $shared_secret;
    ksort($all_params);
    $string_to_hash = '';
    foreach ($all_params as $key => $value) {
      if ($key !== 'hash' && $key !== 'sharedsecret') {
        $string_to_hash .= $value;
      }
    }

    $string_to_hash .= $all_params['sharedsecret'];
    $ascii = '';
    $ascii = bin2hex($string_to_hash);
  }
  return sha1($ascii);
}

/**
 * Creates api object.
 */
function commerce_firstdata_connect_api_object($settings = array(), $instance_id = '') {
  module_load_include('inc', 'commerce_firstdata_connect', 'includes/commerce_firstdata_connect.api');
  if (empty($instance_id)) {
    $instance = commerce_payment_method_instance_load('commerce_firstdata_connect_full_payment|commerce_payment_commerce_firstdata_connect_full_payment');
  }
  else {
    $instance = commerce_payment_method_instance_load($instance_id);
  }
  return new CommerceFirstdataConnectConnectApi($instance['settings']);
}

/**
 * Loads customers profiles by id.
 */
function commerce_firstdata_connect_customer_profile_load($profile_id = '') {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_customer_profile');
  if (!empty($profile_id)) {
    $query->propertyCondition('profile_id', $profile_id);
  }
  $query->propertyOrderBy('profile_id', 'DESC');
  $return = array();
  $result = $query->execute();
  if (!empty($result['commerce_customer_profile'])) {
    foreach ($result['commerce_customer_profile'] as $profile) {
      $return[] = entity_load_single('commerce_customer_profile', $profile->profile_id);
    }
  }
  return $return;
}

/**
 * Implements hool_commerce_payment_transaction_status_info().
 */
function commerce_firstdata_connect_commerce_payment_transaction_status_info() {
  $statuses = array();

  $statuses[COMMERCE_FIRSTDATA_CONNECT_CAPTURED] = array(
    'status' => COMMERCE_FIRSTDATA_CONNECT_CAPTURED,
    'title' => t('Captured'),
    'icon' => drupal_get_path('module', 'commerce_payment') . '/theme/icon-success.png',
    'total' => TRUE,
  );

  $statuses[COMMERCE_FIRSTDATA_CONNECT_REFUND] = array(
    'status' => COMMERCE_FIRSTDATA_CONNECT_REFUND,
    'title' => t('Refund'),
    'icon' => drupal_get_path('module', 'commerce_payment') . '/theme/icon-success.png',
    'total' => FALSE,
  );

  $statuses[COMMERCE_FIRSTDATA_CONNECT_CANCELED] = array(
    'status' => COMMERCE_FIRSTDATA_CONNECT_CANCELED,
    'title' => t('Voided'),
    'icon' => drupal_get_path('module', 'commerce_payment') . '/theme/icon-failure.png',
    'total' => FALSE,
  );

  return $statuses;
}

/**
 * Creates new card on file.
 */
function commerce_firstdata_connect_cardonfile_create($order, $payment_method, $pane_values) {
  global $user;

  if (empty($payment_method['method_id']) and !empty($pane_values['method_id'])) {
    $payment_method = $pane_values;
  }

  if (!empty($order) and !empty($order->order_id)) {
    $billing_profile = commerce_customer_profile_load($order->commerce_customer_billing[LANGUAGE_NONE][0]['profile_id']);
  }

  if (empty($pane_values['credit_card']['number']) and !empty($order['credit_card']['number']['#value'])) {
    $pane_values['credit_card']['number'] = $order['credit_card']['number']['#value'];
    $pane_values['credit_card']['type'] = $order['credit_card']['type']['#value'];
    $pane_values['credit_card']['exp_month'] = $order['credit_card']['exp_month']['#value'];
    $pane_values['credit_card']['exp_year'] = $order['credit_card']['exp_year']['#value'];
    $pane_values['credit_card']['code'] = $order['credit_card']['code']['#value'];
  }
  $card_data = commerce_cardonfile_new();
  $card_data->uid = !empty($order->uid) ? $order->uid : $user->uid;
  $card_data->payment_method = $payment_method['method_id'];
  $card_data->instance_id = $payment_method['instance_id'];
  $card_data->card_type = !empty($pane_values['credit_card']['type']) ? strtolower($pane_values['credit_card']['type']) : '';
  $card_data->card_name = !empty($billing_profile->commerce_customer_address[LANGUAGE_NONE][0]['name_line']) ? $billing_profile->commerce_customer_address[LANGUAGE_NONE][0]['name_line'] : $order['credit_card']['owner']['#value'];
  $card_data->card_number = drupal_substr($pane_values['credit_card']['number'], -4);
  $card_data->card_exp_month = $pane_values['credit_card']['exp_month'];
  $card_data->card_exp_year = $pane_values['credit_card']['exp_year'];
  $card_data->status = 1;
  if (is_object($card_data) == TRUE) {
    commerce_cardonfile_save($card_data);
  }
  $new_card = commerce_firstdata_connect_load_last_added_card();
  if (is_array($new_card) == TRUE) {
    $new_card = reset($new_card);
  }
  $new_card->remote_id = $new_card->card_id;
  if (is_object($new_card) == TRUE) {
    commerce_cardonfile_save($new_card);
  }

  // Save the card on First Data servers.
  if (empty($order->order_id)) {
    $this_card = commerce_firstdata_connect_load_last_added_card();
    if (is_array($this_card) == TRUE) {
      $this_card = reset($this_card);
    }
    $order = commerce_order_new($user->uid, 'cart', 'commerce_order');
    $order->commerce_order_total[LANGUAGE_NONE][0]['amount'] = 10;
    $order->commerce_order_total[LANGUAGE_NONE][0]['data']['components'][0]['price']['amount'] = 10;
    $customer_profile = commerce_customer_profile_new('billing', $user->uid);
    if (empty($customer_profile->commerce_customer_address[LANGUAGE_NONE][0]['name_line'])) {
      $customer_profile->commerce_customer_address[LANGUAGE_NONE][0]['name_line'] = t('None');
    }
    commerce_customer_profile_save($customer_profile);
    commerce_order_save($order);
    $order = commerce_firstdata_connect_load_user_last_order();
    if (is_array($order) == TRUE) {
      $order = reset($order);
    }

    $customer_profile = commerce_customer_profile_load($order->commerce_customer_billing[LANGUAGE_NONE][0]['profile_id']);
    if (is_array($customer_profile) == TRUE) {
      $customer_profile = reset($customer_profile);
    }
    // Initial transaction.
    $api = commerce_firstdata_connect_api_object();
    $amount = new stdClass();
    $amount->amount = 10;
    $amount->currency = $order->commerce_order_total[LANGUAGE_NONE][0]['currency_code'];
    $result = $api->directPayments($customer_profile, $order, $pane_values, $amount, 'new', $this_card, TRUE, 'preauth');
    $response = commerce_firstdata_connect_get_response_data($result);
    $respond_codes = commerce_firstdata_connect_get_response_code($response);
    $order_id_all = $response['oid'];
    $order_id = explode('-', $order_id_all);

    $api = commerce_firstdata_connect_api_object();
    if (!empty($response['response_hash']) and !empty($response['chargetotal']) and !empty($response['currency']) and !empty($order_id[0]) and !empty($response['approval_code'])) {
      $result_hash = $api->calculateResponseHash($result['response_hash'], $response['approval_code'], $response['chargetotal'], $response['currency'], $order_id[0]);
      $flag = 1;
    }

    if ($result->status_message == 'OK' && $result->code == '200' and $respond_codes['approval_code_status'] == 'Y') {
      $transaction = commerce_payment_transaction_new($payment_method['method_id'], $order->order_id);
      $transaction->instance_id = $payment_method['instance_id'];
      $transaction->remote_id = !empty($respond_codes['remote_id']) ? $respond_codes['remote_id'] : '';
      $transaction->amount = $order->commerce_order_total[LANGUAGE_NONE][0]['amount'];
      $transaction->currency_code = $order->commerce_order_total[LANGUAGE_NONE][0]['currency_code'];
      $transaction->status = COMMERCE_PAYMENT_STATUS_PENDING;
      $transaction->message_variables = array('@name' => $user->uid);
      $transaction->message = 'Authorised';
      $transaction->remote_status = $response['status'];
      $transaction->order_id = $order->order_id;
      $transaction->payload = $response;
      $transaction->data['tdate'] = $response['tdate'];
      commerce_payment_transaction_save($transaction);
    }
    elseif (!empty($flag) and empty($result_hash) or $result_hash == FALSE) {
      drupal_set_message(t('The response is not valid! It might be a fraud attempt!'), 'error');
      return;
    }
    $last_saved_transaction = commerce_firstdata_connect_load_last_saved_transaction();
    if (is_array($last_saved_transaction) == TRUE) {
      $last_saved_transaction = reset($last_saved_transaction);
    }

    $amount = new stdClass();
    $amount->currency = $order->commerce_order_total[LANGUAGE_NONE][0]['currency_code'];
    $amount->amount = 10;
    // Capture.
    $result = $api->crossPayment($order, $last_saved_transaction, 'postauth', $amount);
    $response = commerce_firstdata_connect_get_response_data($result);
    $respond_codes = commerce_firstdata_connect_get_response_code($response);
    $order_id_all = $response['oid'];
    $order_id = explode('-', $order_id_all);

    if (!empty($response['response_hash']) and !empty($response['chargetotal']) and !empty($response['currency']) and !empty($order_id[0]) and !empty($response['approval_code'])) {
      $result_hash = $api->calculateResponseHash($result['response_hash'], $response['approval_code'], $response['chargetotal'], $response['currency'], $order_id[0]);
      $flag = 1;
    }

    if ($result->status_message == 'OK' && $result->code == '200' and $respond_codes['approval_code_status'] == 'Y' && ($result_hash == TRUE or $result_hash == 'Parameter txndatetime was not stored.')) {
      $last_saved_transaction->amount = $amount->amount;
      if (!empty($respond_codes['remote_id'])) {
        $last_saved_transaction->remote_id = $last_saved_transaction->remote_id . '/' . $respond_codes['remote_id'];
      }
      $last_saved_transaction->status = COMMERCE_FIRSTDATA_CONNECT_CAPTURED;
      $last_saved_transaction->message .= '<br />' . t('Captured: @date', array('@date' => format_date(REQUEST_TIME, 'short')));
      if (!empty($response['tdate'])) {
        $last_saved_transaction->data['tdate'] = $response['tdate'];
      }
      commerce_payment_transaction_save($last_saved_transaction);
      $order->status = 'pending';
      commerce_order_save($order);

    }
    elseif (!empty($flag) and empty($result_hash) or $result_hash == FALSE) {
      drupal_set_message(t('The response is not valid! It might be a fraud attempt!'), 'error');
      return;
    }
    $last_saved_transaction = commerce_firstdata_connect_load_last_saved_transaction();
    if (is_array($last_saved_transaction) == TRUE) {
      $last_saved_transaction = reset($last_saved_transaction);
    }
    $amount = new stdClass();
    $amount->currency = $order->commerce_order_total[LANGUAGE_NONE][0]['currency_code'];
    $amount->amount = 10;

    // Void.
    $result = $api->crossPayment($order, $last_saved_transaction, 'void', $amount);
    $response = commerce_firstdata_connect_get_response_data($result);
    $respond_codes = commerce_firstdata_connect_get_response_code($response);
    $order_id_all = $response['oid'];
    $order_id = explode('-', $order_id_all);

    if (!empty($response['response_hash']) and !empty($response['chargetotal']) and !empty($response['currency']) and !empty($order_id[0]) and !empty($response['approval_code'])) {
      $result_hash = $api->calculateResponseHash($result['response_hash'], $response['approval_code'], $response['chargetotal'], $response['currency'], $order_id[0]);
      $flag = 1;
    }

    if ($result->status_message == 'OK' && $result->code == '200' and !empty($respond_codes['approval_code_status']) and $respond_codes['approval_code_status'] == 'Y' && ($result_hash == TRUE or $result_hash == 'Parameter txndatetime was not stored.')) {
      $last_saved_transaction->amount = $amount->amount;
      $last_saved_transaction->status = COMMERCE_FIRSTDATA_CONNECT_CANCELED;
      $last_saved_transaction->message .= '<br />' . t('Voided: @date', array('@date' => format_date(REQUEST_TIME, 'short')));
      $last_saved_transaction->message .= '<br />' . t('Adding new card for customer: @user_mail', array('@user_mail' => $user->mail));
      if (!empty($response['tdate'])) {
        $last_saved_transaction->data['tdate'] = $response['tdate'];
      }
      commerce_payment_transaction_save($last_saved_transaction);
      $card_data->remote_id = $card_data->card_id;

      if (is_object($card_data) == TRUE) {
        commerce_cardonfile_save($card_data);
      }
      $card = commerce_cardonfile_load($card_data->card_id);
      if (is_array($card)) {
        $card = reset($card);
      }
      return $card;
    }
    else {
      if (!empty($flag) and empty($result_hash) or $result_hash == FALSE) {
        drupal_set_message(t('The response is not valid! It might be a fraud attempt!'), 'error');
        return;
      }
      drupal_set_message(t('Error occur, the card was not saved.'), 'error');
      $instance = commerce_payment_method_instance_load($payment_method['instance_id']);
      if ($instance['settings']['logs'] == 0) {
        if (empty($response['fail_reason_details'])) {
          $response['fail_reason_details'] = t('An error occur during the transaction process card has been decline.');
        }
        watchdog('commerce_firstdata_connect', "Your card was not saved, an error occur: @error . @error_details", array('@error' => $response['fail_reason'], '@error_details' => $response['fail_reason_details']), WATCHDOG_ERROR);
      }
      commerce_cardonfile_delete($card_data->card_id);
      return FALSE;
    }
    $result->order = $order;
    $result->transaction = $last_saved_transaction;
    $result->amount = $amount;
  }
}

/**
 * Loads latest transactions.
 */
function commerce_firstdata_connect_load_last_saved_transaction() {
  global $user;
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_payment_transaction')
  ->propertyCondition('uid', $user->uid);
  $query->propertyOrderBy('created', 'DESC');
  $query->range(0, 1);
  $return = array();
  $result = $query->execute();
  if (!empty($result['commerce_payment_transaction'])) {
    foreach ($result['commerce_payment_transaction'] as $transaction) {
      $return[] = entity_load_single('commerce_payment_transaction', $transaction->transaction_id);
    }
  }
  return $return;
}

/**
 * Loads last added card.
 */
function commerce_firstdata_connect_load_last_added_card() {
  global $user;
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_cardonfile')
  ->propertyCondition('uid', $user->uid);
  $query->propertyOrderBy('created', 'DESC');
  $query->range(0, 1);
  $return = array();
  $result = $query->execute();
  if (!empty($result['commerce_cardonfile'])) {
    foreach ($result['commerce_cardonfile'] as $card) {
      $return[] = entity_load_single('commerce_cardonfile', $card->card_id);
    }
  }
  return $return;
}

/**
 * Loads latest order of the current user.
 */
function commerce_firstdata_connect_load_user_last_order() {
  global $user;
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_order')
  ->propertyCondition('uid', $user->uid);
  $query->propertyOrderBy('created', 'DESC');
  $query->range(0, 1);
  $return = array();
  $result = $query->execute();
  if (!empty($result['commerce_order'])) {
    foreach ($result['commerce_order'] as $order) {
      $return[] = entity_load_single('commerce_order', $order->order_id);
    }
  }
  return $return;
}

/**
 * Loads transactions by date.
 */
function commerce_firstdata_connect_card_on_file_load_by_date($uid, $card_id = '', $range = '') {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_cardonfile')
  ->propertyCondition('uid', $uid);
  if (!empty($card_id)) {
    $query->propertyCondition('card_id', $card_id);
  }
  $query->propertyOrderBy('created', 'DESC');
  if (!empty($range) and $range != 'none') {
    $query->range($range);
  }
  elseif (empty($range)) {
    $query->range(0, 1);
  }
  $return = array();
  $result = $query->execute();
  if (!empty($result['commerce_cardonfile'])) {
    foreach ($result['commerce_cardonfile'] as $card_on_file) {
      $return[] = entity_load_single('commerce_cardonfile', $card_on_file->card_id);
    }
  }
  return $return;
}

/**
 * Alter the redirect form for the offsite payment method.
 */
function commerce_firstdata_connect_redirect_alter_form($form, &$form_state, $order) {
  $payment_method = commerce_payment_method_instance_load('commerce_firstdata_connect_hosted|commerce_payment_commerce_firstdata_connect_hosted');
  $order->data['payment_redirect_key'] = drupal_hash_base64($order->changed);
  $settings = array(
    'cancel_return' => url('checkout/' . $order->order_id . '/payment/back/' . $order->data['payment_redirect_key'], array('absolute' => TRUE)),
    'return' => url('checkout/' . $order->order_id . '/payment/return/' . $order->data['payment_redirect_key'], array('absolute' => TRUE)),
    'payment_method' => $payment_method['instance_id'],
  );
  commerce_payment_redirect_pane_next_page($order);

  return commerce_firstdata_connect_redirect_form($form, $form_state, $order, array_merge($payment_method['settings'], $settings));
}

/**
 * Redirect function for hosted payment method.
 */
function commerce_firstdata_connect_redirect_form($form, &$form_state, $order, $settings) {
  global $base_root;
  $payment_methods = commerce_payment_method_instance_load('commerce_firstdata_connect_hosted|commerce_payment_commerce_firstdata_connect_hosted');
  $api = commerce_firstdata_connect_api_object('', $payment_methods['instance_id']);

  $payment_methods = commerce_payment_method_instance_load('commerce_firstdata_connect_hosted|commerce_payment_commerce_firstdata_connect_hosted');
  if ($api->transaction_type_process != 'sale') {
    $api->transaction_type_process = 'preauth';
  }
  $amount = $order->commerce_order_total[LANGUAGE_NONE][0]['amount'];
  $currency = $order->commerce_order_total[LANGUAGE_NONE][0]['currency_code'];
  $currency_new_code = commerce_currency_load($currency);
  $currency_code = $currency_new_code['numeric_code'];

  if ($api->commerceFirstdataConnectDevice() == 'mobile') {
    $mobile_mode = TRUE;
  }

  // Get the timezone.
  $money = commerce_currency_amount_to_decimal($amount, $currency);
  // All of the billing data needed for the request.
  $billing_data = array(
    // Mandatory fields.
    'txntype' => !empty($api->transaction_type_process) ? $api->transaction_type_process : $api->commerce_firstdata_connect_errors('transaction_type_process', $payment_methods),
    'timezone' => commerce_firstdata_connect_get_default_time_zone(),
    'txndatetime' => date('Y:m:d-H:i:s'),
    'hash' => commerce_firstdata_connect_createHash($money, $currency_code, date('Y:m:d-H:i:s')),
    'storename' => !empty($api->storename) ? $api->storename : $api->commerce_firstdata_connect_errors('storename', $payment_methods),
    'mode' => !empty($api->mode) ? $api->mode : $api->commerce_firstdata_connect_errors('mode', $payment_methods),
    'chargetotal' => commerce_currency_amount_to_decimal($amount, $currency),
    'currency' => $currency_code,
    'oid' => $order->order_id . '-' . time(),
    // Optional fields.
    'paymentMethod' => !empty($form_state['values']['card_type']) ? $api->commerceFirstdataConnectCardMode($form_state['values']['card_type']) : '',
    'customerid' => $order->uid,
    'invoicenumber' => $order->order_number,
    'comments' => 'commerce_firstdata_connect',
    'responseSuccessURL' => $base_root . '/firstdata_connect/hosted/callback',
    'responseFailURL' => $base_root . '/firstdata_connect/hosted/callback',
    'language' => $api->language,
    'trxOrigin' => 'ECI',
    'transactionNotificationURL' => $base_root . '/firstdata_connect/hosted/callback',
  );

  if (!empty($form_state['values']['hosteddataid'])) {
    $billing_data['hosteddataid'] = $form_state['values']['hosteddataid'];
  }

  if (!empty($mobile_mode) and $mobile_mode == TRUE) {
    $billing_data['mobileMode'] = 'true';
  }

  ksort($billing_data);
  // Build the Ogone redirection URL.
  if ($payment_methods['settings']['url'] == 'test') {
    $url = 'https://test.ipg-online.com/connect/gateway/processing';
  }
  else {
    $url = 'https://www.ipg-online.com/connect/gateway/processing';
  }
  $form['#action'] = $url;

  foreach ($billing_data as $name => $value) {
    if (!empty($value)) {
      $value = trim($value);
      // Build the SHA string from all filled in parameters
      // Add the value as a hidden form element.
      $form[$name] = array('#type' => 'hidden', '#value' => $value);
    }
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Proceed with payment'),
  );

  return $form;
}

/**
 * Returns the default timezone in drupal.
 */
function commerce_firstdata_connect_get_default_time_zone() {
  $time_zone = variable_get('date_default_timezone');
  foreach (timezone_abbreviations_list() as $key => $value) {
    if (strlen($key) > 1) {
      foreach ($value as $v) {
        if ($v['timezone_id'] == $time_zone) {
          $timezone_abriviation = strtoupper($key);
        }
      }
    }
  }
  return $timezone_abriviation;
}
