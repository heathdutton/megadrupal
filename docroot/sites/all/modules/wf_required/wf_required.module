<?php

/**
 * @file
 * Workflow required module.
 *
 * Allow required fields to be empty for selected workflow states.
 */

/**
 * Implements hook_workflow().
 *
 * React on workflow state transitions outside node edit context, validate node
 * and halt transition if validation fails.
 */
function wf_required_workflow($op, $id, $new_sid, $entity, $force, $entity_type = '', $field_name = '', $transition = NULL, $user = NULL) {
  if ($op == 'transition pre') {
    if ($force || $entity_type != 'node') {
      return;
    }
    // A word about context. Workflow transitions can be executed from several
    // points: Node edit form, workflow tab, node view, comment form. But we
    // don't have to worry much about this here. If the workflow was changed to
    // some state that doesn't ignore the required fields, it's catched by
    // hook_node_form_alter(). But we do have to check whether we are in a node
    // edit context or not. If we are and validation didn't fail there is
    // nothing left to do here. Otherwise we're attacking state change from
    // elsewhere and we have to perform an node form validation and see what
    // comes out.
    if (wf_required_node_edit()) {
      return;
    }
    $workflow = $transition->getWorkflow();
    $ignored = variable_get('wf_required_ignored__' . $workflow->wid, array());
    if ($ignored[$id] && !$ignored[$new_sid]) {
      module_load_include('inc', 'node', 'node.pages');
      module_load_include('inc', 'wf_required', 'wf_required.form');
      $form = wf_required_validate_form($entity->type . '_node_form', $entity);
      if ($errors = form_get_errors()) {
        $new_state = $transition->getNewState()->label();
        drupal_set_message(t("State transition to %state failed due to some required fields being empty. Please fix errors before continuing.", array('%state' => $new_state)), 'warning');
        wf_required_map_errors($errors, $entity);
        return FALSE;
      }
    }
  }
}

/**
 * Add direct link to for errors.
 */
function wf_required_map_errors($errors, $entity) {
  foreach ($errors as $ekey => $message) {
    // First remove the old existing message, if found.
    $found = array_search($message, $_SESSION['messages']['error']);
    if ($found !== FALSE) {
      unset($_SESSION['messages']['error'][$found]);
    }

    // Find the element name (most likely field name) and add a link to the
    // entity form with edit-$element as fragment.
    $parents = explode('][', $ekey);
    $element_name = reset($parents);
    $fragment = 'edit-' . strtr($element_name, '_', '-');
    $message .= " [" . l(t("Edit"), "node/{$entity->nid}/edit", array('fragment' => $fragment)) . "]";
    drupal_set_message($message, 'error');
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for workflow_admin_ui_states_form().
 *
 * Add an additional 'Ignore required' setting for each state.
 */
function wf_required_form_workflow_admin_ui_states_form_alter(&$form, &$form_state, $form_id) {
  $workflow = $form['workflow']['#value'];
  $states = $workflow->getStates(TRUE);
  $ignored = variable_get('wf_required_ignored__' . $workflow->wid, array());
  $state_ids = array();
  foreach ($states as $state) {
    $form['states'][$state->sid]['required'] = array(
      '#type' => 'checkbox',
      '#default_value' => empty($ignored[$state->sid]) ? 0 : $ignored[$state->sid],
    );
    $state_ids[] = $state->sid;
  }
  $form['#submit'][] = 'wf_required_form_workflow_admin_ui_states_form_submit';
  $form['wf_required_desc'] = array(
    '#markup' => t("*) By enabling 'Ignore required', any required form element of the node form in this workflow state will ignored, and the node will be saved with empty values. This is useful for 'draft', 'staging' or otherwise unfinished state."),
  );

  // This form is themed as a table in workflow_admin_ui.module, leaving us
  // without options to alter the rendered table server side, so we have to move
  // the checkboxes in a separate column using javascript.
  drupal_add_js(array('wf_required' => array('states' => $state_ids)), 'setting');
  $form['#attached']['js'][] = drupal_get_path('module', 'wf_required') . '/wf_required.states.js';
}

/**
 * Submit handler for workflow_admin_ui_states_form().
 */
function wf_required_form_workflow_admin_ui_states_form_submit($form, $form_state) {
  $workflow = $form_state['values']['workflow'];

  $ignored = array();
  foreach ($form_state['values']['states'] as $sid => $values) {
    if (!$sid) {
      continue;
    }
    $ignored[$sid] = $values['required'];
  }
  variable_set('wf_required_ignored__' . $workflow->wid, $ignored);
}

/**
 * Helper function to retrieve current workflow state from node submission.
 *
 * We cannot use workflow_node_current_state() as this looks up the state from
 * db.  In case the user has changed it during this edit we have to scan the
 * $form_state table.
 */
function _wf_required_current_workflow_state($form_state) {
  $node = $form_state['node'];
  $wf_field_name = '';
  $sid = NULL;
  if (module_exists('workflowfield')) {
    // Find first matching field name.
    $fields = field_info_instances('node', $node->type);
    foreach ($fields as $instance) {
      $field = field_info_field($instance['field_name']);
      if ($field['type'] === 'workflow') {
        $wf_field_name = $instance['field_name'];
        break;
      }
    }
    if (!$wf_field_name) {
      return NULL;
    }
    if (empty($form_state['values'][$wf_field_name])) {
      return workflow_node_current_state($node);
    }
    $state_value = $form_state['values'][$wf_field_name][LANGUAGE_NONE][0];
    if (empty($node->nid)) {
      $sid = _workflow_get_workflow_creation_sid('node', $node, $wf_field_name);
    }
    else {
      $sid = isset($state_value['workflow']['workflow_sid'])
        ? $state_value['workflow']['workflow_sid']
        : $state_value['value'];
    }
  }
  else {
    // @todo: Support workflownode.module.
    return NULL;
  }
  return $sid;
}

/**
 * Implements hook_node_form_alter().
 */
function wf_required_form_node_form_alter(&$form, $form_state) {
  $form['#after_build'][] = 'wf_required_node_form_after_build';
  // Once processing is complete, we re-attach the '#required' attribute for
  // theming purposes.
  $form['#pre_render'][] = 'wf_required_node_form_pre_render';
}

/**
 * Node form after build callback.
 */
function wf_required_node_form_after_build(&$form, $form_state) {
  // No need to change unless it was submitted.
  if (!$form_state['process_input']) {
    return $form;
  }
  // Node is validated outside node edit context. Eject!
  if (!empty($form_state['wf_required_validate'])) {
    return $form;
  }
  $sid = _wf_required_current_workflow_state($form_state);
  if (!$sid) {
    return $form;
  }
  // Luckily node form building is done before hook_workflow($op = 'transition
  // pre'), so we can tell that the transition is handled by us.
  wf_required_node_edit(TRUE);
  $workflow = WorkflowState::load($sid);
  $ignored = variable_get('wf_required_ignored__' . $workflow->wid);
  if (empty($ignored[$sid])) {
    return $form;
  }
  _wf_required_disable_required_fields($form);

  return $form;
}

/**
 * Recursively turn off all #required == TRUE.
 */
function _wf_required_disable_required_fields(&$element) {
  $types = array(
    'actions', 'button', 'checkbox', 'checkboxes', 'container', 'date',
    'date_combo', 'date_popup', 'fieldset', 'file', 'form', 'image_button',
    'managed_file', 'password', 'radio', 'radios', 'select', 'submit',
    'tableselect', 'textarea', 'text_format', 'textfield', 'weight',
  );
  $types = drupal_map_assoc($types);

  if (isset($element['#required']) and $element['#required']) {
    if (isset($element['#type']) and isset($types[$element['#type']])) {
      $element['#required'] = FALSE;
      $element['#required_visual'] = TRUE;
      $element['#attributes']['class'][] = 'required';
    }
  }
  foreach (element_children($element) as $key) {
    if (is_array($element[$key])) {
      _wf_required_disable_required_fields($element[$key]);
    }
  }
}

/**
 * Callback: #pre_render in node form.
 *
 * Re-insert the #required marker on node form for the sake of visual feedback.
 */
function wf_required_node_form_pre_render($form) {
  _wf_required_readd_required_marker($form);
  return $form;
}

/**
 * Recurcively re-add the '#required' attribute.
 */
function _wf_required_readd_required_marker(&$element) {
  if (!empty($element['#required_visual'])) {
    $element['#required'] = TRUE;
  }
  foreach (element_children($element) as $key) {
    if (is_array($element[$key])) {
      _wf_required_readd_required_marker($element[$key]);
    }
  }
}

/**
 * State transition set during node edit.
 *
 * @param bool $set_node_edit
 *   Set state transition during node edit context.
 *
 * @return bool
 *   TRUE if set during node edit.
 */
function wf_required_node_edit($set_node_edit = FALSE) {
  static $node_edit = FALSE;

  if ($set_node_edit) {
    $node_edit = TRUE;
  }
  return $node_edit;
}
