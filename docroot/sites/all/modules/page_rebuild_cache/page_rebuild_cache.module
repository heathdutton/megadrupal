<?php
/**
 * @file
 * Easing the pain when you need to flush...Drupal's cache.
 */

$page_rebuild_cache = array();

/**
 * Implements hook_permission().
 */
function page_rebuild_cache_permission() {
  return array(
    'page rebuild cache' => array(
      'title' => t('Rebuild Page Cache'),
      'description' => t("Allow users to rebuild a page's cached objects"),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function page_rebuild_cache_menu() {
  $items = array();

  // Admin settings
  $items['admin/page_rebuild_cache_trigger'] = array(
    'title' => 'Rebuild page cache',
    'page callback' => 'page_rebuild_cache_trigger',
    'access arguments' => array('page rebuild cache'),
  );
  
  return $items;
}

function page_rebuild_cache_trigger() {
  if (empty($_SERVER['HTTP_REFERER'])) {
    drupal_set_message('Please access this page by using admin-menu. You can trigger a rebuild manually on a page by appending "?rebuild-cache=true"', 'error');
    return FALSE;
  }
  
  // Get the referer, and return the user to the URL they came from, but append rebuild-cache=true
  $referer = parse_url($_SERVER['HTTP_REFERER']);
  if(isset($referer['query'])){
    parse_url($referer['query'], $query = array());
  }
  $query['rebuild-cache'] = 1;
  $referer['query'] = http_build_query($query);
  
  $url = $referer['scheme'] . '://' . $referer['host'] . $referer['path'] . '?' . $referer['query'];
  
  header('Location: ' . $url);
  drupal_exit();
}

/**
 * Implements hook_admin_menu_output_alter().
 */
function page_rebuild_cache_admin_menu_output_alter(&$content) {
  // Add flush page cache item to icon menu item.  
  $content['icon']['icon']['page-rebuild-cache'] = array(
    '#title' => t("Rebuild this page's cache"),
    '#href' => 'admin/page_rebuild_cache_trigger',
    '#access' => user_access('page rebuild cache'), 
  );
}

/**
 * Implements hook_init().
 *
 * Ideally we should be flushing the page's cache via hook_boot() but
 * user_access() isn't available until hook_init().
 */
function page_rebuild_cache_init() {
  global $conf;
  global $page_rebuild_cache;
  if (!empty($_GET['rebuild-cache']) && user_access('page rebuild cache')) {
    
    unset($_GET['rebuild-cache']);
    
    $page_rebuild_cache['cache_default_class'] = !empty($conf['cache_default_class']) ? $conf['cache_default_class'] : 'DrupalDatabaseCache';
    $conf['cache_default_class'] = 'PageRebuildCache';
    
    // Varnish
    if (module_exists('varnish')) {
      varnish_expire_cache(array(page_rebuild_cache_get_url()));
    }
    
    // Drupal page cache
    if (variable_get('cache', 0)) {
      cache_clear_all(page_rebuild_cache_get_url(), 'cache_page');
    }
    
    drupal_set_message(t('Successfully rebuilt cache on this page'));
  }
}

/**
 * Get the full URL for the current page without ?rebuild_cache=1 query param.
 */
function page_rebuild_cache_get_url() {
  $get = $_GET;
  unset($get['q']);
  $url = (isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] == 'on') ? 'https' : 'http';
  $url .= '://'. $_SERVER['HTTP_HOST'] . request_uri(TRUE);
  
  if (!empty($get)) {
    $url .= '&' . http_build_query($get);
  }
}

// Esentially we are highjacking the cache class and forcing the 'get' and 'getMultiple' methods
// to return false, while everything else remains the same.
class PageRebuildCache implements DrupalCacheInterface {
  
  private $cache_object;
  
  /**
   * Constructs a new cache interface.
   *
   * @param $bin
   *   The cache bin for which the object is created.
   */
  function __construct($bin) {
    global $page_rebuild_cache;
    
    // Get the actual default backend class stored in the $page_rebuild_cache global object.
    // We instantiate it and use it for set, cache_clear and all other "non-get" methods.
    // Esentially we are highjacking the cache class and forcing the 'get' and 'getMultiple' methods
    // to return false, while everything else remains the same.
    $default_class = $page_rebuild_cache['cache_default_class'];
    $this->cache_object = new $default_class($bin);
  }

  /**
   * Returns data from the persistent cache.
   *
   * Data may be stored as either plain text or as serialized data. cache_get()
   * will automatically return unserialized objects and arrays.
   *
   * @param $cid
   *   The cache ID of the data to retrieve.
   *
   * @return
   *   Always return FALSE. This forces the cached item to be rebuilt
   */
  function get($cid) {
    return FALSE;
  }

  /**
   * Returns data from the persistent cache when given an array of cache IDs.
   *
   * @param $cids
   *   An array of cache IDs for the data to retrieve. This is passed by
   *   reference, and normally would have the IDs successfully returned from cache
   *   removed. We don't remove any cache-ids, marking them all to be rebuilt.
   *
   * @return
   *   An array of the items successfully returned from cache indexed by cid. 
   *   We always return an empty array to force a rebuid.
   */
  function getMultiple(&$cids) {
    return array();
  }

  /**
   * Stores data in the persistent cache.
   *
   * Just pass this through to the underlying cache backend
   */
  function set($cid, $data, $expire = CACHE_PERMANENT) {
    return $this->cache_object->set($cid, $data, $expire);
  }

  /**
   * Expires data from the cache.
   *
   * Just pass this through to the underlying cache backend
   */
  function clear($cid = NULL, $wildcard = FALSE) {
    return $this->cache_object->clear($cid = NULL, $wildcard);
  }

  /**
   * Checks if a cache bin is empty.
   *
   * Just pass this through to the underlying cache backend
   */
  function isEmpty() {
    return $this->cache_object->isEmpty();
  }
}
