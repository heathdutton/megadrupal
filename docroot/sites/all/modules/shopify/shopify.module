<?php
/**
 * @file
 * Main module file containing hooks and functions.
 */

// Load include files.
module_load_include('inc', 'shopify', 'includes/shopify.api');
module_load_include('inc', 'shopify', 'includes/shopify.webhooks');
module_load_include('inc', 'shopify', 'includes/shopify.search');
module_load_include('inc', 'shopify', 'includes/shopify.metatag');
module_load_include('inc', 'shopify', 'includes/shopify.path');
module_load_include('inc', 'shopify', 'includes/shopify.rules');

/**
 * Implements hook_taxonomy_term_view().
 */
function shopify_taxonomy_term_view($term, $view_mode, $langcode) {
  if ($view_mode !== 'full') {
    return;
  }
  switch ($term->vocabulary_machine_name) {
    case 'shopify_collections':
      $uri = entity_uri('taxonomy_term', $term);
      drupal_goto($uri['path']);
      break;
    case 'shopify_tags':
      $uri = entity_uri('taxonomy_term', $term);
      drupal_goto($uri['path']);
      break;
  }
}

/**
 * Implements hook_views_api().
 */
function shopify_views_api() {
  return array(
    'api' => '3.0',
    'path' => drupal_get_path('module', 'shopify') . '/views'
  );
}

/**
 * Implements hook_views_default_views().
 *
 * Imports views from the /views directory.
 */
function shopify_views_default_views() {
  $path = __DIR__ . '/views/*.view.inc';
  $views = array();
  foreach (glob($path) as $views_filename) {
    $view = FALSE;
    require_once($views_filename);
    $views[$view->name] = $view; // $view exists in the included file.
    unset($view);
  }
  return $views;
}

/**
 * Implements hook_permission().
 */
function shopify_permission() {
  return array(
    'administer shopify' => array(
      'title' => t('Administer Shopify'),
      'description' => t('Full admin control over the Shopify store. Overrides all Shopify permissions.'),
      'restrict access' => TRUE,
    ),
    'administer shopify webhooks' => array(
      'title' => t('Administer Shopify webhooks'),
      'description' => t('Create and remove webhooks from Shopify.'),
      'restrict access' => TRUE,
    ),
    'sync shopify content' => array(
      'title' => t('Sync Shopify content'),
      'description' => t('Sync products and collections to the site.'),
    ),
    'edit shopify products' => array(
      'title' => t('Edit Shopify products'),
      'description' => t('Edit Shopify product fields, metadata, paths, etc.'),
    ),
    'view shopify products' => array(
      'title' => t('View Shopify products'),
      'description' => t('View Shopify products.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function shopify_menu() {

  // Create nice shortcut links for shopify admin pages.
  $store_url = 'https://' . shopify_store_info()->myshopify_domain;
  $items['admin/shopify/store'] = array(
    'title' => 'Admin',
    'page callback' => 'drupal_goto',
    'page arguments' => array($store_url . '/admin'),
    'access callback' => 'shopify_user_access',
    'access arguments' => array('administer shopify'),
    'options' => array('attributes' => array('target' => '_blank')),
    'weight' => -999,
  );
  $items['admin/shopify/store/settings'] = array(
    'title' => 'Settings',
    'page callback' => 'drupal_goto',
    'page arguments' => array($store_url . '/admin/settings/general'),
    'access callback' => 'shopify_user_access',
    'access arguments' => array('administer shopify'),
    'options' => array('attributes' => array('target' => '_blank')),
  );
  $items['admin/shopify/store/products'] = array(
    'title' => 'Products',
    'page callback' => 'drupal_goto',
    'page arguments' => array($store_url . '/admin/products'),
    'access callback' => 'shopify_user_access',
    'access arguments' => array('administer shopify'),
    'options' => array('attributes' => array('target' => '_blank')),
  );
  $items['admin/shopify/store/collections'] = array(
    'title' => 'Collections',
    'page callback' => 'drupal_goto',
    'page arguments' => array($store_url . '/admin/collections'),
    'access callback' => 'shopify_user_access',
    'access arguments' => array('administer shopify'),
    'options' => array('attributes' => array('target' => '_blank')),
  );
  $items['admin/shopify/store/gift_cards'] = array(
    'title' => 'Gift Cards',
    'page callback' => 'drupal_goto',
    'page arguments' => array($store_url . '/admin/gift_cards'),
    'access callback' => 'shopify_user_access',
    'access arguments' => array('administer shopify'),
    'options' => array('attributes' => array('target' => '_blank')),
  );
  $items['admin/shopify/store/orders'] = array(
    'title' => 'Orders',
    'page callback' => 'drupal_goto',
    'page arguments' => array($store_url . '/admin/orders'),
    'access callback' => 'shopify_user_access',
    'access arguments' => array('administer shopify'),
    'options' => array('attributes' => array('target' => '_blank')),
  );
  $items['admin/shopify/store/customers'] = array(
    'title' => 'Customers',
    'page callback' => 'drupal_goto',
    'page arguments' => array($store_url . '/admin/customers'),
    'access callback' => 'shopify_user_access',
    'access arguments' => array('administer shopify'),
    'options' => array('attributes' => array('target' => '_blank')),
  );
  $items['admin/shopify/store/reports'] = array(
    'title' => 'Reports',
    'page callback' => 'drupal_goto',
    'page arguments' => array($store_url . '/admin/reports'),
    'access callback' => 'shopify_user_access',
    'access arguments' => array('administer shopify'),
    'options' => array('attributes' => array('target' => '_blank')),
  );
  $items['admin/shopify/store/discounts'] = array(
    'title' => 'Discounts',
    'page callback' => 'drupal_goto',
    'page arguments' => array($store_url . '/admin/discounts'),
    'access callback' => 'shopify_user_access',
    'access arguments' => array('administer shopify'),
    'options' => array('attributes' => array('target' => '_blank')),
  );
  $items['admin/shopify/store/apps'] = array(
    'title' => 'Apps',
    'page callback' => 'drupal_goto',
    'page arguments' => array($store_url . '/admin/apps'),
    'access callback' => 'shopify_user_access',
    'access arguments' => array('administer shopify'),
    'options' => array('attributes' => array('target' => '_blank')),
  );
  $items['admin/shopify/store/configure'] = array(
    'title' => 'Configure',
    'page callback' => 'drupal_goto',
    'page arguments' => array($store_url . '/admin/dashboard/online'),
    'access callback' => 'shopify_user_access',
    'access arguments' => array('administer shopify'),
    'options' => array('attributes' => array('target' => '_blank')),
  );

  $items['product/%shopify_product'] = array(
    'page callback' => 'entity_ui_entity_page_view',
    'page arguments' => array(1),
    'load arguments' => array('shopify_product'),
    'access callback' => 'entity_access',
    'access arguments' => array('view', 'shopify_product', 1),
    'title callback' => 'shopify_product_title',
    'title arguments' => array(1),
  );

  // Add "View" tab on Product page
  $items['product/%shopify_product/view'] = array(
    'title' => 'View',
    'page callback' => 'entity_ui_entity_page_view',
    'page arguments' => array(1),
    'load arguments' => array('shopify_product'),
    'access callback' => 'entity_access',
    'access arguments' => array('view', 'shopify_product', 1),
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  // Add "Edit" tab on Product page
  $items['product/%shopify_product/edit'] = array(
    'page callback' => 'shopify_redirect_to_edit',
    'page arguments' => array(1),
    'load arguments' => array('shopify_product'),
    'access callback' => 'entity_access',
    'access arguments' => array('update', 'shopify_product', 1),
    'title' => 'Edit',
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
  );

  // Add "View" tab to edit form
  $items['admin/shopify/products/manage/%shopify_product/view'] = array(
    'page callback' => 'shopify_redirect_to_view',
    'page arguments' => array(4),
    'load arguments' => array('shopify_product'),
    'access callback' => 'entity_access',
    'access arguments' => array('view', 'shopify_product', 4),
    'title' => 'View',
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
  );

  $items['admin/shopify'] = array(
    'page callback' => 'shopify_admin_page',
    'title' => 'Shopify',
    'access callback' => 'shopify_user_access',
    'access arguments' => array('administer shopify'),
    'file' => 'includes/shopify.admin.inc',
  );

  $items['admin/shopify/overview'] = array(
    'title' => 'Overview',
    'description' => 'View general information about your Shopify store.',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/shopify/sync'] = array(
    'title' => 'Sync',
    'description' => 'Sync Shopify store information to the website.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('shopify_admin_sync_form'),
    'access callback' => 'shopify_user_access',
    'access arguments' => array('sync shopify content'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'includes/shopify.admin.inc',
  );
  $items['admin/shopify/sync/delete-orphaned-tags'] = array(
    'title' => 'Delete orphaned tags',
    'description' => 'Deletes shopify product tag taxonomy terms from the system.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('shopify_admin_delete_orphaned_tags_form'),
    'access callback' => 'shopify_user_access',
    'access arguments' => array('administer shopify'),
    'type' => MENU_CALLBACK,
    'file' => 'includes/shopify.admin.inc',
  );
  $items['admin/shopify/theme'] = array(
    'title' => 'Theme',
    'description' => 'Download a default Shopify Theme for your Shopify store.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('shopify_admin_theme_download'),
    'access callback' => 'shopify_user_access',
    'access arguments' => array('administer shopify'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'includes/shopify.admin.inc',
  );
  $items['admin/shopify/theme/download'] = array(
    'page callback' => 'shopify_download_theme',
    'access callback' => 'shopify_user_access',
    'access arguments' => array('administer shopify'),
    'type' => MENU_CALLBACK,
    'file' => 'includes/shopify.admin.inc',
  );

  $items['admin/shopify/webhooks'] = array(
    'title' => 'Webhooks',
    'description' => 'Manage Shopify Webhooks',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('shopify_webhooks_admin'),
    'access callback' => 'shopify_user_access',
    'access arguments' => array('administer shopify webhooks'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'includes/shopify.admin.inc',
  );

  $items['shopify/redirect'] = array(
    'page callback' => 'shopify_redirect',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['shopify/theme/download/%/%/%'] = array(
    'page callback' => 'shopify_theme_download',
    'page arguments' => array(5),
    'access callback' => 'shopify_theme_download_access',
    'access arguments' => array(3, 4, 5),
    'type' => MENU_CALLBACK,
  );

  $items['shopify/added-to-cart'] = array(
    'page callback' => 'shopify_added_to_cart',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['shopify/webhook'] = array(
    'page callback' => 'shopify_incoming_webhook',
    'access callback' => 'shopify_webhook_access',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Gets tags from the system that are not associated with any products.
 */
function shopify_get_orphaned_tags() {
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'taxonomy_term')
    ->entityCondition('bundle', 'shopify_tags')
    ->execute();
  $orphaned_terms = array();
  if ($result && isset($result['taxonomy_term']) && $result['taxonomy_term']) {
    $terms = taxonomy_term_load_multiple(array_keys($result['taxonomy_term']));
    // For each term, check if it has products associated with it.
    foreach ($terms as $tid => $term) {
      $query = new EntityFieldQuery();
      $count = $query->entityCondition('entity_type', 'shopify_product')
        ->fieldCondition('shopify_product_tags', 'tid', $tid)
        ->execute();
      if (!$count || !isset($count['shopify_product']) || !count($count['shopify_product'])) {
        $orphaned_terms[] = $term;
      }
    }
  }
  return $orphaned_terms;
}

/**
 * Menu callback for downloading the Shopify theme .zip file.
 *
 * @param string $filename
 *   Name of the file.
 */
function shopify_theme_download($filename) {
  $filepath = file_directory_temp() . '/' . $filename;
  // Reset any previous headers.
  header("Pragma: public");
  header("Expires: 0");
  header("Cache-Control: must-revalidate, post-check=0, pre-check=0");
  header("Cache-Control: public");
  header("Content-Description: File Transfer");
  header("Content-type: application/octet-stream");
  header("Content-Disposition: attachment; filename=\"$filename\"");
  header("Content-Transfer-Encoding: binary");
  header("Content-Length: " . filesize($filepath));
  @readfile($filepath);
  ob_end_flush();
}

/**
 * Menu access callback for downloading the Shopify theme .zip file.
 *
 * @param int $timestamp
 *   Unix timestamp.
 * @param string $sig
 *   Secure signature that ensures the file can only be downloaded by Shopify.
 * @param string $filename
 *   Name of the file.
 *
 * @return boolean
 *   Returns TRUE if the user can access the callback.
 */
function shopify_theme_download_access($timestamp, $sig, $filename) {
  $compare = hash_hmac('sha256', $timestamp . 'default_shopify_theme.zip', variable_get('shopify_api_secret'));
  if ($compare !== $sig) {
    // Someone doesn't have the right sig here.
    return FALSE;
  }
  if (REQUEST_TIME > $timestamp + 500) {
    // The link has expired.
    return FALSE;
  }
  return TRUE;
}

/**
 * Implements hook_cron().
 */
function shopify_cron() {
  // Check last cron run time vs. the cron speed setting.
  if (variable_get('cron_last') + variable_get('shopify_cron_sync_time', 0) > REQUEST_TIME) {
    // No need to sync yet.
    return FALSE;
  }
  if (variable_get('shopify_cron_sync_products')) {
    // Sync products.
    shopify_sync_products(array(
      'updated_at_min' => variable_get('shopify_last_product_sync'),
      'limit' => 250,
    ));
  }
  if (variable_get('shopify_cron_sync_collections')) {
    // Sync collections.
    shopify_sync_collections(array(
      'updated_at_min' => variable_get('shopify_last_collection_sync'),
      'limit' => 250,
    ));
  }
}

/**
 * Sync Shopify products to the site.
 *
 * @param array $options
 *   Array of options to pass the API call.
 */
function shopify_sync_products(array $options = array()) {
  $products = shopify_api_get_products($options);
  foreach ($products as $product) {
    $shopify_product = shopify_product_update($product['id'], 0, $product);
    $shopify_product->save();
    foreach ($product['variants'] as $v) {
      $variant = shopify_product_update($product['id'], $v['id'], $v);
      $variant->save();
    }
  }
  shopify_sync_deleted_products(array('limit' => 250));
}

/**
 * Sync Shopify collections to the site.
 *
 * @param array $options
 *   Array of options to pass the API call.
 */
function shopify_sync_collections(array $options = array()) {
  $collections = shopify_api_get_collections($options);
  foreach ($collections as $collection) {
    $term = shopify_collection_load($collection['id']);
    if (!$term) {
      // Need to create a new collection.
      shopify_collection_create($collection, TRUE);
    }
    else {
      shopify_collection_update($collection, TRUE);
    }
  }
  shopify_sync_deleted_collections(array('limit' => 250));
}

/**
 * Sync deleted collections with the site.
 *
 * @param array $options
 *   Array of options to pass the API.
 *
 * @return int
 *   Returns the number of deleted collections.
 */
function shopify_sync_deleted_collections(array $options = array()) {
  $collections_count = shopify_api_get_collection_count($options);
  $collections = array();
  if (!isset($options['limit'])) {
    $options['limit'] = 250;
  }
  for ($page = 1; $page <= ceil($collections_count / $options['limit']); $page++) {

    // Setup default options for the products API call.
    $options['page'] = $page;
    $options['fields'] = 'id';

    // Build a list of all products in the Shopify system.
    $collections = array_merge($collections, shopify_api_get_collections($options));
  }

  // Format result set as an array of product and variant IDs.
  $collection_ids = array();
  array_walk_recursive($collections, function ($c) use (&$collection_ids) {
    $collection_ids[] = $c;
  });

  $count = 0;

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'taxonomy_term');
  $query->propertyCondition('vid', shopify_collection_vocabulary()->vid);
  if ($collection_ids) {
    $query->fieldCondition('shopify_collection_id', 'value', $collection_ids, 'NOT IN');
  }
  $result = $query->execute();

  if (isset($result['taxonomy_term'])) {
    entity_delete_multiple('taxonomy_term', array_keys($result['taxonomy_term']));
    $count = count($result['taxonomy_term']);
  }

  return $count;
}

/**
 * Sync deleted products/variants with the site.
 *
 * @param array $options
 *   Array of options to pass the API.
 *
 * @return int
 *   Returns the number of deleted products/variants.
 */
function shopify_sync_deleted_products(array $options = array()) {
  $product_count = shopify_api_get_product_count();
  $products = $variants = array();
  if (!isset($options['limit'])) {
    $options['limit'] = 250;
  }
  $variant_ids = $product_ids = array();

  for ($page = 1; $page <= ceil($product_count / $options['limit']); $page++) {

    // Setup default options for the products API call.
    $options['page'] = $page;
    $options['fields'] = 'id,variants';

    // Build a list of all products in the Shopify system.
    $products = shopify_api_get_products($options);

    // Merge all variants for these products.
    foreach ($products as $p) {
      $product_ids[] = $p['id'];
      foreach ($p['variants'] as $v) {
        $variant_ids[] = $v['id'];
      }
    }
  }

  // Free up memory.
  unset($products);

  // Safety check in case the product/variants counts failed.
  if ($product_count !== count($product_ids)) {
    return 0;
  }

  // Delete products in the DB that we did not pull back.
  $deleted_products = db_delete('shopify_products')
    ->condition('product_id', $product_ids, 'NOT IN')
    ->condition('variant_id', 0)// Only delete products that are not a variant.
    ->execute();
  $deleted_variants = db_delete('shopify_products')
    ->condition('variant_id', $variant_ids, 'NOT IN')
    ->condition('variant_id', 0, '!=')// Only delete variants.
    ->execute();

  // Return total count of deleted items.
  return $deleted_variants + $deleted_products;
}

/**
 * Menu access callback that puts 'administer shopify' permission first.
 */
function shopify_user_access($string, $account = NULL) {
  if (user_access('administer shopify', $account) || user_access($string, $account)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Checks to ensure that this incoming webhook is indeed from Shopify.
 *
 * @link https://docs.shopify.com/api/webhooks/using-webhooks#verify-webhook Documentation @endlink
 */
function shopify_webhook_access() {
  if (!isset($_SERVER['HTTP_X_SHOPIFY_HMAC_SHA256'])) {
    // Header is required.
    return FALSE;
  }
  $data = file_get_contents('php://input');
  // Compare their hmac to our own that we calculate.
  return $_SERVER['HTTP_X_SHOPIFY_HMAC_SHA256'] === base64_encode(hash_hmac('sha256', $data, variable_get('shopify_api_secret'), TRUE));
}

/**
 * Implements hook_menu_alter().
 */
function shopify_menu_alter(&$items) {
  // Do not allow any user to delete products.
  $items['admin/shopify/products/manage/%shopify_product/delete']['access callback'] = FALSE;

  // Modify the products page display title and as a tab.
  $items['admin/shopify/products']['title'] = 'Products';
  $items['admin/shopify/products']['type'] = MENU_LOCAL_TASK;
  $items['admin/shopify/products']['weight'] = -5;

  // Products are added on Shopify, not in Drupal.
  $items['admin/shopify/products/add']['page callback'] = 'drupal_goto';
  $items['admin/shopify/products/add']['page arguments'] = array('https://' . shopify_store_info()->myshopify_domain . '/admin/products/new');
  $items['admin/shopify/products/add']['options'] = array('attributes' => array('target' => '_blank'));
}

/**
 * Redirect a URL to a product page based on query params.
 */
function shopify_redirect() {
  $params = drupal_get_query_parameters();
  if (isset($params['variant_id'])) {
    // Check that we have this product.
    if ($product = shopify_variant_load_single($params['variant_id'])) {
      if ($parent = shopify_product_load_single($product->product_id, 0)) {
        // Send the user to the product page.
        $uri = entity_uri('shopify_product', $parent);
        drupal_goto($uri['path'], array('query' => array('variant_id' => $params['variant_id'])));
      }
    }
  }
  elseif (isset($params['product_id'])) {
    if ($product = shopify_product_load_single($params['product_id'], 0)) {
      // Send the user to the product page.
      $uri = entity_uri('shopify_product', $product);
      drupal_goto($uri['path'], array('query' => array('variant_id' => $params['variant_id'])));
    }
  }
  elseif (isset($params['collection_id'])) {
    if ($collection = shopify_collection_load($params['collection_id'])) {
      drupal_goto('products/collections/' . $collection->tid);
    }
  }
  // Missing or bad data, can't find the right product/variant.
  drupal_not_found();
}

/**
 * Redirect to product edit page.
 *
 * @param ShopifyProduct $product
 *   Shopify product entity.
 */
function shopify_redirect_to_edit(ShopifyProduct $product) {
  $path = "admin/shopify/products/manage/{$product->id}/edit";
  drupal_goto($path);
}

/**
 * Redirect to product view page.
 *
 * @param ShopifyProduct $product
 *   Shopify product entity.
 */
function shopify_redirect_to_view(ShopifyProduct $product) {
  $uri = entity_uri('shopify_product', $product);
  drupal_goto($uri['path']);
}

/**
 * Get the product label.
 *
 * @param ShopifyProduct $product
 *   Shopify product entity.
 *
 * @return string
 *   Shopify product title.
 */
function shopify_product_title(ShopifyProduct $product) {
  return $product->label();
}

/**
 * Get the path to the store from the view.
 */
function shopify_store_path() {
  $view = views_get_view('shopify_products');
  return $view->display['page_products']->display_options['path'];
}

/**
 * Add to cart callback.
 *
 * Displays an "Added to cart" message to the user.
 * Certain data must be POSTed to this callback:
 *  - product_id: The parent product ID.
 *  - variant_id: The specific variant ID.
 */
function shopify_added_to_cart() {
  $data = drupal_get_query_array(file_get_contents('php://input'));
  $parent = shopify_product_load_single($data['product_id'], 0);
  $product = shopify_product_load_single($data['product_id'], $data['variant_id']);
  $quantity = $data['quantity'];
  $title = $product->label() == 'Default Title' ? '' : '- ' . $product->label();
  drupal_set_message(t('@quantity x @parent @title (@price) added to !cart_link.', array(
    '@parent' => $parent->label(),
    '@title' => $title,
    '@price' => shopify_money_format() . $product->wrapper()->price->value(),
    '!cart_link' => l(t('your cart'), 'https://' . shopify_store_info()->myshopify_domain . '/cart'),
    '@quantity' => $quantity,
  )));
  print '';
}

/**
 * Update a Shopify collection with new information.
 *
 * @param array $collection
 *   Shopify collection.
 * @param boolean $sync_products
 *   Whether or not to sync product information during update.
 */
function shopify_collection_update($collection, $sync_products = FALSE) {
  $term = shopify_collection_load($collection['id']);
  if ($term) {
    $term->name = $collection['title'];
    $term->description = $collection['body_html'];
    $date = strtotime($collection['published_at']);
    $term->shopify_collection_published_at = array('und' => array(array('value' => $date ? $date : 0)));
  }
  if (taxonomy_term_save($term) && isset($collection['image']['src'])) {
    // Save the image for this term.
    shopify_collection_save_image($term, $collection['image']['src']);
  }
  // Sync product information for this collection.
  shopify_collection_sync_products($collection);
}

/**
 * Create a new collection in the system and sync products.
 *
 * @param array $collection
 *   Shopify collection.
 * @param boolean $sync_products
 *   Whether or not to sync product information during creation.
 */
function shopify_collection_create($collection, $sync_products = FALSE) {
  $vocab = shopify_collection_vocabulary();
  $date = strtotime($collection['published_at']);
  $term = entity_create('taxonomy_term', array(
    'vid' => $vocab->vid,
    'name' => $collection['title'],
    'description' => $collection['body_html'],
    'shopify_collection_id' => array('und' => array(array('value' => $collection['id']))),
    'shopify_collection_published_at' => array('und' => array(array('value' => $date ? $date : 0))),
  ));
  if (taxonomy_term_save($term) && isset($collection['image']['src'])) {
    // Save the image for this term.
    shopify_collection_save_image($term, $collection['image']['src']);
  }
  if ($sync_products) {
    // Sync product information for this collection.
    shopify_collection_sync_products($collection);
  }
}

/**
 * Saves an image for a Shopify collection.
 *
 * @param stdClass $term
 *   Taxonomy term entity.
 * @param string $image_url
 *   Remote image URL for the collection image.
 */
function shopify_collection_save_image(stdClass $term, $image_url) {
  $directory = file_build_uri('shopify_images');
  if (!file_prepare_directory($directory, FILE_CREATE_DIRECTORY)) {
    // If our directory doesn't exist and can't be created, use the default.
    $directory = NULL;
  }
  $file = system_retrieve_file($image_url, $directory, TRUE, FILE_EXISTS_REPLACE);
  $term = entity_metadata_wrapper('taxonomy_term', $term);
  $term->shopify_collection_image->set((array) $file);
  $term->save();
}

/**
 * Sync product collect information for a given collection.
 *
 * @param array $collection
 *   Shopify collection.
 */
function shopify_collection_sync_products($collection) {
  $term = shopify_collection_load($collection['id']);
  $collects = shopify_api_get_collects(array('collection_id' => $collection['id']));
  foreach ($collects as $c) {
    // Update this product information.
    $product = shopify_product_load_single($c['product_id']);
    if (!$product) {
      continue;
    }
    $collections = $product->wrapper()->shopify_product_collections->value();
    foreach ($collections as $collect) {
      if ($collect && ($collect->tid == $term->tid)) {
        // Product already in collection.
        // Check if this collection is active.
        if ($collect->shopify_collection_published_at['und'][0]['value'] == 0) {
          // Remove this collection from the product.
          $collections = array_filter($collections, function ($c) use ($collect) {
            return $c->tid !== $collect->tid;
          });
          $product->wrapper()->shopify_product_collections->set($collections);
          $product->wrapper()->save();
        }
        continue 2;
      }
    }
    $product->wrapper()->shopify_product_collections[] = $term->tid;
    $product->save();
  }
}

/**
 * Delete a collection based on the collection ID.
 *
 * @param int $collection_id
 *   Shopify collection ID.
 */
function shopify_collection_delete($collection_id) {
  $term = shopify_collection_load($collection_id);
  entity_delete_multiple('taxonomy_term', array($term->tid));
  // Delete collection field values with these tid values.
  db_delete('field_data_shopify_product_collections')
    ->condition('shopify_product_collections_tid', $term->tid)
    ->execute();
}

/**
 * Gets the Shopify collections vocabulary.
 */
function shopify_collection_vocabulary() {
  return taxonomy_vocabulary_machine_name_load('shopify_collections');
}

/**
 * Loads a collection.
 *
 * @param int $collection_id
 *   Shopify collection ID.
 *
 * @return stdClass
 *   Returns the taxonomy term collection.
 */
function shopify_collection_load($collection_id) {
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'taxonomy_term')
    ->fieldCondition('shopify_collection_id', 'value', $collection_id)
    ->execute();
  if ($result && isset($result['taxonomy_term'])) {
    $terms = entity_load('taxonomy_term', array_keys($result['taxonomy_term']));
    return reset($terms);
  }
  return NULL;
}

/**
 * Delete all Shopify Products.
 */
function shopify_delete_all_products() {
  $existing = db_query('SELECT s.id FROM {shopify_products} s');
  $ids = $existing->fetchCol();
  shopify_product_delete_multiple($ids);
}

/**
 * Delete all Shopify collections.
 */
function shopify_delete_all_collections() {
  $vocab = taxonomy_vocabulary_machine_name_load('shopify_collections');
  $tids = db_select('taxonomy_term_data', 'ttd')
    ->fields('ttd', array('tid'))
    ->condition('vid', $vocab->vid)
    ->execute()->fetchAllAssoc('tid');
  if ($tids) {
    entity_delete_multiple('taxonomy_term', array_keys($tids));

    // Delete collection field values with these tid values.
    db_delete('field_data_shopify_product_collections')
      ->condition('shopify_product_collections_tid', array_keys($tids), 'IN')
      ->execute();
  }
}

/**
 * Delete Shopify Products and Variants by Shopify Product ID.
 */
function shopify_delete_by_product_id($product_id) {
  $products = db_query('SELECT s.id FROM {shopify_products} s WHERE product_id = :product_id', array(':product_id' => $product_id));
  $ids = $products->fetchCol();
  shopify_product_delete_multiple($ids);
}

/**
 * Update a Shopify Product with new values or create a new one.
 *
 * @param int $product_id
 *   Shopify Product ID.
 * @param int $variant_id
 *   Shopify Variant ID.
 * @param array $new_values
 *   New values to apply to the Shopify Product.
 *
 * @return \ShopifyProduct
 *   Returns the newly created or modified Shopify Product.
 */
function shopify_product_update($product_id, $variant_id = 0, array $new_values = array()) {
  $shopify_product = shopify_product_load_single($product_id, $variant_id);
  if (!$shopify_product) {
    // Create a new product with those values.
    $shopify_product = new ShopifyProduct($new_values);
  }
  else {
    $shopify_product->__construct($new_values);
  }
  return $shopify_product;
}

/**
 * Load a single Shopify Product given a product and variant ID.
 *
 * @param int $product_id
 *   Shopify Product ID.
 * @param int $variant_id
 *   Shopify Variant ID.
 *
 * @return ShopifyProduct
 *   Returns the loaded Shopify Product entity.
 */
function shopify_product_load_single($product_id, $variant_id = 0) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'shopify_product')
    ->propertyCondition('product_id', $product_id)
    ->propertyCondition('variant_id', $variant_id)
    ->addMetaData('account', user_load(1)); // Run the query as user 1.
  $result = $query->execute();
  if (isset($result['shopify_product'])) {
    $ids = array_keys($result['shopify_product']);
    $shopify_product = entity_load_single('shopify_product', reset($ids));
  }
  return isset($shopify_product) ? $shopify_product : NULL;
}

/**
 * Load a single Shopify Product variant given a variant ID.
 *
 * @param int $variant_id
 *   Shopify Variant ID.
 *
 * @return ShopifyProduct
 *   Returns the loaded Shopify Product variant entity.
 */
function shopify_variant_load_single($variant_id) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'shopify_product')
    ->propertyCondition('variant_id', $variant_id)
    ->addMetaData('account', user_load(1)); // Run the query as user 1.
  $result = $query->execute();
  if (isset($result['shopify_product'])) {
    $ids = array_keys($result['shopify_product']);
    $shopify_product = entity_load_single('shopify_product', reset($ids));
  }
  return isset($shopify_product) ? $shopify_product : NULL;
}

/**
 * Implements hook_entity_info().
 */
function shopify_entity_info() {
  $return = array(
    'shopify_product' => array(
      'label' => t('Shopify Product'),
      'label callback' => 'shopify_product_label',
      'uri callback' => 'shopify_product_uri',
      'entity class' => 'ShopifyProduct',
      'controller class' => 'ShopifyProductController',
      'views controller class' => 'ShopifyProductViewsController',
      'base table' => 'shopify_products',
      'metatags' => TRUE,
      'entity keys' => array(
        'id' => 'id',
        'label' => 'title'
      ),
      'fieldable' => TRUE,
      'metadata controller class' => 'ShopifyProductMetadataController',
      'extra fields controller class' => 'EntityDefaultExtraFieldsController',
      'admin ui' => array(
        'path' => 'admin/shopify/products',
        'controller class' => 'ShopifyProductsUIController',
        'menu wildcard' => '%shopify_product',

      ),
      'bundles' => array(
        'shopify_product' => array(
          'label' => 'Shopify Product Fields',
          'metatags' => TRUE,
          'admin' => array(
            'path' => 'admin/shopify/products_structure',
          ),
        ),
      ),
      'view modes' => array(
        'full' => array(
          'label' => t('Full'),
          'custom settings' => FALSE,
        ),
        'teaser' => array(
          'label' => t('Teaser'),
          'custom settings' => FALSE,
        ),
      ),
      'load hook' => 'shopify_product_load',
      'module' => 'shopify',
      'access callback' => 'shopify_product_access',
    ),
  );

  if (module_exists('search')) {
    $return['shopify_product']['view modes'] += array(
      'search_index' => array(
        'label' => t('Search index'),
        'custom settings' => FALSE,
      ),
      'search_result' => array(
        'label' => t('Search result'),
        'custom settings' => FALSE,
      ),
    );
  }

  return $return;
}

/**
 * Implements hook_entity_insert().
 */
function shopify_entity_insert($entity, $type) {
  if (module_exists('path') && $type == 'shopify_product') {
    _shopify_product_insert_path($entity);
  }
}

/**
 * Implements hook_entity_update().
 */
function shopify_entity_update($entity, $type) {
  if (module_exists('path') && $type == 'shopify_product') {
    _shopify_product_update_path($entity);
  }
}

/**
 * Implements hook_entity_delete().
 */
function shopify_entity_delete($entity, $type) {
  if (module_exists('path') && $type == 'shopify_product') {
    _shopify_product_delete_path($entity);
  }
}

/**
 * Page callback for the bundle admin.
 */
function shopify_products_fields_admin() {
  return t('Administer Shopify Product fields and display');
}

/**
 * Add to cart form for Shopify products.
 */
function shopify_add_to_cart_form($form, &$form_state, ShopifyProduct $product = NULL) {
  $form_id = 'shopify-add-to-cart-form-' . $product->handle;
  $form['#id'] = $form_id;
  $form['#action'] = '//' . shopify_store_info()->domain . '/cart/add';
  $form['#attributes']['class'] = 'shopify-add-to-cart-form';

  if ($product) {
    $form['#product'] = $product;
  }
  elseif ($form['#product']) {
    $product = $form['#product'];
  }

  if ((!isset($form_state['values']) || empty($form_state['values']['options'])) && $product->variants) {
    // Set default variant to first one in the list.
    $default_variant = reset($product->variants);

    // Set default variant to whatever is passed as an arg in the URL.
    if (isset($_GET['variant_id'])) {
      foreach ($product->variants as $variant) {
        if ($variant->variant_id == $_GET['variant_id']) {
          $default_variant = $variant;
          break;
        }
      }
    }
  }
  elseif ($product->variants) {
    // Set variant based on options passed.
    $default_variant = shopify_add_to_cart_get_variant_from_options($product, $form_state['values']['options']);
  }
  else {
    $default_variant = $product;
  }

  // Set data attributes for use in JS.
  $form['#attributes']['data-product-id'] = $default_variant->product_id;
  $form['#attributes']['data-variant-id'] = $default_variant->variant_id;

  $form['product'] = array();

  $form['product']['variant'] = array();

  // Products with only 1 default variant will have a title of 'Default Title'.
  // We do not need to show options for these products.
  if ($product->variants && (!$default_variant || $default_variant->title !== 'Default Title')) {
    $form['product']['variant']['options']['#tree'] = TRUE;
    // Create option select lists based on product options.
    foreach ($product->options as $key => $select_list) {
      $form['product']['variant']['options'][] = array(
        '#type' => 'select',
        '#title' => check_plain(t($select_list['name'])),
        '#options' => array(),
        '#default_value' => $default_variant ? $default_variant->option_values[$key] : NULL,
        '#attributes' => array('class' => array('shopify-variant-option')),
        '#ajax' => array(
          'wrapper' => $form_id,
          'method' => 'replace',
          'callback' => 'shopify_add_to_cart_ajax_callback',
        ),
      );
    }

    // Create option lists based on variant options that are available.
    foreach ((array) $product->variants as $v) {
      foreach ((array) $v->option_values as $key => $option_value) {
        $form['product']['variant']['options'][$key]['#options'][$option_value] = $option_value;
      }
    }
  }

  if ($default_variant) {
    $form['product']['variant']['price'] = array(
      '#type' => 'container',
      '#attributes' => array('class' => array('shopify-price')),
      'value' => array(
        '#markup' => shopify_money_format() . $default_variant->wrapper()->price->value(),
      ),
    );
    // Required POST fields for add to cart form.
    $form['id'] = array(
      '#type' => 'hidden',
      '#value' => $default_variant->variant_id,
    );
    $form['return_to'] = array(
      '#type' => 'hidden',
      '#value' => 'back',
    );

    $form['product']['variant']['quantity'] = array(
      '#title' => t('Quantity'),
      '#type' => 'textfield',
      '#value' => 1,
      '#size' => 1
    );

    if ($default_variant->inventory_policy == 'continue' || $default_variant->inventory_quantity > 0 || empty($default_variant->inventory_management)) {
      $form['product']['variant']['actions'] = array(
        '#type' => 'actions',
        'submit' => array(
          '#type' => 'submit',
          '#attributes' => array('class' => array('shopify-add-to-cart-button')),
          '#value' => t('Add to Cart'),
        ),
      );
    }
    else {
      $form['product']['variant']['actions'] = array(
        '#type' => 'button',
        '#disabled' => TRUE,
        '#attributes' => array(
          'class' => array(
            'shopify-add-to-cart-button',
            'shopify-disabled-button',
            'shopify-out-of-stock-button',
            'disabled'
          ),
        ),
        '#value' => t('Out of Stock'),
      );
    }

  }
  else {
    $form['product']['variant']['actions'] = array(
      '#type' => 'button',
      '#disabled' => TRUE,
      '#attributes' => array(
        'class' => array(
          'shopify-add-to-cart-button',
          'shopify-disabled-button',
          'shopify-unavailable-button',
          'disabled'
        ),
      ),
      '#value' => t('Not Available'),
    );
  }

  return $form;
}

/**
 * Get the money format that has been set in Shopify.
 *
 * @return string
 *   Shopify money format.
 */
function shopify_money_format() {
  $format = shopify_store_info()->money_format;
  return str_replace('{{amount}}', '', $format);
}

/**
 * Get Shopify store information.
 *
 * @link https://docs.shopify.com/api/shop Shop API Documentation @endlink
 *
 * @return object
 *   Object of store information.
 */
function shopify_store_info() {
  return (object) variable_get('shopify_store_info', array());
}

/**
 * Load a product by it's given variant_id.
 *
 * @param int $variant_id
 *   Product variant ID.
 * @return ShopifyProduct
 *   Returns a shopify product with the variant id.
 */
function shopify_product_load_by_variant_id($variant_id) {
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'shopify_product')
    ->propertyCondition('variant_id', $variant_id)
    ->execute();
  if (isset($result['shopify_product']) && $result['shopify_product']) {
    $entities = entity_load('shopify_product', array_keys($result['shopify_product']));
    return reset($entities);
  }
  return NULL;
}

/**
 * Returns a variant that matches the passed option values.
 *
 * If no variant is found that matches all the options, null is returned.
 *
 * @param \ShopifyProduct $product
 *   Shopify product with variants.
 *
 * @param array $options
 *   Array of options to check against.
 *
 * @return \ShopifyProduct
 *   Returns the variant that matches the passed options.
 */
function shopify_add_to_cart_get_variant_from_options(ShopifyProduct $product, array $options = array()) {
  $selected_variant = NULL;
  foreach ((array) $product->variants as $v) {
    foreach ((array) $v->option_values as $key => $value) {
      if ($value !== $options[$key]) {
        continue 2;
      }
    }
    $selected_variant = $v;
  }
  return $selected_variant;
}

/**
 * Add to cart form AJAX callback.
 *
 * @see shopify_add_to_cart_form()
 */
function shopify_add_to_cart_ajax_callback($form, $form_state) {
  return $form;
}

/**
 * Shopify product access callback.
 *
 * @return bool
 *   Returns TRUE if the user has access to the product.
 */
function shopify_product_access($op, ShopifyProduct $entity = NULL, $account = NULL, $entity_type = 'shopify_product') {
  if (user_access('administer shopify', $account) || user_access('edit shopify products', $account)) {
    // User has access to do all the things.
    return TRUE;
  }
  switch ($op) {
    case 'view':
      // Check if this product is published.
      return $entity->published_at && user_access('view shopify products', $account);
      break;
  }
  return FALSE;
}

/**
 * Get the entity URI path.
 *
 * @param ShopifyProduct $entity
 *
 * @return array
 *   Returns the path URI.
 */
function shopify_product_uri(ShopifyProduct $entity) {
  return array(
    'path' => 'product/' . $entity->id,
  );
}

/**
 * Fetch a product object.
 *
 * @param int $id
 *   Integer specifying the product id.
 * @param boolean $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return ShopifyProduct
 *   A fully-loaded product or FALSE if it cannot be loaded.
 *
 * @see shopify_product_load_multiple()
 */
function shopify_product_load($id, $reset = FALSE) {
  $product = shopify_product_load_multiple(array($id), array(), $reset);
  return $product ? reset($product) : FALSE;
}

/**
 * Load multiple product entities based on certain conditions.
 *
 * @param array $ids
 *   An array of entity IDs.
 * @param array $conditions
 *   An array of conditions to match against the {entity} table.
 * @param boolean $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return ShopifyProduct[]
 *   An array of product entity objects, indexed by id.
 */
function shopify_product_load_multiple($ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('shopify_product', $ids, $conditions, $reset);
}

/**
 * Delete multiple product entities.
 *
 * @param array $ids
 *   An array of product entity IDs.
 */
function shopify_product_delete_multiple(array $ids) {
  foreach ($ids as $id) {
    if (module_exists('search')) {
      search_reindex($id, 'shopify_product');
    }
  }
  entity_get_controller('shopify_product')->delete($ids);
}

/**
 * Implements hook_field_extra_fields().
 *
 * Adds the add to cart form to the display field settings for organization.
 *
 * @see shopify_add_to_cart_form()
 */
function shopify_field_extra_fields() {
  $info = array();
  if (!isset($info['shopify_product']['shopify_product']['display']['full'])) {
    $info['shopify_product']['shopify_product']['display']['add_to_cart'] = array(
      'label' => t('Add to cart form'),
      'description' => t('Shopify Add to Cart form'),
      'weight' => 10,
    );
  }
  return $info;
}

/**
 * Implements hook_entity_form().
 *
 * Creates the edit/update form for the entity.
 */
function shopify_product_form($form, &$form_state, ShopifyProduct $product = NULL, $action = 'new') {
  $form['#id'] = 'shopify-product-create-form';
  $form_state['shopify_product'] = $product ?: new ShopifyProduct();

  $form_state['#action'] = $action;

  $form['title'] = array(
    '#title' => t('Product or Variant Title'),
    '#type' => 'textfield',
    '#default_value' => $product->title,
    '#required' => TRUE,
  );

  $form['actions'] = array('#type' => 'actions');
  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save product'),
    '#weight' => 40,
  );


  if (module_exists('path')) {
    $path = array();
    if (!empty($form_state['shopify_product']->id)) {
      $conditions = array('source' => 'product/' . $form_state['shopify_product']->id);
      $langcode = entity_language('shopify_product', $form_state['shopify_product']);

      if ($langcode == NULL) {
        $conditions['language'] = LANGUAGE_NONE;
      }
      elseif ($langcode != LANGUAGE_NONE) {
        $conditions['language'] = $langcode;
      }

      $path = path_load($conditions);
      if ($path === FALSE) {
        $path = array();
      }
    }
    $path += array(
      'pid' => NULL,
      'source' => isset($form_state['shopify_product']->id) ? 'product/' . $form_state['shopify_product']->id : NULL,
      'alias' => '',
      'language' => isset($langcode) ? $langcode : LANGUAGE_NONE,
    );

    $form['path'] = array(
      '#type' => 'fieldset',
      '#title' => t('URL path settings'),
      '#collapsible' => TRUE,
      '#collapsed' => empty($path['alias']),
      '#group' => 'additional_settings',
      '#attributes' => array(
        'class' => array('path-form'),
      ),
      '#attached' => array(
        'js' => array(drupal_get_path('module', 'path') . '/path.js'),
      ),
      '#access' => user_access('create url aliases') || user_access('administer url aliases'),
      '#weight' => 30,
      '#tree' => TRUE,
      '#element_validate' => array('path_form_element_validate'),
    );
    $form['path']['alias'] = array(
      '#type' => 'textfield',
      '#title' => t('URL alias'),
      '#default_value' => $path['alias'],
      '#maxlength' => 255,
      '#description' => t('Optionally specify an alternative URL by which this content can be accessed. For example, type "about" when writing an about page. Use a relative path and don\'t add a trailing slash or the URL alias won\'t work.'),
    );
    $form['path']['pid'] = array('#type' => 'value', '#value' => $path['pid']);
    $form['path']['source'] = array(
      '#type' => 'value',
      '#value' => $path['source']
    );
    $form['path']['language'] = array(
      '#type' => 'value',
      '#value' => $path['language']
    );
  }

  // No idea why this is necessary...
  $form['#submit'][] = 'shopify_product_form_submit';

  field_attach_form('shopify_product', $product, $form, $form_state);
  return $form;
}

/**
 * Form API submit callback for the entity type form.
 */
function shopify_product_form_submit(&$form, &$form_state) {
  $product = entity_ui_form_submit_build_entity($form, $form_state);
  $product->save();
  $form_state['redirect'] = 'admin/shopify/products';
}

/**
 * Implements hook_entity_info_alter().
 *
 * Redirect any links to shopify_tag taxonomy terms to a View so the tags
 * actually do something.
 */
function shopify_entity_info_alter(&$entity_info) {
  $entity_info['taxonomy_term']['bundles']['shopify_tags']['uri callback'] = 'shopify_taxonomy_tag_term_uri';
  $entity_info['taxonomy_term']['bundles']['shopify_collections']['uri callback'] = 'shopify_taxonomy_collection_term_uri';
}

/**
 * Entity uri callback for shopify_tag taxonomy terms.
 */
function shopify_taxonomy_tag_term_uri($term) {
  return array(
    'path' => 'products/tags/' . $term->tid,
  );
}

/**
 * Entity uri callback for shopify_tag taxonomy terms.
 */
function shopify_taxonomy_collection_term_uri($term) {
  return array(
    'path' => 'products/collections/' . $term->tid,
  );
}

/**
 * Implements hook_theme().
 */
function shopify_theme($existing, $type, $theme, $path) {
  return array(
    'entity_property__shopify_product__body_html' => array(
      'base hook' => 'entity_property',
    ),
    'entity_property__shopify_product__price' => array(
      'base hook' => 'entity_property',
    ),
  );
}

/**
 * @param $variables
 * @return string
 */
function theme_entity_property__shopify_product__body_html(&$variables) {
  // Get the raw HTML and run it through check_markup, rather than check_plain
  // which is used in entity_property_default_render_value_by_type
  $variables['content'] = check_markup($variables['elements']['#entity_wrapped']->{$variables['property_name']}->value(), 'full_html');
  $output = '';

  // Render the label, if it's not hidden.
  if (!$variables['label_hidden']) {
    $output .= '<div' . $variables['title_attributes'] . '>' . $variables['label'] . ':&nbsp;</div>';
  }

  // Render the content.
  $content_suffix = '';
  if (!$variables['label_hidden'] || $variables['content_attributes']) {
    $output .= '<div' . $variables['content_attributes'] . '>';
    $content_suffix = '</div>';
  }
  $output .= $variables['content'] . $content_suffix;

  // Render the top-level DIV.
  return '<div' . $variables['attributes'] . '>' . $output . '</div>';
}

/**
 * @param $variables
 * @return string
 */
function theme_entity_property__shopify_product__price(&$variables) {
  if ($variables['content']) {
    $variables['content'] = shopify_money_format() . $variables['content'];
  }
  $output = '';

  // Render the label, if it's not hidden.
  if (!$variables['label_hidden']) {
    $output .= '<div' . $variables['title_attributes'] . '>' . $variables['label'] . ':&nbsp;</div>';
  }

  // Render the content.
  $content_suffix = '';
  if (!$variables['label_hidden'] || $variables['content_attributes']) {
    $output .= '<div' . $variables['content_attributes'] . '>';
    $content_suffix = '</div>';
  }
  $output .= $variables['content'] . $content_suffix;

  // Render the top-level DIV.
  return '<div' . $variables['attributes'] . '>' . $output . '</div>';
}

/**
 * Implements hook_image_default_styles().
 */
function shopify_image_default_styles() {
  $styles = array();

  $styles['shopify_product_thumbnail'] = array(
    'label' => 'Shopify Product Thumbnail',
    'effects' => array(
      array(
        'name' => 'image_scale',
        'data' => array(
          'width' => 150,
          'height' => 0,
          'upscale' => 0,
        ),
        'weight' => 0,
      ),
    ),
  );

  return $styles;
}

/**
 * Implements hook_block_info().
 */
function shopify_block_info() {
  $blocks['cart'] = array(
    'info' => t('Shopify Cart'),
    'cache' => DRUPAL_NO_CACHE,
  );
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function shopify_block_view($delta = '') {
  $block = array();
  switch ($delta) {
    case 'cart':
      $domain = shopify_store_info()->myshopify_domain;
      $cart = t('Cart');
      $block['subject'] = $cart;
      $block['content'] = array(
        '#markup' => <<<_HTML
      <a href="https://$domain/cart"><i class="fa fa-shopping-cart"></i> <span id="shopify-cart-text">$cart<span> (<span id='shopify-cart-total'></span>)</a>
      <script type='text/javascript'>
        jQuery.ajax({
            type: 'GET',
            url: 'https://$domain/cart.json',
            dataType: 'jsonp',
            success: function(data) {
                var total = 0;
                for(i=0;i<data.items.length;i++){
                  total += data.items[i].quantity;
                }
                jQuery('#shopify-cart-total').text(total);
            }
        });
      </script>
_HTML
      );
      break;
  }
  return $block;
}

/**
 * Resets the product sync timestamp.
 */
function shopify_products_reset_sync_datestamp() {
  $datetime = new DateTime('1/1/1970');
  $last_updated = $datetime->format('Y-m-d H:i');
  variable_set('shopify_last_product_sync', $last_updated);
}

/**
 * Resets the collections sync timestamp.
 */
function shopify_collections_reset_sync_datestamp() {
  $datetime = new DateTime('1/1/1970');
  $last_updated = $datetime->format('Y-m-d H:i');
  variable_set('shopify_last_collection_sync', $last_updated);
}

/**
 * Modifies the product form to disable fields and add help text.
 */
function shopify_form_shopify_product_form_alter(&$form, &$form_state, $hook) {
  $product = menu_get_object('shopify_product', 4);
  $edit_url = shopify_api_get_product_path($product->product_id, $product->variant_id);

  $form['help'] = array(
    '#markup' => t('Product data synced with Shopify is not editable. Edit those fields on Shopify instead. <a href="!edit_url" target="_blank">!edit_url</a>', array('!edit_url' => $edit_url)),
    '#weight' => -99,
  );

  $disable = array(
    'shopify_product_images',
    'shopify_product_tags',
    'shopify_product_collections',
    'title',
  );

  foreach ($disable as $key) {
    $form[$key]['#disabled'] = TRUE;
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Disable certain taxonomy fields for Shopify terms.
 */
function shopify_form_taxonomy_form_term_alter(&$form, &$form_state) {
  switch ($form['#bundle']) {
    case 'shopify_collections':
      $disabled = array(
        'shopify_collection_id',
        'shopify_collection_image',
        'shopify_collection_published_at',
        'name',
        'description',
        'relations',
      );

      $wrapper = entity_metadata_wrapper('taxonomy_term', $form['#entity']);
      $url = shopify_api_get_shop_admin_path() . '/collections/' . $wrapper->shopify_collection_id->value();

      $form['help'] = array(
        '#markup' => t('Term data synced with Shopify is not editable. <a href="@shopify_collections" target="_blank">Edit that information on Shopify instead.</a>', array('@shopify_collections' => url($url))),
        '#weight' => -99,
      );

      break;
    case'shopify_tags':
      $disabled = array(
        'name',
        'relations',
      );

      $url = shopify_api_get_shop_admin_path() . '/products/';
      $form['help'] = array(
        '#markup' => t('Term data synced with Shopify products is not editable. <a href="@shopify_products" target="_blank">Edit that information on the Shopify products instead.</a>', array('@shopify_products' => url($url))),
        '#weight' => -99,
      );

      break;
  }
  if (isset($disabled) && $disabled) {
    foreach ($disabled as $key) {
      $form[$key]['#disabled'] = TRUE;
    }
  }
}

/**
 * Implements hook_ctools_plugin_api().
 */
function shopify_ctools_plugin_api($owner, $api) {
  if ($owner == 'metatag' && $api == 'metatag') {
    return array('version' => 1);
  }
}
