<?php

/**
 * @file
 * Tests for the Synonyms module.
 */

/**
 * Base class for all Synonyms web test cases.
 */
abstract class SynonymsWebTestCase extends DrupalWebTestCase {

  /**
   * Fully loaded user object of an admin user that has required access rights.
   *
   * @var object
   */
  protected $admin;

  /**
   * Taxonomy vocabulary within which the whole testing happens.
   *
   * @var object
   */
  protected $vocabulary;

  /**
   * Text fields that can be used for general purpose testing of behaviors.
   *
   * The var is firstly keyed by either 'enabled' or 'disabled', correspondingly
   * representing whether the behavior is enabled or disabled on that field. And
   * the inner array has 2 keys:
   * - field: (array) field definition array
   * - instance: (array) instance definition array
   *
   * @var array
   */
  protected $fields = array(
    'enabled' => array(
      'field' => array(
        'field_name' => 'text_enabled',
        'type' => 'text',
        'cardinality' => FIELD_CARDINALITY_UNLIMITED,
      ),
      'instance' => array(
        'entity_type' => 'taxonomy_term',
      ),
    ),
    'disabled' => array(
      'field' => array(
        'field_name' => 'text_disabled',
        'type' => 'text',
        'cardinality' => FIELD_CARDINALITY_UNLIMITED,
      ),
      'instance' => array(
        'entity_type' => 'taxonomy_term',
      ),
    ),
  );

  /**
   * Name of a synonyms behavior that is being tested.
   *
   * @var string
   */
  protected $behavior;

  /**
   * Settings for the behavior that is being tested.
   *
   * @var array
   */
  protected $behavior_settings = array();

  /**
   * SetUp method.
   */
  public function setUp($modules = array()) {
    $modules[] = 'synonyms';
    parent::setUp($modules);

    $this->admin = $this->drupalCreateUser(array(
      'administer taxonomy',
      'administer content types',
      'bypass node access',
      'search content',
    ));

    // Creating vocabularies.
    $this->drupalLogin($this->admin);
    $this->vocabulary = (object) array(
      'name' => $this->randomName(),
      'machine_name' => 'synonyms_test',
      'description' => $this->randomName(),
    );
    taxonomy_vocabulary_save($this->vocabulary);

    $this->fields['enabled']['field'] = field_create_field($this->fields['enabled']['field']);
    $this->fields['enabled']['field'] = field_info_field($this->fields['enabled']['field']['field_name']);
    $this->fields['enabled']['instance']['bundle'] = $this->vocabulary->machine_name;
    $this->fields['enabled']['instance']['field_name'] = $this->fields['enabled']['field']['field_name'];
    $this->fields['enabled']['instance'] = field_create_instance($this->fields['enabled']['instance']);
    $this->fields['enabled']['instance'] = field_info_instance($this->fields['enabled']['instance']['entity_type'], $this->fields['enabled']['instance']['field_name'], $this->fields['enabled']['instance']['bundle']);

    $this->fields['disabled']['field'] = field_create_field($this->fields['disabled']['field']);
    $this->fields['disabled']['field'] = field_info_field($this->fields['disabled']['field']['field_name']);
    $this->fields['disabled']['instance']['bundle'] = $this->vocabulary->machine_name;
    $this->fields['disabled']['instance']['field_name'] = $this->fields['disabled']['field']['field_name'];
    $this->fields['disabled']['instance'] = field_create_instance($this->fields['disabled']['instance']);
    $this->fields['disabled']['instance'] = field_info_instance($this->fields['disabled']['instance']['entity_type'], $this->fields['disabled']['instance']['field_name'], $this->fields['disabled']['instance']['bundle']);

    synonyms_behavior_settings_save(array(
      'instance_id' => $this->fields['enabled']['instance']['id'],
      'behavior' => $this->behavior,
      'settings' => $this->behavior_settings,
    ));
  }

  /**
   * Return last inserted term into the specified vocabulary.
   *
   * @param object $vocabulary
   *   Fully loaded taxonomy vocabulary object
   *
   * @return object
   *   Fully loaded taxonomy term object of the last inserted term into
   *   the specified vocabulary
   */
  protected function getLastTerm($vocabulary) {
    $tid = db_select('taxonomy_term_data', 't');
    $tid->addExpression('MAX(t.tid)');
    $tid->condition('vid', $vocabulary->vid);
    $tid = $tid->execute()->fetchField();
    return entity_load_unchanged('taxonomy_term', $tid);
  }
}

/**
 * Test Synonyms functionality of synonyms module.
 */
class SynonymsSynonymsWebTestCase extends SynonymsWebTestCase {

  protected $behavior = 'synonyms';

  /**
   * GetInfo method.
   */
  public static function getInfo() {
    return array(
      'name' => 'Taxonomy synonyms',
      'description' => 'Ensure that the general "synonyms" behavior works correctly.',
      'group' => 'Synonyms',
    );
  }

  /**
   * Test the functionality of synonyms.
   */
  public function testSynonyms() {
    $name = $this->randomName();
    $synonym = $this->randomName();
    $parent_synonym = $this->randomName();

    // Creating terms for testing synonyms_get_term_synonyms().
    $synonym1 = $this->randomName();
    $synonym2 = $this->randomName();

    $no_synonyms_term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $this->randomName(),
      'description' => $this->randomName(),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(array('value' => $this->randomName())),
      ),
    );
    taxonomy_term_save($no_synonyms_term);

    $one_synonym_term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $this->randomName(),
      $this->fields['enabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(array('value' => $synonym1)),
      ),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(array('value' => $this->randomName())),
      ),
    );
    taxonomy_term_save($one_synonym_term);

    $two_synonyms_term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name'=> $this->randomName(),
      $this->fields['enabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $synonym1),
          array('value' => $synonym2),
        ),
      ),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(array('value' => $this->randomName())),
      ),
    );
    taxonomy_term_save($two_synonyms_term);

    // Creating an identical parent term in order to test $parent parameter in
    // our functions.
    $term_parent = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $name,
      $this->fields['enabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $synonym),
          array('value' => $parent_synonym),
        ),
      ),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(array('value' => $this->randomName())),
      ),
    );
    taxonomy_term_save($term_parent);

    $term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $name,
      'parent' => $term_parent->tid,
      $this->fields['enabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $synonym),
        ),
      ),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(array('value' => $this->randomName())),
      ),
    );
    taxonomy_term_save($term);

    // Testing the 'synonyms' property of 'taxonomy_term' entity.
    $synonyms = synonyms_get_sanitized($no_synonyms_term);
    $this->assertTrue(empty($synonyms), 'Successfully retrieved synonyms_get_sanitized() for a term without synonyms.');
    $synonyms = synonyms_get_sanitized($one_synonym_term);
    $this->assertTrue(count($synonyms) == 1 && $synonyms[0] == $synonym1, 'Successfully retrieved synonyms_get_sanitized() for a term with a single synonym.');
    $synonyms = synonyms_get_sanitized($two_synonyms_term);
    $this->assertTrue(count($synonyms) == 2 && $synonyms[0] == $synonym1 && $synonyms[1] == $synonym2, 'Successfully retrieved synonyms_get_sanitized() for a term with 2 synonyms.');

    // Testing the function synonyms_get_term_by_synonym().
    $tid = synonyms_get_term_by_synonym(drupal_strtoupper($synonym), $this->vocabulary, $term_parent->tid);
    $this->assertEqual($tid, $term->tid, 'Successfully looked up term by its synonym.');
    $tid = synonyms_get_term_by_synonym(drupal_strtoupper($name), $this->vocabulary, $term_parent->tid);
    $this->assertEqual($tid, $term->tid, 'Successfully looked up term by its name.');
    // Now submitting a non-existing name.
    $tid = synonyms_get_term_by_synonym($parent_synonym, $this->vocabulary, $term_parent->tid);
    $this->assertEqual($tid, 0, 'synonyms_get_term_by_synonym() returns 0 if the term is not found (due to $parent parameter).');

    $tid = synonyms_get_term_by_synonym($term->{$this->fields['disabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], $this->vocabulary);
    $this->assertEqual($tid, 0, 'synonyms_get_term_by_synonym() returns 0 if the term is not found (due to a field not being engaged in "synonyms" behavior).');

    // Testing the function synonyms_add_term_by_synonym().
    $tid = synonyms_add_term_by_synonym(drupal_strtolower($name), $this->vocabulary, $term_parent->tid);
    $this->assertEqual($tid, $term->tid, 'Successfully called synonyms_add_term_by_synonym() on an existing title and no new term was created.');
    $tid = synonyms_add_term_by_synonym(drupal_strtolower($synonym), $this->vocabulary, $term_parent->tid);
    $this->assertEqual($tid, $term->tid, 'Successfully called synonyms_add_term_by_synonym() on an existing synonym and no new term was created.');
    drupal_static_reset();
    $tid = synonyms_add_term_by_synonym($parent_synonym, $this->vocabulary, $term_parent->tid);
    $new_term = taxonomy_term_load($tid);
    $new_term_parents = array_keys(taxonomy_get_parents($new_term->tid));
    $this->assertEqual($parent_synonym, $new_term->name, 'Successfully called synonyms_add_term_by_synonym() on a new title and a new term was created (due to parent restriction).');
    $this->assertNotEqual($new_term->tid, $term_parent->tid, 'Successfully called synonyms_add_term_by_synonym() on a synonym of $parent. New term was created instead of returning $parent\'s tid.');
    $this->assertTrue(in_array($term_parent->tid, $new_term_parents), 'Successfully called synonyms_add_term_by_synonym(). New term is assigned as a child to supplied $parent parameter.');

    $tid = synonyms_add_term_by_synonym($term->{$this->fields['disabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], $this->vocabulary);
    $new_term = taxonomy_term_load($tid);
    $this->assertNotEqual($new_term->tid, $term->tid, 'Successfully called synonyms_add_term_by_synonym() on a new title and a new term was created (due to a field not being engaged in "synonyms" behavior).');
  }
}

/**
 * Test "Synonyms friendly autocomplete" widget of Synonyms module.
 */
class AutocompleteSynonymsWebTestCase extends SynonymsWebTestCase {

  protected $behavior = 'autocomplete';

  protected $behavior_settings = array(
    'wording' => '@synonym @field_name @term',
  );

  /**
   * Array of fully loaded taxonomy term entities to be used in this test.
   *
   * @var array
   */
  protected $terms = array();

  /**
   * Entity type to which a term reference field with tested widget is attached.
   *
   * @var string
   */
  protected $entity_type = 'node';

  /**
   * Bundle to which a term reference field with tested widget is attached.
   *
   * @var string
   */
  protected $bundle = 'synonyms_test_content';

  /**
   * Field definition array of the field that will be attached to
   * $this->entity_type with synonyms-friendly autocomplete widget.
   *
   * @var array
   */
  protected $term_reference_field = array();

  /**
   * GetInfo method.
   */
  public static function getInfo() {
    return array(
      'name' => 'Taxonomy synonyms autocomplete',
      'description' => 'Ensure that the "synonym friendly autocomplete" widget works correctly with taxonomy terms.',
      'group' => 'Synonyms',
    );
  }

  /**
   * SetUp method.
   */
  public function setUp($modules = array()) {
    parent::setUp($modules);

    // Creating a test content type.
    $this->drupalPost('admin/structure/types/add', array(
      'name' => 'Synonyms Test Content',
      'type' => $this->bundle,
    ), 'Save content type');

    $this->term_reference_field = array(
      'type' => 'taxonomy_term_reference',
      'field_name' => 'synonyms_term_enabled',
      'cardinality' => FIELD_CARDINALITY_UNLIMITED,
      'settings' => array(
        'allowed_values' => array(
          array(
            'vocabulary' => $this->vocabulary->machine_name,
            'parent' => 0,
          ),
        ),
      ),
    );
    $this->term_reference_field = field_create_field($this->term_reference_field);

    $instance = array(
      'field_name' => $this->term_reference_field['field_name'],
      'entity_type' => 'node',
      'bundle' => $this->bundle,
      'label' => 'Synonym Terms Autcomplete',
      'widget' => array(
        'type' => 'synonyms_autocomplete',
      ),
    );
    $instance = field_create_instance($instance);

    drupal_static_reset();

    // Now creating taxonomy tree.
    $name = $this->randomName();

    $term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $name,
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($term);
    $this->terms['term1'] = $term;

    $name .= $this->randomName();

    $term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name'=> $name,
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($term);
    $this->terms['term1_longer_name'] = $term;

    $term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $this->randomName(),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($term);
    $this->terms['no_synonyms'] = $term;

    $term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $this->randomName(),
      $this->fields['enabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($term);
    $this->terms['one_synonym'] = $term;

    $term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $this->randomName(),
      $this->fields['enabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
          array('value' => $this->randomName()),
        ),
      ),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($term);
    $this->terms['two_synonyms'] = $term;

    $name = $this->randomName();
    $term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $name,
      $this->fields['enabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $name . $this->randomName()),
        ),
      ),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($term);
    $this->terms['name_similar_synonym'] = $term;

    $name = 'similar_synonyms_';
    $term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $this->randomName(),
      $this->fields['enabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $name . $this->randomName()),
          array('value' => $name . $this->randomName()),
        ),
      ),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($term);
    $this->terms['similar_synonyms'] = $term;

    $name = 'one_term_name_another_synonym_';

    $term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $name . $this->randomName(),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($term);
    $this->terms['name_another_synonym'] = $term;

    $term = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => $this->randomName(),
      $this->fields['enabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $name . $this->randomName()),
        ),
      ),
      $this->fields['disabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($term);
    $this->terms['synonym_another_name'] = $term;
  }

  /**
   * Test auto-creation functionality.
   *
   * Test the auto-creation functionality of the synonym friendly autocomplete
   * widget type. Along the way it tests whether synonyms, submitted into the
   * widget's textfield are converted into the terms, synonyms of which they
   * are.
   */
  public function testAutoCreation() {
    // Trying enabled auto creation.
    $this->drupalPost('admin/structure/types/manage/synonyms-test-content/fields/synonyms_term_enabled', array(
      'instance[widget][settings][auto_creation]' => TRUE,
    ), 'Save settings');

    $new_term_name = $this->terms['no_synonyms']->{$this->fields['disabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'];
    $this->drupalPost('node/add/synonyms-test-content', array(
      'title' => $this->randomName(),
      'synonyms_term_enabled[' . LANGUAGE_NONE . ']' => $this->terms['no_synonyms']->name . ', ' . $new_term_name . ', ' . $this->terms['one_synonym']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'],
    ), 'Save');
    $this->assertText($this->terms['no_synonyms']->name, 'Existing term was assigned to the new node');
    $this->assertText($new_term_name, 'Auto created term was assigned to the new node when Auto creation is on.');
    $this->assertText($this->terms['one_synonym']->name, 'Submitting a synonym into autocomplete widget results in the term, to which the synonym belongs, being assigned to the just created entity (when Auto creation is on).');
    $term = $this->getLastTerm($this->vocabulary);
    $this->assertEqual($term->name, $new_term_name, 'The auto created term has been created when Auto creation is on.');

    // Trying disabled auto creation.
    $this->drupalPost('admin/structure/types/manage/synonyms-test-content/fields/synonyms_term_enabled', array(
      'instance[widget][settings][auto_creation]' => FALSE,
    ), 'Save settings');

    $new_term_name = $this->terms['term1']->{$this->fields['disabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'];
    $this->drupalPost('node/add/synonyms-test-content', array(
      'title' => $this->randomName(),
      'synonyms_term_enabled[' . LANGUAGE_NONE . ']' => $this->terms['no_synonyms']->name . ', ' . $new_term_name . ', ' . $this->terms['one_synonym']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'],
    ), 'Save');
    $this->assertText($this->terms['no_synonyms']->name, 'Existing term was assigned to the new node');
    $this->assertNoText($new_term_name, 'Auto created term was not assigned to the new node when Auto creation is off.');
    $this->assertText($this->terms['one_synonym']->name, 'Submitting a synonym into autocomplete widget results in the term, to which the synonym belongs, being assigned to the just created entity (when Auto creation is off).');
    $term = $this->getLastTerm($this->vocabulary);
    $this->assertNotEqual($term->name, $new_term_name, 'The auto created term has not been created when Auto creation is off.');
  }

  /**
   * Test autocomplete menu path.
   *
   * Feed all known "buggy" input to synonym friendly autocomplete menu path,
   * in order to test its performance.
   */
  public function testAutocompleteMenuPath() {
    $this->assertAutocompleteMenuPath('', array(), 'Submitting empty string into autocomplete path returns empty result.');
    $this->assertAutocompleteMenuPath($this->randomName(), array(), 'Submitting a non existing name into autocomplete path returns empty result.');
    $this->assertAutocompleteMenuPath($this->terms['term1']->{$this->fields['disabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], array(), 'Submitting a value for a field with disabled autocomplete behavior yields empty result.');

    $this->assertAutocompleteMenuPath(drupal_strtoupper(drupal_substr($this->terms['term1']->name, 1, -1)), array(
      $this->terms['term1']->name => $this->terms['term1']->name,
      $this->terms['term1_longer_name']->name => $this->terms['term1_longer_name']->name,
    ), 'Submitting a name similar to 2 existing term names yields both terms included in the autocomplete response.');

    $this->assertAutocompleteMenuPath($this->terms['term1']->name . ', ' . drupal_strtoupper(drupal_substr($this->terms['term1']->name, 1, -1)), array(
      $this->terms['term1']->name . ', ' . $this->terms['term1_longer_name']->name => $this->terms['term1_longer_name']->name,
    ), 'Submitting one term already chosen along with a name similar to 2 existing term names yields only suggested a new term.');

    $this->assertAutocompleteMenuPath(drupal_strtoupper(drupal_substr($this->terms['no_synonyms']->name, 1, -1)), array(
      $this->terms['no_synonyms']->name => $this->terms['no_synonyms']->name,
    ), 'Submitting a name similar to one existing term name into autocomplete path yields that term included.');

    $this->assertAutocompleteMenuPath(drupal_strtolower($this->terms['no_synonyms']->name) . ', ' . drupal_strtoupper(drupal_substr($this->terms['no_synonyms']->name, 1, -1)), array(), 'Submitting the same term over again into autocomplete path yields no results.');

    $this->assertAutocompleteMenuPath($this->terms['one_synonym']->name . ', ' . $this->terms['one_synonym']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], array(), 'Submitting a synonym of a term over again into autocomplete path yields no results.');

    foreach (array('no_synonyms', 'one_synonym', 'two_synonyms') as $k) {
      $this->assertAutocompleteMenuPath(drupal_strtolower(drupal_substr($this->terms[$k]->name, 1, -1)), array(
        $this->terms[$k]->name => $this->terms[$k]->name,
      ), 'Submitting a name similar to ' . $k . ' term into autocomplete path yields the term included.');

      $synonyms = field_get_items('taxonomy_term', $this->terms[$k], $this->fields['enabled']['field']['field_name']);
      if (is_array($synonyms)) {
        foreach ($synonyms as $delta => $item) {
          $this->assertAutocompleteMenuPath(drupal_strtolower(drupal_substr($item['value'], 1, -1)), array(
            $this->terms[$k]->name => $this->synonymAutocompleteResult($this->terms[$k], $item['value'], $this->fields['enabled']['instance']),
          ), 'Submitting a name similar to synonym#' . $delta . ' of the term ' . $k . ' into autocomplete path yields the term included.');
        }
      }
    }

    $this->assertAutocompleteMenuPath('one_term_name_another_synonym_', array(
      $this->terms['name_another_synonym']->name => $this->terms['name_another_synonym']->name,
      $this->terms['synonym_another_name']->name => $this->synonymAutocompleteResult($this->terms['synonym_another_name'], $this->terms['synonym_another_name']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], $this->fields['enabled']['instance']),
    ), 'Submitting a name similar to name of one term and synonym of another into autocomplete path yields both terms included.');

    // Enabling another field in the autocomplete suggestions to make sure 2 and
    // more fields can participate in the action.
    synonyms_behavior_settings_save(array(
      'instance_id' => $this->fields['disabled']['instance']['id'],
      'behavior' => $this->behavior,
      'settings' => $this->behavior_settings,
    ));
    $this->terms['one_synonym']->{$this->fields['disabled']['field']['field_name']} = $this->terms['one_synonym']->{$this->fields['enabled']['field']['field_name']};
    taxonomy_term_save($this->terms['one_synonym']);
    $this->assertAutocompleteMenuPath($this->terms['one_synonym']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], array(
      $this->terms['one_synonym']->name => $this->synonymAutocompleteResult($this->terms['one_synonym'], $this->terms['one_synonym']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], $this->fields['enabled']['instance']),
      $this->terms['one_synonym']->name . ' ' => $this->synonymAutocompleteResult($this->terms['one_synonym'], $this->terms['one_synonym']->{$this->fields['disabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], $this->fields['disabled']['instance']),
    ), 'Autocomplete works correctly when more than 1 field participates in the autocomplete behavior.');
  }

  /**
   * Test 'Suggestions Size' setting of synonyms-friendly autocomplete widget.
   */
  public function testWidgetSettingsSuggestionSize() {
    $suggestion_size = 1;
    $this->drupalPost('admin/structure/types/manage/synonyms-test-content/fields/synonyms_term_enabled', array(
      'instance[widget][settings][suggestion_size]' => $suggestion_size,
    ), 'Save settings');

    // If size was bigger than 1, we'd get suggested 2 terms: 'term1' and
    // 'term1_longer_name'.
    $this->assertAutocompleteMenuPath($this->terms['term1']->name, array(
      $this->terms['term1']->name => $this->terms['term1']->name,
    ), 'Suggestions Size option is respected in autocomplete widget for term suggestion entries.');

    $this->assertAutocompleteMenuPath($this->terms['name_similar_synonym']->name, array(
      $this->terms['name_similar_synonym']->name => $this->terms['name_similar_synonym']->name,
    ), 'Suggestions Size option is respected in autocomplete widget for term and synonym suggestion entries.');

    $this->assertAutocompleteMenuPath(drupal_substr($this->terms['similar_synonyms']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], 0, 8), array(
      $this->terms['similar_synonyms']->name => $this->synonymAutocompleteResult($this->terms['similar_synonyms'], $this->terms['similar_synonyms']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], $this->fields['enabled']['instance']),
    ), 'Suggestions Size option is respected in autocomplete widget for synonyms suggestion entries.');

    $this->assertAutocompleteMenuPath('one_term_name_another_synonym_', array(
      $this->terms['name_another_synonym']->name => $this->terms['name_another_synonym']->name,
    ), 'Suggestions Size option is respected in autocomplete widget for the case when there is match by term name and by synonyms; and preference is given to the match by term name.');
  }

  /**
   * Test 'Suggest only one entry per term' setting of autocomplete widget.
   */
  public function testWidgetSettingsSuggestOnlyUnique() {
    // Testing disabled "Suggest only one entry per term" setting.
    $this->assertAutocompleteMenuPath($this->terms['name_similar_synonym']->name, array(
      $this->terms['name_similar_synonym']->name => $this->terms['name_similar_synonym']->name,
      $this->terms['name_similar_synonym']->name . ' ' => $this->synonymAutocompleteResult($this->terms['name_similar_synonym'], $this->terms['name_similar_synonym']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], $this->fields['enabled']['instance']),
    ), 'Both term and its synonym are shown when "Suggest only one entry per term" is off.');

    $this->assertAutocompleteMenuPath(drupal_substr($this->terms['similar_synonyms']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], 0, 8), array(
      $this->terms['similar_synonyms']->name => $this->synonymAutocompleteResult($this->terms['similar_synonyms'], $this->terms['similar_synonyms']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], $this->fields['enabled']['instance']),
      $this->terms['similar_synonyms']->name . ' ' => $this->synonymAutocompleteResult($this->terms['similar_synonyms'], $this->terms['similar_synonyms']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][1]['value'], $this->fields['enabled']['instance']),
    ), 'Multiple synonyms are shown when "Suggest only one entry per term" is off.');

    // Testing enabled "Suggest only one entry per term" setting.
    $this->drupalPost('admin/structure/types/manage/synonyms-test-content/fields/synonyms_term_enabled', array(
      'instance[widget][settings][suggest_only_unique]' => TRUE,
    ), 'Save settings');

    $this->assertAutocompleteMenuPath($this->terms['name_similar_synonym']->name, array(
      $this->terms['name_similar_synonym']->name => $this->terms['name_similar_synonym']->name,
    ), 'Only term is shown and synonym is not shown when "Suggest only one entry per term" is on.');

    $this->assertAutocompleteMenuPath(drupal_substr($this->terms['similar_synonyms']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], 0, 8), array(
      $this->terms['similar_synonyms']->name => $this->synonymAutocompleteResult($this->terms['similar_synonyms'], $this->terms['similar_synonyms']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'], $this->fields['enabled']['instance']),
    ), 'Only single synonym is shown when "Suggest only one entry per term" is on.');
  }

  /**
   * Assert output of synonym friendly autocomplete path.
   *
   * @param string $input
   *   String of input to supply to the autocomplete path
   * @param array $standard
   *   Expected output from the autocomplete path. Supply it as an associative
   *   array
   * @param string $message
   *   Drupal assertion message to be displayed on the rest results page
   */
  protected function assertAutocompleteMenuPath($input, $standard, $message) {
    $response = $this->drupalGet('synonyms/autocomplete/' . $this->term_reference_field['field_name']  . '/' . $this->entity_type . '/' . $this->bundle . '/' . $input);
    if (!$response) {
      $this->fail($message, 'Autocomplete Menu Path');
      return;
    }
    $response = (array) json_decode($response);
    $is_the_same = count($response) == count($standard);
    $is_the_same = $is_the_same && count(array_intersect_assoc($response, $standard)) == count($standard);

    $this->assertTrue($is_the_same, $message, 'Autocomplete Menu Path');
  }

  /**
   * Return expected autocomplete menu path result.
   *
   * The result is prepared as if the term was found by the supplied synonym.
   *
   * @param object $term
   *   Fully loaded taxonomy term object for which the result is generated.
   * @param string $synonym
   *   Synonym by which the term was hit in the search
   * @param array $instance
   *   Instance definition array which the $synonym originates from
   *
   * @return string
   *   Formatted autocomplete result
   */
  protected function synonymAutocompleteResult($term, $synonym, $instance) {
    return format_string($this->behavior_settings['wording'], array(
      '@synonym' => $synonym,
      '@term' => $term->name,
      '@field_name' => drupal_strtolower($instance['label']),
    ));
  }
}

/**
 * Test "Synonyms friendly select" widget of Synonyms module.
 */
class SelectSynonymsWebTestCase extends SynonymsWebTestCase {

  protected $behavior = 'select';

  protected $behavior_settings = array(
    'wording' => '@synonym @term @field_name',
  );

  /**
   * Array of fully loaded taxonomy term entities to be used in this test.
   *
   * @var array
   */
  protected $terms = array();

  /**
   * Entity type to which a term reference field with tested widget is attached.
   *
   * @var string
   */
  protected $entity_type = 'node';

  /**
   * Bundle to which a term reference field with tested widget is attached.
   *
   * @var string
   */
  protected $bundle = 'synonyms_test_content';

  /**
   * Field definition array of the field that will be attached to
   * $this->entity_type with synonyms-friendly select widget.
   *
   * @var array
   */
  protected $term_reference_field = array();

  public static function getInfo() {
    return array(
      'name' => 'Synonyms friendly select',
      'description' => 'Ensure that the "synonym friendly select" widget works correctly with taxonomy terms.',
      'group' => 'Synonyms',
    );
  }

  public function setUp($modules = array()) {
    parent::setUp($modules);

    // Creating a test content type.
    $this->drupalPost('admin/structure/types/add', array(
      'name' => 'Synonyms Test Content',
      'type' => $this->bundle,
    ), 'Save content type');

    $this->term_reference_field = array(
      'type' => 'taxonomy_term_reference',
      'field_name' => 'synonyms_term',
      'cardinality' => FIELD_CARDINALITY_UNLIMITED,
      'settings' => array(
        'allowed_values' => array(
          array(
            'vocabulary' => $this->vocabulary->machine_name,
            'parent' => 0,
          ),
        ),
      ),
    );
    $this->term_reference_field = field_create_field($this->term_reference_field);

    $instance = array(
      'field_name' => $this->term_reference_field['field_name'],
      'entity_type' => 'node',
      'bundle' => $this->bundle,
      'label' => 'Synonym Terms Select',
      'widget' => array(
        'type' => 'synonyms_select',
      ),
    );
    $instance = field_create_instance($instance);

    $this->terms['parent_term'] = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => 'Parent Term',
      $this->fields['enabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => 'Parent TermA' . $this->randomName()),
          array('value' => 'Parent TermZ' . $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($this->terms['parent_term']);

    $this->terms['child_term'] = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => 'Child Term',
      'parent' => $this->terms['parent_term']->tid,
      $this->fields['enabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => 'Child TermZ' . $this->randomName()),
          array('value' => 'Child TermA' . $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($this->terms['child_term']);

    $this->terms['normal_term'] = (object) array(
      'vid' => $this->vocabulary->vid,
      'name' => 'Normal Term',
      $this->fields['enabled']['field']['field_name'] => array(
        LANGUAGE_NONE => array(
          array('value' => 'Normal TermA' . $this->randomName()),
          array('value' => 'Normal TermZ' . $this->randomName()),
        ),
      ),
    );
    taxonomy_term_save($this->terms['normal_term']);
  }

  /**
   * Test sorting options of the widget.
   */
  public function testWidgetSorting() {
    $cardinality = array(
      1 => 1,
      FIELD_CARDINALITY_UNLIMITED => 'unlimited',
    );
    $required = array(
      TRUE => 'required',
      FALSE => 'not required',
    );

    foreach ($cardinality as $cardinality_k => $cardinality_v) {
      foreach ($required as $required_k => $required_v) {
        $this->term_reference_field['cardinality'] = $cardinality_k;
        field_update_field($this->term_reference_field);

        $instance = field_info_instance($this->entity_type, $this->term_reference_field['field_name'], $this->bundle);
        $instance['required'] = $required_k;
        $instance['widget']['settings']['sort'] = 'weight';
        field_update_instance($instance);

        $this->terms['parent_term']->weight = 0;
        taxonomy_term_save($this->terms['parent_term']);

        $options = array();
        $options[] = array(
          'term' => $this->terms['normal_term'],
        );
        $options[] = array(
          'term' => $this->terms['normal_term'],
          'synonym' => $this->terms['normal_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'],
        );
        $options[] = array(
          'term' => $this->terms['normal_term'],
          'synonym' => $this->terms['normal_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][1]['value'],
        );
        $options[] = array(
          'term' => $this->terms['parent_term'],
        );
        $options[] = array(
          'term' => $this->terms['parent_term'],
          'synonym' => $this->terms['parent_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'],
        );
        $options[] = array(
          'term' => $this->terms['parent_term'],
          'synonym' => $this->terms['parent_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][1]['value'],
        );
        $options[] = array(
          'term' => $this->terms['child_term'],
        );
        $options[] = array(
          'term' => $this->terms['child_term'],
          'synonym' => $this->terms['child_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'],
        );
        $options[] = array(
          'term' => $this->terms['child_term'],
          'synonym' => $this->terms['child_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][1]['value'],
        );
        $this->drupalGet('node/add/synonyms-test-content');
        $this->assertSynonymsSelect($options, 'Synonyms select sorting by weight works for the cardinality of ' . $cardinality_v . ' and ' . $required_v);

        $this->terms['parent_term']->weight = -1000;
        taxonomy_term_save($this->terms['parent_term']);
        $options = array();
        $options[] = array(
          'term' => $this->terms['parent_term'],
        );
        $options[] = array(
          'term' => $this->terms['parent_term'],
          'synonym' => $this->terms['parent_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'],
        );
        $options[] = array(
          'term' => $this->terms['parent_term'],
          'synonym' => $this->terms['parent_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][1]['value'],
        );
        $options[] = array(
          'term' => $this->terms['child_term'],
        );
        $options[] = array(
          'term' => $this->terms['child_term'],
          'synonym' => $this->terms['child_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'],
        );
        $options[] = array(
          'term' => $this->terms['child_term'],
          'synonym' => $this->terms['child_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][1]['value'],
        );
        $options[] = array(
          'term' => $this->terms['normal_term'],
        );
        $options[] = array(
          'term' => $this->terms['normal_term'],
          'synonym' => $this->terms['normal_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'],
        );
        $options[] = array(
          'term' => $this->terms['normal_term'],
          'synonym' => $this->terms['normal_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][1]['value'],
        );
        $this->drupalGet('node/add/synonyms-test-content');
        $this->assertSynonymsSelect($options, 'Synonyms select sorting by weight works after changing weights of terms for the cardinality of ' . $cardinality_v . ' and ' . $required_v);

        $instance = field_info_instance($this->entity_type, $this->term_reference_field['field_name'], $this->bundle);
        $instance['widget']['settings']['sort'] = 'name';
        field_update_instance($instance);

        $options = array();
        $options[] = array(
          'term' => $this->terms['normal_term'],
        );
        $options[] = array(
          'term' => $this->terms['normal_term'],
          'synonym' => $this->terms['normal_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'],
        );
        $options[] = array(
          'term' => $this->terms['normal_term'],
          'synonym' => $this->terms['normal_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][1]['value'],
        );
        $options[] = array(
          'term' => $this->terms['parent_term'],
        );
        $options[] = array(
          'term' => $this->terms['child_term'],
        );
        $options[] = array(
          'term' => $this->terms['child_term'],
          'synonym' => $this->terms['child_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][1]['value'],
        );
        $options[] = array(
          'term' => $this->terms['child_term'],
          'synonym' => $this->terms['child_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'],
        );
        $options[] = array(
          'term' => $this->terms['parent_term'],
          'synonym' => $this->terms['parent_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'],
        );
        $options[] = array(
          'term' => $this->terms['parent_term'],
          'synonym' => $this->terms['parent_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][1]['value'],
        );
        $this->drupalGet('node/add/synonyms-test-content');
        $this->assertSynonymsSelect($options, 'Synonyms select sorting by name works for the cardinality of ' . $cardinality_v . ' and ' . $required_v);
      }
    }
  }

  /**
   * Test main functionality of the widget.
   */
  public function testWidget() {
    $name = $this->randomName();
    $this->drupalPost('node/add/synonyms-test-content', array(
      'title' => $name,
      $this->term_reference_field['field_name'] . '[' . LANGUAGE_NONE . '][]' => array(
        $this->synonymSelectKey($this->terms['parent_term'], $this->terms['parent_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value']),
        $this->terms['child_term']->tid,
        $this->terms['normal_term']->tid,
        $this->synonymSelectKey($this->terms['normal_term'], $this->terms['normal_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value']),
      ),
    ), 'Save');

    $node = $this->drupalGetNodeByTitle($name);
    $this->drupalGet('node/' . $node->nid);
    $this->assertText($this->terms['parent_term']->name, 'Term is saved when its synonym is submitted through synonyms friendly select for the unlimited cardinality.');
    $this->assertText($this->terms['child_term']->name, 'Term is saved when it is submitted through synonyms friendly select for the unlimited cardinality.');
    $this->assertUniqueText($this->terms['normal_term']->name, 'Term is saved only once when the term and its synonym are submitted through synonyms friendly select for the unlimited cardinality.');

    $options = array();
    $options[] = array(
      'term' => $this->terms['normal_term'],
      'selected' => TRUE,
    );
    $options[] = array(
      'term' => $this->terms['normal_term'],
      'synonym' => $this->terms['normal_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'],
    );
    $options[] = array(
      'term' => $this->terms['normal_term'],
      'synonym' => $this->terms['normal_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][1]['value'],
    );
    $options[] = array(
      'term' => $this->terms['parent_term'],
      'selected' => TRUE,
    );
    $options[] = array(
      'term' => $this->terms['parent_term'],
      'synonym' => $this->terms['parent_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'],
    );
    $options[] = array(
      'term' => $this->terms['parent_term'],
      'synonym' => $this->terms['parent_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][1]['value'],
    );
    $options[] = array(
      'term' => $this->terms['child_term'],
      'selected' => TRUE,
    );
    $options[] = array(
      'term' => $this->terms['child_term'],
      'synonym' => $this->terms['child_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'],
    );
    $options[] = array(
      'term' => $this->terms['child_term'],
      'synonym' => $this->terms['child_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][1]['value'],
    );
    $this->drupalGet('node/' . $node->nid . '/edit');
    $this->assertSynonymsSelect($options, 'Default values are set correctly in the synonyms friendly select widget when working with field cardinality more than 1.');

    $this->term_reference_field['cardinality'] = 2;
    field_update_field($this->term_reference_field);
    $name = $this->randomName();
    $this->drupalPost('node/add/synonyms-test-content', array(
      'title' => $name,
      $this->term_reference_field['field_name'] . '[' . LANGUAGE_NONE . '][]' => array(
        $this->synonymSelectKey($this->terms['parent_term'], $this->terms['parent_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value']),
        $this->terms['child_term']->tid,
        $this->terms['normal_term']->tid,
      ),
    ), 'Save');
    $this->assertText('this field cannot hold more than 2 values.', 'Submitting 3 entries into a field with cardinality of 2, that refer to 3 terms, results in a form error.');

    $this->drupalPost('node/add/synonyms-test-content', array(
      'title' => $name,
      $this->term_reference_field['field_name'] . '[' . LANGUAGE_NONE . '][]' => array(
        $this->synonymSelectKey($this->terms['parent_term'], $this->terms['parent_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value']),
        $this->terms['normal_term']->tid,
        $this->synonymSelectKey($this->terms['normal_term'], $this->terms['normal_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value']),
      ),
    ), 'Save');
    $node = $this->drupalGetNodeByTitle($name);
    $this->drupalGet('node/' .  $node->nid);
    $this->assertUniqueText($this->terms['parent_term']->name, 'Submitting 3 entries into a field with cardinality of 2, that refer to only 2 terms, results in form getting submitted. Term #1 is saved.');
    $this->assertUniqueText($this->terms['normal_term']->name, 'Term #2 is saved.');

    $this->term_reference_field['cardinality'] = 1;
    field_update_field($this->term_reference_field);
    $name = $this->randomName();
    $this->drupalPost('node/add/synonyms-test-content', array(
      'title' => $name,
      $this->term_reference_field['field_name'] . '[' . LANGUAGE_NONE . ']' => $this->synonymSelectKey($this->terms['parent_term'], $this->terms['parent_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value']),
    ), 'Save');
    $node = $this->drupalGetNodeByTitle($name);
    $this->drupalGet('node/' . $node->nid);
    $this->assertText($this->terms['parent_term']->name, 'Term is saved when its synonym is submitted through synonyms friendly select for the cardinality of 1.');

    $options = array();
    $options[] = array(
      'term' => $this->terms['normal_term'],
    );
    $options[] = array(
      'term' => $this->terms['normal_term'],
      'synonym' => $this->terms['normal_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'],
    );
    $options[] = array(
      'term' => $this->terms['normal_term'],
      'synonym' => $this->terms['normal_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][1]['value'],
    );
    $options[] = array(
      'term' => $this->terms['parent_term'],
      'selected' => TRUE,
    );
    $options[] = array(
      'term' => $this->terms['parent_term'],
      'synonym' => $this->terms['parent_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'],
    );
    $options[] = array(
      'term' => $this->terms['parent_term'],
      'synonym' => $this->terms['parent_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][1]['value'],
    );
    $options[] = array(
      'term' => $this->terms['child_term'],
    );
    $options[] = array(
      'term' => $this->terms['child_term'],
      'synonym' => $this->terms['child_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'],
    );
    $options[] = array(
      'term' => $this->terms['child_term'],
      'synonym' => $this->terms['child_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][1]['value'],
    );
    $this->drupalGet('node/' .  $node->nid . '/edit');
    $this->assertSynonymsSelect($options, 'Default values are set correctly in the synonyms friendly select widget when working with the field cardinality of 1.');

    $this->drupalPost('node/' . $node->nid . '/edit', array(
      $this->term_reference_field['field_name'] . '[' . LANGUAGE_NONE . ']' => $this->terms['child_term']->tid,
    ), 'Save');
    $this->drupalGet('node/' . $node->nid);
    $this->assertNoText($this->terms['parent_term']->name, 'After updating entity the old term is removed.');
    $this->assertText($this->terms['child_term']->name, 'Term is saved when it is submitted through synonyms friendly select for the cardinality of 1.');

    $options = array();
    $options[] = array(
      'term' => $this->terms['normal_term'],
    );
    $options[] = array(
      'term' => $this->terms['normal_term'],
      'synonym' => $this->terms['normal_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'],
    );
    $options[] = array(
      'term' => $this->terms['normal_term'],
      'synonym' => $this->terms['normal_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][1]['value'],
    );
    $options[] = array(
      'term' => $this->terms['parent_term'],
    );
    $options[] = array(
      'term' => $this->terms['parent_term'],
      'synonym' => $this->terms['parent_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'],
    );
    $options[] = array(
      'term' => $this->terms['parent_term'],
      'synonym' => $this->terms['parent_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][1]['value'],
    );
    $options[] = array(
      'term' => $this->terms['child_term'],
      'selected' => TRUE,
    );
    $options[] = array(
      'term' => $this->terms['child_term'],
      'synonym' => $this->terms['child_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][0]['value'],
    );
    $options[] = array(
      'term' => $this->terms['child_term'],
      'synonym' => $this->terms['child_term']->{$this->fields['enabled']['field']['field_name']}[LANGUAGE_NONE][1]['value'],
    );
    $this->drupalGet('node/' .  $node->nid . '/edit');
    $this->assertSynonymsSelect($options, 'Default values are set correctly in the synonyms friendly select widget when working with the field cardinality of 1.');
  }

  /**
   * Assert correctness of the synonyms-friendly select widget.
   *
   * @param array $options
   *   Array of what options must be present in the select form element. It
   *   should consist of arrays that follow such structure:
   *   - term: (object) Term object this option represents
   *   - synonym: (string) If the option comes from a term, then include it here
   *   - selected: (bool) Place here TRUE if this option should be selected by
   *     default
   * @param string $message
   *   Assert message that will be passed on to SimpleTest internals
   */
  protected function assertSynonymsSelect($options, $message = '') {
    $instance = field_info_instance($this->entity_type, $this->term_reference_field['field_name'], $this->bundle);
    $multiple = $this->term_reference_field['cardinality'] > 1 || $this->term_reference_field['cardinality'] == FIELD_CARDINALITY_UNLIMITED;
    $required = $instance['required'];

    $element = array(
      '#options' => array(),
      '#value' => $multiple ? array() : 'nothing',
    );

    if (!$multiple && !$required) {
      $element['#options'][''] = t('- None -');
    }

    foreach ($options as $v) {
      $key = $this->synonymSelectKey($v['term'], isset($v['synonym']) ? $v['synonym'] : NULL);
      $label = $v['term']->name;
      if (isset($v['synonym'])) {
        $label = format_string($this->behavior_settings['wording'], array(
          '@synonym' => $v['synonym'],
          '@term'=> $v['term']->name,
          '@field_name' => $this->fields['enabled']['instance']['label'],
        ));
      }

      if (isset($v['selected']) && $v['selected']) {
        if ($multiple) {
          $element['#value'][] = $key;
        }
        else {
          $element['#value'] = $key;
        }
      }

      $depth = count(taxonomy_get_parents_all($v['term']->tid)) - 1;
      $element['#options'][$key] = str_repeat('-', $depth) . $label;
    }
    $this->assertRaw('>' . form_select_options($element) . '</select>', $message, 'Synonyms friendly select');
  }

  /**
   * Form a key for the option of a synonyms friendly select.
   *
   * @param object $term
   *   Fully loaded taxonomy term for which to generate the key
   * @param string $synonym
   *   If the option, whose key is being generated, comes from a synonym, then
   *   supply it here
   *
   * @return string
   *   Key for the option of a synonym friendly select
   */
  protected function synonymSelectKey($term, $synonym = NULL) {
    $key = $term->tid;
    if ($synonym) {
      $key .= ':' . drupal_html_class($synonym);
    }
    return $key;
  }
}

/**
 * Base class for all tests that test Synonyms behavior implementation classes.
 */
abstract class AbstractSynonymsBehaviorWebTestCase extends SynonymsWebTestCase {

  protected $behavior = 'synonyms';

  /**
   * Test synonymsExtract() method.
   *
   * @param array $items
   *   Array of field items to be saved in tested term
   * @param array $standard
   *   Expected return of synonymsExtract() method
   * @param string $message
   *   Any custom message to be added to the standard one and passed to
   *   SimpleTest assertion method
   */
  protected function assertSynonymsExtract($items, $standard, $message = '') {
    $behavior_implementation = synonyms_behavior_implementation_class('synonyms', $this->fields['enabled']['field']);
    $behavior_implementation = new $behavior_implementation();

    $term = (object) array(
      'name' => $this->randomName(),
      'vid' => $this->vocabulary->vid,
    );
    $term->{$this->fields['enabled']['field']['field_name']} = $items;
    taxonomy_term_save($term);
    $items = field_get_items('taxonomy_term', $term, $this->fields['enabled']['field']['field_name']);

    $synonyms = is_array($items) ? $behavior_implementation->extractSynonyms($items, $this->fields['enabled']['field'], $this->fields['enabled']['instance'], $term, 'taxonomy_term') : array();
    $this->assertTrue(count(array_intersect($standard, $synonyms)) == count($standard), get_class($behavior_implementation) . '::extractSynonyms() passed: ' . $message);
    // Cleaning up.
    taxonomy_term_delete($term->tid);
  }

  /**
   * Test mergeEntityAsSynonym method.
   *
   * @param array $items
   *   Parameter will be passed directly to the behavior implementation object
   * @param object $synonym_entity
   *   Parameter will be passed directly to the behavior implementation object
   * @param string $synonym_entity_type
   *   Parameter will be passed directly to the behavior implementation object
   * @param array $standard
   *   Array that is expected to be returned by the tested method
   * @param string $message
   *   Any custom message to be added to the standard one and passed to
   *   SimpleTest assertion method
   */
  protected function assertMergeEntityAsSynonym($items, $synonym_entity, $synonym_entity_type, $standard, $message = '') {
    $behavior_implementation = synonyms_behavior_implementation_class('synonyms', $this->fields['enabled']['field']);
    $behavior_implementation = new $behavior_implementation();

    $message = get_class($behavior_implementation) . '::mergeEntityAsSynonym() passed: ' . $message;

    $extra_items = $behavior_implementation->mergeEntityAsSynonym($items, $this->fields['enabled']['field'], $this->fields['enabled']['instance'], $synonym_entity, $synonym_entity_type);
    foreach ($standard as $k => $v) {
      if (count(array_intersect($standard[$k], $extra_items[$k])) != count($standard[$k])) {
        $this->fail($message);
        return;
      }
    }
    $this->pass($message);
  }


  /**
   * Test synonymFind method.
   *
   * @param array $meta_data
   *   Array of meta data. Each subarray represents a single term and whether it
   *   is expected to be included in the return of the method. Should have the
   *   following structure:
   *   - items: (array) Array of field items. Terms will be automatically
   *     created with those items
   *   - found_synonyms: (array) Array of synonyms that are expected to be found
   *     for the given term, i.e. if "found_synonyms" is empty, it means the
   *     term should not be found for the given $condition. If the
   *     "found_synonyms" is not empty, then each of the elements in this array
   *     should trigger appearance of the term in the results for the given
   *     $condition
   * @param QueryConditionInterface $condition
   *   Database condition that will be passed to the synonymsFind method
   * @param string $message
   *   Any custom message to be added to the standard one and passed to
   *   SimpleTest assertion method
   */
  protected function assertSynonymsFind($meta_data, QueryConditionInterface $condition, $message = '') {
    $behavior_implementation = synonyms_behavior_implementation_class('synonyms', $this->fields['enabled']['field']);
    $behavior_implementation = new $behavior_implementation();

    $message = get_class($behavior_implementation) . '::synonymsFind() pass: ' . $message;

    $terms = array();
    foreach ($meta_data as $v) {
      $term = (object) array(
        'name' => $this->randomName(),
        'vid' => $this->vocabulary->vid,
        $this->fields['enabled']['field']['field_name'] => $v['items'],
      );
      taxonomy_term_save($term);
      $term->found_synonyms = $v['found_synonyms'];
      $terms[] = $term;
    }

    $return = $behavior_implementation->synonymsFind($condition, $this->fields['enabled']['field'], $this->fields['enabled']['instance']);

    $rows = array();
    foreach ($return as $row) {
      $rows[] = $row;
    }

    $success = TRUE;
    $total_rows_standard = 0;
    $total_rows = 0;
    foreach ($terms as $term) {
      foreach ($term->found_synonyms as $found_synonym) {
        $total_rows_standard++;
        $is_found = FALSE;
        $total_rows = 0;
        foreach ($rows as $row) {
          $total_rows++;
          if ($row->entity_id == $term->tid && $row->synonym == $found_synonym) {
            $is_found = TRUE;
          }
        }
        $success = $success && $is_found;
      }
    }

    $success = $success && $total_rows_standard == $total_rows;

    $this->assertTrue($success, $message);

    // Cleaning up.
    foreach ($terms as $term) {
      taxonomy_term_delete($term->tid);
    }
  }
}

/**
 * Test TextSynonymsBehavior class.
 */
class TextSynonymsBehaviorWebTestCase extends AbstractSynonymsBehaviorWebTestCase {

  /**
   * GetInfo method.
   */
  public static function getInfo() {
    return array(
      'name' => 'TextSynonymsBehavior',
      'description' => 'Ensure that the synonyms module extracts synonyms from text and number fields correctly.',
      'group' => 'Synonyms',
    );
  }

  /**
   * Test synonyms extraction for 'text' field type.
   */
  public function testText() {
    // Testing synonymsExtract().
    $this->assertSynonymsExtract(array(), array(), 'on empty field.');

    $synonym = $this->randomName();
    $this->assertSynonymsExtract(array(
      LANGUAGE_NONE => array(
        0 => array('value' => $synonym),
      ),
    ), array($synonym), 'on a field that holds one value.');

    // Testing mergeEntityAsSynonym() method.
    $node = (object) array(
      'title' => $this->randomName(),
      'type' => 'page',
    );
    node_save($node);
    $this->assertMergeEntityAsSynonym(array(), $node, 'node', array(array('value' => $node->title)), 'on a node entity.');

    // Testing synonymFind() method.
    $this->assertSynonymsFind(array(), db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $this->randomName()), 'on empty field.');

    $meta_data = array();
    $meta_data[] = array(
      'items' => array(),
      'found_synonyms' => array(),
    );
    $this->assertSynonymsFind($meta_data, db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $this->randomName()), 'on a field without values.');

    $meta_data = array();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
        ),
      ),
      'found_synonyms' => array(),
    );
    $this->assertSynonymsFind($meta_data, db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $this->randomName()), 'on a field with a value, but when searching for another string.');

    $meta_data = array();
    $synonym = $this->randomName();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('value' => $synonym),
        ),
      ),
      'found_synonyms' => array($synonym),
    );
    $this->assertSynonymsFind($meta_data, db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $synonym), 'on a field with a single value searching for that string');

    $meta_data = array();
    $synonym = $this->randomName();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('value' => $synonym),
          array('value' => $this->randomName()),
        ),
      ),
      'found_synonyms' => array($synonym),
    );
    $this->assertSynonymsFind($meta_data, db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $synonym), 'on a field with 2 values searching for one of those 2 values');

    $meta_data = array();
    $synonym = $this->randomName();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('value' => $synonym),
          array('value' => $this->randomName()),
        ),
      ),
      'found_synonyms' => array($synonym),
    );
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('value' => $this->randomName()),
          array('value' => $this->randomName()),
        ),
      ),
      'found_synonyms' => array(),
    );
    $this->assertSynonymsFind($meta_data, db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $synonym), 'on 2 fields with 2 values each searching for one of those values');

    $meta_data = array();
    $synonym = $this->randomName();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('value' => $synonym),
        ),
      ),
      'found_synonyms' => array($synonym),
    );
    $this->assertSynonymsFind($meta_data, db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, '%' . db_like(drupal_substr($synonym, 1, -1)) . '%', 'LIKE'), 'on a field with a value searching for a string LIKE the %value%');

    $meta_data = array();
    $tag = $this->randomName();
    $synonym1 = $tag . $this->randomName();
    $synonym2 =  $tag . $this->randomName();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('value' => $synonym1),
          array('value' => $synonym2),
        ),
      ),
      'found_synonyms' => array($synonym1, $synonym2),
    );
    $this->assertSynonymsFind($meta_data, db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, db_like($tag) . '%', 'LIKE'), 'on a field with 2 similar values searching a string like %both values%');

    $meta_data = array();
    $synonym1 = $this->randomName();
    $synonym2 = $this->randomName();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('value' => $synonym1),
          array('value' => $synonym2),
        ),
      ),
      'found_synonyms' => array($synonym1, $synonym2),
    );
    $this->assertSynonymsFind($meta_data, db_or()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $synonym1)->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $synonym2), 'on a field with 2 values searching for value1 or value2');

    $meta_data = array();
    $synonym = $this->randomName();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('value' => $synonym),
          array('value' => $this->randomName()),
        ),
      ),
      'found_synonyms' => array($synonym),
    );
    $this->assertSynonymsFind($meta_data, db_and(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $synonym)->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, db_like(drupal_substr($synonym, 0, -1)) . '%', 'LIKE'), 'on a field with 2 values searching for value1 and LIKE value1%');

    $meta_data = array();
    $synonym1 = $this->randomName();
    $synonym2 = $this->randomName();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('value' => $synonym1),
          array('value' => $synonym2),
        ),
      ),
      'found_synonyms' => array($synonym1, $synonym2),
    );
    $condition = db_or();
    $condition->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $synonym1);
    $condition->condition(db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $synonym2)->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, db_like(drupal_substr($synonym2, 0, -1)) . '%', 'LIKE'));
    $this->assertSynonymsFind($meta_data, $condition, 'on a field with 2 values searching for (value1 or (value2 AND value2%))');

    $meta_data = array();
    $synonym1 = $this->randomName() . ' ' . $this->randomName() . ' ' . $this->randomName();
    $synonym2 = str_replace(' ', '-', $synonym1);
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('value' => $synonym1),
          array('value' => $synonym2),
        ),
      ),
      'found_synonyms' => array($synonym1, $synonym2),
    );
    $condition = db_and()
      ->where("REPLACE(" . AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER . ", ' ', '-') = :synonym", array(
        ':synonym' => $synonym2,
      ));
    $this->assertSynonymsFind($meta_data, $condition, "on a field with 2 values, where 2nd value replaces spaces with dashes in the 1st value, searching for REPLACE(column, ' ', '-') = value2");
  }
}

/**
 * Test TaxonomySynonymsBehavior class.
 */
class TaxonomySynonymsBehaviorWebTestCase extends AbstractSynonymsBehaviorWebTestCase {

  /**
   * Taxonomy vocabulary object terms.
   *
   * Terms of this vocabulary are synonyms of the main vocabulary terms.
   *
   * @var object
   */
  protected $vocabularySource;

  /**
   * GetInfo method.
   */
  public static function getInfo() {
    return array(
      'name' => 'TaxonomySynonymsBehavior',
      'description' => 'Ensure that the synonyms module extracts synonyms from taxonomy term reference fields correctly.',
      'group' => 'Synonyms',
    );
  }

  /**
   * SetUp method.
   */
  public function setUp($modules = array()) {
    $this->fields['enabled']['field'] = array(
      'field_name' => 'term',
      'cardinality' => FIELD_CARDINALITY_UNLIMITED,
      'type' => 'taxonomy_term_reference',
      'settings' => array(
        'allowed_values' => array(
          array(
            'vocabulary' => 'source_vocabulary',
            'parent' => 0,
          ),
        ),
      ),
    );
    parent::setUp($modules);

    $this->vocabularySource = (object) array(
      'name' => $this->randomName(),
      'machine_name' => 'source_vocabulary',
    );
    taxonomy_vocabulary_save($this->vocabularySource);
  }

  /**
   * Test synonyms extraction for 'taxonomy_term_reference' field type.
   */
  public function testTaxonomyTermReference() {
    // Testing synonymsExtract().
    $this->assertSynonymsExtract(array(), array(), 'on empty field.');

    $synonym_term = $this->createSynonymTerm();
    $this->assertSynonymsExtract(array(
      LANGUAGE_NONE => array(
        0 => array(
          'tid' => $synonym_term->tid,
        ),
      ),
    ), array($synonym_term->name), 'on a field that holds one value.');

    // Testing mergeEntityAsSynonym() method.
    $synonym_term = $this->createSynonymTerm();
    $this->assertMergeEntityAsSynonym(array(), $synonym_term, 'taxonomy_term', array(array('tid' => $synonym_term->tid)), 'on a term from referenced vocabulary.');

    // Testing synonymFind() method.
    $this->assertSynonymsFind(array(), db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $this->randomName()), 'on empty field');

    $meta_data = array();
    $meta_data[] = array(
      'items' => array(),
      'found_synonyms' => array(),
    );
    $this->assertSynonymsFind($meta_data, db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $this->randomName()), 'on a field without values');

    $meta_data = array();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('tid' => $this->createSynonymTerm()->tid),
        ),
      ),
      'found_synonyms' => array(),
    );
    $this->assertSynonymsFind($meta_data, db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $this->randomName()), 'on a field with a value but searching for another string');

    $meta_data = array();
    $synonym_term = $this->createSynonymTerm();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('tid' => $synonym_term->tid),
        ),
      ),
      'found_synonyms' => array($synonym_term->name),
    );
    $this->assertSynonymsFind($meta_data, db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $synonym_term->name), 'on a field with a single value searching for that string');

    $meta_data = array();
    $synonym_term = $this->createSynonymTerm();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('tid' => $this->createSynonymTerm()->tid),
          array('tid' => $synonym_term->tid),
        ),
      ),
      'found_synonyms' => array($synonym_term->name),
    );
    $this->assertSynonymsFind($meta_data, db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $synonym_term->name), 'on a field with 2 values searching for one of those 2 values');

    $meta_data = array();
    $synonym_term = $this->createSynonymTerm();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('tid' => $synonym_term->tid),
          array('tid' => $this->createSynonymTerm()->tid),
        ),
      ),
      'found_synonyms' => array($synonym_term->name),
    );
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('tid' => $this->createSynonymTerm()->tid),
          array('tid' => $this->createSynonymTerm()->tid),
        ),
      ),
      'found_synonyms' => array(),
    );
    $this->assertSynonymsFind($meta_data, db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $synonym_term->name), 'on 2 fields with 2 values each searching for one of those values');

    $meta_data = array();
    $synonym_term = $this->createSynonymTerm();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('tid' => $synonym_term->tid),
        ),
      ),
      'found_synonyms' => array($synonym_term->name),
    );
    $this->assertSynonymsFind($meta_data, db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, '%' . db_like(drupal_substr($synonym_term->name, 1, -1)) . '%', 'LIKE'), 'on a field with a value searching for a string LIKE the %value%');

    $meta_data = array();
    $tag = $this->randomName();
    $synonym_term1 = $this->createSynonymTerm($tag . $this->randomName());
    $synonym_term2 = $this->createSynonymTerm($tag . $this->randomName());
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('tid' => $synonym_term1->tid),
          array('tid' => $synonym_term2->tid),
        ),
      ),
      'found_synonyms' => array($synonym_term1->name, $synonym_term2->name),
    );
    $this->assertSynonymsFind($meta_data, db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, db_like($tag) . '%', 'LIKE'), 'on a field with 2 similar values searching a string like %both values%');

    $meta_data = array();
    $synonym_term1 = $this->createSynonymTerm();
    $synonym_term2 = $this->createSynonymTerm();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('tid' => $synonym_term1->tid),
          array('tid' => $synonym_term2->tid),
        ),
      ),
      'found_synonyms' => array($synonym_term1->name, $synonym_term2->name),
    );
    $this->assertSynonymsFind($meta_data, db_or()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $synonym_term1->name)->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $synonym_term2->name), 'on a field with 2 values searching for value1 or value2');

    $meta_data = array();
    $synonym_term = $this->createSynonymTerm();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('tid' => $synonym_term->tid),
          array('tid' => $this->createSynonymTerm()->tid),
        ),
      ),
      'found_synonyms' => array($synonym_term->name),
    );
    $this->assertSynonymsFind($meta_data, db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $synonym_term->name)->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, '%' . db_like(drupal_substr($synonym_term->name, 1, -1)) . '%', 'LIKE'), 'on a field with 2 values searching for value1 and LIKE value1%');

    $meta_data = array();
    $synonym_term1 = $this->createSynonymTerm();
    $synonym_term2 = $this->createSynonymTerm();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('tid' => $synonym_term1->tid),
          array('tid' => $synonym_term2->tid),
        ),
      ),
      'found_synonyms' => array($synonym_term1->name, $synonym_term2->name),
    );
    $condition = db_or();
    $condition->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $synonym_term1->name);
    $condition->condition(db_and()
      ->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $synonym_term2->name)
      ->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, '%' . db_like(drupal_substr($synonym_term2->name, 1 -1)) . '%', 'LIKE'));
    $this->assertSynonymsFind($meta_data, $condition, 'on a field with 2 values searching for (value1 or (value2 AND value2%))');

    $meta_data =  array();
    $synonym_term1 = $this->createSynonymTerm($this->randomName() . ' ' . $this->randomName() . ' ' . $this->randomName());
    $synonym_term2 = $this->createSynonymTerm(str_replace(' ', '-', $synonym_term1->name));
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('tid' => $synonym_term1->tid),
          array('tid' => $synonym_term2->tid),
        ),
      ),
      'found_synonyms' => array($synonym_term1->name, $synonym_term2->name),
    );
    $condition = db_and()
      ->where("REPLACE(" . AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER . ", ' ', '-') = :synonym", array(
        ':synonym' => $synonym_term2->name,
      ));
    $this->assertSynonymsFind($meta_data, $condition, "on a field with 2 values, where 2nd value replaces spaces with dashes in the 1st value, searching for REPLACE(column, ' ', '-') = value2");
  }

  /**
   * Supportive function.
   *
   * Create a taxonomy term in the synonyms source vocabulary with the specified
   * name.
   *
   * @param string $name
   *   Name of the term to be created. If nothing is supplied a random string
   *   is used
   *
   * @return object
   *   Fully loaded taxonomy term object of the just created term
   */
  protected function createSynonymTerm($name = NULL) {
    if (is_null($name)) {
      $name = $this->randomName();
    }
    $synonym_term = (object) array(
      'name' => $name,
      'vid' => $this->vocabularySource->vid,
    );
    taxonomy_term_save($synonym_term);
    return $synonym_term;
  }
}

/**
 * Test EntityReferenceSynonymsBehavior class.
 */
class EntityReferenceSynonymsBehaviorWebTestCase extends AbstractSynonymsBehaviorWebTestCase {

  /**
   * GetInfo method.
   */
  public static function getInfo() {
    return array(
      'name' => 'EntityReferenceSynonymsBehavior',
      'description' => 'Ensure that the synonyms module extracts synonyms from entity reference fields correctly.',
      'group' => 'Synonyms',
    );
  }

  /**
   * SetUp method.
   */
  public function setUp($modules = array()) {
    $modules[] = 'entityreference';

    $this->fields['enabled']['field'] = array(
      'field_name' => 'reference',
      'cardinality' => FIELD_CARDINALITY_UNLIMITED,
      'type' => 'entityreference',
      // For the sake of experiment we use entityreference field that references
      // nodes of a Drupal standard type to make things easier.
      'settings' => array(
        'target_type' => 'node',
        'handler' => 'base',
        'handler_settings' => array(
          'target_bundles' => array('page' => 'page'),
          'sort' => array('type' => 'none'),
        ),
      ),
    );

    parent::setUp($modules);
  }

  /**
   * Test synonyms extraction for 'entityreference' field type.
   */
  public function testEntityReference() {
    // Testing synonymsExtract().
    $this->assertSynonymsExtract(array(), array(), 'on empty field.');

    $synonym_entity = $this->createNode();
    $this->assertSynonymsExtract(array(
      LANGUAGE_NONE => array(
        0 => array(
          'target_id' => entity_id('node', $synonym_entity),
        ),
      ),
    ), array(entity_label('node', $synonym_entity)), 'on a field that holds one value.');

    // Testing mergeEntityAsSynonym() method.
    $node = $this->createNode();
    $this->assertMergeEntityAsSynonym(array(), $node, 'node', array(array('target_id' => $node->nid)), 'on a node.');

    // Testing synonymFind() method.
    $this->assertSynonymsFind(array(), db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $this->randomName()), 'on empty field');

    $meta_data = array();
    $meta_data[] = array(
      'items' => array(),
      'found_synonyms' => array(),
    );
    $this->assertSynonymsFind($meta_data, db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $this->randomName()), 'on a field without values');

    $meta_data = array();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('target_id' => entity_id('node', $this->createNode())),
        ),
      ),
      'found_synonyms' => array(),
    );
    $this->assertSynonymsFind($meta_data, db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, $this->randomName()), 'on a field with a value but searching for another string');

    $meta_data = array();
    $synonym_entity = $this->createNode();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('target_id' => entity_id('node', $synonym_entity)),
        ),
      ),
      'found_synonyms' => array(entity_label('node', $synonym_entity)),
    );
    $this->assertSynonymsFind($meta_data, db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, entity_label('node', $synonym_entity)), 'on a field with a single value searching for that string');

    $meta_data = array();
    $synonym_entity = $this->createNode();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('target_id' => entity_id('node', $synonym_entity)),
          array('target_id' => entity_id('node', $this->createNode())),
        ),
      ),
      'found_synonyms' => array(entity_label('node', $synonym_entity)),
    );
    $this->assertSynonymsFind($meta_data, db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, entity_label('node', $synonym_entity)), 'on a field with 2 values searching for one of those 2 values');

    $meta_data = array();
    $synonym_entity = $this->createNode();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('target_id' => entity_id('node', $synonym_entity)),
          array('target_id' => entity_id('node', $this->createNode())),
        ),
      ),
      'found_synonyms' => array(entity_label('node', $synonym_entity)),
    );
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('target_id' => entity_id('node', $this->createNode())),
          array('target_id' => entity_id('node', $this->createNode())),
        ),
      ),
      'found_synonyms' => array(),
    );
    $this->assertSynonymsFind($meta_data, db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, entity_label('node', $synonym_entity)), 'on 2 fields with 2 values each searching for one of those values');

    $meta_data = array();
    $synonym_entity = $this->createNode();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('target_id' => entity_id('node', $synonym_entity)),
        ),
      ),
      'found_synonyms' => array(entity_label('node', $synonym_entity)),
    );
    $this->assertSynonymsFind($meta_data, db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, '%' . db_like(drupal_substr(entity_label('node', $synonym_entity), 1, -1)) . '%', 'LIKE'), 'on a field with a value searching for a string LIKE the %value%');

    $meta_data = array();
    $tag = $this->randomName();
    $synonym_entity1 = $this->createNode($tag . $this->randomName());
    $synonym_entity2 = $this->createNode($tag . $this->randomName());
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('target_id' => entity_id('node', $synonym_entity1)),
          array('target_id' => entity_id('node', $synonym_entity2)),
        ),
      ),
      'found_synonyms' => array(
        entity_label('node', $synonym_entity1),
        entity_label('node', $synonym_entity2),
      ),
    );
    $this->assertSynonymsFind($meta_data, db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, db_like($tag) . '%', 'LIKE'), 'on a field with 2 similar values searching a string like %both values%');

    $meta_data = array();
    $synonym_entity1 = $this->createNode();
    $synonym_entity2 = $this->createNode();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('target_id' => entity_id('node', $synonym_entity1)),
          array('target_id' => entity_id('node', $synonym_entity2)),
        ),
      ),
      'found_synonyms' => array(
        entity_label('node', $synonym_entity1),
        entity_label('node', $synonym_entity2),
      ),
    );
    $condition = db_or()
      ->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, entity_label('node', $synonym_entity1))
      ->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, entity_label('node', $synonym_entity2));
    $this->assertSynonymsFind($meta_data, $condition, 'on a field with 2 values searching for value1 or value2');

    $meta_data = array();
    $synonym_entity = $this->createNode();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('target_id' => entity_id('node', $synonym_entity)),
          array('target_id' => entity_id('node', $this->createNode())),
        ),
      ),
      'found_synonyms' => array(entity_label('node', $synonym_entity)),
    );
    $condition = db_and()
      ->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, entity_label('node', $synonym_entity))
      ->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, '%' . db_like(drupal_substr(entity_label('node', $synonym_entity), 1, -1)) . '%', 'LIKE');
    $this->assertSynonymsFind($meta_data, $condition, 'on a field with 2 values searching for value1 and LIKE value1%');

    $meta_data = array();
    $synonym_entity1 = $this->createNode();
    $synonym_entity2 = $this->createNode();
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('target_id' => entity_id('node', $synonym_entity1)),
          array('target_id' => entity_id('node', $synonym_entity2)),
        ),
      ),
      'found_synonyms' => array(
        entity_label('node', $synonym_entity1),
        entity_label('node', $synonym_entity2),
      ),
    );
    $condition = db_or()
      ->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, entity_label('node', $synonym_entity1))
      ->condition(db_and()->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, entity_label('node', $synonym_entity2))->condition(AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER, '%' . db_like(drupal_substr(entity_label('node', $synonym_entity2), 1, -1)) . '%', 'LIKE'));
    $this->assertSynonymsFind($meta_data, $condition, 'on a field with 2 values searching for (value1 or (value2 AND value2%))');

    $meta_data = array();
    $synonym_entity1 = $this->createNode($this->randomName() . ' ' . $this->randomName() . ' ' . $this->randomName());
    $synonym_entity2 = $this->createNode(str_replace(' ', '-', entity_label('node', $synonym_entity1)));
    $meta_data[] = array(
      'items' => array(
        LANGUAGE_NONE => array(
          array('target_id' => entity_id('node', $synonym_entity1)),
          array('target_id' => entity_id('node', $synonym_entity2)),
        ),
      ),
      'found_synonyms' => array(
        entity_label('node', $synonym_entity1),
        entity_label('node', $synonym_entity2),
      ),
    );
    $condition = db_and()
      ->where("REPLACE(" . AbstractSynonymsSynonymsBehavior::COLUMN_PLACEHOLDER . ", ' ', '-') = :synonym", array(
        ':synonym' => entity_label('node', $synonym_entity2),
      ));
    $this->assertSynonymsFind($meta_data, $condition, "on a field with 2 values, where 2nd value replaces spaces with dashes in the 1st value, searching for REPLACE(column, ' ', '-') = value2");
  }

  /**
   * Supportive function.
   *
   * Create an entity of necessary entity type (in our test it's node).
   *
   * @param string $label
   *   Label to use for the entity that is about to be created
   * @param string $bundle
   *   Bundle to use for the entity that is about to be created
   *
   * @return object
   *   Fully loaded entity object of the just created entity
   */
  protected function createNode($label = NULL, $bundle = 'page') {
    if (is_null($label)) {
      $label = $this->randomName();
    }
    $entity = (object) array(
      'type' => $bundle,
      'title' => $label,
    );
    node_save($entity);
    return $entity;
  }
}
