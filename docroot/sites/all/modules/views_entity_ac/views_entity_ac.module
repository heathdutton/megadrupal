<?php
  
/**
 * Implements hook_views_plugins()
 */
function views_entity_ac_views_plugins() {
  $plugins = array(
    'access' => array(
      'entity_ca' => array(
        'title' => t('Entity Access check'),
        'help' => t('this is an entity access plugin'),
        'handler' => 'views_entity_ac_access_plugin',
        'path' => drupal_get_path('module', 'plugins/views_entity_ac'),
        'uses options' => TRUE,
        'help topic' => 'entity-access-control',
      ),
    ),
  );
  return $plugins;
}

function views_entity_ac_access($entity_option = array(), $perm = array(), $account = NULL) {
  $access = FALSE;
  
  // TODO: Clean this mess up.
  $view_access = views_check_perm($perm[1][0], $account);
  
  // Get the current loaded page (our display and layout view need to be 
  // access controlled) so we need to figure out what sort of entity we 
  // have loaded and send proper access privs.
  $entity_option_array = explode('::', $entity_option);
  if (count($entity_option_array) > 1) {
    list($type, $name) = $entity_option_array;
  } else {
    $type = $entity_option_array[0];
  }
  
  // The the object type is a match or not, we deal with it.
  // The the name variable is empty, and we aren't dealing with a node
  // we need to send it down the pipe to the entities solutions.
  switch ($type) {
    case 'node':
      $object = &drupal_static(__FUNCTION__, NULL);
      if (!$object) {
        $object = node_load(arg(1));
      }
      if (!empty($name)) {
        
        if ($object->type == $name) {
          $access = TRUE && $view_access;
        }
      } else {
        $access = _views_entity_ac_check_entity($type, $object) && $view_access;
      }
      break;
    
    default:
      //TODO: We'll work on this section (for other entities) when the
      //      time comes. At present, we only care about NODES, so we'll
      //      work with those hard coded values.
    
      // Attempt to fetch the entity that is being viewed via a backtrace to the
      // field_attach_view($entity_type, $entity) function and parameters if found.
      // $backtrace = debug_backtrace();
      // foreach ($backtrace as $caller) {
      //   dd($caller['function'], 'BACK');
      //   if ($caller['function'] == 'field_attach_view') {
      //     $entity_type = $caller['args'][0];
      //     $entity = $caller['args'][2];
      //
      //     dd($entity_type, 'ENTITY_TYPE');
      //     dd($entity, 'ENTITY');
      //
      //   }
      // }
    
      //$wrapper = entity_metadata_wrapper('node', $object);
      // $entity_info = entity_get_info($object->type);
      // if ($entity_info) {
      //
      // }
  }
  
  
  return $access;
}

/**
 * Helper function to return a boolean value whether the entity is valid 
 */
function _views_entity_ac_check_entity($type, $object) {
  foreach (entity_get_info() as $entity_type => $entity_info) {
    if ($entity_type == $type) {
      foreach($entity_info['bundles'] as $bundle_system_name => $bundle) {
        if(($bundle_system_name && $type) == $object->type) {
          return TRUE;
        }
      }
    }
  }
  return FALSE;
}
