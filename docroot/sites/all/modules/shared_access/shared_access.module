<?php

/**
 * @file
 * Shared Access module file.
 */


/**
 * Modules should return this value from hook_shared_access() to allow access
 * to an entity.
 */
define('SHARED_ACCESS_ALLOW', 'allow');

/**
 * Modules should return this value from hook_shared_access() to deny access
 * to an entity.
 */
define('SHARED_ACCESS_DENY', 'deny');

/**
 * Modules should return this value from hook_shared_access() to not affect
 * entity access.
 */
define('SHARED_ACCESS_IGNORE', NULL);


/***************************************************************
 * Drupal core API hooks
 ***************************************************************/

/**
 * Implements hook_permission().
 */
function shared_access_permission() {
  return array(
    // Shared access field permissions
    'attach shared access fields' =>  array(
      'title' => t('Attach shared access fields'),
      'description' =>  t('A user with this permission can add shared access fields to an entity.'),
      'restrict access' => TRUE,
    ),
    'edit raw shared access values' =>  array(
      'title' => t('Edit raw shared access values'),
      'description' =>  t('Only grant to admins who know what they are doing. This permission allows the user to enter raw \'realm\', \'gid\', and \'op\' values.'),
      'restrict access' => TRUE,
    ),
    'administer any shared access field' => array(
      'title' => t('Administer any shared access field'),
      'description' =>  t('Allows a user to enter access and administer any shared access field on any entity.'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_menu().
 */
function shared_access_menu() {
  $items = array(
    'shared_access/usb/autocomplete/%/%/%' => array(
      'page callback' => 'shared_access_usb_autocomplete_callback',
      'page arguments' => array(3, 4, 5),
      'type' => MENU_CALLBACK,
      'access callback' => 'shared_access_autocomplete_access_callback',
    ),
  );
  return $items;
}

/**
 * Implements hook_menu_alter().
 *
 * If we want to be able to control who has access to user accounts then we
 * need to override the respective menu access callbacks defined by the user
 * module.
 */
function shared_access_menu_alter(&$items) {
  // Override user view, edit and cancellation access callbacks if the user
  // entity has an attached shared_access field.
  if (module_exists('user') && ($fields = get_shared_access_fields())) {
    $user_fields = field_info_instances('user', 'user');
    if (array_intersect_key($fields, $user_fields)) {
      // View user account.
      $items['user/%user']['access arguments'] = array('view', 1, $items['user/%user']['access callback']);
      $items['user/%user']['access callback'] = '_shared_access_user_access';
      // Edit user account.
      $items['user/%user/edit']['access arguments'] = array('update', 1, $items['user/%user/edit']['access callback']);
      $items['user/%user/edit']['access callback'] = '_shared_access_user_access';
      // Cancel user account.
      $items['user/%user/cancel']['access arguments'] = array('delete', 1, $items['user/%user/cancel']['access callback']);
      $items['user/%user/cancel']['access callback'] = '_shared_access_user_access';
      // Cancel confirm user account.
      $items['user/%user/cancel/confirm/%/%']['access arguments'] = array('delete', 1, $items['user/%user/cancel/confirm/%/%']['access callback']);
      $items['user/%user/cancel/confirm/%/%']['access callback'] = '_shared_access_user_access';
    }
  }
}

/**
 * Implements hook_theme().
 */
function shared_access_theme() {
  // Find path to the theme direcotry for the shared_access module.
  $path = drupal_get_path('module', 'shared_access') . '/theme';

  $theme_info = array(
    // Define a theme template file used to display the sharing settings form.
    'shared_access' => array(
      'variables' => array('grants' => NULL,),
      'template' => 'shared_access',
      'pattern' => 'shared_access__',
      'path' => $path,
    ),
    'shared_access_summary' => array(
      'variables' => array('op' => null, 'realm' => null, 'gid' => null, 'gstr' => null),
      'file' => 'includes/shared_access.theme.inc',
    ),
    'sa_table' =>array(
      'variables' => array('header' => array(), 'rows' => array(), 'attributes' => array(), 'caption' => null, 'colgroups' => array(), 'sticky' => FALSE, 'empty' => null, 'tbodys' => array()),
      'file' => 'includes/shared_access.theme.inc',
    ),
    'sa_table_container' => array(
      'render element' => 'element',
      'file' => 'includes/shared_access.theme.inc',
    ),
    'sa_item_title' => array(
      'variables' => array('element' => NULL, 'item' => NULL),
      'file' => 'includes/shared_access.theme.inc',
      'pattern' => 'sa_item_title__',
    ),
  );

  // Load theme information from available shared access realms.
  foreach(shared_access_get_realms() as $realm => $ignore){
    if ($class = shared_access_get_access_controllers($realm)) {
      $theme_info += $class::theme();
    }
  }

  return $theme_info;
}

/**
 * Implements hook_module_implements_alter().
 *
 * Hopefully ensure that our implementation of hook_entity_info_alter() is
 * called after the entity module so we can override the access callbacks on
 * some entities.
 */
function shared_access_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'entity_info_alter') {
    // Move shared_access_entity_info_alter() to the end of the list.
    // module_implements() iterates through $implementations with a foreach loop
    // which PHP iterates in the order that the items were added, so to move an
    // item to the end of the array, we remove it and then add it.
    $group = $implementations ['shared_access'];
    unset($implementations ['shared_access']);
    $implementations ['shared_access'] = $group;
  }
}

/**
 * Implements hook_entity_info_alter().
 */
function shared_access_entity_info_alter(&$entity_info) {
  if ($fields = get_shared_access_fields()) {
    // Override the access callback given to the user entity by the entity API.
    if (module_exists('user')) {
      $user_fields = field_info_instances('user', 'user');
      if (array_intersect_key($fields, $user_fields)) {
        $entity_info['user']['shared_access']['access callback'] = $entity_info['user']['access callback'];
        $entity_info['user']['shared_access']['keep'] = TRUE;
        $entity_info['user']['access callback'] = 'shared_access_entity_access_callback';
      }
    }
  }
}


/***************************************************************
 * Field API hooks
 ***************************************************************/

/**
 * Implements hook_field_info().
 *
 * Provides the definition for the shared_access field.
 */
function shared_access_field_info() {
  return array(
    // We name our field as the associative name of the array.
    'shared_access' => array(
      'label' => t('Shared Access'),
      'description' => t('Adds the ability to control access to the entities attached to the field.'),
      'default_widget' => 'shared_access_none',
      'default_formatter' => 'shared_access_button',
      'settings' => array('ops' => array()),
      'instance_settings' => array('realms' => array()),
      // Entity API additions.
      // @see entity_hook_field_info().
      'property_type' => 'shared_access',
      'property_callbacks' => array('shared_access_property_info_callback'),
    ),
  );
}

/**
 * Implements hook_field_settings_form().
 *
 * Provides the global settings form for a shared_access field. Namely the 'ops'
 * setting which determines what operations are affected by this shared access
 * field.
 */
function shared_access_field_settings_form($field, $instance, $has_data) {
  $settings = $field['settings'];

  $ops = array();
  foreach ($ops = shared_access_get_ops() as $op => $info) {
    $options[$op] = $info['label'];
  }

  if ($ops) {
    $field_name_css = strtr($field['field_name'], '_', '-');
    asort($options);
    $op_descriptions = '<ul class="shared-access shared-access-ops shared-access-ops-' . $field_name_css . '">';
    foreach ($options as $op => $label) {
      $op_descriptions .= '<li class="shared-access shared-access-op shared-access-op-' . $field_name_css . ' shared-access-op-' . $op  . ' shared-access-op-' . $field_name_css . '-' . $op .'" >' . $label . ': ' . $ops[$op]['description'] . '</li>';
    }
    $op_descriptions .= '</ul>';
  }

  // TODO: Only show checkboxes for those that have not yet been checked and
  //       display the ones that have with a separate table and ability to delete
  //       through a confirmation process.
  $form['ops'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Enabled operations'),
    '#default_value' => $settings['ops'],
    '#options' => $options,
    '#description' => $op_descriptions,
  );

  return $form;
}

/**
 * Implements hook_field_instance_settings_form().
 *
 * Provides the instance settings form for a shared_access field.
 */
function shared_access_field_instance_settings_form($field, $instance) {
  $settings = $instance['settings'];

  $realm_options = array();
  foreach ($realms = shared_access_get_realms() as $realm => $info) {
    $realm_options[$realm] = $info['title'];
  }

  if ($realm_options) {
    $field_name_css = strtr($field['field_name'], '_', '-');
    asort($realm_options);
    $realm_descriptions = '<ul class="shared-access realm-ops realm-ops-' . $field_name_css . '">';
    foreach ($realm_options as $realm => $title) {
      $realm_descriptions .= '<li class="shared-access realm-op realm-op-' . $field_name_css . ' realm-op-' . $realm  . ' realm-op-' . $field_name_css . '-' . $realm .'" >' . $title . ': ' . $realms[$realm]['description'] . '</li>';
    }
    $realm_descriptions .= '</ul>';
  }

  // TODO: Only show checkboxes for those that have not yet been checked and
  //       display the ones that have with a separate table and ability to delete
  //       through a confirmation process.
  $form['realms'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Enabled access realms'),
    '#default_value' => $settings['realms'],
    '#options' => $realm_options,
    '#description' => $realm_descriptions,
  );

  $enabled_realms = array_filter($settings['realms']);
  foreach(array_intersect_key(shared_access_get_implementing_controllers('SharedAccessControllerSettingsInterface'), $enabled_realms) as $realm => $controller) {
    $form[$realm] = array(
      '#type' => 'fieldset',
      '#title' => t('@realm realm settings', array('@realm' => $realm)),
    );
    $form[$realm] += $controller->field_instance_settings($field, $instance);
  }

  return $form;
}

/**
 * Implements hook_field_formatter_info().
 *
 * Defines the formatters used to display the shared access settings form.
 */
function shared_access_field_formatter_info() {
  return array(
    'shared_access_embedded' => array(
      'label' => t('Embedded form'),
      'description' => t('Displays the shared access settings form within the content of the entity display.'),
      'field types' => array('shared_access'),
      'settings' => array('label' => '', 'wrapper_type' => ''),
    ),
    'shared_access_button' => array(
      'label' => t('Share Button'),
      'description' => t('Uses a button/link to take the admin to a shared access settings <em>modal form</em> or a separate <em>page</em>.'),
      'field types' => array('shared_access'),
      'settings' => array('label' => '', 'modal' => 1),
    ),
  );
}

/**
 * Implements hook_field_formatter_settings_form().
 *
 * Provides the formatter settings form for a shared_access field.
 */
function shared_access_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $element = array(
    'label' => array(
      '#type' => 'textfield',
      '#title' => t('Label'),
      '#size' => 15,
      '#description' => t('The text to use as the label for the share button/link or embedded form.'),
      '#default_value' => (!empty($settings['label'])) ? $settings['label'] : $instance['label'],
    ),
  );

  if ($display['type'] == 'shared_access_button') {
    $element['modal'] = array(
      '#type' => 'checkbox',
      '#title' => t('Use a modal form'),
      '#default_value' => (!empty($settings['modal'])) ? $settings['modal'] : 1,
      '#description' => t('Display the shared access settings form using a Ctools modal form.'),
    );
  } elseif ($display['type'] == 'shared_access_embedded') {
    $element['wrapper_type'] = array(
      '#type' => 'radios',
      '#title' => t('Embedded form wrapper'),
      '#options' => array(
        ''          => t('None'),
        'collapsed' => t('Collapsible (collapsed by default)'),
        'expanded'  => t('Collapsible (expanded by default)'),
      ),
      '#default_value' => (!empty($settings['wrapper_type'])) ? $settings['wrapper_type'] : '',
      '#description' => t('Choose the wrapper type for the embedded shared access form.'),
    );
  }

  return $element;

}

/**
 * Implements hook_field_formatter_settings_summary().
 *
 * Settings summary on entity 'display settings' pages for shared_access fields.
 */
function shared_access_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $summary = t('Label: ') . ((!empty($settings['label'])) ? $settings['label'] : $instance['label']) . '&nbsp;|&nbsp;';

  if ($display['type'] == 'shared_access_button') {
    $summary .= t('Use a modal form: ') . ((!isset($settings['modal']) || $settings['modal']) ? t('Yes') : t('No'));
  } elseif ($display['type'] == 'shared_access_embedded') {
    $options = array(
        ''          => t('None'),
        'collapsed' => t('Collapsible (collapsed by default)'),
        'expanded'  => t('Collapsible (expanded by default)'),
    );
    $summary .= t('Embedded form wrapper: ') . ((!empty($settings['wrapper_type'])) ? $options[$settings['wrapper_type']] : 'None');
  }

  return $summary;
}

/**
 * Implements hook_field_formatter_prepare_view().
 *
 * Alters the $items parameter for displays of the field using the
 * 'shared_access_button' and 'shared_access_embedded' formatters to always have
 * one item for display which will be the shared access settings form.
 *
 * The original $items list of field values is propagated forward as
 * $items[0]['items'].
 */
function shared_access_field_formatter_prepare_view($entity_type, $entities, $field, $instances, $langcode, &$items, $displays) {
  // multiples keyed by entity id, so we have to iterate over them individually.
  foreach ($displays as $entity_id => $display) {
    switch ($display['type']) {
      case 'shared_access_button':
      case 'shared_access_embedded':
        // Always have one item.
        $items[$entity_id] = array(
          0 => array('items' => $items[$entity_id]),
        );
      default:
        continue;
    }
  }
}

/**
 * Implements hook_field_formatter_view().
 *
 * Determines how our shared access fields should be displayed depending on the
 * field display settings
 * configured on a particular entity bundle's display settings tab.
 */
function shared_access_field_formatter_view($object_type, $object, &$field, $instance, $langcode, $items, $display) {
  $element = array();
  switch ($display['type']) {
    case 'shared_access_button':
      foreach ($items as $delta => $item) {
        $element[$delta]['#type'] = 'markup';
        $element[$delta]['#markup'] = '<div class="shared-access-modal">MODAL DISPLAY</div>';
      }
      break;
    case 'shared_access_embedded':
      foreach ($items as $delta => $item) {
        $form_state = array(
          'build_info' => array(
            'args' => array($object_type, $object, $field, $instance, $langcode, $items, $display),
            ),
        );
        form_load_include($form_state, 'inc', 'shared_access', 'includes/classes.shared_access');

        $element[$delta] = array(
          '#type' => 'fieldset',
          '#title' => $display['settings']['label'],
          '#attributes' => array(
            'class' => array(),
          ),
          'settings_wrapper' => drupal_build_form('shared_access_form', $form_state),
        );
        switch($display['settings']['wrapper_type']) {
          case 'collapsed' :
            $element[$delta]['#attributes']['class'][] = 'collapsed';
          case 'expanded' :
            $element[$delta]['#attributes']['class'][] = 'collapsible';
            $element[$delta]['#attached'] = array(
              'js' => array(
                'misc/form.js',
                'misc/collapse.js',
              ),
            );
        }
        //$element[$delta]['#type'] = 'markup';
        //$element[$delta]['#markup'] = '<div class="shared-access-basic">BASIC DISPLAY</div>';
      }
      break;
  }
  return $element;
}

function shared_access_form($form, $form_state, $entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  //$vars = array('form' => $form, 'form_state' => $form_state, 'entity_type' => $entity_type, 'entity' => $entity, 'field' => $field, 'instance' => $instance, 'langcode' => $langcode, 'items' => $items, 'display' => $display);
  //dsm($vars, 'shared_access_form: vars');
  global $user;

  $field_items = (isset($items[0]['items'])) ? $items[0]['items'] : $items;
  list($entity_id,, $bundle) = entity_extract_ids($entity_type, $entity);
  // Store relevant info in the form.
  $form['#entity_type'] = $entity_type;
  $form['#bundle'] = $bundle;
  $form['#entity_id'] = $entity_id;
  $form['#field'] = $field;
  $form['#instance'] = $instance;
  $form['#langcode'] = $langcode;
  $form['#items'] = $field_items;
  $form['#display'] = $display;
  $form['#account'] = $user->uid; // for validation.

  $enabled_realms = array_filter($instance['settings']['realms']);

  // Use a container with custom process and theme callbacks to build the shared
  // access table.
  // see theme_sa_table() for how the container parameters are used.
  $form['share_table'] = array(
    '#type' => 'container',
    '#process' => array('form_process_sa_table_container'),
    '#theme' => 'sa_table_container',
    '#tree' => TRUE,
    '#title' => t('Who has access'),
    '#header' => array(),
    '#empty' => t('You have not shared this yet ...'),
    // Set up some classes for columns.
    '#colgroups' => array(
      array(
        'class' => 'sa-shared-col-item',
        'data' => array(
          array(
            'class' => array('sa-shared-col-item-icon'),
          ),
          array(
            'class' => array('sa-shared-col-item-title'),
          ),
          array(
            'class' => array('sa-shared-col-item-ops'),
          ),
          array(
            'class' => array('sa-shared-col-item-extra'),
          ),
        ),
      ),
    ),
    '#tbodys' => array(),
    '#entity_type' => $entity_type,
    '#bundle' => $bundle,
    '#entity_id' => $entity_id,
    '#field' => $field,
    '#instance' => $instance,
    '#langcode' => $langcode,
    '#items' => $field_items,
    '#display' => $display,
    '#account' => $user->uid,
    '#realms' => $enabled_realms,
  );

  // Add a universal sharing text box that controllers may choose to use.
  $form['universal_share_box'] = array(
    '#tree' => TRUE,
    '#type' => 'fieldset',
    '#attributes' => array('class' => array('shared-access-universal')),
    '#access' => FALSE,        // Hide this for starters. Controllers that want to use
    '#share_types' => array(), // it can enable it by adding to the #share_types.
  );
  // Prepare the autocomplete path.
  $autocomplete_path = 'shared_access/usb/autocomplete/' . $field['field_name'] . '/' . $instance['entity_type'] . '/' . $instance['bundle'];
  $form['universal_share_box']['share_box'] = array(
    '#title' => 'Add people',
    '#type' => 'textfield',
    '#default_value' => (!empty($form_state['values']['universal_share_box']['share_box'])) ? $form_state['values']['universal_share_box']['share_box'] : '',
    '#size' => 80,
    '#maxlength' => 1000,
    '#attributes' => array('class' => array('shared-access-universal')),
    '#autocomplete_path' => $autocomplete_path,
  );
  $options = array();
  foreach ($ops = shared_access_get_ops() as $op => $info) {
    if (!empty($field['settings']['ops'][$op])) $options[$op] = $info['label'];
  }
  $form['universal_share_box']['op'] = array(
    '#type' => 'select',
    '#default_value' => (!empty($form_state['values']['universal_share_box']['op'])) ? $form_state['values']['universal_share_box']['op'] : '',
    '#options' => $options,
    '#attributes' => array('class' => array('shared-access-universal')),
  );

  foreach(array_intersect_key(shared_access_get_implementing_controllers('SharedAccessShareFormInterface'), $enabled_realms) as $realm => $controller) {
      $controller->share_form($form, $form_state);
  }

  if (!empty($form['universal_share_box']['#share_types'])){
    $hints = array_values($form['universal_share_box']['#share_types']);
    if (count($hints) > 1) {
      $last_hint = array_pop($hints);
      $placeholder = t('Enter @hints, or @last.', array('@hints' =>  implode( ', ' , $hints ), '@last' => $last_hint));
    } else {
      $placeholder = t('Enter @hint.', array('@hint' =>  $hints[0]));
    }
    // Set the placeholder text.
    $form['universal_share_box']['share_box']['#attributes'] += array('placeholder' => $placeholder);
    // Make sure the box shows up.
    $form['universal_share_box']['#access'] = TRUE;
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Share and save'),
  );

  return $form;
}

function form_process_sa_table_container($element, &$form_state) {
  // Generate the ID of the element if it's not explicitly given.
  if (!isset($element['#id'])) {
    $element['#id'] = drupal_html_id(implode('-', $element['#parents']) . '-wrapper');
  }

  // Add item elements to define rows for the shared_access table.
  foreach(array_intersect_key(shared_access_get_access_controllers(), $element['#realms']) as $realm => $controller) {
      $controller->sa_table_process($element, $form_state);
  }

  return $element;
}


function shared_access_form_submit($form, &$form_state) {
  // We want the un-altered version of the entity so load it from the db.
  $entity = entity_load_unchanged($form['#entity_type'], $form['#entity_id']);
  // Some field modules require the original parameter to be set.
  $entity->original = $entity;

//  dsm((array)$entity, 'shared_access_form_submit: entity');
//  dsm($form_state, 'shared_access_form_submit: form_state');
//  dsm($form, 'shared_access_form_submit: form');

  // Extract some info stored in the form.
  $langcode = $form['#langcode'];
  $field = $form['#field'];
  $items = $form['#items'];

  // Only change the settings if the field has realms enabled.
  if (!empty($form['#instance']['settings']['realms'])) {
    $instance = $form['#instance'];
    $realm_tags = array('unprocessed' => array());
    $enabled_realms = array_filter($form['#instance']['settings']['realms']);

    foreach(array_intersect_key(shared_access_get_implementing_controllers('SharedAccessShareFormInterface'), $enabled_realms) as $realm => $controller) {
      $controller->share_form_process($form, $form_state, $items);
    }

    if ($form['universal_share_box']['#access'] && !empty($form['universal_share_box']['#share_types'])) {
      $op = $form_state['values']['universal_share_box']['op'];
      $unprocessed_tags = array();
      if (!empty($form_state['values']['universal_share_box']['share_box'])) {
        $tags_selected = drupal_explode_tags($form_state['values']['universal_share_box']['share_box']);
        foreach ($tags_selected as $selection) {
          if ($tags = explode(': ', $selection)) {
            if (count($tags) == 2) {
              list($key, $tag) = $tags;
              // This could lead to non-realm tags but that is okay.
              $realm_tags[$key][] = $tag;
            } else {
              // Not sure who these belong to so go through these after.
              $realm_tags['unprocessed'][] = $selection;
            }
          }
        }
        // Loop over the realms that use the usb and let them manipulate items.
        foreach (array_keys($form['universal_share_box']['#share_types']) as $realm) {
          if ($controller = shared_access_get_access_controllers($realm)) {
            $controller->process_usb_tags($op, $items, $realm_tags);
          }
        }
      }
    }
    // Save the updated field values.
    if (isset($entity->{$field['field_name']})) {
      $entity->{$field['field_name']}[$langcode] = $items;
      field_attach_update($form['#entity_type'], $entity);
    }
  }
}

// TODO: Add access stuff here.
function shared_access_autocomplete_access_callback() {
  return TRUE;
}

/**
 * Menu callback: autocomplete the universal share box.
 *
 * @param $field_name
 *   The name of the shared_access field.
 * @param $entity_type
 *   The entity type.
 * @param $bundle_name
 *   The bundle name.
 * @param $string
 *   The label of a particular realm to query.
 */
function shared_access_usb_autocomplete_callback($field_name, $entity_type, $bundle_name, $string = '') {
  $field = field_info_field($field_name);
  $instance = field_info_instance($entity_type, $field_name, $bundle_name);
  $matches = array();

  // The user enters a comma-separated list. We only autocomplete the last one.
  $tags_typed = drupal_explode_tags($string);
  $tag_last = drupal_strtolower(array_pop($tags_typed));
  if (!empty($tag_last)) {
    $prefix = count($tags_typed) ? implode(', ', $tags_typed) . ', ' : '';
  }

  $enabled_realms = array_filter($instance['settings']['realms']);

  foreach(array_intersect_key(shared_access_get_implementing_controllers('SharedAccessUniversalShareBoxInterface'), $enabled_realms) as $realm => $controller) {
    $matches += $controller->share_usb_autocomplete($field, $instance, $entity_type, $bundle_name, $tag_last, $prefix);
  }

  drupal_json_output($matches);
}

/**
 * Implements hook_field_widget_info().
 *
 * Define widgets for different methods of displaying the field in the entity
 * bundle edit pages.
 *
 * We provide 3 options out of the box:
 *
 *    - Display nothing: Do not display anything for the field on the edit page.
 *    - Summary of access granted: Summarizes the configured shared access
 *      grants that have been configured for the entity.
 *    - Sharing settings form: A form to configure the shared access for the
 *      entity.
 *
 * These widget types will eventually show up in hook_field_widget_form,
 * where we will have to flesh them out.
 *
 * @see hook_field_widget_info()
 * @see shared_access_field_widget_form()
 */
function shared_access_field_widget_info() {
  return array(
    'shared_access_none' => array(
      'label' => t('Hidden'),
      'field types' => array('shared_access'),
    ),
    'shared_access_summary' => array(
      'label' => t('Summary of access granted'),
      'field types' => array('shared_access'),
    ),
    'shared_access_settings' => array(
      'label' => t('Sharing settings form'),
      'field types' => array('shared_access'),
    ),
  );
}


/**
 * Implements hook_field_widget_form().
 *
 */
function shared_access_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  //$values=array('form' => $form, 'form_state' => $form_state, 'field' => $field, 'instance' => $instance, 'langcode' => $langcode, 'items' => $items, 'delta' => $delta, 'element' => $element);
  //dsm($values, 'shared_access_field_widget_form');

  $gid = isset($items[$delta]['gid']) ? $items[$delta]['gid'] : '';
  $gstr = isset($items[$delta]['gstr']) ? $items[$delta]['gstr'] : '';
  $realm = isset($items[$delta]['realm']) ? $items[$delta]['realm'] : '';
  $op = isset($items[$delta]['op']) ? $items[$delta]['op'] : '';

  $widget = $element;

  if (isset($element['#entity'])) {
    if (!isset($element['#entity']->shared_access_widget)) {
      $element['#entity']->shared_access_widget = array();
    }
    if (!isset($element['#entity']->shared_access_widget[$field['field_name']])) {
      $element['#entity']->shared_access_widget[$field['field_name']] = $instance['widget'];
    }
  }

  switch ($instance['widget']['type']) {
    case 'shared_access_summary':
      $summary = (!isset($delta) || empty($items[$delta]) || shared_access_field_is_empty($items[$delta], $field)) ? t('Empty access setting') : theme('shared_access_summary', $items[$delta]);
      $element['summary'] = array(
        '#type' => 'markup',
        '#markup' => $summary,
        '#weight' => 2,
      );
      if (!empty($element['#entity'])) {
        foreach ($field['columns'] as $column => $structure) {
          $element[] = array(
            '#type' => 'hidden',
            '#default_value' => isset(${$column}) ? ${$column} : NULL,
          );
        }
        break;
      }
    case 'shared_access_none':
    case 'shared_access_settings':
    default:
      $ops = shared_access_get_field_ops($field);
      $element += array(
        'realm' => array(
          '#title' => t('Realm'),
          '#description' => t('The realm defines what type of access is being granted. Most of the time this is an entity type. So a realm of \'user\' is granting access to the given operation to a user whose uid matches the respectively entered gid.'),
          '#type' => 'textfield',
          '#default_value' => $realm,
          '#size' => 60,
          '#maxlength' => 255,
          '#element_validate' => array('_shared_access_realm_validate'),
          '#weight' => 1,
        ),
        'op' => array(
          '#type' => 'select',
          '#title' => t('Operation'),
          '#default_value' => $op,
          '#options' => $ops,
          '#empty_option' => '-none-',
          '#description' => t('The operation for which access is being granted.'),
          '#element_validate' => array('_shared_access_op_validate'),
        ),
        'gid' => array(
          '#title' => t('Grant Id'),
          '#description' => t('The id of the entity or custom identifier that is being granted access to the configured operation.'),
          '#type' => 'textfield',
          '#default_value' => $gid,
          '#size' => 60,
          '#maxlength' => 255,
          '#element_validate' => array('_shared_access_gid_validate'),
          '#weight' => 1,
        ),
        'gstr' => array(
          '#title' => t('Grant String'),
          '#description' => t('Optional: string identifier that is being granted access to the configured operation.'),
          '#type' => 'textfield',
          '#default_value' => $gstr,
          '#size' => 60,
          '#maxlength' => 255,
          '#element_validate' => array('_shared_access_gstr_validate'),
          '#weight' => 1,
        ),
      );
  }

  return $element;
}


/**
 * Implements hook_field_access. This is actually called after the
 * shared_access_field_widget_form() function. So we'll take advantage
 * of that fact to pass in the widget info.
 *
 * We need to limit access to this field for several reasons:
 *
 *   1. If the 'hidden' widget type is chosen, then we do not want this field to
 *      show up on the edit page for the entity.
 *   2. Only users with admin sharing privileges should see the shared_access
 *      forms when viewing this entity.
 */
function shared_access_field_access($op, $field, $entity_type, $entity, $account) {
  if ('shared_access' != $field['type']) return;
  //$vars = array('op' => $op, 'field' => $field, 'entity_type' => $entity_type, 'entity' => $entity, 'account' => $account);
  //dsm($vars, 'shared_access_field_access');

  // 1. Don't show if its a hidden widget.
  if ($op == 'edit' && !empty($entity) && !empty($entity->shared_access_widget[$field['field_name']]['type']) && ('shared_access_none' == $entity->shared_access_widget[$field['field_name']]['type'])) {
    // Stop users from editing their shared_access fields on entity edit forms.
    return FALSE;
  }

  // 2. Only display the field if the user account has admin access.
  return (user_access('administer any shared access field', $account) || shared_access('admin', $entity_type,  $entity, $account));
}


// Widget form validation functions


/**
 * Validation callback for the grant id input from the shared access form.
 */
function _shared_access_gid_validate($element, &$form_state) {
  return TRUE;
}

/**
 * Validation callback for the optional grant string input from the shared
 * access form.
 */
function _shared_access_gstr_validate($element, &$form_state) {
  return TRUE;
}

/**
 * Validation callback for the realm input from the shared access form.
 */
function _shared_access_realm_validate($element, &$form_state) {
  return TRUE;
}

/**
 * Validation callback for the operation being granted.
 */
function _shared_access_op_validate($element, &$form_state) {
  return TRUE;
}


/**
 * Implements hook_field_is_empty.
 */
function shared_access_field_is_empty($item, $field) {
  return (empty($item['realm']) || empty($item['gid']) || empty($item['op']));
}

/**
 * Callback to alter the property info of address fields.
 *
 * @see shared_access_field_info().
 */
function shared_access_property_info_callback(&$info, $entity_type, $field, $instance, $field_type) {
  $name = $field['field_name'];
  $property = &$info[$entity_type]['bundles'][$instance['bundle']]['properties'][$name];

  $property['type'] = ($field['cardinality'] != 1) ? 'list<shared_access>' : 'shared_access';
  $property['getter callback'] = 'entity_metadata_field_verbatim_get';
  $property['setter callback'] = 'entity_metadata_field_verbatim_set';

  $property['property info'] = array(
    'op' => array(
      'type' => 'token',
      'label' => t('Operation'),
      'options list' => 'shared_access_get_field_ops',
      'setter callback' => 'entity_property_verbatim_set',
      'getter callback' => 'entity_property_verbatim_get',
    ),
    'realm' => array(
      'type' => 'token',
      'label' => t('Realm'),
      'options list' => 'shared_access_get_field_realms',
      'setter callback' => 'entity_property_verbatim_set',
      'getter callback' => 'entity_property_verbatim_get',
    ),
    'gstr' => array(
      'type' => 'text',
      'label' => t('Grant string'),
      'sanitized' => TRUE,
      'getter callback' => 'entity_metadata_field_text_get',
      'setter callback' => 'entity_property_verbatim_set',
      'raw getter callback' => 'entity_property_verbatim_get',
    ),
    'gid' => array(
      'type' => 'integer',
      'label' => t('Grant Id'),
      'getter callback' => 'entity_metadata_field_text_get',
      'setter callback' => 'entity_property_verbatim_set',
      'raw getter callback' => 'entity_property_verbatim_get',
    ),
  );

  // Enable auto-creation of the item, so that it is possible to just set
  // some of the properties.
  $property['auto creation'] = 'entity_property_create_array';

  unset($property['query callback']);
}


/***************************************************************
 * Query hooks
 ***************************************************************/

/**
 *
/**
 * Implements hook_query_TAG_alter().
 *
 * This function implements the same functionality as
 * node_query_node_access_alter() for the SQL field storage engine. Node access
 * conditions are added for field values belonging to nodes only.
 */
function shared_access_query_entity_field_access_alter($query) {
  //dsm($query, 'shared_access_query_entity_field_access_alter');
}

function shared_access_field_storage_query($query) {
  //dsm($query, 'shared_access_field_storage_query');
}

function shared_access_query_alter($query) {
  if (!empty($query->alterTags)) {
    //dsm($query->alterTags, 'alterTags');
    $base_table = $query->getMetaData('base table');
    //dsm($base_table, 'shared_access_query_alter');
  }
}


/***************************************************************
 * Access functions
 ***************************************************************/

/**
 * Returns information about shared_access type fields.
 *
 * @param $field_name
 *   Optional: if a non empty value is passed in then the return value is an
 *   array containing information for that field specifically. If empty then all
 *   shared_access fields are returned.
 *
 * @return
 *   An array containing shared_access field information indexed by the field
 *   name, or information for a specific shared_access field.
 */
function get_shared_access_fields($field_name = '') {
  $fields = &drupal_static(__FUNCTION__);

  if (!isset($fields)) {
    $fields = field_read_fields(array('type' => 'shared_access'));
  }

  if (!empty($field_name)) {
    if (isset($fields[$field_name])) return $fields[$field_name];
    return array();
  }
  return $fields;
}

/**
 * Get information for all the available shared_access realms.
 *
 * @param $realm
 *   The realm, e.g. user, for which the info shall be returned, or NULL
 *   to return an array with info about all realms.
 *
 * @see hook_shared_access_realms()
 * @see hook_shared_access_realms_alter()
 */
function shared_access_get_realms($realm = NULL) {
  // Use the advanced drupal_static() pattern, since this could be called often.
  static $drupal_static_fast;
  if (!isset($drupal_static_fast)) {
    $drupal_static_fast['shared_access_realms'] = &drupal_static(__FUNCTION__);
  }
  $shared_access_realms = &$drupal_static_fast['shared_access_realms'];

  if (empty($shared_access_realms)) {
    foreach (module_implements('shared_access_realms') as $module) {
        $module_realms = (array) module_invoke($module, 'shared_access_realms');
        foreach ($module_realms as $key => $realm_info) {
          // Provide defaults.
          $realm_info += array(
            'title' => t($key),
            'description' => '',
            'file' => FALSE,
          );
          $shared_access_realms[$key] = $realm_info;
          $shared_access_realms[$key]['module'] = $module;
        }
      }
    // Let other modules alter the shared access info.
    drupal_alter('shared_access_realms', $shared_access_realms);
  }

  if (empty($realm)) {
    return $shared_access_realms;
  }
  elseif (isset($shared_access_realms[$realm])) {
    return $shared_access_realms[$realm];
  }
}

/**
 * Get a list of the available shared_access realms as an options array.
 *
 * @return
 *   An options list of realms.
 */
function shared_access_get_field_realms($instance = NULL) {
  if (!$instance) return array();

  $enabled_realms = array();
  // For entity api and rule handling $instance receives either 'edit' or 'view'
  // so in these cases we want to return all possible operations configured for
  // all shared_access fields since we have no way of determining field
  // instance specific settings.
  if (is_scalar($instance)) {
    foreach (field_info_field_map() as $field_name => $field_map_info) {
      if ($field_map_info['type'] == 'shared_access') {
        foreach ($field_map_info['bundles'] as $entity_type => $bundles) {
          foreach ($bundles as $bundle) {
            $field_instance = field_info_instance($entity_type, $field_name, $bundle);
            if ($field_instance && !empty($field_instance['settings']['realms'])) {
              $enabled_realms += array_filter($field_instance['settings']['realms']);
            }
          }
        }
      }
    }
  }
  // Field instance specific settings have been passed in so only return the
  // realms allowed for this field instance.
  elseif (isset($instance['settings']['realms'])) {
    $enabled_realms = array_filter($instance['settings']['realms']);
  }

  $options = array();
  foreach (shared_access_get_realms() as $realm => $info) {
    if (!empty($enabled_realms[$realm])) {
      $options[$realm] = $info['title'];
    }
  }
  return $options;
}

/**
 * Implements hook_shared_access_realms().
 *
 * @return
 *   A structured array of the default access realms supplied by
 *   the shared access module. This includes:
 *
 *     - user: Access can be granted to individual users of the site.
 *     - group: Access can be granted based on Organic Group membership.
 *     - mail: Access can be granted to anonymous users through links sent to
 *             email addresses.
 *     - domain: Access can be granted to anyone who has an email address from a
 *               specific domain.
 *
 * @see hook_shared_access_realms().
 * @see shared_access_get_realms().
 * @see hook_shared_access_realms_alter().
 */
function shared_access_shared_access_realms() {
  $shared_access_realms = array(
    'owner' => array(
      'title' => t('Owner rights'),
      'description' => t('Controls ownership of an entity.'),
      'access controller' => 'OwnerSharedAccessController',
      'file' => 'includes/shared_access.classes.inc',
    ),
    'user' => array(
      'title' => t('User access'),
      'description' => t('Access can be granted to individual users of the site.'),
      'access controller' => 'UserSharedAccessController',
      'file' => 'includes/shared_access.classes.inc',
    ),
    'mail' => array(
      'title' => t('Email authorization'),
      'description' => t('Access can be granted to anonymous users through links sent to email addresses.'),
      'access controller' => 'MailSharedAccessController',
      'file' => 'includes/shared_access.classes.inc',
    ),
    'domain' => array(
      'title' => t('Domain authorization'),
      'description' => t('Access can be granted to anyone who has an email address from a specific domain.'),
      'access controller' => 'DomainSharedAccessController',
      'file' => 'includes/shared_access.classes.inc',
    ),
    // TODO: Add another realm 'sync' for synchronizing access to that of another
    //       shared access field on another entity.
  );
  if (module_exists('og')) {
    $shared_access_realms['group'] = array(
      'title' => t('Group access'),
      'description' => t('Access can be granted based on Organic Group membership.'),
      'access controller' => 'GroupSharedAccessController',
      'file' => 'includes/shared_access.classes.inc',
    );
  }
  return $shared_access_realms;
}

/**
 * Get the access controller class for a specific realm.
 *
 * @param $realm
 *   The realm to retreive the access controller class for.
 *
 * @return
 *   An instance of the access controller class or FALSE if the class could not
 *   be loaded.
 *
 * @see shared_access_get_realms().
 */
function shared_access_get_access_controllers($realm_name = '') {
  $controllers = &drupal_static(__FUNCTION__, array());
  if (empty($controllers)) {
    foreach (shared_access_get_realms() as $realm => $realm_info) {
      $class = $realm_info['access controller'];
      $class_loaded = class_exists($class);
      if (!$class_loaded) {
        if (function_exists('drupal_get_path') && $realm_info['file']) {
          $file = DRUPAL_ROOT . '/' . drupal_get_path('module', $realm_info['module']) . '/' . $realm_info['file'];
          if (is_file($file)) {
            require_once $file;
            $class_loaded = TRUE;
          }
        }
      }
      $controllers[$realm] = ($class_loaded) ? new $class($realm) : FALSE;
    }
  }
  if (!$realm_name) return $controllers;

  if (isset($controllers[$realm_name])) return $controllers[$realm_name];
}

/**
 * Get the array of shared access operations (ops).
 *
 * Modules may define new operations and grouped operations by implementing
 * hook_shared_access_ops() and alter existing operation definitions with
 * hook_shared_access_ops_alter().
 *
 * @return $ops
 *   An array of operations that can be controlled by shared access fields.
 *   The returned array contains key/value pairs where the key is the operation
 *   that would typically be used in an access function such as 'view' and the
 *   value is an array of information used by shared access to perform access
 *   functionality. The value array has the following structure:
 *
 *   'label' - A label for the operation used in shared access forms.
 *   'description' - A description of what the operation is used for.
 *   'sub ops' - Optional: An array whose values are the keys of other shared
 *               access operations. These sub ops will inherit access to realms
 *               granted to this one.
 *
 * @see hook_shared_access_ops()
 * @see hook_shared_access_ops_alter()
 */
function shared_access_get_ops($op = NULL) {
  // Use the advanced drupal_static() pattern, since this could be called often.
  static $drupal_static_fast;
  if (!isset($drupal_static_fast)) {
    $drupal_static_fast['ops'] = &drupal_static(__FUNCTION__);
  }
  $ops = &$drupal_static_fast['ops'];

  if (empty($ops)) {
    $default_ops = array(
      'view' => array(
        'label' => t('Can View'),
        'description' => t('View the entity. Standard op used by entity CRUD. i.e. used by nodes.'),
      ),
      'update' => array(
        'label' => t('Can Update'),
        'description' => t('Update the entity. Standard op used by entity CRUD. i.e. used by nodes.'),
      ),
      'delete' => array(
        'label' => t('Can Delete'),
        'description' => t('Delete the entity. Standard op used by entity CRUD. i.e. used by nodes.'),
      ),
      'manage' => array(
        'label' => t('Can Edit'),
        'description' => t('View and update the entity.'),
        'sub ops' => array('view', 'update'),
      ),
      'admin' => array(
        'label' => t('Administer'),
        'description' => t('View, update, delete and assign access to the entity.'),
        'sub ops' => array('manage', 'delete'),
      ),
      'owns' => array(
        'label' => t('Is owner'),
        'description' => t('The owner of the entity.'),
        'sub ops' => array('admin'),
      ),
    );
    $ops = $default_ops += module_invoke_all('shared_access_ops');
    // Let other modules alter the shared access ops.
    drupal_alter('shared_access_ops', $ops);
  }
  if ($op && isset($ops[$op])) {
    return $ops[$op];
  }
  return $ops;
}

function shared_access_get_field_ops($field = NULL) {

  if (!$field) return array();

  $enabled_ops = array();
  // For entity api and rule handling $field receives either 'edit' or 'view'
  // so in these cases we want to return all possible operations configured for
  // all shared_access fields since we have no way of determining field specific
  // settings.
  if (is_scalar($field)) {
    foreach (get_shared_access_fields() as $field_info) {
      $enabled_ops += $field_info['settings']['ops'];
    }
  }
  // Field specific settings have been passed in to only return the operations
  // allowed for this field.
  elseif (isset($field['settings']['ops'])) {
    $enabled_ops = array_filter($field['settings']['ops']);
  }

  $ops = array();
  foreach (shared_access_get_ops() as $key => $op_info) {
    if (!empty($enabled_ops[$key])) {
      $ops[$key] = $op_info['label'];
    }
  }

  return $ops;
}

/**
 * Determines if a given operation inherits its access from another. Is it
 * a sub operation?
 *
 * @param $child
 *   The operation currently being checked for access.
 * @param $parent
 *   An operation to check inheritance against. Is this operation the parent of
 *   The child operation? Meaning is it okay to grant access for the child
 *   operation if access has been granted for this operation if not specifically
 *   for the child?
 *
 * @see shared_access()
 * @see hook_shared_access_ops()
 */
function shared_access_inherits_op($child, $parent) {
  $op = shared_access_get_ops($parent);
  if ($op && isset($op['sub ops'])) {
    foreach ($op['sub ops'] as $sub_op) {
      if ($sub_op == $child) {
        return TRUE;
      } // Also check recursively down the inherited chain.
      elseif (shared_access_inherits_op($child, $sub_op)) {
        return TRUE;
      }
    }
  }
  return FALSE;
}

/**
 * Determine if an entity's access should be controlled by shared access fields.
 *
 * @param $op
 *   The operation to be performed on the entity. Standard values are:
 *   - "view"
 *   - "update"
 *   - "delete"
 *   - "create"
 *   However, operations can be extended through hook_shared_access_op_info.
 *
 * @param $entity_type
 *   The entity type of the entity we're checking access for.
 * @param $entity
 *   The entity to check access for. If no entity is given, it will be
 *   determined whether access is allowed for all entities of the given type.
 * @return
 *   An array of field instances indexed by field_name that affect the operation
 *   of an entity, or an empty array otherwise.
 */
function shared_access_entity_uses_op($op, $entity_type, $entity) {
  $bundle_access = &drupal_static(__FUNCTION__, array());
  if (!$op || !$entity_type || !$entity) {
    // If there was no entity to check against we return an empty array.
    return array();
  }
  // We need the bundle type .
  list(,, $bundle) = entity_extract_ids($entity_type, $entity);
  if (!$bundle) return array();

  if (!isset($bundle_access[$entity_type][$bundle][$op])) {
    $bundle_access[$entity_type][$bundle][$op] = array();

    // Get a list of all shared access fields.
    $shared_access_fields = get_shared_access_fields();

    // Loop through all of the shared access fields attached to this entity.
    foreach ($shared_access_fields as $field_name => $field) {
      // Check to see if the op is supported by this field.
      $supported_ops = array_filter($field['settings']['ops']);
      if (!($op_found = array_key_exists($op, $supported_ops))) {
        // Were not lucky enough to find the op key so look for op inheritance.
        foreach (array_keys($supported_ops) as $op_key ) {
          if ($op_found = shared_access_inherits_op($op, $op_key)) break;
        }
      }
      if ($op_found) {
        if ($instance = field_info_instance($entity_type, $field_name, $bundle)) {
          $bundle_access[$entity_type][$bundle][$op][$field_name] = $instance;
        }
      }
    }
  }
  return $bundle_access[$entity_type][$bundle][$op];
}

/**
 * Determine whether the current user may perform the given operation on the
 * specified entity.
 *
 * @param $op
 *   The operation to be performed on the node. Standard values are:
 *   - "view"
 *   - "update"
 *   - "delete"
 *   However, operations are extendable and are configurable by field instance
 *   so any module can add and use any custom operations.
 *
 * @param $entity_type
 *   The entity type of the entity we're checking access for.
 * @param $entity
 *   The entity to check access for. If no entity is given, it will be
 *   determined whether access is allowed for all entities of the given type.
 * @param $account
 *   Optionally a user account to check for. Leave NULL to use the global user.
 * @return
 *   TRUE if the operation may be performed, FALSE otherwise.
 */
function shared_access($op, $entity_type, $entity, $account = NULL) {
  $shared_access = &drupal_static(__FUNCTION__, array());

  if (!$entity_type || !$entity) {
    // If there was no entity to check against, or the $op was not one of the
    // supported ones, we return access denied.
    return FALSE;
  }
  // We need the id.
  list($id,,) = entity_extract_ids($entity_type, $entity);

  if (!$id) return FALSE;

  // Use the current user if none was passed.
  if (!$account) {
    global $user;
    $account = $user;
  }

  // Unique access key for a given user to a specific operation on an entity.
  $shared_access_key = $account->uid . '-' . $entity_type . '-' . $id . '-' . $op;

  // TODO include entity_type and other variables.
  if (!$account->uid || !isset($shared_access[$shared_access_key])) {
    $shared_access[$shared_access_key] = FALSE;

    // Loop through all of the shared access fields that affect access to
    // operations on this entity.
    foreach (shared_access_entity_uses_op($op, $entity_type, $entity) as $field_name => $instance) {
      // Default parameters to use when determining access.
      $default_params = array(
        'op' => $op,
        'entity_type' => $entity_type,
        'entity id' => $id,
        'entity' => $entity,
        'field_name' => $field_name,
        'instance' => $instance,
        'account' => $account,
      );
      // Allow other modules to add parameters to use when determining access.
      $params = $default_params += module_invoke_all('shared_access_params', $default_params);

      // Check realms to see if they implement any priority access checking.
      foreach(array_intersect_key(shared_access_get_implementing_controllers('SharedAccessPriorityAccessInterface'), $instance['settings']['realms']) as $realm => $controller) {
        if ($controller->priority_access($params)) {
          $shared_access[$shared_access_key] = TRUE;
          break 2;
        }
      }

      // Check the field items for access grants.
      if ($items = field_get_items($entity_type, $entity, $field_name)) {
        // If this is not the first time we're checking access for this entity,
        // then we need to check for the alteration we made in
        // shared_access_field_formatter_prepare_view().
        if ($items && isset($items[0]['items'])) $items = $items[0]['items'];
        // Loop through each item on the field and determine if the account has
        // access.
        foreach ($items as $item) {
          // Skip this item if its not relevant to the operation.
          if (($op != $item['op']) && !shared_access_inherits_op($op, $item['op'])) continue;
          // Get the controller and then check access.
          $controller = shared_access_get_access_controllers($item['realm']);
          if ($controller->access($item, $params)) {
            $shared_access[$shared_access_key] = TRUE;
            break 2;
          }
        }
      }
    }
  }
  return $shared_access[$shared_access_key];
}

/**
 * Implements hook_shared_access_params().
 *
 * Adds the 'sa_key' to the params if the instance has the 'mail' realm enabled.
 */
function shared_access_shared_access_params($default_params) {
  $params = &drupal_static(__FUNCTION__, array());
  $id = $default_params['instance']['id'];
  if (!isset($params[$id])) {
    $params[$id] = array();
    // Add the query string to the params if the 'mail' realm is enabled for
    // this shared_access field instance.
    if (in_array('mail', $default_params['instance']['settings']['realms'])) {
      $query_parameters = drupal_get_query_parameters();
      if (!empty($query_parameters['sa_key'])) {
        $params[$id]['sa_key'] = $query_parameters['sa_key'];
      }
    }
  }
  // only return an array if there is something to return.
  if ($params[$id]) {
    return $params[$id];
  }
}

/***************************************************************
 * Module access hooks
 ***************************************************************/

/**
 * Implements hook_node_access().
 */
function shared_access_node_access($node, $op, $account) {
  // Only act on fully defined node entities since access is granted
  // from the shared access field attached to the node.
  if (is_string($node)) return NODE_ACCESS_IGNORE;

  // TODO check that the node has a shared access field before entering this
  // container.
  if (shared_access_entity_uses_op($op, 'node', $node)) {
    if (shared_access($op, 'node', $node, $account)) return NODE_ACCESS_ALLOW;
    return NODE_ACCESS_DENY;
  }

  return NODE_ACCESS_IGNORE;
}

/***************************************************************
 * Module access callbacks
 ***************************************************************/

/**
 * Overrides access callbacks for the user_menu() edit, view and delete.
 */
function _shared_access_user_access($op, $account, $callback = '', $user = NULL) {
  // Load a user entity if we were only given an id.
  if (!is_object($account)) {
    $account = user_load((int) $account);
  }
  // Never allow access to view, edit or delete the anonymous user;
  if (!$account || !$account->uid) {
    return FALSE;
  }
  if (!$user) {
    global $user;
  }
  // We check that there is a shared_access field attached to the user entity
  // in shared_access_menu_alter() so we don't need to check again here.
  if (shared_access_entity_uses_op($op, 'user', $account)) {
    if (shared_access($op, 'user', $account, $user)) return TRUE;
  }
  // Work within the confines of the default Drupal user access model.
  if ($callback && function_exists($callback)) {
    return $callback($account);
  }
  return FALSE;
}

/**
 * Access callback for generic entities called by entity_access().
 */
function shared_access_entity_access_callback($op, $entity = NULL, $account = NULL, $entity_type = NULL) {
  if (!$account) {
    global $user;
    $account = $user;
  }

  $ops_supported = FALSE;
  // We check that there is a shared_access field attached to the entity
  // in shared_access_menu_alter() so we don't need to check again here.
  if (shared_access_entity_uses_op($op, $entity_type, $entity)) {
    $ops_supported = TRUE;
    if (shared_access($op, $entity_type, $entity, $account)) return TRUE;
  }

  // Work within the confines of the entity API access model.
  $info = entity_get_info();
  $keep_access_callback = (isset($info[$entity_type]['shared_access']['keep']) && $info[$entity_type]['shared_access']['keep']);
  if ((!$ops_supported || $keep_access_callback) && isset($info[$entity_type]['shared_access']['access callback'])) {
    return $info[$entity_type]['access callback']($op, $entity, $account, $entity_type);
  }
  return FALSE;
}

/***************************************************************
 * Shared Access helper functions
 ***************************************************************/

function shared_access_get_implementing_controllers($interfaceName) {
  return array_filter(
    shared_access_get_access_controllers(),
    function ($class) use ($interfaceName) {
      return $class instanceof $interfaceName;
    }
  );
}

/**
 * Helper function to determine if an item already exists in the field.
 */
function _shared_access_equal_items($item, $items) {
  return array_filter(
    $items,
    function ($item2) use ($item) {
      return $item == $item2;
    }
  );
}
