package {	import flash.display.MovieClip;	import flash.display.Loader;	import flash.display.DisplayObject;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.SimpleButton;	import flash.geom.ColorTransform;	import flash.geom.Matrix;	import flash.geom.Point;	import flash.net.URLRequest;	import flash.net.URLVariables;	import flash.net.URLLoader;	import flash.net.URLRequestMethod;	import flash.net.URLLoaderDataFormat;	import flash.net.navigateToURL;	import flash.external.ExternalInterface;	import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TimerEvent;	import flash.utils.Timer;	import flash.media.Sound;	import flash.text.TextFieldAutoSize;	import flash.errors.IOError;	import flash.events.IOErrorEvent;		public class Peel extends MovieClip {		// tracking code		private static const CURLYPAGE_TRACKING_CODE:String = "LiPXZui3RT2i9rg2";		// BEGIN PEEL PARAMETERS		// unique curlypage identifier		private var cpid:uint;				// sizes		private var peelWidth:uint;		private var peelHeight:uint;				// peel position on page. Values: topleft || topright || bottomleft || bottomright		private var peelPosition:String;		// mirror the image on peel. Values: true || false		private var mirror:Boolean;		// color of peel. Values: golden || silver || custom		private var peelColor:String;		// color of peel style. Values: flat || gradient		private var peelColorStyle:String;		// red value of custom color. Values 0-255		private var redValue:uint;		// green value of custom color. Values 0-255		private var greenValue:uint;		// blue value of custom color. Values 0-255		private var blueValue:uint;		// link enabled. Values: true || false		private var linkEnabled:Boolean;		// where to open ad link, same or new window. Values: _self || _blank		private var linkTarget:String;		// ad link		private var link:String;		// speed of peel movement. Values: 1-9		private var peelSpeed:uint;		// milliseconds to automatic open the peel.		private var automaticOpen:uint;		// milliseconds to automatic close the peel.		private var automaticClose:uint;		// enable a close button on opened peel. Values: true || false		private var close_button_enable:Boolean;		// text on close button		private var text_on_close_button:String;		// red value of close button color		private var close_redValue:uint;		// green value of close button color		private var close_greenValue:uint;		// blue value of close button color		private var close_blueValue:uint;		// enable tracking. Values: true || false		private var tracking:Boolean;		// END PEEL PARAMETERS		// size of design flag		private const PEELDESIGNSIZE:uint = 500;		private var imageLoader:Loader;		private var toScaleX:Number;		private var toScaleY:Number;		private var openSound:Sound;		private var closeSound:Sound;		private var openSoundEnabled:Boolean = false;		private var closeSoundEnabled:Boolean = false;				// automatic open timer		var automaticOpenTimer:Timer;		// automatic close timer		var automaticCloseTimer:Timer;		private const childNames = new Array("image_mask", "inner_shadow", "peel", "top_shadow", "mirror_image", "button", "close_button_container");		// this flag controls the movement direction. False -> forward. True -> backward		private var moveBackwards:Boolean = false;				// complementary color to use on close mouse over		private var closeMouseOverRedValue, closeMouseOverGreenValue, closeMouseOverBlueValue:uint;				// to track the currentFrame of childs to be shown		private var peelCurrentFrame:uint;				// mirror image bitmap and timer to update it		private var mirrorImageBitmap:Bitmap = new Bitmap();		private var updateMirrorImageTimer:Timer;				// this flag controls if the curlypage has been totally opened		private var hasBeenOpened:Boolean = false;		// this flag controls if the curlypage has been clicked		private var clicked:Boolean = false;		/*		 * Constructor		 */		public function Peel(cpid:uint,							 peelPosition:String,							 mirror:Boolean,							 peelColor:String,							 peelColorStyle:String,							 redValue:uint,							 greenValue:uint,							 blueValue:uint,							 linkEnabled:Boolean,							 linkTarget:String,							 link:String,							 peelSpeed:uint,							 automaticOpen:uint,							 automaticClose:uint,							 close_button_enable:Boolean,							 text_on_close_button:String,							 close_redValue:uint,							 close_greenValue:uint,							 close_blueValue:uint,							 imageLoader:Loader,							 openSound:Sound,							 closeSound:Sound,							 peelWidth:uint,							 peelHeight:uint,							 tracking:Boolean)		{			this.cpid = cpid;			this.peelPosition = peelPosition;			this.mirror = mirror;			this.peelColor = peelColor;			this.peelColorStyle = peelColorStyle;			this.redValue = redValue;			this.greenValue = greenValue;			this.blueValue = blueValue;			this.linkEnabled = linkEnabled;			this.linkTarget = linkTarget;			this.link = link;			this.peelSpeed = peelSpeed;			this.automaticOpen = automaticOpen;			this.automaticClose = automaticClose;			this.close_button_enable = close_button_enable;			this.text_on_close_button = text_on_close_button;			this.close_redValue = close_redValue;			this.close_greenValue = close_greenValue;			this.close_blueValue = close_blueValue;						this.imageLoader = imageLoader;			this.openSound = openSound;			this.closeSound = closeSound;			this.toScaleX = toScaleX;			this.toScaleY = toScaleY;			this.peelWidth = peelWidth;			this.peelHeight = peelHeight;			this.toScaleX = peelWidth/PEELDESIGNSIZE;			this.toScaleY = peelHeight/PEELDESIGNSIZE;			this.tracking = tracking;			if (openSound == null) {				openSoundEnabled = false;			} else {				openSoundEnabled = true;			}						if (closeSound == null) {				closeSoundEnabled = false;			} else {				closeSoundEnabled = true;			}			scaleMovie();			//set peel color			if (peelColor == "golden") {				this.redValue = 50;				this.greenValue = 100;				this.blueValue = 10;			} else if (peelColor == "silver") {				if (peelColorStyle == "flat") {					this.redValue = 192;					this.greenValue = 192;					this.blueValue = 192;				} else {					this.redValue = 0;					this.greenValue = 0;					this.blueValue = 0;				}			}						setPeelColor(this.redValue, this.greenValue, this.blueValue);						if (automaticOpen > 0) {				// automatic open timer				automaticOpenTimer = new Timer(automaticOpen, 1);				// event to control automatic open timer completion				automaticOpenTimer.addEventListener(TimerEvent.TIMER_COMPLETE, openTimerCompleted);								if (automaticClose > 0) {					// automatic close timer					automaticCloseTimer = new Timer(automaticClose, 1);					// event to control automatic close timer completion					automaticCloseTimer.addEventListener(TimerEvent.TIMER_COMPLETE, closeTimerCompleted);				}			}						// add big image to its container			setImage();			// add mirror image to peel if configured to do so			if (mirror) {				setMirrorImage();			}						// listen for flag to open the peel			ExternalInterface.addCallback("doPeel", doPeel);			if (linkEnabled) {				// add mouuse up event to control when user press button				MovieClip(getChildByName("button")).peelBigButton.addEventListener(MouseEvent.MOUSE_UP, doLink);			}						// start the automatic open timer when added to stage			addEventListener(Event.ADDED_TO_STAGE, peelAddedToStage);						// calculate complementary color for close button mouse over			closeMouseOverRedValue = ((255-this.redValue)*3+(255-this.close_redValue))/4;			closeMouseOverGreenValue = ((255-this.greenValue)*3+(255-this.close_greenValue))/4;			closeMouseOverBlueValue = ((255-this.blueValue)*3+(255-this.close_blueValue))/4;			stopAll();			this.peelCurrentFrame = 1;		}				/*		 * start automatic open timer		 */		private function peelAddedToStage (e:Event) : void {			if (automaticOpen > 0 && automaticOpenTimer != null) {				automaticOpenTimer.start();			}		}		/*		 * automatic open timer completion event handler		 */		private function openTimerCompleted (e:TimerEvent) : void {			ExternalInterface.call("curlypage_do_peel", this.cpid, this.peelPosition);			doPeel();		}		/*		 * automatic close timer completion event handler		 */		private function closeTimerCompleted (e:TimerEvent) : void {			doUnpeel();		}		/*		 * Sets color of peel.		 */		private function setPeelColor (redValue, greenValue, blueValue: uint) : void {			var peelTransform:ColorTransform;			if (this.peelColorStyle == "flat") {				peelTransform = new ColorTransform(0,0,0,1,redValue,greenValue,blueValue,0);			} else {				peelTransform = new ColorTransform(1,1,1,1,redValue,greenValue,blueValue,0);			}			MovieClip(getChildByName("peel")).transform.colorTransform = peelTransform;		}		/*				 * Flip horizontal in place		 */		 		private function flipHorizontal(dsp:DisplayObject):void {			var matrix:Matrix = dsp.transform.matrix;			matrix.transformPoint(new Point(dsp.width/2, dsp.height/2));			if(matrix.a > 0){				matrix.a = -1 * matrix.a;				matrix.tx = dsp.width + dsp.x;			} else {				matrix.a = -1 * matrix.a;				matrix.tx = dsp.x - dsp.width;			}			dsp.transform.matrix = matrix;		}		/*		 * Flip vertical in place		 */		private function flipVertical(dsp:DisplayObject):void {			var matrix:Matrix = dsp.transform.matrix;			matrix.transformPoint(new Point(dsp.width/2, dsp.height/2));			if(matrix.d > 0){				matrix.d = -1 * matrix.d;				matrix.ty = dsp.height + dsp.y;			} else {				matrix.d = -1 * matrix.d;				matrix.ty = dsp.y - dsp.height;			}			dsp.transform.matrix = matrix;		}		/*		 * Move clips to specific frame		 */		private function gotoFrame (frame:uint) {			for each (var childname:String in childNames)  {				MovieClip(getChildByName(childname)).gotoAndStop(frame);			}						this.peelCurrentFrame = frame;		}		/*		 * Move clips forward		 */		private function goNext (speed:uint = 1) : void {			var frameToGo:uint;			frameToGo = this.peelCurrentFrame + speed;			if (frameToGo > 50) {				frameToGo = 50;			}			gotoFrame(frameToGo);		}		/*		 * Move clips backward		 */		function goPrev (speed:uint = 1) : void {			var frameToGo:int;			frameToGo = this.peelCurrentFrame - speed;			if (frameToGo < 2) {				frameToGo = 2;			}			gotoFrame(frameToGo);		}		/*		 * Stop all clips		 */		private function stopAll() : void {			for each (var childname:String in childNames)  {				MovieClip(getChildByName(childname)).stop();			}		}		/*		 * Move clips		 */		private function do_move (e:Event) {			if (moveBackwards) {				if (this.peelCurrentFrame == 2) {					stopAll();					removeEventListener(Event.ENTER_FRAME, do_move);					if (close_button_enable && !linkEnabled) {						// restore the peel button to its z position under close button						setChildIndex(getChildByName("button"), numChildren - 2);					}					MovieClip(getChildByName("button")).peelBigButton.addEventListener(MouseEvent.MOUSE_OVER, mouseOverPeel);					MovieClip(getChildByName("button")).peelBigButton.removeEventListener(MouseEvent.MOUSE_OUT, mouseOutPeel);					ExternalInterface.call("curlypage_do_flag", this.cpid, this.peelPosition);				} else {					goPrev(peelSpeed);				}			} else {				if (this.peelCurrentFrame == 50) {					// Track open view, the peel has been completelly opened					if (!hasBeenOpened) {						if (tracking) {							curlypageView(this.cpid);						}						hasBeenOpened = true;					}					if (close_button_enable) {						// add and configure close button if it is enabled						setCloseButton();					}					removeEventListener(Event.ENTER_FRAME, do_move);					if (automaticCloseTimer != null) {						automaticCloseTimer.start();					}					return;				}						goNext(peelSpeed);			}		}				/*		 * Scale Movie		 */		private function scaleMovie () {			// scale the peel			if (peelPosition == "topleft" || peelPosition == "bottomleft") {				this.scaleX = -1 * toScaleX;				this.x += peelWidth;			} else {				this.scaleX = toScaleX;			}						if (peelPosition == "bottomleft" || peelPosition == "bottomright") {				this.scaleY = -1 * toScaleY;				this.y += peelHeight;			} else {				this.scaleY = toScaleY;			}		}		/*		 * Sets the image		 */		private function setImage () : void {			MovieClip(getChildByName("big_image")).addChild(imageLoader);			// downscale the image, cause it has been scaled with the rest of the peel as it inherits its parent scales.			MovieClip(getChildByName("big_image")).scaleX = 1/toScaleX;			MovieClip(getChildByName("big_image")).scaleY = 1/toScaleY;						// mirror the image as needed in its corner			if (peelPosition == "topleft" || peelPosition == "bottomleft") {				MovieClip(getChildByName("big_image")).scaleX *= -1;				MovieClip(getChildByName("big_image")).x += PEELDESIGNSIZE;			}			if (peelPosition == "bottomleft" || peelPosition == "bottomright") {				MovieClip(getChildByName("big_image")).scaleY *= -1;				MovieClip(getChildByName("big_image")).y += PEELDESIGNSIZE;			}		}				/*		 * Updates the mirror image on peel when it is a clip		 */		private function updateMirrorImage(e:TimerEvent):void {  			//updates the reflection to visually match the movie clip			var mirrorBitmapData:BitmapData;			mirrorBitmapData = new BitmapData(imageLoader.width, imageLoader.height, true, 0xFFFFFF);  			mirrorBitmapData.draw(imageLoader);  			mirrorImageBitmap.bitmapData = mirrorBitmapData;		}				/*		 * Sets the mirror image on peel		 */		private function setMirrorImage () : void {			mirrorImageBitmap.bitmapData = new BitmapData(imageLoader.width, imageLoader.height, true, 0xFFFFFF);  			mirrorImageBitmap.bitmapData.draw(imageLoader);			MovieClip(getChildByName("mirror_image")).mirror_big_image_container.mirror_big_image.addChild(mirrorImageBitmap);						if (imageLoader.getChildAt(0) is MovieClip) {				// if the image on peel is a movieclip it has to be updated every 100ms to				// properly display the current frame of the loading flash movie				updateMirrorImageTimer = new Timer(100, 0);				updateMirrorImageTimer.addEventListener(TimerEvent.TIMER, updateMirrorImage);				updateMirrorImageTimer.start();			}			// downscale the mirror image as it has been scaled with all the peel as it inherits its parent scales			MovieClip(getChildByName("mirror_image")).mirror_big_image_container.mirror_big_image.scaleX = 1/toScaleX;			MovieClip(getChildByName("mirror_image")).mirror_big_image_container.mirror_big_image.scaleY = 1/toScaleY;			// mirror the image as needed in its corner			if (peelPosition == "topright" || peelPosition == "bottomright") {				MovieClip(getChildByName("mirror_image")).mirror_big_image_container.mirror_big_image.scaleX *= -1;				MovieClip(getChildByName("mirror_image")).mirror_big_image_container.mirror_big_image.x += PEELDESIGNSIZE;			}						if (peelPosition == "bottomleft" || peelPosition == "bottomright") {				MovieClip(getChildByName("mirror_image")).mirror_big_image_container.mirror_big_image.scaleY *= -1;				MovieClip(getChildByName("mirror_image")).mirror_big_image_container.mirror_big_image.y += PEELDESIGNSIZE;			}		}				/*		 * Sets the close button properties		 */		private function setCloseButton () : void {			MovieClip(getChildByName("close_button_container")).close_label_clip.close_label.text = text_on_close_button;			MovieClip(getChildByName("close_button_container")).close_label_clip.close_label.autoSize = TextFieldAutoSize.LEFT;			MovieClip(getChildByName("close_button_container")).close_label_clip.buttonMode = true;			MovieClip(getChildByName("close_button_container")).close_label_clip.useHandCursor = true;			setCloseColor(close_redValue, close_greenValue, close_blueValue);			if (peelPosition == "topleft" || peelPosition == "bottomleft") {				flipHorizontal(MovieClip(getChildByName("close_button_container")).close_label_clip.close_label);				MovieClip(getChildByName("close_button_container")).close_label_clip.close_label.autoSize = TextFieldAutoSize.RIGHT;			}			if (peelPosition == "bottomleft" || peelPosition == "bottomright") {				flipVertical(MovieClip(getChildByName("close_button_container")).close_label_clip.close_label);				MovieClip(getChildByName("close_button_container")).close_label_clip.close_label.y -= 4; 			}			MovieClip(getChildByName("close_button_container")).close_button.addEventListener(MouseEvent.MOUSE_UP, closeButtonClicked);			MovieClip(getChildByName("close_button_container")).close_label_clip.addEventListener(MouseEvent.MOUSE_UP, closeButtonClicked);			MovieClip(getChildByName("close_button_container")).close_button.addEventListener(MouseEvent.MOUSE_OVER, setCloseOverColor);			MovieClip(getChildByName("close_button_container")).close_label_clip.addEventListener(MouseEvent.MOUSE_OVER, setCloseOverColor);			MovieClip(getChildByName("close_button_container")).close_button.alpha = 1;			MovieClip(getChildByName("close_button_container")).close_label_clip.alpha = 1;			MovieClip(getChildByName("close_button_container")).close_button.scaleX = 1/toScaleX;			MovieClip(getChildByName("close_button_container")).close_button.scaleY = 1/toScaleY;			MovieClip(getChildByName("close_button_container")).close_label_clip.scaleX = 1/toScaleX;			MovieClip(getChildByName("close_button_container")).close_label_clip.scaleY = 1/toScaleY;					}				/*		 * Sets a color on mouse button on mouse over		 */		private function setCloseOverColor (e:Event) : void {			e.target.removeEventListener(MouseEvent.MOUSE_OVER, setCloseOverColor);			e.target.addEventListener(MouseEvent.MOUSE_OUT, setCloseOutColor);			setCloseColor(closeMouseOverRedValue, closeMouseOverGreenValue, closeMouseOverBlueValue);		}				/*		 * Restores close button color on mouse out		 */		private function setCloseOutColor (e:Event) : void {			e.target.removeEventListener(MouseEvent.MOUSE_OUT, setCloseOutColor);			e.target.addEventListener(MouseEvent.MOUSE_OVER, setCloseOverColor);			setCloseColor(close_redValue, close_greenValue, close_blueValue);		}		/*		 * sets the color of close button		 */		private function setCloseColor (close_redValue, close_greenValue, close_blueValue) : void {			var closeTransform:ColorTransform;			closeTransform = new ColorTransform(0,0,0,1,close_redValue,close_greenValue,close_blueValue,0);			MovieClip(getChildByName("close_button_container")).close_button.transform.colorTransform = closeTransform;				MovieClip(getChildByName("close_button_container")).close_label_clip.close_label.textColor = RGBToHex(close_redValue, close_greenValue, close_blueValue);		}		/*		 * close button click handler		 */		private function closeButtonClicked (e:MouseEvent) : void {			e.target.removeEventListener(MouseEvent.MOUSE_OUT, setCloseOutColor);						doUnpeel();		}				/*		 * open the peel		 */		private function doPeel () : void {						// abort the automatic open if the peel is manually opened before			if (automaticOpenTimer != null) {				automaticOpenTimer.stop();				automaticOpenTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, openTimerCompleted);				automaticOpenTimer = null;			}						moveBackwards = false;			if (this.peelCurrentFrame != 50) {				if (openSoundEnabled) {					openSound.play();				}			}			if (close_button_enable && !linkEnabled) {				// move the peel button to bottom				// if an interactive flash is loaded on peel it can receive mouse events				setChildIndex(getChildByName("button"), 0);			}						MovieClip(getChildByName("button")).peelBigButton.removeEventListener(MouseEvent.MOUSE_OVER, mouseOverPeel);						if (!close_button_enable) {				MovieClip(getChildByName("button")).peelBigButton.addEventListener(MouseEvent.MOUSE_OUT, mouseOutPeel);			}			// event to control movement on enter frames			addEventListener(Event.ENTER_FRAME, do_move);		}		/*		 * close the peel		 */		private function doUnpeel() : void {			// abort the automatic close if the peel is manually closed before			if (automaticCloseTimer != null) {				automaticCloseTimer.stop();				automaticCloseTimer.removeEventListener(TimerEvent.TIMER_COMPLETE, closeTimerCompleted);				automaticCloseTimer = null;			}			moveBackwards = true;						MovieClip(getChildByName("button")).peelBigButton.removeEventListener(MouseEvent.MOUSE_OUT, mouseOutPeel);			if (!close_button_enable) {				MovieClip(getChildByName("button")).peelBigButton.addEventListener(MouseEvent.MOUSE_OVER, mouseOverPeel);			}			// event to control movement on enter frames			addEventListener(Event.ENTER_FRAME, do_move);			if (closeSoundEnabled) {				closeSound.play();			}		}		/*		 * mouse over event handler		 */		private function mouseOverPeel (e:MouseEvent) : void {			doPeel();		}		/*		 * mouse out event handler		 */		private function mouseOutPeel (e:MouseEvent) : void {			doUnpeel();		}		/*		 * mouse up event handler		 */		public function doLink (e:MouseEvent) : void {			// Track click.			if (!clicked) {				if (tracking) {					curlypageClick(this.cpid);				}				clicked = true;			}			navigateToURL (new URLRequest(link), linkTarget);		}		/*		 * Track views function		 */		private function curlypageView(cpid:uint) : void {			var loader:URLLoader;			var variables:URLVariables;			var req:URLRequest;						variables = new URLVariables();			variables.status = "open";			variables.source = Peel.CURLYPAGE_TRACKING_CODE;			req = new URLRequest("/curlypage/" + cpid + "/view");			req.data = variables;			req.method = URLRequestMethod.POST;						loader = new URLLoader();			loader.dataFormat = URLLoaderDataFormat.TEXT;			loader.addEventListener(Event.COMPLETE, completedView);			loader.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);			try {				loader.load(req);			} catch (error:Error) {                trace("Unable to load requested document.");            }		}				/*		 * Track clicks function		 */		private function curlypageClick(cpid:uint) : void {			var loader:URLLoader;			var variables:URLVariables;			var req:URLRequest;						variables = new URLVariables();			variables.source = Peel.CURLYPAGE_TRACKING_CODE;			req = new URLRequest("/curlypage/" + cpid + "/click");			req.data = variables;			req.method = URLRequestMethod.POST;			loader = new URLLoader();			loader.dataFormat = URLLoaderDataFormat.TEXT;			loader.addEventListener(Event.COMPLETE, completedClick);			loader.addEventListener(IOErrorEvent.IO_ERROR, ioErrorHandler);			try {				loader.load(req);			} catch (error:Error) {                trace("Unable to load requested document.");            }		}		/*		 * Complete view handler		 */		private function completedView (e:Event) : void {		    // we don't need to do anything with returned data            var loader:URLLoader;            loader = URLLoader(e.target);			trace (loader.data);		}				/*		 * Complete click handler		 */		private function completedClick (e:Event) : void {		    // we don't need to do anything with returned data            var loader:URLLoader;            loader = URLLoader(e.target);			trace (loader.data);		}				/*		 * Error handler		 */		private function ioErrorHandler (e:IOErrorEvent) : void {			// we are not going to do anything even in case of an error			trace("ioErrorHandler: " + e);		}		/*		 * Convert RGB color to Hexadecimal		 */		private function RGBToHex (r:uint, g:uint, b:uint) : uint {			var red:String;			var green:String;			var blue:String;   			if (r < 15) {				red = "0" + r.toString(16);			} else {				red = r.toString(16);			}				if (g < 15) {				green = "0" + g.toString(16);			} else {				green = g.toString(16);			}				if (b < 15) {				blue = "0" + b.toString(16);			} else {				blue = b.toString(16);			}   			var hex:String = "0x" + red + green + blue;			return uint(hex);		}	}}