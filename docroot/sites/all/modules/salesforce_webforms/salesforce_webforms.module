<?php

/**
 * @file
 * Allow webforms to integrate with Salesforce via th Salesforce Suite module.
 */

include_once 'salesforce_webforms.maps.inc';

define('SALESFORCE_WEBFORMS_INCLUDE_ALL', 1);
define('SALESFORCE_WEBFORMS_INCLUDE_FILTERED', 2);
define('SALESFORCE_WEBFORMS_CACHE_DURATION', 60 * 60 * 12);

/**
 * Implements hook_menu().
 */
function salesforce_webforms_menu() {
  $items = array();

  $items['node/%webform_menu/webform/salesforce'] = array(
    'title' => 'Salesforce',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('salesforce_webforms_maps_form', 1),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'file' => 'salesforce_webforms.admin.inc',
    'weight' => 4,
    'type' => MENU_LOCAL_TASK,
  );

  $items['node/%webform_menu/webform/salesforce/add/%'] = array(
    'title' => 'Add object mapping',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('salesforce_webforms_manage_map', 1, 'add', 5),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'file' => 'salesforce_webforms.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['node/%webform_menu/webform/salesforce/edit/%/%salesforce_webforms_map'] = array(
    'title' => 'Edit map',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('salesforce_webforms_manage_map', 1, 'edit', 5, 6),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'file' => 'salesforce_webforms.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['node/%webform_menu/webform/salesforce/delete/%salesforce_webforms_map'] = array(
    'title' => 'Delete map',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('salesforce_webforms_delete_rule', 5),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'file' => 'salesforce_webforms.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['node/%webform_menu/submission/%webform_menu_submission/sf'] = array(
    'title' => 'Resubmit to Salesforce',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('salesforce_webforms_resubmit', 1, 3),
    'access callback' => 'node_access',
    'access arguments' => array('update', 1),
    'file' => 'salesforce_webforms.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/salesforce/webforms'] = array(
    'title' => 'Configure Webforms integration',
    'description' => 'Allows the administrator to configure site wide details related to the integration with webforms.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('salesforce_webforms_config'),
    'access arguments' => array('administer salesforce'),
    'file' => 'salesforce_webforms.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * Implements hook_module_implements_alter().
 *
 * Makes sure our hooks are called after the equivalent webform hooks.
 */
function salesforce_webforms_module_implements_alter(&$implementations, $hook) {
  switch ($hook) {
    case 'node_load':
      $group = $implementations['salesforce_webforms'];
      unset($implementations['salesforce_webforms']);
      $implementations['salesforce_webforms'] = $group;

      break;
  }
}

/**
 * Implements hook_node_load().
 */
function salesforce_webforms_node_load($nodes, $types) {
  salesforce_webforms_get_nodes_maps($nodes);
}

/**
 * Implements hook_node_insert().
 */
function salesforce_webforms_node_insert($node) {
  salesforce_webforms_save_node_maps($node);
}

/**
 * Implements hook_node_update().
 */
function salesforce_webforms_node_update($node) {
  salesforce_webforms_save_node_maps($node);
}

/**
 * Implements hook_help().
 */
function salesforce_webforms_help($path, $arg) {
  $msg = "";

  switch ($path) {
    case 'node/%/webform/salesforce':
      $msg = '<p>' . t('This form allows fields in the webform, as well
as constant data, to be assigned to multiple fields within multiple
Salesforce objects. To create a new mapping, choose a name, which must
be unique among all maps for this form, and must contain only letters,
numbers, and underscore (_) characters. A Salesforce object must also
be chosen. This will allow for editing of the specific fields on the
next page.') . '</p>';
      break;

    case 'node/%/webform/salesforce/add/%':
    case 'node/%/webform/salesforce/edit/%/%':
      // Get the info about this object.
      $objects = salesforce_webforms_get_objects();
      $obj = $objects[$arg[5]];

      $msg = '<p>' . t('This form allows for the editing of the mappings
within a :object object. Each available field within the :object object
will be shown. Clicking on the name of the field will expand it out to
show the possible values. All fields have a text input area of some
sort. Some provide a single line of text, while others provide a
multi-line text area. This is determined by the type of data expected
in that field by Salesforce. Some fields also provide a dropdown list
of possible choices. If one of these items is selected, then the
text input for that field will be disabled. Each field also contains
a "Key field" checkbox. If this is checked, then the value of this field,
along with all other key fields, will be used to attempt to find an
existing :object to update, rather than always creating a new :object. If
multiple fields are marked as key fields, then all fields must match
for a(n) :object to be chosen for update. If one or more key fields is
not able to match. or if no key fields are defined, then a new :object
will be created.', array(':object' => $obj['label'])) . '</p>';
      break;

    case 'node/%/webform/salesforce/delete/%':
      $msg = '<p>' . t('Delete the specific mapping. This operation cannot
be undone.') . '</p>';
      break;

    case 'node/%/submission/%/sf':
      $msg = '<p>' . t('Allows for the resubmission of data to Salesforce
from a previously completed form. This might be necessary if, for instance,
the connection with Salesforce was down during the initial form
submission, or if the data was edited and needed to be resent. When sending
the form data, the system will attempt to updated the Salesforce objects
created during the initial submission, if possible, unless told not to
do so. If told not to update the original objects, or if the original
objects are no longer available, then new objects will be created, except
that the key field lookup logic will still be used.') . '</p>';
      break;

    case 'admin/help#salesforce_webforms':
      $msg = '<p>' . t('Webforms can be used to easily build forms without
relying on code. With this integration, those forms can interact with
the Salesforce suite of tools. Multiple Salesforce objects can be created
from a single Webform, and Salesforce picklists can be used to drive
drop down select lists within the form presented to the site
visitor.') . '</p>';
      break;
  }

  return $msg;
}

/**
 * Loads object map from menu parameter.
 *
 * @param int $mapid
 *   The ID of the map to load.
 *
 * @return array
 *   The map data.
 */
function salesforce_webforms_map_load($mapid) {
  return salesforce_webforms_get_map($mapid);
}

/**
 * Implements hook_theme().
 */
function salesforce_webforms_theme() {
  return array(
    'salesforce_webforms_manage_overview' => array(
      'variables' => array(
        'maps' => NULL,
        'node' => NULL,
      ),
    ),
    'salesforce_webforms_maps_form' => array(
      'render element' => 'form',
      'file' => 'salesforce_webforms.admin.inc',
    ),
  );
}

/**
 * Returns all defined Salesforce objects.
 *
 * @param bool $use_cache
 *   Determines if the cached data is acceptable (TRUE) or if the cache
 *   should be bypassed and updated (FALSE).
 *
 * @return array
 *   An associative array of Salesforce objects, keyed by the internal
 *   Salesforce name of the object.
 */
function salesforce_webforms_get_objects($use_cache = TRUE) {
  $sobjects = _salesforce_webforms_fetch("sobjects", $use_cache);
  $return = array();

  foreach ($sobjects['sobjects'] as $data) {
    $return[$data['name']] = $data;
  }
  return $return;
}

/**
 * Gets the list of Saleforce objects as an array of options.
 *
 * @param bool $filter
 *   If TRUE, limit selections based on admin settings.
 *
 * @return array
 *   An associative array appropriate for use as an 'options' element.
 */
function salesforce_webforms_get_objects_selection($filter = TRUE) {
  $selections = array();
  if ($filter) {
    $limit = variable_get('salesforce_webforms_all_objects', SALESFORCE_WEBFORMS_INCLUDE_ALL);
    if ($limit != SALESFORCE_WEBFORMS_INCLUDE_ALL) {
      $limited_list = variable_get('salesforce_webforms_objects', array());
    }
    else {
      $filter = FALSE;
    }
  }

  $objs = salesforce_webforms_get_objects();
  if ($objs) {
    foreach ($objs as $info) {
      if (!$filter || isset($limited_list[$info['name']])) {
        $selections[$info['name']] = $info['label'];
      }
    }
  }

  // Allow modules to filter the list.
  drupal_alter('salesforce_webforms_objects', $selections);

  return $selections;
}

/**
 * Gets the Salesforce suite object and verified connectivity.
 *
 * @return object
 *   The Salesforce object used for communicating with Salesforce.
 */
function salesforce_webforms_get_sfapi() {
  $sf = &drupal_static(__FUNCTION__);

  if (!isset($sf)) {
    $sf = salesforce_get_api();
    $sf->isAuthorized();
  }

  return $sf;
}

/**
 * Gets the fields for a given object.
 *
 * @param string $obj
 *   The internal Salesforce name of the object.
 * @param bool $use_cache
 *   Determines if the cache should be used (TRUE) or bypassed and
 *   updated (FALSE).
 *
 * @return array|NULL
 *   An associative array of fields, keyed by the field name. The data of
 *   each field is an array of attributes as defined by Salesforce.
 */
function salesforce_webforms_get_object_fields($obj, $use_cache = TRUE) {
  // See if we can get the data from our cache.
  $cache_name = "object:$obj";
  $sobject = NULL;

  if ($use_cache) {
    $cache = cache_get($cache_name, 'cache_salesforce_webforms');
    if ($cache && $cache->expire >= time() && !empty($cache->data)) {
      $sobject = $cache->data;
    }
  }

  if ($sobject == NULL) {
    $sf = salesforce_webforms_get_sfapi();

    try {
      $sobject = $sf->objectDescribe($obj, FALSE);
      cache_set($cache_name, $sobject, 'cache_salesforce_webforms',
        time() + SALESFORCE_WEBFORMS_CACHE_DURATION);
    }
    catch (SalesforceException $e) {
      drupal_set_message(t('Get Object fields: @msg', array('@msg' => $e->getMessage())), 'error');

      watchdog(
        'salesforce_webforms',
        'Salesforce Exception @code: @msg',
        array(
          '@msg' => $e->getMessage(),
          '@code' => $e->getCode(),
        ),
        WATCHDOG_ERROR);

      return NULL;
    }
  }

  $return = array();

  foreach ($sobject['fields'] as $field) {
    $return[$field['name']] = $field;
  }

  // Allow hooks to manipulate the list.
  $hook_data = array($obj => $return);
  drupal_alter('salesforce_webform_fields', $hook_data);
  return $hook_data[$obj];
}

/**
 * Implements hook_webform_component_info().
 */
function salesforce_webforms_webform_component_info() {
  $components = array();

  $components['sf_picklist'] = array(
    'label' => t('Salesforce picklist'),
    'description' => t('Select list driven by a Salesforce picklist'),
    'features' => array(
      // Includes an analysis callback.
      'analysis' => TRUE,
      // Include in CSV.
      'csv' => TRUE,
      // Allows default values?
      'default_value' => FALSE,
      // Allows a description field?
      'description' => TRUE,
      // Valid as field in emails?
      'email' => TRUE,
      // Valid as an email FROM or TO?
      'email_address' => FALSE,
      // Valid as an email name?
      'email_name' => FALSE,
      // Can this be set to required?
      'required' => TRUE,
      // Supports the 'title' attribute?
      'title' => FALSE,
      // Has a title which can be toggled on/off?
      'title_display' => TRUE,
      // Can title be displayed inline?
      'title_inline' => TRUE,
      // Can other fields conditionally display based on this field?
      'conditional' => TRUE,
      // Can this be a group container?
      'group' => FALSE,
      // Can this be used for SPAM analysis?
      'spam_analysis' => FALSE,
      // Saves attachements?
      'attachment' => FALSE,
      // Supports a range of values?
      'views_range' => FALSE,
    ),

    // Conditional comparison type.
    'conditional_type' => 'sf_picklist',

    'file' => 'salesforce_webforms.picklist.inc',
  );

  return $components;
}

/**
 * Saves a mapping.
 *
 * @param array $values
 *   An associative array containing:
 *   - object: String identifying the Salesforce object.
 *   - action: One of:
 *     - add.
 *     - edit.
 *   - nid: Node ID.
 *   - mapid: Int ID of the map to be operated upon.
 *   - map_fields: Associative array of fields and values.
 *
 * @return int|NULL
 *   The created or updated map id.
 */
function salesforce_webforms_map_save(array $values) {
  // Let any code process a pre-save function, allowing data to be updated.
  foreach (module_implements('salesforce_webforms_map_presave') as $module) {
    $function = $module . '_salesforce_webforms_map_presave';

    // Call the hook handler, allowing for call by reference if requested.
    $function($values);
  }

  // Save map data.
  $values['sf_object'] = $values['object'];

  if ($values['action'] == 'add') {
    drupal_write_record('salesforce_webforms_map', $values);
  }
  elseif ($values['action'] == 'edit') {
    drupal_write_record('salesforce_webforms_map', $values, 'mapid');
  }
  else {
    // Invalid operation. Return.
    return NULL;
  }
  $mapid = $values['mapid'];
  if ($mapid) {
    // Delete the old version of the fields, if any.
    db_delete('salesforce_webforms_field')
      ->condition('mapid', $mapid)
      ->execute();

    if (isset($values['map_fields']) && array_filter($values['map_fields'])) {
      salesforce_webforms_save_fields($mapid, $values['map_fields']);
    }
  }

  // Allow all post-save hooks to run.
  module_invoke_all('salesforce_webforms_map_save', $values);

  return $mapid;
}

/**
 * Save the individual field mappings of a map.
 *
 * @param int $mapid
 *   The ID of the map being saved.
 * @param array $fields
 *   An associative array of fields and values, keyed by field name, containing:
 *   - target: String identifying target value.
 *   - keyfield: Boolean indicating if this is a key field.
 *   - picklist: (optional) String to override target.
 *   - filter: (optional) name of a filter defined by
 *             hook_salesforce_webforms_filter_info().
 */
function salesforce_webforms_save_fields($mapid, array $fields) {
  $i = 1;
  $schema_version = salesforce_webforms_schema_version();
  $include_filter = ($schema_version >= 7004);

  foreach ($fields as $fname => &$values) {
    // Only process if we are given source data.
    if (isset($values['picklist'])) {
      if (is_array($values['picklist'])) {
        if (count($values['picklist']) > 0) {
          $values['target'] = implode(';', $values['picklist']);
        }
      }
      elseif ($values['picklist'] != '') {
        $values['target'] = $values['picklist'];
      }
    }

    if ($values['target']) {
      $field_values = array(
        'mapid' => $mapid,
        'sf_fieldname' => $fname,
        'source_data' => $values['target'],
        'is_keyfield' => $values['keyfield'],
        'displayorder' => $i++,
      );
      if ($include_filter) {
        $field_values['filter'] = isset($values['filter']) ? $values['filter'] : NULL;
      }

      db_insert('salesforce_webforms_field')
        ->fields($field_values)
        ->execute();
    }
  }
}

/**
 * Gets the current webform version.
 */
function salesforce_webforms_webform_version() {
  // Keep track of the current version of webform.
  $webform_version = &drupal_static(__FUNCTION__);
  if (!$webform_version) {
    $info = system_get_info('module', 'webform');

    $webform_version = 3;
    if ($info['version']) {
      $versions = explode('-', $info['version']);
      $webform_version = $versions[1];
    }
  }

  return $webform_version;
}

/**
 * Gets the current database schema version for this module.
 */
function salesforce_webforms_schema_version() {
  static $version = NULL;

  if ($version === NULL) {
    module_load_include('inc', 'content', 'includes/install');
    $version = drupal_get_installed_schema_version('salesforce_webforms');
  }

  return $version;
}

/**
 * Implements hook_webform_submission_insert().
 */
function salesforce_webforms_webform_submission_insert($node, $sub, $update = FALSE, $force_error_display = FALSE) {
  // Skip if draft.
  if ($sub->is_draft) {
    return;
  }

  // Get the version of Webform to know how to filter.
  $webform_version = salesforce_webforms_webform_version();

  // See if we have any maps for this node.
  $maps = salesforce_webforms_get_node_maps($node->nid);
  if (!$maps || count($maps) == 0) {
    return;
  }
  else {
    // Load the settings.
    $settings = salesforce_webforms_settings_get($node->nid);
    if ($force_error_display) {
      // In admin. Always show error messages.
      $settings['suppress_errors'] = FALSE;
    }

    if ($update) {
      // Get any existing keys.
      $existing_keys = salesforce_webforms_get_submission_keys($sub->sid);
    }

    // Array of generated IDs to send to hook handlers.
    $mapped_ids = array();

    foreach ($maps as $map) {
      // Fields to use as keys.
      $keyfields = array();
      $fields = array();

      // Get the data and parse out the tokens.
      $object = $map['sf_object'];
      $mapname = $map['mapname'];

      foreach ($map['fields'] as $field) {
        $target = $field['sf_fieldname'];
        $source = $field['source_data'];
        $key = $field['keyfield'];

        // See if we're running on webform 3.x. If so, replace tokens.
        if ($webform_version < 4) {
          $filtered_source = _webform_filter_values($source, $node, $sub, NULL, FALSE, TRUE);
          if ($filtered_source != '') {
            $tokens = array(
              'node' => $node,
              'webform-submission' => $sub,
            );

            $new = token_replace($filtered_source, $tokens, array('clear' => TRUE));
            $filtered_source = $new;
          }
        }
        else {
          $filtered_source = webform_replace_tokens($source, $node, $sub, NULL, FALSE);
        }

        // Do we have any filters to apply?
        if (isset($field['filter'])) {
          $filtered_source = salesforce_webforms_filter_invoke($field['filter'], $filtered_source);
        }

        if ($key) {
          // We have a key field - try update first.
          $keyfields[$target] = $filtered_source;
        }

        $fields[$target] = $filtered_source;
      }

      // Skip if we didn't define any fields.
      if (count($fields) == 0) {
        continue;
      }

      // See if we are always creating new, or trying to update existing.
      $target_id = isset($existing_keys[$mapname]) ? $existing_keys[$mapname] : FALSE;
      if (!$target_id && count($keyfields) > 0) {
        // Try to find the ID.
        $sql = "SELECT Id FROM $object WHERE ";
        $union = "";
        foreach ($keyfields as $field => $val) {
          $sql .= "$union$field = '$val'";
          $union = " AND ";
        }
        $res = _salesforce_webforms_fetch("query?q=" . urlencode($sql), FALSE, $settings['suppress_errors']);
        if (count($res['records']) > 0) {
          $target_id = $res['records'][0]['Id'];
        }
      }

      // Call hook_salesforce_webforms_submission_save_alter.
      $context = array(
        'map' => $map,
        'node' => $node,
        'submission' => $sub,
        'id' => $target_id,
      );
      drupal_alter('salesforce_webforms_submission_save', $fields, $context);

      // @deprecated as of 7.x-1.1
      drupal_alter('salesforce_webforms_push_params', $fields, $context);

      if ($target_id) {
        // Do an update.
        $res = salesforce_webforms_update_object($object, $target_id, $fields, $settings['suppress_errors']);
      }
      else {
        $res = salesforce_webforms_create_object($object, $fields, $settings['suppress_errors']);
        $target_id = $res['id'];
      }

      $data = array(
        'sid' => $sub->sid,
        'mapname' => $map['mapname'],
        'sfid' => $target_id,
      );
      db_insert('salesforce_webforms_key')
        ->fields($data)
        ->execute();

      $mapped_ids[] = $data;
    }

    module_invoke_all('salesforce_webforms_save_submission', $mapped_ids, $sub->sid);
  }
}

/**
 * Implements hook_webform_submission_update().
 */
function salesforce_webforms_webform_submission_update($node, $sub) {
  // Call the insert hook, with instructions to update any existing maps.
  salesforce_webforms_webform_submission_insert($node, $sub, TRUE);
}

/**
 * Implements hook_webform_submission_delete().
 */
function salesforce_webforms_webform_submission_delete($node, $sub) {
  // Allow other modules to clean up if they need to on delete.
  module_invoke_all('salesforce_webforms_delete_submission', $sub->sid);

  // And delete the key data.
  db_delete('salesforce_webforms_key')
    ->condition('sid', $sub->sid)
    ->execute();
}

/**
 * Implements hook_webform_submission_actions().
 */
function salesforce_webforms_webform_submission_actions($node, $sub) {
  $actions = array();

  // See if we have any mappings.
  $map = salesforce_webforms_get_node_maps($node->nid);
  if (!$map) {
    return $actions;
  }

  if (webform_results_access($node) && user_access('resend salesforce webform results')) {
    $actions['sf'] = array(
      'title' => t('Resend to Salesforce'),
      'href' => 'node/' . $node->nid . '/submission/' . $sub->sid . '/sf',
      'query' => drupal_get_destination(),
    );
  }

  return $actions;
}

/**
 * Implements hook_token_info_alter().
 */
function salesforce_webforms_token_info_alter(&$data) {
  // See if we have 'submission' as a valid type.
  if (!isset($data['tokens']['submission'])) {
    // Add a dummy placeholder in case we're on an older version of webform.
    $data['types']['submission'] = array(
      'name' => t('Webform submission data'),
      'description' => t('Webform submission data.'),
      'dynamic' => TRUE,
    );
  }
  $data['tokens']['submission']['salesforce'] = array(
    'name' => t('Salesforce ID'),
    'description' => t('The unique ID of the Salesforce object associated with a webform mapping. Replace the "?" with the name of the mapping'),
    'dynamic' => TRUE,
  );
}

/**
 * Implements hook_tokens().
 */
function salesforce_webforms_tokens($type, $tokens, array $data = array(), $options = array()) {
  $replacements = array();

  if ($type == 'submission' && !empty($data['webform-submission'])) {
    $sub = $data['webform-submission'];

    if ($sf_tokens = token_find_with_prefix($tokens, 'salesforce')) {
      // We need map data. Load it up.
      $keys = salesforce_webforms_get_submission_keys($sub->sid);
      foreach ($sf_tokens as $name => $original) {
        $replacements[$original] = $keys[$name];
      }
    }
  }

  return $replacements;
}

/**
 * Implements hook_form_alter().
 */
function salesforce_webforms_form_alter(&$form, &$state, $fid) {
  // See if this is a webform with our components.
  $needs_update = FALSE;
  if (isset($state['webform']['component_tree']['children'])) {
    foreach ($state['webform']['component_tree']['children'] as $component) {
      if ($component['type'] == 'sf_picklist') {
        $needs_update = TRUE;
      }
    }
  }

  if ($needs_update) {
    $form['#attached']['js'][] = drupal_get_path('module', 'salesforce_webforms') . '/js/salesforce.js';
  }
}

/**
 * Implements hook_webform_select_options_info().
 */
function salesforce_webforms_webform_select_options_info() {
  $items = array();

  $objects = salesforce_webforms_get_objects_selection();
  foreach ($objects as $name => $label) {
    $items['salesforce_webforms_' . $name] = array(
      'title' => t('Salesforce @object records', array('@object' => $label)),
      'options callback' => 'salesforce_webforms_object_select_list',
      'options arguments' => $name,
    );
  }

  return $items;
}

/**
 * Implements hook_salesforce_webforms_filter_info().
 */
function salesforce_webforms_salesforce_webforms_filter_info() {
  return array(
    'salesforce webforms date' => array(
      'label' => t('Format as Salesforce Date'),
      'file' => 'salesforce_webforms.filters.inc',
      'callback' => 'salesforce_webforms_date_filter',
      'field types' => array('date'),
    ),
    'salesforce webforms date time' => array(
      'label' => t('Format as Salesforce Date/Time'),
      'file' => 'salesforce_webforms.filters.inc',
      'callback' => 'salesforce_webforms_datetime_filter',
      'field types' => array('datetime'),
    ),
  );
}

/**
 * Implements hook_webform_conditional_operator_info().
 */
function salesforce_webforms_webform_conditional_operator_info() {
  return array(
    'sf_picklist' => array(
      'equal' => array(
        'label' => t('is'),
        'comparison callback' => 'webform_conditional_operator_string_equal',
        'js comparison callback' => 'conditionalOperatorStringEqual',
        'form callback' => 'salesforce_webforms_conditional_select',
      ),
      'not_equal' => array(
        'label' => t('is not'),
        'comparison callback' => 'webform_conditional_operator_string_not_equal',
        'js comparison callback' => 'conditionalOperatorStringNotEqual',
        'form callback' => 'salesforce_webforms_conditional_select',
      ),
      'empty' => array(
        'label' => t('is empty'),
        'comparison callback' => 'webform_conditional_operator_string_empty',
        'js comparison callback' => 'conditionalOperatorStringEmpty',
        'form callback' => FALSE,
      ),
      'not_empty' => array(
        'label' => t('is not empty'),
        'comparison callback' => 'webform_conditional_operator_string_not_empty',
        'js comparison callback' => 'conditionalOperatorStringNotEmpty',
        'form callback' => FALSE,
      ),
    ),
  );
}

/**
 * Callback to build the list of records of the given object.
 *
 * @param array $object
 *   The object to query.
 *
 * @return array
 *   Array suitable to be used as an options form element.
 */
function salesforce_webforms_object_select_list(array $object) {
  $obj = $object['extra']['options_source'];
  // Throw away the prefix we added.
  $obj = substr($obj, strlen('salesforce_webforms_'));
  $recs = salesforce_webforms_get_object_records($obj);
  return $recs;
}

/**
 * Callback for picklist conditional fields.
 *
 * Patterned after webform_conditional_form_select() from webform module.
 */
function salesforce_webforms_conditional_select($node) {
  static $count = 0;
  $forms = array();

  webform_component_include('sf_picklist');
  foreach ($node->webform['components'] as $cid => $component) {
    if (webform_component_property($component['type'], 'conditional_type') == 'sf_picklist') {
      list($options) = _webform_sf_picklist_options($component);
      $element = array(
        '#type' => 'select',
        '#multiple' => FALSE,
        '#size' => NULL,
        '#attributes' => array(),
        '#id' => NULL,
        '#name' => 'webform-conditional-sf-picklist-' . $cid . '-' . $count,
        '#options' => $options,
        '#parents' => array(),
      );

      $forms[$cid] = drupal_render($element);
    }
  }

  $count++;
  return $forms;
}

/**
 * Loads data from Salesforce, optionally thorugh a cache.
 *
 * @param string $url
 *   The Salesforce URL used to fetch the data.
 * @param bool $use_cache
 *   A flag indicating whether to use the cached data (TRUE) or bypass and
 *   update the cache (FALSE).
 *
 * @return array
 *   The Salesforce response data.
 */
function _salesforce_webforms_fetch($url, $use_cache = TRUE, $suppress_errors = FALSE) {
  $data = NULL;
  // Do we need to switch languages for the connection?
  $lang = salesforce_webforms_language_prefix();
  $sf_lang = NULL;

  $cachename = "url:" . $lang . md5($url);
  if ($use_cache) {
    $cached = cache_get($cachename, 'cache_salesforce_webforms');
    if ($cached && $cached->expire >= time() && !empty($cached->data)) {
      return $cached->data;
    }
  }

  // Not in cache, or we're ignore the cache data.
  // Do we need to switch languages()?
  if ($lang) {
    $sf_lang = salesforce_webforms_get_sf_language();
    salesforce_webforms_set_sf_language(salesforce_webforms_language_code());
  }

  $sf = salesforce_webforms_get_sfapi();
  try {
    $data = $sf->apiCall($url);
  }
  catch (SalesforceException $e) {
    if (!$suppress_errors) {
      drupal_set_message(t('Salesforce webforms fetch data: @msg', array('@msg' => $e->getMessage())), 'error');
    }

    watchdog(
      'salesforce_webforms',
      'Salesforce Exception @code: @msg',
      array(
        '@msg' => $e->getMessage(),
        '@code' => $e->getCode(),
      ),
      WATCHDOG_ERROR);

    // See if we can still get the data from the cache.
    $cached = cache_get($cachename, 'cache_salesforce_webforms');
    if ($cached && $cached->expire >= time() && !empty($cached->data)) {
      $data = $cached->data;
    }
  }

  // Switch back to English if needed.
  if ($lang) {
    salesforce_webforms_set_sf_language($sf_lang);
  }

  // Update the cache with the data.
  cache_set($cachename, $data, 'cache_salesforce_webforms', time() + SALESFORCE_WEBFORMS_CACHE_DURATION);

  return $data;
}

/**
 * Gets the list of data filters defined by this and other modules.
 */
function salesforce_webforms_filters() {
  static $filters;

  if (!$filters) {
    $filters = array();

    // Invoke all of the hooks to define filters.
    foreach (module_implements('salesforce_webforms_filter_info') as $module) {
      $module_filters = module_invoke($module, 'salesforce_webforms_filter_info');
      foreach ($module_filters as $type => $info) {
        // Store the module name so we can include the file if needed.
        $module_filters[$type]['module'] = $module;
      }
      $filters += $module_filters;
    }

    // Invoke all implementations of hook_salesforce_webforms_filter_info_alter.
    drupal_alter('salesforce_webforms_filter_info', $filters);

    // Sort by the label.
    uasort($filters, function($a, $b) {
      return strnatcasecmp($a['label'], $b['label']);
    });
  }

  return $filters;
}

/**
 * Load a filter file into memory.
 *
 * @param string $filter_type
 *   The string machine name of the filter.
 */
function salesforce_webforms_filter_include($filter_type) {
  static $included = array();

  // Don't load it if we've already loaded this filter.
  if (!isset($included[$filter_type])) {
    $filters = salesforce_webforms_filters();
    $included[$filter_type] = TRUE;

    // Is the file attribute specified?
    if (($info = $filters[$filter_type]) && isset($info['file'])) {
      $pathinfo = pathinfo($info['file']);
      $basename = basename($pathinfo['basename'], '.' . $pathinfo['extension']);
      $path = (!empty($pathinfo['dirname']) ? $pathinfo['dirname'] . '/' : '') . $basename;
      module_load_include($pathinfo['extension'], $info['module'], $path);
    }
  }
}

/**
 * Invokes a filter.
 *
 * @param string $filter
 *   The machine name of the filter.
 * @param string $value
 *   The source value, after all tokens have been replaced.
 *
 * @return string|array
 *   The filtered value, as returned by the callback function.
 */
function salesforce_webforms_filter_invoke($filter, $value) {
  // Initialize the return value to be the same as the source.
  $return = $value;

  // Look up the filter.
  $filters = salesforce_webforms_filters();

  // Is there a callback specified?
  if (isset($filters[$filter]) && isset($filters[$filter]['callback'])) {
    $callback = $filters[$filter]['callback'];

    // Make sure the function's definition has been included.
    salesforce_webforms_filter_include($filter);
    if (function_exists($callback)) {
      $return = $callback($value);
    }
  }

  return $return;
}

/**
 * Implements hook_cron().
 */
function salesforce_webforms_cron() {
  // See if enough time has passed since the last run.
  $last = variable_get('salesforce_webforms_cron_last', 0);
  $min = variable_get('salesforce_webforms_cron_min', 60) * 60;
  $now = time();

  if ($last + $min > $now) {
    // Minimum time hasn't passed. Skip this run.
    return;
  }

  // Store the current time for the next interval check.
  variable_set('salesforce_webforms_cron_last', $now);

  // The list of possible picklists is big, so we
  // refresh the cache on a regular basis.
  watchdog("salesforce_webforms", "Initiate cache refresh");
  $objlist = salesforce_webforms_get_objects(FALSE);
  $queue = DrupalQueue::get('salesforce_webforms');
  $queue->createItem(array_keys($objlist));
}

/**
 * Implements hook_cron_queue_info().
 */
function salesforce_webforms_cron_queue_info() {
  $queues['salesforce_webforms'] = array(
    'worker callback' => 'salesforce_webforms_queue_obj',
    'time' => 120,
  );

  return $queues;
}

/**
 * Implements hook_flush_caches().
 */
function salesforce_webforms_flush_caches() {
  return array('cache_salesforce_webforms');
}

/**
 * Implements hook_permission().
 */
function salesforce_webforms_permission() {
  return array(
    'resend salesforce webform results' => array(
      'title' => t('Allow resending webform results to Salesforce'),
      'description' => t('Users with this permission can resend weborm data to Salesforce for any submission which they hav access to.'),
    ),
  );
}

/**
 * Refreshes the cache data for info on a given object or list of objects.
 *
 * @param string|string[] $objlist
 *   An object name, or an array of names, to be refreshed.
 */
function salesforce_webforms_queue_obj($objlist) {
  if (!is_array($objlist)) {
    $objlist = array($objlist);
  }

  foreach ($objlist as $obj) {
    watchdog("salesforce_webforms", "Cache refresh of %obj", array('%obj' => $obj));
    salesforce_webforms_get_object_fields($obj, FALSE);
  }
}

/**
 * Updates an existing Salesforce object.
 *
 * @param string $object
 *   The Salesforce internal name of the object type to be updated.
 * @param string $id
 *   The Salesforce ID of the object to be updated.
 * @param array $fields
 *   The fields and corresponding values to be stored.
 *
 * @return array|NULL
 *   The Salesforce response as an array.
 */
function salesforce_webforms_update_object($object, $id, array $fields, $suppress_errors = FALSE) {
  $sf = salesforce_webforms_get_sfapi();
  if (!$sf->isAuthorized()) {
    return NULL;
  }
  try {
    // $res = $sf->objectUpdate($object, 'id', $id, $fields);
    $res = $sf->objectUpsert($object, 'id', $id, $fields);
  }
  catch (SalesforceException $e) {
    if (!$suppress_errors) {
      drupal_set_message(t('Error updating Salesforce object: @msg', array('@msg' => $e->getMessage())), 'error');
    }

    watchdog(
      'salesforce_webforms',
      'Salesforce Exception @code: @msg',
      array(
        '@msg' => $e->getMessage(),
        '@code' => $e->getCode(),
      ),
      WATCHDOG_ERROR);

    return NULL;
  }

  return $res;
}

/**
 * Creates a new Salesforce object.
 *
 * @param string $object
 *   The Salesforce internal name of the object type to be creatd.
 * @param array $fields
 *   The fields and corresponding values to be stored.
 *
 * @return array|NULL
 *   The Salesforce response as an array.
 */
function salesforce_webforms_create_object($object, array $fields, $suppress_errors = FALSE) {
  $sf = salesforce_webforms_get_sfapi();
  try {
    $res = $sf->objectCreate($object, $fields);
  }
  catch (SalesforceException $e) {
    if (!$suppress_errors) {
      drupal_set_message(t('Error creating Salesforce object: @msg', array('@msg' => $e->getMessage())), 'error');
    }

    watchdog(
      'salesforce_webforms',
      'Salesforce Exception @code: @msg',
      array(
        '@msg' => $e->getMessage(),
        '@code' => $e->getCode(),
      ),
      WATCHDOG_ERROR);
    return NULL;
  }

  return $res;
}

/**
 * Get the path prefix for the specified language, or the current context.
 *
 * Used to ensure that cached objects are associated with the correct
 * language.
 *
 * @param string $lang
 *   The language to look up. If not specified, then the language of the
 *   currently loaded page will be used.
 *
 * @return string
 *   The prefix code to use for the specified or current language.
 */
function salesforce_webforms_language_prefix($lang = NULL) {
  if (isset($lang)) {
    $list = language_list('language');
    $prefix = $list[$lang]->prefix;
  }
  else {
    $prefix = $GLOBALS['language']->prefix;
  }
  if ($prefix != "") {
    $prefix .= "_";
  }
  return $prefix;
}

/**
 * Sets the language attribute of the salesforce API user.
 *
 * This is a workaround, since it's not possible within SalesForce
 * to specify the language to return for picklists. To get around
 * that, we temporarily set the active language of the user
 * authenticated to SalesForce to that language. We then set it back
 * when we're done.
 *
 * @param string $lang
 *   The language code to make active.
 */
function salesforce_webforms_set_sf_language($lang) {
  $sf = salesforce_webforms_get_sfapi();
  if (!$sf->isAuthorized()) {
    return NULL;
  }

  $id_obj = $sf->getIdentity();
  $id = $id_obj['user_id'];
  $fields = array(
    'LanguageLocaleKey' => $lang,
  );
  salesforce_webforms_update_object("User", $id, $fields);
}

/**
 * Gets the language attribute of the Salesforce API user.
 *
 * This is used so that we can reset it back if we change it to get data
 * in a non-default language.
 *
 * @return string|NULL
 *   The Salesforce language attribute or NULL on error.
 */
function salesforce_webforms_get_sf_language() {
  $sf = salesforce_webforms_get_sfapi();
  if (!$sf->isAuthorized()) {
    return NULL;
  }

  $id_obj = $sf->getIdentity();

  return $id_obj['language'];
}

/**
 * Builds an array of objects of the given type usable as an options array.
 *
 * @param string $object
 *   The object to query.
 *
 * @return array
 *   An associative array suitable for use as an #options element, where the
 *   key is the Salesforce ID, and the value is built based on a best guess
 *   as to an intelligent label for that object.
 */
function salesforce_webforms_get_object_records($object) {
  $details = salesforce_webforms_get_object_fields($object);

  // Start building up the query.
  $sql = "SELECT id";

  // Use a 'Name' field if one exists.
  if (isset($details['Name'])) {
    $sql .= ",name";
  }

  // Special handling for case objects.
  if (isset($details['CaseNumber'])) {
    $sql .= ',CaseNumber';
  }

  $sql .= " FROM $object";

  // If the object supports the 'IsDeleted' flag then use it to filter.
  if (isset($details['IsDeleted'])) {
    $sql .= " WHERE IsDeleted=FALSE";
  }

  $records = _salesforce_webforms_fetch("query?q=" . urlencode($sql));
  $options = array();

  foreach ($records['records'] as $row) {
    $id = $row['Id'];

    if (isset($row['Name'])) {
      $options[$id] = $row['Name'];
    }
    elseif (isset($row['CaseNumber'])) {
      $options[$id] = $row['CaseNumber'];
    }
    else {
      $options[$id] = $id;
    }
  }

  drupal_alter('salesforce_webforms_object_records', $options);

  return $options;
}

/**
 * Builds a grouped array of picklists usable as an options array.
 *
 * @param bool $limit
 *   If TRUE, then only those options allowed by the admin settings will
 *   be returned.
 *
 * @return array
 *   An associative array suitable for use as an #options element, where the
 *   key is the object name concatinated with a "." and the field name, and
 *   the value is the label of the field.
 */
function salesforce_webforms_get_picklist_options($limit = TRUE) {
  $picklists = array();

  // See if we should limit the list.
  if ($limit) {
    $all = variable_get('salesforce_webforms_all_picklists', SALESFORCE_WEBFORMS_INCLUDE_ALL);
    if ($all == SALESFORCE_WEBFORMS_INCLUDE_FILTERED) {
      $list = variable_get('salesforce_webforms_picklists', array());
    }
    else {
      $limit = FALSE;
    }
  }

  $objlist = salesforce_webforms_get_objects();
  foreach (array_keys($objlist) as $obj) {
    $fields = salesforce_webforms_get_object_fields($obj);
    $picklists[$obj] = array();
    foreach ($fields as $fieldname => $details) {
      // Is this a picklist?
      if ($details['type'] == 'picklist' || $details['type'] == 'multipicklist') {
        $key = $obj . "." . $fieldname;

        if (!$limit || isset($list[$key])) {
          $picklists[$obj][$key] = $details['label'];
        }
      }
    }

    // Throw away the option if no picklists.
    if (count($picklists[$obj]) == 0) {
      unset($picklists[$obj]);
    }
  }

  drupal_alter('salesforce_webforms_picklists', $picklists);
  return $picklists;
}

/**
 * Gets the Salesforce language code for the given Drupal language code.
 *
 * In most instances, these two values are the same. However, for English,
 * Drupal uses 'en' while Salesforce expects 'en_US'. Also, when the country
 * is included in the language code, Drupal follows RFC 4646, where the string
 * is of the form ll-CC, while Salesforce expects ll_CC.
 *
 * @param string $language
 *   The language to query. If not specified, the language of the current
 *   page is used.
 *
 * @return string
 *   The Salesforce language code corresponding to the Drupal language code.
 */
function salesforce_webforms_language_code($language = NULL) {
  if (!isset($language)) {
    $language = $GLOBALS['language']->language;
  }

  if ($language == 'en') {
    $language = 'en_US';
  }

  // Map dashes (-) (RFC 4646)  to underscore (_) (Salesforce standard).
  $language = str_replace("-", "_", $language);

  return $language;
}
