<?php

/**
 * @defgroup dr_line_item_minmax_impl Implements minmax restriction types.
 * @{
 * Implements "fixed date" and "relative interval" minmax restrictions types.
 */

/**
 * Implements hook_date_restrictions_minmax_info().
 */
function date_restrictions_commerce_line_item_date_restrictions_minmax_info() {
  return array(
    'product_display_date' => array(
      'title' => t('Product display: get fixed date from a source field'),
      'settings' => array(
        'source_field' => null,
        'end_date' => false,
      ),
    ),
    'product_display_interval' => array(
      'title' => t('Product display: get relative date from a source field'),
      'dependencies' => 'interval',
    )
  );
}

/**
 * Implements minmax_settings_form callback.
 */
function date_restrictions_commerce_line_item_minmax_settings_form($type, $limit, $default_value, $context) {
  $instance = $context['instance'];
  $bundles = date_restrictions_commerce_line_item_get_product_displays($instance['bundle']);

  switch ($type) {
    case 'product_display_date':
      $options = date_restrictions_get_bundle_instances_as_options($bundles, array('date', 'datetime', 'datestamp'));
      $elements = array(
        '#theme_wrappers' => array('container'),
        '#attributes' => array('class' => array('container-inline')),
      );
      $elements['source_field'] = array(
        '#type' => 'select',
        '#title' => t('Source field'),
        '#options' => $options,
        '#default_value' => $default_value['source_field'],
      );
      $elements['end_date'] = array(
        '#type' => 'checkbox',
        '#title' => t("Use end date value. If not available, this restriction won't take effect."),
        '#default_value' => $default_value['end_date'],
      );
      break;
    case 'product_display_interval':
      $options = date_restrictions_get_bundle_instances_as_options($bundles, 'interval');
      $elements = array(
        '#type' => 'select',
        '#title' => t('Source field'),
        '#options' => $options,
        '#default_value' => $default_value,
      );
      break;
  }

  return $elements;
}

/**
 * Implements minmax_settings_validate callback.
 */
function date_restrictions_commerce_line_item_minmax_settings_validate($type, $limit, $value, $form) {
  # For some reason $value is not empty if it had a previous value and the related field has been deleted.
  switch ($type) {
    case 'product_display_date':
      $element = $form[$limit][$type]['source_field'];
      $option = $value['source_field'];
      break;
    case 'product_display_interval':
      $element = $form[$limit][$type];
      $option = $value;
      break;
  }
  if (!isset($element['#options'][$option])) {
    $label = ($limit == 'min') ? t('Minimum date') : t('Maximum date');
    form_error($element, t("@label: source field can't be empty.", array('@label' => $label)));
  }
}

/**
 * Implements minmax_date_popup_settings callback.
 */
function date_restrictions_commerce_line_item_minmax_date_popup_settings($type, $limit, $settings, $element, $form_state, $context) {
  $source_field = ($type == 'product_display_date') ? $settings['source_field'] : $settings;
  $items = date_restrictions_commerce_line_item_get_source_field_values($form_state, $source_field);
  if (empty($items)) {
    return;
  }

  switch ($type) {
    case 'product_display_date':
      $date = (!$settings['end_date']) ? $items[0]['value'] : $items[0]['value2'];
      $date = new DateObject($date, $items[0]['timezone']);
      $date_format = date_popup_date_format($element);
      $value = date_format_date($date, 'custom', $date_format);
      break;
    case 'product_display_interval':
      $interval = $items[0];
      $value = $interval['interval'] . ' ' . $interval['period'][0];
      break;
  }

  return $value;
}

/**
 * Implements minmax_restriction_date callback.
 */
function date_restrictions_commerce_line_item_minmax_restriction_date($type, $settings, $element, $form_state) {
  $source_field = ($type == 'product_display_date') ? $settings['source_field'] : $settings;
  $items = date_restrictions_commerce_line_item_get_source_field_values($form_state, $source_field);
  if (empty($items)) {
    return;
  }

  $timezone = $element['#date_timezone'];
  $date = null;
  switch ($type) {
    case 'product_display_date':
      $date = $items[0];
      $date = (!$settings['end_date']) ? $items[0]['value'] : $items[0]['value2'];
      $date = new DateObject($date, $items[0]['timezone']);
      break;
    case 'product_display_interval':
      $interval = $items[0];
      $date = new DateObject('now', $timezone);
      interval_apply_interval($date, $interval);
      break;
  }

  return $date;
}

/**
 * @}
 * End of "defgroup dr_line_item_minmax_impl"
 */

/**
 * @defgroup dr_line_item_allowed_values_impl Implements allowed_values restriction types.
 * @{
 */

/**
 * Implements hook_date_restrictions_allowed_values_info().
 */
function date_restrictions_commerce_line_item_date_restrictions_allowed_values_info() {
  return array(
    'product_display_date' => array(
      'title' => t('Product display: get allowed dates from a source field'),
    ),
  );
}

/**
 * Implements allowed_values_settings_form callback.
 */
function date_restrictions_commerce_line_item_allowed_values_settings_form($type, $default_value, $context) {
  $instance = $context['instance'];
  $bundles = date_restrictions_commerce_line_item_get_product_displays($instance['bundle']);

  switch ($type) {
    case 'product_display_date':
      $options = date_restrictions_get_bundle_instances_as_options($bundles, array('date', 'datetime'));
      $element = array(
        '#type' => 'select',
        '#title' => t('Source field'),
        '#options' => $options,
        '#default_value' => $default_value,
      );
      break;
  }

  return $element;
}

/**
 * Implements allowed_values_remitter_pack callback.
 */
function date_restrictions_commerce_line_item_allowed_values_remitter_pack($type, $element, $form_state) {
  $line_item = $form_state['line_item'];
  return $line_item->type . ':' . $element['#field']['id'] . ':' . $line_item->data['context']['entity']['entity_id'];
}

/**
 * Implements allowed_values_remitter_unpack callback.
 */
function date_restrictions_commerce_line_item_allowed_values_remitter_unpack($type, $remitter) {
  list($line_item_bundle, $field_id, $entity_id) = explode(':', $remitter);
  $field_info = field_info_field_by_id($field_id);
  $instance_info = field_info_instance('commerce_line_item', $field_info['field_name'], $line_item_bundle);
  $settings = $instance_info['settings']['restrictions']['allowed_values'][$type];
  return array(
    'entity_id' => $entity_id,
    'settings' => $settings,
  );
}

/**
 * Implements allowed_values_access_callback callback.
 */
function date_restrictions_commerce_line_item_allowed_values_access_callback($type, $remitter) {
  list($entity_type, $bundle, $field_name) = explode(':', $remitter['settings']);
  $entity = entity_load_single($entity_type, $remitter['entity_id']);
  return entity_access('view', $entity_type, $entity);
}

/**
 * Implements allowed_values_page_callback callback.
 *
 * It performs direct access to the database instead of loading the entity to
 * improve performance.
 *
 * @todo add cache.
 */
function date_restrictions_commerce_line_item_allowed_values_page_callback($type, $remitter, $year, $month) {
  list($entity_type, $bundle, $field_name) = explode(':', $remitter['settings']);
  $entity_id = $remitter['entity_id'];
  $entity_info = entity_get_info($entity_type);
  $field_info = field_info_field($field_name);

  switch ($type) {
    case 'product_display_date':
      // Start and end dates for the given month.
      $start = new DateObject("$year-$month-01");
      $start = date_restrictions_prepare_db_date($start, $field_info);
      $days = date_days_in_month($year, $month);
      $end = new DateObject("$year-$month-$days");
      $end = date_restrictions_prepare_db_date($end, $field_info);

      // Get date values in the month range.
      $query = new EntityFieldQueryExtraFields();
      $query
        ->entityCondition('entity_type', $entity_type)
        ->propertyCondition($entity_info['entity keys']['id'], $entity_id)
        ->fieldCondition($field_name, 'value', array($start, $end), 'BETWEEN')
        ->addExtraField($field_name, 'value', 'value');
      $values = $query->execute();

      // Iterate values obtained from the database, adjust timezone and build an
      // array of output data.
      $dates = array();
      if (!empty($values[$entity_type])) {
        // Prepare timezone.
        $timezone = new DateTimeZone(date_get_timezone($field_info['settings']['tz_handling']));
        $timezone_db = new DateTimeZone(date_get_timezone_db($field_info['settings']['tz_handling']));
        $db_format = date_type_format($field_info['type']);
        $values = $values[$entity_type][$entity_id]->extraFields->{$field_name . '_value'};
        // If there's only a value it won't be an array.
        if (!is_array($values)) {
          $values = array($values);
        }
        foreach ($values as $value) {
          $date = new DateObject($value, $timezone_db, $db_format);
          date_timezone_set($date, $timezone);
          $dates[] = $date->format('Y-m-d');
        }
      }
      break;
  }

  return $dates;
}

/**
 * Implements allowed_values_valid_date callback.
 */
function date_restrictions_commerce_line_item_allowed_values_valid_date($date, $type, $settings, $element, $form_state, $form) {
  list($entity_type, $bundle, $field_name) = explode(':', $settings[$type]['source_field']);
  $line_item = $form_state['line_item'];
  $entity_id = $line_item->data['context']['entity']['entity_id'];
  switch ($type) {
    case 'product_display_date':
      return date_restrictions_is_allowed_date($date, $entity_type, $field_name, $entity_id);
      break;
  }

  return false;
}

/**
 * @}
 * End of "defgroup dr_line_item_allowed_values_impl"
 */

/**
 * Query a date field's table to check if a value exists.
 *
 * @todo move to main module?
 */
function date_restrictions_is_allowed_date($date, $entity_type, $field_name, $entity_id) {
  $entity_info = entity_get_info($entity_type);
  $field_info = field_info_field($field_name);

  $date = date_restrictions_prepare_db_date($date, $field_info);

  $query = new EntityFieldQueryExtraFields();
  $query
    ->entityCondition('entity_type', $entity_type)
    ->propertyCondition($entity_info['entity keys']['id'], $entity_id)
    ->fieldCondition($field_name, 'value', $date, 'STARTS_WITH');

  $r = $query->execute();
  return (!empty($r));
}

/**
 * Converts date to db format and timezone of given field.
 *
 * @todo move to main module?
 */
function date_restrictions_prepare_db_date($date, $field_info) {
  $timezone_db = date_get_timezone_db($field_info['settings']['tz_handling']);
  date_timezone_set($date, timezone_open($timezone_db));
  $date = date_format($date, date_type_format($field_info['type']));
  return substr($date, 0, 10);
}

/**
 * Obtains bundles related to a line item type via a product_reference field.
 *
 * 1. Obtain entity_type, field_name and bundle of every
 *    commerce_product_reference instance.
 * 2. Iterate each commerce_product_reference instance and
 *    check if the line_item_type used in its add to cart form
 *    is the same one which contains the date instance being
 *    configured.
 */
function date_restrictions_commerce_line_item_get_product_displays($line_item_type) {
  $static = &drupal_static(__FUNCTION__);
  if (!isset($static)) {
    $static = array();
  }
  if (!isset($static[$line_item_type])) {
    // Get a list of node template variants indexed by node type.
    if (module_exists('panels')) {
      $panels_handlers = array();
      $task = page_manager_get_task('node_view');
      ctools_get_plugins('page_manager', 'task_handlers', 'panel_context');
      $handlers = page_manager_load_sorted_handlers($task, '', TRUE);
      foreach ($handlers as $handler) {
        foreach ($handler->conf['access']['plugins'] as $plugin) {
          if ($plugin['name'] == 'node_type') {
            $panels_handlers[reset($plugin['settings']['type'])] = $handler;
          }
        }
      }
    }

    // Get a list of entity type and bundle containing product_reference fields
    // using our line item type for the add to cart form.
    $bundles = array();
    $query = db_select('field_config_instance', 'fci');
    $query->join('field_config', 'fc', 'fci.field_name = fc.field_name');
    $query
      ->fields('fci', array('entity_type', 'bundle', 'field_name'))
      ->condition('fc.type', 'commerce_product_reference')
      ->condition('fci.entity_type', 'commerce_line_item', '!=');
    $result = $query->execute();

    while ($pr = $result->fetchObject()) {
      $pr_instance = field_info_instance($pr->entity_type, $pr->field_name, $pr->bundle);

      // Check if any display of the entity bundle is using our line item type.
      foreach ($pr_instance['display'] as $display) {
        if (($display['type'] == 'commerce_cart_add_to_cart_form') && ($display['settings']['line_item_type'] == $line_item_type)) {
          $bundles[$pr->entity_type][] = $pr->bundle;
        }
      }

      // Check also if it is being used in a panels' node view template.
      if (module_exists('panels')) {
        foreach ($panels_handlers as $node_type => $handler) {
          $display = panels_panel_context_get_display($handler);
          foreach ($display->content as $pane) {
            $subtype = $pr->entity_type.':'.$pr->field_name;
            if (($pane->subtype == $subtype) &&
                ($pane->configuration['formatter'] == 'commerce_cart_add_to_cart_form') &&
                ($pane->configuration['formatter_settings']['line_item_type'] == $line_item_type)) {
              $bundles[$pr->entity_type][] = $pr->bundle;
            }
          }
        }
      }
    }

    $static[$line_item_type] = $bundles;
  }

  return $static[$line_item_type];
}

/**
 * Obtain values from the source field in a product display.
 */
function date_restrictions_commerce_line_item_get_source_field_values($form_state, $source_field) {
  $line_item = $form_state['line_item'];
  list($entity_type, $bundle, $field_name) = explode(':', $source_field);
  $entity = entity_load_single($entity_type, $line_item->data['context']['entity']['entity_id']);
  return field_get_items($entity_type, $entity, $field_name);
}
