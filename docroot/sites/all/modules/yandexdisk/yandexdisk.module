<?php

/**
 * @file
 * Main functions and hook implementations.
 */

/**
 * Implements hook_stream_wrappers().
 */
function yandexdisk_stream_wrappers() {
  return array(
    'yandexdisk' => array(
      'name' => t('Yandex.Disk'),
      'class' => 'YandexDiskStreamWrapper',
      'description' => t('Files served by Yandex.Disk cloud service.'),
    ),
  );
}

/**
 * Implements hook_permission().
 */
function yandexdisk_permission() {
  return array(
    'view own yandexdisk resources' => array(
      'title' => t('View own Yandex.Disk resources'),
      'description' => t('Download files, get directories structure, read resources properties of own account.'),
    ),
    'view any yandexdisk resources' => array(
      'title' => t('View any Yandex.Disk resources'),
      'description' => t('Download files, get directories structure, read resources properties of any account.'),
      'restrict access' => TRUE,
    ),
    'edit own yandexdisk resources' => array(
      'title' => t('Edit own Yandex.Disk resources'),
      'description' => t('Create, update and delete resources of own account.'),
    ),
    'edit any yandexdisk resources' => array(
      'title' => t('Edit any Yandex.Disk resources'),
      'description' => t('Create, update and delete resources of any account.'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_form_FORM_ID_alter() for user_admin_permissions().
 */
function yandexdisk_form_user_admin_permissions_alter(&$form, &$form_state) {
  // Disable permissions that don't make sense for anonymous users.
  $form['checkboxes'][DRUPAL_ANONYMOUS_RID]['view own yandexdisk resources']['#disabled'] = TRUE;
  $form['checkboxes'][DRUPAL_ANONYMOUS_RID]['edit own yandexdisk resources']['#disabled'] = TRUE;
}

/**
 * Saves the access token information record to the database.
 *
 * @param string $name
 *   Yandex account name.
 * @param int $uid
 *   Site's user ID.
 * @param string $token
 *   The access token string.
 * @param int $expire
 *   Token expiration timestamp.
 *
 * @return int|false
 *   If the record insert or update failed, returns FALSE. If it succeeded,
 *   returns SAVED_NEW or SAVED_UPDATED, depending on the operation performed.
 */
function yandexdisk_token_save($name, $uid, $token, $expire) {
  $record = array(
    'name'   => $name,
    'uid'    => $uid,
    'token'  => $token,
    'expire' => $expire,
  );

  if (yandexdisk_token_load($name)) {
    $success = drupal_write_record('yandexdisk_access_tokens', $record, 'name');
  }
  else {
    $success = drupal_write_record('yandexdisk_access_tokens', $record);
  }

  if (!$success) {
    $vars = array('!user' => theme('username', array('account' => user_load($uid))));
    watchdog('yandexdisk', 'Cannot save the access token for the user !user.', $vars, WATCHDOG_ERROR);
  }

  return $success;
}

/**
 * Given an account name loads the access token information from a database.
 *
 * @param string $name
 *   Yandex account name.
 * @param bool $fresh
 *   (optional) Set to TRUE to load only unexpired token.
 *
 * @return array|false
 *   Associative array with token info if conditions matching token exists. See
 *   yandexdisk_access_tokens DB schema fields to find all elements of an array.
 *   Otherwise returns FALSE.
 */
function yandexdisk_token_load($name, $fresh = FALSE) {
  $cache = &drupal_static(__FUNCTION__, array());

  if (!isset($cache[$name])) {
    $cache[$name] = db_query('SELECT * FROM {yandexdisk_access_tokens} WHERE name = :name', array(':name' => $name))->fetchAssoc();
  }

  if ($fresh && $cache[$name] && $cache[$name]['expire'] <= REQUEST_TIME) {
    return FALSE;
  }

  return $cache[$name];
}

/**
 * Generates string to use directly in authorization header.
 *
 * @param string $name
 *   Yandex account name.
 *
 * @return string|null
 *   String on success, NULL if corresponding access token is not found or
 *   expired.
 */
function yandexdisk_auth_string($name) {
  if ($token = yandexdisk_token_load($name, TRUE)) {
    return 'OAuth ' . $token['token'];
  }
}

/**
 * Determines whether a user may perform the operation on the uri.
 *
 * @param string $op
 *   The operation to be performed on the uri. Possible values are:
 *   - 'get'.
 *   - 'put'.
 *   - 'mkcol'.
 *   - 'copy'.
 *   - 'move'.
 *   - 'delete'.
 *   - 'propfind'.
 *   - 'proppatch'.
 * @param string $uri
 *   The Yandex.Disk uri (yandexdisk://yandex_username/path) on which the
 *   operation is to be performed.
 * @param object|null $account
 *   (optional) A user object representing the user for whom the operation is to
 *   be performed. Determines access for a user other than the current user.
 *
 * @return bool
 *   TRUE if the operation may be performed, FALSE otherwise.
 */
function yandexdisk_access($op, $uri, $account = NULL) {
  $rights = &drupal_static(__FUNCTION__, array());

  // If no user object is supplied, the access check is for the current user.
  if (empty($account)) {
    $account = $GLOBALS['user'];
  }

  // If we've already checked access for this uri, user and op, return from
  // cache.
  if (!isset($rights[$account->uid][$uri][$op])) {
    // We grant access to the uri if both of the following conditions are met:
    // - No modules say to deny access.
    // - At least one module says to grant access.
    // If no module specified either allow or deny, we fall back to the FALSE.
    $access = module_invoke_all('yandexdisk_access', $op, $uri, $account);
    if (in_array(TRUE, $access, TRUE) && !in_array(FALSE, $access, TRUE)) {
      $rights[$account->uid][$uri][$op] = TRUE;
    }
    else {
      $rights[$account->uid][$uri][$op] = FALSE;
    }
  }

  return $rights[$account->uid][$uri][$op];
}

/**
 * Implements hook_yandexdisk_access().
 */
function yandexdisk_yandexdisk_access($op, $uri, $account) {
  $parsed_url = parse_url($uri);
  $token = yandexdisk_token_load($parsed_url['host']);

  // Not all Yandex accounts belong to authenticated users. For this case we
  // don't give anonymous users access to 'own' Yandex.Disks (accounts
  // associated with uid 0).
  $own_account = $account->uid && $account->uid == $token['uid'];

  switch ($op) {
    case 'get':
    case 'propfind':
      if (user_access('view any yandexdisk resources', $account) || $own_account && user_access('view own yandexdisk resources', $account)) {
        return TRUE;
      }
      break;

    case 'put':
    case 'mkcol':
    case 'copy':
    case 'move':
    case 'delete':
    case 'proppatch':
      if (user_access('edit any yandexdisk resources', $account) || $own_account && user_access('edit own yandexdisk resources', $account)) {
        return TRUE;
      }
      break;
  }
}

/**
 * Implements hook_cron().
 */
function yandexdisk_cron() {
  // This is the only way to get info from yandex_services_auth module.
  if (module_exists('yandex_services_auth')) {
    $token = variable_get('yandex_services_auth_token');
    $expire = variable_get('yandex_services_auth_timestamp');

    // Check if the access token already exists and the token expiration
    // time is in the future. We need this check of timestamp variable because
    // of a bug in older versions of yandex_services_auth module, where it was
    // set to the current time, and not to the token expiration time like it is
    // done in the latest version.
    if ($token && $expire > REQUEST_TIME) {
      try {
        $disk = new YandexDiskApiWebdavHelper('OAuth ' . $token);
        // We don't know an account owner, so set to 0.
        yandexdisk_token_save($disk->getUser(), 0, $token, $expire);
      }
      catch (YandexDiskException $e) {
        watchdog_exception('yandexdisk', $e);
      }
    }
  }
}

/**
 * Implements hook_hybridauth_user_login().
 *
 * @see yandexdisk_hybridauth_identity_added()
 */
function yandexdisk_hybridauth_user_login($account, $data) {
  if ($data['provider'] == 'Yandex') {
    // Add/update account's access token.
    $token_info = hybridauth_get_instance()->getAdapter('Yandex')->getAccessToken();
    yandexdisk_token_save($data['displayName'], $account->uid, $token_info['access_token'], $token_info['expires_at']);
  }
}

/**
 * Implements hook_hybridauth_identity_added().
 *
 * @see yandexdisk_hybridauth_user_login()
 */
function yandexdisk_hybridauth_identity_added($account, $data) {
  yandexdisk_hybridauth_user_login($account, $data);
}

/**
 * Implements hook_hybridauth_identity_deleted().
 */
function yandexdisk_hybridauth_identity_deleted($account, $data) {
  if ($data['provider'] == 'Yandex') {
    // Delete account's access token.
    db_delete('yandexdisk_access_tokens')
      ->condition('name', $data['displayName'])
      ->execute();
  }
}

/**
 * Creates a directory in Disk recursively.
 *
 * A helper function to work with specified Disk.
 *
 * @param \YandexDiskApiWebdav $disk
 *   Disk instance.
 * @param string $path
 *   Path to the directory to be created, relative to the root, and with a
 *   leading slash.
 *
 * @return bool
 *   Returns TRUE on success or FALSE on failure.
 */
function yandexdisk_mkdir_recursive(YandexDiskApiWebdav $disk, $path) {
  $levels = explode('/', trim($path, '/'));
  $count = count($levels);
  $success = FALSE;

  // Iterate from the deepest path to first found existing directory.
  for ($i = $count; $i > 0; $i--) {
    $path = '/' . implode('/', array_slice($levels, 0, $i)) . '/';
    if ($disk->mkcol($path)->execute()) {
      $success = TRUE;
      break;
    }
  }

  if ($success) {
    // Now iterate from existing path and create each new directory.
    for (++$i; $i <= $count; $i++) {
      $path = '/' . implode('/', array_slice($levels, 0, $i)) . '/';
      if (!$disk->mkcol($path)->execute()) {
        $success = FALSE;
        break;
      }
    }
  }

  return $success;
}

/**
 * Copies a resource with all included contents between two Disks.
 *
 * A helper function to work with specified Disks.
 *
 * @param \YandexDiskApiWebdavHelper $src_disk
 *   Source Disk instance.
 * @param string $src_path
 *   Source path, relative to the root, and with a leading slash.
 * @param \YandexDiskApiWebdavHelper $dst_disk
 *   Destination Disk instance.
 * @param string $dst_path
 *   Destination path, relative to the root, and with a leading slash.
 *
 * @return bool
 *   Returns TRUE on success or FALSE on failure.
 */
function yandexdisk_copy_recursive(YandexDiskApiWebdavHelper $src_disk, $src_path, YandexDiskApiWebdavHelper $dst_disk, $dst_path) {
  if ($src_disk->isFile($src_path)) {
    $data = $src_disk->read($src_path, NULL, NULL);
    $properties = $src_disk->getProperties($src_path);
    return $dst_disk->write($dst_path, $data, $properties['d:getcontenttype']);
  }
  elseif (yandexdisk_mkdir_recursive($dst_disk, $dst_path)) {
    foreach ($src_disk->scanDir($src_path) as $item_name) {
      if (!yandexdisk_copy_recursive($src_disk, $src_path . '/' . $item_name, $dst_disk, $dst_path . '/' . $item_name)) {
        return FALSE;
      }
    }
    return TRUE;
  }

  return FALSE;
}
