<?php

/**
 * @file
 * Node Access Keys helps to grant users temporary view permissions.
 */

/**
 * Implements hook_help().
 */
function nodeaccesskeys_help($section) {
  switch ($section) {
    case 'admin/config#description':
      return t('Access Keys helps to grant users temporary view permissions.');
  }
}

/**
 * Implements hook_views_api().
 */
function nodeaccesskeys_views_api() {
  return array(
    'api' => 3,
  );
}

/**
 * Implements hook_permission().
 *
 * @see hook_permissions()
 */
function nodeaccesskeys_permission() {
  return array(
    'administer node access keys' => array(
      'title' => t('Administer Node Access Keys'),
      'description' => t('May add, delete, and edit Node Access Keys as well as manage their settings.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function nodeaccesskeys_menu() {
  // Administration overview page.
  $items['admin/config/people/nodeaccesskeys'] = array(
    'title' => 'Node Access Keys',
    'description' => "Edit your site's Access Keys.",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nodeaccesskeys_list'),
    'access arguments' => array('administer node access keys'),
    'weight' => -5,
    'file' => 'nodeaccesskeys.admin.inc',
  );

  // Tab for Administration overview page.
  $items['admin/config/people/nodeaccesskeys/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  // Administration settings page.
  $items['admin/config/people/nodeaccesskeys/settings'] = array(
    'title' => 'Settings',
    'description' => "Edit Node Access Keys Settings.",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nodeaccesskeys_settings'),
    'access arguments' => array('administer node access keys'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,
    'file' => 'nodeaccesskeys.admin.inc',
  );

  // Administration page for adding Access Keys.
  $items['admin/config/people/nodeaccesskeys/add'] = array(
    'title' => 'Add Access Key',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nodeaccesskeys_add'),
    'access arguments' => array('administer node access keys'),
    'description' => 'Add an Access Key to your site.',
    'file' => 'nodeaccesskeys.admin.inc',
    'type' => MENU_LOCAL_ACTION,
  );

  // Administration page for editing an Access Key.
  $items['admin/config/people/nodeaccesskeys/%/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nodeaccesskeys_edit', 4),
    'access arguments' => array('administer node access keys'),
    'weight' => 0,
    'file' => 'nodeaccesskeys.admin.inc',
  );

  // Administration page for deleting an Access Key.
  $items['admin/config/people/nodeaccesskeys/%/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('nodeaccesskeys_delete', 4),
    'access arguments' => array('administer node access keys'),
    'weight' => 1,
    'file' => 'nodeaccesskeys.admin.inc',
  );

  // Permission denied page (403) with Node Access Key form.
  $items['nodeaccesskeys/denied'] = array(
    'title' => 'Access denied',
    'page callback' => 'nodeaccesskeys_denied',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  // A page used to clear a user's Node Access Keys session.
  $items['nodeaccesskeys/clear'] = array(
    'title' => 'Session ended',
    'page callback' => 'nodeaccesskeys_end_session',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Function to add a Node Access Key.
 *
 * @return int|false
 *   The function returns the Access Key's ID or FALSE if the key was empty.
 */
function nodeaccesskeys_add_key($accesskey, $node_types = array(), $roles = array()) {
  // Validate node types.
  $node_types_available = array_keys(node_type_get_names());
  $node_types = array_values(array_intersect($node_types, $node_types_available));

  // Validate roles.
  $role_ids = array_keys(user_roles());
  $roles = array_values(array_intersect($roles, $role_ids));

  if (!empty($accesskey)) {
    $aid = db_insert('nodeaccesskeys')->fields(array(
      'accesskey' => $accesskey,
      'nodetypes' => serialize($node_types),
      'roles' => serialize($roles),
    ))
    ->execute();

    node_access_rebuild();
    return $aid;
  }
  return FALSE;
}

/**
 * Access Key form builder.
 *
 * @see nodeaccesskeys_form_validate()
 * @see nodeaccesskeys_form_submit()
 * @ingroup forms
 */
function nodeaccesskeys_form($form, &$form_state) {

  $node_type = _nodeaccesskeys_get_node_type();
  if ($node_type === FALSE) {
    $node_type = variable_get('nodeaccesskeys_default_node_type', NULL);
  }

  $form_state['node_type'] = $node_type;

  $form['accesskey'] = array(
    '#type' => 'password',
    '#title' => t('Access Key'),
    '#size' => 60,
    '#maxlength' => 256,
    '#required' => TRUE,
  );

  $form['actions'] = array('#type' => 'actions');
  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Validate'),
  );

  return $form;
}

/**
 * Form validation handler for nodeaccesskeys_form().
 *
 * @see nodeaccesskeys_form_submit()
 * @ingroup forms
 */
function nodeaccesskeys_form_validate($form, &$form_state) {
  global $user;

  $result = db_query(
    "SELECT aid, accesskey, nodetypes
      FROM {nodeaccesskeys}
      WHERE accesskey = :accesskey",
    array(
      ':accesskey' => $form_state['values']['accesskey'],
    )
  );

  // Flag to check whether any of the matching Access Keys resulted in Access.
  $access_granted = FALSE;

  if (!empty($form_state['node_type']) && $result->rowCount()) {

    foreach ($result as $record) {
      // Create an array of node types that the Access Key grants permission to.
      $types = unserialize($record->nodetypes);

      // If the Access Key applies to this Node Type and the Access Key ID isn't
      // already in the users session variable then add it.
      if (in_array($form_state['node_type'], $types)) {
        $user_aids = _nodeaccesskeys_user_aids();
        if (!in_array($record->aid, $user_aids)) {
          $access_granted = TRUE;
          $user_aids[] = $record->aid;
          $_SESSION['nodeaccesskeys_aids'] = $user_aids;
          watchdog(
            'nodeaccesskeys',
            'Access granted using %key', array('%key' => $record->accesskey)
          );
        }
      }
    }
  }

  if (!$access_granted) {
    form_set_error('accesskey', t('Access Key not recognized for this content.'));
  }
}

/**
 * Form submission handler for nodeaccesskeys_form().
 *
 * @see nodeaccesskeys_form_validate()
 * @ingroup forms
 */
function nodeaccesskeys_form_submit($form, &$form_state) {
  drupal_set_message(t('Access granted.'));

  // We don't want to create an infinite loop if a theme calls the form somewhere
  // on the end session page.
  if (current_path() == 'nodeaccesskeys/clear') {
    $form_state['redirect'] = '<front>';
  }
}

/**
 * Page callback for Permission Denied (403) page.
 */
function nodeaccesskeys_denied() {
  $node_type = _nodeaccesskeys_get_node_type();

  // First check that this is actually a protected page.
  if ($node_type === FALSE || nodeaccesskeys_get_protection($node_type, NODE_ACCESS_ALLOW)) {
    $path = variable_get('nodeaccesskeys_site_403', NULL);
    if (!empty($path)) {
      // Custom 403 handler. Set the active item in case there are tabs to
      // display or other dependencies on the path.
      menu_set_active_item($path);
      return menu_execute_active_handler($path, FALSE);
    }
    else {
      return MENU_ACCESS_DENIED;
    }
  }

  // This page is protected. Give the user the Node Access Keys form.
  drupal_set_title(t('Access Denied'));
  $output = drupal_get_form('nodeaccesskeys_form');
  drupal_set_page_content($output);
  $page = element_info('page');

  return $page;
}

/**
 * Page callback to clear a user's Node Access Key session.
 */
function nodeaccesskeys_end_session() {
  drupal_set_title(t('Session ended'));

  if (isset($_SESSION['nodeaccesskeys_aids'])) {
    unset($_SESSION['nodeaccesskeys_aids']);
    drupal_set_page_content('<p>' . t('You have ended your session.') . '</p>');
  }
  else {
    drupal_set_page_content('<p>' . t('Session has already been ended.') . '</p>');
  }

  $page = element_info('page');
  $page['#nodeaccesskeys_clear'] = TRUE;

  return $page;
}

/**
 * Implements hook_node_access().
 */
function nodeaccesskeys_node_access($node, $op, $account) {
  if (!is_object($node)) {
    return NODE_ACCESS_IGNORE;
  }

  // If viewing a protected, published node, check the permission.
  if ($op == 'view' && $node->status) {
    if (_nodeaccesskeys_get_permission($node->type)) {
      return NODE_ACCESS_ALLOW;
    }
    else {
      return NODE_ACCESS_DENY;
    }
  }
  return NODE_ACCESS_IGNORE;
}

/**
 * Implements hook_query_TAG_alter().
 */
function nodeaccesskeys_query_node_access_alter(QueryAlterableInterface $query) {
  global $user;

  // Read meta-data from query, if provided.
  if (!$account = $query->getMetaData('account')) {
    $account = $user;
  }
  if (!$op = $query->getMetaData('op')) {
    $op = 'view';
  }

  // If $account can bypass node access, or there are no node access modules,
  // or the operation is 'view' and the $acount has a global view grant (i.e.,
  // a view grant for node ID 0), we don't need to alter the query.
  if (user_access('bypass node access', $account)) {
    return;
  }

  // If viewing protected nodes, check permission.
  if ($op == 'view') {
    $tables = $query->getTables();
    // @see _node_query_node_access_alter().
    $node_table_alias = FALSE;
    foreach ($tables as $alias => $table) {
      if ($table['table'] == 'node') {
        $node_table_alias = $alias;
        break;
      }
    }
    if ($node_table_alias) {
      $alias = $node_table_alias;
      foreach (_nodeaccesskeys_protected_nodes() as $type) {
        if (_nodeaccesskeys_get_permission($type)) {
          // User is allowed to view this content type.
          continue;
        }
        else {
          // User doesn't have permission to view this content type.
          $query->condition("$alias.type", $type, '<>');
        }
      }
    }
  }
}

/**
 * Node Access Keys public function to check a node's permissions.
 *
 * @param string $type
 *   A string of the content type to be checked.
 *
 * @param string $protection
 *   A string indicating what type of protection to test for.
 *
 * @return bool
 *   A boolean indicating whether or not the given content type is protected.
 */
function nodeaccesskeys_get_protection($type = 'page', $protection = NODE_ACCESS_DENY) {
  $node = new stdClass();
  $node->status = 1;
  $node->type = $type;
  $access = nodeaccesskeys_node_access($node, 'view', NULL);

  // Ignoring access is the same as allowing access.
  if ($access == NODE_ACCESS_IGNORE && $protection != NODE_ACCESS_IGNORE) {
    $access = NODE_ACCESS_ALLOW;
  }
  return $access == $protection;
}

/**
 * Helper function that returns all protected content types for the
 * currently logged in user.
 *
 * @return array
 *   An array of machine-readable Content Types that this module protects.
 */
function _nodeaccesskeys_protected_nodes() {
  global $user;

  $types = array();
  $result = db_query("SELECT nodetypes, roles FROM {nodeaccesskeys}");

  foreach ($result as $record) {
    // Check if the Access Key applies to this user.
    $role_ids = array_flip(unserialize($record->roles));
    $roles = array_intersect_key($user->roles, $role_ids);

    if (!empty($roles)) {
      // Only merge the Node Types that are not already in the $types array.
      $temp = array_diff(unserialize($record->nodetypes), $types);
      $types = array_merge($types, $temp);
    }
  }
  return $types;
}

/**
 * Helper function that returns the Access Keys IDs.
 *
 * @return array
 *   An array of Access Key IDs that the logged in user has verified with.
 */
function _nodeaccesskeys_user_aids() {
  if (isset($_SESSION['nodeaccesskeys_aids'])) {
    return $_SESSION['nodeaccesskeys_aids'];
  }
  else {
    return array();
  }
}

/**
 * Helper function that returns a boolean indicating whether
 * the user has access to the give node type.
 *
 * @param string $node_type
 *   A string representing which node type to check permissions on.
 *
 * @return bool
 *   A boolean value for whether the logged in user has access to the supplied
 *   node type.
 */
function _nodeaccesskeys_get_permission($node_type) {
  // Safety first.
  if (empty($node_type)) {
    return FALSE;
  }

  // Grant permission if the content type is unprotected.
  if (!in_array($node_type, _nodeaccesskeys_protected_nodes())) {
    return TRUE;
  }

  $user_aids = _nodeaccesskeys_user_aids();

  $types = array();
  if (!empty($user_aids)) {
    foreach ($user_aids as $aid) {
      $result = db_query(
        "SELECT nodetypes FROM {nodeaccesskeys} WHERE aid = :aid",
        array(
          ':aid' => $aid,
        )
      );
      foreach ($result as $record) {
        // Only merge the Node Types that are not already in the $types array.
        $temp = array_diff(unserialize($record->nodetypes), $types);
        $types = array_merge($types, $temp);
      }
    }
  }
  return in_array($node_type, $types);
}

/**
 * Helper function for getting the node type when on the 403 page.
 *
 * @return string|false
 *   The function returns the node type taken from the request path. The
 *   function returns FALSE if no node type is found, such as admin pages.
 */
function _nodeaccesskeys_get_node_type() {
  $path = drupal_get_normal_path(request_path());

  // Attempt to load the current node.
  $nid = arg(1, $path);
  if (arg(0, $path) == 'node' && is_numeric($nid)) {
    $node = node_load($nid);
    return $node->type;
  }
  // Next check if it is a Views page.
  else {
    $menu_item = menu_get_item($path);
    if ($menu_item['page_callback'] == 'views_page' && !empty($menu_item['access_arguments'])) {
      $access_args = unserialize($menu_item['access_arguments']);
      if ($access_args[0][0] = 'nodeaccesskeys_get_protection') {
        return $access_args[0][1][0];
      }
    }
  }

  return FALSE;
}
