<?php
/**
 * @file
 * Wysifield framework for adding/manipulating entities to a filtered text area
 *
 * Wraps WYSIWYG plugins system to simplify creation and modification of plugins
 * Also provides a number of utility functions/callbacks for forms.
 */

// Load all Field module hooks for wysifield.
require_once DRUPAL_ROOT . '/modules/image/image.field.inc';
module_load_include('inc', 'wysifield', 'wysifield.field');

/**
 * Implements hook_init().
 *
 * Fixes issue with node_forms in ajax callbacks not properly validating.
 * See https://drupal.org/node/1167076 for more info.
 *
 * TODO POSSIBLY ENTEND TO ENTITIES
 */
function wysifield_init() {
  if ($_GET['q'] == 'system/ajax' && preg_match('/^[a-z_]+_node_form/', $_POST['form_id'])) {
    module_load_include('inc', 'node', 'node.pages');
  }
}

/**
 * Implements hook_menu().
 */
function wysifield_menu() {
  $items = array();
  $items['wysifield/embed-modal/%ctools_js/%'] = array(
    'title'           => 'Modal callback',
    'delivery callback' => 'ajax_deliver',
    'page arguments'  => array(2, 3, 4, 5),
    'page callback'   => '_wysifield_modal_callback',
    'access callback' => TRUE,
    'type'            => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Helper function to set plugin field settings.
 *
 * Helper function that goes through all field bundles, determines which are
 * plugins and then builds the correct settings arrays and caches/returns the
 * settings.
 *
 * @TODO Refactor for clarity and to remove install specific unsets.
 */
function wysifield_get_field_metadata() {
  static $cached;
  // Simple static cache.
  if (is_null($cached)) {
    // Get fields across all bundles.
    $field_info_map = field_info_field_map();
    $plugin = array();
    // @TODO Refactor to check the field type instead of the field machine name.
    // Search node bundles for wysifield_field
    if (isset($field_info_map['wysifield_field']['bundles'])) {
      foreach ($field_info_map['wysifield_field']['bundles'] as $key => $bundles) {
        // Loop through lower level bundles, set type for identification.
        $type = $key;
        foreach ($bundles as $sub_key => $bundle) {
          $tmp = field_info_instances($type, $bundle);
          if (isset($tmp['wysifield_field'])) {
            // Manually set required fields.
            $plugin[$bundle] = $tmp['wysifield_field']['settings'];
            $plugin[$bundle]['type'] = $bundle;
            $plugin[$bundle]['name'] = $bundle;
            $plugin[$bundle]['path'] = 'sites/all/modules/features';
            $plugin[$bundle]['vendor_url'] = 'Dynamically Generated by wysifield';
            $plugin[$bundle]['icon title'] = 'Insert a ' . $bundle;
            $plugin[$bundle]['module'] = 'wysifield';
            $plugin[$bundle]['css path'] = NULL;
            $plugin[$bundle]['css file'] = NULL;
            $plugin[$bundle]['js path'] = NULL;
            $plugin[$bundle]['js file'] = NULL;
            // Parse field config for path and file from field config.
            $path = $tmp['wysifield_field']['settings']['button_icon'];
            $icon_array = explode('/', $tmp['wysifield_field']['settings']['button_icon']);
            $icon_file = array_pop($icon_array);
            $icon_path = implode('/', $icon_array);
            $plugin[$bundle]['icon path'] = $icon_path;
            $plugin[$bundle]['icon file'] = $icon_file;
            $plugin[$bundle]['settings'] = array(
            // @TODO Target the image path better, maybe /feature/[bundle_name].
              'preview_img' => '/missing/preview/image',
              'type' => 'wysifield',
              'weight' => '6',
              'title' => 'Open ' . $bundle,
              'settings' => array(
                'type' => $bundle,
                'class' => 'open-' . $bundle,
                $bundle => '',
              ),
              'dialog' => array(
                'url' => 'wysifield/' . $bundle,
                'width' => '600',
                'height' => '500',
              ),
            );

          }
        }
      }
    }
    // Remove first bundle / field created on install and wysifield generic
    // with wysifield_field
    unset($plugin['install']);
    unset($plugin['wysifield']);
    $cached = $plugin;
  }
  // Call drupal_add_js with the list of plugins + metadata.
  drupal_add_js(
    array(
      'wysifield' => array(
        'plugins' => $cached,
      ),
    ),
    'setting'
  );

  return $cached;
}

/**
 * Register a directory containing Wysiwyg plugins.
 *
 * @params $type
 * The type of objects being collected: either 'plugins' or 'editors'.
 *
 * @return object
 *   A sub-directory of the implementing module that contains the corresponding
 *   plugin files. This directory must only contain integration files for
 *   Wysiwyg module.
 */
function wysifield_wysiwyg_include_directory($type) {
  switch ($type) {
    case 'plugins':
      // You can just return $type, if you place your Wysiwyg plugins into a
      // sub-directory named 'plugins'.
      return $type;
  }
}

/**
 * Implements hook_wysiwyg_plugin().
 */
function wysifield_wysiwyg_plugin($editor, $version) {
  switch ($editor) {
    case 'ckeditor':
      $path = '' . drupal_get_path('module', 'wysifield');
      drupal_add_js($path . '/wysifield.js');
      ctools_include('modal');
      ctools_include('ajax');
      ctools_modal_add_js();
      break;
  }
}

/**
 * Alter WYSIWYG editor settings.
 *
 * This function allows us to set the sort order for the wysiwyg plugins
 * and removes the image and forms plugins that may conflict with the
 * image model.
 */
function wysifield_wysiwyg_editor_settings_alter(&$settings, $context) {

  // Image functionality overrides wysifield js so manual remove.
  if ($context['profile']->editor == 'ckeditor') {
    // Remove the 'image' plugin since it conflicts with our plugin.
    $settings['removePlugins'] = 'image,forms';
  }
}

/**
 * Implements hook_form_alter().
 *
 * Alter the fieldable_panels_panes form to add the view mode.
 */
function wysifield_form_alter(&$form, &$form_state, $form_id) {

  // Add view mode field to all entities in the wysifield modal.
  if (isset($form['#entity_type']) && arg(0) == 'wysifield') {

    // Add ajax submit callback before rendering $form in _wysifield_modal_callback().
    $form['actions']['submit']['#ajax'] = array(
      'callback' => 'wysifield_modal_submit',
      'effect' => 'fade',
      'progress' => array('type' => 'throbber', 'message' => ''),
    );

    $entity_type = $form['#entity_type'];

    // Get node bundle.
    if ($form['#entity_type'] == 'node') {
      $bundle = $form['#bundle'];
    }
    else {
      $bundle = $form['#entity']->bundle;
    }

    // Get active view modes.
    $view_modes = field_view_mode_settings($entity_type, $bundle);

    // If view modes are enabled display a selection form element.
    if (!empty($view_modes)) {
      $options = FALSE;
      foreach ($view_modes as $mode => $settings) {
        if ($settings['custom_settings']) {
          $options[$mode] = $mode;
        }
      }
      if ($options) {
        $form['field_view_mode'] = array(
          '#type' => 'select',
          '#title' => t('View Mode'),
          '#options' => $options,
          '#description' => t('Select the desired view mode.'),
        );
      }
    }
  }
}

/**
 * Menu callback for the AJAX form request.
 */
function _wysifield_modal_callback($js, $bundle, $instance_id, $nid = FALSE) {
  // Load all field instances and walk through them looking for entity.
  $entity_info = field_info_instances();
  foreach ($entity_info as $key => $value) {
    if (is_array($value) && array_key_exists($bundle, $value)) {
      // Successfully determined entity type.
      $entity_type = $key;
    }
  }
  // @TODO Verify form is in the list of supported form_ids.
  if (empty($bundle)) {
    return 'ERROR: No form_id was sent.';
  }

  $type = $bundle;
  $node = NULL;
  // If we're re-opening a node, prepare the form.
  if (!empty($nid)) {
    $entity = entity_load_single($entity_type, $nid);
  }
  else {
    global $user;
    $entity = (object) array(
      'title'     => '',
      'uid'       => $user->uid,
      'name'      => (isset($user->name) ? $user->name : ''),
      'type'      => $type,
      'view_mode'      => 'full',
      'language'  => LANGUAGE_NONE,
      'bundle' => $bundle,
    );
  }

  if ($js) {
    ctools_include('node.pages', 'node', '');
    drupal_add_library('system', 'ui.dialog');
    // required for the loaded form to be ajaxy
    drupal_add_library('system', 'drupal.ajax');
    drupal_add_library('system', 'jquery.form');
  }
  else {
    // Someone navigated to the AJAX endpoint.
    drupal_access_denied();
  }

  // Prepare $form_id.
  if ($entity_type == 'node') {
    $form_id = $type . '_node_form';
  }
  else {
    $form_id = $entity_type . 's_entity_edit_form';
  }

  // @TODO dynamically add type of wysifield to title.
  /*
   * NEEDS REFACTORING
   * We need to detect entity type and buld form_states specifically.
   *
   * Need to determine in FPP follows the standard system for entities or if it
   * uses its own form logic.
   * Depending on question above detect fpp and adapt to it? How to genericize?
   *
   */
  $form_state = array(
    'ajax' => TRUE,
    're_render' => FALSE,
    'no_redirect' => TRUE,
    'build_info' => array(
      'args' => array($entity),
    ),
    'entity' => $entity,
    'add submit' => TRUE,
    'storage' => array (
      'wysifield' => array(
        'instance_id' => $instance_id,
      ),
    ),
  );

  // Since this will run again on form rebuild while still in the modal, prevent
  // form IDs from being incremented.
  // @todo https://drupal.org/node/1305882
  if (!empty($form_state['reset_html_ids']) && !empty($_POST['ajax_html_ids'])) {
    unset($_POST['ajax_html_ids']);
  }

  $form = drupal_build_form($form_id, $form_state);

  if (!empty($form_state['ajax']) && (!$form_state['executed'] || $form_state['rebuild'])) {
    // Render form.
    $html = drupal_render($form);

    return array(
      '#type' => 'ajax',
      '#commands' =>  array(
        ajax_command_html('#wysifield-modal', $html),
        ajax_command_prepend('#wysifield-modal', theme('status_messages')),
      ),
    );
  }

  return $form;
}

/**
 * Ajax submit callback to close dialog and kick off js insertion of embedded entity.
 */
function wysifield_modal_submit($form, $form_state) {

  // Build params array for wysifield_insert ajax command below.
  $entity = $form_state['build_info']['args'][0];

  // Determine if the emedded entity is a node so we can get the id.
  if ($form_state['build_info']['base_form_id'] == 'node_form') {
    $eid = $entity->nid;
    $entity_type = 'node';
    $bundle = $entity->bundle;
  }

  // @TODO Support other entities as this is targeting Fieldable Panel Panes.
  else {
    $eid = $entity->fpid;
    $entity_type = $entity->type;
    $bundle = $entity->bundle;
    $view_mode = $entity->view_mode;
  }
  $params = array(
    'eid'   => $eid,
    // @TODO This should be bundle instead of type.
    'type'  => $bundle,
    'view_mode' => (!empty($view_mode) ? $view_mode : 'full'),
  );

  $comamnds = array();
  // Renders system messages in div#console element.
  $commands[] = ajax_command_prepend('#console', theme('status_messages'));
  // Fires the Drupal.wysifield.modalClose() in wysifield.js
  $commands[] = array('command' => 'wysifield_close_modal', 'data' => array());
  // Fire the Drupal.wysifield.wysifield_insert() in wysifield.js
  $commands[] = array(
    'command' => 'wysifield_insert',
    'data' => array(
      'type' => $entity_type,
      'params' => $params,
      'instance_id' => $form_state['storage']['wysifield']['instance_id'],
    )
  );

  return array('#type' => 'ajax', '#commands' => $commands);
}

/**
 * Implements hook_filter_info().
 */
function wysifield_filter_info() {
  $filters = array();
  $filters['wysifield'] = array(
    'title'             => t('Wysifield Formatter'),
    'description'       => t('Converts the transitional format [wysifield:type ... ] to the expected output.'),
    'process callback'  => '_wysifield_filter_process',
    'cache' => FALSE,
  );
  return $filters;
}

/**
 * Process callback for the wysifield input filter.
 *
 * Finds Wysifield tokens and renders them as content.
 */
function _wysifield_filter_process($text, $filter = NULL, $format = NULL, $langcode = NULL, $cache = NULL, $cache_id = NULL, $wysifield_types = array()) {
  $wysifield = array();
  preg_match_all('/\[wysifield-(\w+)\|[^\]]+\]/', $text, $wysifield, PREG_PATTERN_ORDER);
  foreach ($wysifield[0] as $wysifield_token) {
    $wysifield_type = $wysifield[1][0];

    // Skip tokens not in the wysifield_types array. If wysifield_types is empty, all tokens will be replaced.
    if (!empty($wysifield_types) && !in_array($wysifield_type, $wysifield_types)) {
      continue;
    }

    preg_match_all('/\|(?P<key>[^=]+)="(?P<value>[^"]+)"/', $wysifield_token, $matches, PREG_PATTERN_ORDER);

    // If there are no tokens, just return.
    if (count($matches['key']) == 0) {
      return $text;
    }

    // Get actual values out of parsed tokens.
    $params = array_combine($matches['key'], $matches['value']);

    // Load all possible entities.
    $entities = entity_get_info();

    // Loop through entites and determine bundle.
    foreach ($entities as $entity_type) {
      if (array_key_exists($params['type'], $entity_type['bundles'])) {
        $type = $entity_type['base table'];

        // Address plural naming of fieldable_panels_panes base table.
        if ($type == 'fieldable_panels_panes') {
          $type = 'fieldable_panels_pane';
        }
      }
    }

    // Load node from embedded eid.
    $entity = entity_load_single($type, $params['eid']);
    if (!$entity) {
      drupal_set_message(t('Wysifield for %wysifield_type (%eid) not loaded. Could this have been deleted?', array('%wysifield_type' => $params['type'], '%eid' => $params['eid'])), 'error');
      return FALSE;
    }

    // Determine view mode when available.
    // Render using view_mode.
    $content = entity_view($type, array($entity), $params['view_mode']);
    $text = str_replace($wysifield_token, drupal_render($content), $text);
  }

  return $text;
}
