<?php

/**
 * @file
 * Export API Module which generates XML feed of products for Zbozi.cz or Heureka.cz
 *
 * @author Vojtech Kusy <wojtha@gmail.com>
 * @copyright Vojtech Kusy <wojtha@gmail.com>
 * @license GNU GPL v2
 *
 * Based on:
 *  - http://drupal.org/node/988192#comment-3847954
 *  - http://svendecabooter.be/blog/performing-batch-data-operations-on-cron-run-drupal-6
 *  - http://api.drupal.org/api/drupal/modules--system--system.queue.inc/group/queue/7
 */

//=============================================================================
// HOOK IMPLEMENTATIONS
//=============================================================================

/**
 * Implementation of hook_menu
 */
function exporter_menu() {
  $items = array();

  $items['admin/content/exporter'] = array(
    'title' => 'Exporters',
    'page callback' => 'exporter_overview_page',
    'access arguments' => array('administer exporter'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'exporter.pages.inc'
  );

  $items['admin/content/exporter/%/settings'] = array(
    'title' => 'Exporters',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('exporter_settings_form', 3),
    'access arguments' => array('administer exporter'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'exporter.pages.inc'
  );

  $items['admin/content/exporter/%/export'] = array(
    'title' => 'Confirm batch export',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('exporter_batch_confirm', 3),
    'access arguments' => array('administer exporter'),
    'type' => MENU_CALLBACK,
    'file' => 'exporter.pages.inc'
  );

  $items['admin/content/exporter/%/preview'] = array(
    'title' => 'Preview',
    'page callback' => 'exporter_preview_page',
    'page arguments' => array(3),
    'access arguments' => array('administer exporter'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'exporter.pages.inc'
  );

  return $items;
}

/**
 * Implementation of hook_perm()
 */
function exporter_permission() {
  return array('administer exporter' => array(
    'title' => t('Administer exporters'),
    'description' => t('Perform administration tasks for Exporter.'),
  ));
}

/**
 * Implementation of hook_cron()
 */
function exporter_cron() {
  $scheduler = ExporterScheduler::instance();
  $scheduler->cron();
}

/**
 * Implements hook_node_update().
 */
function exporter_node_update($node) {
  exporter_flush_node_cache($node);
}

/**
 * Implements hook_node_delete().
 */
function exporter_node_delete($node) {
  exporter_flush_node_cache($node);
}

/**
 * Implements hook_node_revision_delete().
 */
function exporter_node_revision_delete($node) {
  exporter_flush_node_cache($node);
}

/**
 * Implementation of hook_user().
 */
function exporter_user($type, &$edit, &$user, $category = NULL) {
  switch ($type) {
    case 'update':
    case 'delete':
    foreach (exporter_get_exporters() as $exporter) {
      if ($exporter instanceof UserExporter && $exporter->use_cache) {
        $exporter->cache->invalidate($user->uid);
      }
    }
  }
}

/**
 * Implementation of hook_flush_caches().
 */
function exporter_flush_caches() {
  foreach (exporter_get_exporters() as $exporter) {
    $exporter->cache->flush();
  }
}

//=============================================================================
// BATCH
//=============================================================================

/**
 * Batch definition
 */
function exporter_batch_export($id) {
  $scheduler = ExporterScheduler::instance();
  $exporter = exporter_get_exporter($id);
  $scheduler->batchRun($exporter);
}

/**
 * Batch finish callback
 */
function exporter_batch_finished($success, $results, $operations) {
  $message = t('Done! Export has been generated.');
  drupal_set_message($message);
}

//=============================================================================
// QUEUE
//=============================================================================

/**
 * Implementation of hook_queue_info()
 */
function exporter_cron_queue_info() {
  $queue = array();
  $ids = array_keys(exporter_get_info());
  foreach ($ids as &$id) {
    $queue['exporter_' . $id] = array(
      'worker callback' => 'exporter_queue_run_operation',
    );
  }
  return $queue;
}

/**
 * Implementation of hook_drupal_queue_load_classes()
 *
 * To use ZboziExportQueue instead of default SystemQueue you need also set
 * the variable queue_class_exporter to act only on this queue or set
 * variable to queue_default_class act as default queue class for all queues.
 */
function exporter_drupal_queue_load_classes() {
  module_load_include('inc', 'exporter', 'ExporterQueue');
}

/**
 * Worker callback function used during queue processing
 *
 * @param array $data
 */
function exporter_queue_run_operation($operation) {
  list($function, $param_arr) = $operation;
  call_user_func_array($function, $param_arr);
}

/**
 *
 *
 * @param $id
 * @param $method
 * @param null $offset
 * @param null $limit
 */
function exporter_worker($id, $method, $offset = NULL, $limit = NULL) {
  $exporter = exporter_get_exporter($id);
  exporter_log(WATCHDOG_INFO, 'Worker: %id queue %method.', array('%id' => $id, '%method' => $method));
  if ($method == 'exportItems') {
    $exporter->exportItems($offset, $limit);
  }
  else {
    $exporter->{$method}();
  }
}

//=============================================================================
// MODULE LOGIC
//=============================================================================

/**
 * Returns info about exporter submodules received through hook_exporter_info.
 *
 * @param string $id
 *   Id of the exporter.
 *
 * @return array
 *   The type of result is dependent upon the $option parameter
 */
function exporter_get_info($exporter_id = NULL, $reset = FALSE) {
  static $info_all;

  if (!isset($info_all) || $reset) {
    $info_all = module_invoke_all('exporter_info');
    drupal_alter('exporter_info', $info_all);
    foreach ($info_all as $id => &$info) {
      // Set ID and make sure that proper queue class is set.
      $info['id'] = $id;
      exporter_set_exporter_queue_class($id, $info);
    }
  }

  // Return info for particular exporter ...
  if ($exporter_id) {
    if (isset($info_all[$exporter_id])) {
      return $info_all[$exporter_id];
    }
    else {
      return NULL;
    }
  }

  // ... or return info for all.
  return $info_all;
}

/**
 * Returns exporter object.
 *
 * @param $id
 * @return Exporter
 */
function exporter_get_exporter($id) {
  $info = exporter_get_info($id);
  if (isset($info['class']) && class_exists($info['class'])) {
    $exporter = $info['class'];
    return new $exporter($id);
  }
  else {
    exporter_log(WATCHDOG_ERROR, 'Exporter %class in %exporter exporter is not defined. Exporter settings: %info', array('%class' => $info['class'], '%exporter' => $id, '%info' => print_r($info, TRUE)));
  }
}

/**
 * Returns array of exporter objects.
 *
 * @return array of Exporter obejects
 */
function exporter_get_exporters() {
  $exporters = array();
  $info_all = exporter_get_info();
  foreach ($info_all as $id => &$info) {
    if (isset($info['class']) && class_exists($info['class'])) {
      $exporter = $info['class'];
      $exporters[$id] = new $exporter($id);
    }
    else {
      exporter_log(WATCHDOG_ERROR, 'Exporter %class in %exporter exporter is not defined. Exporter settings: %info', array('%class' => $info['class'], '%exporter' => $id, '%info' => print_r($info, TRUE)));
    }
  }
  return $exporters;
}

/**
 * Iterates through all exporters and flushes fragment cache for given node.
 *
 * @param $node
 */
function exporter_flush_node_cache($node) {
  foreach (exporter_get_exporters() as $exporter) {
    if ($exporter instanceof NodeExporter && $exporter->use_cache) {
      $exporter->cache->invalidate($node->nid);
    }
  }
}

/**
 * Sets proper queue class for particular exporter.
 * @see DrupalQueue::get()
 *
 * @param $id int
 *    Exporter ID
 * @param $info array
 *    Exporter info array
 */
function exporter_set_exporter_queue_class($id, $info) {
  $queue_class = !empty($info['queue_class']) ? $info['queue_class'] : 'ExporterQueue';
  $set_class = variable_get('queue_class_' . $id, NULL);
  if (!$set_class || $set_class != $queue_class) {
    variable_set('queue_class_' . $id, $queue_class);
  }
}

/**
 * Exporter logger.
 *
 * @param int $severity 0-6, see watchdog()
 * @param string $message
 * @param array $variables
 * @param null $link
 */
function exporter_log($severity, $message, $variables = array(), $link = NULL) {
  static $logger;

  if (!isset($logger)) {
    $logger = new ExporterLogger();
  }

  $logger->log($message, $variables, $severity, $link);
}

/**
 * Sanitize a string for an atom feed.
 *
 * Certain HTML character entities are not valid in XML and cause character
 * encoding to go completely bananas.  This function converts those characters
 * to their unicode equivalents.
 *
 * @link http://changelog.ca/log/2006/06/12/making_nbsp_work_with_xml_rss_and_atom
 * @link http://www.lazycat.org/php-convert-entities.php
 * @link http://www.php.net/manual/en/function.get-html-translation-table.php#83874
 * @link https://mailman.uni-konstanz.de/pipermail/basex-talk/2011-January/001121.html
 * @param $string
 *   The string to sanitize. If any other data type is passed it is returned
 *   unaffected.
 */
function exporter_xml_sanitize($string) {
  static $replacements = NULL;

  // build replacement mappings
  if (is_null($replacements)) {
    $replacements = array(
      '& ' => '&#38; ',
      "\r\n" => "\n",
    );
    foreach (get_html_translation_table(HTML_ENTITIES, ENT_QUOTES) as $char => $entity){
      $replacements[$entity] = '&#' . ord($char) . ';';
    }
  }

  // replace the entities and cleanup the unknown entities
  if (is_string($string)) {
    return preg_replace('/&[^#][a-z0-9]+;/i', '', strtr($string, $replacements));
  }

  return $string;
}
