<?php

/**
 * @file
 * Hierarchy functions.
 */

/**
 * Implements hook_views_api().
 */
function hierarchy_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'hierarchy') . '/includes/views',
  );
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function hierarchy_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools') {
    return 'plugins/' . $plugin;
  }

  return NULL;
}

/**
 * Implements hook_theme().
 */
function hierarchy_theme() {
  return array(
    'hierarchy' => array(
      'render element' => 'elements',
      'template' => 'hierarchy',
    ),
    'hierarchy_reorder_items_form' => array(
      'render element' => 'form',
      'file' => 'includes/hierarchy.admin.inc',
    ),
  );
}

/**
 * Implements hook_field_info().
 */
function hierarchy_field_info() {
  return array(
    'hierarchy_position' => array(
      'label' => t('Hierarchy position'),
      'description' => t('Position in a hierarchy.'),
      'settings' => array(
        'hierarchy_type' => '',
        'entity_type' => '',
      ),
      'instance_settings' => array(),
      'default_widget' => 'hierarchy_hidden',
      'default_formatter' => 'hierarchy_hidden',
      'property_type' => 'hierarchy_position',
      'property_callbacks' => array('hierarchy_position_field_entity_property_callback'),
    ),
  );
}

/**
 * Implements hook_field_is_empty().
 */
function hierarchy_field_is_empty($item, $field) {
  return empty($item['hid']);
}

/**
 * Implements hook_field_settings_form().
 */
function hierarchy_field_settings_form($field, $instance, $has_data) {
  $settings = $field['settings'];
  $form = array();

  if ($field['type'] == 'hierarchy_position') {
    $hierarchy_type_options = array();
    $hierarchy_type_options[''] = t('Any hierarchy type');
    foreach (hierarchy_type_get_names() as $hierarchy_type => $hierarchy_name) {
      $hierarchy_type_options[$hierarchy_type] = $hierarchy_name;
    }

    $entity_type_options = array();
    $entity_type_options[''] = t('Any entity type');
    foreach (entity_get_info() as $entity_type => $entity_info) {
      if (!empty($entity_info['bundle of'])) {
        continue;
      }
      // @todo Filter entities which are enabled for hierarchies only.
      $entity_type_options[$entity_type] = $entity_info['label'];
    }

    $form['hierarchy_type'] = array(
      '#type' => 'select',
      '#title' => t('Hierarchy type'),
      '#options' => $hierarchy_type_options,
      '#default_value' => $settings['hierarchy_type'],
      '#description' => t('Select the hierarchy type for the field.') . '<br />' .
        t('Caution! If you select the unique hierarchy, and this field is required, all entities with this field will be added to the hierarchy.'),
      '#disabled' => $has_data,
    );

    $form['entity_type'] = array(
      '#type' => 'select',
      '#title' => t('Entity type of hierarchy items'),
      '#options' => $entity_type_options,
      '#default_value' => $settings['entity_type'],
      '#description' => t('Select the entity type of the parent of the hierarchy item.'),
      '#disabled' => FALSE,
    );
  }

  return $form;
}

/**
 * Implements hook_field_update_field().
 */
function hierarchy_field_update_field($field, $prior_field, $has_data) {
  // @todo Use hook_field_update_instance (and hook_field_create_instance).
  if ($field['type'] !== 'hierarchy_position') {
    return;
  }
  if (!empty($field['settings']['hierarchy_type'])) {
    $hierarchy_type = hierarchy_type_load($field['settings']['hierarchy_type']);
    if ((!empty($hierarchy_type)) && ($hierarchy_type->is_unique)) {
      hierarchy_add_entities_to_hierarchy_for_required_field($field['field_name'], hierarchy_load_unique_by_type($hierarchy_type));
    }
  }
}

/**
 * Implements hook_permission().
 */
function hierarchy_permission() {
  $permissions = array();

  $permissions['administer hierarchies'] = array(
    'title' => t('Administer hierarchies'),
    'description' => t('Administer hierarchies.'),
  );

  $permissions['create hierarchies'] = array(
    'title' => t('Create hierarchies'),
    'description' => t('Create non-unique hierarchies.'),
  );

  $permissions['reorder hierarchies'] = array(
    'title' => t('Reorder hierarchies'),
    'description' => t('Reorder hierarchies.'),
  );

  return $permissions;
}

/**
 * Implements hook_entity_info().
 */
function hierarchy_entity_info() {
  $items['hierarchy_type'] = array(
    'label' => t('Hierarchy type'),
    'plural label' => t('Hierarchy types'),
    'controller class' => 'EntityAPIControllerExportable',
    'entity class' => 'HierarchyType',
    'base table' => 'hierarchy_type',
    'fieldable' => FALSE,
    'redirect' => FALSE,
    'uuid' => TRUE,
    'entity keys' => array(
      'id' => 'id',
      'label' => 'name',
      'name' => 'type',
      'uuid' => 'uuid',
    ),
    'exportable' => TRUE,
    'export' => array(
      'default hook' => 'default_hierarchy_type',
    ),
    'bundle of' => 'hierarchy',
    'module' => 'hierarchy',
    'access callback' => 'hierarchy_type_access',
    'admin ui' => array(
      'path' => 'admin/structure/hierarchy/type',
      'file' => 'includes/hierarchy.admin.inc',
      'controller class' => 'HierarchyTypeUIController',
    ),
  );

  $items['hierarchy'] = array(
    'label' => t('Hierarchy'),
    'plural label' => t('Hierarchies'),
    'controller class' => 'EntityAPIController',
    'entity class' => 'Hierarchy',
    'base table' => 'hierarchy',
    'fieldable' => TRUE,
    'redirect' => FALSE,
    'uuid' => TRUE,
    'access callback' => 'hierarchy_access',
    'entity keys' => array(
      'id' => 'hid',
      'label' => 'name',
      'bundle' => 'type',
      'uuid' => 'uuid',
    ),
    'uri callback' => 'entity_class_uri',
    'bundles' => array(),
    'bundle keys' => array(
      'bundle' => 'type',
    ),
    'view modes' => array(
      'full' => array(
        'label' => t('Full page'),
        'custom settings' => FALSE,
      ),
    ),
    'module' => 'hierarchy',
    'metadata controller class' => 'HierarchyMetadataController',
    'views controller class' => 'HierarchyViewsController',
    'admin ui' => array(
      'path' => 'admin/structure/hierarchy',
      'file' => 'includes/hierarchy.admin.inc',
      'controller class' => 'HierarchyUIController',
      'menu wildcard' => '%hierarchy',
    ),
  );

  foreach (hierarchy_type_get_names() as $type => $name) {
    $items['hierarchy']['bundles'][$type] = array(
      'label' => $name,
      'admin' => array(
        'path' => 'admin/structure/hierarchy/type/manage/%hierarchy_type',
        'real path' => 'admin/structure/hierarchy/type/manage/' . $type,
        'bundle argument' => 5,
        'access arguments' => array('administer hierarchies'),
      ),
    );
  }

  $items['hierarchy_relation'] = array(
    'label' => t('Hierarchy relation'),
    'label callback' => 'entity_class_label',
    'plural label' => t('Hierarchy relations'),
    'controller class' => 'EntityAPIController',
    'entity class' => 'HierarchyRelation',
    'base table' => 'hierarchy_relation',
    'fieldable' => TRUE,
    'redirect' => FALSE,
    'uuid' => FALSE,
    'access callback' => 'hierarchy_access',
    'entity keys' => array(
      'id' => 'rid',
      'bundle' => 'field_name',
    ),
    'bundles' => array(),
    'bundle keys' => array(
      'bundle' => 'field_name',
    ),
    'view modes' => array(),
    'module' => 'hierarchy',
    'deletion callback' => 'hierarchy_relation_delete',
    'metadata controller class' => 'HierarchyRelationMetadataController',
    'views controller class' => 'HierarchyRelationViewsController',
  );

  foreach (field_read_fields(array('type' => 'hierarchy_position')) as $field_name => $field) {
    $items['hierarchy_relation']['bundles'][$field_name] = array(
      'label' => t('Hierarchy relation @field', array('@field' => $field_name)),
      'admin' => array(
        'path' => 'admin/structure/hierarchy/relation/manage/%hierarchy_relation_field_name',
        'real path' => 'admin/structure/hierarchy/relation/' . strtr($field_name, array('_' => '-')),
        'bundle argument' => 5,
        'access arguments' => array('administer hierarchies'),
      ),
    );
  }

  return $items;
}

function hierarchy_type_get_names() {
  $names = &drupal_static(__FUNCTION__);
  if (!isset($names)) {
    $names = array();
    if (db_table_exists('hierarchy_type')) {
      foreach (db_select('hierarchy_type', 'ht')->fields('ht')->execute()->fetchAllAssoc('type') as $type => $info) {
        $names[$type] = $info->name;
      }
    }
  }

  return $names;
}

/**
 * Implements hook_menu().
 */
function hierarchy_menu() {
  $items = array();

  if (module_exists('field_ui')) {
    $items['admin/structure/hierarchy/relation'] = array(
      'title' => 'Hierarchy relations',
      'description' => 'Manage fields of hierarchy relations.',
      'page callback' => 'hierarchy_relations_overview',
      'access arguments' => array('administer hierarchies'),
      'type' => MENU_LOCAL_ACTION,
      'file' => 'includes/hierarchy.admin.inc',
    );
    $items['admin/structure/hierarchy/relation/list'] = array(
      'title' => 'List',
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'weight' => -10,
    );
    $items['admin/structure/hierarchy/relation/manage/%'] = array(
      'title' => 'Edit',
      'page callback' => 'drupal_goto',
      'page arguments' => array('admin/structure/hierarchy/relation'),
      'access arguments' => array('administer hierarchies'),
    );
  }

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function hierarchy_menu_alter(&$items) {
  if (isset($items['admin/structure/hierarchy/type'])) {
    $items['admin/structure/hierarchy/type']['type'] = MENU_LOCAL_ACTION;
  }
}

/**
 * Implements hook_field_extra_fields().
 */
function hierarchy_field_extra_fields() {
  $extra = array();

  foreach (hierarchy_type_get_names() as $type => $name) {
    $extra['hierarchy'][$type] = array(
      'display' => array(
        'hierarchy_items' => array(
          'label' => t('Hierarchy items'),
          'description' => t('List of hierarchy items'),
          'weight' => 100,
        ),
      ),
    );
  }

  return $extra;
}

/**
 * Implements field hook_field_widget_info().
 */
function hierarchy_field_widget_info() {
  return array(
    'hierarchy_hidden' => array(
      'label' => t('Hidden'),
      'field types' => array('hierarchy_position'),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
        'default value' => FIELD_BEHAVIOR_NONE,
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_info_alter().
 */
function hierarchy_field_widget_info_alter(&$info) {
  $widgets = array(
    'options_select' => array('hierarchy_position'),
    'options_buttons' => array('hierarchy_position'),
    'options_onoff' => array('hierarchy_position'),
  );

  foreach ($widgets as $widget => $field_types) {
    $info[$widget]['field types'] = array_merge($info[$widget]['field types'], $field_types);
  }
}

/**
 * Implements hook_options_list().
 */
function hierarchy_options_list($field, $instance, $entity_type, $entity) {
  $options = array();

  if ($field['type'] == 'hierarchy_position') {
    $settings = $field['settings'];
    $hierarchy_type = $settings['hierarchy_type'];
    if (!empty($hierarchy_type)) {
      $hierarchies = hierarchy_load_by_type($hierarchy_type);
      foreach ($hierarchies as $hierarchy) {
        $options[$hierarchy->hid] = $hierarchy->name;
      }
    }
  }

  return $options;
}

/**
 * Implements hook_entity_delete().
 */
function hierarchy_entity_delete($entity, $entity_type) {
  if ($entity_type == 'hierarchy') {
    // @todo Delete all records of hierarchy.
    // @todo Prohibit deletion if fields referencing the hierarchy exist.
  }
  // list($entity_id) = entity_extract_ids($entity_type, $entity);
  // @todo Delete records having entity as descendant.
  // @todo Set previous records as descendant_is_sink, set proper distance.
  // @todo Delete records having entity as ancestor.
  // @todo Set Next records as ancestor_is_source, set proper distance.
}

/*
 * http://www.trellon.com/content/blog/creating-own-entities-entity-api
 * http://cgit.drupalcode.org/model/tree/?h=7.x-1.x
 * http://cgit.drupalcode.org/while/tree/while.module
 * https://www.drupal.org/node/878784
 */

/**
 * Defines info for the properties of the field item data structure.
 */
function hierarchy_position_field_entity_property_callback(&$info, $entity_type, $field, $instance, $field_type) {
  $property = &$info[$entity_type]['bundles'][$instance['bundle']]['properties'][$field['field_name']];
  $property['getter callback'] = 'entity_metadata_field_verbatim_get';
  $property['setter callback'] = 'entity_metadata_field_verbatim_set';
  $property['auto creation'] = 'hierarchy_position_field_item_create';
  unset($property['query callback']);

  $property['property info']['hierarchy'] = array(
    'label' => t('Hierarchy'),
    'getter callback' => 'entity_property_verbatim_get',
    'setter callback' => 'entity_property_verbatim_set',
    'type' => 'hierarchy',
    'schema field' => 'hid',
    'required' => TRUE,
  );

  $property['property info']['parent'] = array(
    'label' => t('Hierarchy'),
    'getter callback' => 'hierarchy_position_parent_get',
    'setter callback' => 'hierarchy_position_parent_set',
    'type' => 'entity',
    'required' => TRUE,
  );

  $property['property info']['relation'] = array(
    'label' => t('Relation'),
    'getter callback' => 'entity_property_verbatim_get',
    'type' => 'hierarchy_relation',
    'schema field' => 'relation_id',
  );

  /*$property['property info']['weight'] = array(
    'label' => t('Position weight'),
    'getter callback' => 'entity_property_verbatim_get',
    'setter callback' => 'entity_property_verbatim_set',
    'type' => 'integer',
  );*/
}

/**
 * Hierarchy type loader.
 *
 * @param string $type
 *   (optional) The name of the hierarchy type.
 *   If no type is given, all existing types are returned.
 *
 * @return HierarchyType
 *   Returns a fully-loaded hierarchy type definition if a type name is passed.
 *   Else an array containing all types is returned.
 */
function hierarchy_type_load($type = NULL) {
  // Replace dashes with underscores so this can be used as menu argument
  // loader too.
  $types = entity_load_multiple_by_name('hierarchy_type', isset($type) ? array(strtr($type, array('-' => '_'))) : FALSE);

  if (isset($type)) {
    return isset($types[$type]) ? $types[$type] : FALSE;
  }

  return $types;
}

/**
 * Loads hierarchy relation.
 *
 * @param int $rid
 *   The hierarchy relation ID.
 *
 * @return HierarchyRelation
 *   A hierarchy relation object.
 */
function hierarchy_relation_load($rid, $reset = FALSE) {
  $result = hierarchy_relation_load_multiple(array($rid), array(), $reset);
  return $result ? reset($result) : FALSE;
}

/**
 * Loads multiple hierarchy relations.
 */
function hierarchy_relation_load_multiple($ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('hierarchy_relation', $ids, $conditions, $reset);
}


/**
 * Menu callback for loading the hierarchy relation bundle names.
 */
function hierarchy_relation_field_name_load($arg) {
  $field_name = strtr($arg, array('-' => '_'));
  if (($field = field_info_field($field_name)) && $field['type'] == 'hierarchy_position') {
    return $field_name;
  }

  return NULL;
}

/**
 * Inserts or updates a hierarchy type object into the database.
 *
 * @param object $hierarchy_type
 *   The hierarchy type object to be inserted.
 *
 * @return int|boolean
 *   Failure to write a record will return FALSE. Otherwise SAVED_NEW or
 *   SAVED_UPDATED is returned depending on the operation performed.
 */
function hierarchy_type_save($hierarchy_type) {
  return entity_save('hierarchy_type', $hierarchy_type);
}

/**
 * Deletes an existing hierarchy type.
 *
 * @param string $type
 *   The name of the hierarchy type to be deleted.
 */
function hierarchy_type_delete($type) {
  return entity_delete('hierarchy_type', $type);
}

/**
 * Helper to create hierarchy.
 *
 * @param string $type
 *   The hierarchy type.
 * @param array $values
 *   Array with the following keys:
 *   - "name" - The name of hierarchy.
 *   - "timestamp" - The UNIX timestamp of the creation time of the hierarchy.
 *     If empty, the current time will be used.
 * @param object $account
 *   Optional; The user object to become the creator of the hierarchy.
 *     If empty, the current user will be used.
 */
function hierarchy_create($type, array $values = array(), $account = NULL) {
  $values['type'] = $type;
  $values['uid'] = (empty($account)) ? $GLOBALS['user']->uid : $account->uid;

  return entity_create('hierarchy', $values);
}

/**
 * Loads hierarchy.
 *
 * @param int $hid
 *   The hierarchy ID.
 *
 * @return Hierarchy
 *   A hierarchy object.
 */
function hierarchy_load($hid, $reset = FALSE) {
  $result = hierarchy_load_multiple(array($hid), array(), $reset);
  return $result ? reset($result) : FALSE;
}

/**
 * Loads multiple hierarchies.
 */
function hierarchy_load_multiple($hids, $conditions = array(), $reset = FALSE) {
  return entity_load('hierarchy', $hids, $conditions, $reset);
}

function hierarchy_load_by_type($type) {
  $query = new EntityFieldQuery();
  $query->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT');
  $query->entityCondition('entity_type', 'hierarchy');
  $query->entityCondition('bundle', $type);
  $query->propertyOrderBy('name');
  $hierarchies = $query->execute();
  return hierarchy_load_multiple(array_keys($hierarchies['hierarchy']));
}

function hierarchy_load_unique_by_type($type) {
  $cache = &drupal_static(__FUNCTION__, array());

  if (is_object($type)) {
    $type = $type->type;
  }

  if (!isset($cache[$type])) {
    $query = db_select('hierarchy', 'h');
    $query->fields('h', array('hid'));
    $query->innerJoin('hierarchy_type', 't', 't.type = h.type');
    $query->condition('t.type', $type);
    $query->condition('t.is_unique', 1);
    $cache[$type] = hierarchy_load($query->execute()->fetchField());
  }

  return $cache[$type];
}

/**
 * Saves hierarchy.
 */
function hierarchy_save($hierarchy) {
  return entity_save('hierarchy', $hierarchy);
}

/**
 * Deletes hierarchy.
 *
 * @param array $hids
 *   Array of hierarchy IDs.
 */
function hierarchy_delete_multiple(array $hids = array()) {
  entity_delete_multiple('hierarchy', $hids);
}

/**
 * Access callback for the hierarchy entity.
 */
function hierarchy_access($op, $entity, $account = NULL, $entity_type = 'hierarchy') {
  if ($op === 'view') {
    return user_access('access content', $account);
  }
  // @todo use different permissions for 'view', 'update', 'create' and 'delete' operations.
  return user_access('create hierarchies', $account);
}

/**
 * Access callback for the hierarchy type entities.
 */
function hierarchy_type_access($op, $entity, $account, $entity_type) {
  return user_access('administer hierarchies', $account);
}

function hierarchy_relation_access($op, HierarchyRelation $item = NULL, $account = NULL) {
  if (user_access('administer hierarchies', $account)) {
    return TRUE;
  }
  if (!isset($item)) {
    return FALSE;
  }
  $op = ($op === 'view' ? 'view' : 'edit');
  // Access is determined by the entity and field containing the reference.
  $field = field_info_field($item->field_name);
  $entity_access = entity_access($op == 'view' ? 'view' : 'update', $item->hostEntityType(), $item->hostEntity(), $account);
  return $entity_access && field_access($op, $field, $item->hostEntityType(), $item->hostEntity(), $account);
}

/**
 * Callback for creating a new, empty hierarchy position field item.
 */
function hierarchy_position_field_item_create() {
  return array(
    'hid' => NULL,
    'parent_type' => NULL,
    'parent_id' => NULL,
    'relation_id' => NULL,
  );
}

function hierarchy_position_parent_get() {
  // @todo Create getter.
}

function hierarchy_position_parent_set() {
  // @todo Create setter.
}

function hierarchy_place_between($entity_type, $entity_id) {
  // @todo Create place changer.
}

function hierarchy_put_entity_in_hierarchy($entity_type, $entity, $hierarchy, $hierarchy_position_field_name, $parent_entity_type, $parent_entity_id) {
  if (!isset($entity->{$hierarchy_position_field_name})) {
    throw new Exception('Hierarchy: entity does not contain hierarchy position field in hierarchy_put_entity_in_hierarchy().');
  }
  $langcode = field_language($entity_type, $entity, $hierarchy_position_field_name);
  if ($langcode === FALSE) {
    $langcode = LANGUAGE_NONE;
  }

  if (!empty($entity->{$hierarchy_position_field_name}[$langcode])) {
    foreach ($entity->{$hierarchy_position_field_name}[$langcode] as $value) {
      if ($value['hid'] == $hierarchy->hid) {
        // The entity is already in this hierarchy.
        return;
      }
    }
  }

  $entity->{$hierarchy_position_field_name}[$langcode][] = array(
    'hid' => $hierarchy->hid,
    'parent_type' => $parent_entity_type,
    'parent_id' => $parent_entity_id,
  );

  entity_save($entity_type, $entity);
}

/**
 * Sets weights of the relations according to the order of entities.
 *
 * @param array|string $entity_types
 *   Array or entity types (one per entity) or string (common entity type).
 * @param array $entities
 *   Array of entities to reorder according to the order in this array.
 * @param object $hierarchy
 *   Hierarchy object.
 * @param string $hierarchy_position_field_name
 *   Field name of the field of type "hierarchy_position".
 * @param string $parent_entity_type
 *   Entity type of the common parent.
 * @param int $parent_entity_id
 *   Entity identifier of the common parent.
 */
function hierarchy_reorder_entity_list($entity_types, array $entities, $hierarchy, $hierarchy_position_field_name, $parent_entity_type, $parent_entity_id) {
  $entity_count = count($entities);
  if ($entity_count === 0) {
    return;
  }

  // Check that $entities are the same as existing children
  // of the parent entity.
  if (!is_array($entity_types)) {
    $entity_types = array_fill(0, $entity_count, $entity_types);
  }
  $entity_ids = array();
  if (count($entity_types) !== $entity_count) {
    throw new Exception('Hierarchy: count of $entity_types and count of $entities differ in hierarchy_reorder_entity_list().');
  }
  reset($entity_types);
  foreach ($entities as $entity) {
    $entity_type = current($entity_types);
    next($entity_types);
    list($entity_id) = entity_extract_ids($entity_type, $entity);
    $entity_ids[] = $entity_type . ':' . $entity_id;
  }

  $existing_entity_ids = array();
  $query = new EntityFieldQuery();
  $query->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT');
  // @todo Add language conditions.
  $query->fieldCondition($hierarchy_position_field_name, 'hid', $hierarchy->hid);

  if (!is_null($parent_entity_type)) {
    $query->fieldCondition($hierarchy_position_field_name, 'parent_type', $parent_entity_type);
  }
  else {
    $query->fieldCondition($hierarchy_position_field_name, 'parent_type', NULL);
  }

  if (!is_null($parent_entity_id)) {
    $query->fieldCondition($hierarchy_position_field_name, 'parent_id', $parent_entity_id);
  }
  else {
    $query->fieldCondition($hierarchy_position_field_name, 'parent_id', NULL);
  }

  $existing_entities = $query->execute();

  if (!empty($existing_entities)) {
    foreach ($existing_entities as $entity_type => $type_entities) {
      foreach (array_keys($type_entities) as $entity_id) {
        $existing_entity_ids[] = $entity_type . ':' . $entity_id;
      }
    }
  }

  if (count($entity_ids) !== count($existing_entity_ids)) {
    throw new Exception('Hierarchy: count of $entities and count of actual descendants differ in hierarchy_reorder_entity_list().');
  }
  sort($entity_ids);
  sort($existing_entity_ids);
  if ($entity_ids !== $existing_entity_ids) {
    throw new Exception('Hierarchy: $entities and actual descendants differ in hierarchy_reorder_entity_list().');
  }

  // Load relation entities.
  $relation_ids = array();
  foreach ($entities as $entity) {
    reset($entity_types);
    $entity_type = current($entity_types);
    next($entity_types);
    $items = field_get_items($entity_type, $entity, $hierarchy_position_field_name);
    if (!empty($items)) {
      // Simple way to handle strings, numbers and NULL.
      $parent_entity_type_str = strval($parent_entity_type);
      $parent_entity_id_str = strval($parent_entity_id);
      foreach ($items as $item) {
        if (($item['hid'] == $hierarchy->hid) && (strval($item['parent_type']) === $parent_entity_type_str) && (strval($item['parent_id']) === $parent_entity_id_str)) {
          list($entity_id) = entity_extract_ids($entity_type, $entity);
          $entity_key = $entity_type . ':' . $entity_id;
          if (isset($relation_ids[$entity_key])) {
            throw new Exception('Hierarchy: two items of single entity field refer to the same parent in hierarchy_reorder_entity_list().');
          }
          $relation_id = $item['relation_id'];
          $relation_ids[$entity_key] = $relation_id;
        }
      }
    }
  }

  $relations = entity_load('hierarchy_relation', $relation_ids);
  if (count($relations) !== count($relation_ids)) {
    throw new Exception('Hierarchy: relation entities are missing in hierarchy_reorder_entity_list().');
  }

  $weight = 0;

  foreach ($relation_ids as $relation_id) {
    $weight++;
    $relation = $relations[$relation_id];
    if ($relation->weight == $weight) {
      continue;
    }
    $relation->weight = $weight;
    $relation->save();
  }
}

/**
 * Process variables for hierarchy.tpl.php.
 */
function template_preprocess_hierarchy(&$variables) {
  $hierarchy = $variables['elements']['#entity'];

  $variables['view_mode'] = $variables['elements']['#view_mode'];
  $variables['hierarchy'] = $hierarchy;

  /* // Helpful $content variable for templates.
  $variables['content'] = array();
  foreach (element_children($variables['elements']) as $key) {
    $variables['content'][$key] = $variables['elements'][$key];
  }

  // Make the field variables available with the appropriate language.
  field_attach_preprocess('hierarchy', $hierarchy,
    $variables['content'], $variables);
  list(, , $bundle) = entity_extract_ids('hierarchy', $hierarchy);

  // Gather CSS classes.
  $variables['classes_array'][] = drupal_html_class('entity-hierarchy');
  $variables['classes_array'][] = drupal_html_class('hierarchy-' . $bundle);

  // Add suggestions.
  $variables['theme_hook_suggestions'][] = 'hierarchy';
  $variables['theme_hook_suggestions'][] = 'hierarchy' . $bundle;
  $variables['theme_hook_suggestions'][] = 'hierarchy__' .
    $bundle . '__' . $variables['view_mode'];

  if ($id = entity_id('hierarchy', $hierarchy)) {
    $variables['theme_hook_suggestions'][] = 'hierarchy__' . $id;
  }*/
}

function hierarchy_generate_uuid() {
  if (function_exists('ctools_uuid_generate')) {
    return ctools_uuid_generate();
  }

  if (function_exists('uuid_generate')) {
    return uuid_generate();
  }

  // The field names refer to RFC 4122 section 4.1.2.
  return sprintf('%04x%04x-%04x-4%03x-%04x-%04x%04x%04x',
    // 32 bits for "time_low".
    mt_rand(0, 65535), mt_rand(0, 65535),
    // 16 bits for "time_mid".
    mt_rand(0, 65535),
    // 12 bits after the 0100 of (version) 4 for "time_hi_and_version".
    mt_rand(0, 4095),
    bindec(substr_replace(sprintf('%016b', mt_rand(0, 65535)), '10', 0, 2)),
    // 8 bits, the last two of which (positions 6 and 7) are 01,
    // for "clk_seq_hi_res".
    // (hence, the 2nd hex digit after the 3rd hyphen can only be 1, 5, 9 or d)
    // 8 bits for "clk_seq_low" 48 bits for "node".
    mt_rand(0, 65535), mt_rand(0, 65535), mt_rand(0, 65535)
  );
}

/**
 * Checks existence of hierarchies of the particular hierarchy type.
 *
 * @param string $type
 *   The name for the hierarchy type.
 *
 * @return bool
 *   TRUE if hierarchies exist.
 */
function hierarchy_exists_for_type($type) {
  $query = new EntityFieldQuery();
  $query->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT');
  $query->entityCondition('entity_type', 'hierarchy');
  $query->entityCondition('bundle', $type);
  $query->range(0, 1);
  $hierarchies = $query->execute();
  return !empty($hierarchies['hierarchy']);
}

function hierarchy_field_get_diff($items, $original_entity, $field, $langcode, $columns) {
  $original_items = !empty($original_entity->{$field['field_name']}[$langcode]) ? $original_entity->{$field['field_name']}[$langcode] : array();
  $diff = array('-' => array(), '+' => array());

  $items_by_key = array();
  $original_items_by_key = array();

  foreach ($items as $delta => $item) {
    $item['delta'] = $delta;
    $key = '';
    foreach ($columns as $column) {
      if (isset($item[$column])) {
        $key .= $column . '=' . $item[$column];
      }
    }
    $items_by_key[$key] = $item;
  }

  foreach ($original_items as $original_item) {
    $key = '';
    foreach ($columns as $column) {
      if (isset($original_item[$column])) {
        $key .= $column . '=' . $original_item[$column];
      }
    }
    $original_items_by_key[$key] = $original_item;
  }

  foreach ($original_items_by_key as $key => $original_item) {
    if (!isset($items_by_key[$key])) {
      $diff['-'][] = $original_item;
    }
  }

  foreach ($items_by_key as $key => $item) {
    if (!isset($original_items_by_key[$key])) {
      $diff['+'][] = $item;
    }
  }

  return $diff;
}

function hierarchy_position_check_position_correctness_get_hids($entity_type, $entity, $langcode) {
  // @todo Check cycles and top+nontop positions.
  list(, , $bundle) = entity_extract_ids($entity_type, $entity);
  $hids = array();
  $parents = array();
  foreach (field_info_instances($entity_type, $bundle) as $instance) {
    $field_name = $instance['field_name'];
    $field = field_info_field($field_name);
    if ((!empty($field)) && ($field['type'] === 'hierarchy_position')) {
      if (isset($entity->{$field_name}[$langcode])) {
        foreach ($entity->{$field_name}[$langcode] as $value) {
          if (isset($value['hid'])) {
            $hid = intval($value['hid']);
            $parent_type = isset($value['parent_type']) ? trim($value['parent_type']) : '';
            $parent_id = isset($value['parent_id']) ? intval($value['parent_id']) : 0;
            if ((isset($hids[$hid])) && (!isset($hids[$hid][$field_name]))) {
              // Multiple fields reference the same hierarchy.
              // @todo Do this more correctly.
              throw new Exception('Bad data.');
            }
            $hids[$hid][$field_name] = TRUE;

            if (isset($parents[$hid][$parent_type][$parent_id])) {
              // Multiple references to the same parent in the same hierarchy.
              // @todo Do this more correctly.
              throw new Exception('Bad data.');
            }
            $parents[$hid][$parent_type][$parent_id] = TRUE;
          }
        }
      }
    }
  }

  return $hids;
}

/**
 * Implements hook_field_insert().
 */
function hierarchy_field_insert($entity_type, $entity, $field, $instance, $langcode, &$items) {
  if ($field['type'] == 'hierarchy_position') {
    if ((empty($items)) && (!empty($instance['required'])) && (!empty($field['settings']['hierarchy_type']))) {
      $hierarchy_type = hierarchy_type_load($field['settings']['hierarchy_type']);
      if ((!empty($hierarchy_type)) && ($hierarchy_type->is_unique)) {
        $hierarchy = hierarchy_load_unique_by_type($hierarchy_type);
        if (!empty($hierarchy)) {
          $items[] = array(
            'hid' => $hierarchy->hid,
            'parent_type' => NULL,
            'parent_id' => NULL,
          );
        }
      }
    }

    $property_names = array('hid', 'parent_type', 'parent_id', 'relation_id');
    foreach ($items as $delta => $item) {
      if (!is_array($item)) {
        $hid = $item;
        $item = array_fill_keys($property_names, NULL);
        $item['hid'] = $hid;
      }
      foreach ($property_names as $property_name) {
        if (!array_key_exists($property_name, $item)) {
          $item[$property_name] = NULL;
        }
      }
      $items[$delta] = $item;
    }

    hierarchy_position_check_position_correctness_get_hids($entity_type, $entity, $langcode);
    list($entity_id) = entity_extract_ids($entity_type, $entity);
    foreach ($items as $delta => $item) {
      if ((empty($item['hid'])) || (!empty($item['relation_id']))) {
        // @todo Do this more correctly.
        throw new Exception('Bad data.');
      }
      $items[$delta]['relation_id'] = hierarchy_relation_create($entity_type, $entity, $field, $instance, $langcode, $item);
      hierarchy_position_add($item['hid'], isset($item['parent_type']) ? $item['parent_type'] : NULL,
        isset($item['parent_id']) ? $item['parent_id'] : NULL, $entity_type, $entity_id, $langcode);
    }
  }
}

/**
 * Implements hook_field_update().
 */
function hierarchy_field_update($entity_type, $entity, $field, $instance, $langcode, &$items) {
  if ($field['type'] == 'hierarchy_position') {
    // @todo Process current revision only!
    $hids = hierarchy_position_check_position_correctness_get_hids($entity_type, $entity, $langcode);
    list($entity_id, $revision_id, $bundle) = entity_extract_ids($entity_type, $entity);

    if ((empty($items)) && (!empty($instance['required'])) && (!empty($field['settings']['hierarchy_type']))) {
      $hierarchy_type = hierarchy_type_load($field['settings']['hierarchy_type']);
      if ((!empty($hierarchy_type)) && ($hierarchy_type->is_unique)) {
        $hierarchy = hierarchy_load_unique_by_type($hierarchy_type);
        if (!empty($hierarchy)) {
          $items[] = array(
            'hid' => $hierarchy->hid,
            'parent_type' => NULL,
            'parent_id' => NULL,
          );
        }
      }
    }

    // Compare the original field values with the ones that are being saved. Use
    // $entity->original to check this when possible, but if it isn't available,
    // create a bare-bones entity and load its previous values instead.
    $original_entity = NULL;
    if (isset($entity->original)) {
      $original_entity = $entity->original;
    }
    else {
      $properties = array($entity_id, $revision_id, $bundle);
      $original_entity = entity_create_stub_entity($entity_type, $properties);
      field_attach_load($entity_type, array($entity_id => $original_entity), FIELD_LOAD_CURRENT, array('field_id' => $field['id']));
    }
    $property_names = array('hid', 'parent_type', 'parent_id', 'relation_id');
    $original_items = !empty($original_entity->{$field['field_name']}[$langcode]) ? $original_entity->{$field['field_name']}[$langcode] : array();
    foreach ($items as $delta => $item) {
      if (!is_array($item)) {
        $item = array('hid' => $item);
      }
      if (count($item) === 1) {
        $hid = $item['hid'];
        $item = array_fill_keys($property_names, NULL);
        $item['hid'] = $hid;
        foreach ($original_items as $delta => $original_item) {
          if ($hid == $original_item['hid']) {
            $item = $original_item;
            unset($original_items[$delta]);
            break;
          }
        }
      }
      foreach ($property_names as $property_name) {
        if (!array_key_exists($property_name, $item)) {
          $item[$property_name] = NULL;
        }
      }
      $items[$delta] = $item;
    }

    foreach ($items as $item) {
      if (empty($item['hid'])) {
        // @todo Do this more correctly.
        throw new Exception('Bad data.');
      }
    }
    $diff = hierarchy_field_get_diff($items, $original_entity, $field, $langcode, $property_names);
    foreach ($diff['-'] as $item) {
      $entity_is_thrown = !isset($hids[intval($item['hid'])]);
      hierarchy_relation_delete($item['relation_id'], TRUE);
      hierarchy_position_remove($item['hid'], $item['parent_type'], $item['parent_id'], $entity_type, $entity_id, $langcode, $entity_is_thrown);
    }
    foreach ($diff['+'] as $item) {
      if (!empty($item['relation_id'])) {
        hierarchy_relation_delete($item['relation_id'], TRUE);
      }
      $items[$item['delta']]['relation_id'] = hierarchy_relation_create($entity_type, $entity, $field, $instance, $langcode, $item);
      hierarchy_position_add($item['hid'], isset($item['parent_type']) ? $item['parent_type'] : NULL,
        isset($item['parent_id']) ? $item['parent_id'] : NULL, $entity_type, $entity_id, $langcode);
    }
  }
}

/**
 * Implements hook_field_delete().
 */
function hierarchy_field_delete($entity_type, $entity, $field, $instance, $langcode, &$items) {
  if ($field['type'] == 'hierarchy_position') {
    list($entity_id) = entity_extract_ids($entity_type, $entity);
    foreach ($items as $item) {
      hierarchy_relation_delete($item['relation_id'], TRUE);
      hierarchy_position_remove($item['hid'], $item['parent_type'], $item['parent_id'], $entity_type, $entity_id, $langcode, TRUE);
    }
  }
}

/**
 * Implements hook_field_delete_revision().
 */
function hierarchy_field_delete_revision($entity_type, $entity, $field, $instance, $langcode, &$items) {
  if ($field['type'] == 'hierarchy_position') {
    foreach ($items as $item) {
      hierarchy_relation_delete($item['relation_id'], TRUE);
    }
  }
}

function hierarchy_position_add($hid, $parent_type, $parent_id, $entity_type, $entity_id, $langcode) {
}

function hierarchy_position_remove($hid, $parent_type, $parent_id, $entity_type, $entity_id, $langcode, $entity_is_thrown) {
  /*'hid'
  'language'
  'ancestor_entity_type'
  'ancestor_entity_id'
  'ancestor_is_source'
  'descendant_entity_type'
  'descendant_entity_id'
  'descendant_is_sink'
  'descendant_weight'
  'distance'*/
}

/**
 * Deletion callback for hierarchy relations.
 */
function hierarchy_relation_delete($rid, $host_entity_item_deleted = FALSE) {
  $relation = hierarchy_relation_load($rid);
  if ($relation) {
    $relation->delete($host_entity_item_deleted);
  }
}

function hierarchy_relation_create($entity_type, $entity, $field, $instance, $langcode, $item) {
  $hierarchy_relation = new HierarchyRelation(array('field_name' => $field['field_name'], 'weight' => 0));
  $hierarchy_relation->save();
  return $hierarchy_relation->rid;
}

/**
 * Implements hook_field_create_field().
 */
function hierarchy_field_create_field($field) {
  if ($field['type'] == 'hierarchy_position') {
    field_attach_create_bundle('hierarchy_relation', $field['field_name']);
    entity_info_cache_clear();
    variable_set('menu_rebuild_needed', TRUE);
  }
}

/**
 * Implements hook_field_delete_field().
 */
function hierarchy_field_delete_field($field) {
  if ($field['type'] == 'hierarchy_position') {
    field_attach_delete_bundle('hierarchy_relation', $field['field_name']);
    entity_info_cache_clear();
    variable_set('menu_rebuild_needed', TRUE);
  }
}

/**
 * Implements hook_features_pipe_COMPONENT_alter().
 *
 * This is used with Features v1.0 and v2.0 prior to beta2, newer releases
 * separated the field_base from the field_instance so this won't be used.
 */
function hierarchy_features_pipe_field_alter(&$pipe, $data, $export) {
  // Skip this if Features has been updated to v2.0-beta2 or newer as it will
  // use the separate field_instance integration instead.
  if (!function_exists('field_instance_features_export_options')) {
    // Add the fields of the field collection entity to the pipe.
    foreach ($data as $identifier) {
      if (($field = features_field_load($identifier)) && $field['field_config']['type'] == 'hierarchy_position') {
        $fields = field_info_instances('hierarchy_relation', $field['field_config']['field_name']);
        foreach ($fields as $name => $field) {
          $pipe['field'][] = "{$field['entity_type']}-{$field['bundle']}-{$field['field_name']}";
        }
      }
    }
  }
}

/**
 * Implements hook_features_pipe_COMPONENT_alter().
 *
 * This is used with Features v2.0-beta2 and newer.
 */
function hierarchy_features_pipe_field_instance_alter(&$pipe, $data, $export) {
  // Add the fields of the field collection entity to the pipe.
  foreach ($data as $identifier) {
    if (($field = features_field_load($identifier)) && $field['field_config']['type'] == 'hierarchy_position') {
      $fields = field_info_instances('hierarchy_relation', $field['field_config']['field_name']);
      foreach ($fields as $name => $field) {
        $pipe['field_instance'][] = "{$field['entity_type']}-{$field['bundle']}-{$field['field_name']}";
      }
    }
  }
}

/**
 * Entity property info getter callback for the host entity property.
 */
function hierarchy_relation_get_host_entity(HierarchyRelation $item) {
  return entity_metadata_wrapper($item->hostEntityType(), $item->hostEntity());
}

function hierarchy_reorder_items_form($form, &$form_state, $hierarchy, $langcode = NULL) {
  module_load_include('inc', 'hierarchy', 'includes/hierarchy.admin');
  hierarchy_reorder_items_build_form($form, $form_state, $hierarchy, $langcode);

  return $form;
}

function hierarchy_item_tree_content($hierarchy, $langcode = NULL) {
  module_load_include('inc', 'hierarchy', 'includes/hierarchy.admin');
  return hierarchy_build_item_tree_content($hierarchy, $langcode);
}

function hierarchy_add_entities_to_hierarchy_for_required_field($field_name, $hierarchy) {
  $hierarchy_type = hierarchy_type_load($hierarchy->type);
  if (empty($hierarchy_type->is_unique)) {
    throw new Exception('Hierarchy: non-unique hierarchy in hierarchy_add_entities_to_hierarchy_for_required_field().');
  }

  $field = field_info_field($field_name);
  if (empty($field)) {
    throw new Exception('Hierarchy: non-existing field in hierarchy_add_entities_to_hierarchy_for_required_field().');
  }

  if (isset($field['bundles'])) {
    foreach ($field['bundles'] as $entity_type => $bundles) {
      foreach ($bundles as $bundle) {
        $instance = field_info_instance($entity_type, $field_name, $bundle);
        if (!empty($instance['required'])) {
          $entities = entity_load($entity_type, hierarchy_get_entities_not_in_hierarchy($entity_type, $bundle, $hierarchy, $field_name));
          foreach ($entities as $entity) {
            hierarchy_put_entity_in_hierarchy($entity_type, $entity, $hierarchy, $field_name, NULL, NULL);
          }
        }
      }
    }
  }
}

function hierarchy_get_entities_not_in_hierarchy($entity_type, $bundle, $hierarchy, $hierarchy_position_field_name) {
  $query = new EntityFieldQuery();
  $query->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT');
  $query->entityCondition('entity_type', $entity_type);
  $query->entityCondition('bundle', $bundle);
  $all_entities = $query->execute();
  $all_entity_ids = !empty($all_entities[$entity_type]) ? array_keys($all_entities[$entity_type]) : array();

  $query = new EntityFieldQuery();
  $query->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT');
  $query->entityCondition('entity_type', $entity_type);
  $query->entityCondition('bundle', $bundle);
  // @todo Add language conditions.
  $query->fieldCondition($hierarchy_position_field_name, 'hid', $hierarchy->hid);
  $hierarchy_entities = $query->execute();
  $hierarchy_entity_ids = !empty($hierarchy_entities[$entity_type]) ? array_keys($hierarchy_entities[$entity_type]) : array();

  return array_diff($all_entity_ids, $hierarchy_entity_ids);
}
