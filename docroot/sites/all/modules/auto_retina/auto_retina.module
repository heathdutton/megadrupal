<?php
/**
 * @file
 * Base file for the auto_retina module.
 *
 * @defgroup auto_retina Auto Retina
 * @{
 */

// Path to the admin settings form
// Be sure to update .info file as well if you change this.
define('AUTO_RETINA_URL_SETTINGS', 'admin/config/media/image-styles/auto-retina');

/**
 * @var AUTO_RETINA_LOG
 *
 * Should image quality concerns be logged?
 */
define('AUTO_RETINA_LOG', TRUE);
/**
 * @var AUTO_RETINA_REGEX
 *
 * The default suffix to use.
 */
define('AUTO_RETINA_REGEX', '(.+)([suffix])\.(png|jpg|jpeg|gif)$');

/**
 * @var  AUTO_RETINA_SUFFIX
 *
 * The default suffix to use.
 */
define('AUTO_RETINA_SUFFIX', '@2x');

/**
 * @var AUTO_RETINA_JS
 *
 * Should the js vars be included on every page
 */
define('AUTO_RETINA_JS', FALSE);


// If the file is not included here, the hooks won't be found.
require_once dirname(__FILE__) . '/includes/auto_retina.effects.inc';

/**
 * Implements hook_page_alter().
 *
 * Adds in our JS vars per settings.
 */
function auto_retina_page_alter(&$build) {

  // Adds a Javascript settings array if asked.
  if (variable_get('auto_retina_js', AUTO_RETINA_JS)) {
    $settings = auto_retina_get_settings();
    if (preg_match('/\/(.+)\//', $settings['regex'], $matches)) {
      $settings['regex'] = $matches[1];
    }
    $build['page_bottom']['#attached']['js'][] =  array(
      'type' => 'setting', 
      'data' => array('autoRetina' => $settings),
    );
  }
}

/**
 * Returns the module settings array.
 *
 * @return array
 *   - suffix
 *   - regex
 */
function auto_retina_get_settings() {
  $suffix        = variable_get('auto_retina_suffix', '@2x');
  $regex_pattern = variable_get('auto_retina_regex', AUTO_RETINA_REGEX);
  $regex         = str_replace('[suffix]', $suffix, $regex_pattern);
  if (strpos($regex, 0, 1) !== '/') {
    $regex = '/' . $regex . '/i';
  }

  return array(
    'suffix' => $suffix,
    'regex' => $regex,
  );
}

/**
 * Implements hook_menu().
 */
function auto_retina_menu() {
  $items = array();

  $items[AUTO_RETINA_URL_SETTINGS] = array(
   'title' => 'Auto Retina',
   'description' => 'Administer module configuration settings',
   'page callback' => 'drupal_get_form',
   'page arguments' => array('auto_retina_admin_settings'),
   'file' => 'includes/auto_retina.admin.inc',
   'access arguments' => array('administer image styles'),
   'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function auto_retina_menu_alter(&$items) {

  // This is how we hook into the derivative image delivery process...
  $directory_path = file_stream_wrapper_get_instance_by_scheme('public')->getDirectoryPath();
  $items[$directory_path . '/styles/%image_style']['page callback'] = 'auto_retina_image_style_deliver';
  $items['system/files/styles/%image_style']['page callback'] = 'auto_retina_image_style_deliver';
}

/**
 * Parses a "retina" path and returns it's parts.
 *
 * @param  string $path E.g. my-file@2x.png
 *
 * @return array
 *   list($original, $suffix, $extension) = auto_retina_parse_path($path);
 */
function auto_retina_parse_path($path) {
  $info = auto_retina_get_settings();
  preg_match($info['regex'], $path, $matches);

  return $matches;
}

/**
 * Checks if a path is a retina image per settings.
 *
 * @param  string $path E.g. my-file@2x.png
 *
 * @return  bool
 */
function auto_retina_path_is_retina($path) {
  $info = auto_retina_parse_path($path);
  
  return !empty($info[0]);
}

/**
 * Implements hook_auto_retina_create_derivative_alter().
 */
function auto_retina_auto_retina_create_derivative_alter(&$style, &$source, &$destination) {
  $args = func_get_args();
  if (auto_retina_path_is_retina($destination)) {
    module_load_include('inc', 'auto_retina', 'includes/auto_retina.effects');
    foreach ($style['effects'] as &$effect) {
      $alters = array('auto_retina_effect_' . $effect['name'], 'auto_retina_effect');
      foreach ($alters as $hook) {
        drupal_alter($hook, $effect, $style['auto_retina'], $args);
      }
    }
  }
}

/**
 * Multiplies width by a number and increases height to maintain aspect ratio.
 *
 * @param  float $multiplier
 * @param  int &$width
 * @param  int &$height
 *
 * @return array The new dimensions
 */
function auto_retina_multiply_width_maintain_aspect_ratio($multiplier, &$width, &$height) {
  $new_width = $width * $multiplier;
  $height    = intval(($height / $width) * $new_width);
  $width     = intval($new_width);

  return array('width' => $width, 'height' => $height);
}


/**
 * Page callback: Generates a derivative, given a style and image path.
 *
 * After generating an image, transfer it to the requesting agent.
 *
 * @param $style
 *   The image style
 *
 * @see  image_style_deliver()
 */
function auto_retina_image_style_deliver($style, $scheme) {
  $args = func_get_args();
  array_shift($args);
  array_shift($args);
  $target = implode('/', $args);
  
  // Find the retina info stored in the url.
  $original_target      = $target;
  $style['auto_retina'] = array('suffix' => '', 'multiplier' => 1);
  if (($retina_info = auto_retina_parse_path($target))) {
    $original_target = $retina_info[1] . '.' . $retina_info['3'];
    $style['auto_retina'] = array(
      'suffix' => $retina_info[2],
      'multiplier' => preg_replace('/[^0-9]/', '', $retina_info[2]) * 1,
    );
  }

  // Check that the style is defined, the scheme is valid, and the image
  // derivative token is valid. (Sites which require image derivatives to be
  // generated without a token can set the 'image_allow_insecure_derivatives'
  // variable to TRUE to bypass the latter check, but this will increase the
  // site's vulnerability to denial-of-service attacks. To prevent this
  // variable from leaving the site vulnerable to the most serious attacks, a
  // token is always required when a derivative of a derivative is requested.)
  $valid = !empty($style) && file_stream_wrapper_valid_scheme($scheme);
  if (!variable_get('image_allow_insecure_derivatives', FALSE) || strpos(ltrim($target, '\/'), 'styles/') === 0) {
    $valid = $valid && isset($_GET[IMAGE_DERIVATIVE_TOKEN]) && $_GET[IMAGE_DERIVATIVE_TOKEN] === image_style_path_token($style['name'], $scheme . '://' . $original_target);
  }
  if (!$valid) {
    return MENU_ACCESS_DENIED;
  }

  $image_uri          = $scheme . '://' . $target;
  $original_image_uri = $scheme . '://' . $original_target;
  $derivative_uri     = image_style_path($style['name'], $image_uri);

  // If using the private scheme, let other modules provide headers and
  // control access to the file.
  if ($scheme == 'private') {
    if (file_exists($derivative_uri)) {
      file_download($scheme, file_uri_target($derivative_uri));
    }
    else {
      $headers = module_invoke_all('file_download', $image_uri);
      if (in_array(-1, $headers) || empty($headers)) {
        return MENU_ACCESS_DENIED;
      }
      if (count($headers)) {
        foreach ($headers as $name => $value) {
          drupal_add_http_header($name, $value);
        }
      }
    }
  }

  // Confirm that the original source image exists before trying to process it.
  if (!is_file($original_image_uri)) {
    watchdog('image', 'Source image at %source_image_path not found while trying to generate derivative image at %derivative_path.',  array('%source_image_path' => $original_image_uri, '%derivative_path' => $derivative_uri));
    return MENU_NOT_FOUND;
  }

  // Don't start generating the image if the derivative already exists or if
  // generation is in progress in another thread.
  $lock_name = 'image_style_deliver:' . $style['name'] . ':' . drupal_hash_base64($image_uri);
  if (!file_exists($derivative_uri)) {
    $lock_acquired = lock_acquire($lock_name);
    if (!$lock_acquired) {
      // Tell client to retry again in 3 seconds. Currently no browsers are known
      // to support Retry-After.
      drupal_add_http_header('Status', '503 Service Unavailable');
      drupal_add_http_header('Content-Type', 'text/html; charset=utf-8');
      drupal_add_http_header('Retry-After', 3);
      print t('Image generation in progress. Try again shortly.');
      drupal_exit();
    }
  }

  // Try to generate the image, unless another thread just did it while we were
  // acquiring the lock.
  $success = file_exists($derivative_uri) || auto_retina_image_style_create_derivative($style, $original_image_uri, $derivative_uri);

  if (!empty($lock_acquired)) {
    lock_release($lock_name);
  }

  if ($success) {
    $image = image_load($derivative_uri);
    file_transfer($image->source, array('Content-Type' => $image->info['mime_type'], 'Content-Length' => $image->info['file_size']));
  }
  else {
    watchdog('image', 'Unable to generate the derived image located at %path.', array('%path' => $derivative_uri));
    drupal_add_http_header('Status', '500 Internal Server Error');
    drupal_add_http_header('Content-Type', 'text/html; charset=utf-8');
    print t('Error generating image.');
    drupal_exit();
  }
}

/**
 * Creates a new image derivative based on an image style.
 *
 * Generates an image derivative by creating the destination folder (if it does
 * not already exist), applying all image effects defined in $style['effects'],
 * and saving a cached version of the resulting image.
 *
 * @param $style
 *   An image style array.
 * @param $source
 *   Path of the source file.
 * @param $destination
 *   Path or URI of the destination file.
 *
 * @return
 *   TRUE if an image derivative was generated, or FALSE if the image derivative
 *   could not be generated.
 *
 * @see image_style_load()
 * @see image_style_create_derivative
 */
function auto_retina_image_style_create_derivative($style, $source, $destination) {
  drupal_alter('auto_retina_create_derivative', $style, $source, $destination);

  // If the source file doesn't exist, return FALSE without creating folders.
  if (!$image = image_load($source)) {
    return FALSE;
  }

  // Get the folder for the final location of this style.
  $directory = drupal_dirname($destination);

  // Build the destination folder tree if it doesn't already exist.
  if (!file_prepare_directory($directory, FILE_CREATE_DIRECTORY | FILE_MODIFY_PERMISSIONS)) {
    watchdog('image', 'Failed to create style directory: %directory', array('%directory' => $directory), WATCHDOG_ERROR);
    return FALSE;
  }

  foreach ($style['effects'] as $effect) {
    image_effect_apply($image, $effect);
  }

  if (!image_save($image, $destination)) {
    if (file_exists($destination)) {
      watchdog('image', 'Cached image file %destination already exists. There may be an issue with your rewrite configuration.', array('%destination' => $destination), WATCHDOG_ERROR);
    }
    return FALSE;
  }

  return TRUE;
}