<?php

/**
 * @file
 * Drupal module for downloading groups of files.
 */

define('DOCBINDER_PATH_ADD', 'docbinder/add');
define('DOCBINDER_PATH_REMOVE', 'docbinder/remove');
define('DOCBINDER_PATH_TOGGLE', 'docbinder/toggle');
define('DOCBINDER_PATH_GET', 'docbinder/get');

/**
 * Implements hook_menu().
 */
function docbinder_menu() {
  $items['admin/config/media/docbinder'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('docbinder_settings_form'),
    'title' => 'DocBinder',
    'description' => 'Configure settings for DocBinder',
    'access arguments' => array('administer site configuration'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'docbinder.admin.inc',
  );
  $items[DOCBINDER_PATH_ADD] = array(
    'page callback' => 'docbinder_add_file_to_docbinder',
    'page arguments' => array(FALSE),
    'title' => 'Add file to DocBinder',
    'type' => MENU_CALLBACK,
    'access arguments' => array('access docbinder downloads'),
  );
  $items[DOCBINDER_PATH_ADD . '/AJAX'] = array(
    'page callback' => 'docbinder_add_file_to_docbinder',
    'page arguments' => array(TRUE),
    'title' => 'Add file to DocBinder',
    'type' => MENU_CALLBACK,
    'access arguments' => array('access docbinder downloads'),
  );
  $items[DOCBINDER_PATH_REMOVE] = array(
    'page callback' => 'docbinder_remove_file_from_docbinder',
    'page arguments' => array(FALSE),
    'title' => 'Remove file to DocBinder',
    'type' => MENU_CALLBACK,
    'access arguments' => array('access docbinder downloads'),
  );
  $items[DOCBINDER_PATH_REMOVE . '/AJAX'] = array(
    'page callback' => 'docbinder_remove_file_from_docbinder',
    'page arguments' => array(TRUE),
    'title' => 'Remove file to DocBinder',
    'type' => MENU_CALLBACK,
    'access arguments' => array('access docbinder downloads'),
  );
  $items[DOCBINDER_PATH_TOGGLE] = array(
    'page callback' => 'docbinder_toggle_file_in_docbinder',
    'page arguments' => array(FALSE),
    'title' => 'Toggle file in DocBinder',
    'type' => MENU_CALLBACK,
    'access arguments' => array('access docbinder downloads'),
  );
  $items[DOCBINDER_PATH_TOGGLE . '/AJAX'] = array(
    'page callback' => 'docbinder_toggle_file_in_docbinder',
    'page arguments' => array(TRUE),
    'title' => 'Toggle file in DocBinder',
    'type' => MENU_CALLBACK,
    'access arguments' => array('access docbinder downloads'),
  );
  $items[DOCBINDER_PATH_GET] = array(
    'page callback' => 'docbinder_get_zip',
    'title' => 'Download DocBinder',
    'type' => MENU_CALLBACK,
    'access arguments' => array('access docbinder downloads'),
  );
  $items['docbinder'] = array(
    'page callback' => 'docbinder_docbinder',
    'title' => 'Your DocBinder',
    'description' => 'Modify and download your current DocBinder',
    'access arguments' => array('access docbinder downloads'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'docbinder.pages.inc',
  );
  return $items;
}

/**
 * Implements hook_theme().
 */
function docbinder_theme($existing, $type, $theme, $fid) {
  return array(
    'docbinder_block_downloads' => array(
      'template' => 'docbinder-block-downloads',
      'variables' => array(
        'count' => 0,
        'files' => NULL,
      ),
    ),
    'docbinder_download' => array(
      'variables' => array(
        'text' => 'Download',
        'fid' => NULL,
        'options' => array(),
      ),
    ),
    'docbinder_link' => array(
      'variables' => array(
        'file' => NULL,
        'icon_directory' => NULL,
      ),
    ),
  );
}

/**
 * Implements hook_perm().
 */
function docbinder_permission() {
  return array(
    'access docbinder downloads' => array(
      'title' => t('Access DocBinder Downloads'),
      'description' => t('Allow users to access DocBinder Downloads'),
    ),
  );
}

/**
 * Implements hook_block_info().
 */
function docbinder_block_info() {
  $blocks[0] = array(
    'info'  => t('DocBinder Downloads'),
    'cache' => DRUPAL_NO_CACHE,
  );
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function docbinder_block_view($delta = '') {
  if (user_access('access docbinder downloads')) {
    switch ($delta) {
      case '0':
        $block = array(
          'subject' => t('My Downloads'),
          'content' => theme('docbinder_block_downloads'),
        );
        return $block;
    }
  }
}

/**
 * Return block content for docbinder block.
 */
function docbinder_block_content() {
  $count = (!empty($_SESSION['docbinder']['files'])) ? count($_SESSION['docbinder']['files']) : 0;
  $files = (!empty($_SESSION['docbinder']['files'])) ? $_SESSION['docbinder']['files'] : NULL;
  return theme('docbinder_block_downloads', $count, $files);
}

/**
 * Implements hook_field_formatter_info().
 * @see field_example_field_formatter_view()
 */
function docbinder_field_formatter_info() {
  return array(
    'file_default' => array(
      'label' => t('Generic file'),
      'field types' => array('file', 'image'),
      'module' => 'docbinder',
    ),
    'file_table' => array(
      'label' => t('Table of files'),
      'field types' => array('file'),
      'module' => 'docbinder',
    ),
    'file_id' => array(
      'label' => t('File Id'),
      'field types' => array('file'),
      'module' => 'docbinder',
    ),
  );
}

/**
 * Implements hook_field_formatter_info_alter().
 * @see field_example_field_formatter_view()
 */
function docbinder_field_formatter_info_alter(&$info) {
  // Add a setting to a formatter type.
  $info['file_default']['module'] = 'docbinder';
  $info['file_table']['module'] = 'docbinder';
}

/**
 * Implements hook_field_formatter_view().
 * @see field_example_field_formatter_info()
 */
function docbinder_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $docbinder_node_types = array_filter(variable_get('docbinder_node_types_active', array()));
  if (empty($docbinder_node_types) || $docbinder_node_types[$entity->type] === $entity->type) {
    $element = array();
    $options = array(
      'html' => FALSE,
      'query' => array('destination' => current_path()),
      'attributes' => array('class' => array('docbinder')),
    );
    if (variable_get('docbinder_field_display', 'link') == 'checkbox') {
      $options['attributes']['class'][] = 'docbinder-checkbox';
    }
    switch ($display['type']) {
      // This formatter simply outputs a docbinder link
      case 'file_default':
        foreach ($items as $delta => $item) {
          if (empty($item['description'])) {
            $link_text = $item['filename'];
          }
          else {
            $link_text = $item['description'];
            $options['attributes']['title'] = check_plain($item['filename']);
          }
          $options['attributes']['id'] = 'docbinder-id-' . $item['fid'];
          if (!empty($_SESSION['docbinder']['files']) && isset($_SESSION['docbinder']['files'][$item['fid']])) {
            $path = DOCBINDER_PATH_REMOVE . '/' . $item['fid'];
            $link_text .= ' (-)';
          }
          else {
            $path = DOCBINDER_PATH_ADD . '/' . $item['fid'];
            $link_text .= ' (+)';
          }
          $mime = check_plain($item['filemime']);
          $icon_url = file_icon_url((object) $item);
          $icon = '<img class="file-icon" alt="" title="' . $mime . '" src="' . $icon_url . '" /> ';
          $element[$delta] = array(
            '#theme' => 'link',
            '#text' => $link_text,
            '#path' => $path,
            '#options' => $options,
            '#prefix' => $icon,
          );
        }
        break;

      // This formatter just returns the file id to be used for rewrites in views
      case 'file_id':
        foreach ($items as $delta => $item) {
          $element[$delta] = array('#markup' => $item['fid']);
        }
        break;

      // This formatter adds a docbinder download link to a file table
      case 'file_table':
        // Some formatters might need to display all values within a single piece
        // of markup.
        $rows = array();
        foreach ($items as $delta => $item) {
          if (empty($item['description'])) {
            $link_title = $item['filename'];
          }
          else {
            $link_title = $item['description'];
          }
          $link_text = 'Your Downloads';
          $options['attributes']['id'] = 'docbinder-id-' . $item['fid'];
          if (!empty($_SESSION['docbinder']['files']) && isset($_SESSION['docbinder']['files'][$item['fid']])) {
            $path = DOCBINDER_PATH_REMOVE . '/' . $item['fid'];
            $link_text .= ' (-)';
          }
          else {
            $path = DOCBINDER_PATH_ADD . '/' . $item['fid'];
            $link_text .= ' (+)';
          }
          $mime = check_plain($item['filemime']);
          $icon_url = file_icon_url((object) $item);
          $icon = '<img class="file-icon" alt="" title="' . $mime . '" src="' . $icon_url . '" /> ';
          $docbinder_table_link = l($link_text, $path, $options);

          $rows[] = array(
            (variable_get('docbinder_remove_hotlink', 0) == 0) ? theme('file_link', array('file' => (object) $item)) : $link_title,
            $docbinder_table_link,
            format_size($item['filesize']),
          );
        }
        $element[0] = array(
          '#theme' => 'table',
          '#header' => array(t('Attachment'), t('Your Downloads'), t('Size')),
          '#rows' => $rows,
        );
        break;
    }
    return $element;
  }
  else {
    $default_formatter = $field['type'] . '_field_formatter_view';
    return $default_formatter($entity_type, $entity, $field, $instance, $langcode, $items, $display);
  }
}

/**
 * Implements hook_file_download().
 */
function docbinder_file_download($filepath) {
  // dpm($filepath);
}

/**
 * Implements hook_zipmethods().
 */
function docbinder_zipmethods() {
  $methods['zip_builtin'] = array(
    'title'    => 'PHP Zip extension',
    'callback' => '_docbinder_phpzip',
  );
  return $methods;
}

/**
 * Return an array of zip methods.
 */
function _docbinder_get_available_methods() {
  foreach (module_implements('zipmethods') as $module) {
    $function = $module . '_zipmethods';
    if ($methods = $function()) {
      if (is_array($methods)) {
        foreach ($methods as $key => $method) {
          $avail_methods[$key] = $method;
        }
      }
    }
  }
  return $avail_methods;
}

/**
 * Add a file path to a user's $_SESSION.
 *
 * Check the user has permission to access the file here, warn if they do not.
 */
function docbinder_add_file_to_docbinder($ajax = FALSE) {
  $fid = func_get_arg(1);
  $success = FALSE;
  $file = file_load($fid);
  if ($file) {
    $headers = module_invoke_all('file_download', $file->uri);
    if (!in_array(-1, $headers)) {
      // OK, hook_file_download didn't object.
      $files = array($file->uri);
      $files = module_invoke_all('filterzip', $files);
      if (!empty($files)) {
        $_SESSION['docbinder']['files'][$fid] = $file->uri;
        $success = TRUE;
      }
    }
  }

  $result = array(
    'docbinder' => $_SESSION['docbinder']['files'],
    'result' => $success,
    'action' => 'added',
  );
  if ($ajax) {
    drupal_json_output($result);
  }
  else {
    if ($success) {
      $targs = array(
        '%filename' => check_plain($file->filename),
        '!view' => l(t('Click here view your docbinder.'), 'docbinder'),
      );
      drupal_set_message(t('The file %filename has been added to your binder. !view', $targs));
    }
    else {
      drupal_set_message(t('The file !filename could not be added to your binder.', array('!filename' => check_plain($filename))));
    }
    drupal_goto();
  }
}

/**
 * Remove a file path from a user's $_SESSION.
 *
 * Check the user has permission to access the file here, warn if they do not.
 */
function docbinder_remove_file_from_docbinder($ajax = FALSE) {
  $fid = func_get_arg(1);
  $success = FALSE;
  $file = file_load($fid);
  if (isset($_SESSION['docbinder']['files'][$fid])) {
    // file is in binder, remove now
    unset($_SESSION['docbinder']['files'][$fid]);
    $success = TRUE;
  }

  $result = array(
    'docbinder' => $_SESSION['docbinder']['files'],
    'result' => $success,
    'action' => 'removed',
  );
  if ($ajax) {
    drupal_json_output($result);
  }
  else {
    if ($success) {
      $targs = array(
        '%filename' => check_plain($file->filename),
        '!view' => l(t('Click here view your DocBinder.'), 'docbinder'),
      );
      drupal_set_message(t('The file %filename has been removed from your binder. !view', $targs));
    }
    else {
      drupal_set_message(t('The file !filename could not be removed from your binder.', array('!filename' => check_plain($filename))));
    }
    drupal_goto();
  }
}

/**
 * Toggle a file path in a user's $_SESSION.
 *
 * Check the user has permission to access the file here, warn if they do not.
 */
function docbinder_toggle_file_in_docbinder($ajax = FALSE) {
  $fid = func_get_arg(1);
  if (isset($_SESSION['docbinder']['files'][$fid])) {
    // file is in binder, remove now
    docbinder_remove_file_from_docbinder($ajax, $fid);
  }
  else {
    // not in finder, add now
    docbinder_add_file_to_docbinder($ajax, $fid);
  }
}

/**
 * Get the files as a zip.
 */
function docbinder_get_zip() {
  if (empty($_SESSION['docbinder']['files'])) {
    drupal_set_message(t('Sorry, there are no files queued for you to download.'));
    drupal_goto();
  }
  else {
    $files = $_SESSION['docbinder']['files'];
    $files = module_invoke_all('filterzip', $files);

    if (!empty($files)) {
      $methods = _docbinder_get_available_methods();
      $zipmethod = variable_get('docbinder_zip_method', 'zip_builtin');
      if (isset($methods[$zipmethod])) {
        $zipfunction = $methods[$zipmethod]['callback'];
        if (!$zipfunction($files)) {
          return 'Download failed.';
        }
        else {
          drupal_set_message('Binder downloaded.');
          return TRUE;
        }
      }
    }
  }
}

/**
 * Preprocess the list of files.
 *
 * Don't ever share these files:
 *   $excluded = array( 'sites/.*settings.*php' );
 *
 * Only ever include these files:
 *   $included = array( 'sites/files/.*' );
 *
 * Always include a certain file:
 *   $add = array( 'sites/default/files/README.txt' );
 */
function docbinder_filterzip($files) {
  $directory = drupal_realpath(file_default_scheme() . '://');
  foreach ($files as $i => &$file) {
    if (strpos(drupal_realpath($file), $directory) !== 0) {
      watchdog('docbinder', 'Forbidding download of !file',
                            array('!file' => $file), WATCHDOG_NOTICE);
      unset($files[$i]);
    }

    // Reject external URIs.
    $localpath = drupal_realpath($file);
    if ($localpath) {
      $file = $localpath;
    }
    else {
      watchdog('docbinder', 'External file cannot be added to zip. !file',
                          array('!file' => $file), WATCHDOG_NOTICE);
      unset($files[$i]);
    }

  }
  return $files;
}

/**
 * Invoke hook_docbinder_download_complete() when download completed.
 */
function _docbinder_download_complete($filename, $files) {
  module_invoke_all('docbinder_download_complete', $filename, $files);
}

/**
 * Zip callback: PHP zip extension.
 */
function _docbinder_phpzip($files) {
  $zip = new ZipArchive();
  // We build the file in $filename, but file_transfer will
  // only deliver it via a registered Drupal stream.
  $filename = drupal_tempnam(file_directory_temp(), 'docbinder');
  $transfer_filename = 'temporary://' . basename($filename);
  $zip_open = $zip->open($filename, ZIPARCHIVE::CREATE | ZIPARCHIVE::OVERWRITE);
  if ($zip_open === TRUE) {
    $zip->setArchiveComment('Generated by DocBinder for Drupal.');
    // http://drupal.org/node/1234282 - duplicate filenames.
    foreach ($files as $file) {
      if (file_exists($file)) {
        if ($zip->addFile($file, basename($file))) {
          // drupal_set_message(t('!file added to binder.', array('!file' => basename($file))));
        }
        else {
          drupal_set_message(t('!file could not be added to binder.', array('!file' => $file)), 'error');
          watchdog('docbinder', 'Failed to add !file to binder.', array('!file' => $file), WATCHDOG_ERROR);
        }
      }
      else {
        watchdog('docbinder', 'Failed to locate !file.', array('!file' => $file), WATCHDOG_ERROR);
        drupal_set_message('!file not found.', array('!file' => $file), 'error');
      }
    }
    if (!$zip->close()) {
      watchdog('docbinder', 'Error saving file: !status_string', array('!status_string' => $zip->getStatusString()), WATCHDOG_ERROR);
    }

    $headers = module_invoke_all('file_download', $filename);
    if (in_array(-1, $headers)) {
      return drupal_access_denied();
    }
    $zip_filename = _docbinder_zip_filename();
    $headers['Content-Type'] = file_get_mimetype($zip_filename);
    $headers['Content-Disposition'] = 'attachment; filename="' . $zip_filename . '"';
    // FIXME: it would be nice to wait until the file transfer completes before
    // we clear the files out of the session. However, if we do that, the user
    // can't add new files to their docbinder until the zip is downloaded. So we'll
    // do this first.
    $files = $_SESSION['docbinder']['files'];
    $_SESSION['docbinder']['files'] = array();
    drupal_register_shutdown_function('_docbinder_download_complete', $filename, $files);
    if (!file_transfer($transfer_filename, $headers)) {
      watchdog('docbinder', 'Unable to transfer file from !filename.', array('!filename' => check_plain($transfer_filename)), WATCHDOG_ERROR);
      drupal_set_message(t('Unable to transfer file from !filename.', array('!filename' => check_plain($transfer_filename))), 'error');
    }
  }
  else {
    watchdog('docbinder', 'Unable to create file !filename.', array('!filename' => check_plain($filename)), WATCHDOG_ERROR);
    drupal_set_message(t('Unable to create file !filename.', array('!filename' => check_plain($filename))), 'error');
    drupal_access_denied();
  }
}

/**
 * Generate a suitable filename for the zip.
 */
function _docbinder_zip_filename() {
  $filename = 'Files - ' . date('Y-m-d_Hi') . '.zip';
  return $filename;
}

/**
 * Obtain correct path to return user to after adding file to docbinder.
 */
function _docbinder_get_destination_alias() {
  if (isset($_REQUEST['destination'])) {
    $path = check_plain(drupal_get_path_alias($_REQUEST['destination']));
  }
  else {
    // Use $_GET here to retrieve the original path in source form.
    $path = isset($_GET['q']) ? check_plain(drupal_get_path_alias($_GET['q'])) : '';
  }
  return array(
    'destination' => $path,
  );
}

/**
 * Theme function to generate a download link.
 */
function theme_docbinder_download($vars = array()) {
  $text = !empty($vars['text']) ? $vars['text'] : '';
  $fid = !empty($vars['fid']) ? $vars['fid'] : NULL;
  if (is_null($fid)) {
    return NULL;
  }
  $options = !empty($vars['options']) ? $vars['options'] : array();
  $default_options = array(
    'attributes' => array(
      'class' => 'docbinder',
    ),
    'query' => _docbinder_get_destination_alias(),
  );
  $options = array_merge($default_options, $options);
  return l($text, DOCBINDER_PATH_ADD . '/' . $fid, $options);
}

/**
 * Implements hook_docbinder_download_complete().
 */
function docbinder_docbinder_download_complete($filename) {
  drupal_unlink($filename);
}

/**
 * Theme preprocess function.
 */
function docbinder_preprocess_docbinder_block_downloads(&$variables) {
  drupal_add_js(drupal_get_path('module', 'docbinder') . '/docbinder.js');
  drupal_add_js(array(
    'docbinder' => array(
      'path_add' => DOCBINDER_PATH_ADD,
      'path_add_ajax' => DOCBINDER_PATH_ADD . '/AJAX',
      'path_remove' => DOCBINDER_PATH_REMOVE,
      'path_remove_ajax' => DOCBINDER_PATH_REMOVE . '/AJAX',
      'path_toggle' => DOCBINDER_PATH_TOGGLE,
      'path_toggle_ajax' => DOCBINDER_PATH_TOGGLE . '/AJAX',
    )
  ), 'setting');
  $variables['count'] = (!empty($_SESSION['docbinder']['files'])) ? count($_SESSION['docbinder']['files']) : 0;
  $variables['files'] = (!empty($_SESSION['docbinder']['files'])) ? $_SESSION['docbinder']['files'] : NULL;
}
