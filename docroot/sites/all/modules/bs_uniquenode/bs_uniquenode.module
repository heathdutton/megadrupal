<?php

/**
 * @file
 *
 * This module provides a function to check new content which may be similar or
 * equal to other nodes.
 *
 * This does integrate with cck and uses phonem to make sound check on strings
 * to detect "drupal" and "trupal" as an equal field.
 */

define('SUBMIT_UNIQUE_CONTENT', 'submit_unique_content');

/*
 * Implements hook_init().
 */
function bs_uniquenode_init() {
  drupal_add_css(drupal_get_path('module', 'bs_uniquenode') . '/bs_uniquenode.css');
}

/**
 * Implements hook_cron().
 */
function bs_uniquenode_cron() {
  _bs_uniquenode_update_phonem();
}

/**
 * Implements hook_theme().
 */
function bs_uniquenode_theme() {
  return array(
    'uniquity_check_field' => array(
      'variables' => array(
        'fieldlink' => FALSE,
        'fieldname' => FALSE,
        'checktype' => FALSE,
      ),
      'file' => 'theme.inc',
    ),
    'uniquity_check_field_explanation' => array(
      'variables' => array(
        'message' => FALSE,
      ),
      'file' => 'theme.inc',
    ),
    'matching_node_message' => array(
      'variables' => array(
        'nid' => FALSE,
        'title' => FALSE,
      ),
      'file' => 'theme.inc',
    ),
  );
}

/**
 * Implements hook_form_BASE_FORM_ID_alter() for node_form().
 * 
 * @param $form
 * @param $form_state
 * @param $form_id
 */
function bs_uniquenode_form_node_form_alter(&$form, &$form_state, $form_id) {
  // Wenn es eine Nodeform ist.

  // Extra validation for Node form!
  // DE: Extra Validierung fÃ¼r Node form!
  $form['#validate'][] = '_bs_uniquenode_form_validate';

  if (isset($form_state['storage']) &&
          isset($form_state['storage']['bs_uniquenode'])) {

    $matching_content = $form_state['storage']['bs_uniquenode']['content'];

    $type = $form['type']['#value'];

    $form[SUBMIT_UNIQUE_CONTENT] = array(
      '#type' => 'container',
      '#attributes' => array(
        'class' => array(
          drupal_html_class(SUBMIT_UNIQUE_CONTENT),
        ),
      ),
      '#weight' => -500,
    ) + _bs_uniquenode_submit_form($matching_content, $type);

    // Show messages.
    $messages = $form_state['storage']['bs_uniquenode']['messages'];
    if (is_array($messages)) {
      foreach ($messages as $message) {
        drupal_set_message(filter_xss($message), 'warning');
      }
    }
  }
}

/**
 * Implements hook_preprocess_ds_forms_custom_form().
 * 
 * @param $entity_info
 */
if (module_exists('ds_forms')) {
  function bs_uniquenode_preprocess_ds_forms_custom_form(&$vars) {
    if (isset($vars['form']['#node_edit_form']) && $vars['form']['#node_edit_form']) {
      $region = 'left';
      if (isset($vars[$region])) {

        $field = &$vars['form'][SUBMIT_UNIQUE_CONTENT];
        $output_field = drupal_render($field);

        $output = &$vars[$region];

        $vars[$region] = $output_field . $output;
      }
    }
  }
}

/**
 * Implements hook_theme_registry_alter()
 * to ensure we run it after 'ds_form' module.
 */
function bs_uniquenode_theme_registry_alter(&$theme_registry) {
  $key = 'ds_forms_custom_form';
  if (isset($theme_registry[$key])) {
    $function = 'bs_uniquenode_preprocess_' . $key;
    $functions = &$theme_registry[$key]['preprocess functions'];
    
    // Remove hook in the current position
    if (($s_key = array_search($function, $functions)) !== false) {
      unset($functions[$s_key]);
    }

    // Add it to the end
    $functions[] = $function;
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for 'field_ui_field_edit_form' form.
 * 
 * @param $form
 * @param $form_state
 * @param $form_ida
 */
function bs_uniquenode_form_field_ui_field_edit_form_alter(&$form, &$form_state) {
  $form['uniquecontent'] = array(
    '#title' => t('Unique Content'),
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#tree' => FALSE,
  );

  // A field is going to be edited.
  $field_name = $form['#field']['field_name'];
  // Remove the 'field_' prefix from a full field name.
  $field_name = substr($field_name, 6, strlen($field_name) - 6);

  $field_type = $form['#field']['type'];

  // Compare options.
  $compare_options = array(
    0 => t('Dont use for uniquity check'),
    1 => t('Compare Method: Exact equality'),
  );

  if ($field_type == 'text') {
    // Phonem may be enabled only on field type = text.
    $compare_options[2] = t('Compare Method: phonemic');
  }

  $default_method = variable_get('bs_uniquenode_compare_method_' . $field_name, 0);

  $form['uniquecontent']['bs_uniquenode_compare_method_' . $field_name] = array(
    '#type' => 'radios',
    '#options' => $compare_options,
    '#default_value' => $default_method ? $default_method : 0,
    '#title' => t('Use field to check for unique content'),
  );

  $form['uniquecontent']['bs_uniquenode_node_type_intern_' . $field_name] = array(
    '#type' => 'checkbox',
    '#default_value' => variable_get('bs_uniquenode_node_type_intern_' . $field_name, TRUE),
    '#title' => t('Only same Nodetype?'),
    '#description' => t('if checked: field is only checked for uniquity in the same nodetype. not checked: field is checked for uniquity in all node types.'),
  );

  $form['#submit'][] = '_bs_uniquenode_manage_fields_submit';
}

/**
 * Implements hook_form_FORM_ID_alter() for 'node_type_form' form.
 * 
 * @param $form
 * @param $form_state
 * @param $form_id
 */
function bs_uniquenode_form_node_type_form_alter(&$form, &$form_state) {
  $form['uniquecontent'] = array(
    '#title' => t('Unique Content'),
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#tree' => FALSE,
    '#group' => 'additional_settings',
  );

  // The content type will be edit.
  $type = $form['#node_type']->type;
  // Check in userspace or global.
  $form['uniquecontent']['bs_uniquenode_respect_userspace_' . $type] = array(
    '#type' => 'checkbox',
    '#default_value' => variable_get('bs_uniquenode_respect_userspace_' . $type, FALSE),
    '#title' => t('Uniquity per user'),
    '#description' => t(
      'Limits the checking only to nodes of the user that is logged in. ' .
      'Other Users may created content with the same Title/Fields.'
     ),
  );

  // Must be unique or show warning and sumbmit if nodes are equal.
  $form['uniquecontent']['bs_uniquenode_must_be_unique_' . $type] = array(
    '#type' => 'checkbox',
    '#default_value' => variable_get('bs_uniquenode_must_be_unique_' . $type, TRUE),
    '#title' => t('Enable override ability'),
    '#description' => t(
      'If checked, the user will be questioned if he wants to insert a node despite it not being unique.'
    ),
  );

  // Check node on update?
  $form['uniquecontent']['bs_uniquenode_check_on_update_' . $type] = array(
    '#type' => 'checkbox',
    '#default_value' => variable_get('bs_uniquenode_check_on_update_' . $type, FALSE),
    '#title' => t('Check on update of node'),
    '#description' => t(
      'It is always checked on insert. If this is checked, on update of a node will be checked, too'
    ),
  );

  // Check node on feeds import?
  $form['uniquecontent']['bs_uniquenode_check_on_import_' . $type] = array(
    '#type' => 'checkbox',
    '#default_value' => variable_get('bs_uniquenode_check_on_import_' . $type, TRUE),
    '#title' => t('Check on import of node'),
    '#description' => t(
      'If this is checked, on feeds import of a node will be checked, too.'
    ),
  );
  // All fields must be unique or is node unique if a single field is unique?
  $form['uniquecontent']['bs_uniquenode_all_checked_fields_need_to_be_unique_' . $type] = array(
    '#type' => 'checkbox',
    '#default_value' => variable_get('bs_uniquenode_all_checked_fields_need_to_be_unique_' . $type, TRUE),
    '#title' => t('All fields must be unique'),
    '#description' => t(
      'If checked, the entity will be unique if at least one field is unique. ' .
      'If not checked, all fields must be unique to identify entity as unique.'
     ),
  );
  
  // Should an empty fields affect to the entities unicity?
  $form['uniquecontent']['bs_uniquenode_skip_empty' . $type] = array(
    '#type' => 'checkbox',
    '#default_value' => variable_get('bs_uniquenode_skip_empty' . $type, TRUE),
    '#title' => t('Skip empty field checking'),
    '#description' => t(
      'If checked, all empty fields will be ignored while unique cheking.' .
      'If not checked, empty fields will not affect to the entities unicity.'
     ),
  );
  
  // Should we use intersection between field matches?
  $form['uniquecontent']['bs_uniquenode_use_intersection_' . $type] = array(
    '#type' => 'checkbox',
    '#default_value' => variable_get('bs_uniquenode_use_intersection_' . $type, TRUE),
    '#title' => t('Use the intersection between field matches'),
    '#description' => t(
      'If checked, a node that matches the field query will be included in ' .
      'the overall result only if it will be presented in the results found ' .
      'for all searched fields. If not checked, union will be used.'
     ),
  );
  
  // Should we search the equality first before phonem search?
  $form['uniquecontent']['bs_uniquenode_search_equal_first_' . $type] = array(
    '#type' => 'checkbox',
    '#default_value' => variable_get('bs_uniquenode_search_equal_first_' . $type, TRUE),
    '#title' => t('Search the equality first before phonem search'),
    '#description' => t(
      'If checked, this will avoid matching nodes not beeing found because of' .
      ' phonem cache misses. If not checked, only phonem search will run.'
     ),
  );
  
  // Should we search with phonem only if equal result is empty?
  $form['uniquecontent']['bs_uniquenode_phonem_search_if_equal_result_empty_' . $type] = array(
    '#type' => 'checkbox',
    '#default_value' => variable_get('bs_uniquenode_phonem_search_if_equal_result_empty_' . $type, TRUE),
    '#title' => t('Search with phonem only if equal result is empty'),
    '#description' => t(
      'If checked, search with phonem will run only if equal result is empty. ' .
      'If not checked, search with phonem will be runned in any way.'
     ),
  );

  // Title compare with phonem or equality or not.
  $default_title_check = variable_get('bs_uniquenode_title_check_' . $type, 0);
  $form['uniquecontent']['bs_uniquenode_title_check_' . $type] =  array(
    '#type' => 'radios',
    '#options' => array(
      0 => t('Dont use for uniquity check'),
      1 => t('Compare Method: exact equality'),
      2 => t('Compare Method: phonemic'),
    ),
    '#default_value' => $default_title_check ? $default_title_check : 0,
    '#title' => t('Use title to check for uniquity'),
  );

  $form['uniquecontent']['bs_uniquenode_custom_message_on_equal_' . $type] = array(
    '#type' => 'textfield',
    '#default_value' => variable_get('bs_uniquenode_custom_message_on_equal_' . $type, ''),
    '#title' => t('Equality Message'),
    '#description' => t(
      'This message is shown if the node seems to be a doublette.'
    ),
  );

  $form['uniquecontent']['checkedfields'] = array(
    '#type' => 'fieldset',
    '#title' => t('Checked Fields'),
    '#collapsed' => TRUE,
    '#collapsible' => TRUE,
  );

  // Display every field here and link to it.
  $form['uniquecontent']['checkedfields']['fields'] = array(
    '#type' => 'item',
    '#markup' => _bs_uniquenode_get_fields_checked_for_display_on_node_edit_form($type),
  );

  $form['#submit'][] = '_bs_uniquenode_manage_fields_submit';
}

/**
 * Implements hook_form_FORM_ID_alter() for 'field_ui_field_delete_form' form.
 * 
 * @param $form
 * @param $form_state
 * @param $form_id
 */
function bs_uniquenode_form_field_ui_field_delete_form_alter(&$form, &$form_state) {
  // If a field is going to be deleted, add an own submithandler 
  // to the delete submit form.
  $form['#submit'][] = '_bs_uniquenode_content_field_remove_submit';
}

/**
 * Submithandler if a content field is deleted, here we clean the phonemcache
 * for this field for all nodes of the given content-type.
 * 
 * @param $form
 * @param $form_state
 */
function _bs_uniquenode_content_field_remove_submit($form, $form_state) {
  $values     = $form_state['values'];

  $field_name = $values['field_name'];
  $type       = $values['bundle'];

  _bs_uniquenode_delete_phonem_of_field($field_name, $type);
}

/**
 * Shows alle Fields that are checked on that node type with link
 * to edit directly.
 * 
 * @param $type
 *   The content type.
 *   
 * @return string
 *   The HTML formatted themed string.
 */
function _bs_uniquenode_get_fields_checked_for_display_on_node_edit_form($type) {
  $field_html = theme('uniquity_check_field_explanation', array('message' =>
      t('These fields are used for uniquity computation (Method in brackets).' .
              ' Click to edit the field:')
  ));

  $fields_to_check = _bs_uniquenode_get_fields_to_check($type);
  foreach ($fields_to_check as $field_name => $field) {
    if ($field['check_method'] == 1) {
      $check_type = 'exact Equality';
    }
    elseif ($field['check_method'] == 2) {
      $check_type = 'Phonem';
    }
    else {
      $check_type = 'Unknown';
    }

    // Link to edit field in UI.
    $field_link = '/admin/structure/types/manage/' . $type . '/fields/field_' .
                      $field_name . '?destination=' . $_GET['q'];

    $field_html .= theme('uniquity_check_field',
                        array(
                          'fieldlink' => $field_link,
                          'fieldname' => $field_name,
                          'checktype' => $check_type,
                        )
                   );
  }

  return $field_html;
}

/**
 * This is the form, a user has to submit if content may be unique but musst not
 * be unique.
 * 
 * @param $matching_content
 *   Format: $matching_content[$field][$nid] = $title;
 * @param $type
 *   Machine name of node type.
 * 
 * @return array
 *   The Drupal FAPI form.
 */
function _bs_uniquenode_submit_form($matching_content, $type) {
  $form = array();

  $error = _bs_uniquenode_get_matching_node_message($matching_content);

  $form['nodes'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#title' => t('Equal nodes'),
  );

  // Default message or nodetype specific message.
  $message = variable_get('bs_uniquenode_custom_message_on_equal_' . $type,
          t('The following content is equal to the node you want to create.'));

  $form['nodes']['nodelinks'] = array(
    '#type' => 'item',
    '#markup' => "<div class='messages error'>" . $message . '</div><br/>' . $error,
  );

  $form['nodes']['proceed_on_nonunique'] = array(
    '#type' => 'checkbox',
    '#title' => t('Proceed anyway?'),
  );

  return $form;
}

/**
 * Here, each node is validated for uniquity.
 * 
 * @param $form
 * @param $form_state
 */
function _bs_uniquenode_form_validate($form, &$form_state) {
  $type    = $form['type']['#value'];  
  $values  = $form_state['values'];
  
  $nid = isset($values['nid']) ? $values['nid'] : null;

  // Don't validate if delete button has been submitted.
  if (isset($form['actions']['delete']) && $form_state['triggering_element']['#id'] == $form['actions']['delete']['#id']) {
    return;
  }

  $check_on_update = variable_get('bs_uniquenode_check_on_update_' . $type, FALSE);
  if (! (empty($nid) || $check_on_update)) {
    // We dont validate existing nodes yet!
    return;
  }

  // All Fields of this node have to be checked!
  $fields_to_check = _bs_uniquenode_get_fields_to_check($type);

  _bs_uniquenode_add_field_values($fields_to_check, $values, $type);

  $matching_content = _bs_uniquenode_check_fields($fields_to_check, $type, $values['uid'], $nid);

  $ask_user_about_non_unique = variable_get('bs_uniquenode_must_be_unique_' . $type, TRUE);

  if ($matching_content && count($matching_content) > 0) {
    // Here we have found nodes matching the actual node that is going to be saved.

    // If nodetype must be always unique, display an error, no opportunity to save the node anyway.
    if (!$ask_user_about_non_unique) {
      $error = _bs_uniquenode_get_matching_node_message($matching_content);
      if ($error) {
        $message = variable_get('bs_uniquenode_custom_message_on_equal_' . $type,
                t('Sorry, this node must be unique. The following nodes are equal:'));

        form_set_error('ALL_FIELDS_OF_NODE', $message);
        drupal_set_message(filter_xss($error), 'error');

        return;
      }
    }

    // Is submit box visible.
    if (isset($form[SUBMIT_UNIQUE_CONTENT]['nodes']['proceed_on_nonunique']) &&
            $values['proceed_on_nonunique']) {
      // Checkbox was clicked an user would like to save the node anyway.
      return;
    }
    // Checkbox is visible but has not been checked on submit.
    $messages[] = t('Please check checkbox to save this non unique node');

    /**
     * There is duplicate content but the checkbox is not
Â Â Â Â  * clicked OR OR OR the checkbox is not there yet.
     * DE: Hier gibt es doppelten Content, aber die Checkbox wurde nicht
     * geklickt ODER ODER ODER die checkbox ist noch gar nicht da.
     */
    $form_state['rebuild'] = TRUE;

    // Save to use in rebuilded form.
    $form_state['storage']['bs_uniquenode']['content']  = $matching_content;
    $form_state['storage']['bs_uniquenode']['messages'] = $messages;

    return;
  }
}

/**
 * Here, each node is validated for uniquity while feeds importing.
 * 
 * @param $source
 * @param $entity
 * @param $item
 * @param $entity_id
 */
/**
 * Implements hook_feeds_presave().
 */
function bs_uniquenode_feeds_presave($source, $entity, $item, $entity_id) {
  if (get_class($source->importer->processor) != 'FeedsNodeProcessor') {
    return;
  }

  $type    = $entity->type;
  $values  = (array) $entity;

  $check_on_import = variable_get('bs_uniquenode_check_on_import_' . $type, TRUE);
  if (!$check_on_import) {
    return;
  }

  $check_on_update = variable_get('bs_uniquenode_check_on_update_' . $type, FALSE);
  if (! (empty($entity_id) || $check_on_update)) {
    // We dont validate existing nodes yet!
    return;
  }

  // All Fields of this node have to be checked!
  $fields_to_check = _bs_uniquenode_get_fields_to_check($type);

  _bs_uniquenode_add_field_values($fields_to_check, $values, $type);

  $matching_content = _bs_uniquenode_check_fields($fields_to_check, $type, $values['uid'], $entity_id);

  if ($matching_content && count($matching_content) > 0) {
    // Here we have found nodes matching tha actual node that is going to be saved.

    // If nodetype must be always unique, display an error, no opportunity to save the node anyway.
    $error = _bs_uniquenode_get_matching_node_message($matching_content);
    if ($error) {
      $entity->feeds_item->skip = TRUE;
      
      $message = variable_get('bs_uniquenode_custom_message_on_equal_' . $type,
              t('Sorry, this node must be unique. The following nodes are equal:'));
      $error = $message . ' ' . $error;

      drupal_set_message(filter_xss($error), 'error');
    }
  }
}
/**
 * Create a Message of all matching nodes.
 * 
 * @param $matching_content
 *   Format: $matching_content[$field][$nid] = $title;
 * 
 * @return Ambigous <boolean, string>
 *   An error string. FALSE otherwise.
 */
function _bs_uniquenode_get_matching_node_message($matching_content) {
  $matchin_content_by_nid = _bs_uniquenode_convert_matches_by_nid($matching_content);
  $error = FALSE;

  foreach ($matchin_content_by_nid as $nid => $values) {
    if ($error) {
      $error .= '<br/>';
    }

    $line = FALSE;
    foreach ($values as $value) {
      if ($line) {
        $line .= ', ';
      }

      $line .= $value;
    }

    $text = $line . ' (' . $nid . ')';
    $html = theme('matching_node_message', array('nid' => $nid, 'value' => $text));

    $error .= $html;
  }

  return $error;
}

/**
* Returns the title by nid
*/
function _bs_unique_node_title_by_nid($nid) {
  $result = db_query('SELECT title FROM {node} WHERE nid=:nid', array(':nid' => $nid))->fetchField();
  
  return $result;
}

/**
 * Convert matching content to make links from.
 * 
 * @param $matching_content
 *   Format: $matching_content[$field][$nid] = $title;
 * 
 * @return array
 *   Format: $ret[$nid] = $title
 */
function _bs_uniquenode_convert_matches_by_nid($matching_content) {
  $ret = array();

  foreach ($matching_content as $field => $matches) {
    foreach ($matches['matches'] as $nid => $value) {
      $field_type = $matches['field_type'];
      if ($field_type == 'entityreference') {
        //it makes no sence to show the referenced ID, so we need to get the title
        $value = _bs_unique_node_title_by_nid($value);
      }
      $ret[$nid][] = $value;
    }
  }

  return $ret;
}

/**
 * Returns elements for submit none unique node anyway.
 * 
 * @return array
 *   The Drupal FAPI form. 
 */
function _bs_uniquenode_submit_form_elements() {
  $form = array();

  // Add form element!
  $form['content_not_unique'] = array(
    '#type' => 'fieldset',
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
    '#title' => t('Similar nodes'),
  );

  $form['content_not_unique']['list'] = array(
    '#type' => 'value',
    '#value' => 'NODE FOUND',
  );

  $form['content_not_unique']['skipp_unique_check'] = array(
    '#type' => 'checkbox',
    '#title' => t('Skip check and insert node anyway'),
    '#default_value' => FALSE,
  );

  return $form;
}

/**
 * Submithandler if node edit form or field edit form is submitted.
 * 
 * @param $form
 * @param $form_state
 */
function _bs_uniquenode_manage_fields_submit($form, $form_state) {
  $values = $form_state['values'];
  $form_id = $values['form_id'];
  $variables = array();

  if ($form_id == 'field_ui_field_edit_form') {
    // A single field has been saved.
    $field_name = $form['#field']['field_name'];
    $field_name = substr($field_name, 6, strlen($field_name) - 6);
    $field_type = $form['#field']['type'];

    variable_set('bs_uniquenode_compare_method_'   . $field_name, $values['bs_uniquenode_compare_method_'   . $field_name]);
    variable_set('bs_uniquenode_node_type_intern_' . $field_name, $values['bs_uniquenode_node_type_intern_' . $field_name]);
    
    $variables += array(
      'bs_uniquenode_compare_method_'   . $field_name,
      'bs_uniquenode_node_type_intern_' . $field_name,
    );
  }

  if ($form_id == 'node_type_form') {
    // A node type has been saved.
    $type = $form['#node_type']->type;
    variable_set('bs_uniquenode_respect_userspace_'       . $type, $values['bs_uniquenode_respect_userspace_'       . $type]);
    variable_set('bs_uniquenode_must_be_unique_'          . $type, $values['bs_uniquenode_must_be_unique_'          . $type]);
    variable_set('bs_uniquenode_all_checked_fields_need_to_be_unique_' . $type,
            $values['bs_uniquenode_all_checked_fields_need_to_be_unique_' . $type]);

    variable_set('bs_uniquenode_skip_empty'               . $type, $values['bs_uniquenode_skip_empty'               . $type]);
    variable_set('bs_uniquenode_use_intersection_'        . $type, $values['bs_uniquenode_use_intersection_'        . $type]);
    variable_set('bs_uniquenode_search_equal_first_'      . $type, $values['bs_uniquenode_search_equal_first_'      . $type]);
    variable_set('bs_uniquenode_phonem_search_if_equal_result_empty_' . $type,
            $values['bs_uniquenode_phonem_search_if_equal_result_empty_' . $type]);

    variable_set('bs_uniquenode_title_check_'             . $type, $values['bs_uniquenode_title_check_'             . $type]);
    variable_set('bs_uniquenode_check_on_update_'         . $type, $values['bs_uniquenode_check_on_update_'         . $type]);
    variable_set('bs_uniquenode_check_on_import_'         . $type, $values['bs_uniquenode_check_on_import_'         . $type]);
    variable_set('bs_uniquenode_custom_message_on_equal_' . $type, $values['bs_uniquenode_custom_message_on_equal_' . $type]);

    // Save a valiable names to uninstall procedure.
    $variables += array(
      'bs_uniquenode_respect_userspace_'                    . $type,
      'bs_uniquenode_must_be_unique_'                       . $type,
      'bs_uniquenode_all_checked_fields_need_to_be_unique_' . $type,
      'bs_uniquenode_skip_empty'                            . $type,
      'bs_uniquenode_use_intersection_'                     . $type,
      'bs_uniquenode_search_equal_first_'                   . $type,
      'bs_uniquenode_phonem_search_if_equal_result_empty_'  . $type,
      'bs_uniquenode_title_check_'                          . $type,
      'bs_uniquenode_check_on_update_'                      . $type,
      'bs_uniquenode_check_on_import_'                      . $type,
      'bs_uniquenode_custom_message_on_equal_'              . $type,
    );
  }
  // Add only unique variables
  $variables += array_diff($variables,
          variable_get('bs_uniquenode_variables', array()));

  variable_set('bs_uniquenode_variables', $variables);
}

/**
 * Add form values to fields.
 * 
 * @param $fields
 *   The fields and its params array. 
 * @param $values
 *   The form_state values data.
 * @param unknown_type $type
 *   The machine name of node type. 
  */
function _bs_uniquenode_add_field_values(&$fields, $values, $type) {
  if (!is_array($fields)) {
    return;
  }

  foreach ($fields as $name => $field) {
    $field_name = 'field_' . $name;
    
    if (isset($values[$field_name])) {
      $field_value = $values[$field_name];
      $fields[$name]['formvalue'] = $field_value;
    }
  }

  // Titel dazu?
  $check_title_method = variable_get('bs_uniquenode_title_check_' . $type, 0);
  if ($check_title_method) {
    $fields['title'] = array(
      'formvalue' => $values['title'],
      'check_method' => $check_title_method,
      'field_name' => 'title',
    );
  }
}

/**
 * Checks these Fields for unique content!
 * 
 * @param $fields_to_check
 *   The fields and its params array. 
 * @param unknown_type $node_type
 *   The machine name of node type. 
 * @param $uid
 *   The user identifier.
 * @param $updated_nid
 *   Node NID of straight updated node that should not be considered!   
 * 
 * @return Ambigous <boolean, array>
 *   The array with
 *     key == fieldname and
 *     value == array of matching nodeIDs and field values
 *   FALSE otherwise.
 */
function _bs_uniquenode_check_fields($fields_to_check, $node_type, $uid, $updated_nid) {

  $only_not_unique_if_all_match = variable_get('bs_uniquenode_all_checked_fields_need_to_be_unique_' . $node_type, TRUE);
  $matched = array();

  if (!is_array($fields_to_check)) {
    return FALSE;
  }

  $check_title_method = variable_get('bs_uniquenode_title_check_' . $node_type, 0);

  $field_types = array();
  
  $c = 0;
  $intersection = FALSE;
 
  // Skip all checks on empty fields.
  $skip_empty = variable_get('bs_uniquenode_skip_empty' . $node_type, 1);
  if ($skip_empty) {
    foreach ($fields_to_check as $name => $field) {
      if (!isset($field['formvalue'])) {
        unset($fields_to_check[$name]);
      }
      // The 'title' field is required, but if for any reason it is blank skip it too.
      else if ($name === 'title') {
        if ($field['formvalue'] === '') {
          unset($fields_to_check[$name]);
        }
      }
      else {
        foreach ($field['formvalue'] as $lang => $form_values) {
          
          if (!count($form_values))
            unset($fields_to_check[$name]);
            
          $field_colum = _bs_uniquenode_get_field_column($field['field_name']); 
          $field_info = field_info_field($field['field_name']);
          $field_types[$field['field_name']] = $field_info['type'];
          
          foreach ($form_values as $delta => $value) {            
            if ((isset($value[$field_colum]) && $value[$field_colum] === '') || !isset($value[$field_colum])) {           
              unset($fields_to_check[$name]);
            }
          }
        }
      }
    }
  }

  $use_intersection = variable_get('bs_uniquenode_use_intersection_' . $node_type, 1);
  foreach ($fields_to_check as $name => $field) {
    $field_name = $field['field_name'];

    // Check other fields than title!
    $matching_content = _bs_uniquenode_check_field($field, $node_type, $uid, $updated_nid);

    if ($only_not_unique_if_all_match) {

      if (!$matching_content) {
        return FALSE;
      }

      if ($use_intersection) {
        // Der Node ist nur dann gleich, wenn ALLE FELDER matchen. hier wurde nicht gemachted, daher ist der Node ok!
        // Wenn die Lastmatches nicht gleich den aktuell sind, ist hier nicht weiter zu prÃ¼fen.
        $keys = array_keys($matching_content);

        if ($intersection) {
          $last_keys = $intersection;

          $intersection = array_intersect($keys, $last_keys);

          if (count($intersection) <= 0) {
            return FALSE;
          }
        } else {
          $intersection = $keys;
        }
      }
    }

    $matched[$field_name] = $matching_content;
    $c++;
  }

  if ($use_intersection && is_array($matched)) {
    foreach ($matched as $field_name => $matching_content) {

      if ($intersection) {
        // Delete all nodes in matching content that are not in intersection!
        foreach ($matching_content as $nid => $value) {
          if (!in_array($nid, $intersection)) {
            unset($matched[$field_name][$nid]);
          }
        }
      }
    }
  }

  //add the field types
  $result = array();
  foreach ($matched as $field_name => $matches) {
    $result[$field_name] = array('field_type' => $field_types[$field_name], 'matches' => $matches);
  }
  
  // Das ist entweder FALSE oder ein array mit key=field_name und Value = array
  // aller mathenden Werte mit key=nid und Wert = der Wert des Feldes des Notes
  return count($result) ? $result : false;
}

/**
* Returns the column of the field where the value is stored (such as "value" or "target_id")
* @param $field_name
*/
function _bs_uniquenode_get_field_column($field_name) {
  $field_info = field_info_field($field_name);
  $columns = $field_info['columns'];
  $column_keys = array_keys($columns);
 
  //@TODO how to work with multicolumn fields, currently we only return the first column
  return reset($column_keys);
}

/**
 * Checks one field for unique content.
 * 
 * @param $field
 *   Field params.
 * @param $node_type
 *   The machine name of node type. 
 * @param $uid
 *   The user identifier.
 * @param $updated_nid
 *   Node NID of straight updated node that should not be considered!
 * 
 * @return Ambigous <boolean, array>
 *   Format: $ret[$match['nid']] = $match['value'];
 *   FALSE otherwise.
 */
function _bs_uniquenode_check_field($field, $node_type, $uid, $updated_nid) {
  $result = FALSE;

  $field_name = $field['field_name'];
  $pure_field_name = substr($field_name, 6, strlen($field_name) - 6);

  $respect_userspace = variable_get('bs_uniquenode_respect_userspace_' . $node_type, FALSE);

  $respect_nodetype = variable_get('bs_uniquenode_node_type_intern_' . $pure_field_name, TRUE);

  $tmp_nodetype = $node_type;
  if (!$respect_nodetype) {
    $tmp_nodetype = FALSE;
  }

  $tmp_uid = FALSE;
  if ($respect_userspace) {
    $tmp_uid = $uid;
  }

  $check_method = $field['check_method'];

  $search_equal_first = variable_get('bs_uniquenode_search_equal_first_' . $node_type, TRUE);
  $phonem_search_if_equal_result_empty = variable_get('bs_uniquenode_phonem_search_if_equal_result_empty_' . $node_type, TRUE);

  if ($check_method == 1) {
    // Compare with equality.
    $result = _bs_uniquenode_check_field_equal($field, $tmp_nodetype, $tmp_uid);
  }
  elseif ($check_method == 2) {
    // OK; first check equality, this will avoid matching nodes not beeing found because of phonem cache misses.
    if($search_equal_first) {
      $result = _bs_uniquenode_check_field_equal($field, $tmp_nodetype, $tmp_uid);
    }

    if (! ($result && $phonem_search_if_equal_result_empty)) {
      // Check with Phonem.
      $result = _bs_uniquenode_check_field_phonem($field, $tmp_nodetype, $tmp_uid);
    }
  }

  // Der gerade geupdatede Node darf nicht berÃ¼cksichtigt werden!
  if ($updated_nid) {
    if (isset($result[$updated_nid])) {
      unset($result[$updated_nid]);
    }
  }

  return $result;
}

/**
 * Checks content of a field for equality
 * 
 * When nodetype is set, compare the contents of the field only in nodes
 * of these types... If the uid is set, only nodes are used for comparison,
 * which includes this uid.
 * 
 * DE: Wenn nodetype gesetzt wir der inhalt des Feldes nur in nodes diesen
 * types verglichen... Wenn uid gesetzt, werden nur nodes zum vergleich
 * herangezogen, die dieser uid gehÃ¶ren.
 *
 * @param $field
 *   Field params.
 * @param $node_type
 *   The machine name of node type. 
 * @param $uid
 *   The user identifier.
 *   
 * @return Ambigous <boolean, array>
 *   Format: $ret[$match['nid']] = $match['value'];
 *   FALSE otherwise.
 */
function _bs_uniquenode_check_field_equal($field, $node_type = FALSE, $uid = FALSE) {

  $ret = FALSE;
  $field_name = $field['field_name'];
  if ($field_name == 'title') {
    // Check Title
    // DE: Title prÃ¼fen
    $sql = 'SELECT nid AS id, title AS value FROM {node} n';
  }
  else {
    // Check another field.
    // DE: Ein anderes feld prÃ¼fen.
    $table = 'field_data_' . $field_name;
    
    // TODO: May be  multiple columns???
    $field_colum = _bs_uniquenode_get_field_column($field['field_name']); 
    $column = $field_name . '_'.$field_colum; //@TODO: better use field info field to get the storrage information!

    $sql = 'SELECT c.entity_id AS id, c.' . $column . ' AS value FROM {' . $table . '} c LEFT JOIN {node} n ON c.entity_id=n.nid';
  }

  $where = FALSE;
  $values = array();
  if ($uid) {
    if ($where) {
      $where .= " AND";
    }
    $where .= " n.uid=:uid";
    $values[':uid'] = $uid;
  }

  if ($node_type) {
    if ($where) {
      $where .= " AND";
    }
    $where .= " n.type=:node_type";
    $values[':node_type'] = $node_type;
  }

  if ($field_name != 'title') {
    // Now add the value to the where.
    $form_values_lang = $field['formvalue'];
    $value_where = '';
    foreach ($form_values_lang as $lang => $form_values) {
      foreach ($form_values as $delta => $value) {
        if (!is_array($value)) {
          // Skip checking this delta of field value
          continue;
        }

        if ($value_where) {
          $value_where .= " OR";
        }
        // Integer or Text?
        if ($field['widget']['type'] == 'text_textfield') {
          $value_where .= " " . $column . "=:value";
        }
        else {
          $value_where .= " " . $column . "=:value";
        }

        $field_colum = _bs_uniquenode_get_field_column($field['field_name']); 
        $values[':value'] = $value[$field_colum];
      }
    }

    if ($value_where) {
      if ($where) {
        $where .= " AND";
      }
      $where .= " (" . $value_where . ")";
    }
  }
  else {
    // Validate the title for equality.
    if ($where) {
      $where .= " AND";
    }
    $where .= " n.title=:title";

    $values[':title'] = $field['formvalue'];
  }

  if ($where) {
    $sql .= ' WHERE ' . $where;
  }

  // TODO: Please convert this statement to the D7 database API syntax.
  $res = db_query($sql, $values);
 
  foreach ($res as $match) {
    $ret[$match->id] = $match->value;
  }

  return $ret;
}

/**
 * Checks content of a field for equality USING PHONEM
 * 
 * When nodetype is set, compare the contents of the field only in nodes
 * of these types... If the uid is set, only nodes are used for comparison,
 * which includes this uid.
 * 
 * DE: Wenn nodetype gesetzt wir der inhalt des Feldes nur in nodes diesen
 * types verglichen... Wenn uid gesetzt, werden nur nodes zum vergleich
 * herangezogen, die dieser uid gehÃ¶ren.
 * 
 * @param $field
 *   Field params.
 * @param $node_type
 *   The machine name of node type. 
 * @param $uid
 *   The user identifier.
 *   
 * @return Ambigous <boolean, array>
 *   Format: $ret[$match['nid']] = $match['value'];
 *   FALSE otherwise.
 */
function _bs_uniquenode_check_field_phonem($field, $node_type = FALSE, $uid = FALSE) {

  $ret = FALSE;
  $sql = 'SELECT p.nid AS id, field_value AS value FROM {bs_uniquenode_phonem} p LEFT JOIN {node} n ON n.nid=p.nid';

  $where = FALSE;
  $values = array();
  if ($uid) {
    if ($where) {
      $where .= " AND";
    }
    $where .= " n.uid=:uid";
    $values[':uid'] = $uid;
  }

  if ($node_type) {
    if ($where) {
      $where .= " AND";
    }
    $where .= " n.type=:node_type";
    $values[':node_type'] = $node_type;
  }

  $field_name = $field['field_name'];
  if ($field_name != 'title') {
    // Now add the value to the where.
    $form_values_lang = $field['formvalue'];
    $value_where = '';
    foreach ($form_values_lang as $lang => $form_values) {
      foreach ($form_values as $delta => $value) {

        // DELTA doesnt matter in sql cause if field matches
        // it doesnt matter on which delta...
        // it matches on that field, thats enough!
        if ($value_where) {
          $value_where .= " OR";
        }

        // Integer or Text?
        if ($field['widget']['type'] == 'text_textfield') {
          $value_where .= " phonem=:phonem";
        }
        else {
          $value_where .= " field_value=:phonem";
        }

        $values[':phonem'] = _bs_uniquenode_Phonem($value['value']);
      }
    }

    if ($value_where) {
      if ($where) {
        $where .= " AND";
      }
      $where .= " (" . $value_where . ")";
    }
  }
  else {
    // Validate the title for equality.
    // FIXME: Equal or Phonem?
    if ($where) {
      $where .= " AND";
    }
    $where .= " p.field_name='title' AND p.phonem=:phonem";

    $values[':phonem'] = _bs_uniquenode_Phonem($field['formvalue']);
  }

  if ($where) {
    $sql .= ' WHERE ' . $where;
  }

  // TODO Please convert this statement to the D7 database API syntax.
  $res = db_query($sql, $values);

  foreach ($res as $match) {
    $ret[$match->id] = $match->value;
  }

  return $ret;
}

/**
 * Returns all fields of the type.
 * 
 * @param $content_type_name
 *   The machine name of node type. 
 * @param $method
 *   Comparifon method (taken from 'bs_uniquenode_form_alter()')
 *     0 - 'Dont use for uniquity check'
 *     1 - 'Compare Method: Exact equality'
 *     2 - 'Compare Method: phonemic'
 * 
 * @return array
 *   Format: $typed_fields[$field_name] = $field; 
 */
function _bs_uniquenode_get_fields_to_check($content_type_name, $method = FALSE) {
  $typed_fields = array();
  if (!$content_type_name) {
    return $typed_fields;
  }

  $bundles = field_info_instances('node');

  foreach ($bundles as $bundle_name => $fields) {
    foreach ($fields as $field_name => $field) {
      $field_name = substr($field_name, 6, strlen($field_name) - 6);
      $check_intern_only = variable_get('bs_uniquenode_node_type_intern_' . $field_name, TRUE);
      $check_method = variable_get('bs_uniquenode_compare_method_' . $field_name, 0);
  
      if (($bundle_name == $content_type_name || !$check_intern_only) &&
             ($check_method && (!$method || $method == $check_method))) {
        // Should be checked according to the settings field?
        // If it is to be equivalent to the current content type or
        // content type across checked
        // DE: Soll das feld laut einstellungen gecheckt werden?
        // Wenn es dem aktuellen content_type entspricht oder
        // content type Ã¼bergreifend gecheckt werden soll.
        $field['check_method'] = $check_method;
        $typed_fields[$field_name] = $field;
      }
  
    }
  }

  return $typed_fields;
}

/**
 * Get node info of node table (I dont want to execute node_load for each
 * matching node).
 * 
 * @param $nid
 *   Node ID.
 * @return Ambigous <boolean, array>
 *   A single field from the single record, or FALSE if there is no next record.
 */
function _bs_uniquenode_get_node_title($nid) {
  return db_select('node', 'n')
    ->fields('n', array('title'))
    ->condition('n.nid', $nid)
    ->execute()
    ->fetchField();
}

/**
 * #####################
 * PHONEM IMPLEMENTATION
 * #####################
 */

/**
 * Implements hook_node_delete().
 * 
 * @param $node
 */
function bs_uniquenode_node_delete($node) {
  if (TRUE) {
    _bs_uniquenode_delete_phonem_of_node($node->nid);
  }
}

/**
 * Implements hook_node_update().
 * 
 * @param $node
 */
function bs_uniquenode_node_update($node) {
  if (TRUE || TRUE) {
    _bs_uniquenode_insert_all_fields_phonem($node);

  }
}

/**
 * Implements hook_node_insert().
 * 
 * @param unknown_type $node
 */
function bs_uniquenode_node_insert($node) {
  if (TRUE || TRUE) {
    _bs_uniquenode_insert_all_fields_phonem($node);

  }
}

/**
 * Delete all phonem tags of this node.
 * 
 * @param unknown_type $nid
 */
function _bs_uniquenode_delete_phonem_of_node($nid) {
  db_delete('bs_uniquenode_phonem')
  ->condition('nid', $nid)
  ->execute();
}

/**
 * Deletes all phonem values in cache with the field name and the node type.
 * 
 * @param $field_name
 * @param $node_type
 */
function _bs_uniquenode_delete_phonem_of_field($field_name, $node_type) {
  if (!$field_name || !$node_type) {
    return;
  }

  $query = db_select('bs_uniquenode_phonem', 'p')
    ->fields('p', array('pid'));
  $query
    ->leftJoin('node', 'n', 'p.nid = n.nid');
  $query
    ->condition('p.field_name', $field_name)
    ->condition('n.type', $node_type);
  
  $pids = $query
    ->execute()
    ->fetchCol();

  if (count($pids)) {
    db_delete('bs_uniquenode_phonem', 'p')
      ->condition('p.pid', $pids, 'IN')
      ->execute();
  }
}

/**
 * First delete and then insert all phonem tags for this node!
 * 
 * @param $node
 */
function _bs_uniquenode_insert_all_fields_phonem($node) {
  $type = node_type_get_type($node);
  $type = $type->type;

  // Delete.
  _bs_uniquenode_delete_phonem_of_node($node->nid);

  /*
   * Now get all fields that should be comparable by phonem
   * and update database, TITLE, TOO.
   */

  // Only fields that are to be tested with phoneme.
  // DE: Nur felder die mit Phonem geprÃ¼ft werden sollen.
  $fields_to_check = _bs_uniquenode_get_fields_to_check($type, 2);

  // Title to this?
  // DE: Titel dazu?
  $check_title_method = variable_get('bs_uniquenode_title_check_' . $type, 0);
  if ($check_title_method == 2) {
    $fields_to_check['title'] = array(
      'check_method' => $check_title_method,
      'field_name' => 'title',
    );
  }

  foreach ($fields_to_check as $name => $field) {
    $field_name = $field['field_name'];
    if ($field_name) {
      if (isset($node->$field_name) && ($node_field = $node->$field_name)) {
        if (is_array($node_field)) {
          foreach($node->$field_name as $lang => $node_field) {

            // FOREACH DELTA SAVE !!
            foreach ($node_field as $delta => $delta_field) {
              $value = $delta_field['value'];
              $phonem_value = _bs_uniquenode_Phonem($value);
              _bs_uniquenode_save_field_phonem($field_name, $delta, $phonem_value, $value, $node->nid);
            }
          }
        }
        else {
          // NO DELTAS!
          $value = $node_field;

          // Now save as Phonem.
          $phonem_value = _bs_uniquenode_Phonem($value);
          _bs_uniquenode_save_field_phonem($field_name, 0, $phonem_value, $value, $node->nid);
        }
      }
    }
  }

}

/**
 * Save one phonemtag to a field.
 * 
 * @param $field_name
 * @param $delta
 * @param $phonem_value
 * @param $field_value
 * @param $nid
 */
function _bs_uniquenode_save_field_phonem($field_name, $delta, $phonem_value, $field_value, $nid) {
  $id = db_insert('bs_uniquenode_phonem')
  ->fields(array(
      'field_name' => $field_name,
      'phonem' => $phonem_value,
      'updated' => REQUEST_TIME,
      'nid' => $nid,
      'delta' => $delta,
      'field_value' => $field_value,
  ))
  ->execute();
}

/**
 * Prepare string from the phoneme string.
 * DE: Erstellt zu einem String den Phonem String.
 * 
 * @param $string
 *   Original string.
 * 
 * @return string
 *   Resulted string.
 */
function _bs_uniquenode_Phonem($string) {

  $doublechars = array(
    "SC" => "C",
    "SZ" => "C",
    "CZ" => "C",
    "DT" => "D",
    "TZ" => "C",
    "SZ" => "C",
    "TS" => "C",
    "KS" => "X",
    "PF" => "V",
    "QU" => "KW",
    "PH" => "V",
    "UE" => "Y",
    "AE" => "E",
    "OE" => "ï¿½",
    "EI" => "AY",
    "EY" => "AY",
    "EU" => "OY",
    "AU" => "Aï¿½",
    "OU" => "ï¿½ ",
    "AR" => "R",
  );

  $string = strtoupper(utf8_decode($string));
  for ($i = 0; $i < strlen($string) -1; $i++) {
    $pc = substr($string, $i, 2);
    if (!isset($doublechars[$pc])) {
      continue;
    }
    $string = substr($string, 0, $i) . $doublechars[$pc] . substr($string, $i +  2);
  }

  $string = str_replace(str_split(("ZKGQï¿½ï¿½IJflFWPTï¿½ï¿½ï¿½ï¿½ï¿½ï¿½uï¿½oiï¿½")), str_split(("CCCCEYYYYVVVBDAAEEUUOOYY")), $string);
  $string = preg_replace(("/[^ABCDLMNORSUVWXYï¿½]/"), "", $string);
  $string = preg_replace('{(.)\1+}', '$1', $string);
  return utf8_encode( $string );
}

/**
 * Update fields of all nodes
 */
function _bs_uniquenode_update_phonem() {
  // Get all content types.
  $types = array_keys(node_type_get_names());
  foreach ($types as $type) {
    // Get all fields tho check with phonem.
    $fields_to_check = _bs_uniquenode_get_fields_to_check($type, 2);

    // Title to this?
    // DE: Titel dazu?
    $check_title_method = variable_get('bs_uniquenode_title_check_' . $type, 0);
    if ($check_title_method == 2) {
      $fields_to_check['title'] = array(
        'check_method' => $check_title_method,
        'field_name' => 'title',
      );
    }
    // Now go through all fields and check update.
    foreach ($fields_to_check as $name => $field) {
      $field_name = $field['field_name'];
      $query = db_select('node', 'n')
        ->fields('n', array('nid'));

      if ($field_name == 'title') {
        // The title is right in the Nodetable! So NO JOIN is needed!
        // DE: Der Titel ist direkt in der Nodetabelle! also KEIN JOIN nÃ¶tig!

        $query
          ->addField('n', 'title', 'value');
        $query
          ->leftJoin('bs_uniquenode_phonem', 'p', 'n.nid = p.nid');
        $query
          ->condition(db_or()
              ->isNull('p.pid')
              ->condition(db_and()
                  ->condition('p.field_value', 'n.title', '<>')
                  ->condition('p.field_name', 'title', '=')
                  ->condition('n.type', $type, '=')
              )
          );
      }
      else {
        $table = 'field_data_' . $field_name;
        $column = $field_name . '_value';

        // Search all nodes of Typs type that have no phonemtabellen entry or
        // where the values are out of sync ...
        //
        // DE: Alle Nodes des Typs type suchen, die keine phonemtabellen eintrag
        // haben oder wo die werte nicht synchron sind...

        $query
          ->leftJoin($table, 't', 'n.nid = t.entity_id');
        $query
          ->addField('t', $column, 'value');
        $query
          ->addField('t', 'delta', 'delta');
        $query
          ->leftJoin('bs_uniquenode_phonem', 'p',
              'n.nid = p.nid AND p.field_name = :field_name',
                array(':field_name' => $field['field_name'])
          );
        $query
          ->condition(db_or()
              ->isNull('p.pid')
              ->condition('p.field_value', 't.' . $column, '<>')
          )
          ->condition('n.type', $type,'=')
          ->condition('t.' . $column, '','<>')
          ->isNotNull('t.' . $column);
      }
      $res = $query->execute();

      // Sql executed and updated!
      // DE: Sql ausfÃ¼hren und updaten!
      while ($row = $res->fetchAssoc()) {
        $field_value = $row['value'];
        $phonem_value = _bs_uniquenode_Phonem($field_value);
        $nid = $row['nid'];
        $delta = $row['delta'] ? $row['delta'] : 0;

        // Delete this field phonem.
        db_delete('bs_uniquenode_phonem')
          ->condition('field_name', $field_name)
          ->condition('nid', $nid)
          ->condition('delta', $delta)
          ->execute();

        // Now insert again.
        _bs_uniquenode_save_field_phonem($field_name, $delta, $phonem_value, $field_value, $nid);
      }
    }

  }
}
