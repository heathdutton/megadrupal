<?php
/**
 * @file
 * Tests the unsubscription system.
 */
module_load_include('test', 'wildfire', 'tests/wildfire');

/**
 * Test unsubscribe functionality and its effect on lists.
 */
class WildfireUnsubscribeTestCase extends WildfireWebTestCase {
  /**
   * Implementation of getInfo().
   */
  public static function getInfo() {
    return array(
      'name' => 'Lists - Unsubscribe',
      'description' => 'Test the unsubscribe functionality of the Wildfire module',
      'group' => 'Wildfire',
    );
  }

  public function setUp() {
    // Load the parts of the module we want to use
    module_load_include('inc', 'wildfire_broadcasts', 'wildfire_broadcasts.api');
    module_load_include('inc', 'wildfire_lists', 'wildfire_lists.api');
    module_load_include('inc', 'wildfire_jobs', 'wildfire_jobs.api');

    // Create our random details for our example test case.
    $this->unsubscribe = new stdClass;
    $this->unsubscribe->list = new stdClass;

    // Generic setup, eg, user, etc. Also load the RPC EMU so that the
    // unsubscribe calls out to the server can pass
    parent::setUp(
      array(
        'wildfire_rpc_emu'
      )
    );

    // Set the RPC EMUs initial state
    $state = array(
      'job' => array(),
      'content' => array(),
      'list' => array(),
      'return_values' => array(
        'lists_remove_user' => array(
          'status' => TRUE
        ),
        'amend_job' => array(
          'content_count_diff' => 0,
          'list_count_diff' => 0,
        )
      ),
    );

    cache_set('wildfire_rpc_emu', $state, 'cache', CACHE_TEMPORARY);

  }

  /**
   * Unsubscribe main test.
   */
  protected function testUnsubscribe() {
    // Test if setup failed.
    if ($this->preFail !== FALSE) {
      $preFail = is_string($this->preFail)
        ? $this->preFail
        : 'Setup failed. Test aborted.';
      $this->fail($preFail);
      return;
    }

    $start = microtime();

    // Create a list for testing purposes.
    $this->unsubscribe->list = $this->generateList();

    $this->unsubscribeAPI();
    $this->unsubscribeToken();
    $this->unsubscribeDoubleToken();
    $this->unsubscribeDoubleJob();

    $this->pass(t(
      'Tests completed in !time seconds',
      array('!time' => $this->elapsedTime($start))
    ));
  }

  /**
   * Test some unsubscribe API functions here.
   */
  protected function unsubscribeAPI() {
    // Pass in any old crap to the wildfire_job_get_unsubscribe_token
    // function. Should return FALSE.
    $token = wildfire_job_get_unsubscribe_token(rand(100, 134095), rand(99, 345988));
    $this->assertIdentical(
      FALSE,
      $token,
      t('No unsubscribe token found when false details used')
    );

    // Create a temporary unsubscribe user, then globally opt the user out.
    $unsubuser = $this->drupalCreateUser();
    $lid = 0;

    $stamp = REQUEST_TIME;

    // Add the user to the list and then unsubscribe the user.
    $token = wildfire_lists_user_add($unsubuser->uid, $lid);
    $result = wildfire_list_unsubscribe($unsubuser->uid, $lid);
    $this->assertIdentical(
      TRUE,
      $result,
      t('Successfully unsubscribed user from list using API')
    );

    // We shouldn't be allowed to unsubscribe twice.
    $result = wildfire_list_unsubscribe($unsubuser->uid, $lid);
    $this->assertIdentical(
      FALSE,
      $result,
      t('Was\'t able to unsubscribe user from list a second time using API')
    );

    // Check that the optout is recorded in the database.
    $query = db_select('wildfire_optouts', 'co')
      ->fields('co', array(
        'timestamp'
      ));
    $query->condition('uid', $unsubuser->uid, '=');
    $query->condition('lid', $lid, '=');
    $result = $query->execute();

    $result = $result->fetchField();

    $this->assertTrue(
      $result > 0,
      t('Timestamp for the optout was recorded successfully in the database.')
    );

  }

  /**
   * Add a user to a list, then unsubscribe using the token.
   */
  protected function unsubscribeToken() {
    // Generate a random token and try to use it to unsubscribe. We should be
    // told that it was not successful.
    $token = wildfire_random_string(WILDFIRE_UNSUBSCRIBE_LENGTH);
    $this->drupalGet('wildfire/unsubscribe/' . $token);
    $this->assertText('The unsubscribe link used does not correspond');

    // Put the user into our testing list and send a broadcast to the user so
    // that an unsubscribe token gets generated.
    $lid = 0; // Only test with global optouts.
    $token = wildfire_lists_user_add($this->user->uid, $lid);
    $job = $this->generateJob();
    $job = new WildfireClientJob($job['jid']);
    $job->getContent();
    $job_list = $job->getListUsers();

    $this->user = user_load($job_list[0]['uid']);

    // Make sure that there is no entry in the optout table already for this
    // user.
    $query = db_select('wildfire_optouts', 'co')
      ->fields('co', array(
        'uid'
      ));
    $query->condition('uid', $this->user->uid, '=');
    $query->condition('lid', 0, '=');
    //$query->limit(0, 1);
    $result = $query->execute();

    $result = $result->fetchField();

    $this->assertIdentical($result, FALSE, t('User has not already opted out in the database'));

    // Execute the job so we generate an unsubscribe token for this user.
    wildfire_job_execute($job->jid);
    $token = wildfire_job_get_unsubscribe_token($this->user->uid, $job->jid);

    // Unsubscribe the user.
    $this->drupalGet('wildfire/unsubscribe/' . $token);
    $this->assertText('has been unsubscribed');
    $this->assertText($this->user->mail);

    // Make sure the optout table has been updated.
    $query = db_select('wildfire_optouts', 'co')
      ->fields('co', array(
        'uid'
      ));
    $query->condition('uid', $this->user->uid, '=');
    $query->condition('lid', 0, '=');
    //$query->limit(0, 1);
    $result = $query->execute();

    $result = $result->fetchField();

    $this->assertEqual($result, $this->user->uid, t('User has opted out in the database'));

    /**
     * Get the unsubscribe page again. At this point, if the previous
     * unsubscription was successful, the token no longer exists in the
     * wildfire_job_mails table, thus this should present the "no token"
     * message.
     */
    $this->drupalGet('wildfire/unsubscribe/' . $token);
    $this->assertText('The unsubscribe link used does not correspond');
  }

  /**
   * Make sure unsubscribe tokens are not overwritten on send.
   *
   * Set up a job, then manually add an unsubscribe token. Send the job, and
   * make sure the manually added token is not overwritten.
   */
  protected function unsubscribeDoubleToken() {
    // Make a job and get the first user.
    $job = $this->generateJob();
    $job = new WildfireClientJob($job['jid']);
    $job->getContent();
    $job_list = $job->getListUsers();
    $uid = $job_list[0]['uid'];
    $token = wildfire_random_string(WILDFIRE_UNSUBSCRIBE_LENGTH);

    // Add an unsubscribe token manually for this recipient.
    $record = array();
    $record['jid'] = $job->jid;
    $record['uid'] = $uid;
    $record['token'] = $token;
    drupal_write_record('wildfire_job_mails', $record, array('jid', 'uid'));

    // Execute the job.
    wildfire_job_execute($job->jid);

    // Make sure that the token has not been overwritten and remains the same
    // as it was before.
    $query = db_select('wildfire_job_mails', 'cjm')
      ->fields('cjm', array(
        'token'
      ));
    $query->condition('jid', $job->jid, '=');
    $query->condition('uid', $uid, '=');
    $result = $query->execute();

    $token2 = $result->fetchField();

    $this->assertEqual(
      $token,
      $token2,
      t('Token was preserved on job send.')
    );
  }

  /**
   * Check that tokens are pulled in for the correct job ID
   *
   * This test was created as there was a fringe case where if you create
   * two broadcasts, and cancel the newest before the oldest is executed,
   * the wrong tokens are pulled in.
   */
  function unsubscribeDoubleJob() {

    $broadcasts = array();
    $jobs = array();

    // Create two broadcasts
    $broadcasts[0]  = $this->generateBroadcast(2);
    $broadcasts[1]  = $this->generateBroadcast(2);

    // Create a list. Both broadcasts need to use the same one
    $list = $this->generateList(2);

    // Create two jobs
    $job = array(
      'template'    => $this->template,
      'lid'         => $list->id,
      'type'        => 'broadcast',
      'extra'       => $broadcasts[0]->id,
      'mode'        => WILDFIRE_JOB_MODE_NORMAL,
    );

    $jobs[0] = wildfire_job_add($job, WILDFIRE_JOB_CREATE_IMMEDIATE);

    $job = array(
      'template'    => $this->template,
      'lid'         => $list->id,
      'type'        => 'broadcast',
      'extra'       => $broadcasts[1]->id,
      'mode'        => WILDFIRE_JOB_MODE_NORMAL,
    );

    $jobs[1] = wildfire_job_add($job, WILDFIRE_JOB_CREATE_IMMEDIATE);

    // Force-set the scheduled date of the newest job to ahead of the oldest job
    // to ensure it really IS the newest job
    $query = db_update('wildfire_jobs');
    $query->fields(array(
      'scheduled' => time() + 3600,
    ));
    $query->condition('jid', $jobs[1], '=');
    $query->execute();

    // Cancel the newest
    wildfire_job_cancel($jobs[1]);

    // Execute the oldest
    wildfire_job_execute($jobs[0]);

    // Tokens will have been added to wildfire_job_mails. Let's check the API
    // returns the same results as in the table.
    $query = db_select('wildfire_job_mails', 'jm');
    $query->fields('jm', array(
        'uid',
        'token',
      )
    );
    $query->condition('jid', $jobs[0]);
    $result = $query->execute();

    $tokens_list = array();

    while ($row = $result->fetchAssoc()) {
      $tokens_list[$row['uid']] = $row['token'];
    }

    // Get the token for a user via the API, and compare
    $list_users = wildfire_list_get($list->id, TRUE);
    foreach ($list_users as $user) {

      $token_via_api = wildfire_job_get_unsubscribe_token($user['uid'], $jobs[0]);

      $this->assertEqual(
        $tokens_list[$user['uid']],
        $token_via_api,
        t(
          'Token for UID !uid matches (!token1/!token2)',
          array(
            '!uid' => $user['uid'],
            '!token1' => $tokens_list[$user['uid']],
            '!token2' => $token_via_api,
          )
        )
      );
    }

  }


}
