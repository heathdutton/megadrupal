<?php
/**
 * @file
 * Tests the list system
 */
module_load_include('test', 'wildfire', 'tests/wildfire');

class WildfireListTestCase extends WildfireWebTestCase {

  protected $list;

  /** ------------------------------------------------------------------------
   * Get Information
   *
   * @access public
   * @return array
   */
  public static function getInfo() {
    return array(
      'name' => 'Lists - Main',
      'description' => 'Test the List functionality',
      'group' => 'Wildfire',
    );
  }

  /** ------------------------------------------------------------------------
   * Setup
   *
   * @access public
   * @return void
   */
  public function setUp() {
    // Load the parts of the module we want to use
    module_load_include('module', 'wildfire_lists', 'wildfire_lists');

    // Create our random details for our example test case.
    $this->list = new stdClass;
    $this->list->name = $this->randomName(12);
    $this->users = array();
    // Generic setup, eg, user, etc.

    parent::setUp();

    // Create some extra permissions needed for this module
    $permissions = array(
      'administer wildfire global settings',
      'administer wildfire lists',
      'use wildfire lists',
    );

    // Add a new role with these permissions
    $new_role = $this->drupalCreateRole($permissions);

    // Add this additional role to the user account.
    $this->user->roles[$new_role] = $new_role;
    user_save($this->user);

    // Log in again to ensure the permissions are being picked up
    $this->drupalLogin($this->user);

  }

  /** ------------------------------------------------------------------------
   * Lists Test
   *
   * @access public
   * @return void
   */
  public function testLists() {
    // Test if setup failed.
    if ($this->preFail !== FALSE) {
      $preFail = is_string($this->preFail)
        ? $this->preFail
        : 'Setup failed. Test aborted.';
      $this->fail($preFail);
      return;
    }

    $start = microtime();

    $this->randomUsers(3);
    $this->listAPI();
    $this->listCreate();
    $this->listEdit();
    $this->listAddUsers();
    $this->listUnsubscribe();
    $this->listView();
    $this->listAddFieldTest();
    $this->listImportPage();
    $this->listExportTab();
    $this->deleteUsers();
    $this->listDelete();
    $this->listCounts();
    $this->listLocking();
    $this->listSystemSettingsPage();

    $this->pass(t(
      'Tests completed in !time seconds',
      array('!time' => $this->elapsedTime($start))
    ));
  }

  /**
   * Create some random users for testing purposes.
   *
   * @param int $count
   *    The number of users to create.
   */
  protected function randomUsers($count = 10) {
    for ($i = 0; $i < $count; $i++) {
      $this->users[] = $this->drupalCreateUser();
    }
  }

  /**
   * Delete the test users and check all traces were removed from the
   * relevant wildfire list tables
   */
  protected function deleteUsers() {

    foreach ($this->users as $account) {
      // Store $account->uid as the delete (or a module hook) may nuke it.
      $uid = $account->uid;
      /**
       * 2011-09-27, craig: Using Drupals internal cancel function as I want
       * to bypass the batch processing of user deletion, as the deletion
       * need to be synchronous to allow the hooks to run inline, allowing us
       * to check it right afterwards - batching it gives us asynchronous
       * operation, which is not what we want here.
       */
      _user_cancel(NULL, $account, 'user_cancel_delete');

      $this->pass(t(
        'deleting user !user',
        array(
        '!user' => $uid
        )
      ));

      // Check entries in the wildfire tables are gone...
      // Lists table
      $result = db_select('wildfire_lists_users', 'clu');
      $result->condition('uid', $uid, '=');
      $result->addExpression('COUNT(lid)', 'count');
      $result = $result->execute();

      $list_entry_count = $result->fetchField();

      $this->assertEqual(
        $list_entry_count,
        0,
        t('Entries for user in list table is Zero (%count)', array('%count' => $list_entry_count))
      );

      // Opt-out table
      $query = db_select('wildfire_optouts', 'co');
      $query->condition('uid', $uid, '=');
      $query->addExpression('COUNT(lid)', 'count');
      $result = $query->execute();

      $list_entry_count = $result->fetchField();

      $this->assertEqual(
        $list_entry_count,
        0,
        t('Entries for user in opt-out table is Zero (%count)', array('%count' => $list_entry_count))
      );

    }

  }

  /**
   * Test some list API functions.
   */
  protected function listAPI() {

    $query = db_select('wildfire_lists', 'cl');
    $query->addExpression('COUNT(1)', 'count');
    $result = $query->execute();
    $listcount = $result->fetchField();

    $apiuser = $this->drupalCreateUser();
    $apilist = $this->generateList();
    $anotherlist = $this->generateList();

    // There should be two more lists than there were before.
    $query = db_select('wildfire_lists', 'cl');
    $query->addExpression('COUNT(1)', 'count');
    $result = $query->execute();
    $newcount = $result->fetchField();

    $this->assertEqual(
      $newcount,
      $listcount + 2,
      t('There are two more lists than there were before')
    );

    // User should not be in any list.
    $this->assertIdentical(
      FALSE,
      wildfire_user_is_subscribed($apiuser->uid),
      t('User is not subscribed to any lists')
    );

    // Add user to two lists.
    wildfire_lists_user_add($apiuser->uid, $apilist->id);
    wildfire_lists_user_add($apiuser->uid, $anotherlist->id);

    // User should now be subscribed to both lists, but not a fake list.
    $this->assertIdentical(
      TRUE,
      wildfire_user_is_subscribed($apiuser->uid),
      t('User is subscribed to one or more lists')
    );
    $this->assertIdentical(
      TRUE,
      wildfire_user_is_subscribed($apiuser->uid, $apilist->id),
      t('User is subscribed to API test list')
    );
    $this->assertIdentical(
      TRUE,
      wildfire_user_is_subscribed($apiuser->uid, $anotherlist->id),
      t('User is subscribed to second test list')
    );
    $this->assertIdentical(
      TRUE,
      wildfire_user_is_subscribed($apiuser->uid, 4359087),
      t('User is not subscribed to made-up list ID')
    );

    // Remove the user from one of the lists and make sure it is no longer
    // subscribed.
    wildfire_lists_user_remove($apiuser->uid, $anotherlist->id);
    $this->assertIdentical(
      FALSE,
      wildfire_user_is_subscribed($apiuser->uid, $anotherlist->id),
      t('User is not in the second test list any more')
    );

    // Add an opt-out so that the user should no longer be in the API list.
    wildfire_list_unsubscribe($apiuser->uid, $apilist->id);

    $this->assertIdentical(
      FALSE,
      wildfire_user_is_subscribed($apiuser->uid, $apilist->id),
      t('User has opted out of the API list')
    );

    // Add the user back into the second list, then unsubscribe the user
    // globally. Make sure user is not subscribed to the second list.
    wildfire_lists_user_add($apiuser->uid, $anotherlist->id);
    wildfire_list_unsubscribe($apiuser->uid);
    $this->assertIdentical(
      FALSE,
      wildfire_user_is_subscribed($apiuser->uid, $anotherlist->id),
      t('User has globally opted out')
    );

    // Remove the opt-outs that we have created.
    wildfire_list_resubscribe($apiuser->uid);
    wildfire_list_resubscribe($apiuser->uid, $apilist->id);

    // The user should be back in both lists now.
    $this->assertIdentical(
      TRUE,
      wildfire_user_is_subscribed($apiuser->uid, $apilist->id),
      t('User is subscribed to API test list')
    );
    $this->assertIdentical(
      TRUE,
      wildfire_user_is_subscribed($apiuser->uid, $anotherlist->id),
      t('User is subscribed to second test list')
    );

    // Whilst we have lists to check, verify that the list totals given
    // by wildfire_list_get_totals() are actually integers, rather than
    // strings that contain integers.
    $totals = wildfire_list_get_totals($apilist->id);

    // wildfire_list_get_totals() should return keys 'total', 'name',
    // WILDFIRE_STATUS_UNSUBSCRIBED and WILDFIRE_STATUS_SUBSCRIBED, so check
    // that they are all present.
    foreach (
      array(
        'total',
        'name',
        WILDFIRE_STATUS_UNSUBSCRIBED,
        WILDFIRE_STATUS_SUBSCRIBED,
      ) as $key) {

      // Check the key exists.
      $this->assertTrue(
        array_key_exists($key, $totals),
        t(
          'Key !key found in output from wildfire_list_get_totals()',
          array(
            '!key' => $key,
          )
        )
      );

      // Check that the fields that should be integers actually are.
      if ($key !== 'name') {
        $this->assertIdentical(
          $totals[$key],
          (int) $totals[$key],
          t(
            'Value for key !key is an integer',
            array(
              '!key' => $key,
            )
          )
        );
      }

    }

    // Delete both the lists we created. This should mean that the user is
    // not subscribed to either of them any more.
    wildfire_lists_delete($anotherlist->id);
    wildfire_lists_delete($apilist->id);

    $this->assertIdentical(
      FALSE,
      wildfire_user_is_subscribed($apiuser->uid, $apilist->id),
      t('User is not subscribed to API test list')
    );
    $this->assertIdentical(
      FALSE,
      wildfire_user_is_subscribed($apiuser->uid, $anotherlist->id),
      t('User is not subscribed to second test list')
    );

  }

  /** ------------------------------------------------------------------------
   * Create List
   *
   * @access protected
   * @return void
   */
  protected function listCreate() {
    // Make sure that the add list page exists.
    $this->drupalGet('admin/wildfire/lists/add');
    $this->assertText(t('List name'));
    // Create a list by entering the form.
    $create_list = array(
      'listname' => $this->list->name,
    );
    $this->drupalPost(
      'admin/wildfire/lists/add',
      $create_list,
      t('Add')
    );
    // Confirm that it was created successfully, both outpu-wise and database.
    $this->assertText(t(
      'The list !list has been created.',
      array('!list' => $this->list->name)
    ));

    // Let's check that the list has been entered into the database.
    $query = db_select('wildfire_lists', 'cl')
      ->fields('cl', array(
        'lid'
      ));
    $query->condition('name', $this->list->name, '=');
    $result = $query->execute();

    $result = $result->fetchField();

    $this->list->id = $result;
  }

  /** ------------------------------------------------------------------------
   * Edit List
   *
   * @access protected
   * @return void
   */
  protected function listEdit() {
    // Check whether the list edit page is valid.
    $this->drupalGet(
      'admin/wildfire/lists/' . $this->list->id . '/edit'
    );
    $this->assertRaw('value="' . $this->list->name . '"');

    // Change the list name to another random string.
    $this->list->name = $this->randomName(12);
    // Attempt to update the list with the new name.
    $list_update = array(
      'listname' => $this->list->name,
    );
    $this->drupalPost(
      'admin/wildfire/lists/' . $this->list->id . '/edit',
      $list_update,
      t('Save')
    );

    // Check that the update was successful, both through the output and in
    // the database.
    $this->assertText(t(
      'The changes to list !list have been saved',
      array('!list' => $this->list->name)
    ));

    $query = db_select('wildfire_lists', 'cl');
    $query->condition('lid', $this->list->id, '=');
    $query->condition('name', $this->list->name, '=');
    $query->addExpression('COUNT(1)', 'count');
    $result = $query->execute();

    $result = $result->fetchField();

    $this->assertEqual(
      1,
      $result,
      t('List details have successfully been updated in database.')
    );
  }

  /**
   * Add users to list and remove them again.
   */
  protected function listAddUsers() {
    // Load the Wildfire module, so we can use the module API
    // functions.
    module_load_include('inc', 'wildfire_lists', 'wildfire_lists.api');

    // Now we make sure that the list does not have any users in.
    $count = wildfire_list_get_count($this->list->id);
    $this->assertEqual($count, 0, 'No users in list.');

    // Also check the HTML output. The totals should all be 0.
    $this->drupalGet('admin/wildfire/lists');
    $regex = "#{$this->list->name}</td><td>0</td><td>0</td><td>0<#";
    $this->assertPattern($regex);

    // Let's create a crash test dummy user!
    wildfire_lists_user_add($this->user->uid, $this->list->id);

    // The number of users in the list should now be 1. Verify.
    $count = wildfire_list_get_count($this->list->id);
    $this->assertEqual($count, 1, t('User added to list. Total: 1'));

    // We must re-fetch the page to see any changes to the HTML code. There
    // should be a total of 1 user, with no unsubscribes and 1 active.
    $this->drupalGet('admin/wildfire/lists');
    $regex = "#{$this->list->name}</td><td>1</td><td>0</td><td>1</td><#";
    $this->assertPattern($regex);

    // Add some more users.
    foreach ($this->users as $account) {
      wildfire_lists_user_add($account->uid, $this->list->id);
    }

    // Get the list count. It should be updated now.
    $count = wildfire_list_get_count($this->list->id);
    $this->assertEqual($count, count($this->users) + 1, t('New users added successfully'));

    // Get the List view page. No testing of whether this returns the right
    // thing is done here, we assume it's right. Testing of the page itself
    // occurs in other tests.
    $this->drupalGet('admin/wildfire/lists/' . $this->list->id . '/view');

    // Submit an Add request via AJAX, and check that the User
    // was actually added

    // 1. Try adding a user that doesn't already exist.
    $email = md5(microtime()) . '@example.com';

    $this->drupalPostAJAX(
      NULL,
      array(
        'adduser_email' => $email
      ),
      array(
        'op' => 'Add'
      )
    );

    /*
     * $this->drupalPostAJAX() should alter $this->content according to
     * the AJAX commands returned, but it seems it's not a full implementation
     * as selectors in commands aren't parsed. As our commands modify more
     * than one page element (e.g. add a row, add a status message), we can't
     * use a single 'wrapper' fully. This limitation is already marked as a
     * @todo in the drupalPostAJAX() function as of December 2011.
     *
     * As a result, this assertion will never pass as $this->content does not
     * contain the modification to the status div that occurs in real use.
     */
    //$this->assertNoText('<em class="placeholder">' . $email . '</em>');

    /**
     * Load the user back in, as it should have been created as it did not
     * already exist. The newuser fieldset should not have been triggered as
     * $this->listAddFieldTest() hasn't run yet, thus there should be no extra
     * fields
     */
    $account = user_load_by_mail($email);
    $this->assertTrue(
      !empty($account),
      t(
        'New user account created for !email',
        array(
          '!email' => $email,
        )
      )
    );

    if ($account !== FALSE) {

      $this->assertTrue(
        wildfire_user_is_subscribed($account->uid, $this->list->id),
        t(
          'User !email is subscribed to list !list',
          array(
            '!email' => $email,
            '!list' => $this->list->id,
          )
        )
      );

    }
    else {

      $this->assertTrue(
        t(
          'Account for !email could not be loaded back in',
          array(
            '!email' => $email,
            '!list' => $this->list->id,
          )
        )
      );

    }

    // 2. Try adding an existing user.
    $account = $this->drupalCreateUser();
    $this->users[] = $account;

    $this->drupalPostAJAX(
      NULL,
      array(
        'adduser_email' => $account->mail
      ),
      array(
        'op' => 'Add'
      )
    );

    // User should be subscribed at this point; newuser fieldset should not have
    // been triggered as the user already exists.
    $this->assertTrue(
      wildfire_user_is_subscribed($account->uid, $this->list->id),
      t(
        'User !email is subscribed to list !list',
        array(
          '!email' => $account->mail,
          '!list' => $this->list->id,
        )
      )
    );

    // 3. Try to add the same user again. It should essentially be an no-op.
    $this->drupalPostAJAX(
      NULL,
      array(
        'adduser_email' => $account->mail
      ),
      array(
        'op' => 'Add'
      )
    );

    $this->assertTrue(
      wildfire_user_is_subscribed($account->uid, $this->list->id),
      t(
        'User !email is subscribed to list !list',
        array(
          '!email' => $account->mail,
          '!list' => $this->list->id,
        )
      )
    );

  }

  /**
   * Test unsubscribing one of the users.
   */
  protected function listUnsubscribe() {
    $firstacc = $this->users[0];
    wildfire_list_unsubscribe($this->list->id, $firstacc->uid);

    $this->drupalGet('admin/wildfire/lists');
    $regex = "#{$this->list->name}</td><td>" . (count($this->users) + 2) .
      "</td><td>1</td><td>" . (count($this->users) + 1) . "</td><#";
    $this->assertPattern($regex);
  }

  /**
   * Test that the field information is correct when adding addresses.
   *
   * On the 'view' page for a particular list, when we add a new email
   * address, there should be an extra step to fill out profile information,
   * but ONLY when "field" is enabled and there are actually some fields.
   */
  protected function listAddFieldTest() {
    module_load_include('inc', 'wildfire_lists', 'wildfire_lists.api');

    // We need at least one list in order to complete the test.
    $lists = wildfire_lists_get();

    if (count($lists) == 0) {
      $this->fail('No lists with which to test.');
      return;
    }

    $lid = array_pop(array_keys($lists));

    // The 'field' module is a dependency, so it's probably already enabled.
    // let's disable it, and record what other modules were turned off
    // i.e. what modules had 'field' as a dependency.
    $modules_before = module_list(TRUE);
    module_disable(array('field'));
    $modules_after = module_list(TRUE);

    // There should not be a field with id edit-newuser-save.
    $this->drupalGet('admin/wildfire/lists/' . $lid . '/view');
    $this->assertNoFieldById('edit-newuser-save');

    // Now enable the 'field' module.
    module_enable(array('field'));
    $modules_missing = array_diff($modules_before, $modules_after);

    // There should still not be a field with id edit-newuser-save.
    $this->drupalGet('admin/wildfire/lists/' . $lid . '/view');
    $this->assertNoFieldById('edit-newuser-save');

    // Naively reenable any modules that got disabled by proxy of disabling
    // 'field', putting our state back to the way it was before we started.
    // Needed to actually create new fields.
    module_enable($modules_missing);

    /**
     * 2011-09-27, craig:
     * Make sure the list of modules implementing permissions is up to date.
     * See: http://drupal.org/node/1187858; although not the same issue, same
     * symptoms.
     */
    drupal_static_reset();
    node_types_rebuild();

    $fields = array(
      'field_first_name' => array(
        'label' => 'First name',
        'description' => '',
        'required' => FALSE,
        'field_name' => 'field_first_name',
        'type' => 'text',
        'default_value' => 'Default First Name',
        'module' => 'text',
        'entity_type' => 'user',
        'bundle' => 'user',
      ),
      'field_last_name' => array(
        'label' => 'Last name',
        'description' => '',
        'required' => FALSE,
        'field_name' => 'field_last_name',
        'type' => 'text',
        'default_value' => 'Default Last Name',
        'module' => 'text',
        'entity_type' => 'user',
        'bundle' => 'user',
      ),
    );

    $existing_fields = field_info_instances('user');

    // Unset new field definition for any field that already exists...
    foreach ($existing_fields['user'] as $existing_field) {
      unset($fields[$existing_field['field_name']]);
    }

    // ... then setup anything that remains
    foreach ($fields as $field_name => $field) {
      field_create_field($field);
      $instance = array(
        'label' => $field['label'],
        'field_name' => $field['field_name'],
        'entity_type' => $field['entity_type'],
        'bundle' => 'user',
      );
      field_create_instance($instance);
    }

    // There SHOULD be a field with id edit-newuser-save now :)
    $this->drupalGet('admin/wildfire/lists/' . $lid . '/view');
    $this->assertFieldById('edit-newuser-save');

    /**
     * Check that the user add process now triggers the newuser fieldset
     * rather than just skipping over it as it would if no fields are present.
     *
     * If it doesn't, it will add a new user to the list, and the remaining
     * tests will fail as appropriate.
     */
    $email = md5(microtime()) . '@example.com';

    $ajax_commands = $this->drupalPostAJAX(
      NULL,
      array(
        'adduser_email' => $email
      ),
      array(
        'op' => 'Add'
      )
    );

    $newuser_fieldset_command = FALSE;

    foreach ($ajax_commands as $ajax_command) {
      if (
        $ajax_command['command'] == 'invoke'
        && $ajax_command['selector'] == '#edit-newuser-fieldset'
        && $ajax_command['method'] == 'slideDown'
      ) {
        $newuser_fieldset_command = TRUE;
        break;
      }
    }

    $this->assertTrue(
      $newuser_fieldset_command,
      t('Add user form requests the fields are filled in for new users')
    );

  }

  /**
   * List Tests: Import Page
   *
   * Test the rendering of the Import CSV entry page.
   *
   * A full test of the Import system itself is performed
   * in wildfire.import.test
   */
  protected function listImportPage() {
    // Fetch the Import page. We want to test for form fields.
    $this->drupalGet('admin/wildfire/lists/import');
    // Check that the page is displaying the correct message to the user.
    $this->assertText('Choose a CSV file to import from your local computer.');
    // Check the the file upload form, and the upload button, exist.
    $this->assertFieldById('edit-importsubmit', 'Upload');
    $this->assertFieldById(
      'edit-csvfile',
      '',
      t('File upload field exists for importing to lists.')
    );
  }

  /**
   * List Tests: Export Tab
   *
   * Test for the presence of the export tab on a list page.
   *
   * A full test of the Export system itself is performed
   * in wildfire.export.test
   */
  protected function listExportTab() {
    $this->drupalGet('admin/wildfire/lists/' . $this->list->id);

    // We can't target the primary tabs on the list page since there's no ID we
    // can go after, so in order to test the presence of specific tags, we're
    // forced to match all <ul>s and look at what gets returned.
    $xpath = $this->xpath('//ul/li[3]');
    $found_export = FALSE;
    foreach ($xpath as $path) {
      if ($path->a == 'Export') {
        $found_export = TRUE;
        $this->pass(t('Found the export tab on the lists page'));
        break;
      }
    }

    if (!$found_export) {
      $this->fail(t('Found the export tab on the lists page'));
    }
  }

  /**
   * List Tests: Delete
   */
  protected function listDelete() {
    // Fetch the main lists page and ensure that the delete link exists.
    $this->drupalGet('admin/wildfire/lists');
    $delete_page = 'admin/wildfire/lists/'
                 . $this->list->id
                 . '/delete';
    $this->assertLinkByHref($delete_page);
    // Follow that link and make sure that the delete confirmation page
//  contains the correct items (list name and a form).
    $this->drupalGet($delete_page);
    $this->assertText($this->list->name);
    $this->assertFieldById('edit-delete', 'Delete');
    // Submit the form to delete the list, check that the list no longer
    // appears.
    $this->drupalPost($delete_page, array(), t('Delete'));
    $this->drupalGet('admin/wildfire/lists');
    $this->assertNoText($this->list->name);

    // Make sure that it has successfully been deleted from the database!
    $query = db_select('wildfire_lists', 'cl');
    $query->condition('lid', $this->list->id, '=');
    $query->addExpression('COUNT(lid)', 'count');
    $result = $query->execute();

    $count = $result->fetchField();

    $this->assertEqual(
      0,
      $count,
      t(
        'List "!list" was successfully deleted from database.',
        array('!list' => $this->list->name)
      )
    );
  }

  /** ------------------------------------------------------------------------
   * Test the list 'view' page and make sure everything is in order.
   *
   * @access protected
   * @return void
   */
  protected function listView() {
    module_load_include('inc', 'wildfire_lists', 'wildfire_lists.api');
    $lists = wildfire_lists_get();

    // Make sure there is at least one list to work with.
    if (count($lists) == 0) {
      $this->fail('No lists found. Must abort.');
      return;
    }

    $lid = array_pop(array_keys($lists));
    $this->drupalGet('admin/wildfire/lists/' . $lid . '/view');

    // Make sure that the hidden field contains the current list ID.
    $this->assertFieldById('edit-lid', $lid);

    // Test the add functionality on this page. Create a new user, then
    // attempt to add the user to the list.
    $account = $this->drupalCreateUser();

    // Check that the user is not already in the list.
    $query = db_select('wildfire_lists_users', 'clu')
      ->fields('clu', array(
        'uid'
      ));
    $query->condition('uid', $account->uid);
    $query->condition('lid', $lid);
    $result = $query->execute();

    $result = $result->fetchField();

    $this->assertFalse(
      $result,
      t(
        'User with ID %uid is not in the list with ID %lid.',
        array('%uid' => $account->uid, '%lid' => $lid)
      )
    );

    // Add the user to the list via AJAX. This should succeed without prompting
    // for fields as the user already exists
    $ajax_commands = $this->drupalPostAJAX(
      NULL,
      array(
        'adduser_email' => $account->mail
      ),
      array(
        'op' => 'Add'
      )
    );

    /*
     * See comments in $this->listAddUsers()
     */
    //$this->assertNoText('<em class="placeholder">' . $email . '</em>');

    // Is the User in the table?
    $account = user_load_by_mail($account->mail);
    $this->assertTrue(
      !empty($account),
      t(
        'New user account created for !email',
        array(
          '!email' => $account->mail,
        )
      )
    );

    if ($account !== FALSE) {

      $this->assertTrue(
        wildfire_user_is_subscribed($account->uid, $this->list->id),
        t(
          'User !email is subscribed to list !list',
          array(
            '!email' => $account->mail,
            '!list' => $this->list->id,
          )
        )
      );

    }
    else {

      $this->assertTrue(
        t(
          'Account for !email could not be loaded back in',
          array(
            '!email' => $account->mail,
            '!list' => $this->list->id,
          )
        )
      );

    }

    // Check again. The user should be in the list now.
    $query = db_select('wildfire_lists_users', 'clu')
      ->fields('clu', array(
        'uid'
      ));
    $query->condition('uid', $account->uid);
    $query->condition('lid', $lid);
    $result = $query->execute();

    $result = $result->fetchField();

    $this->assertEqual(
      $account->uid,
      $result,
      t(
        'User with ID %uid is in the list with ID %lid.',
        array('%uid' => $account->uid, '%lid' => $lid)
      )
    );

    // Make up a random email address and add this to the list.
    $mail = $this->randomName() . '@example.com';

    // Add the user to the list via AJAX.
    $ajax_commands = $this->drupalPostAJAX(
      NULL,
      array(
        'adduser_email' => $mail
      ),
      array(
        'op' => 'Add'
      )
    );

    // Attempt to load the new user's account.
    $newacc = array_shift(user_load_multiple(array(), array('mail' => $mail)));
    $this->assertNotEqual(
      $newacc,
      FALSE,
      t('Successfully loaded %email\'s account', array('%email' => $mail))
    );

    // Check that the user is in the list.
    $query = db_select('wildfire_lists_users', 'clu')
      ->fields('clu', array(
        'uid'
      ));
    $query->condition('uid', $newacc->uid);
    $query->condition('lid', $lid);
    $result = $query->execute();

    $result = $result->fetchField();

    $this->assertEqual(
      $newacc->uid,
      $result,
      t(
        'User with ID %uid is in the list with ID %lid.',
        array('%uid' => $newacc->uid, '%lid' => $lid)
      )
    );

    // Refresh the list view page. We should see both email addresses on it
    // now. Both should be subscribed.
    $this->drupalGet('admin/wildfire/lists/' . $lid . '/view');
    $subbed = wildfire_user_is_subscribed($account->uid, $lid) ? 'subscribed' : 'not subscribed';
    $this->pass($subbed);

    // Get the first row of the table and test it.
    $xpath = $this->xpath('//table[@id="wildfire-userlist"]/tbody/tr');
    $newacc_index = -1;
    $account_index = -1;
    $xpath_total = count($xpath);

    // Contrived code to collect the table rows that contain the emails we're
    // looking for.
    for ($i = 0; $i < $xpath_total; $i++) {
      if ($xpath[$i]->td[0]->a[0] == $account->mail) {
        $account_index = $i;
      }
      elseif ($xpath[$i]->td[0]->a[0] == $newacc->mail) {
        $newacc_index = $i;
      }
    }

    // Check that the first and second email addresses are both marked as
    // subscribed.
    $this->assertEqual(
      $xpath[$account_index]->td[1],
      'Subscribed',
      t('First email address (%email) is subscribed', array('%email' => $account->mail))
    );
    $this->assertEqual(
      $xpath[$newacc_index]->td[1],
      'Subscribed',
      t('Second email address (%email) is subscribed', array('%email' => $newacc->mail))
    );

    // Remove one of the users by using the AJAX callback that would normally
    // be triggered by the 'remove' link on a row. We aren't interested in
    // the return value here.
    $this->drupalGet('admin/wildfire/lists/user/remove/' . $newacc->uid . '/' . $lid);

    // View the list
    $this->drupalGet('admin/wildfire/lists/' . $lid . '/view');
    $this->assertNoText($newacc->mail);

    // Unsubscribe the other user via the API and make sure the status text
    // is updated.
    wildfire_list_unsubscribe($account->uid, $lid);
    $this->drupalGet('admin/wildfire/lists/' . $lid . '/view');

    $xpath = $this->xpath('//table[@id="wildfire-userlist"]/tbody/tr');
    $account_index = -1;
    $xpath_total = count($xpath);

    // Contrived code to collect the table row that contains the email we're
    // looking for.
    for ($i = 0; $i < $xpath_total; $i++) {
      if ($xpath[$i]->td[0]->a[0] == $account->mail) {
        $account_index = $i;
      }
    }

    $this->assertEqual(
      $xpath[$account_index]->td[1],
      'Unsubscribed',
      t('Second email address (%email) is unsubscribed', array('%email' => $account->mail))
    );
  }

  /**
   * Make sure the list counts on the list index page are correct.
   */
  protected function listCounts() {
    // Create two lists. Add user to both lists. Unsubscribe user from one
    // list. Make sure counts make sense.
    $list1 = $this->generateList(0);
    $list2 = $this->generateList(0);
    $unsubuser = $this->drupalCreateUser();
    wildfire_lists_user_add($unsubuser->uid, $list1->id);
    wildfire_lists_user_add($unsubuser->uid, $list2->id);
    wildfire_list_unsubscribe($unsubuser->uid, $list2);
    wildfire_lists_user_remove($unsubuser->uid, $list1->id);

    $this->drupalGet('admin/wildfire/lists');

    $this->assertRaw(
      $list1->name . '</td><td>0</td><td>0</td><td>0<',
      t('First list counts all check out')
    );
    $this->assertRaw(
      $list2->name . '</td><td>1</td><td>1</td><td>0<',
      t('Second list counts all check out')
    );
  }

  /**
   * Test that list locking /unlocking behaves correctly
   *
   * @access protected
   * @return void
   */
  protected function listLocking() {

    // Create a new list
    $list = $this->generateList(5);

    // Lock it
    wildfire_list_lock($list->id);

    // Check it reports as locked
    $this->assertTrue(
      wildfire_list_is_locked($list->id),
      t(
        'List #!lid is currently locked',
        array(
          '!lid' => $list->id
        )
      )
    );

    // Lock the users on the list
    wildfire_list_users_lock_all($list->id);

    // Check that the entries on the list are now locked
    $list_entries = wildfire_list_get($list->id);
    $entries_locked = TRUE;
    foreach ($list_entries as $entry) {
      if ($entry['locked'] != WILDFIRE_LIST_USER_LOCKED) {
        $entries_locked = FALSE;
        break;
      }
    }

    $this->assertTrue(
      $entries_locked,
      t(
        'Users in #!lid are currently locked',
        array(
          '!lid' => $list->id
        )
      )
    );

    // Unlock the entries. Note that there's presently no global "unlock all"
    // API for this.
    foreach ($list_entries as $entry) {
      wildfire_list_user_unlock($list->id, $entry['uid']);
    }

    // Check that the entries on the list are now unlocked
    // Make sure we flush the static cache, so that the list is up-to-date.
    $cache =& drupal_static('wildfire_list_get');
    $cache = array();

    $list_entries = wildfire_list_get($list->id);
    $entries_unlocked = TRUE;
    foreach ($list_entries as $entry) {
      if ($entry['locked'] != WILDFIRE_LIST_USER_UNLOCKED) {
        $entries_unlocked = FALSE;
        break;
      }
    }

    $this->assertTrue(
      $entries_unlocked,
      t(
        'Users in #!lid are currently unlocked',
        array(
          '!lid' => $list->id
        )
      )
    );

    // Unlock it
    wildfire_list_unlock($list->id);

    // Check it reports as unlocked
    $this->assertFalse(
      wildfire_list_is_locked($list->id),
      t(
        'List #!lid is currently unlocked',
        array(
          '!lid' => $list->id
        )
      )
    );

    // Try to lock users on an unlocked list - this should fail
    $this->assertFalse(
      wildfire_list_users_lock_all($list->id),
      t(
        'Locking users on unlocked list #!lid failed',
        array(
          '!lid' => $list->id
        )
      )
    );

    wildfire_list_lock($list->id);
    wildfire_list_users_lock_all($list->id);
    wildfire_list_unlock($list->id);

    // Try to unlock a user on a unlocked list - this should fail
    $this->assertFalse(
      wildfire_list_user_unlock($list->id, $list_entries[0]['uid']),
      t(
        'Unlocking user #!uid on unlocked list #!lid failed',
        array(
          '!uid' => $list_entries[0]['uid'],
          '!lid' => $list->id
        )
      )
    );

  }

  protected function listSystemSettingsPage() {

    // Make sure the relevant fields are on the form and defaults are correct.
    $this->drupalGet('admin/wildfire/settings');
    $this->assertFieldByName('wildfire_registration_add_to_list', '');
    $this->assertFieldByName('wildfire_registration_list', 0);

    /**
     * Set the system name so that the form doesn't fail on validation.
     * Whether that field validates or not is in the Core system settings tests
     */
    variable_set('wildfire_system_name', $this->randomName(32));

    // Test that the 'automatically add new users to a mailing list' works when
    // saved and not checked.
    $test = array('wildfire_registration_add_to_list' => FALSE);
    $this->drupalPost(
      'admin/wildfire/settings',
      $test,
      t('Save configuration')
    );

    $this->assertFalse(
      variable_get('wildfire_registration_add_to_list', TRUE),
      t('Successfully set "automatically add" to FALSE')
    );

    // Test that the 'automatically add new users to a mailing list' works when
    // saved and checked, when setting the list to 'none'.
    $test = array(
      'wildfire_registration_add_to_list' => TRUE,
      'wildfire_registration_list' => 0,
    );
    $this->drupalPost(
      'admin/wildfire/settings',
      $test,
      t('Save configuration')
    );

    $this->assertTrue(
      variable_get('wildfire_registration_add_to_list', FALSE),
      t('Successfully set "automatically add" to FALSE')
    );
    $this->assertEqual(
      variable_get('wildfire_registration_list', 1337),
      0,
      t('Successfully set "automatically add" to TRUE using the "none" list')
    );

    // Add a new list. Set the 'automatically add new users to a mailing list'
    // to use this list.
    $list = $this->generateList();

    $test = array(
      'wildfire_registration_add_to_list' => TRUE,
      'wildfire_registration_list' => $list->id,
    );
    $this->drupalPost(
      'admin/wildfire/settings',
      $test,
      t('Save configuration')
    );

    $this->assertEqual(
      variable_get('wildfire_registration_list', 1337),
      $list->id,
      t('Successfully set "automatically add" to TRUE using a custom list with ID %lid', array('%lid' => $list->id))
    );

  }

}
