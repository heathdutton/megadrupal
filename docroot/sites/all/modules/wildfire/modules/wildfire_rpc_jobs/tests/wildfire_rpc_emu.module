<?php
/**
 * @file
 *  wildfire_rpc_emu.module
 *
 *  Emulates the WildfireHQ server RPC interface for the purposes of
 *  testing the client RPC functionality without having to send live requests.
 *
 * @author Craig Jones <craig@tiger-fish.com>
 *
 * TODO: Improve the basic logic, and add error checking for well-formed input.
 *
 * NOTE: The emulator currently contains rudimentary logic only, and relies on
 * the state being set externally to emulate a success or failure condition.
 * Predominantly it's to check that the client can actually issue XML-RPC
 * requests properly and correctly process success / failure conditions from
 * such a request gracefully.
 */

/**
 * Allows the internal state of the emulator to be changed. This uses
 * the cache to store a temporary state whilst the test runs.
 *
 * @param array $state
 *  If set, will reset the internal state of the emulator to this value
 *
 * @return array
 *  The internal state of the emulator.
 */
function wildfire_rpc_emu_state($state = NULL) {

  if (!empty($state)) {
    cache_set('wildfire_rpc_emu', $state, 'cache', CACHE_TEMPORARY);
  }

  $cache = cache_get('wildfire_rpc_emu', 'cache');
  return $cache->data;

}

/**
 * Implements hook_xmlrpc().
 *
 * This contains 'clones' of all of the commands that the server implements
 * so we can test each one in turn.
 */
function wildfire_rpc_emu_xmlrpc() {
  $commands = array();

  $commands[] = array(
    'wildfire.job.newJob',
    'wildfire_rpc_emu_new_job',
    array('struct', 'int', 'string', 'string', 'struct'),
    t('Requests a new job to be created for the given system')
  );
  $commands[] = array(
    'wildfire.job.addToContentSet',
    'wildfire_rpc_emu_add_to_content_set',
    array('struct', 'int', 'string', 'string', 'struct'),
    t('Adds an entry to a content set associated with a job')
  );
  $commands[] = array(
    'wildfire.job.addToList',
    'wildfire_rpc_emu_add_to_list',
    array('struct', 'int', 'string', 'string', 'struct'),
    t('Adds an entry to list associated with a job')
  );
  $commands[] = array(
    'wildfire.job.processJob',
    'wildfire_rpc_emu_process_job',
    array('struct', 'int', 'string', 'string', 'struct'),
    t('Process the job if in a state to do so')
  );
  $commands[] = array(
    'wildfire.job.getStatus',
    'wildfire_rpc_emu_get_status',
    array('struct', 'int', 'string', 'string', 'struct'),
    t('Start processing the job if in a state to do so')
  );
  $commands[] = array(
    'wildfire.jobs.list',
    'wildfire_rpc_emu_list_jobs',
    array('struct', 'int', 'string', 'string', 'struct'),
    t('Lists the jobs for the given system')
  );
  $commands[] = array(
    'wildfire.lists.removeUser',
    'wildfire_rpc_emu_lists_remove_user',
    array('struct', 'int', 'string', 'string', 'struct'),
    t('Removes a user from remote jobs')
  );
  $commands[] = array(
    'wildfire.job.amendJob',
    'wildfire_rpc_emu_amend_job',
    array('struct', 'int', 'string', 'string', 'struct'),
    t('Amends job details if in a state to do so')
  );
  $commands[] = array(
    'wildfire.system.getQuota',
    'wildfire_rpc_emu_get_quota',
    array('struct', 'int', 'string', 'string', 'struct'),
    t('Obtains the systems send quota')
  );
  $commands[] = array(
    'wildfire.job.retryJob',
    'wildfire_rpc_emu_retry_job',
    array('struct', 'int', 'string', 'string', 'struct'),
    t('Retries the job if possible to do so')
  );

  return $commands;
}

/**
 * RPC function to add a new job to the system
 *
 * @param $api_version
 *  The API version for the request
 * @param $system
 *  The system requesting the add
 * @param $hash
 *  A SHA-1 hash of the parameters salted with the system auth key
 * @param $params
 *  An associative array with the following keys:
 *    'content_count' - The count of expected content chunks
 *    'list_count' - The count of the expected list entries
 *
 * @return array
 *  An associative array containing the following keys:
 *    'uid' - The Job ID to use in subsequent requests
 */
function wildfire_rpc_emu_new_job($api_version, $system, $hash, $params) {

  $state = wildfire_rpc_emu_state();
  $state['job'] = array(
    'system' => $system,
    'hash' => $hash,
    'params' => $params,
  );
  $state = wildfire_rpc_emu_state($state);

  $result = $state['return_values']['new_job'];

  if (empty($result)) {
    return xmlrpc_error(-9, t('Emu failed to return a valid result'));
  }

  if (!empty($result['error'])) {
    return xmlrpc_error($result['error_code'], $result['error']);
  }
  else {
    return $result;
  }

}

/**
 * RPC function to add content to a jobs content set
 *
 * @param $api_version
 *  The API version for the request
 * @param $system
 *  The system requesting the add
 * @param $hash
 *  A SHA-1 hash of the parameters salted with the system auth key
 * @param $params
 *  An associative array with the following keys:
 *    'jid'     - Job ID to add the content to
 *    'content' - The actual content to add
 *    'type'    - Type of this chunk, either 'parent' (AKA overall)  or 'child'
 *
 * @return array
 *  An associative array containing the following keys:
 *    'success'  - Either TRUE for success, or FALSE for failure
 */
function wildfire_rpc_emu_add_to_content_set($api_version, $system, $hash, $params) {

  $state = wildfire_rpc_emu_state();
  $state['content'] = array(
    'system' => $system,
    'hash' => $hash,
    'params' => $params,
  );
  $state = wildfire_rpc_emu_state($state);

  $result = $state['return_values']['add_to_content_set'];

  if (empty($result)) {
    return xmlrpc_error(-9, t('Emu failed to return a valid result'));
  }

  if (!empty($result['error'])) {
    return xmlrpc_error($result['error_code'], $result['error']);
  }
  else {
    return $result;
  }

}

/**
 * RPC function to add entries to the list for a job
 *
 * @param $api_version
 *  The API version for the request
 * @param $system
 *  The system requesting the add
 * @param $hash
 *  A SHA-1 hash of the parameters salted with the system auth key
 * @param $params
 *  An associative array with the following keys:
 *    'jid' - Job ID to add the content to
 *    'entries' - An array containing any number of sub arrays with the
 *                following keys:
        'mail'  - The users email address
 *      'metadata' - An array containing the users metadata
 *
 * @return array
 *  An associative array containing the following keys:
 *    'total'   - Total number of users in list given
 *    'added'   - Total number that succeeded
 *    'failed'  - Total number that failed
 */
function wildfire_rpc_emu_add_to_list($api_version, $system, $hash, $params) {

  $state = wildfire_rpc_emu_state();
  $state['list'] = array(
    'system' => $system,
    'hash' => $hash,
    'params' => $params,
  );
  $state = wildfire_rpc_emu_state($state);

  $result = $state['return_values']['add_to_list'];

  if (empty($result)) {
    return xmlrpc_error(-9, t('Emu failed to return a valid result'));
  }

  if (!empty($result['error'])) {
    return xmlrpc_error($result['error_code'], $result['error']);
  }
  else {
    return $result;
  }

}

/**
 * RPC function to process a job
 *
 * @param $api_version
 *  The API version for the request
 * @param $system
 *  The system requesting the process
 * @param $hash
 *  A SHA-1 hash of the parameters salted with the system auth key
 * @param $params
 *  An associative array with the following keys:
 *    'jid' - Job ID to add the content to
 *    'starttime' - (optional) When to start the send, if this is to be a
 *                  delayed start.
 *
 * @return array
 *  An associative array containing the following keys:
 *    The current contents of $this->dbrow at the job start
 */
function wildfire_rpc_emu_process_job($api_version, $system, $hash, $params) {

  $state = wildfire_rpc_emu_state();

  // Set the state of the job in the emulator to WILDFIRE_JOB_PREPARED,
  // as a success code for a real process would do.

  if (!empty($state['return_values']['process_job']['status'])) {

    if ($state['return_values']['process_job']['status'] !== WILDFIRE_JOB_PREPARED) {

      $state['return_values']['process_job']['status'] = WILDFIRE_JOB_PREPARED;
      $state['return_values']['get_status']['status'] = WILDFIRE_JOB_PREPARED;
      wildfire_rpc_emu_state($state);

      $result = $state['return_values']['process_job'];

    }
    else {

      // Its already being processed!
      // TODO: should match the response from the real server
      $result = array(
        'error' => t(
          'Job does not have the status WILDFIRE_JOB_PREPARED (Status: !status)',
          array(
            '!status' => $state['return_values']['process_job']['status']
          )
        ),
        'error_code' => -1,
      );

    }

  }

  if (empty($result)) {
    return xmlrpc_error(-9, t('Emu failed to return a valid result'));
  }

  if (!empty($result['error'])) {
    return xmlrpc_error($result['error_code'], $result['error']);
  }
  else {
    return $result;
  }

}

/**
 * RPC function to get the status of a job
 *
 * @param $api_version
 *  The API version for the request
 * @param $system
 *  The system requesting the start
 * @param $hash
 *  A SHA-1 hash of the parameters salted with the system auth key
 * @param $params
 *  An associative array with the following keys:
 *    'jid' - Job ID to get the status for
 *
 * @return array
 *  An associative array containing the following keys:
 *    'status'        - A valid WFHQ job status. See WFHQ_JOB_* constants
 *    'total_mails'   - How many mails are to be sent
 *    'sent_mails'    - How many mails have been sent
 *    'failed_mails'  - How many mails have failed to be sent
 */
function wildfire_rpc_emu_get_status($api_version, $system, $hash, $params) {

  $state = wildfire_rpc_emu_state();

  $result = $state['return_values']['get_status'];

  if (empty($result)) {
    return xmlrpc_error(-9, t('Emu failed to return a valid result'));
  }

  if (!empty($result['error'])) {
    return xmlrpc_error($result['error_code'], $result['error']);
  }
  else {
    return $result;
  }

}

/**
 * RPC function to get the status of a job
 *
 * @param $api_version
 *  The API version for the request
 * @param $system
 *  The system requesting the start
 * @param $hash
 *  A SHA-1 hash of the parameters salted with the system auth key
 * @param $params
 *  An associative array with the following keys:
 *    'status' - An array of statuses to filter the results on.
 *
 * @return array
 *  An array containing the
 */
function wildfire_rpc_emu_list_jobs($api_version, $system, $hash, $params) {

  $state = wildfire_rpc_emu_state();

  $result = $state['return_values']['list_jobs'];

  if (empty($result)) {
    return xmlrpc_error(-9, t('Emu failed to return a valid result'));
  }

  if (!empty($result['error'])) {
    return xmlrpc_error($result['error_code'], $result['error']);
  }
  else {
    return $result;
  }

}

/**
 * RPC function to remove a user from any lists for jobs that have not yet
 * been processed.
 *
 * @param $api_version
 *  The API version for the request
 * @param $system
 *  The system requesting the add
 * @param $hash
 *  A SHA-1 hash of the parameters salted with the system auth key
 * @param $params
 *  An associative array with the following keys:
 *    'mail' - The email address for the user to remove
 *
 * @return array
 *  An associative array containing the following keys:
 *    'status' - TRUE if the removal succeeded, else FALSE
 */
function wildfire_rpc_emu_lists_remove_user($api_version, $system, $hash, $params) {

  $state = wildfire_rpc_emu_state();

  $result = $state['return_values']['lists_remove_user'];

  if (empty($result)) {
    return xmlrpc_error(-9, t('Emu failed to return a valid result'));
  }

  if (!empty($result['error'])) {
    return xmlrpc_error($result['error_code'], $result['error']);
  }
  else {
    return $result;
  }

}

/**
 * RPC function to amend an in-progress job in the system
 *
 * @param $api_version
 *  The API version for the request
 * @param $system
 *  The system requesting the add
 * @param $hash
 *  A SHA-1 hash of the parameters salted with the system auth key
 * @param $params
 *  An associative array with the following keys:
 *    'content_count' - The count of expected content chunks
 *    'list_count' - The count of list entries expected
 *
 * @return array
 *  An associative array containing the following keys:
 *    'content_count_diff' => The difference between the count on server and
 *                            the amended value
 *    'list_count_diff' => The difference between the count on server and the
  *                        amended value
 */
function wildfire_rpc_emu_amend_job($api_version, $system, $hash, $params) {

  $state = wildfire_rpc_emu_state();

  $result = $state['return_values']['amend_job'];

  if (empty($result)) {
    return xmlrpc_error(-9, t('Emu failed to return a valid result'));
  }

  if (!empty($result['error'])) {
    return xmlrpc_error($result['error_code'], $result['error']);
  }
  else {
    return $result;
  }

}

/**
 * RPC function to obtain system quota information
 *
 * @param $api_version
 *  The API version for the request
 * @param $system
 *  The system requesting the add
 * @param $hash
 *  A SHA-1 hash of the parameters salted with the system auth key
 * @param $params
 *  An empty array
 *
 * @return array
 *  An associative array containing the following keys:
 *    'total' -The current total send quota for the system
 *    'top-up' -The current total top-up quota for the system
 *    'monthly' -The current total monthly quota for the system
 */
function wildfire_rpc_emu_get_quota($api_version, $system, $hash, $params) {

  $state = wildfire_rpc_emu_state();

  $result = $state['return_values']['get_quota'];

  if (empty($result)) {
    return xmlrpc_error(-9, t('Emu failed to return a valid result'));
  }

  if (!empty($result['error'])) {
    return xmlrpc_error($result['error_code'], $result['error']);
  }
  else {
    return $result;
  }

}

/**
 * RPC function to retry a job
 *
 * @param $api_version
 *  The API version for the request
 * @param $system
 *  The system requesting the process
 * @param $hash
 *  A SHA-1 hash of the parameters salted with the system auth key
 * @param $params
 *  An associative array with the following keys:
 *    'jid' - Job ID to add the content to
 *
 * @return array
 *  An associative array containing the following keys:
 *    'status' => The jobs current status after an attempted restart
 */
function wildfire_rpc_emu_retry_job($api_version, $system, $hash, $params) {

  $state = wildfire_rpc_emu_state();

  /**
   * This one work a bit differently, as the emulator state stores what the
   * job is, not what the result of the call will be. It will always return
   * WILDFIRE_JOB_PREPARED if 'job_is' set to WILDFIRE_JOB_PAUSED
   */
  $job_is = $state['return_values']['retry_job']['job_is'];

  if ($job_is !== WILDFIRE_JOB_PAUSED) {
    $result = array(
      'error_code' => WILDFIRE_RPC_ERROR_JOB_STATUS_DISALLOWS_OPERATION,
      'error' => t('Job is not in a state from which it can be restarted')
    );
  }
  else {
    $result = WILDFIRE_JOB_PREPARED;
  }

  if (!empty($result['error'])) {
    return xmlrpc_error($result['error_code'], $result['error']);
  }
  else {
    return $result;
  }

}
