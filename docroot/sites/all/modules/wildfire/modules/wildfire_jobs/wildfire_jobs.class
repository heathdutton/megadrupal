<?php
/**
 * @file
 *  Classes for Wildfire Jobs module
 *
 * @author Craig Jones <craig@tiger-fish.com>
 */

/**
 * Custom Exception thrown whenever an invalid Email Address is encountered.
 */
class WildfireEmailAddressException extends RuntimeException {
}

/**
 * Class to collate a Job details
 */
class WildfireClientJob {

  /**
   * @var array $dbrow
   *  An associative array containing the data in the jobs corresponding data
   *  row
   */
  protected $dbrow;

  /**
   * @var array $tokenList
   *  An associative array of the tokens required by all of the content.
   */
  protected $token_list;

  /**
   * @var WildfireClientMessage $message
   *  The message associated with the job.
   */
  protected $message;

  /**
   * @var bool $stale
   *  Whether the data in $this->dbrow needs to be committed
   */
  protected $stale = FALSE;

  /**
   * Constructor
   *
   * @param int $jid
   *  If not empty, initializes the new object state to this job
   */
  public function __construct($jid = NULL) {

    if (!empty($jid)) {
      $this->load($jid);
    }

  }

  /**
   * Magic method to obtain data from the local db row by reading unset
   * properties.
   *
   * @param name
   *  The name of the unset property
   *
   * @return string
   *  Value for the property, or NULL if the key does not exist in $this->dbrow
   */
  public function __get($name) {

    if (array_key_exists($name, $this->dbrow)) {
      return $this->dbrow[$name];
    }

    // Raise a non-fatal error if the property does not exist
    $trace = debug_backtrace();
    trigger_error(
      'Undefined property via WildfireJob->__get(): ' . $name .
      ' in ' . $trace[0]['file'] .
      ' on line ' . $trace[0]['line'],
      E_USER_NOTICE);
    return NULL;

  }

  /**
   * Magic method to set data to the local db row by writing unset
   * properties.
   *
   * @param name
   *  The name of the unset property
   *
   * @param value
   *  The value to set
   *
   * @return NULL
   */
  public function __set($name, $value) {

     $this->dbrow[$name] = $value;
     $this->stale = TRUE;

  }

  /**
   * Destructor
   */
  public function __destruct() {

    if ($this->stale) {
      $this->save();
    }

  }

  /**
   * Magic method to use with isset() / empty()
   *
   * @param name
   *  The name of the property
   *
   * @return bool
   *  TRUE if it is set, else FALSE
   */
  public function __isset($name) {

    return isset($this->dbrow[$name]);

  }

  /**
   * Magic method to sleep the object when serialized.
   *
   * Batch jobs will serialize the object state, so this ensures that when
   * woken up, the job is in the exact same state.
   *
   */
  public function __sleep() {
    if (!empty($this->dbrow['jid'])) {
      $this->save($this->dbrow['jid']);
    }
    return array('dbrow', 'token_list', 'message');
  }

  /**
   * Magic method to wakeup the object
   *
   * When the object is unserialized, we want to reload the objects internal
   * state.
   */
  public function __wakeup() {

    if (!empty($this->dbrow['jid'])) {
      $this->load($this->dbrow['jid']);

      /**
       * If the Jobs internal WildfireClientMessage has not yet been instantiated,
       * do that now. This caters for scenarios where the object was put to sleep
       * prior to WildfireClientJob->newContent() being called, in that if the
       * associated WildfireClientMessage now exists, it is reinstated correctly
       * as you would expect. If the WildfireClientMessage was instantiated when
       * the object was put to sleep, $this->message won't be NULL and thus the
       * load won't be required.
       *
       * If you do a wakeup on a Job where the message has not yet been
       * created via WildfireClientJob->newContent(), $this->message will of
       * course be empty.
       */
      if ($this->message === NULL) {
        $this->message = WildfireClientMessage::getMessageObject($this->dbrow['type']);
        $this->message->loadFromJob($this->dbrow['jid']);
      }
    }

  }

  /**
   * Adds newly-found tokens in content to the token list for the job object
   *
   * @param array $token_list
   *  Token list array, keyed by token name.
   */
  function addToTokenList($token_list) {

    // Append any new tokens to the end.
    if (is_array($token_list) && !empty($token_list)) {
      if (!empty($this->token_list)) {
        $this->token_list = array_merge($this->token_list, $token_list);
      }
      else {
        $this->token_list = $token_list;
      }
    }

  }

  /**
   * Returns whether the job can be cancelled
   *
   * @throws BadMethodCallException
   *  If you attempt to obtain status for a job that has not been loaded
   *
   * @return bool
   *  TRUE if the job can be cancelled, else FALSE
   */
  public function canCancel() {

    if (!isset($this->dbrow['status'])) {
      throw new BadMethodCallException(
        t('Cannot obtain status for a job that has not been loaded')
      );
    }

    return in_array($this->dbrow['status'], array(
      WILDFIRE_JOB_PENDING,
      WILDFIRE_JOB_PREPARED,
    ));

  }

  /**
   * Marks a job as cancelled
   *
   * @return bool
   *  Returns TRUE if the job was successfully cancelled, else FALSE
   *  In FALSE conditions, the reason that the status could not be changed
   *  will be raised as an Exception and logged.
   */
  public function cancelJob() {

    if ($this->canCancel()) {
      try {
        $this->setStatus(WILDFIRE_JOB_CANCELLED);
      }
      catch (Exception $e) {

        watchdog(
          'wildfire_jobs',
          t(
            'Cancelling Job !jid failed: !message',
            array(
              '!jid' => $this->dbrow['jid'],
              '!message' => $e->getMessage()
            )
          )
        );

      }
    }

    return TRUE;

  }

  /**
   * Places the template and message content into content chunks ready to
   * be sent. This also works out what tokens are going to be required based
   * on the loaded content.
   *
   * @param int $limit
   *  How many chunks to obtain Defaults to -1, which represents all chunks
   * @param bool $only_pending
   *  Set to TRUE to only return items that are pending upload in the results.
   *  Defaults to FALSE
   *
   * @return array
   *  Returns the processed content.
   *
   * TODO: LATER PHASE: $limit and $only_pending don't currently do anything
   * with this method as in the present design there's only one chunk
   * with type 'parent'. This is really gearing it up for later when we will
   * have conditional content and user to chunk mappings.
   */
  public function getContent($limit = -1, $only_pending = FALSE) {

    $job_content = array();

    $query = db_select('wildfire_job_content', 'wjc')
      ->fields('wjc', array(
        'type',
        'delta',
        'content',
        'token_list',
      ));
    $query->condition('jid', $this->dbrow['jid'], '=');
    if ($limit > 0) {
      $query->range(0, $limit);
    }
    if ($only_pending) {
      $query->condition('uploaded', WILDFIRE_JOB_PART_PENDING, '=');
    }
    $result = $query->execute();

    while($row = $result->fetchAssoc()) {

      $job_content[] = array(
        'content_type' => $row['type'],
        'content' => unserialize($row['content']),
        'token_list' => unserialize($row['token_list']),
      );

    }

    return !empty($job_content) ? $job_content : FALSE;

  }

  /**
   * Gets the users from the Job list.
   *
   * @param int $limit
   *  How many user to obtain from the list. Defaults to -1, which represents
   *  all users
   * @param bool $only_pending
   *  Set to TRUE to only return items that are pending upload in the results.
   *  Defaults to FALSE
   *
   * @return array
   *  Array of users in the list as subarray with the following keys:
   *    'uid'       - Users UID
   *    'mail'      - Users email address
   *    'metadata'  - Associative array containing the users token replacements
   *                  and content chunk mappings (if any)
   *
   * Returns FALSE if the list is empty
   */
  public function getListUsers($limit = -1, $only_pending = FALSE) {

    $job_users = array();

    $query = db_select('wildfire_job_mails', 'wjm')
      ->fields('wjm', array(
        'uid',
        'mail',
        'metadata'
      ));
    $query->condition('jid', $this->dbrow['jid'], '=');
    if ($limit > 0) {
      $query->range(0, $limit);
    }
    if ($only_pending) {
      $query->condition('uploaded', WILDFIRE_JOB_PART_PENDING, '=');
    }
    $result = $query->execute();

    while($row = $result->fetchAssoc()) {
      /**
       * Only return this record if the email address is actually valid.
       *
       * This Job mails list should have been pre-vetted, so this should never
       * not be the case, so this is "belt and braces" to ensure nothing bad
       * leaks into what will eventually be uploaded to the server.
       */
      if (wildfire_valid_email_address($row['mail'])) {
        $row['metadata'] = unserialize($row['metadata']);
        $job_users[] = $row;
      }
    }

    return !empty($job_users) ? $job_users : FALSE;

  }

  /**
   * Gets the status of the job.
   *
   * @throws BadMethodCallException
   *  If you attempt to obtain status for a job that has not been loaded
   *
   * @return int
   *  The current status of the job.
   */
  public function getStatus() {

    if (!isset($this->dbrow['status'])) {
      throw new BadMethodCallException(
        t('Cannot obtain status for a job that has not been loaded')
      );
    }

    return $this->dbrow['status'];

  }

  /**
   * Obtains a users details along with any tokens required to be passed
   * through as metadata when building the recipient lists
   *
   * @param int $uid
   *  User ID to obtain.
   *
   * @throws InvalidArgumentException
   *  If the message associated with the job has not been loaded.
   *
   * @throws WildfireEmailAddressException
   *  If the user contains an email address that cannot be used.
   *
   * @return array
   *  Associative array with the following keys:
   *    'mail'      - Users email address,
   *    'metadata'  - Associative array containing the users token replacements
   *                  and content chunk mappings (if any)
   */
  protected function getUserWithTokens($uid) {

    if (empty($this->message)) {
      throw new InvalidArgumentException(
        t('Message object to extract valid token list for user from has not been loaded')
      );
    }

    $query = db_select('users', 'u')
      ->fields('u', array(
        'mail'
    ));
    $query->condition('uid', $uid, '=');
    $result = $query->execute();

    // If there's not exactly one row, reject the user.
    if ($result->rowCount() == 1) {

      $mail = $result->fetchField();

      /**
       * If the user does not have a valid email address, it can't be used.
       * Should never really happen unless the user account is broken, in which
       * case it should not have entered the source list in the first place.
       */
      if (!wildfire_valid_email_address($mail)) {
        throw new WildfireEmailAddressException(
          t(
            '!mail is not a valid Email address',
            array(
              '!mail' => $mail
            )
          )
        );
      }

      $metadata = array();

      /**
       * Get the tokens specific to this recipient. We load these from the
       * corresponding message for this job to ensure that we are providing
       * replacements for all tokens found within the messages content.
       */
      $this->message->populateTokenReplacements($this->dbrow['jid'], $uid);

      $metadata['tokens'] = $this->message->getTokenReplacements();

      // Get the chunk mappings
      /**
       * TODO: LATER PHASE: This is to be implemented in a later development
       * phase, pass through empty for now.
       */
      $metadata['chunk_map'] = array();

      return array(
        'mail' => $mail,
        'metadata' => $metadata,
      );

    }
    else {
      return FALSE;
    }

  }



  /**
   * Loads an object state from the database into the object
   *
   * @throws InvalidArgumentException
   *  If the Job ID is invalid or can't be loaded.
   *
   * @param int $jid
   *  Job ID to load
   *
   * @return bool
   *  TRUE if the load succeeded, else FALSE
   */
  public function load($jid) {

    try {

      if (!ctype_digit((string)$jid)) {
        throw new InvalidArgumentException(
          t('Job ID is not an integer')
        );
      }

      $query = db_select('wildfire_jobs', 'wj')
        ->fields('wj');
      $query->condition('jid', $jid, '=');
      $result = $query->execute();

      if ($result->rowCount() == 0) {
        throw new InvalidArgumentException(t('Job ID given was not valid'));
      }

      $this->dbrow = $result->fetchAssoc();

      return TRUE;

    }
    catch (Exception $e) {

      watchdog(
        'wildfire_jobs',
        t(
          'Loading Job !jid failed: !message',
          array(
            '!jid' => $jid,
            '!message' => $e->getMessage()
          )
        )
      );

      return FALSE;

    }

  }

  /**
   * Creates a new Job
   *
   * @param string $template
   *  ID of the template to use for this job
   * @param int $lid
   *  ID of the list of users to send this job to
   * @param string $type
   *  The type of message being sent. Presently, only 'broadcast' is supported.
   *  See wildfire_mail_types() in "wildfire" module for a list of valid types.
   * @param int $extra
   *  ID of the message to obtain the content from if $type is broadcast
   *  Uee is undefined in any other case.
   * @param int $sendtime
   *  (optional) UNIX timestamp. If given, will schedule the job for this time.
   * @param string $title
   *  Human-readable title for the job. If none is given, it will attempt to
   *  obtain this from the message, if the message type given supports it.
   * @param int $mode
   *  Mode for the job. Valid values are:
   *    WILDFIRE_JOB_MODE_NORMAL
   *    WILDFIRE_JOB_MODE_TEST
   *  Default if unspecified is WILDFIRE_JOB_MODE_NORMAL
   *
   * @return int
   *  The job ID the job was created, else FALSE
   */
  public function newJob($template, $lid, $type, $extra, $sendtime = 0, $title = '', $mode = WILDFIRE_JOB_MODE_NORMAL) {

    global $user;

    $this->dbrow = array(
      'template' => $template,
      'uid' => $user->uid,
      'lid' => $lid,
      'type' => $type,
      'extra' => $extra,
      'started' => 0,
      'scheduled' => $sendtime > 0 ? $sendtime : REQUEST_TIME,
      'completed' => 0,
      'count' => 0,
      'status' => WILDFIRE_JOB_PENDING,
      'processed_count' => 0,
      'processor' => 'remote',
      'title' => '',
      'mode' => $mode,
    );

    // Fill in the title, or obtain it from the corresponding message object.
    if (!empty($title)) {
      $this->dbrow['title'] = $title;
    }
    else {
      // Get the subject if one was not specified.

      $message = WildfireClientMessage::getMessageObject($this->dbrow['type']);
      $message->load($this->dbrow['extra']);
      $this->dbrow['title'] = $message->getTitle();
    }

    $job_saved = $this->save();

    return $job_saved;

  }

  /**
   * Prepares the job content table by rendering the message, performing all
   * link aliasing, and storing the serialized content into the job content
   * table.
   *
   * This basically snapshots the state of the message at the time of
   * job creation, meaning subsequent processing on the job is a simple read
   * rather than a recalculation / retokenization every time.
   */
  public function newContent() {

    // Include the Messages and Tokens APIs
    module_load_include('inc', 'wildfire_broadcasts', 'wildfire_broadcasts.api');

    // Prepare and render the template as the 'parent' content.
    $this->message = WildfireClientMessage::getMessageObject($this->dbrow['type']);
    $this->message->load($this->dbrow['extra']);

    // Render the message
    $this->message->render();

    /**
     * If the job is not a test, add tracking links to the content before
     * we send it to the server. You could alias links for a test job if you
     * want, and this will theoretically allow you to track click throughs and
     * opens within a test send job.
     *
     * In most cases this isn't desired though, as it's a bit pointless to
     * store tracking info for a job sent to only a bunch of 'fake' recipients.
     */
    if ($this->mode == WILDFIRE_JOB_MODE_NORMAL) {
      // Alias any links to prepare the message for use in the job
      $this->message->addTrackingToLinks($this->dbrow['jid']);

      // Add the tracking image to prepare the message for use in the job
      $this->message->addTrackingImage($this->dbrow['jid']);
    }

    /**
     * Tokenize the message, then obtain the fragments for upload and the
     * tokens required to build the message. The tokens list is used when
     * building the job users list to determine if we need to get any custom
     * fields that the end user has provided as custom tokens in the message
     * content.
     */
    $this->message->tokenizeContent();

    // Store the tokens we've parsed.
    $this->addToTokenList($this->message->getTokenList());

    $record = array(
      'jid' => $this->dbrow['jid'],
      'delta' => 0,
      'type' => 'parent',
      'content' => $this->message->getTokenizedContent(),
      'token_list' => $this->message->getTokenList(),
      'uploaded' => WILDFIRE_JOB_PART_PENDING,
    );

    drupal_write_record('wildfire_job_content', $record);

    /**
     * If the token indicate that there are other content chunks to create for
     * the job, do that here.
     *
     * TODO: LATER PHASE: Child content chunks are to be implemented in a later
     * phase
     */

  }

  /**
   * Prepare the jobs mails table by copying the current entries from the
   * list associated with the job.
   *
   * Essentially, the "wildfire_jobs_mails" table is a representation of the
   * users that will receive an email in the job run. If the list from which
   * the job was derived changes in the meantime, the job recipients remain
   * unaffected. This table also allows us to store unsubscribe tokens and
   * other metadata relating to the progress of a particular send to this
   * user on this job.
   *
   * @param int $start
   *  Where to start processing in the list. Defaults to 0. If set to -1,
   *  all records will be processed in one go.
   * @param int $limit
   *  The number to process in this batch. Ignored if start is -1.
   *
   * @return int
   *  The number of Job mails actually created
   */
  public function newJobMails($start = 0, $limit = 10) {

    $created_count = 0;

    /**
     * Uses Lists API, so let's load it!
     */
    module_load_include('inc', 'wildfire_lists', 'wildfire_lists.api');

    // Select the next batch of users from the list, but only where they
    // haven't opted-out and are locked.
    $query = db_select('wildfire_lists_users', 'wlu')
      ->fields('wlu', array(
      'uid',
      'mail',
    ));
    $query->condition('wlu.lid', $this->dbrow['lid'], '=');
    /**
     * This will get the next batch of addresses from the source list that are
     * WILDFIRE_LIST_USER_LOCKED or WILDFIRE_LIST_USER_PENDING_REMOVAL.
     * The latter case is a flag denoting that the user was in the list at the
     * time the list was locked, but has changed status whilst the list is
     * being processed.
     *
     * So they WERE a user that is supposed to get this job when the job was
     * initiated but WON'T be in the list after this final email is sent to
     * them. We do this to ensure that the initial hash / counts we calculated
     * are not broken by an unsubscribe occurring whilst a job is still in the
     * build stage.
     */
    $query->condition('wlu.locked', array(
      WILDFIRE_LIST_USER_LOCKED,
      WILDFIRE_LIST_USER_PENDING_REMOVAL,
    ), 'IN');
    $query->leftJoin('wildfire_optouts', 'wo', 'wlu.uid = wo.uid');
    $query->where('wo.timestamp IS NULL');
    if ($start !== -1) {
      $query->range($start, $limit);
    }
    $result = $query->execute();

    while($row = $result->fetchAssoc()) {

      /**
       * Check that the email address for the list entry is actually valid.
       * Skip the user if this key field is not correct
       *
       * We use a direct table lookup here to avoid loading the entire user
       * entity just to verify this one thing.
       */
      if (!empty($row['uid'])) {
        // The row has a UID, obtain the email address from it
        $query = db_select('users', 'u')
          ->fields('u', array(
            'mail'
        ));
        $query->condition('uid', $row['uid'], '=');
        $email = $query->execute()->fetchField(0);
      }
      else {
        // The row doesn't have a UID so is an anon entry; use the raw email
        // address from the table directly
        $email = $row['mail'];
      }

      if (wildfire_valid_email_address($email)) {

        /**
         * Do the initial save, so that we store a consistent user token.
         *
         * As there can be any number of token replacements defined by any
         * number of modules, we need the users UID token to be consistent
         * if it's used within the built token replacement. For example,
         * wildfire_jobs_wildfire_token() uses the users UID token to build
         * the unsubscribe and browserview links.
         */
        $record = array(
          'jid' => $this->dbrow['jid'],
          'uid' => $row['uid'],
          'mail' => $email,
          'metadata' => array(
            'tokens' => array(
              'wildfire:email' => $email
            ),
            'chunk_map' => array()
          ),
          'processed' => 0,
          'token' => wildfire_random_string(WILDFIRE_UNSUBSCRIBE_LENGTH),
          'uploaded' => WILDFIRE_JOB_PART_PENDING,
        );

        if (drupal_write_record('wildfire_job_mails', $record) !== FALSE) {

          $created_count++;

        }
        else {

          watchdog(
            'wildfire_jobs',
            'Failed to add Job Mail for address "!mail" - drupal_write_record() returned FALSE ($record = !record)',
            array(
              '!mail' => $email,
              '!record' => print_r($record, TRUE),
            ),
            WATCHDOG_WARNING
          );

        }

        /**
         * Get any user-specific token replacements and chunk mappings.
         * This is skipped for addresses not associated with a drupal user
         * account, as there won't be any token replacements for them bar
         * 'mail', which is already covered.
         *
         * TODO: Not calling getUserWithTokens() is safe for test sends, but
         * for live sends where unsubscribe tokens, etc, need to be filled in,
         * this will not work. To be revised when it becomes possible to send
         * live sends to addresses not associated with a drupal user account.
         *
         * See Codebase Ticket #145.
         */
        if (!empty($row['uid'])) {
          $user = $this->getUserWithTokens($row['uid']);
          if (!empty($user)) {
            $update = array(
              'jid' => $this->dbrow['jid'],
              'uid' => $row['uid'],
              'mail' => $user['mail'],
              'metadata' => $user['metadata'],
            );
            drupal_write_record('wildfire_job_mails', $update, array('jid', 'uid'));
          }
        }

        // Unlock the source user record, as we have finished with it.
        wildfire_list_user_unlock(
          $this->dbrow['lid'],
          $row['uid']
        );

      }
      else {

        // Watchdog the failed address for later reference.
        watchdog(
          'wildfire_jobs',
          'Failed to add Job Mail for address "!mail" - address is malformed',
          array(
            '!mail' => $email,
          ),
          WATCHDOG_WARNING
        );

        if (!empty($row['uid'])) {
          // Unlock the source user record, as we have finished with it.
          wildfire_list_user_unlock(
            $this->dbrow['lid'],
            $row['uid']
          );
        }

      }

    }

    return $created_count;

  }

  /**
   * Saves the object state to the database
   *
   * If the Job ID in $this->dbrow['jid'] is already present, this performs
   * an update to an existing job. Else, it creates a new database record for
   * this job.
   *
   * @throws BadMethodCallException
   *  If you try to save a job that's marked as a pseudo job.
   *
   * @return int
   *  SAVED_NEW / SAVED_UPDATE on success, FALSE on failure
   */
  public function save() {

    if (!empty($this->dbrow['pseudo_job'])) {
      throw new BadMethodCallException(t('Cannot save a pseudo job'));
    }

    return drupal_write_record(
      'wildfire_jobs',
      $this->dbrow,
      !empty($this->dbrow['jid']) ? 'jid' : array()
    );

  }

  /**
   * Sets the status of the job.
   *
   * @throws InvalidArgumentException
   *  If the requested status is not a valid status ID
   *
   * @throws BadMethodCallException
   *  - If the job has not been loaded
   *  - If a status that cannot be changed to from the current status is
   *    requested
   *
   * @param int $req_status
   *  Status to set on the job
   */
  public function setStatus($req_status) {

    if (!isset($this->dbrow['status'])) {
      throw new BadMethodCallException(
        t('Cannot change status for a job that has not been loaded')
      );
    }

    // Check that the new status can be set from the present status
    switch($req_status) {
      case WILDFIRE_JOB_PENDING:
        $valid_from = array();
      break;
      case WILDFIRE_JOB_PAUSED:
        $valid_from = array(
          WILDFIRE_JOB_PROCESSING,
          WILDFIRE_JOB_PREPARING,
          WILDFIRE_JOB_PREPARED,
        );
      break;
      case WILDFIRE_JOB_CANCELLED:
        $valid_from = array(
          WILDFIRE_JOB_PENDING,
          WILDFIRE_JOB_PREPARING,
          WILDFIRE_JOB_PREPARED,
        );
      break;
      case WILDFIRE_JOB_PROCESSING:
        $valid_from = array(
          WILDFIRE_JOB_PENDING,
          WILDFIRE_JOB_PAUSED,
          WILDFIRE_JOB_PREPARING,
          WILDFIRE_JOB_PREPARED,
        );
      break;
      case WILDFIRE_JOB_COMPLETE:
        $valid_from = array(
          WILDFIRE_JOB_PENDING,
          WILDFIRE_JOB_PAUSED,
          WILDFIRE_JOB_CANCELLED,
          WILDFIRE_JOB_PROCESSING,
          WILDFIRE_JOB_COMPLETE,
          WILDFIRE_JOB_FAILED,
          WILDFIRE_JOB_PREPARING,
        );
      break;
      case WILDFIRE_JOB_FAILED:
        $valid_from = array(
          WILDFIRE_JOB_PENDING,
          WILDFIRE_JOB_PAUSED,
          WILDFIRE_JOB_CANCELLED,
          WILDFIRE_JOB_PROCESSING,
          WILDFIRE_JOB_COMPLETE,
          WILDFIRE_JOB_FAILED,
          WILDFIRE_JOB_PREPARING,
        );
      break;
      case WILDFIRE_JOB_PREPARING:
        $valid_from = array(
          WILDFIRE_JOB_PENDING,
          WILDFIRE_JOB_PAUSED,
        );
      break;
      case WILDFIRE_JOB_PREPARED:
        $valid_from = array(
          WILDFIRE_JOB_PENDING,
          WILDFIRE_JOB_PREPARING,
          WILDFIRE_JOB_PAUSED,
        );
      break;
      default:
        throw new InvalidArgumentException(
          t(
            'Requested status #!status does not correspond to a valid status',
            array(
              '!status' => $req_status
            )
          )
        );
      break;
    }

    // If the status change is not valid, throw an exception.
    if (!in_array($this->dbrow['status'], $valid_from)) {
      throw new BadMethodCallException(
        t(
          'Changing a jobs status from #!from to #!to is not valid',
          array(
            '!from' => $this->dbrow['status'],
            '!to' => $req_status
          )
        )
      );
    }
    // Set the new status
    $this->dbrow['status'] = $req_status;
    $this->save();

  }

  /**
   * Get the count of the number of content chunks currently waiting to be
   * uploaded
   *
   * @return mixed
   *  Returns the number of content chunks on the job, or FALSE on failure.
   */
  public function getContentPendingCount() {

    return $this->getContentCount(TRUE);

  }


  /**
   * Obtains the count of the content on the job
   *
   * @param bool $pending
   *  Set to TRUE to filter the count to only entries that are pending upload.
   *  Defaults to FALSE
   *
   * @return mixed
   *  Returns the number of content chunks on the job, or FALSE on failure.
   */
  public function getContentCount($pending = FALSE) {

    $query = db_select('wildfire_job_content', 'wjm');
    $query->addExpression('COUNT(1)', 'c');
    $query->condition('wjm.jid', $this->dbrow['jid'], '=');
    if ($pending) {
      $query->condition('uploaded', WILDFIRE_JOB_PART_PENDING, '=');
    }
    $result = $query->execute()->fetchField(0);

    return $result;

  }

  /**
   * Get the count of the number of list entries currently waiting to be
   * uploaded
   *
   * @return mixed
   *  Returns the number of entries in the list, or FALSE on failure.
   */
  public function getListUsersPendingCount() {

    return $this->getListUsersCount(TRUE);

  }

  /**
   * Obtains the count of users in the jobs mails table.
   *
   * At this stage, it should only contain valid entries, as any bad entries
   * should have been filtered out upon list creation.
   *
   * @param bool $pending
   *  Set to TRUE to filter the count to only entries that are pending upload.
   *  Defaults to FALSE
   *
   * @return mixed
   *  Returns the number of entries in the list, or FALSE on failure.
   */
  public function getListUsersCount($pending = FALSE) {

    $query = db_select('wildfire_job_mails', 'wjm');
    $query->addExpression('COUNT(1)', 'c');
    $query->leftJoin('users', 'u', 'u.uid=wjm.uid');
    $query->condition('wjm.jid', $this->dbrow['jid'], '=');
    $query->where('u.mail IS NOT NULL');
    if ($pending) {
      $query->condition('uploaded', WILDFIRE_JOB_PART_PENDING, '=');
    }
    $result = $query->execute()->fetchField(0);

    return $result;
  }

}

