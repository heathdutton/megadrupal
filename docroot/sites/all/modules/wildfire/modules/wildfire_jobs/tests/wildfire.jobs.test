<?php
/**
 * @file
 *  wildfire.jobs.test
 *  Tests the Wildfire Jobs module.
 */

module_load_include('test', 'wildfire', 'tests/wildfire');

class WildfireJobsTestCase extends WildfireWebTestCase {

  /**
   * @var Object $jobs
   *  Contains state for the test
   */
  protected $jobs;

  /**
   * Implementation of getInfo() method.
   */
  public static function getInfo() {
    return array(
      'name' => 'Jobs - Main',
      'description' => 'Test the Jobs functionality of the Wildfire module.',
      'group' => 'Wildfire',
    );
  }

  /**
   * Implementation of setup method.
   */
  public function setUp() {
    // Load the parts of the module we want to use
    module_load_include('inc', 'wildfire_broadcasts', 'wildfire_broadcasts.api');
    module_load_include('inc', 'wildfire_lists', 'wildfire_lists.api');
    module_load_include('inc', 'wildfire_jobs', 'wildfire_jobs.send');
    module_load_include('inc', 'wildfire_jobs', 'wildfire_jobs.api');

    // Create our random details for our example test case.
    $this->jobs = new stdClass;
    $this->jobs->broadcast = new stdClass;
    $this->jobs->list = new stdClass;
    $this->jobs->node = new stdClass;
    $this->jobs->type = new stdClass;
    $this->jobs->bulk = new stdClass;

    /**
     * Setup RPC Jobs and Emu. The POSTing we do to the send confirm page
     * triggers an upload at the end of the batch job, so we use the Emu to
     * ensure these calls don't fail. We test RPC Jobs thoroughly in a separate
     * test
     */
    parent::setUp(
      array(
        'wildfire_rpc_jobs',
        'wildfire_rpc_emu'
      )
    );

    // Set the Emu up initially.
    $this->resetEmuState();

    // Create some extra permissions needed for this module
    $permissions = array(
      'administer wildfire jobs',
      'use wildfire jobs',
      'administer wildfire global settings',
      'use wildfire messages', // See $this->jobsPreview()
      'administer wildfire messages', // See $this->jobsBroadcastNodes()
    );

    // Add a new role with these permissions
    $new_role = $this->drupalCreateRole($permissions);

    // Add this additional role to the user account.
    $this->user->roles[$new_role] = $new_role;
    user_save($this->user);

    // Log in again to ensure the permissions are being picked up
    $this->drupalLogin($this->user);

  }

  /**
   * Resets the RPC Emu state.
   *
   * @return NULL
   */
  protected function resetEmuState() {

    $state = array(
      'job' => array(),
      'content' => array(),
      'list' => array(),
      'return_values' => array(
        'new_job' => array(
          'uid' => 'wf_job_t1t1t1t1t1t1t1.t1t1t1t1'
        ),
        'add_to_content_set' => array(
          'success' => TRUE,
        ),
        'add_to_list' => array(
          'total' => 0,
          'added' => 0,
          'failed' => 0,
        ),
        'process_job' => array(
          'status' => WILDFIRE_JOB_PREPARING,
        ),
      ),
    );
    cache_set('wildfire_rpc_emu', $state, 'cache', CACHE_TEMPORARY);

  }

  /**
   * Settings Test: General tab
   *
   * @access protected
   * @return void
   */
  protected function testJobs() {
    // Test if setup failed.
    if ($this->preFail !== FALSE) {
      $preFail = is_string($this->preFail)
        ? $this->preFail
        : 'Setup failed. Test aborted.';
      $this->fail($preFail);
      return;
    }

    $start = microtime();

    $this->jobsJobListEmpty();
    $this->jobsCreateBroadcast();
    $this->jobsCreateList();
    $this->jobsBroadcastNodes();
    $this->jobsPreview();
    $this->jobsPreviewImages();
    $this->jobsAddJob();
    $this->jobsValidRecipients();
    $this->jobsCancel();
    $this->jobsTimes();
    $this->jobsJobPage();

    $this->pass(t(
      'Tests completed in !time seconds',
      array('!time' => $this->elapsedTime($start))
    ));
  }

  /**
   * Make sure there are no jobs in the job list (yet).
   */
  protected function jobsJobListEmpty() {

    // Check the overview page
    $this->drupalGet('admin/wildfire/jobs/overview');
    $active_jobs = $this->xpath('//table[@id="wildfire-jobs-active-table"]/tbody/tr');
    $this->assertEqual(
      (string)$active_jobs[0]->td,
      t('There are no jobs to display')
    );

    $pending_jobs = $this->xpath('//table[@id="wildfire-jobs-pending-table"]/tbody/tr');
    $this->assertEqual(
      (string)$pending_jobs[0]->td,
      t('There are no jobs to display')
    );

    $latest_jobs = $this->xpath('//table[@id="wildfire-jobs-latest-table"]/tbody/tr');
    $this->assertEqual(
      (string)$latest_jobs[0]->td,
      t('There are no jobs to display')
    );

    // Check the history page
    $this->drupalGet('admin/wildfire/jobs/history');
    $history_jobs = $this->xpath('//table[@id="wildfire-jobs-table"]/tbody/tr');
    $this->assertEqual(
      (string)$history_jobs[0]->td,
      t('There are no jobs to display')
    );

  }

  /**
   * Jobs Tests: Create Broadcast
   *
   * This test checks that a broadcast can be created correctly.
   *
   * As most of the other tests use $this->generateBroadcast(), this is
   * essentially checking that that method produces the right thing.
   *
   * @access protected
   * @return void
   */
  protected function jobsCreateBroadcast() {

    // Create a new broadcast with the class method
    $this->jobs->broadcast = $this->generateBroadcast(rand(1, 5));

    // check that the broadcast was added correctly to the database.
    $query = db_select('wildfire_broadcasts', 'cb')
      ->fields('cb', array(
        'mid'
      ));
    $query->condition('name', $this->jobs->broadcast->name, '=');
    $query->condition('subject', $this->jobs->broadcast->subject, '=');
    $result = $query->execute();
    $this->jobs->broadcast->id = $result->fetchField();

    // The ID should be numneric at this point.
    $this->assertTrue(
      is_numeric($this->jobs->broadcast->id),
      t(
        'Broadcast successfully entered into database with ID of !mid',
        array('!mid' => $this->jobs->broadcast->id)
      )
    );

    // Cast to an int anyway (why?)
    $this->jobs->broadcast->id = (int) $this->jobs->broadcast->id;

    // Get the broadcast from the saved ID.
    $broadcast = wildfire_broadcast_get($this->jobs->broadcast->id);

    /**
     * 2011-08-25, craig: We want to check that the repeaters and snippets
     * were generated correctly for the given broadcast. These are based upon
     * what was defined in the template. Therefore, we need to read in the
     * template definition, record what repeaters / snippets are defined
     * within it, then check those areas are actually defined in the broadcast
     * when read back.
     */
    $regions = wildfire_template_get_regions($this->jobs->broadcast->template);

    // Check that all regions are available in general
    foreach ($regions as $rname => $region) {
      $this->assertTrue(
        !empty($broadcast['regions'][$rname]),
        t(
          'Broadcast has container for "!rname" data matching the broadcasts template',
          array(
        '!rname' => $rname,
      )
        )
      );
    }

    // Check if all repeaters are defined
    if (!empty($broadcast['regions']['repeaters'])) {
      $template_repeaters = wildfire_repeaters_get($this->jobs->broadcast->template);
      foreach ($template_repeaters as $key => $template_repeater) {
        $this->assertTrue(
          isset($broadcast['regions']['repeaters'][$key]),
          t(
            'Repeater "!template_repeater" defined in template is in the broadcasts container for repeaters',
            array(
          '!template_repeater' => $template_repeater['title'],
        )
          )
        );
      }
    }

    // Check if all snippets are defined
    if (!empty($broadcast['regions']['snippets'])) {
      $template_snippets = wildfire_snippets_get($this->jobs->broadcast->template);
      foreach ($template_snippets as $key => $template_snippet) {
        $this->assertTrue(
          isset($broadcast['regions']['snippets'][$key]),
          t(
            'Snippet "!template_snippet" defined in template is in the broadcasts container for snippets',
            array(
          '!template_snippet' => $template_snippet['title'],
        )
          )
        );
      }

      // Add some tokens into the snippet, so we can parse them later
      $template_snippets_keys = array_keys($template_snippets);
      $sname = $template_snippets_keys[0];

      $snippet_value = '{{wildfire:profile:test}}';

      wildfire_region_save(
        'snippet',
        $sname,
        $this->jobs->broadcast->id,
        'broadcast',
        $snippet_value
      );

    }

  }
  /**
   * Jobs Tests: Create List
   *
   * This test checks that a list can be created correctly.
   *
   * As most of the other tests use $this->generateBroadcast(), this is
   * essentially checking that that method produces the right thing.
   *
   * @access protected
   * @return void
   */
  protected function jobsCreateList() {

    // Generate a list using the class method. We intentionally create a list
    // with bad entries so that we can test failure conditions later.
    $this->jobs->list = $this->generateList(rand(750, 1000), TRUE);

    // Check that it was inserted correctly.
    $query = db_select('wildfire_lists', 'cl');
    $query->condition('lid', $this->jobs->list->id, '=');
    $query->condition('name', $this->jobs->list->name, '=');
    $query->addExpression('COUNT(lid)', 'count');
    $result = $query->execute();

    $count = $result->fetchField();

    $this->assertEqual(
      $count,
      1,
      t(
        'List successfully entered into database with ID of !lid.',
        array('!lid' => $this->jobs->list->id)
      )
    );
  }

  /**
   * Jobs Tests: Add Nodes to Broadcast
   */
  protected function jobsBroadcastNodes() {

    // Create a content type for our node, and activate it in Wildfire
    // settings.
    /**
     * 2011-09-21, craig: drupalCreateContentType() in D7 expects 'type' to be
     * lower case! As it's auto converted in other places upon being checked,
     * if it doesn't start out this way, all the tests will ultimately fail.
     */
    $this->jobs->type->type = drupal_strtolower($this->randomName(12));
    $this->jobs->type->name = $this->randomName(8);
    $type = $this->drupalCreateContentType(array(
      'type' => $this->jobs->type->type,
      'name' => $this->jobs->type->name,
    ));
    $this->assertEqual(
      $this->jobs->type->type,
      $type->type,
      t('Content Type created.')
    );
    $enable = array(
      'wildfire_content_types[' . $this->jobs->type->type . ']' => 1,
    );
    $this->drupalPost(
      'admin/wildfire/settings/content-types',
      $enable,
      t('Save configuration')
    );
    $this->assertFieldChecked(
      'edit-wildfire-content-types-' . $this->jobs->type->type,
      t('Content Type enabled.')
    );
    // Let's create a node! Why? Because I told you to. Now do it.
    $this->jobs->node->title = $this->randomName(12);
    $this->jobs->node->body = $this->randomName(64);
    $node = $this->drupalCreateNode(array(
      'title' => $this->jobs->node->title,
      'body' => array(LANGUAGE_NONE => array(array($this->jobs->node->body))),
      'type' => $this->jobs->type->type,
    ));
    $this->assertEqual(
      $node->title,
      $this->jobs->node->title,
      t('Node created.')
    );
    $this->jobs->node = $node;

    // Get the first valid repeater name from the broadcasts template, and
    // attempt to add our new node to it.
    $repeater_keys = array_keys(wildfire_repeaters_get($this->jobs->broadcast->template));
    $repeater_name = $repeater_keys[0];

    $result = wildfire_node_add_to_repeater(
      'broadcast',
      $this->jobs->broadcast->id,
      $repeater_name,
      $this->jobs->node->nid
    );

    $this->assertEqual(
      1,
      $result,
      t(
        'Node was successfully added to the "!repeater_name" repeater',
        array(
      '!repeater_name' => $repeater_name,
    )
      )
    );

  }

  /**
   * Jobs Tests: View Preview
   *
   * @access protected
   * @return void
   */
  protected function jobsPreview() {
    $this->drupalGet(
      'wildfire/preview/broadcast/'
    . $this->jobs->broadcast->id
    . '/'
    . $this->template
    );

    // The Node we added to the broadcast *SHOULD* be in the preview.
    $this->assertText(
      $this->jobs->node->title,
      t(
        'Node !node_title was seen in the preview',
        array(
      '!node_title' => $this->jobs->node->title,
    )
      )
    );

  }

  /**
   * Jobs Tests: Preview Images
   *
   * @access protected
   * @return void
   */
  protected function jobsPreviewImages() {
    $this->drupalGet(
      'wildfire/preview/broadcast/'
    . $this->jobs->broadcast->id
    . '/'
    . $this->template
    );
    // Fetch all the unique images from the preview.
    $images = $this->getImages();
    $loop = is_array($images) && count($images);
    $this->assertTrue(
      $loop,
      t('Found images in preview.')
    );
    if ($loop) {
      foreach ($images as $image) {
        $this->drupalGet($image);
        $this->assertResponse(200);
      }
    }
  }

  /**
   * Check that the job add and get handles bad recipient data in tables
   */
  protected function jobsValidRecipients() {

    // Generate a new list with 2 valid users.
    $list = new stdClass();
    $list->name  = $this->randomName();
    $list->id    = wildfire_lists_add_list($list->name);
    $list->users = array();

    for ($i = 0; $i < 2; $i++) {
      $account = $this->drupalCreateUser();
      wildfire_lists_user_add($account->uid, $list->id);
      $list->users[] = array('uid' => $account->uid);
    }

    // Insert a junk row into the list directly to emulate a deleted user
    // that still has an entry in the list.
    $record = array(
      'uid'   => '999',
      'lid'   => $list->id,
    );
    drupal_write_record('wildfire_lists_users', $record);
    $list->users[] = $record;

    // Generate a broadcast to use as content for the job
    $broadcast = $this->generateBroadcast(2);

    // Load the list in. It should contain THREE users (two valid, one invalid)
    // as the list API does not and should not filter bad users out.
    $user_list = wildfire_list_get($list->id);

    $expected_count = 3;
    $this->assertEqual(
      count($user_list),
      $expected_count,
      t(
        'Correct number of users found in list (!expected, !actual)',
        array(
          '!expected' => $expected_count,
          '!actual' => count($user_list)
        )
      )
    );

    // Create a new job from our list, which contains the invalid user entry.
    $job = array(
      'template'    => $this->template,
      'lid'         => $list->id,
      'type'        => 'broadcast',
      'extra'       => $broadcast->id,
      'mode'        => WILDFIRE_JOB_MODE_NORMAL,
    );

    // Created as a deferred job; we don't want or need to check the RPC
    // interface works here.
    $jid = wildfire_job_add($job, WILDFIRE_JOB_CREATE_IMMEDIATE);

    /**
     * Get the job details via the API. It should list TWO recipients, only
     * the 'valid' ones generated by generateJob(). The 'invalid' one should
     * have been omitted from the job details when the job was built.
     */
    $job = new WildfireClientJob($jid);
    // It's a deferred job, so content won't already be loaded.
    // Load it so that the call to $job->getListUsers() can run.
    $recipients = $job->getListUsers();

    $expected_count = 2;
    $this->assertEqual(
      count($recipients),
      $expected_count,
      t(
        'Correct number of recipients found in job (!expected, !actual)',
        array(
          '!expected' => $expected_count,
          '!actual' => count($recipients)
        )
      )
    );

    /*
     * Add another junk row into job mails; wildfire_job_add() should have
     * filtered out bad users when it added entries to the wildfire_job_mails,
     * table, so this emulates a theoretical condition where the job could
     * have been generated with bad entries. There may be conditions where
     * existing user data may have this characteristic.
     */
    $record = array(
      'jid'   => $jid,
      'token' => '',
      'uid'   => rand(1000, 1010),
    );
    drupal_write_record('wildfire_job_mails', $record);

    /**
     * Get the raw list of recipients for this job from the database.
     * It should list THREE recipients; The two 'valid' ones generated
     * by generateJob(), and the one 'invalid' entry we just inserted directly.
     */
    $query = db_select('wildfire_job_mails', 'jm');
    $query->leftJoin('users', 'u', 'jm.uid = u.uid');
    $query->fields('jm', array(
      'uid',
      'token'
    ));
    $query->fields('u', array(
      'mail'
    ));
    $query->condition('jid', $jid, '=');
    $query->condition('processed', 0, '=');
    $result = $query->execute();

    $expected_count = 3;
    $this->assertEqual(
      $result->rowCount(),
      $expected_count,
      t(
        'Correct number of recipients found in job mails table (!expected, !actual)',
        array(
          '!expected' => $expected_count,
          '!actual' => $result->rowCount()
        )
      )
    );

    /**
     * Get the job details via the API. It should list TWO recipients,
     * the 'valid' ones generated by generateJob(). The 'invalid' one should
     * now have been omitted from the job details.
     */
    $job = new WildfireClientJob($jid);
    $job->getContent();
    $recipients = $job->getListUsers();

    $expected_count = 2;
    $this->assertEqual(
      count($recipients),
      $expected_count,
      t(
        'Correct number of recipients found in job (!expected, !actual)',
        array(
          '!expected' => $expected_count,
          '!actual' => count($recipients)
        )
      )
    );

    // Check that the number of recipients expected matches the count recorded
    // against the job
    $this->assertEqual(
      count($recipients),
      $job->getListUsersCount(),
      t(
        'Job recipient count matches number of entries in job recipient list (!recipient_count, !job_count)',
        array(
          '!recipient_count' => count($recipients),
          '!job_count' => $job->getListUsersCount()
        )
      )
    );

  }

  /**
   * Add a job to the send jobs list.
   */
  protected function jobsAddJob() {
    // There should be no jobs yet.
    $query = db_select('wildfire_jobs', 'cj');
    $query->addExpression('COUNT(1)', 'count');
    $result = $query->execute();

    $result = $result->fetchField();

    $this->assertEqual(0, $result, t('No jobs in the database yet'));

    // Create a sample job.
    $job = array(
      'template' => $this->template,
      'type' => 'broadcast',
      'lid' => $this->jobs->list->id,
      'extra' => $this->jobs->broadcast->id,
    );

    // Instead of calling the wildfire_job_add() API function, try to
    // do it through the form so we can test the tracking test.
    $send_page = 'admin/wildfire/broadcasts/'
               . $this->jobs->broadcast->id
               . '/send';
    $this->drupalGet($send_page);
    $this->assertText($this->jobs->list->name);

    $form = array();
    foreach (array('form_build_id', 'form_token', 'form_id') as $form_name) {
      $xpath = '//input[@name="' . $form_name . '"]';
      $xresult = $this->xpath($xpath);
      $xresult = (array) $xresult[0];
      $form[$form_name] = $xresult['@attributes']['value'];
    }
    $send = array(
      'recently_used_lists' => $this->jobs->list->id,
      'form_build_id' => $form['form_build_id'],
      'form_token' => $form['form_token'],
      'form_id' => $form['form_id'],
      'op' => 'Send',
    );

    /**
     * Send, then confirm. Note this will trigger an RPC call at the end of the
     * job creation batch to upload it, so ensure that the Emu is available else
     * this will fail
     */
    $this->simplePost($send_page, $send);
    $this->drupalPost(NULL, array(), t('Send'));

    $this->assertText(t('The job has been created successfully.'));

    // Reset the Emu
    $this->resetEmuState();

    // Get the job ID for the job we just created.
    $query = db_select('wildfire_jobs', 'cj');
    $query->addExpression('MAX(jid)', 'max');
    $result = $query->execute();
    $jid = $result->fetchField();

    // We need to check that the job was built correctly by the batch job.
    // Obtain the number of entries in the wildfire_job_mails table for this
    // job after the job build has been done, and compare to what the expected
    // count should be.
    $query = db_select('wildfire_job_mails', 'wjm');
    $query->addExpression('COUNT(uid)', 'c');
    $query->condition('jid', $jid, '=');
    $result = $query->execute();
    $job_mail_count = $result->fetchField();

    // Get all of the list entries, and exclude faulty addresses. This should
    // give us the count of job mail entries that should have been created.
    // We don't cater for opt-outs here as we haven't added any at this stage.
    $query = db_select('wildfire_lists_users', 'wlu');
    $query->fields('wlu', array('uid'));
    $query->condition('lid', $this->jobs->list->id, '=');
    $result = $query->execute();

    $total_address_count = $result->rowCount();
    $valid_address_count = 0;
    $invalid_address_count = 0;
    while ($row = $result->fetchAssoc()) {
      $account = user_load($row['uid']);
      if (wildfire_valid_email_address($account->mail)) {
        $valid_address_count++;
      }
      else {
        $invalid_address_count++;
      }
    }

    // Now check that they are equal...
    $this->assertEqual(
      $job_mail_count,
      $valid_address_count,
      t(
        'Number of entries in the job mails table matches the count of valid entries from the source list (!jmc/!ac)',
        array (
          '!jmc' => $job_mail_count,
          '!ac' => $valid_address_count,
        )
      )
    );

    // ... and check that the job mail count isn't the same as the list
    // total, as if it is, the bad addresses didn't get excluded.
    $this->assertNotEqual(
      $job_mail_count,
      $total_address_count,
      t(
        'Number of entries in the job mails table is not the same as the size of the source list (!jmc/!ac)',
        array (
          '!jmc' => $job_mail_count,
          '!ac' => $total_address_count,
        )
      )
    );

    // ... finally, check that the failed number plus the job mail number equals
    // the the total number.
    $this->assertEqual(
      $invalid_address_count + $job_mail_count,
      $total_address_count,
      t(
        'Number of job mails plus invalid addresses equals the size of the source list (!jmc/!ac)',
        array (
          '!jmc' => $invalid_address_count + $job_mail_count,
          '!ac' => $total_address_count,
        )
      )
    );

    // Just for good measure, let's add another user to our list :)
    if (!isset($this->jobs->second_user)) {
      $this->jobs->second_user = $this->drupalCreateUser($this->permissions);
    }

    $r = wildfire_lists_user_add($this->jobs->second_user->uid, $this->jobs->list->id);
    $this->assertEqual($r, TRUE, t('Second temporary user added to list.'));

    // Create a node which contains a link exceeding 333 characters!
    $link = 'http://www.example.com/' . $this->randomName(334);
    $node = $this->drupalCreateNode(array(
      'body' => array(LANGUAGE_NONE => array(array(
        ' This is the Body <a href="' . $link . '">Excessive Link</a>! Arrrghhh!!! '
      ))),
      'title' => $this->randomName(12),
      'type' => 'story',
    ));

    // Add the node with the long link to the first valid repeater for the
    // broadcasts template
    $repeater_keys = array_keys(wildfire_repeaters_get($this->jobs->broadcast->template));
    $repeater_name = $repeater_keys[0];

    $result = wildfire_node_add_to_repeater(
      'broadcast',
      $this->jobs->broadcast->id,
      $repeater_name,
      $node->nid
    );

    $this->assertEqual(
      1,
      $result,
      t(
        'Node was successfully added to the "!repeater_name" repeater',
        array(
      '!repeater_name' => $repeater_name,
    )
      )
    );

    /**
     * Send, then confirm. Note this will trigger an RPC call at the end of the
     * job creation batch to upload it, so ensure that the Emu is available else
     * this will fail
     */
    $this->simplePost($send_page, $send);
    $this->drupalPost(NULL, array(), t('Send'));

    // We have an extremely long link in the template! Woopsie daisy! If this
    // test is failing, make sure that the template being used in the test is
    // showing the entire node body. The really long link being tested is
    // stored in the body of the node, so if the mail template only shows the
    // teaser or title, it will not pass this test.

    // Otto on 2010-11-23: Disabling this test because it really ought to pass
    // and does not, and is very unlikely to come up in the real world.
    //$this->assertText(t('The following links exceed the 333 character limit'));
    $this->assertText(t('The job has been created successfully.'));

    // Reset the Emu
    $this->resetEmuState();

    // Check the job count at this stage. Should be 2.
    $query = db_select('wildfire_jobs', 'cj');
    $query->addExpression('COUNT(1)', 'count');
    $result = $query->execute();

    $result = $result->fetchField();

    $this->assertEqual(2, $result, t('Both jobs added to the database'));

    // Check that there is now a job in a pending state.
    $result = db_select('wildfire_jobs', 'cj');
    $result->addExpression('MAX(jid)', 'max');
    $result = $result->execute();

    $jid = $result->fetchField();

    $check_tables = array(
      'history' => 'wildfire-jobs-table',
      'overview' => 'wildfire-jobs-pending-table'
    );

    foreach ($check_tables as $path => $table_id) {

      $this->drupalGet('admin/wildfire/jobs/' . $path);
      $xpath = $this->xpath('//table[@id="' . $table_id . '"]/tbody/tr');

      // Find the row in the job table that corresponds to the last job to be
      // added.
      $job = new WildfireClientJob($jid);

      $row = -1;

      foreach ($xpath as $num => $xrow) {
        if ($xrow->td[0]->a == $job->title) {
          $row = $num;
          break;
        }
      }

      if ($row == -1) {
        $this->fail('Could not find job with ID ' . $jid . ' in the jobs table');
        return;
      }

      // Make sure the job is in a prepared state and no 'begin send' time has yet
      // been added.
      $pending_cell = $xpath[$row]->td[5]->span->div;
      $this->assertTrue(
        strpos($xpath[$row]->td[5]->span->div, t('Prepared')),
        t('Newly added job is in the prepared state')
      );

    }

    // Save the last job ID so we can use it elsewhere.
    $this->jobs->job = new stdClass;
    $this->jobs->job->id = $jid;
  }

  /**
   * Test adding a job and then cancelling it before it is sent.
   */
  protected function jobsCancel() {

    // Get the cancel page for a fake job ID and make sure we're told we can't
    // cancel it.
    $this->drupalGet('admin/wildfire/jobs/' . rand(999, 9999) . '/cancel');
    $this->assertText('cannot be cancelled');

    // Create a new job
    $job = $this->generateJob();

    // Make sure that there is a link on the jobs list so we can cancel this
    // job.
    $this->drupalGet('admin/wildfire/jobs/overview');
    $this->assertLinkByHref('admin/wildfire/jobs/' . $job['jid'] . '/cancel');

    $this->drupalGet('admin/wildfire/jobs/history');
    $this->assertLinkByHref('admin/wildfire/jobs/' . $job['jid'] . '/cancel');

    // Switch status of job to complete, then make sure no cancel link is on
    // the page any more. Switch it back to pending.
    wildfire_jobs_set_status($job['jid'], WILDFIRE_JOB_COMPLETE);
    $this->drupalGet('admin/wildfire/jobs/history');
    $this->assertNoRaw('admin/wildfire/jobs/' . $job['jid'] . '/cancel');

    // Now get the corresponding cancel page directly, and check we can't cancel
    // from here either.
    $this->drupalGet('admin/wildfire/jobs/' . $job['jid'] . '/cancel');
    $this->assertText('cannot be cancelled');

    // Create a new job
    $job = $this->generateJob();

    // Cancel the job using the UI and make sure it is properly cancelled.
    $this->drupalPost(
      'admin/wildfire/jobs/' . $job['jid'] . '/cancel',
      array('jid' => $job['jid']),
      t('Yes')
    );
    $this->assertText('has been cancelled');

    $job = new WildfireClientJob($job['jid']);
    $this->assertEqual($job->status, WILDFIRE_JOB_CANCELLED, t('Job status set to cancelled'));
  }

  /**
   * Check that the job timings are all correct.
   */
  protected function jobsTimes() {

    /**
     * The way in which job start dates are obtained now is from an RPC
     * call to the server, which updates the local table. Thus to test that the
     * start dates get set correctly on job execution, you would need to perform
     * the whole chain of events, or "fake it" as we do here.
     *
     * This test needs to be revisited at some point.
     */
    $start = REQUEST_TIME;
    $job = $this->generateJob();

    // Make sure the times are correct pre-send.
    $query = db_select('wildfire_jobs', 'cj')
      ->fields('cj', array(
        'scheduled',
        'started',
        'completed',
      ));
    $query->condition('jid', $job['jid'], '=');
    $result = $query->execute();

    $dbrow = $result->fetchAssoc();

    $finish = REQUEST_TIME;
    $this->assertTrue(
      $start <= $dbrow['scheduled'] && $dbrow['scheduled'] <= $finish,
      t('Start time recorded successfully')
    );
    $this->assertEqual(0, $dbrow['started'], t('Send time not yet set'));
    $this->assertEqual(0, $dbrow['completed'], t('Completion time not yet set'));

    $start = REQUEST_TIME;

    // This fails as it can't perform the RPC call due to enviroment, so we
    // "fake" it.
    //wildfire_job_execute($job['jid']);

    $record = array(
      'jid' => $job['jid'],
      'started' => REQUEST_TIME,
      'completed' => REQUEST_TIME,
    );
    drupal_write_record('wildfire_jobs', $record, 'jid');

    // Make sure the times are correct post-send.
    $query = db_select('wildfire_jobs', 'cj')
      ->fields('cj', array(
        'scheduled',
        'started',
        'completed',
      ));
    $query->condition('jid', $job['jid'], '=');
    $result = $query->execute();

    $dbrow = $result->fetchAssoc();

    $finish = REQUEST_TIME;

    $this->assertTrue(
      $start <= $dbrow['started'] && $dbrow['started'] <= $finish,
      t('Send time recorded successfully')
    );
    $this->assertTrue(
      $start <= $dbrow['completed'] && $dbrow['completed'] <= $finish,
      t('Completion time recorded successfully')
    );
  }

  /**
   * Make sure that the jobs are displayed in the correct order.
   */
  protected function jobsJobPage() {

    $job_first  = $this->generateJob(2, 2);
    sleep(2);
    $job_second = $this->generateJob(2, 2);
    sleep(2);
    $job_third  = $this->generateJob(2, 2);

    $all_jobs = wildfire_jobs_get();

    $status_ok = TRUE;

    foreach ($all_jobs as $job) {
      if (isset($previous_job_time)) {
        if ($job['scheduled'] < $previous_job_time) {
          $status_ok = TRUE;
        }
        else {
          $status_ok = FALSE;
          break;
        }
      }
      else {
        $previous_job_time = $job['scheduled'];
      }
    }

    //if status_ok = TRUE all is well else FAIL
    $this->assertIdentical(
      TRUE,
      $status_ok,
      t('Job list in descending date order')
    );
  }
}



