<?php
/**
 * @file
 * Tests for the token system.
 */
module_load_include('test', 'wildfire', 'tests/wildfire');

class WildfireTokenTestCase extends WildfireWebTestCase {
  /**
   * Implementation of getInfo().
   */
  public static function getInfo() {
    return array(
      'name' => 'Jobs - Tokens',
      'description' => 'Test the token replacement functionality.',
      'group' => 'Wildfire',
    );
  }

  /**
   * Setup
   *
   * @access public
   * @return void
   */
  public function setUp() {
    // Load the parts of the module we want to use
    module_load_include('inc', 'wildfire_broadcasts', 'wildfire_broadcasts.api');
    module_load_include('inc', 'wildfire_jobs', 'wildfire_jobs.send');
    module_load_include('inc', 'wildfire_lists', 'wildfire_lists.api');
    module_load_include('inc', 'wildfire_jobs', 'wildfire_jobs.api');

    // Generic setup, eg, user, etc.
    parent::setUp();
  }

  /**
   * Settings Test: General tab
   */
  protected function testTokens() {
    // Test if setup failed.
    if ($this->preFail !== FALSE) {
      $preFail = is_string($this->preFail)
        ? $this->preFail
        : 'Setup failed. Test aborted.';
      $this->fail($preFail);
      return;
    }

    $start = microtime();

    // List the tests here.
    $this->tokenBrowserview();
    $this->tokenEmail();
    $this->tokenUid();
    $this->tokenUnsubscribe();

    $this->pass(t(
      'Tests completed in !time seconds',
      array('!time' => $this->elapsedTime($start))
    ));
  }

    /**
   * Tests a specific token replacement worked
   */
  protected function checkToken($token_to_test, $ct_meta) {

    $uid =& $ct_meta['uid'];
    $jid =& $ct_meta['jid'];

    // Wrap token in start/end tags for a complete token
    // e.g. {{wildfire:something}}
    $full_token_to_test = WILDFIRE_TOKEN_START . $token_to_test . WILDFIRE_TOKEN_END;

    // Load the job and the message
    $job = new WildfireClientJob($jid);
    $message = WildfireClientMessage::getMessageObject($job->type);

    // Note that $message->_setRawContent() will perform a pseudo render
    $message->_setRawContent($full_token_to_test);

    /**
     * Check that the token was recognized when it was tokenized. If the
     * token doesn't end up alone as an element of the array, the tokenize
     * stage failed.
     */
    $tokenized = $message->getTokenizedContent();
    $this->assertTrue(
      in_array($full_token_to_test, $tokenized),
      t('Token !token found as an element of chunks array',
        array(
          '!token' => $token_to_test
        )
      )
    );

    // Also check that the token exists in the token list that was created.
    $tokens = $message->getTokenList();
    $this->assertTrue(
      in_array($token_to_test, array_keys($tokens)),
      t(
        'Token !token found as an element of token list array',
        array(
          '!token' => $token_to_test
        )
      )
    );

    // Now fully populate the message, and obtain the content.
    $message->addTrackingToLinks($job->jid);
    $message->populateTokenReplacements($job->jid, $uid);

    /**
     * Is our token in the rendered text? If it isn't, the template we are
     * using probably isn't suitable for this test.
     * The default, 'wildfire_example_newsletter', as a fully populated template should
     * contain all of the tokens we want to test.
    */
    $pos = strpos($message->getContent(), $full_token_to_test);
    $this->assertTrue(
      $pos !== FALSE,
      t('Token !token found in pre-tokenized text',
        array(
          '!token' => $token_to_test
        )
      )
    );

    /**
     * Check that the token is where it's expected to be in chunks. If the
     * indexes don't actually match where the tokens are in the chunks array,
     * the reconstruction of the message after token replacement will result in
     * a garbage message.
     */
    foreach ($tokens[$token_to_test] as $index) {
      $this->assertEqual(
        $tokenized[$index],
        $full_token_to_test,
        t('Token list index !index identifies correct chunk for token !token',
          array(
            '!index' => $index,
            '!token' => $token_to_test
          )
        )
      );
    }

    // Only populate the token we are testing, so it's the only token that
    // gets replaced.
    $token_list = array_keys($message->getTokenList());
    $token_list = array_flip($token_list);
    foreach ($token_list as $key => &$value) {
      $value = '';
    }

    $populated_tokens = $message->getTokenReplacements();
    $token_list[$token_to_test] = $populated_tokens[$token_to_test];

    $message->setTokenReplacements($token_list);

    // The raw token should NOT be in the render at this point.
    $content = $message->getContentWithTokenReplacements();
    $pos = strpos($content, $full_token_to_test);
    $this->assertFalse(
      $pos !== FALSE,
      t(
        'Token !token not found in rendered text',
        array(
          '!token' => $token_to_test
        )
      )
    );

    // Return the rendered text after token replacement, so that we can perform
    // token-specific post checks upon it.
    return $message->getContentWithTokenReplacements();

  }

  /**
   * Test the browserview token.
   */
  protected function tokenBrowserview() {

    $job = $this->generateJob();
    $jid = $job['jid'];

    $ct_meta = array(
      'jid' => $job['jid']
    );

    // Get the UID of the first user in the job recipient list
    $job_load = new WildfireClientJob($jid);

    $recipients = $job_load->getListUsers();
    $account = user_load_by_mail($recipients[0]['mail']);
    $ct_meta['uid'] = $account->uid;

    $render = $this->checkToken('wildfire:browserview', $ct_meta);

    // Get the URL that we are supposed to be looking for in the token-replaced
    // text.
    $browserview = url(
      'wildfire/view/' . $jid . '/' .
        wildfire_job_get_unsubscribe_token($job['uid'], $jid),
      array(
        'absolute'  => TRUE,
        'alias'     => TRUE,
      )
    );

    // Is the browserview URL now in the rendered text?
    $pos = strpos($render, $browserview);

    $this->assertTrue(
      $pos !== FALSE,
      t('Correct replacement for wildfire:browserview token found in rendered text')
    );

  }

  /**
   * Test the email address token.
   */
  protected function tokenEmail() {

    $job = $this->generateJob();
    $jid = $job['jid'];

    $ct_meta = array(
      'jid' => $job['jid']
    );

    // Get the UID of the first user in the job recipient list
    $job_load = new WildfireClientJob($jid);

    $recipients = $job_load->getListUsers();
    $account = user_load_by_mail($recipients[0]['mail']);
    $ct_meta['uid'] = $account->uid;

    $render = $this->checkToken('wildfire:email', $ct_meta);

    $email = $recipients[0]['mail'];

    // Is the email address now in the rendered text?
    $pos = strpos($render, $email);

    $this->assertTrue(
      $pos !== FALSE,
      t('Correct replacement for wildfire:email token found in rendered text')
    );

    // Test that on the browserview version, the token is still there.
    wildfire_job_execute($job['jid']);

    $query = db_select('wildfire_job_mails', 'cjm')
      ->fields('cjm', array(
        'token'
      ));
    $query->condition('jid', $job['jid'], '=');
    $query->condition('uid', $ct_meta['uid'], '=');
    $result = $query->execute();

    $token = $result->fetchField();

    $this->drupalGet('wildfire/view/' . $job['jid'] . '/' . $token);

    $this->assertText(
      $email,
      t('wildfire:email token substituted on browserview version')
    );
  }

  /**
   * Test the uid token.
   */
  protected function tokenUid() {

    $job = $this->generateJob();
    $jid = $job['jid'];

    $ct_meta = array(
      'jid' => $job['jid']
    );

    // Get the UID of the first user in the job recipient list
    $job_load = new WildfireClientJob($jid);
    $recipients = $job_load->getListUsers();
    $account = user_load_by_mail($recipients[0]['mail']);
    $ct_meta['uid'] = $account->uid;

    $render = $this->checkToken('wildfire:uid', $ct_meta);

    /**
     * UID is a literal number. Note we can't guarantee that performing a find
     * on the rendered text won't get false positives, as the number might
     * exist as part of content. This goes for the other tokens too to a
     * lesser extent.
     */
    $pos = strpos($render, $ct_meta['uid']);

    $this->assertTrue(
      $pos !== FALSE,
      t('Correct replacement for wildfire:uid token found in rendered text')
    );

  }

  /**
   * Test the unsubscribe token.
   */
  protected function tokenUnsubscribe() {

    $job = $this->generateJob();
    $jid = $job['jid'];

    $ct_meta = array(
      'jid' => $job['jid']
    );

    // Get the UID of the first user in the job recipient list
    $job_load = new WildfireClientJob($jid);
    $recipients = $job_load->getListUsers();
    $account = user_load_by_mail($recipients[0]['mail']);
    $ct_meta['uid'] = $account->uid;

    $render = $this->checkToken('wildfire:unsubscribe', $ct_meta);

    // Get the URL that we are supposed to be looking for in the token-replaced
    // text.
    $unsubscribe = url(
      'wildfire/unsubscribe/' .
        wildfire_job_get_unsubscribe_token($ct_meta['uid'], $jid),
      array(
        'absolute'  => TRUE,
        'alias'     => TRUE,
      )
    );

    // Is the unsubscribe link now in the rendered text?
    $pos = strpos($render, $unsubscribe);

    $this->assertTrue(
      $pos !== FALSE,
      t('Correct replacement for wildfire:unsubscribe token found in rendered text')
    );

  }
}
