<?php
/**
 * @file
 * Tests the broadcast system.
 */
module_load_include('test', 'wildfire', 'tests/wildfire');

/**
 * Wildfire Web Test Case: Broadcast
 */
class WildfireBroadcastTestCase extends WildfireWebTestCase {

  protected $broadcast, $nodes, $abort = FALSE;

  /**
   * Implementation of getInfo().
   */
  public static function getInfo() {
    return array(
      'name' => 'Broadcasts - Main',
      'description' => 'Test the Broadcast functionality of Wildfire',
      'group' => 'Wildfire',
    );
  }

  /** ------------------------------------------------------------------------
   * Setup
   */
  public function setUp() {
    $this->broadcast = new stdClass;
    // Our tests do not have any contextual meaning, so generate some random
    // data! We love random data, it's like turning at a junction when you
    // don't know where you're going :)
    $this->broadcast->name = $this->randomName(16);
    $this->broadcast->subject = $this->randomName(32);
    $this->broadcast->send_name = $this->randomName(50);
    $this->broadcast->send_email = $this->randomName(32)
                                 . '@'
                                 . $this->randomname(50)
                                 . '.com';
    // Enable the search module so we don't get any errors whilst deleting
    // nodes :)
    parent::setUp(array('search'));

    // Create some extra permissions needed for this module
    $permissions = array(
      'administer wildfire messages',
      'use wildfire messages',
    );

    // Add a new role with these permissions
    $new_role = $this->drupalCreateRole($permissions);

    // Add this additional role to the user account.
    $this->user->roles[$new_role] = $new_role;
    user_save($this->user);

    // Log in again to ensure the permissions are being picked up
    $this->drupalLogin($this->user);

  }

  /** ------------------------------------------------------------------------
   * Test Broadcasts
   *
   * @access public
   * @return void
   */
  public function testBroadcast() {
    // Test if setup failed.
    if ($this->preFail !== FALSE) {
      $preFail = is_string($this->preFail)
        ? $this->preFail
        : 'Setup failed. Test aborted.';
      $this->fail($preFail);
      return;
    }

    $start = microtime();

    // Load specific parts of the module so we can access their functions.
    module_load_include('inc', 'wildfire_broadcasts', 'wildfire_broadcasts.api');
    module_load_include('inc', 'wildfire_lists', 'wildfire_lists.api');

    // Start the Broadcast tests.
    $this->broadcastAddContentType();
    $this->broadcastZeroBroadcasts();
    $this->broadcastCreate();
    $this->broadcastCreateWithoutFromOrReply();
    $this->broadcastCreateWithoutReply();
    $this->broadcastEdit();
    $this->broadcastNodePage();

    $this->broadcastListPage();

    $this->broadcastDelete();
    $this->broadcastSendPage();
    $this->broadcastScheduledSend();

    $this->pass(t(
      'Tests completed in !time seconds',
      array('!time' => $this->elapsedTime($start))
    ));
  }

  /**
   * Check functionality and messages related to having no Broadcasts defined
   */
  protected function broadcastZeroBroadcasts() {
    // If a previous test has specified that we abort, do so.
    if ($this->abort === TRUE) {
      return;
    }

    // Create an example node.
    $node = array(
      'type' => $this->broadcast->contenttype,
    );
    $content = $this->drupalCreateNode($node);

    // Get the "Add to Broadcast" node page, and check the "No broadcasts"
    // message is displayed.
    $this->drupalGet('node/' . $content->nid . '/add_to_broadcast');

    $this->assertText(t('You currently have no broadcasts to add content to.'));

  }

  /**
   * Create a broadcast using the standard add broadcast form.
   */
  protected function broadcastCreate() {
    // If a previous test has specified that we abort, do so.
    if ($this->abort === TRUE) {
      return;
    }

    // Create a new broadcast with these details.
    $create_details = array(
      'broadcast_name' => $this->broadcast->name,
      'template' => $this->template,
      'from_name' => $this->broadcast->send_name,
      'from_email' => $this->broadcast->send_email,
      'reply_name' => $this->broadcast->send_name,
      'reply_email' => $this->broadcast->send_email,
    );

    // Post the broadcast add form to save the broadcast.
    $this->drupalPost(
      'admin/wildfire/broadcasts/add',
      $create_details,
      t('Add')
    );

    // Let's check that the following page is showing the correct values!
    $this->assertText(t(
      'Broadcast !broadcast has been created.',
      array('!broadcast' => $this->broadcast->name)
    ));

    // Check that the values got entered into the database correctly.
    $query = db_select('wildfire_broadcasts', 'cb')
      ->fields('cb', array(
        'mid',
      ));
    $query->condition('name', $this->broadcast->name, '=');
    $result = $query->execute();

    $this->broadcast->id = $result->fetchField();

    if (!$this->broadcast->id) {
      // What?! You can't find the broadcast in the database? Aw, snap!
      $this->fail('Broadcast could not be retrieved from the database.');
      $this->abort = TRUE;
      return;
    }

    $broadcast = wildfire_broadcast_get($this->broadcast->id);
    $this->assertEqual(
      $broadcast['name'],
      $this->broadcast->name,
      t('Broadcast name was successfully entered into the database.')
    );
    $this->assertEqual(
      $broadcast['template'],
      $this->template,
      t('Broadcast template was successfully entered into the database.')
    );
    $this->assertEqual(
      $broadcast['from_name'],
      $this->broadcast->send_name,
      t('From name was successfully entered into the database.')
    );
    $this->assertEqual(
      $broadcast['from_email'],
      $this->broadcast->send_email,
      t('From email was successfully entered into the database.')
    );
    $this->assertEqual(
      $broadcast['reply_name'],
      $this->broadcast->send_name,
      t('Reply name was successfully entered into the database.')
    );
    $this->assertEqual(
      $broadcast['reply_email'],
      $this->broadcast->send_email,
      t('Reply email was successfully entered into the database.')
    );
  }

  /**
   * Create a broadcast without setting the from or reply details.
   *
   * We should find that they have been filled in automatically.
   */
  protected function broadcastCreateWithoutFromOrReply() {

    global $base_url;

    // If a previous test has specified that we abort, do so.
    if ($this->abort === TRUE) {
      return;
    }

    // Create a new broadcast with these details. Don't set the from name or
    // email, or the reply name or email.
    $create_details = array(
      'broadcast_name' => $this->randomName(32),
      'template' => $this->template,
    );

    // Post the broadcast add form to save the broadcast.
    $this->drupalPost(
      'admin/wildfire/broadcasts/add',
      $create_details,
      t('Add')
    );

    // Let's check that the following page is showing the correct values!
    $this->assertText(t(
      'Broadcast !broadcast has been created.',
      array('!broadcast' => $create_details['broadcast_name'])
    ));

    // Check that the values got entered into the database correctly.
    $query = db_select('wildfire_broadcasts', 'cb')
      ->fields('cb', array(
        'mid',
    ));
    $query->condition('name', $create_details['broadcast_name'], '=');
    $result = $query->execute();

    $mid = $result->fetchField();

    $broadcast = wildfire_broadcast_get($mid);

    $this->assertEqual(
      $broadcast['from_name'],
      'Wildfire',
      t('Broadcast from_name was set correctly')
    );
    $this->assertEqual(
      $broadcast['from_email'],
      variable_get('site_mail', 'webmaster@' . parse_url($base_url, PHP_URL_HOST)),
      t('Broadcast from_email was set correctly')
    );
    $this->assertEqual(
      $broadcast['reply_name'],
      'Wildfire',
      t('Broadcast reply_name was set correctly')
    );
    $this->assertEqual(
      $broadcast['reply_email'],
      variable_get('site_mail', 'webmaster@' . parse_url($base_url, PHP_URL_HOST)),
      t('Broadcast reply_email was set correctly')
    );
  }

  /**
   * Create a broadcast without setting the from or reply details.
   *
   * We should find that they have been filled in automatically.
   */
  protected function broadcastCreateWithoutReply() {
    // If a previous test has specified that we abort, do so.
    if ($this->abort === TRUE) {
      return;
    }

    // Create a new broadcast with these details. Don't set the from name or
    // email, or the reply name or email.
    $create_details = array(
      'broadcast_name' => $this->randomName(32),
      'template' => $this->template,
      'from_name' => $this->randomName(32),
      'from_email' => $this->randomName(16) . '@example.com',
    );

    // Post the broadcast add form to save the broadcast.
    $this->drupalPost(
      'admin/wildfire/broadcasts/add',
      $create_details,
      t('Add')
    );

    // Let's check that the following page is showing the correct values!
    $this->assertText(t(
      'Broadcast !broadcast has been created.',
      array('!broadcast' => $create_details['broadcast_name'])
    ));

    // Check that the values got entered into the database correctly.
    $query = db_select('wildfire_broadcasts', 'cb')
      ->fields('cb', array(
        'mid'
      ));
    $query->condition('name', $create_details['broadcast_name'], '=');
    $result = $query->execute();

    $mid = $result->fetchField();

    $broadcast = wildfire_broadcast_get($mid);

    // The reply name and email address should have the same values as the
    // from name and email.
    $this->assertEqual(
      $broadcast['reply_name'],
      $create_details['from_name'],
      t('Broadcast reply_name was set correctly')
    );
    $this->assertEqual(
      $broadcast['reply_email'],
      $create_details['from_email'],
      t('Broadcast reply_email was set correctly')
    );
  }

  /**
   * Edit an existing broadcast.
   */
  protected function broadcastEdit() {
    // If a previous test has specified that we abort, do so.
    if ($this->abort === TRUE) {
      return;
    }

    // Fetch the edit page.
    $this->drupalGet(
      'admin/wildfire/broadcasts/'
    . $this->broadcast->id
    . '/edit'
    );

    // Make sure that the edit form is displaying the correct values.
    $this->assertFieldByName('broadcast_name', $this->broadcast->name);
    $this->assertFieldByName('from_name', $this->broadcast->send_name);
    $this->assertFieldByName('from_email', $this->broadcast->send_email);
    $this->assertFieldByName('reply_name', $this->broadcast->send_name);
    $this->assertFieldByName('reply_email', $this->broadcast->send_email);

    // We want some different data for our broadcast.
    $this->broadcast->name = $this->randomName(16);
    $this->broadcast->subject = $this->randomName(32);
    // Different length string this time.
    $this->broadcast->send_name = $this->randomName(50);
    $this->broadcast->send_email = $this->randomName(32)
                                 . '@'
                                 . $this->randomName(50)
                                 . '.net';

    // This part is where we could shuffle the templates around (if there is
    // more than one, of course) and use a different one to that which we used
    // to create it!

    // Define what we are going to update with.
    $update_fields = array(
      'mid' => $this->broadcast->id,
      'broadcast_name' => $this->broadcast->name,
      'from_name' => $this->broadcast->send_name,
      'from_email' => $this->broadcast->send_email,
      'reply_name' => $this->broadcast->send_name,
      'reply_email' => $this->broadcast->send_email,
    );

    $this->drupalPost(
      'admin/wildfire/broadcasts/' . $this->broadcast->id . '/edit',
      $update_fields,
      t('Update')
    );

    // Check that the module was happy with all that.
    $this->assertText(t(
      'Broadcast !broadcast has been updated.',
      array('!broadcast' => $this->broadcast->name)
    ));

    $broadcast = wildfire_broadcast_get($this->broadcast->id);
    $this->assertEqual(
      $broadcast['name'],
      $this->broadcast->name,
      t('Broadcast name successfully updated.')
    );
    $this->assertEqual(
      $broadcast['from_name'],
      $this->broadcast->send_name,
      t('From name successfully updated.')
    );
    $this->assertEqual(
      $broadcast['from_email'],
      $this->broadcast->send_email,
      t('From email successfully updated.')
    );
    $this->assertEqual(
      $broadcast['reply_name'],
      $this->broadcast->send_name,
      t('Reply name successfully updated.')
    );
    $this->assertEqual(
      $broadcast['reply_email'],
      $this->broadcast->send_email,
      t('Reply email successfully updated.')
    );

    // Check that if we add an invalid email address to either the from_email
    // or reply_email fields, there is an error.
    // Define what we are going to update with.
    $update_fields['from_email'] = $this->randomName(32);

    $this->drupalPost(
      'admin/wildfire/broadcasts/' . $this->broadcast->id . '/edit',
      $update_fields,
      t('Update')
    );

    $this->assertText('Please enter a valid "from" email address.');

    $update_fields['from_email'] = $this->broadcast->send_name;
    $update_fields['reply_email'] = $this->randomName(32);

    $this->drupalPost(
      'admin/wildfire/broadcasts/' . $this->broadcast->id . '/edit',
      $update_fields,
      t('Update')
    );

    $this->assertText('Please enter a valid "reply" email address.');
  }

  /** ------------------------------------------------------------------------
   * Add Content to Broadcast
   *
   * @access protected
   * @return void
   */
  protected function broadcastAddContentType() {
    // If a previous test has specified that we abort, do so.
    if ($this->abort === TRUE) {
      return;
    }

    // To run this test we need to create a content type and enable it.
    $this->broadcast->contenttype = $this->randomName(12);
    $contenttype = $this->drupalCreateContentType(array(
      'type' => $this->broadcast->contenttype,
    ));
    $this->assertEqual(
      $this->broadcast->contenttype,
      $contenttype->type,
      t(
        'Content type "!contenttype" created successfully.',
        array('!contenttype' => $this->broadcast->contenttype)
      )
    );
    $enable = array(
      'wildfire_content_types[' . $this->broadcast->contenttype . ']' => 1,
    );
    $this->drupalPost(
      'admin/wildfire/settings/content-types',
      $enable,
      t('Save configuration')
    );

  }

  /** ------------------------------------------------------------------------
   * Delete Broadcast
   *
   * @access protected
   * @return void
   */
  protected function broadcastDelete() {
    // If a previous test has specified that we abort, do so.
    if ($this->abort === TRUE) {
      return;
    }
    $this->drupalGet(
      'admin/wildfire/broadcasts/' . $this->broadcast->id . '/delete'
    );
    $this->assertText(t(
      'Are you sure you want to delete the broadcast !broadcast?',
    array('!broadcast' => $this->broadcast->name)
    ));
    $delete_params = array(
      'mid' => $this->broadcast->id,
    );

    $this->drupalPost(
      'admin/wildfire/broadcasts/' . $this->broadcast->id . '/delete',
      $delete_params,
      t('Yes')
    );

    $this->assertText(t(
      'Broadcast !broadcast has been deleted.',
      array('!broadcast' => $this->broadcast->name)
    ));

    // Check we can't delete what has already been deleted
    $this->drupalGet(
      'admin/wildfire/broadcasts/' . $this->broadcast->id . '/delete'
    );
    $this->assertText(t(
      'Cannot delete broadcast !mid, as it is not a valid broadcast ID',
      array(
        '!mid' => $this->broadcast->id
      )
    ));

    // Finally, we shall check if the broadcast actually got deleted from the
    // database! That's kind of important, we don't want unwanted broadcast
    // cluttering up our attic space :)

    $query = db_select('wildfire_broadcasts', 'cb');
    $query->condition('mid', $this->broadcast->id, '=');
    $query->addExpression('COUNT(1)');
    $result = $query->execute();

    $count = $result->fetchField();

    $this->assertEqual(
      0,
      $count,
      t('Broadcast was successfully deleted from the database.')
    );

  }

  /**
   * Make sure that the information on the broadcast send page is correct.
   */
  protected function broadcastSendPage() {
    // Create two random users and add them to a random list. Also create a
    // broadcast to work with.
    $acc1 = $this->drupalCreateUser();
    $acc2 = $this->drupalCreateUser();
    $list = $this->generateList(0);

    // Generate one broadcast with no nodes, and another with 2 nodes.
    $broadcast_0 = $this->generateBroadcast(0);
    $this->assertNotEqual(
      $broadcast_0,
      FALSE,
      t('Broadcast with 0 nodes successfully generated')
    );

    $broadcast_2 = $this->generateBroadcast(2);
    $this->assertNotEqual(
      $broadcast_2,
      FALSE,
      t('Broadcast with 2 nodes successfully generated')
    );

    wildfire_lists_user_add($acc1->uid, $list->id);
    wildfire_lists_user_add($acc2->uid, $list->id);

    // Test that there is a message to warn the user there's no content
    $this->drupalGet('admin/wildfire/broadcasts/' . $broadcast_0->id . '/send');
    $this->assertText(
      t(
        'Broadcast "!broadcast" has no content defined',
        array(
        '!broadcast' => $broadcast_0->name,
        )
      )
    );

    // Test that all of the expected fields appear on the form.
    $this->assertFieldByName(
      'cmsubject',
      $broadcast_0->subject,
      t('Found subject field')
    );
    $this->assertFieldByXPath(
      '//input[@name="recipient_type"][@value="list"]',
      NULL,
      t('Found send to list radio')
    );
    $this->assertFieldByXPath(
      '//input[@name="recipient_type"][@value="test"]',
      NULL,
      t('Found send to test radio')
    );
    $this->assertFieldByName(
      'recipient_addresses',
      NULL,
      t('Found recipient addresses textarea')
    );
    $this->assertFieldByXPath(
      '//input[@name="send_when"][@value="now"]',
      NULL,
      t('Found send now radio')
    );
    $this->assertFieldByXPath(
      '//input[@name="send_when"][@value="later"]',
      NULL,
      t('Found send later radio')
    );
    $this->assertFieldByName(
      'op',
      'Send',
      t('Found send submit button')
    );

    // Test that there is not a message to warn the user there's no content
    $this->drupalGet('admin/wildfire/broadcasts/' . $broadcast_2->id . '/send');
    $this->assertNoText(
      t(
        'Broadcast "!broadcast" has no content defined',
        array(
          '!broadcast' => $broadcast_2->name,
        )
      )
    );

    // Check the title is right only. No need to check for all other fields
    // as we have performed those checks already.
    $this->assertFieldByName('cmsubject', $broadcast_2->subject);

    // CHECK THE LIVE LIST SELECTION PART OF THE FORM

    /**
     * We should have only one list at this point. We need to check if there are
     * WILDFIRE_MAX_TOP_LISTS radios (and no more), that these are in the right
     * order, and that if there are more lists than WILDFIRE_MAX_TOP_LISTS,
     * that the 'select from all' drop-down is displayed.
     */

    $this->drupalGet('admin/wildfire/broadcasts/' . $broadcast_0->id . '/send');

    $this->assertNoFieldByXPath(
      '//select[@name="all_lists"]',
      NULL,
      t('All lists selector is not present yet')
    );

    // Add enough lists to get us beyond WILDFIRE_MAX_TOP_LISTS count
    for ($i = 0; $i < WILDFIRE_MAX_TOP_LISTS + 2; $i++) {
      $this->generateList(rand(0, 3));
    }

    /**
     * Grab the page again, and recheck if the select all drop-down is now
     * present - it should be at this point as we are over the threshold.
     */
    $this->drupalGet('admin/wildfire/broadcasts/' . $broadcast_0->id . '/send');

    $this->assertFieldByXPath(
      '//select[@name="all_lists"]',
      NULL,
      t('All lists selector is present')
    );

    // Check the 'select from all' radio exists as well
    $this->assertFieldByXPath(
      '//input[@name="recently_used_lists"]',
      -1,
      t('Select from all lists radio is present')
    );

    // Check the 'select all' radio label is correct
    $input = $this->xpath('//input[@name="recently_used_lists"][@value="-1"]');
    if (!empty($input)) {
      $id = (string)$input[0]->attributes()->id;
      $label = $this->xpath('//label[@for="' . $id . '"]');

      /**
       * trim() is required as the label gets rendered with extraneous spaces
       * despite the original input not containing any.
       */
      $label = trim((string)$label[0]);

      $this->assertEqual(
        t('Select from all available lists'),
        $label,
        t('Label of select from all lists radio matches expected value')
      );
    }
    else {
      $this->fail(
        t('Select from all lists radio is missing')
      );
    }

    /*
     * Get the lists back via the API, ordered by most recent. This should
     * match the order in which the radios are displayed on the page too
     */
    $top_lists = wildfire_lists_get('recent', TRUE);
    $top_lists_keys = array_keys($top_lists);

    $xpath = $this->xpath('//input[@name="recently_used_lists"]');

    if (!empty($xpath)) {
      /**
       * We expect as many radios as there are lists plus 1 for the 'select all'
       * row. Thus when checking list count against radio counts, it's
       * list count + 1
       */
      $this->assertEqual(
        count($xpath),
        count($top_lists) + 1,
        t(
          'Lists radio count matches expected count (%radio/%count)',
          array(
            '%radio' => count($xpath),
            '%count' => count($top_lists) + 1
          )
        )
      );

      /**
       * Check each radio matches up to the corresponding list entry, and
       * simultaneously check that the listed count for the entry is right.
       */
      foreach ($xpath as $option) {

        $id = (string)$option->attributes()->id;
        $value = (string)$option->attributes()->value;

        /**
         * The 'select from all' radio isn't formatted the same as the list
         * ones, but we have already checked it for accuracy, so it can be
         * skipped here.
         */
        if ($value == -1) {
          continue;
        }

        $label = $this->xpath('//label[@for="' . $id . '"]');
        preg_match('/(.*) \(([0-9]*)\)/', trim((string)$label[0]), $matches);

        $list_title = array_shift($top_lists);
        $list_key = array_shift($top_lists_keys);

        $totals = wildfire_list_get_totals($list_key);
        $count = $totals[WILDFIRE_STATUS_SUBSCRIBED];

        // Check ID match
        $this->assertEqual(
          $value,
          $list_key,
          t(
            'ID of top list radio matches entry in list (%value/%next)',
            array(
              '%value' => $value,
              '%next' => $list_key,
            )
          )
        );

        // Check name match
        $this->assertEqual(
          $matches[0],
          $list_title,
          t('Label of top list radio matches entry in list')
        );

        // Check count match
        $this->assertEqual(
          $matches[2],
          $count,
          t('Count in entry title is correct')
        );

      }

    }
    else {
      $this->fail(
        t('Recently used list radios are missing')
      );
    }

    /**
     * Reset lists 'last_send_to' date, to push it to the top of the
     * recently used lists.
     *
     * TODO: there probably should be a Wildfire API function for this.
     */
    $record = array(
      'lid' => $list->id,
      'last_sent_to' => time(),
    );
    drupal_write_record('wildfire_lists', $record, array('lid'));

    // Get an initial count of users from the list.
    $test_list_count = wildfire_list_get_count($list->id);

    /**
     * Unsubscribe a user, which should decrement the list count by one. So we
     * decrement our calculated list count, and recheck the label corresponding
     * to the list on the page to ensure it still displays the right thing.
    */
    wildfire_list_unsubscribe($acc1->uid, $list->id);
    $test_list_count--;

    $this->drupalGet('admin/wildfire/broadcasts/' . $broadcast_2->id . '/send');

    $input = $this->xpath('//input[@name="recently_used_lists"][@value="' . $list->id . '"]');
    if (!empty($input)) {

      $id = (string)$input[0]->attributes()->id;
      $label = $this->xpath('//label[@for="' . $id . '"]');
      preg_match('/(.*) \(([0-9]*)\)/', (string)$label[0], $matches);

      if (!empty($matches)) {
        $this->assertEqual(
          $test_list_count,
          $matches[2],
          t('Count displayed for list matches count after user is unsubscribed')
        );
      }
      else {
        $this->fail(
          t('Label for list that had a user unsubscribed could not be parsed.')
        );
      }

    }
    else {
      $this->fail(
        t(
          'Recently used list entry matching list ID %listid is missing',
          array(
           '%listid' => $list->id,
          )
        )
      );
    }

    // CHECK THE TEST LIST SELECTION PART OF THE FORM

    // Check that the 'send to test recipients' textarea is present.
    $this->assertFieldByXPath(
      '//textarea[@name="recipient_addresses"]',
      NULL,
      t('Test recipients textarea is present')
    );

    // Check that there's no 'recent test email address set' radios
    $this->assertNoFieldByXPath(
      '//input[@name="recently_used_tests"]',
      NULL,
      t('Recently used test email address sets is not present')
    );

    // Add some test lists via the API
    // Try 'array' input
    $test_addresses_1 = array();
    for ($i = 0; $i < rand(2, 7); $i++) {
      $test_addresses_1[] = $this->randomName(12) . '@example.com';
    }
    $test_list_1 = wildfire_lists_save_test_list($test_addresses_1);

    $this->assertTrue(
      ctype_digit((string)$test_list_1),
      t('Test list 1 saved')
    );

    // Try 'comma separated' input
    $test_addresses_2 = array();
    for ($i = 0; $i < rand(10, 16); $i++) {
      $test_addresses_2[] = $this->randomName(12) . '@example.com';
    }
    $test_list_2 = wildfire_lists_save_test_list(implode(',', $test_addresses_2));

    $this->assertTrue(
      ctype_digit((string)$test_list_2),
      t('Test list 2 saved')
    );

    // Check the input versus the API output
    $list_1 = array();
    $test_list = wildfire_list_get($test_list_1);
    foreach ($test_list as $item) {
      $list_1[] = $item['mail'];
    }
    sort($list_1);
    sort($test_addresses_1);
    $this->assertEqual(
      $list_1,
      $test_addresses_1,
      t('Test list 1 API result matches input')
    );

    $list_2 = array();
    $test_list = wildfire_list_get($test_list_2);
    foreach ($test_list as $item) {
      $list_2[] = $item['mail'];
    }
    sort($list_2);
    sort($test_addresses_2);
    $this->assertEqual(
      $list_2,
      $test_addresses_2,
      t('Test list 2 API result matches input')
    );

    // Reget the page, check if there are now radios, and that their
    // labels match the expected values.
    $this->drupalGet('admin/wildfire/broadcasts/' . $broadcast_2->id . '/send');

    // Get the test lists back out via the API so that we can check the values
    $test_lists = wildfire_lists_get_test_lists();
    $test_keys = array_keys($test_lists);

    $xpath = $this->xpath('//input[@name="recently_used_tests"]');

    if (!empty($xpath)) {

      foreach ($xpath as $option) {

        $id = (string)$option->attributes()->id;
        $value = (string)$option->attributes()->value;

        $test_label = array_shift($test_lists);
        $test_key = array_shift($test_keys);

        // Check that the value matches
        $this->assertEqual(
          $value,
          $test_key,
          t('Test set radio value matches expected value')
        );

        // Check that the label matches the list name
        $label = $this->xpath('//label[@for="' . $id . '"]');
        $label = trim((string)$label[0]);
        $this->assertEqual(
          $label,
          $test_label,
          t('Test set radio label matches expected value')
        );

        /**
         * Split the label, and check that it was constructed
         * correctly from the source list. This also verifies that
         * wildfire_lists_get_test_lists() is generating valid labels.
         */
        $label_addresses = explode(',', $label);

        /**
         * Check if last entry in the label is 'and X others'. If it is,
         * pop it off the end (so that it's not checked as though it were an
         * address) and increment the count so we can check it matches the
         * actual list entry count.
         */
        $list_count = 0;
        $last = end($label_addresses);
        preg_match('/and ([0-9]+)* other[s]?/', $last, $matches);
        if (!empty($matches)) {
          reset($label_addresses);
          array_pop($label_addresses);
          $list_count += $matches[1];
        }

        $list_count += count($label_addresses);

        // Get the address list for this list via the API
        $list_addresses = array();
        $test_list = wildfire_list_get($test_key);
        foreach ($test_list as $item) {
          $list_addresses[] = $item['mail'];
        }

        // Check that the counts match
        $this->assertEqual(
          $list_count,
          count($list_addresses),
          t(
            'Actual list count matches displayed list count (%actual/%displayed)',
            array(
              '%actual' => $list_count,
              '%displayed' => count($list_addresses)
            )
          )
        );

        /**
         * Check the addresses that were in the displayed list against the
         * actual list. Note that the list may be displayed in any order,
         * hence the use of in_array() to determine if the addresses displayed
         * are indeed members of the full list for that row.
         */
        foreach ($label_addresses as $address) {
          $this->assertTrue(
            in_array(trim($address), $list_addresses),
            t('Test list label address matches an address in the full list')
          );
        }

      }

    }
    else {
      $this->fail(
        t('Recently used test email address sets radios are missing')
      );
    }

    // Test that the form does not submit if no list is selected.
    $send_params = array();
    $this->drupalPost(
      'admin/wildfire/broadcasts/' . $broadcast_2->id . '/send',
      $send_params,
      t('Send')
    );
    $this->assertText(t('Please select a list for this send'));

    // Test that the first part of the form submits to the confirmation page
    // and that the correct values are displayed in the notice on that page.

    $broadcast_subject = $this->randomName(16);

    $send_params = array(
      'recently_used_lists' => $list->id,
      'cmsubject' => $broadcast_subject,
    );
    $this->drupalPost(
      'admin/wildfire/broadcasts/' . $broadcast_2->id . '/send',
      $send_params,
      t('Send')
    );
    $this->assertText(t(
      '"@title" broadcast',
      array('@title' => $broadcast_2->name)
    ));
    $this->assertText(t(
      '"@list" list',
      array('@list' => $list->name)
    ));
    $this->assertText(t(
      '@users ?',
      array('@users' => format_plural(count($list), '1 user', '@count users'))
    ));

    // test that the subject was saved properly
    $broadcast = wildfire_broadcast_get($broadcast_2->id);
    $this->assertEqual(
      $broadcast['subject'],
      $broadcast_subject,
      t('Subject was saved correctly')
    );

    // test the cancel button on the confirmation page
    $this->assertLinkByHref(
      'admin/wildfire/broadcasts/' . $broadcast_2->id . '/send'
    );

    // test that the broadcast job is actually added to the jobs list
    $this->drupalPost(
      NULL,
      array(),
      t('Send')
    );
    $this->assertText(t(
      'The job has been created successfully.'
    ));

    $this->assertNoText(t(
      'Please select a list for this send.'
    ));

    $this->assertNoText(t(
      'Updating the last sent date on the broadcast failed'
    ));

    // Sending a broadcast should update the last sent date on it, so let's
    // check it did.
    $broadcast = wildfire_broadcast_get($broadcast_2->id);
    $this->assertTrue(
      !empty($broadcast['lastsent']),
      t('Broadcasts last sent date has been updated')
    );

    /*
     * Disable the template being used by the broadcast (i.e the default),
     * and test that the send, edit snippets, and edit regions pages
     * redirect to the edit broadcast form.
     */
    wildfire_template_disable($this->default_template);

    $this->drupalGet('admin/wildfire/broadcasts/' . $broadcast_2->id . '/send');
    $this->assertText(t('please choose a different template'));

    $this->drupalGet('admin/wildfire/broadcasts/' . $broadcast_2->id . '/content/repeaters');
    $this->assertText(t('please choose a different template'));

    $this->drupalGet('admin/wildfire/broadcasts/' . $broadcast_2->id . '/content/snippets');
    $this->assertText(t('please choose a different template'));

    // Reset the templates state ready for more testing
    wildfire_template_enable($this->default_template);

  }

  /**
   * Test that a job created with a future send date will be added properly.
   */
  protected function broadcastScheduledSend() {
    $broadcast = $this->generateBroadcast();

    $this->assertNotEqual(
      $broadcast,
      FALSE,
      t('Broadcast successfully generated')
    );

    $list = $this->generateList(2);
    $scheduled = format_date(REQUEST_TIME + 86400, 'custom', 'j M Y H:i:s');

    /**
     * At this point in the test, we have more than WILDFIRE_MAX_TOP_LISTS
     * lists thus the 'all_lists' drop-down will be available. We will select
     * our new list using the 'all_lists' selector, as the list hasn't been
     * used yet thus won't be in the 'recently_used_lists' radio selections
     */
    $send_params = array(
      'recently_used_lists' => '-1',
      'all_lists' => $list->id,
      'send_when' => 'later',
      'date' => $scheduled,
    );

    $this->drupalPost(
      'admin/wildfire/broadcasts/' . $broadcast->id . '/send',
      $send_params,
      t('Send')
    );
    $this->drupalPost(NULL, array(), t('Send'));

    $query = db_select('wildfire_jobs', 'cj')
      ->fields('cj', array(
        'jid'
      ));
    $query->condition('scheduled', strtotime($scheduled), '=');
    $result = $query->execute();

    $jid = $result->fetchField();

    $this->assertTrue(
      $jid > 0,
      t('Scheduled send added successfully')
    );
  }

  /**
   * Make sure that the broadcasts are displayed in the correct order.
   */
  protected function broadcastListPage() {

    $broadcast_first  = $this->generateBroadcast(1);
    $this->assertNotEqual(
      $broadcast_first,
      FALSE,
      t('Broadcast (first) successfully generated')
    );
    sleep(2);
    $broadcast_second = $this->generateBroadcast(1);
    $this->assertNotEqual(
      $broadcast_second,
      FALSE,
      t('Broadcast (second) successfully generated')
    );
    sleep(2);
    $broadcast_third  = $this->generateBroadcast(1);
    $this->assertNotEqual(
      $broadcast_third,
      FALSE,
      t('Broadcast (third) successfully generated')
    );

    //$this->pass($this->vardump($broadcast_first->id));
    //$this->pass($this->vardump($broadcast_second->id));
    //$this->pass($this->vardump($broadcast_third->id));

    $broadcast_first = wildfire_broadcast_get($broadcast_first->id);
    $broadcast_second = wildfire_broadcast_get($broadcast_second->id);
    $broadcast_third = wildfire_broadcast_get($broadcast_third->id);

    //$this->pass($this->vardump($broadcast_first));
    //$this->pass($this->vardump($broadcast_second));
    //$this->pass($this->vardump($broadcast_third));

    $all_broadcasts = wildfire_broadcasts_get();

    //$this->pass($this->vardump($all_broadcasts));
    $status_ok = TRUE;

    foreach ($all_broadcasts as $bc) {
      if (isset($previous_bc_time)) {
        if ($bc['created'] <= $previous_bc_time) {
          $status_ok = TRUE;
        }
        else {
          $status_ok = FALSE;
          break;
        }
      }
      else {
        $previous_bc_time = $bc['created'];
      }
    }

    //if status_ok = TRUE all is well else FAIL
    $this->assertIdentical(
      TRUE,
      $status_ok,
      t('Broadcast list in descending date order')
    );
  }

  /**
   * Tests that the node pages integrate correctly into broadcasts
   *
   * @return void
   */
  protected function broadcastNodePage() {

    // Create two example nodes.
    $node = array(
      'type' => $this->broadcast->contenttype,
    );
    $this->node = array();
    $this->node[1] = $this->drupalCreateNode($node);
    $this->node[2] = $this->drupalCreateNode($node);

    // Get the "Add to Broadcast" node page, and check it has the right fields
    $this->drupalGet('node/' . $this->node[1]->nid . '/add_to_broadcast');

    $this->assertText($this->broadcast->name);
    $this->assertFieldById('edit-broadcast');

    /**
     * Check that all of the checkboxes are present
     */
    $all_repeaters = wildfire_repeaters_get();
    foreach ($all_repeaters as $key => $value) {
      $this->assertFieldById('edit-repeater-' . $key);
      $this->assertText(t($value['title']));
    }

    $this->assertFieldById('edit-submit');

    // Get the first valid repeater name from the broadcasts template, and
    // attempt to add our new node to it.
    $repeater_keys = array_keys(wildfire_repeaters_get($this->template));
    $repeater = $repeater_keys[0];
    $add_node = array(
      'broadcast' => $this->broadcast->id,
      'repeater[' . $repeater . ']' => $repeater,
    );

    $this->drupalPost(
      'node/' . $this->node[1]->nid . '/add_to_broadcast',
      $add_node,
      t('Save')
    );
    $this->assertText(t(
      'Node with ID "' . $this->node[1]->nid . '" was added to the "' . $repeater . '" repeater',
      array('!node' => $this->node[1]->title)
    ));

    $this->drupalPost(
      'node/' . $this->node[2]->nid . '/add_to_broadcast',
      $add_node,
      t('Save')
    );
    $this->assertText(t(
      'Node with ID "' . $this->node[2]->nid . '" was added to the "' . $repeater . '" repeater',
      array('!node' => $this->node[2]->title)
    ));

    // Get the "Delete Node" page, and check it has the right fields
    /**
     * NOTE: The test user needs to be assigned 'administer nodes'
     * in order for this test to pass.
     *
     * 2011-09-20, craig: Added 'bypass node access' perms as need delete perms
     * but can't add specific content-type overrrides as we don't know what the
     * content type is until after the test user has already been assigned
     * permissions
     */
    $this->drupalGet('node/' . $this->node[1]->nid . '/delete');

    $this->assertText(t('Are you sure you want to delete'));
    $this->assertFieldById('edit-submit');

    // Automate clicking the 'delete' button
    $this->drupalPost(
      'node/' . $this->node[1]->nid . '/delete',
      array(),
      t('Delete')
    );

    // Now check that the entries for this node have been nuked from
    // the repeaters table(s).
    $query = db_select('wildfire_repeaters_nodes', 'crn')
      ->condition('nid', $this->node[1]->nid, '=');
    $query->addExpression('COUNT(1)', 'count');
    $result = $query->execute();

    $count = $result->fetchField();

    $this->assertEqual(
      0,
      $count,
      t(
        'References to node were removed from the repeaters table (!count)',
        array(
      '!count' => $count,
    )
      )
    );

  }

}
