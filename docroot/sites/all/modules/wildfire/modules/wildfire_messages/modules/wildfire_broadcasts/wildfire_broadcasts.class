<?php
/**
 * @file
 *  Classes for Wildfire Broadcasts module
 *
 * @author Craig Jones <craig@tiger-fish.com>
 */

/**
 * Class to handle Broadcasts
 */
class WildfireBroadcast extends WildfireClientMessage implements WildfireClientMessageInterface {

  /**
   * @var $type
   *  The type of message implemented by this class. Used to lookup if this
   *  class implements the type we require.
   */
  public static $type = 'broadcast';

  /**
   * {@inheritdoc}
   */
  public function load($mid) {

    try {

      if (!ctype_digit((string)$mid)) {
        throw new InvalidArgumentException(
          t('Message ID is not an integer')
        );
      }

      $query = db_select('wildfire_broadcasts', 'wb')
        ->fields('wb');
      $query->condition('mid', $mid, '=');
      $result = $query->execute();

      if ($result->rowCount() == 0) {
        throw new InvalidArgumentException(t('Message ID given was not valid'));
      }

      $this->dbrow = $result->fetchAssoc();

      return TRUE;

    }
    catch (Exception $e) {

      watchdog(
        'wildfire_messages',
        t(
          'Loading Messages !mid failed: !message',
          array(
            '!mid' => $mid,
            '!message' => $e->getMessage()
          )
        )
      );

      return FALSE;

    }

  }

  /**
   * Loads an object state from the database based upon the state of the object
   * when sent in a job.
   *
   * Note that if a Job contains multiple content chunks, only the 'parent'
   * type is currently used.
   * TODO: Update this when multi chunk support is added.
   *
   * @throws InvalidArgumentException
   *  If the Job ID is invalid or can't be loaded.
   *
   * @param int $jid
   *  Job ID to obtain the message object for
   *
   * @return bool
   *  TRUE if the load succeeded, else FALSE
   */
  public function loadFromJob($jid) {

    $job = new WildfireClientJob($jid);

    $content = $job->getContent(-1);

    if (!empty($content)) {
      // Go through the returned content, and find the 'parent'
      foreach($content as $chunk) {
        if ($chunk['content_type'] == 'parent') {
          $this->tokenizedContent = $chunk['content'];
          $this->tokens = $chunk['token_list'];
          return TRUE;
        }
      }
    }

    return FALSE;

  }

  /**
   * {@inheritdoc}
   */
  public function save() {

    if ($this->validateBroadcast($this->dbrow)) {
      return drupal_write_record(
        'wildfire_broadcasts',
        $this->dbrow,
        !empty($this->dbrow['mid']) ? 'mid' : array()
      );
    }
    else {
      return FALSE;
    }

  }

  /**
   * Creates a new Broadcast
   *
   * @param string $template
   *  ID of the template to use for this job
   * @param string $name
   *  The human-readable name for the Broadcast
   * @param string $subject
   *  The subject for the Broadcast
   * @param string $from_name
   *  The from name for the Broadcast
   * @param string $from_email
   *  The from email for the Broadcast
   * @param string $reply_name
   *  The reply name for the Broadcast
   * @param string $reply_email
   *  The reply email for the Broadcast
   *
   * @return int
   *  The Message ID of the Broadcast that was created, else FALSE
   */
  public function newBroadcast($template, $name, $subject, $from_name='', $from_email='', $reply_name='', $reply_email='') {

    $new_record = array(
      'name' => $name,
      'created' => REQUEST_TIME,
      'lastsent' => 0,
      'subject' => $subject,
      'template' => $template,
      'from_name' => $from_name,
      'from_email' => $from_email,
      'reply_name' => $reply_name,
      'reply_email' => $reply_email,
    );

    if ($this->validateBroadcast($new_record, TRUE)) {
      $this->dbrow = $new_record;
      $broadcast_saved = $this->save();
    }
    else {
      $broadcast_saved = FALSE;
    }

    return $broadcast_saved;

  }

  /**
   * Sets the last sent timestamp
   *
   * @throws BadMethodCallException
   *  - If the message has not been loaded
   *
   * @return NULL
   */
  public function setLastSent($last_sent) {

    if (!isset($this->dbrow['mid'])) {
      throw new BadMethodCallException(
        t('Cannot change last sent for a message that has not been loaded')
      );
    }

    $new_record = $this->dbrow;
    $new_record['lastsent'] = $last_sent;

    if ($this->validateBroadcast($new_record)) {
      $this->dbrow = $new_record;
      $this->save();
    }

  }

  /**
   * Validates a broadcast array, ready to be inserted into a database, etc.
   *
   * @param &$broadcast array
   *    The broadcast to be validated. Note that this is passed by ref so that
   *    default values can be set if not given.
   * @param $validate_add bool
   *    Set to TRUE if this is validating the data required for an record add.
   *    Defaults to FALSE
   *
   * @throws InvalidArgumentException
   *  If any of the input is invalid. This is intended to be caught by the callee.
   *
   * @return bool
   *  TRUE if the broadcast input is valid, else FALSE
   */
  function validateBroadcast(&$broadcast = array(), $validate_add = FALSE) {

    global $base_url;

    // If a broadcast ID is specified, it MUST be numeric and be a positive
    // integer.
    if (isset($broadcast['mid'])) {
      if ($broadcast['mid'] < 0 || !is_numeric($broadcast['mid'])) {
        throw new InvalidArgumentException(t('Broadcast ID provided was invalid'));
      }
    }

    if (!$broadcast['name']) {
      throw new InvalidArgumentException(t('Broadcast name cannot be empty'));
    }

    // Set up name. May not be longer than 128 chars.
    $broadcast['name'] = check_plain($broadcast['name']);
    $broadcast['name'] = drupal_strlen($broadcast['name']) > 128 ? drupal_substr($broadcast['name'], 0, 128) : $broadcast['name'];

    if ($validate_add) {
      // Check that there's a created date (only validate on a record add)
      if (!isset($broadcast['created'])) {
        $broadcast['created'] = REQUEST_TIME;
      }
    }

    // Set up the template. If this is blank, use the first template we can get
    // our hands on. Check that the template is a valid one.
    $templates = wildfire_templates_get();

    // Are there any templates at all? Better make sure!
    if (!count($templates)) {
      $broadcast['template'] = '';
    }
    else {
      if (!isset($broadcast['template']) || $broadcast['template'] == '') {
        // If no template is already set for the broadcast, just grab the first
        // one we find from the list of templates on the system.
        $temp = array_shift($templates);
        $broadcast['template'] = $temp['name'];
      }
      elseif (empty($templates[$broadcast['template']])) {
        // The template does not exist. Use a 'safe' template that we know
        // exists.
        $temp = array_shift($templates);
        $broadcast['template'] = $temp['name'];
      }
    }

    // Set up some default values in case the user has left these fields blank.
    // The database's default values cannot be used because Drupal will try to
    // insert empty strings which won't trigger the database defaults.
    $defaults = array(
      'from_name' => 'Wildfire',
      'from_email' => variable_get('site_mail', 'webmaster@' . parse_url($base_url, PHP_URL_HOST)),
    );

    foreach ($defaults as $key => $value) {
      if (!isset($broadcast[$key]) || $broadcast[$key] == '') {
        $broadcast[$key] = $value;
      }
    }

    // If the reply name and email were not filled in, copy these from the 'from'
    // fields.
    if (!isset($broadcast['reply_name']) || $broadcast['reply_name'] == '') {
      $broadcast['reply_name'] = $broadcast['from_name'];
    }
    if (!isset($broadcast['reply_email']) || $broadcast['reply_email'] == '') {
      $broadcast['reply_email'] = $broadcast['from_email'];
    }

    return TRUE;
  }

  /**
   * {@inheritdoc}
   */
  public function delete() {

    if (!isset($this->dbrow['mid'])) {
      throw new BadMethodCallException(
        t('Cannot delete a message that has not been loaded')
      );
    }

    db_delete('wildfire_broadcasts')
      ->condition('mid', $this->dbrow['mid'], '=')
      ->execute();

    /**
     * Also delete any attached regions for this broadcast, if any are defined.
     * We use a callback for this so that any extension modules that implement
     * extra region types also have the chance to clean up.
     */
    module_invoke_all(
      'wildfire_message_delete_regions',
      'broadcast',
      $this->dbrow['mid']
    );

    return TRUE;

  }

  /**
   * {@inheritdoc}
   */
  public function getType() {
    return self::$type;
  }

  /**
   * Get the title for this message object. Useful for setting a parent
   * jobs title.
   *
   * For broadcast objects, the message title is equal to the 'subject' line
   * of the broadcast.
   *
   * @return string
   *  String representing the title for this object.
   */
  public function getTitle() {
    return $this->dbrow['subject'];
  }

  /**
   * {@inheritdoc}
   */
  public function getMetadata() {

    $message = array(
      'type' => 'broadcast',
      'mid' => $this->dbrow['mid'],
    );

    return module_invoke_all('wildfire_message_metadata', $message);

  }

}
