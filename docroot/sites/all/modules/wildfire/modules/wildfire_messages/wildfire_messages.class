<?php
/**
 * @file
 *  Interfaces and Classes for Wildfire Messages module
 *
 * @author Craig Jones <craig@tiger-fish.com>
 */

define('WILDFIRE_MESSAGE_FORMAT_HTML', 0);
define('WILDFIRE_MESSAGE_FORMAT_PLAIN', 1);

/**
 * Class to handle templates
 */
class WildfireTemplate {
  /**
   * TODO: convert Wildfire Template handling into a class, and
   * separate the template functionality out into a separate module.
   */
}

/**
 * Interface for WildfireClientMessageInterface
 *
 * You can derive your Message implementation directly from this interface,
 * but it's recommended that you extend the WildfireClientMessage abstract
 * class instead so that common functionality does not have to be reimplemented
 * in you derived class.
 *
 * Of course, if you want to do the whole works yourself, this is the place to
 * start!
 */
interface WildfireClientMessageInterface {

  /**
   * Preprocess the body of the message by aliasing links.
   *
   * @param int $jid
   *    The job ID of the job being sent.
   *
   * @throws BadMethodCallException
   *  If the message has not yet been rendered
   *
   * @return bool
   *  TRUE if the aliasing was successful, else FALSE
   *
   */
  public function addTrackingToLinks($jid);

  /**
   * Deletes the specified message.
   *
   * After deletion, the object is in an undefined state. You should unset() the
   * object in the callee immediately after issuing a delete().
   *
   * @throws InvalidArgumentException
   *  If the ID given to delete is not valid e.g. the object isn't loaded
   *
   * @return bool
   *  TRUE if the deletion was successful, else FALSE
   */
  public function delete();

  /**
   * Returns the raw content from the object
   *
   * @param int $format
   *  One of the following constants:
   *    WILDFIRE_MESSAGE_FORMAT_HTML
   *    WILDFIRE_MESSAGE_FORMAT_PLAIN
   * Defaults to WILDFIRE_MESSAGE_FORMAT_HTML
   *
   * @return string
   *  The HTML or Plain text output of the message rendered as is without any
   *  token replacements made.
   */
  public function getContent($format = WILDFIRE_MESSAGE_FORMAT_HTML);

  /**
   * Returns the content from the object with tokens replaced as appropriate
   *
   * @param int $format
   *  One of the following constants:
   *    WILDFIRE_MESSAGE_FORMAT_HTML
   *    WILDFIRE_MESSAGE_FORMAT_PLAIN
   * Defaults to WILDFIRE_MESSAGE_FORMAT_HTML
   *
   * @return string
   *  The HTML or Plain text output of the message rendered with all token
   *  replacements made.
   */
  public function getContentWithTokenReplacements($format = WILDFIRE_MESSAGE_FORMAT_HTML);

  /**
   * Static method to obtain an appropriate object implementing
   * WildfireClientMessageInterface depending on the type given.
   *
   * @static
   *
   * @param int $type
   *  The type of the Message
   *
   * @throws InvalidArgumentException
   *  If the implementation for the requested class type does not exist.
   *
   * @return WildfireClientMessage
   *  An object implementing the WildfireClientMessageInterface, with the
   *  relevant per-type extensions.
   */
  public static function getMessageObject($type);

  /**
   * Returns the tokenized form of the content. Used by WildfireClientJobs
   * to extract the messages content in the correct format for upload to the
   * master server.
   *
   * @return array
   *  Array representing the tokenized fragments, that when concatenated
   *  back together will build the message.
   */
  public function getTokenizedContent();

  /**
   * Gets the Token list from a message that has been rendered and tokenized.
   *
   * This is read-only data essentially - there shouldn't be many, if any,
   * reasons to want to manipulate this externally from the class.
   *
   * @return array
   *  Associative array representing the tokens list for this object.
   */
  public function getTokenList();

  /**
   * Returns the token replacements from the last call to
   * WildfireClientMessageInterface->populateTokenReplacements().
   * Used by WildfireClientJobs to extract the replacements that are relevant
   * to this user / job / message combination.
   *
   * @return array
   *  Array representing the token replacements that will be made in a
   *  call to $this->getContentWithTokenReplacements().
   */
  public function getTokenReplacements();

  /**
   * Gets the classes type. Required as this variable is declared as static.
   *
   * @return string
   *  The classes type
   */
  public function getType();

  /**
   * Loads an object state from the database into the object
   *
   * @throws InvalidArgumentException
   *  If the Message ID is invalid or can't be loaded.
   *
   * @param int $mid
   *  Message ID to load
   *
   * @return bool
   *  TRUE if the load succeeded, else FALSE
   */
  public function load($mid);

  /**
   * Retrieve a list of token replacements for the list of tokens stored in
   * $this->tokens, depending on the user and job IDs given.
   *
   * @param int $jid
   *    Job ID of the job that we require tokens for
   * @param int $uid
   *    UID of the user that that we require tokens for
   * @param bool $reset
   *    Set to TRUE to reset the internal token module cache. Defaults to FALSE
   *
   * @throws InvalidArgumentException
   *  If the internal token list is empty, as the object will not know what
   *  tokens are required otherwise.
   *
   * @return array
   *    Array of token replacements keyed by token name
   */
  public function populateTokenReplacements($jid = 0, $uid = 0, $reset = FALSE);

  /**
   * Renders the message into $this->rawContent, ready for $this->get()
   * to return it.
   *
   * @throws InvalidArgumentException
   *  If the template to render is invalid
   *  If the message has not been fully loaded.
   */
  public function render();

  /**
   * Replace tokens in a tokenized block of text.
   *
   * Requirements:
   *   $this->tokenizedContent should contain a tokenized content structure
   *   $this->tokens should contain an extracted list of the tokens required
   *   $this->tokenReplacements should contain a list of token replacements,
   *    with entries for all of the tokens declared in $this->tokens.
   *
   * @throws InvalidArgumentException
   *  If any of the required internal variables are empty or invalid.
   *
   * @return string
   *  A string containing the chunks pieced back together with their
   *  replacements
   */
  public function replaceTokensInContent();

  /**
   * Saves the object state to the database
   *
   * If the Message ID in $this->dbrow['mid'] is already present, this should
   * perform an update to an existing Message. Else, it should create a new
   * database record for this message.
   *
   * @return int
   *  SAVED_NEW / SAVED_UPDATE on success, FALSE on failure
   */
  public function save();

  /**
   * Manually set token replacements. Used for test sends, etc.
   *
   * @param array $tokens
   *  Associative array of tokens to set. Note that this array should contain
   *  replacements for all of the tokens that have been found in the content
   *  i.e. all tokens listed in $this->tokens
   *
   * @throws BadMethodCallException
   *  If the message has not been rendered yet / there are no tokens in the
   *  content
   *
   * @throws InvalidArgumentException
   *  If the array does not contain all of the necessary tokens,
   *
   * @return bool
   *  TRUE if the set was successful, else FALSE
   */
  public function setTokenReplacements($tokens);

  /**
   * Take an email body and split it up into sections of text and tokens.
   *
   * The content must have already been passed through $this->render() first
   * i.e. $this->rawContent should contain the raw message content as a string.
   *
   * @throws BadMethodCallException
   *  If the message has not been rendered yet
   *
   * @return array
   *    array(
   *      0 => The chunks of text and tokens as an array
   *      1 => A list of the unique tokens we found, with their indexes into
   *          0 as an array for each element
   *    );
   */
  public function tokenizeContent();

  /**
   * Get the title for this message object. Useful for setting a parent
   * jobs title.
   *
   * @return string
   *  String representing the title for this object.
   */
  public function getTitle();

  /**
   * Obtains all of the regions valid for the template specified for this
   * message.
   *
   * @return array
   *  Array of regions attached to this message object
   */
  public function getRegions();

  /**
   * Gets the content contained within any attached regions.
   *
   * @return array
   *  Array of content for the attached regions, keyed by region machine name
   */
  public function getRegionContent();

  /**
   * Gets the metadata, such as message subject, from name, etc, for this
   * message.
   *
   * @return array|bool
   *  Associative array of metadata, or FALSE on failure
   */
  public function getMetadata();

}

/**
 * Abstract class to handle Messages.
 *
 * This is an abstract base class implementing the WildfireMessageInterface
 * interface, to allow you to extend it whilst not needing to 'reinvent the
 * wheel' for functionality common to all message objects.
 *
 * WildfireBroadcast should be used as an example of how to create your
 * class implementing WildfireMessageInterface from this abstract class.
 */
abstract class WildfireClientMessage implements WildfireClientMessageInterface {

  /**
   * @var $type
   *  The type of message implemented by this class. Used to lookup if this
   *  class implements the type we require.
   */
  public static $type = 'message';

  /**
   * @var $dbrow
   *  Database row representing the objects state
   */
  protected $dbrow;

  /**
   * @var $rawContent
   *  String representing the raw content of the message
   */
  protected $rawContent;

  /**
   * @var $tokenizedContent
   *  Array containing the internal tokenized chunk form of the content.
   */
  protected $tokenizedContent;

  /**
   * @var $tokens
   *  An array of tokens discovered in the content.
   */
  protected $tokens;

  /**
   * @var $tokenReplacements
   *  Array representing the tokens that should be replaced on a getContentWithTokenReplacements()
   */
  protected $tokenReplacements;

  /**
   * @var bool $stale
   *  Whether the data in $this->dbrow needs to be committed
   */
  protected $stale = FALSE;

  /**
   * Constructor
   *
   * @param int $mid
   *  If not empty, initializes the new object state to this message
   */
  public function __construct($mid = NULL) {

    if (!empty($mid)) {
      $this->load($mid);
    }

  }

  /**
   * Magic method to obtain data from the local db row by reading unset
   * properties.
   *
   * @param name
   *  The name of the unset property
   *
   * @return string
   *  Value for the property, or NULL if the key does not exist in $this->dbrow
   */
  public function __get($name) {

    if (array_key_exists($name, $this->dbrow)) {
      return $this->dbrow[$name];
    }

    // Raise a non-fatal error if the property does not exist
    $trace = debug_backtrace();
    trigger_error(
      'Undefined property via WildfireJob->__get(): ' . $name .
      ' in ' . $trace[0]['file'] .
      ' on line ' . $trace[0]['line'],
      E_USER_NOTICE);
    return NULL;

  }

  /**
   * Magic method to set data to the local db row by writing unset
   * properties.
   *
   * @param name
   *  The name of the unset property
   *
   * @param value
   *  The value to set
   *
   * @return NULL
   */
  public function __set($name, $value) {

     $this->dbrow[$name] = $value;
     $this->stale = TRUE;

  }

  /**
   * Destructor
   */
  public function __destruct() {

    if ($this->stale) {
      $this->save();
    }

  }

  /**
   * Magic method to use with isset() / empty()
   *
   * @param name
   *  The name of the property
   *
   * @return bool
   *  TRUE if it is set, else FALSE
   */
  public function __isset($name) {

    return isset($this->dbrow[$name]);

  }

  /**
   * {@inheritdoc}
   *
   * Implement this method in your extension class
   *
   * Declaration is commented out due to this PHP Bug:
   * https://bugs.php.net/bug.php?id=43200
   */
  //abstract public function load($mid);

  /**
   * {@inheritdoc}
   *
   * Implement this method in your extension class
   *
   * Declaration is commented out due to this PHP Bug:
   * https://bugs.php.net/bug.php?id=43200
   */
  //abstract public function save();

  /**
   * {@inheritdoc}
   *
   * Implement this method in your extension class
   *
   * Declaration is commented out due to this PHP Bug:
   * https://bugs.php.net/bug.php?id=43200
   */
  //abstract public function delete();

  /**
   * Gets the Token list from a message that has been rendered and tokenized.
   *
   * This is read-only data essentially - there shouldn't be many, if any,
   * reasons to want to manipulate this externally from the class.
   *
   * @return array
   *  Associative array representing the tokens list for this object.
   */
  public function getTokenList() {
    return $this->tokens;
  }

  /**
   * Convert an HTML email's body to text-only format.
   *
   * This is heavily based on Drupal 6's drupal_html_to_text() but with the call
   * to filter_htmlcorrector() commented out. This is because our text contains
   * tokens and this filter struggles when it encounters tokens inside href=""
   * and possibly other places.
   *
   * This means that this function does not correct poorly formed HTML, so if a
   * bad HTML document is converted to text, the results are somewhat
   * unpredictable.
   *
   * @param string $string
   *    The HTML body of the email.
   *
   * @return string
   *    The same email body, but converted to text-only format.
   */
  private function htmlToText($string) {
    // Cache list of supported tags.
    static $supported_tags;
    if (empty($supported_tags)) {
      $supported_tags = array('a', 'em', 'i', 'strong', 'b', 'br', 'p', 'blockquote', 'ul', 'ol', 'li', 'dl', 'dt', 'dd', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr');
    }

    // Make sure tags, entities and attributes are well-formed and properly
    // nested. Commented out since this causes issues when encountering
    // wildfire tokens.
    //$string = _filter_htmlcorrector(filter_xss($string, $allowed_tags));

    // Apply inline styles.
    $string = preg_replace('!</?(em|i)((?> +)[^>]*)?>!i', '/', $string);
    $string = preg_replace('!</?(strong|b)((?> +)[^>]*)?>!i', '*', $string);

    // Replace inline <a> tags with the text of link and a footnote.
    // 'See <a href="http://drupal.org">the Drupal site</a>' becomes
    // 'See the Drupal site [1]' with the URL included as a footnote.
    _drupal_html_to_mail_urls(NULL, TRUE);
    $pattern = '@(<a[^>]+?href="([^"]*)"[^>]*?>(.+?)</a>)@i';
    $string = preg_replace_callback($pattern, '_drupal_html_to_mail_urls', $string);
    $urls = _drupal_html_to_mail_urls();
    $footnotes = '';
    if (count($urls)) {
      $footnotes .= "\n";
      for ($i = 0, $max = count($urls); $i < $max; $i++) {
        $footnotes .= '[' . ($i + 1) . '] ' . $urls[$i] . "\n";
      }
    }

    // Split tags from text.
    $split = preg_split('/<([^>]+?)>/', $string, -1, PREG_SPLIT_DELIM_CAPTURE);
    // Note: PHP ensures the array consists of alternating delimiters and literals
    // and begins and ends with a literal (inserting $null as required).

    $tag = FALSE; // Odd/even counter (tag or no tag)
    $casing = NULL; // Case conversion function
    $output = '';
    $indent = array(); // All current indentation string chunks
    $lists = array(); // Array of counters for opened lists
    foreach ($split as $value) {
      $chunk = NULL; // Holds a string ready to be formatted and output.

      // Process HTML tags (but don't output any literally).
      if ($tag) {
        list($tagname) = explode(' ', drupal_strtolower($value), 2);
        switch ($tagname) {
          // List counters
          case 'ul':
            array_unshift($lists, '*');
            break;
          case 'ol':
            array_unshift($lists, 1);
            break;
          case '/ul':
          case '/ol':
            array_shift($lists);
            $chunk = ''; // Ensure blank new-line.
            break;

            // Quotation/list markers, non-fancy headers
          case 'blockquote':
            // Format=flowed indentation cannot be mixed with lists.
            $indent[] = count($lists) ? ' "' : '>';
            break;
          case 'li':
            $indent[] = is_numeric($lists[0]) ? ' ' . $lists[0]++ . ') ' : ' * ';
            break;
          case 'dd':
            $indent[] = '    ';
            break;
          case 'h3':
            $indent[] = '.... ';
            break;
          case 'h4':
            $indent[] = '.. ';
            break;
          case '/blockquote':
            if (count($lists)) {
              // Append closing quote for inline quotes (immediately).
              $output = rtrim($output, "> \n") . "\"\n";
              $chunk = ''; // Ensure blank new-line.
            }
            // Fall-through
          case '/li':
          case '/dd':
            array_pop($indent);
            break;
          case '/h3':
          case '/h4':
            array_pop($indent);
          case '/h5':
          case '/h6':
            $chunk = ''; // Ensure blank new-line.
            break;

            // Fancy headers
          case 'h1':
            $indent[] = '======== ';
            $casing = 'drupal_strtoupper';
            break;
          case 'h2':
            $indent[] = '-------- ';
            $casing = 'drupal_strtoupper';
            break;
          case '/h1':
          case '/h2':
            $casing = NULL;
            // Pad the line with dashes.
            $output = _drupal_html_to_text_pad($output, ($tagname == '/h1') ? '=' : '-', ' ');
            array_pop($indent);
            $chunk = ''; // Ensure blank new-line.
            break;

            // Horizontal rulers
          case 'hr':
            // Insert immediately.
            $output .= drupal_wrap_mail('', implode('', $indent)) . "\n";
            $output = _drupal_html_to_text_pad($output, '-');
            break;

            // Paragraphs and definition lists
          case '/p':
          case '/dl':
            $chunk = ''; // Ensure blank new-line.
            break;
        }
      }
      // Process blocks of text.
      else {
        // Convert inline HTML text to plain text.
        $value = trim(preg_replace('/\s+/', ' ', decode_entities($value)));
        if (drupal_strlen($value)) {
          $chunk = $value;
        }
      }

      // See if there is something waiting to be output.
      if (isset($chunk)) {
        // Apply any necessary case conversion.
        if (isset($casing)) {
          $chunk = $casing($chunk);
        }
        // Format it and apply the current indentation.
        $output .= drupal_wrap_mail($chunk, implode('', $indent)) . "\n";
        // Remove non-quotation markers from indentation.
        $indent = array_map('_drupal_html_to_text_clean', $indent);
      }

      $tag = !$tag;
    }

    return $output . $footnotes;
  }

  /**
   * {@inheritdoc}
   */
  public function tokenizeContent() {

    if (!isset($this->rawContent)) {
      throw new BadMethodCallException(
        t('Cannot tokenize a message that has not yet been rendered')
      );
    }

    $pieces = explode(WILDFIRE_TOKEN_START, $this->rawContent);
    $c = count($pieces);
    $chunks = array();  // Used to store our final set of tokens and text.
    $token_list = array(); // Used to store a list of unique tokens we found.

    $k = 0;
    // Allegedly this for() loop is much faster. Has other benefits in terms of
    // modifying the original array, too.
    for ($i = 0; $i < $c; $i++) {
      // Find the position of the closing token in the piece.
      $pos = strpos($pieces[$i], WILDFIRE_TOKEN_END);

      // If there is not an end token in this piece, just move onto the next
      // piece.
      if ($pos === FALSE) {
        continue;
      }

      // Get the name of the token. For {{wildfire:uid}}, will be 'uid'.
      $token_name = drupal_substr($pieces[$i], 0, $pos);

      // Remove the token's end part from the current piece.
      $pieces[$i] = drupal_substr($pieces[$i], $pos + drupal_strlen(WILDFIRE_TOKEN_END));

      // Add the PREVIOUS piece to the chunks array, then re-formulate the token
      // and add that as a separate array element.
      $chunks[$k++] = $pieces[$i - 1];
      $token = WILDFIRE_TOKEN_START . $token_name . WILDFIRE_TOKEN_END;
      $chunks[$k++] = $token;

      // Add the token and the index where it was found to the token list,
      // so we don't have to scan $chunks later to obtain them outside the
      // function.
      $token_list[$token_name][] = $k - 1;
    }

    // Add on the final piece of the array.
    $chunks[] = $pieces[$c - 1];

    // Store the token list with offsets.
    $this->tokens = $token_list;

    // Store the content chunks
    $this->tokenizedContent = $chunks;

    return TRUE;
  }

  /**
   * {@inheritdoc}
   */
  public function addTrackingToLinks($jid) {

    if (!isset($this->rawContent)) {
      throw new BadMethodCallException(
        t('Cannot alias links in a message that has not yet been rendered')
      );
    }

    // AFTER the body has been rendered, we need to swap all links. This function
    // will be passed a rendered string.
    $links = preg_match_all('/href="([^"]+)"/i', $this->rawContent, $matches, PREG_SET_ORDER);

    if (!$links) {
      return FALSE;
    }

    foreach ($matches as $match) {
      /**
       * If the href begins with WILDFIRE_TOKEN_START it is more than
       * likely to be one of our tokens, so just skip this one and move onto
       * the next. Also, don't track mailto: links.
       */
      $token_start_length = drupal_strlen(WILDFIRE_TOKEN_START);
      if (drupal_substr($match[1], 0, $token_start_length) == WILDFIRE_TOKEN_START ||
          drupal_substr($match[1], 0, 7) == 'mailto:'
      ) {
        continue;
      }

      module_load_include('module', 'wildfire_tracking', 'wildfire_tracking');
      $link = wildfire_tracking_link_add($match[1], $jid);

      if (!$link) {
        // If the link is not a string (highly unlikely), or it exceeds 333
        // characters, just skip this link - it hasn't been entered into the
        // database anyway; replacing the link is pointless.
        continue;
      }

      $link = 'href="'
        . url(
            'wildfire/link/' . $link,
            array('absolute' => TRUE)
          ) . '/{{wildfire:uid}}"';

      if (isset($link)) {
        $this->rawContent = str_replace($match[0], $link, $this->rawContent);
      }
    }

    return TRUE;
  }

  /**
   * {@inheritdoc}
   */
  public function replaceTokensInContent() {

    if (empty($this->tokenizedContent)) {
      throw new InvalidArgumentException(t('Cannot get content as it has not been tokenized yet'));
    }
    if (empty($this->tokens)) {
      throw new InvalidArgumentException(t('Token list is empty'));
    }
    if (empty($this->tokenReplacements)) {
      throw new InvalidArgumentException(t('No replacements for tokens have been given'));
    }

    $output = '';
    $fragments = array();

    // Go through the token list, and replace tokens in $chunks based on index.
    foreach ($this->tokens as $token_name => $indexes) {
      for ($i = 0; $i < count($indexes); $i++) {
        if (!empty($this->tokenReplacements[$token_name])) {
          $fragments[$indexes[$i]] = $this->tokenReplacements[$token_name];
        }
        else {
          // We have no replacement, so replace with an empty string
          // to prevent junk entering into the finalized message.
          $fragments[$indexes[$i]] = '';
        }
      }
    }

    // Construct the message
    $frag_count = count($this->tokenizedContent);
    for ($i = 0; $i < $frag_count; $i++) {
      if (!empty($fragments[$i])) {
        // Use the replacement we found
        $output .= $fragments[$i];
      }
      else {
        // Use the original fragment from $this->tokenizedContent
        $output .= $this->tokenizedContent[$i];
      }
    }

    return $output;
  }

  /**
   * {@inheritdoc}
   */
  public function render() {

    if (!isset($this->dbrow['mid'])) {
      throw new BadMethodCallException(
        t('Cannot render a message that has not been loaded')
      );
    }

    // Load the Templates API
    module_load_include('inc', 'wildfire_messages', 'wildfire_messages.template.api');

    $templates = wildfire_template_get_available();

    // If the template to render is invalid, throw an exception.
    if ( !isset($this->dbrow['template'])
        || $this->dbrow['template'] == ''
        || !in_array($this->dbrow['template'], array_keys($templates))
    ) {

      throw new InvalidArgumentException(
        t(
          'Cannot render message as its template (!template) cannot be found',
          array(
            '!template' => $this->dbrow['template']
          )
        )
      );

    }

    // Setup the $vars array for use inside the template
    $vars = array();

    // Reserved $vars names
    $reserved_vars = array('message', 'regions', 'template');


    /**
     * Get our valid template definition so we can reference it inside the
     * template
     */
    $vars['template'] = $templates[$this->dbrow['template']];

    //Collate details about the message, such as the header metadata, etc
    $vars['message'] = $this->getMetadata();
    $vars['message']['title'] = $this->getTitle();

    // Get all of the region content to use within the template
    $vars['regions'] = $this->getRegionContent();

    /**
     * Link the region content to their own variables. This is to make life
     * easy for template authors, as they then don't have to create these
     * shortcuts within mailtemplate.php
     */
    if (!empty($vars['regions'])) {
      foreach($vars['regions'] as $region_type => &$region) {
        foreach($region as $region_name => &$content) {
          $key = drupal_strtolower($region_type . '_' . $region_name);
          $key = preg_replace('/[^a-z0-9\-_]/', '_', $key);
          $vars[$key] =& $content['content'];
          $reserved_vars[] = $key;
        }
      }
    }

    // If the template has settings, pull these in
    $settings = wildfire_templates_get_settings($this->dbrow['template'], 0);
    // Set the vars
    if (!empty($settings)) {
      foreach ($settings as $key => $value) {
        /**
         * Skip reserved keys, in case somebody did something wrong in the
         * template definition, like recycling a regions name for a setting, etc.
         */
        if (in_array($key, $reserved_vars)) {
          continue;
        }
        $vars[$key] = $value;
      }
    }

    /**
     * Load the mailtemplate.php file, if there is one, so that its functions
     * are available to the mail template.
     */
    $mailtemplate_file = DRUPAL_ROOT . '/' . $vars['template']['path'] . '/mailtemplate.php';
    if (file_exists($mailtemplate_file)) {
      require_once $mailtemplate_file;
    }

    /**
     * If the mailtemplate.php file declared a preprocess function,
     * call that now to preprocess the $vars array.
     */
    $preprocess_callback = $vars['template']['name'] . '_preprocess_mailtemplate';
    if (is_callable($preprocess_callback)) {
      $preprocess_callback($vars);
    }

    // Perform the actual render
    $contents = $this->renderTemplate(
      $vars['template']['name'],
      $vars['template']['path'],
      $vars
    );

    // Store the raw content
    $this->rawContent = $contents;

    // Process the content for tokens, etc
    $this->tokenizeContent();

    return TRUE;
  }

  /**
   * {@inheritdoc}
   *
   * Presently, all this does is call wildfire_template_get_regions(). This
   * will be able to use a WildfireTemplate object once implemented to do the
   * same.
   */
  public function getRegions() {

    return wildfire_template_get_regions($this->dbrow['template']);

  }

  /**
   * {@inheritdoc}
   *
   * Presently, all this does is invoke 'wildfire_message_populate' with the
   * right parameters to obtain the messages content from the module that
   * implements regions for the type of object this is.
   */
  public function getRegionContent() {

    /**
     * Only pass in the minimum we need in order to get the region content,
     * which is the mid, type and the region definitions.
     */
    $populate['mid'] = $this->dbrow['mid'];
    $populate['type'] = $this->getType();
    $populate['regions'] = $this->getRegions();

    $populate = module_invoke_all('wildfire_message_populate', $populate);

    if (!empty($populate['regions'])) {
      return $populate['regions'];
    }
    else {
      return array();
    }

  }

  /**
   * Protected class method to render the template in a "sandbox" so that other
   * variables from the exposed render() method don't leak into it.
   *
   * @param string $name
   *  Machine name of the template being rendered
   * @param string $path
   *  Path to the template file to render
   *
   * @param array $vars
   *  Array of template vars. These will be expanded into actual named variables
   *  e.g.
   *    $vars = array('a' => '1', 'b' => '2');
   *    ... will be expanded to...
   *    $a = '1';
   *    $b = '2';
   *
   * @return string
   *  The rendered template content.
   *
   * TODO: should be a method of WildfireTemplate when it gets implemented
   */

  protected function renderTemplate($name, $path, $vars = array()) {

    /**
     * Extract $vars into variables with same name as the key. Prefix any
     * collisions with wf_
     */
    extract($vars, EXTR_PREFIX_SAME, 'wf_');

    /**
     * =========================================================================
     * WARNING
     *
     * If the template fails to be included (for example, it's not valid PHP
     * or it calls functions internally that aren't defined), execution will
     * halt and you will either get the contents of the output buffer up to the
     * fail point, or a white screen of death.
     *
     * TODO: perform syntax checking on the template before classing as 'valid'
     * =========================================================================
     */
    ob_start();
    include DRUPAL_ROOT . '/' . $path . '/' . $name . '.tpl.php';
    $contents = ob_get_contents();
    ob_end_clean();

    return $contents;

  }

  /**
   * {@inheritdoc}
   */
  public function getContent($format = WILDFIRE_MESSAGE_FORMAT_HTML) {

    if ($format == WILDFIRE_MESSAGE_FORMAT_PLAIN) {
      return $this->htmlToText($this->rawContent);
    }
    else {
      return $this->rawContent;
    }

  }

  /**
   * {@inheritdoc}
   */
  public function getContentWithTokenReplacements($format = WILDFIRE_MESSAGE_FORMAT_HTML) {

    if (empty($this->tokenizedContent)) {
      throw new InvalidArgumentException(t('Cannot get content as it has not been tokenized yet'));
    }
    if (empty($this->tokenReplacements)) {
      throw new InvalidArgumentException(t('No replacements for tokens have been given'));
    }

    $output = $this->replaceTokensInContent();

    if ($format == WILDFIRE_MESSAGE_FORMAT_PLAIN) {
      return $this->htmlToText($output);
    }
    else {
      return $output;
    }

  }

  /**
   * {@inheritdoc}
   */
  public function getTokenizedContent() {
    return $this->tokenizedContent;
  }

  /**
   * {@inheritdoc}
   */
  public function getTokenReplacements() {
    return $this->tokenReplacements;
  }

  /**
   * {@inheritdoc}
   */
  public function populateTokenReplacements($jid = 0, $uid = 0, $reset = FALSE) {

    if (empty($this->tokens)) {
      throw new InvalidArgumentException(t('Token list is empty'));
    }

    // Cache the module list, so that we only have to work it out once.
    $token_module_cache =& drupal_static(__FUNCTION__);

    $this->tokenReplacements = array();

    if (empty($token_module_cache) || $reset) {

      $token_modules = module_invoke_all('wildfire_token_info');

      foreach ($token_modules as $module => $module_token_list) {
        foreach ($module_token_list as $module_token) {
          // If already set, some other module is providing the token already
          // TODO: implement a weighting system for the cache
          if (!isset($token_module_cache[$module_token])) {
            $token_module_cache[$module_token] = $module;
          }
        }
      }

    }

    // Got through each token we need, find which module implements it, and
    // call its callback
    foreach ($this->tokens as $token_name => $indexes) {

      if (!isset($this->tokenReplacements[$token_name])) {
        if (isset($token_module_cache[$token_name])) {

          $this->tokenReplacements[$token_name] = module_invoke(
            $token_module_cache[$token_name],
            'wildfire_token',
            $token_name,
            array(
              'uid' => $uid,
              'jid' => $jid,
            )
          );

        }
      }

    }

  }

  /**
   * {@inheritdoc}
   */
  public function setTokenReplacements($tokens) {

    if (empty($this->tokens)) {
      throw new BadMethodCallException(t('Token list is empty'));
    }

    // Sort the internal token list
    ksort($this->tokens);

    // Sort the input
    ksort($tokens);

    // Do they both contain the same keys?
    if (array_keys($this->tokens) !== array_keys($tokens)) {
      throw new InvalidArgumentException(
        t(
          'Token replacements were not given for all tokens found in the content (Expected:!expected, Got:!actual)',
          array(
            '!expected' => print_r(array_keys($this->tokens), TRUE),
            '!actual' => print_r(array_keys($tokens), TRUE),
          )
        )
      );
    }

    // If they contain the same keys, set the objects replacements to the input
    $this->tokenReplacements = $tokens;

  }



  /**
   * {@inheritdoc}
   *
   * *** THIS CODE WORKS ON PHP 5.3+ ONLY ***
   * due to referencing class in a variable (i.e. $class::$type)
   */
  public static function getMessageObject($type) {

    /**
     * If the type requested is the base class type, short-circuit the search
     * and throw an exception, because what you are trying to do is silly.
     */
    if (WildfireClientMessage::$type == $type) {
      throw new InvalidArgumentException(
        t('Cannot directly instantiate abstract class WildfireClientMessage')
      );
    }

    /**
     * Ensure that any class that's related to Wildfire is declared
     * This is a workaround for the fact that classes are not autoloaded until
     * their first use, meaning that their definitions won't be available to
     * search unless the class is already declared somehow.
     *
     * We assume that the class file will be called wildfire_<something>.class
     * and resides in the root of any wildfire_<something> modules folder.
     *
     * TODO: Document this formally for the benefit of extension module authors
     */
    $module_list = module_list();
    foreach($module_list as $module) {
      if (substr($module, 0, 8) == 'wildfire') {
        module_load_include('class', $module, $module);
      }
    }

    // Search all declared classes for one that implements the type requested
    foreach (get_declared_classes() as $class) {
      if (is_subclass_of($class, 'WildfireClientMessageInterface')) {
        if (isset($class::$type) && $class::$type == $type) {
          return new $class;
        }
      }
    }

    /**
     * No class implements the requested type. Raise an exception as any code
     * that relies on having an object to use should really be requesting
     * a valid type
     */
    throw new InvalidArgumentException(
      t(
        'No class implementing WildfireClientMessageInterface implements the type "!type"',
        array(
          '!type' => $type
        )
      )
    );

  }

  /**
   * {@inheritdoc}
   */
  public function getType() {
    return self::$type;
  }

  /**
   * Sets the raw content of the message. Only to be used in testing scenarios;
   * in all other cases, this should only be set by a call to $this->render();
   *
   * @throws BadMethodCallException
   *  If you try to call this outside of a SimpleTest.
   *
   * @param $content
   * @return bool
   */
  public function _setRawContent($content) {

    $test_info = &$GLOBALS['drupal_test_info'];
    if (empty($test_info['test_run_id'])) {
      throw new BadMethodCallException(
        t('You cannot call _setRawContent() outside of a SimpleTest run')
      );
    }

    // Store the raw content
    $this->rawContent = $content;

    // Process the content for tokens, etc
    $this->tokenizeContent();

    return TRUE;

  }

  /**
   * Insert a Job Tracking image into the messages rendered content.
   *
   * @param int $jid
   *  Job ID of job to insert a tracking image for
   *
   * @throws InvalidArgumentException
   *  If the object has not yet been rendered
   */
  public function addTrackingImage($jid) {

    if (empty($this->rawContent)) {
      throw new InvalidArgumentException(t('Cannot inject a tracking image into a message that is not yet rendered'));
    }

    // This code uses the Wildfire Tracking API, so let's load it.
    module_load_include('module', 'wildfire_tracking', 'wildfire_tracking');
    $this->rawContent = wildfire_tracking_inject_image(
      $this->rawContent,
      $this->getType(),
      $this->dbrow['mid'],
      $jid
    );

    // If the tokenized version has been built, rebuild with the new content.
    if (!empty($this->tokenizedContent)) {
      $this->tokenizeContent();
    }

  }

}
