<?php
/**
 * @file
 * Wildfire Web Test Case master class from which others inherit.
 *
 * All other test classes inherit from this class, which provides some
 * Wildfire-specific methods like being able to generate a generic job for
 * sending.
 */
class WildfireWebTestCase extends DrupalWebTestCase {

  protected $preFail = FALSE,
            $user,
            // The following email address is where we want our test emails to
            // be sent; we don't want a randomly generated email because we
            // will never see the email. And we certainly don't want the email
            // to point to a client!
            $test_email = 'webmaster@wildfirehq.co.uk',

            $default_template = 'wildfire_example_newsletter',
            $permissions = NULL;
  public $template;

  /** ------------------------------------------------------------------------
   * Setup
   * Setup generic configuration for all tests.
   *
   * @param array $modules
   *    An array of the names of the modules that should be enabled.
   */
  public function setUp($modules = array()) {
    // Deal with a situation where the caller has provided a string or
    // something instead of an array.
    if (!is_array($modules)) {
      $modules = array($modules);
    }

    // Add Wildfire to the list of other modules we need, if any.
    $modules[] = 'wildfire_lists';
    $modules[] = 'wildfire_messages';
    $modules[] = 'wildfire_broadcasts';
    $modules[] = 'wildfire_jobs';
    $modules[] = 'wildfire_tracking';
    $modules[] = 'wildfire';

    // Set up the list of modules.
    //call_user_func_array(array('parent', 'setUp'), $modules);
    //parent::setUp('wildfire');
    parent::setUp($modules);

    // Specify the permissions to grant to the temporary test user.
    $this->permissions = array(
      'use wildfire',
      'access content',
      'delete any page content',
      'delete own page content',
      'delete any article content',
      'delete own article content',
      'administer filters',
      'administer nodes',
      'administer content types',
      'bypass node access',
    );
    // Create the user with the specified permissions.
    $this->user = $this->drupalCreateUser($this->permissions);
    if ($this->user === FALSE) {
      $this->preFail = 'Failed to create test user. Test aborted';
      return;
    }
    $this->user->mail = $this->test_email;
    // There's no point creating a user if we don't log them in!
    $this->drupalLogin($this->user);

    // Right, we want a theme which has mail templates!
    // If you don't have templates in this theme, things are going to go
    // horribly wrong. There is no point testing for this situation, because
    // it will never happen in a production environment.
    // If it does, you're in big trouble :)
    $theme = 'bartik';
    if (!$this->setTheme($theme)) {
      $this->preFail = 'Failed to load theme "' . $theme . '". Test aborted.';
      return;
    }

    // Load a specific part of the module, so we can access it's functions.
    module_load_include('inc', 'wildfire_messages', 'wildfire_messages.template.api');

    // Fetch all the templates in the theme.
    $templates = wildfire_templates_refresh();

    // We need a template for this test. Don't care which one, as long as
    // there is one available.
    if (!is_array($templates) || count($templates) < 1) {
      // Oh noes! We haven't any templates!
      // We'll have to set that we failed in a class member, because we can't
      // use the fail() method from DrupalWebTestCase in setUp() for some
      // reason which I haven't bothered looking into yet.
      $this->preFail = 'No templates in theme. Test cannot run without them.';
      $this->template = '';
    }
    else {
      // Enable all templates, so the temporary test user can use them.
      foreach ($templates as $template) {
        wildfire_template_enable($template['name']);
      }
      // To be honest, we're being greedy; we only need one.
      // At least we aren't fussy, just grab the first one off the array, save
      // it so we can use it throughout the tests.
      $template = array_shift($templates);
      $this->template = $template['name'];
    }

    /**
     * Enable Clean URLs in the SimpleTest sandbox as it defaults to off.
     * Most of the UI tests presume that it's enabled, and all live systems
     * will have it enabled.
     */
    variable_set('clean_url', 1);

  }

  /** ------------------------------------------------------------------------
   * Tear Down (Destruct Method)
   * Do we really need to define this method if all we do is call the parent
   * method?
   *
   * @access public
   * @return void
   */
  /*
  public function tearDown() {
    parent::tearDown();
  }
  */

  /** ------------------------------------------------------------------------
   * Set Theme
   * Tries to set the theme specified by $theme as the system default for the
   * test. Returns true on success, false on failure.
   *
   * @access protected
   * @param  string    $theme
   * @return boolean
   */
  protected function setTheme($theme) {

    // Check that the theme we have specified exists.
    $query = db_select('system', 's')
      ->fields('s', array(
        'name',
      ));
    $query->condition('type', 'theme', '=');
    $query->condition('name', $theme, '=');
    $result = $query->execute();

    $result = $result->fetchField();

    if ($result === FALSE) {
      return FALSE;
    }

    // Update the system to use the specified theme as default.
    db_update('system')
      ->fields(array(
        'status' =>  1,
      )
    )
    ->condition('type', 'theme')
    ->condition('name', $theme)
    ->execute();

    // Play around with the system variable settings. Confusing stuff.
    variable_set('theme_default', $theme);
    unset($GLOBALS['theme']);

    // Bring the theme ALIVE!
    drupal_theme_initialize();
    return TRUE;
  }

  /** ------------------------------------------------------------------------
   * Simplified version of drupalPost() that allows posting to AJAX.
   *
   * This version of the function removes the check on the submit button, so
   * it can be used to POST data to an AJAX callback URL. It does no checking
   * on the result of the POST, so you will need to handle this yourself.
   *
   * @access protected
   * @param string $path
   * @param array $edit
   * @param array $options
   * @param array $headers
   * @return void
   */
  protected function simplePost($path, $edit, array $options = array(), array $headers = array()) {
    $action = $this->getAbsoluteUrl($path);
    $post = $edit;

    foreach ($post as $key => $value) {
      // Encode according to application/x-www-form-urlencoded
      // Both names and values needs to be urlencoded, according to
      // http://www.w3.org/TR/html4/interact/forms.html#h-17.13.4.1
      $post[$key] = urlencode($key) . '=' . urlencode($value);
    }
    $post = implode('&', $post);

    $out = $this->curlExec(array(CURLOPT_URL => $action, CURLOPT_POST => TRUE, CURLOPT_POSTFIELDS => $post, CURLOPT_HTTPHEADER => $headers));
    // Ensure that any changes to variables in the other thread are picked up.
    $this->refreshVariables();

    $this->pass('simplePost has posted data to ' . $path);
  }

  /** ------------------------------------------------------------------------
   * Debug: Var Dump Return
   *
   * @access protected
   * @param  mixed     $var
   * @param  boolean   $html
   * @return string
   */
  protected function vardump($var, $html = TRUE) {
    ob_start();
    var_export($var);
    $content = ob_get_contents();
    ob_end_clean();
    if ($html) {
      $content = htmlentities($content);
      $content = str_replace(
        array(' ', "\n"),
        array('&#160;', '<br />'),
        $content
      );
      $content = '<pre>' . $content . '</pre>';
    }
    return $content;
  }

  /**
   * Elapsed Time
   *
   * @access protected
   * @param  float|string  $start
   * @return string
   */
  protected function elapsedTime($start) {
    $end = microtime(true);
    if (is_string($start)) {
      $start = preg_match('/^0\\.[0-9]+ [0-9]+$/', $start)
        ? (float) preg_replace(
          '/^(0\\.[0-9]+) ([0-9]+)$/',
          '$2.$1',
          $start
        )
        : FALSE;
    }
    if (is_string($end)) {
      $start = preg_match('/^0\\.[0-9]+ [0-9]+$/', $end)
        ? (float) preg_replace('/^(0\\.[0-9]+) ([0-9]+)$/', '$2.$1', $end)
        : FALSE;
    }
    if (!is_float($start) || !is_float($end)) {
      return 'UNKNOWN';
    }
    $elapsed = $end - $start;
    return (string) round($elapsed, 3);
  }

  /**
   * SimpleTest Method Overwrite: assertLinkByHref
   *
   * For some reason, even though it is referenced in the API, I recieve a
   * fatal error saying that assertLinkByHref is undefined; nor can I find it
   * in the source. This is my implementation of what I believe it would have
   * been.
   * This is nowhere near thorough enough though, it does not support things
   * inside the URL, such as query strings or fragments. Mainly because I
   * don't know XPath.
   *
   * @access protected
   * @param  string    $href
   * @param  int       $index
   * @param  string    $message
   * @param  string    $group
   * @return boolean
   */
  protected function assertLinkByHref($href, $index = 0, $message = '', $group = 'Other') {
    $xpath = '//a[@href="' . url($href) . '"]';
    $links = $this->xpath($xpath);
    // If no links were returned, it's probably because the page contains
    // absolute URLs.
    if (count($links) == 0) {
      $xpath = '//a[@href="' . url($href, array('absolute' => TRUE)) . '"]';
      $links = $this->xpath($xpath);
    }
    $message = $message
      ? $message
      : t('Link with href "!href" found.', array('!href' => $href));
    return $this->assert(isset($links[$index]), $message, $group);
  }

  /**
   * Get Images
   *
   * Returns an array of unique URLs found inside <img /> src attributes.
   *
   * @access protected
   * @return array
   */
  protected function getImages() {
    $images = $this->xpath('//img[@src]');
    if (count($images) == 0) {
      return array();
    }
    $ret = array();
    foreach ($images as $image) {
      $image = (array) $image;
      if (isset($image['@attributes']['src'])) {
        $ret[] = $image['@attributes']['src'];
      }
    }
    $ret = array_unique($ret, SORT_REGULAR);
    return $ret;
  }

  /**
   * Create a new broadcast and add some nodes to it.
   *
   * @param int $num
   *    The number of nodes to generate on each repeater.
   * @param string $template
   *    The name of the template to use. If not given, uses the
   *    parent class default
   */
  protected function generateBroadcast($num = 0, $template = '') {
    module_load_include('inc', 'wildfire_broadcasts', 'wildfire_broadcasts.api');
    module_load_include('inc', 'wildfire_messages', 'wildfire_messages.template.api');
    $broadcast = array();

    $broadcast['name']     = $this->randomName();
    $broadcast['subject']  = $this->randomName();
    $broadcast['template'] = empty($template) ? $this->default_template : $template;

    // Check that the template we have now chosen for this Broadcast actually
    // exists
    $template = wildfire_template_get($broadcast['template']);
    if ($template === FALSE) {
      return FALSE;
    }

    $new_broadcast = new WildfireBroadcast();
    $new_broadcast->newBroadcast(
      $broadcast['template'],
      $broadcast['name'],
      $broadcast['subject']
    );

    // This emulates getting the entire row from the class
    /**
     * TODO: Tests should be refactored to use the individual class variables
     * directly as appropriate rather than hauling around this array
     */
    $broadcast = array(
      'mid' => $new_broadcast->mid,
      'name' => $new_broadcast->name,
      'created' => $new_broadcast->created,
      'lastsent' => $new_broadcast->lastsent,
      'subject' => $new_broadcast->subject,
      'template' => $new_broadcast->template,
      'from_name' => $new_broadcast->from_name,
      'from_email' => $new_broadcast->from_email,
      'reply_name' => $new_broadcast->reply_name,
      'reply_email' => $new_broadcast->reply_email,
    );

    // Most tests use id rather than mid, so alias it. This is to prevent
    // having to perform a refactor of the tests at this point.
    // TODO: Refactor tests to use mid instead.
    $broadcast['id'] =& $broadcast['mid'];

    // Work out what regions we should have on this template and set up dummy
    // content.
    $broadcast['regions'] = wildfire_template_get_regions($broadcast['template']);

    /**
     * Only generate a snippet if the node count to add is greater than 0. This
     * allows for the generation of 'empty' broadcasts.
     */
    if ($num > 0 && !empty($broadcast['regions']['snippets']) && is_array($broadcast['regions']['snippets'])) {
      foreach ($broadcast['regions']['snippets'] as $sname => &$snippet) {

        // Add a random string
        $snippet['content'][0] = $this->randomName(32);

        // Add some tokens
        $snippet['content'][0] .= '{{wildfire:user:test}}';
        $snippet['content'][0] .= '{{wildfire:message:test}}';

        // Add some multibyte characters
        $snippet['content'][0] .= '£¤± ¡multibyte string! £¤±£¤±';

        wildfire_snippet_save($sname, $broadcast['mid'], 'broadcast', $snippet['content'][0]);
      }
    }

    if ($num > 0 && !empty($broadcast['regions']['repeaters']) && is_array($broadcast['regions']['repeaters'])) {
      foreach ($broadcast['regions']['repeaters'] as $rname => &$repeater) {
        for ($i = 0; $i < $num; $i++) {
          $repeater['content'][$i] = $this->generateNode();
        }
        wildfire_repeater_save($rname, $broadcast['mid'], 'broadcast', $repeater['content']);
      }
    }

    return (object)$broadcast;
  }

  /**
   * Create a job ready for sending.
   *
   * Creates a sample broadcast with nodes, a sample list and a sample user to
   * be used for this job.
   *
   * @param int $num
   *    The number of nodes to be generated and attached to the broadcast that
   *    this job will generate.
   * @param int $users
   *    The number of users to generate and add to the mailing list.
   * @return array
   *    An array of the properties of the created Job object
   */
  protected function generateJob($num = 2, $users = 2) {
    module_load_include('inc', 'wildfire_lists', 'wildfire_lists.api');
    module_load_include('inc', 'wildfire_jobs', 'wildfire_jobs.send');
    module_load_include('inc', 'wildfire_jobs', 'wildfire_jobs.api');

    // Generate a broadcast (with nodes), a list, and a random user.
    $broadcast  = $this->generateBroadcast($num);
    $this->assertNotEqual(
      $broadcast,
      FALSE,
      t('Broadcast successfully generated')
    );
    $list = $this->generateList($users);

    // Make a job and add it to the job queue.
    $job = array(
      'template' => $this->template,
      'lid' => $list->id,
      'type' => 'broadcast',
      'extra' => $broadcast->id,
    );

    /**
     * Create a local job, with the Job content and mails in place, but
     * defer upload. We are only checking that the job was created for the
     * purposes of checking entries in the UI, not that the RPC mechanism
     * works, which is handled elsewhere.
     */
    $jid = wildfire_job_add($job, WILDFIRE_JOB_CREATE_IMMEDIATE);

    // Load a WildfireClientJob object from the JID returned
    $job = new WildfireClientJob($jid);

    /**
     * Return an array of the jobs properties. We could return an object
     * directly but that would cause an inconsistency with other, non object
     * based tests.
    */
    return array(
      'jid' => $job->jid,
      'template' => $job->template,
      'uid' => $job->uid,
      'lid' => $job->lid,
      'type' => $job->type,
      'extra' => $job->extra,
      'started' => $job->started,
      'scheduled' => $job->scheduled,
      'completed' => $job->completed,
      'count' => $job->count,
      'status' => $job->status,
      'processed_count' => $job->processed_count,
      'processor' => $job->processor,
      'juid' => $job->juid,
      'title' => $job->title,
      'last_modified' => $job->last_modified,
    );

  }

  /**
   * Create a new list.
   *
   * @param int $users
   *    The number of new users to add to this list.
   * @param bool $generate_bad
   *    Intentionally create a bad entry once every 10 entries. Only works if
   *    $users is greater than 10.
   *    Defaults to FALSE
   * @return object
   *    The list object, with name and id properties.
   */
  protected function generateList($users = 2, $generate_bad = FALSE) {
    module_load_include('inc', 'wildfire_lists', 'wildfire_lists.api');
    $list = new stdClass();

    $list->name  = $this->randomName();
    $list->id    = wildfire_lists_add_list($list->name);

    $c = 0;

    // Create the desired number of users.
    for ($i = 0; $i < $users; $i++) {

      // Create user and add it to the list.
      $account = $this->drupalCreateUser();

      // Generate a bad entry once every 10 users, if enabled.
      if ($generate_bad) {
        if ($c++ > 10) {
          $c = 0;
          user_save(
            $account,
            array(
              'mail' => $this->randomName(32)
            )
          );
        }
      }

      wildfire_lists_user_add($account->uid, $list->id);
    }

    return $list;
  }

  /**
   * Create a node with random content.
   *
   * @return object
   *    The node object.
   */
  protected function generateNode($type = 'story') {
    $node = $this->drupalCreateNode(array(
      'type' => $type,
      'title' => $this->randomName(),
      // When generating the body, make sure there's a URL in there.
      'body' => array(LANGUAGE_NONE => array(array(
        $this->randomName()
        . ' <a href="http://example.com">sample link</a>'
        . '£¤± ¡multibyte string! £¤±£¤±'
      ))),
    ));
    return $node;
  }

  /**
   * Switch to the specified user account
   *
   * @param object $account
   *    The user account to be switched to. This should be an account that
   *    has been created with ->drupalCreateUser().
   */
  protected function switchUser($account) {
    $this->drupalLogin($account);
  }

  /**
   * 2011-08-17, craig:
   * Overrides DrupalWebTestCase::drupalCreateUser(), as we need to define custom
   * fields provided by 'profile' and the default implementation has no way of
   * allowing us to do this. See http://drupal.org/node/836548
   *
   * Create a user with a given set of permissions. The permissions correspond to the
   * names given on the privileges page.
   *
   * @param array $permissions
   *   Array of permission names to assign to user.
   * @param array $extra_edit
   *  Array of extra fields to add to the created user.
   * @return Entity
   *   A fully loaded user object with pass_raw property, or FALSE if account
   *   creation fails.
   */
  protected function drupalCreateUser($permissions = array('access content', 'post comments'), $extra_edit = array()) {

    // Create a role with the given permission set.
    if (!($rid = $this->drupalCreateRole($permissions))) {
      return FALSE;
    }

    // Create a user assigned to that role.
    $edit = array();
    $edit['name']   = $this->randomName();
    $edit['mail']   = $edit['name'] . '@example.com';
    $edit['roles']  = array($rid => $rid);
    $edit['pass']   = user_password();
    $edit['status'] = 1;

    /**
     * 2011-08-17, craig:
     * Wildfire also defines these two using the core 'fields' module
     * so we should ensure that they are suitably defaulted
     */
    $edit['field_first_name'][LANGUAGE_NONE][0]['value'] = 'Default first name';
    $edit['field_last_name'][LANGUAGE_NONE][0]['value'] = 'Default last name';

    // Merge $extra_edit with the fields we've already defined as 'defaults'
    if (!empty($extra_edit) && is_array($extra_edit)) {
      $edit = array_merge($edit, $extra_edit);
    }

    $account = user_save('', $edit);

    $this->assertTrue(!empty($account->uid), t('User created with name %name and pass %pass', array('%name' => $edit['name'], '%pass' => $edit['pass'])), t('User login'));
    if (empty($account->uid)) {
      return FALSE;
    }

    // Add the raw password so that we can log in as this user.
    $account->pass_raw = $edit['pass'];
    return $account;
  }

}
