<?php

/**
 * @file
 * Provides a file stream wrapper to store private files that can be altered
 * on download.
 */

/**
 * Implements hook_menu().
 */
function private_dynamic_stream_menu() {
  $items = array();

  $items['system/dynamics'] = array(
    'title' => 'File download',
    'page callback' => '_private_dynamic_stream_file_download',
    'page arguments' => array('privatedynamic'),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  // Generate and deliver image derivatives of private files.
  // These image derivatives are always delivered through the menu system.
  $items['system/dynamics/styles/%image_style'] = array(
    'title' => 'Generate image style',
    'page callback' => '_private_dynamic_stream_image_style_deliver',
    'page arguments' => array(3),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_stream_wrappers().
 */
function private_dynamic_stream_stream_wrappers() {
  $wrappers = array();

  // Only register the private file stream wrapper if a file path has been set.
  if (variable_get('private_dynamic_stream_path', FALSE)) {
    $wrappers['privatedynamic'] = array(
      'name' => t('Private Dynamic files'),
      'class' => 'PrivateDynamicStreamWrapper',
      'description' => t('Private dynamic local files served by Drupal.'),
      'type' => STREAM_WRAPPERS_LOCAL_NORMAL,
      'dynamic' => TRUE,
    );
  }

  return $wrappers;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function private_dynamic_stream_form_system_file_system_settings_alter(&$form, $form_state, $form_id) {

  $form['private_dynamic_stream_path'] = array(
    '#type' => 'textfield',
    '#title' => t('Private dynamic file system path'),
    '#default_value' => variable_get('private_dynamic_stream_path', ''),
    '#maxlength' => 255,
    '#description' => t('An existing local file system path for storing private dynamic files. It should be writable by Drupal and not accessible over the web. See the online handbook for <a href="@handbook">more information about securing private files</a>.', array('@handbook' => 'http://drupal.org/documentation/modules/file')),
    '#after_build' => array('system_check_directory'),
    '#weight' => 1,
  );

  // rearrange form
  if (isset($form['actions'])) {
    $form['actions']['#weight'] = 50;
  }
  if (isset($form['file_default_scheme'])) {
    $form['file_default_scheme']['#weight'] = 10;
  }
}

/**
 * Implements hook_hook_info().
 */
function private_dynamic_stream_hook_info() {
  $hooks = array(
    'private_dynamic_stream_append' => array(
      'group' => 'file',
    ),
    'private_dynamic_stream_append_alter' => array(
      'group' => 'file',
    ),
  );

  return $hooks;
}

/**
 * File download for dynamic files
 */
function _private_dynamic_stream_file_download() {
  // Merge remainder of arguments from GET['q'], into relative file path.
  $args = func_get_args();

  $scheme = array_shift($args);
  $target = implode('/', $args);
  $uri = $scheme . '://' . $target;
  drupal_alter('private_dynamic_stream_uri', $uri);

  if (file_stream_wrapper_valid_scheme($scheme) && file_exists($uri)) {
    $headers = _private_dynamic_stream_file_download_headers($uri);
    if (count($headers)) {
      _private_dynamic_stream_file_transfer($uri, $headers);
    }

    // DENY if no headers
    drupal_access_denied();
  }
  else {
    drupal_not_found();
  }
  drupal_exit();
}

/**
 * Returns an array of headers from invoking hook_download
 *
 * Let other modules provide headers and controls access to the file.
 * module_invoke_all() uses array_merge_recursive() which merges header
 * values into a new array. To avoid that and allow modules to override
 * headers instead, use array_merge() to merge the returned arrays.
 *
 * @return
 *   An array of HTTP headers to send along with file.
 */
function _private_dynamic_stream_file_download_headers($uri) {
  $headers = array();
  foreach (module_implements('file_download') as $module) {
    $function = $module . '_file_download';
    $result = $function($uri);
    if ($result == -1) {
      // Throw away the headers received so far and exit
      $headers = array();
      break;
    }
    if (isset($result) && is_array($result)) {
      $headers = array_merge($headers, $result);
    }
  }

  return $headers;
}

/**
 * Transfers a dynamic file to the client using HTTP.
 *
 * Pipes a dynamic file through Drupal to the client.
 *
 * @param $uri
 *   String specifying the file URI to transfer.
 * @param $headers
 *   An array of HTTP headers to send along with file.
 */
function _private_dynamic_stream_file_transfer($uri, $headers) {
  if (ob_get_level()) {
    ob_end_clean();
  }

  // extract scheme
  $scheme = file_uri_scheme($uri);
  $stream_wrapper = _private_dynamic_stream_get_wrappers($scheme);

  // Build appended data
  $append_content = NULL;
  if ($stream_wrapper && !empty($stream_wrapper['dynamic'])) {
    $append_data = module_invoke_all('private_dynamic_stream_append', $uri);
    drupal_alter('private_dynamic_stream_append', $append_data, $uri);

    if (!empty($append_data)) {
      // combine all data
      $append_content = implode('', $append_data);

      // Add the appended length to the specified headers
      if (isset($headers['Content-Length'])) {
        $headers['Content-Length'] += strlen($append_content);
      }
    }
  }

  // add headers and send file headers
  foreach ($headers as $name => $value) {
    drupal_add_http_header($name, $value);
  }

  // send remaining headers
  drupal_send_headers();

  if ($scheme && file_stream_wrapper_valid_scheme($scheme)) {
    // Allow module to provide their own transfer callback.
    $transfer_callbacks = module_invoke_all('private_dynamic_stream_transfer_callback', $uri);
    $transfer_callback = array_shift($transfer_callbacks);
    if (function_exists($transfer_callback)) {
      $transfer_callback($uri);
    }
    else if ($fd = fopen($uri, 'rb')) {
      // Transfer file in 1024 byte chunks to save memory usage.
      while (!feof($fd)) {
        print fread($fd, 1024);
      }
      fclose($fd);
    }

    // Append content
    if (isset($append_content)) {
      print $append_content;
    }
  }
  else {
    drupal_not_found();
  }
  drupal_exit();
}


/**
 * Menu callback; Given a style and image path, generate a derivative.
 *
 * After generating an image, transfer it to the requesting agent.
 *
 * A custom implementation is needed since image_style_deliver() explicitly
 * checks for 'private' before calling file_download()
 *
 * @param $style
 *   The image style
 */
function _private_dynamic_stream_image_style_deliver($style, $scheme) {
  // Check that the style is defined and the scheme is valid.
  if (!$style || !file_stream_wrapper_valid_scheme($scheme)) {
    drupal_exit();
  }

  // get function args
  $args = func_get_args();

  // get stream info
  $stream_wrapper = _private_dynamic_stream_get_wrappers($scheme);

  // if not a dynamic scheme, then use default image function
  if (empty($stream_wrapper['dynamic'])) {
    call_user_func_array('image_style_deliver', $args);
    return;
  }

  // process input
  array_shift($args);
  array_shift($args);
  $target = implode('/', $args);

  // create image uri's
  $image_uri = $scheme . '://' . $target;
  $derivative_uri = image_style_path($style['name'], $image_uri);

  // If using the private scheme, let other modules provide headers and
  // control access to the file.
  if (file_exists($derivative_uri)) {
    _private_dynamic_stream_file_download($scheme, file_uri_target($derivative_uri));
  }
  else {
    $headers = _private_dynamic_stream_file_download_headers($image_uri);
    if (empty($headers)) {
      return drupal_access_denied();
    }
    if (count($headers)) {
      foreach ($headers as $name => $value) {
        drupal_add_http_header($name, $value);
      }
    }
  }


  // Don't start generating the image if the derivative already exists or if
  // generation is in progress in another thread.
  $lock_name = 'image_style_deliver:' . $style['name'] . ':' . drupal_hash_base64($image_uri);
  if (!file_exists($derivative_uri)) {
    $lock_acquired = lock_acquire($lock_name);
    if (!$lock_acquired) {
      // Tell client to retry again in 3 seconds. Currently no browsers are known
      // to support Retry-After.
      drupal_add_http_header('Status', '503 Service Unavailable');
      drupal_add_http_header('Retry-After', 3);
      print t('Image generation in progress. Try again shortly.');
      drupal_exit();
    }
  }

  // Try to generate the image, unless another thread just did it while we were
  // acquiring the lock.
  $success = file_exists($derivative_uri) || image_style_create_derivative($style, $image_uri, $derivative_uri);

  if (!empty($lock_acquired)) {
    lock_release($lock_name);
  }

  if ($success) {
    $image = image_load($derivative_uri);
    _private_dynamic_stream_file_transfer($image->source, array('Content-Type' => $image->info['mime_type'], 'Content-Length' => $image->info['file_size']));
  }
  else {
    watchdog('image', 'Unable to generate the derived image located at %path.', array('%path' => $derivative_uri));
    drupal_add_http_header('Status', '500 Internal Server Error');
    print t('Error generating image.');
    drupal_exit();
  }
}


// -----------------------------------------------------------------------
// Helpers

/**
 * Returns stream wrapper info for a specific scheme
 */
function _private_dynamic_stream_get_wrappers($scheme) {
  $wrappers = file_get_stream_wrappers();
  return isset($wrappers[$scheme]) ? $wrappers[$scheme] : NULL;
}
