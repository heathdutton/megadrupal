<?php

/**
 * @file
 * The core that allows entities to be grouped together. Modules and scripts may
 * programmatically submit galleries using the usual form API pattern.
 */

/**
 * Entity gallery is not published.
 */
define('ENTITY_GALLERY_NOT_PUBLISHED', 0);

/**
 * Entity gallery is published.
 */
define('ENTITY_GALLERY_PUBLISHED', 1);

/**
 * Entity gallery is not sticky at top of the page.
 */
define('ENTITY_GALLERY_NOT_STICKY', 0);

/**
 * Entity gallery is sticky at top of the page.
 */
define('ENTITY_GALLERY_STICKY', 1);

/**
 * Modules should return this value from hook_entity_gallery_access() to allow access to an entity gallery.
 */
define('ENTITY_GALLERY_ACCESS_ALLOW', 'allow');

/**
 * Modules should return this value from hook_entity_gallery_access() to deny access to an entity gallery.
 */
define('ENTITY_GALLERY_ACCESS_DENY', 'deny');

/**
 * Modules should return this value from hook_entity_gallery_access() to not affect entity gallery access.
 */
define('ENTITY_GALLERY_ACCESS_IGNORE', NULL);

/**
 * The name of the entity reference field used by entity galleries.
 */
define('ENTITY_GALLERY_FIELD_ENTITY_REFERENCE', 'entity_gallery_reference');

// entity.module helper functions.
require_once dirname(__FILE__) . '/entity.inc';

// features.module helper functions.
require_once dirname(__FILE__) . '/features.inc';

// path.module helper functions.
require_once dirname(__FILE__) . '/path.inc';

// pathauto.module helper functions.
require_once dirname(__FILE__) . '/pathauto.inc';

/**
 * Implements hook_help().
 */
function entity_gallery_help($path, $arg) {
  switch ($path) {
    case 'admin/help#entity_gallery':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The Entity Gallery module manages the creation, editing, deletion, settings, and display of galleries. Gallery items managed by the Entity Gallery module are typically displayed as pages on your site, and include a title, some meta-data (author, creation time, gallery type, etc.), and optional fields containing text or other data (fields are managed by the <a href="@field">Field module</a>). For more information, see the online handbook entry for <a href="@entity-gallery">Entity Gallery module</a>.', array('@entity-gallery' => 'http://drupal.org/documentation/modules/entity-gallery', '@field' => url('admin/help/field'))) . '</p>';
      $output .= '<h3>' . t('Uses') . '</h3>';
      $output .= '<dl>';
      $output .= '<dt>' . t('Creating galleries') . '</dt>';
      $output .= '<dd>' . t('When new galleries are created, the Entity Gallery module records basic information about the gallery, including the author, date of creation, and the <a href="@gallery-type">Gallery type</a>. It also manages the <em>publishing options</em>, which define whether or not the gallery is published, and/or sticky at the top of gallery lists. Default settings can be configured for each <a href="@gallery-type">type of gallery</a> on your site.', array('@gallery-type' => url('admin/structure/gallery-types'))) . '</dd>';
      $output .= '<dt>' . t('Creating custom gallery types') . '</dt>';
      $output .= '<dd>' . t('The Entity Gallery module gives users with the <em>Administer entity gallery types</em> permission the ability to <a href="@gallery-new">create new gallery types</a> in addition to the default ones already configured. Creating custom gallery types allows you the flexibility to add <a href="@field">fields</a> and configure default settings that suit the differing needs of various site galleries.', array('@galleries-new' => url('admin/structure/gallery-types/add'), '@field' => url('admin/help/field'))) . '</dd>';
      $output .= '<dt>' . t('Administering content') . '</dt>';
      $output .= '<dd>' . t('The <a href="@galleries">Galleries administration page</a> allows you to review and bulk manage your site galleries.', array('@galleries' => url('admin/content/gallery'))) . '</dd>';
      $output .= '<dt>' . t('Creating revisions') . '</dt>';
      $output .= '<dd>' . t('The Entity Gallery module also enables you to create multiple versions of any gallery, and revert to older versions using the <em>Revision information</em> settings.') . '</dd>';
      $output .= '<dt>' . t('User permissions') . '</dt>';
      $output .= '<dd>' . t('The Entity Gallery module makes a number of permissions available for each gallery type, which can be set by role on the <a href="@permissions">permissions page</a>.', array('@permissions' => url('admin/people/permissions', array('fragment' => 'module-entity-gallery')))) . '</dd>';
      $output .= '</dl>';
      return $output;

    case 'admin/structure/gallery-types/add':
      return '<p>' . t('Individual gallery types can have different fields, behaviors, and permissions assigned to them.') . '</p>';

    case 'admin/structure/gallery-types/manage/%/display':
      return '<p>' . t('Gallery items can be displayed using different view modes: Teaser, Full content, Print, etc. <em>Teaser</em> is a short format that is typically used in lists of multiple gallery items. <em>Full content</em> is typically used when the gallery is displayed on its own page.') . '</p>' .
      '<p>' . t('Here, you can define which fields are shown and hidden when %type gallery is displayed in each view mode, and define how the fields are displayed in each view mode.', array('%type' => entity_gallery_type_get_name($arg[4]))) . '</p>';

    case 'gallery/%/revisions':
      return '<p>' . t('Revisions allow you to track differences between multiple versions of your galleries, and revert back to older versions.') . '</p>';

    case 'gallery/%/edit':
      $entity_gallery = entity_gallery_load($arg[1]);
      $type = entity_gallery_type_get_type($entity_gallery);
      return (!empty($type->help) ? '<p>' . filter_xss_admin($type->help) . '</p>' : '');
  }

  if ($arg[0] == 'entity_gallery' && $arg[1] == 'add' && $arg[2]) {
    $type = entity_gallery_type_get_type(str_replace('-', '_', $arg[2]));
    return (!empty($type->help) ? '<p>' . filter_xss_admin($type->help) . '</p>' : '');
  }
}

/**
 * Implements hook_theme().
 */
function entity_gallery_theme() {
  return array(
    'entity_gallery' => array(
      'render element' => 'elements',
      'template' => 'entity_gallery',
    ),
    'entity_gallery_search_admin' => array(
      'render element' => 'form',
    ),
    'entity_gallery_add_list' => array(
      'variables' => array('content' => NULL),
      'file' => 'entity_gallery.pages.inc',
    ),
    'entity_gallery_preview' => array(
      'variables' => array('entity_gallery' => NULL),
      'file' => 'entity_gallery.pages.inc',
    ),
    'entity_gallery_admin_overview' => array(
      'variables' => array('name' => NULL, 'type' => NULL),
      'file' => 'gallery_types.inc',
    ),
  );
}

/**
 * Implements hook_entity_info().
 */
function entity_gallery_entity_info() {
  $return = array(
    'entity_gallery' => array(
      'label' => t('Entity Gallery'),
      'controller class' => 'EntityGalleryController',
      'base table' => 'entity_gallery',
      'revision table' => 'entity_gallery_revision',
      'uri callback' => 'entity_gallery_uri',
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'egid',
        'revision' => 'vid',
        'bundle' => 'type',
        'label' => 'title',
        'language' => 'language',
      ),
      'bundle keys' => array(
        'bundle' => 'type',
      ),
      'bundles' => array(),
      'view modes' => array(
        'full' => array(
          'label' => t('Full gallery'),
          'custom settings' => FALSE,
        ),
        'teaser' => array(
          'label' => t('Teaser'),
          'custom settings' => TRUE,
        ),
      ),
    ),
  );

  // Entity API integration.
  // Set plural labels.
  $return['entity_gallery']['plural label'] = t('Entity Galleries');

  // Set descriptions.
  $return['entity_gallery']['description'] = t('Entity galleries allow users to group entities together into galleries.');

  // Set access callbacks.
  $return['entity_gallery']['access callback'] = 'entity_gallery_entity_api_no_hook_access';

  // CRUD function callbacks.
  $return['entity_gallery']['creation callback'] = 'entity_gallery_entity_api_create';
  $return['entity_gallery']['save callback'] = 'entity_gallery_save';
  $return['entity_gallery']['deletion callback'] = 'entity_gallery_delete';
  $return['entity_gallery']['revision deletion callback'] = 'entity_gallery_revision_delete';

  // Form callbacks.
  $return['entity_gallery']['form callback'] = 'entity_gallery_entity_api_form';

  // View callbacks.
  $return['entity_gallery']['view callback'] = 'entity_gallery_entity_api_view';

  // Search integration is provided by entity_gallery.module, so search-related
  // view modes for galleries are defined here and not in search.module.
  if (module_exists('search')) {
    $return['entity_gallery']['view modes'] += array(
      'search_index' => array(
        'label' => t('Search index'),
        'custom settings' => FALSE,
      ),
      'search_result' => array(
        'label' => t('Search result highlighting input'),
        'custom settings' => FALSE,
      ),
    );
  }

  // Title integration.
  $return['entity_gallery']['field replacement'] = array(
    'title' => array(
      'field' => array(
        'type' => 'text',
        'cardinality' => 1,
        'translatable' => TRUE,
      ),
      'instance' => array(
          'label' => t('Title'),
          'description' => '',
          'required' => TRUE,
          'settings' => array(
            'text_processing' => 0,
          ),
          'widget' => array(
            'weight' => -5,
          ),
          'display' => array(
            'default' => array(
              'type' => 'hidden',
          ),
        ),
      ),
      'efq bundle conditions' => TRUE,
    ),
  );

  // Bundles must provide a human readable name so we can create help and error
  // messages, and the path to attach Field admin pages to.
  foreach (entity_gallery_type_get_names() as $type => $name) {
    $return['entity_gallery']['bundles'][$type] = array(
      'label' => $name,
      'admin' => array(
        'path' => 'admin/structure/gallery-types/manage/%entity_gallery_type',
        'real path' => 'admin/structure/gallery-types/manage/' . str_replace('_', '-', $type),
        'bundle argument' => 4,
        'access arguments' => array('administer entity gallery types'),
      ),
    );
  }

  return $return;
}

/**
 * Implements hook_field_display_ENTITY_TYPE_alter().
 */
function entity_gallery_field_display_entity_gallery_alter(&$display, $context) {
  // Hide field labels in search index.
  if ($context['view_mode'] == 'search_index') {
    $display['label'] = 'hidden';
  }
}

/**
 * Implements callback_entity_info_uri().
 */
function entity_gallery_uri($entity_gallery) {
  return array(
    'path' => 'gallery/' . $entity_gallery->egid,
  );
}

/**
 * Implements hook_admin_paths().
 */
function entity_gallery_admin_paths() {
  if (variable_get('node_admin_theme')) {
    $paths = array(
      'gallery/*/edit' => TRUE,
      'gallery/*/delete' => TRUE,
      'gallery/*/revisions' => TRUE,
      'gallery/*/revisions/*/revert' => TRUE,
      'gallery/*/revisions/*/delete' => TRUE,
      'gallery/add' => TRUE,
      'gallery/add/*' => TRUE,
    );
    return $paths;
  }
}

/**
 * Gathers a listing of links to entity galleries.
 *
 * @param $result
 *   A database result object from a query to fetch entity gallery entities.
 * @param $title
 *   A heading for the resulting list.
 *
 * @return
 *   A renderable array containing a list of linked entity gallery titles
 *   fetched from $result, or FALSE if there are no rows in $result.
 */
function entity_gallery_title_list($result, $title = NULL) {
  $items = array();
  $num_rows = FALSE;
  foreach ($result as $entity_gallery) {
    $items[] = l($entity_gallery->title, 'entity-gallery/' . $entity_gallery->egid, array());
    $num_rows = TRUE;
  }

  return $num_rows ? array('#theme' => 'item_list__entity_gallery', '#items' => $items, '#title' => $title) : FALSE;
}

/**
 * Extracts the type name.
 *
 * @param $entity_gallery
 *   Either a string or object, containing the entity gallery type information.
 *
 * @return
 *   Entity gallery type of the passed-in data.
 */
function _entity_gallery_extract_type($entity_gallery) {
  return is_object($entity_gallery) ? $entity_gallery->type : $entity_gallery;
}

/**
 * Returns a list of all the available entity gallery types.
 *
 * This list can include types that are queued for addition or deletion.
 * See _entity_gallery_types_build() for details.
 *
 * @return
 *   An array of entity gallery types, as objects, keyed by the type.
 *
 * @see entity_gallery_type_get_type()
 */
function entity_gallery_type_get_types() {
  return _entity_gallery_types_build()->types;
}

/**
 * Returns the entity gallery type of the passed entity gallery or entity
 * gallery type string.
 *
 * @param $entity_gallery
 *   An entity gallery object or string that indicates the entity gallery type
 *   to return.
 *
 * @return
 *   A single entity gallery type, as an object, or FALSE if the entity gallery
 *   type is not found.
 *   The entity gallery type is an object containing fields from
 *   hook_entity_gallery_info() return values, as well as the field 'type'
 *   (the machine-readable type) and other fields used internally and defined in
 *   _entity_gallery_types_build(), hook_entity_gallery_info(), and
 *   entity_gallery_type_set_defaults().
 */
function entity_gallery_type_get_type($entity_gallery) {
  $type = _entity_gallery_extract_type($entity_gallery);
  $types = _entity_gallery_types_build()->types;
  return isset($types[$type]) ? $types[$type] : FALSE;
}

/**
 * Returns the entity gallery type base of the passed entity gallery or entity gallery type string.
 *
 * The base indicates which module implements this entity gallery type and is
 * used to execute entity-gallery-type-specific hooks. For types defined in the
 * user interface and managed by entity_gallery.module, the base is
 * 'entity_gallery_content'.
 *
 * @param $entity_gallery
 *   An entity gallery object or string that indicates the entity gallery type
 *   to return.
 *
 * @return
 *   The entity gallery type base or FALSE if the entity gallery type is not
 *   found.
 *
 * @see entity_gallery_invoke()
 */
function entity_gallery_type_get_base($entity_gallery) {
  $type = _entity_gallery_extract_type($entity_gallery);
  $types = _entity_gallery_types_build()->types;
  return isset($types[$type]) && isset($types[$type]->base) ? $types[$type]->base : FALSE;
}

/**
 * Returns a list of available entity gallery type names.
 *
 * This list can include types that are queued for addition or deletion.
 * See _entity_gallery_types_build() for details.
 *
 * @return
 *   An array of entity gallery type names, keyed by the type.
 */
function entity_gallery_type_get_names() {
  return _entity_gallery_types_build()->names;
}

/**
 * Returns the entity gallery type name of the passed entity gallery or entity gallery type string.
 *
 * @param $entity_gallery
 *   An entity gallery object or string that indicates the entity gallery type
 *   to return.
 *
 * @return
 *   The entity gallery type name or FALSE if the entity gallery type is not
 *   found.
 */
function entity_gallery_type_get_name($entity_gallery) {
  $type = _entity_gallery_extract_type($entity_gallery);
  $types = _entity_gallery_types_build()->names;
  return isset($types[$type]) ? $types[$type] : FALSE;
}

/**
 * Updates the database cache of entity gallery types.
 *
 * All new module-defined entity gallery types are saved to the database via a
 * call to entity_gallery_type_save(), and obsolete ones are deleted via a call
 * to entity_gallery_type_delete(). See _entity_gallery_types_build() for an
 * explanation of the new and obsolete types.
 *
 * @see _entity_gallery_types_build()
 */
function entity_gallery_types_rebuild() {
  _entity_gallery_types_build(TRUE);
}

/**
 * Menu argument loader: loads an entity gallery type by string.
 *
 * @param $name
 *   The machine-readable name of an entity gallery type to load, where '_' is
 *   replaced with '-'.
 *
 * @return
 *   An entity gallery type object or FALSE if $name does not exist.
 */
function entity_gallery_type_load($name) {
  return entity_gallery_type_get_type(strtr($name, array('-' => '_')));
}

/**
 * Saves an entity gallery type to the database.
 *
 * @param object $info
 *   The entity gallery type to save; an object with the following properties:
 *   - type: A string giving the machine name of the entity gallery type.
 *   - name: A string giving the human-readable name of the entity gallery type.
 *   - base: A string that indicates the base string for hook functions. For
 *     example, 'entity_gallery_gallery' is the value used by the UI when
 *     creating a new entity gallery type.
 *   - description: A string that describes the entity gallery type.
 *   - help: A string giving the help information shown to the user when
 *     creating an entity gallery of this type.
 *   - custom: TRUE or FALSE indicating whether this type is defined by a module
 *     (FALSE) or by a user (TRUE) via Add Entity Gallery Type.
 *   - modified: TRUE or FALSE indicating whether this type has been modified by
 *     an administrator. When modifying an existing entity gallery type, set to
 *     TRUE, or the change will be ignored on entity_gallery_types_rebuild().
 *   - locked: TRUE or FALSE indicating whether the administrator can change the
 *     machine name of this type.
 *   - disabled: TRUE or FALSE indicating whether this type has been disabled.
 *   - has_title: TRUE or FALSE indicating whether this type uses the entity
 *     gallery title field.
 *   - title_label: A string containing the label for the title.
 *   - module: A string giving the module defining this type of entity gallery.
 *   - orig_type: A string giving the original machine-readable name of this
 *     entity gallery type. This may be different from the current type name if
 *     the 'locked' key is FALSE.
 *
 * @return int
 *   A status flag indicating the outcome of the operation, either SAVED_NEW or
 *   SAVED_UPDATED.
 */
function entity_gallery_type_save($info) {
  $existing_type = !empty($info->old_type) ? $info->old_type : $info->type;
  $is_existing = (bool) db_query_range('SELECT 1 FROM {entity_gallery_type} WHERE type = :type', 0, 1, array(':type' => $existing_type))->fetchField();
  $type = entity_gallery_type_set_defaults($info);

  $fields = array(
    'type' => (string) $type->type,
    'name' => (string) $type->name,
    'base' => (string) $type->base,
    'has_title' => (int) $type->has_title,
    'title_label' => (string) $type->title_label,
    'entity_type' => (string) $type->entity_type,
    'entity_type_bundles' => serialize($type->entity_type_bundles),
    'description' => (string) $type->description,
    'help' => (string) $type->help,
    'custom' => (int) $type->custom,
    'modified' => (int) $type->modified,
    'locked' => (int) $type->locked,
    'disabled' => (int) $type->disabled,
    'module' => $type->module,
  );

  if ($is_existing) {
    db_update('entity_gallery_type')
      ->fields($fields)
      ->condition('type', $existing_type)
      ->execute();

    if (!empty($type->old_type) && $type->old_type != $type->type) {
      field_attach_rename_bundle('entity_gallery', $type->old_type, $type->type);
    }
    module_invoke_all('entity_gallery_type_update', $type);
    $status = SAVED_UPDATED;
  }
  else {
    $fields['orig_type'] = (string) $type->orig_type;
    db_insert('entity_gallery_type')
      ->fields($fields)
      ->execute();

    field_attach_create_bundle('entity_gallery', $type->type);

    module_invoke_all('entity_gallery_type_insert', $type);
    $status = SAVED_NEW;
  }

  // Clear the entity gallery type cache.
  entity_gallery_type_cache_reset();

  return $status;
}

/**
 * Adds an entity reference field to an entity gallery type.
 *
 * @param $type
 *   An entity gallery type object.
 *
 * @param $target_type
 *   The type of the entity allowed to be referenced by the gallery.
 *
 * @param $entity_type_bundles
 *   The bundles of the entity allowed to be referenced by the gallery.
 *
 * @return
 *   Entity reference field instance.
 */
function entity_gallery_create_entity_reference_field($type, $target_type, $entity_type_bundles) {
  // Add or remove the entity reference field, as needed.
  $field = field_info_field('entity_gallery_' . $target_type);
  $instance = field_info_instance('entity_gallery', 'entity_gallery_' . $target_type, $type->type);
  if (empty($field)) {
    $field = _entity_gallery_entity_reference_field_definition($target_type, $entity_type_bundles);
    $field = field_create_field($field);
  }
  if (empty($instance)) {
    $instance = _entity_gallery_entity_reference_field_instance_definition($type, $target_type);
    $instance = field_create_instance($instance);
  }
  return $instance;
}

/**
 * Updates an entity reference field on an entity gallery type.
 *
 * @param $type
 *   An entity gallery type object.
 *
 * @param $target_type
 *   The type of the entity allowed to be referenced by the gallery.
 *
 * @param $entity_type_bundles
 *   The bundles of the entity allowed to be referenced by the gallery.
 */
function entity_gallery_update_entity_reference_field($type, $target_type, $entity_type_bundles) {
  // Add or remove the entity reference field, as needed.
  $field = field_info_field('entity_gallery_' . $target_type);
  $instance = field_info_instance('entity_gallery', 'entity_gallery_' . $target_type, $type->type);
  if (!empty($field)) {
    $field = _entity_gallery_entity_reference_field_definition($target_type, $entity_type_bundles);
    field_update_field($field);
  }
  if (!empty($instance)) {
    $instance = _entity_gallery_entity_reference_field_instance_definition($type, $target_type);
    field_update_instance($instance);
  }
}

/**
 * Removes an entity reference field from an entity gallery type.
 *
 * @param $type
 *   An entity gallery type object.
 *
 * @param $target_type
 *   The type of the entity allowed to be referenced by the gallery.
 */
function entity_gallery_delete_entity_reference_field($type, $target_type) {
  $instance = field_info_instance('entity_gallery', 'entity_gallery_' . $target_type, $type->type);
  if (!empty($instance)) {
    field_delete_instance($instance);
  }
}

/**
 * Helper function to get the definition of an entity gallery entity reference field.
 *
 * @param $target_type
 *   The type of the entity allowed to be referenced by the gallery.
 *
 * @param $entity_type_bundles
 *   The bundles of the entity allowed to be referenced by the gallery.
 *
 * @return
 *   Entity reference field definition.
 */
function _entity_gallery_entity_reference_field_definition($target_type, $entity_type_bundles) {
  $field = array(
    'cardinality' => FIELD_CARDINALITY_UNLIMITED,
    'field_name' => 'entity_gallery_' . $target_type,
    'locked' => TRUE,
    'translatable' => TRUE,
    'type' => 'entityreference',
    'settings' => array(
      'target_type' => $target_type,
    ),
  );

  if (!empty($entity_type_bundles)) {
    $field['settings']['handler_settings'] = array(
      'target_bundles' => $entity_type_bundles,
    );
  }

  return $field;
}

/**
 * Helper function to get the definition of an entity gallery entity reference field instance.
 *
 * @param $type
 *   An entity gallery type object.
 *
 * @param $target_type
 *   The type of the entity allowed to be referenced by the gallery.
 *
 * @return
 *   Entity reference field instance definition.
 */
function _entity_gallery_entity_reference_field_instance_definition($type, $target_type) {
  $instance = array(
    'bundle' => $type->type,
    'description' => 'Reference one or more existing items to add to the gallery.',
    'display' => array(
      'default' => array(
        'label' => 'hidden',
        'settings' => array(
          'links' => FALSE,
          'view_mode' => 'full',
        ),
        'type' => 'entityreference_entity_view',
      ),
      'teaser' => array(
        'label' => 'hidden',
        'settings' => array(
          'links' => FALSE,
          'view_mode' => 'teaser',
        ),
        'type' => 'entityreference_entity_view',
      ),
    ),
    'entity_type' => 'entity_gallery',
    'field_name' => 'entity_gallery_' . $target_type,
    'label' => 'Gallery Items',
    'required' => TRUE,
    'widget' => array(
      'type' => 'entityreference_autocomplete',
    ),
  );

  return $instance;
}

/**
 * Adds default description field to an entity gallery type.
 *
 * @param $type
 *   An entity gallery type object.
 * @param $label
 *   The label for the description instance.
 *
 * @return
 *   Description field instance.
 */
function entity_gallery_add_description_field($type, $label = 'Description') {
  // Add or remove the description field, as needed.
  $field = field_info_field('entity_gallery_description');
  $instance = field_info_instance('entity_gallery', 'entity_gallery_description', $type->type);
  if (empty($field)) {
    $field = array(
      'field_name' => 'entity_gallery_description',
      'type' => 'text_with_summary',
      'entity_types' => array('entity_gallery'),
    );
    $field = field_create_field($field);
  }
  if (empty($instance)) {
    $instance = array(
      'field_name' => 'entity_gallery_description',
      'entity_type' => 'entity_gallery',
      'bundle' => $type->type,
      'label' => $label,
      'widget' => array('type' => 'text_textarea_with_summary'),
      'settings' => array('display_summary' => TRUE),
      'display' => array(
        'default' => array(
          'label' => 'hidden',
          'type' => 'text_default',
        ),
        'teaser' => array(
          'label' => 'hidden',
          'type' => 'text_summary_or_trimmed',
        ),
      ),
    );
    $instance = field_create_instance($instance);
  }
  return $instance;
}

/**
 * Implements hook_field_extra_fields().
 */
function entity_gallery_field_extra_fields() {
  $extra = array();

  foreach (entity_gallery_type_get_types() as $type) {
    if ($type->has_title) {
      $extra['entity_gallery'][$type->type] = array(
        'form' => array(
          'title' => array(
            'label' => $type->title_label,
            'description' => t('Entity gallery module element'),
            'weight' => -5,
          ),
        ),
      );
    }

    // Add support for the 'URL path settings' to be re-ordered by the user on
    // the 'Manage Fields' tab of gallery types.
    if (module_exists('pathauto')) {
      if (!isset($info['entity_gallery'][$type->type]['form']['path'])) {
        $info['entity_gallery'][$type->type]['form']['path'] = array(
          'label' => t('URL path settings'),
          'description' => t('Path module form elements'),
          'weight' => 30,
        );
      }
    }
  }

  return $extra;
}

/**
 * Deletes an entity gallery type from the database.
 *
 * @param $type
 *   The machine-readable name of the entity gallery type to be deleted.
 */
function entity_gallery_type_delete($type) {
  $info = entity_gallery_type_get_type($type);
  db_delete('entity_gallery_type')
    ->condition('type', $type)
    ->execute();
  field_attach_delete_bundle('entity_gallery', $type);
  module_invoke_all('entity_gallery_type_delete', $info);

  // Clear the entity gallery type cache.
  entity_gallery_type_cache_reset();
}

/**
 * Updates all entity galleries of one type to be of another type.
 *
 * @param $old_type
 *   The current entity gallery type of the entity galleries.
 * @param $type
 *   The new entity gallery type of the entity galleries.
 *
 * @return
 *   The number of entity galleries whose entity gallery type field was
 *   modified.
 */
function entity_gallery_type_update_entity_galleries($old_type, $type) {
  return db_update('entity_gallery')
    ->fields(array('type' => $type))
    ->condition('type', $old_type)
    ->execute();
}

/**
 * Builds and returns the list of available entity gallery types.
 *
 * The list of types is built by invoking hook_entity_gallery_info() on all
 * modules and comparing this information with the entity gallery types in the
 * {entity_gallery_type} table.
 * These two information sources are not synchronized during module installation
 * until entity_gallery_types_rebuild() is called.
 *
 * @param $rebuild
 *  TRUE to rebuild entity gallery types. Equivalent to calling
 *  entity_gallery_types_rebuild().
 *
 * @return
 *   An object with two properties:
 *   - names: Associative array of the names of entity gallery types, keyed by
 *     the type.
 *   - types: Associative array of entity gallery type objects, keyed by the
 *     type.
 *   Both of these arrays will include new types that have been defined by
 *   hook_entity_gallery_info() implementations but not yet saved in the
 *   {entity_gallery_type} table. These are indicated in the type object by
 *   $type->is_new being set to the value 1. These arrays will also include
 *   obsolete types: types that were previously defined by modules that have now
 *   been disabled, or for whatever reason are no longer being defined in
 *   hook_entity_gallery_info() implementations, but are still in the database.
 *   These are indicated in the type object by $type->disabled being set to
 *   TRUE.
 */
function _entity_gallery_types_build($rebuild = FALSE) {
  $cid = 'entity_gallery_types:' . $GLOBALS['language']->language;

  if (!$rebuild) {
    $_entity_gallery_types = &drupal_static(__FUNCTION__);
    if (isset($_entity_gallery_types)) {
      return $_entity_gallery_types;
    }
    if ($cache = cache_get($cid)) {
      $_entity_gallery_types = $cache->data;
      return $_entity_gallery_types;
    }
  }

  $_entity_gallery_types = (object) array('types' => array(), 'names' => array());

  foreach (module_implements('entity_gallery_info') as $module) {
    $info_array = module_invoke($module, 'entity_gallery_info');
    foreach ($info_array as $type => $info) {
      $info['type'] = $type;
      $_entity_gallery_types->types[$type] = entity_gallery_type_set_defaults($info);
      $_entity_gallery_types->types[$type]->module = $module;
      $_entity_gallery_types->names[$type] = $info['name'];
    }
  }
  $query = db_select('entity_gallery_type', 'egt')
    ->addTag('translatable')
    ->addTag('entity_gallery_type_access')
    ->fields('egt')
    ->orderBy('egt.type', 'ASC');
  if (!$rebuild) {
    $query->condition('disabled', 0);
  }
  foreach ($query->execute() as $type_object) {
    $type_db = $type_object->type;
    // Original disabled value.
    $disabled = $type_object->disabled;
    // Check for entity gallery types from disabled modules and mark their types
    // for removal.
    // Types defined by the entity gallery module in the database (rather than
    // by a separate module using hook_entity_gallery_info) have a base value of
    // 'entity_gallery_content'. The isset() check prevents errors on old
    // (pre-Drupal 7) databases.
    if (isset($type_object->base) && $type_object->base != 'entity_gallery_content' && empty($_entity_gallery_types->types[$type_db])) {
      $type_object->disabled = TRUE;
    }
    if (isset($_entity_gallery_types->types[$type_db])) {
      $type_object->disabled = FALSE;
    }
    if (!isset($_entity_gallery_types->types[$type_db]) || $type_object->modified) {
      $_entity_gallery_types->types[$type_db] = $type_object;
      $_entity_gallery_types->names[$type_db] = $type_object->name;

      if ($type_db != $type_object->orig_type) {
        unset($_entity_gallery_types->types[$type_object->orig_type]);
        unset($_entity_gallery_types->names[$type_object->orig_type]);
      }
    }
    $_entity_gallery_types->types[$type_db]->disabled = $type_object->disabled;
    $_entity_gallery_types->types[$type_db]->disabled_changed = $disabled != $type_object->disabled;
  }

  if ($rebuild) {
    foreach ($_entity_gallery_types->types as $type => $type_object) {
      if (!empty($type_object->is_new) || !empty($type_object->disabled_changed)) {
        entity_gallery_type_save($type_object);
      }
    }
  }

  asort($_entity_gallery_types->names);

  cache_set($cid, $_entity_gallery_types);

  return $_entity_gallery_types;
}

/**
 * Clears the entity gallery type cache.
 */
function entity_gallery_type_cache_reset() {
  cache_clear_all('entity_gallery_types:', 'cache', TRUE);
  drupal_static_reset('_entity_gallery_types_build');
}

/**
 * Sets the default values for an entity gallery type.
 *
 * The defaults are appropriate for a type defined through
 * hook_entity_gallery_info(), since 'custom' is TRUE for types defined in the
 * user interface, and FALSE for types defined by modules. (The 'custom' flag
 * prevents types from being deleted through the user interface.) Also, the
 * default for 'locked' is TRUE, which prevents users from changing the machine
 * name of the type.
 *
 * @param $info
 *   (optional) An object or array containing values to override the defaults.
 *   See hook_entity_gallery_info() for details on what the array elements mean.
 *   Defaults to an empty array.
 *
 * @return
 *   An entity gallery type object, with missing values in $info set to their defaults.
 */
function entity_gallery_type_set_defaults($info = array()) {
  $info = (array) $info;
  $new_type = $info + array(
      'type' => '',
      'name' => '',
      'base' => '',
      'entity_type' => '',
      'entity_type_bundles' => '',
      'description' => '',
      'help' => '',
      'custom' => 0,
      'modified' => 0,
      'locked' => 1,
      'disabled' => 0,
      'is_new' => 1,
      'has_title' => 1,
      'title_label' => 'Title',
    );
  $new_type = (object) $new_type;

  // If the type has no title, set an empty label.
  if (!$new_type->has_title) {
    $new_type->title_label = '';
  }
  if (empty($new_type->module)) {
    $new_type->module = $new_type->base == 'entity_gallery_content' ? 'entity_gallery' : '';
  }
  $new_type->orig_type = isset($info['type']) ? $info['type'] : '';

  return $new_type;
}

/**
 * Implements hook_rdf_mapping().
 */
function entity_gallery_rdf_mapping() {
  return array(
    array(
      'type' => 'entity_gallery',
      'bundle' => RDF_DEFAULT_BUNDLE,
      'mapping' => array(
        'rdftype' => array('sioc:Item', 'foaf:Document'),
        'title' => array(
          'predicates' => array('dc:title'),
        ),
        'created' => array(
          'predicates' => array('dc:date', 'dc:created'),
          'datatype' => 'xsd:dateTime',
          'callback' => 'date_iso8601',
        ),
        'changed' => array(
          'predicates' => array('dc:modified'),
          'datatype' => 'xsd:dateTime',
          'callback' => 'date_iso8601',
        ),
        'description' => array(
          'predicates' => array('content:encoded'),
        ),
        'uid' => array(
          'predicates' => array('sioc:has_creator'),
          'type' => 'rel',
        ),
        'name' => array(
          'predicates' => array('foaf:name'),
        ),
        'last_activity' => array(
          'predicates' => array('sioc:last_activity_date'),
          'datatype' => 'xsd:dateTime',
          'callback' => 'date_iso8601',
        ),
      ),
    ),
  );
}

/**
 * Determines whether an entity gallery hook exists.
 *
 * @param $entity_gallery
 *   An entity gallery object or a string containing the entity gallery type.
 * @param $hook
 *   A string containing the name of the hook.
 *
 * @return
 *   TRUE if the $hook exists in the entity gallery type of $entity_gallery.
 */
function entity_gallery_hook($entity_gallery, $hook) {
  $base = entity_gallery_type_get_base($entity_gallery);
  return module_hook($base, $hook);
}

/**
 * Invokes an entity gallery hook.
 *
 * @param $entity_gallery
 *   An entity gallery object or a string containing the entity gallery type.
 * @param $hook
 *   A string containing the name of the hook.
 * @param $a2, $a3, $a4
 *   Arguments to pass on to the hook, after the $entity_gallery argument.
 *
 * @return
 *   The returned value of the invoked hook.
 */
function entity_gallery_invoke($entity_gallery, $hook, $a2 = NULL, $a3 = NULL, $a4 = NULL) {
  if (entity_gallery_hook($entity_gallery, $hook)) {
    $base = entity_gallery_type_get_base($entity_gallery);
    $function = $base . '_' . $hook;
    return ($function($entity_gallery, $a2, $a3, $a4));
  }
}

/**
 * Loads entity gallery entities from the database.
 *
 * This function should be used whenever you need to load more than one entity
 * gallery from the database. Entity galleries are loaded into memory and will
 * not require database access if loaded again during the same page request.
 *
 * @see entity_load()
 * @see EntityFieldQuery
 *
 * @param $egids
 *   An array of entity gallery IDs.
 * @param $conditions
 *   (deprecated) An associative array of conditions on the {entity_gallery}
 *   table, where the keys are the database fields and the values are the
 *   values those fields must have. Instead, it is preferable to use
 *   EntityFieldQuery to retrieve a list of entity IDs loadable by
 *   this function.
 * @param $reset
 *   Whether to reset the internal entity_gallery_load cache.
 *
 * @return
 *   An array of entity gallery objects indexed by egid.
 *
 * @todo Remove $conditions in Drupal 8.
 */
function entity_gallery_load_multiple($egids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('entity_gallery', $egids, $conditions, $reset);
}

/**
 * Loads an entity gallery object from the database.
 *
 * @param $egid
 *   The entity gallery ID.
 * @param $vid
 *   The revision ID.
 * @param $reset
 *   Whether to reset the entity_gallery_load_multiple cache.
 *
 * @return
 *   A fully-populated entity gallery object, or FALSE if the entity gallery is
 *   not found.
 */
function entity_gallery_load($egid = NULL, $vid = NULL, $reset = FALSE) {
  $egids = (isset($egid) ? array($egid) : array());
  $conditions = (isset($vid) ? array('vid' => $vid) : array());
  $entity_gallery = entity_gallery_load_multiple($egids, $conditions, $reset);
  return $entity_gallery ? reset($entity_gallery) : FALSE;
}

/**
 * Prepares an entity gallery object for editing.
 *
 * Fills in a few default values, and then invokes hook_prepare() on the entity
 * gallery type module, and hook_entity_gallery_prepare() on all modules.
 *
 * @param $entity_gallery
 *   An entity gallery object.
 */
function entity_gallery_object_prepare($entity_gallery) {
  // Set up default values, if required.
  $entity_gallery_options = variable_get('entity_gallery_options_' . $entity_gallery->type, array('status'));
  // If this is a new entity gallery, fill in the default values.
  if (!isset($entity_gallery->egid) || isset($entity_gallery->is_new)) {
    foreach (array('status', 'sticky') as $key) {
      // Multistep entity gallery forms might have filled in something already.
      if (!isset($entity_gallery->$key)) {
        $entity_gallery->$key = (int) in_array($key, $entity_gallery_options);
      }
    }
    global $user;
    $entity_gallery->uid = $user->uid;
    $entity_gallery->created = REQUEST_TIME;
  }
  else {
    $entity_gallery->date = format_date($entity_gallery->created, 'custom', 'Y-m-d H:i:s O');
    // Remove the log message from the original entity gallery object.
    $entity_gallery->log = NULL;
  }
  // Always use the default revision setting.
  $entity_gallery->revision = in_array('revision', $entity_gallery_options);

  entity_gallery_invoke($entity_gallery, 'prepare');
  module_invoke_all('entity_gallery_prepare', $entity_gallery);
}

/**
 * Implements hook_validate().
 *
 * Performs validation checks on the given entity gallery.
 */
function entity_gallery_validate($entity_gallery, $form, &$form_state) {
  if (isset($entity_gallery->egid) && (entity_gallery_last_changed($entity_gallery->egid) > $entity_gallery->changed)) {
    form_set_error('changed', t('The content on this page has either been modified by another user, or you have already submitted modifications using this form. As a result, your changes cannot be saved.'));
  }

  // Validate the "authored by" field.
  if (!empty($entity_gallery->name) && !($account = user_load_by_name($entity_gallery->name))) {
    // The use of empty() is mandatory in the context of usernames
    // as the empty string denotes the anonymous user. In case we
    // are dealing with an anonymous user we set the user ID to 0.
    form_set_error('name', t('The username %name does not exist.', array('%name' => $entity_gallery->name)));
  }

  // Validate the "authored on" field.
  if (!empty($entity_gallery->date) && strtotime($entity_gallery->date) === FALSE) {
    form_set_error('date', t('You have to specify a valid date.'));
  }

  // Invoke hook_validate() for entity gallery type specific validation and
  // hook_entity_gallery_validate() for miscellaneous validation needed by modules. Can't
  // use entity_gallery_invoke() or module_invoke_all(), because $form_state
  // must be receivable by reference.
  $function = entity_gallery_type_get_base($entity_gallery) . '_validate';
  if (function_exists($function)) {
    $function($entity_gallery, $form, $form_state);
  }
  foreach (module_implements('entity_gallery_validate') as $module) {
    $function = $module . '_entity_gallery_validate';
    $function($entity_gallery, $form, $form_state);
  }
}

/**
 * Prepares entity gallery for saving by populating author and creation date.
 *
 * @param $entity_gallery
 *   An entity gallery object.
 *
 * @return
 *   An updated entity gallery object.
 */
function entity_gallery_submit($entity_gallery) {
  // A user might assign the entity gallery author by entering a user name in
  // the entity gallery form, which we then need to translate to a user ID.
  if (isset($entity_gallery->name)) {
    if ($account = user_load_by_name($entity_gallery->name)) {
      $entity_gallery->uid = $account->uid;
    }
    else {
      $entity_gallery->uid = 0;
    }
  }

  $entity_gallery->created = !empty($entity_gallery->date) ? strtotime($entity_gallery->date) : REQUEST_TIME;
  $entity_gallery->validated = TRUE;

  return $entity_gallery;
}

/**
 * Saves changes to an entity gallery or adds a new entity gallery.
 *
 * @param $entity_gallery
 *   The $entity_gallery object to be saved. If $entity_gallery->egid is
 *   omitted (or $entity_gallery->is_new is TRUE), a new entity gallery will be
 *   added.
 */
function entity_gallery_save($entity_gallery) {
  $transaction = db_transaction();

  try {
    // Load the stored entity, if any.
    if (!empty($entity_gallery->egid) && !isset($entity_gallery->original)) {
      $entity_gallery->original = entity_load_unchanged('entity_gallery', $entity_gallery->egid);
    }

    field_attach_presave('entity_gallery', $entity_gallery);
    global $user;

    // Determine if we will be inserting a new entity gallery.
    if (!isset($entity_gallery->is_new)) {
      $entity_gallery->is_new = empty($entity_gallery->egid);
    }

    // Set the timestamp fields.
    if (empty($entity_gallery->created)) {
      $entity_gallery->created = REQUEST_TIME;
    }
    // The changed timestamp is always updated for bookkeeping purposes,
    // for example: revisions, searching, etc.
    $entity_gallery->changed = REQUEST_TIME;

    $entity_gallery->timestamp = REQUEST_TIME;
    $update_entity_gallery = TRUE;

    // Let modules modify the entity gallery before it is saved to the database.
    module_invoke_all('entity_gallery_presave', $entity_gallery);
    module_invoke_all('entity_presave', $entity_gallery, 'entity_gallery');

    if ($entity_gallery->is_new || !empty($entity_gallery->revision)) {
      // When inserting either a new entity gallery or a new entity gallery
      // revision, $entity_gallery->log must be set because
      // {entity_gallery_revision}.log is a text column and therefore cannot
      // have a default value. However, it might not be set at this point (for
      // example, if the user submitting an entity gallery form does not have
      // permission to create revisions), so we ensure that it is at least an
      // empty string in that case.
      // @todo: Make the {entity_gallery_revision}.log column nullable so that
      // we can remove this check.
      if (!isset($entity_gallery->log)) {
        $entity_gallery->log = '';
      }
    }
    elseif (!isset($entity_gallery->log) || $entity_gallery->log === '') {
      // If we are updating an existing entity gallery without adding a new
      // revision, we need to make sure $entity_gallery->log is unset whenever
      // it is empty. As long as $entity_gallery->log is unset,
      // drupal_write_record() will not attempt to update the existing database
      // column when re-saving the revision; therefore, this code allows us to
      // avoid clobbering an existing log entry with an empty one.
      unset($entity_gallery->log);
    }

    // When saving a new entity gallery revision, unset any existing
    // $entity_gallery->vid so as to ensure that a new revision will actually be
    // created, then store the old revision ID in a separate property for use by
    // entity gallery hook implementations.
    if (!$entity_gallery->is_new && !empty($entity_gallery->revision) && $entity_gallery->vid) {
      $entity_gallery->old_vid = $entity_gallery->vid;
      unset($entity_gallery->vid);
    }

    // Save the entity gallery and entity gallery revision.
    if ($entity_gallery->is_new) {
      // For new entity galleries, save new records for both the entity gallery
      // itself and the entity gallery revision.
      drupal_write_record('entity_gallery', $entity_gallery);
      _entity_gallery_save_revision($entity_gallery, $user->uid);
      $op = 'insert';
    }
    else {
      // For existing entity galleries, update the entity gallery record which
      // matches the value of $entity_gallery->egid.
      drupal_write_record('entity_gallery', $entity_gallery, 'egid');
      // Then, if a new entity gallery revision was requested, save a new record
      // for that; otherwise, update the entity gallery revision record which
      // matches the value of $entity_gallery->vid.
      if (!empty($entity_gallery->revision)) {
        _entity_gallery_save_revision($entity_gallery, $user->uid);
      }
      else {
        _entity_gallery_save_revision($entity_gallery, $user->uid, 'vid');
        $update_entity_gallery = FALSE;
      }
      $op = 'update';
    }
    if ($update_entity_gallery) {
      db_update('entity_gallery')
        ->fields(array('vid' => $entity_gallery->vid))
        ->condition('egid', $entity_gallery->egid)
        ->execute();
    }

    // Call the entity gallery specific callback (if any). This can be
    // entity_gallery_invoke($entity_gallery, 'insert') or
    // entity_gallery_invoke($entity_gallery, 'update').
    entity_gallery_invoke($entity_gallery, $op);

    // Save fields.
    $function = "field_attach_$op";
    $function('entity_gallery', $entity_gallery);

    module_invoke_all('entity_gallery_' . $op, $entity_gallery);
    module_invoke_all('entity_' . $op, $entity_gallery, 'entity_gallery');

    // Clear internal properties.
    unset($entity_gallery->is_new);
    unset($entity_gallery->original);
    // Clear the static loading cache.
    entity_get_controller('entity_gallery')->resetCache(array($entity_gallery->egid));

    // Ignore slave server temporarily to give time for the
    // saved entity gallery to be propagated to the slave.
    db_ignore_slave();
  }
  catch (Exception $e) {
    $transaction->rollback();
    watchdog_exception('entity_gallery', $e);
    throw $e;
  }
}

/**
 * Helper function to save a revision with the uid of the current user.
 *
 * The resulting revision ID is available afterward in $entity_gallery->vid.
 *
 * @param $entity_gallery
 *   An entity gallery object.
 * @param $uid
 *   The current user's UID.
 * @param $update
 *   (optional) An array of primary keys' field names to update.
 */
function _entity_gallery_save_revision($entity_gallery, $uid, $update = NULL) {
  $temp_uid = $entity_gallery->uid;
  $entity_gallery->uid = $uid;
  if (isset($update)) {
    drupal_write_record('entity_gallery_revision', $entity_gallery, $update);
  }
  else {
    drupal_write_record('entity_gallery_revision', $entity_gallery);
  }
  // Have entity gallery object still show entity gallery owner's uid, not
  // revision author's.
  $entity_gallery->uid = $temp_uid;
}

/**
 * Deletes an entity gallery.
 *
 * @param $egid
 *   An entity gallery ID.
 */
function entity_gallery_delete($egid) {
  entity_gallery_delete_multiple(array($egid));
}

/**
 * Deletes multiple entity galleries.
 *
 * @param $egids
 *   An array of entity gallery IDs.
 */
function entity_gallery_delete_multiple($egids) {
  $transaction = db_transaction();
  if (!empty($egids)) {
    $entity_galleries = entity_gallery_load_multiple($egids, array());

    try {
      foreach ($entity_galleries as $egid => $entity_gallery) {
        // Call the entity gallery-specific callback (if any):
        entity_gallery_invoke($entity_gallery, 'delete');
        module_invoke_all('entity_gallery_delete', $entity_gallery);
        module_invoke_all('entity_delete', $entity_gallery, 'entity_gallery');
        field_attach_delete('entity_gallery', $entity_gallery);

        // Remove this entity gallery from the search index if needed.
        // This code is implemented in entity gallery module rather than in
        // search module, because entity gallery module is implementing search
        // module's API, not the other way around.
        if (module_exists('search')) {
          search_reindex($egid, 'entity_gallery');
        }
      }

      // Delete after calling hooks so that they can query entity gallery tables
      // as needed.
      db_delete('entity_gallery')
        ->condition('egid', $egids, 'IN')
        ->execute();
      db_delete('entity_gallery_revision')
        ->condition('egid', $egids, 'IN')
        ->execute();
    }
    catch (Exception $e) {
      $transaction->rollback();
      watchdog_exception('entity_gallery', $e);
      throw $e;
    }

    // Clear the page and block and entity_gallery_load_multiple caches.
    entity_get_controller('entity_gallery')->resetCache();
  }
}

/**
 * Deletes an entity gallery revision.
 *
 * @param $revision_id
 *   The revision ID to delete.
 */
function entity_gallery_revision_delete($revision_id) {
  if ($revision = entity_gallery_load(NULL, $revision_id)) {
    // Prevent deleting the current revision.
    $entity_gallery = entity_gallery_load($revision->egid);
    if ($revision_id == $entity_gallery->vid) {
      return FALSE;
    }

    db_delete('entity_gallery_revision')
      ->condition('egid', $revision->egid)
      ->condition('vid', $revision->vid)
      ->execute();
    module_invoke_all('entity_gallery_revision_delete', $revision);
    field_attach_delete_revision('entity_gallery', $revision);
    return TRUE;
  }
  return FALSE;
}

/**
 * Generates an array for rendering the given entity gallery.
 *
 * @param $entity_gallery
 *   An entity gallery object.
 * @param $view_mode
 *   View mode, e.g. 'full', 'teaser'...
 * @param $langcode
 *   (optional) A language code to use for rendering. Defaults to the global
 *   content language of the current request.
 *
 * @return
 *   An array as expected by drupal_render().
 */
function entity_gallery_view($entity_gallery, $view_mode = 'full', $langcode = NULL) {
  if (!isset($langcode)) {
    $langcode = $GLOBALS['language_content']->language;
  }

  // Populate $entity_gallery->content with a render() array.
  entity_gallery_build_content($entity_gallery, $view_mode, $langcode);

  $build = $entity_gallery->content;
  // We don't need duplicate rendering info in entity_gallery->content.
  unset($entity_gallery->content);

  $build += array(
    '#theme' => 'entity_gallery',
    '#entity_gallery' => $entity_gallery,
    '#view_mode' => $view_mode,
    '#language' => $langcode,
  );

  // Add contextual links for this entity gallery, except when the entity
  // gallery is already being displayed on its own page. Modules may alter this
  // behavior (for example, to restrict contextual links to certain view modes)
  // by implementing hook_entity_gallery_view_alter().
  if (!empty($entity_gallery->egid) && !($view_mode == 'full' && entity_gallery_is_page($entity_gallery))) {
    $build['#contextual_links']['entity_gallery'] = array('entity_gallery', array($entity_gallery->egid));
  }

  // Allow modules to modify the structured entity gallery.
  $type = 'entity_gallery';
  drupal_alter(array('entity_gallery_view', 'entity_view'), $build, $type);

  return $build;
}

/**
 * Builds a structured array representing the entity gallery's content.
 *
 * The content built for the entity gallery (field values, file attachments or
 * other entity gallery components) will vary depending on the $view_mode
 * parameter.
 *
 * Drupal core defines the following view modes for entity galleries, with the
 * following default use cases:
 *   - full (default): entity gallery is being displayed on its own page
 *     (gallery/123)
 *   - teaser: entity gallery is being displayed on taxonomy listing pages, or
 *     on blog listing pages.
 *   If search.module is enabled:
 *   - search_index: entity gallery is being indexed for search.
 *   - search_result: entity gallery is being displayed as a search result.
 *   If book.module is enabled:
 *   - print: entity gallery is being displayed in print-friendly mode.
 * Contributed modules might define additional view modes, or use existing
 * view modes in additional contexts.
 *
 * @param $entity_gallery
 *   An entity gallery object.
 * @param $view_mode
 *   View mode, e.g. 'full', 'teaser'...
 * @param $langcode
 *   (optional) A language code to use for rendering. Defaults to the global
 *   content language of the current request.
 */
function entity_gallery_build_content($entity_gallery, $view_mode = 'full', $langcode = NULL) {
  if (!isset($langcode)) {
    $langcode = $GLOBALS['language_content']->language;
  }

  // Remove previously built content, if exists.
  $entity_gallery->content = array();

  // Allow modules to change the view mode.
  $view_mode = key(entity_view_mode_prepare('entity_gallery', array($entity_gallery->egid => $entity_gallery), $view_mode, $langcode));

  // The 'view' hook can be implemented to overwrite the default function
  // to display entity galleries.
  if (entity_gallery_hook($entity_gallery, 'view')) {
    $entity_gallery = entity_gallery_invoke($entity_gallery, 'view', $view_mode, $langcode);
  }

  // Build fields content.
  // In case of a multiple view, entity_gallery_view_multiple() already ran the
  // 'prepare_view' step. An internal flag prevents the operation from running
  // twice.
  field_attach_prepare_view('entity_gallery', array($entity_gallery->egid => $entity_gallery), $view_mode, $langcode);
  entity_prepare_view('entity_gallery', array($entity_gallery->egid => $entity_gallery), $langcode);
  $entity_gallery->content += field_attach_view('entity_gallery', $entity_gallery, $view_mode, $langcode);

  // Always display a read more link on teasers because we have no way to know
  // when a teaser view is different than a full view.
  $links = array();
  $entity_gallery->content['links'] = array(
    '#theme' => 'links__entity_gallery',
    '#pre_render' => array('drupal_pre_render_links'),
    '#attributes' => array('class' => array('links', 'inline')),
  );
  if ($view_mode == 'teaser') {
    $entity_gallery_title_stripped = strip_tags($entity_gallery->title);
    $links['entity_gallery-readmore'] = array(
      'title' => t('Read more<span class="element-invisible"> about @title</span>', array('@title' => $entity_gallery_title_stripped)),
      'href' => 'gallery/' . $entity_gallery->egid,
      'html' => TRUE,
      'attributes' => array('rel' => 'tag', 'title' => $entity_gallery_title_stripped),
    );
  }
  $entity_gallery->content['links']['entity_gallery'] = array(
    '#theme' => 'links__entity_gallery__entity_gallery',
    '#links' => $links,
    '#attributes' => array('class' => array('links', 'inline')),
  );

  // Allow modules to make their own additions to the entity gallery.
  module_invoke_all('entity_gallery_view', $entity_gallery, $view_mode, $langcode);
  module_invoke_all('entity_view', $entity_gallery, 'entity_gallery', $view_mode, $langcode);

  // Make sure the current view mode is stored if no module has already
  // populated the related key.
  $entity_gallery->content += array('#view_mode' => $view_mode);
}

/**
 * Generates an array which displays an entity gallery detail page.
 *
 * @param $entity_gallery
 *   An entity gallery object.
 * @param $message
 *   A flag which sets a page title relevant to the revision being viewed.
 *
 * @return
 *   A $page element suitable for use by drupal_render().
 */
function entity_gallery_show($entity_gallery, $message = FALSE) {
  if ($message) {
    drupal_set_title(t('Revision of %title from %date', array('%title' => $entity_gallery->title, '%date' => format_date($entity_gallery->revision_timestamp))), PASS_THROUGH);
  }

  // For markup consistency with other pages, use entity_gallery_view_multiple() rather than entity_gallery_view().
  $entity_galleries = entity_gallery_view_multiple(array($entity_gallery->egid => $entity_gallery), 'full');

  return $entity_galleries;
}

/**
 * Returns whether the current page is the full page view of the passed-in entity gallery.
 *
 * @param $entity_gallery
 *   An entity gallery object.
 *
 * @return
 *   The ID of the entity gallery if this is a full page view, otherwise FALSE.
 */
function entity_gallery_is_page($entity_gallery) {
  $page_entity_gallery = menu_get_object('entity_gallery');
  return (!empty($page_entity_gallery) ? $page_entity_gallery->egid == $entity_gallery->egid : FALSE);
}

/**
 * Processes variables for entity_gallery.tpl.php
 *
 * Most themes utilize their own copy of entity_gallery.tpl.php. The default is
 * located inside "modules/entity_gallery/entity_gallery.tpl.php". Look in there
 * for the full list of variables.
 *
 * The $variables array contains the following arguments:
 * - $entity_gallery
 * - $view_mode
 * - $page
 *
 * @see entity_gallery.tpl.php
 */
function template_preprocess_entity_gallery(&$variables) {
  $variables['view_mode'] = $variables['elements']['#view_mode'];
  // Provide a distinct $teaser boolean.
  $variables['teaser'] = $variables['view_mode'] == 'teaser';
  $variables['entity_gallery'] = $variables['elements']['#entity_gallery'];
  $entity_gallery = $variables['entity_gallery'];

  $variables['date']      = format_date($entity_gallery->created);
  $variables['name']      = theme('username', array('account' => $entity_gallery));

  $uri = entity_uri('entity_gallery', $entity_gallery);
  $variables['entity_gallery_url']  = url($uri['path'], $uri['options']);
  $variables['title']     = check_plain($entity_gallery->title);
  $variables['page']      = $variables['view_mode'] == 'full' && entity_gallery_is_page($entity_gallery);

  // Flatten the entity gallery object's member fields.
  $variables = array_merge((array) $entity_gallery, $variables);

  // Helpful $content variable for templates.
  $variables += array('content' => array());
  foreach (element_children($variables['elements']) as $key) {
    $variables['content'][$key] = $variables['elements'][$key];
  }

  // Make the field variables available with the appropriate language.
  field_attach_preprocess('entity_gallery', $entity_gallery, $variables['content'], $variables);

  // Display post information only on certain entity gallery types.
  if (variable_get('entity_gallery_submitted_' . $entity_gallery->type, TRUE)) {
    $variables['display_submitted'] = TRUE;
    $variables['submitted'] = t('Submitted by !username on !datetime', array('!username' => $variables['name'], '!datetime' => $variables['date']));
    $variables['user_picture'] = theme_get_setting('toggle_entity_gallery_user_picture') ? theme('user_picture', array('account' => $entity_gallery)) : '';
  }
  else {
    $variables['display_submitted'] = FALSE;
    $variables['submitted'] = '';
    $variables['user_picture'] = '';
  }

  // Gather entity gallery classes.
  $variables['classes_array'][] = drupal_html_class('entity-gallery-' . $entity_gallery->type);
  if ($variables['sticky']) {
    $variables['classes_array'][] = 'entity-gallery-sticky';
  }
  if (!$variables['status']) {
    $variables['classes_array'][] = 'entity-gallery-unpublished';
  }
  if ($variables['teaser']) {
    $variables['classes_array'][] = 'entity-gallery-teaser';
  }
  if (isset($variables['preview'])) {
    $variables['classes_array'][] = 'entity-gallery-preview';
  }

  // Clean up name so there are no underscores.
  $variables['theme_hook_suggestions'][] = 'entity_gallery__' . $entity_gallery->type;
  $variables['theme_hook_suggestions'][] = 'entity_gallery__' . $entity_gallery->egid;
}

/**
 * Process variables for page.tpl.php.
 */
function entity_gallery_process_page(&$variables) {
  if (!module_exists('title')) {
    return;
  }

  // Ugly but necessary: there is no standardized way to tell if the current
  // page is an entity view page. This information should be injected here in
  // some form by entity-defining modules.
  $entity_types = array(
    'entity_gallery' => 1,
  );

  foreach ($entity_types as $entity_type => $position) {
    if ($entity = menu_get_object($entity_type, $position)) {
      break;
    }
  }

  if ($entity) {
    title_field_replacement_hide_label($entity_type, $entity, $variables, TRUE);
  }
}

/**
 * Process variables for entity_gallery.tpl.php on behalf of title.module.
 */
function title_process_entity_gallery(&$variables) {
  title_field_replacement_hide_label('entity_gallery', $variables['entity_gallery'], $variables);
}

/**
 * Implements hook_permission().
 */
function entity_gallery_permission() {
  $perms = array(
    'bypass entity gallery access' => array(
      'title' => t('Bypass gallery access control'),
      'description' => t('View, edit and delete all galleries regardless of permission restrictions.'),
      'restrict access' => TRUE,
    ),
    'administer entity gallery types' => array(
      'title' => t('Administer gallery types'),
      'restrict access' => TRUE,
    ),
    'administer entity galleries' => array(
      'title' => t('Administer galleries'),
      'restrict access' => TRUE,
    ),
    'access entity galleries overview' => array(
      'title' => t('Access the gallery overview page'),
      'description' => t('Get an overview of <a href="@url">all galleries</a>.', array('@url' => url('admin/content/gallery'))),
    ),
    'access entity galleries' => array(
      'title' => t('View published galleries'),
    ),
    'view own unpublished entity galleries' => array(
      'title' => t('View own unpublished galleries'),
    ),
    'view entity gallery revisions' => array(
      'title' => t('View gallery revisions'),
    ),
    'revert entity gallery revisions' => array(
      'title' => t('Revert gallery revisions'),
    ),
    'delete entity gallery revisions' => array(
      'title' => t('Delete gallery revisions'),
    ),
  );

  // Generate standard entity gallery permissions for all applicable entity
  // gallery types.
  foreach (entity_gallery_permissions_get_configured_types() as $type) {
    $perms += entity_gallery_list_permissions($type);
  }

  return $perms;
}

/**
 * Gathers the rankings from the hook_ranking() implementations.
 *
 * @param $query
 *   A query object that has been extended with the Search DB Extender.
 */
function _entity_gallery_rankings(SelectQueryExtender $query) {
  if ($ranking = module_invoke_all('ranking')) {
    $tables = &$query->getTables();
    foreach ($ranking as $rank => $values) {
      if ($entity_gallery_rank = variable_get('entity_gallery_rank_' . $rank, 0)) {
        // If the table defined in the ranking isn't already joined, then add it.
        if (isset($values['join']) && !isset($tables[$values['join']['alias']])) {
          $query->addJoin($values['join']['type'], $values['join']['table'], $values['join']['alias'], $values['join']['on']);
        }
        $arguments = isset($values['arguments']) ? $values['arguments'] : array();
        $query->addScore($values['score'], $arguments, $entity_gallery_rank);
      }
    }
  }
}

/**
 * Implements hook_search_info().
 */
function entity_gallery_search_info() {
  return array(
    'title' => 'Galleries',
    'path' => 'galleries',
  );
}

/**
 * Implements hook_search_access().
 */
function entity_gallery_search_access() {
  return user_access('access entity galleries');
}

/**
 * Implements hook_search_reset().
 */
function entity_gallery_search_reset() {
  db_update('search_dataset')
    ->fields(array('reindex' => REQUEST_TIME))
    ->condition('type', 'entity_gallery')
    ->execute();
}

/**
 * Implements hook_search_status().
 */
function entity_gallery_search_status() {
  $total = db_query('SELECT COUNT(*) FROM {entity_gallery}')->fetchField();
  $remaining = db_query("SELECT COUNT(*) FROM {entity_gallery} eg LEFT JOIN {search_dataset} d ON d.type = 'entity_gallery' AND d.sid = eg.egid WHERE d.sid IS NULL OR d.reindex <> 0")->fetchField();
  return array('remaining' => $remaining, 'total' => $total);
}

/**
 * Implements hook_search_admin().
 */
function entity_gallery_search_admin() {
  // Output form for defining rank factor weights.
  $form['galleries_ranking'] = array(
    '#type' => 'fieldset',
    '#title' => t('Galleries ranking'),
  );
  $form['galleries_ranking']['#theme'] = 'entity_gallery_search_admin';
  $form['galleries_ranking']['info'] = array(
    '#markup' => '<p><em>' . t('Influence is a numeric multiplier used in ordering search results. A higher number means the corresponding factor has more influence on search results; zero means the factor is ignored. Changing these numbers does not require the search index to be rebuilt. Changes take effect immediately.') . '</em></p>'
  );

  // Note: reversed to reflect that higher number = higher ranking.
  $options = drupal_map_assoc(range(0, 10));
  foreach (module_invoke_all('ranking') as $var => $values) {
    $form['galleries_ranking']['factors']['entity_gallery_rank_' . $var] = array(
      '#title' => $values['title'],
      '#type' => 'select',
      '#options' => $options,
      '#default_value' => variable_get('entity_gallery_rank_' . $var, 0),
    );
  }
  return $form;
}

/**
 * Implements hook_search_execute().
 */
function entity_gallery_search_execute($keys = NULL, $conditions = NULL) {
  // Build matching conditions
  $query = db_select('search_index', 'i', array('target' => 'slave'))->extend('SearchQuery')->extend('PagerDefault');
  $query->join('entity_gallery', 'eg', 'eg.egid = i.sid');
  $query
    ->condition('eg.status', 1)
    ->addTag('entity_gallery_access')
    ->searchExpression($keys, 'entity_gallery');

  // Insert special keywords.
  $query->setOption('type', 'eg.type');
  $query->setOption('language', 'eg.language');
  if ($query->setOption('term', 'ti.tid')) {
    $query->join('taxonomy_index', 'ti', 'eg.egid = ti.egid');
  }
  // Only continue if the first pass query matches.
  if (!$query->executeFirstPass()) {
    return array();
  }

  // Add the ranking expressions.
  _entity_gallery_rankings($query);

  // Load results.
  $find = $query
    ->limit(10)
    ->execute();
  $results = array();
  foreach ($find as $item) {
    // Render the entity gallery.
    $entity_gallery = entity_gallery_load($item->sid);
    $build = entity_gallery_view($entity_gallery, 'search_result');
    unset($build['#theme']);
    $entity_gallery->rendered = drupal_render($build);

    $extra = module_invoke_all('entity_gallery_search_result', $entity_gallery);

    $uri = entity_uri('entity_gallery', $entity_gallery);
    $results[] = array(
      'link' => url($uri['path'], array_merge($uri['options'], array('absolute' => TRUE))),
      'type' => check_plain(entity_gallery_type_get_name($entity_gallery)),
      'title' => $entity_gallery->title,
      'user' => theme('username', array('account' => $entity_gallery)),
      'date' => $entity_gallery->changed,
      'entity_gallery' => $entity_gallery,
      'extra' => $extra,
      'score' => $item->calculated_score,
      'snippet' => search_excerpt($keys, $entity_gallery->rendered),
      'language' => entity_language('entity_gallery', $entity_gallery),
    );
  }
  return $results;
}

/**
 * Implements hook_ranking().
 */
function entity_gallery_ranking() {
  // Create the ranking array and add the basic ranking options.
  $ranking = array(
    'relevance' => array(
      'title' => t('Keyword relevance'),
      // Average relevance values hover around 0.15
      'score' => 'i.relevance',
    ),
    'sticky' => array(
      'title' => t('Gallery is sticky at top of lists'),
      // The sticky flag is either 0 or 1, which is automatically normalized.
      'score' => 'eg.sticky',
    ),
  );

  // Add relevance based on creation or changed date.
  if ($entity_gallery_cron_last = variable_get('entity_gallery_cron_last', 0)) {
    $ranking['recent'] = array(
      'title' => t('Recently posted'),
      // Exponential decay with half-life of 6 months, starting at last indexed entity gallery
      'score' => 'POW(2.0, (GREATEST(eg.created, eg.changed) - :entity_gallery_cron_last) * 6.43e-8)',
      'arguments' => array(':entity_gallery_cron_last' => $entity_gallery_cron_last),
    );
  }
  return $ranking;
}

/**
 * Implements hook_user_cancel().
 */
function entity_gallery_user_cancel($edit, $account, $method) {
  switch ($method) {
    case 'user_cancel_block_unpublish':
      // Unpublish entity galleries (current revisions).
      module_load_include('inc', 'entity_gallery', 'entity_gallery.admin');
      $entity_galleries = db_select('entity_gallery', 'eg')
        ->fields('eg', array('egid'))
        ->condition('uid', $account->uid)
        ->execute()
        ->fetchCol();
      entity_gallery_mass_update($entity_galleries, array('status' => 0));
      break;

    case 'user_cancel_reassign':
      // Anonymize entity galleries (current revisions).
      module_load_include('inc', 'entity_gallery', 'entity_gallery.admin');
      $entity_galleries = db_select('entity_gallery', 'eg')
        ->fields('eg', array('egid'))
        ->condition('uid', $account->uid)
        ->execute()
        ->fetchCol();
      entity_gallery_mass_update($entity_galleries, array('uid' => 0));
      // Anonymize old revisions.
      db_update('entity_gallery_revision')
        ->fields(array('uid' => 0))
        ->condition('uid', $account->uid)
        ->execute();
      break;
  }
}

/**
 * Implements hook_user_delete().
 */
function entity_gallery_user_delete($account) {
  // Delete entity galleries (current revisions).
  // @todo Introduce entity_gallery_mass_delete() or make entity_gallery_mass_update() more flexible.
  $entity_galleries = db_select('entity_gallery', 'eg')
    ->fields('eg', array('egid'))
    ->condition('uid', $account->uid)
    ->execute()
    ->fetchCol();
  entity_gallery_delete_multiple($entity_galleries);
  // Delete old revisions.
  $revisions = db_query('SELECT vid FROM {entity_gallery_revision} WHERE uid = :uid', array(':uid' => $account->uid))->fetchCol();
  foreach ($revisions as $revision) {
    entity_gallery_revision_delete($revision);
  }
}

/**
 * Returns HTML for the content ranking part of the search settings admin page.
 *
 * @param $variables
 *   An associative array containing:
 *   - form: A render element representing the form.
 *
 * @see entity_gallery_search_admin()
 * @ingroup themeable
 */
function theme_entity_gallery_search_admin($variables) {
  $form = $variables['form'];

  $output = drupal_render($form['info']);

  $header = array(t('Factor'), t('Influence'));
  foreach (element_children($form['factors']) as $key) {
    $row = array();
    $row[] = $form['factors'][$key]['#title'];
    $form['factors'][$key]['#title_display'] = 'invisible';
    $row[] = drupal_render($form['factors'][$key]);
    $rows[] = $row;
  }
  $output .= theme('table', array('header' => $header, 'rows' => $rows));

  $output .= drupal_render_children($form);
  return $output;
}

/**
 * Access callback: Checks entity gallery revision access.
 *
 * @param $entity_gallery
 *   The entity gallery to check.
 * @param $op
 *   (optional) The specific operation being checked. Defaults to 'view.'
 * @param object $account
 *   (optional) A user object representing the user for whom the operation is
 *   to be performed. Determines access for a user other than the current user.
 *
 * @return
 *   TRUE if the operation may be performed, FALSE otherwise.
 *
 * @see entity_gallery_menu()
 */
function _entity_gallery_revision_access($entity_gallery, $op = 'view', $account = NULL) {
  $access = &drupal_static(__FUNCTION__, array());

  $map = array(
    'view' => 'view entity gallery revisions',
    'update' => 'revert entity gallery revisions',
    'delete' => 'delete entity gallery revisions',
  );

  if (!$entity_gallery || !isset($map[$op])) {
    // If there was no entity gallery to check against, or the $op was not one
    // of the supported ones, we return access denied.
    return FALSE;
  }

  if (!isset($account)) {
    $account = $GLOBALS['user'];
  }

  // Statically cache access by revision ID, user account ID, and operation.
  $cid = $entity_gallery->vid . ':' . $account->uid . ':' . $op;

  if (!isset($access[$cid])) {
    // Perform basic permission checks first.
    if (!user_access($map[$op], $account) && !user_access('administer entity galleries', $account)) {
      return $access[$cid] = FALSE;
    }

    $entity_gallery_current_revision = entity_gallery_load($entity_gallery->egid);
    $is_current_revision = $entity_gallery_current_revision->vid == $entity_gallery->vid;

    // There should be at least two revisions. If the vid of the given entity
    // gallery and the vid of the current revision differ, then we already have
    // two different revisions so there is no need for a separate database
    // check.
    // Also, if you try to revert to or delete the current revision, that's not
    // good.
    if ($is_current_revision && (db_query('SELECT COUNT(vid) FROM {entity_gallery_revision} WHERE egid = :egid', array(':egid' => $entity_gallery->egid))->fetchField() == 1 || $op == 'update' || $op == 'delete')) {
      $access[$cid] = FALSE;
    }
    elseif (user_access('administer entity galleries', $account)) {
      $access[$cid] = TRUE;
    }
    else {
      // First check the access to the current revision and finally, if the
      // entity gallery passed in is not the current revision then access to
      // that, too.
      $access[$cid] = entity_gallery_access($op, $entity_gallery_current_revision, $account) && ($is_current_revision || entity_gallery_access($op, $entity_gallery, $account));
    }
  }

  return $access[$cid];
}

/**
 * Access callback: Checks whether the user has permission to add an entity gallery.
 *
 * @return
 *   TRUE if the user has add permission, otherwise FALSE.
 *
 * @see entity_gallery_menu()
 */
function _entity_gallery_add_access() {
  $types = entity_gallery_type_get_types();
  foreach ($types as $type) {
    if (entity_gallery_hook($type->type, 'form') && entity_gallery_access('create', $type->type)) {
      return TRUE;
    }
  }
  if (user_access('administer entity gallery types')) {
    // There are no entity gallery types defined that the user has permission to
    // create, but the user does have the permission to administer the entity
    // gallery types, so grant them access to the page anyway.
    return TRUE;
  }
  return FALSE;
}

/**
 * Implements hook_menu().
 */
function entity_gallery_menu() {
  $items['admin/content/gallery'] = array(
    'title' => 'Galleries',
    'description' => 'Find and manage galleries.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('entity_gallery_admin_gallery'),
    'access arguments' => array('access entity galleries overview'),
    'weight' => -10,
    'type' => MENU_LOCAL_TASK | MENU_NORMAL_ITEM,
    'file' => 'entity_gallery.admin.inc',
  );
  $items['admin/content/gallery/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  $items['admin/structure/gallery-types'] = array(
    'title' => 'Gallery types',
    'description' => 'Manage gallery types, including publishing options, display settings, etc.',
    'page callback' => 'entity_gallery_overview_types',
    'access arguments' => array('administer entity gallery types'),
    'file' => 'gallery_types.inc',
  );
  $items['admin/structure/gallery-types/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/structure/gallery-types/add'] = array(
    'title' => 'Add gallery type',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('entity_gallery_type_form'),
    'access arguments' => array('administer entity gallery types'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'gallery_types.inc',
  );
  $items['admin/structure/gallery-types/manage/%entity_gallery_type'] = array(
    'title' => 'Edit gallery type',
    'title callback' => 'entity_gallery_type_page_title',
    'title arguments' => array(4),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('entity_gallery_type_form', 4),
    'access arguments' => array('administer entity gallery types'),
    'file' => 'gallery_types.inc',
  );
  $items['admin/structure/gallery-types/manage/%entity_gallery_type/edit'] = array(
    'title' => 'Edit',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/structure/gallery-types/manage/%entity_gallery_type/delete'] = array(
    'title' => 'Delete',
    'page arguments' => array('entity_gallery_type_delete_confirm', 4),
    'access arguments' => array('administer entity gallery types'),
    'file' => 'gallery_types.inc',
  );

  $items['gallery/add'] = array(
    'title' => 'Add gallery',
    'page callback' => 'entity_gallery_add_page',
    'access callback' => '_entity_gallery_add_access',
    'file' => 'entity_gallery.pages.inc',
  );
  // @todo Remove this loop when we have a 'description callback' property.
  // Reset internal static cache of _entity_gallery_types_build(), forces to
  // rebuild the entity gallery type information.
  entity_gallery_type_cache_reset();
  foreach (entity_gallery_type_get_types() as $type) {
    $type_url_str = str_replace('_', '-', $type->type);
    $items['gallery/add/' . $type_url_str] = array(
      'title' => $type->name,
      'title callback' => 'check_plain',
      'page callback' => 'entity_gallery_add',
      'page arguments' => array($type->type),
      'access callback' => 'entity_gallery_access',
      'access arguments' => array('create', $type->type),
      'description' => $type->description,
      'file' => 'entity_gallery.pages.inc',
    );
  }
  $items['gallery/%entity_gallery'] = array(
    'title callback' => 'entity_gallery_page_title',
    'title arguments' => array(1),
    // The page callback also invokes drupal_set_title() in case
    // the menu router's title is overridden by a menu link.
    'page callback' => 'entity_gallery_page_view',
    'page arguments' => array(1),
    'access callback' => 'entity_gallery_access',
    'access arguments' => array('view', 1),
  );
  $items['gallery/%entity_gallery/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['gallery/%entity_gallery/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'entity_gallery_page_edit',
    'page arguments' => array(1),
    'access callback' => 'entity_gallery_access',
    'access arguments' => array('update', 1),
    'weight' => 0,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'file' => 'entity_gallery.pages.inc',
  );
  $items['gallery/%entity_gallery/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('entity_gallery_delete_confirm', 1),
    'access callback' => 'entity_gallery_access',
    'access arguments' => array('delete', 1),
    'weight' => 1,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'file' => 'entity_gallery.pages.inc',
  );
  $items['gallery/%entity_gallery/revisions'] = array(
    'title' => 'Revisions',
    'page callback' => 'entity_gallery_revision_overview',
    'page arguments' => array(1),
    'access callback' => '_entity_gallery_revision_access',
    'access arguments' => array(1),
    'weight' => 2,
    'type' => MENU_LOCAL_TASK,
    'file' => 'entity_gallery.pages.inc',
  );
  $items['gallery/%entity_gallery/revisions/%/view'] = array(
    'title' => 'Revisions',
    'load arguments' => array(3),
    'page callback' => 'entity_gallery_show',
    'page arguments' => array(1, TRUE),
    'access callback' => '_entity_gallery_revision_access',
    'access arguments' => array(1),
  );
  $items['gallery/%entity_gallery/revisions/%/revert'] = array(
    'title' => 'Revert to earlier revision',
    'load arguments' => array(3),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('entity_gallery_revision_revert_confirm', 1),
    'access callback' => '_entity_gallery_revision_access',
    'access arguments' => array(1, 'update'),
    'file' => 'entity_gallery.pages.inc',
  );
  $items['gallery/%entity_gallery/revisions/%/delete'] = array(
    'title' => 'Delete earlier revision',
    'load arguments' => array(3),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('entity_gallery_revision_delete_confirm', 1),
    'access callback' => '_entity_gallery_revision_access',
    'access arguments' => array(1, 'delete'),
    'file' => 'entity_gallery.pages.inc',
  );
  return $items;
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function entity_gallery_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  // Add action link to 'gallery/add' on 'admin/content/gallery' page.
  if ($root_path == 'admin/content/gallery') {
    $item = menu_get_item('gallery/add');
    if ($item['access']) {
      $data['actions']['output'][] = array(
        '#theme' => 'menu_local_action',
        '#link' => $item,
      );
    }
  }
}

/**
 * Title callback: Returns the unsanitized title of the entity gallery type edit form.
 *
 * @param $type
 *   The entity gallery type object.
 *
 * @return string
 *   An unsanitized string that is the title of the entity gallery type edit form.
 *
 * @see entity_gallery_menu()
 */
function entity_gallery_type_page_title($type) {
  return $type->name;
}

/**
 * Title callback: Returns the title of the entity gallery.
 *
 * @param $entity_gallery
 *   The entity gallery object.
 *
 * @return
 *   An unsanitized string that is the title of the entity gallery.
 *
 * @see entity_gallery_menu()
 */
function entity_gallery_page_title($entity_gallery) {
  return $entity_gallery->title;
}

/**
 * Finds the last time an entity gallery was changed.
 *
 * @param $egid
 *   The ID of an entity gallery.
 *
 * @return
 *   A unix timestamp indicating the last time the entity gallery was changed.
 */
function entity_gallery_last_changed($egid) {
  return db_query('SELECT changed FROM {entity_gallery} WHERE egid = :egid', array(':egid' => $egid))->fetch()->changed;
}

/**
 * Returns a list of all the existing revision numbers.
 *
 * @param $entity_gallery
 *   The entity gallery object.
 *
 * @return
 *   An associative array keyed by entity gallery revision number.
 */
function entity_gallery_revision_list($entity_gallery) {
  $revisions = array();
  $result = db_query('SELECT r.vid, r.title, r.log, r.uid, eg.vid AS current_vid, r.timestamp, u.name FROM {entity_gallery_revision} r LEFT JOIN {entity_gallery} eg ON eg.vid = r.vid INNER JOIN {users} u ON u.uid = r.uid WHERE r.egid = :egid ORDER BY r.vid DESC', array(':egid' => $entity_gallery->egid));
  foreach ($result as $revision) {
    $revisions[$revision->vid] = $revision;
  }

  return $revisions;
}

/**
 * Constructs a drupal_render() style array from an array of loaded entity galleries.
 *
 * @param $entity_galleries
 *   An array of entity galleries as returned by entity_gallery_load_multiple().
 * @param $view_mode
 *   View mode, e.g. 'full', 'teaser'...
 * @param $weight
 *   An integer representing the weight of the first entity gallery in the list.
 * @param $langcode
 *   (optional) A language code to use for rendering. Defaults to NULL which is
 *   the global content language of the current request.
 *
 * @return
 *   An array in the format expected by drupal_render().
 */
function entity_gallery_view_multiple($entity_galleries, $view_mode = 'teaser', $weight = 0, $langcode = NULL) {
  $build = array();
  $entities_by_view_mode = entity_view_mode_prepare('entity_gallery', $entity_galleries, $view_mode, $langcode);
  foreach ($entities_by_view_mode as $entity_view_mode => $entities) {
    field_attach_prepare_view('entity_gallery', $entities, $entity_view_mode, $langcode);
    entity_prepare_view('entity_gallery', $entities, $langcode);

    foreach ($entities as $entity) {
      $build['entity_galleries'][$entity->egid] = entity_gallery_view($entity, $entity_view_mode, $langcode);
    }
  }

  foreach ($entity_galleries as $entity_gallery) {
    $build['entity_galleries'][$entity_gallery->egid]['#weight'] = $weight;
    $weight++;
  }

  // Sort here, to preserve the input order of the entities that were passed to
  // this function.
  uasort($build['entity_galleries'], 'element_sort');
  $build['entity_galleries']['#sorted'] = TRUE;

  return $build;
}

/**
 * Menu callback: Displays a single entity gallery.
 *
 * @param $entity_gallery
 *   The entity gallery object.
 *
 * @return
 *   A page array suitable for use by drupal_render().
 *
 * @see entity_gallery_menu()
 */
function entity_gallery_page_view($entity_gallery) {
  // If there is a menu link to this entity gallery, the link becomes the last
  // part of the active trail, and the link name becomes the page title.
  // Thus, we must explicitly set the page title to be the entity gallery title.
  drupal_set_title($entity_gallery->title);
  $uri = entity_uri('entity_gallery', $entity_gallery);
  // Set the entity gallery path as the canonical URL to prevent duplicate content.
  drupal_add_html_head_link(array('rel' => 'canonical', 'href' => url($uri['path'], $uri['options'])), TRUE);
  // Set the non-aliased path as a default shortlink.
  drupal_add_html_head_link(array('rel' => 'shortlink', 'href' => url($uri['path'], array_merge($uri['options'], array('alias' => TRUE)))), TRUE);
  return entity_gallery_show($entity_gallery);
}

/**
 * Implements hook_update_index().
 */
function entity_gallery_update_index() {
  $limit = (int)variable_get('search_cron_limit', 100);

  $result = db_query_range("SELECT eg.egid FROM {entity_gallery} eg LEFT JOIN {search_dataset} d ON d.type = 'entity_gallery' AND d.sid = eg.egid WHERE d.sid IS NULL OR d.reindex <> 0 ORDER BY d.reindex ASC, eg.egid ASC", 0, $limit, array(), array('target' => 'slave'));

  foreach ($result as $entity_gallery) {
    _entity_gallery_index_entity_gallery($entity_gallery);
  }
}

/**
 * Indexes a single entity gallery.
 *
 * @param $entity_gallery
 *   The entity gallery to index.
 */
function _entity_gallery_index_entity_gallery($entity_gallery) {
  $entity_gallery = entity_gallery_load($entity_gallery->egid);

  // Save the changed time of the most recent indexed entity gallery, for the
  // search results half-life calculation.
  variable_set('entity_gallery_cron_last', $entity_gallery->changed);

  // Render the entity gallery.
  $build = entity_gallery_view($entity_gallery, 'search_index');
  unset($build['#theme']);
  $entity_gallery->rendered = drupal_render($build);

  $text = '<h1>' . check_plain($entity_gallery->title) . '</h1>' . $entity_gallery->rendered;

  // Fetch extra data normally not visible
  $extra = module_invoke_all('entity_gallery_update_index', $entity_gallery);
  foreach ($extra as $t) {
    $text .= $t;
  }

  // Update index
  search_index($entity_gallery->egid, 'entity_gallery', $text);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function entity_gallery_form_search_form_alter(&$form, $form_state) {
  if (isset($form['module']) && $form['module']['#value'] == 'entity_gallery' && user_access('use advanced search')) {
    // Keyword boxes:
    $form['advanced'] = array(
      '#type' => 'fieldset',
      '#title' => t('Advanced search'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#attributes' => array('class' => array('search-advanced')),
    );
    $form['advanced']['keywords'] = array(
      '#prefix' => '<div class="criterion">',
      '#suffix' => '</div>',
    );
    $form['advanced']['keywords']['or'] = array(
      '#type' => 'textfield',
      '#title' => t('Containing any of the words'),
      '#size' => 30,
      '#maxlength' => 255,
    );
    $form['advanced']['keywords']['phrase'] = array(
      '#type' => 'textfield',
      '#title' => t('Containing the phrase'),
      '#size' => 30,
      '#maxlength' => 255,
    );
    $form['advanced']['keywords']['negative'] = array(
      '#type' => 'textfield',
      '#title' => t('Containing none of the words'),
      '#size' => 30,
      '#maxlength' => 255,
    );

    // Entity gallery types:
    $types = array_map('check_plain', entity_gallery_type_get_names());
    $form['advanced']['type'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Only of the type(s)'),
      '#prefix' => '<div class="criterion">',
      '#suffix' => '</div>',
      '#options' => $types,
    );
    $form['advanced']['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Advanced search'),
      '#prefix' => '<div class="action">',
      '#suffix' => '</div>',
      '#weight' => 100,
    );

    // Languages:
    $language_options = array();
    foreach (language_list('language') as $key => $entity) {
      if ($entity->enabled) {
        $language_options[$key] = $entity->name;
      }
    }
    if (count($language_options) > 1) {
      $form['advanced']['language'] = array(
        '#type' => 'checkboxes',
        '#title' => t('Languages'),
        '#prefix' => '<div class="criterion">',
        '#suffix' => '</div>',
        '#options' => $language_options,
      );
    }

    $form['#validate'][] = 'entity_gallery_search_validate';
  }
}

/**
 * Form validation handler for entity_gallery_form_alter().
 */
function entity_gallery_search_validate($form, &$form_state) {
  // Initialize using any existing basic search keywords.
  $keys = $form_state['values']['processed_keys'];

  // Insert extra restrictions into the search keywords string.
  if (isset($form_state['values']['type']) && is_array($form_state['values']['type'])) {
    // Retrieve selected types - Form API sets the value of unselected
    // checkboxes to 0.
    $form_state['values']['type'] = array_filter($form_state['values']['type']);
    if (count($form_state['values']['type'])) {
      $keys = search_expression_insert($keys, 'type', implode(',', array_keys($form_state['values']['type'])));
    }
  }

  if (isset($form_state['values']['term']) && is_array($form_state['values']['term']) && count($form_state['values']['term'])) {
    $keys = search_expression_insert($keys, 'term', implode(',', $form_state['values']['term']));
  }
  if (isset($form_state['values']['language']) && is_array($form_state['values']['language'])) {
    $languages = array_filter($form_state['values']['language']);
    if (count($languages)) {
      $keys = search_expression_insert($keys, 'language', implode(',', $languages));
    }
  }
  if ($form_state['values']['or'] != '') {
    if (preg_match_all('/ ("[^"]+"|[^" ]+)/i', ' ' . $form_state['values']['or'], $matches)) {
      $keys .= ' ' . implode(' OR ', $matches[1]);
    }
  }
  if ($form_state['values']['negative'] != '') {
    if (preg_match_all('/ ("[^"]+"|[^" ]+)/i', ' ' . $form_state['values']['negative'], $matches)) {
      $keys .= ' -' . implode(' -', $matches[1]);
    }
  }
  if ($form_state['values']['phrase'] != '') {
    $keys .= ' "' . str_replace('"', ' ', $form_state['values']['phrase']) . '"';
  }
  if (!empty($keys)) {
    form_set_value($form['basic']['processed_keys'], trim($keys), $form_state);
  }
}

/**
 * @defgroup entity_gallery_access Entity gallery access rights
 * @{
 * The entity gallery access system determines who can do what to which entity
 * galleries.
 *
 * In determining access rights for an entity gallery, entity_gallery_access()
 * first checks whether the user has the "bypass gallery access" permission.
 * Such users have unrestricted access to all entity galleries. user 1 will
 * always pass this check.
 *
 * Next, all implementations of hook_entity_gallery_access() will be called. Each
 * implementation may explicitly allow, explicitly deny, or ignore the access
 * request. If at least one module says to deny the request, it will be rejected.
 * If no modules deny the request and at least one says to allow it, the request
 * will be permitted.
 *
 * In entity gallery listings (lists of entity galleries generated from a select
 * query), the process above is followed except that
 * hook_entity_gallery_access() is not called on each entity gallery for
 * performance reasons and for proper functioning of the pager system. When
 * adding an entity gallery listing to your module, be sure to use a dynamic
 * query created by db_select() and add a tag of "entity_gallery_access". This
 * will allow modules dealing with entity gallery access to ensure only entity
 * galleries to which the user has access are retrieved, through the use of
 * hook_query_TAG_alter().
 *
 * Note: Even a single module returning ENTITY_GALLERY_ACCESS_DENY from
 * hook_entity_gallery_access() will block access to the entity gallery.
 * Therefore, implementers should take care to not deny access unless they
 * really intend to. Unless a module wishes to actively deny access it should
 * return ENTITY_GALLERY_ACCESS_IGNORE (or simply return nothing) to allow other
 * modules to control access.
 *
 * To see how to write an entity gallery access module of your own, see
 * entity_gallery_access_example.module.
 */

/**
 * Determines whether the current user may perform the operation on the entity gallery.
 *
 * @param $op
 *   The operation to be performed on the entity gallery. Possible values are:
 *   - "view"
 *   - "update"
 *   - "delete"
 *   - "create"
 * @param $entity_gallery
 *   The entity gallery object on which the operation is to be performed, or
 *   entity gallery type (e.g. 'file') for "create" operation.
 * @param $account
 *   Optional, a user object representing the user for whom the operation is to
 *   be performed. Determines access for a user other than the current user.
 *
 * @return
 *   TRUE if the operation may be performed, FALSE otherwise.
 */
function entity_gallery_access($op, $entity_gallery, $account = NULL) {
  $rights = &drupal_static(__FUNCTION__, array());

  if (!$entity_gallery || !in_array($op, array('view', 'update', 'delete', 'create'), TRUE)) {
    // If there was no entity gallery to check against, or the $op was not one
    // of the supported ones, we return access denied.
    return FALSE;
  }
  // If no user object is supplied, the access check is for the current user.
  if (empty($account)) {
    $account = $GLOBALS['user'];
  }

  // $entity_gallery may be either an object or an entity gallery type. Since
  // entity gallery types cannot be an integer, use either egid or type as the
  // static cache id.

  $cid = is_object($entity_gallery) ? $entity_gallery->egid : $entity_gallery;

  // If we've already checked access for this entity gallery, user and op,
  // return from cache.
  if (isset($rights[$account->uid][$cid][$op])) {
    return $rights[$account->uid][$cid][$op];
  }

  if (user_access('bypass entity gallery access', $account)) {
    $rights[$account->uid][$cid][$op] = TRUE;
    return TRUE;
  }
  if (!user_access('access entity galleries', $account)) {
    $rights[$account->uid][$cid][$op] = FALSE;
    return FALSE;
  }

  // We grant access to the entity gallery if both of the following conditions
  // are met:
  // - No modules say to deny access.
  // - At least one module says to grant access.
  $access = module_invoke_all('entity_gallery_access', $entity_gallery, $op, $account);
  if (in_array(ENTITY_GALLERY_ACCESS_DENY, $access, TRUE)) {
    $rights[$account->uid][$cid][$op] = FALSE;
    return FALSE;
  }
  elseif (in_array(ENTITY_GALLERY_ACCESS_ALLOW, $access, TRUE)) {
    $rights[$account->uid][$cid][$op] = TRUE;
    return TRUE;
  }

  // Check if authors can view their own unpublished entity galleries.
  if ($op == 'view' && !$entity_gallery->status && user_access('view own unpublished entity galleries', $account) && $account->uid == $entity_gallery->uid && $account->uid != 0) {
    $rights[$account->uid][$cid][$op] = TRUE;
    return TRUE;
  }

  // The default behavior is to allow all users to view published entity
  // galleries, so reflect that here.
  if ($op != 'create' && $entity_gallery->egid) {
    if (is_object($entity_gallery) && $op == 'view' && $entity_gallery->status) {
      $rights[$account->uid][$cid][$op] = TRUE;
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Implements hook_entity_gallery_access().
 */
function entity_gallery_entity_gallery_access($entity_gallery, $op, $account) {
  $type = is_string($entity_gallery) ? $entity_gallery : $entity_gallery->type;

  if (in_array($type, entity_gallery_permissions_get_configured_types())) {
    if ($op == 'create' && user_access('create ' . $type . ' entity gallery', $account)) {
      return ENTITY_GALLERY_ACCESS_ALLOW;
    }

    if ($op == 'update') {
      if (user_access('edit any ' . $type . ' entity gallery', $account) || (user_access('edit own ' . $type . ' entity gallery', $account) && ($account->uid == $entity_gallery->uid))) {
        return ENTITY_GALLERY_ACCESS_ALLOW;
      }
    }

    if ($op == 'delete') {
      if (user_access('delete any ' . $type . ' entity gallery', $account) || (user_access('delete own ' . $type . ' entity gallery', $account) && ($account->uid == $entity_gallery->uid))) {
        return ENTITY_GALLERY_ACCESS_ALLOW;
      }
    }
  }

  return ENTITY_GALLERY_ACCESS_IGNORE;
}

/**
 * Helper function to generate standard entity gallery permission list for a
 * given type.
 *
 * @param $type
 *   The machine-readable name of the entity gallery type.
 *
 * @return array
 *   An array of permission names and descriptions.
 */
function entity_gallery_list_permissions($type) {
  $info = entity_gallery_type_get_type($type);

  // Build standard list of entity gallery permissions for this type.
  $perms = array(
    "create $type entity gallery" => array(
      'title' => t('%type_name: Create new gallery', array('%type_name' => $info->name)),
    ),
    "edit own $type entity gallery" => array(
      'title' => t('%type_name: Edit own gallery', array('%type_name' => $info->name)),
    ),
    "edit any $type entity gallery" => array(
      'title' => t('%type_name: Edit any gallery', array('%type_name' => $info->name)),
    ),
    "delete own $type entity gallery" => array(
      'title' => t('%type_name: Delete own gallery', array('%type_name' => $info->name)),
    ),
    "delete any $type entity gallery" => array(
      'title' => t('%type_name: Delete any gallery', array('%type_name' => $info->name)),
    ),
  );

  return $perms;
}

/**
 * Returns an array of entity gallery types that should be managed by
 * permissions.
 *
 * By default, this will include all entity gallery types in the system. To
 * exclude a specific entity gallery from getting permissions defined for it,
 * set the entity_gallery_permissions_$type variable to 0. Core does not provide
 * an interface for doing so. However, contrib modules may exclude their own
 * entity galleries in hook_install(). Alternatively, contrib modules may
 * configure all entity gallery types at once, or decide to apply some other
 * hook_entity_gallery_access() implementation to some or all entity gallery
 * types.
 *
 * @return
 *   An array of entity gallery types managed by this module.
 */
function entity_gallery_permissions_get_configured_types() {

  $configured_types = array();

  foreach (entity_gallery_type_get_types() as $type => $info) {
    if (variable_get('entity_gallery_permissions_' . $type, 1)) {
      $configured_types[] = $type;
    }
  }

  return $configured_types;
}

/**
 * @defgroup entity_gallery_content Hook implementations for user-created gallery types
 * @{
 * Functions that implement hooks for user-created gallery types.
 */

/**
 * Implements hook_form().
 */
function entity_gallery_content_form($entity_gallery, $form_state) {
  // It is impossible to define a gallery type without implementing hook_form()
  // @todo: remove this requirement.
  $form = array();
  $type = entity_gallery_type_get_type($entity_gallery);

  if ($type->has_title) {
    $form['title'] = array(
      '#type' => 'textfield',
      '#title' => check_plain($type->title_label),
      '#required' => TRUE,
      '#default_value' => $entity_gallery->title,
      '#maxlength' => 255,
      '#weight' => -5,
    );
  }

  return $form;
}

/**
 * @} End of "defgroup entity_gallery_content".
 */

/**
 * Implements hook_forms().
 *
 * All entity gallery forms share the same form handler.
 */
function entity_gallery_forms() {
  $forms = array();
  if ($types = entity_gallery_type_get_types()) {
    foreach (array_keys($types) as $type) {
      $forms[$type . '_entity_gallery_form']['callback'] = 'entity_gallery_form';
    }
  }
  return $forms;
}

/**
 * Implements hook_action_info().
 */
function entity_gallery_action_info() {
  $info['entity_gallery_publish_action'] = array(
    'type' => 'entity_gallery',
    'label' => t('Publish gallery'),
    'configurable' => FALSE,
    'behavior' => array('changes_property'),
    'triggers' => array('entity_gallery_presave'),
  );
  $info['entity_gallery_unpublish_action'] = array(
    'type' => 'entity_gallery',
    'label' => t('Unpublish gallery'),
    'configurable' => FALSE,
    'behavior' => array('changes_property'),
    'triggers' => array('entity_gallery_presave'),
  );
  $info['entity_gallery_make_sticky_action'] = array(
    'type' => 'entity_gallery',
    'label' => t('Make gallery sticky'),
    'configurable' => FALSE,
    'behavior' => array('changes_property'),
    'triggers' => array('entity_gallery_presave'),
  );
  $info['entity_gallery_make_unsticky_action'] = array(
    'type' => 'entity_gallery',
    'label' => t('Make gallery unsticky'),
    'configurable' => FALSE,
    'behavior' => array('changes_property'),
    'triggers' => array('entity_gallery_presave'),
  );
  $info['entity_gallery_assign_owner_action'] = array(
    'type' => 'entity_gallery',
    'label' => t('Change the author of gallery'),
    'configurable' => TRUE,
    'behavior' => array('changes_property'),
    'triggers' => array('entity_gallery_presave'),
  );
  $info['entity_gallery_unpublish_by_keyword_action'] = array(
    'type' => 'entity_gallery',
    'label' => t('Unpublish gallery containing keyword(s)'),
    'configurable' => TRUE,
    'triggers' => array('entity_gallery_presave', 'entity_gallery_insert', 'entity_gallery_update'),
  );

  if (module_exists('pathauto')) {
    $info['pathauto_entity_gallery_update_action'] = array(
      'type' => 'entity_gallery',
      'label' => t('Update entity gallery alias'),
      'configurable' => FALSE,
    );
  }
}

/**
 * Sets the status of an entity gallery to 1 (published).
 *
 * @param $entity_gallery
 *   An entity gallery object.
 * @param $context
 *   (optional) Array of additional information about what triggered the action.
 *   Not used for this action.
 *
 * @ingroup actions
 */
function entity_gallery_publish_action($entity_gallery, $context = array()) {
  $entity_gallery->status = ENTITY_GALLERY_PUBLISHED;
  watchdog('action', 'Set @type %title to published.', array('@type' => entity_gallery_type_get_name($entity_gallery), '%title' => $entity_gallery->title));
}

/**
 * Sets the status of an entity gallery to 0 (unpublished).
 *
 * @param $entity_gallery
 *   An entity gallery object.
 * @param $context
 *   (optional) Array of additional information about what triggered the action.
 *   Not used for this action.
 *
 * @ingroup actions
 */
function entity_gallery_unpublish_action($entity_gallery, $context = array()) {
  $entity_gallery->status = ENTITY_GALLERY_NOT_PUBLISHED;
  watchdog('action', 'Set @type %title to unpublished.', array('@type' => entity_gallery_type_get_name($entity_gallery), '%title' => $entity_gallery->title));
}

/**
 * Sets the sticky-at-top-of-list property of an entity gallery to 1.
 *
 * @param $entity_gallery
 *   An entity gallery object.
 * @param $context
 *   (optional) Array of additional information about what triggered the action.
 *   Not used for this action.
 *
 * @ingroup actions
 */
function entity_gallery_make_sticky_action($entity_gallery, $context = array()) {
  $entity_gallery->sticky = ENTITY_GALLERY_STICKY;
  watchdog('action', 'Set @type %title to sticky.', array('@type' => entity_gallery_type_get_name($entity_gallery), '%title' => $entity_gallery->title));
}

/**
 * Sets the sticky-at-top-of-list property of an entity gallery to 0.
 *
 * @param $entity_gallery
 *   An entity gallery object.
 * @param $context
 *   (optional) Array of additional information about what triggered the action.
 *   Not used for this action.
 *
 * @ingroup actions
 */
function entity_gallery_make_unsticky_action($entity_gallery, $context = array()) {
  $entity_gallery->sticky = ENTITY_GALLERY_NOT_STICKY;
  watchdog('action', 'Set @type %title to unsticky.', array('@type' => entity_gallery_type_get_name($entity_gallery), '%title' => $entity_gallery->title));
}

/**
 * Saves an entity gallery.
 *
 * @param $entity_gallery
 *   The entity gallery to be saved.
 *
 * @ingroup actions
 */
function entity_gallery_save_action($entity_gallery) {
  entity_gallery_save($entity_gallery);
  watchdog('action', 'Saved @type %title', array('@type' => entity_gallery_type_get_name($entity_gallery), '%title' => $entity_gallery->title));
}

/**
 * Assigns ownership of an entity gallery to a user.
 *
 * @param $entity_gallery
 *   An entity gallery object to modify.
 * @param $context
 *   Array with the following elements:
 *   - 'owner_uid': User ID to assign to the entity gallery.
 *
 * @see entity_gallery_assign_owner_action_form()
 * @see entity_gallery_assign_owner_action_validate()
 * @see entity_gallery_assign_owner_action_submit()
 * @ingroup actions
 */
function entity_gallery_assign_owner_action($entity_gallery, $context) {
  $entity_gallery->uid = $context['owner_uid'];
  $owner_name = db_query("SELECT name FROM {users} WHERE uid = :uid", array(':uid' => $context['owner_uid']))->fetchField();
  watchdog('action', 'Changed owner of @type %title to uid %name.', array('@type' =>  entity_gallery_type_get_name($entity_gallery), '%title' => $entity_gallery->title, '%name' => $owner_name));
}

/**
 * Generates the settings form for entity_gallery_assign_owner_action().
 *
 * @param $context
 *   Array of additional information about what triggered the action. Includes
 *   the following elements:
 *   - 'owner_uid': User ID to assign to the entity gallery.
 *
 * @see entity_gallery_assign_owner_action_submit()
 * @see entity_gallery_assign_owner_action_validate()
 *
 * @ingroup forms
 */
function entity_gallery_assign_owner_action_form($context) {
  $description = t('The username of the user to which you would like to assign ownership.');
  $count = db_query("SELECT COUNT(*) FROM {users}")->fetchField();
  $owner_name = '';
  if (isset($context['owner_uid'])) {
    $owner_name = db_query("SELECT name FROM {users} WHERE uid = :uid", array(':uid' => $context['owner_uid']))->fetchField();
  }

  // Use dropdown for fewer than 200 users; textbox for more than that.
  if (intval($count) < 200) {
    $options = array();
    $result = db_query("SELECT uid, name FROM {users} WHERE uid > 0 ORDER BY name");
    foreach ($result as $data) {
      $options[$data->name] = $data->name;
    }
    $form['owner_name'] = array(
      '#type' => 'select',
      '#title' => t('Username'),
      '#default_value' => $owner_name,
      '#options' => $options,
      '#description' => $description,
    );
  }
  else {
    $form['owner_name'] = array(
      '#type' => 'textfield',
      '#title' => t('Username'),
      '#default_value' => $owner_name,
      '#autocomplete_path' => 'user/autocomplete',
      '#size' => '6',
      '#maxlength' => '60',
      '#description' => $description,
    );
  }
  return $form;
}

/**
 * Validates settings form for entity_gallery_assign_owner_action().
 *
 * @see entity_gallery_assign_owner_action_submit()
 */
function entity_gallery_assign_owner_action_validate($form, $form_state) {
  $exists = (bool) db_query_range('SELECT 1 FROM {users} WHERE name = :name', 0, 1, array(':name' => $form_state['values']['owner_name']))->fetchField();
  if (!$exists) {
    form_set_error('owner_name', t('Enter a valid username.'));
  }
}

/**
 * Saves settings form for entity_gallery_assign_owner_action().
 *
 * @see entity_gallery_assign_owner_action_validate()
 */
function entity_gallery_assign_owner_action_submit($form, $form_state) {
  // Username can change, so we need to store the ID, not the username.
  $uid = db_query('SELECT uid from {users} WHERE name = :name', array(':name' => $form_state['values']['owner_name']))->fetchField();
  return array('owner_uid' => $uid);
}

/**
 * Generates settings form for entity_gallery_unpublish_by_keyword_action().
 *
 * @param array $context
 *   Array of additional information about what triggered this action.
 *
 * @return array
 *   A form array.
 *
 * @see entity_gallery_unpublish_by_keyword_action_submit()
 */
function entity_gallery_unpublish_by_keyword_action_form($context) {
  $form['keywords'] = array(
    '#title' => t('Keywords'),
    '#type' => 'textarea',
    '#description' => t('The gallery will be unpublished if it contains any of the phrases above. Use a case-sensitive, comma-separated list of phrases. Example: funny, bungee jumping, "Company, Inc."'),
    '#default_value' => isset($context['keywords']) ? drupal_implode_tags($context['keywords']) : '',
  );
  return $form;
}

/**
 * Saves settings form for entity_gallery_unpublish_by_keyword_action().
 */
function entity_gallery_unpublish_by_keyword_action_submit($form, $form_state) {
  return array('keywords' => drupal_explode_tags($form_state['values']['keywords']));
}

/**
 * Unpublishes an entity gallery containing certain keywords.
 *
 * @param $entity_gallery
 *   An entity gallery object to modify.
 * @param $context
 *   Array with the following elements:
 *   - 'keywords': Array of keywords. If any keyword is present in the rendered
 *     entity gallery, the entity gallery's status flag is set to unpublished.
 *
 * @ingroup actions
 */
function entity_gallery_unpublish_by_keyword_action($entity_gallery, $context) {
  foreach ($context['keywords'] as $keyword) {
    $elements = entity_gallery_view(clone $entity_gallery);
    if (strpos(drupal_render($elements), $keyword) !== FALSE || strpos($entity_gallery->title, $keyword) !== FALSE) {
      $entity_gallery->status = ENTITY_GALLERY_NOT_PUBLISHED;
      watchdog('action', 'Set @type %title to unpublished.', array('@type' => entity_gallery_type_get_name($entity_gallery), '%title' => $entity_gallery->title));
      break;
    }
  }
}

/**
 * Controller class for entity galleries.
 *
 * This extends the DrupalDefaultEntityController class, adding required
 * special handling for entity gallery objects.
 */
class EntityGalleryController extends DrupalDefaultEntityController {

  protected function attachLoad(&$entity_galleries, $revision_id = FALSE) {
    // Create an array of entity galleries for each gallery type and pass this
    // to the object type specific callback.
    $typed_entity_galleries = array();
    foreach ($entity_galleries as $id => $entity) {
      $typed_entity_galleries[$entity->type][$id] = $entity;
    }

    // Call object type specific callbacks on each typed array of entity
    // galleries.
    foreach ($typed_entity_galleries as $entity_gallery_type => $entity_galleries_of_type) {
      if (entity_gallery_hook($entity_gallery_type, 'load')) {
        $function = entity_gallery_type_get_base($entity_gallery_type) . '_load';
        $function($entity_galleries_of_type);
      }
    }
    // Besides the list of entity galleries, pass one additional argument to
    // hook_entity_gallery_load(), containing a list of entity gallery types
    // that were loaded.
    $argument = array_keys($typed_entity_galleries);
    $this->hookLoadArguments = array($argument);
    parent::attachLoad($entity_galleries, $revision_id);
  }

  protected function buildQuery($ids, $conditions = array(), $revision_id = FALSE) {
    // Ensure that uid is taken from the {entity_gallery} table,
    // alias timestamp to revision_timestamp and add revision_uid.
    $query = parent::buildQuery($ids, $conditions, $revision_id);
    $fields =& $query->getFields();
    unset($fields['timestamp']);
    $query->addField('revision', 'timestamp', 'revision_timestamp');
    $fields['uid']['table'] = 'base';
    $query->addField('revision', 'uid', 'revision_uid');
    return $query;
  }
}

/**
 * Implements hook_file_download_access().
 */
function entity_gallery_file_download_access($field, $entity_type, $entity) {
  if ($entity_type == 'entity_gallery') {
    return entity_gallery_access('view', $entity);
  }
}

/**
 * Implements hook_entity_gallery_load() on behalf of user.module.
 */
function user_entity_gallery_load($entity_galleries, $types) {
  // Build an array of all uids for entity gallery authors, keyed by egid.
  $uids = array();
  foreach ($entity_galleries as $egid => $entity_gallery) {
    $uids[$egid] = $entity_gallery->uid;
  }

  // Fetch name, picture, and data for these users.
  $user_fields = db_query("SELECT uid, name, picture, data FROM {users} WHERE uid IN (:uids)", array(':uids' => $uids))->fetchAllAssoc('uid');

  // Add these values back into the entity gallery objects.
  foreach ($uids as $egid => $uid) {
    $entity_galleries[$egid]->name = $user_fields[$uid]->name;
    $entity_galleries[$egid]->picture = $user_fields[$uid]->picture;
    $entity_galleries[$egid]->data = $user_fields[$uid]->data;
  }
}

/**
 * Display the list of available entity gallery types for entity gallery creation.
 */
function seven_entity_gallery_add_list($variables) {
  $content = $variables['content'];
  $output = '';
  if ($content) {
    $output = '<ul class="admin-list">';
    foreach ($content as $item) {
      $output .= '<li class="clearfix">';
      $output .= '<span class="label">' . l($item['title'], $item['href'], $item['localized_options']) . '</span>';
      $output .= '<div class="description">' . filter_xss_admin($item['description']) . '</div>';
      $output .= '</li>';
    }
    $output .= '</ul>';
  }
  else {
    $output = '<p>' . t('You have not created any gallery types yet. Go to the <a href="@create-gallery">gallery type creation page</a> to add a new gallery type.', array('@create-gallery' => url('admin/structure/gallery-types/add'))) . '</p>';
  }
  return $output;
}

/**
 * Implements hook_preprocess_entity_gallery() on behalf of views.module.
 *
 * A theme preprocess function to automatically allow view-based entity gallery
 * templates if called from a view.
 *
 * The 'views/entity_gallery.views.inc' file is a better place for this, but
 * we haven't got a chance to load that file before Drupal builds the
 * entity gallery portion of the theme registry.
 */
function views_preprocess_entity_gallery(&$vars) {
  // The 'view' attribute of the entity gallery is added in
  // views_preprocess_entity_gallery().
  if (!empty($vars['entity_gallery']->view) && !empty($vars['entity_gallery']->view->name)) {
    $vars['view'] = $vars['entity_gallery']->view;
    $vars['theme_hook_suggestions'][] = 'entity_gallery__view__' . $vars['entity_gallery']->view->name;
    if (!empty($vars['entity_gallery']->view->current_display)) {
      $vars['theme_hook_suggestions'][] = 'entity_gallery__view__' . $vars['entity_gallery']->view->name . '__' . $vars['entity_gallery']->view->current_display;

      // If an entity gallery is being rendered in a view, and the view does not
      // have a path, prevent drupal from accidentally setting the $page
      // variable:
      if ($vars['page'] && $vars['view_mode'] == 'full' && !$vars['view']->display_handler->has_path()) {
        $vars['page'] = FALSE;
      }
    }
  }

  // Allow to alter links based on the settings in the row plugin.
  if (!empty($vars['view']->style_plugin->row_plugin) && get_class($vars['view']->style_plugin->row_plugin) == 'views_plugin_row_entity_gallery_view') {
    entity_gallery_row_entity_gallery_view_preprocess_entity_gallery($vars);
  }
}

/**
 * Implements hook_views_api().
 */
function entity_gallery_views_api() {
  return array(
    'api' => '3.0',
  );
}

/**
 * Implements hook_ctools_plugin_directory().
 *
 * Views UI provides wizard plugins on behalf of entity gallery base tables.
 */
function entity_gallery_ctools_plugin_directory($module, $plugin) {
  if ($module == 'views_ui' && $plugin == 'views_wizard') {
    return 'plugins/' . $plugin;
  }
}
