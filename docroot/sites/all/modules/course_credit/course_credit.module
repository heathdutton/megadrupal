<?php

/**
 * @file course_credit.module
 * Main course credit file.
 */

/**
 * Implements hook_menu().
 */
function course_credit_menu() {
  $items = array();

  $items['admin/course/credit'] = array(
    'title' => 'Credit',
    'description' => 'Configure course credit.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('course_credit_settings_form'),
    'access arguments' => array('administer course credit'),
  );

  $items['admin/course/credit/settings'] = array(
    'title' => 'Settings',
    'description' => 'Configure course credit.',
    'access arguments' => array('administer course credit'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -1,
  );

  $items['admin/course/credit/types/list'] = array(
    'title' => 'Credit types',
    'description' => 'Manage credit types.',
    'access arguments' => array('administer course credit'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/course/credit/types'] = array(
    'title' => 'Credit types',
    'description' => 'Manage credit types.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('course_credit_types_form'),
    'access arguments' => array('administer course credit'),
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/course/credit/types/%/map'] = array(
    'title' => 'Credit Map',
    'access arguments' => array('administer course credit'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('course_credit_type_map_form', 4),
  );

  $items += rules_ui()->config_menu('admin/course/credit/types');

  $items['admin/course/credit/types/%/delete'] = array(
    'title' => 'Delete credit type',
    'access arguments' => array('administer course credit'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('course_credit_type_delete_form', 4),
  );

  $items['admin/course/credit/types/add-type'] = array(
    'title' => 'Add type',
    'access arguments' => array('administer course credit'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('course_credit_type_add_form'),
    'type' => MENU_LOCAL_ACTION,
  );

  // FAPI form.
  $items['node/%course/course-credit-app'] = array(
    'title' => 'Claim credit',
    'access callback' => 'course_credit_can_apply_access',
    'access arguments' => array(1),
    'page callback' => 'course_credit_form_router',
    'page arguments' => array(1),
    'type' => MENU_LOCAL_ACTION,
  );

  return $items;
}

/**
 * Implements hook_course_handlers().
 */
function course_credit_course_handlers() {
  //$settings = 'includes/course_credit.settings.inc';
  return array(
    'object' => array(
      'credit' => array(
        'name' => t('Credit'),
        'class' => 'CourseObjectCredit',
        'description' => t('A credit course object.'),
      ),
    ),
  );
}

/**
 * Display the credit form, with configured options, for submission within the
 * course workflow.
 *
 * @global object $user
 *   The user taking the course.
 *
 * @param object $node
 *   The course node.
 *
 * @return array
 *   The appropriate credit form.
 */
function course_credit_form_router($node) {
  global $user;

  if (course_credit_must_claim($node, $user)) {
    // User has not yet claimed variable credit though they are eligible for it.
    return drupal_get_form('course_credit_app_form', $node);
  }

  if (!$awarded = course_credit_get_credit_awarded($node->nid, $user->uid)) {

    course_credit_award_credit($node, $user);
  }

  drupal_goto("node/{$node->nid}/course-complete");
}

/**
 * Check if the user is eligible for variable credit and has not yet claimed it.
 *
 * @return bool
 */
function course_credit_must_claim($node, $account) {
  if (variable_get('course_credit_skip_no_claim', 1)) {
    // Skipping claim, but check for variable credit.
    $etypes = course_credit_user_credit_types($node, $account);
    foreach ($etypes as $etype) {
      if ($etype->enable_variable_credit) {
        $awarded = course_credit_get_credit_awarded($node->nid, $account->uid);
        // Found active credit claiming. Show form.
        if (!isset($awarded[$etype->type])) {
          return TRUE;
        }
      }
    }
    return FALSE;
  }
  return TRUE;
}

/**
 * Implements hook_theme().
 */
function course_credit_theme() {
  return array(
    'course_credit_app_form' => array(
      'render element' => 'form',
    ),
    'course_credit_types_form' => array(
      'render element' => 'form',
    ),
    'course_credit' => array(
      'variables' => NULL,
    ),
    'course_credit_awarded' => array(
      'variables' => NULL,
    ),
  );
}

/**
 * Implements hook_field_extra_fields().
 */
function course_credit_field_extra_fields() {
  $extra = array();
  foreach (entity_get_info() as $entity_type => $entity_info) {
    foreach (array_keys($entity_info['bundles']) as $bundle) {
      if (in_array($bundle, course_get_types())) {
        $extra[$entity_type][$bundle]['form']['course_credit'] = array(
          'label' => t('Course credit'),
          'description' => t('Course credit form elements.'),
          'weight' => 0,
        );
        $extra[$entity_type][$bundle]['display']['course_credit'] = array(
          'label' => t('Course credit'),
          'weight' => 0,
        );
      }
    }
  }
  return $extra;
}

/**
 * Implements hook_field_attach_form().
 */
function course_credit_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode) {
  if (course_credit_node_is_creditable($entity)) {
    $node = $entity;

    // @see ctools/includes/dependent.inc.
    if (module_exists('ctools')) {
      ctools_include('dependent');
    }

    // Get credit types.
    $types = course_credit_get_credit_types();

    if (empty($types)) {
      $fieldset_desc = t('Please !configure before adding credit to an activity.', array(
        '!configure' => l('configure credit types', 'admin/course/credit'),
      ));
    }
    else {
      $fieldset_desc = t('Set the credit settings for this course.');
    }

    $form['course_credit'] = array(
      '#type' => 'fieldset',
      '#title' => t('Course credit settings'),
      '#collapsible' => TRUE,
      '#description' => $fieldset_desc,
      '#tree' => TRUE,
    );

    // Loop through credit types.
    foreach ($types as $type) {
      // After a preview or form reload, the course credit types must be
      // converted to objects. This is because because during preview, the
      // object in $form['#node'] isn't a real node, but a converted form array.
      // @see merlinofchaos http://drupal.org/node/443176#comment-1551972
      // @see taxonomy_preview_terms()
      if (isset($node->preview)) {
        // Typecast $node->course_credit back to an array of objects.
        $node->course_credit[$type->type] = (object) $node->course_credit[$type->type];
      }

      // Check fields where we process the default_value loaded from the
      // database, so we don't re-process it.
      $default_values = array();
      $expiration_date = isset($node->course_credit[$type->type]) ? $node->course_credit[$type->type]->expiration_date : NULL;
      $expiration_offset = isset($node->course_credit[$type->type]) ? $node->course_credit[$type->type]->expiration_offset : NULL;
      if (isset($node->preview)) {
        // On preview, output the form_state values without processing.
        $default_values['expiration_date'] = $expiration_date ? $expiration_date : '';
        $default_values['expiration_offset'] = $expiration_offset ? $expiration_offset : 0;
      }
      else {
        // When not previewing, process the data.
        $default_values['expiration_date'] = $expiration_date ? date('Y-m-d H:i:s', $expiration_date) : '';
        $default_values['expiration_offset'] = $expiration_offset ? ($expiration_offset / 86400) : 0;
      }

      // Create a new fieldset for every credit instance.
      $form['course_credit'][$type->type] = array(
        '#type' => 'fieldset',
        // The credit title may include HTML.
        '#title' => filter_xss_admin($type->title),
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
        '#description' => filter_xss($type->description),
      );

      // Controls display of all settings for this type.
      $form['course_credit'][$type->type]['active'] = array(
        '#title' => t('Active'),
        '#type' => 'checkbox',
      );

      $form['course_credit'][$type->type]['increments'] = array(
        '#title' => t('Increments'),
        '#type' => 'textfield',
        '#size' => 4,
        // Start inline container.
        '#prefix' => '<div class="container-inline">',
      );

      $form['course_credit'][$type->type]['min'] = array(
        '#title' => t('Min'),
        '#type' => 'textfield',
        '#size' => 4,
      );

      $form['course_credit'][$type->type]['max'] = array(
        '#title' => t('Max'),
        '#type' => 'textfield',
        '#size' => 4,
        // End inline container.
        '#suffix' => '</div>',
      );

      // Display if course credit code is enabled.
      if (variable_get('course_credit_code', 1)) {
        $form['course_credit'][$type->type]['code'] = array(
          '#title' => t('Code'),
          '#type' => 'textfield',
          '#size' => 16,
        );
      }

      // Display if variable credit claiming is enabled.
      if (variable_get('course_credit_variable', 1)) {
        $form['course_credit'][$type->type]['enable_variable_credit'] = array(
          '#title' => t('Variable credit'),
          '#type' => 'checkbox',
          '#size' => 16,
        );
      }

      foreach (array('active', 'increments', 'min', 'max', 'code', 'enable_variable_credit') as $field_key) {
        if (isset($node->course_credit[$type->type])) {
          $form['course_credit'][$type->type][$field_key]['#default_value'] = $node->course_credit[$type->type]->$field_key;
        }
      }

      // Display if credit expiration is enabled.
      if (variable_get('course_credit_expiration', 1)) {
        // We don't have drupal_clean_css_identifier() until Drupal 7.
        $credit_type_html = strtr($type->type, '_', '-');

        $expiration_types = array(
          'date' => t('Specify date'),
          'calendar_year' => t('End of year credit awarded'),
          'credit_awarded' => t('Date credit is awarded'),
        );

        // Create another array of all type options except date. We need this so
        // ctools can hide other elements not applicable to date selection.
        $non_date_options = $expiration_types;
        if (isset($non_date_options['date'])) {
          unset($non_date_options['date']);
        }

        // Set common ctools dependency element components, for display on all
        // but the date type.
        $date_independent = array(
          // CTools dependent API compliant.
          '#process' => array('ctools_dependent_process'),
          '#dependency' => array(
            "edit-course-credit-{$credit_type_html}-expiration-type" => array_keys($non_date_options),
          ),
        );
        // Set the reverse, for display only when date type is selected.
        $reverse = array(
          '#dependency' => array(
            "edit-course-credit-{$credit_type_html}-expiration-type" => array('date'),
          ),
        );
        $date_dependent = $reverse + $date_independent;

        // Add 'none' option after dependency settings are in place.
        $expiration_types = array('' => t('None')) + $expiration_types;

        $form['course_credit'][$type->type]['expiration_type'] = array(
          '#title' => t('Expiration type'),
          '#type' => 'select',
          '#options' => $expiration_types,
          '#default_value' => isset($node->course_credit[$type->type]) ? $node->course_credit[$type->type]->expiration_type : NULL,
        );

        // Dependent on date expiration type option.
        $form['course_credit'][$type->type]['expiration_date'] = array(
          '#title' => t('Please specify'),
          '#type' => 'textfield',
          '#size' => 16,
          '#default_value' => $default_values['expiration_date'],
          '#description' => t('For absolute date use Y-m-d.'),
          ) + $date_dependent;
        // Make this a date popup field if available.
        // @see date_popup_elements()
        if (module_exists('date_popup')) {
          $form['course_credit'][$type->type]['expiration_date']['#type'] = 'date_popup';
          $form['course_credit'][$type->type]['expiration_date']['#date_format'] = 'Y-m-d';
          $form['course_credit'][$type->type]['expiration_date']['#date_year_range'] = '-10:+10';
          $form['course_credit'][$type->type]['expiration_date']['#process'][] = 'date_popup_element_process';
          // Date popup adds it's own description.
          $form['course_credit'][$type->type]['expiration_date']['#description'] = NULL;
        }

        // Dependent on non-date expiration type options.
        $form['course_credit'][$type->type]['expiration_offset'] = array(
          '#title' => t('Plus additional days'),
          '#type' => 'textfield',
          '#size' => 16,
          // Convert seconds (from DB) to days (for human readability).
          '#default_value' => $default_values['expiration_offset'],
          '#description' => t('For relative types, optionally specify an offset (in days) from the selected type.'),
          ) + $date_independent;
      }
      // Add settings summary to fieldset title, so it can be quickly scanned
      // when collapsed. Similar to verticaltab summary.
      $summary = course_credit_type_fieldset_summary($type->type, $form, $node);
      if (!empty($summary)) {
        // Append the summary to the fieldset title.
        $form['course_credit'][$type->type]['#title'] .= ' (' . implode(' | ', $summary) . ')';
      }

      // Prefill with global defaults if no values provided.
      if (!isset($node->course_credit[$type->type])) {
        foreach (element_children($form['course_credit'][$type->type]) as $key) {
          if (isset($type->$key)) {
            // Excluding "active", "code", and "expiration" because we have no
            // defaults for those.
            $form['course_credit'][$type->type][$key]['#default_value'] = $type->$key;
          }
        }
      }
    }
  }

  if ($entity_type == 'course_credit_awarded') {
    $types = array();
    foreach (node_type_get_names() as $type => $name) {
      $node->type = $type;
      if (course_credit_node_is_creditable($node)) {
        $types[] = $type;
      }
    }

    $form['nid'] = array(
      '#title' => t('Course'),
      '#type' => 'textfield',
      '#disabled' => TRUE,
    );

    $form['uid'] = array(
      '#title' => t('User'),
      '#type' => 'textfield',
      '#disabled' => TRUE,
    );

    $form['credits'] = array(
      '#title' => t('Credits'),
      '#type' => 'textfield',
      '#size' => 8,
    );

    $form['date'] = array(
      '#title' => t('Date awarded'),
      '#type' => 'date_popup',
    );

    $form['type'] = array(
      '#title' => t('Credit type'),
      '#type' => 'select',
      '#options' => course_credit_get_credit_titles(),
    );

    foreach ($entity as $key => $val) {
      if (isset($form[$key])) {
        if ($key == 'date') {
          $form[$key]['#default_value'] = date('Y-m-d H:i:s', $val);
        }
        else {
          $form[$key]['#default_value'] = $val;
        }
      }
    }
  }
}

/**
 * Implements hook_field_attach_submit().
 */
function course_credit_field_attach_submit($entity_type, $entity, &$form, &$form_state) {
  if ($entity_type == 'course_credit_awarded') {
    foreach (array('credits', 'date', 'type')as $key) {
      if (isset($form_state['values'][$key])) {
        if ($key == 'date') {
          $entity->$key = strtotime($form_state['values'][$key]);
        }
        else {
          $entity->$key = $form_state['values'][$key];
        }
      }
    }
  }
}

/**
 * Helper function to build node credit type settings summary.
 *
 * @param string $type
 *   The credit type identifier.
 * @param array $form
 *   The node form.
 * @param stdClass $node
 *   The node object as represented in $form['#node'], but with special
 *   modifications during preview.
 */
function course_credit_type_fieldset_summary($type, $form, $node) {
  // Set some variables for this credit type.
  $form_elements = $form['course_credit'][$type];
  $node_values = isset($node->course_credit[$type]) ? $node->course_credit[$type] : NULL;
  // Reset summary array for this credit type.
  $summary = array();
  // Only display summary if credit type is active.
  if ($node_values && $node_values->active) {
    // Loop over each form element for this credit type.
    foreach (element_children($form_elements) as $element) {
      // Check if this element has a value, otherwise skip.
      if ($node_values->$element) {
        // Reset summary_value for this form element.
        $summary_value = NULL;
        // Set some variables for this form element.
        $sumary_title = $form_elements[$element]['#title'];
        $is_allowed_type = !in_array($form_elements[$element]['#type'], array('value', 'hidden', 'fieldset'));
        $is_expiration_element = in_array($element, array('expiration_type', 'expiration_date', 'expiration_offset'));
        // Display checkbox titles only.
        if ($form_elements[$element]['#type'] == 'checkbox') {
          $summary[] = t('@title', array('@title' => $sumary_title));
        }
        // Display title and value for all other allowed fields types, except
        // expiration fields.
        elseif ($is_allowed_type && !$is_expiration_element) {
          $summary_value = $node_values->$element;
        }
        // Simplify expiration summary.
        elseif ($is_expiration_element) {
          // Date.
          if ($node_values->expiration_type == 'date') {
            // Format the expiration date field, depending on preview.
            if ($element == 'expiration_date') {
              $date = !empty($node->preview) ? $node_values->$element : date('Y-m-d', $node_values->$element);
              $summary[] = t('Expires on: @date', array('@date' => $date));
            }
          }
          // If expiration type is set to anything other than date.
          else {
            if ($element == 'expiration_type') {
              // Get the offset value here so we can make one summary array
              // addition. Check explicitly if the offset field is set.
              $offset = 0;
              if ($node_values->expiration_offset) {
                // Format the offset depending on preview.
                $offset = $node->preview ? $node_values->expiration_offset : ($node_values->expiration_offset / 86400);
              }
              $summary[] = t('Expires on @type@plus', array(
                '@type' => $type_name = $form_elements[$element]['#options'][$node_values->$element],
                '@plus' => $offset ? ' ' . t('plus @offset days', array('@offset' => $offset)) : NULL,
              ));
            }
          }
        }
        // If a summary value is set for this element, add to the summary array.
        if (!empty($summary_value)) {
          $summary[] = t('@title: @value', array('@title' => $sumary_title, '@value' => strip_tags($summary_value)));
        }
      }
    }
  }
  else {
    $summary[] = t('Inactive');
  }

  return $summary;
}

function course_credit_save_credit_type(&$credit_type) {
  if (!isset($credit_type['description'])) {
    $credit_type['description'] = '';
  }
  if (!course_credit_get_credit_type($credit_type['type'])) {
    return drupal_write_record('course_credit_type', $credit_type);
  }
  else {
    return drupal_write_record('course_credit_type', $credit_type, array('type'));
  }
}

function course_credit_save_course_credit_type_instance(&$credit_type_instance) {
  if (is_object($credit_type_instance)) {
    $credit_type_instance = (array) $credit_type_instance;
  }
  if (!course_credit_get_credit_type_instance($credit_type_instance['nid'], $credit_type_instance['type'])) {
    return drupal_write_record('course_credit', $credit_type_instance);
  }
  else {
    return drupal_write_record('course_credit', $credit_type_instance, array('nid', 'type'));
  }
}

/**
 * Get credit type.
 *
 * @return object or null.
 */
function course_credit_get_credit_type($type) {
  $result = db_query("SELECT * FROM  {course_credit_type} WHERE type = :type", array(':type' => $type))->fetchObject();
  return $result;
}

/**
 * Get credit type instance.
 *
 * @return object or null.
 */
function course_credit_get_credit_type_instance($nid, $type) {
  $result = db_query("SELECT * FROM  {course_credit} WHERE nid = :nid AND type = :type", array(':nid' => $nid, ':type' => $type))->fetchObject();
  return $result;
}

/**
 * Implements hook_node_view().
 */
function course_credit_node_view($node, $view_mode = 'full') {
  if (course_credit_node_is_creditable($node)) {
    $node->content['course_credit']['#markup'] = course_credit_render_credit($node);
  }
}

/**
 * Implements hook_node_load().
 */
function course_credit_node_load($nodes, $types) {
  $nids = array_keys($nodes);
  $sql = "SELECT cc.*, cct.title, cct.type, cct.description FROM {course_credit} cc
    INNER JOIN {course_credit_type} cct USING (type)
    WHERE nid in (:nid)
    ORDER BY cct.weight";
  $result = db_query($sql, array(':nid' => $nids));
  foreach ($result as $row) {
    $nodes[$row->nid]->course_credit[$row->type] = $row;
  }
}

/**
 * Implements hook_node_delete().
 */
function course_credit_node_delete($node) {
  db_delete('course_credit_awarded')->condition('nid', $node->nid)->execute();
  db_delete('course_credit')->condition('nid', $node->nid)->execute();
}

/**
 * D6 function refactored for D7- Implemented hook_nodeapi().
 */
function course_credit_nodeapi_insert_update(&$node, $op) {
  if (in_array($op, array('insert', 'update')) && course_credit_node_is_creditable($node)) {
    if (!empty($node->course_credit)) {
      // Clear out old values.
      db_delete('course_credit')->condition('nid', $node->nid)->execute();
      // Keep track of maximum credit for all types.
      $max_credits = array();
      foreach ($node->course_credit as $key => $entry) {
        if (is_object($entry)) {
          $entry = (array) $entry;
        }

        if ($node->is_new) {
          // Blank out the existing ccIDs, for cloning.
          unset($entry['ccid']);
        }

        $entry['nid'] = $node->nid;
        $entry['type'] = $key;

        if ($entry['active']) {
          $max_credits[] = $entry['max'];
        }
        if (isset($entry['expiration_type'])) {
          // Convert date format to unix.
          $expiration_type_is_date = $entry['expiration_type'] == 'date';
          $entry['expiration_date'] = $expiration_type_is_date && ($unix = strtotime($entry['expiration_date'])) ? $unix : NULL;
          // Store offset in seconds (from days in field entry).
          $entry['expiration_offset'] = !$expiration_type_is_date && ($seconds = ($entry['expiration_offset'] * 86400)) ? $seconds : 0;
        }
        // Ensure decimal values.
        foreach (array('increments', 'min', 'max') as $deckey) {
          $entry[$deckey] = round($entry[$deckey], 2);
        }
        // Save the entry.
        course_credit_save_course_credit_type_instance($entry);
      }

      if (!empty($max_credits)) {
        $has_credit_object = FALSE;
        $course = course_get_course($node);
        foreach ($course->getObjects() as $courseObject) {
          if ($courseObject->getComponent() == 'credit') {
            $has_credit_object = TRUE;
          }
        }

        if (!$has_credit_object) {
          $courseObject = course_get_course_object('course_credit', 'credit', $node->nid);
          $courseObject->setCourse($course)->save();
        }
      }

      // Find max of max credits to stash.
      $max_credits = !empty($max_credits) ? max($max_credits) : NULL;
      $sql = "UPDATE {course_node} SET credits = :max_credits WHERE nid = :nid";
      db_query($sql, array(':max_credits' => $max_credits, ':nid' => $node->nid));
    }
  }
}

function course_credit_node_insert($node) {
  course_credit_nodeapi_insert_update($node, 'insert');
}

function course_credit_node_update($node) {
  course_credit_nodeapi_insert_update($node, 'update');
}

/**
 * Return the HTML with the eligible credit for a node.
 */
function course_credit_render_credit($node, $account = NULL) {
  if (!$account) {
    global $user;
    $account = $user;
  }

  if (isset($node->course_credit) && count($node->course_credit)) {
    // Must have at least 1 credit instance.
    $eligible_credit = $user->uid ? course_credit_user_credit_types($node, $account) : $node->course_credit;
    return theme('course_credit', array('course_credit' => $eligible_credit, 'node' => $node, 'account' => $account));
  }
}

/**
 * Theme a list of course credit.
 */
function theme_course_credit($variables) {
  $eligible_credit = $variables['course_credit'];
  $account = $variables['account'];
  $node = $variables['node'];
  $items = array();
  foreach ($eligible_credit as $key => $credit_instance) {
    if ($credit_instance->active) {
      $item = t('<span class="course-credit-amount">@credits</span> <span class="course-credit-title">!title</span>', array(
        '@credits' => number_format($credit_instance->max, 2),
        '!title' => filter_xss($credit_instance->title),
      ));
      $desc = token_replace(filter_xss($credit_instance->description), array('node' => $node, 'user' => $account));
      if ($desc) {
        $item .= t("<div class=\"course-credit-description\">!desc</div>", array('!desc' => filter_xss($desc)));
      }

      $items[] = array(
        'data' => $item,
        'class' => array('course-credit-' . drupal_html_class($key)),
      );
    }
  }
  return $items ? theme('item_list', array('items' => $items, 'title' => NULL, 'type' => 'ul', 'attributes' => array('class' => 'course-credit-list'))) : '';
}

/**
 * Theme a list of awarded course credit.
 */
function theme_course_credit_awarded($variables) {
  $eligible_credit = $variables['course_credit_awarded'];
  foreach ($eligible_credit as $key => $credit_awarded) {
    $item = t('You were awarded <span class="course-credit-awarded-credit">@credits</span> <span class="course-credit-awarded-title">!title</span> @creditp.', array(
      '@credits' => number_format($credit_awarded->credits, 2),
      '!title' => filter_xss($credit_awarded->title),
      '@creditp' => format_plural($credit_awarded->credits, 'credit', 'credits')
    ));

    $items[] = array(
      'data' => $item,
      'class' => array('course-credit-awarded' . drupal_html_class($key)),
    );
  }
  return $items ? theme('item_list', array('items' => $items, 'title' => NULL, 'type' => 'ul', 'attributes' => array('class' => 'course-credit-awarded-list'))) : '';
}

/**
 * Implements hook_course_credit_awarded_presave().
 */
function course_credit_course_credit_awarded_presave($course_credit_awarded) {
  global $user;

  // Check for an existing record from the triplet.
  $cca = db_select('course_credit_awarded', 'cca')
    ->fields('cca')
    ->condition('type', $course_credit_awarded->type)
    ->condition('nid', $course_credit_awarded->nid)
    ->condition('uid', $course_credit_awarded->uid)
    ->execute()
    ->fetchObject();
  if ($cca) {
    $course_credit_awarded->ccaid = $cca->ccaid;
    $course_credit_awarded->is_new = 0;
    $course_credit_awarded->vid = $cca->vid;
  }

  if (!isset($course_credit_awarded->expiration)) {
    $node = node_load($course_credit_awarded->nid);
    // New record, or old record with no expiration, and expiration not
    // explicitly provided - calculate expiration.
    $expiration = NULL;
    $course_credit = $node->course_credit[$course_credit_awarded->type];
    switch ($course_credit->expiration_type) {
      case 'date':
        // Arbitrary date + offset
        $expiration = $course_credit->expiration_date + $course_credit->expiration_offset;
        break;
      case 'calendar_year':
        // End of year + offset.
        $expiration = (mktime(0, 0, 0, 1, 1, date('Y') + 1) - 1) + $course_credit->expiration_offset;
        break;
      case 'credit_awarded':
        // Credit awarded date + offset.
        $expiration = REQUEST_TIME + $course_credit->expiration_offset;
        break;
    }

    // Use our defaults, but pass the expiration type to another module.
    $expirations = module_invoke_all('course_credit_calculate_expiration', $course_credit->expiration_type);
    if ($expirations) {
      $expiration = reset($expirations);
    }

    $course_credit_awarded->expiration = $expiration;
  }

  if (empty($course_credit_awarded->date)) {
    // New or no date or date not provided - timestamp the claim.
    $course_credit_awarded->date = REQUEST_TIME;
  }

  if (!isset($course_credit_awarded->created)) {
    $course_credit_awarded->created = REQUEST_TIME;
  }

  $course_credit_awarded->changed = REQUEST_TIME;

  $course_credit_awarded->is_new_revision = TRUE;

  $course_credit_awarded->author_uid = $user->uid;
}

function course_credit_award_delete($ccaid) {
  //check for the credit award record:
  $ret = entity_delete('course_credit_awarded', $ccaid);
  if ($ret != FALSE) {
    watchdog("course_credit", "course credit award deleted for ccaid:{$ccaid}");
    return TRUE;
  }
  return $ret;
}

/**
 * Admin form for course credit.
 */
function course_credit_settings_form() {
  $form = array();

  $fallback_options[] = 'none';
  $result = course_credit_get_credit_types();
  foreach ($result as $row) {
    $fallback_options[$row->type] = strip_tags($row->title);
  }

  $form['course_credit_open_claim'] = array(
    '#type' => 'checkbox',
    '#title' => t('Skip eligibility checks'),
    '#description' => t('Profile mapping will not be used to determine eligibility. Users can claim any active credit type. Select this if you are using Rules for eligibility.'),
    '#default_value' => variable_get('course_credit_open_claim', 0),
  );

  $form['course_credit_skip_no_claim'] = array(
    '#type' => 'checkbox',
    '#title' => t('Automatically claim non-variable credit'),
    '#description' => t('When a user is only eligible for non-variable credit, credit will be claimed automatically.'),
    '#default_value' => variable_get('course_credit_skip_no_claim', 1),
  );

  $form['course_credit_fallback_type'] = array(
    '#type' => 'select',
    '#title' => t('Fallback credit type'),
    '#description' => t('Credit to award when a user is not eligible for any others.'),
    '#options' => $fallback_options,
    '#default_value' => variable_get('course_credit_fallback_type', ''),
  );

  $form['creditable_types'] = array(
    '#type' => 'fieldset',
    '#title' => 'Extra creditable types',
    '#description' => t('By default, Courses are always creditable.'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );

  foreach (node_type_get_types() as $type => $info) {
    $form['creditable_types']["course_credit_creditable_$type"] = array(
      '#title' => check_plain($info->name),
      '#type' => 'checkbox',
      '#default_value' => variable_get("course_credit_creditable_$type", 0),
    );
  }

  $form['course_credit_code'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable credit code settings on courses'),
    '#description' => t('This will enable credit code settings on all course edit forms.'),
    '#default_value' => variable_get('course_credit_code', 1),
  );

  $form['course_credit_variable'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable variable credit settings on courses'),
    '#description' => t('This will enable variable credit settings on all course edit forms.'),
    '#default_value' => variable_get('course_credit_variable', 1),
  );

  $form['course_credit_expiration'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable credit expiration settings on courses'),
    '#description' => t('This will enable credit type expiration settings on all course edit forms.'),
    '#default_value' => variable_get('course_credit_expiration', 1),
  );

  return system_settings_form($form);
}

/**
 * Credit application form.
 */
function course_credit_app_form($form, &$form_state, $node) {
  global $user;

  drupal_set_title($node->title . ': Credit claiming');

  $form = array();

  // Claim credit for credit types.
  $form['credits_claimed'] = array(
    '#type' => 'fieldset',
    '#tree' => TRUE,
    '#weight' => 1,
  );

  $credit_types = course_credit_user_credit_types($node, $user);

  // Is the user claiming variable credit?
  $claiming = FALSE;

  foreach ($credit_types as $credit_type) {
    // Get additional type info (type & title).
    $credit_type_info = course_credit_get_credit_type($credit_type->type);

    // $credit_type_info is from the global
    // $credit_type is from the user

    if ($credit_type->enable_variable_credit) {
      $form['credits_claimed'][$credit_type_info->type] = array(
        '#type' => 'textfield',
        '#prefix' => t('!title credit can be claimed in @increments increments up to a maximum of @credits.', array(
          '!title' => str_replace(' credit', '', $credit_type_info->title),
          '@credits' => number_format($credit_type->max, 2),
          '@plural' => format_plural($credit_type->max, 'credits', 'credits'),
          '@increments' => $credit_type->increments,
        )),
        '#title' => 'Credits',
        '#default_value' => NULL,
        '#size' => 4,
        '#required' => TRUE,
        '#description' => 'Enter the amount of credits to claim.',
      );

      // Now we prevents skipping the credit claim screen from the router.
      $claiming = 1;
    }
    else {
      $form['credits_claimed'][$credit_type_info->type] = array(
        '#type' => 'textfield',
        '#prefix' => t('You can claim @credits !title @plural.', array(
          '!title' => str_replace(' credit', '', $credit_type_info->title),
          '@credits' => number_format($credit_type->max, 2),
          '@plural' => format_plural($credit_type->max, 'credit', 'credits'),
        )),
        '#title' => 'Credits',
        '#default_value' => number_format($credit_type->max, 2),
        '#disabled' => TRUE,
        '#value' => number_format($credit_type->max, 2),
        '#size' => 4,
        '#required' => TRUE,
      );
    }
  }

  $form['agreement'] = array(
    '#type' => 'checkbox',
    '#title' => t('I agree that I am only claiming credit commensurate with the extent of my participation in the activity.'),
    '#required' => TRUE,
    // Do not show agreement if user is claiming max automatically.
    '#access' => $claiming == 1,
    '#weight' => 0,
  );

  if (arg(2) == 'inframe') {
    $form['inframe'] = array(
      '#type' => 'hidden',
      '#value' => 1,
    );
  }

  if (empty($credit_types)) {
    $form['credits_claimed']['#value'] = t('There is no valid credit to be awarded for this activity.');
  }
  else {
    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Claim credits'),
      '#weight' => 100,
    );
  }

  return $form;
}

/**
 * @todo document me.
 */
function course_credit_app_form_submit(&$form, &$form_state) {
  global $user;
  $account = $user;
  $course_node = node_load(arg(1));
  $form_post = $form_state['values'];
  $credits_claimed = $form_post['credits_claimed'];

  if (is_array($credits_claimed)) {
    foreach ($credits_claimed as $credit_type_name => $credits_value) {
      $credit_type = course_credit_get_credit_type($credit_type_name);

      // Save the array to a credit award record.
      $award_save_array = array(
        'type' => $credit_type->type,
        'nid' => $course_node->nid,
        'uid' => $account->uid,
        'credits' => $credits_value,
        'status' => 1,
      );

      $course_credit_awarded = entity_create('course_credit_awarded', $award_save_array);
      $ret = entity_save('course_credit_awarded', $course_credit_awarded);

      if ($ret == SAVED_NEW) {
        drupal_set_message('Awarded credit.');
      }
      if ($ret == SAVED_UPDATED) {
        drupal_set_message('Updated credit.');
      }
    }
  }
}

/**
 * Theme credit application form.
 *
 * Arranges commitment to change questions in a table.
 *
 * @ingroup themeable
 * @ingroup forms
 * @see course_credit_app_form()
 *
 * @todo remove this. If we want modules to theme the form, they can use
 * hook_theme() and their own theme function.
 */
function theme_course_credit_app_form($variables) {
  $form = $variables['form'];
  $output = '';
  //$output .= drupal_render($form['date']);
  $output .= drupal_render($form['statement']);
  $output .= drupal_render($form['credits_claimed']);
  $output .= drupal_render($form['agreement']);

  // Allow other modules to add to this themed form (a themed table for example).
  $object->output = $output;
  $object->form = $form;
  // We pass an object because they are always passed by reference. It gets
  // around drupal_alter's inability to pass additional arguments by reference.
  drupal_alter('credit_app_form', $object);
  $form = $object->form;
  $output = $object->output;

  // Render all form elements that haven't already been rendered.
  $output .= drupal_render_children($form);

  return $output;
}

/**
 * Implements hook_validate().
 *
 * @see course_credit_app_form().
 */
function course_credit_app_form_validate($form, &$form_state) {
  global $user;
  $values = $form_state['values'];

  // Validate credits claimed.
  // Get course node.
  $credits_claimed = $values['credits_claimed'];
  $course_node = node_load(arg(1));
  $credit_types = course_credit_user_credit_types($course_node, $user);

  // Alter the eligible types.
  drupal_alter('course_credit_user_credit_types', $credit_types, $course_node, $user);

  foreach ($credit_types as $credit_type) {
    $credits_claimed_params[$credit_type->type] = array(
      'title' => $credit_type->title,
      'max' => $credit_type->max,
      'min' => $credit_type->min,
      'increment' => $credit_type->increments,
    );
  }

  if (is_array($credits_claimed)) {
    foreach ($credits_claimed as $key => $claim) {
      if ($credits_claimed_params[$key]['max'] < $claim) {
        form_set_error('credits_claimed', t('Credits claimed exceed maximum of ' . $credits_claimed_params[$key]['max'] . '.'));
      }

      if ($credits_claimed_params[$key]['min'] > $claim) {
        form_set_error('credits_claimed', t('Credits claimed below minimum of ' . $credits_claimed_params[$key]['min'] . '.'));
      }

      $claim = (float) $claim;
      $credit_increment = (float) $credits_claimed_params[$key]['increment'];
      if ($credit_increment) {
        $mod = ($claim * 100) % ($credit_increment * 100);
        if ($mod) {
          form_set_error('credits_claimed', t('Credits claimed must be in increments of ' . $credits_claimed_params[$key]['increment'] . '.'));
        }
      }
    }
  }

  // Validate agreement because of a drupal core bug "Required radios/checkboxes are not validated (D6)".
  // @see http://drupal.org/node/259292
  // Or just use the Checkbox validate module.
  // @see http://drupal.org/project/checkbox_validate
  if ($form['agreement']['#access'] && $values['agreement'] != 1) {
    form_set_error('agreement', t('Please verify your statement.'));
  }
}

/**
 * Menu callback to determine if the user can access the standalone credit
 * claiming page.
 */
function course_credit_can_apply_access($course_node) {
  global $user;
  $course = course_get_course($course_node, $user);
  $has_completed_course = $course->getTracker()->getOption('complete');
  $courseObject = course_get_course_object('course_credit', 'credit', $course_node->nid, $user);
  $get_credit = $has_completed_course && $courseObject;

  // If user has not completed course, then prevent access. Originally we
  // allowed for admin to bypass this, but it confuses people who have the
  // permissions and are testing a course.
  if (!$get_credit && arg(2) == 'course-credit-app') {
    // If incomplete required objects exist and they do not have a fulfillment
    // record, redirect the user to a view of all remaining required objects.
    drupal_goto("node/{$course_node->nid}/course-complete");
  }

  return $get_credit;
}

function course_credit_type_map_form($form, &$form_state, $type) {
  // @todo set this properly in the menu using title callback.
  drupal_set_title(t('Edit credit type mapping for %type', array('%type' => $type)), PASS_THROUGH);
  $stored = variable_get('course_credit_type_map_' . $type, array());

  $form = array();
  $form['help']['#markup'] = "<p>Users meeting any selected criteria will be able to receive credit for this type.</p>";
  $form['type']['#type'] = 'hidden';
  $form['type']['#value'] = $type;
  $form['map']['#tree'] = TRUE;

  $types = field_info_instances('profile2');
  $types += field_info_instances('user');
  if (!empty($types)) {

    $form['map']['user_profile'] = array(
      '#type' => 'fieldset',
      '#title' => 'User Profile data',
      '#tree' => TRUE,
      '#description' => "If the user matches any of these profile values, they will be eligible for this credit type.",
    );
    foreach ($types as $bundle_name => $fields) {
      foreach ($fields as $field) {
        $field_info = field_info_field($field['field_name']);
        if ($field_info['module'] == 'list') {
          $options = list_allowed_values($field_info);
          if (!empty($options)) {
            $form['map']['user_profile'][$field['field_name']] = array(
              '#title' => check_plain($field['label']),
              '#type' => 'select',
              '#multiple' => TRUE,
              '#options' => $options,
              '#default_value' => isset($stored['user_profile'][$field['field_name']]) ? $stored['user_profile'][$field['field_name']] : array(),
            );
          }
        }
      }
    }

    $map_types = module_invoke_all('course_credit_map_options');
    foreach ($map_types as $key => $map_type) {
      $form['map'][$key]['#type'] = 'fieldset';
      $form['map'][$key]['#title'] = $map_type['title'];
      $form['map'][$key]['#description'] = $map_type['description'];
      foreach ($map_type['mappers'] as $map_key => $mapper) {
        $form['map'][$key][$map_key]['#title'] = $mapper['title'];
        $form['map'][$key][$map_key]['#type'] = 'select';
        $form['map'][$key][$map_key]['#multiple'] = 1;
        $form['map'][$key][$map_key]['#options'] = $mapper['options'];
        $form['map'][$key][$map_key]['#default_value'] = isset($stored[$key][$map_key]) ? $stored[$key][$map_key] : array();
      }
    }
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Set mapping',
  );

  return $form;
}

/**
 * Save mappings.
 */
function course_credit_type_map_form_submit(&$form, &$form_state) {
  if (isset($form_state['values']['map'])) {
    variable_set('course_credit_type_map_' . $form_state['values']['type'], $form_state['values']['map']);
    drupal_set_message(t('Credit type %type mappings saved.', array('%type' => $form_state['values']['type'])));
  }
}

/**
 * List and edit credit types.
 */
function course_credit_types_form() {
  $form = array();

  $form['#theme'] = 'course_credit_types_form';

  // Get credit types.
  $types = course_credit_get_credit_types();

  $form['credit_types']['#tree'] = TRUE;
  foreach ($types as $type) {
    $form['credit_types'][$type->type] = array(
      '#tree' => TRUE,
      'title' => array(
        '#type' => 'textfield',
        '#default_value' => $type->title,
        '#size' => 16,
      ),
      'type' => array(
        '#markup' => $type->type,
      ),
      'description' => array(
        '#type' => 'textarea',
        '#default_value' => $type->description,
        '#rows' => 5,
      ),
      'min' => array(
        '#type' => 'textfield',
        '#default_value' => $type->min,
        '#size' => 5,
      ),
      'max' => array(
        '#type' => 'textfield',
        '#default_value' => $type->max,
        '#size' => 5,
      ),
      'increments' => array(
        '#type' => 'textfield',
        '#default_value' => $type->increments,
        '#size' => 5,
      ),
      'enable_variable_credit' => array(
        '#type' => 'checkbox',
        '#default_value' => $type->enable_variable_credit,
      ),
      'edit' => array(
        '#type' => 'markup',
        '#markup' => implode(' | ', array(
          l('Edit', "admin/course/credit/types/$type->type/map"),
          l('Conditions', "admin/course/credit/types/manage/course_credit_eligibility_{$type->type}"),
          l('Delete', "admin/course/credit/types/$type->type/delete"),
        )),
      ),
      'weight' => array(
        '#type' => 'weight',
        '#title' => t('Weight'),
        '#default_value' => $type->weight,
        '#delta' => 10,
        '#title_display' => 'invisible',
        '#attributes' => array('class' => array('credit-weight')),
      ),
    );
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Save changes',
  );

  return $form;
}

/**
 * Theme credit types form as a table.
 */
function theme_course_credit_types_form($variables) {
  $form = $variables['form'];
  $out = '';
  // Help text.
  $out .= '<div class="description">' . t('These are the default settings that will be used when creating a creditable activity.') . '</div>';

  $headers = array('', 'Title', 'Type', 'Description', 'Min', 'Max', 'Increments', 'Variable', '', 'Weight');
  $rows = array();
  foreach (element_children($form) as $key) {
    foreach (element_children($form[$key]) as $credit_type) {
      $row = array();
      $row[] = '';
      foreach (element_children($form['credit_types'][$credit_type]) as $credit_field) {
        // Add as cell.
        $row[] = drupal_render($form['credit_types'][$credit_type][$credit_field]);
      }

      // Add credit type row to table.
      $rows[] = array(
        'class' => array('draggable'),
        'data' => $row,
      );
    }
  }
  $out .= theme('table', array('header' => $headers, 'rows' => $rows, 'attributes' => array('id' => 'course-credit-types-table')));

  // Render any additional elements.
  $out .= drupal_render_children($form);

  drupal_add_tabledrag('course-credit-types-table', 'order', 'sibling', 'credit-weight');

  return $out;
}

function course_credit_types_form_submit($form, $form_state) {
  foreach ($form_state['values']['credit_types'] as $key => $credit_type) {
    unset($credit_type['type']);
    $credit_type['type'] = $key;
    course_credit_save_credit_type($credit_type);
  }
  drupal_set_message('Updated credit types.');
}

/**
 * Return the credit types that the user can claim set by the mappings.
 *
 * Checks all the mappings and returns all credit type *instances* that the user can claim.
 *
 * @param stdClass $node
 *   A course node object.
 * @param stdClass $account
 *   A user object.
 *
 * @return array
 *   An array of valid credit instances as objects, keyed by type.
 */
function course_credit_user_credit_types($node, $account) {
  $valid_credit_instances = array();
  $fallback_instance = NULL;

  $fallback_credit_type = variable_get('course_credit_fallback_type', null);

  $profile['user'] = $account;
  if (module_exists('profile2')) {
    $types = field_info_instances('profile2');
    foreach ($types as $bundle_name => $fields) {
      $profile[$bundle_name] = profile2_load_by_user($account, $bundle_name);
    }
  }
  if (module_exists('course')) {
    if (!$enrollment = course_enrollment_load($node, $account)) {
      $enrollment = new stdClass;
      $enrollment->type = 'course_enrollment';
    }
  }

  $open_claim = variable_get('course_credit_open_claim', 0);

  $sql = "SELECT cct.title, cct.description, cc.* FROM {course_credit} cc
    INNER JOIN {course_credit_type} cct USING (type)
    WHERE nid = :nid
    ORDER BY cct.weight";
  $result = db_query($sql, array(':nid' => $node->nid));
  foreach ($result as $ct_instance) {
    if ($ct_instance->active) {
      if ($open_claim) {
        // Credit claim is open. User is eligible for all active types.
        $valid_credit_instances[$ct_instance->type] = $ct_instance;
      }

      // If credit type is active, try mappings.
      $mappings = variable_get('course_credit_type_map_' . $ct_instance->type, array());
      // Match against profile fields.
      if (isset($mappings['user_profile']) && is_array($mappings['user_profile'])) {
        foreach ($mappings['user_profile'] as $field_name => $values) {
          foreach ($profile as $bundle => $user_profile) {
            if (isset($user_profile->{$field_name}) && $user_profile->{$field_name} && is_array($user_profile->{$field_name}['und'])) {
              foreach ($user_profile->{$field_name}['und'] as $delta => $item) {
                if (in_array($item['value'], $values)) {
                  $valid_credit_instances[$ct_instance->type] = $ct_instance;
                }
              }
            }
          }
        }
      }

      // Have fun!
      if (array_filter(module_invoke_all('course_credit_map', $node, $account, $mappings))) {
        // We're just looking for true, if the user is eligible.
        $valid_credit_instances[$ct_instance->type] = $ct_instance;
      }

      if ($ct_instance->type == $fallback_credit_type) {
        // If this type we're looping over is fallback, save the instance.
        $fallback_instance = $ct_instance;
      }
    }

    // Rules cannot grant eligibility, only take it away. To use rules fully
    // similar to the way Commerce/Ubercart payment conditions work, make sure
    // "open claim" is set.
    if ($set = rules_config_load("course_credit_eligibility_{$ct_instance->type}")) {
      if (!$set->execute($ct_instance, $account, $enrollment)) {
        // The rule did not pass. Remove the credit type from eligbility.
        unset($valid_credit_instances[$ct_instance->type]);
      }
    }
  }


  if (!count($valid_credit_instances) && $fallback_instance) {
    // We have no valid instances, so use the fallback.
    $valid_credit_instances[$fallback_instance->type] = $fallback_instance;
  }

  // Alter the eligible types.
  drupal_alter('course_credit_user_credit_types', $valid_credit_instances, $node, $account);

  return $valid_credit_instances;
}

/**
 * Implements hook_access_certificate().
 *
 * Block access to certificate if user can claim credit, but hasn't.
 *
 * @todo This is a legacy function, the plan is to introduce course credit as a
 * course object.
 */
function course_credit_access_certificate($node, $user) {
  $has_active = FALSE;

  if (course_credit_node_is_creditable($node) && !empty($node->course_credit)) {
    // Check course for active credit.
    foreach ($node->course_credit as $type) {
      if ($type->active) {
        $has_active = TRUE;
        break;
      }
    }

    if ($has_active) {
      $sql = "select 1 from  {course_credit_awarded} where nid = :nid and uid = :uid";
      if (db_query($sql, array(':nid' => $node->nid, ':uid' => $user->uid))->fetchField()) {
        // User already claimed credit for this course. Allow the certificate.
        return TRUE;
      }
      else {
        // User did not claim credit for the course. Redirect to credit app.
        if (arg(2) == 'certificate') {
          drupal_goto("node/{$node->nid}/course-credit-app");
        }
      }
    }
  }
}

/**
 * Implements hook_token_info().
 */
function course_credit_token_info() {
  $types = array();

  $types['course-credit-awarded'] = array(
    'name' => t('Course credit awarded'),
    'description' => t("Tokens related to a node and user's awarded credit records."),
  );

  $types['course-credit-awarded-single'] = array(
    'name' => t('Course credit awarded single'),
    'description' => t("Tokens related to a node and user's first awarded credit record."),
  );

  $types['course-credit'] = array(
    'name' => t('Course credit'),
    'description' => t("Tokens related to the node's credit."),
    'needs-data' => 'node',
  );

  // Get credit types.
  $rows = course_credit_get_credit_types();

  $fields = array(
    'credits' => 'credits awarded',
    'min' => 'minimum variable credits',
    'max' => 'maximum variable credits',
    'title' => 'title',
    'code' => 'code',
    'ceu' => 'CEUs',
  );

  $credit_awarded_tokens = array();
  $credit_tokens = array();
  $single_awarded_tokens = array();
  foreach ($rows as $row) {
    // We have to generate the tokens for every credit type.
    foreach ($fields as $field => $desc) {
      if ($field != 'credits') {
        $credit_tokens["{$row->type}:$field"] = array('name' => "Credit {$row->title} $field", 'description' => $desc);
      }
      $credit_awarded_tokens["{$row->type}:$field"] = array('name' => "Awarded {$row->title} $field", 'description' => $desc);
    }
  }

  if ($rows) {
    foreach ($fields as $field => $desc) {
      $single_awarded_tokens["{$field}"] = array('name' => "Single {$row->title} $field", 'description' => $desc);
    }
  }

  return array(
    'types' => $types,
    'tokens' => array(
      'course-credit-awarded' => $credit_awarded_tokens,
      'course-credit' => $credit_tokens,
      'node' => array(
        'course-credit' => array(
          'name' => t('Course credit'),
          'description' => t('The course credit of the node.'),
          'type' => 'course-credit',
        ),
      ),
      'course-credit-awarded-single' => $single_awarded_tokens,
    ),
  );
}

/**
 * Implements hook_tokens().
 */
function course_credit_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();
  $sanitize = !empty($options['sanitize']);

  if ($type == 'course-credit-awarded' || $type == 'course-credit-awarded-single') {
    if (!empty($data['course_credit_awarded'])) {
      // A single course credit awarded entity was passed.
      return entity_token_tokens('course_credit_awarded', $tokens, $data, $options);
    }
    if (!empty($data['node']) && course_node_is_course($data['node']) && !empty($data['user'])) {
      $sql = "SELECT cct.title, cct.type, cc.*, cca.* FROM {course_credit_awarded} cca
      LEFT JOIN {course_credit} cc ON (cc.type = cca.type and cc.nid = :nid)
      INNER JOIN {course_credit_type} cct ON (cct.type = cca.type)
      WHERE cca.nid = :nid AND cca.uid = :uid
      ORDER BY cct.weight";
      $result = db_query($sql, array(':nid' => $data['node']->nid, ':nid' => $data['node']->nid, ':uid' => $data['user']->uid));
      foreach ($result as $row) {
        $row->ceu = $row->credits / 10;
        foreach ($row as $key => $value) {
          if (in_array($key, array('min', 'max', 'credits'))) {
            $value = number_format($value, 2);
          }
          elseif ($sanitize) {
            $value = check_plain($value);
          }
          if ($type == 'course-credit-awarded') {
            if (isset($tokens["{$row->type}:$key"])) {
              $replacements[$tokens["{$row->type}:$key"]] = $value;
            }
          }
          else {
            if (isset($tokens[$key])) {
              $replacements[$tokens[$key]] = $value;
            }
          }
        }
      }
    }
  }

  if ($type == 'node') {
    $course_credit_tokens = token_find_with_prefix($tokens, 'course-credit');
    $sql = "SELECT cct.title, cct.type, cc.* FROM {course_credit} cc
      LEFT JOIN {course_credit_type} cct ON (cct.type = cc.type)
      WHERE cc.nid = :nid
      ORDER BY cct.weight";
    $result = db_query($sql, array(':nid' => $data['node']->nid));
    foreach ($result as $row) {
      foreach ($row as $key => $value) {
        if (isset($course_credit_tokens["{$row->type}:$key"])) {
          $row->ceu = $row->max / 10;
          if (in_array($key, array('min', 'max', 'credits'))) {
            $value = number_format($value, 2);
          }
          elseif ($sanitize) {
            $value = check_plain($value);
          }
          $replacements[$course_credit_tokens["{$row->type}:$key"]] = $value;
        }
      }
    }
  }

  return $replacements;
}

/**
 * Implements hook_views_api().
 */
function course_credit_views_api() {
  return array(
    'api' => 3,
  );
}

/**
 * Hide course-credit-app in menu.
 *
 * @todo find a better way to do this, or do it as a course object.
 */
function phptemplate_menu_local_task($link, $active = FALSE) {
  $kill = array(
    'course-credit-app',
  );

  // Check each tab being rendered for our victim.
  foreach ($kill as $drupal) {
    if (strpos($link, $drupal) !== FALSE) {
      return '';
    }
  }
  // Note that we intentionally call this theme function directly, because
  // theme('menu_local_task', $link, $active) would cause an endless loop here.
  return theme_menu_local_task($link, $active);
}

/**
 * Check that a node is creditable.
 *
 * @return bool
 */
function course_credit_node_is_creditable(&$node) {
  if (course_node_is_course($node)) {
    return TRUE;
  }
  if (isset($node->type) && variable_get('course_credit_creditable_' . $node->type)) {
    return TRUE;
  }
}

/**
 * Implements hook_user_cancel().
 */
function course_credit_user_cancel($edit, $account, $method) {
  $ccaids = db_select('course_credit_awarded', 'cca')
      ->fields('cca', array('ccaid'))
      ->condition('uid', $user->uid)
      ->execute()->fetchAllKeyed();
  entity_delete_multiple('course_credit_awarded', array_keys($ccaids));
}

/**
 * Get an array of all credit types in the system.
 */
function course_credit_get_credit_types() {
  $credit_types = array();

  $sql = "SELECT * FROM {course_credit_type} ORDER BY weight";
  $result = db_query($sql);
  foreach ($result as $row) {
    $credit_types[$row->type] = $row;
  }

  return $credit_types;
}

/**
 * Add new credit type.
 */
function course_credit_type_add_form($form, &$form_state) {
  $form = array();

  $form['title'] = array(
    '#title' => 'Name of credit type',
    '#type' => 'textfield',
    '#size' => 16,
    '#required' => TRUE,
  );

  $form['type'] = array(
    '#title' => 'Machine name',
    '#description' => 'A machine-readable name, only using lowercase letters (a-z), numbers (0-9), and the underscore (_).',
    '#type' => 'machine_name',
    '#size' => 16,
    '#required' => TRUE,
    '#machine_name' => array(
      'source' => array('title'),
      'label' => 'Short name',
      'exists' => 'course_credit_get_credit_type',
    ),
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Save',
  );

  $form['#validate'][] = 'course_credit_type_add_form_validate';

  return $form;
}

/**
 * Validate machine name.
 */
function course_credit_type_add_form_validate($form, &$form_state) {
  $type = $form_state['values']['type'];
  if (!preg_match('/^[a-z0-9_]+$/', $type)) {
    form_error($form['type'], t('%type contains invalid characters.', array('%type' => $type)));
  }
}

/**
 * Save credit type from form submission.
 */
function course_credit_type_add_form_submit(&$form, &$form_state) {
  $credit_type = new stdClass();
  $credit_type->title = $form_state['values']['title'];
  $credit_type->type = $form_state['values']['type'];
  $credit_type->description = '';
  $credit_type->min = 0;
  $credit_type->max = 0;
  $credit_type->increments = 0;

  drupal_write_record('course_credit_type', $credit_type);
  drupal_set_message(t('New credit type added.'));
  $form_state['redirect'] = 'admin/course/credit/types';
}

/**
 * Delete confirmation form.
 */
function course_credit_type_delete_form($form, &$form_state, $type) {
  $form['type']['#type'] = 'hidden';
  $form['type']['#value'] = $type;
  return confirm_form($form, t('Are you sure you want to delete the credit type %type?', array('%type' => $type)), 'admin/course/credit/course_credit_types', 'Disabling it is probably a better idea. This cannot be un-done, and course credit will be deleted from users who received this credit type.');
}

/**
 * Delete course credit from form submission.
 */
function course_credit_type_delete_form_submit(&$form, &$form_state) {
  db_delete('course_credit_type')
    ->condition('type', $form_state['values']['type'])
    ->execute();
  drupal_set_message(t('Credit type deleted.'));
  $form_state['redirect'] = 'admin/course/credit/course_credit_types';
}

/**
 * Implements hook_course_enrollment_delete().
 */
function course_credit_course_enrollment_delete($course_enrollment) {
  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'course_credit_awarded')
    ->propertyCondition('nid', $course_enrollment->nid)
    ->propertyCondition('uid', $course_enrollment->uid)
    ->execute();

  if (!empty($result['course_credit_awarded'])) {
    entity_delete_multiple('course_credit_awarded', array_keys($result['course_credit_awarded']));
  }
}

/**
 * Implements certificate_map_options().
 *
 * Return a list of options.
 */
function course_credit_certificate_map_options() {
  $options = array();

  foreach (course_credit_get_credit_types() as $cc) {
    $options[$cc->type] = $cc->title;
  }
  return array(
    'course_credit_awarded' => array(
      'title' => 'Awarded course credit',
      'options' => $options,
      'description' => t('Using this mapping will award a certificate based on the credit type the user claimed after completing a course.<br/>You may set up eligibility for credit types on the !link page.', array('!link' => l('credit types', 'admin/course/credit/course_credit_types'))),
    ),
  );
}

/**
 * Implements certificate_map().
 *
 * Return which options match.
 */
function course_credit_certificate_map($node, $user, $map_type, $options) {
  $valid = array();

  if ($map_type == 'course_credit_awarded') {
    $sql = 'SELECT * FROM {course_credit_awarded} cca
      INNER JOIN {course_credit_type} cct ON cca.type = cct.type
      WHERE nid = :nid AND uid = :uid
      ORDER BY cct.weight';
    $result = db_query($sql, array(':nid' => $node->nid, ':uid' => $user->uid));
    while ($credit_awarded = $result->fetchObject()) {
      foreach ($options as $type) {
        if ($credit_awarded->type == $type) {
          $valid[] = $type;
        }
      }
    }
  }

  return $valid;
}

/**
 * Implements hook_date_api_fields().
 *
 * Expose the awarded expiration date, credit claim time, and hard expiration
 * date for course credit to date API.
 */
function course_credit_date_api_fields($field) {
  $values = array(
    'sql_type' => DATE_UNIX,
    'granularity' => array('year', 'month', 'day'),
  );

  switch ($field) {
    case 'course_credit_awarded.expiration':
    case 'course_credit_awarded.date':
    case 'course_credit.expiration_date':
      return $values;
  }
}

/**
 * Implements hook_date_api_tables().
 */
function course_credit_date_api_tables() {
  return array('course_credit_awarded', 'course_credit');
}

/**
 * Get the awarded credit for a user in a course.
 */
function course_credit_get_credit_awarded($nid, $uid) {
  $awarded = array();

  $sql = "SELECT cca.*, cc.*, cct.title FROM {course_credit_awarded} cca
    INNER JOIN {course_credit} cc ON (cca.nid = cc.nid and cc.type = cca.type)
    INNER JOIN {course_credit_type} cct ON (cca.type = cct.type)
    WHERE (cca.nid = :nid) AND (cca.uid = :uid)";
  $result = db_query($sql, array(':nid' => $nid, ':uid' => $uid));
  foreach ($result as $row) {
    $awarded[$row->type] = $row;
  }

  return $awarded;
}

/**
 * Implements hook_permission().
 */
function course_credit_permission() {
  return array(
    'administer course credit' => array(
      'title' => t('Administer course credit'),
      'description' => t('Add, edit, and delete credit types.'),
    ),
  );
}

/**
 * Implements hook_entity_info().
 */
function course_credit_entity_info() {
  $info = array(
    'course_credit_awarded' => array(
      'label' => t('Course credit awarded'),
      'plural label' => t('Course credit awarded'),
      'controller class' => 'EntityAPIController',
      'base table' => 'course_credit_awarded',
      'revision table' => 'course_credit_awarded_revision',
      'fieldable' => FALSE,
      'entity keys' => array(
        'id' => 'ccaid',
        'revision' => 'vid',
        'bundle' => 'type',
      ),
      'label callback' => 'course_credit_awarded_label',
      'views controller class' => 'EntityDefaultViewsController',
      'access callback' => 'course_credit_access',
      'admin ui' => array(
        'path' => 'admin/course/credit/awarded',
        'controller class' => 'EntityDefaultUIController',
      ),
    ),
    'course_credit' => array(
      'label' => t('Course credit instance'),
      'controller class' => 'EntityAPIController',
      'base table' => 'course_credit',
      'fieldable' => FALSE,
      'entity keys' => array(
        'id' => 'ccid',
      ),
      'label callback' => 'course_credit_awarded_label',
      'views controller class' => 'EntityDefaultViewsController',
      'access callback' => 'course_credit_access',
    ),
    'course_credit_type' => array(
      'label' => t('Course credit type'),
      'controller class' => 'EntityAPIControllerExportable',
      'base table' => 'course_credit_type',
      'fieldable' => FALSE,
      'entity keys' => array(
        'id' => 'type',
        'label' => 'title',
      ),
      'views controller class' => 'EntityDefaultViewsController',
      'exportable' => TRUE,
      'access callback' => 'course_credit_access',
    ),
  );

  foreach (course_credit_get_credit_titles() as $type => $name) {
    $info['course_credit_awarded']['bundles'][$type] = array(
      'label' => $name,
    );
  }

  return $info;
}

/**
 * Implements hook_entity_property_info_alter().
 *
 * Define our special schema fields and relationships.
 */
function course_credit_entity_property_info_alter(&$info) {
  $info['course_credit']['properties']['active']['type'] = 'boolean';
  $info['course_credit']['properties']['enable_variable_credit']['type'] = 'boolean';
  $info['course_credit']['properties']['nid']['expiration_date'] = 'date';
  $info['course_credit']['properties']['nid']['expiration_offset'] = 'duration';
  $info['course_credit']['properties']['nid']['required'] = TRUE;
  $info['course_credit']['properties']['nid']['type'] = 'node';
  $info['course_credit']['properties']['type']['options list'] = 'course_credit_get_credit_titles';
  $info['course_credit']['properties']['type']['required'] = TRUE;
  $info['course_credit']['properties']['type']['type'] = 'course_credit_type';

  $info['course_credit_awarded']['properties']['author_uid']['type'] = 'user';
  $info['course_credit_awarded']['properties']['changed']['type'] = 'date';
  $info['course_credit_awarded']['properties']['created']['type'] = 'date';
  $info['course_credit_awarded']['properties']['date']['type'] = 'date';
  $info['course_credit_awarded']['properties']['expiration']['type'] = 'date';
  $info['course_credit_awarded']['properties']['nid']['required'] = TRUE;
  $info['course_credit_awarded']['properties']['nid']['type'] = 'node';
  $info['course_credit_awarded']['properties']['status']['type'] = 'boolean';
  $info['course_credit_awarded']['properties']['type']['options list'] = 'course_credit_get_credit_titles';
  $info['course_credit_awarded']['properties']['type']['required'] = TRUE;
  $info['course_credit_awarded']['properties']['type']['type'] = 'course_credit_type';
  $info['course_credit_awarded']['properties']['uid']['required'] = TRUE;
  $info['course_credit_awarded']['properties']['uid']['type'] = 'user';

  $info['course_credit_type']['properties']['enable_variable_credit']['type'] = 'boolean';
  $info['course_credit_type']['properties']['type']['options list'] = 'course_credit_get_credit_titles';
  $info['course_credit_type']['properties']['type']['required'] = TRUE;
}

/**
 * Get an array of all credit types in the system.
 *
 * @return array
 *   An array of credit type titles, keyed by credit type.
 */
function course_credit_get_credit_titles() {
  $credit_types = course_credit_get_credit_types();
  $titles = array();
  foreach ($credit_types as $key => $credit_type) {
    $titles[$key] = $credit_type->title;
  }
  return $titles;
}

/**
 * Implements hook_course_report_insert().
 */
function course_credit_course_report_insert($course_report) {
  course_credit_course_report_update($course_report);
}

/**
 * Implements hook_course_report_update().
 *
 * Claim credit on course completion if skip non-variable credit is set.
 */
function course_credit_course_report_update($course_report) {
  if (empty($course_report->original->complete) && !empty($course_report->complete)) {
    $node = node_load($course_report->nid);
    $account = user_load($course_report->uid);
    if (!course_credit_must_claim($node, $account)) {
      // User does not have to claim credit so let's award credit here.
      course_credit_award_credit($node, $account);
    }
  }
}

/**
 * Helper function to award eligible non-variable credit.
 *
 * @param type $node
 * @param type $account
 */
function course_credit_award_credit($node, $account) {
  foreach (course_credit_user_credit_types($node, $account) as $credit) {
    if (empty($credit->enable_variable_credit) && variable_get('course_credit_skip_no_claim', 1)) {
      $entity = $credit;
      $entity->uid = $account->uid;
      $entity->credits = $credit->max;
      entity_save('course_credit_awarded', $entity);
    }
  }
}

/**
 * Implements hook_course_credit_awarded_insert().
 *
 * Fire course completion for a course credit course object.
 */
function course_credit_course_credit_awarded_insert($cca) {
  $account = user_load($cca->uid);
  if ($courseObject = course_get_course_object('course_credit', 'credit', $cca->nid, $account)) {
    $courseObject->getFulfillment()->setComplete()->save();
  }
}

/**
 * Entity access callback.
 */
function course_credit_access($op, $entity = NULL, $account = NULL) {
  return user_access('administer course credit');
}

/**
 * Course credit awarded edit form.
 */
function course_credit_awarded_form($form, &$form_state, $course_credit_awarded) {
  field_attach_form('course_credit_awarded', $course_credit_awarded, $form, $form_state);


  $form['actions'] = array('#type' => 'actions');
  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
    '#weight' => 2,
  );
  $form['actions']['delete'] = array(
    '#type' => 'submit',
    '#value' => t('Delete'),
    '#weight' => 1,
  );

  $form['#submit'][] = 'course_credit_awarded_form_submit';
  return $form;
}

/**
 * Save or update credit.
 */
function course_credit_awarded_form_submit($form, &$form_state) {
  $course_credit_awarded = $form_state['course_credit_awarded'];
  field_attach_submit('course_credit_awarded', $course_credit_awarded, $form, $form_state);
  entity_save('course_credit_awarded', $course_credit_awarded);
  drupal_set_message(t('Updated credit.'));
}

function course_credit_awarded_label($entity) {
  return $entity->type;
}
