<?php

/**
 * @file
 *  This submodule will replace entity module's entity_metadata_no_hook_node_access's use
 *  of node_access_view_all_nodes with module grants' _module_grants_node_access_view_all_nodes
 */

/**
 * Implement hook_module_implements_alter:
 * 1. Move our hook_entity_info_alter to the last place
 */
function module_grants_entity_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'entity_info_alter') {
    $module = 'module_grants_entity';
    $group = $implementations[$module];
    unset($implementations[$module]);
    $implementations[$module] = $group;
  }
}

/**
 * Implements hook_entity_info_alter().
 */
function module_grants_entity_entity_info_alter(&$entity_info) {
  $entity_info['node']['access callback'] = 'module_grants_entity_metadata_node_access';
}

/**
 * Access callback for the node entity.
 * Copied from entity_metadata_no_hook_node_access() in callbacks.inc
 */
function module_grants_entity_metadata_node_access($op, $node = NULL, $account = NULL) {
  if (isset($node)) {
    // If a non-default revision is given, incorporate revision access.
    if (isset($node->nid)) {
      $default_revision = node_load($node->nid);
      if ($node->vid != $default_revision->vid) {
        return _node_revision_access($node, $op);
      }
      else {
        return node_access($op, $node, $account);
      }
    }
    elseif ($op == 'create' && isset($node->type)){
      // if a new node is passed in, need to check if it's for create
      return node_access($op, $node->type, $account);
    }
  }
  // Is access to all nodes allowed?
  if (!user_access('access content', $account)) {
    return FALSE;
  }
  if (user_access('bypass node access', $account) || (!isset($account) && $op == 'view' && _module_grants_node_access_view_all_nodes())) {
    return TRUE;
  }
  return FALSE;
}