<?php
/**
 * @file
 * Code for the Webform Queue.
 */

/**
 * Implements hook_views_api().
 */
function webform_events_views_api() {
  return array("api" => "3.0");
}

/**
 * Implements hook_node_info().
 */
function webform_events_node_info() {
  $items            = array(
    'webform_events' => array(
      'name'        => t('Event'),
      'base'        => 'node_content',
      'description' => t('Event with webform signups'),
      'has_title'   => '1',
      'title_label' => t('Title'),
      'help'        => '',
    ),
  );
  return $items;
}

/**
 * Implements hook_menu().
 */
function webform_events_menu() {
  $items = array();
  // Management page.
  $items['node/%node/manage-event'] = array(
    'title'                         => 'Manage event',
    // Function to build form.
    'page callback'                 => 'drupal_get_form',
    // Attachs arguments to drupal_get_form.
    'page arguments'                => array('webform_events_form', 1),
    'access arguments'              => array(1),
    'access callback'               => '_webform_events_nodetype_check',
    // File that contains requested page.
    'file'                          => 'includes/webform_events.pages.inc',
    'weight'                        => 20,
    'type'                          => MENU_LOCAL_TASK,
  );
  $items['admin/structure/webform_events'] = array(
    'title'             => 'Webform events',
    'description'       => 'Configuration for the webform events module',
    'page callback'     => 'drupal_get_form',
    // Set form.
    'page arguments'    => array('webform_events_admin_form'),
    'access arguments'  => array('administer events'),
    'type'              => MENU_NORMAL_ITEM,
  );
  return $items;
}

/**
 * Implements hook_block_info().
 */
function webform_events_block_info() {
  $blocks = array();
  $blocks['webform_events_user_events'] = array(
    'info' => t('Webform events: Events for current user'),
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function webform_events_block_view($delta = '') {
  $block = array();

  switch ($delta) {
    case 'webform_events_user_events':
      $block['content'] = webform_events_user_events_view();
      break;
  }

  return $block;
}

/**
 * Custom function to assemble renderable array for block content.
 */
function webform_events_user_events_view() {
  module_load_include('inc', 'webform', 'includes/webform.submissions');
  global $user;
  $uid = $user->uid;
  $user_submissions = webform_get_submissions(array('uid' => $uid));

  // Init vars.
  $markup = "";
  $block = array();

  $rows = _webform_events_submission_array($user_submissions);

  // Set headers.
  $header = array(
    t('Event name'),
    t('Action'),
    t('View'),
  );

  // Let's build a pager, first how many per page.
  $per_page = variable_get('webform_events_default_profile_pager');
  // Get current page.
  $current_page = pager_default_initialize(count($rows), $per_page);
  // Break row data to chunks defined by $per_page.
  $chunks = $rows;
  $chunks = array_chunk($rows, $per_page, TRUE);
  if (!empty($chunks)) {
    $chunks = $chunks[$current_page];
  }
  // Theme table actual data by chunks.
  $markup = theme('table', array(
      'header' => $header,
      'rows' => $chunks,
      'attributes' => array('width' => '100%'),
  ));
  // Add pager to markup.
  $markup .= theme('pager', array('quantity', count($rows)));

  // Block output in HTML with div wrapper.
  $block = array(
    'message' => array(
      '#prefix' => '<div class="class_name">',
      '#type' => 'markup',
      '#markup' => $markup,
      '#suffix' => '</div>',
    ),
  );

  return $block;
}

/**
 * Form builder; Default settings for webform events.
 */
function webform_events_admin_form($form, &$form_state) {
  // Text field for the default e-mail.
  // Remember to declare variables as webform_events_default_FIELD.
  $form['webform_events_default_email'] = array(
    '#type'             => 'textfield',
    '#default_value'    => variable_get('webform_events_default_email', ''),
    '#title'            => t('Default email'),
    '#description'      => t('The default email for events.'),
    '#size'             => 60,
    '#maxlength'        => 60,
    '#required'         => FALSE,
  );
  $form['webform_events_default_participants'] = array(
    '#title'            => t('Initial number of participants'),
    '#description'      => t('Default value for participants. Must be whole number.'),
    '#default_value'    => variable_get('webform_events_default_participants', 10),
    '#type'             => 'textfield',
    '#value_key'        => 'value',
    '#maxlength'        => 60,
    '#size'             => 60,
    '#required'         => FALSE,
  );
  $form['webform_events_default_manage_pager'] = array(
    '#title'            => t('Results per manage event page'),
    '#description'      => t('How many results to show on manage event page per page. Must be whole number.'),
    '#default_value'    => variable_get('webform_events_default_manage_pager', 10),
    '#type'             => 'textfield',
    '#value_key'        => 'value',
    '#maxlength'        => 6,
    '#size'             => 6,
    '#required'         => FALSE,
  );
  $form['webform_events_default_profile_pager'] = array(
    '#title'            => t('Results per profile page'),
    '#description'      => t('How many results to show on profile page per page. Affects also block. Must be whole number.'),
    '#default_value'    => variable_get('webform_events_default_profile_pager', 10),
    '#type'             => 'textfield',
    '#value_key'        => 'value',
    '#maxlength'        => 6,
    '#size'             => 6,
    '#required'         => FALSE,
  );
  $form['webform_events_default_overbooking'] = array(
    '#title'            => t('Default overbooking'),
    '#description'      => t('Enable overbooking by default.'),
    '#default_value'    => variable_get('webform_events_default_overbooking', 0),
    '#on_value'         => 1,
    '#off_value'        => 0,
    '#value_key'        => 'value',
    '#type'             => 'checkbox',
    '#required'         => FALSE,
  );
  $form['webform_events_default_limit'] = array(
    '#title'            => t('Default signup limitation'),
    '#description'      => t('Limit signups to single by default.'),
    '#default_value'    => variable_get('webform_events_default_limit', 0),
    '#on_value'         => 1,
    '#off_value'        => 0,
    '#value_key'        => 'value',
    '#type'             => 'checkbox',
    '#required'         => FALSE,
  );
  $form['webform_events_show_profile'] = array(
    '#title'            => t('Show events on profile'),
    '#description'      => t('Add events as table to user profile.'),
    '#default_value'    => variable_get('webform_events_show_profile', 0),
    '#on_value'         => 1,
    '#off_value'        => 0,
    '#value_key'        => 'value',
    '#type'             => 'checkbox',
    '#required'         => FALSE,
  );
  $form['webform_events_change_titles'] = array(
    '#title'            => t('Change titles according to date'),
    '#description'      => t('Modifies title to include starting date if event has not started or indicates event is closed if signups ending date has passed.'),
    '#default_value'    => variable_get('webform_events_change_titles', 0),
    '#on_value'         => 1,
    '#off_value'        => 0,
    '#value_key'        => 'value',
    '#type'             => 'checkbox',
    '#required'         => FALSE,
  );
  $form['webform_events_manage_page'] = array(
    '#title'            => t('Show manage page only to event creator'),
    '#description'      => t('Show manage page only to event creator. Combine this with webform permissions to limit event to creator.'),
    '#default_value'    => variable_get('webform_events_manage_page', 0),
    '#on_value'         => 1,
    '#off_value'        => 0,
    '#value_key'        => 'value',
    '#type'             => 'checkbox',
    '#required'         => FALSE,
  );

  // Submit button.
  $form['submit']   = array(
    '#type'         => 'submit',
    '#value'        => t('Save settings'),
  );

  $form['#validate'] = array('_webform_events_admin_validate');
  return $form;
}

/**
 * Admin page validations.
 */
function _webform_events_admin_validate($form_state) {
  if (!is_numeric($form_state['webform_events_default_profile_pager']['#value'])) {
    form_set_error('webform_events_default_profile_pager', t('Value must be numeric.'));
  }
  if (!is_numeric($form_state['webform_events_default_manage_pager']['#value'])) {
    form_set_error('webform_events_default_manage_pager', t('Value must be numeric.'));
  }
  if (!is_numeric($form_state['webform_events_default_participants']['#value'])) {
    form_set_error('webform_events_default_participants', t('Value must be numeric.'));
  }
}

/**
 * Save configuration settings for webform event module.
 */
function webform_events_admin_form_submit($form, &$form_state) {
  // Save default email.
  variable_set('webform_events_default_email', $form_state['values']['webform_events_default_email']);
  // Save default overbooking.
  variable_set('webform_events_default_overbooking', $form_state['values']['webform_events_default_overbooking']);
  // Save default limit.
  variable_set('webform_events_default_limit', $form_state['values']['webform_events_default_limit']);
  // Save default participants.
  variable_set('webform_events_default_participants', $form_state['values']['webform_events_default_participants']);
  // Save manage event pager.
  variable_set('webform_events_default_manage_pager', $form_state['values']['webform_events_default_manage_pager']);
  // Save manage event pager.
  variable_set('webform_events_default_profile_pager', $form_state['values']['webform_events_default_profile_pager']);
  // Save default overbooking.
  variable_set('webform_events_show_profile', $form_state['values']['webform_events_show_profile']);
  // Save default title handling.
  variable_set('webform_events_change_titles', $form_state['values']['webform_events_change_titles']);
  // Save default manage page visibility.
  variable_set('webform_events_manage_page', $form_state['values']['webform_events_manage_page']);
  // Inform save was succesful.
  drupal_set_message(t('The settings have been saved'));
}

/**
 * Implements hook_theme().
 */
function webform_events_theme() {
  return array(
    'webform_events'     => array(
      'template'        => 'webform_events',
      'variables'       => array(
        'headers'       => NULL,
        'submissions'   => NULL,
        'queue'         => NULL,
        'cancel'        => NULL),
    ),
  );
}

/**
 * Implements hook_permission().
 */
function webform_events_permission() {
  return array(
    'view expired events' => array(
      'title' => t(
        'View events that have have passed due date.'
      ),
      'description' => t(
        'Allows to see expired events. Set this for event moderators.'
      ),
    ),
    'administer events' => array(
      'title' => t(
        'Access administration tools'
      ),
      'description' => t(
        'Grants access to administration page for events'
      ),
    ),
    'view own event activity' => array(
      'title' => t(
        "View own event activity"
      ),
      'description' => t(
        'Let user see own user profile event related activity in profile view.'
      ),
    ),
    'view current user event activity' => array(
      'title' => t(
        "View current user's event activity"
      ),
      'description' => t(
        'Let user see currently viewed user profile event related activity in profile view'
      ),
    ),
  );
}

/**
 * Implements hook_image_default_styles().
 */
function webform_events_image_default_styles() {
  $styles = array();

  // webform_events image style.
  $styles['webform_events'] = array(
    'name'                      => 'webform_events',
    'effects'                   => array(
      1                         => array(
        'label'                 => 'Scale',
        'help'                  => 'Scaling will maintain the aspect-ratio of the original image. If only a single dimension is specified, the other dimension will be calculated.',
        'effect callback'       => 'image_scale_effect',
        'dimensions callback'   => 'image_scale_dimensions',
        'form callback'         => 'image_scale_form',
        'summary theme'         => 'image_scale_summary',
        'module'                => 'image',
        'name'                  => 'image_scale',
        'data'                  => array(
          'width'               => '250',
          'height'              => '',
          'upscale'             => 0,
        ),
        'weight'                => '1',
      ),
    ),
  );
  return $styles;
}

/**
 * Implements hook_entity_view().
 */
function webform_events_entity_view($entity, $type) {
  // Check is show setting enabled.
  $show = variable_get('webform_events_show_profile');

  if ($show == 1) {
    // Load user.
    global $user;

    // Get current path.
    $path = current_path();
    $check = "user/" . $user->uid;

    // Does user have right to view every profile activity?.
    if (user_access('view own event activity')) {
      $profile = stristr($path, "user/");
    }

    // Is own profile and/or has right to view profile activity.
    if ($path == $check || !empty($profile)) {
      // Load webform functions.
      module_load_include('inc', 'webform', 'includes/webform.submissions');

      // Get viewed profile uid.
      $uid = $entity->uid;

      // Get submissions related to user.
      $user_submissions = webform_get_submissions($filters = array('uid' => $uid));

      $rows = _webform_events_submission_array($user_submissions);

      // Set headers.
      $header = array(
        t('Event name'),
        t('Action'),
        t('View'),
      );

      // Let's build a pager, first how many per page.
      $per_page = variable_get('webform_events_default_profile_pager');
      // Get current page.
      $current_page = pager_default_initialize(count($rows), $per_page);
      // Break row data to chunks defined by $per_page.
      $chunks = $rows;
      $chunks = array_chunk($rows, $per_page, TRUE);
      if (!empty($chunks)) {
        $chunks = $chunks[$current_page];
      }
      // Theme table actual data by chunks.
      $form = theme('table', array(
          'header' => $header,
          'rows' => $chunks,
          'attributes' => array('width' => '100%'),
      ));
      // Add pager to markup.
      $form .= theme('pager', array('quantity', count($rows)));

      // Insert markup to user profile.
      $extra = array(
        '#markup' => $form,
        '#weight' => 99,
      );

      // If is own profile. $uid is entity uid here.
      if ($uid == $user->uid) {
        $entity->content['summary']['events'] = $extra;
      }

      // If has rights to view all profiles. Else nothing.
      if (user_access('view current user event activity')) {
        $entity->content['summary']['events'] = $extra;
      }
    }
  }
}

/**
 * Implements hook_form_alter().
 */
function webform_events_form_alter(&$form, &$form_state, $form_id) {
  // This is to get rid of notices from undefined indexes.
  if (!isset($form['#node'])) {
    return;
  }

  // Check that we are dealing with webform_events.
  $nodetype = $form['#node']->type;

  if ($nodetype == "webform_events") {
    // Return current path.
    $path = current_path();
    $add = "node/add/webform-event";

    // We are on add node page.
    if ($path == $add) {
      // Get fields.
      $field_list = field_info_fields();
      foreach ($field_list as $field) {
        if (stristr($field['field_name'], "field_webform_events")) {
          $field_type = str_replace("field_webform_events_", "", $field['field_name']);
          $var_name = "webform_events_default_" . $field_type;
          $lang = $form[$field['field_name']]['#language'];

          // Set default values for fields.
          if ($field_type == "email" || $field_type == "participants") {
            $form[$field['field_name']][$lang]['0']['value']['#default_value'] = variable_get($var_name);
          }
          elseif ($field_type == "overbooking" || $field_type == "limit") {
            $form[$field['field_name']][$lang]['#default_value'] = variable_get($var_name);
          }
        }
      }
    }

    // Add validation.
    array_unshift($form['#validate'], 'webform_events_validate');

    // CHECKS AND MISCALLENEOUS.
    // Ready webform functions.
    module_load_include('inc', 'webform', 'includes/webform.submissions');

    // Load node. Can be done via node_load() but data is available already.
    $node = $form['#node'];

    // Get nid.
    $nid = "";
    if (isset($node->nid)) {
      $nid = $node->nid;
    }

    // BASE INFORMATION SETUP.
    // Is signup limited?.
    $limit = field_view_field('node', $node, 'field_webform_events_limit');
    if (isset($limit['#items'])) {
      $limit = $limit['#items']['0']['value'];
    }

    // Get Participant limit.
    $participants = "";
    $participant_field = field_view_field('node', $node, 'field_webform_events_participant');
    if (isset($participant_field['#items'][0]['value'])) {
      $participants = $participant_field['#items'][0]['value'];
    }

    // Check overbooking status.
    $overbooking = field_view_field('node', $node, 'field_webform_events_overbooking');
    if (isset($overbooking['#items'])) {
      $overbooking = $overbooking['#items']['0']['value'];
    }

    // Do we change titles?.
    $change_titles = 0;
    $change_titles = variable_get('webform_events_change_titles');
    $started = 1;
    $ended = 0;

    // Event slot information.
    $slot_info = _webform_events_slot_info($nid, $participants);
    $used_slots = $slot_info['used'];
    $free_slots = $slot_info['free'];
    $queue_slots = $slot_info['queued'];

    // Assign check for node view and for the case node is referenced.
    $check = "node/" . $nid;
    $node_ref_check = $form['#action'];
    $ref_check = "node" . str_replace("/node", "", $node_ref_check);

    // Non-admin side form handling.
    if ($path == $check || $path == $ref_check) {

      // Get all results. TODO: Could this be done via submission data?.
      $actions = db_select('webform_submitted_data', 'data')
                  ->fields('data', array('data'))
                  ->condition('data.nid', $nid, '=')
                  ->condition('data.data', array('cancel', 'queue'), 'IN');
      $actions->addExpression('COUNT(nid)', 'count');
      $actions->groupBy('data.data');
      $result = $actions->execute();

      // Setup vars.
      $cancel = $full = 0;
      $queue_notice = "";

      // If event is limited, limit slots.
      if ($limit == 1 || ($limit == 0 && $overbooking == 0 && $queue_slots > 0 && $used_slots >= $participants) || ($limit == 0 && $overbooking == 0 && $queue_slots > 0 && $used_slots < $participants) || $limit == 0 && $overbooking == 0 && $queue_slots == 0 && $used_slots == $participants) {
        $form['submitted']['event_slots']['#type'] = "value";
        $form['submitted']['event_slots']['#value'] = 1;
        hide($form['submitted']['event_slots']);
      }

      while ($action = $result->fetchAssoc()) {
        switch ($action['data']) {

          case 'cancel':
            $cancel = $action['count'];
            break;

          default:
            break;
        }
      }

      // Handle full event.
      if ($used_slots >= $participants && $participants > 0) {
        // Append this to normal page title.
        $full_title = $form['#node']->title . " " . t("- Event is full.");

        /* Participation limit is full, modify page title and unset
         * the form until there is more space. User can free up
         * space to course by deleting submissions if he wants to.
         */
        drupal_set_title($full_title);

        // Disable signup.
        unset($form['submitted']['event_action']['#options']['signup']);

        /* Notify user that submission limit has been reached.
         * Clear possible previous messages.
         */
        if (!empty($_SESSION['messages'])) {
          unset($_SESSION['messages']);
        }

        drupal_set_message(t('This event is currently full. However you can queue for the event.'), 'warning');

        // Flag event full.
        $full = 1;

        // Set queue message.
        $queue_notice = "<br/>" . t("Event is full. However you can queue.");

        // Limit slots. TODO: This can be removed?.
        if ($overbooking == 0) {
          $form['#node']->content['webform']['#form']['submitted']['event_slots']['#options'] = array(1 => 1);
        }
      }

      /* Don't allow signing up if there is people in queue even
  	   * if there is space on course, in other words - maintainer
  	   * has not updated someone from queue to course or is currently doing so.
  	   * This protects course from signups while maintainer is
  	   * working on with signups.
       */
      elseif ($used_slots < $participants && $participants > 0 && $queue_slots > 0) {
        // Unset signup option.
        unset($form['submitted']['event_action']['#options']['signup']);
        unset($_SESSION['messages']);

        // Inform user.
        drupal_set_message(t('This event has free slots but has queue. At this time you can only queue for the event.'), 'warning');

        // Limit slots unless overbooking is allowed.
        if ($overbooking == 0) {
          $form['#node']->content['webform']['#form']['submitted']['event_slots']['#options'] = array(1 => 1);
        }
      }
      else {
        // Unset queue so it's not an option when there is space on course.
        unset($form['submitted']['event_action']['#options']['queue']);
      }

      // DATE.
      // Let's check if ending date has passed and disable submission.
      if (!user_access('view expired events')) {
        // Convert starting date to epoch time stamp for comparison.
        // Field must have no timezone for this to work.
        $start_date_field = field_view_field('node', $node, 'field_webform_events_start_date');
        $start_date = "";

        if (isset($start_date_field['#items'][0]['value'])) {
          $start_date = strtotime($start_date_field['#items'][0]['value']);
        }

        // Convert ending date to epoch time stamp for comparison.
        // Field must have no timezone for this to work.
        $end_date_field = field_view_field('node', $node, 'field_webform_events_end_date');
        $end_date = "";

        if (isset($end_date_field['#items'][0]['value'])) {
          $end_date = strtotime($end_date_field['#items'][0]['value']);
        }

        // Get current date and set variable for comparison.
        $today = getdate();

        // Get last key epoch value from date array for epoch stamp comparison.
        $today = array_slice($today, -1, 1, TRUE);
        $today = $today[0];

        if ($today <= $start_date && !empty($start_date)) {
          unset($form['actions']['submit']);
          unset($form['submitted']);
          $started = 0;

          if ($change_titles == 1) {
            $open_date = field_view_field('node', $node, 'field_webform_events_start_date');
            $open_date = $open_date['#items']['0']['value'];
            // Event has not started, modify page title.
            $due_title = $form['#node']->title . " " . t("- Event opens on @day at @time", array(
              "@day" => date("d-m-Y", strtotime($open_date)),
              "@time" => date("H:i", strtotime($open_date)),
            ));
            drupal_set_title($due_title);
          }
        }

        /* Compare date today to subscription end date and disable edit button
         * if it is equal or greater than end date. If epoch value of today is
         * greater or same than epoch value of end date disable submit.
         */
        if ($today >= $end_date && !empty($end_date)) {
          // Unset form components.
          unset($form['actions']['submit']);
          unset($form['submitted']);
          $ended = 1;

          if ($change_titles == 1) {
            // Due date has passed, modify page title.
            $due_title = $form['#node']->title . " " . t("- Event closed.");
            drupal_set_title($due_title);

            // Notify user that due date for signups has passed.
            // Clear possible previous messages.
            if (!empty($_SESSION['messages'])) {
              unset($_SESSION['messages']);
            }

            // Inform user.
            drupal_set_message(t('Ending date for event subscriptions has passed. Event is closed.'), 'warning');
          }
        }
      }

      // MARKUP FOR THE PAGE.
      // Generate markup.
      if (isset($form['submitted']['event_slots']['#description'])) {
        // Update event slots description field to show slots.
        $description = $form['submitted']['event_slots']['#description'];
        $form['submitted']['event_slots']['#description'] = $description . '. ' . t('Free slots:') . " " . $free_slots . $queue_notice;
      }

      // Let's update options to match free slots.
      if ($full == 0 && $limit == 0) {
        $form['submitted']['event_slots']['#options'] = array();
        $i = 0;
        while ($i < $free_slots) {
          $i++;
          $form['submitted']['event_slots']['#options'][$i] = $i;
        }
      }

      // Allow multislots when there is queue and overbooking is allowed.
      elseif ($full == 1 && $overbooking == 1 && $limit == 0) {
        $form['submitted']['event_slots']['#options'] = array();
        $i = 0;
        while ($i < $participants) {
          $i++;
          $form['submitted']['event_slots']['#options'][$i] = $i;
        }
      }

      else {
        $form['submitted']['event_slots']['#options'] = array(1 => 1);
      }

      // How many are currently participating for markup.
      if ($started == 1 && $ended == 0) {
        $current_participants = t("Currently participating %used_slots / %participants.", array('%used_slots' => $used_slots, '%participants' => $participants));

        // If there is queue, tell how much.
        if ($queue_slots > 0) {
          $current_participants .= " " . t("There is %queue person(s) in the queue.", array('%queue' => $queue_slots));
        }
      }
      else {
        $current_participants = t("Signups are closed.");
      }

      // Has someone canceled?.
      if ($cancel > 0 && user_access('show webform administrator messages')) {
        drupal_set_message(t('NOTICE: There is participant(s) that have canceled their participation. <a href="/node/@nid/manage-event">Remove their signups to free up space from here.</a>', array('@nid' => $nid)), 'warning');
      }

      // Move information to markup.
      if (isset($participant_field['#items'][0]['value'])) {
        $form['#node']->content['field_webform_events_participant'][0]['#markup'] = $current_participants;
      }

      // Custom validation to prevent overflowing.
      array_unshift($form['#validate'], 'webform_events_validate');
    }

    // Administration side enchancements.
    if ($path != $check && $path != $ref_check) {
      // Let's give a event_action -compononent a slight protection.
      if (isset($form['form_token']['#id']) && $form['form_token']['#id'] == 'edit-webform-components-form-form-token') {
        // Unset components to prevent modification.
        unset($form['#node']->webform['components']['1']);
        unset($form['#node']->webform['components']['2']);

        // Instant diet to also remove lingering weight.
        unset($form['components']['1']);
        unset($form['components']['2']);
      }

      // Markups for admin side go below this.
      if (isset($form['submitted']['event_slots']['#description'])) {
        $description = $form['submitted']['event_slots']['#description'];
        // This applies only to admin side as existing submissions have a value.
        // Notify current slots reserved by signup submission.
        $existing = 0;

        // If is a signup.
        if (isset($form['submitted']['event_action']) && $form['submitted']['event_action']['#default_value'] == "signup") {
          $existing = $form['submitted']['event_slots']['#default_value'];
        }

        // Get max available and output it.
        $max = $existing + $free_slots;
        $form['submitted']['event_slots']['#description'] = t("This signup has currently reserved: @slots slots. You can update up to @max slots.", array('@slots' => $existing, '@max' => $max));
        if ($overbooking == 0) {
          array_unshift($form['#validate'], 'webform_events_validate');
        }
      }
    }
  }
}

/**
 * Implements hook_validate().
 */
function webform_events_validate($form, &$form_state) {
  // Declare nid and participant limit.
  $node = $form['#node'];
  $nid = "";
  if (!empty($node->nid)) {
    $nid = $node->nid;
  }

  // Get Participant limit.
  $participants = "";
  $participant_field = field_view_field('node', $node, 'field_webform_events_participant');
  if (isset($participant_field['#items'][0]['value'])) {
    $participants = $participant_field['#items'][0]['value'];
  }

  // Get used slots.
  $used_slots = 0;
  $data = _webform_events_slot_info($nid, $participants);
  $used_slots = $data['used'];

  // If editing the form, take into account existing slots submission has.
  $existing = "";

  if (isset($form['submitted']['event_slots']['#default_value']) && !empty($form['submitted']['event_slots']['#default_value']) && $form['submitted']['event_action']['#default_value'] == "signup") {
    $existing = $form['submitted']['event_slots']['#default_value'];
  }

  // Calculate total used slots.
  if (isset($form_state['values']['submitted']['event_slots'])) {
    $used_slots = $used_slots + $form_state['values']['submitted']['event_slots'] - $existing;
  }

  // If action would overflow the event.
  if ($used_slots > $participants && $participants > 0 && $form_state['values']['submitted']['event_action'] == "signup") {
    // Set new value to prevent error message.
    $form['submitted']['event_action']['#webform_component']['value'] = "queue|Queue";
    $path = current_path();

    // Build error string.
    $nodepath = "node/" . $nid;
    $overbooking = field_view_field('node', $node, 'field_webform_events_overbooking');
    $overbooking = $overbooking['#items']['0']['value'];

    // Admin side.
    if ($path != $nodepath && $overbooking == 0) {
      $error_string = t("Unfortunately event has become full or cannot accept requested @slots slots. You can't signup @slots slots at this moment. However you can choose less slots or queue for the event if there is no slots left.", array('@slots' => $form_state['values']['submitted']['event_slots']));
      form_set_error('event_slots', $error_string);
      // Set new value to prevent error message.
      $form_state['complete form']['submitted']['event_slots']['#value'] = "";
    }
  }

  // Email validation for node/add.
  $email = "";
  if (isset($form_state['complete form']['field_webform_events_email']['#language'])) {
    $lang = $form_state['complete form']['field_webform_events_email']['#language'];
    if (isset($form['field_webform_events_email'][$lang]['0']['value']['#value'])) {
      $email = $form['field_webform_events_email'][$lang]['0']['value']['#value'];
      if (!filter_var($email, FILTER_VALIDATE_EMAIL) && !empty($email)) {
        form_set_error('field_webform_events_email', t("Please provide a valid email address."));
      }
    }
  }
}

/**
 * Implements hook_node_insert().
 */
function webform_events_node_insert($node) {
  if ($node->type == "webform_events") {
    _webform_events_fields_insert($node);
    _webform_events_email_update($node);
  }
}

/**
 * Implements hook_node_update().
 */
function webform_events_node_update($node) {
  if ($node->type == "webform_events") {
    _webform_events_email_update($node);
  }
}

/**
 * Updates email to webform email submissions.
 */
function _webform_events_email_update($node) {
  $email = "";
  $email_field = field_view_field('node', $node, 'field_webform_events_email');

  if (isset($email_field['#items']['0']['value'])) {
    $email = $email_field['#items']['0']['value'];
  }

  // TODO: Implement db_delete() when email value is left empty + record exists.
  if (!empty($email)) {
    $check = db_select('webform_emails')
              ->condition('nid', $node->nid, '=')
              ->condition('eid', 1, '=')
              ->fields('webform_emails')
              ->execute()
              ->fetchAll();

    if (empty($check)) {
      db_insert('webform_emails')
        ->fields(array(
          'nid' => $node->nid,
          'eid' => 1,
          'email' => $email,
          'subject' => t('New activity on event: @event', array("@event" => $node->title)),
          'from_name' => $node->title,
          'from_address' => 'default',
          'template' => 'default',
          'excluded_components' => '',
          'html' => '0',
          'attachments' => '0'))
        ->execute();
    }
    else {
      db_update('webform_emails')
        ->condition('nid', $node->nid, '=')
        ->condition('eid', 1, '=')
        ->fields(array(
          'email' => $email,
          ))
        ->execute();
    }
  }
}

/**
 * Field inserting functionality.
 */
function _webform_events_fields_insert($node) {
  /* Here we will force signup action field (and possibly other fields)
   * that is default for all forms when they're created.
   * When user adds component to the webform, select element for action
   * to take is generated.
   */
  if ($node->type == "webform_events") {
    // Enable webform.
    db_insert('webform')
      ->fields(array(
        'nid'           => $node->nid,
        'confirmation'  => "",
        'status'        => 1,
      ))
      ->execute();

    // Get roles.
    $user_roles = user_roles();
    $i = 1;
    foreach ($user_roles as $rid) {
      // Allow sending of the webform.
      db_insert('webform_roles')
        ->fields(array(
          'nid'           => $node->nid,
          'rid'           => $i,
        ))
        ->execute();
      $i++;
    }

    /* Include webform component functions. If we don't do this,
     * we can't use webform functions needed to create element.
     */
    module_load_include('inc', 'webform', 'includes/webform.components');

    // Check if component exists by doing database query and checking cid=1.
    $dbresult = db_select('webform_component', 'comps')
                  ->fields('comps')
                  ->condition('cid', 1, '=')
                  ->condition('nid', $node->nid, '=')
                  ->execute()
                  ->fetchAll();

    // It doesn't exists, create it.
    if (!$dbresult) {
      $component_action = array(
        'cid'           => 1,
        'pid'           => 0,
        'nid'           => (int) $node->nid,
        'form_key'      => 'event_action',
        'name'          => t('Select an action'),
        'type'          => 'select',
        'extra'         => array(
          'description' => 'Select an action to perform',
          'items'       => 'signup|' . t('Signup') . "\n" . 'queue|' . t('Queue') . "\n" . 'cancel|' . t('Cancel'),
        ),
        'mandatory'     => 1,
        'weight'        => -99,
        'page_num'      => 1,
      );
      // Insert action component to webform.
      webform_component_insert($component_action);

      $component_slots      = array(
        'cid'               => 2,
        'pid'               => 0,
        'value'             => '',
        'nid'               => (int) $node->nid,
        'form_key'          => 'event_slots',
        'name'              => t('Slots'),
        'type'              => 'number',
        'extra'             => array(
          'description'     => t('Input the slots you want to reserve'),
          'title_display'   => 'inline',
          'type'            => 'select',
          'decimals'        => '0',
          'separator'       => '',
          'point'           => '.',
          'min'             => '1',
          'max'             => '100',
          'excludezero'     => '0',
        ),
        'mandatory'         => 1,
        'weight'            => -98,
        'page_num'          => 1,
      );
      // Insert slots component to webform.
      webform_component_insert($component_slots);
    }
  }
}

/**
 * Implements hook_webform_submission_delete().
 */
function webform_events_webform_submission_delete($node, $submission) {
  if ($node->type == "webform_events") {
    /* Get sid of the first in the queue.
     * If there is someone in the queue and there is free space,
     * let event moderator know about it.
     */
    $queue_first_sid = db_select('webform_submitted_data', 'queue')
                        ->fields('queue', array('sid'))
                        ->condition('data', 'queue', '=')
                        ->condition('nid', $node->nid, '=')
                        ->execute()
                        ->fetchAll();

    // There is someone in queue.
    if (!empty($queue_first_sid)) {
      $first_queued = array();
      $first_queued = min($queue_first_sid);
      $first_queued = $first_queued->sid;
      unset($_SESSION['messages']);
      drupal_set_message(t('You have a person waiting in queue. You might want to update him/her to signed up status <a href="submission/@first/edit?destination=node/@nid/manage-event">here</a>', array('@first' => $first_queued, '@nid' => $node->nid)));
    }
  }
}

/**
 * Implements hook_webform_component_insert().
 */
function webform_events_webform_component_insert($component) {
  // We have to check this doesn't trigger on node creation and cause data loss.
  $path = current_path();
  $path = substr($path, 0, 8);
  module_load_include('inc', 'webform', 'includes/webform.submissions');

  if ($path != "node/add") {
    $submissions = webform_get_submissions($component['nid']);
    foreach ($submissions as $submission) {

      if ($submission->nid == $component['nid']) {
        db_insert('webform_submitted_data')
          ->fields(array(
            'nid'    => $component['nid'],
            'sid'    => $submission->sid,
            'cid'    => $component['cid'],
            'no'     => 0,
            'data'   => "",
        ))
          ->execute();
      }
    }
  }
}

/**
 * This function checks the node type combined with access.
 */
function _webform_events_nodetype_check($node) {
  global $user;
  $manage = variable_get('webform_events_manage_page');
  if ($manage == 1 && $node->uid != $user->uid) {
    return FALSE;
  }
  else {
    return $node->type == 'webform_events' && user_access('administer events');
  }
}

/**
 * This function get's slot info.
 */
function _webform_events_slot_info($nid, $participants) {
  module_load_include('inc', 'webform', 'includes/webform.submissions');
  $submission_data = webform_get_submissions($nid);
  $sum_array = $sum_array_queue = array();
  // Get array for calculation.
  foreach ($submission_data as $submission) {
    // Webform 3.18 and 4.
    if (isset($submission->data[1]['0']) && !isset($submission->data[1]['value'])) {
      if ($submission->data[1]['0'] == "signup") {
        $sum_array[] = $submission->data[2]['0'];
      }
      if ($submission->data[1]['0'] == "queue") {
        $sum_array_queue[] = $submission->data[2]['0'];
      }
    }
    if (isset($submission->data[1]['value'])) {
      if ($submission->data[1]['value']['0'] == "signup") {
        $sum_array[] = $submission->data[2]['value']['0'];
      }
      if ($submission->data[1]['value']['0'] == "queue") {
        $sum_array_queue[] = $submission->data[2]['value']['0'];
      }
    }
  }
  $used_slots         = array_sum($sum_array);
  $queue_slots        = array_sum($sum_array_queue);
  $free_slots         = $participants - $used_slots;
  return array(
    'used' => $used_slots,
    'free' => $free_slots,
    'queued' => $queue_slots,
  );
}

/**
 * Custom function to build submission array for theme table.
 */
function _webform_events_submission_array($user_submissions) {
  $rows = array();
  $i = 1;
  // Loop submissions.
  foreach ($user_submissions as $submission) {
    // 3.18 and 4 webform compatibility.
    $array_path = $submission->data[1];
    if (isset($submission->data[1]['value'])) {
      $array_path = $submission->data[1]['value'];
    }
    // Load submission related event.
    $node = node_load($submission->nid);
    // Check we are dealing with an event.
    if ($node->type == "webform_events") {
      // Get title.
      $rows[$i][] = $node->title;

      // Get action.
      $rows[$i][] = t(":action", array(":action" => $array_path['0']));

      // Output a link to event.
      $rows[$i][] = l(t('View event'), 'node/' . $submission->nid, array('query' => drupal_get_destination()));
      $i++;
    }
  }
  return array_reverse($rows);
}
