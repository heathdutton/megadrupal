<?php

/**
 * @file
 * PageFlip main module.
 */

include_once 'pageflip.features.inc';

// Machine readable names of our content types.
define('PAGEFLIP_BOOK_CONTENT_TYPE', 'pageflip_book');
define('PAGEFLIP_CHAPTER_CONTENT_TYPE', 'pageflip_chapter');
define('PAGEFLIP_PAGE_CONTENT_TYPE', 'pageflip_page');
// Not a real content type name.
define('PAGEFLIP_AD_FAKE_CONTENT_TYPE', 'PAGEFLIP-AD-CONTENT');

// Keys to be returned by implementors of hook_pageflip_viewer_settings()
define('PAGEFLIP_VIEWER_MEGAZINE3', 'pageflip_mz3_viewer');
define('PAGEFLIP_VIEWER_HTML', 'pageflip_html_viewer');

// Resolutions must be in the WIDTHxHEIGHT format exactly, because they're
// exploded along 'x'.
define('PAGEFLIP_VIEWER_LOW_RES', '1280x720');
define('PAGEFLIP_VIEWER_HIGH_RES', '1920x1080');

// Taxonomy IDs for our ad groups -- @todo make these Drupal variables.
define('PAGEFLIP_MEGAZINE3_AD_GROUP', 1);
define('PAGEFLIP_HTML_AD_GROUP', 2);

// Options used by viewer modules when theming.
define('PAGEFLIP_FRONT_COVER', 0);
define('PAGEFLIP_NORMAL_PAGE', 1);
define('PAGEFLIP_BACK_COVER', 2);

/**
 * Implements hook_init().
 *
 * Detect user agent so viewers can implement special behavior for mobile
 * devices. So far we only detect Apple devices.
 */
function pageflip_init() {
  global $_SERVER;
  $mobiles = array('iPhone', 'iPad', 'iPod');
  foreach ($mobiles as $device) {
    if (strpos($_SERVER['HTTP_USER_AGENT'], $device) !== FALSE) {
      pageflip_is_mobile(TRUE);
      pageflip_mobile_device($device);
      break;
    }
  }
}

/**
 * Returns TRUE if the user's browsing with a mobile device.
 * (This function also used to set the 'is_mobile' flag.)
 */
function pageflip_is_mobile($set = NULL) {
  static $is_mobile = FALSE;
  if (isset($set)) {
    $is_mobile = $set;
  }
  return $is_mobile;
}

/**
 * Returns which mobile device we're rendering for.
 * (This function also used to set the mobile device.)
 */
function pageflip_mobile_device($set = NULL) {
  static $mobile_device = '';
  if (isset($set)) {
    $mobile_device = $set;
  }
  return $mobile_device;
}

/**
 * Implements hook_help().
 */
function pageflip_help($path, $arg) {
  switch ($path) {
    // A simple notification for users if there are no pages created.
    case 'node/add/pageflip-book':
      if (!db_query("SELECT count(*) FROM {node} WHERE type = 'pageflip_page'")->fetchField()) {
        drupal_set_message(t('At least one PageFlip Page needs to be created first to act as the cover of the book.'), 'error');
      }
      $add_page = 'node/add/pageflip-page';
      $link = l(t('Create a new page'), $add_page, array('query' => array('destination' => $path)));
      $text = 'A PageFlip Page must be created first to act as the cover. !link';
      return '<p>' . t($text, array('!link' => $link)) . '</p>';
  }
}

/**
 * Implements hook_menu().
 */
function pageflip_menu() {
  $items = array();
  $items['admin/config/media/pageflip'] = array(
    'title' => 'PageFlip',
    'description' => 'Manage PageFlip',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('pageflip_settings_form'),
    'access arguments' => array('administer pageflip'),
    'file' => 'pageflip.admin.inc',
  );
  $items['admin/config/media/pageflip/settings'] = array(
    'title' => 'Settings',
    'description' => 'Manage PageFlip global settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('pageflip_settings_form'),
    'access arguments' => array('administer pageflip'),
    'file' => 'pageflip.admin.inc',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  return $items;
}

/**
 * Implements hook_permission().
 */
function pageflip_permission() {
  return array(
    'administer pageflip' => array(
      'title' => t('Administer PageFlip settings'),
      'description' => t('Grants ability to modify all settings under Configuration > Media > PageFlip.'),
    ),
  );
}

/**
 * Implements hook_node_view().
 */
function pageflip_node_view($node, $view_mode, $langcode) {
  // Only run if we're on a node-view page.
  if (!($view_mode == 'full' && ($menu_ob = menu_get_object()) && $menu_ob->nid == $node->nid)) {
    return;
  }

  // Sanity check: don't try to render a book during a cron run (i.e. search
  // indexing) because book rendering may call exit(). This check probably
  // isn't necessary, but why not.
  global $_SERVER, $_GET;
  if (strpos($_SERVER['SCRIPT_FILENAME'], 'cron.php') !== FALSE ||
      strpos($_GET['q'], 'admin/reports/status') !== FALSE) {
    return;
  }

  $deny = FALSE;
  // Don't let non-admins access node-view page for pages.
  if ($node->type === PAGEFLIP_PAGE_CONTENT_TYPE && !user_access('administer pageflip')) {
    $deny = TRUE;
  }

  // @todo: Factor out all the access checks into another function.
  if ($node->type === PAGEFLIP_CHAPTER_CONTENT_TYPE) {
    // Redirect to this chapter in the book it's actually in, if any, and
    // only if it's a published chapter or the user is an admin.
    if ($node->status || user_access('administer pageflip')) {
      if ($book_node = pageflip_get_book_from_chapter($node)) {
        if ($chapter_index = pageflip_get_chapter_index($book_node, $node)) {
          drupal_goto('node/' . $book_node->nid, array('fragment' => 'chapter' . $chapter_index));
        }
      }
    }

    // If we got here, we didn't redirect, so don't allow access.
    $deny = TRUE;
  }

  if ($deny) {
    drupal_access_denied();
    exit;
  }

  if ($node->type !== PAGEFLIP_BOOK_CONTENT_TYPE) {
    return;
  }

  $mz3 = module_exists('pageflip_mz3_viewer');
  $html = module_exists('pageflip_html_viewer');

  $settings = pageflip_get_viewer_settings();
  $is_mobile = pageflip_is_mobile();

  // Should we invoke the MegaZine3 viewer?
  if ($mz3 && !$is_mobile && ($settings['viewer'] === PAGEFLIP_VIEWER_MEGAZINE3 || !$html)) {
    $content = pageflip_mz3_viewer_view($node);
  }
  elseif ($html) {
    $resolution = $is_mobile ? 'low' : NULL;
    $content = pageflip_html_viewer_view($node, $resolution);
  }
  else {
    drupal_set_message(t('Warning: No PageFlip viewer modules are enabled. Please enable a viewer module.'), 'error');
  }
  $node->content['body']['#markup'] = $content;
}

/**
 * Finds the book that owns the given chapter node or returns NULL if there is
 * none. If the given chapter belongs to more than one book for some reason,
 * then nobody but the DB knows which book you're gonna get.
 *
 * @param object $node
 *   Chapter whose parent (book) we seek.
 *
 * @return object
 *   Node object for the chapter's book.
 */
function pageflip_get_book_from_chapter($node) {
  if ($node->type !== PAGEFLIP_CHAPTER_CONTENT_TYPE) {
    return NULL;
  }
  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', 'pageflip_book')
    ->fieldCondition('field_pageflip_chapters', 'nid', $node->nid, '=');
  $entities = $query->execute();
  if (!empty($entities)) {
    $node = array_pop($entities['node']);
    return node_load($node->nid);
  }
  return NULL;
}

/**
 * Finds the index of a chapter from its book.
 *
 * @param object $book
 *   Book node object.
 * @param object $chapter
 *   Chapter node object.
 *
 * @return int|NULL
 *   Index of chapter or NULL if chapter isn't found in book.
 */
function pageflip_get_chapter_index($book, $chapter) {
  // 0th chapter is "opening pages", so start at 1
  $index = 1;
  $chapters = field_get_items('node', $book, 'field_pageflip_chapters');
  foreach ($chapters as $noderef) {
    if ($noderef['nid'] == $chapter->nid) {
      return $index;
    }
    $index++;
  }
  return NULL;
}

/**
 * Loads all of a PageFlip Book node's chapters and pages.
 *
 * @param object $book
 *   Book node object.
 *
 * @return array
 *   An array of chapter arrays.
 */
function pageflip_load_book($book) {
  $chapters = array();
  $chapters[0] = array();
  $chapters[0]['chapter'] = NULL;
  $chapters[0]['pages'] = array();

  $cover = field_get_items('node', $book, 'field_pageflip_cover');
  $chapters[0]['pages'][] = node_load($cover[0]['nid']);

  // Load the opening pages as part of "chapter zero".
  $opening_pages = field_get_items('node', $book, 'field_pageflip_opening_pages');
  if ($opening_pages) {
    foreach ($opening_pages as $noderef) {
      $chapters[0]['pages'][] = node_load($noderef['nid']);
    }
  }

  // Load all the actual chapters.
  $chapters_field = field_get_items('node', $book, 'field_pageflip_chapters');
  if ($chapters_field) {
    $index = 1;
    foreach ($chapters_field as $noderef) {
      if ($noderef['nid']) {
        $chapter = node_load($noderef['nid']);
        $chapters[$index] = array();
        $chapters[$index]['chapter'] = $chapter;

        // Load all of the chapter's pages.
        $chapters[$index]['pages'] = array();
        $pages = field_get_items('node', $chapter, 'field_pageflip_pages');
        foreach ($pages as $page_noderef) {
          $chapters[$index]['pages'][] = node_load($page_noderef['nid']);
        }
        $index++;
      }
    }
  }

  return $chapters;
}

/**
 * Allows caller to specify what viewer is active on this page request.
 * Usually the user's preferred viewer is active, but the preferred viewer
 * can be overridden with the right URL structure (see the viewers'
 * hook_menu() implementations for the override paths).
 *
 * @param string $viewer
 *   (optional) The viewer (module name) to set as currently active.
 * @param object $node
 *   (required if $viewer) The book node being viewed.
 *
 * @return string
 *   Currently active pageflip viewer.
 */
function pageflip_set_active_viewer($viewer = NULL, $node = NULL) {
  static $active_viewer = PAGEFLIP_VIEWER_MEGAZINE3;
  if ($viewer) {
    $active_viewer = $viewer;
    module_invoke_all('pageflip_viewer', $viewer, $node);
  }
  return $active_viewer;
}

/**
 * Load the embedding code for an advertisement.
 *
 * @return array
 *   An array of ads, where each entry is the ad's markup.
 */
function pageflip_ad($quantity = 1) {
  /* Figure out which ad group to pull ads from */
  $active_viewer = pageflip_set_active_viewer();
  if ($active_viewer === PAGEFLIP_VIEWER_MEGAZINE3) {
    $ad_group = PAGEFLIP_MEGAZINE3_AD_GROUP;
  }
  else {
    $ad_group = PAGEFLIP_HTML_AD_GROUP;
  }

  $options = array('ad_display' => 'raw');
  $use_ads = module_exists('ad') && variable_get('pageflip_use_ads', module_exists('ad_pageflip_mz3'));
  $start_chapters_on_right = variable_get('pageflip_start_chapters_on_right', FALSE);
  $ads = array();
  for (; $quantity > 0; $quantity--) {
    if (!$use_ads) {
      // Use blank pages to substitute for ads if we wish to only start
      // chapters on right-side pages -- bit of a hack that this is *here*,
      // but this works to prevent unwanted blanks between chapters.
      if ($start_chapters_on_right) {
        $ads[] = NULL;
      }
      continue;
    }
    $ad_content = ad($ad_group, 1, $options);
    $ad = new stdClass();
    $ad->type = PAGEFLIP_AD_FAKE_CONTENT_TYPE;
    if ($ad_group === PAGEFLIP_MEGAZINE3_AD_GROUP) {
      // Remove ad module's HTML.
      $ad_content = preg_replace('#</div>#', '', $ad_content);
      $ad_content = preg_replace('#<div class="ad-image-counter"><img src="[^"]*" height="0" width="0" alt="view counter" />#', '', $ad_content);
      $ad_content = preg_replace('#<!--.*-->#U', '', $ad_content);
    }
    $ad->content['body']['#value'] = $ad_content;
    $ads[] = $ad;
  }
  return $ads;
}


/**
 * Retrieves settings array (for settings that are potentially user dependent).
 */
function pageflip_get_viewer_settings() {
  static $settings = NULL;
  if ($settings) {
    return $settings;
  }

  // Look for a module that wants to define settings for us. there *should*
  // only be one module--so, use result from first responder if there are >1.
  if (!($settings = module_invoke_all('pageflip_viewer_settings'))) {
    // No responders. Use defaults.
    $settings = array(
      'viewer' => PAGEFLIP_VIEWER_MEGAZINE3,
      'resolution' => PAGEFLIP_VIEWER_LOW_RES,
    );
  }
  return $settings;
}

/**
 * Generates an image URL from a given page node and 'high' or 'low' resolution.
 */
function pageflip_page_image_url($page, $resolution = 'high') {
  $image_high = field_get_items('node', $page, 'field_pageflip_page_image_high');
  $image_low  = field_get_items('node', $page, 'field_pageflip_page_image_low');

  $uri = $resolution == 'high' ? $image_high[0]['uri'] : $image_low[0]['uri'];

  if ($style = variable_get('pageflip_' . $resolution . '_resolution_preset', 0)) {
    if ($style = image_style_load(NULL, $style)) {
      if ($url = image_style_url($style['name'], $uri)) {
        return $url;
      }
    }
  }
  return file_create_url($uri);
}
