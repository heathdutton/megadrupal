<?php

/**
 * @file
 * PageFlip MegaZine3 integration: MegaZine3 Viewer.
 *
 * Chapters are numbered starting at 0, where chapter 0 starts with the
 * front cover and ends with the last page before the first actual chapter.
 */

// Div element CSS id (should correspond to that in megazine.js).
define('PAGEFLIP_MZ3_VIEWER_PLAYER_ID', 'megazine');

// Default no-Flash message.
define('PAGEFLIP_MZ3_VIEWER_FLASH_FALLBACK', '<p>Please install Flash to view this page.</p>');

/**
 * Implements hook_menu().
 */
function pageflip_mz3_viewer_menu() {
  $items = array();
  $items['admin/config/media/pageflip/megazine3'] = array(
    'title' => 'MegaZine3 Viewer',
    'description' => 'Administer MegaZine3 Viewer settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('pageflip_mz3_viewer_settings_form'),
    'access arguments' => array('administer pageflip'),
    'file' => 'pageflip_mz3_viewer.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['node/%node/pageflip/mz3-viewer'] = array(
    'title' => 'View in MegaZine3',
    'page callback' => 'pageflip_mz3_viewer_view',
    'page arguments' => array(1),
    'access callback' => 'pageflip_mz3_viewer_access',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK,
  );
  $items['node/%node/pageflip/mz3-viewer-xml'] = array(
    'title' => 'MegaZine3 XML callback',
    'page callback' => 'pageflip_mz3_viewer_mz3',
    'page arguments' => array(1),
    'access callback' => 'pageflip_mz3_viewer_access',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Access callback.
 */
function pageflip_mz3_viewer_access($node) {
  return $node->type == PAGEFLIP_BOOK_CONTENT_TYPE && user_access('access content');
}

/**
 * Implements hook_theme().
 */
function pageflip_mz3_viewer_theme() {
  return array(
    'pageflip_mz3_viewer_book_xml' => array(
      'variables' => array('book' => NULL, 'chapters' => array()),
      'template' => 'pageflip-mz3-viewer-book-xml',
    ),
    'pageflip_mz3_viewer_chapter_xml' => array(
      'variables' => array('book' => NULL, 'chapter' => array(), 'chapter_index' => 0, 'last_chapter' => 0),
      'template' => 'pageflip-mz3-viewer-chapter-xml',
    ),
    'pageflip_mz3_viewer_page_xml' => array(
      'variables' => array('book' => NULL, 'page' => NULL, 'which_page' => PAGEFLIP_NORMAL_PAGE),
      'template' => 'pageflip-mz3-viewer-page-xml',
    ),
    'pageflip_mz3_viewer_embed' => array(
      'variables' => array('node' => NULL, 'chapter_index' => 0, 'element_id' => PAGEFLIP_MZ3_VIEWER_PLAYER_ID),
      'template' => 'pageflip-mz3-viewer-embed',
    ),
    'pageflip_mz3_viewer_embed_js' => array(
      'variables' => array('megazine_path' => '', 'chapter_index' => 0, 'element_id' => PAGEFLIP_MZ3_VIEWER_PLAYER_ID),
    ),
  );
}

/**
 * Implements hook_token_info().
 */
function pageflip_mz3_viewer_token_info() {
  return array(
    'tokens' => array(
      'node' => array(
        'page-content' => array(
          'name' => t('PageFlip Chapter XML'),
          'description' => t("Rendered XML of a Chapter node's pages."),
          'type' => 'node',
        ),
      ),
    ),
  );
}

/**
 * Implements hook_token().
 */
function pageflip_mz3_viewer_token($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();
  if ($type == 'node' && !empty($data['node'])) {
    $node = $data['node'];
    foreach ($tokens as $name => $original) {
      if ($name == 'page-content') {
        $replacements[$original] = $node->pageflip_rendered_pages;
      }
    }
  }
  return $replacements;
}

/**
 * Retrieves book XML tag attributes.
 */
function pageflip_mz3_viewer_book_attributes() {
  $page_width = variable_get('pageflip_page_width_low', 640);
  $page_height = variable_get('pageflip_page_height_low', 720);
  // By default, at *least* set the page width and page height.
  $default = "pagewidth=\"{$page_width}\" pageheight=\"{$page_height}\"";
  return variable_get('pageflip_mz3_viewer_book_attributes', $default);
}

/**
 * Injects advertisements.
 */
function pageflip_mz3_viewer_inject_ads(&$chapters) {
  // Inject either one or two ad pages after cover & credits pages.
  $num_ads = 2 - (count($chapters[0]['pages']) % 2);
  $chapters[0]['pages'] = array_merge($chapters[0]['pages'], pageflip_ad($num_ads));

  /* We don't need to add in blank pages in the middle of the book, because
   * MegaZine3 automatically adds them so that all chapters start on right-
   * hand pages.
   */

  // Add an ad or two depending on length of last chapter.
  $last_chapter = count($chapters) - 1;
  if ($last_chapter > 0) {
    $num_ads = (count($chapters[$last_chapter]['pages']) % 2) + 1;
    $chapters[$last_chapter]['pages'] = array_merge($chapters[$last_chapter]['pages'], pageflip_ad($num_ads));
  }
}

/**
 * Adds back cover page to an array of chapter arrays.
 *
 * @param array $chapters
 *   Chapter container array as returned by pageflip_load_book().
 */
function pageflip_mz3_viewer_add_back_cover(&$chapters) {
  $nid = variable_get('pageflip_mz3_viewer_back_cover_nid', NULL);
  if ($nid) {
    $last_chapter = count($chapters) - 1;
    $chapters[$last_chapter]['pages'] = array_merge($chapters[$last_chapter]['pages'], array(node_load($nid)));
  }
}

/**
 * Process data for xml template.
 *
 * @param array $vars
 *   Array containing:
 *   - object book: Book node object.
 *   - array chapters: Array of chapters; each chapter is an array of page
 *     node objects.
 */
function template_preprocess_pageflip_mz3_viewer_book_xml(&$vars) {
  $vars['book_attributes'] = pageflip_mz3_viewer_book_attributes();

  pageflip_mz3_viewer_inject_ads($vars['chapters']);
  pageflip_mz3_viewer_add_back_cover($vars['chapters']);

  $vars['content'] = '';
  $chapter_index = 0;
  $last_chapter = count($vars['chapters']) - 1;
  foreach ($vars['chapters'] as $chapter) {
    $vars['content'] .= theme('pageflip_mz3_viewer_chapter_xml',
      array(
        'book' => $vars['book'],
        'chapter' => $chapter,
        'chapter_index' => $chapter_index++,
        'last_chapter' => $last_chapter,
      )
    );
  }
}

/**
 * Process data for a chapter.
 *
 * @param array $vars
 *   Array containing:
 *   - book: Book node object.
 *   - chapter: Chapter container array (contains chapter node and pages
 *     array) as returned by pageflip_load_book().
 *   - chapter_index: Zero-based index of this chapter in the book.
 *   - last_chapter: Zero-based index of the final chapter in the book.
 */
function template_preprocess_pageflip_mz3_viewer_chapter_xml(&$vars) {
  /* $vars['chapter_index'] and ['last_chapter'] pass through to template. */

  $rendered_pages = pageflip_mz3_viewer_render_chapter_pages($vars['book'], $vars['chapter'], $vars['chapter_index'], $vars['last_chapter']);

  // Alias chapter node object, if any, and dig out the XML override field.
  $chapter = $vars['chapter']['chapter'];
  $xml_field = $chapter ? field_get_items('node', $chapter, 'field_pageflip_mz3_xml') : NULL;
  $xml = $chapter && !empty($xml_field) ? $xml_field[0]['value'] : NULL;

  $vars['override'] = NULL;
  if (!$chapter || empty($xml)) {
    $vars['content'] = $rendered_pages;
  }
  else {
    // Use the user-supplied overridden XML.
    $chapter->pageflip_rendered_pages = $rendered_pages;
    $vars['override'] = token_replace($xml, array('site' => NULL, 'node' => $chapter));
  }
}

/**
 * Render all pages for a chapter.
 *
 * @param object $book
 *   Book node object.
 * @param array $chapter
 *   Chapter container array (contains chapter node and pages array) as
 *   returned by pageflip_load_book().
 * @param int $chapter_index
 *   Zero-based index of this chapter in the book.
 * @param int $last_chapter
 *   Zero-based index of the final chapter in the book.
 */
function pageflip_mz3_viewer_render_chapter_pages($book, $chapter, $chapter_index, $last_chapter) {
  $content = '';
  $last_page = count($chapter['pages']) - 1;
  $page_index = 0;

  // Render each page of this chapter.
  foreach ($chapter['pages'] as $page) {
    $which_page = PAGEFLIP_NORMAL_PAGE;
    if ($chapter_index === 0 && $page_index === 0) {
      $which_page = PAGEFLIP_FRONT_COVER;
    }
    elseif ($chapter_index === $last_chapter && $page_index === $last_page) {
      $which_page = PAGEFLIP_BACK_COVER;
    }

    $content .= theme('pageflip_mz3_viewer_page_xml',
      array(
        'book' => $book,
        'page' => $page,
        'which_page' => $which_page,
      )
    );
    $page_index++;
  }
  return $content;
}

/**
 * Process data for a page.
 *
 * @param array $vars
 *   Array containing:
 *   - object book: Book node object.
 *   - object page: Page node object.
 *   - int which_page: Value indicating what kind of page we're dealing with:
 *     PAGEFLIP_NORMAL_PAGE, PAGEFLIP_FRONT_COVER, or PAGEFLIP_BACK_COVER.
 */
function template_preprocess_pageflip_mz3_viewer_page_xml(&$vars) {
  // Choose which page attributes to use.
  if ($vars['which_page'] == PAGEFLIP_NORMAL_PAGE) {
    $vars['page_attributes'] = variable_get('pageflip_mz3_viewer_page_attributes', '');
  }
  elseif ($vars['which_page'] == PAGEFLIP_FRONT_COVER) {
    $vars['page_attributes'] = variable_get('pageflip_mz3_viewer_front_cover_attributes', 'stiff="true"');
  }
  elseif ($vars['which_page'] == PAGEFLIP_BACK_COVER) {
    $vars['page_attributes'] = variable_get('pageflip_mz3_viewer_back_cover_attributes', 'stiff="true"');
  }

  // Determine page size -- the templates need the lower size.
  $vars['page_width'] = variable_get('pageflip_page_width_low', 640);
  $vars['page_height'] = variable_get('pageflip_page_height_low', 720);

  // If we actually have any attributes, the template needs a leading space.
  if (!empty($vars['page_attributes'])) {
    $vars['page_attributes'] = ' ' . $vars['page_attributes'];
  }

  $vars['content'] = NULL;
  $page = $vars['page'];
  $xml = NULL;
  if ($page) {
    $xml_field = field_get_items('node', $page, 'field_pageflip_mz3_xml');
    $xml = $page && !empty($xml_field) ? $xml_field[0]['value'] : NULL;
  }

  $vars['content'] = NULL;
  $vars['image_high'] = NULL;
  $vars['image_low'] = NULL;
  if (!$page) {
    // Blank page.
  }
  elseif ($page->type !== PAGEFLIP_PAGE_CONTENT_TYPE) {
    // Advertisement.
    $vars['content'] = $page->content['body']['#value'];
  }
  elseif (empty($xml)) {
    $vars['image_high'] = pageflip_page_image_url($page, 'high');
    $vars['image_low'] = pageflip_page_image_url($page, 'low');
  }
  else {
    // Use the user-supplied overridden XML.
    $vars['content'] = token_replace($xml, array('site' => NULL, 'node' => $vars['book']));
  }
}

/**
 * Generates the JavaScript used to activate MegaZine3.
 */
function theme_pageflip_mz3_viewer_embed_js($variables) {
  $megazine_path = $variables['megazine_path'];
  $chapter_index = $variables['chapter_index'];
  $element_id = $variables['element_id'];
  return <<<EOQ
    jQuery(function() {
      swfobject.embedSWF(
        '$megazine_path/megazine/preloader-fat.swf', '$element_id', '100%', '100%', '9.0.115',
        '$megazine_path/js/expressInstall.swf',
        Drupal.settings.pageflipMz3Viewer.flashvars,
        Drupal.settings.pageflipMz3Viewer.params,
        Drupal.settings.pageflipMz3Viewer.attributes
      );
    });
EOQ;
}

/**
 * Sets node the MZ3 viewer is viewing and flags (internally) that the viewer
 * *is* active this page load.
 */
function _pageflip_mz3_viewer_active_node($node = NULL) {
  static $active_node = NULL;
  if (empty($node)) {
    return $active_node;
  }
  $active_node = $node;
}

/**
 * Generate the MegaZine3 embed code appropriate for the given book node and
 * chapter number.
 * MegaZine3 Viewer entry point.
 */
function pageflip_mz3_viewer_view($node) {
  pageflip_set_active_viewer(PAGEFLIP_VIEWER_MEGAZINE3, $node);
  _pageflip_mz3_viewer_active_node($node);

  // In case the flash doesn't load, show a node with a help message (hiding
  // behind the flash).
  $content = '';
  if ($fallback = variable_get('pageflip_mz3_viewer_flash_fallback', t(PAGEFLIP_MZ3_VIEWER_FLASH_FALLBACK))) {
    if (is_numeric($fallback)) {
      $fallback = node_load($fallback);
      // Don't render the title of our flash node page; it's a link that we
      // don't want anybody to follow.
      unset($fallback->title);
      $content = node_view($fallback, FALSE, FALSE, FALSE);
    }
    else {
      $content = $fallback;
    }
  }

  // If the HTML viewer's installed and the Flash doesn't load, give the user
  // links to the same book in the HTML viewer (in both low res and high res).
  $postscript = '';
  if (module_exists('pageflip_html_viewer')) {
    $postscript = t('<p class="pageflip-mz3-viewer-alternative"><h3>Or select a resolution for the non-Flash version:</h3><span class="lowres">!lowres</span> <span class="or">or</span> <span class="highres">!highres</span></p>',
      array(
        '!lowres' => l(t(PAGEFLIP_VIEWER_LOW_RES), 'node/' . $node->nid . '/pageflip/html-viewer/low'),
        '!highres' => l(t(PAGEFLIP_VIEWER_HIGH_RES), 'node/' . $node->nid . '/pageflip/html-viewer/high'),
      )
    );
  }
  return $content . $postscript;
}

/**
 * Implements hook_page_build().
 */
function pageflip_mz3_viewer_page_build(&$page) {
  if (!($node = _pageflip_mz3_viewer_active_node())) {
    return;
  }

  // Set page title to the title of this book.
  drupal_set_title(check_plain($node->title));

  // Add our CSS file which styles the MegaZine div.
  drupal_add_css(drupal_get_path('module', 'pageflip_mz3_viewer') . '/pageflip_mz3_viewer.css', 'file');

  // Add a few tons of JavaScript for embedding MegaZine.
  $megazine_path = variable_get('pageflip_mz3_viewer_megazine3_path', 'sites/all/libraries/mz3');
  drupal_add_js($megazine_path . '/js/swfobject.js', 'file');
  drupal_add_js($megazine_path . '/js/swfaddress.js', 'file');

  $element_id = PAGEFLIP_MZ3_VIEWER_PLAYER_ID;

  // Set up configuration dictionaries that need to be passed to
  // swfobject.embedSWF().
  $absolute = array('absolute' => TRUE);
  $abs_megazine_path = url($megazine_path, $absolute);
  $options = array(
    'pageflipMz3Viewer' => array(
      'flashvars' => array(
        'basePath' => $abs_megazine_path . '/megazine',
        'xmlFile' => url('node/' . $node->nid . '/pageflip/mz3-viewer-xml', $absolute),
      ),
      'params' => array(
        'menu' => 'false',
        'scale' => 'noScale',
        'allowFullscreen' => variable_get('pageflip_mz3_viewer_allow_fullscreen', 'true'),
        'allowScriptAccess' => 'always',
        'bgColor' => variable_get('pageflip_mz3_viewer_bg_color', '#333333'),
      ),
      'attributes' => array(
        // CSS div id.
        'id' => $element_id,
      ),
    ),
  );
  if (isset($_GET['chapter_index']) && is_numeric($_GET['chapter_index'])) {
    $chapters_field = field_get_items('node', $book, 'field_pageflip_chapters');
    $chapter_index = $_GET['chapter_index'];
    if ($chapter_index < 0) {
      $chapter_index = 0;
    }
    elseif ($chapter_index > count($chapters_field)) {
      $chapter_index = count($chapters_field);
    }
  }
  else {
    $chapter_index = 0;
  }
  drupal_add_js($options, 'setting');
  drupal_add_js(
    theme('pageflip_mz3_viewer_embed_js',
      array(
        'megazine_path' => $abs_megazine_path,
        'chapter_index' => $chapter_index,
        'element_id' => $element_id,
      )
    ),
    'inline'
  );

  // Our flash object goes in the footer because otherwise browsers that
  // correctly render HTML over Flash will render part of the page over the
  // MegaZine3 display.
  $flash_content = theme('pageflip_mz3_viewer_embed',
    array(
      'node' => $node,
      'chapter_index' => $chapter_index,
      'element_id' => $element_id,
    )
  );
  if (!isset($page['page_bottom'])) {
    $page['page_bottom'] = array();
  }
  $page['page_bottom']['pageflip_mz3_viewer']['#markup'] = $flash_content;
}

/**
 * XML page callback: Generate the XML "mz3" file for a MegaZine3 book.
 */
function pageflip_mz3_viewer_mz3($book) {
  // We need the entire book in order to generate the megazine3 XML.
  $chapters = pageflip_load_book($book);

  drupal_add_http_header('Content-Type', 'text/xml; charset=utf-8');
  print theme('pageflip_mz3_viewer_book_xml',
    array(
      'book' => $book,
      'chapters' => $chapters,
    )
  );
  exit();
}
