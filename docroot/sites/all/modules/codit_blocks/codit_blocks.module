<?php

/**
 * @file
 * Hooks for the codit Blocks module.
 *
 * To declare a block, do it in codit_local/blocks/block_bin
 */

/**
 * Implements hook_help().
 */
function codit_blocks_help($path, $arg) {
  switch ($path) {
    case 'admin/help#codit_blocks':
      $output = file_get_contents(drupal_get_path('module', 'codit_blocks') . '/README.md');
      // Use markdown filter if it is available to make the readme pretty.
      if (module_exists('markdown')) {
        // Markdown can be used.
        module_load_include('php', 'markdown', 'markdown');
        $output = Markdown($output);
      }
      else {
        // Markdown is not available.
        $output = '<pre>' . $output . '</pre>';
      }
      return $output;
  }
}

/**
 * Returns a cached array of block deltas registered by codit_blocks.
 *
 * @return array
 *   The array of block deltas is built from whatever block directories are
 *   present in codit_local/blocks/block_bin/.  Block directories
 *   beginning with _ are ignored (considered disabled).
 */
function codit_blocks_get_blocks() {
  $a_block_list = &drupal_static(__FUNCTION__);
  if (!isset($a_block_list)) {
    if ($cache = cache_get('codit_blocks_block_list')) {
      $a_block_list = $cache->data;
    }
    else {
      // Do heavy lifting and populate $a_block_list
      $a_block_list = array();
      $path_to_local_blocks = codit_path_to_local('blocks');
      $path_to_block_bin = $path_to_local_blocks . 'block_bin';

      // Scan the directory codit_local/blocks/block_bin/ for any
      // sub-directories.
      $dir_options = array(
        'recurse' => FALSE,
        'key' => 'name',
        'min_depth' => 0,
        'nomask' => '/.*\.(txt|inc|module|class|gif|jpg|png|cvs|svn|git|md)$/',
      );
      $mask  = '//';
      $a_block_directories = file_scan_directory($path_to_block_bin, $mask, $dir_options);

      // Scan the block_bin for files.
      $file_options = array(
        'recurse' => TRUE,
        'key' => 'uri',
        'min_depth' => 1,
        'nomask' => '/.*\.(txt|module|class|gif|jpg|png|cvs|svn|git|md)$/',
      );
      $mask = '/.*\.(tpl.php|inc)$/';
      $mask = '//';
      $a_block_files  = file_scan_directory($path_to_block_bin, $mask, $file_options);

      $a_block_list = array();

      // Cycle through $a_block_directories and build the array of block deltas.
      foreach (is_array($a_block_directories) ? $a_block_directories : array() as $block_name => $o_block_directory) {
        // Process this file to see if it belongs in $a_block_list
        // Skip any beginning with '_' or '.'.  These are treated as hidden.
        if ($block_name !== ltrim($block_name, '._')) {
          continue;
        }

        // Skip any that are named longer than 32 char, the legal limit set by
        // the block table.
        if (strlen($block_name) > 32) {
          // Too long to be allowed, skip using this block.
          $message = 'Codit Blocks could not register the block @blockname, because it is @length characters and block names must be 32 chars or less.';
          $variables = array(
            'blockname' => $block_name,
            'length' => strlen($block_name),
          );
          watchdog('codit_blocks', $message, $variables, WATCHDOG_DEBUG);
          continue;
        }

        // Skip any that don't have a tpl named correctly and in the right spot.
        $target_tpl = "{$o_block_directory->uri}/codit_blocks_{$block_name}.tpl.php";

        if (empty($a_block_files[$target_tpl])) {
          $message = 'Codit Blocks could not register the block @blockname, because its template was not found here: @templatename. Must match its blockname: @blockname';
          $variables = array(
            'blockname' => $block_name,
            'templatename' => $target_tpl,
          );
          watchdog('codit_blocks', $message, $variables, WATCHDOG_DEBUG);
          continue;
        }

        // Check for _callback file, not because it is required, but just to
        // avoid making a bunch of include attempts that return nothing.
        $target_callback = "{$o_block_directory->uri}/_callback.inc";
        if (empty($a_block_files[$target_callback])) {
          // There is no callback so save NULL.
          $target_callback = NULL;
        }

        // It made it this far so it must be legitimate. Save the block delta.
        $a_block_list[$block_name] = array(
          'delta' => $block_name,
          'template' => $target_tpl,
          'callback' => $target_callback,
        );
      }
      cache_set('codit_blocks_block_list', $a_block_list, 'cache');
    }
  }

  asort($a_block_list);
  return $a_block_list;
}


/**
 * Implements hook_block_view_alter().
 *
 * Perform alterations to the content of a block.
 */
function codit_blocks_block_view_alter(&$data, $block) {
  // This alters the title of blocks being output.
  // To add a block title, edit the array $_codit_blocks_block_title_override
  // in codit_local/blocks/config_blocks.inc
  $path_to_local = codit_path_to_local('blocks');
  include_once $path_to_local . 'config_blocks.inc';

  global $_codit_blocks_block_title_override;

  // By default, block titles will be output unless
  // $_codit_blocks_block_title_override['show-block-titles'] is intentionally
  // set to FALSE in codit_local/blocks/config_blocks.inc
  $b_show_block_titles = ((array_key_exists('show-block-titles', $_codit_blocks_block_title_override)) && ($_codit_blocks_block_title_override['show-block-titles'] == FALSE)) ? FALSE : TRUE;

  if (array_key_exists($block->delta, $_codit_blocks_block_title_override)) {
    // An override title is in the array so process it to show the override.
    $data['subject'] = $_codit_blocks_block_title_override[$block->delta];
  }
  elseif (!empty($block->module) && (!empty($_codit_blocks_block_title_override[$block->module]) && ($_codit_blocks_block_title_override[$block->module] == 'all'))) {
    // This catches any blocks that are added by a module that has been allowed
    // to display and allows them to use their own block title.
  }
  else {
    if ((!empty($_codit_blocks_block_title_override)) && ($b_show_block_titles)) {
      // Not supposed to hide any titles, so do nothing.
    }
    else {
      // Catches any blocks not specified above and sets to display no title.
      $data['subject'] = '';
    }
  }
}


/**
 * Implements hook_theme().
 */
function codit_blocks_theme($existing, $type, $path) {
  $a_themes = array();

  // Create dynamic entries for all possible Codit Blocks.
  $a_blocks = codit_blocks_get_blocks();

  foreach ($a_blocks as $delta => $block) {
    $path_to_tpl = codit_path_to_local('blocks') . "block_bin/{$delta}";
    $a_themes[$delta] = array(
      'variables' => array(),
      'path' => $path_to_tpl,
      'template' => 'codit_blocks_' . $delta,
    );
  }

  return $a_themes;
}


/**
 * Implements hook_block_info().
 */
function codit_blocks_block_info() {
  $blocks = array();

  // Create dynamic entries for all blocks defined by codit_blocks.
  $a_blocks = codit_blocks_get_blocks();

  foreach ($a_blocks as $delta => $block) {
    $human_readable = str_replace('_', ' ', $delta);
    $blocks[$delta] = array(
      'info' => ucwords($human_readable),
    );
  }

  return $blocks;
}


/**
 * Implements hook_block_view().
 */
function codit_blocks_block_view($delta = '') {
  // This hook generates the contents of the blocks.
  $block = array();
  // Get the blocks defined by codit_blocks.
  $a_blocks = codit_blocks_get_blocks();

  // Check to see if $delta is is present in $a_blocks.
  if (!empty($a_blocks[$delta])) {
    // The current delta is defined by this module so build the block.
    $path_to_local = codit_path_to_local('blocks');
    $path_to_block = "{$path_to_local}block_bin/{$delta}";

    // Load the entity to pass either the node object or term object if the
    // block is placed on a node or entity.
    $o_entity = codit_load_the_entity();

    // Check to see if the block components are present by checking for the dir.
    // This has been scanned once and cached so it is possible it has been
    // deleted without a cache flush, so checking to be sure it is there.
    if (file_exists($path_to_block)) {
      // The block directory exists.  Do not assume the tpl or callback do.
      // Build an empty callback function as a fallback.
      $_callback = function () {
        // Just a fallback, do nothing, return an array.
        return array();
      };
      // Build fallback for $_access function.
      $_access = function () {
        // Just a fallback, return true so things are visible unless overridden.
        return TRUE;
      };

      // Build fallback for $_cache_id function.
      $_cache_id = function () {
        // Just a fallback, return FALSE so $_callback is not cached.
        return FALSE;
      };

      // Try to load the real callback file.  If it exists, it will be used and
      // its contents will override the $_callback, $_access, and $_cache_id
      // anonymous functions that were just defined.
      if (!empty($a_blocks[$delta]['callback'])) {
        include $a_blocks[$delta]['callback'];
      }

      // Get the $user object so it can be used for access caching or checking.
      global $user;
      // Check for access granted to see block.
      $accessible = $_access($user);
      if (!empty($accessible)) {
        // Permission access has been granted.
        // Build the block.
        // Check to see if cachable.
        $cache_string = $_cache_id($user);
        $cache_array = explode('|', $cache_string);
        $cache_id = $cache_array[0];
        if ((!empty($cache_array[1])) && (is_numeric($cache_array[1]))) {
          $cache_expiration = REQUEST_TIME + $cache_array[1];
        }
        else {
          $cache_expiration = CACHE_PERMANENT;
        }

        if (!empty($cache_id) && (!codit_debug('', 'blocks-no-cache', ''))) {
          // Caching has been requested so prep to cache.
          // Make cache id unique to this module to avoid collision risk.
          $cache_id = 'codit_blocks_' . $cache_id;
          // Since cache id is developer defined, trim to 250 chars to fit db.
          $cache_id = substr($cache_id, 0, 250);
          // Begin static and db caching.
          $block_callback_returned = &drupal_static($cache_id);
          $source = 'drupal_static';
          if (!isset($block_callback_returned)) {
            if ($cache = cache_get($cache_id)) {
              // This is coming from cache.
              $block_callback_returned = $cache->data;
              $source = 'drupal_cache';
            }
            else {
              // Do heavy lifting and populate $block_callback_returned
              $block_callback_returned = $_callback();
              // Store it in cache for next time.
              cache_set($cache_id, $block_callback_returned, 'cache', $cache_expiration);
              $source = 'fresh';
            }
          }
        }
        else {
          // No caching desired.  Get the block data for the template.
          $block_callback_returned = $_callback();
          $source = 'fresh';
        }

        // Add the source element to the array|object for debugging.
        if (is_object($block_callback_returned)) {
          // It is an object.
          $block_callback_returned->datasource_for_debug = $source;
        }
        else {
          // It is a string or array, so treat it as an array.
          $block_callback_returned = (array) $block_callback_returned;
          $block_callback_returned['datasource_for_debug'] = $source;
        }

        $human_readable = str_replace('_', ' ', $delta);
        $human_readable = ucwords($human_readable);

        $args = array(
          'o_entity' => $o_entity,
          "blockdata_$delta" => $block_callback_returned,
        );

        $s_content = theme($delta, $args);
        if (!empty($s_content)) {
          // Check for permissions to output basic template tracers.
          $tracer_open = (user_access('view codit template tracers')) ? "<!-- $delta.tpl.php  -$source- -->\n" : '';
          $tracer_close = (user_access('view codit template tracers')) ? "<!-- /$delta.tpl.php -$source- -->\n" : '';

          $block['content'] = array(
            '#markup' => $s_content,
            '#subject' => $human_readable,
            '#prefix' => "\n $tracer_open <div class=\"wrapper wrapper-$delta\">\n",
            '#suffix' => "\n</div>\n$tracer_close",
          );
        }

        return $block;
      }
    }
  }
}
