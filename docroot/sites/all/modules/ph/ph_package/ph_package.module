<?php
/**
 * @file
 * Repository package handler.
 */

/**
 * Implements hook_menu().
 */
function ph_package_menu() {
  $items['admin/config/system/ph-repository/package'] = array(
    'title' => 'Packaging',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ph_package_admin_settings'),
    'access arguments' => array('administer project repository'),
    'file' => 'ph_package.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Packages a named version of a repository.
 *
 * @param PHRepository $repository
 *   Repository to export.
 * @param array $version
 *   Repository version array. This version is changed to the detailed exported
 *   version from the backend.
 * @param array $version_since
 *   Base version array to compute the detailed version on.
 * @return string
 *   Path to the directory the repository has been exported to.
 *
 * @see ph_version_make()
 */
function ph_package_export(PHRepository $repository, &$version, $version_since = NULL) {
  if ($directory = ph_package_working_directory()) {
    // Prepare export working directory.
    $directory .= '/' . $repository->rid;
    // Re-create directory if exists.
    if (file_exists($directory)) {
      file_unmanaged_delete_recursive($directory);
    }
    file_prepare_directory($directory, FILE_CREATE_DIRECTORY);
    // Export and refine version.
    $version = ph_repository_export($repository, $directory, $version, $version_since);
    ph_package_put_license($directory);
    // Return exported directory.
    return $directory;
  }

  return NULL;
}

/**
 * Packages a license file.
 */
function ph_package_put_license($directory, $filename = 'LICENSE.txt') {
  // Copy license file.
  $source = drupal_get_path('module', 'ph_package') . '/gpl-2.0.txt';
  @file_unmanaged_copy($source, $directory . '/' . $filename, FILE_EXISTS_REPLACE);
}

/**
 * Stamps an exported package.
 *
 * @param string $directory
 *   Path to the directory containing an exported package.
 * @param array $metadata
 *   Package metadata, including:
 *   - version: Project version info. See ph_version_make().
 *   - project: Project machine name.
 *   - project_status_url: (optional) Project update feed base URL. If not
 *     specified and the Updates Feed module is available, the feed URL will be
 *     derived from the URL configured.
 *   - datestamp: (optional) Unix timestamp to add to info files.
 *
 * @see ph_version_make()
 */
function ph_package_stamp($directory, array $metadata) {
  $factory = ph_package_stamp_factory();
  $stamp = $factory->createStamp($directory);
  $stamp->stamp($metadata);
}

/**
 * Returns a stamp factory.
 *
 * @param $name
 *   Stamp name. If unspecified, the currently configured stamp is used.
 * @return PHPackageStampFactoryInterface
 *   Stamp factory object.
 */
function ph_package_stamp_factory($name = NULL) {
  if (!isset($name)) {
    $name = variable_get('ph_package_stamp', 'default');
  }

  $factories = &drupal_static(__FUNCTION__, array());
  if (!isset($factories[$name])) {
    $info = ph_package_get_stamp_info();
    // Fall back to default if specified stamp provider is not available.
    if (!isset($info[$name]) || !module_exists($info[$name]['module'])) {
      $name = 'default';
    }
    // Create factory instance.
    if (isset($info[$name]) && !isset($factories[$name])) {
      $factories[$name] = new $info[$name]['factory class']();
    }
  }

  return isset($factories[$name]) ? $factories[$name] : NULL;
}

/**
 * Retrieves available package stamp handlers.
 */
function ph_package_get_stamp_info() {
  $stamp_info = &drupal_static(__FUNCTION__, array());

  if (empty($stamp_info)) {
    if ($cache = cache_get('ph_package_stamp_info', 'cache_ph_package')) {
      $stamp_info = $cache->data;
    }
    else {
      // Rebuild the cache and save it.
      $stamp_info = array();
      foreach (module_implements('ph_package_stamp_info') as $module) {
        $info = module_invoke($module, 'ph_package_stamp_info');
        foreach (array_keys($info) as $name) {
          $info[$name] += array(
            'label' => $name,
            'factory class' => '',
            'module' => $module,
          );
        }
        $stamp_info = array_merge($stamp_info, $info);
      }
      drupal_alter('ph_package_stamp_info', $stamp_info);
      ksort($stamp_info);
      cache_set('ph_package_stamp_info', $stamp_info, 'cache_ph_package');
    }
  }

  return $stamp_info;
}

/**
 * Formats and returns the configured metadata header.
 */
function ph_package_get_stamp_header() {
  $header = variable_get('ph_package_stamp_header', '');
  if ($header) {
    $header = token_replace($header);
    $header = strip_tags($header);
  }
  return $header;
}

/**
 * Archives an exported package.
 *
 * @param string $directory
 *   Path to the directory containing an exported package.
 * @param array $metadata
 *   Package metadata. See ph_package_stamp().
 * @param $extension
 *   Archive extension.
 * @return stdClass
 *   Archive file object.
 *
 * @see ph_package_stamp()
 */
function ph_package_archive($directory, array $metadata, $extension) {
  $archive = new PHPackageArchive($directory, $metadata);
  $replace_behavior = variable_get('ph_package_archive_replace', FILE_EXISTS_REPLACE);
  $file = $archive->createArchive($extension, array('replace' => $replace_behavior));
  return $file;
}

/**
 * Lists supported package archive extension info.
 *
 * This wraps around hook_archiver_info() to list supported archives in core.
 */
function ph_package_get_archive_extensions() {
  $info = &drupal_static(__FUNCTION__);
  if (!isset($info)) {
    $info = array();
    foreach (archiver_get_info() as $name => $archive) {
      foreach ($archive['extensions'] as $extension) {
        if (!isset($info[$extension])) {
          $info[$extension] = array(
            'label' => drupal_strtoupper($extension),
            'archiver' => $name,
          );
        }
      }
    }
    ksort($info);
  }
  return $info;
}

/**
 * Returns extension option labels.
 */
function ph_package_extension_options() {
  $options = array();
  foreach (ph_package_get_archive_extensions() as $extension => $info) {
    $options[$extension] = $info['label'];
  }
  return $options;
}

/**
 * Gets the working directory for packaging.
 */
function ph_package_working_directory($create_directory = TRUE) {
  $directory = variable_get('ph_package_working_directory', 'temporary://ph_package');
  $writable = ph_repository_prepare_working_directory($directory, $create_directory);
  return $writable ? $directory : FALSE;
}

/**
 * Validates internal directory for a text element.
 */
function ph_package_validate_local_directory($element, &$form_state) {
  $directory = $element['#value'];

  $scheme = file_uri_scheme($directory);
  if (!$scheme || !in_array($scheme, array('public', 'private', 'temporary'))) {
    form_error($element, t('The specified path is not in the Drupal file system.'));
  }
}

/**
 * Implements hook_hook_info().
 */
function ph_package_hook_info() {
  $hooks['ph_package_stamp_info'] = array(
    'group' => 'ph',
  );
  return $hooks;
}

/**
 * Returns the hash of a release archive file.
 */
function ph_package_archive_get_hash($file) {
  $bin = &drupal_static(__FUNCTION__, array());

  // Cache file hashes.
  $cid = 'filehash:' . $file->fid . ':' . $file->timestamp;
  if (!isset($bin[$cid])) {
    if ($cache = cache_get($cid, 'cache_ph_package')) {
      $bin[$cid] = $cache->data;
    }
    else {
      $filepath = drupal_realpath($file->uri);
      // First try 'md5sum' command.
      $result = exec(escapeshellcmd('md5sum ' . $filepath), $lines, $return);
      if (!$return) {
        $hash = substr($result, 0, 32);
      }
      // Fallback to PHP checksum if 'md5sum' could not be executed.
      else {
        $hash = md5_file(drupal_realpath($file->uri));
      }
      $bin[$cid] = $hash;
      cache_set($cid, $bin[$cid], 'cache_ph_package');
    }
  }

  return $bin[$cid] ? $bin[$cid] : NULL;
}

/**
 * Returns the full extension of a release archive file.
 */
function ph_package_archive_get_extension($file) {
  foreach (array_keys(ph_package_get_archive_extensions()) as $extension) {
    $dot_extension = '.' . $extension;
    $dot_extension_length = strlen($dot_extension);
    if (substr($file->filename, - $dot_extension_length) == $dot_extension) {
      return $extension;
    }
  }
}

/**
 * Implements hook_flush_caches().
 */
function ph_package_flush_caches() {
  return array('cache_ph_package');
}
