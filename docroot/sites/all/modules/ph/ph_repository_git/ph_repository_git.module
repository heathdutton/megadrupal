<?php
/**
 * @file
 * Git repository implementation.
 */

/**
 * Implements hook_form_FORM_ID_alter() for ph_repository_admin_settings.
 */
function ph_repository_git_form_ph_repository_admin_settings_alter(&$form, &$form_state) {
  form_load_include($form_state, 'inc', 'ph_repository_git', 'ph_repository_git.admin');
  _ph_repository_git_form_ph_repository_admin_settings_alter($form, $form_state);
}

/**
 * Searches a variable value and the system path for the Git executable.
 */
function ph_repository_git_find_executable($reset = FALSE) {
  $path = &drupal_static(__FUNCTION__);

  if (!isset($path) || $reset) {
    // Retrieve cached path.
    if (!$reset && $cache = cache_get('ph_repository_git_path')) {
      $path = $cache->data;
    }
    // Determine path to Git executable.
    else {
      $path = variable_get('ph_repository_git_path');
      // Use configured path.
      if ($path) {
        $path = file_exists($path) && is_executable($path) ? $path : FALSE;
      }
      // Search system paths.
      else {
        // Search only once per session (or until found and cached).
        $path = FALSE;
        // Iterate over binary paths.
        $extensions = array('', '.exe', '.bat', '.cmd', '.com');
        foreach (explode(PATH_SEPARATOR, getenv('PATH')) as $system_path) {
          foreach ($extensions as $extension) {
            $bin = realpath($system_path . '/git' . $extension);
            if (file_exists($bin) && is_executable($bin)) {
              $path = $bin;
            }
          }
        }
      }
      // Cache path.
      if ($path) {
        cache_set('ph_repository_git_path', $path);
      }
    }
  }

  return $path;
}

/**
 * Implements hook_field_info().
 */
function ph_repository_git_field_info() {
  return array(
    'ph_repository_git_url' => array(
      'label' => t('Git repository URL'),
      'description' => t('Stores the URL for the remote Git repository.'),
      'settings' => array(),
      'instance_settings' => array(),
      'default_widget' => 'ph_repository_git_url_text',
      'default_formatter' => 'ph_repository_git_url_plain',
      'property_type' => 'text',
    ),
  );
}

/**
 * Implements hook_field_validate().
 */
function ph_repository_git_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  foreach ($items as $delta => $item) {
    if (!empty($item['value'])) {
      if (drupal_strlen($item['value']) > 255) {
        $errors[$field['field_name']][$langcode][$delta][] = array(
          'error' => 'text_max_length',
          'message' => t('%name: the value may not be longer than %max characters.', array('%name' => $instance['label'], '%max' => 255)),
        );
      }
      elseif (!ph_repository_git_valid_url($item['value'])) {
        $errors[$field['field_name']][$langcode][$delta][] = array(
          'error' => 'git_url',
          'message' => t('%name: the value is not a valid Git repository URL.', array('%name' => $instance['label'])),
        );
      }
    }
  }
}

/**
 * Validates a Git repository URL.
 *
 * @param string $url
 * @return boolean
 */
function ph_repository_git_valid_url($url) {
  // Validate absolute URL (scheme-based).
  if (preg_match('!^[^:]+://([^@:/]+@)?[^@:/]+(:\d+)?/.*$!', $url)) {
    return TRUE;
  }
  // Validate local file URL.
  elseif (preg_match('!^file://(.*)$!', $url)) {
    return TRUE;
  }
  // Validate SCP-style URL.
  elseif (preg_match('!^([^@:/]+@)?([^:]+):/?([^/]+(?:/|$))*$!', $url)) {
    return TRUE;
  }
  // Fail match.
  return FALSE;
}

/**
 * Implements hook_field_is_empty().
 */
function ph_repository_git_field_is_empty($item, $field) {
  return empty($item['value']);
}

/**
 * Implements hook_field_widget_info().
 */
function ph_repository_git_field_widget_info() {
  return array(
    'ph_repository_git_url_text' => array(
      'label' => t('Text field'),
      'field types' => array('ph_repository_git_url'),
      'settings' => array('size' => 60),
    ),
  );
}

/**
 * Implements hook_field_widget_settings_form().
 */
function ph_repository_git_field_widget_settings_form($field, $instance) {
  $widget = $instance['widget'];
  $settings = $widget['settings'];

  $form['size'] = array(
    '#type' => 'textfield',
    '#title' => t('Size of textfield'),
    '#default_value' => $settings['size'],
    '#element_validate' => array('element_validate_integer_positive'),
    '#required' => TRUE,
  );

  return $form;
}

/**
 * Implements hook_field_widget_form().
 */
function ph_repository_git_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $widget = $instance['widget'];
  $settings = $widget['settings'];

  $items += array($delta => array());
  $items[$delta] += array('value' => '');
  $main_widget = $element + array(
    '#type' => 'textfield',
    '#size' => $settings['size'],
    '#max_length' => 255,
    '#default_value' => $items[$delta]['value'],
  );

  $element['value'] = $main_widget;
  return $element;
}

/**
 * Implements hook_field_widget_error().
 */
function ph_repository_git_field_widget_error($element, $error, $form, &$form_state) {
  form_error($element['value'], $error['message']);
}

/**
 * Implements hook_field_formatter_info().
 */
function ph_repository_git_field_formatter_info() {
  return array(
    'ph_repository_git_url_plain' => array(
      'label' => t('Plain text'),
      'field types' => array('ph_repository_git_url'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function ph_repository_git_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  foreach ($items as $delta => $item) {
    $element[$delta] = array(
      '#markup' => check_plain($item['value']),
    );
  }
  return $element;
}
