<?php
/**
 * @file
 * Version field and associated implementations.
 */

module_load_include('inc', 'ph_version', 'ph_version.property');

/**
 * Version string pattern.
 *
 * Matched parts:
 * 1. Core base version.
 * 2. Core minor version.
 * 3. Major version.
 * 4. Patch level.
 * 5. Extra version identifier (unchecked, may be 'dev').
 * 6. Commit increment.
 */
define('PH_VERSION_PATTERN', '(\d+)\.(?:(\d+)\.)?(?:x-(\d+)\.)?(?:x|x-dev|(\d+)(?:-([A-Za-z0-9]+))?(?:\+(\d+)-dev)?)');

/**
 * Implements hook_field_info().
 */
function ph_version_field_info() {
  return array(
    'ph_version' => array(
      'label' => t('Version'),
      'description' => t('This field represents a complete version string, such as 7.x-1.0-beta3, and all its parts.'),
      'settings' => array(),
      'instance_settings' => array('version_type' => ''),
      'default_widget' => 'ph_version_text',
      'default_formatter' => 'ph_version_standard',
      'property_type' => 'ph_version',
      'property_callbacks' => array('ph_version_property_info_callback'),
    ),
  );
}

/**
 * Implements hook_field_instance_settings_form().
 */
function ph_version_field_instance_settings_form($field, $instance) {
  $settings = $instance['settings'];

  $form['version_type'] = array(
    '#type' => 'radios',
    '#title' => t('Version type'),
    '#default_value' => $settings['version_type'],
    '#options' => array(
      '' => t('Any'),
      'contrib' => t('Contribution (module, theme, distribution)'),
      'core' => t('Drupal core'),
    ),
  );

  return $form;
}

/**
 * Implements hook_field_validate().
 */
function ph_version_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  foreach ($items as $delta => $item) {
    if (!ph_version_field_is_empty($item, $field)) {
      // Check entered type conforms with field instance type setting.
      $type = $instance['settings']['version_type'];
      $item_type = ph_version_is_core($item) ? 'core' : 'contrib';
      if ($type && $type != $item_type) {
        $errors[$field['field_name']][$langcode][$delta][] = array(
          'error' => 'ph_version_type',
          'message' => t('%name: the entered version must be for @type.', array(
            '%name' => $instance['label'],
            '@type' => $type == 'core' ? t('Drupal core') : t('contributions'),
          )),
        );
      }
    }
  }
}

/**
 * Implements hook_field_is_empty().
 */
function ph_version_field_is_empty($item, $field) {
  return !is_array($item) || empty($item['core']);
}

/**
 * Implements hook_field_widget_info().
 */
function ph_version_field_widget_info() {
  return array(
    'ph_version_text' => array(
      'label' => t('Text field'),
      'field types' => array('ph_version'),
      'settings' => array('format' => ''),
    ),
  );
}

/**
 * Implements hook_field_widget_settings_form().
 */
function ph_version_field_widget_settings_form($field, $instance) {
  $widget = $instance['widget'];
  $settings = $widget['settings'];

  if ($widget['type'] == 'ph_version_text') {
    $form['format'] = array(
      '#type' => 'radios',
      '#title' => t('Version format'),
      '#default_value' => $settings['format'],
      '#options' => array(
        '' => t('Any (e.g. 7.x-1.0-alpha3+6-dev)'),
        'standard' => t('Standard (e.g. 7.x-1.x-dev)'),
        'tag' => t('Tag (e.g. 7.x-1.x)'),
      ),
    );
    return $form;
  }
}

/**
 * Implements hook_field_widget_form().
 */
function ph_version_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $widget = $instance['widget'];
  $instance_settings = $instance['settings'] + array(
    'version_type' => '',
  );
  $settings = $widget['settings'] + array(
    'format' => '',
  );

  // Prepare default value.
  $default_value = '';
  if (isset($items[$delta]) && is_array($items[$delta])) {
    $format = $settings['format'] ? $settings['format'] : 'full';
    $default_value = ph_version_format($items[$delta], $format, $instance_settings['version_type']);
  }

  // Construct widget.
  switch ($widget['type']) {
    // Construct text input.
    case 'ph_version_text':
      $element['value'] = $element + array(
        '#type' => 'textfield',
        '#default_value' => $default_value,
        '#element_validate' => array('ph_version_text_value_validate'),
        '#version_format' => $settings['format'],
        '#size' => 25,
      );
      break;
  }

  $element['#element_validate'][] = 'ph_version_field_widget_validate';
  $element['#widget_type'] = $widget['type'];
  return $element;
}

/**
 * Validates version widget.
 */
function ph_version_field_widget_validate($element, &$form_state) {
  switch ($element['#widget_type']) {
    case 'ph_version_text':
      // Set value as version item.
      $version = drupal_array_get_nested_value($form_state['values'], $element['value']['#parents']);
      drupal_array_set_nested_value($form_state['values'], $element['#parents'], $version);
      break;
  }
}

/**
 * Validates version text input.
 */
function ph_version_text_value_validate($element, &$form_state) {
  $version_input = drupal_array_get_nested_value($form_state['values'], $element['#parents']);
  if ($version_input) {
    // Extract version info.
    $version = ph_version_extract_info($version_input);
    drupal_array_set_nested_value($form_state['values'], $element['#parents'], $version);

    // Validate version.
    if ($version === FALSE) {
      form_error($element, t('The version format is invalid.'));
    }
    elseif (in_array($element['#version_format'], array('standard', 'tag')) && !ph_version_valid_format($version_input, $element['#version_format'])) {
      // Display corresponding error message.
      if ($element['#version_format'] == 'standard') {
        form_error($element, t('The version must be in standard format (e.g. 7.x-1.0-beta2, 7.x-1.x-dev).'));
      }
      elseif ($element['#version_format'] == 'tag') {
        form_error($element, t('The version must be in tag format (e.g. 7.x-1.0-beta2, 7.x-1.x).'));
      }
    }
  }
}

/**
 * Implements hook_field_widget_error().
 */
function ph_version_field_widget_error($element, $error, $form, &$form_state) {
  $error_element = $element;
  switch ($error['error']) {
    case 'ph_version_type':
      if ($element['#widget_type'] == 'ph_version_text') {
        $error_element = $element['value'];
      }
      break;
  }

  form_error($error_element, $error['message']);
}

/**
 * Implements hook_field_formatter_info().
 */
function ph_version_field_formatter_info() {
  return array(
    'ph_version_standard' => array(
      'label' => t('Standard'),
      'description' => t('Formats a simple, standard version string.'),
      'field types' => array('ph_version'),
      'settings' => array(),
    ),
    'ph_version_full' => array(
      'label' => t('Full'),
      'description' => t('Formats full version string, complete with details suitable for comparison.'),
      'field types' => array('ph_version'),
      'settings' => array(),
    ),
    'ph_version_tag' => array(
      'label' => t('Tag'),
      'description' => t('Formats as version control tag.'),
      'field types' => array('ph_version'),
      'settings' => array(),
    ),
    'ph_version_component' => array(
      'label' => t('Component'),
      'description' => t('Displays a specific component of a version string.'),
      'field types' => array('ph_version'),
      'settings' => array('component' => 'core'),
    ),
  );
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function ph_version_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $summary = '';

  if ($display['type'] == 'ph_version_component') {
    $labels = ph_version_component_options();
    $summary = t('Display: @component', array('@component' => $labels[$settings['component']]));
  }

  return $summary;
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function ph_version_field_formatter_settings_form($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $element = array();

  if ($display['type'] == 'ph_version_component') {
    $element['component'] = array(
      '#type' => 'radios',
      '#title' => t('Display:'),
      '#default_value' => $settings['component'],
      '#options' => ph_version_component_options(),
      '#required' => TRUE,
    );
    return $element;
  }
}

/**
 * Returns displayable version component option labels.
 */
function ph_version_component_options() {
  return array(
    'core_api' => t('Core API version'),
    'core' => t('Drupal core version'),
    'core_minor' => t('Drupal core minor version'),
    'major' => t('Contribution major version'),
    'patch' => t('Patch level'),
    'extra' => t('Extra version identifier'),
    'increment' => t('Commit increment'),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function ph_version_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  static $version_format_map = array(
    'ph_version_full' => 'full',
    'ph_version_standard' => 'standard',
    'ph_version_tag' => 'tag',
  );

  $element = array();
  $settings = $display['settings'];
  $display_type = $display['type'];

  if (isset($version_format_map[$display_type])) {
    foreach ($items as $delta => $item) {
      $element[$delta] = array(
        '#markup' => check_plain(ph_version_format($item, $version_format_map[$display_type])),
      );
    }
  }
  elseif ($display['type']) {
    $component = $settings['component'];
    foreach ($items as $delta => $item) {
      $output = NULL;
      if ($component == 'core_api') {
        $output = ph_version_format($item, 'core_api');
      }
      elseif (isset($item[$component])) {
        $output = $item[$component];
      }
      if (isset($output)) {
        $element[$delta] = array(
          '#markup' => check_plain($output),
        );
      }
    }
  }

  return $element;
}

/**
 * Implements hook_views_api().
 */
function ph_version_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'ph_version') . '/views',
  );
}

/**
 * Implements hook_field_views_data().
 */
function ph_version_field_views_data($field) {
  $data = field_views_field_default_views_data($field);
  $field_name = $field['field_name'];
  list($label) = field_views_field_label($field_name);

  foreach ($data as $table => $table_data) {
    $base_data = array(
      'field_name' => $field_name,
    );
    if (isset($table_data['entity_id'])) {
      $field_column = $table_data['entity_id']['field']['moved to'][1];
    }
    else {
      $base_data['is revision'] = TRUE;
      $field_column = $table_data['revision_id']['field']['moved to'][1];
    }

    // Adjust default field.
    $data[$table][$field_column]['field']['click sortable'] = FALSE;
    if (isset($data[$table][$field_column]['field']['real field'])) {
      unset($data[$table][$field_column]['field']['real field']);
    }

    // Duplicate default field data from main field.
    $field_data = $table_data[$field_column];
    $field_data = array_diff_key($field_data, array_flip(array('argument', 'filter', 'sort')));

    // Add 'is_dev' property.
    $column_real_name = $field_name . '_is_dev';
    $data[$table][$column_real_name] = array(
      'title' => t('@field is development', array('@field' => $label)),
      'title short' => t('@field:is_dev', array('@field' => $label)),
    ) + $field_data;
    $data[$table][$column_real_name]['field'] = array(
      'handler' => 'ph_version_views_handler_field_dev',
      'additional fields' => array(
        $field_name . '_patch',
        $field_name . '_increment',
      ),
    ) + $base_data;
    $data[$table][$column_real_name]['filter'] = array(
      'field' => $column_real_name,
      'table' => $table,
      'handler' => 'ph_version_views_handler_filter_dev',
      'label' => t('Development'),
      'additional fields' => $data[$table][$column_real_name]['field']['additional fields'],
      'allow empty' => TRUE,
    ) + $base_data;
  }

  return $data;
}

/**
 * Formats a version string.
 *
 * @param array $version
 *   Version info structure.
 * @param $format
 *   Version format name, one of:
 *   - full: Detailed development snapshot information.
 *   - standard: Generic development version, e.g. '7.x-1.x-dev'.
 *   - tag: Version control tag, e.g. '7.x-1.x'.
 *   - core_api: Core API version, e.g. '7.x'.
 * @param $type
 *   Type of version to constrain to, 'core' to omit any major version, all
 *   available parts displayed (per format) otherwise.
 * @return string
 *   Formatted version string.
 */
function ph_version_format(array $version, $format = 'full', $type = '') {
  // Add core base.
  $string = $version['core'] . '.';
  if (isset($version['core_minor'])) {
    $string .= $version['core_minor'] . '.';
  }

  // Return core API version.
  if ($format == 'core_api') {
    return $string . 'x';
  }

  // Add contribution major version.
  if (isset($version['major']) && $type != 'core') {
    $string .= 'x-' . $version['major'] . '.';
  }

  // Add development snapshot suffix.
  if (!isset($version['patch']) || isset($version['increment']) && $format != 'full') {
    $string .= 'x';
    // Add '-dev' only if not formatting as tag.
    if ($format != 'tag') {
      $string .= '-dev';
    }
  }
  // Add patch level.
  else {
    $string .= $version['patch'];

    // Add extra version.
    if (isset($version['extra'])) {
      $string .= '-' . $version['extra'];
    }

    // Add full development snapshot suffix.
    if (isset($version['increment'])) {
      $string .= '+' . $version['increment'] . '-dev';
    }
  }

  return $string;
}

/**
 * Constructs a stub default version structure.
 */
function ph_version_defaults() {
  static $keys = array('core', 'core_minor', 'major', 'patch', 'extra', 'increment');
  return array_fill_keys($keys, NULL);
}

/**
 * Makes a version structure with given initial values.
 */
function ph_version_make(array $initial) {
  $defaults = ph_version_defaults();
  $values = array_intersect_key($initial, $defaults);
  return array_merge($defaults, $values);
}

/**
 * Creates a wrapped version array.
 */
function ph_version_rules_create_array(array $values) {
  return rules_wrap_data(ph_version_make($values), array('type' => 'ph_version'));
}

/**
 * Standardizes version info by removing non-applicable parts.
 */
function ph_version_standardize(array $version) {
  if (!ph_version_is_dev($version)) {
    return $version;
  }
  else {
    $version['patch'] = NULL;
    $version['extra'] = NULL;
    $version['increment'] = NULL;
    return $version;
  }
}

/**
 * Extracts an version info structure from a version string.
 *
 * @param $version
 *   Version string.
 * @return array
 *   Version info structure array, or FALSE if $version is an invalid string.
 */
function ph_version_extract_info($version) {
  if (preg_match('!^' . str_replace('!', '\!', PH_VERSION_PATTERN) . '$!', $version, $match)) {
    static $pattern_parts = array(
      1 => 'core',
      2 => 'core_minor',
      3 => 'major',
      4 => 'patch',
      5 => 'extra',
      6 => 'increment',
    );

    $info = ph_version_defaults();
    foreach ($match as $i => $value) {
      if (isset($pattern_parts[$i]) && $value !== '') {
        $info[$pattern_parts[$i]] = is_numeric($value) ? (int) $value : $value;
      }
    }

    // Ensure 'extra' is not 'dev'.
    if ($info['extra'] == 'dev') {
      return FALSE;
    }

    return $info;
  }

  return FALSE;
}

/**
 * Checks whether a given version string is in a particular format.
 *
 * @param string $version
 *   Version string.
 * @param string $format
 *   Version format name. See ph_version_format() for a list of valid options.
 * @return bool
 *   TRUE if the version is valid with matching format, FALSE otherwise.
 */
function ph_version_valid_format($version, $format) {
  $result = &drupal_static(__FUNCTION__, array());

  if (!is_string($version) || !is_string($format)) {
    return FALSE;
  }

  if (!isset($result[$version][$format])) {
    $info = ph_version_extract_info($version);
    $result[$version][$format] = !empty($info) && ph_version_format($info, $format) == $version;
  }

  return $result[$version][$format];
}

/**
 * Determines if a version is a core version.
 *
 * @param array $version
 *   Version info structure.
 * @return bool
 *   TRUE if core version, FALSE otherwise.
 */
function ph_version_is_core(array $version) {
  return !isset($version['major']);
}

/**
 * Determines if a version is a development snapshot.
 *
 * A version is for a development snapshot if there is no patch level or if
 * there is a commit increment (i.e. since the last patch level).
 *
 * @param array $version
 *   Version info structure.
 * @return bool
 *   TRUE if a development version, FALSE otherwise.
 */
function ph_version_is_dev(array $version) {
  return !isset($version['patch']) || isset($version['increment']);
}
