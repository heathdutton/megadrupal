<?php
/**
 * @file
 * Source repository management entity.
 */

/**
 * Implements hook_pemission().
 */
function ph_repository_permission() {
  return array(
    'administer project repository' => array(
      'title' => t('Administer project repository'),
      'restrict access' => TRUE,
    ),
    'view project repository' => array(
      'title' => t('View project repository'),
    ),
    'update project repository' => array(
      'title' => t('Update project repository'),
    ),
    'create project repository' => array(
      'title' => t('Create project repository'),
    ),
    'delete project repository' => array(
      'title' => t('Delete project repository'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function ph_repository_menu() {
  $items['admin/config/system/ph-repository'] = array(
    'title' => 'Project repository settings',
    'description' => 'Configure settings for repository operations.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ph_repository_admin_settings'),
    'access arguments' => array('administer project repository'),
    'file' => 'ph_repository.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/config/system/ph-repository/repository'] = array(
    'title' => 'Repository',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -5,
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function ph_repository_theme() {
  return array(
    'ph_repository_directory_help' => array(
      'render element' => 'element',
      'file' => 'ph_repository.admin.inc',
    ),
  );
}

/**
 * Implements hook_entity_info().
 */
function ph_repository_entity_info() {
  $entity_info['ph_repository'] = array(
    'label' => t('Project repository'),
    'entity class' => 'PHRepository',
    'controller class' => 'EntityAPIController',
    'metadata controller class' => 'PHRepositoryMetadataController',
    'base table' => 'ph_repository',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'rid',
      'bundle' => 'type',
    ),
    'bundles' => array(),
    'access callback' => 'ph_repository_entity_access',
    'form callback' => 'ph_repository_entity_form',
    'token type' => 'ph-repository',
    'module' => 'ph_repository',
    'inline entity form' => array(
      'controller' => 'PHRepositoryInlineEntityFormController',
    ),
  );

  // Add available repository types as bundles.
  $types = ph_repository_get_types();
  foreach ($types as $type => $info) {
    if (module_exists($info['module'])) {
      $entity_info['ph_repository']['bundles'][$type] = array(
        'label' => $info['label'],
        'backend class' => $info['backend class'],
      );
    }
  }

  return $entity_info;
}

/**
 * Loads a single repository entity.
 *
 * @param $rid
 * @return PHRepository
 */
function ph_repository_load($rid) {
  $entities = entity_load('ph_repository', array($rid));
  return $entities ? reset($entities) : NULL;
}

/**
 * Determines user access to repository.
 */
function ph_repository_entity_access($op, $entity = NULL, $account = NULL) {
  // Permit restrictive administration access.
  $permission = 'administer project repository';
  if (user_access($permission, $account)) {
    return TRUE;
  }

  // Check CRUD permissions.
  switch ($op) {
    case 'view':
    case 'update':
    case 'create':
    case 'delete':
      $permission = $op . ' project repository';
      return user_access($permission, $account);
  }

  // Forbid by default.
  return FALSE;
}

/**
 * Builds the entity form for a repository.
 */
function ph_repository_entity_form($repository) {
  return drupal_get_form('ph_repository_form', $repository);
}

/**
 * Constructs a repository edit form.
 */
function ph_repository_form($form, &$form_state, $repository) {
  // Add entity keys for constructing pseudo-entity when validating.
  $form['rid'] = array(
    '#type' => 'value',
    '#value' => $repository->rid,
  );
  $form['type'] = array(
    '#type' => 'value',
    '#value' => $repository->type,
  );

  // Attach field form.
  field_attach_form('ph_repository', $repository, $form, $form_state);

  // Add action buttons.
  $form['actions'] = array(
    '#type' => 'actions',
    '#weight' => 20,
  );
  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
  );

  return $form;
}

/**
 * Validates repository edit form submission.
 */
function ph_repository_form_validate($form, &$form_state) {
  // Validate fields.
  entity_form_field_validate('ph_repository', $form, $form_state);
}

/**
 * Handles repository edit form submission and saves the repository.
 */
function ph_repository_form_submit($form, &$form_state) {
  /** @var $repository PHRepository */
  $repository = reset($form_state['build_info']['args']);
  entity_form_submit_build_entity('ph_repository', $repository, $form, $form_state);
  $repository->save();
}

/**
 * Checks a text input for a valid working directory.
 */
function ph_repository_validate_directory($element, &$form_state) {
  $directory = $element['#value'];

  // Check existing file.
  if (file_exists($directory)) {
    if (!is_dir($directory)) {
      form_error($element, t('The specified path exists but is not a directory.'));
    }
    elseif (!file_prepare_directory($directory)) {
      form_error($element, t('The specified directory is not writable.'));
    }
    return;
  }

  // Attempt to create directory if under Drupal file system.
  $scheme = file_uri_scheme($directory);
  if ($scheme && in_array($scheme, array('public', 'private', 'temporary'))) {
    file_prepare_directory($directory, FILE_CREATE_DIRECTORY);
  }

  // Check directory.
  if (!file_exists($directory)) {
    form_error($element, t('The specified directory does not exist.'));
  }
}

/**
 * Retrieves plugin information about a repository type.
 */
function ph_repository_get_type($type, $reset = FALSE) {
  $types = &drupal_static(__FUNCTION__);

  if (!$types || $reset) {
    if ($cache = cache_get('ph_repository_types')) {
      $types = $cache->data;
    }
    else {
      // Collect types.
      $types = array();
      foreach (module_implements('ph_repository_info') as $module) {
        $repository_info = module_invoke($module, 'ph_repository_info');
        if ($repository_info) {
          foreach ($repository_info as $repository_type => $repository_type_info) {
            // Add defaults.
            $repository_type_info += array(
              'label' => '',
              'backend class' => '',
              'module' => $module,
              'field_config' => array(),
              'field_instance' => array(),
            );
            // Fill in default field info.
            foreach ($repository_type_info['field_config'] as &$field_config) {
              $field_config += array(
                'field_name' => '',
                'type' => '',
              );
            }
            unset($field_config);
            foreach ($repository_type_info['field_instance'] as &$field_instance) {
              $field_instance += array(
                'field_name' => '',
                'entity_type' => 'ph_repository',
                'bundle' => $repository_type,
              );
            }
            unset($field_instance);
            // Register type.
            $types[$repository_type] = $repository_type_info;
          }
        }
      }
      // Cache types.
      cache_set('ph_repository_types', $types);
    }
  }

  return isset($type) ? (isset($types[$type]) ? $types[$type] : NULL) : $types;
}

/**
 * Retrieves plugin information about all repository types.
 */
function ph_repository_get_types($reset = FALSE) {
  return ph_repository_get_type(NULL, $reset);
}

/**
 * Clears cached info for repositories.
 */
function ph_repository_cache_clear() {
  drupal_static_reset('ph_repository_get_type');
  cache_clear_all('ph_repository_types', 'cache');
}

/**
 * Implements hook_flush_caches().
 */
function ph_repository_flush_caches() {
  ph_repository_ensure_fields();
}

/**
 * Implements hook_modules_enabled().
 */
function ph_repository_modules_enabled($modules) {
  // Determine which modules implement repositories.
  $repository_providers = array();
  foreach ($modules as $module) {
    if (module_hook($module, 'ph_repository_info')) {
      $repository_providers[] = $module;
    }
  }

  if ($repository_providers) {
    // Reset types.
    ph_repository_cache_clear();
    // Set up fields provided by modules implementing repository types.
    ph_repository_ensure_fields($repository_providers);
  }
}

/**
 * Implements hook_modules_disabled().
 */
function ph_repository_modules_disabled($modules) {
  // Determine which modules implement repositories.
  $repository_providers = array();
  foreach ($modules as $module) {
    if (module_hook($module, 'ph_repository_info')) {
      $repository_providers[] = $module;
    }
  }

  if ($repository_providers) {
    // Reset types.
    ph_repository_cache_clear();
  }
}

/**
 * Ensures fields and instances provided by repository types are set up.
 */
function ph_repository_ensure_fields(array $modules = array()) {
  // Set up fields.
  $fields = ph_repository_get_ensured_fields($modules);
  ph_repository_ensure_create_fields($fields);

  // Set up instances.
  $instances = ph_repository_get_ensured_instances($modules);
  ph_repository_ensure_create_instances($instances);
}

/**
 * Gets ensured fields.
 */
function ph_repository_get_ensured_fields(array $modules = array()) {
  $types = ph_repository_get_types();
  $fields = array();
  foreach ($types as $type) {
    if (empty($modules) || in_array($type['module'], $modules)) {
      foreach ($type['field_config'] as $field_config) {
        if (!empty($field_config['field_name'])) {
          $fields[] = $field_config;
        }
      }
    }
  }
  return $fields;
}

/**
 * Gets ensured fields.
 */
function ph_repository_get_ensured_instances(array $modules = array()) {
  $types = ph_repository_get_types();
  $instances = array();
  foreach ($types as $type) {
    if (empty($modules) || in_array($type['module'], $modules)) {
      foreach ($type['field_instance'] as $field_instance) {
        if (!empty($field_instance['field_name'])) {
          $instances[] = $field_instance;
        }
      }
    }
  }
  return $instances;
}

/**
 * Ensures fields are created.
 */
function ph_repository_ensure_create_fields(array $fields) {
  foreach ($fields as $field_config) {
    // Create field if not exists.
    $field = field_info_field($field_config['field_name']);
    if (!$field) {
      try {
        field_create_field($field_config);
      }
      catch (Exception $e) {
        // Catch and log all errors.
        watchdog_exception('ph_repository', $e);
      }
    }
  }
}

/**
 * Ensures field instances are created.
 */
function ph_repository_ensure_create_instances(array $instances) {
  foreach ($instances as $field_instance) {
    // Create instance if not exists.
    $instance = field_info_instance($field_instance['entity_type'], $field_instance['field_name'], $field_instance['bundle']);
    if (!$instance) {
      try {
        field_create_instance($field_instance);
      }
      catch (Exception $e) {
        // Catch and log all errors.
        watchdog_exception('ph_repository', $e);
      }
    }
  }
}

/**
 * Gets the working directory for repositories.
 */
function ph_repository_working_directory($create_directory = TRUE) {
  $directory = variable_get('ph_repository_working_directory', 'temporary://ph_repository');
  $writable = ph_repository_prepare_working_directory($directory, $create_directory);
  return $writable ? $directory : FALSE;
}

/**
 * Prepares working directory.
 */
function ph_repository_prepare_working_directory($directory, $create_directory = TRUE) {
  $prepare_options = $create_directory ? FILE_CREATE_DIRECTORY : 0;
  $prepare_options |= FILE_MODIFY_PERMISSIONS;
  return file_prepare_directory($directory, $prepare_options);
}

/**
 * Implements hook_entity_delete().
 */
function ph_repository_entity_delete($entity, $type) {
  if ($type == 'ph_repository' && $entity instanceof PHRepository) {
    try {
      $directory = $entity->getWorkingDirectory();
      if (file_exists($directory)) {
        file_unmanaged_delete_recursive($directory);
      }
    }
    catch (PHRepositoryException $e) {
      return;
    }
  }
}

/**
 * Returns the summary for a repository.
 */
function ph_repository_get_summary(PHRepository $repository) {
  return $repository->backend()->getSummary();
}

/**
 * Synchronizes a repository.
 */
function ph_repository_synchronize(PHRepository $repository) {
  $repository->backend()->synchronize();
}

/**
 * Lists exportable versions from a repository.
 */
function ph_repository_list_versions(PHRepository $repository) {
  // Automatically synchronize repository.
  if (variable_get('ph_repository_sync_auto')) {
    ph_repository_synchronize($repository);
  }

  $versions = $repository->backend()->listVersions();
  $versions = array_map('ph_version_standardize', $versions);
  return $versions;
}

/**
 * Exports a specified repository version into a directory.
 */
function ph_repository_export(PHRepository $repository, $directory, $version, $version_since = NULL) {
  // Automatically synchronize repository.
  if (variable_get('ph_repository_sync_auto')) {
    ph_repository_synchronize($repository);
  }
  return $repository->backend()->export(drupal_realpath($directory), $version, $version_since);
}

/**
 * Implements hook_hook_info().
 */
function ph_repository_hook_info() {
  $hooks['ph_repository_info'] = array(
    'group' => 'ph',
  );
  return $hooks;
}
