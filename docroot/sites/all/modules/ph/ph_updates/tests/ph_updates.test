<?php
/**
 * @file
 * Tests for the updates feed.
 */

/**
 * Updates feed tests.
 */
class PHUpdatesFeedTest extends DrupalWebTestCase {
  /**
   * Declares test.
   */
  public static function getInfo() {
    return array(
      'name' => 'Updates feed',
      'description' => 'Test basic feed functionality.',
      'group' => 'Project Hosting',
    );
  }

  /**
   * Sets up the test.
   */
  protected function setUp() {
    parent::setUp('ph_updates');
  }

  /**
   * Tests feed path.
   */
  public function testPath() {
    // Test path validation.
    $this->assertTrue(ph_updates_valid_feed_path('path'), 'Feed path is validated.');
    $this->assertFalse(ph_updates_valid_feed_path('path@'), 'Path must contain only valid characters.');
    $this->assertTrue(ph_updates_valid_feed_path('part1/part2'), 'Feed path with multiple segments is valid.');
    $this->assertFalse(ph_updates_valid_feed_path('part1//part2'), 'Path segments must be separated by a single slash.');
    $this->assertFalse(ph_updates_valid_feed_path('/path'), 'Path must not have a leading slash.');
    $this->assertFalse(ph_updates_valid_feed_path('path/'), 'Path must not have a trailing slash.');
  }
}

/**
 * Updates feed data structure tests.
 */
class PHUpdatesDataTest extends DrupalWebTestCase {
  /**
   * Declares test.
   */
  public static function getInfo() {
    return array(
      'name' => 'Updates data',
      'description' => 'Test feed data structure and tree extraction.',
      'group' => 'Project Hosting',
    );
  }

  /**
   * Sets up the test.
   */
  protected function setUp() {
    parent::setUp('ph_updates', 'ph_updates_test');
  }

  /**
   * Tests type construct and extract functions.
   */
  public function testTypeUtility() {
    // Test type construction.
    $type = ph_updates_get_data_type('info', 'test');
    $this->assertEqual('ph_updates_info<test>', $type, 'Full info type is constructed from kind and name.');
    $type = ph_updates_get_data_type('tree', 'test');
    $this->assertEqual('ph_updates_tree<test>', $type, 'Full tree type is constructed from kind and name.');
    $type = ph_updates_get_data_type('invalid', 'test');
    $this->assertNull($type, 'Invalid kind is not used to construct a full type.');
    $type = ph_updates_get_data_type('info', 'invalid');
    $this->assertNull($type, 'Invalid type name is not used to construct a full type.');

    // Test type extraction.
    $name = ph_updates_extract_data_type('ph_updates_info<test>', $kind);
    $this->assertEqual('test', $name, 'Type is extracted from full info type.');
    $this->assertEqual('info', $kind, 'Kind is extracted from full info type.');
    $name = ph_updates_extract_data_type('ph_updates_tree<test>', $kind);
    $this->assertEqual('test', $name, 'Type is extracted from full tree type.');
    $this->assertEqual('tree', $kind, 'Kind is extracted from full tree type.');
    $name = ph_updates_extract_data_type('ph_updates_invalid<test>', $kind);
    $this->assertTrue(!isset($name) && !isset($kind), 'Type is not extracted from full type with unrecognized kind.');
    $name = ph_updates_extract_data_type('ph_updates_info<invalid>', $kind);
    $this->assertTrue(!isset($name) && !isset($kind), 'Type is not extracted from full type with unrecognized name.');
  }

  /**
   * Tests type definition.
   */
  public function testInfo() {
    // Test basic info facility.
    $info = ph_updates_get_info();
    $this->assertNotNull($info['test'], 'Data type is declared.');
    $this->assertNotNull($info['test']['property info']['value']['setter callback'], 'Default setter callback is specified.');
    $this->assertNotNull($info['test']['format info']['']['/'], 'Data type definition is altered.');
    $info = ph_updates_get_info('test');
    $this->assertNotNull($info['label'], 'Specific data type definition is retrieved.');

    // Test Rules info adaptation.
    $cache = rules_get_cache();
    $data_info = $cache['data_info'];
    $this->assertNotNull($data_info['ph_updates_info<test>'], 'Data type is mapped to Rules info type.');
    $this->assertNotNull($data_info['ph_updates_info<test>']['property info'], 'Rules info type contains property info.');
    $this->assertNotNull($data_info['ph_updates_tree<test>'], 'Data type is mapped to Rules tree type.');
    $this->assertNotNull($data_info['ph_updates_tree<test>']['format info'], 'Rules tree type contains format info.');
  }

  /**
   * Tests data tree wrapper.
   */
  public function testTreeFormatInfo() {
    // Test consolidating format info.
    /** @var $wrapper PHUpdatesTreeWrapper */
    $wrapper = ph_updates_data_create('tree', 'test');
    $info = $wrapper->getFormatInfo();
    $this->assertFalse(isset($info['']), 'General format info is removed from consolidated info.');
    $this->assertNotNull($info['test_format'], 'Format info is defined.');
    $this->assertNotNull($info['test_format']['/test'], 'General format info is merged into specific format info.');
    $this->assertNotNull($info['test_format']['/']['test option'], 'Format info is merged by path.');
    $this->assertEqual('overridden', $info['test_format']['/']['general option'], 'Specific format info takes precedence.');
    $this->assertEqual('additional value', $info['test_format']['/']['additional option'], 'Format info is altered.');

    // Test retrieving format info by parameter.
    $consolidatedInfo = $info;
    $info = $wrapper->getFormatInfo('test_format');
    $this->assertIdentical($consolidatedInfo['test_format'], $info, 'Retrieving format info by format type returns format-specific consolidated info.');

    // Ensure setting a tree wrapper value updates enclosing format info.
    /** @var $tree PHUpdatesTreeWrapper */
    $tree = ph_updates_data_create('tree', 'test');
    $tree->mergeFormatInfo(array('test_format' => array('/change' => array('option' => 'value'))));
    $wrapper->set($tree);
    $this->assertIdentical($tree->getFormatInfo(), $wrapper->getFormatInfo(), 'Setting a tree wrapper as value updates the target format info.');
  }

  /**
   * Tests mapping data.
   */
  public function testMapData() {
    // Prepare information.
    /** @var $info PHUpdatesInfoWrapper */
    $info = ph_updates_data_create('info', 'test');
    ph_updates_test_build_project_info($info);

    $tree = $info->extractTree();
    $treeData = $tree->value();

    // Check extracted data.
    $this->assertEqual('value', $treeData['value'], 'Plain value is mapped in tree.');
    $this->assertEqual('struct', $treeData['struct']['value'], 'Structure is mapped in tree.');
    $this->assertEqual('composite', $treeData['composite'], 'Composite value property is mapped in tree.');
    $this->assertEqual(array('container' => 'custom'), $treeData['custom'], 'Custom value callback produces value mapped in tree.');
    $this->assertEqual('list item', $treeData['list'][0], 'List item is mapped directly in tree.');
    $this->assertEqual('list_nested item', $treeData['list_nested'][0]['value'], 'List item is mapped as nested value in tree.');
    $this->assertEqual('list_composite item', $treeData['list_composite'][0]['composite'], 'List item is mapped as composite value in tree.');
    $this->assertEqual(array('container' => 'list_custom item'), $treeData['list_custom'][0], 'Custom value callback produces list item value mapped in tree.');
    $this->assertEqual(array('container' => 'list_custom_nested item'), $treeData['list_custom_nested'][0]['value'], 'Custom value callback produces list item value mapped as nested value in tree.');
    $this->assertEqual('subinfo', $treeData['subinfo']['composite'], 'Nested info data is mapped in tree.');
    $this->assertEqual('subtree', $treeData['subtree']['composite'], 'Nested tree data is mapped in tree.');
    $this->assertEqual('deep_struct', $treeData['subinfo']['struct']['value'], 'Deep selector selects a deep property.');
    $this->assertFalse(isset($treeData['subtree']['value']), 'Partial tree data is extracted.');

    // Check merged format info.
    $formatInfo = $tree->getFormatInfo();
    $expected = $formatInfo['test_format']['/test'];
    $this->assertEqual($expected, $formatInfo['test_format']['/subtree/test'], 'Format info for nested tree is merged into tree.');
    $this->assertEqual($expected, $formatInfo['test_format']['/subinfo/test'], 'Format info for nested info is merged into tree.');
    $this->assertEqual($expected, $formatInfo['test_format']['/subinfo/subtree/test'], 'Format info for deep-nested tree in nested info is merged into tree.');
    $this->assertEqual($expected, $formatInfo['test_format']['/subtree/subtree/test'], 'Format info for deep-nested tree in nested tree is merged into tree.');
  }
}

/**
 * Feed formatter framework tests.
 */
class PHUpdatesFormatTest extends DrupalWebTestCase {
  /**
   * Declares test.
   */
  public static function getInfo() {
    return array(
      'name' => 'Updates feed format',
      'description' => 'Test feed format framework and extension.',
      'group' => 'Project Hosting',
    );
  }

  /**
   * Sets up the test.
   */
  protected function setUp() {
    parent::setUp('ph_updates_test');
    // Format feeds using the test format.
    variable_set('ph_updates_feed_format', 'test_format');
    variable_set('ph_updates_feed_path', 'release-history');
  }

  /**
   * Tests the format info.
   */
  public function testInfo() {
    $info = ph_updates_get_format_info();
    $this->assertTrue(isset($info['test_format']), 'Feed format info is defined.');
    $this->assertEqual('ph_updates_test', $info['test_format']['module'], 'Feed format provider module is defined.');
  }

  /**
   * Tests formatting the tree.
   */
  public function testFormat() {
    $user = $this->drupalCreateUser(array('view project updates feed'));
    $this->drupalLogin($user);

    $this->drupalGet('release-history/test_project/7.x');
    $this->assertRaw('a:2:{s:10:"short_name";s:12:"test_project";s:11:"api_version";s:3:"7.x";}', 'Project feed is displayed.');
    $this->drupalGet('release-history/invalid/7.x');
    $this->assertRaw('No release history was found for the requested project (invalid).', 'Accessing invalid project name results in error.');
    $this->drupalGet('release-history/test_project/6.x');
    $this->assertRaw('No release history available for test_project 6.x.', 'Accessing invalid core API version results in error.');
  }
}

/**
 * XML feed formatter tests.
 */
class PHUpdatesXMLFormatTest extends DrupalWebTestCase {
  /**
   * Declares test.
   */
  public static function getInfo() {
    return array(
      'name' => 'XML format',
      'description' => 'Test feed format using XML.',
      'group' => 'Project Hosting',
    );
  }

  /**
   * Sets up the test.
   */
  protected function setUp() {
    parent::setUp('ph_updates_test');
    // Build info for testing.
    variable_set('ph_updates_test_build_info', TRUE);
  }

  /**
   * Tests XML formatting.
   */
  public function testFormat() {
    $test_info = ph_updates_data_create('info', 'test');
    ph_updates_test_build_project_info($test_info);
    $tree = $test_info->extractTree();
    $formatter = ph_updates_format_create('xml');
    $xml = $formatter->format($tree);

    $search = '</root>';
    $this->assertMatchString($search, $xml, 'Root element is formatted using the specified name.');
    $search = '<root xmlns:x="http://xml.example.com/ns"';
    $this->assertMatchString($search, $xml, 'Declared namespace prefix is formatted.');
    $search = '</x:value>';
    $this->assertMatchString($search, $xml, 'Element is formatted with prefix.');
    $search = '<x:value>';
    $this->assertMatchString($search, $xml, 'Re-declared namespace prefix definition is not formatted.');
    $search = '</custom_alt>';
    $this->assertMatchString($search, $xml, 'Element name is overridden when formatted.');
    $search = '<custom_alt xmlns="http://xml.example.com/ns"';
    $this->assertMatchString($search, $xml, 'Element default namespace is formatted.');
    $search = '</x:container>';
    $this->assertMatchString($search, $xml, 'Format information for nested element is applied.');
    $search = '<x:container xmlns:y="http://xml.example.com/ns3"';
    $this->assertMatchString($search, $xml, 'Namespace prefix definition for nested element is formatted on the element.');
    $search = '<x:container xmlns:y="http://xml.example.com/ns3" xmlns:x="http://xml.example.com/ns2"';
    $this->assertMatchString($search, $xml, 'Default namespace for nested element is formatted on the element.');
    $search = '</a:list>';
    $this->assertMatchString($search, $xml, 'Unknown prefix is output regardless.');
    $search = '<a:list xmlns:x="http://xml.example.com/ns1"';
    $this->assertMatchString($search, $xml, 'Different namespace URI for existing prefix is formatted on the declaring element.');
  }

  /**
   * Asserts a string is found in another.
   */
  protected function assertMatchString($needle, $haystack, $message = '') {
    if (!$message) {
      $message = 'Text string is found.';
    }
    $this->assertTrue(is_int(strpos($haystack, $needle)), $message);
  }
}
