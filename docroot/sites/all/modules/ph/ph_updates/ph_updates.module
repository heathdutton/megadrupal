<?php
/**
 * @file
 * Updates feed publisher module.
 */

module_load_include('inc', 'ph_updates', 'ph_updates.property');

/**
 * Feed path regular expression.
 */
define('PH_UPDATES_FEED_PATH_PATTERN', '!^[\w.-]+(/[\w.-]+)*$!i');

/**
 * Implements hook_permission().
 */
function ph_updates_permission() {
  return array(
    'view project updates feed' => array(
      'title' => t('View project updates feed'),
    ),
    'configure project updates feed' => array(
      'title' => t('Configure project updates feed'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function ph_updates_menu() {
  $path = variable_get('ph_updates_feed_path');
  if (ph_updates_valid_feed_path($path)) {
    $path_parts = explode('/', $path);
    $path_count = count($path_parts);
    $items[$path . '/%/%'] = array(
      'title' => 'Project updates feed',
      'page callback' => 'ph_updates_view_feed',
      'page arguments' => array($path_count, $path_count + 1),
      'delivery callback' => 'ph_updates_deliver_feed',
      'access arguments' => array('view project updates feed'),
      'file' => 'ph_updates.pages.inc',
    );
  }

  $items['admin/config/system/ph-updates'] = array(
    'title' => 'Project updates feed settings',
    'description' => 'Configure settings for publishing the updates feed.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ph_updates_admin_settings'),
    'access arguments' => array('configure project updates feed'),
    'file' => 'ph_updates.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/config/system/ph-updates/general'] = array(
    'title' => 'General',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -5,
  );

  return $items;
}

/**
 * Validates feed path.
 */
function ph_updates_valid_feed_path($path) {
  return (bool) preg_match(PH_UPDATES_FEED_PATH_PATTERN, $path);
}

/**
 * Delivers an updates feed as its own page.
 */
function ph_updates_deliver_feed($result) {
  if (is_numeric($result)) {
    // Deliver an error code as if it were a regular HTML page.
    drupal_deliver_html_page($result);
  }
  elseif (is_array($result)) {
    print drupal_render($result);
  }
  // Invoke regular footer to allow page caching.
  drupal_page_footer();
}

/**
 * Derives the full name of a data type.
 *
 * @param $kind
 *   Kind of type name to construct, either 'info' or 'tree'. An 'info' type
 *   contains type properties. A 'tree' type contains format info.
 * @param $name
 *   Name of data type declared in hook_ph_updates_info().
 * @return string
 *   Full type name, or NULL if given kind is invalid or name is unrecognized.
 *
 * @see hook_ph_updates_info().
 */
function ph_updates_get_data_type($kind, $name) {
  // Validate kind.
  if (!in_array($kind, array('info', 'tree'), TRUE)) {
    return NULL;
  }
  // Validate name.
  if (!ph_updates_get_info($name)) {
    return NULL;
  }
  // Return full name.
  return "ph_updates_$kind<$name>";
}

/**
 * Extracts the contained data type name.
 *
 * @param $type
 *   Full type name.
 * @param $kind
 *   Reference to the extracted data type kind.
 * @return string
 *   Data type name as defined in hook_ph_updates_info(), or NULL if type name
 *   is not recognized.
 */
function ph_updates_extract_data_type($type, &$kind = NULL) {
  $kind = NULL;

  // Check type.
  if (!is_string($type)) {
    return NULL;
  }
  // Match type name.
  if (preg_match('/^ph_updates_(\w+)<(\w+)>$/', $type, $match)) {
    // Validate matched kind.
    if (!in_array($match[1], array('info', 'tree'))) {
      return NULL;
    }
    // Validate matched name.
    if (!ph_updates_get_info($match[2])) {
      return NULL;
    }
    // Pass.
    $kind = $match[1];
    return $match[2];
  }
  // Fail.
  return NULL;
}

/**
 * Creates a data wrapper for a specific type.
 *
 * See ph_updates_get_data_type() for parameter usage.
 *
 * @param $kind
 *   Kind of type name.
 * @param $name
 *   Name of data type.
 * @param array $data
 *   Initial data.
 * @return EntityMetadataWrapper
 *   Data wrapper.
 */
function ph_updates_data_create($kind, $name, array $data = array()) {
  $type = ph_updates_get_data_type($kind, $name);
  if (isset($type)) {
    return rules_wrap_data($data, array('type' => $type), TRUE);
  }
  return NULL;
}

/**
 * Extracts a data tree from an update info wrapper.
 */
function ph_updates_extract_tree(EntityMetadataWrapper $wrapper) {
  if ($wrapper instanceof PHUpdatesTreeExtractable) {
    $tree = $wrapper->extractTree();
    return rules_wrap_data($tree, array('type' => 'ph_updates_tree'), TRUE);
  }
  return NULL;
}

/**
 * Value callback for a comma-delimited list of values.
 */
function ph_updates_value_comma_delimited_list(EntityListWrapper $list) {
  $values = array();
  foreach ($list as $item) {
    if ($item instanceof EntityValueWrapper) {
      $values[] = $item->value();
    }
  }
  return implode(',', $values);
}

/**
 * Value callback for boolean value switching 'published' and 'not published'.
 */
function ph_updates_value_boolean_published(EntityMetadataWrapper $property) {
  return $property->value() ? 'published' : 'not published';
}

/**
 * Retrieves update data type definition.
 */
function ph_updates_get_info($type = NULL, $reset = FALSE) {
  $data_info = &drupal_static(__FUNCTION__);

  if (!isset($data_info) || $reset) {
    if (!$reset && $cache = cache_get('ph_updates_info')) {
      $data_info = $cache->data;
    }
    else {
      // Build info.
      $data_info = module_invoke_all('ph_updates_info');
      // Give other modules a chance to modify info.
      drupal_alter('ph_updates_info', $data_info);
      // Process info.
      foreach ($data_info as $data_type => &$info) {
        // Fill in defaults.
        $info += array(
          'label' => '',
          'property info' => array(),
          'format info' => array(),
        );
        $info['property info'] = ph_updates_process_property_info($info['property info']);
      }
      unset($info);
      // Save info to cache.
      cache_set('ph_updates_info', $data_info);
    }
  }

  return !isset($type) ? $data_info : (isset($data_info[$type]) ? $data_info[$type] : NULL);
}

/**
 * Processes properties for info.
 */
function ph_updates_process_property_info($property_info) {
  foreach ($property_info as $name => &$info) {
    // Add default info.
    if (!empty($info['type'])) {
      // Add default setter callback for a typed property.
      $info += array(
        'setter callback' => 'entity_property_verbatim_set',
      );
    }
    // Process nested properties.
    if (!empty($info['property info'])) {
      $info['property info'] = ph_updates_process_property_info($info['property info']);
    }
  }
  return $property_info;
}

/**
 * Retrieves update format definition.
 */
function ph_updates_get_format_info($format = NULL, $reset = FALSE) {
  $format_info = &drupal_static(__FUNCTION__);

  if (!isset($format_info) || $reset) {
    if (!$reset && $cache = cache_get('ph_updates_format_info')) {
      $format_info = $cache->data;
    }
    else {
      // Build info.
      $format_info = array();
      foreach (module_implements('ph_updates_format_info') as $module) {
        if ($module_info = module_invoke($module, 'ph_updates_format_info')) {
          foreach ($module_info as $module_format => $info) {
            // Fill in defaults.
            $info += array(
              'label' => '',
              'class' => '',
              'mimetype' => 'text/plain',
              'module' => $module,
            );
            $format_info[$module_format] = $info;
          }
        }
      }
      // Save info to cache.
      cache_set('ph_updates_format_info', $format_info);
    }
  }

  return !isset($format) ? $format_info : (isset($format_info[$format]) ? $format_info[$format] : NULL);
}

/**
 * Creates a format object for formatting a tree.
 *
 * @param string $format
 * @return PHUpdatesFormatInterface
 */
function ph_updates_format_create($format) {
  if ($info = ph_updates_get_format_info($format)) {
    return new $info['class']();
  }
  else {
    return NULL;
  }
}

/**
 * Builds a project update feed.
 *
 * @param string $name
 *   Project name.
 * @param string $core_api
 *   Core API version, e.g. '7.x'.
 * @return PHUpdatesTreeWrapper
 * @throws PHUpdatesInfoError
 */
function ph_updates_build_project_tree($name, $core_api) {
  // Build project info.
  /** @var $info PHUpdatesInfoWrapper */
  $info = ph_updates_data_create('info', 'project');
  module_invoke_all('ph_updates_project_info_build', $info, $name, $core_api);
  drupal_alter('ph_updates_project_info', $info, $name, $core_api);
  module_invoke_all('ph_updates_project_info_check', $info, $name, $core_api);

  // Normalize releases.
  $releases_wrapper = $info->get('releases');
  try {
    if ($releases = $releases_wrapper->value()) {
      // Group release by development status.
      $regular_releases = array();
      $dev_releases = array();
      foreach ($releases as $release) {
        $release_data = $release->value();
        if (isset($release_data['version_extra']) && $release_data['version_extra'] == 'dev') {
          $dev_releases[] = $release;
        }
        else {
          $regular_releases[] = $release;
        }
      }
      // Place development releases at the end.
      $releases_wrapper->set(array_merge($regular_releases, $dev_releases));
    }
  }
  catch (EntityMetadataWrapperException $ex) {}

  return $info->extractTree();
}

/**
 * Implements hook_hook_info().
 */
function ph_updates_hook_info() {
  $info = array(
    'group' => 'ph',
  );
  $hooks['ph_updates_info'] = $info;
  $hooks['ph_updates_info_alter'] = $info;
  $hooks['ph_updates_format_info'] = $info;
  $hooks['ph_updates_project_info_build'] = $info;
  $hooks['ph_updates_project_info_alter'] = $info;
  $hooks['ph_updates_project_info_check'] = $info;
  return $hooks;
}

/**
 * Implements hook_ph_updates_project_info_build() on behalf of rules.
 */
function rules_ph_updates_project_info_build(PHUpdatesInfoWrapper $info, $name, $core_api) {
  rules_invoke_event('ph_updates_project_info_build', $info, $name, ph_version_extract_info($core_api));
}
