<?php

/**
 * @file
 * Support for reminders for nodes with dates.
 *
 * anon_datereminder, or date reminder.  A module that lets an anonymous user
 * ask for a reminder to be set at one or more durations before a
 * scheduled event.  It can be a repeating event; reminders will
 * be sent at the requested times before each occurrence.
 *
 * This is a refactoring of the datereminder module.
 *
 * See the README file for a list of outstanding issues.
 */

/**
 * Implements hook_menu().
 */
function anon_datereminder_menu() {
  module_load_include('inc', 'anon_datereminder', 'includes/defines');

  $cfgbase = 'admin/config/people/anon_datereminder';
  $items = array();

  $items[$cfgbase] = array(
    'title' => 'Anonymous Date reminders',
    'description' => 'Configure reminders for calendar events',
    'page callback' => 'drupal_get_form',
    'access arguments' => array(ANON_DATEREMINDER_ADMINISTER_REMINDERS),
    'page arguments' => array('anon_datereminder_settings_form'),
    'file' => 'anon_datereminder.admin.inc',
    'weight' => 0,
  );

  $items["$cfgbase/settings"] = array(
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'title' => 'Configure Settings',
  );

  $items["$cfgbase/mail"] = array(
    'type' => MENU_LOCAL_TASK,
    'title' => 'Configure email',
    'description' => 'Set up reminder email content',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('anon_datereminder_email_form'),
    'access arguments' => array(ANON_DATEREMINDER_ADMINISTER_REMINDERS),
    'file' => 'anon_datereminder.admin.inc',
    'weight' => 5,
  );

  $items["$cfgbase/view"] = array(
    'type' => MENU_LOCAL_TASK,
    'title' => 'View all',
    'description' => 'View all reminders',
    'page callback' => 'drupal_get_form',
    'page arguments' => array(
      'anon_datereminder_form_summary',
      NULL,
      'all',
      'm',
    ),
    'access arguments' => array(ANON_DATEREMINDER_ADMINISTER_REMINDERS),
    'weight' => 10,
  );

  $items['node/%node/anon_datereminder'] = array(
    'type' => MENU_LOCAL_TASK,
    'title' => 'All Reminders For This Event',
    'description' => 'All reminders for this event',
    'access callback' => 'anon_datereminder_allowed_access_node',
    'access arguments' => array(1, 'all'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array(
      'anon_datereminder_form_summary',
      1,
      'all_node',
      'm',
    ),
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function anon_datereminder_permission() {
  module_load_include('inc', 'anon_datereminder', 'includes/defines');

  $perms = array();
  $perms[ANON_DATEREMINDER_ADMINISTER_REMINDERS] = array(
    'title' => t('Administer reminders'),
    'description' => t('Control node types that support reminders. Configure reminder email.'),
    'restrict' => TRUE,
  );
  $perms[ANON_DATEREMINDER_VIEW_OTHER_USER_REMINDERS] = array(
    'title' => t('See reminders'),
    'description' => t('See, but not change, visitor reminders'),
  );

  return $perms;
}

/**
 * Check if this user can access reminders for this node.
 *
 * @param node $node
 *   The node
 * @param string $acc
 *   What kind of access is requested?
 *   'all' means view others' reminders
 *
 * @return bool
 *   FALSE if user does not have access
 *
 * @ingroup callbacks
<<<<<<< HEAD
=======
 */
function anon_datereminder_allowed_access_node($node = NULL, $acc = 'all') {
  global $user;
  if (!isset($user)) {
    return FALSE;
  }

  module_load_include('inc', 'anon_datereminder', 'includes/defines');
  // First, be sure reminders are on for this.
  if (!isset($node)
    || ($node->anon_datereminder_enabled != ANON_DATEREMINDER_TYPE_ON)) {
    return FALSE;
  }

  if (user_access(ANON_DATEREMINDER_VIEW_OTHER_USER_REMINDERS)
    || user_access(ANON_DATEREMINDER_ADMINISTER_REMINDERS)) {
    return TRUE;
  }

  return (($acc == 'own') && (user_access(ANON_DATEREMINDER_REQUEST_REMINDER)));
}

/**
 * Implements hook_nodeapi().
>>>>>>> 13649003a161dde9cb04a8419f78647e5bbf1ad3
 */
function anon_datereminder_allowed_access_node($node = NULL, $acc = 'all') {
  module_load_include('inc', 'anon_datereminder', 'includes/defines');
  // First, be sure reminders are on for this.
  if (!isset($node)
    || ($node->anon_datereminder_enabled != ANON_DATEREMINDER_TYPE_ON)) {
    return FALSE;
  }

  if (user_access(ANON_DATEREMINDER_VIEW_OTHER_USER_REMINDERS)
    || user_access(ANON_DATEREMINDER_ADMINISTER_REMINDERS)) {
    return TRUE;
  }

  return (($acc == 'own') && (user_access(ANON_DATEREMINDER_REQUEST_REMINDER)));
}

/**
 * Implements hook_node_delete().
 */
function anon_datereminder_node_delete($node) {
  module_load_include('inc', 'anon_datereminder', 'includes/defines');
  module_load_include('inc', 'anon_datereminder', ANON_DATEREMINDER_DB);

  // This will clear the enable flag for the node, plus clean out any
  // existing reminders.
  _anon_datereminder_set_node_enabled($node, ANON_DATEREMINDER_TYPE_DISABLED);
}

/**
 * Implements hook_node_insert().
 */
function anon_datereminder_node_insert($node) {
  module_load_include('inc', 'anon_datereminder', 'includes/node');
  _anon_datereminder_node_insert($node);
}

/**
 * Implements hook_node_update().
 */
function anon_datereminder_node_update($node) {
  module_load_include('inc', 'anon_datereminder', 'includes/node');
  _anon_datereminder_node_update($node);
}

/**
 * Implements hook_node_load().
 */
function anon_datereminder_node_load($nodes, $types) {
  module_load_include('inc', 'anon_datereminder', 'includes/defines');
  module_load_include('inc', 'anon_datereminder', ANON_DATEREMINDER_DB);

  $typenabled = array();
  foreach ($types as $t) {
    $typenabled[$t] = _anon_datereminder_type_enabled($t);
  }
  foreach ($nodes as $nid => $node) {
    $en = NULL;
    if ($typenabled[$node->type] >= ANON_DATEREMINDER_TYPE_ALLOWED) {
      $en = _anon_datereminder_get_node_enabled($nid);
    }
    if ($en == NULL) {
      $en = ANON_DATEREMINDER_TYPE_DISABLED;
    }
    $nodes[$nid]->anon_datereminder_enabled = $en;
  }
}

/**
 * Implements hook_node_view().
 */
function anon_datereminder_node_view($node, $view_mode, $langcode) {
  // Don't bother with teasers or other, or if reminders are
  // displayed in a tab.
  $enabled = $node->anon_datereminder_enabled;
  if ($enabled > 0) {
    // This node has reminders to display. But only display if this is
    // full (not teaser) view, and if reminders are set to display inline.
    if (($view_mode == 'full') && (variable_get('anon_datereminder_display') == 'node')) {
      module_load_include('inc', 'anon_datereminder', 'includes/defines');
      // Do we actually want reminders for this node?
      if ($enabled >= ANON_DATEREMINDER_TYPE_ALLOWED) {
        $content = _anon_datereminder_node_output($node, 'node');
        $content['#weight'] = 50;
        $node->content['reminder'] = $content;
      }
    }
  }
}

/**
 * Add option to node allowing visitor to request a reminder.
 */
function _anon_datereminder_node_output(&$node, $type = 'node') {
  module_load_include('inc', 'anon_datereminder', 'includes/defines');

  $output = '';
  if (empty($node->anon_datereminder_enabled)
          || $node->anon_datereminder_enabled < ANON_DATEREMINDER_TYPE_ALLOWED) {
    return $output;
  }

  $output = _anon_datereminder_current_user_reminder($node, $type);

  return $output;
}

/**
 * Get table of the given node's reminders.
 */
function _anon_datereminder_current_user_reminder($node, $type = 'node') {
  $output = '';

  $fieldset = $type == 'node' ? 'f' : 'm';
  $output = drupal_get_form('anon_datereminder_form', $node, $fieldset);

  return $output;
}

/**
 * Implements hook_form_alter().
 *
 * Add section to node type edit form to enable reminders.
 */
function anon_datereminder_form_alter(&$form, &$form_state, $form_id) {
  switch ($form_id) {
    case 'node_type_form':
      module_load_include('inc', 'anon_datereminder', 'includes/node_form');
      anon_datereminder_alter_node_type_form($form,
              $form_state, $form['#node_type']->type);
      break;

    default:
      if (!empty($form['type']['#value'])) {
        if ($form_id == $form['type']['#value'] . '_node_form') {
          module_load_include('inc', 'anon_datereminder', 'includes/node_form');
          anon_datereminder_alter_node_form($form, $form_state, $form_id);
        }
      }
      break;
  }
}

/**
 * Make sure that the user doesn't try to set node enabled to silly value.
 *
 * Note: This is only invoked if reminders are allowed for this node type.
 *
 * @param array $form
 *   The raw form.
 * @param array $form_state
 *   State info about form, including submitted values.
 */
function _anon_datereminder_form_validate_node(&$form, &$form_state) {
  module_load_include('inc', 'anon_datereminder', 'includes/defines');
  // What is user setting it to?
  $en = $form_state['values']['anon_datereminder_enabled'];
  if (($en != ANON_DATEREMINDER_TYPE_DISABLED)
    && ($en != ANON_DATEREMINDER_TYPE_ON)
    && ($en != ANON_DATEREMINDER_TYPE_RETAIN)) {
    form_set_error('anon_datereminder_enabled',
      t("That's not a legal reminder setting"), 'error');
  }
}
/**
 * Handle form submit when admin enables or disables reminder for a node.
 *
 * Note: We don't need to check user access here. We'll only come here
 * if anon_datereminder_alter_node_form() said we should. And it will only do
 * that if it's OK for the user to enable or disable reminders on this node.
 * Note that if reminders are enabled for this node type, anyone who can
 * modify a node of that type can enable or disable reminders.
 *
 * @param array &$form
 *   The submitted form
 * @param array &$form_state
 *   State of submitted form.
 *
 * @todo
 *   Move this into include/node.inc. Requires updating node_form.inc
 *   to direct the form update there.
 */
function _anon_datereminder_form_submit_node(&$form, &$form_state) {
  module_load_include('inc', 'anon_datereminder', 'includes/defines');
  module_load_include('inc', 'anon_datereminder', ANON_DATEREMINDER_DB);

  $node = $form['#node'];
  $newen = $form_state['values']['anon_datereminder_enabled'];

  $node->anon_datereminder_enabled = $newen;
}

/**
 * Get enablement for a content type.
 *
 * Functionally, it would make sense to put this in node_type.inc, but
 * it's used in so many places...
 *
 * @param string $type
 *   The content type
 *
 * @return int
 *   Enum telling default value for reminders for this type.
 */
function _anon_datereminder_type_enabled($type) {
  module_load_include('inc', 'anon_datereminder', 'includes/defines');
  return variable_get("anon_datereminder_enabled_$type", ANON_DATEREMINDER_TYPE_DISABLED);
}

/**
 * Callback on submit from anon_datereminder_form.
 */
function _anon_datereminder_form_submit_user($form, &$form_state) {
  $v = $form_state['values'];
  $node = $form_state['anon_datereminder_node'];
  $rows = explode(',', $v['rids']);

  module_load_include('inc', 'anon_datereminder', 'includes/date');
  $df = _anon_datereminder_get_node_datefield($node);
  $changedrems = array();
  foreach ($rows as $rtag) {
    $changed = FALSE;
    $newtime = FALSE;
    $r = new stdClass();
    $ldtag = "anon_datereminder_lead_$rtag";
    if (isset ($v[$ldtag])) {
      $r->leadtime = $v[$ldtag];
      if ($r->leadtime > 0) {
        $rid = -(substr($rtag, 1));
        $r->nid = $node->nid;
        $r->node = $node;
        $r->next_due = 0;
        $r->rid = $rid;
        $r->expired = 0;
        $r->email = $v["anon_datereminder_email_$rtag"];
        $newtime = TRUE;
      }
    }

    if ($newtime) {
      _anon_datereminder_get_next_reminder($r, $df);
      if (!isset($r->next_due)) {
        drupal_set_message(t("Sorry, but it's too late to send that reminder"),
                'error');
        return;
      }
      $changed = TRUE;
    }
    if ($changed) {
      $changedrems[$rid] = $r;
    }
  }

  if (count($changedrems) > 0) {
    _anon_datereminder_set_reminders($changedrems);
    unset($node->reminders);
  }

  drupal_set_message(t("Your reminder has been set."),
    'status');

  if ($v['send-now']) {
    module_load_include('inc', 'anon_datereminder', 'includes/mailer');
    $r->leadtime = 0;
    $r->next_due = NULL;

    if (_anon_datereminder_send_reminder($r)) {
      drupal_set_message(t('An email reminder has been sent'));
    }
    else {
      drupal_set_message(t('Sorry, there was a problem sending mail'), 'error');
    }
  }
}

/**
 * Callback on validate from anon_datereminder_form.
 *
 * Did the visitor put reasonable values in the form?
 */
function _anon_datereminder_form_validate_user($form, &$form_state) {
  module_load_include('inc', 'anon_datereminder', 'includes/defines');

  $ok = TRUE;
  $v = $form_state['values'];
  $rid = $v['rids'];
  $rows = explode(',', $v['rids']);
  $nid = $v['nid'];
  $reminders = _anon_datereminder_load_reminders(array('nid' => $nid));
  $node = node_load($nid);
  $maxrem = variable_get('anon_datereminder_max_reminders', ANON_DATEREMINDER_MAX_REMINDERS);

  if (empty($node)) {
    form_error($form, t('Permission error'));
    return FALSE;
  }

  foreach ($rows as $rtag) {
    $ldtag = "anon_datereminder_lead_$rtag";
    if (empty($v[$ldtag])) {
      form_error($form, t('Please select a valid frequency.'));
      $ok = FALSE;
    }
  }

  $e = $v["anon_datereminder_email_$rid"];
  if (empty($e)) {
    form_error($form, t('Please enter a valid email address.'));
    $ok = FALSE;
  }
  if ($e) {
    foreach (explode(',', $e) as $email) {
      if ($email && !valid_email_address($email)) {
        form_error($form, t('This email address appears to be invalid'));
        $ok = FALSE;
      }

      $currentrem = _anon_datereminder_count_email_reminders($email, $reminders);
      if ($currentrem >= $maxrem) {
        form_error($form, t('Max number of reminders reached'));
        $ok = FALSE;
      }
    }
  }

  // Any reason not to do this?
  $form_state['anon_datereminder_node'] = $node;

  $rows = $v['rids'];

  if (!isset($rows) or $rows == '') {
    form_error($form, t('Corrupted form'));
    return FALSE;
  }

  return $ok;
}

/**
 * Count times a given email address has requested reminder for this nid.
 *
 * @param varchar $email
 *   Email address
 * @param array $reminders
 *   array of all reminders for a node
 *
 * @return array
 *   Array of past-due reminders, indexed by rid.
 */
function _anon_datereminder_count_email_reminders($email, $reminders = array()) {
  $countemails = array_filter($reminders, function($reminder) use ($email) {
    return $reminder->email == $email;
  });

  return count($countemails);
}

/**
 * Callback to delete a group of reminders from admin menu form.
 */
function _anon_datereminder_admin_delete_set($form, &$form_state) {
  $v = $form_state['values'];
  $reminders = $v['reminders'];

  $dset = array();
  foreach ($reminders as $rem) {
    if ($rem > 0) {
      $dset[] = $rem;
    }
  }

  if (count($dset) > 0) {
    module_load_include('inc', 'anon_datereminder', 'includes/defines');
    module_load_include('inc', 'anon_datereminder', ANON_DATEREMINDER_DB);
    _anon_datereminder_delete_rids($dset);
  }
}

/**
 * Utility function to load node objects for a reminder when needed.
 *
 * @param object  $r
 *   Reminder to be completed
 */
function _anon_datereminder_complete_reminder(&$r) {
  if (!isset($r->node)) {
    $r->node = node_load($r->nid);
  }
}

/**
 * Implements hook_tokens().
 */
function anon_datereminder_tokens($type, $tokens, $data, $options) {
  $ret = array();

  // Check that this is for us.
  if ($type == 'anon_datereminder') {
    $r = $data['anon_datereminder'];
    if ($r) {
      module_load_include('inc', 'anon_datereminder', 'includes/date');
      $datefield = _anon_datereminder_get_datefield($r);
      $tz = variable_get('date_default_timezone', 0);

      $next_due = $r->next_due;
      // We want then next-date tokens to show next occurrance after
      // the time this reminder will be sent. But if the reminder isn't
      // currently scheduled, use 'now'.
      if (isset($next_due)) {
        $next_due = _anon_datereminder_internal_date_to_datetime($next_due);
      }
      else {
        $next_due = _anon_datereminder_now();
      }
      $dobj = _anon_datereminder_get_occurrence_after_date($datefield, $next_due);

      if (isset($dobj)) {
        $tstamp = _anon_datereminder_date_format_internal($dobj);

        // OK, so we have the time. Go head and format time.
        foreach ($tokens as $name => $orig) {
          if (substr($name, 0, 5) == 'next-') {
            $fmt = substr($name, 5);
            if ($fmt == 'short' || $fmt == 'medium' || $fmt == 'long') {
              $f = format_date($tstamp, $fmt, '', $tz);
            }
            else {
              $f = format_date($tstamp, 'custom', $fmt, $tz);
            }
            $ret[$orig] = $f;
          }
        }
      }
      else {
        foreach ($tokens as $name => $orig) {
          $ret[$orig] = t('Past');
        }
      }
    }
  }

  return $ret;
}

/**
 * Implements hook_token_info().
 */
function anon_datereminder_token_info() {
  $tokens = array();

  $tokens['next-short'] = array(
    'name' => t('Next date, short form'),
    'description' => t('The date of the next occurrance of this event, short form.'),
  );
  $tokens['next-medium'] = array(
    'name' => t('Next date, medium form'),
    'description' => t('The date of the next occurrance of this event, medium form.'),
  );
  $tokens['next-long'] = array(
    'name' => t('Next date, long form'),
    'description' => t('The date of the next occurrance of this event, long form.'),
  );

  $type = array(
    'name' => t('Date reminders'),
    'description' => t('Information about upcoming events when sending reminders.'),
    'needs-data' => 'anon_datereminder',
  );

  return array(
    'tokens' => array('anon_datereminder' => $tokens),
    'types' => array('anon_datereminder' => $type),
  );
}

/**
 * Implements hook_cron().
 */
function anon_datereminder_cron() {
  module_load_include('inc', 'anon_datereminder', 'includes/cron');
  _anon_datereminder_cron();
}

/**
 * Implements hook_theme().
 */
function anon_datereminder_theme() {
  return array(
    'anon_datereminder_manage_reminders' => array(
      'render element' => 'form table',
      'file' => 'anon_datereminder_form.inc',
      'path' => drupal_get_path('module', 'anon_datereminder') . '/includes',
    ),

    'anon_datereminder_table' => array(
      'render element' => 'form',
      'file' => 'anon_datereminder_form.inc',
      'path' => drupal_get_path('module', 'anon_datereminder') . '/includes',
    ),

    'anon_datereminder_fields' => array(
      'render element' => 'form',
      'file' => 'anon_datereminder_form.inc',
      'path' => drupal_get_path('module', 'anon_datereminder') . '/includes',
    ),
  );
}

/**
 * Build the visitor reminder form.
 *
 * @param string $form
 *   Name of the form? (New in D7)
 * @param array $form_state
 *   What's built so far
 * @param node $node
 *   The fully loaded node object.
 * @param array $fieldset
 *   Boolean that indicates if the reminder form should be in a fieldset.
 */
function anon_datereminder_form($form, &$form_state, $node, $fieldset = 'f') {
  module_load_include('inc', 'anon_datereminder', 'includes/anon_datereminder_form');
  return _anon_datereminder_form($form, $form_state, $node, $fieldset);
}

/**
 * Build a form with a list of reminders.
 *
 * @param array $form
 *   Form array
 * @param array $form_state
 *   Current state of the form
 * @param object $arg
 *   node object
 * @param string $content
 *   Determines content of the list. Allowed values:
 *    'all_node' -- Show all reminders for this node
 *    'all' -- Show all reminders
 * @param string $fieldset
 *   String that indicates if the reminder form should be in a fieldset.
 *
 * @return array
 *   Form array
 *
 * @ingroup forms
 *
 * @todo This really ought to be combined with anon_datereminder_form().
 */
function anon_datereminder_form_summary($form, &$form_state, $arg, $content = 'all_node', $fieldset = 'f') {
  module_load_include('inc', 'anon_datereminder', 'includes/anon_datereminder_form');

  return _anon_datereminder_form_summary($form, $form_state, $arg, $content, $fieldset);
}

/**
 * Implements hook_block_info().
 */
function anon_datereminder_block_info() {
  $blocks['anon_datereminder'] = array(
    'info' => t('Anonymous Datereminder'),
    'cache' => DRUPAL_NO_CACHE,
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function anon_datereminder_block_view($delta = '') {
  $block = array();

  switch ($delta) {
    case 'anon_datereminder':
      $block['subject'] = t('Anonymous Datereminder');
      $block['content'] = anon_datereminder_render_block();
      break;
  }

  return $block;
}

/**
 * Render the reminder form to place inside a block.
 *
 * @return array
 *   The form array
 */
function anon_datereminder_render_block() {
  if (!arg(0) == 'node' || (arg(0) == 'node' && !is_numeric(arg(1)))) {
    return;
  };

  $nid = arg(1);
  $node = node_load($nid);
  $enabled = $node->anon_datereminder_enabled;
  if ($enabled > 0) {
    // This node has valid reminders.
    module_load_include('inc', 'anon_datereminder', 'includes/defines');
    // Do we actually want reminders for this node?
    if ($enabled >= ANON_DATEREMINDER_TYPE_ALLOWED) {
      return _anon_datereminder_node_output($node, 'block');
    }
  }
}
