<?php

/**
 * @file
 * Main functions for the dbee module.
 */

/**
 * Implements hook_permission().
 *
 * The 'administer database email encryption' allow access :
 * - to the dbee module admin options (on ?q=admin/settings/dbee),
 * - and to a specfic field 'security' on each user page (?q=/user/%user).
 */
function dbee_permission() {
  return array(
    'administer database email encryption' => array(
      'title' => t('Administer database email encryption'),
      'description' => t("Configure options for the 'database email encryption' module"),
    ),
  );
}

/**
 * Implements hook_menu().
 *
 * Create the module administration page.
 */
function dbee_menu() {
  return array('admin/config/system/dbee' => array(
    'title' => 'DataBase Email Encryption settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('dbee_admin_form'),
    'access arguments' => array('administer database email encryption'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'dbee.admin.inc',
    ),
  );
}

/**
 * Provide the stored database value of an email address.
 *
 * Returns the email encrypted value of an email. it is used, for example, on
 * operations inspecting or updating email values into the database user table.
 * It can provide either the encrypted value of the lowercase email address or
 * the encrypted value of the sensitive case email address.
 *
 * @param $string
 *   A string, the uncrypted (readable) email address to encrypt.
 * @param $lowercase
 *   A boolean, if set to TRUE, returns the encrypted value of the lowercase
 *   email address. Default is FALSE.
 * @param bool $base64encode
 *   Whether to return the string base64 encoded (recommended for database
 *   insertion).
 * @param string $custom_key
 *   Use this as the key rather than the stored one for this operation.
 * @param string $custom_cipher
 *   Use this cipher rather than the default one. (only with Mcrypt - ignored
 *   with phpseclib)
 * @param string $custom_iv
 *   Use this initialization vector instead of the default one.
 * @param string $custom_implementation
 *   Can be "phpseclib" or "mcrypt". Warning: Does not check if the requested
 *   implementation actually exists.
 *
 * @return
 *   A string corresponding to the email (lowercase or sensitive case) crypted
 *   value (of FALSE on eror) or the email value if encryption is not needed.
 */
function dbee_encrypt($string, $lowercase = FALSE, $base64encode = TRUE, $custom_key = NULL, $custom_cipher = NULL, $custom_iv = NULL, $custom_implementation = NULL) {
  $email = $string;
  if ( (!empty($email)) && valid_email_address($email)) {
    // The email need to be encrypted.
    $formated_mail = check_plain(trim($email));
    // Provide either the lowercase or the sensitive case email address.
    if ($lowercase) {
      $formated_mail = drupal_strtolower($formated_mail);
    }
    // It returns the encrypted value.
    return aes_encrypt($formated_mail, $base64encode, $custom_key, $custom_cipher, $custom_iv, $custom_implementation);
  }
  else {
    return $email;
  }
}


/**
 * Decrypts an email address if needed.
 *
 * Always returns the uncrypted provided value.
 *
 * @param $string
 *   A string, the encrypted (non readable) email address to decrypt.
 * @param bool $base64encoded
 *   Whether this encrypted string is base64 encoded or not.
 * @param string $custom_key
 *   Use this as the key rather than the stored one for this operation.
 * @param string $custom_cipher
 *   Use this cipher rather than the default one. (only with Mcrypt - ignored
 *   with phpseclib)
 * @param string $custom_iv
 *   Use this initialization vector instead of the default one.
 * @param string $custom_implementation
 *   Can be "phpseclib" or "mcrypt". Warning: Does not check if the requested
 *   implementation actually exists.
 *
 * @return
 *   A string corresponding to the email decrypted value (of FALSE on eror) or
 *   the email value if decryption is not needed.
 */
function dbee_decrypt($string, $base64encoded = TRUE, $custom_key = NULL, $custom_cipher = NULL, $custom_iv = NULL, $custom_implementation = NULL) {
  if (!empty($string) && !valid_email_address($string)) {
    $uncrypted_mail = aes_decrypt($string, $base64encoded, $custom_key, $custom_cipher, $custom_iv, $custom_implementation);
    // Check if the decrypted email address is valid before returning it :
    if (valid_email_address($uncrypted_mail)) {
      return $uncrypted_mail;
    }
    else {
      // This was not a valid email address : decryption is cancelled.
      return $string;
    }
  }
  else {
    // This email address is empty or is already decrypted.
    return $string;
  }
}

/**
 * Provide the encrypted mails values to store into the database.
 *
 * Provide the encrypted values for 4 fields of the {users} table (the 'mail',
 * 'init', 'dbee_mail' and 'dbee_init' fields) from provided 'mail and 'init'
 * values.
 *
 * @param $account
 *   An user object, $account->mail and $account->init may be used.
 * @param $edit
 *   An array, if provided, $edit['mail'] or edit['init'] will overwrite
 *   $account->mail and $account->init. It is used by the dbee_user_presave()
 *   function. Default is empty.
 * @param $encrypt_params
 *   An array (optional). Encryption options provided by hook_aes_config_change().
 *   Keys are 'string', 'base64encode', 'custom_key', 'custom_cipher',
 *   'custom_iv', 'custom_implementation'. Defaults is empty.
 *
 * @return
 *   An array, keyed by 'mail', 'init', dbee_mail', and 'dbee_init'. Values are
 *   the encrypted mails (lowercase for the dbee_* ones).
 */
function dbee_store($account, $edit = array(), $encrypt_params = array()) {
  if (!is_object($account) || !is_array($edit)) {
    return array();
  }
  // If $encrypt_params is not provided by the hook_aes_config_change()
  // function, make sure 'string' is the first index and 'lowercase' the
  // second one.
  $encrypt_params_and_case = array(
    'string' => FALSE,
    'lowercase' => FALSE,
  );
  if (!empty($encrypt_params)) {
    // Set the 'lowercase' arguement at the second position.
    $encrypt_params_and_case = $encrypt_params_and_case + $encrypt_params;
  }

  $dbee_fields = array('mail', 'init');
  $to_store = $edited_value = array();
  $mail_edited_value = FALSE;
  foreach ($dbee_fields as $dbee_field) {
    // $edit value overwrites the $account value.
    $edited_value = (!empty($edit[$dbee_field])) ? $edit[$dbee_field] : ((!empty($account->$dbee_field)) ? $account->$dbee_field : '');
    // For performance raisons, does not decrypt the value twice.
    $mail_init_equal = ($mail_edited_value !== FALSE && $edited_value == $mail_edited_value);
    $field_is_lc = ($edited_value == drupal_strtolower($edited_value));
    // Here : store the encrypted values.
    $encrypt_params_and_case['string'] = $edited_value;
    $encrypt_params_and_case['lowercase'] = FALSE;
    $to_store[$dbee_field] = ($mail_edited_value === FALSE || !$mail_init_equal) ? call_user_func_array('dbee_encrypt', $encrypt_params_and_case) : $to_store['mail'];
    $encrypt_params_and_case['lowercase'] = TRUE;
    $to_store["dbee_{$dbee_field}"] = ($field_is_lc) ? $to_store[$dbee_field] : call_user_func_array('dbee_encrypt', $encrypt_params_and_case);
    // Save the 'mail' value in order to compare it to the 'init' value.
    $mail_edited_value = $edited_value;
  }
  return $to_store;
}

/**
 * Provide the uncrypted dbee mails values.
 *
 * Provide the encrypted values for 4 fields of the {users} table (the 'mail',
 * 'init', 'dbee_mail' and 'dbee_init' fields) from provided 'mail and 'init'
 * values. 'dbee_mail' and 'dbee_init' will be equal to empty string.
 *
 * @param $account
 *   An user object, $account->mail and $account->init may be used.
 * @param $decrypt_params
 *   An array (optional). Encryption options provided by hook_aes_config_change().
 *   Keys are 'string', 'base64encode', 'custom_key', 'custom_cipher',
 *   'custom_iv', 'custom_implementation'. Defaults is empty.
 *
 * @return
 *   An array, keyed by 'mail', 'init', dbee_mail', and 'dbee_init'. Values are
 *   the encrypted mails (lowercase for the dbee_* ones).
 */
function dbee_unstore($account, $decrypt_params = array()) {
  if (!is_object($account)) {
    return array();
  }

  // If $encrypt_params is not provided by the hook_aes_config_change()
  // function, make sure 'string' is the first index.
  if (empty($decrypt_params)) {
    $decrypt_params = array(
      'string' => FALSE,
    );
  }

  $dbee_fields = array('mail', 'init');
  $to_unstore = array();
  $mail_value = FALSE;
  foreach ($dbee_fields as $dbee_field) {
    $field_value = (!empty($account->$dbee_field)) ? $account->$dbee_field : '';
    // For performance raisons, does not decrypt the value twice.
    $mail_init_equal = ($mail_value !== FALSE && $field_value == $mail_value);
    $field_is_lc = ($field_value == drupal_strtolower($field_value));
    // Here : store the uncrypted values.
    $decrypt_params['string'] = $field_value;
    $to_unstore[$dbee_field] = ($mail_value === FALSE || !$mail_init_equal) ? call_user_func_array('dbee_decrypt', $decrypt_params) : $to_unstore['mail'];
    $to_unstore["dbee_{$dbee_field}"] = '';
    // Save the 'mail' value in order to compare it to the 'init' value.
    $mail_value = $field_value;
  }
  return $to_unstore;
}

/**
 * Fix the encrypted mail and init values on an user object.
 *
 * Decrypt 'mail' and 'init' variables from the user object and delete
 * unnecessary 'dbee_mail' and 'dbee_init' variables. Note that the user object
 * is passed by reference.
 *
 * @param $account
 *   An user object, $account->mail and $account->init will be used.
 *
 */
function dbee_extract(&$account) {
  if (isset($account->dbee_mail) || empty($account->uid)) {
    $changes = dbee_unstore($account);
    foreach ($changes as $field => $value) {
      $account->$field = $value;
      // Delete lowercase values.
      if (drupal_substr($field, 0, 5) == 'dbee_') {
        unset($account->$field);
      }
    }
  }
}

/**
 * Encrypts or decrypts all user email addresses.
 *
 * This function encrypts or decrypts all user email addresses from the user
 * table. It is used when the dbee module is installed, enabled or disabled, or
 * when the AES encryption options are updated.
 *
 * @param $action
 *   A string. Possible values are 'decrypt', 'encrypt', and 'change'. Default
 *   to 'encrypt'.
 * @param $set_message
 *   A boolean (optional). If true : it displays a message when the
 *   encryption/decryption is completed. Defaults to TRUE.
 * @param $decrypt_params
 *   An array (optional). Encryption options provided by hook_aes_config_change().
 *   Keys are 'string', 'base64encode', 'custom_key', 'custom_cipher',
 *   'custom_iv', 'custom_implementation'. Defaults is empty.
 * @param $encrypt_params
 *   An array (optional). Encryption options provided by hook_aes_config_change().
 *   Keys are 'string', 'base64encode', 'custom_key', 'custom_cipher',
 *   'custom_iv', 'custom_implementation'. Defaults is empty.
 */
function dbee_update_crypt_all($action = 'encrypt', $set_message = TRUE, $decrypt_params = array(), $encrypt_params = array()) {

  if (!in_array($action, array('decrypt', 'encrypt', 'change'))) {
    return FALSE;
  }
  $result = db_query('SELECT uid, mail, init, dbee_mail, dbee_init FROM {users} WHERE uid <> :uid', array(':uid' => 0));
  $updated_users = $n_users = 0;
  while ($account = $result->fetchObject()) {
    // Initialisation.
    $to_update = array();
    $current = array(
      'mail' => $account->mail,
      'init' => $account->init,
      'dbee_mail' => $account->dbee_mail,
      'dbee_init' => $account->dbee_init,
    );
    ++$n_users;
    if ($action == 'decrypt') {
      // Decrypt every email addresses.
      $to_update = dbee_unstore($account);
    }
    elseif ($action == 'encrypt') {
      // Encrypt every email addresses.
      $to_update = dbee_store($account);
    }
    else { // Case $action == 'change':
      // First decrypt every email addresses.
      $uncrypted_to_update = dbee_unstore($account, $decrypt_params);
      // Now encrypt every email addresses with the new parameters.
      $uncrypted_account = (object) $uncrypted_to_update;
      $to_update = dbee_store($uncrypted_account, array(), $encrypt_params);
    }

    $compare = array_diff_assoc($current, $to_update);
    if (!empty($compare)) {
      // Processed to the update of the user table.
      ++$updated_users;
      db_update('users')
      ->fields($to_update)
      ->condition('uid', $account->uid)
      ->execute();
    }
  }

  // Display message.
  $do_message = (($action == 'encrypt') ? t('encrypted') : (($action == 'decrypt') ? t('decrypted') : t('re-encrypted')));
  if ($set_message) {
    drupal_set_message(t('All users email addresses have been %crypted (concerning @updated_users of @total_users users)',
      array('@updated_users' => $updated_users, '@total_users' => $n_users, '%crypted' => $do_message)));
  }
  // Watchdog changes.
  if ($updated_users > 0) {
    watchdog('dbee', 'All users email addresses have been %crypted (concerning @updated_users of @total_users users)',
      array('%crypted' => $do_message, '@updated_users' => $updated_users, '@total_users' => $n_users), WATCHDOG_NOTICE);
  }
}

/**
 * Implements hook_user_load().
 *
 * Decrypted the mail and init addresses loading a user object.
 */
function dbee_user_load($users) {

  // Decrypt email address when a user is loaded, it makes the email address
  // available for the system.
  foreach ($users as $record) {
    dbee_extract($record);
  }
}

/**
 * Implements hook_user_presave().
 *
 * Encrypt the email address on saving a user account.
 */
function dbee_user_presave(&$edit, $account, $category) {
  $to_update = dbee_store($account, $edit);
  $edit = array_merge($edit, $to_update);
}

/**
 * Implements hook_user_insert().
 *
 * Decrypt the email address on saving a new user account once the mails are
 * saved into the {users} table.
 */
function dbee_user_insert(&$edit, $account, $category) {
  dbee_user_update($edit, $account, $category);
}

/**
 * Implements hook_user_update().
 *
 * Decrypt the email address on saving an existing user account once the mails
 * are saved into the {users} table.
 */
function dbee_user_update(&$edit, $account, $category) {

  // Reset the mail and init values to the decrypted version : thanks to this
  // lines, the user_save() core function will return the decrypted mail and
  // init values.
  dbee_extract($account);
  // Optional, reset the $edit values to the decrypted version :
  $edit['mail'] = $account->mail;
  $edit['init'] = $account->init;
  unset($edit['dbee_mail'], $edit['dbee_init']);
}

/**
 * Implements hook_user_view().
 *
 * This function display an explicit message on the user profile page,
 * concerning the email encryption.
 */
function dbee_user_view($account, $view_mode, $langcode) {
  if (user_access('administer database email encryption') && $view_mode == 'full') {
    // Specific field, it explicits security about email address.
    // Use static query to bypass dbee_query_alter() function.
    $stored_mail = db_query('SELECT mail FROM {users} WHERE uid = :uid', array(':uid' => $account->uid))->fetchField();

    // Handle output message about email address encryption.
    if ($stored_mail == '') {
      $email_status = t('No email address registered for %name.', array('%name' => $account->name));
    }
    elseif (!valid_email_address($stored_mail)) {
      $stored_mail_decrypted = dbee_decrypt($stored_mail);
      if ($stored_mail_decrypted != $stored_mail) {
        $email_status = t("The %name's email address is encrypted.", array('%name' => $account->name));
      }
      else {
        $email_status = t("The %name's email address is encrypted but corrupted. Sending email will be a failure.", array('%name' => $account->name));
      }
    }
    else {
      $email_status = t("The %name's email address is not encrypted.", array('%name' => $account->name));
    }

    // Display new field on the user profile page.
    $account->content['crypted email']['#type'] = 'user_profile_category';
    $account->content['crypted email']['#title'] = t('Security');
    $account->content['crypted email']['#attributes']['class'] = 'user-member';
    $account->content['crypted email']['email status'] = array(
      '#type' => 'user_profile_item',
      '#title' => t('Contact email'),
      '#markup' => $email_status,
    );
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Replace the email validation call back.
 */
function dbee_form_user_profile_form_alter(&$form, &$form_state, $form_id) {
  $to_replace = 'user_account_form_validate';
  $replaced_by = 'dbee_user_account_form_validate';
  $key_to_replace = array_search($to_replace, $form['#validate']);
  if ($key_to_replace !== FALSE) {
    $form['#validate'][$key_to_replace] = $replaced_by;
  }

  if (dbee_logintoboggan_fix()) {
    $to_replace = 'logintoboggan_user_edit_validate';
    $replaced_by = 'dbee_logintoboggan_user_edit_validate';
    $key_to_replace = array_search($to_replace, $form['#validate']);
    if ($key_to_replace !== FALSE) {
      $form['#validate'][$key_to_replace] = $replaced_by;
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Replace the email validation call back.
 */
function dbee_form_user_register_form_alter(&$form, &$form_state, $form_id) {
  dbee_form_user_profile_form_alter($form, $form_state, $form_id);
}

/**
 * Form validation handler for user_account_form().
 *
 * This function replace the user_account_form_validate() core function.
 *
 * @see user_account_form()
 */
function dbee_user_account_form_validate($form, &$form_state) {
  if ($form['#user_category'] == 'account' || $form['#user_category'] == 'register') {
    $account = $form['#user'];
    // Validate new or changing username.
    if (isset($form_state['values']['name'])) {
      if ($error = user_validate_name($form_state['values']['name'])) {
        form_set_error('name', $error);
      }
      elseif ((bool) db_select('users')->fields('users', array('uid'))->condition('uid', $account->uid, '<>')->condition('name', db_like($form_state['values']['name']), 'LIKE')->range(0, 1)->execute()->fetchField()) {
        form_set_error('name', t('The name %name is already taken.', array('%name' => $form_state['values']['name'])));
      }
    }

    // Trim whitespace from mail, to prevent confusing 'e-mail not valid'
    // warnings often caused by cutting and pasting.
    $mail = trim($form_state['values']['mail']);
    form_set_value($form['account']['mail'], $mail, $form_state);

    // Validate the e-mail address, and check if it is taken by an existing user.
    if ($error = user_validate_mail($form_state['values']['mail'])) {
      form_set_error('mail', $error);
    }
    // HERE: we edit the core function.
    elseif ((bool) db_select('users')->fields('users', array('uid'))->condition('uid', $account->uid, '<>')->condition('dbee_mail', dbee_encrypt($form_state['values']['mail'], TRUE), '=')->range(0, 1)->execute()->fetchField()) {
      // Format error message dependent on whether the user is logged in or not.
      if ($GLOBALS['user']->uid) {
        form_set_error('mail', t('The e-mail address %email is already taken.', array('%email' => $form_state['values']['mail'])));
      }
      else {
        form_set_error('mail', t('The e-mail address %email is already registered. <a href="@password">Have you forgotten your password?</a>', array('%email' => $form_state['values']['mail'], '@password' => url('user/password'))));
      }
    }

    // Make sure the signature isn't longer than the size of the database field.
    // Signatures are disabled by default, so make sure it exists first.
    if (isset($form_state['values']['signature'])) {
      // Move text format for user signature into 'signature_format'.
      $form_state['values']['signature_format'] = $form_state['values']['signature']['format'];
      // Move text value for user signature into 'signature'.
      $form_state['values']['signature'] = $form_state['values']['signature']['value'];

      $user_schema = drupal_get_schema('users');
      if (drupal_strlen($form_state['values']['signature']) > $user_schema['fields']['signature']['length']) {
        form_set_error('signature', t('The signature is too long: it must be %max characters or less.', array('%max' => $user_schema['fields']['signature']['length'])));
      }
    }
  }
}

/**
  * Implements hook_aes_config_change().
  *
  * When encryption parameters change from the aes module : update all users
  * with the new encyption parameters.
  */
function dbee_aes_config_change($decrypt_params, $encrypt_params) {
  dbee_update_crypt_all('change', TRUE, $decrypt_params, $encrypt_params);
}

/**
 * Implements hook_boot().
 *
 * Make the email address available for the connected user (loaded during the
 * bootstrap).
 */
function dbee_boot() {
  global $user;
  if ($user && (!empty($user->mail) || !empty($user->init))) {
    // Load the needed files.
    drupal_load('module', 'aes');
    drupal_load('module', 'dbee');
    $files = array();
    // Load common.inc for the valid_email_address() core function.
    $files[] = DRUPAL_ROOT . '/' . 'includes/common.inc';
    // Load unicode.inc for the drupal_strtolower() core function.
    $files[] = DRUPAL_ROOT . '/' . 'includes/unicode.inc';
    foreach ($files as $file) {
      if (is_file($file)) {
        require_once $file;
      }
      // uncrypt datas for the connected user.
    }

    // Fix email and init values.
    dbee_extract($user);
  }
}

/**
 * Implements hook_mail_alter().
 *
 * Make the email address available for mass mailing feature. This functions is
 * not needed for core feature but may improve compatibility with custom
 * modules.
 */
function dbee_mail_alter(&$message) {
  // @TODO : add a parser for multiple email recipients.
  $message['to'] = dbee_decrypt($message['to']);
}

/**
 * Implements hook_module_implements_alter().
 *
 * Change the hook order. The purpose is to improve the compatibility with
 * custom modules : call the dbee module on an early stage for decrypting and
 * on a ultimate stage for encrypting.
 */
function dbee_module_implements_alter(&$implementations, $hook) {

  // In order to improve compatibility with custom modules, set the decryption
  // on an early stage.
  $hook_decrypt = array(
    'user_load',
    'user_insert',
    'user_update',
    'mail_alter',
    'boot',
    'entity_load',
  );
  if (in_array($hook, $hook_decrypt) && isset($implementations['dbee'])) {
    $group = $implementations['dbee'];
    unset($implementations['dbee']);
    $implementations = array_merge(array('dbee' => $group), $implementations);
  }

  // In order to improve compatibility with custom modules, set the encryption
  // on an ultimate stage.
  $hook_encrypt = array(
    'query_alter',
    'query_user_load_multiple_alter',
    'query_pager_alter',
    'entity_query_alter',
  );
  if (in_array($hook, $hook_encrypt) && isset($implementations['dbee'])) {
    $group = $implementations['dbee'];
    unset($implementations['dbee']);
    $implementations['dbee'] = $group;
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Allow to connect using own email instead of the username.
 */
function dbee_form_user_login_alter(&$form, &$form_state, $form_id) {
  // Extra option : allow to connect using own email.
  // Set compatibility with the 'logintoboggan'' or the 'email_registration'
  // custom modules.
  if (dbee_mail_login_fix()) {
    if (dbee_logintoboggan_fix() && isset($form['#validate'])) {
      $to_replace = 'logintoboggan_user_login_validate';
      $replaced_by = 'dbee_user_login_validate';
      $key_to_replace = array_search($to_replace, $form['#validate']);
      if ($key_to_replace !== FALSE) {
        $form['#validate'][$key_to_replace] = $replaced_by;
      }
    }
    elseif (dbee_email_registration_fix() && isset($form['name']['#element_validate'])) {
      $to_replace = 'email_registration_user_login_validate';
      $replaced_by = 'dbee_user_login_validate';
      $key_to_replace = array_search($to_replace, $form['name']['#element_validate']);
      if ($key_to_replace !== FALSE) {
        $form['name']['#element_validate'][$key_to_replace] = $replaced_by;
      }
    }
  }
  elseif (variable_get('dbee_loggin_email', 0)) {
    $form['name']['#title'] = t('username or mail:');
    $form['name']['#element_validate'][] = 'dbee_user_login_validate';
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Allow to connect using own email instead of the username.
 */
function dbee_form_user_login_block_alter(&$form, &$form_state, $form_id) {
  dbee_form_user_login_alter($form, $form_state, $form_id);
}

/**
 * Allow to login using email address instead of the username.
 *
 * Allow to login using either the email address or the username, instead of
 * only the username. This is an extra feature, disabled by default. It can be
 * enable on the dbee setting page.
 */
function dbee_user_login_validate($form, &$form_state) {
  if (isset($form_state['values']['name'])) {
    if (dbee_email_registration_fix()) {
      // #1291908 : added from email_registration 7.x-1.0 to 7.x-1.1 version.
      // Keep the email value in form state for further validation.
      $form_state['values']['email'] = $form_state['values']['name'];
    }
    $name = db_query('SELECT name FROM {users} WHERE dbee_mail = :mail', array(':mail' => dbee_encrypt(check_plain($form_state['values']['name']), TRUE)))->fetchField();
    if ($name) {
      $form_state['values']['name'] = $name;
    }
  }
}

/**
 * Implements hook_views_api().
 *
 * Make the email address available for the Views module.
 */
function dbee_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'dbee') . '/views',
  );
}

/**
 * Implements hook_entity_load().
 *
 * On user cache creation, the hook_user_load() function seems to not be
 * called. We fix it here.
 */
function dbee_entity_load($entities, $type) {
  if ($type == 'user') {
    // Reset the mail and init values to the decrypted version : thanks to
    // this line, the entity_load() core function will return the decrypted
    // mail and init values.
    dbee_user_load($entities);
  }
}


/**
 * Inform if a fix is needed for compatibility with the logintoggoban module.
 *
 * @return
 *   A Boolean. TRUE if the fix is needed.
 */
function dbee_logintoboggan_fix() {
  return (module_exists('logintoboggan') && variable_get('logintoboggan_login_with_email', 0));
}

/**
 * Inform if a fix is needed for compatibility with the Email Registration module.
 *
 * @return
 *   A Boolean. TRUE if the fix is needed.
 */
function dbee_email_registration_fix() {
  return (module_exists('email_registration'));
}

/**
 * Inform if a fix is needed for login by user email address.
 *
 * @return
 *   A Boolean. TRUE if the fix is needed.
 */
function dbee_mail_login_fix() {
  return (module_exists('email_registration') || (module_exists('logintoboggan') && variable_get('logintoboggan_login_with_email', 0)));
}

/**
 * Custom validation function for user edit form
 *
 * Fix compatibility with the logintoboggan custom module.
 *
 * @ingroup logintoboggan_form
 */
function dbee_logintoboggan_user_edit_validate($form, &$form_state) {

  $account = $form['#user'];
  $edit = $form_state['values'];

  // If login with mail is enabled...
  if (variable_get('logintoboggan_login_with_email', 0)) {
    $uid = isset($account->uid) ? $account->uid : 0;
    // Check that no user is using this name for their email address.
    $arg = array(
      ':mail' => dbee_encrypt($edit['name'], TRUE),
      ':uid' => $uid,
    );
    if (isset($edit['name']) && (db_query('SELECT uid FROM {users} WHERE dbee_mail = :mail AND uid <> :uid', $arg)->fetchField() || db_query('SELECT uid FROM {users} WHERE LOWER(name) = :mail AND uid <> :uid', $arg)->fetchField())) {
      form_set_error('name', t('This name has already been taken by another user.'));
    }
    // Check that no user is using this email address for their name.
    if (isset($edit['mail']) && db_query('SELECT uid FROM {users} WHERE LOWER(name) = LOWER(:name) AND uid <> :uid', array(
      ':name' => $edit['mail'],
      ':uid' => $uid,
    ))->fetchField()) {
      form_set_error('mail', t('This e-mail has already been taken by another user.'));
    }
  }

  if (!empty($edit['pass'])) {
    // If we're changing the password, validate it.
    $pass_err = logintoboggan_validate_pass($edit['pass']);
    if ($pass_err) {
      form_set_error('pass', $pass_err);
    }
  }
}

/**
 * Implements hook_query_alter().
 *
 * Encrypt the email on queries. This hook is only called on dynamic tagged
 * queries. The 'dbee' tag is not required. As an example, the query from the
 * user_load_by_mail() function is going to be altered thanks to the
 * 'user_load_multiple' tag. On the contrary, the user_account_form_validate()
 * is not tagged, the hook_query_alter() function is not called, that why I
 * replace this function by the custom function
 * (dbee_user_account_form_validate()). The dbee_query_alter() is going to
 * encrypt any dynamic tagged query that contains the mail or init field into the
 * where clause. This function add 2 tags on queries informing that some fields
 * may probably need to be decrypted from the result set : 'dbee_mail' and
 * 'dbee_init' tags for the 'mail' and 'init' fields. Concerning core fuctions,
 * this function is only used for fixing the user_load_by_mail() function. The
 * dbee_query_alter() function improves the dbee module compatibility with
 * custom modules that would use dynamic tagged queries.
 */
function dbee_query_alter(QueryAlterableInterface $query) {
  $users_alias = FALSE;
  $tables = &$query->getTables();
  foreach ($tables as $table_alias => $table_properties) {
    if ($table_properties['table'] == 'users') {
      // The users table is queryed.
      $users_alias = $table_properties['alias'];
      break;
    }
  }

  if ($users_alias) {
    // The {users} table is queried.
    $dbee_fields = array('mail', 'init');
    foreach ($dbee_fields as $dbee_field) {
      $field_selected[$dbee_field] = FALSE;
      // Set a default mail alias :
      $dbee_alias[$dbee_field] = $dbee_field;
    }
    // Check if all fields are loaded.
    if (is_array($tables[$users_alias]) && array_key_exists('all_fields', $tables[$users_alias]) && $tables[$users_alias]['all_fields']) {
      foreach ($dbee_fields as $dbee_field) {
        $field_selected[$dbee_field] = TRUE;
        // Optional, the mail alias is the same as default but its value is
        // confirmed.
        $dbee_alias[$dbee_field] = $dbee_field;
      }
    }
    else {
      // Or at least the mail or init fields.
      $fields = &$query->getFields();
      foreach ($fields as $field_alias => $field_properties) {
        if ($field_properties['table'] == $users_alias) {
          foreach ($dbee_fields as $dbee_field) {
            if ($field_properties['field'] == $dbee_field) {
              $field_selected[$dbee_field] = TRUE;
              $dbee_alias[$dbee_field] = $field_properties['alias'];
            }
          }
        }
      }
    }

    foreach ($dbee_fields as $dbee_field) {
      if ($field_selected[$dbee_field]) {
        // The 'mail' or the 'init' field from the table 'users' is queryed.
        // The 'dbee_mail' or 'dbee_init' tags inform that the result set will
        // problably return encrypted mail values and should go throught the
        // dbee_decrypt() function !
        $query->addTag('dbee_' . $dbee_field);
      }
    }

    // Now take care of the WHERE clause.
    dbee_where_clause($query, $users_alias, $dbee_alias);
  }
}

/**
 * Helper reformating database queries regarding encryption.
 *
 * Regarding field, operator and value on the where clause, returns the
 * corresponding changed values. As an example : replace "WHERE mail LIKE
 * 'john@example.com'" by  "WHERE uid IN (2, 7)" or "WHERE uid = 3".
 *
 */
function dbee_where_clause(&$query, $users_alias, $dbee_alias) {
  // Now take care of the WHERE clause.
  $dbee_fields = array('mail', 'init');
  $where = &$query->conditions();

  foreach ($where as $placeholder => $where_properties) {
    if (is_array($where_properties) && array_key_exists('field', $where_properties) && array_key_exists('value', $where_properties)) {
      if (is_object($where_properties['field'])) {
        // For nested conditions (db_or()). Used by user_search_execute().
        dbee_where_clause($where[$placeholder]['field'], $users_alias, $dbee_alias);
      }
      elseif (is_string($where_properties['field'])) {
        // Used by the load_by_mail_user() core function.
        foreach ($dbee_fields as $dbee_field) {
          // Alias : 'users.mail' or 'mail' in most cases.
          $where_alias = array($users_alias . '.' . $dbee_alias[$dbee_field], $dbee_alias[$dbee_field]);
          if (in_array($where_properties['field'], $where_alias)) {
            // The where clause does contain the mail or init fields !

            // First handle simple or multiple values.
            $where_strings = array();
            if (is_string($where_properties['value'])) {
              // The user_load_by_mail() core function needs the code below.
              $where_strings[] = $where_properties['value'];
            }
            elseif (is_array($where_properties['value'])) {
              $where_strings = $where_properties['value'];
            }
            else {
              // This case should never happen.
              continue;
            }

            // Initialisation :
            $need_rewrite = FALSE;
            $new_values = array();
            $new_field = FALSE;
            $operator = drupal_strtoupper($where_properties['operator']);
            $where_match = in_array($operator, array('LIKE', '=', 'IN'));

            // Special behavior regarding issues #2324701 and #2616264
            // (https://www.drupal.org/node/2616264#comment-10576582)
            // Due to MySQL collation, queries are executed as insensitive case.
            if (isset($query->alterTags['user_load_multiple'])) {
              if ($operator == '=') {
                $operator = 'LIKE';
              }
              elseif ($operator == '<>') {
                $operator = 'NOT LIKE';
              }
            }

            // The where clause needs to decrypt all users on complex searchs
            // with wildcards ('_' and '%'),

            // Look for unescaped wildcards :
            // find active '%' and '_'mysql wildcards.
            $pattern_wildcards = '[^\\\\]%|^%|[^\\\\]_|^_';
            // The custom method is not the default one. It is faster but less
            // powerfull because it will return the user only if the whole mail
            // string is provided.
            if (!variable_get('dbee_custom_search', 0) && in_array($operator, array('LIKE', 'NOT LIKE')) && preg_match("!$pattern_wildcards!", $where[$placeholder]['value']) === 1) {
              $need_rewrite = TRUE;
              $result_uids = dbee_where_mailfields2uid($where_strings, $dbee_field, $operator);
              $new_values = $result_uids;
              $n_matching_user = count($result_uids);
              if ($n_matching_user == 0) {
                // No users match, returns "WHERE 0 = '1'".
                $new_field = 1;
                $new_values = 0;
              }
              else {
                $new_field = $users_alias . '.uid';
                $new_values = $result_uids;
              }
            }
            elseif (in_array($operator, array('=', '<>', 'IN', 'NOT IN', 'LIKE', 'NOT LIKE'))) {
              // Encrypt the mail or init value(s).
              $lowercase = (in_array($operator, array('LIKE', 'NOT LIKE')));
              $crypted_where_strings = $where_strings;
              foreach ($where_strings as $index => $string) {
                $crypted_string = dbee_encrypt($string, $lowercase);
                if ($crypted_string != $string) {
                  // The email is not crypted : fix it.
                  $crypted_where_strings[$index] = $crypted_string;
                }
              }
              if ($crypted_where_strings != $where_strings) {
                // Value(s) from the WHERE clause does need to be encrypted.
                $need_rewrite = TRUE;
                $new_values = $crypted_where_strings;
                if ($lowercase) {
                  $new_field =  'dbee_' . $dbee_field;
                }
              }
            }
            else {
              // Operator is 'IS NULL' [using : $query->isNull('mail');] or
              // 'IS NOT NULL' or '<', '>', '<=', '>=', 'BETWEEN'.
              continue;
            }

            if ($need_rewrite) {
              // At last : edit the Where condition.
              if (count($new_values) == 1) {
                $where[$placeholder]['operator'] = ($where_match) ? '=' : '<>';
                $where[$placeholder]['value'] = $new_values[0];
              }
              else {
                $where[$placeholder]['operator'] = ($where_match) ? 'IN' : 'NOT IN';
                $where[$placeholder]['value'] = $new_values;
              }
              if ($new_field) {
                $where[$placeholder]['field'] = $new_field;
              }
            }
          }
        }
      }
    }
  }
}

/**
 * Provide corresponding user ID to a dabase WHERE clause, decrypting all users.
 *
 * Convert database wilcards to php regex patterns. Use cache if called several
 * times during the script.
 *
 * @param $keys
 *   An array of research strings, using database wilcards ('%' and '_').
 * @param $field
 *   A string, the field into the {users} table : can be 'mail' (default) or
 *   'init'.
 * @param $operator
 *   A string, the operator on the WHERE clause. Default is 'LIKE'.
 *
 * @return
 *   An array, the user uids that match the keys (no index).
 */
function dbee_where_mailfields2uid($keys = array(), $field = 'mail', $operator = 'LIKE') {

  if (empty($keys) || (!is_array($keys)) || !in_array($field, array('mail', 'init'))) {
    return array();
  }

  // Prepare the regex patterns corresponding to the key(s).
  $patterns = array();
  // Look for unescaped wildcards :
  // find active '%' mysql wildcard, replaced by php regex '.*'.
  $pattern_percent = '[^\\\\]%|^%';
  // find active '_' mysql wildcard, replaced by php regex '.'.
  $pattern_underscore = '[^\\\\]_|^_';
  $pattern_wildcards = "$pattern_percent|$pattern_underscore";
  $like = in_array($operator, array('LIKE', 'NOT LIKE'));
  $sensitive_case = ($like) ? FALSE : TRUE;
  foreach ($keys as $key) {
    // Prepare the key

    $php_value = ($like && preg_match("!^%!", $key) === 1) ? '#' : '#^';
    if ($like) {

      $split_value = preg_split("!($pattern_wildcards)!", $key, -1, PREG_SPLIT_DELIM_CAPTURE | PREG_SPLIT_NO_EMPTY);
      $index_max = count($split_value) - 1;
      foreach ($split_value as $index => $string) {
        if (drupal_strlen($string) <= 2) {
          $substring = $string;
          $replace_by = '';
          if (preg_match("!([^\\\\])%|()^%!", $string, $previous_char) === 1) {
            $replace_by = ($index > 0 && $index < $index_max) ? '.*' : '';
            $substring = $previous_char[1];
          }
          elseif (preg_match("!([^\\\\])_|()^_!", $string, $previous_char) === 1) {
            $replace_by = '.';
            $substring = $previous_char[1];
          }
          // db_like() add addcslashes() fonction.
          $php_value .= quotemeta(stripcslashes($substring)) . $replace_by;
        }
        else {
          $php_value .= quotemeta(stripcslashes($string));
        }
      }
    }
    else {
      $php_value .= quotemeta($key);
    }
    if (!$sensitive_case) {
      $php_value = drupal_strtolower($php_value);
    }

    $php_value .= ($like && preg_match("!%$!", $key) === 1) ? '#' : '$#';
    $patterns[] = $php_value;
  }

  // Create cache.
  static $users = array();

  // Uncrypt all users, looking for such patterns.
  if (empty($users) || !array_key_exists(0, $users) || !array_key_exists($field, $users[0])) {
    $all_mails = db_query('SELECT uid, mail, init FROM {users} WHERE uid <> :uid ORDER BY uid', array(':uid' => 0));
    $result = array();
    while ($account = $all_mails->fetchAssoc()) {
      $uncrypted_field = dbee_decrypt($account[$field]);
      $users[$account['uid']][$field] = $uncrypted_field;
      $users[$account['uid']][$field . '_lc'] = drupal_strtolower($uncrypted_field);
    }
  }

  $field_case = ($sensitive_case) ? $field : $field . '_lc';
  foreach ($users as $uid => $datas) {
    $uncrypted_field = $datas[$field_case];
    // Search the key(s).
    foreach ($patterns as $pattern) {
      if (preg_match($pattern, $uncrypted_field)) {
        // Avoid doublon thanks to the index.
        $result[$uid] = $uid;
      }
    }
  }
  return array_values($result);
}
