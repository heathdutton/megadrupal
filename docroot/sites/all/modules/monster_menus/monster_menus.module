<?php

/**
 * @file
 * Menus, menus, menus
 */

require_once 'mm_constants.inc';
require_once 'mm_content.inc';
require_once 'mm_menu.inc';
require_once 'misc.inc';
require_once 'mm_ui.inc';
require_once 'mm_node.inc';
require_once 'mm_static.inc';

/**
 * Implements hook_help().
 */
function monster_menus_help($path, $arg) {
  switch ($path) {
    case 'admin/modules#description':
      return t('Provides a menu system with granular node access.');

    case 'admin/help#monster_menus':
      return t('<p></p>');

    case 'admin/mm/sites':
    case 'admin/mm/sites/list':
      return t('Monster Menus can manage an unlimited number of virtual sites, giving each its own menu tree. Each site can have different overall Drupal settings, but share the same content and Monster Menus permissions. To configure Drupal for multiple sites, see the comments in <code>sites/default/default.settings.php</code>. After setting up a new site, revisit this page using its URL, <strong>Add</strong> a new homepage, and select it as the homepage for the current site.');

    case 'admin/mm/regions':
      return t('Here, you can control which content types are allowed in each page region, and who can put them there. To change the default region for a given content type, visit !link and click on the <strong>Edit</strong> link for the type.', array('!link' => l('admin/structure/types', 'admin/structure/types')));

    case 'admin/mm/reassign':
      return t('This feature allows you to transfer ownership of all pages and nodes from one user to another. It is most useful when a particular user has been removed or blacklisted from the system.<p><em>This process is irreversible.</em> Only use this feature if you are absolutely sure you know what you are doing.</p>');

    case 'mm/%/contents/add':
      $temp_arg = array('node', 'add', NULL, NULL, NULL);
      if ($arg[4]) {
        $temp_arg[2] = $arg[4];
      }
      break;
  }

  foreach (mm_node_types() as $type) {
    if ('node/add#' . $type['name'] == $path) {
      return $type['description'];
    }
  }

  if ($arg[0] == 'mm' && $arg[2] == 'node') {
    $temp_arg = array_splice($arg, 2);
    $temp_path = drupal_substr($path, drupal_strlen('mm/%/'));
  }

  if (isset($temp_arg)) {
    $output = '';
    if (!isset($temp_path)) {
      $temp_path = rtrim(join('/', $temp_arg), '/');
    }
    foreach (mm_module_implements('help') as $name) {
      // Lookup help for this path.
      if ($help = module_invoke($name, 'help', $temp_path, $temp_arg)) {
        $output .= $help . "\n";
      }
    }
    return $output;
  }
}

/**
 * Implements hook_node_info().
 */
function monster_menus_node_info() {
  return mm_node_types();
}

/**
 * Implements hook_permission().
 */
function monster_menus_permission() {
  $perms = array(
    'administer all groups' => array(
      'title' => t('Administer all Monster Menus groups'),
      'description' => t('Create, read, update membership, and delete all Monster Menus groups'),
      'restrict access' => TRUE,
    ),
    'administer all menus' => array(
      'title' => t('Administer all Monster Menus menus'),
      'description' => t('Create, read, update settings, and delete all Monster Menus pages'),
      'restrict access' => TRUE,
    ),
    'administer all users' => array(
      'title' => t('Administer all Monster Menus user home pages'),
      'description' => t('Create, read, update settings, and delete all Monster Menus user home pages'),
      'restrict access' => TRUE,
    ),
    'see create/modify times' => array(
      'title' => t('See create/modify times'),
      'description' => t('Can see when a page was created and modified, in its settings'),
    ),
    'show/hide post information' => array(
      'title' => t('Show/Hide post information'),
      'description' => t('Allows user to set attribution styles for nodes'),
    ),
    'use permissions solver' => array(
      'title' => t('Use Monster Menus permissions solver'),
      'description' => t('Provides an interface for determining effective page permissions for users'),
    ),
    'use search/replace' => array(
      'title' => t('Use Monster Menus search'),
      'description' => t('Provides an interface to search a part of the Monster Menus tree'),
    ),
    'use tree browser' => array(
      'title' => t('Use Monster Menus tree browser'),
      'description' => t('Provides an interface for viewing the tree, for example when adding a file'),
    ),
    'view all menus' => array(
      'title' => t('View all Monster Menus menus'),
      'description' => t('Allows user to see the entire tree, in read-only mode'),
      'restrict access' => TRUE,
    ),
    'create archives' => array(
      'title' => t('Create Monster Menus archive pages'),
      'description' => t('Move nodes to an archive page when they pass a specified date'),
    ),
    'enable/disable comments' => array(
      'title' => t('Enable and disable comments'),
      'description' => t('Whether a user can turn commenting on or off at the node level'),
    ),
    'delete permanently' => array(
      'title' => t('Permanently delete from or empty recycle bins'),
      'description' => t('Allows the user to permanently delete content from or empty recycle bins'),
    ),
    'propagate node perms' => array(
      'title' => t('Propagate Monster Menus node permissions'),
      'description' => t('When saving Monster Menus page settings, the user can decide to apply permissions to all nodes on the page'),
      'restrict access' => TRUE,
    ),
    'propagate page perms' => array(
      'title' => t('Propagate Monster Menus page permissions'),
      'description' => t('When saving Monster Menus page settings, the user can decide to apply permissions to all sub-pages of the page'),
      'restrict access' => TRUE,
    ),
  );

  foreach (mm_node_types() as $type) {
    $perms = array_merge($perms, $type['perms']);
  }

  if (variable_get('mm_finegrain_comment_readability', FALSE)) {
    foreach (variable_get('mm_comments_readable_labels', array()) as $label)
      $perms[$label['perm']] = array(
        'title' => t('<em>Comment readability:</em> @perm', array('@perm' => $label['desc'])),
      );
    $perms[MM_COMMENT_READABILITY_DEFAULT] = array(
      'title' => t('<em>Comment readability:</em> @perm', array('@perm' => t('can read comments by default'))),
      'description' => t('When no other comment readability setting is applied to a node, roles checked here will be able to read the comments'),
    );
  }

  return $perms;
}

/**
 * Implements hook_mm_cascaded_settings().
 */
function monster_menus_mm_cascaded_settings() {
  return array(
    'allow_reorder' => array('data_type' => 'int', 'user_access' => 'administer all menus'),
    'allowed_themes' => array('data_type' => 'string', 'multiple' => TRUE, 'user_access' => 'administer all menus'),
    'allowed_node_types' => array('data_type' => 'string', 'multiple' => TRUE, 'user_access' => 'administer all menus'),
    'comments_readable' => array('data_type' => 'string', 'not_empty' => TRUE),
    'nodes_per_page' => array('data_type' => 'int', 'not_empty' => TRUE),
  );
}

/**
 * Implements hook_menu().
 */
function monster_menus_menu() {
  $items = array();
  foreach (mm_node_types() as $type) {
    $items = array_merge($items, $type['menus']);
  }

  module_load_include('inc', 'monster_menus', 'mm_admin');
  $items = array_merge($items, mm_admin_menu());
  module_load_include('inc', 'monster_menus', 'mm_browser');
  $items = array_merge($items, mm_browser_menu());

  $items['mm-auto'] = array(
    'title' => '',
    'page callback' => 'mm_autocomplete',
    'page arguments' => array(FALSE),
    'access callback' => 'user_access',
    'access arguments' => array('access user profiles'),
    'type' => MENU_CALLBACK);
  $items['mm-txtimg'] = array(
    'title' => '',
    'page callback' => 'mm_text2image_img',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK);
  $items['mmsr-get'] = array(
    'title' => '',
    'file' => 'mm_search_replace.inc',
    'page callback' => 'mm_search_result_count',
    'access callback' => 'user_access',
    'access arguments' => array('use search/replace'),
    'type' => MENU_CALLBACK);

  if (variable_get('mm_sitemap_max_level', MM_SITEMAP_MAX_LEVEL_DEFAULT) >= 0) {
    $items['-mm-sitemap'] = array(
      'title' => 'Generate sitemap.xml',
      'file' => 'mm_sitemap.inc',
      'page callback' => 'mm_sitemap',
      'access callback' => TRUE,
      'type' => MENU_CALLBACK);
    $items['sitemap.xml'] = array(
      'title' => 'View sitemap.xml',
      'file' => 'mm_sitemap.inc',
      'page callback' => 'mm_sitemap_show',
      'access callback' => TRUE,
      'type' => MENU_CALLBACK);
  }

  // Menu entries to display a page
  $items['mm'] = array(
    'title' => 'Home',
    'page callback' => 'mm_show_page',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK);
  $items['mm/%mm_mmtid'] = array(
    'title' => 'View',
    'page_callback' => 'mm_show_page',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK);
  $items['mm/%mm_mmtid/viewall'] = array(
    'title' => 'View All Users',
    'page callback' => 'mm_show_group',
    'page arguments' => array(1),
    'access callback' => '_mm_menu_access_group_viewall',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK);
  $items['mm/%mm_mmtid/%/render'] = array(
    'title' => 'Render the node(s) on a page',
    'page callback' => 'mm_render_nodes_on_page',
    'page arguments' => array(1, 2),
    'access callback' => 'mm_content_user_can',
    'access arguments' => array(1, MM_PERMS_READ),
    'type' => MENU_CALLBACK);

  // Local tasks -- Contents tab
  $items['mm/%mm_mmtid/contents'] = array(
    'title' => 'Contents',
    'access callback' => TRUE,
    'weight' => 1,
    'type' => MENU_DEFAULT_LOCAL_TASK);
  $items['mm/%mm_mmtid/contents/add'] = array(
    'title' => 'Add',
    'page callback' => 'mm_ui_node_add',
    'page arguments' => array(1, 4),
    'access callback' => '_mm_menu_access_add',
    'access arguments' => array(1),
    'weight' => 2,
    'type' => MENU_LOCAL_TASK);
  $items['mm/%mm_mmtid/contents/view'] = array(
    'title' => 'View',
    'weight' => 1,
    'type' => MENU_DEFAULT_LOCAL_TASK);
  $items['mm/%mm_mmtid/contents/reorder'] = array(
    'title' => 'Reorder',
    'file' => 'mm_ui_node_reorder.inc',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mm_ui_node_reorder', 1),
    'access callback' => '_mm_menu_access_node_reorder',
    'access arguments' => array(1),
    'weight' => 3,
    'type' => MENU_LOCAL_TASK);
  // Local tasks -- Settings tab
  $items['mm/%mm_mmtid/settings'] = array(
    'title' => 'Settings',
    'file' => 'mm_ui_content.inc',
    'page callback' => 'mm_ui_content',
    'page arguments' => array(1),
    'access callback' => '_mm_menu_access_settings_tab',
    'access arguments' => array(1),
    'weight' => 2,
    'type' => MENU_LOCAL_TASK);
  $items['mm/%mm_mmtid/settings/empty'] = array(
    'title' => 'Empty recycle bin',
    'file' => 'mm_ui_content.inc',
    'page callback' => 'mm_ui_content',
    'page arguments' => array(1, 'empty'),
    'access callback' => '_mm_menu_access_empty_bin',
    'access arguments' => array(1),
    'weight' => 2,
    'type' => MENU_LOCAL_TASK);
  $items['mm/%mm_mmtid/settings/edit'] = array(
    'title' => 'Edit',
    'file' => 'mm_ui_content.inc',
    'page callback' => 'mm_ui_content',
    'page arguments' => array(1, 'edit'),
    'access callback' => '_mm_menu_access_edit',
    'access arguments' => array(1),
    'weight' => 1,
    'type' => MENU_DEFAULT_LOCAL_TASK);
  $items['mm/%mm_mmtid/settings/copymove'] = array(
    'title' => 'Copy/Move',
    'file' => 'mm_ui_content.inc',
    'page callback' => 'mm_ui_content',
    'page arguments' => array(1, 'copymove'),
    'access callback' => '_mm_menu_access_copy',
    'access arguments' => array(1),
    'weight' => 2,
    'type' => MENU_LOCAL_TASK);
  $items['mm/%mm_mmtid/settings/restore'] = array(
    'title' => 'Restore',
    'file' => 'mm_ui_content.inc',
    'page callback' => 'mm_ui_content',
    'page arguments' => array(1, 'restore'),
    'access callback' => '_mm_menu_access_restore',
    'access arguments' => array(1),
    'weight' => 3,
    'type' => MENU_LOCAL_TASK);
  $items['mm/%mm_mmtid/settings/delete'] = array(
    'title callback' => '_mm_menu_title_settings_delete',
    'title arguments' => array(1),
    'file' => 'mm_ui_content.inc',
    'page callback' => 'mm_ui_content',
    'page arguments' => array(1, 'delete'),
    'access callback' => '_mm_menu_access_delete',
    'access arguments' => array(1),
    'weight' => 4,
    'type' => MENU_LOCAL_TASK);
  $items['mm/%mm_mmtid/settings/sub'] = array(
    'title callback' => '_mm_menu_title_settings_sub',
    'title arguments' => array(1),
    'file' => 'mm_ui_content.inc',
    'page callback' => 'mm_ui_content',
    'page arguments' => array(1, 'sub'),
    'access callback' => '_mm_menu_access_sub',
    'access arguments' => array(1),
    'weight' => 5,
    'type' => MENU_LOCAL_TASK);
  $items['mm/%mm_mmtid/settings/reorder'] = array(
    'title' => 'Reorder menu',
    'file' => 'mm_ui_menu_reorder.inc',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mm_ui_menu_reorder', 1),
    'access callback' => '_mm_menu_access_menu_reorder',
    'access arguments' => array(1),
    'weight' => 6,
    'type' => MENU_LOCAL_TASK);
  $items['mm/%mm_mmtid/settings/revisions'] = array(
    'title' => 'Revisions',
    'file' => 'mm_ui_content.inc',
    'page callback' => 'mm_ui_content_revisions',
    'page arguments' => array(1),
    'access callback' => 'user_access',
    'access arguments' => array('see create/modify times'),
    'weight' => 7,
    'type' => MENU_LOCAL_TASK);
  $items['mm/%mm_mmtid/settings/search'] = array(
    'title' => 'Search', // eventually Search/Replace
    'file' => 'mm_ui_content.inc',
    'page callback' => 'mm_ui_content',
    'page arguments' => array(1, 'search'),
    'access callback' => 'user_access',
    'access arguments' => array('use search/replace'),
    'weight' => 8,
    'type' => MENU_LOCAL_TASK);
  $items['mm/%mm_mmtid/settings/search/result'] = array(
    'title' => 'Search', // eventually Search/Replace
    'file' => 'mm_ui_content.inc',
    'page callback' => 'mm_ui_content',
    'page arguments' => array(1, 'search result'),
    'access callback' => 'user_access',
    'access arguments' => array('use search/replace'),
    'type' => MENU_CALLBACK);
  $items['mm/%mm_mmtid/settings/search/result.csv'] = array(
    'title' => 'Search', // eventually Search/Replace
    'file' => 'mm_ui_content.inc',
    'page callback' => 'mm_ui_content',
    'page arguments' => array(1, 'search result csv'),
    'access callback' => 'user_access',
    'access arguments' => array('use search/replace'),
    'type' => MENU_CALLBACK);
  $items['mm/%mm_mmtid/settings/solver'] = array(
    'title' => 'Solve Permissions Issues',
    'file' => 'mm_ui_solver.inc',
    'page callback' => 'mm_ui_solver',
    'page arguments' => array(1, 4),
    'access callback' => '_mm_menu_access_solver',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK);
  $items['mm/%mm_mmtid/csv_export'] = array(
    'title' => 'Export Group Members',
    'file' => 'mm_ui_content_edit.inc',
    'page callback' => 'mm_ui_content_edit_export',
    'page arguments' => array(1),
    'access callback' => '_mm_menu_access_edit',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK);
  $items['-mm-users-json/%mm_mmtid/listusers/%'] = array(
    'title' => 'List users in a group',
    'page callback' => 'mm_large_group_get_users_json',
    'page arguments' => array(1, 3),
    'access callback' => 'mm_content_user_can',
    'access arguments' => array(1, MM_PERMS_READ),
    'type' => MENU_CALLBACK);
  $items['-mm-users-json/%mm_mmtid/%mm_form_token/listusers/%'] = array(
    'title' => 'List users in a group',
    'load arguments' => array(1, 2, 5),
    'page callback' => 'mm_large_group_get_users_json',
    'page arguments' => array(1, 4, 2),
    'access callback' => 'mm_content_user_can',
    'access arguments' => array(1, MM_PERMS_READ),
    'type' => MENU_CALLBACK);
  $items['-mm-users-json/%mm_mmtid/%mm_form_token/deleteusers/%user'] = array(
    'title' => 'Delete user from a group',
    'file' => 'mm_ui_content.inc',
    'load arguments' => array(1, 2, 5),
    'page callback' => 'mm_large_group_delete_user',
    'page arguments' => array(1, 2, 4),
    'access callback' => '_mm_menu_access_edit',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK);
  $items['-mm-users-json/%mm_mmtid/%mm_form_token/addusers/%'] = array(
    'title' => 'Add users to a group',
    'file' => 'mm_ui_content.inc',
    'load arguments' => array(1, 2, 5),
    'page callback' => 'mm_large_group_add_users',
    'page arguments' => array(1, 2, 4),
    'access callback' => '_mm_menu_access_edit',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK);

  // Node operations
  $items['mm/%mm_mmtid/node/%node/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'mm_ui_node_edit',
    'page arguments' => array(3),
    'access callback' => 'node_access',
    'access arguments' => array('update', 3),
    'type' => MENU_CALLBACK);
  $items['mm/%mm_mmtid/node/%node/delete'] = array(
    'title callback' => '_mm_menu_title_node_delete',
    'title arguments' => array(3),
    'file' => 'mm_ui_node_delete.inc',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mm_ui_node_delete_confirm', 1, 3),
    'access callback' => '_mm_menu_access_node_delete',
    'access arguments' => array(3),
    'type' => MENU_CALLBACK);
  $items['mm/%mm_mmtid/node/%node/restore'] = array(
    'title' => 'Restore',
    'file' => 'mm_ui_node_restore.inc',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mm_ui_node_restore_confirm', 1, 3),
    'access callback' => '_mm_menu_access_node_restore',
    'access arguments' => array(1, 3),
    'type' => MENU_CALLBACK);
  // Node revisions
  $items['mm/%mm_mmtid/node/%node/revisions'] = array(
    'title' => 'Revisions',
    'page callback' => 'mm_ui_node_revisions',
    'page arguments' => array(3),
    'access callback' => '_mm_menu_access_node_revisions',
    'access arguments' => array(3),
    'type' => MENU_CALLBACK);
  $items['mm/%mm_mmtid/node/%node/revisions/%/revert'] = array(
    'title' => 'Revert to earlier revision',
    'load arguments' => array(5),
    'page callback' => 'mm_ui_node_revisions',
    'page arguments' => array(3, 5, 'revert'),
    'access callback' => '_mm_menu_access_node_revisions',
    'access arguments' => array(3),
    'type' => MENU_CALLBACK);
  $items['mm/%mm_mmtid/node/%node/revisions/%/delete'] = array(
    'title' => 'Delete earlier revision',
    'load arguments' => array(5),
    'page callback' => 'mm_ui_node_revisions',
    'page arguments' => array(3, 5, 'delete'),
    'access callback' => '_mm_menu_access_node_revisions',
    'access arguments' => array(3),
    'type' => MENU_CALLBACK);
  $items['mm/%mm_mmtid/node/%node/revisions/%/view'] = array(
    'title' => 'View a revision',
    'load arguments' => array(5),
    'page callback' => 'mm_ui_node_revisions',
    'page arguments' => array(3, 5, 'view'),
    'access callback' => '_mm_menu_access_node_revisions',
    'access arguments' => array(3),
    'type' => MENU_CALLBACK);
  $items['mm/%mm_mmtid/node/%node/revisions/%/view/%'] = array(
    'title' => 'Compare revisions',
    'load arguments' => array(5),
    'page callback' => 'mm_ui_node_revisions',
    'page arguments' => array(3, 5, 'compare', 7),
    'access callback' => '_mm_menu_access_node_revisions',
    'access arguments' => array(3),
    'type' => MENU_CALLBACK);
  // alternate version of the above, used in the diff module
  $items['mm/%mm_mmtid/node/%node/revisions/view/%'] = array(
    'title' => 'Compare revisions',
    'load arguments' => array(6),
    'page callback' => 'mm_ui_node_revisions',
    'page arguments' => array(3, 6, 'compare', 7),
    'access callback' => '_mm_menu_access_node_revisions',
    'access arguments' => array(3),
    'type' => MENU_CALLBACK);

  $items['mm/%mm_mmtid/ajax_node'] = array(
    'title' => 'Get nodes for a page using Ajax call',
    'page callback' => 'mm_content_load_by_ajax',
    'page arguments' => array(1),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK);

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function monster_menus_menu_alter(&$callbacks) {
  // override the function in user.module
  $callbacks['user/autocomplete'] = array(
    'title' => 'User autocomplete',
    'page callback' => 'mm_autocomplete',
    'page arguments' => array(TRUE),
    'access callback' => 'user_access',
    'access arguments' => array('access user profiles'),
    'type' => MENU_CALLBACK);

  if (isset($callbacks['taxonomy/term/%taxonomy_term'])) {
    // Override a couple of functions in taxonomy.module with our own versions
    // which present only the results the user can see
    $callbacks['taxonomy/term/%taxonomy_term'] = array(
      'title' => 'Taxonomy term',
      'page callback' => 'mm_taxonomy_term_page',
      'page arguments' => array(2),
      'access arguments' => array('access content'),
      'type' => MENU_CALLBACK,
      'file' => 'mm_taxonomy.inc',
      'module' => 'monster_menus',
    );
  }

  if (isset($callbacks['taxonomy/term/%taxonomy_term/feed'])) {
    // Override a couple of functions in taxonomy.module with our own versions
    // which present only the results the user can see
    $callbacks['taxonomy/term/%taxonomy_term/feed'] = array(
      'title' => 'Taxonomy term',
      'title callback' => 'taxonomy_term_title',
      'title arguments' => array(2),
      'page callback' => 'mm_taxonomy_term_feed',
      'page arguments' => array(2),
      'access arguments' => array('access content'),
      'type' => MENU_CALLBACK,
      'file' => 'mm_taxonomy.inc',
      'module' => 'monster_menus',
    );
  }

  // Remove the default node page, which displays all promoted nodes
  $callbacks['node']['access callback'] = FALSE;

  if (module_exists('comment')) {
    $callbacks['mm/%mm_mmtid/comment/delete'] = array(
      'title' => 'Delete comment',
      'page callback' => 'mm_ui_comment',
      'page arguments' => array(3),
      'access arguments' => array('administer comments'),
      'type' => MENU_CALLBACK,
    );
    $callbacks['mm/%mm_mmtid/comment/edit'] = array(
      'title' => 'Edit comment',
      'page callback' => 'mm_ui_comment',
      'page arguments' => array(3),
      'access arguments' => array('post comments'),
      'type' => MENU_CALLBACK,
    );
    $callbacks['mm/%mm_mmtid/comment/reply/%node'] = array(
      'title' => 'Reply to comment',
      'page callback' => 'mm_ui_comment',
      'page arguments' => array(3, 4),
      'access callback' => 'node_access',
      'access arguments' => array('view', 4),
      'type' => MENU_CALLBACK,
    );
  }

  // These menu entries rely upon core form functions that need to be loaded
  // from disk when the MM menu entry is called
  $callbacks['mm/%mm_mmtid/contents/add']['file'] = $callbacks['node/add']['file'];
  $callbacks['mm/%mm_mmtid/contents/add']['module'] = $callbacks['node/add']['module'];
  $old_paths = array(
    'node/%node/edit',
    'node/%node/revisions',
    'node/%node/revisions/%/revert',
    'node/%node/revisions/%/delete',
    'comment/delete',
    'comment/edit',
    'comment/reply/%node',
  );
  foreach ($old_paths as $old_path) {
    if (isset($callbacks[$old_path]['file'])) {
      $callbacks["mm/%mm_mmtid/$old_path"]['file'] = $callbacks[$old_path]['file'];
    }

    if (isset($callbacks[$old_path]['module'])) {
      $callbacks["mm/%mm_mmtid/$old_path"]['module'] = $callbacks[$old_path]['module'];
    }
  }

  mm_module_invoke_all_array('mm_menu_alter', array(&$callbacks));

  foreach ($callbacks as $path => $callback) {
    if (!isset($callbacks["mm/%mm_mmtid/$path"]) && (substr_compare('node/', $path, 0, 5) === 0 || substr_compare('comment/', $path, 0, 8) === 0)) {
      if (substr_count($path, '/') + 2 >= MENU_MAX_PARTS) {
        drupal_set_message(t("The menu path @path is too long to be translated by Monster Menus. It may not work properly, depending on the module's code.", array('@path' => $path)));
      }
      else {
        foreach (array('load arguments', 'access arguments', 'page arguments', 'title arguments', 'theme arguments') as $type) {
          if (isset($callback[$type]) && is_array($callback[$type])) {
            foreach ($callback[$type] as $index => $val) {
              if (is_int($val)) {
                $callback[$type][$index] = $val + 2;
              }
            }
          }
        }

        if (isset($callback['page callback'])) {
          if ($callback['page callback'] == 'node_page_view') {
            $callback['page callback'] = 'mm_node_page_view';
          }
          else if ($callback['page callback'] == 'comment_permalink') {
            $callback['page callback'] = 'mm_comment_permalink';
            $callback['page arguments'][] = 1;  // Add the mmtid.
          }
        }

        $callbacks["mm/%mm_mmtid/$path"] = $callback;
        if (preg_match('{^node/%(\w+)(/|$)}', $path)) {
          $callbacks[$path]['page callback'] = '_mm_menu_show_node';
          $callbacks[$path]['page arguments'] = array(1);
          $callbacks[$path]['access callback'] = 'mm_content_user_can_node';
          $callbacks[$path]['access arguments'] = array(1, MM_PERMS_READ);
        }
        else {
          unset($callbacks[$path]);
        }
      }
    }
  }

  // Override the default node delete page
  $callbacks['node/%node/delete'] = array(
    'title callback' => '_mm_menu_title_node_delete',
    'title arguments' => array(1),
    'file' => 'mm_ui_node_delete.inc',
    'module' => 'monster_menus',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mm_ui_node_delete_confirm', NULL, 1),
    'access callback' => '_mm_menu_access_node_delete',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK
  );

  // Override the default node revisions page
  $callbacks['node/%node/revisions'] = array(
    'title' => 'Revisions',
    'page callback' => 'mm_ui_node_revisions',
    'page arguments' => array(1),
    'access callback' => '_mm_menu_access_node_revisions',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK
  );
  $callbacks['node/%node/revisions/view/%/%'] = array(
    'title' => 'Revisions',
    'page callback' => 'mm_ui_node_revisions',
    'page arguments' => array(1, 4, 'compare', 5),
    'access callback' => '_mm_menu_access_node_revisions',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK
  );
  if ($callbacks['node/%node/revisions/%/view']['page callback'] == 'node_show') {
    $callbacks['node/%node/revisions/%/view']['page callback'] = 'mm_node_show';
  }

  // Generate the list of keywords that are not allowed in URL aliases, and give
  // an error message if there already is something in mm_tree using one of the
  // menu keywords.
  $checked = $reserved = array();
  foreach ($callbacks as $path => $callback) {
    // Remove leading or trailing slashes, then squish any multiple slashes in a
    // row.
    $elems = explode('/', preg_replace('{//+}', '/', trim($path, '/')));
    if (count($elems) >= 3 && $elems[0] == 'mm' && $elems[1] == '%mm_mmtid') {
      $failed_elems = array();
      for ($i = 2; $i < count($elems); $i++) {
        // Only reserve the first non-token after mm/%mm_mmtid
        if ($elems[$i][0] != '%') {
          if (empty($reserved[$elems[$i]])) {
            if (!isset($checked[$elems[$i]])) {
              $checked[$elems[$i]] = mm_content_get(array('alias' => $elems[$i]), array(), 10);
            }

            if (!empty($checked[$elems[$i]])) {
              $failed_elems[] = $elems[$i];
            }
            $reserved[$elems[$i]] = TRUE;
          }
          break;
        }
      }

      foreach ($failed_elems as $elem) {
        $list = array();
        foreach ($checked[$elem] as $tree) {
          $list[] = '&nbsp;&nbsp;' . l(mm_content_get_name($tree), 'mm/' . $tree->mmtid . '/settings');
        }
        $error = 'The menu entry %entry, defined by module %module, contains the element %element. This conflicts with the URL names that are already assigned to these MM pages:<br />!list<br />The menu entry has been disabled. You must change the URL name(s) and rebuild the menus.';
        $err_arr = array(
          '%entry' => $path,
          '%module' => empty($callback['module']) ? t('(unknown)') : $callback['module'],
          '%element' => $elem,
          '!list' => join('<br />', $list),
        );
        if (user_access('administer all menus')) {
          drupal_set_message(t($error, $err_arr), 'error');
        }
        watchdog('mm', $error, $err_arr, WATCHDOG_ERROR);
        unset($callbacks[$path]);
      }
    }
  }
  variable_set('mm_reserved_alias', array_merge(array_keys($reserved), mm_content_reserved_aliases_base()));

  // Emit an error message if there already is something in mm_tree that would
  // match one of the system menu entries.
  // First, get the position of the homepage within the tree.
  //   SELECT depth FROM mm_tree_parents WHERE parent = [mm_home_mmtid()] LIMIT 1
  $home_depth = db_select('mm_tree_parents', 'p')
    ->condition('parent', mm_home_mmtid())
    ->fields('p', array('depth'))
    ->range(0, 1)
    ->execute()
    ->fetchField();
  if (isset($home_depth)) {
    foreach ($callbacks as $path => $callback) {
      // Remove leading or trailing slashes, then squish any multiple slashes in
      // a row.
      $elems = explode('/', preg_replace('{//+}', '/', trim($path, '/')));
      if (count($elems) >= 2 && $elems[0] == 'mm' && $elems[1] == '%mm_mmtid') {
        continue;
      }
      $where = '';
      $compare_total = 0;
      // SELECT COUNT(*) FROM mm_tree t
      //   INNER JOIN mm_tree_parents p ON p.mmtid = t.mmtid
      //   INNER JOIN mm_tree t2 ON t2.mmtid = p.parent
      // WHERE t.alias = '[level 3 alias]' AND (
      //   SELECT COUNT(*) FROM mm_tree_parents WHERE mmtid = t.mmtid) = 4 AND (
      //     t2.alias = '[level 2 alias]' AND p.depth = 3
      //     OR t2.alias = '[level 1 alias]' AND p.depth = 2
      //     OR p.depth = 1 AND t2.mmtid = [mm_home_mmtid()] )     (etc.)
      // GROUP BY t.mmtid HAVING COUNT(*) = [overall depth]
      $ors = array('p.depth = :home_depth AND t2.mmtid = :home_mmtid');
      $args = array(':home_depth' => $home_depth, ':home_mmtid' => mm_home_mmtid());
      foreach (array_reverse($elems, TRUE) as $depth => $elem) {
        if ($elem[0] != '%') {
          $args[":alias$depth"] = $elem;
          $args[":depth$depth"] = $depth + $home_depth + 1;
          if (empty($where)) {
            $where = "t.alias = :alias$depth AND (SELECT COUNT(*) FROM {mm_tree_parents} WHERE mmtid = t.mmtid) = :depth$depth";
          }
          else {
            $ors[] = "t2.alias = :alias$depth AND p.depth = :depth$depth";
          }
          $compare_total++;
        }
      }

      if ($where) {
        $args[':compare'] = $compare_total;
        if ($ors) {
          $where .= ' AND (' . join(' OR ', $ors) . ')';
        }
        $result = db_query('SELECT t.* FROM {mm_tree} t ' .
          'INNER JOIN {mm_tree_parents} p ON p.mmtid = t.mmtid ' .
          "INNER JOIN {mm_tree} t2 ON t2.mmtid = p.parent WHERE $where " .
          'GROUP BY t.mmtid HAVING COUNT(*) = :compare LIMIT 10', $args);
        $list = array();
        foreach ($result as $tree) {
          $list[] = '&nbsp;&nbsp;' . l(mm_content_get_name($tree), 'mm/' . $tree->mmtid . '/settings');
        }
        if ($list) {
          $error = 'The menu entry %entry, defined by module %module, conflicts with these MM pages:<br />!list<br />The menu entry has been disabled. Change either the URL name(s) or the menu path and rebuild the menus.';
          $err_arr = array(
            '%entry' => $path,
            '%module' => empty($callback['module']) ? t('(unknown)') : $callback['module'],
            '!list' => join('<br />', $list),
          );
          if (user_access('administer all menus')) {
            drupal_set_message(t($error, $err_arr), 'error');
          }
          watchdog('mm', $error, $err_arr, WATCHDOG_ERROR);
          unset($callbacks[$path]);
        }
      }
    }
  }

  // Regenerate the list of MM tree entry names to hide from non-admin users
  $hidden_names = array(MM_ENTRY_NAME_DEFAULT_USER, MM_ENTRY_NAME_DISABLED_USER);
  $hidden_names = array_merge($hidden_names, mm_module_invoke_all('mm_hidden_user_names'));
  variable_set('mm_hidden_user_names', $hidden_names);
  // debug_add_dump($callbacks);

  // Regenerate the custom page display list
  _mm_showpage_router(TRUE);
}

/**
 * Implements hook_node_view().
 */
function monster_menus_node_view($node, $view_mode) {
  if (!isset($node)) return;

  mm_node_all_nodes_hook('view', $node, $view_mode);

  $_mm_mmtid_of_node = &drupal_static('_mm_mmtid_of_node');
  $_mm_page_args = &drupal_static('_mm_page_args');

  if (!empty($node->nid) && !mm_content_user_can_node($node, MM_PERMS_READ)) {
    mm_node_load_fail($node, $view_mode == 'teaser');
  }
  else {
    // If this is a view rendering a node not on an MM page, allow the
    // Edit/Delete/etc. links to appear.
    if (isset($node->view) && isset($node->view->style_plugin) && isset($node->view->style_plugin->row_plugin) && $node->view->style_plugin->row_plugin->options['links']) {
      $_mm_mmtid_of_node[$node->nid] = TRUE;
    }

    // Restrict comment access based on MM's node- and page-level settings.
    if ($node->comment && $view_mode == 'full' && module_exists('comment') && empty($node->in_preview)) {
      if (_mm_content_comments_readable($node)) {
        // The comment module's hook_node_view() uses node_is_page(), which
        // requires that the node be displayed all by itself with a node/% URL.
        // Therefore, we need to load any comments here.
        if (!node_is_page($node)) {
          if (variable_get('mm_show_count_instead_of_comments', FALSE)) {
            $args = arg();
            if (($count = count($args)) >= 2 && $args[$count - 2] == 'node' && $args[$count - 1] == $node->nid) {
              $node->content['comments'] = comment_node_page_additions($node);
              unset($node->content['links']['comment']['#links']['comment_forbidden']);
            }
            else {
              // Redo the comments using the teaser view, to get the proper
              // links.
              comment_node_view($node, 'teaser');
            }
          }
          else {
            $node->content['comments'] = comment_node_page_additions($node);
          }
        }
      }
      else {
        // The user cannot view comments. Remove any links and the comments
        // themselves.
        $node->content['links']['comment']['#links'] = array();
        unset($node->content['comments']);
        if ($node->comment_count > 0) {
          // Add a "Log in to read or post comments" message.
          $node->content['links']['comment']['#links']['comment_forbidden'] = array('title' => theme('comment_post_forbidden', array('node' => $node, 'read' => TRUE)), 'html' => TRUE);
        }
      }
    }
  }

  $node->title = mm_ui_hide_node_title($node->title);

  $node_types = array_keys(node_type_get_names());
  _mm_menu_active_item();
  if (isset($_mm_mmtid_of_node[$node->nid]) && in_array($node->type, $node_types)) {
    $defaults = array('query' => array('destination' => 'mm/' . $_mm_mmtid_of_node[$node->nid]));
    $links = array();
    if (!empty($_GET['destination'])) {
      $defaults = array('query' => array('destination' => $_GET['destination']));
    }

    $pa = empty($_mm_page_args) ? 'node/' : "$_mm_page_args/node/";

    $query = db_select('node_revision', 'r');
    $query->join('node', 'n', 'n.nid = r.nid');
    $query->condition('r.nid', $node->nid, '=');
    $query->addField('n', 'vid', 'current_vid');
    $query->addExpression('COUNT(*)', 'count_revisions');
    $revisions = $query->execute()->fetchObject();

    $is_latest = $revisions->current_vid == $node->vid;
    if ($is_latest && node_access('update', $node)) {
      $links[] = $defaults + array('title' => t('Edit'), 'href' => $pa . $node->nid . '/edit');
    }

    if (_mm_menu_access_node_restore($_mm_mmtid_of_node[$node->nid], $node)) {
      $links[] = array(
        'title' => t('Restore'),
        'href' => $pa . $node->nid . '/restore');
    }

    if ($is_latest && _mm_menu_access_node_delete($node)) {
      $perm = mm_content_node_is_recycled($node, MM_NODE_RECYCLED_MMTID_CURR);
      $links[] = ($perm ? array() : $defaults) + array(
        'title' => $perm ? t('Delete permanently') : t('Delete'),
        'href' => $pa . $node->nid . '/delete');
    }

    if ($revisions->count_revisions > 1 && node_access('update', $node) && node_access('view', $node) && (user_access('view revisions') || (user_access('administer nodes') && user_access('bypass node access')))) {
      $links[] = $defaults + array('title' => t('Revisions'),
          'href' => $pa . $node->nid . '/revisions');
      if (!$is_latest) {
        $links[] = $defaults + array('title' => t('Revert to this revision'),
            'href' => $pa . $node->nid . '/revisions/' . $node->vid . '/revert');
        $links[] = $defaults + array('title' => t('Delete this revision'),
            'href' => $pa . $node->nid . '/revisions/' . $node->vid . '/delete');
      }
    }

    if ($links) {
      $node->content['links'][$node->type] = array(
        '#links' => $links,
        '#attributes' => array('class' => array('links', 'inline')),
      );
    }
  }

  if ($view_mode == 'rss' && isset($node->nid)) {
    $node->created = $node->changed;
  }
}

/**
 * Implements hook_boot().
 */
function monster_menus_boot() {
  global $user;

  if ($user->uid > 0) {
    mm_set_user_roles($user);
  }

  // The module_implements() static cache may get modified below. However,
  // because we are only in the bootstrap phase, any changes will be incomplete.
  // Therefore, store a copy of what's there now and restore it later on.
  $implementations = &drupal_static('module_implements');
  // Create a clone.
  $old_implementations = empty($implementations) ? array() : $implementations + array();

  // Rewrite the URL stored in $_GET so that MM aliases point to the correct location
  require_once DRUPAL_ROOT . '/includes/unicode.inc';
  $old_q = $new_q = isset($_GET['q']) ? $_GET['q'] : '';
  mm_module_invoke_all_array('url_inbound_alter', array(&$new_q, $new_q, NULL));
  if ($new_q != '' || $_GET['q'] == mm_home_path() || $_GET['q'] == mm_home_path() . '/') {
    $_GET['q'] = $new_q;
    if ($_SERVER['REQUEST_METHOD'] == 'GET' || $_SERVER['REQUEST_METHOD'] == 'HEAD') {
      // If the URL contains mm/N or just N, redirect to the appropriate alias
      if (preg_match('{^(mm/)?\d+/?$}', $old_q)) {
        require_once DRUPAL_ROOT . '/includes/path.inc';
        require_once DRUPAL_ROOT . '/includes/common.inc';
        $dummy = array();
        mm_module_invoke_all_array('url_outbound_alter', array(&$new_q, &$dummy, $new_q));
        // Only redirect if the URL has changed and this is not an anonymous
        // page cache hit.
        if ($new_q != $old_q && !in_array('X-Drupal-Cache: HIT', headers_list())) {
          module_load_include('module', 'filter', 'filter');
          module_load_include('module', 'field', 'field');
          $GLOBALS['devel_shutdown'] = TRUE;    // prevent a missing function problem
          // 'language' is necessary because global $language_url isn't initialized yet
          drupal_goto($new_q, array('query' => drupal_get_query_parameters($_GET, array('q')), 'language' => language_default()));
        }
      }
    }
  }
  // Reset the module_implements() static cache because it is not valid. It's
  // not necessary to do this before the drupal_goto() above, since that call
  // does not trigger a write to disk.
  $implementations = $old_implementations;
}

/**
 * Implements hook_custom_theme().
 */
function monster_menus_custom_theme() {
  mm_parse_args($mmtids, $oarg_list);
  // MySQL works faster if there are no negative mmtids here.
  $mmtids = array_filter($mmtids, create_function('$mmtid', 'return $mmtid > 0;'));
  if (count($mmtids)) {
    $select = db_select('mm_tree', 't');
    $select->fields('t', array('theme'));
    $select->addExpression('LENGTH(sort_idx)', 'tree_depth');
    $select->condition('t.mmtid', $mmtids)
      ->condition('t.theme', '', '<>')
      ->orderBy('tree_depth', 'DESC')
      ->range(0, 1);
    if ($theme = $select->execute()->fetchField()) {
      return $theme;
    }
  }
}

/**
 * Implements hook_url_inbound_alter().
 */
function monster_menus_url_inbound_alter(&$path, $original_path, $path_language) {
  $cache = &drupal_static(__FUNCTION__);

  if (preg_match('/^\w+:/', $original_path)) {
    // Ignore URLs starting with "proto:".
    return;
  }

  // remove empty '//' elements
  $original_path = preg_replace('{/+}', '/', $original_path);
  $original_path = trim($original_path, '/');

  $path = $original_path;
  if ($original_path == '' || $original_path == mm_home_path()) {
    $path = mm_home_path();
    return;
  }

  if (isset($cache[$original_path])) {
    $path = $cache[$original_path];
    return;
  }
//   debug_add("* from: $original_path");

  $elems = explode('/', $original_path);
  $in_mm = FALSE;
  if ($elems[0] == 'mm' && count($elems) >= 2 && is_numeric($elems[1])) {
    $in_mm = TRUE;
    array_shift($elems);
  }

  if ($elems[0] == mm_home_mmtid()) {
    $in_mm = TRUE;
    $this_mmtid = $parent = mm_home_mmtid();
    array_shift($elems);
  }

  if (count($elems) >= 2 && ($elems[0] == mm_content_users_alias() || is_numeric($elems[0]) && $elems[0] == mm_content_users_mmtid()) && strlen($elems[1]) == 1 && variable_get('mm_use_virtual_user_dir', TRUE)) {
    $in_mm = TRUE;
    $alias = ctype_alpha($elems[1][0]) ? strtoupper($elems[1][0]) : '~';
    array_splice($elems, 0, 2);
    $this_mmtid = $parent = count($elems) ? mm_content_users_mmtid() : -ord($alias);
  }

  $joins = $wheres = $numeric = $args = $args_at_level = array();
  $a = 0;
  $reserved = mm_content_reserved_aliases();
  $max = min(count($elems), variable_get('mm_content_mysql_max_joins', MM_CONTENT_MYSQL_MAX_JOINS));
  for ($i = 0; $i < $max; $i++) {
    $elem = $elems[$i];
    $numeric[$i] = FALSE;
    if (!$in_mm && $i == 0 && ($elem == 'settings' || $elem == 'contents')) {
      $in_mm = TRUE;
      $this_mmtid = mm_home_mmtid();
      break;
    }
    elseif (!in_array($elem, $reserved)) {
      $n = count($joins);
      $nprev = $n - 1;
      $joins[] = "{mm_tree} t$n" . ($n ? " ON t$n.parent = t$nprev.mmtid" : '');
      $prefix = $n ? '' : (empty($parent) ? '' : "t0.parent = $parent AND ");
      $middle = $n ? '' : (empty($parent) ? 't0.parent IN(1, ' . mm_home_mmtid() . ') AND ' : '');
      $numeric[$i] = is_numeric($elem) && intval($elem) == $elem && $elem != 0;
      $args[':a' . $a++] = $elem;
      if ($numeric[$i] && $elem > 0) {
        $wheres[] = "{$prefix}(t$n.mmtid = :a" . ($a - 1) . " OR {$middle}t$n.alias = :a$a)";
        $args[':a' . $a++] = $elem;
        $args_at_level[$i] = 2;
      }
      else {
        $wheres[] = "{$prefix}{$middle}t$n.alias = :a" . ($a - 1);
        $args_at_level[$i] = 1;
      }
    }
    else break;
  }

  while ($joins) {
    $n = count($joins) - 1;
    $new_mmtid = db_query("SELECT t$n.mmtid FROM " . join(' INNER JOIN ', $joins) . ' WHERE ' . join(' AND ', $wheres) . " ORDER BY t$n.alias LIMIT 1", $args)->fetchField();
    array_pop($joins);
    array_pop($wheres);
    $was_numeric = array_pop($numeric);
    if ($new_mmtid) {
      $in_mm = TRUE;
      $this_mmtid = $new_mmtid;
      break;
    }
    elseif ($was_numeric) {
      if ($elems[0] < 0) {
        $this_mmtid = $elems[0];
        $in_mm = TRUE;
        break;
      }
      elseif (!$joins) {
        $site_404 = variable_get('site_404', '');
        if ($site_404 && $site_404 != $original_path) {
          mm_module_invoke_all_array('url_inbound_alter', array(&$path, $site_404, $path_language));
          return;
        }
        break;
      }
    }
    // There can't be any extra args, so remove what's not needed
    if ($popped = array_pop($args_at_level)) {
      array_splice($args, -$popped);
    }
    $i--;
  }

  if ($in_mm && !empty($this_mmtid)) {
    $elems = array_slice($elems, $i);
    array_unshift($elems, "mm/$this_mmtid");
    $path = implode('/', $elems);
  }
  $cache[$original_path] = $path;
//   debug_add("* to: $path ");
}

/**
 * Implements hook_url_outbound_alter().
 */
function monster_menus_url_outbound_alter(&$path, &$options, $unused) {
  global $base_url;
  $_mm_custom_url_rewrite_outbound_cache = &drupal_static('_mm_custom_url_rewrite_outbound_cache', array());
  $original_path = $path;

  // Remove any absolute, internal path
  $base_slash = $base_url . '/';
  $base_len = strlen($base_slash);
  if (!strncmp($path, $base_slash, $base_len)) {
    $path = substr($path, $base_len);
    $absolute = TRUE;
  }

  $cache_id = $original_path . ':' . (isset($options['query']) && $options['query'] ? serialize($options['query']) : '');
  if (isset($_mm_custom_url_rewrite_outbound_cache[$cache_id])) {
    $path = $_mm_custom_url_rewrite_outbound_cache[$cache_id];
    return;
  }

  // Rewrite comment URLs that were not generated the proper way, using the
  // entity hook.
  if (preg_match('{^comment(/reply/\d+)?/(\d+)(.*)}', $path, $matches)) {
    if ($comment = comment_load($matches[2])) {
      $uri = monster_menus_comment_uri($comment);
      if ($matches[1]) {
        $path = preg_replace('{^(mm/\d+/comment)(/\d+)}', '$1' . $matches[1] . '$2', $uri['path']) . $matches[3];
      }
      else {
        $path = $uri['path'] . $matches[3];
      }
    }
  }

//    debug_add("** from: $path");
  if (($arg0 = mm_parse_args($mmtids, $oarg_list, $this_mmtid, $path)) == 'mm') {
    if ($mmtids && $mmtids[0] == mm_home_mmtid()) {
      if (count($mmtids) == 1 && count($oarg_list)) {
        $_mm_custom_url_rewrite_outbound_cache[$cache_id] = $path;
        return;
      }
      array_shift($mmtids);
    }

    $test_path = "mm/$this_mmtid" . (isset($options['query']) && $options['query'] ? serialize($options['query']) : '');
    if (isset($_mm_custom_url_rewrite_outbound_cache[$test_path])) {
      $path = implode('/', array_merge(array($_mm_custom_url_rewrite_outbound_cache[$test_path]), $oarg_list));
      $_mm_custom_url_rewrite_outbound_cache[$cache_id] = $path;
      return;
    }

    $tree = mm_content_get($mmtids);

    foreach ($mmtids as $i => $mmtid) {
      foreach ($tree as $key => $item) {
        if ($item->mmtid == $mmtid) {
          if ($item->alias != '') {
            $mmtids[$i] = $item->alias;
          }
          unset($tree[$key]);
          break;
        }
      }
    }

    $path = implode('/', array_merge($mmtids, $oarg_list));

    mm_module_invoke_all_array('mm_url_rewrite_outbound', array($this_mmtid, &$path, &$options, $original_path));
  }
  elseif ($path != '') {
    $curr_page = _mm_menu_active_item();
    $link_page = _mm_menu_active_item($path);

    $mmtid = isset($curr_page->mmtid) && !is_null($curr_page->nid) ? $curr_page->mmtid : (isset($link_page->mmtid) ? $link_page->mmtid : NULL);
    if ($mmtid && !is_null($link_page->nid)) {
      $path = implode('/', array_merge(array('mm', $mmtid, $arg0), $oarg_list));
    }

    mm_module_invoke_all_array('mm_url_rewrite_outbound', array($mmtid, &$path, &$options, $original_path));

    if ($mmtid && $path != $original_path) {
      // $path and $options are already references, so no need to use &
      drupal_alter('url_outbound', $path, $options, $original_path);
    }
  }

  if (!empty($absolute)) {
    $path = $base_slash . $path;
  }

  // Don't use $cache_id here, since $options['query'] may have changed
  $_mm_custom_url_rewrite_outbound_cache[$original_path . ':' . (isset($options['query']) && $options['query'] ? serialize($options['query']) : '')] = $path;
//    debug_add("** to: $path ");
}

/**
 * Implements hook_entity_info_alter().
 */
function monster_menus_entity_info_alter(&$entity_info) {
  if (isset($entity_info['comment'])) {
    $entity_info['comment']['uri callback'] = 'monster_menus_comment_uri';
  }
}

function monster_menus_comment_uri($comment) {
  if (empty($comment->nid)) {
    // This comment is attached to something other than a node.
    return comment_uri($comment);
  }

  $out = array(
    'path' => "node/$comment->nid",
    'options' => array('fragment' => 'comment-' . $comment->cid),
  );
  $mmtids = mm_content_get_by_nid($comment->nid);
  if ($mmtids) {
    mm_parse_args($dummy, $dummy, $this_mmtid);
    if (!in_array($this_mmtid, $mmtids)) {
      $this_mmtid = $mmtids[0];
    }
    $out['path'] = "mm/$this_mmtid/comment/$comment->cid";
  }
  return $out;
}

/**
 * Implements hook_block_info().
 */
function monster_menus_block_info() {
  return mm_content_get_blocks();
}

/**
 * Implements hook_block_view().
 */
function monster_menus_block_view($delta = '') {
  $blocks = mm_content_get_blocks();
  mm_parse_args($mmtids, $oarg_list, $this_mmtid);
  $show_arr = mm_module_invoke_all('mm_menus_block_shown', $this_mmtid, $delta);
  if ($show_arr && array_product($show_arr) == 0) return;
  if (isset($blocks[$delta])) {
    $block['content'] = array();
    if (!$mmtids) $mmtids = array(mm_home_mmtid());

    // Search up the path, looking for the bottom-most block with an
    // entry in mm_tree_block.
    if ($starters = mm_content_get_blocks_at_mmtid($mmtids, $delta, TRUE)) {
      $starter = array_pop($starters);
      $start = $starter['mmtid'];

      $b = $blocks[$delta];
      if ($b['show_node_contents']) {
        $here = NULL;
      }
      else {
        $here = array($start);
        if (($i = array_search($start, $mmtids)) !== FALSE) {
          $here = array_slice($mmtids, $i);
        }
      }

      $params = array(
        MM_GET_TREE_ADD_TO_CACHE => TRUE,
        MM_GET_TREE_BLOCK => $delta,
        MM_GET_TREE_DEPTH => $starter['max_depth'],
        MM_GET_TREE_HERE => $here,
        MM_GET_TREE_PRUNE_PARENTS => TRUE,
        MM_GET_TREE_RETURN_NODE_COUNT => variable_get('mm_hide_empty_pages', FALSE),
        MM_GET_TREE_RETURN_PERMS => TRUE,
        MM_GET_TREE_SORT => TRUE,
      );
      $tree = mm_content_get_tree($start, $params);
      $can_edit = $tree[0]->perms[MM_PERMS_WRITE] || $tree[0]->perms[MM_PERMS_SUB] || $tree[0]->perms[MM_PERMS_APPLY];

      if ($b['title_is_cat']) $name = $tree[0]->name;

      if ($b['show_node_contents']) {
        $prev = $tree[0]->level;

        $block['content'] = array();
        foreach ($tree as $t) {
          if (!$t->perms[MM_PERMS_IS_RECYCLED]) {
            if ($t->level <= $prev) {
              array_splice($mmtids, $prev - $t->level - 1);
            }

            $mmtids[] = $t->mmtid;

            $block['content'][] = _mm_render_pages($mmtids, array(), $err, TRUE, $b['allow_rss'], $delta);
            $prev = $t->level;
          }
        }
      }
      else {
        $base = $b['title_is_cat'] ? 1 : 0;

        $parents = array('mm');
        if ($tree[$base]->parent != 1) {
          $parents[] = $tree[$base]->parent;
        }

        $content = mm_content_render_tree($tree, $base, $path, $parents);

        if ($content['body'] != '' || $b['title_is_cat'] && $can_edit) {
          $block['content'] = array(
            '#markup' => $content['prefix'] . $content['body'] . $content['suffix'],
          );
        }
      }

      if ($b['title_is_cat'] || $b['show_node_contents']) {
        $edit_links = array();
        $contextual = module_exists('contextual') && user_access('access contextual links');
        if ($can_edit) {
          $href = mm_content_get_mmtid_url($start);
          if ($contextual) {
            // The contextual menu code doesn't work out of the box with this
            // link, so hack it in monster_menus_contextual_links_view_alter().
            // This also lets us set a proper title.
            $edit_links['monster_menus-0'] = array(
              $href,
              array(),
              t('View this page'),
            );
            $edit_links['monster_menus-1'] = array(
              $href . '/settings/edit',
              array(),
              t('Page settings'),
            );
          }
          else {
            $edit_links[] = array(
              'title' => t('Edit'),
              'href' => $href . ($b['show_node_contents'] ? '' : '/settings/edit'),
            );
          }
        }

        foreach ($starters as $other) {
          if (($perms = mm_content_user_can($other['mmtid'])) && ($perms[MM_PERMS_WRITE] || $perms[MM_PERMS_SUB] || $perms[MM_PERMS_APPLY])) {
            $href = mm_content_get_mmtid_url($other['mmtid']) . ($b['show_node_contents'] ? '' : '/settings/edit');
            if ($contextual) {
              $edit_links['monster_menus-' . count($edit_links)] = array(
                $href,
                array(),
                $b['show_node_contents'] ? t('View hidden page') : t('Hidden page settings'),
              );
            }
            else {
              $edit_links[] = array(
                'title' => t('Edit hidden'),
                'href' => $href,
              );
            }
          }
        }

        if (count($edit_links)) {
          if ($contextual) {
            $block['content']['#contextual_links'] = $edit_links;
          }
          else {
            array_unshift($block['content'], array(
              '#theme' => 'links__mm_block_edit',
              '#prefix' => '<div class="link-wrapper">',
              '#suffix' => '</div>',
              '#attributes' => array('class' => array('links inline')),
              '#links' => $edit_links,
            ));
          }
        }
      }
    }

    $block['subject'] = isset($name) ? $name : (isset($b) && isset($b['title']) ? $b['title'] : '');
  }
  else {
    $block = array('content' => array(), 'subject' => '');
  }
  return $block;
}

/**
 * Implements hook_contextual_links_view_alter().
 */
function monster_menus_contextual_links_view_alter(&$element, $items) {
  // The contextual menu code doesn't work out of the box with our links, so
  // so hack it here. This also lets us set a proper title.
  foreach ($element['#contextual_links'] as $key => $entry) {
    if (!strncmp($key, 'monster_menus-', 14) && !isset($element['#links'][$key])) {
      $element['#links'][$key] = array(
        'title' => $entry[2],
        'href' => $entry[0],
      );
    }
  }
}

/**
 * Implements hook_cron().
 *
 * Updates the table containing all results of virtual group queries; flushes
 * any recycled content that has expired; updates the virtual user directory cache
 */
function monster_menus_cron() {
  // update any parts of the tree with dirty sort indices
  mm_content_update_sort(1, FALSE);

  // regenerate mm_virtual_group if needed
  mm_regenerate_vgroup();

  // Remove unneeded cache entries. This doesn't need to be done in the case
  // of memcache, since memcache does expiration automatically.
  db_delete('mm_access_cache')->condition('expire', REQUEST_TIME, '<')->execute();

  // Keep track of the average time between cron runs, so that we can tell the
  // user in mm_content_get_recycle_autodel_time() when recycling bins are likely to be
  // automatically emptied
  //
  // average_time_between_runs = (mm_cron_run_last - mm_cron_run_since) / mm_cron_run_count
  //      likely_next_cron_run = mm_cron_run_last + average_time_between_runs
  //
  variable_set('mm_cron_run_count', variable_get('mm_cron_run_count', -1) + 1);
  if (variable_get('mm_cron_run_since', 0) == 0)
      variable_set('mm_cron_run_since', REQUEST_TIME);
  variable_set('mm_cron_run_last', REQUEST_TIME);

  global $user;
  drupal_save_session(FALSE);  // in case of error, don't save session as wrong user
  $old_user = $user;
  $user = user_load(1);        // run as admin user
  mm_content_empty_all_bins(MM_CRON_EMPTY_BINS_LIMIT);
  // other tasks that must run as admin can be added here
  $user = $old_user;           // reset user from above
  drupal_save_session(TRUE);   // re-enable session saving

  // Clear out the group editing temp table
  // DELETE FROM {mm_group_temp} m WHERE
  //   (SELECT COUNT(*) = 0 FROM {sessions} s WHERE s.sid = m.sessionid)
  $count = db_select('sessions');
  $count->addExpression('COUNT(*) = 0');   // countQuery() won't work here
  $count->where('sid = {mm_group_temp}.sessionid');
  db_delete('mm_group_temp')
    ->condition($count)
    ->execute();

  // add any future tasks here, outside of admin user block
}

/**
 * Implements hook_page_alter().
 */
function monster_menus_page_alter(&$page) {
  // Unfortunately, we can't just add the footer content here, since it might
  // not be available yet. So add an element with a theme function that will
  // append the actual code later on.
  $page['page_bottom']['monster_menus'] = array('#theme' => 'mm_page_footer');

  // Add content not in the main region.
  mm_parse_args($mmtids, $oarg_list, $this_mmtid);
  if (($item = mm_content_get($this_mmtid)) && mm_content_user_can($item->mmtid, MM_PERMS_READ)) {
    $_mm_mmtid_of_node = &drupal_static('_mm_mmtid_of_node');

    $omit_nodes = '';
    $omit_node_types = mm_get_node_info(MM_NODE_INFO_NO_RENDER, $item);
    if ($omit_node_types) {
      $omit_nodes = " AND n.type NOT IN('" . join("', '", $omit_node_types) . "')";
    }

    $result = mm_content_get_accessible_nodes_by_mmtid($item->mmtid, 0, NULL, ', n.region', '', $omit_nodes . ' AND r.region IS NOT NULL');
    $nids = $scheduled = array();
    foreach ($result as $n) {
      $_mm_mmtid_of_node[$n->nid] = $item->mmtid;
      $scheduled[$n->nid] = !empty($n->scheduled);
      $nids[$n->region][] = $n->nid;
    }

    global $theme;
    $regions_on_page = system_region_list($theme, REGIONS_VISIBLE);

    foreach ($nids as $region => $n) {
      if (isset($regions_on_page[$region])) {
        $output = array();
        _mm_render_nodes($n, $scheduled, $item->previews ? 'teaser' : 'full', FALSE, $output, $rss_link);
        if ($output) {
          $page[$region]['wrapper'] = $output;
          $page[$region]['wrapper']['#prefix'] = '<div id="' . drupal_html_id("block-monster-menus-$region") . '" class="block block-monster-menus">';
          $page[$region]['wrapper']['#suffix'] = '</div>';
        }
      }
    }
  }
}

/**
 * Implements hook_exit().
 */
function monster_menus_exit($main = 0) {
  // Process any queued changes to the sort index
  mm_content_update_sort_queue();

  // Get the list of pages whose permissions or location in the tree have
  // changed and remove entries from mm_access_cache for all nodes appearing on
  // these pages and their children.
  $mmtids = _mm_content_clear_access_cache();
  if (!empty($mmtids)) {
    _mm_content_get_access_cache_object()->clearNidsByMmtid($mmtids);
  }
}

/**
 * Implements hook_user_delete().
 */
function monster_menus_user_delete($account) {
  foreach (mm_module_implements('mm_user_delete') as $module) {
    if (call_user_func_array($module . '_mm_user_delete', array(&$account))) return;
  }

  if ($account->user_mmtid) mm_content_move_to_disabled($account->user_mmtid);
  db_delete('mm_group')->condition('uid', $account->uid)->execute();
  db_delete('mm_virtual_group')->condition('uid', $account->uid)->execute();
  db_delete('mm_tree_bookmarks')->condition('uid', $account->uid)->execute();

  // Remove cached access rights.
  _mm_content_get_access_cache_object()->clearByUid($account->uid);

  // Regenerate "All logged-in users" virtual group during next cron.
  mm_mark_all_logged_in_vgroup_dirty();
}

/**
 * Implements hook_user_login().
 */
function monster_menus_user_login(&$edit, $account) {
  foreach (mm_module_implements('mm_user_login') as $module) {
    if (call_user_func_array($module . '_mm_user_login', array(&$edit, $account))) return;
  }

  // Make sure the user has a home directory, if applicable.
  mm_content_add_user($account);
}

/**
 * Implements hook_user_insert().
 */
function monster_menus_user_insert(&$edit, $account, $category) {
  foreach (mm_module_implements('mm_user_insert') as $module) {
    if (call_user_func_array($module . '_mm_user_insert', array(&$edit, $account, $category))) return;
  }

  // Make sure the user has a home directory, if applicable.
  mm_content_add_user($account);

  // Regenerate "All logged-in users" virtual group during next cron.
  mm_mark_all_logged_in_vgroup_dirty();
}

/**
 * Implements hook_user_update().
 */
function monster_menus_user_update(&$edit, $account, $category) {
  foreach (mm_module_implements('mm_user_update') as $module) {
    if (call_user_func_array($module . '_mm_user_update', array(&$edit, $account, $category))) return;
  }

  // Make sure the user has a home directory, if applicable.
  mm_content_add_user($account);
}

/**
 * Implements hook_user_load().
 */
function monster_menus_user_load($users) {
  // Note: $users is already a reference, so no need to use &$users above
  foreach (mm_module_implements('mm_user_load') as $module) {
    if (call_user_func_array($module . '_mm_user_load', array($users))) return;
  }

  global $user;
  foreach ($users as $uid => $account) {
    if ($uid > 0) {
      $home = mm_content_get(array('flags' => array('user_home' => $uid)));
      if (isset($home[0]) && is_object($home[0])) {
        $users[$uid]->user_mmtid = $home[0]->mmtid;
        if ($account->uid == $user->uid) $user->user_mmtid = $home[0]->mmtid;
      }
      mm_set_user_roles($users[$uid]);
    }
  }
}

/**
 * Implements hook_node_load().
 */
function monster_menus_node_load($nodes, $types) {
  $mmtids_to_load = array();
  $nids = array_keys($nodes);
  $mmtids_containing_node = mm_content_get_by_nid($nids);
  foreach ($nids as $nid) {
    $node = &$nodes[$nid];

    mm_node_all_nodes_hook('load', $node);

    if (isset($mmtids_containing_node[$nid])) {
      $mmtids_to_load = array_merge($mmtids_to_load, $mmtids_containing_node[$nid]);
    }

    $node->mm_catlist = array();
    $node->others_w = FALSE;
    $node->users_w = $node->groups_w = array();
    $node->recycle_bins = $node->recycle_from_mmtids = array();
  }

  $result = db_select('mm_node_write', 'w')
    ->fields('w', array('gid', 'nid'))
    ->condition('w.nid', $nids)
    ->execute();
  foreach ($result as $r) {
    if ($r->gid == 0) {
      $nodes[$r->nid]->others_w = TRUE;
    }
    elseif ($r->gid < 0) {
      $nodes[$r->nid]->users_w = array_fill_keys(mm_content_get_uids_in_group($r->gid), '');
    }
    else {
      $nodes[$r->nid]->groups_w[$r->gid] = '';
    }
  }

  $result = db_select('mm_recycle', 'r')
    ->fields('r')
    ->condition('r.type', 'node')
    ->condition('r.id', $nids)
    ->execute();
  foreach ($result as $r) {
    $node = &$nodes[$r->id];
    // Display the oldest recycle date to the user.
    if (!isset($node->recycle_date) || $r->recycle_date < $node->recycle_date) {
      $node->recycle_date = $r->recycle_date;
    }
    $node->recycle_bins[] = $r->bin_mmtid;
    $node->recycle_from_mmtids[] = $r->from_mmtid;
  }

  $result = db_select('mm_node_info', 'i')
    ->fields('i', array('show_node_info', 'comments_readable', 'nid'))
    ->condition('i.nid', $nids)
    ->execute();
  foreach ($result as $r) {
    $node = &$nodes[$r->nid];

    $node->show_node_info = $r->show_node_info;
    $node->comments_readable = $r->comments_readable;
  }

  $result = db_select('mm_node_schedule', 's')
    ->fields('s', array('publish_on', 'unpublish_on', 'set_change_date', 'nid'))
    ->condition('s.nid', $nids)
    ->execute();
  foreach ($result as $r) {
    $node = &$nodes[$r->nid];

    $node->publish_on = $r->publish_on;
    $node->unpublish_on = $r->unpublish_on;
    $node->set_change_date = $r->set_change_date;
  }

  // Fetch the names of all needed pages at once.
  $names = array();
  foreach (mm_content_get(array_unique($mmtids_to_load)) as $mm_tree) {
    $names[$mm_tree->mmtid] = mm_content_get_name($mm_tree);
  }

  // Cleanup
  foreach ($nids as $nid) {
    if (isset($nodes[$nid])) {
      $node = &$nodes[$nid];

      // Populate page list
      if (isset($mmtids_containing_node[$nid])) {
        foreach ($mmtids_containing_node[$nid] as $mmtid) {
          $node->mm_catlist[$mmtid] = isset($names[$mmtid]) ? $names[$mmtid] : t('Unknown');
        }
      }

      $node->recycle_bins = array_unique($node->recycle_bins);
      $node->recycle_from_mmtids = array_unique($node->recycle_from_mmtids);
    }
  }
}

/**
 * Implements hook_node_validate().
 */
function monster_menus_node_validate($node, $form, &$form_state) {
  mm_node_all_nodes_hook('validate', $node, $form, $form_state);

  if (!empty($node->mm_catlist) && is_array($node->mm_catlist) && count($node->mm_catlist)) {
    if (is_array($node->mm_catlist_restricted)) {
      $node->mm_catlist = array_diff_key($node->mm_catlist, array_flip($node->mm_catlist_restricted));
    }
    foreach ($node->mm_catlist as $mmtid => $name) {
      if (!$mmtid || !mm_content_user_can($mmtid, MM_PERMS_APPLY)) {
        form_set_error('mm_catlist', t('You are not allowed to assign content to the page %cat.', array('%cat' => $name)));
      }
      elseif (mm_content_is_archive($mmtid)) {
        form_set_error('mm_catlist', t('The page %cat is an archive of another page. Assign the content to the main page, and the archive will be updated automatically.', array('%cat' => $name)));
      }
    }
  }
  elseif (empty($node->mm_catlist_restricted)) {
    form_set_error('mm_catlist', t('You must assign this content to at least one page.'));
  }

  if (isset($node->owner) && user_access('administer all menus')) {
    _mm_ui_verify_userlist($node->owner, 'owner');
  }

  if (empty($node->mm_skip_perms)) {
    if (isset($node->groups_w) && is_array($node->groups_w)) {
      foreach ($node->groups_w as $gid => $name) {
        if ($gid && !mm_content_user_can($gid, MM_PERMS_APPLY)) {
          form_set_error('groups_w', t('You do not have permission to use the group %grp.', array('%grp' => $name)));
        }
      }
    }

    if (isset($node->users_w) && is_array($node->users_w)) {
      _mm_ui_verify_userlist($node->users_w, 'users_w');
    }
  }

  if (!empty($node->publish_on) && !empty($node->unpublish_on) && !is_array($node->publish_on) && !is_array($node->unpublish_on)) {
    $publish_on = strtotime($node->publish_on);
    $unpublish_on = strtotime($node->unpublish_on);
    if ($unpublish_on > 0 && $unpublish_on < $publish_on) {
      form_set_error('unpublish_on', t('You have chosen an unpublish date earlier than the publish date.'));
    }
  }
}

/**
 * Implements hook_node_presave().
 */
function monster_menus_node_presave($node) {
  mm_node_all_nodes_hook('presave', $node);

  if (user_access('administer all menus') && isset($node->owner) && ($account = user_load($node->owner))) {
    $node->uid = $account->uid;
    $node->name = $account->name;
  }

  if (isset($node->all_values_group)) {
    list($groups, $users,) = _mm_ui_form_parse_perms((array)$node, FALSE);
    $node->groups_w = array_flip(array_keys($groups));
    $node->users_w = array_flip(array_keys($users));
    $node->others_w = !empty($node->{'node-everyone'});
  }

  // Revert node_save()'s behavior, so that we can use it to update a node
  // without affecting its changed date.
  if (!empty($node->keep_changed_date) && !empty($node->original)) {
    $node->changed = $node->original->changed;
  }
}

/**
 * Implements hook_node_access().
 */
function monster_menus_node_access($node, $op, $account) {
  $return = mm_node_all_nodes_hook('access', $node, $op, $account);
  if (is_object($node) && $node->nid) {
    $return[] = mm_content_node_access($node, $op, $account) ? NODE_ACCESS_ALLOW : NODE_ACCESS_DENY;
  }

  if (is_array($return)) {
    if (in_array(NODE_ACCESS_DENY, $return, TRUE)) {
      return NODE_ACCESS_DENY;
    }
    elseif (in_array(NODE_ACCESS_ALLOW, $return, TRUE)) {
      return NODE_ACCESS_ALLOW;
    }
  }
}

/**
 * Implements hook_node_update().
 */
function monster_menus_node_update($node) {
  mm_node_all_nodes_hook('update', $node);

  if (!mm_content_node_is_recycled($node)) {
    if (!isset($node->mm_catlist_restricted)) {
      $node->mm_catlist_restricted = array();
    }

    $list = array_merge(array_keys($node->mm_catlist), $node->mm_catlist_restricted);
    if ($list) {
      db_delete('mm_node_reorder')
        ->condition('nid', $node->nid)
        ->condition('mmtid', $list, 'NOT IN')
        ->execute();
    }
    else {
      db_delete('mm_node_reorder')
        ->condition('nid', $node->nid)
        ->execute();
    }
  }

  _monster_menus_node_update_or_insert($node, FALSE);
}

/**
 * Implements hook_node_insert().
 */
function monster_menus_node_insert($node) {
  mm_node_all_nodes_hook('insert', $node);
  _monster_menus_node_update_or_insert($node, TRUE);
}

function _monster_menus_node_update_or_insert($node, $insert) {
  if (!$insert) {
    $old_node = node_load($node->nid);
    if ($old_node && empty($old_node->mm_catlist_restricted)) {
      $old_node->mm_catlist_restricted = array();
    }
    $old_catlist = array_unique(array_merge(array_keys($old_node->mm_catlist), $old_node->mm_catlist_restricted));
    sort($old_catlist);
  }

  if (!mm_content_node_is_recycled($node)) {
    if (empty($node->mm_catlist)) {
      $node->mm_catlist = array();
    }

    if (empty($node->mm_catlist_restricted)) {
      $node->mm_catlist_restricted = array();
    }

    $node->mm_catlist = array_diff_key($node->mm_catlist, array_flip($node->mm_catlist_restricted));
    $new_catlist = array_merge(array_keys($node->mm_catlist), $node->mm_catlist_restricted);
    sort($new_catlist);

    if (empty($old_catlist) || $new_catlist != $old_catlist) {
      if (!$insert) {
        db_delete('mm_node2tree')
          ->condition('nid', $node->nid)
          ->execute();
      }

      if ($new_catlist) {
        $insert = db_insert('mm_node2tree')
          ->fields(array('nid', 'mmtid'));
        foreach ($new_catlist as $mmtid) {
          $insert->values(array(
            'nid' => $node->nid,
            'mmtid' => $mmtid,
          ));
        }
        $insert->execute();
      }
    }

    if ($insert && $new_catlist) {
      $default_regions = variable_get('mm_default_region', array());
      if (isset($default_regions[$node->type]) && $default_regions[$node->type] != MM_UI_REGION_CONTENT) {
        $insert = db_insert('mm_node_reorder')
          ->fields(array('nid', 'mmtid', 'weight', 'region'));
        foreach ($new_catlist as $mmtid) {
          $insert->values(array(
            'nid' => $node->nid,
            'mmtid' => $mmtid,
            'weight' => 0,
            'region' => $default_regions[$node->type],
          ));
        }
        $insert->execute();
      }
    }
  }

  mm_content_set_node_perms($node);

  if (empty($node->show_node_info)) {
    $node->show_node_info = FALSE;
  }
  if (empty($node->comments_readable)) {
    $node->comments_readable = FALSE;
  }

  db_merge('mm_node_info')
    ->key(array('nid' => $node->nid))
    ->fields(array(
      'show_node_info' => intval($node->show_node_info),
      'comments_readable' => $node->comments_readable,
    ))
    ->execute();

  if (empty($node->publish_on) || is_array($node->publish_on)) {
    $node->publish_on = 0;
  }
  else {
    if (!is_numeric($node->publish_on)) {
      $node->publish_on = strtotime($node->publish_on);
    }
    if ($node->publish_on <= 0) {
      $node->publish_on = 0;
    }
  }

  if (empty($node->unpublish_on) || is_array($node->unpublish_on)) {
    $node->unpublish_on = 0;
  }
  else {
    if (!is_numeric($node->unpublish_on)) {
      $node->unpublish_on = strtotime($node->unpublish_on);
    }
    if ($node->unpublish_on <= 0) {
      $node->unpublish_on = 0;
    }
  }

  if (empty($node->set_change_date)) {
    $node->set_change_date = 0;
  }

  if ($node->publish_on || $node->unpublish_on || $node->set_change_date) {
    db_merge('mm_node_schedule')
      ->key(array('nid' => $node->nid))
      ->fields(array(
        'publish_on' => $node->publish_on,
        'unpublish_on' => $node->unpublish_on,
        'set_change_date' => $node->set_change_date,
      ))
      ->execute();
  }
  elseif (!$insert) {
    db_delete('mm_node_schedule')
      ->condition('nid', $node->nid)
      ->execute();
  }

  $clone = clone $node;
  if (!empty($old_catlist)) {
    $clone->old_catlist = $old_catlist;
  }
  mm_content_notify_change($insert ? 'insert_node' : 'update_node', NULL, $clone->nid, array($clone->nid => $clone));
}

/**
 * Implements hook_node_revision_delete().
 */
function monster_menus_node_revision_delete($node) {
  mm_node_all_nodes_hook('revision_delete', $node);

  // Remove cached access rights.
  _mm_content_get_access_cache_object()->clearByNid($node->nid);
}

/**
 * Implements hook_node_delete().
 */
function monster_menus_node_delete($node) {
  mm_node_all_nodes_hook('delete', $node);

  db_delete('mm_node2tree')
    ->condition('nid', $node->nid)
    ->execute();
  db_delete('mm_node_reorder')
    ->condition('nid', $node->nid)
    ->execute();
  db_delete('mm_recycle')
    ->condition('type', 'node')
    ->condition('id', $node->nid)
    ->execute();
  db_delete('mm_node_info')
    ->condition('nid', $node->nid)
    ->execute();
  db_delete('mm_node_schedule')
    ->condition('nid', $node->nid)
    ->execute();
  _mm_ui_delete_node_groups($node, TRUE);
  if (isset($node->recycle_bins) && is_array($node->recycle_bins)) {
    foreach ($node->recycle_bins as $bin) {
      mm_content_clear_caches($bin);
      mm_content_delete_bin($bin);
    }
  }
  mm_content_notify_change('delete_node', NULL, $node->nid, array($node->nid => $node));
}

/**
 * Implements hook_node_type_insert().
 */
function monster_menus_node_type_insert($content_type) {
  mm_node_all_nodes_hook('node_type_insert', $content_type);
}

/**
 * Implements hook_preprocess_username().
 *
 * @param $variables
 *   An associative array containing:
 *   - account: The user object to format.
 *   - name: The user's name, sanitized.
 *   - extra: Additional text to append to the user's name, sanitized.
 *   - link_path: The path or URL of the user's profile page, home page, or
 *     other desired page to link to for more information about the user.
 *   - link_options: An array of options to pass to the l() function's $options
 *     parameter if linking the user's name to the user's page.
 *   - attributes_array: An array of attributes to pass to the
 *     drupal_attributes() function if not linking to the user's page.
 */
function monster_menus_preprocess_username(&$variables) {
  $account = $variables['account'];
  $uid = isset($account->uid) ? $account->uid : 0;
  $name = isset($account->name) ? $account->name : '';

  if (!empty($uid) && !empty($name) && user_access('access user profiles')) {
    $variables['name'] = mm_content_uid2name($uid, 'fml', NULL, $hover);
    if (!empty($hover)) {
      $variables['link_attributes']['title'] = $hover;
    }
  }
}

/**
 * Implements hook_library().
 */
function monster_menus_library() {
  $mm_basepath = drupal_get_path('module', 'monster_menus');
  $libraries['mm'] = array(
    'title' => 'MM',
    'website' => 'http://drupal.org/node/1118296',
    'version' => '1.0',
    'js' => array(
       "$mm_basepath/js/mm.js" => array(
        'scope' => 'header',
      ),
    ),
    'css' => array(
      "$mm_basepath/css/mm.css" => array(),
    ),
  );
  $libraries['mm_browser'] = array(
    'title' => 'MM Browser',
    'website' => 'http://drupal.org/node/1118296',
    'version' => '1.0',
    'js' => array(
      "$mm_basepath/js/mm_browser.js" => array(),
    ),
    'css' => array(
      "$mm_basepath/css/mm_browser.css" => array(),
    ),
  );
  // Used by mm_browser.inc
  $libraries['jsTree'] = array(
    'title' => 'jsTree',
    'website' => 'http://www.jstree.com/',
    'version' => '1.0-rc1',
    'js' => array(
      "$mm_basepath/libraries/jsTree/jquery.jstree.js" => array(),
    ),
    'css' => array(
      "$mm_basepath/libraries/jsTree/source/tree_component.css" => array(),
    ),
  );
  // Used by mm_browser.inc
  $libraries['fg.menu'] = array(
    'title' => 'fg.menu',
    'website' => 'http://www.filamentgroup.com/lab/jquery_ipod_style_and_flyout_menus/',
    'version' => '3.0',
    'js' => array(
      "$mm_basepath/libraries/fg.menu.js" => array(),
    ),
    'css' => array(
      "$mm_basepath/libraries/fg.menu.css" => array(),
    ),
    'dependencies' => array(
      array('system', 'ui'),
    ),
  );
  $libraries['splitter'] = array(
    'title' => 'Splitter',
    'website' => 'http://methvin.com/splitter/',
    'version' => '1.5.1',
    'js' => array(
      "$mm_basepath/libraries/splitter.js" => array(),
    ),
    'dependencies' => array(
      array('system', 'jquery.cookie'),
    ),
  );
  $libraries['dataTables'] = array(
    'title' => 'Data Tables',
    'website' => 'http://www.datatables.net/',
    'version' => '1.7.4',
    'js' => array(
      "$mm_basepath/libraries/jquery.dataTables.min.js" => array(),
    ),
  );
  $libraries['xregexp'] = array(
    'title' => 'XRegExp',
    'website' => 'http://xregexp.com',
    'version' => '1.5.0',
    'js' => array(
      "$mm_basepath/libraries/xregexp.js" => array(),
    ),
  );

  return $libraries;
}

/**
 * Implements hook_token_info().
 */
function monster_menus_token_info() {
  $tokens = array();

  $type = array(
    'name' => t('MM Tree'),
    'description' => t('Tokens related to the Monster Menus tree.'),
    'needs-data' => 'mm_tree',
  );

  // Unfortunately, drupal_get_schema() strips the field descriptions.
  module_load_include('install', 'monster_menus');
  $schema = module_invoke('monster_menus', 'schema');
  foreach ($schema['mm_tree']['fields'] as $name => $field) {
    if (isset($field['description'])) {
      $tokens[$name] = array(
        'name' => $name,
        'description' => $field['description'],
      );
    }
  }

  $predefined = mm_ui_flags_info();
  $predef_flags = array();
  foreach ($predefined as $module => $flags) {
    foreach ($flags as $name => $info) {
      $predef_flags[] = $name;
      $tokens["flag:$name"] = array(
        'name' => t('MM flag !name from module !module', array('!name' => $name, '!module' => $module)),
        'description' => $info['#description'],
      );
    }
  }
  $result = db_query('SELECT DISTINCT flag FROM {mm_tree_flags}');
  foreach ($result as $r) {
    if (!in_array($r->flag, $predef_flags)) {
      $tokens['flag:' . $r->flag] = array(
        'name' => t('MM flag !name', array('!name' => $r->flag)),
        'description' => t('Monster Menus flag'),
      );
    }
  }

  return array(
    'types' => array('mm_tree' => $type),
    'tokens' => array('mm_tree' => $tokens),
  );
}

/**
 * Implements hook_tokens().
 */
function monster_menus_tokens($type, $tokens, $data = NULL, $options = array()) {
  $replacements = array();
  if ($type == 'mm_tree' && isset($data['mm_tree'])) {
    $tree = $data['mm_tree'];

    foreach ($tokens as $name => $raw) {
      if (isset($tree->$name)) {
        $replacements[$raw] = $tree->$name;
      }
    }

    if (is_array($tree->flags) && ($flags_tokens = token_find_with_prefix($tokens, 'flag'))) {
      foreach ($flags_tokens as $flag => $raw) {
        if (isset($tree->flags[$flag])) {
          // Convert empty flags to boolean TRUE
          $replacements[$raw] = empty($tree->flags[$flag]) ? TRUE : $tree->flags[$flag];
        }
        else {
          $replacements[$raw] = FALSE;
        }
      }
    }
  }
  return $replacements;
}

/**
 * Implements hook_mail().
 */
function monster_menus_mail($key, &$message, $params) {
  $langcode = $message['language']->language;
  switch ($key) {
    case 'mm_regenerate_vgroup':
      $message['subject'] = t('Error in virtual group regeneration', array(), array('langcode' => $langcode));
      $message['body'] = $params['errors'];
      $message['body'][] = t('To ignore the errors and regenerate the data in all of the listed virtual groups, execute this SQL code:', array(), array('langcode' => $langcode));
      $message['body'][] = 'UPDATE mm_vgroup_query SET dirty=' . MM_VGROUP_DIRTY_REDO . ' WHERE vgid IN(' . $params['in'] . ')';
  }
}
