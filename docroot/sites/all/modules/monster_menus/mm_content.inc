<?php

/**
 * @file
 * Functions related to the retrieval of data for monster menus
 */

/**
 * Render an entry and its children as HTML
 *
 * @param $tree
 *   Array of tree nodes, as generated by mm_get_tree
 * @param &$i
 *   Optional starting index
 * @param &$path
 *   Optional menu array, suitable to be passed to menu_set_location()
 * @param &$parents
 *   Optional array containing the full GET path of the current item. Used
 *   internally.
 * @param $depth
 *   Depth to display; set to -1 to show all levels
 * @param $renderer
 *   mmRenderer (or subclass) to use in rendering the HTML. If omitted,
 *   uses theme('mm_get_renderer') which, by default, produces a simple menu
 *   tree.
 * @return
 *   An array of HTML code elements:
 *    - 'prefix': the prefix for the items, such as <ul>
 *    - 'body': the items, such as <li>...</li>
 *    - 'suffix': the suffix for the items, such as </ul>
 */
function mm_content_render_tree($tree, &$i = 0, &$path = NULL, &$parents = array('mm'), $depth = -1, $renderer = NULL) {
  if ($i >= count($tree)) {
    return;
  }

  if (!isset($renderer)) {
    $renderer = theme('mm_get_renderer');
  }
  $renderer->preprocess($tree);

  $body = '';
  $lev0 = $tree[$i]->level;
  while ($i < count($tree) && $tree[$i]->level == $lev0) {
    $leaf = $tree[$i];
    $name = mm_content_get_name($leaf);

    if (!$renderer->is_visible($leaf) ||
        $name[0] == '.' && !(isset($leaf->perms) ?
        $leaf->perms[MM_PERMS_READ] : mm_content_user_can($leaf->mmtid, MM_PERMS_READ))) {
      while (++$i < count($tree) && $tree[$i]->level > $lev0) ; // skip kids
      continue;   // get next sibling
    }

    $item = array('title' => $name);
    if (!empty($leaf->hover)) {
      $item['description'] = $leaf->hover;
    }
    $link_item = array('path' => implode('/', $parents) . '/' . $leaf->mmtid);
    if (is_array($path) && $leaf->state & MM_GET_TREE_STATE_EXPANDED) {
      $path[] = array(
        'path' => $link_item['path'],
        'title' => $name);
    }

    $body .= $renderer->prefix_leaf($leaf, $item, $link_item) . $renderer->link_leaf($leaf, $item, $link_item);

    while (++$i < count($tree) && $tree[$i]->level > $lev0) {
      if ($tree[$i]->level == $lev0 + 1 && ($depth || $leaf->state & MM_GET_TREE_STATE_EXPANDED)) {
        $parents[] = $leaf->mmtid;
        $cur_leaf = $tree[$i];
        $child = mm_content_render_tree($tree, $i, $path, $parents, 0, $renderer);
        $body .= $renderer->prefix_parent($cur_leaf, $item, $link_item) .
            $child['body'] .
            $renderer->suffix_parent($cur_leaf, $item, $link_item);
        array_pop($parents);
        $i--;
      }
    }

    $body .= $renderer->suffix_leaf($leaf, $item, $link_item);
  }

  return array(
    'prefix' => $renderer->prefix_all(),
    'body'   => $body,
    'suffix' => $renderer->suffix_all(),
  );
}

/**
 * Return a nicer version of entry names starting with '.'
 *
 * @param $name
 *   The entry name, obtained from mm_content_get_tree
 * @return
 *   The nicer version
 */
function mm_content_expand_name($name) {
  static $drupal_static_fast;
  if (!isset($drupal_static_fast)) {
    // This is cumbersome, but assigning to an array is the only way that works.
    $drupal_static_fast['aliases'] = &drupal_static(__FUNCTION__);
    $drupal_static_fast['aliases'] = array(
      MM_ENTRY_NAME_DEFAULT_USER  => t('[New account defaults]'),
      MM_ENTRY_NAME_DISABLED_USER => t('[Disabled accounts]'),
      MM_ENTRY_NAME_GROUPS        => t('Permission groups'),
      MM_ENTRY_NAME_RECYCLE       => t('[Recycle bin]'),
      MM_ENTRY_NAME_USERS         => t('User list'),
      MM_ENTRY_NAME_VIRTUAL_GROUP => t('[Pre-defined groups]'),
    );
    $drupal_static_fast['aliases'] += mm_module_invoke_all('mm_item_name');
  }

  $aliases = &$drupal_static_fast['aliases'];
  if (isset($aliases[$name])) {
    if (is_array($aliases[$name])) {
      if (isset($aliases[$name]['callback']) && function_exists($aliases[$name]['callback'])) {
        $result = call_user_func($aliases[$name]['callback'], $name);
        if (!empty($result)) {
          return $result;
        }
      }
      if (!empty($aliases[$name]['name'])) {
        return $aliases[$name]['name'];
      }
    }
    else {
      return $aliases[$name];
    }
  }

  return $name;
}

/**
 * Class used with mm_content_get_tree to take an action as each node is found.
 * IMPORTANT: Do not depend on $item->state in iterate(). It is not correct.
 */
class getTreeIterator {
  private $parent_is_group, $parent_is_user;

  public function iterate($item) {
    // function must return 1 if no error, 0 if error, -1 if this node
    // and any of its children should be skipped
    return 1;
  }
}

/**
 * Traverse the tree
 *
 * @param $mmtid (1)
 *   Starting tree ID
 * @param $params
 *   An array containing parameters. The array is indexed using the constants
 *   below.
 *   - MM_GET_TREE_ADD_SELECT (none):
 *     A string or array of strings to add to the SELECT portion of the query
 *   - MM_GET_TREE_ADD_TO_CACHE (FALSE):
 *     Add results to the caches used by mm_content_get() and
 *     mm_content_get_parents()
 *   - MM_GET_TREE_BIAS_ANON (TRUE):
 *     If TRUE, assume user 0 can't read any groups (more secure)
 *   - MM_GET_TREE_BLOCK (0):
 *     Only retrieve entries that are part of one block. Defaults to all blocks.
 *   - MM_GET_TREE_DEPTH (-1):
 *     When 'mmtid' is used, a query to return all items in the tree below that
 *     point can be returned. This field specifies the depth of recursion:
 *     - 0:  just the item specified by $mmtid
 *     - -1: all levels
 *     - 1:  the item and its immediate children
 *     - N:  any other other number will return that many levels (can be slow)
 *   - MM_GET_TREE_FAKE_READ_BINS (FALSE):
 *     Pretend the user can read all recycle bins (used internally)
 *   - MM_GET_TREE_FILTER_BINS (TRUE):
 *     Get entries that are recycle bins
 *   - MM_GET_TREE_FILTER_DOTS (TRUE):
 *     Get all entries with names that start with '.'. If FALSE, only .Groups,
 *     .Users, and .Virtual are returned.
 *   - MM_GET_TREE_FILTER_GROUPS (TRUE):
 *     Get entries that are groups
 *   - MM_GET_TREE_FILTER_HIDDEN (FALSE):
 *     If TRUE, return entries with the "hidden" attribute set, even if the
 *     current user does not normally have permission to view them
 *   - MM_GET_TREE_FILTER_NORMAL (TRUE):
 *     Get entries that are neither groups nor in /users
 *   - MM_GET_TREE_FILTER_USERS (TRUE):
 *     Get entries in /users
 *   - MM_GET_TREE_HERE (none)
 *     An array of MM Tree IDs currently being viewed by the user. Parent
 *     entries will have their their state set to MM_GET_TREE_STATE_EXPANDED.
 *   - MM_GET_TREE_ITERATOR (none):
 *     getTreeIterator (or subclass) to call as each new item is found.
 *     When this option is used, memory is conserved by not returning anything.
 *   - MM_GET_TREE_PRUNE_PARENTS (FALSE):
 *     If TRUE, prune parents, depending upon max_parents in the block
 *   - MM_GET_TREE_RETURN_BINS (FALSE):
 *     A comma-separated list of the mmtids of any parent recycle bins
 *   - MM_GET_TREE_RETURN_BLOCK (FALSE):
 *     Attributes from the mm_tree_block table
 *   - MM_GET_TREE_RETURN_FLAGS (FALSE):
 *     Flags from the mm_tree_flags table
 *   - MM_GET_TREE_RETURN_KID_COUNT (FALSE):
 *     A count of the number of children each tree entry has
 *   - MM_GET_TREE_RETURN_MTIME (FALSE):
 *     The muid (user ID who made the last modification) and mtime (time) of the
 *     modification
 *   - MM_GET_TREE_RETURN_NODE_COUNT (FALSE):
 *     If TRUE, return a count of the number of nodes assigned to each item. If
 *     a string or array of strings, return a count of the number of nodes of
 *     that type.
 *   - MM_GET_TREE_RETURN_PERMS (none):
 *     If set, return whether or not the user can perform that action
 *     (MM_PERMS_READ, MM_PERMS_WRITE, MM_PERMS_SUB, MM_PERMS_APPLY,
 *     MM_PERMS_IS_USER, MM_PERMS_IS_GROUP, MM_PERMS_IS_RECYCLE_BIN,
 *     MM_PERMS_IS_RECYCLED). The requested permission can either be a single
 *     value or an array. If an empty array or TRUE is passed, all permissions
 *     are returned.
 *   - MM_GET_TREE_SORT (FALSE):
 *     If TRUE, sort the entries according to sort_idx; always TRUE when
 *     MM_GET_TREE_DEPTH != 0
 *   - MM_GET_TREE_USER (current user):
 *     User object to test permissions against
 *   - MM_GET_TREE_VIRTUAL (TRUE):
 *     Include virtual user list sub-entries
 *   - MM_GET_TREE_WHERE (none):
 *     Add a WHERE clause to the outermost query
 *   If none of ([...USERS], [...GROUPS], [...NORMAL]) is TRUE, all types are
 *   retrieved. MM_GET_TREE_RETURN_TREE is always TRUE.
 * @return
 *   Array of tree entries, unless MM_GET_TREE_ITERATOR is used
 */
function mm_content_get_tree($mmtid = 1, $params = NULL) {
  global $user;

  $defaults = array(
    MM_GET_TREE_BLOCK =>         0,
    MM_GET_TREE_DEPTH =>         -1,
    MM_GET_TREE_FILTER_BINS =>   TRUE,
    MM_GET_TREE_FILTER_DOTS =>   TRUE,
    MM_GET_TREE_FILTER_GROUPS => FALSE,
    MM_GET_TREE_FILTER_HIDDEN => FALSE,
    MM_GET_TREE_FILTER_NORMAL => FALSE,
    MM_GET_TREE_FILTER_USERS =>  FALSE,
    MM_GET_TREE_HERE =>          NULL,
    MM_GET_TREE_ITERATOR =>      NULL,
    MM_GET_TREE_PRUNE_PARENTS => FALSE,
    MM_GET_TREE_SORT =>          FALSE,
    MM_GET_TREE_USER =>          $user,
    MM_GET_TREE_VIRTUAL =>       TRUE,
    'found' =>                   -1,
    'level' =>                   0,
    'parent_level' =>            -1,
    'pprune' =>                  -1,
    'q' =>                       NULL,
  );

  if (!is_array($params)) {
    $params = array();
  }
  $params = array_merge($defaults, $params);

  if (empty($params[MM_GET_TREE_FILTER_GROUPS]) && empty($params[MM_GET_TREE_FILTER_USERS]) && empty($params[MM_GET_TREE_FILTER_NORMAL])) {
    $params[MM_GET_TREE_FILTER_GROUPS] = $params[MM_GET_TREE_FILTER_USERS] = $params[MM_GET_TREE_FILTER_NORMAL] = TRUE;
  }

  if ($params[MM_GET_TREE_VIRTUAL] && !variable_get('mm_use_virtual_user_dir', TRUE)) {
    $params[MM_GET_TREE_VIRTUAL] = FALSE;
  }

  if (!empty($params[MM_GET_TREE_SORT]) || $params[MM_GET_TREE_DEPTH] != 0) {
    mm_content_update_sort_queue();
  }

  if (!class_exists('getTreeResults')) {
    /**
     * Class used internally, to provide the ability to store the most recent
     * result and re-retrieve it later.
     */
    class getTreeResults {
      private $query_obj, $prev, $backed;
      public $start_level, $level_offset;

      public function __construct($query) {
        $this->query_obj = db_query($query);
      }

      public function next() {
        if (!empty($this->backed)) {
          $this->backed = FALSE;
          return $this->prev;
        }
        return $this->prev = $this->query_obj->fetchObject();
      }

      public function back() {
        $this->backed = TRUE;
      }
    }
  }

  return _mm_content_get_tree($mmtid, $params);
}

function _mm_content_get_tree($mmtid, &$params) {
  $users_mmtid = mm_content_users_mmtid();

  $have_virtual = FALSE;
  if (empty($params['q'])) {
    $params['q'] = _mm_content_get_tree_query($mmtid, $params);
    if (is_array($params[MM_GET_TREE_HERE])) {
      foreach ($params[MM_GET_TREE_HERE] as $i => $h) {
        if ($h < 0) {
          unset($params[MM_GET_TREE_HERE][$i]);
          $have_virtual = TRUE;
          if ($params[MM_GET_TREE_DEPTH] > 0) {
            $params[MM_GET_TREE_DEPTH]--;
          }
          break;
        }
        elseif ($params[MM_GET_TREE_VIRTUAL] && $h == $users_mmtid && $params[MM_GET_TREE_DEPTH]) {
          $have_virtual = TRUE;
        }
      }
    }
  }

  $rows = array();

  while ($r = $params['q']->next()) {
    if (!isset($params['q']->start_level)) {
      $params['q']->start_level = strlen($r->sort_idx) / MM_CONTENT_BTOA_CHARS;
    }
    $r->level = strlen($r->sort_idx) / MM_CONTENT_BTOA_CHARS - $params['q']->start_level + $params['q']->level_offset;

    if ($r->level <= $params['parent_level']) {
      $params['q']->back();
      break;
    }
    elseif ($r->level > $params['parent_level']) {
      if (!isset($r->bid) || is_null($r->bid)) {
        $r->bid = 0;
        $r->max_depth = $r->max_parents = -1;
      }
      $add = _mm_content_get_tree_recurs($r, $params, isset($r->{MM_PERMS_IS_GROUP}) ? $r->{MM_PERMS_IS_GROUP} : FALSE, isset($r->{MM_PERMS_IS_USER}) ? $r->{MM_PERMS_IS_USER} : FALSE, $last);
    }

    if (is_array($rows) && !empty($add) && is_array($add)) {
      $rows = array_merge($rows, $add);
      unset($add);   // save some memory
    }

    if (!empty($last)) {
      break;
    }
  }

  if ($params['pprune'] > 0 && $params['found']) {
    $params['pprune']--;
  }

  if (isset($params[MM_GET_TREE_ITERATOR])) {
    return NULL;
  }

  if (!$params['level'] && ($have_virtual || $mmtid == $users_mmtid) && $params[MM_GET_TREE_DEPTH]) {
    if ($params[MM_GET_TREE_VIRTUAL]) {
      $select = db_select('mm_tree', 't');
      $select->addExpression('GROUP_CONCAT(DISTINCT UCASE(SUBSTR(t.name, 1, 1)) ORDER BY t.name SEPARATOR \'\')', 'letters');
      $select->condition('t.parent', $users_mmtid);
      $letters = $select->execute()->fetchField();
      $letters = preg_replace('/[\W_]/', '', $letters, -1, $matches);
      if ($matches) $letters = "~$letters";
      $letters = str_split($letters);
      $parent = NULL;

      for ($i = 0; $i < count($rows); $i++) {
        if ($rows[$i]->mmtid == $users_mmtid) {
          $parent = $rows[$remainder = $i];
          $parent->state &= ~MM_GET_TREE_STATE_HERE;
          $last = 0;

          while (++$i < count($rows) && $rows[$i]->level > $parent->level) {
            if ($rows[$i]->level == $parent->level + 1) {
              $letr = drupal_strtoupper($rows[$i]->name[0]);
              $name = ctype_alpha($letr) ? $letr : t('(other)');
              if (!$last || $name != $rows[$last]->name) {
                $alias = ctype_alpha($letr) ? $letr : '~';
                while ($letters) {
                  $add = array_shift($letters);
                  $new = _mm_content_virtual_dir(-ord($add), $parent->mmtid, $parent->level + 1, $add == $alias ? MM_GET_TREE_STATE_EXPANDED|MM_GET_TREE_STATE_HERE : MM_GET_TREE_STATE_COLLAPSED);
                  $new->default_mode = $parent->default_mode;
                  array_splice($rows, $last = $i++, 0, array($new));  // insert virtual dir
                  $remainder++;
                  if ($add == $alias) {
                    break;
                  }
                }
              }

              $rows[$i]->parent = $rows[$last]->mmtid;
              if ($rows[$i]->state & MM_GET_TREE_STATE_EXPANDED) {
                $rows[$last]->state = MM_GET_TREE_STATE_EXPANDED;
              }
            }     // if
            $remainder++;

            $rows[$i]->level++;
          }       // while
          break;  // exit outer for loop
        }         // if
      }           // for
    }

    if (!user_access('administer all users', $params[MM_GET_TREE_USER])) {
      $hidden_names = variable_get('mm_hidden_user_names', array());
      $dels = array();
      foreach ($rows as $i => $r) {
        if ($r->alias == '~') {
          $other = $i;
        }
        elseif ($r->parent == -126 || $r->parent == $users_mmtid) {  // -126 = -ord('~')
          if (in_array($r->name, $hidden_names)) {
            $dels[] = $i;
          }
          else {
            unset($other);
          }
        }
      }

      if (isset($other)) {
        // All 'other' rows are invisible to the user
        array_unshift($dels, $other);
      }

      foreach (array_reverse($dels) as $i) {
        array_splice($rows, $i, 1);
      }
    }

    if ($params[MM_GET_TREE_VIRTUAL]) {
      $i = $parent ? $remainder + 1 : count($rows);
      foreach ($letters as $add) {
        $new = _mm_content_virtual_dir(-ord($add), $users_mmtid, $parent ? $parent->level + 1 : 0, MM_GET_TREE_STATE_COLLAPSED);
        if ($parent) {
          $new->default_mode = $parent->default_mode;
        }
        array_splice($rows, $i++, 0, array($new));  // insert virtual dir
      }
    }
  }

// if( !$params['level'] ) debug_add_dump( $rows );
  return $rows;
}

/**
 * Helper function for _mm_content_get_tree()/mm_content_get()
 */
function _mm_content_split_flags($flags) {
  if (is_array($flags)) {
    return $flags;
  }
  preg_match_all('/(?:(.*?)\|1(.*?)(?:\|2|$))/', $flags, $matches);
  return $matches[0] ? array_combine($matches[1], $matches[2]) : array();
}

/**
 * Helper function for _mm_content_get_tree()
 */
function _mm_content_get_tree_query($mmtid, $params) {
  $params[MM_GET_TREE_RETURN_TREE] = TRUE;
  if (isset($params[MM_GET_TREE_BLOCK]) && $params[MM_GET_TREE_BLOCK] != 0) {
    $params[MM_GET_TREE_RETURN_BLOCK] = TRUE;
  }

  if (!is_array($params[MM_GET_TREE_HERE])) {
    $params[MM_GET_TREE_HERE] = array($mmtid);
  }
  elseif (!count($params[MM_GET_TREE_HERE])) {
    $params[MM_GET_TREE_HERE][] = $mmtid;
  }
  elseif ($params[MM_GET_TREE_DEPTH] != 0) {
    $params[MM_GET_TREE_DEPTH] = 1;
  }

  $query = array();
  $max = count($params[MM_GET_TREE_HERE]) - 1;
  $users_mmtid = $params[MM_GET_TREE_VIRTUAL] ? mm_content_users_mmtid() : -1;
  if (isset($params[MM_GET_TREE_RETURN_PERMS])) {
    if (!isset($params[MM_GET_TREE_ITERATOR])) {
      $params[MM_GET_TREE_RETURN_BINS] = TRUE;
      $params[MM_GET_TREE_FAKE_READ_BINS] = TRUE;
    }
  }
  else {
    $params[MM_GET_TREE_RETURN_PERMS] = array(MM_PERMS_IS_GROUP, MM_PERMS_IS_USER);
  }

  for ($i = 0; $i <= $max; $i++) {
    $mmtid = $params[MM_GET_TREE_HERE][$i];
    if ($mmtid != $users_mmtid || $i == $max || $params[MM_GET_TREE_HERE][$i + 1] >= 0) {
      $params2 = $params;
      if ($mmtid < 0) {
        $ch = chr(-$mmtid);
        $re = $ch == '~' ? "t.name REGEXP '^[^[:alpha:]]'" : "UCASE(t.name) LIKE '$ch%'";
        $params2[MM_GET_TREE_INNER_FILTER] = " AND $re";
        $params2[MM_GET_TREE_DEPTH] = 1;
        $params2[MM_GET_TREE_MMTID] = $users_mmtid;
      }
      else {
        $params2[MM_GET_TREE_INNER_FILTER] = '';
        $params2[MM_GET_TREE_DEPTH] = $mmtid == $users_mmtid ? 0 : 1;
        $params2[MM_GET_TREE_MMTID] = $mmtid;
      }

      if ($i == $max) {
        if ($mmtid != $users_mmtid) $params2[MM_GET_TREE_DEPTH] = $params[MM_GET_TREE_DEPTH];
        $params2[MM_GET_TREE_BLOCK] = $params[MM_GET_TREE_BLOCK];
        $params2[MM_GET_TREE_SORT] = $params[MM_GET_TREE_DEPTH] != 0 || !empty($params[MM_GET_TREE_SORT]);
        $query[] = mm_content_get_query($params2);
      }
      else {
        $params2[MM_GET_TREE_BLOCK] = 0;
        $params2[MM_GET_TREE_SORT] = FALSE;
        $query[] = preg_replace('/ ORDER BY NULL$/', '', mm_content_get_query($params2));
      }
    }
  }

// debug_add_dump($mode, $params[MM_GET_TREE_HERE], Database::getConnection()->prefixTables(join(' UNION ', $query)));
  $params['q'] = new getTreeResults(join(' UNION ', $query));
  $params['q']->level_offset = $params['level'];
  return $params['q'];
}

function _mm_content_get_tree_recurs($r, $params, $parent_is_group, $parent_is_user, &$last) {
  $_mmtbt_cache = &drupal_static('_mmtbt_cache', array());
  $_mmgp_cache = &drupal_static('_mmgp_cache', array());
  $_mmuc_cache = &drupal_static('_mmuc_cache', array());

  $rows = array();
  $last = TRUE;

  $xlate = array(MM_PERMS_WRITE, MM_PERMS_SUB, MM_PERMS_APPLY, MM_PERMS_READ, MM_PERMS_IS_GROUP, MM_PERMS_IS_USER, MM_PERMS_ADMIN, MM_PERMS_IS_RECYCLE_BIN, MM_PERMS_IS_RECYCLED);
  foreach ($xlate as $field) {
    if (isset($r->$field)) {
      if (!isset($r->perms)) {
        $r->perms = array();
      }
      $r->perms[$field] = $r->$field != 0;
      unset($r->$field);
    }
  }

  if (!empty($params[MM_GET_TREE_RETURN_PERMS]) && !isset($params[MM_GET_TREE_ITERATOR])) {
    if ($r->perms[MM_PERMS_IS_RECYCLE_BIN]) {
      $r->perms[MM_PERMS_APPLY] = TRUE;
      $r->perms[MM_PERMS_READ] = mm_content_user_can_recycle($r->mmtid, MM_PERMS_READ, $params[MM_GET_TREE_USER]);
    }
    elseif (isset($r->recycle_bins)) {
      foreach (explode(',', $r->recycle_bins) as $bin) {
        $r->perms[MM_PERMS_READ] = $r->perms[MM_PERMS_READ] && mm_content_user_can_recycle($bin, MM_PERMS_READ, $params[MM_GET_TREE_USER]);
      }
    }
  }

  if (!empty($params[MM_GET_TREE_ADD_TO_CACHE])) {
    if (!isset($_mmtbt_cache[$r->mmtid])) {
      $_mmtbt_cache[$r->mmtid] = $r;
    }

    if (!isset($_mmgp_cache[$r->mmtid])) {
      $_mmgp_cache[$r->mmtid] = $r->parent;
    }

    if (isset($r->perms)) {
      foreach ($r->perms as $field => $val) {
        if (!isset($_mmuc_cache[$r->mmtid][$params[MM_GET_TREE_USER]->uid][$field])) {
          $_mmuc_cache[$r->mmtid][$params[MM_GET_TREE_USER]->uid][$field] = $val;
        }
      }
    }
  }

  if (!empty($params[MM_GET_TREE_RETURN_FLAGS])) {
    $r->flags = _mm_content_split_flags($r->flags);
  }

  if (!isset($r->is_group)) {
    $r->is_group =
      $parent_is_group || $r->name == MM_ENTRY_NAME_GROUPS ||
      !empty($params[MM_GET_TREE_ITERATOR]->parent_is_group) ||
      (isset($r->perms) ? $r->perms[MM_PERMS_IS_GROUP] : mm_content_user_can($r->mmtid, MM_PERMS_IS_GROUP, $params[MM_GET_TREE_USER]));
  }

  if (!isset($r->is_user)) {
    $r->is_user =
      $parent_is_user  || $r->name == MM_ENTRY_NAME_USERS ||
      !empty($params[MM_GET_TREE_ITERATOR]->parent_is_user) ||
      (isset($r->perms) ? $r->perms[MM_PERMS_IS_USER]  : mm_content_user_can($r->mmtid, MM_PERMS_IS_USER, $params[MM_GET_TREE_USER]));
  }

  $r->is_dot = $r->name[0] == '.';

  if ($r->is_group) {
    unset($r->nodecount);
  }

  $visible = (!empty($params[MM_GET_TREE_FILTER_GROUPS]) || !$r->is_group) &&
      (!empty($params[MM_GET_TREE_FILTER_NORMAL]) || $r->is_group || $r->is_user) &&
      (!empty($params[MM_GET_TREE_FILTER_USERS]) || !$r->is_user);

  if ($r->is_user && in_array($r->name, variable_get('mm_hidden_user_names', array()))) {
    $r->bid = -1;
  }

  if ($visible || $r->mmtid == 1) {
    if ($r->is_group || $r->name == MM_ENTRY_NAME_USERS || $r->mmtid == 1) {
      unset($r->nodecount);
    }

    $params2 = $params;
    if (is_array($params[MM_GET_TREE_HERE])) {
      $params2[MM_GET_TREE_HERE] =& $params[MM_GET_TREE_HERE];
    }
    $params2[MM_GET_TREE_DEPTH] = $params[MM_GET_TREE_DEPTH] < 0 ? -1 : $params[MM_GET_TREE_DEPTH] - 1;

    if (count($params[MM_GET_TREE_HERE]) && $r->mmtid == $params[MM_GET_TREE_HERE][0]) {
      $r->state = count($params[MM_GET_TREE_HERE]) >= 2 ? MM_GET_TREE_STATE_EXPANDED : MM_GET_TREE_STATE_EXPANDED|MM_GET_TREE_STATE_HERE;
      array_shift($params[MM_GET_TREE_HERE]);

      if ($params[MM_GET_TREE_BLOCK] && ($r->bid < 0 && $r->max_depth >= 0 || $r->bid > 0)) {
        $depth_new = $r->max_depth;
        if ($depth_new == -1) {
          $params2[MM_GET_TREE_DEPTH] = $params[MM_GET_TREE_DEPTH] = -1;
        }
        else {
          $params[MM_GET_TREE_DEPTH] = $depth_new;
          $params2[MM_GET_TREE_DEPTH] = $depth_new - 1;
        }
      }
      elseif ($params[MM_GET_TREE_DEPTH] < 0 || $params[MM_GET_TREE_DEPTH] > 2) {
        $params[MM_GET_TREE_DEPTH] = count($params[MM_GET_TREE_HERE]) + 2;
        $params2[MM_GET_TREE_DEPTH] = $params[MM_GET_TREE_DEPTH] - 1;
      }

      $params['found'] = $r->mmtid;
      if ($params[MM_GET_TREE_PRUNE_PARENTS] && $r->max_parents != '' && $r->max_parents >= 0) {
        $params['pprune'] = $r->max_parents + 2;
      }
    }
    else {
      $r->state = $params[MM_GET_TREE_DEPTH] && $r->parent <= 0 ? MM_GET_TREE_STATE_EXPANDED : (isset($r->kids) && $r->kids > 0 ? MM_GET_TREE_STATE_COLLAPSED : MM_GET_TREE_STATE_LEAF);
      if (is_array($params[MM_GET_TREE_HERE])) {
        $params2[MM_GET_TREE_DEPTH] = 0;
        $params2['once'] = TRUE;
        foreach (array(MM_GET_TREE_PRUNE_PARENTS, MM_GET_TREE_RETURN_NODE_COUNT) as $mode) {
          $params2[$mode] = FALSE;
        }
      }
    }

    if ((!$params[MM_GET_TREE_BLOCK] || $r->bid == $params[MM_GET_TREE_BLOCK] || $r->bid <= 0) && (!$r->hidden || !$r->level || $params[MM_GET_TREE_FILTER_HIDDEN] || isset($params[MM_GET_TREE_ITERATOR]) || !isset($r->perms) || !empty($r->perms[MM_PERMS_WRITE]) || !empty($r->perms[MM_PERMS_SUB]) || !empty($r->perms[MM_PERMS_APPLY]) || user_access('view all menus', $params[MM_GET_TREE_USER]))) {

      if (!isset($params[MM_GET_TREE_ITERATOR])) {
        $parent = count($rows);
      }

      if ($r->state) {
        if ($r->hidden) {
          $r->state |= MM_GET_TREE_STATE_HIDDEN;
        }
        elseif ($r->name == MM_ENTRY_NAME_RECYCLE) {
          $r->state |= MM_GET_TREE_STATE_RECYCLE;
        }

        if (!$r->is_group) {
          if (isset($r->perms[MM_PERMS_READ]) && !$r->perms[MM_PERMS_READ]) {
            $r->state |= MM_GET_TREE_STATE_DENIED;
            $skip_kids = TRUE;
          }

          if (strpos($r->default_mode, MM_PERMS_READ) === FALSE) {
            $r->state |= MM_GET_TREE_STATE_NOT_WORLD;
          }
        }

        if ($visible) {
          if (!isset($params[MM_GET_TREE_ITERATOR])) {
            $rows[] = $r;
            if (!empty($params['once'])) {
              return $rows;
            }
          }
          elseif (!empty($params['once'])) {
            return;
          }
          elseif (($iter_ok = $params[MM_GET_TREE_ITERATOR]->iterate($r)) < 0) {
            $last = FALSE;
            $skip_kids = TRUE;
          }
          elseif (!$iter_ok) {
            return;
          }
        }
      }

      if (!isset($skip_kids) && $params[MM_GET_TREE_DEPTH]) {
        if (isset($params[MM_GET_TREE_ITERATOR])) {
          $ois_grp = !empty($params[MM_GET_TREE_ITERATOR]->parent_is_group);
          $ois_user = !empty($params[MM_GET_TREE_ITERATOR]->parent_is_user);
          $params[MM_GET_TREE_ITERATOR]->parent_is_group = $r->is_group;
          $params[MM_GET_TREE_ITERATOR]->parent_is_user = $r->is_user;
        }

        $params2['found'] = -1;
        if (!empty($params2['once'])) $params2['pprune'] = -1;
        $params2['level'] = $params['level'] + 1;
        $params2['parent_level'] = $r->level;
        $kids = _mm_content_get_tree($r->mmtid, $params2);

        if ($params2['pprune'] >= 0) {
          if ($params2['pprune'] == 0) {
            $params['pprune'] = 0;
            return $kids;
          }
          elseif ($params2['found']) {
            $params['pprune'] = $params2['pprune'];
          }
        }

        if (isset($params[MM_GET_TREE_ITERATOR])) {
          $params[MM_GET_TREE_ITERATOR]->parent_is_group = $ois_grp;
          $params[MM_GET_TREE_ITERATOR]->parent_is_user = $ois_user;
        }
        else {
          if (count($rows) > $parent) {
            if ($rows[$parent]->is_group) {
              foreach ($kids as $k) {
                $k->is_group = TRUE;
                unset($k->nodecount);
              }
            }

            if ($rows[$parent]->is_user) {
              foreach ($kids as $k) {
                $k->is_user = TRUE;
                $k->is_user_home = $k->level == $rows[$parent]->level + 1 && $rows[$parent]->name == MM_ENTRY_NAME_USERS;
              }
            }

            if ($params['found'] != $r->mmtid) {
              $rows[$parent]->state &= ~(MM_GET_TREE_STATE_EXPANDED|MM_GET_TREE_STATE_COLLAPSED|MM_GET_TREE_STATE_LEAF);
              $rows[$parent]->state |= $params2['found'] >= 0 ? MM_GET_TREE_STATE_EXPANDED :
                  (count($kids) || isset($r->kids) && $r->kids > 0 ? MM_GET_TREE_STATE_COLLAPSED : MM_GET_TREE_STATE_LEAF);
            }
          }

          if ((!isset($params['once']) || !$params['once']) && is_array($kids)) {
            $rows = array_merge($rows, $kids);
          }
        }

        if ($params2['found'] >= 0) {
          $params['found'] = $params2['found'];
        }
      }       // if( $params[MM_GET_TREE_DEPTH] )
      else {
        $skip_kids = TRUE;
      }
    }         // if( !$params[MM_GET_TREE_BLOCK] || ...
    else {
      $skip_kids = TRUE;
    }
  }           // if( $visible || $r->parent<=0 )
  else {
    $skip_kids = TRUE;
  }

  if (isset($skip_kids)) {
    while (($row = $params['q']->next()) && strlen($row->sort_idx) > strlen($r->sort_idx));
    if ($row) {
      $params['q']->back();
    }
  }

  $last = FALSE;
  return $rows;
}

/**
 * Get the cascaded (inherited by children) settings for an entry.
 *
 * This function returns the exact settings for a particular entry, and does not
 * consider the settings of its parents. To include the parents' settings, see
 * mm_content_resolve_cascaded_setting().
 *
 * @param $mmtid
 *   ID of the entry to load settings for. If NULL, return a list of possible
 *   settings and their data representation. The structure of the returned array
 *   in this case is:
 *   - data_type:   'int' (integer) or 'string'
 *   - multiple:    TRUE if multiple values are accepted
 *   - user_access: user must have user_access() for this value in order to set
 *                  the setting
 *   - not_empty:   TRUE if only !empty() values should be stored
 * @param $name
 *   Name of the setting to return, or NULL to return all settings
 * @return
 *   Either an array or a single value, depending on $name
 */
function mm_content_get_cascaded_settings($mmtid = NULL, $name = NULL) {
  static $drupal_static_fast;

  if (is_null($mmtid)) {
    if (!isset($drupal_static_fast)) {
      // This is cumbersome, but assigning to an array is the only way that works.
      $drupal_static_fast['settings'] = &drupal_static(__FUNCTION__);
      // Check for mm_cascaded_settings hooks
      $drupal_static_fast['settings'] = module_invoke_all('mm_cascaded_settings');
    }
    return $drupal_static_fast['settings'];
  }

  $cascaded = array();
  $result = db_select('mm_cascaded_settings', 's')
    ->fields('s')
    ->condition('s.mmtid', $mmtid)
    ->execute();
  foreach ($result as $r) {
    if ($r->data_type == 'int') {
      $r->data = (int) $r->data;
    }

    if ($r->multiple) {
      if (!isset($cascaded[$r->name]) || !is_array($cascaded[$r->name])) {
        $cascaded[$r->name] = array();
      }
      if ($r->array_key != '') {
        $cascaded[$r->name][$r->array_key] = $r->data;
      }
      else {
        $cascaded[$r->name][] = $r->data;
      }
    }
    else {
      $cascaded[$r->name] = $r->data;
    }
  }

  if (!empty($name)) {
    if (isset($cascaded[$name])) {
      return $cascaded[$name];
    }
    $settings = mm_content_get_cascaded_settings();
    return empty($settings[$name]['multiple']) ? NULL : array();
  }
  return $cascaded;
}

/**
 * Set the cascaded (inherited by children) settings for an entry
 *
 * @param $mmtid
 *   Tree ID of the entry to set settings for
 * @param $settings
 *   Array containing the settings
 * @param $delete
 *   If TRUE, delete the old settings first
 */
function mm_content_set_cascaded_settings($mmtid, $settings, $delete = TRUE) {
  $cascaded_settings = mm_content_get_cascaded_settings();

  if ($delete) {
    db_delete('mm_cascaded_settings')
      ->condition('mmtid', $mmtid)
      ->execute();
    mm_content_notify_change('clear_cascaded', $mmtid, NULL);
  }

  foreach ($cascaded_settings as $name => $desc) {
    if (isset($settings[$name])) {
      if (!empty($desc['multiple'])) {
        foreach ($settings[$name] as $array_key => $data) {
          _mm_content_insert_cascaded_setting($mmtid, $name, $desc, $array_key, $data);
        }
      }
      else {
        _mm_content_insert_cascaded_setting($mmtid, $name, $desc, '', $settings[$name]);
      }
    }
  }

  if ($added = array_intersect_key($settings, $cascaded_settings)) {
    mm_content_notify_change('insert_cascaded', $mmtid, NULL, $added);
  }
}

/**
 * Notify hook_mm_notify_change() implementations that a change has occurred in
 * one or more nodes or MM pages.
 *
 * @param $type
 *   A string representing the type of change that occurred:
 *   'clear_cascaded':
 *     All cascaded settings have been cleared for the tree entries.
 *   'clear_flags':
 *     All flags have been cleared for the tree entries.
 *   'delete_node':
 *     The nodes with $nids, described by $data, have been permanently deleted.
 *   'delete_page':
 *     The tree entries with $mmtids have been permanently deleted.
 *   'insert_cascaded':
 *     One or more cascaded settings were added to the tree entries.
 *   'insert_flags':
 *     One or more flags were added to the tree entries.
 *   'insert_node':
 *     A node has been created. $data describes it.
 *   'insert_page':
 *     A tree entry has been created. $data describes it.
 *   'move_node':
 *     The nodes described by $nids have moved from $data['old_mmtid'] to
 *     $data['new_mmtid'].
 *   'move_page':
 *     The tree entries at $mmtids have moved from $data['old_parent'] to
 *     $data['new_parent'].
 *   'update_node':
 *     A node has been updated. $data describes the entire new state.
 *   'update_node_perms':
 *     The nodes' permissions have been modified to match $data.
 *   'update_page':
 *     A tree entry has been updated. $data describes the entire new state.
 *   'update_page_quick':
 *     A portion of the tree entry's settings have changed, according to $data.
 * @param $mmtids
 *   A single tree ID or an array of IDs that were affected, or NULL if none
 * @param $nids
 *   A single node ID or an array of IDs that were affected, or NULL if none
 * @param $data
 *   A $type-specific description of the change
 */
function mm_content_notify_change($type, $mmtids = NULL, $nids = NULL, $data = NULL) {
  if (isset($nids) && !is_array($nids)) {
    $nids = array($nids);
  }
  else if (empty($nids)) {
    $nids = array();
  }

  if (isset($mmtids) && !is_array($mmtids)) {
    $mmtids = array($mmtids);
  }
  else if (empty($mmtids)) {
    $mmtids = array();
  }

  module_invoke_all('mm_notify_change', $type, $mmtids, $nids, $data);
}

/**
 * Scan a tree entry and its parents upward, looking for the closest change in a
 * cascaded setting.
 *
 * To retrieve the settings for a particular entry without considering its
 * parents, see mm_content_get_cascaded_settings().
 *
 * @param $name
 *   Setting to look for
 * @param $mmtid
 *   Tree ID of the entry (and its parents) to query
 * @param $at
 *   Tree ID where the closest change occurs
 * @param $parent
 *   Tree ID of the nearest parent after $at containing a change in state
 * @param $new_entry
 *   Set to TRUE if $mmtid is that of the (future) parent of a new child
 * @return
 *   An array or single value (depending on the data type) containing the state
 *   of the given settings at the level $at
 */
function mm_content_resolve_cascaded_setting($name, $mmtid, &$at, &$parent, $new_entry = FALSE) {
  $q = db_query('SELECT s.* FROM (SELECT :mmtid1 AS mmtid, 10000 AS depth UNION SELECT parent, depth FROM {mm_tree_parents} WHERE mmtid = :mmtid2) t INNER JOIN {mm_cascaded_settings} s ON s.mmtid = t.mmtid WHERE s.name = :name ORDER BY t.depth DESC',
    array(
      ':mmtid1' => $mmtid,
      ':mmtid2' => $mmtid,
      ':name' => $name,
    )
  );

  $out = array();
  $r = $q->fetch();
  while ($r) {
    $this_mmtid = $r->mmtid;
    if (is_array($out) && !$out) {
      if ($r->multiple) {
        do {
          if ($r->data_type == 'int') {
            $r->data = (int) $r->data;
          }

          if ($r->array_key != '') {
            $out[$r->array_key] = $r->data;
          }
          else {
            $out[] = $r->data;
          }

          $r = $q->fetch();
        } while ($r && $r->multiple && $r->mmtid == $this_mmtid);
      }
      else {
        if ($r->data_type == 'int') {
          $r->data = (int) $r->data;
        }
        $out = $r->data;
      }
      $at = $this_mmtid;
    }
    elseif ($r->multiple) {
      do {
        $r = $q->fetch();
      } while ($r && $r->multiple && $r->mmtid == $this_mmtid);
    }
    else {
      $r = $q->fetch();
    }

    if ($new_entry || $this_mmtid != $mmtid) {
      $parent = $this_mmtid;
      return $out;
    }
  }

  $parent = 0;
  if (!$out && $out !== 0) {
    $cascaded_settings = mm_content_get_cascaded_settings();
    if (!isset($cascaded_settings[$name]['multiple']) || !$cascaded_settings[$name]['multiple']) return NULL;
  }
  return $out;
}

/**
 * Get the parent tree ID of an entry
 *
 * @param $mmtids
 *   Tree ID (or array of Tree IDs) of the entry whose parent we are looking for
 * @return
 *   Tree ID of the parent (if a single $mmtid is supplied), or an array where
 *   the key is the child Tree ID and the value is the parent
 */
function mm_content_get_parent($mmtids) {
  if (is_array($mmtids)) {
    if (count($mmtids) == 1) {
      // If only one mmtid, use the simple case because it might be cached.
      $mmtid = array_pop($mmtids);
      $parent = mm_content_get_parent($mmtid);
      if (isset($parent)) {
        return array($mmtid => $parent);
      }
      return array();
    }
    return db_select('mm_tree', 't')
      ->fields('t', array('mmtid', 'parent'))
      ->condition('mmtid', $mmtids)
      ->execute()
      ->fetchAllKeyed();
  }

  $t = mm_content_get($mmtids);
  if ($t) {
    return $t->parent;
  }
  return NULL;
}

/**
 * Get all parent tree IDs of a entry
 *
 * @param $mmtid
 *   Tree ID of the entry whose parent we are looking for
 * @param $slow
 *   If TRUE, don't rely on the 'parents' field of the mm_tree table, instead
 *   slowly traverse up the tree
 * @param $virtual
 *   If TRUE, include the negative IDs that are added to children of the
 *   /.Users entry by mm_content_get_tree().
 * @return
 *   Array of parent tree IDs, listed highest-first
 */
function mm_content_get_parents($mmtid, $slow = FALSE, $virtual = TRUE) {
  $_mmtbt_cache = &drupal_static('_mmtbt_cache', array());
  $_mmgp_cache = &drupal_static('_mmgp_cache', array());

  $list = array();
  $mmtid0 = $mmtid;

  if ($mmtid < 0) {
    return array(1, mm_content_users_mmtid());
  }

  if (!$slow) {
    if ($mmtid == 1) {
      return $list;
    }
    while ($mmtid > 1 && isset($_mmgp_cache[$mmtid])) {
      array_unshift($list, $mmtid = $_mmgp_cache[$mmtid]);
    }

    if ($mmtid > 1) {
      $r = mm_content_get($mmtid, MM_GET_PARENTS);
      if (empty($r)) {
        return $list;
      }

      $list = array_merge($r->parents, $list);
      $prev = $mmtid0;
      foreach (array_reverse($list) as $m) {
        $_mmgp_cache[$prev] = $m;
        $prev = $m;
      }
    }
  }
  else {
    $last = -1;
    do {
      $mmtid = mm_content_get_parent($mmtid);
      if ($mmtid) {
        array_unshift($list, $mmtid);
      }

      if ($mmtid == $last) {
        // shouldn't happen, but just in case
        break;
      }

      $last = $mmtid;
    }
    while ($mmtid > 1);
  }

  $virtual = $virtual && variable_get('mm_use_virtual_user_dir', TRUE);
  if ($virtual && count($list) >= 2 && $list[1] == mm_content_users_mmtid()) {
    $m = count($list) >= 3 ? $list[2] : $mmtid0;
    $tree = isset($_mmtbt_cache[$m]) ? $_mmtbt_cache[$m] : mm_content_get($m);

    if ($tree) {
      $letr = drupal_strtoupper($tree->name[0]);
      $alias = ctype_alpha($letr) ? $letr : '~';
      array_splice($list, 2, 0, -ord($alias));
    }
  }

  return $list;
}

/**
 * Get all parent tree IDs of a entry, plus the ID itself
 *
 * @param $mmtid
 *   Tree ID of the entry whose parent we are looking for
 * @param $slow
 *   If TRUE, don't rely on the 'parents' field of the mm_tree table, instead
 *   slowly traverse up the tree
 * @param $virtual
 *   If TRUE, include the negative IDs that are added to children of the
 *   /.Users entry by mm_content_get_tree().
 * @return
 *   Array of parent tree IDs, listed highest-first, with $mmtid at the end
 */
function mm_content_get_parents_with_self($mmtid, $slow = FALSE, $virtual = TRUE) {
  $list = mm_content_get_parents($mmtid, $slow, $virtual);
  $list[] = $mmtid;
  return $list;
}

/**
 * Get the full tree path of a tree ID
 *
 * @param $mmtid
 *   Tree ID of the page whose path we are looking for
 * @return
 *   Full path in the format 1/7/234/847
 */
function mm_content_get_full_path($mmtid) {
  return join('/', mm_content_get_parents_with_self($mmtid));
}

/**
 * Get a page's name.
 *
 * @param $mmtid_or_tree
 *   Tree ID or full tree object of the page whose name is being requested. If
 *   known, it is better to provide the full object, to avoid extra queries to
 *   the database.
 * @return
 *   The expanded name
 * @see hook_mm_mmtid_name
 */
function mm_content_get_name($mmtid_or_tree) {
  static $drupal_static_fast;

  if (!is_object($mmtid_or_tree)) {
    if (!($mmtid_or_tree = mm_content_get($mmtid_or_tree))) {
      return '';
    }
  }

  if (!isset($drupal_static_fast)) {
    // This is cumbersome, but assigning to an array is the only way that works.
    $drupal_static_fast['table'] = &drupal_static(__FUNCTION__, array());
    // We can't use (mm_)module_invoke_all() as it does not handle numeric keys
    // (mmtids, in this case) correctly.
    foreach (mm_module_implements('mm_mmtid_name') as $module) {
      $drupal_static_fast['table'] += module_invoke($module, 'mm_mmtid_name');
    }
  }

  $mmtid = $mmtid_or_tree->mmtid;
  $table = &$drupal_static_fast['table'];
  if (isset($table[$mmtid])) {
    if (is_array($table[$mmtid])) {
      if (isset($table[$mmtid]['callback']) && function_exists($table[$mmtid]['callback'])) {
        $result = call_user_func($table[$mmtid]['callback'], $mmtid_or_tree);
        if (!empty($result)) {
          return $result;
        }
      }
      if (!empty($table[$mmtid]['name'])) {
        return $table[$mmtid]['name'];
      }
    }
    else {
      return $table[$mmtid];
    }
  }

  return mm_content_expand_name($mmtid_or_tree->name);
}

/**
 * Get a list of tree entries, using their tree IDs
 *
 * @param $options
 *   Either a single tree ID, an array of tree IDs, or an associative array
 *   containing key => value pairs of attributes to query. When using an
 *   associative array, the value can be an array of values. The allowed keys
 *   are all of the columns in the mm_tree table, plus:
 *   - query: a sub-query which returns a list of mmtids to query against
 *   - flags: an array of key => value pairs which are ANDed together; a NULL
 *            value becomes IS NULL in the query
 * @param $return
 *   A single value, or an array of values, from the list of constants below:
 *   - MM_GET_ARCHIVE: return archive status (mm_archive)
 *   - MM_GET_FLAGS:   return flags (mm_tree_flags)
 *   - MM_GET_PARENTS: return parents (mm_tree_parents)
 * @param $limit
 *   Optional maximum number of results to return (0)
 * @param $sort
 *   If TRUE, sort the results by their position in the tree (FALSE)
 * @return
 *   If $options['mmtids'] is a single tree ID, return the one tree object.
 *   Otherwise, return an array of tree objects (order is random).
 */
function mm_content_get($options, $return = array(), $limit = 0, $sort = FALSE) {
  $_mmtbt_cache = &drupal_static('_mmtbt_cache', array());

  $single = FALSE;
  if (!is_array($options)) {
    $single = TRUE;
    $options = array('mmtid' => array($options));
  }
  elseif (is_numeric(mm_ui_mmlist_key0($options))) {
    $options = array('mmtid' => $options);
  }

  if (!is_array($return)) {
    $return = array($return);
  }
  $return = array_flip($return);

  $out = $args = $wheres = $joins = array();
  $add_field = $group_by = '';

  // Use a cache in the simple case where the only keys are mmtids
  if (isset($options['mmtid']) && count(array_keys($options)) == 1 && !$sort) {
    if (!is_array($options['mmtid'])) $options['mmtid'] = array($options['mmtid']);

    foreach ($options['mmtid'] as $key => $mmtid) {
      if (isset($_mmtbt_cache[$mmtid]) && (!isset($return[MM_GET_ARCHIVE]) || isset($_mmtbt_cache[$mmtid]->archive_cached)) && (!isset($return[MM_GET_FLAGS]) || isset($_mmtbt_cache[$mmtid]->flags)) && (!isset($return[MM_GET_PARENTS]) || isset($_mmtbt_cache[$mmtid]->parents))) {
        if (!$limit || count($out) < $limit) {
          $out[] = clone $_mmtbt_cache[$mmtid];
        }
        unset($options['mmtid'][$key]);
      }
      elseif ($mmtid < 0) {
        if (!$limit || count($out) < $limit) {
          $out[] = _mm_content_virtual_dir($mmtid, mm_content_users_mmtid(), 0, 0);
        }
        unset($options['mmtid'][$key]);
      }
      elseif (!is_numeric($mmtid) || !$mmtid) {
        unset($options['mmtid'][$key]);
      }
    }
    // Reset array keys after unset()
    $options['mmtid'] = array_merge($options['mmtid']);
  }

  if (isset($options['query']) && !isset($options['mmtid'])) {
    $wheres[] = 't.mmtid IN (' . $options['query'] . ')';
    $single = FALSE;
    unset($options['query']);
  }

  if (isset($options['flags']) && is_array($options['flags'])) {
    $n = 0;
    foreach ($options['flags'] as $flag => $data) {
      $joins[] = "LEFT JOIN {mm_tree_flags} f$n ON f$n.mmtid = t.mmtid";
      $wheres[] = "f$n.flag = ?";
      $args[] = $flag;
      if (is_null($data)) {
        $wheres[] = "f$n.data IS NULL";
      }
      else {
        $wheres[] = "f$n.data = ?";
        $args[] = $data;
      }
      $n++;
    }
    $single = FALSE;
    unset($options['flags']);
  }

  foreach ($options as $k => $v) {
    if (!is_array($v) || $v) {
      if (is_array($v) && count($v) == 1) {
        $v = $v[0];
      }

      $k = strtolower($k);
      if (strchr($k, '.') === FALSE) {
        $k = "t.$k";
      }

      if (is_array($v)) {
        $vals = array();
        foreach ($v as $v2) {
          $vals[] = '?';
          $args[] = $v2;
        }
        $wheres[] = "$k IN(" . join(', ', $vals) . ')';
      }
      else {
        $wheres[] = "$k = ?";
        $args[] = $v;
      }
    }
  }

  if ($limit) {
    // Consider cached data already copied to $out
    $limit -= count($out);
    if ($limit <= 0) {
      return $single ? $out[0] : $out;
    }
  }

  if (isset($return[MM_GET_ARCHIVE])) {
    $joins[] = 'LEFT JOIN {mm_archive} a ON a.main_mmtid = t.mmtid OR a.archive_mmtid = t.mmtid';
    $add_field .= ', a.*, 1 AS archive_cached';
  }

  if (isset($return[MM_GET_FLAGS])) {
    $joins[] = 'LEFT JOIN {mm_tree_flags} f ON f.mmtid = t.mmtid';
    $add_field .= ", GROUP_CONCAT(DISTINCT CONCAT_WS('|1', f.flag, f.data) SEPARATOR '|2') AS flags";
    $group_by = ' GROUP BY t.mmtid';
  }

  if (isset($return[MM_GET_PARENTS])) {
    $joins[] = 'LEFT JOIN {mm_tree_parents} p ON p.mmtid = t.mmtid';
    $add_field .= ', GROUP_CONCAT(DISTINCT p.parent ORDER BY p.depth) AS parents';
    $group_by = ' GROUP BY t.mmtid';
  }

  if (!empty($wheres)) {
    $space = count($joins) ? ' ' : '';
    $query = "SELECT t.*$add_field FROM {mm_tree} t$space" . join(' ', $joins) . ' WHERE ' . join(' AND ', $wheres) . $group_by;
    if ($sort) {
      $query .= ' ORDER BY t.sort_idx';
    }

    if ($limit) {
      $q = db_query_range($query, 0, $limit, $args);
    }
    else {
      $q = db_query($query, $args);
    }

    foreach ($q as $r) {
      if (isset($return[MM_GET_FLAGS])) {
        $r->flags = _mm_content_split_flags($r->flags);
      }
      elseif (isset($_mmtbt_cache[$r->mmtid]) && isset($_mmtbt_cache[$r->mmtid]->flags)) {
        $r->flags = $_mmtbt_cache[$r->mmtid]->flags;
      }

      if (isset($return[MM_GET_PARENTS]) && !is_array($r->parents)) {
        $r->parents = empty($r->parents) ? array() : explode(',', $r->parents);
      }
      elseif (isset($_mmtbt_cache[$r->mmtid]) && isset($_mmtbt_cache[$r->mmtid]->parents)) {
        $r->parents = $_mmtbt_cache[$r->mmtid]->parents;
      }

      if (!isset($return[MM_GET_ARCHIVE]) && isset($_mmtbt_cache[$r->mmtid]) && isset($_mmtbt_cache[$r->mmtid]->archive_cached)) {
        $r->archive_cached = 1;
        $r->main_mmtid = $_mmtbt_cache[$r->mmtid]->main_mmtid;
        $r->archive_mmtid = $_mmtbt_cache[$r->mmtid]->archive_mmtid;
        $r->frequency = $_mmtbt_cache[$r->mmtid]->frequency;
        $r->main_nodes = $_mmtbt_cache[$r->mmtid]->main_nodes;
      }

      $_mmtbt_cache[$r->mmtid] = $out[] = $r;
    }
  }

  return $single && isset($out[0]) ? $out[0] : $out;
}

/**
 * Update a tree entry's list of parent nodes, or update the lists for all
 * entries in the tree.
 *
 * @param $mmtid
 *   ID of the entry to update, or NULL to update all entries
 * @param $parents
 *   Array of parent IDs, or NULL to recalculate from the tree
 * @param $is_new
 *   Set to TRUE if the entry doesn't already have parents, to avoid an extra
 *   DELETE
 * @param $force
 *   When $mmtid is NULL, set this parameter to TRUE in order to force all
 *   entries to be updated, not just those that currently have no 'parents' info
 */
function mm_content_update_parents($mmtid = NULL, $parents = NULL, $is_new = FALSE, $force = FALSE) {
  if (is_null($mmtid)) {
    $select = db_select('mm_tree', 't')
      ->fields('t', array('mmtid'));

    if ($force) {
      // SELECT t.mmtid FROM {mm_tree} t
      // LEFT JOIN {mm_tree_parents} p ON p.mmtid = t.mmtid
      // WHERE t.parent > 0 AND p.parent IS NULL
      $select->leftJoin('mm_tree_parents', 'p', 'p.mmtid = t.mmtid');
      $select->condition('t.parent', 0, '>')
        ->isNull('p.parent');
    }

    $result = $select->execute();

    foreach ($result as $r) {
      mm_content_update_parents($r->mmtid, NULL);
    }

    return;
  }

  $txn = db_transaction();  // Lock DB.

  if (is_null($parents)) {
    $parents = mm_content_get_parents($mmtid, TRUE, FALSE);
  }

  if ($parents && !$is_new) {
    _mm_content_clear_access_cache($mmtid);
  }

  db_delete('mm_tree_parents')
    ->condition('mmtid', $mmtid)
    ->execute();

  if ($parents) {
    if (!$is_new) {
      // UPDATE {mm_tree} SET parent = <last parent> WHERE mmtid = <mmtid>
      db_update('mm_tree')
        ->fields(array('parent' => $parents[count($parents) - 1]))
        ->condition('mmtid', $mmtid)
        ->execute();
    }

    $insert = db_insert('mm_tree_parents')
      ->fields(array('mmtid', 'parent', 'depth'));
    foreach ($parents as $depth => $parent) {
      $insert->values(array(
        'mmtid' => $mmtid,
        'parent' => $parent,
        'depth' => $depth));
    }
    $insert->execute();
  }

  // Update the variable which controls how many nested joins are performed when
  // rewriting inbound URLs.
  $max_depth = db_query('SELECT MAX(depth) FROM {mm_tree_parents}')->fetchField() + 1;
  $new_max = min($max_depth, MM_CONTENT_MYSQL_MAX_JOINS);
  if (variable_get('mm_content_mysql_max_joins') !== $new_max) {
    variable_set('mm_content_mysql_max_joins', $new_max);
  }

  mm_module_invoke_all('mm_content_update_parents', $mmtid, $parents, $is_new);
}

/**
 * Return the URL for a tree entry
 *
 * @param $mmtid
 *   ID of the entry
 * @return
 *   The URL, starting with 'mm/'
 */
function mm_content_get_mmtid_url($mmtid) {
  return "mm/$mmtid";
}

/**
 * Return a list of tree IDs to which a given node is assigned
 *
 * @param $nids
 *   Node ID or array of node IDs to query
 * @param $reset
 *   If TRUE, clear the cache
 * @return
 *   If $nids is a single nid, return an array of tree IDs, otherwise return an
 *   outer array keyed by nid, where each value is an array of mmtids.
 */
function mm_content_get_by_nid($nids, $reset = FALSE) {
  if ($reset) {
    drupal_static(__FUNCTION__, array(), TRUE);
    return;
  }

  $cache = &drupal_static(__FUNCTION__, array());

  $want_array = TRUE;
  if (!is_array($nids)) {
    $want_array = FALSE;
    $nids = array($nids);
  }

  $needed = array_diff($nids, array_keys($cache));
  if ($needed) {
    $result = db_select('mm_node2tree', 't')
      ->fields('t', array('mmtid', 'nid'))
      ->condition('t.nid', $needed)
      ->execute();
    foreach ($result as $r) {
      $cache[$r->nid][] = $r->mmtid;
    }
  }

  if (!$want_array) {
    return isset($cache[$nids[0]]) ? $cache[$nids[0]] : array();
  }

  return array_intersect_key($cache, array_flip($nids));
}

/**
 * Figure out if a user can see or delete a recycle bin
 *
 * @param $mmtid
 *   ID of the bin being queried
 * @param $mode
 *   If set, return whether or not the user can perform that action
 *   (MM_PERMS_READ (see), MM_PERMS_WRITE (delete)). Otherwise, return an array
 *   containing these elements with either TRUE or FALSE values. There is also a
 *   special mode, 'EMPTY', which returns TRUE if the user has permission to
 *   empty the entire bin (i.e.: has write on everything in it.)
 * @param $usr
 *   User object of the user to test, or NULL to test the global $user
 * @return
 *   See above
 */
function mm_content_user_can_recycle($mmtid, $mode = '', $usr = NULL) {
  global $user;
  $_mmucr_cache = &drupal_static('_mmucr_cache', array());

  if (!$usr) $usr = $user;
  $uid = $usr->uid;

  if ($mode != '' ? !isset($_mmucr_cache[$mmtid][$uid][$mode]) : !isset($_mmucr_cache[$mmtid][$uid])) {
    if (!class_exists('mmucrGetTreeIterator')) {
      class mmucrGetTreeIterator extends getTreeIterator {
        public $readable, $writable, $emptyable, $mode, $usr;

        public function __construct($mode, $usr) {
          $this->readable = FALSE;
          $this->writable = FALSE;
          $this->emptyable = TRUE;
          $this->mode = $mode;
          $this->usr = $usr;
        }

        public function iterate($item) {
          // function must return 1 if no error, 0 if error, -1 if this node
          // and any of its children should be skipped
          if ($item->name == MM_ENTRY_NAME_RECYCLE) { // the bin exists
            // Make sure the entity info for 'node' is available. If this code
            // is called during hook_boot(), it might not be.
            if (entity_get_info('node')) {
              $this->writable = TRUE;                // no nodes: default to writable
              if (!empty($item->perms[MM_PERMS_ADMIN]) || $item->perms[MM_PERMS_WRITE]) $this->readable = TRUE;
              foreach (node_load_multiple(mm_content_get_nids_by_mmtid($item->mmtid)) as $node) {
                $this->writable = FALSE;             // it's not empty, so not writable
                if ($node->nid) {
                  if (node_access('delete', $node, $this->usr)) {
                    $this->readable = TRUE;          // the bin is readable
                    if ($this->mode != 'EMPTY') return 0;  // skip everything else
                  }
                  elseif ($this->mode == 'EMPTY') {
                    $this->emptyable = FALSE;
                    return 0;
                  }
                }
              }
              return 1;
            }
          }
          $this->writable = FALSE;                 // it's not empty, so not writable

          if ($item->perms[MM_PERMS_WRITE]) {      // if the user can write to at least one kid
            $this->readable = TRUE;                // the bin is readable
            if ($this->mode != 'EMPTY') return 0;  // skip everything else
          }
          elseif ($this->mode == 'EMPTY') {        // looking for emptyable status
            $this->emptyable = FALSE;              // can't write, so not emptyable
            return 0;
          }

          return -1;                               // skip this node and kids; we only care about sibs
        } // iterate
      }   // class
    }     // !class_exists

    $iter = new mmucrGetTreeIterator($mode, $usr->uid == $user->uid ? NULL : $usr);
    if (mm_content_user_can(mm_content_get_parent($mmtid), MM_PERMS_READ, $usr)) {
      $params = array(
        MM_GET_TREE_FAKE_READ_BINS => TRUE,
        MM_GET_TREE_USER           => $usr,
        MM_GET_TREE_RETURN_PERMS   => TRUE,
        MM_GET_TREE_DEPTH          => 1,
        MM_GET_TREE_ITERATOR       => $iter,
      );
      mm_content_get_tree($mmtid, $params);
    }
    elseif ($mode == 'EMPTY') {
      $iter->emptyable = FALSE;
    }

    if ($mode == 'EMPTY') {
      $_mmucr_cache[$mmtid][$uid]['EMPTY'] = $iter->emptyable && user_access('delete permanently', $usr);
    }
    else {
      $_mmucr_cache[$mmtid][$uid][MM_PERMS_READ] = $iter->readable;
      $_mmucr_cache[$mmtid][$uid][MM_PERMS_WRITE] = $iter->writable;
    }
  }       // !isset($_mmucr_cache[$mmtid][$uid])

  if ($mode != '') {
    return isset($_mmucr_cache[$mmtid][$uid][$mode]) ? $_mmucr_cache[$mmtid][$uid][$mode] : FALSE;
  }

  return $_mmucr_cache[$mmtid][$uid];
}

/**
 * Figure out if a given user can access a particular tree ID
 *
 * @param $mmtid
 *   ID of the term being queried
 * @param $mode
 *   If set, return whether or not the user can perform that action
 *   (MM_PERMS_READ, MM_PERMS_WRITE, MM_PERMS_SUB, MM_PERMS_APPLY,
 *   MM_PERMS_IS_USER, MM_PERMS_IS_GROUP, MM_PERMS_IS_RECYCLE_BIN,
 *   MM_PERMS_IS_RECYCLED). Otherwise, return an array containing each of these
 *   permissions with either TRUE or FALSE values.
 * @param $usr
 *   User object to test against. Defaults to the current user.
 * @param $bias_anon
 *   If TRUE, assume user 0 can't read any groups (faster, more secure)
 * @return
 *   See above
 */
function mm_content_user_can($mmtid, $mode = '', $usr = NULL, $bias_anon = TRUE) {
  global $user;
  $_mmuc_cache = &drupal_static('_mmuc_cache', array());
  if (!$usr) $usr = $user;
  $uid = $usr->uid;

  $mmtid = intval($mmtid);
  if (!empty($mode) ? !isset($_mmuc_cache[$mmtid][$uid][$mode]) : !isset($_mmuc_cache[$mmtid][$uid])) {
    // set default values, in case mmtid does not exist
    $_mmuc_cache[$mmtid][$uid] = array(
      MM_PERMS_WRITE          => FALSE,
      MM_PERMS_SUB            => FALSE,
      MM_PERMS_APPLY          => FALSE,
      MM_PERMS_READ           => FALSE,
      MM_PERMS_IS_USER        => FALSE,
      MM_PERMS_IS_GROUP       => FALSE,
      MM_PERMS_IS_RECYCLE_BIN => FALSE,
      MM_PERMS_IS_RECYCLED    => FALSE,
    );
    if ($mmtid < 0) {
      // speedup for virtual user directory (A-Z)
      $_mmuc_cache[$mmtid][$uid][MM_PERMS_READ] = $_mmuc_cache[$mmtid][$uid][MM_PERMS_IS_USER] = TRUE;
    }
    elseif ($mmtid) {
      $cid = "$mmtid::$uid";
      $cached = _mm_content_access_cache($cid);
      if (is_array($cached)) {
        $_mmuc_cache[$mmtid][$uid] = $cached;
      }
      else {
        $params = array(
          MM_GET_TREE_BIAS_ANON      => $bias_anon,
          MM_GET_TREE_FAKE_READ_BINS => TRUE,
          MM_GET_TREE_MMTID          => $mmtid,
          MM_GET_TREE_RETURN_BINS    => TRUE,
          MM_GET_TREE_RETURN_PERMS   => TRUE,
          MM_GET_TREE_USER           => $usr,
        );
        $row = db_query(mm_content_get_query($params))->fetchObject();
        if ($row) {
          $bins = array();
          foreach ((array)$row as $key => $val) {
            if ($key == 'recycle_bins') {
              if (!empty($val)) $bins = explode(',', $val);
            }
            else {
              $_mmuc_cache[$mmtid][$uid][$key] = $val != 0;
            }
          }

          // it's too expensive to do this in the query
          if ($_mmuc_cache[$mmtid][$uid][MM_PERMS_IS_RECYCLE_BIN]) {
            $_mmuc_cache[$mmtid][$uid][MM_PERMS_APPLY] = TRUE;
            $_mmuc_cache[$mmtid][$uid][MM_PERMS_READ] = mm_content_user_can_recycle($mmtid, MM_PERMS_READ, $usr);
          }
          else {
            // re-calculate the MM_PERMS_READ flag for anything in a bin
            foreach ($bins as $bin) {
              $_mmuc_cache[$mmtid][$uid][MM_PERMS_READ] = $_mmuc_cache[$mmtid][$uid][MM_PERMS_READ] && mm_content_user_can_recycle($bin, MM_PERMS_READ, $usr);
            }
          }
        }
        _mm_content_access_cache($cid, $_mmuc_cache[$mmtid][$uid], $uid, 0, $mmtid);
      }
    }
  }

  if (!empty($mode)) return $_mmuc_cache[$mmtid][$uid][$mode];

  return $_mmuc_cache[$mmtid][$uid];
}

/**
 * Get a database query to return a part of the tree, or to determine whether or
 * not a user has permission to access a particular node or part of the tree
 *
 * @param $params
 *   An array containing parameters. The array is indexed using the constants
 *   below. Either [MM_GET_TREE_NODE] or [MM_GET_TREE_MMTID] must be specified.
 *   - MM_GET_TREE_ADD_SELECT (none):
 *     A string or array of strings to add to the SELECT portion of the query
 *   - MM_GET_TREE_BIAS_ANON (TRUE):
 *     If TRUE, assume user 0 can't read any groups (more secure)
 *   - MM_GET_TREE_DEPTH (0):
 *     When 'mmtid' is used, a query to return all items in the tree below that
 *     point can be returned. This field specifies the depth of recursion:
 *     - 0:  just the item specified by MM_GET_TREE_MMTID
 *     - -1: all levels
 *     - 1:  the item and its immediate children
 *     - N:  any other other number will return that many levels (can be slow)
 *   - MM_GET_TREE_FAKE_READ_BINS (FALSE):
 *     Pretend the user can read all recycle bins (used internally)
 *   - MM_GET_TREE_FILTER_BINS (TRUE):
 *     Get entries that are recycle bins
 *   - MM_GET_TREE_FILTER_DOTS (TRUE):
 *     Get all entries with names that start with '.'. If FALSE, only .Groups,
 *     .Users, and .Virtual are returned.
 *   - MM_GET_TREE_FILTER_GROUPS (TRUE):
 *     Get entries that are groups (MM_GET_TREE_MMTID mode)
 *   - MM_GET_TREE_FILTER_NORMAL (TRUE):
 *     Get entries that are neither groups nor in /users (MM_GET_TREE_MMTID
 *     mode)
 *   - MM_GET_TREE_FILTER_USERS (TRUE):
 *     Get entries in /users (MM_GET_TREE_MMTID mode)
 *   - MM_GET_TREE_INNER_FILTER:
 *     Used internally
 *   - MM_GET_TREE_MMTID:
 *     Tree ID to query
 *   - MM_GET_TREE_NODE:
 *     Node object to query permissions for
 *   - MM_GET_TREE_RETURN_BINS (FALSE):
 *     A comma-separated list of the mmtids of any parent recycle bins
 *   - MM_GET_TREE_RETURN_BLOCK (FALSE):
 *     Attributes from the mm_tree_block table (MM_GET_TREE_MMTID mode)
 *   - MM_GET_TREE_RETURN_FLAGS (FALSE):
 *     Flags from the mm_tree_flags table (MM_GET_TREE_MMTID mode)
 *   - MM_GET_TREE_RETURN_KID_COUNT (FALSE):
 *     A count of the number of children each tree entry has (MM_GET_TREE_MMTID
 *     mode)
 *   - MM_GET_TREE_RETURN_MTIME (FALSE):
 *     The muid (user ID who made the last modification) and mtime (time) of the
 *     modification
 *   - MM_GET_TREE_RETURN_NODE_COUNT (FALSE):
 *     If TRUE, return a count of the number of nodes assigned to each item. If
 *     a string or array of strings, return a count of the number of nodes of
 *     that type.
 *   - MM_GET_TREE_RETURN_PERMS (none):
 *     If set, return whether or not the user can perform that action
 *     (MM_PERMS_READ, MM_PERMS_WRITE, MM_PERMS_SUB, MM_PERMS_APPLY,
 *     MM_PERMS_IS_USER, MM_PERMS_IS_GROUP, MM_PERMS_IS_RECYCLE_BIN,
 *     MM_PERMS_IS_RECYCLED). Only (MM_PERMS_READ, MM_PERMS_WRITE, MM_PERMS_SUB,
 *     MM_PERMS_APPLY) are supported when [MM_GET_TREE_NODE] is used. The
 *     requested permission can either be a single value or an array. If an
 *     empty array or TRUE is passed, all permissions are returned.
 *   - MM_GET_TREE_RETURN_TREE (FALSE):
 *     Attributes from the mm_tree table (MM_GET_TREE_MMTID mode)
 *   - MM_GET_TREE_SORT (FALSE):
 *     If TRUE, sort the entries according to sort_idx; always TRUE when
 *     MM_GET_TREE_DEPTH != 0
 *   - MM_GET_TREE_USER (current user):
 *     User object to test permissions against
 *   - MM_GET_TREE_WHERE (none):
 *     Add a WHERE clause to the outermost query
 *   If none of ([...USERS], [...GROUPS], [...NORMAL]) is TRUE, all types are
 *   retrieved by the query.
 * @return
 *   The query string
 */
function mm_content_get_query($params) {
  global $user;
  static $user_access;
  if (!isset($user_access)) {
    $user_access = &drupal_static(__FUNCTION__);
  }

  $defaults = array(
    MM_GET_TREE_BIAS_ANON        => TRUE,
    MM_GET_TREE_DEPTH            => 0,
    MM_GET_TREE_FAKE_READ_BINS   => FALSE,
    MM_GET_TREE_FILTER_BINS      => TRUE,
    MM_GET_TREE_FILTER_DOTS      => TRUE,
    MM_GET_TREE_FILTER_GROUPS    => FALSE,
    MM_GET_TREE_FILTER_NORMAL    => FALSE,
    MM_GET_TREE_FILTER_USERS     => FALSE,
    MM_GET_TREE_INNER_FILTER     => '',
    MM_GET_TREE_RETURN_BINS      => FALSE,
    MM_GET_TREE_RETURN_BLOCK     => FALSE,
    MM_GET_TREE_RETURN_FLAGS     => FALSE,
    MM_GET_TREE_RETURN_KID_COUNT => FALSE,
    MM_GET_TREE_RETURN_MTIME     => FALSE,
    MM_GET_TREE_RETURN_TREE      => FALSE,
    MM_GET_TREE_USER             => $user,
    MM_GET_TREE_WHERE            => '',
  );

  $params = array_merge($defaults, $params);
  if (!$params[MM_GET_TREE_FILTER_GROUPS] && !$params[MM_GET_TREE_FILTER_USERS] && !$params[MM_GET_TREE_FILTER_NORMAL]) {
    $params[MM_GET_TREE_FILTER_GROUPS] = $params[MM_GET_TREE_FILTER_USERS] = $params[MM_GET_TREE_FILTER_NORMAL] = TRUE;
  }

  $is_node = isset($params[MM_GET_TREE_NODE]);

  if (isset($params[MM_GET_TREE_RETURN_PERMS]) && $params[MM_GET_TREE_RETURN_PERMS] === TRUE ||
      ($is_node ? !isset($params[MM_GET_TREE_RETURN_PERMS]) || !$params[MM_GET_TREE_RETURN_PERMS] :
      isset($params[MM_GET_TREE_RETURN_PERMS]) && empty($params[MM_GET_TREE_RETURN_PERMS]))) {
    $params[MM_GET_TREE_RETURN_PERMS] = array(MM_PERMS_WRITE, MM_PERMS_SUB, MM_PERMS_APPLY, MM_PERMS_READ, MM_PERMS_IS_USER, MM_PERMS_IS_GROUP, MM_PERMS_IS_RECYCLE_BIN, MM_PERMS_IS_RECYCLED);
  }
  elseif (!isset($params[MM_GET_TREE_RETURN_PERMS])) {
    $params[MM_GET_TREE_RETURN_PERMS] = array();
  }
  elseif (!is_array($params[MM_GET_TREE_RETURN_PERMS])) {
    $params[MM_GET_TREE_RETURN_PERMS] = array($params[MM_GET_TREE_RETURN_PERMS]);
  }
  $perms = array_flip($params[MM_GET_TREE_RETURN_PERMS]);

  if (!$is_node && empty($params[MM_GET_TREE_MMTID])) {
    watchdog('mm', 'mm_content_get_query() called without a node ID or MM tree ID.',
        array(), WATCHDOG_ERROR);
    return;
  }

  // TODO: fix for recursive where mmtid<0
  if (!$is_node && $params[MM_GET_TREE_DEPTH] == 0 && $params[MM_GET_TREE_MMTID] < 0) {
    // virtual user directory (A-Z)
    return 'SELECT 0 AS ' . MM_PERMS_WRITE . ', 0 AS ' . MM_PERMS_SUB . ', 0 AS ' . MM_PERMS_APPLY . ', 0 AS ' . MM_PERMS_READ . ', 1 AS ' . MM_PERMS_IS_USER . ', 0 AS ' . MM_PERMS_IS_GROUP . ', 0 AS ' . MM_PERMS_IS_RECYCLE_BIN . ', 0 AS ' . MM_PERMS_IS_RECYCLED;
  }

  $uid = $params[MM_GET_TREE_USER]->uid;

  $is_admin = $uid == 1;
  if (!isset($user_access[$uid])) {
    if (!function_exists('user_access')) {
      module_load_include('module', 'user');
    }

    foreach (array('administer all menus', 'administer all users', 'administer all groups', 'view all menus') as $access_mode) {
      if ($uid || substr($access_mode, 0, 4) == 'view') {
        $user_access[$uid][$access_mode] = user_access($access_mode, $params[MM_GET_TREE_USER]);
      }
      else {
        $user_access[$uid][$access_mode] = FALSE;
      }
    }
  }
  $is_admin |= $user_access[$uid]['administer all menus'];

  $outside_selects = array();
  if (isset($params[MM_GET_TREE_ADD_SELECT]))
    if (is_array($params[MM_GET_TREE_ADD_SELECT])) $outside_selects = $params[MM_GET_TREE_ADD_SELECT];
    else $outside_selects[] = $params[MM_GET_TREE_ADD_SELECT];

  if (isset($params[MM_GET_TREE_RETURN_NODE_COUNT]) && !empty($params[MM_GET_TREE_RETURN_NODE_COUNT])) {
    if (is_array($params[MM_GET_TREE_RETURN_NODE_COUNT])) $compare = " AND node.type IN ('" . join("', '", $params[MM_GET_TREE_RETURN_NODE_COUNT]) . "')";
    elseif (is_string($params[MM_GET_TREE_RETURN_NODE_COUNT])) $compare = " AND node.type = '" . $params[MM_GET_TREE_RETURN_NODE_COUNT] . "'";
    else $compare = '';
    $outside_selects[] = "(SELECT COUNT(DISTINCT n.nid) FROM {mm_node2tree} n INNER JOIN {node} node ON node.nid = n.nid WHERE n.mmtid = t.mmtid$compare) AS nodecount";
  }

  $outside_group_by = $node_selects = array();
  $outside_where = $params[MM_GET_TREE_WHERE];
  $inside_joins = $outside_joins = $outside_order_by = $anon_group = '';
  $inside_selects = $inside_group_by = array('i.mmtid');
  $having = '';
  $filter_dots = "(SUBSTR(name, 1, 1) <> '.' OR name IN('" . MM_ENTRY_NAME_GROUPS . "', '" . MM_ENTRY_NAME_USERS . "', '" . MM_ENTRY_NAME_VIRTUAL_GROUP . "'))";

  $inside_selects[] = 'i.container';
  $inside_group_by[] = 'i.container';
  $outside_group_by[] = 'o.container';

  if (!$is_node && (!$params[MM_GET_TREE_FILTER_GROUPS] || !$params[MM_GET_TREE_FILTER_USERS] || !$params[MM_GET_TREE_FILTER_NORMAL] || !$params[MM_GET_TREE_FILTER_BINS] || !$params[MM_GET_TREE_FILTER_DOTS])) {
    $havings = array();
    if ($params[MM_GET_TREE_FILTER_GROUPS]) {
      $perms[MM_PERMS_IS_GROUP] = 1;
      $havings[] = 'SUM(o.is_group) > 0';
    }

    if ($params[MM_GET_TREE_FILTER_NORMAL]) {
      $perms[MM_PERMS_IS_USER] = $perms[MM_PERMS_IS_GROUP] = 1;
      if ($params[MM_GET_TREE_FILTER_USERS] && !$params[MM_GET_TREE_FILTER_GROUPS]) {
        $havings[] = 'SUM(o.is_group) = 0';
      }
      else {
        $havings[] = 'SUM(o.is_user) = 0 AND SUM(o.is_group) = 0';
      }
    }
    elseif ($params[MM_GET_TREE_FILTER_USERS]) {
      $perms[MM_PERMS_IS_USER] = 1;
      $havings[] = 'SUM(o.is_user) > 0';
    }

    $having = join(' OR ', $havings);
    $condit = array();
    if (!$params[MM_GET_TREE_FILTER_DOTS]) {
      $condit[] = $filter_dots;
    }
    if (!$params[MM_GET_TREE_FILTER_BINS]) {
      $condit[] = 'SUM(o.is_recycled) = 0';
    }

    if (!$condit) {
      $having = ' HAVING ' . $having;
    }
    elseif ($having) {
      $having = ' HAVING (' . $having . ') AND ' . join(' AND ', $condit);
    }
    else {
      $having = ' HAVING ' . join(' AND ', $condit);
    }

    if (!$outside_group_by) {
      $outside_group_by[] = 'o.mmtid';
    }
  }

  if ($perms) {
    if ($uid) {
      if (!$is_admin) {
        $inside_joins .=
          'LEFT JOIN {mm_tree_access} a ON a.mmtid = i.mmtid ' .
          'LEFT JOIN {mm_group} g ON g.gid = a.gid ' .
          "LEFT JOIN {mm_virtual_group} v ON v.vgid = g.vgid AND v.uid = $uid ";
      }
    }
    elseif ($params[MM_GET_TREE_BIAS_ANON]) {
      $anon_group = 'SUM(o.is_group) = 0 AND ';
    }

    if ($is_admin) {
      foreach (array(MM_PERMS_WRITE, MM_PERMS_SUB, MM_PERMS_APPLY, MM_PERMS_READ) as $m) {
        if (isset($perms[$m])) {
          $outside_selects[$m] = "COUNT(*) > 0 AS $m";
        }
      }
      $outside_selects[] = '1 AS ' . MM_PERMS_ADMIN;
    }
    else {
      $outside_admin = array();
      if (!empty($user_access[$uid]['administer all groups'])) {
        $outside_admin[] = 'SUM(o.is_group) > 0';
      }
      if (!empty($user_access[$uid]['administer all users'])) {
        $outside_admin[] = 'SUM(o.is_user) > 0';
      }
      $outside_admin = count($outside_admin) ? join(' OR ', $outside_admin) . ' OR ' : $anon_group;

      foreach (array(MM_PERMS_WRITE, MM_PERMS_SUB, MM_PERMS_APPLY) as $m) {
        if (isset($perms[$m])) {
          if ($uid) {
            $mode_cmp = $m == MM_PERMS_WRITE ? "= '" . MM_PERMS_WRITE . "'" : "IN ('" . MM_PERMS_WRITE . "', '$m')";
            $not_anon = "a.mode $mode_cmp AND (v.uid = $uid OR g.vgid = 0 AND g.uid = $uid) OR i.uid = $uid OR ";
          }
          else $not_anon = '';  // ignore anon user when owner or in a group

          $outside_selects[$m] = "{$outside_admin}(SUM(o.container = o.mmtid AND o.can_$m) > 0" . ($user_access[$uid]['view all menus'] ? '' : ' AND COUNT(*) = SUM(o.can_r)') . ") AS $m";
          $mode_cmp = "LOCATE('" . MM_PERMS_WRITE . "', i.default_mode) > 0";
          if ($m != MM_PERMS_WRITE) $mode_cmp .= " OR LOCATE('$m', i.default_mode) > 0";
          $inside_selects[$m] = "SUM($not_anon$mode_cmp) > 0 AS can_$m";
          $node_selects[] = "SUM($m) > 0 AS $m";
        }
      }

      if (isset($perms[MM_PERMS_READ])) {
        if ($user_access[$uid]['view all menus']) {
          $outside_selects[] = "SUM(o.is_recycled) = 0 AND (SUM(o.is_group) = 0 AND COUNT(*) > 0 OR COUNT(*) = SUM(o.can_r)) AS r";
        }
        elseif ($is_node) {
          $outside_selects[] = "{$outside_admin}COUNT(o.container = o.mmtid) = SUM(o.can_r) AS r";
        }
        else {
          $outside_selects[] = "{$outside_admin}IF(SUM(o.is_group), SUM(o.container = o.mmtid AND o.can_m) > 0, COUNT(o.container = o.mmtid) = SUM(o.can_r)) AS r";
        }
        $node_selects[] = "SUM(r) > 0 AS r";
      }

      $not_anon = $uid ? "(v.uid = $uid OR g.vgid = 0 AND g.uid = $uid) OR i.uid = $uid OR " : '';
      if ($params[MM_GET_TREE_FAKE_READ_BINS]) {
        $not_anon .= "i.name = '" . MM_ENTRY_NAME_RECYCLE . "' OR ";
      }
      $inside_selects[] = "SUM({$not_anon}i.default_mode <> '') > 0 AS can_r";

      if (!$is_node) {
        $not_anon = $uid ? "a.mode IN ('" . MM_PERMS_WRITE . "', '" . MM_PERMS_SUB . "', '" . MM_PERMS_READ . "') AND (v.uid = $uid OR g.vgid = 0 AND g.uid = $uid) OR i.uid = $uid OR " : '';
        $inside_selects[] = "SUM({$not_anon}LOCATE('" . MM_PERMS_WRITE . "', i.default_mode) > 0 OR LOCATE('" . MM_PERMS_SUB . "', i.default_mode) > 0 OR LOCATE('" . MM_PERMS_READ . "', i.default_mode) > 0) > 0 AS can_m";
      }
    }

    if (isset($perms[MM_PERMS_IS_USER]) || $user_access[$uid]['administer all users']) {
      $inside_selects[] = 'i.mmtid = ' . mm_content_users_mmtid() . ' AS is_user';
      if (isset($perms[MM_PERMS_IS_USER]) && !$is_node) {
        $outside_selects[] = 'SUM(o.is_user) > 0 AS ' . MM_PERMS_IS_USER;
      }
    }

    if (isset($perms[MM_PERMS_IS_GROUP]) || !empty($anon_group) || $user_access[$uid]['administer all groups'] || $user_access[$uid]['view all menus']) {
      $inside_selects[] = 'i.mmtid = ' . mm_content_groups_mmtid() . ' AS is_group';
      if (isset($perms[MM_PERMS_IS_GROUP]) && !$is_node) {
        $outside_selects[] = empty($anon_group) ? 'SUM(o.is_group) > 0 AS ' . MM_PERMS_IS_GROUP : '0 AS ' . MM_PERMS_IS_GROUP;
      }
    }

    if (isset($perms[MM_PERMS_IS_RECYCLE_BIN])) {
      $inside_selects[] = "i.mmtid = i.container AND i.name = '" . MM_ENTRY_NAME_RECYCLE . "' AS is_recycle_bin";
      $outside_selects[] = "SUM(o.container = o.mmtid AND o.is_recycle_bin) > 0 AS " . MM_PERMS_IS_RECYCLE_BIN;
      $node_selects[] = 'SUM(' . MM_PERMS_IS_RECYCLE_BIN . ') AS ' . MM_PERMS_IS_RECYCLE_BIN;
    }

    if (isset($perms[MM_PERMS_IS_RECYCLED]) || $params[MM_GET_TREE_RETURN_BINS] || $user_access[$uid]['view all menus'] || !$params[MM_GET_TREE_FILTER_BINS]) {
      $inside_selects[] = "SUM(i.name = '" . MM_ENTRY_NAME_RECYCLE . "') AS is_recycled";
      if (isset($perms[MM_PERMS_IS_RECYCLED]) || !$params[MM_GET_TREE_FILTER_BINS]) {
        $outside_selects[] = 'SUM(o.is_recycled) > 0 AS ' . MM_PERMS_IS_RECYCLED;
        $node_selects[] = 'SUM(' . MM_PERMS_IS_RECYCLED . ') AS ' . MM_PERMS_IS_RECYCLED;
      }

      if ($params[MM_GET_TREE_RETURN_BINS]) {
        $inside_selects[] = "IF(i.name = '" . MM_ENTRY_NAME_RECYCLE . "', i.mmtid, NULL) AS recycle_bins";
        $outside_selects[] = 'GROUP_CONCAT(o.recycle_bins ORDER BY o.recycle_bins) AS recycle_bins';
        $node_selects[] = 'GROUP_CONCAT(recycle_bins) AS recycle_bins';
      }
    }
  }   // if ($perms)

  if ($is_node) {
    $i =
      'SELECT t.mmtid, t.default_mode, t.uid, t.name, n2.mmtid AS container ' .
        'FROM {mm_tree_parents} p ' .
          'LEFT JOIN {mm_tree} t ON t.mmtid = p.parent ' .
          'INNER JOIN {mm_node2tree} n2 ON n2.mmtid = p.mmtid ' .
        'WHERE n2.nid = ' . $params[MM_GET_TREE_NODE]->nid . ' ' .
      'UNION SELECT t.mmtid, t.default_mode, t.uid, t.name, n2.mmtid AS container ' .
        'FROM {mm_tree} t ' .
          'LEFT JOIN {mm_node2tree} n2 ON n2.mmtid = t.mmtid ' .
        'WHERE n2.nid = ' . $params[MM_GET_TREE_NODE]->nid;
  }
  else {
    if ($params[MM_GET_TREE_RETURN_TREE] || $params[MM_GET_TREE_DEPTH] || $params[MM_GET_TREE_RETURN_MTIME]) {
      if ($params[MM_GET_TREE_RETURN_TREE]) {
        $outside_selects[] = 't.*';
      }

      if ($params[MM_GET_TREE_DEPTH] && $params[MM_GET_TREE_SORT]) {
        $outside_order_by = ' ORDER BY sort_idx';
      }

      if ($perms || $params[MM_GET_TREE_DEPTH] || $params[MM_GET_TREE_RETURN_MTIME]) {
        $outside_joins .= " INNER JOIN {mm_tree} t ON t.mmtid = o.container";
      }
    }

    if ($params[MM_GET_TREE_RETURN_FLAGS]) {
      $outside_selects[] = "(SELECT GROUP_CONCAT(CONCAT_WS('|1', flag, data) SEPARATOR '|2') FROM {mm_tree_flags} WHERE mmtid = o.container) AS flags";
    }

    if ($params[MM_GET_TREE_RETURN_MTIME]) {
      $outside_selects[] = 'tr.muid, tr.mtime';
      $outside_joins .= ' LEFT JOIN {mm_tree_revisions} tr ON tr.vid = t.vid';
    }

    if ($params[MM_GET_TREE_RETURN_BLOCK]) {
      $outside_selects[] = 'b.bid, b.max_depth, b.max_parents';
      $outside_joins .= " LEFT JOIN {mm_tree_block} b ON b.mmtid = o.container";
    }

    if ($params[MM_GET_TREE_RETURN_KID_COUNT]) {
      $condit = array();
      if (!$params[MM_GET_TREE_FILTER_BINS]) {
        $condit[] = "name <> '" . MM_ENTRY_NAME_RECYCLE . "'";
      }
      if (!$params[MM_GET_TREE_FILTER_DOTS]) {
        $condit[] = $filter_dots;
      }

      if ($condit) {
        $outside_selects[] = "(SELECT COUNT(*) FROM {mm_tree} WHERE parent = o.container AND " . join(' AND ', $condit) . ") AS kids";
      }
      else {
        $outside_selects[] = "(SELECT COUNT(*) FROM {mm_tree} WHERE parent = o.container) AS kids";
      }
    }

    switch ($params[MM_GET_TREE_DEPTH]) {
      case -1:
        $i =
          // the item
          'SELECT mmtid AS container, mmtid, default_mode, uid, name ' .
            'FROM {mm_tree} ' .
            'WHERE mmtid = ' . $params[MM_GET_TREE_MMTID] . ' ' .
          // the item's children
          'UNION SELECT p.mmtid, t.mmtid, t.default_mode, t.uid, t.name ' .
            'FROM {mm_tree_parents} p ' .
              'INNER JOIN {mm_tree} t ON t.mmtid = p.mmtid ' .
            'WHERE p.parent = ' . $params[MM_GET_TREE_MMTID];
        if ($perms) {
          $i .= ' ' .
          // the item's parents
          'UNION SELECT p.mmtid, t.mmtid, t.default_mode, t.uid, t.name ' .
            'FROM {mm_tree_parents} p ' .
              'INNER JOIN {mm_tree} t ON t.mmtid = p.parent ' .
            'WHERE p.mmtid = ' . $params[MM_GET_TREE_MMTID] . ' ' .
          // its children's parents
          'UNION SELECT p0.mmtid, t.mmtid, t.default_mode, t.uid, t.name ' .
            'FROM {mm_tree_parents} p0 ' .
              'INNER JOIN {mm_tree_parents} p1 ON p1.mmtid = p0.mmtid ' .
              'INNER JOIN {mm_tree} t ON t.mmtid = p1.parent ' .
            'WHERE p0.parent = ' . $params[MM_GET_TREE_MMTID];
        }
        break;

      case 0:
        if (!$perms) {
          return
            'SELECT ' . join(', ', $outside_selects) . ' FROM {mm_tree} t' .
            $outside_joins .
            (empty($params[MM_GET_TREE_WHERE]) ? '' : ' WHERE ' . $params[MM_GET_TREE_WHERE]);
        }

        $i =
          // the item
          'SELECT mmtid AS container, mmtid, default_mode, uid, name ' .
            'FROM {mm_tree} ' .
            'WHERE mmtid = ' . $params[MM_GET_TREE_MMTID] . ' ' .
          // its parents
          'UNION SELECT p.mmtid, t.mmtid, t.default_mode, t.uid, t.name ' .
            'FROM {mm_tree_parents} p ' .
              'INNER JOIN {mm_tree} t ON t.mmtid = p.parent ' .
            'WHERE p.mmtid = ' . $params[MM_GET_TREE_MMTID];
        break;

      case 1:
        $i =
          // the item
          'SELECT t.mmtid AS container, t.mmtid, t.default_mode, t.uid, t.name ' .
            'FROM {mm_tree} t ' .
            'WHERE t.mmtid = ' . $params[MM_GET_TREE_MMTID] . ' ' .
          // the item's immediate children
          'UNION SELECT t.mmtid AS container, t.mmtid, t.default_mode, t.uid, t.name ' .
            'FROM {mm_tree} t ' .
            'WHERE t.parent = ' . $params[MM_GET_TREE_MMTID] . $params[MM_GET_TREE_INNER_FILTER];
        if ($perms) {
          $i .= ' ' .
          // the item's parents
          'UNION SELECT p.mmtid, t.mmtid, t.default_mode, t.uid, t.name ' .
            'FROM {mm_tree_parents} p ' .
              'INNER JOIN {mm_tree} t ON t.mmtid = p.parent ' .
            'WHERE p.mmtid = ' . $params[MM_GET_TREE_MMTID] . ' ' .
          // its immediate children's parents
          'UNION SELECT t.mmtid, t2.mmtid, t2.default_mode, t2.uid, t2.name ' .
            'FROM {mm_tree} t ' .
            'INNER JOIN {mm_tree_parents} p ON t.mmtid = p.mmtid ' .
            'INNER JOIN {mm_tree} t2 ON t2.mmtid = p.parent ' .
            'WHERE t.parent = ' . $params[MM_GET_TREE_MMTID] . $params[MM_GET_TREE_INNER_FILTER];
        }
        break;

      default:
        $select = db_select('mm_tree_parents', 'p');
        $select->addExpression('MAX(p.depth)', 'depth');
        $select->condition('p.mmtid', $params[MM_GET_TREE_MMTID]);
        $depth = $select->execute()->fetchField() + $params[MM_GET_TREE_DEPTH] + 1;

        $i =
          'SELECT x.container, t.mmtid, t.default_mode, t.uid, t.name ' .
            'FROM (' .
              'SELECT p0.mmtid AS container, p1.parent AS mmtid ' .
                'FROM (' .
                  'SELECT p0.mmtid ' .
                    'FROM {mm_tree_parents} p0 ' .
                    'INNER JOIN {mm_tree_parents} p1 ON p1.mmtid = p0.mmtid ' .
                    'WHERE p0.parent = ' . $params[MM_GET_TREE_MMTID] . ' ' .
                    'GROUP BY p0.mmtid HAVING MAX(p1.depth) < ' . $depth .
                ') p0 ' .
                'INNER JOIN {mm_tree_parents} p1 ON p1.mmtid = p0.mmtid ' .
              'UNION (' .
                'SELECT p0.mmtid, p0.mmtid ' .
                  'FROM {mm_tree_parents} p0 ' .
                  'INNER JOIN {mm_tree_parents} p1 ON p1.mmtid = p0.mmtid ' .
                  'WHERE p0.parent = ' . $params[MM_GET_TREE_MMTID] . ' ' .
                  'GROUP BY p0.mmtid HAVING MAX(p1.depth) < ' . $depth .
              ') ' .
              'UNION SELECT ' . $params[MM_GET_TREE_MMTID] . ', parent ' .
                'FROM {mm_tree_parents} ' .
                'WHERE mmtid = ' . $params[MM_GET_TREE_MMTID] . ' ' .
              'UNION SELECT ' . $params[MM_GET_TREE_MMTID] . ', ' . $params[MM_GET_TREE_MMTID] .
            ') AS x ' .
            'INNER JOIN {mm_tree} t ON t.mmtid = x.mmtid';
        break;
    }
  }

  // Note: Always use ORDER BY NULL instead of GROUP BY without ORDER BY, as
  // this is slightly faster.
  $query =
    'SELECT ' . join(', ', $outside_selects) . ' FROM (' .
      'SELECT ' . join(', ', $inside_selects) . ' ' .
      'FROM (' .
        $i .
      ') AS i ' .
      $inside_joins .
      'GROUP BY ' . join(', ', $inside_group_by) . ' ' .
      'ORDER BY NULL' .
    ') AS o' .
    $outside_joins .
    (empty($outside_where) ? '' : ' WHERE ' . $outside_where) .
    ($outside_group_by ? ' GROUP BY ' . join(', ', $outside_group_by) . $having : '') .
    ($outside_order_by ? $outside_order_by : ($outside_group_by ? ' ORDER BY NULL' : ''));

  if ($is_node && $node_selects && !$is_admin) {
    return 'SELECT ' . join(', ', $node_selects) . " FROM ($query) q";
  }

  return $query;
}

/**
 * Clear one element of the caches used by various functions, or completely
 * clear all caches.
 *
 * @param $mmtid
 *   If set, delete just the cached user_can data for this tree ID or array of
 *   tree IDs. Otherwise, clear the whole cache.
 */
function mm_content_clear_caches($mmtid = NULL) {
  $_mmtbt_cache = &drupal_static('_mmtbt_cache', array());
  $_mmgp_cache = &drupal_static('_mmgp_cache', array());
  $_mmuc_cache = &drupal_static('_mmuc_cache', array());
  $_mmucr_cache = &drupal_static('_mmucr_cache', array());
  $_mmcucn_cache = &drupal_static('_mmcucn_cache');
  $_mm_custom_url_rewrite_outbound_cache = &drupal_static('_mm_custom_url_rewrite_outbound_cache');

  if (isset($mmtid)) {
    if (is_array($mmtid)) {
      $flipped = array_flip($mmtid);
      $_mmuc_cache = array_diff_key($_mmuc_cache, $flipped);
      $_mmucr_cache = array_diff_key($_mmucr_cache, $flipped);
      $_mmtbt_cache = array_diff_key($_mmtbt_cache, $flipped);
      $_mmgp_cache = array_diff_key($_mmgp_cache, $flipped);
    }
    else {
      unset($_mmuc_cache[$mmtid]);
      unset($_mmucr_cache[$mmtid]);
      unset($_mmtbt_cache[$mmtid]);
      unset($_mmgp_cache[$mmtid]);
    }
    _mm_content_clear_access_cache($mmtid);
  }
  else {
    $_mmuc_cache = $_mmucr_cache = $_mmtbt_cache = $_mmgp_cache = array();
  }
  // Always clear arrays not indexed by mmtid
  $_mmcucn_cache = $_mm_custom_url_rewrite_outbound_cache = array();
}

/**
 * Queue mm_tree entries that have changed, or update the sort index for all
 * queued entries.
 *
 * If neither $parent nor $child is set, perform all queued updates. This
 * usually happens during monster_menus_exit().
 *
 * @param $parent
 *   If set, queue this portion of the tree for future update; this should be
 *   the parent term ID of the entry that has changed. If the parent is not
 *   known, use NULL and specify a value in $child, instead.
 * @param $child
 *   Instead of using $parent, a $child can be specified. In this case, the
 *   parent is queried in an additional step, so this method should be avoided
 *   when possible.
 * @param $all
 *   If TRUE, update all entries, not just the dirty ones; this is generally
 *   only done the very first time the sort index is generated.
 */
function mm_content_update_sort_queue($parent = NULL, $child = NULL, $all = FALSE) {
  static $drupal_static_fast;
  $_mm_content_defer_sort_index_update = &drupal_static('_mm_content_defer_sort_index_update');

  if (!isset($drupal_static_fast)) {
    // This is cumbersome, but assigning to an array is the only way that works.
    $drupal_static_fast['q'] = &drupal_static(__FUNCTION__, array());
  }
  $queue = &$drupal_static_fast['q'];

  if (empty($parent) && !empty($child)) {
    $parent = mm_content_get_parent($child);
    if (empty($parent)) {
      return;
    }
  }

  if (!empty($parent)) {
    if (isset($queue[$parent])) {
      $queue[$parent] |= $all;
    }
    else {
      $queue[$parent] = $all;
    }
  }
  elseif ($queue) {
    if (!empty($_mm_content_defer_sort_index_update)) {
      return;
    }

    $uniq = array_unique($queue);
    if (count($uniq) == 1 && !$uniq[mm_ui_mmlist_key0($uniq)]) {
      mm_content_update_sort(array_keys($queue), FALSE);
    }
    else {
      foreach ($queue as $parent => $all) {
        mm_content_update_sort($parent, $all);
      }
    }
    $queue = array();
  }
}

/**
 * Update the mm_tree column containing the sort index.
 *
 * @param $mmtid
 *   Point from which to update entries downward in the tree. Can be an array
 *   of values when $all is FALSE.
 * @param $all
 *   If TRUE, update all entries, not just the dirty ones; this is generally
 *   only done the very first time the sort index is generated.
 */
function mm_content_update_sort($mmtid = 1, $all = TRUE) {
  if ($all) {
    if (!function_exists('__mm_content_update_sort_all')) {
      function __mm_content_update_sort_all($sort_idx, $mmtid) {
        $order = 0;
        $select = db_select('mm_tree', 't');
        $select->addField('t', 'mmtid');
        $select->addExpression('IF(hidden, 1, IF(name = :name, 2, 0))', 'sort_column', array(':name' => MM_ENTRY_NAME_RECYCLE));
        $select->condition('t.parent', $mmtid);
        $select->orderBy('sort_column')
          ->orderBy('weight')
          ->orderBy('name');
        $result = $select->execute();
        foreach ($result as $r) {
          $new_idx = $sort_idx . _mm_content_btoa($order++);
          _mm_content_test_sort_length($new_idx, $r->mmtid, TRUE);
          db_update('mm_tree')
            ->fields(array('sort_idx' => $new_idx, 'sort_idx_dirty' => 0))
            ->condition('mmtid', $r->mmtid)
            ->execute();
          __mm_content_update_sort_all($new_idx, $r->mmtid);
          if (drupal_is_cli() && !function_exists('drush_log')) {
            // From commandline, without drush
            print $r->mmtid . ' ' . $new_idx . "\n";
          }
        }
      }
    }

    if ($mmtid <= 1) {
      $mmtid = 1;
      $sort_idx = '';
      db_update('mm_tree')
        ->fields(array('sort_idx' => $sort_idx, 'sort_idx_dirty' => 0))
        ->condition('mmtid', $mmtid)
        ->execute();
    }
    else {
      $sort_idx = db_select('mm_tree', 't')
        ->fields('t', array('sort_idx'))
        ->condition('t.mmtid', $mmtid)
        ->execute()->fetchField();
    }
    __mm_content_update_sort_all($sort_idx, $mmtid);
  }
  else {
    for ($last = -1;;) {
      $in = is_array($mmtid) ? 'IN (:mmtid)' : '= :mmtid';
      $parent_q = db_query_range(
        'SELECT t.parent, t.sort_idx, t.mmtid ' .
          'FROM {mm_tree} t ' .
          'INNER JOIN {mm_tree_parents} p ON p.mmtid = t.mmtid ' .
        "WHERE t.sort_idx_dirty = 1 AND p.parent $in " .
        'GROUP BY NULL ' .
        'ORDER BY LENGTH(t.sort_idx) DESC',
        0, 1, array(':mmtid' => $mmtid)
      );
      if ($parent = $parent_q->fetchObject()) {
        // Prevent the outer for loop from running amok if there is a DB error
        if ($parent->mmtid == $last) {
          break;
        }
        $last = $parent->mmtid;
        $sort_idx = substr_replace($parent->sort_idx, '', -MM_CONTENT_BTOA_CHARS);
        $sort_len = strlen($sort_idx);
        $order = 0;
        $quick = array();

        $select = db_select('mm_tree', 't');
        $select->fields('t', array('mmtid', 'sort_idx', 'sort_idx_dirty'));
        $select->addExpression(
          'IF(t.hidden, :hidden_weight, IF(name = :recycle_name, :recycle_weight, :normal_weight))',
          'sort_group',
          array(
            ':hidden_weight' => 1,
            ':recycle_name' => MM_ENTRY_NAME_RECYCLE,
            ':recycle_weight' => 2,
            ':normal_weight' => 0
          )
        );
        $select->condition('t.parent', $parent->parent);
        $select->orderBy('sort_group')
          ->orderBy('t.weight')
          ->orderBy('t.name');

        $result = $select->execute();
        foreach ($result as $r) {
          $new_idx = _mm_content_btoa($order++);
          if ($new_idx != substr($r->sort_idx, -MM_CONTENT_BTOA_CHARS)) {
            db_query(
              'UPDATE {mm_tree} t ' .
              'INNER JOIN {mm_tree_parents} p ON p.mmtid = t.mmtid ' .
              'SET t.sort_idx = CONCAT(' .
                  'SUBSTRING(t.sort_idx, :sort_start, :sort_len), :new_idx, SUBSTRING(t.sort_idx, :my_idx)' .
                '), t.sort_idx_dirty = :dirty ' .
              'WHERE p.parent = :mmtid OR t.mmtid = :mmtid',
              array(
                ':sort_start' => 1,
                ':sort_len' => $sort_len,
                ':new_idx' => $new_idx,
                ':my_idx' => $sort_len + MM_CONTENT_BTOA_CHARS + 1,
                ':dirty' => 0,
                ':mmtid' => $r->mmtid,
              )
            );
          }
          elseif ($r->sort_idx_dirty) {
            $quick[] = $r->mmtid;
          }
        }

        if ($quick) {
          db_update('mm_tree')
            ->fields(array('sort_idx_dirty' => 0))
            ->condition('mmtid', $quick)
            ->execute();
        }
      }
      else {
        break;
      }
    }
  }
}

/**
 * Decode a 32-bit word represented by four ASCII characters, derived from the
 * number's base-64 equivalent. This is the inverse of _mm_content_btoa().
 *
 * @param $str
 *   The string containing the encoded integer
 * @return
 *   The resulting integer
 */
function _mm_content_atob($str) {
  $out = 0;
  while (!empty($str) || $str === '0') {
    $out = $out * MM_CONTENT_BTOA_BASE + ord($str[0]) - MM_CONTENT_BTOA_START;
    $str = substr($str, 1);
  }
  return $out;
}

/**
 * Encode a 32-bit word using four ASCII characters, derived from the number's
 * base-64 equivalent. This produces a sequence that is suitable for sorting in
 * SQL, without sacrificing too much space. A larger base cannot be used without
 * the possibility of causing case-insensitive sorting errors.
 *
 * @param $uword
 *   The unsigned word to encode
 * @return
 *   The word, encoded in a string
 */
function _mm_content_btoa($uword) {
  static $pows, $max;

  if (!isset($pows)) {
    $max = (int) pow(MM_CONTENT_BTOA_BASE, MM_CONTENT_BTOA_CHARS);
    $pows = array();
    for ($i = 1; $i < MM_CONTENT_BTOA_CHARS; $i++) {
      array_unshift($pows, (int) pow(MM_CONTENT_BTOA_BASE, $i));
    }
  }

  if ($uword < 0 || $uword >= $max) {
    die('Range error');
  }

  $out = '';
  foreach ($pows as $pow) {
    $out .= chr(MM_CONTENT_BTOA_START + $uword / $pow);
    // The % operator doesn't work correctly, here
    $uword = $uword - intval($uword / $pow) * $pow;
  }
  $out .= chr(MM_CONTENT_BTOA_START + $uword);
  return $out;
}

/**
 * Automatically empty all recycle bins of content that has been there for more
 * than a set time. Run as uid=1 during monster_menus_cron().
 *
 * @param $limit
 *   The maximum number of nodes/pages to delete
 */
function mm_content_empty_all_bins($limit = 0) {
  if (($empty = variable_get('mm_recycle_auto_empty', 0)) > 0) {
    $query = db_select('mm_recycle', 'rc')
      ->fields('rc')
      ->condition('rc.recycle_date', REQUEST_TIME - $empty, '<');
    if ($limit > 0) {
      $query->range(0, $limit);
    }
    $result = $query->execute();

    $bins = $nodes = array();
    foreach ($result as $r) {
      if ($r->type == 'node') {
        if (empty($nodes[$r->id])) {
          watchdog('mm', "Automatically emptying nid=$r->id from recycle bin");
          node_delete($r->id);
          // It's remotely possible for a node to be left over in mm_recycle,
          // even though it has already been deleted. In this case MM's deletion
          // code isn't called during node_delete(), so call it (again) now.
          $node = (object)array('nid' => $r->id);
          monster_menus_node_delete($node);
          $nodes[$r->id] = TRUE;
        }
      }
      elseif ($r->type == 'cat') {
        watchdog('mm', "Automatically deleting mmtid=$r->id from recycle bin");
        mm_content_delete($r->id, TRUE);
      }
      $bins[$r->bin_mmtid] = 1;
    }

    foreach (array_keys($bins) as $bin) {
      mm_content_delete_bin($bin);
    }
  }
}

/**
 * Figure out if a given user can access a particular node. When a node belongs
 * to more than one entry, logically OR the permissions for all entries.
 *
 * @param $node
 *   The node object or node number being queried
 * @param $mode
 *   If set, return whether or not the user can perform that action
 *   (MM_PERMS_READ, MM_PERMS_WRITE, MM_PERMS_SUB, MM_PERMS_APPLY). Otherwise,
 *   return an array containing each of these elements with either TRUE or FALSE
 *   values.
 * @param $account
 *   User object of user to test against. Defaults to the current user.
 * @return
 *   See above
 */
function mm_content_user_can_node($node, $mode = '', $account = NULL) {
  global $user;
  static $recursive = FALSE;
  $_mmcucn_cache = &drupal_static('_mmcucn_cache');

  $perms = array(
    MM_PERMS_WRITE => FALSE,
    MM_PERMS_SUB   => FALSE,
    MM_PERMS_APPLY => FALSE,
    MM_PERMS_READ  => FALSE
  );

  // There's a chance that the calls to mm_content_node_access() below can lead
  // to a recursive call to this function.
  if ($recursive) {
    if (empty($mode)) {
      return $perms;
    }
    return FALSE;
  }
  $recursive = TRUE;

  if (is_object($node)) {
    $nid = $node->nid;
  }
  else {
    $nid = $node;
    $node = (object)array('nid' => $nid);
  }

  $uid = isset($account) ? $account->uid : $user->uid;
  if (!isset($_mmcucn_cache[$nid][$uid])) {
    $cid = ":$nid:$uid";
    $cached = _mm_content_access_cache($cid);
    if (is_array($cached)) {
      $_mmcucn_cache[$nid][$uid] = $cached;
    }
    else {
      $params = array(
        MM_GET_TREE_FAKE_READ_BINS => TRUE,
        MM_GET_TREE_NODE           => $node,
        MM_GET_TREE_RETURN_BINS    => TRUE,
        MM_GET_TREE_RETURN_PERMS   => array(MM_PERMS_WRITE, MM_PERMS_SUB, MM_PERMS_APPLY, MM_PERMS_READ, MM_PERMS_IS_RECYCLE_BIN),
        MM_GET_TREE_USER           => isset($account) ? $account : $user,
      );
      $row = db_query(mm_content_get_query($params))->fetchObject();
      if ($row) {
        foreach ((array)$row as $key => $val) {
          if (strlen($key) == 1) {
            $perms[$key] = $val != 0;
          }
        }

        // mm_content_get_query() only considers the permissions of the page, so
        // now consider the node itself.
        if ($perms[MM_PERMS_READ]) {
          $has_page_write = $perms[MM_PERMS_WRITE];
          $perms[MM_PERMS_WRITE] = mm_content_node_access($node, 'update', $account);
        }

        if (isset($row->recycle_bins)) {
          $bins = explode(',', $row->recycle_bins);
          if ($row->{MM_PERMS_IS_RECYCLE_BIN}) {
            // Node is in a bin and possibly outside at the same time: if user
            // can access it in any bin, allow it here.
            $perms[MM_PERMS_APPLY] = TRUE;
            if (!$perms[MM_PERMS_READ]) {
              foreach ($bins as $bin) {
                if ($perms[MM_PERMS_READ] = mm_content_user_can_recycle($bin, MM_PERMS_READ, $account)) {
                  break;
                }
              }
            }
          }
          else {
            // Containing page is in one or more bins: only allow read access if
            // the user can access all containing pages.
            if ($perms[MM_PERMS_READ]) {
              foreach ($bins as $bin) {
                if (!($perms[MM_PERMS_READ] = mm_content_user_can_recycle($bin, MM_PERMS_READ, $account))) {
                  break;
                }
              }
            }
          }
        }
      }
      else {
        // not assigned to any pages
        $perms[MM_PERMS_READ] = $perms[MM_PERMS_APPLY] = TRUE;
      }

      // If the user does not have write permission, consider the appearance schedule
      if (empty($has_page_write) && !$perms[MM_PERMS_WRITE] && !mm_content_node_access($node, 'update', $account)) {
        $scheduled = (!isset($node->status) || $node->status) && (!isset($node->publish_on) || $node->publish_on == 0 || $node->publish_on <= REQUEST_TIME) && (!isset($node->unpublish_on) || $node->unpublish_on == 0 || REQUEST_TIME < $node->unpublish_on);
        $perms[MM_PERMS_READ] = $perms[MM_PERMS_READ] && $scheduled;  // must use logical && to preserve boolean type
      }
      $_mmcucn_cache[$nid][$uid] = $perms;
      // Don't bother trying to figure out cache intervals when
      // publish/unpublish is used.
      if (empty($node->publish_on) && empty($node->unpublish_on)) {
        _mm_content_access_cache($cid, $perms, $uid, $nid, 0);
      }
    }
  }

  $recursive = FALSE;
  if (empty($mode)) {
    return $_mmcucn_cache[$nid][$uid];
  }
  return $_mmcucn_cache[$nid][$uid][$mode];
}

/**
 * Delete an entry and all of its children
 *
 * @param $mmtid
 *   ID of the entry to delete
 * @param $nodes
 *   If TRUE, also delete any nodes using these IDs (FALSE)
 * @param $allow_non_empty_bin
 *   If TRUE, allow a non-empty recycle bin at the top level to be deleted (FALSE)
 * @return
 *   An error message, if an error occurs
 */
function mm_content_delete($mmtid, $nodes = TRUE, $allow_non_empty_bin = FALSE) {
  $tree = mm_content_get_tree($mmtid, array(MM_GET_TREE_RETURN_PERMS => TRUE));
  if (!$tree) {
    return t('Page not found');
  }

  if (!$allow_non_empty_bin && $tree[0]->name == MM_ENTRY_NAME_RECYCLE && count($tree) > 1) {
    return t('This is a recycle bin that is not empty.');
  }

  $mmtids = $nids = $bins = array();
  foreach ($tree as $t) {
    if (!$t->perms[MM_PERMS_WRITE] && $t->name != MM_ENTRY_NAME_RECYCLE) {
      $msg = $t->mmtid == $mmtid ?
        'You do not have permission to delete the page %name' :
        'You cannot delete this page because you do not have permission to delete the sub-page %name';
      return t($msg, array('%name' => $t->name));
    }
    $mmtids[] = $t->mmtid;
    if ($t->name == MM_ENTRY_NAME_RECYCLE) {
      $bins[] = $t->mmtid;
    }
  }

  $vgroup = mm_content_is_vgroup($mmtid);
  // Start a transaction.
  $txn = db_transaction();

  if ($nodes) {
    foreach (node_load_multiple(mm_content_get_nids_by_mmtid($mmtids, 0, TRUE)) as $node) {
      if (node_access('delete', $node)) {
        $nids[] = $node->nid;
      }
    }
  }
  if (!empty($nids)) {
    node_delete_multiple($nids);
  }

  if ($bins) {
    db_delete('mm_tree_revisions')
      ->condition('mmtid', $bins)
      ->execute();
  }

  db_delete('mm_tree')
    ->condition('mmtid', $mmtids)
    ->execute();
  db_delete('mm_tree_flags')
    ->condition('mmtid', $mmtids)
    ->execute();
  db_delete('mm_tree_parents')
    ->condition(db_or()
      ->condition('mmtid', $mmtids)
      ->condition('parent', $mmtids)
    )
    ->execute();
  db_delete('mm_node2tree')
    ->condition('mmtid', $mmtids)
    ->execute();
  // Clear the cache used by mm_content_get_by_nid.
  mm_content_get_by_nid(NULL, TRUE);
  db_delete('mm_tree_block')
    ->condition('mmtid', $mmtids)
    ->execute();
  db_delete('mm_node_reorder')
    ->condition('mmtid', $mmtids)
    ->execute();
  db_delete('mm_archive')
    ->condition(db_or()
      ->condition('main_mmtid', $mmtids)
      ->condition('archive_mmtid', $mmtids)
    )
    ->execute();
  db_delete('mm_recycle')
    ->condition('type', 'cat')
    ->condition('id', $mmtids)
    ->execute();
  db_delete('mm_recycle')
    ->condition('type', 'node')
    ->condition('bin_mmtid', $mmtids)
    ->execute();
  db_update('mm_recycle')
    ->fields(array('from_mmtid' => 0))
    ->condition('type', 'node')
    ->condition('from_mmtid', $mmtids)
    ->execute();

  // remove ad-hoc groups (gid<0) first
  // DELETE FROM {mm_group} WHERE
  //   (SELECT 1 FROM {mm_tree_access} a WHERE a.gid = {mm_group}.gid
  //     AND a.mmtid IN(:mmtids) AND a.gid < 0)
  $adhoc = db_select('mm_tree_access', 'a');
  $adhoc->addExpression(1);
  $adhoc->where('a.gid = {mm_group}.gid')
    ->condition('a.mmtid', $mmtids)
    ->condition('a.gid', 0, '<');
  db_delete('mm_group')
    ->condition($adhoc)
    ->execute();

  // remove virtual groups; mm_virtual_group is cleaned up automatically in cron
  // DELETE FROM {mm_vgroup_query} WHERE
  //   (SELECT 1 FROM {mm_group} g WHERE g.vgid = {mm_vgroup_query}.vgid
  //     AND g.gid IN(:mmtids))
  $mm_group = db_select('mm_group', 'g');
  $mm_group->addExpression(1);
  $mm_group->where('g.vgid = {mm_vgroup_query}.vgid')
    ->condition('g.gid', $mmtids);
  db_delete('mm_vgroup_query')
    ->condition($mm_group)
    ->execute();

  // remove remaining groups
  db_delete('mm_tree_access')
    ->condition(db_or()
      ->condition('mmtid', $mmtids)
      ->condition('gid', $mmtids)
    )
    ->execute();
  db_delete('mm_group')
    ->condition('gid', $mmtids)
    ->execute();
  db_delete('mm_node_write')
    ->condition('gid', $mmtids)
    ->execute();
  db_delete('mm_node_redir')
    ->condition('mmtid', $mmtids)
    ->execute();
  db_delete('mm_cascaded_settings')
    ->condition('mmtid', $mmtids)
    ->execute();
  db_delete('mm_role2group')
    ->condition('gid', $mmtids)
    ->execute();

  if ($vgroup) {
    foreach ($mmtids as $mmtid) {
      mm_content_update_vgroup_view($mmtid);
    }
  }

  // check for mm_delete hooks
  module_invoke_all('mm_delete', $mmtids, $nids);

  // End transaction.
  unset($txn);

  if ($mmtids) {
    mm_content_notify_change('delete_page', $mmtids);
  }
  if ($nids) {
    mm_content_notify_change('delete_node', NULL, $nids);
  }
  mm_content_clear_caches($mmtids);            // clear caches for this entry and it children
  mm_content_clear_caches($tree[0]->parent);   // clear caches for parent

  watchdog('mm', 'Deleted %name (%alias) mmtids = %mmtids', array(
    '%name' => $tree[0]->name,
    '%alias' => $tree[0]->alias,
    '%mmtids' => join(',', $mmtids))
  );
}

/**
 * Set breadcrumbs based on the current MM path
 *
 * @param $mmtids
 *   Optional list of tree IDs. If not set, the list is retrieved based on the
 *   current URL.
 * @return
 *   The new page title
 */
function mm_content_fix_breadcrumbs($mmtids = NULL) {
  $_mm_content_saved_breadcrumb = &drupal_static('_mm_content_saved_breadcrumb');

  if (!isset($mmtids)) {
    mm_parse_args($mmtids, $oarg_list);
    if (!$mmtids == 0) {
      return;
    }
  }
  else {
    mm_parse_args($dummy, $oarg_list);
  }

  if (isset($mmtids[0]) && $mmtids[0] == mm_home_mmtid()) {
    array_shift($mmtids);
  }

  $base = mm_content_get(mm_home_mmtid());
  $bread[] = l(mm_content_get_name($base), '<front>');
  $path[] = mm_home_path();
  foreach ($mmtids as $mmtid) {
    if (!($tree = mm_content_get($mmtid, MM_GET_FLAGS))) {
      break;
    }

    if ($mmtid == $mmtids[count($mmtids) - 1] || !isset($tree->flags['no_breadcrumb'])) {
      $path[] = $mmtid;
      $bread[] = l($title = mm_content_get_name($tree), implode('/', $path));
    }

    if (!mm_content_user_can($mmtid, MM_PERMS_READ)) {
      break;
    }
  }

  if (count($oarg_list) != 2 || $oarg_list[0] != 'node') {
    if (isset($title)) {
      array_pop($bread);
      drupal_set_title($title);
    }
    elseif (count($bread) == 1) {   // homepage
      drupal_set_title($title = '');
    }
  }

  if (!isset($title)) {
    $title = '';
  }
  drupal_set_breadcrumb($bread);
  $_mm_content_saved_breadcrumb = array($bread, $title);
  return $title;
}

/**
 * Add a new page title to the end of the already-set breadcrumb
 *
 * @param $crumb
 *   New page title to add
 */
function mm_content_add_breadcrumb($crumb) {
  mm_parse_args($mmtids, $oarg_list, $this_mmtid);

  $bread = drupal_get_breadcrumb();
  if ($mmtids) {
    $bread[] = l(drupal_get_title(), "mm/$this_mmtid");
    drupal_set_breadcrumb($bread);
  }
  drupal_set_title($crumb, PASS_THROUGH);

  $_mm_content_saved_breadcrumb = &drupal_static('_mm_content_saved_breadcrumb');
  $_mm_content_saved_breadcrumb = array($bread, $crumb);
}

/**
 * Restore (part of) the previously-set breadcrumb, usually because another part
 * of Drupal has changed it
 *
 * @param $bread
 *   (optional) Array of URLs for upper levels of the breadcrumb
 * @param $crumb
 *   (optional) New page title
 */
function mm_content_restore_breadcrumb($bread = NULL, $crumb = NULL) {
  $_mm_content_saved_breadcrumb = &drupal_static('_mm_content_saved_breadcrumb');

  if (!isset($bread)) {
    $bread = $_mm_content_saved_breadcrumb[0];
  }
  if (!isset($crumb)) {
    $crumb = $_mm_content_saved_breadcrumb[1];
  }
  if (isset($bread) && isset($crumb)) {
    drupal_set_breadcrumb($bread);
    drupal_set_title($crumb);
    $_mm_content_saved_breadcrumb = array($bread, $crumb);
  }
}

/**
 * Return the long username ('last, first middle.' or 'first middle last')
 * associated with a uid
 *
 * @param $uid
 *   ID of the user to query
 * @param $order
 *   Either 'lfm', 'fml', 'lfmu', or 'fmlu' to choose the order. Defaults to
 *   'lfmu' [last, first, middle, (username)].
 * @param $usr
 *   Optional object, from which the name, pref_lfm, pref_fml, firstname,
 *   middlename, and lastname fields are used to construct (and cache) the
 *   output
 * @param $hover
 *   Optionally return the mouse 'hover' text associated with this user
 * @return
 *   The user's long name or FALSE if not found
 */
function mm_content_uid2name($uid, $order = 'lfmu', $usr = NULL, &$hover = NULL) {
  static $drupal_static_fast;

  if (!isset($drupal_static_fast)) {
    // This is cumbersome, but assigning to an array is the only way that works.
    $drupal_static_fast['cache'] = &drupal_static(__FUNCTION__, array());
  }
  $cache = &$drupal_static_fast['cache'];

  if (!isset($cache[$uid])) {
    if ($uid == 0) {
      $cache[$uid] = (object) array(
        'name' => variable_get('mm_username_anon', t('Anonymous user'))
      );
    }
    elseif ($uid == 1) {
      $cache[$uid] = (object) array(
        'name' => variable_get('mm_username_admin', t('Administrator'))
      );
    }
    else {
      if (!$usr) {
        $usr = user_load($uid);
      }

      if (!is_object($usr)) {
        $cache[$uid] = FALSE;
      }
      else {
        $disabled = isset($usr->status) && $usr->status == 0;

        mm_module_invoke_all_array('mm_uid2name_alter', array(&$usr, &$disabled));

        if ($disabled && !user_access('administer all users')) {
          $cache[$uid] = (object) array(
            'name' => variable_get('mm_username_disabled', t('Inactive user'))
          );
        }
        else {
          $middle = '';
          if (isset($usr->middlename) && drupal_strlen($usr->middlename)) {
            $middle = ' ' . $usr->middlename[0] . '.';
          }
          $cache[$uid] = (object) array(
            'pref_fml' => isset($usr->pref_fml) ? $usr->pref_fml : '',
            'pref_lfm' => isset($usr->pref_lfm) ? $usr->pref_lfm : '',
            'last'     => isset($usr->lastname) ? $usr->lastname : '',
            'first'    => isset($usr->firstname) ? $usr->firstname : '',
            'name'     => isset($usr->name) ? $usr->name : '',
            'middle'   => $middle,
            'hover'    => isset($usr->hover) ? $usr->hover : '',
            'disabled' => $disabled ? ' ' . t('(inactive)') : '',
          );
        }
      }
    }
  }

  if (($u = $cache[$uid]) !== FALSE) {
    $hover = isset($u->hover) ? $u->hover : '';

    $uname_only = FALSE;
    $fml = drupal_substr($order, 0, 3) == 'fml';
    if ($fml ? !empty($u->pref_fml) : !empty($u->pref_lfm)) {
      $out = $fml ? $u->pref_fml : $u->pref_lfm;
    }
    elseif (!empty($u->last) && !empty($u->first)) {
      $out = $fml ? "$u->first$u->middle $u->last" : "$u->last, $u->first$u->middle";
    }
    elseif (!empty($u->last)) {
      $out = $u->last;
    }
    elseif (!empty($u->first)) {
      $out = $u->first;
    }
    else {
      $out = $u->name;
      $uname_only = TRUE;
    }

    if (isset($order) && isset($order[3]) && $order[3] == 'u' && $u->name != '' && !$uname_only) {
      $out .= " ($u->name)";
    }
    $out .= isset($u->disabled) ? $u->disabled : '';

    return $out;
  }

  return FALSE;
}

/**
 * Return the uid associated with a username
 *
 * @param $username
 *   ID of the user to query
 * @return
 *   The user's ID or FALSE if not found
 */
function mm_content_name2uid($username) {
  $mmc_u2uid_cache = &drupal_static(__FUNCTION__, array());

  if (!isset($mmc_uid2u_cache[$username])) {
    $usr = user_load_by_name($username);
    $mmc_u2uid_cache[$username] = is_object($usr) ? $usr->uid : FALSE;
  }
  return $mmc_u2uid_cache[$username];
}

/**
 * Determine if a tree entry is a group
 *
 * @param $mmtid
 *   The numeric ID of the potential group
 * @return
 *   TRUE if the group ID is that of an existing (possibly virtual) group, and
 *   not a different type of tree entry
 */
function mm_content_is_group($mmtid) {
  $mmc_isgrp_cache = &drupal_static(__FUNCTION__, array());

  if (!isset($mmc_isgrp_cache[$mmtid])) {
    $list = mm_content_get_parents_with_self($mmtid, FALSE, TRUE);
    $mmc_isgrp_cache[$mmtid] = isset($list[1]) && $list[1] == mm_content_groups_mmtid();
  }
  return $mmc_isgrp_cache[$mmtid];
}

/**
 * Determine if a tree entry is a virtual group
 *
 * @param $mmtid
 *   The numeric ID of the group
 * @return
 *   TRUE if the group ID is that of an existing virtual group, and not a
 *   different type of tree entry
 */
function mm_content_is_vgroup($mmtid) {
  $list = mm_content_get_parents_with_self($mmtid);
  return count($list) >= 3 && ($tree = mm_content_get($list[2])) && $tree->name == MM_ENTRY_NAME_VIRTUAL_GROUP;
}

/**
 * Determine if a tree ID belongs to a normal entry, as opposed to a group
 *
 * @param $mmtid
 *   The tree ID to test
 * @param $user_is_normal
 *   If TRUE, consider anything in .Users to be a normal entry
 * @return
 *   TRUE if the ID refers to a normal entry
 */
function mm_content_is_normal($mmtid, $user_is_normal = TRUE) {
  $cache = &drupal_static(__FUNCTION__, array());

  if (!isset($cache[$mmtid][$user_is_normal])) {
    $list = mm_content_get_parents_with_self($mmtid);
    if (count($list) == 1) {   // root
      $cache[$mmtid][$user_is_normal] = FALSE;
    }
    else {
      $cache[$mmtid][$user_is_normal] = $list[1] != mm_content_groups_mmtid() &&
          ($user_is_normal || $list[1] != mm_content_users_mmtid());
    }
  }
  return $cache[$mmtid][$user_is_normal];
}

/**
 * Determine if a tree ID refers to the main page or the archive page of an
 * archive
 *
 * @param $mmtid
 *   The tree ID to test
 * @param $test_main
 *   If TRUE, see if the ID refers to the main page, otherwise the archive page
 * @return
 *   TRUE if the ID refers to an archive page of the requested type
 */
function mm_content_is_archive($mmtid, $test_main = FALSE) {
  $tree = mm_content_get($mmtid, MM_GET_ARCHIVE);
  return is_object($tree) && $mmtid == ($test_main ? $tree->main_mmtid : $tree->archive_mmtid);
}

/**
 * Determine if a tree entry is a child of another entry; useful in preventing
 * bad moves.
 *
 * @param $child
 *   The tree ID of the child entry
 * @param $of
 *   The tree ID of the entry to test for a relationship
 * @return
 *   TRUE if $child is a child of $of
 */
function mm_content_is_child($child, $of) {
  return in_array($of, mm_content_get_parents($child));
}

/**
 * Determine if a tree entry is in a recycle bin.
 *
 * @param $mmtid
 *   The tree ID of the entry to test
 * @return
 *   TRUE if $mmtid is in a bin
 */
function mm_content_is_recycled($mmtid) {
  return mm_content_user_can($mmtid, MM_PERMS_IS_RECYCLED);
}

/**
 * Determine if a tree entry is a recycle bin.
 *
 * @param $mmtid
 *   The tree ID of the entry to test
 * @return
 *   TRUE if $mmtid is a recycle bin
 */
function mm_content_is_recycle_bin($mmtid) {
  return mm_content_user_can($mmtid, MM_PERMS_IS_RECYCLE_BIN);
}

/**
 * Get a list of all blocks
 *
 * @param $allowed
 *   If set, only return the blocks the current user can apply to a page
 * @return
 *   An array indexed on block ID, containing these elements:
 *   - info: the 'name' field
 *   - title: the 'name' field
 *   - title_is_cat: set to 1 if the entry's top node should be displayed as
 *                   the block title
 */
function mm_content_get_blocks($allowed = FALSE) {
  $cache = &drupal_static(__FUNCTION__);

  if (!is_array($cache) && ($result = db_select('mm_block', 'b')->fields('b')->execute())) {
    $cache = array();
    foreach ($result as $r) {
      $cache[$r->bid] = array(
        'info' => $r->name,
        'title' => $r->title,
        'title_is_cat' => $r->title_is_cat,
        'show_node_contents' => $r->show_node_contents,
        'help' => $r->help,
        'allow_rss' => $r->allow_rss,
        'admin_only' => $r->admin_only,
        'cache' => DRUPAL_NO_CACHE
      );
    }
  }

  if (!$allowed || user_access('administer all menus')) {
    return $cache;
  }

  return array_filter($cache, create_function('$elem', 'return !$elem["admin_only"];'));
}

/**
 * Search up the path, looking for the bottom-most block with an entry in
 * mm_tree_block
 *
 * @param $mmtids
 *   List of tree IDs comprising the path to search
 * @param $block_id
 *   - On entry:  Set to the block ID of the block to match, or leave as 0 to
 *                search all blocks
 *   - On return: If 0 on entry, this variable is set to the ID of the block
 *                that was found
 * @param $multiple
 *   If TRUE, return all blocks in the list
 * @return
 *   Tree ID of the starting point, all blocks in the list (if $multiple), or 0
 *   on error
 */
function mm_content_get_blocks_at_mmtid($mmtids, &$block_id = 0, $multiple = FALSE) {
  if (!count($mmtids)) {
    return 0;
  }

  // Remove virtual directory
  foreach ($mmtids as $i => $mmtid) {
    if ($mmtid < 0) {
      array_splice($mmtids, $i, 1);
      break;
    }
  }

  $select = db_select('mm_tree_block', 'tb');
  $select->join('mm_tree', 't', 'tb.mmtid = t.mmtid');
  $select->join('mm_block', 'b', 'b.bid = tb.bid');
  $cond = db_and()
    ->condition('t.parent', $mmtids);
  if ($block_id > 0) {
    $cond->condition('b.bid', $block_id);
  }

  $select->fields('t', array('mmtid', 'parent'))
    ->fields('b', array('bid', 'show_node_contents'))
    ->fields('tb', array('max_depth', 'max_parents'))
    ->condition(db_or()
      ->condition('t.mmtid', $mmtids)
      ->condition($cond));
  $direct = $by_parent = array();
  $result = $select->execute();
  foreach ($result as $r) {
    if (!in_array($r->mmtid, $mmtids)) {
      // Starting point of a sub-menu
      $by_parent[$r->parent][] = (array)$r;
    }
    else {
      $direct[$r->mmtid] = (array)$r;
    }
  }

  if ($direct || $by_parent) {
    for ($i = count($mmtids); --$i >= 0;) {
      $t = $mmtids[$i];
      if (isset($direct[$t])) {
        $entry = $direct[$t];
        if (!$block_id || $entry['bid'] == $block_id) {
          if (!$block_id) {
            $block_id = $entry['bid'];
          }
          if ($multiple) {
            return array($entry);
          }
          return $t;
        }
      }

      if (isset($by_parent[$t])) {
        foreach ($by_parent[$t] as $entry) {
          if (!$block_id || $entry['bid'] == $block_id) {
            // If show_node_contents is set, just go with it.
            $ok = !empty($entry['show_node_contents']);

            // Otherwise, see what block the parent is in.
            for ($j = $i; $j >= 0 && !$ok; $j--) {
              // If the parent is in a different block, it's OK.
              if (isset($direct[$mmtids[$j]])) {
                if ($direct[$mmtids[$j]]['bid'] == $entry['bid']) {
                  // Same block as parent, ignore it.
                  break;
                }
                $ok = TRUE;
              }
            }

            if ($ok) {
              if (!$block_id) {
                $block_id = $entry['bid'];
              }
              if ($multiple) {
                return $by_parent[$t];
              }
              return $entry['mmtid'];
            }
          }
        }
      }
    }
  }

  return 0;
}

/**
 * Return the tree ID of the /root/.Groups entry
 *
 * @return
 *   The tree ID
 */
function mm_content_groups_mmtid() {
  $mmtid = variable_get('mm_content_groups_mmtid', 0);
  if (empty($mmtid)) {
    $tree = mm_content_get(array('parent' => 1, 'name' => MM_ENTRY_NAME_GROUPS));
    variable_set('mm_content_groups_mmtid', $mmtid = $tree[0]->mmtid);
  }

  return $mmtid;
}

/**
 * Return the tree ID of the /root/.Users entry
 *
 * @return
 *   The tree ID
 */
function mm_content_users_mmtid() {
  $mmtid = variable_get('mm_content_users_mmtid', 0);
  if (empty($mmtid)) {
    $tree = mm_content_get(array('parent' => 1, 'name' => MM_ENTRY_NAME_USERS));
    variable_set('mm_content_users_mmtid', $mmtid = $tree[0]->mmtid);
  }

  return $mmtid;
}

/**
 * Return the alias of the /root/.Users entry
 *
 * @return
 *   The alias
 */
function mm_content_users_alias() {
  if (is_null($alias = variable_get('mm_content_users_alias', NULL))) {
    $tree = mm_content_get(array('parent' => 1, 'name' => MM_ENTRY_NAME_USERS));
    variable_set('mm_content_users_alias', $alias = $tree[0]->alias);
  }

  return $alias;
}

/**
 * Return a list of user IDs in an MM group, query whether or not a given uid
 * is in one or more groups, or return all groups to which a uid belongs. This
 * function differs from mm_content_get_uids_in_group(), in that permissions
 * are not considered and the user's name is not returned.
 *
 * @param $mmtids
 *   A single tree ID (gid) or an array of gids (can be empty or NULL)
 * @param $uids
 *   A single user ID, or an array of user IDs to query (optional)
 * @param $normal
 *   If TRUE, consider "normal" (not ad-hoc or virtual) groups (optional)
 * @param $virtual
 *   If TRUE, consider virtual groups (optional)
 * @param $ad_hoc
 *   If TRUE, consider ad-hoc groups (optional)
 * @return
 *   If both $mmtids and $uids are set:
 *   - If $uids is a single value, return an array containing the groups
 *     matching $mmtids to which the user belongs
 *   - If $uids is an array, return an array where the key is the uid and the
 *     value is an array containing the groups matching $mmtids to which the
 *     user belongs
 *   If only $mmtids is set:
 *   - If $mmtids is a single value, return an array containing all uids that
 *     are members of the group
 *   - If $mmtids is an array, return an array where the key is the mmtid and
 *     the value is an array containing all uids that are members of the group
 *   If only $uids is set:
 *   - If $uids is a single value, return all mmtids (gids) to which the user
 *     belongs
 *   - If $uids is an array, return an array where the key is the uid and the
 *     value is an array containing all mmtids (gids) to which the user belongs
 *
 * At least one of $normal, $virtual, or $ad_hoc must be TRUE.
 */
function mm_content_get_uids_in_group($mmtids, $uids = NULL, $normal = TRUE, $virtual = TRUE, $ad_hoc = TRUE) {
  if (!$virtual && !$normal && !$ad_hoc) {
    return array();
  }

  if (!empty($mmtids)) {
    if (is_array($mmtids)) {
      $in_mmtids = 'IN (:mmtids)';
    }
    else {
      $in_mmtids = '= :mmtids';
      $mmtids_single = TRUE;
    }
  }

  if (!empty($uids)) {
    if (is_array($uids)) {
      $in_uids = 'IN (:uids)';
    }
    else {
      $in_uids = '= :uids';
      $uids = array($uids);
      $uids_single = TRUE;
    }

    // uid=0 should never appear in any group
    $uids = array_diff($uids, array(0));
    if (!$uids) {
      return array();
    }
  }

  $out = array();
  if (!empty($mmtids) && !empty($uids)) {
    $where1 = "g.gid $in_mmtids AND v.uid $in_uids";
    $where2 = "gid $in_mmtids AND uid $in_uids";
    $params = array(':mmtids' => $mmtids, ':uids' => $uids);
  }
  elseif (!empty($mmtids)) {
    $where1 = "g.gid $in_mmtids";
    $where2 = "gid $in_mmtids AND uid > 0";
    $params = array(':mmtids' => $mmtids);
  }
  elseif (!empty($uids)) {
    $where1 = "v.uid $in_uids";
    $where2 = "uid $in_uids";
    $params = array(':uids' => $uids);
  }
  else {
    return array();
  }

  $qs = array();
  if ($virtual) {
    $qs[] = 'SELECT g.gid, v.uid FROM {mm_group} g ' .
      'INNER JOIN {mm_virtual_group} v ON v.vgid = g.vgid ' .
      "WHERE $where1";
  }
  if ($normal || $ad_hoc) {
    if (!$normal) $where2 .= ' AND gid < 0';
    elseif (!$ad_hoc) $where2 .= ' AND gid > 0';

    $qs[] = 'SELECT gid, uid FROM {mm_group} ' .
      "WHERE $where2";
  }
  $query = db_query(join(' UNION ', $qs), $params);

  if (!empty($uids)) {
    foreach ($query as $row) {
      $out[$row->uid][] = $row->gid;
    }
    if (!empty($uids_single)) {
      return isset($out[$uids[0]]) ? $out[$uids[0]] : array();
    }
    return $out;
  }

  foreach ($query as $row) {
    $out[$row->gid][] = $row->uid;
  }
  if (!empty($mmtids_single)) {
    return isset($out[$mmtids]) ? $out[$mmtids] : array();
  }
  return $out;
}

/**
 * Return a list of users in an MM group, suitable for presentation in the UI.
 * This function calls hook_mm_get_users_in_group_alter(), which can be used to
 * prevent the disclosure of group membership to unauthorized viewers.
 *
 * @param $mmtid
 *   Tree ID (gid) of the group
 * @param $sep
 *   If not set, return an array. If set, join the list of users with this
 *   string and return the result.
 * @param $halt
 *   If TRUE, and there are more than $limit matches, return NULL
 * @param $limit
 *   If non-zero, limit the number of results. If the number of results would
 *   exceed the limit, either append '...' to the return (when a string), or
 *   add a '...' element to the returned array (when an array is requested).
 * @param $see_all
 *   If TRUE, and there are more than $limit matches, include a "see all users"
 *   link
 * @return
 *   The textual or array list, or possibly NULL if $halt is set
 */
function mm_content_get_users_in_group($mmtid, $sep = NULL, $halt = FALSE, $limit = 20, $see_all = FALSE) {
  $mmtids = is_array($mmtid) ? $mmtid : array($mmtid);
  foreach ($mmtids as $test_mmtid) {
    if (!mm_content_user_can($test_mmtid, MM_PERMS_READ)) {
      $msg = t('(not permitted to see list)');
      if (isset($sep)) {
        return $msg;
      }
      return array($msg);
    }
  }

  $limit_str = $limit ? "AND v.preview <= $limit + 1 " : '';
  $lim = '';

  $mmtid_match = 'IN(' . join(', ', $mmtids) . ')';
  $qs = 'SELECT %s FROM ((SELECT %s FROM ' .
          '(SELECT u.uid, u.name FROM ' .
            "(SELECT * FROM {mm_group} WHERE gid $mmtid_match) AS g " .
          "INNER JOIN {mm_virtual_group} v ON v.vgid = g.vgid $limit_str" .
          'INNER JOIN {users} u ON u.uid = v.uid) AS u) ' .
        'UNION ' .
        '(SELECT %s FROM ' .
          '(SELECT u.uid, u.name FROM ' .
            "(SELECT * FROM {mm_group} WHERE gid $mmtid_match AND uid > 0) AS g " .
          'INNER JOIN {users} u ON u.uid = g.uid) AS u)) x';

  $query = sprintf($qs . ' ORDER BY x.name', '*', 'u.uid, u.name', 'u.uid, u.name');
  $countquery = sprintf($qs, 'SUM(c)', 'COUNT(DISTINCT u.uid) AS c', 'COUNT(DISTINCT u.uid) AS c', '');

  mm_module_invoke_all_array('mm_get_users_in_group_alter', array($mmtids, &$query, &$countquery));

  if ($limit > 0) {
    if ($halt) {
      $r = db_query($countquery)->fetchField();
      if ($r == NULL || $r > $limit) {
        return NULL;
      }
    }
    else {
      $lim .= ' LIMIT ' . ($limit + 1);
    }
  }

  $query .= $lim;
  $q = db_query($query);

  $users = array();
  foreach ($q as $r) {
    $users[$r->uid] = mm_content_uid2name($r->uid, 'lfmu', $r);
  }

  if (!$halt && $limit > 0 && count($users) == $limit + 1 && count($mmtids) == 1) {
    $overflow = TRUE;
    array_pop($users);
    if ($see_all && $mmtids[0] > 0) {
      $tree = mm_content_get($mmtids[0]);
      $see_link = l(
        t('See all users in this group'),
        mm_content_get_mmtid_url($mmtids[0]) . '/viewall',
        array(
          'attributes' => array(
            'class' => array('thickbox'),
            'title' => t('All users in the group @name', array('@name' => mm_content_get_name($tree))), // can't use %name here
          ),
          'query' => array('TB_iframe' => 'true', 'height' => '400', 'width' => '400')
        )
      );
      $users = array_merge(array(-1 => $see_link), $users);
    }
  }

  if (!empty($overflow)) {
    $users[''] = '...';
  }

  if (!isset($sep)) {
    return $users;
  }

  return implode($sep, $users);
}

/**
 * Ensure that a particular alias will not conflict with the core menu tree, or
 * other entries already at the same level, by adding "_N" to it until it no
 * longer conflicts.
 *
 * @param $alias
 *   The initial alias
 * @param $mmtid
 *   The tree ID of the parent entry
 * @return
 *   The safe alias
 */
function mm_content_get_safe_alias($alias, $mmtid) {
  $reserved = mm_content_reserved_aliases();
  $i = 0;
  $test = $alias;
  while (in_array($test, $reserved) || mm_content_get(array('parent' => $mmtid, 'alias' => $test)) || mm_content_alias_conflicts($test, $mmtid)) {
    $test = $alias . '_' . (++$i);
  }
  return $test;
}

/**
 * Get the list of words that can never be used as URL aliases.
 *
 * @return
 *   An array containing the list of words
 */
function mm_content_reserved_aliases() {
  return variable_get('mm_reserved_alias', mm_content_reserved_aliases_base());
}

/**
 * Get the base list of words that can never be used as URL aliases. This is
 * before any words that are added based on Drupal menu entries.
 *
 * @return
 *   An array containing the list of words
 */
function mm_content_reserved_aliases_base() {
  return array(
    'feed',   // Appending "feed" onto a URL produces an RSS feed of the page.
  );
}

/**
 * Ensure that a particular alias will not conflict with the core menu tree or
 * one of the reserved aliases.
 *
 * @param $alias
 *   The initial alias
 * @param $mmtid
 *   The tree ID of the parent entry
 * @return
 *   TRUE if the alias conflicts
 */
function mm_content_alias_conflicts($alias, $mmtid) {
  if (in_array($alias, mm_content_reserved_aliases())) {
    return TRUE;
  }
  $path = $original_path = $mmtid == mm_home_mmtid() ? $alias : "mm/$mmtid/$alias";
  $opt = array();
  drupal_alter('url_outbound', $path, $opt, $original_path);
  return menu_get_item(drupal_get_path_alias($path));
}

/**
 * Called when a new user account has been created, this function creates a
 * user's home directory in the MM tree.
 *
 * @param $account
 *   The user object describing the account being added
 */
function mm_content_add_user($account) {
  global $user;

  if (!empty($account->user_mmtid) || !variable_get('mm_use_user_dir', TRUE)) {
    return;
  }

  // Some functions are needed at lower levels of this code, which may not be
  // available yet when this function is called early in the bootstrap process.
  if (!function_exists('menu_execute_active_handler')) {
    return;
  }

  $users_mmtid = mm_content_users_mmtid();
  $default_tree = mm_content_get(array('name' => MM_ENTRY_NAME_DEFAULT_USER, 'parent' => $users_mmtid));
  if (!count($default_tree)) {
    watchdog('user', 'Missing !path', array('!path' => '/' . MM_ENTRY_NAME_USERS . '/' . MM_ENTRY_NAME_DEFAULT_USER), WATCHDOG_ERROR);
    return;
  }

  $fullname = mm_content_uid2name($account->uid, 'lfmu', $account, $hover);

  $dest_mmtid = $users_mmtid;
  foreach (mm_module_implements('mm_add_user_alter') as $module) {
    $function = $module . '_mm_add_user_alter';
    if ($function($account, $dest_mmtid, $fullname) === FALSE) {
      return;
    }
  }

  // Find the first empty slot with a name ending in either $name or
  // '$name (username)'
  for ($i = 0;;) {
    $test = !$i ? preg_replace('/ \(.*?\)$/', '', $fullname) : $fullname;
    $exists = mm_content_get(array('name' => $test, 'parent' => $users_mmtid));
    if (!count($exists)) {
      $name = $test;
      break;
    }

    $other = user_load($exists[0]->uid);
    // If owner of homedir no longer exists or his username is the same as
    // the one on the new account, move the old homedir out of the way.
    if ($other === FALSE || $other->name == $account->name) {
      $name = $test;
      if (($err = mm_content_move_to_disabled($exists[0]->mmtid)) !== FALSE) {
        watchdog('user', 'Error moving existing account %name into !path: !message', array('%name' => $name, '!path' => MM_ENTRY_NAME_DISABLED_USER, '!message' => $err), WATCHDOG_ERROR);
        return;
      }
      else {
        watchdog('user', 'Moved existing account %name into !path', array('%name' => $name, '!path' => MM_ENTRY_NAME_DISABLED_USER), WATCHDOG_WARNING);
      }

      break;
    }

    if ($i++) {
      watchdog('user', 'Could not create %test homepage because it already exists',
          array('%test' => $test), WATCHDOG_ERROR);
      return;
    }
  }

  $copy_params = array(
    MM_COPY_ALIAS =>    mm_content_get_safe_alias($account->name, $dest_mmtid),
    MM_COPY_CONTENTS => TRUE,
    MM_COPY_NAME =>     $name,
    MM_COPY_OWNER =>    $account->uid,
  );
  $new_mmtid = mm_content_copy($default_tree[0]->mmtid, $dest_mmtid, $copy_params);

  if (is_numeric($new_mmtid)) {
    $user->user_mmtid = $new_mmtid;
    mm_content_set_flags($new_mmtid, array('user_home' => $account->uid), FALSE);
    mm_content_update_quick(array('hover' => $hover), array('mmtid' => $new_mmtid));
    mm_module_invoke_all_array('mm_add_user_post', array(&$account, $new_mmtid, $dest_mmtid));
  }
  else {
    watchdog('user', 'Error copying default user home dir into %name: !message', array('%name' => $name, '!message' => $new_mmtid), WATCHDOG_ERROR);
  }
  mm_content_clear_caches($users_mmtid);
}

/**
 * Prepend the MM path of the current page. This lets you generate URLs that
 * preserve the MM menu state.
 *
 * @param $rel_url
 *   An optional relative URL to append to the path
 * @return
 *   The new URL, suitable for passing to the l() function
 */
function mm_content_prepend_mm_path($rel_url = NULL) {
  mm_parse_args($mmtids, $oarg_list, $this_mmtid);
  if (is_null($this_mmtid)) {
    $this_mmtid = mm_home_mmtid();
  }

  if (empty($rel_url)) {
    return "mm/$this_mmtid";
  }
  return "mm/$this_mmtid/$rel_url";
}

/**
 * Copy an item (and, optionally, its children) within the MM tree.
 *
 * @param $src_mmtid
 *   Tree ID of the entry to start copying from
 * @param $dest_mmtid
 *   Tree ID of the entry to copy to
 * @param $options
 *   An array containing options. The array is indexed using the constants
 *   below.
 *   - MM_COPY_ALIAS (NULL):
 *     URL alias of the new item, or NULL to keep the original value
 *   - MM_COPY_COMMENTS (FALSE):
 *     If TRUE, and MM_COPY_CONTENTS is also TRUE, copy the comments associated
 *     with any contents
 *   - MM_COPY_CONTENTS (FALSE):
 *     If TRUE, copy the contents of the page(s)
 *   - MM_COPY_ITERATE_ALTER (none):
 *     If set, this function or array of functions is called before any
 *     processing is done on each entry in the tree. If the function returns -1,
 *     the entry and any children will be skipped; if it returns 1, just the
 *     current entry is skipped; if it returns 0, all further processing is
 *     canceled; any other return value leads to no change. The function can
 *     also alter the item passed to it.
 *   - MM_COPY_NAME (NULL):
 *     Name of the new, top-level item, or NULL to keep the original value
 *   - MM_COPY_NODE_PRESAVE_ALTER (none):
 *     If set, this function or array of functions is passed copied nodes just
 *     before creation, for possible alteration
 *   - MM_COPY_OWNER (no change):
 *     If set, change the owner of the copies to this UID
 *   - MM_COPY_READABLE (FALSE):
 *     If TRUE, only copy entries readable by the user
 *   - MM_COPY_RECUR (TRUE):
 *     If TRUE, copy recursively (include all children)
 *   - MM_COPY_TREE (TRUE):
 *     If TRUE, copy the page(s)
 *   - MM_COPY_TREE_PRESAVE_ALTER (none):
 *     If set, this function or array of functions is passed the new page's
 *     description just before creation, for possible alteration
 *   - MM_COPY_TREE_SKIP_DUPS (FALSE):
 *     If TRUE, a check is done to ensure that tree entries with the same
 *     aliases as existing entries are not created in the destination
 * @return
 *   If successful, the tree ID of the first, new entry; otherwise, a human-
 *   readable error message
 */
function mm_content_copy($src_mmtid, $dest_mmtid, $options) {
  if (!class_exists('mmctcGetTreeIterator')) {
    class mmctcGetTreeIterator extends getTreeIterator {
      public $first_mmtid, $dest_mmtid, $error, $cont_userlist, $cont_grouplist, $nodemap, $options, $predefined_flags;

      public function __construct($src_mmtid, $dest_mmtid, $options) {
        $defaults = array(
          MM_COPY_ALIAS =>              NULL,
          MM_COPY_COMMENTS =>           FALSE,
          MM_COPY_CONTENTS =>           FALSE,
          MM_COPY_ITERATE_ALTER =>      NULL,
          MM_COPY_NAME =>               NULL,
          MM_COPY_NODE_PRESAVE_ALTER => NULL,
          MM_COPY_OWNER =>              NULL,
          MM_COPY_READABLE =>           FALSE,
          MM_COPY_RECUR =>              TRUE,
          MM_COPY_TREE =>               TRUE,
          MM_COPY_TREE_PRESAVE_ALTER => NULL,
          MM_COPY_TREE_SKIP_DUPS =>     FALSE,
        );
        $this->options = array_merge($defaults, $options);
        $this->dest_mmtid = $dest_mmtid;
        $this->nodemap = array(mm_content_get_parent($src_mmtid) => $dest_mmtid);

        $hooks = array(
          MM_COPY_ITERATE_ALTER =>      'mm_copy_tree_iterate_alter',
          MM_COPY_TREE_PRESAVE_ALTER => 'mm_copy_tree_tree_alter',
          MM_COPY_NODE_PRESAVE_ALTER => 'mm_copy_tree_node_alter',
        );
        foreach ($hooks as $constant => $hook) {
          $this->options[$constant] = isset($this->options[$constant]) ? (is_array($this->options[$constant]) ? $this->options[$constant] : array($this->options[$constant])) : array();
          foreach (mm_module_implements($hook) as $module) {
            $this->options[$constant][] = "{$module}_$hook";
          }
        }

        if ($this->options[MM_COPY_CONTENTS] && !$this->options[MM_COPY_TREE]) {
          mm_content_get_default_node_perms($dest_mmtid, $this->cont_grouplist, $this->cont_userlist, 0);
        }
        $this->predefined_flags = module_invoke_all('mm_tree_flags');
      }

      public function iterate($item) {
        // function must return 1 if no error, 0 if error, -1 if this node
        // and any of its children should be skipped
        if (isset($this->error)) {
          // was set in a previous invocation
          return 0;
        }

        if ($this->options[MM_COPY_READABLE] && !$item->perms[MM_PERMS_READ]) {
          // skip this node and kids
          return -1;
        }

        if ($item->name == MM_ENTRY_NAME_RECYCLE) {
          // recycle bin: skip this node and kids
          return -1;
        }

        $options_temp = $this->options;
        if (is_array($options_temp[MM_COPY_ITERATE_ALTER])) {
          foreach ($options_temp[MM_COPY_ITERATE_ALTER] as $alter) {
            switch (call_user_func_array($alter, array(&$item, &$options_temp))) {
              case 1:   // skip this one
                return;
              case -1:  // skip this one and kids
                return -1;
              case 0:   // completely stop
                return 0;
            }
          }
        }

        if ($options_temp[MM_COPY_CONTENTS] && !$options_temp[MM_COPY_TREE]) {
          if (!isset($this->first_mmtid)) {
            $this->nodemap[$item->mmtid] = $this->dest_mmtid;
          }
          else {
            $exists = mm_content_get(array('parent' => $this->nodemap[$item->parent], 'alias' => $item->alias));
            if ($exists) {
              $this->nodemap[$item->mmtid] = $exists[0]->mmtid;
            }
            else {
              $this->error = t('There is no destination page with the URL alias %alias to copy the content to.', array('%alias' => $item->alias));
              return 0;
            }
          }
        }
        else {
          $dest_mmtid = $this->nodemap[$item->parent];
          $alias = is_null($options_temp[MM_COPY_ALIAS]) ? $item->alias : $options_temp[MM_COPY_ALIAS];

          $exists = FALSE;
          if ($options_temp[MM_COPY_TREE_SKIP_DUPS] && !empty($alias)) {
            $tree = mm_content_get(array('parent' => $dest_mmtid, 'alias' => $alias));
            if ($tree) {
              $this->nodemap[$item->mmtid] = $tree[0]->mmtid;
              $exists = TRUE;
            }
          }

          if (!$exists) {
            $perms = array();
            $select = db_select('mm_tree', 't');
            $select->join('mm_tree_access', 'a', 't.mmtid = a.gid');
            $select->fields('t', array('mmtid'))
              ->fields('a', array('mode'))
              ->condition('a.gid', 0, '>=')
              ->condition('a.mmtid', $item->mmtid);
            $result = $select->execute();
            foreach ($result as $r) {
              $perms[$r->mode]['groups'][] = $r->mmtid;
            }

            $select = db_select('mm_tree_access', 'a');
            $select->join('mm_group', 'g', 'g.gid = a.gid');
            $select->fields('a', array('mode'))
              ->fields('g', array('uid'))
              ->condition('a.gid', 0, '<')
              ->condition('a.mmtid', $item->mmtid);
            $result = $select->execute();
            foreach ($result as $r) {
              $perms[$r->mode]['users'][] = $r->uid;
            }

            $result = db_select('mm_tree_block', 'b')
              ->fields('b', array('bid', 'max_depth', 'max_parents'))
              ->condition('b.mmtid', $item->mmtid)
              ->execute();
            if ($item->is_group || !($block = $result->fetchAssoc())) {
              $block = array('bid' => 0, 'max_depth' => -1, 'max_parents' => -1);
            }

            if (!isset($this->nodemap[$item->parent])) {
              $this->error = t('Unexpected tree structure');
              return 0;
            }

            $new = array(
              'name' => !empty($options_temp[MM_COPY_NAME]) ? $options_temp[MM_COPY_NAME]  : $item->name,
              'alias' => $alias,
              'default_mode' => $item->default_mode,
              'uid' => $options_temp[MM_COPY_OWNER],
              'cascaded' => mm_content_get_cascaded_settings($item->mmtid),
              'perms' => $perms,
              'menu_start' => $block['bid'],
              'max_depth' => $block['max_depth'],
              'max_parents' => $block['max_parents'],
            );
            foreach (array('theme', 'flags', 'rss', 'node_info', 'previews', 'hidden', 'comment') as $field) {
              $new[$field] = $item->$field;
            }
            if (isset($this->first_mmtid)) {
              $new['weight'] = $item->weight;
            }

            foreach ($this->predefined_flags as $flag => $elem) {
              if (isset($elem['#flag_copy']) && $elem['#flag_copy'] === FALSE) {
                unset($new['flags'][$flag]);
              }
            }

            if (is_array($options_temp[MM_COPY_TREE_PRESAVE_ALTER])) {
              foreach ($options_temp[MM_COPY_TREE_PRESAVE_ALTER] as $alter) {
                call_user_func_array($alter, array(&$new, $dest_mmtid));
              }
            }

            $this->nodemap[$item->mmtid] = mm_content_insert_or_update(1, $dest_mmtid, $new);
          }
        }   // $options_temp[MM_COPY_CONTENTS] && !$options_temp[MM_COPY_TREE]

        if (!isset($this->first_mmtid)) {
          $this->first_mmtid = $this->nodemap[$item->mmtid];
          $this->options[MM_COPY_NAME] = $this->options[MM_COPY_ALIAS] = NULL;
        }

        if ($options_temp[MM_COPY_CONTENTS]) {
          foreach (node_load_multiple(mm_content_get_nids_by_mmtid($item->mmtid)) as $n => $node) {
            if (!empty($node->nid)) {
              $old_catlist = $node->mm_catlist;
              $node->mm_catlist = array($this->nodemap[$item->mmtid] => '');
              $node->mm_catlist_restricted = array();
              $old_nid = $node->nid;
              unset($node->nid);
              unset($node->vid);
              unset($node->created);
              unset($node->recycle_date);
              unset($node->recycle_bins);
              unset($node->recycle_from_mmtids);
              if ($options_temp[MM_COPY_CONTENTS] && !$options_temp[MM_COPY_TREE] && !$node->others_w) {
                $node->groups_w = $this->cont_grouplist;
                $node->users_w = $this->cont_userlist;
              }

              if (is_array($options_temp[MM_COPY_NODE_PRESAVE_ALTER])) {
                foreach ($options_temp[MM_COPY_NODE_PRESAVE_ALTER] as $alter) {
                  call_user_func_array($alter, array(&$node, $old_catlist));
                }
              }

              node_save($node);

              if ($node->nid && $options_temp[MM_COPY_COMMENTS] && module_exists('comment')) {
                $comment_map = array();
                $result = db_select('comment', 'c')
                  ->fields('c')
                  ->condition('nid', $old_nid)
                  ->execute();
                foreach ($result as $comment) {
                  $old_cid = $comment->cid;
                  $comment->nid = $node->nid;
                  drupal_write_record('comments', $comment);
                  $comment_map[$old_cid] = $comment->cid;
                }

                foreach ($comment_map as $old_cid => $new_cid) {
                  db_update('comment')
                    ->fields(array('pid' => $new_cid))
                    ->condition('pid', $old_cid)
                    ->condition('nid', $node->nid)
                    ->execute();
                }

                $comment_stat = db_select('node_comment_statistics', 's')
                  ->fields('s')
                  ->condition('s.nid', $old_nid)
                  ->execute()->fetchObject();
                $comment_stat->nid = $node->nid;
                drupal_write_record('node_comment_statistics', $comment_stat, array('nid'));
              }

              watchdog('mm', '%type: During copy, copied node nid=!id1 (%name) to nid=!id2',
                  array('%type' => $node->type, '%name' => $node->title, '!id1' => $n, '!id2' => $node->nid));
            }
          }
        }

        if ($item->is_group) { // copy group entries
          $select = db_select('mm_group', 'g');
          $select->addExpression(':gid', 'gid', array(':gid' => $this->nodemap[$item->mmtid]));
          $select->addField('g', 'uid');
          $select->condition('g.gid', $item->mmtid);
          db_insert('mm_group')
            ->from($select)
            ->execute();
        }

        return 1;
      }

      public function output() {
        if (isset($this->error)) {
          return $this->error;
        }

        return $this->first_mmtid;
      }
    }   // class
  }     // if (!class_exists ...

  $iter = new mmctcGetTreeIterator($src_mmtid, $dest_mmtid, $options);
  if ($iter->options[MM_COPY_RECUR]) {
    if ($msg = _mm_content_test_copy_move($src_mmtid, $dest_mmtid)) {
      return $msg;
    }
  }

  $params = array(
    MM_GET_TREE_DEPTH        => $iter->options[MM_COPY_RECUR] ? -1 : 0,
    MM_GET_TREE_ITERATOR     => $iter,
    MM_GET_TREE_RETURN_PERMS => $iter->options[MM_COPY_READABLE] ? TRUE : NULL,
    MM_GET_TREE_RETURN_FLAGS => TRUE,
  );
  mm_content_get_tree($src_mmtid, $params);

  mm_content_clear_caches($dest_mmtid);
  watchdog('mm', "Copied mmtid=$src_mmtid to parent=$dest_mmtid!recur, new name=%name (%alias)",
      array('!recur' => $iter->options[MM_COPY_RECUR] ? ' ' . t('recursively') : '', '%name' => $iter->options[MM_COPY_NAME], '%alias' => $iter->options[MM_COPY_ALIAS]));

  return $iter->output();
}

/**
 * Move an entry within the MM tree.
 *
 * @param $src_mmtid
 *   Tree ID of the entry to move
 * @param $dest_mmtid
 *   Tree ID of the destination entry (new parent)
 * @param $recycle_mode
 *   Set to either 'recycle' or 'restore' to indicate if we are manipulating the
 *   recycle bin.
 * @return
 *   FALSE if successful; otherwise, a human-readable error message
 */
function mm_content_move($src_mmtid, $dest_mmtid, $recycle_mode = '') {
  if (!class_exists('mmctmGetTreeIterator')) {
    class mmctmGetTreeIterator extends getTreeIterator {
      public $parents, $pindex, $error, $recycle_mode, $bin, $delete_bins, $time, $first, $src_sort_idx;

      public function __construct($parents, $recycle_mode, $bin, $src_sort_idx) {
        $this->parents = $parents;
        $this->pindex = count($parents);
        $this->recycle_mode = $recycle_mode;
        $this->time = REQUEST_TIME;
        $this->bin = $bin;
        $this->delete_bins = array();
        $this->src_sort_idx = $src_sort_idx;
        $this->first = TRUE;
        $this->moved_node = array();
      }

      public function iterate($item) {
        // function must return 1 if no error, 0 if error, -1 if this entry
        // and any of its children should be skipped
        if (isset($this->error)) {
          // was set in a previous invocation
          return 0;
        }

        $this->parents = array_slice($this->parents, 0, $this->pindex + $item->level);
        if ($this->first) {
          $parent = $this->parents[count($this->parents) - 1];
          $parent_idx = _mm_content_get_next_sort($parent);
          mm_content_update_parents($item->mmtid, $this->parents);
          mm_content_write_revision($item->mmtid);

          // Temporarily move the sort_idx into the right part of the tree, using
          // an index which is larger than it needs to be, then re-sort later.
          $like = str_replace(array('\\', '_', '%'), array('\\\\', '\_', '\%'), $this->src_sort_idx) . '%';
          $txn = db_transaction();  // Lock DB.
          db_update('mm_tree')
            ->fields(array('sort_idx_dirty' => 1, 'weight' => 0))
            ->condition('mmtid', $item->mmtid)
            ->execute();
          db_update('mm_tree')
            ->expression('sort_idx', 'CONCAT(:parent_idx, SUBSTRING(sort_idx, :length))', array(':parent_idx' => $parent_idx, ':length' => strlen($this->src_sort_idx) + 1))
            ->condition('sort_idx', $like, 'LIKE')
            ->execute();
          unset($txn);              // Free lock.
          mm_content_update_sort_queue($parent);
          mm_content_notify_change('move_page', $item->mmtid, NULL, array('old_parent' => $item->parent, 'new_parent' => $parent));
          $this->first = FALSE;
        }
        else {
          mm_content_update_parents($item->mmtid, $this->parents);
        }

        $this->parents[] = $item->mmtid;
        mm_content_clear_caches($item->mmtid);

        if ($this->recycle_mode == 'recycle' && !$item->perms[MM_PERMS_IS_RECYCLED]) {
          foreach (mm_content_get_nids_by_mmtid($item->mmtid) as $nid) {
            if (!in_array($nid, $this->moved_node)) {
              $this->moved_node[] = $nid;
              foreach (mm_content_get_by_nid($nid) as $mmtid) {
                if (in_array($this->bin, mm_content_get_parents_with_self($mmtid))) {
                  db_merge('mm_recycle')
                    ->key(array(
                      'type' => 'node',
                      'id' => $nid,
                      'from_mmtid' => $mmtid
                    ))
                    ->fields(array(
                      'bin_mmtid' => $this->bin,
                      'recycle_date' => $this->time
                    ))
                    ->execute();
                  watchdog('mm', "Recycled node=$nid from mmtid=$mmtid");
                }
              }
            }
          }
        }
        elseif ($this->recycle_mode == 'restore') {
          $dels = array();
          $txn = db_transaction();    // Lock.
          $result = db_select('mm_recycle', 'r')
            ->fields('r', array('id', 'from_mmtid'))
            ->condition('r.bin_mmtid', $this->bin)
            ->condition('r.type', 'node')
            ->execute();
          foreach ($result as $r) {
            db_update('mm_node2tree')
              ->fields(array('mmtid' => $r->from_mmtid))
              ->condition('mmtid', $this->bin)
              ->condition('nid', $r->id)
              ->execute();
            mm_content_clear_caches(array($r->from_mmtid, $this->bin));
            $this->delete_bins[$this->bin] = 1;
            $dels[] = $r->id;
          }
          unset($txn);    // Unlock.
          // Clear the cache used by mm_content_get_by_nid.
          mm_content_get_by_nid(NULL, TRUE);

          if ($dels) {
            db_delete('mm_recycle')
              ->condition('type', 'node')
              ->condition('id', $dels)
              ->execute();
            watchdog('mm', "Restored nodes to mmtid=$item->mmtid");
          }
        }

        return 1;
      }
    }
  }

  if ($msg = _mm_content_test_copy_move($src_mmtid, $dest_mmtid)) {
    return $msg;
  }

  $src = mm_content_get($src_mmtid);
  $list = mm_content_get_parents_with_self($dest_mmtid, FALSE, FALSE); // don't include virtual parents
  $bin = $recycle_mode == 'recycle' ? $dest_mmtid : mm_content_get_parent($src_mmtid);
  $iter = new mmctmGetTreeIterator($list, $recycle_mode, $bin, $src->sort_idx);
  $params = array(
    MM_GET_TREE_RETURN_PERMS => $recycle_mode == 'recycle' ? TRUE : NULL,
    MM_GET_TREE_DEPTH        => -1,
    MM_GET_TREE_ITERATOR     => $iter,
  );
  mm_content_get_tree($src_mmtid, $params);

  mm_content_clear_caches(array($src_mmtid, $dest_mmtid));

  foreach (array_keys($iter->delete_bins) as $bin) {
    mm_content_delete_bin($bin);
  }

  switch ($recycle_mode) {
    case 'recycle':
      watchdog('mm', "Recycled mmtid=$src_mmtid to bin=$dest_mmtid");
      break;

    case 'restore':
      mm_content_clear_caches($iter->bin);
      watchdog('mm', "Restored mmtid=$src_mmtid to parent=$dest_mmtid");
      break;

    default:
      watchdog('mm', "Moved mmtid=$src_mmtid to new parent=$dest_mmtid");
  }

  if ($iter->error) {
    watchdog('mm', 'Move error: %error', array('%error' => $iter->error), WATCHDOG_ERROR);
    return $iter->error;
  }
  return FALSE;
}

/**
 * Move a user's home directory into /.Users/.Disabled within the MM tree.
 *
 * @param $mmtid
 *   Tree ID of the entry to move
 * @return
 *   FALSE if successful; otherwise, a human-readable error message
 */
function mm_content_move_to_disabled($mmtid) {
  $user_dir = mm_content_get(array('name' => MM_ENTRY_NAME_USERS, 'parent' => 1));
  if (!$user_dir) {
    return t('@dir not found', array('@dir' => MM_ENTRY_NAME_USERS));
  }

  $disab_dir = mm_content_get(array('name' => MM_ENTRY_NAME_DISABLED_USER, 'parent' => $user_dir[0]->mmtid));
  if (!$disab_dir) {
    return t('@dir not found', array('@dir' => MM_ENTRY_NAME_DISABLED_USER));
  }

  // This might create duplicate names in /.Users/.Disabled, but it's probably
  // best to leave them.
  return mm_content_move($mmtid, $disab_dir[0]->mmtid);
}

function _mm_content_get_next_sort($parent) {
  $max = db_select('mm_tree', 't')
    ->fields('t', array('sort_idx'))
    ->condition('t.parent', $parent)
    ->orderBy('t.sort_idx', 'DESC')
    ->range(0, 1)
    ->execute()->fetchField();
  if (empty($max)) {
    $parent_sort_idx = db_select('mm_tree', 't')
      ->fields('t', array('sort_idx'))
      ->condition('t.mmtid', $parent)
      ->execute()->fetchField();
    return $parent_sort_idx . _mm_content_btoa(0);
  }
  return substr($max, 0, -MM_CONTENT_BTOA_CHARS) . _mm_content_btoa(_mm_content_atob(substr($max, -MM_CONTENT_BTOA_CHARS)) + 1);
}

function _mm_content_test_sort_length($sort_idx, $msg, $critical = FALSE) {
  $max = &drupal_static(__FUNCTION__ . '_max');
  $did_error = &drupal_static(__FUNCTION__ . '_did_error', FALSE);

  if (empty($max)) {
    $schema = drupal_get_schema('mm_tree');
    $max = $schema['fields']['sort_idx']['length'];
  }

  if (strlen($sort_idx) > $max) {
    if (empty($did_error)) {
      if (is_numeric($msg)) {
        $vars = array('@mmtid' => $msg);
        $msg = 'The tree is nested too deeply, starting at mmtid=@mmtid. Presentation of sorted trees will suffer. To correct this problem, increase the length of mm_tree.sort_idx then run mm_content_update_sort().';
      }
      else {
        $vars = $msg[1];
        $msg = $msg[0];
      }

      watchdog('mm', $msg, $vars, $critical ? WATCHDOG_CRITICAL : WATCHDOG_WARNING);
      $did_error = TRUE;
    }
    return FALSE;
  }
  return TRUE;
}

function _mm_content_test_copy_move($src_mmtid, $dest_mmtid) {
  // Don't allow a copy/move to happen if the resulting sort_idx would be too long
  $max_sort_idx = db_query('SELECT ' .
    'CONCAT(' .
      '(SELECT sort_idx FROM {mm_tree} WHERE mmtid = :dest_mmtid), ' .
      'SUBSTR(' .
        "REPEAT('x', " .
          '(SELECT MAX(LENGTH(t.sort_idx)) ' .
            'FROM {mm_tree_parents} p ' .
            'INNER JOIN {mm_tree} t ON t.mmtid = p.mmtid ' .
            'WHERE p.parent = :src_mmtid1 OR t.mmtid = :src_mmtid2' .
          ')' .
        '), ' .
        '(SELECT LENGTH(sort_idx) ' .
          'FROM {mm_tree} WHERE mmtid = :src_mmtid3' .
        ') - :length' .
      ')' .
    ')',
    array(
      ':dest_mmtid' => $dest_mmtid,
      ':src_mmtid1' => $src_mmtid,
      ':src_mmtid2' => $src_mmtid,
      ':src_mmtid3' => $src_mmtid,
      ':length' => MM_CONTENT_BTOA_CHARS - 1
    )
  )->fetchField();
  $msg = array(
    'An attempt to copy or move mmtid=@src to mmtid=@dest failed, because it would result in a tree that is too deeply nested. To correct this problem, increase the length of mm_tree.sort_idx then run mm_content_update_sort().',
    array('@src' => $src_mmtid, '@dest' => $dest_mmtid),
  );
  if (!_mm_content_test_sort_length($max_sort_idx, $msg)) {
    return t('This operation cannot be performed because it would cause the tree to become too deeply nested. Please contact a system administrator.');
  }
  return FALSE;
}

/**
 * Add a new entry or replace an existing entry in the MM tree.
 *
 * @param $add
 *   TRUE if the entry is new
 * @param $mmtid
 *   Tree ID of the new entry's parent ($add=TRUE), or the ID of the entry to
 *   replace
 * @param $parameters
 *   Either an array or an object with one more more of the attributes listed
 *   below. Other modules can add settings using hook_mm_cascaded_settings().
 *   - 'alias':
 *     The entry's alias
 *   - 'cascaded':
 *     An array containing these possible elements, which describe settings that
 *     are cascaded downward in the tree to any children:
 *     - 'allowed_node_types':
 *       If not NULL, then set the entry's allowed node type list to this array
 *       of values. To indicate that the parent settings should be inherited,
 *       pass an empty array or NULL. To indicate that there should be no node
 *       types allowed, pass array('').
 *     - 'allow_reorder':
 *       Allow users with write access to reorder the menu of this page and its
 *       children (-1 = inherit)
 *     - 'allowed_themes':
 *       If not NULL, then set the entry's allowed theme list to this array of
 *       values
 *     - 'comments_readable':
 *       Default comment readability for new nodes added to this entry
 *     - 'share_default':  (in mm_share_widget.module)
 *       Default state for the Share link in new nodes added to this entry and
 *       its children (0 = off, 1 = on, -1 = inherit)
 *   - 'comment':
 *     Default comment mode for new content added to this entry (0)
 *   - 'default_mode':
 *     Default access mode for the entry, a comma-separated list of
 *     MM_PERMS_READ, MM_PERMS_WRITE, MM_PERMS_SUB, MM_PERMS_APPLY ('')
 *   - 'flags':
 *     A single string or array of strings in flag => value format to be added
 *     to the entry (admins. only)
 *   - 'hidden':
 *     If set, the entry only appears in menus if the user can edit it or add
 *     content to it (FALSE)
 *   - 'hover':
 *     Text for title attribute, displayed when the mouse hovers over the link
 *     ('')
 *   - 'max_depth':
 *     If $menu_start is set, the maximum depth of the menu block (-1)
 *   - 'max_parents':
 *     If $menu_start is set, the maximum number of parent levels to display
 *     (-1)
 *   - 'members':
 *     For non-virtual groups, an array of the uids of the group's members; if
 *     an empty string (''), do not change any existing users
 *   - 'menu_start':
 *     If non-zero, a menu block using this block ID starts at this level ('')
 *   - 'name':
 *     The entry's name
 *   - 'node_info':
 *     The default value for showing 'Submitted by' lines on nodes added to this
 *     page (TRUE)
 *   - 'perms':
 *     An array of arrays [MM_PERMS_READ, MM_PERMS_WRITE, MM_PERMS_SUB,
 *     MM_PERMS_APPLY]['groups', 'users']. All are optional. For 'groups',
 *     provide an array of gids; for 'users' an array of uids.
 *   - 'previews':
 *     If set, show all nodes on the page as teasers (FALSE)
 *   - 'propagate_node_perms':
 *     If TRUE, and !$add, set the permissions on all nodes for which the user
 *     has write access to match the entry. If recurs_perms is also true,
 *     recursively set the permissions on the nodes on all children as well.
 *     (FALSE)
 *   - 'qfield':
 *     For a virtual group, the "column to select" portion of the query; ignored
 *     for non-virtual groups
 *   - 'qfrom':
 *     For a virtual group, the "FROM clause" portion of the query; ignored for
 *     non-virtual groups
 *   - 'recurs_perms':
 *     If TRUE, and !$add, recursively set the permissions on all children for
 *     which the user has write access to match the parent. (FALSE)
 *   - 'rss':
 *     If set, show an 'Add this page to my portal' button on the page (FALSE)
 *   - 'theme':
 *     Name of the entry's theme, if any (none)
 *   - 'uid':
 *     User ID of the entry's owner (1)
 *   - 'weight':
 *     Order of the entry among its siblings (0)
 * @param $stats
 *   (optional) Array with which to populate statistics:
 *   - pages:
 *     An array indexed by mmtid, containing an array of sub-arrays each with
 *     the elements "message" and "vars", which describe the pages that were
 *     acted upon.
 *   - groups:
 *     An array indexed by mmtid, containing an array of sub-arrays each with
 *     the elements "message" and "vars", which describe the groups that were
 *     acted upon.
 *   - errors:
 *     An array containing sub-arrays with the elements "message" and "vars",
 *     which describe any errors that occurred.
 *   A count of the number of pages acted upon can be derived using the count()
 *   function.
 * @return
 *   Tree ID of the entry that was added or replaced, or 0 on error
 * @throws Exception
 *   Any exception occurring during the insert/update
 */
function mm_content_insert_or_update($add, $mmtid, $parameters, &$stats = 'undef') {
  global $user;
  static $defaults = array(
    'alias' => '',
    'cascaded' => array(),
    'comment' => 0,
    'default_mode' => '',
    'flags' => '',
    'hidden' => FALSE,
    'hover' => '',
    'large_group_form_token' => '',
    'max_depth' => -1,
    'max_parents' => -1,
    'members' => '',
    'menu_start' => -1,
    'name' => '',
    'node_info' => TRUE,
    'perms' => array(),
    'previews' => FALSE,
    'propagate_node_perms' => FALSE,
    'qfield' => '',
    'qfrom' => '',
    'recurs_perms' => FALSE,
    'rss' => FALSE,
    'theme' => '',
    'uid' => 1,
    'weight' => 0,
  );
  static $cascaded_settings;

  $parameters = (array)$parameters;
  foreach (array_keys($parameters) as $p) {
    if (!isset($defaults[$p])) {
      watchdog('mm', 'Unknown parameter %name to mm_content_insert_or_update', array('%name' => $p), WATCHDOG_CRITICAL);
      drupal_set_message(t('An error occurred.'));
      return 0;
    }

    if ($p == 'cascaded') {
      if (!isset($cascaded_settings)) {
        $cascaded_settings = mm_content_get_cascaded_settings();
      }
      foreach (array_keys($parameters[$p]) as $c) {
        if (!isset($cascaded_settings[$c])) {
          watchdog('mm', 'Unknown cascaded setting %name in mm_content_insert_or_update', array('%name' => $c), WATCHDOG_CRITICAL);
          drupal_set_message(t('An error occurred.'));
          return 0;
        }
      }
    }
  }
  $parameters = array_merge($defaults, $parameters);

  $is_group = mm_content_is_group($mmtid);

  if ($add) {
    $parent = $mmtid;
    $list = mm_content_get_parents_with_self($parent, FALSE, FALSE); // don't include virtual parents

    $parameters['parent'] = $parent;
    $parameters['ctime'] = REQUEST_TIME;
    $parameters['cuid'] = $user->uid;
    $parameters['sort_idx'] = _mm_content_get_next_sort($parent);
    $parameters['sort_idx_dirty'] = 1;

    $msg = array('An attempt to create a new child of mmtid=@mmtid failed, because it would result in a tree that is too deeply nested. To correct this problem, increase the length of mm_tree.sort_idx then run mm_content_update_sort().', array('@mmtid' => $parent));
    if (!_mm_content_test_sort_length($parameters['sort_idx'], $msg)) {
      drupal_set_message(t('This operation cannot be performed because it would cause the tree to become too deeply nested. Please contact a system administrator.'));
      return 0;
    }

    $transaction = db_transaction();
    try {
      drupal_write_record('mm_tree', $parameters);
      $mmtid = $parameters['mmtid'];
      mm_content_update_parents($mmtid, $list, TRUE);
      mm_content_write_revision($mmtid);

      mm_content_set_flags($mmtid, $parameters['flags'], FALSE);
      mm_content_set_perms($mmtid, $parameters['perms'], $is_group, FALSE);
      if ($is_group) {
        mm_content_set_group_members($mmtid, NULL, $parameters['qfield'], $parameters['qfrom'], $parameters['members'], $parameters['large_group_form_token']);
      }
      mm_content_clear_caches($parent);
      mm_content_update_sort_queue($parent);
      mm_content_notify_change('insert_page', $mmtid, NULL, $parameters);
      _mm_report_stat($is_group, $mmtid, "Added %name (%alias) mmtid=!mmtid", array('%name' => $parameters['name'], '%alias' => $parameters['alias']), $stats, TRUE);
    }
    catch (Exception $e) {
      $had_error = TRUE;
      $transaction->rollback();
      watchdog_exception('mm', $e);
      throw $e;
    }
  }
  else {
    if ($parameters['recurs_perms']) {
      $list = array();
      foreach (mm_content_get_tree($mmtid, array(MM_GET_TREE_RETURN_PERMS => TRUE)) as $t) {
        if ($t->perms[MM_PERMS_WRITE]) {
          $list[] = $t->mmtid;
        }
        if (!isset($old)) {
          $old = $t;
        }
      }
    }
    else {
      $list = array($mmtid);
      $old = mm_content_get($mmtid);
    }

    unset($parameters['ctime']);
    unset($parameters['cuid']);
    unset($parameters['parent']);
    $count = 0;
    foreach ($list as $t) {
      unset($parameters['sort_idx_dirty']);

      $transaction = db_transaction();
      try {
        if ($count++) {    // recursive: item after the first
          $updated_rows = db_update('mm_tree')
            ->fields(array('default_mode' => $parameters['default_mode'], 'uid' => $parameters['uid']))
            ->condition('mmtid', $t)
            ->execute();
          if ($updated_rows) {
            mm_content_write_revision($t);
          }
        }
        else {             // first item only
          $parameters['mmtid'] = $t;
          if ($parameters['name'] != $old->name || $parameters['weight'] != $old->weight || $parameters['hidden'] != $old->hidden) {
            $parameters['sort_idx_dirty'] = 1;
            mm_content_update_sort_queue($old->parent);
          }
          $written = drupal_write_record('mm_tree', $parameters, 'mmtid');
          if ($written) {
            mm_content_write_revision($t);
          }

          if ($is_group) {
            mm_content_set_group_members($mmtid, NULL, $parameters['qfield'], $parameters['qfrom'], $parameters['members'], $parameters['large_group_form_token']);
          }
          else {
            db_delete('mm_tree_block')
              ->condition('mmtid', $t)
              ->execute();
          }
          db_delete('mm_cascaded_settings')
            ->condition('mmtid', $t)
            ->execute();
          mm_content_set_flags($mmtid, $parameters['flags']);
        }

        mm_content_set_perms($t, $parameters['perms'], $is_group, TRUE);
        mm_content_notify_change('update_page', $t, NULL, $parameters);

        // Copy the permissions onto nodes attached to the entry if requested.
        if ($parameters['propagate_node_perms']) {
          foreach (node_load_multiple(mm_content_get_nids_by_mmtid($t)) as $node) {
            if ($node && node_access('update', $node)) {
              $node->users_w = is_array($parameters['perms'][MM_PERMS_WRITE]['users']) ? array_flip($parameters['perms'][MM_PERMS_WRITE]['users']) : array();
              if (is_array($parameters['perms'][MM_PERMS_APPLY]['users'])) {
                $node->users_w += array_flip($parameters['perms'][MM_PERMS_APPLY]['users']);
              }
              $node->groups_w = is_array($parameters['perms'][MM_PERMS_WRITE]['groups']) ? array_flip($parameters['perms'][MM_PERMS_WRITE]['groups']) : array();
              if (is_array($parameters['perms'][MM_PERMS_APPLY]['groups'])) {
                $node->groups_w += array_flip($parameters['perms'][MM_PERMS_APPLY]['groups']);
              }
              $node->others_w = strpos($parameters['default_mode'], MM_PERMS_WRITE) !== FALSE || strpos($parameters['default_mode'], MM_PERMS_APPLY) !== FALSE;

              mm_content_set_node_perms($node);
            }
          }
        }
      }
      catch (Exception $e) {
        if ($count == 1) {
          $had_error = TRUE;
        }
        $transaction->rollback();
        watchdog_exception('mm', $e);
        throw $e;
        break;
      }
    }

    if (empty($had_error)) {
      mm_content_clear_caches();  // clear everything, because there may be affected kids, even without recursion

      $did_perms = array();
      if ($parameters['recurs_perms']) {
        $did_perms[] = ' ' . t('Permissions were copied to all children.');
      }
      if ($parameters['propagate_node_perms']) {
        $did_perms[] = ' ' . t('Permissions were copied to nodes.');
      }
      _mm_report_stat($is_group, $mmtid, "Updated %name (%alias) mmtid = !mmtid.@perms", array('%name' => $parameters['name'], '%alias' => $parameters['alias'], '@perms' => join('', $did_perms)), $stats, TRUE);
    }
  }

  if (!empty($had_error)) {
    return 0;
  }

  if (!$is_group) {
    mm_content_set_cascaded_settings($mmtid, $parameters['cascaded'], FALSE);

    if ($parameters['menu_start'] && $parameters['menu_start'] != -1 || $parameters['max_depth'] >= 0 || $parameters['max_parents'] >= 0) {
      db_insert('mm_tree_block')
        ->fields(array(
          'mmtid' => $mmtid,
          'bid' => $parameters['menu_start'],
          'max_depth' => $parameters['max_depth'],
          'max_parents' => $parameters['max_parents'],
        ))
        ->execute();
    }
  }

  return $mmtid;
}

/**
 * Update an existing entry in the MM tree. Only attributes which are stored in
 * the mm_tree table are supported.
 *
 * @param $parameters
 *   Either an array or an object with one more more of the attributes listed
 *   below. Only those attributes which are listed can be updated.
 *   - 'alias':
 *     The entry's alias
 *   - 'comment':
 *     Default comment mode for new content added to this entry
 *   - 'default_mode':
 *     Default access mode for the entry, a comma-separated list of
 *     MM_PERMS_READ, MM_PERMS_WRITE, MM_PERMS_SUB, MM_PERMS_APPLY
 *   - 'hidden':
 *     If set, the entry only appears in menus if the user can edit it or add
 *     content to it
 *   - 'hover':
 *     Text for title attribute, displayed when the mouse hovers over the link
 *   - 'name':
 *     The entry's name
 *   - 'node_info':
 *     The default value for showing 'Submitted by' lines on nodes added to this
 *     page
 *   - 'previews':
 *     If set, show all nodes on the page as teasers
 *   - 'rss':
 *     If set, show an 'Add this page to my portal' button on the page
 *   - 'theme':
 *     Name of the entry's theme, if any
 *   - 'uid':
 *     User ID of the entry's owner
 *   - 'weight':
 *     Order of the entry among its siblings
 * @param $where
 *   Defines what tree entries to update. If a single value is supplied, then it
 *   it treated as the tree ID (mmtid) of an entry.
 *
 *   An associative array can also be supplied; it must contain one or more
 *   attributes from the list above, or "mmtid", as the array key. The array
 *   value becomes part of the update query WHERE. At a minimum, "mmtid" must be
 *   specified.
 * @param $parent
 *   If the name, hidden, or weight attribute is being changed, the parent tree
 *   ID may need to be queued for later update. If it is needed and not
 *   specified in $parent, it will be retrieved using an additional query.
 * @param $revision
 *   If TRUE, update the mm_tree_revisions table
 */
function mm_content_update_quick($parameters, $where, $parent = NULL, $revision = TRUE) {
  $parameters = (array)$parameters;
  if (!is_array($where)) {
    $where = array('mmtid' => $where);
  }

  $special = array_intersect_key($parameters, array('name' => 1, 'hidden' => 1, 'weight' => 1));
  $not_special = array_diff_key($parameters, $special);
  if ($special) {
    if ($not_special) {
      mm_content_update_quick($special, $where, $parent, FALSE);
      $parameters = $not_special;
      unset($special);
    }
    else {
      $parameters['sort_idx_dirty'] = 1;
    }
  }

  $schema = drupal_get_schema('mm_tree');
  $schema = $schema['fields'];

  foreach (array_keys($parameters) as $p) {
    if (!isset($schema[$p])) {
      watchdog('mm', 'Unknown attribute %name in $parameters to mm_content_update_quick', array('%name' => $p), WATCHDOG_CRITICAL);
      drupal_set_message(t('An error occurred.'));
      return;
    }
  }

  foreach (array_keys($where) as $p) {
    if (!isset($schema[$p])) {
      watchdog('mm', 'Unknown attribute %name in $where to mm_content_update_quick', array('%name' => $p), WATCHDOG_CRITICAL);
      drupal_set_message(t('An error occurred.'));
      return;
    }
  }

  $update = db_update('mm_tree');
  $special_conditions = db_condition('or');
  $fields = array();

  foreach ($schema as $field => $info) {
    if ($info['type'] != 'serial' && isset($parameters[$field])) {
      $fields[$field] = $parameters[$field];
      if (!empty($special) && $field != 'sort_idx_dirty') {
        $special_conditions->condition($field, $parameters[$field], '<>');
        $have_special = TRUE;
      }
    }
  }

  $update->fields($fields);
  if (!empty($have_special)) {
    $update->condition($special_conditions);
  }

  foreach ($where as $key => $val) {
    $update->condition($key, $val);
  }

  if ($update->execute()) {   // There were affected rows
    if ($revision) {
      if (!isset($where['mmtid'])) {
        unset($fields['sort_idx_dirty']);
        if ($tree = mm_content_get($fields, array(), 1)) {
          $where['mmtid'] = $tree[0]->mmtid;
        }
      }

      if (isset($where['mmtid'])) {
        mm_content_write_revision($where['mmtid']);
      }
    }

    if (!empty($special)) {
      if (empty($parent)) {
        $parent = NULL;
      }
      $child = !isset($where['mmtid']) ? NULL : $where['mmtid'];
      if (!is_null($parent) || !is_null($child)) {
        mm_content_update_sort_queue($parent, $child);
      }
    }

    if (isset($where['mmtid'])) {
      if (!is_null($parent)) {
        $parameters['parent'] = $parent;
      }
      mm_content_notify_change('update_page_quick', $where['mmtid'], NULL, $parameters);
    }
  }
}

/**
 * Makes a copy of an mm_tree entry to the mm_tree_revisions table
 *
 * @param $mmtid
 *   The tree ID of the entry being copied
 */
function mm_content_write_revision($mmtid) {
  global $user;

  $schema_rev = drupal_get_schema('mm_tree_revisions');
  $select = db_select('mm_tree', 't');
  foreach ($schema_rev['fields'] as $field => $info) {
    if ($info['type'] != 'serial' && $field != 'muid' && $field != 'mtime') {
      $select->addField('t', $field);
    }
  }
  $select->addExpression(':muid', 'muid', array(':muid' => $user->uid));
  $select->addExpression(':mtime', 'mtime', array(':mtime' => REQUEST_TIME));
  $select->condition('t.mmtid', $mmtid);
  $vid = db_insert('mm_tree_revisions')
    ->from($select)
    ->execute();
  if ($vid) {
    db_update('mm_tree')
      ->fields(array('vid' => $vid))
      ->condition('mmtid', $mmtid)
      ->execute();
  }
}

/**
 * Based on an entry's permissions, return appropriate default values for 'who
 * can edit or delete this content' on nodes added to it.
 *
 * @param $mmtid
 *   The tree ID of the entry nodes are being added to
 * @param $grouplist
 *   On return, contains an array of long group names, indexed by the mmtid of
 *   the group
 * @param $userlist
 *   On return, contains an array of long user names, indexed by uid
 * @param $max
 *   The maximum number of users to copy in ad-hoc groups
 */
function mm_content_get_default_node_perms($mmtid, &$grouplist, &$userlist, $max) {
  // Find groups
  $grouplist = array();
  $select = db_select('mm_tree', 't');
  $select->join('mm_tree_access', 'a', 'a.mmtid = t.mmtid');
  $select->leftJoin('mm_tree', 't2', 'a.gid = t2.mmtid');
  $select->fields('t2', array('mmtid', 'name'))
    ->distinct()
    ->condition('t2.mmtid', 0, '>=')
    ->condition(db_or()
      ->condition('a.mode', MM_PERMS_APPLY)
      ->condition('a.mode', MM_PERMS_WRITE)
    )
    ->condition('a.mmtid', $mmtid)
    ->orderBy('t2.name');
  $result = $select->execute();
  foreach ($result as $r) {
    $grouplist[$r->mmtid] = $r->name;
  }

  // Find individual users
  $userlist = array();
  $result = db_select('mm_tree_access', 'a')
    ->fields('a', array('gid'))
    ->distinct()
    ->condition('a.gid', 0, '<')
    ->condition(db_or()
      ->condition('a.mode', MM_PERMS_APPLY)
      ->condition('a.mode', MM_PERMS_WRITE)
    )
    ->condition('a.mmtid', $mmtid)
    ->execute();
  foreach ($result as $r) {
    $users = mm_content_get_users_in_group($r->gid, NULL, TRUE, $max);

    if (!is_null($users))
      $userlist += $users;
  }
}

/**
 * Set a group's membership list or virtual group attributes
 *
 * @param $mmtid
 *   MM tree ID of the group
 * @param $vgid
 *   Virtual group ID of the group, if known. If this value is NULL and the
 *   group is determined to be a virtual group, its vgid is retrieved
 * @param $qfield
 *   For a virtual group, the "column to select" portion of the query; ignored
 *   for non-virtual groups
 * @param $qfrom
 *   For a virtual group, the "FROM clause" portion of the query; ignored for
 *   non-virtual groups
 * @param $members
 *   For non-virtual groups, an array of the uids of the group's members; if
 *   an empty string (''), do not change any existing users
 * @param $large_group_form_token
 *   If large group management is used, contains the token associated with the
 *   input form.
 */
function mm_content_set_group_members($mmtid, $vgid, $qfield, $qfrom, $members, $large_group_form_token = '') {
  $vgroup = mm_content_is_vgroup($mmtid);
  if ($vgroup && empty($vgid)) {
    $select = db_select('mm_group', 'g');
    $select->join('mm_vgroup_query', 'v', 'g.vgid = v.vgid');
    $select->fields('v', array('vgid'))
      ->condition('g.gid', $mmtid);
    $vgid = $select->execute()->fetchField();
  }

  if ($vgroup && !empty($qfield) && !empty($vgid)) {
    db_update('mm_vgroup_query')
      ->fields(array(
        'field' => $qfield,
        'qfrom' => $qfrom,
        'dirty' => MM_VGROUP_DIRTY_NEXT_CRON,
      ))
      ->condition('vgid', $vgid)
      ->execute();
  }
  elseif ($vgroup || is_array($members) || !empty($large_group_form_token)) {
    // DELETE FROM {mm_vgroup_query} WHERE
    //   (SELECT 1 FROM {mm_group} g WHERE g.vgid = {mm_vgroup_query}.vgid
    //     AND g.gid = :mmtid)
    $mm_group = db_select('mm_group', 'g');
    $mm_group->addExpression(1);
    $mm_group->where('g.vgid = {mm_vgroup_query}.vgid')
      ->condition('g.gid', $mmtid);
    db_delete('mm_vgroup_query')
      ->condition($mm_group)
      ->execute();
    db_delete('mm_group')
      ->condition('gid', $mmtid)
      ->execute();

    if (!empty($large_group_form_token)) { // Copy from the temp table and then remove temp records
      $select = db_select('mm_group_temp', 'g');
      $select->addExpression($mmtid, 'gid');
      $select->addField('g', 'uid');
      $select->addExpression('0', 'vgid');
      $select->condition('sessionid', session_id());
      $select->condition('token', $large_group_form_token);
      db_insert('mm_group')
        ->from($select)
        ->execute();
      db_delete('mm_group_temp')
        ->condition('sessionid', session_id())
        ->condition('token', $large_group_form_token)
        ->execute();
    }

    if ($vgroup) {
      if (!empty($qfield)) {
        $vgid = db_insert('mm_vgroup_query')
          ->fields(array(
            'field' => $qfield,
            'qfrom' => $qfrom,
            'dirty' => MM_VGROUP_DIRTY_NEXT_CRON,
          ))
          ->execute();
        db_insert('mm_group')
          ->fields(array(
            'gid' => $mmtid,
            'uid' => 0,
            'vgid' => $vgid,
          ))
          ->execute();
      }
    }
    elseif (is_array($members)) {
      foreach ($members as $uid) {
        db_insert('mm_group')
          ->fields(array(
            'gid' => $mmtid,
            'uid' => $uid,
            'vgid' => 0,
          ))
          ->execute();
      }
    }
  }
}

/**
 * Given a node, return TRUE if the node is in a recycle bin.
 *
 * @param $node
 *   The node to test
 * @param $mmtid
 *   Either the MM Tree ID of the page (recycle bin) to test against, or one of
 *   these constants:
 *   - MM_NODE_RECYCLED_MMTID_CURR: Recycled on the current page (bin)
 *   - MM_NODE_RECYCLED_MMTID_EXCL: Recycled on all pages where it is shown
 * @return
 *   TRUE if the node is in a recycle bin
 */
function mm_content_node_is_recycled($node, $mmtid = MM_NODE_RECYCLED_MMTID_EXCL) {
  if (!isset($mmtid) || !isset($node->recycle_date)) {
    return FALSE;
  }

  if ($mmtid == MM_NODE_RECYCLED_MMTID_CURR) {
    mm_parse_args($term_ids, $oarg_list, $mmtid);
    if (is_null($mmtid)) {
      return FALSE;
    }
  }

  if ($mmtid == MM_NODE_RECYCLED_MMTID_EXCL) {
    return (bool) db_query('SELECT COUNT(*) = 0 FROM {mm_node2tree} n2 LEFT JOIN {mm_recycle} r ON n2.nid = r.id AND `type` = :type AND (r.from_mmtid = n2.mmtid OR r.bin_mmtid = n2.mmtid) WHERE n2.nid = :nid AND r.id IS NULL',
      array(
        ':type' => 'node',
        ':nid' => $node->nid,
      ))->fetchField();
  }

  return (bool) db_query('SELECT COUNT(*) FROM {mm_recycle} WHERE `type` = :type AND id = :nid AND (bin_mmtid = :mmtid OR from_mmtid = :mmtid)',
    array(
      ':type' => 'node',
      ':nid' => $node->nid,
      ':mmtid' => $mmtid,
    ))->fetchField();
}

/**
 * Given a set of tree IDs, return a list of the node IDs assigned to them.
 *
 * @param $mmtids
 *   An array of tree IDs, or a single ID
 * @param $limit
 *   Optional limit to the number of results
 * @param $unique
 *   If set, return only those nodes that are assigned to entries from the list,
 *   and not to other entries.
 * @return
 *   An array of node IDs
 */
function mm_content_get_nids_by_mmtid($mmtids, $limit = '', $unique = FALSE) {
  if (!is_array($mmtids)) {
    $mmtids = array($mmtids);
  }

  if (count($mmtids) == 1) {
    $in = '= :one';
    $args = array(':one' => $mmtids[0]);
  }
  else {
    $in = 'IN(:list)';
    $args = array(':list' => $mmtids);
  }

  if ($unique) {
    $query = 'SELECT t1.nid FROM {mm_node2tree} t1 ' .
        "INNER JOIN {mm_node2tree} t2 ON t1.nid = t2.nid AND t2.mmtid $in " .
        "GROUP BY t1.nid HAVING SUM(IF(t1.mmtid $in, 1, 0)) = COUNT(*)";
  }
  else {
    $query = "SELECT nid FROM {mm_node2tree} WHERE mmtid $in";
  }

  if ($limit) {
    $q = db_query_range($query, 0, $limit, $args);
  }
  else {
    $q = db_query($query, $args);
  }

  $out = array();
  foreach ($q as $r) {
    $out[] = $r->nid;
  }

  return $out;
}

/**
 * Given a tree ID, return a SQL query handle for nodes that appear on it. Only
 * nodes the user has permission to view are returned, and they are sorted
 * according to all of the various possible criteria.
 *
 * @param $mmtid
 *   The tree ID of the entry
 * @param int $per_page
 *   Nodes per page in the pager (optional)
 * @param int $element
 *   Pager element number (optional)
 * @param string $add_select
 *   Text to add to the SELECT part of the outer query (optional)
 * @param string $add_join
 *   Additional LEFT JOINs for the outer query (optional)
 * @param string $add_inner_where
 *   Text to add to the WHERE part of the inner query (optional)
 * @param string $add_outer_where
 *   Text to add to the WHERE part of the outer query (optional)
 * @param string $add_groupby
 *   Text to add to the GROUP BY part of the outer query (optional)
 * @param string $add_orderby
 *   Text to add to the ORDER BY part of the outer query (optional)
 * @return DatabaseStatementInterface
 *   An SQL query handle
 */
function mm_content_get_accessible_nodes_by_mmtid($mmtid, $per_page = 0, $element = 0, $add_select = '', $add_join = '', $add_inner_where = '', $add_outer_where = '', $add_groupby = '', $add_orderby = '') {
  if ($mmtid < 0) {
    return NULL;
  }
  $q = mm_content_get_accessible_nodes_by_mmtid_query($mmtid, $count_sql, $add_select, $add_join, $add_inner_where, $add_outer_where, $add_groupby, $add_orderby);

  if ($per_page == 0 && MM_MAX_NUMBER_OF_NODES_PER_PAGE != 0) {
    return db_query_range($q, 0, MM_MAX_NUMBER_OF_NODES_PER_PAGE);
  }

  if ($per_page > 0) {
    $total = db_query($count_sql)->fetchField();
    $page = pager_default_initialize($total, $per_page, $element);
    return db_query_range($q, $per_page * $page, $per_page);
  }

  if ($per_page == -2) {
    $start_value = !empty($_GET['page']) ? $_GET['page'] * MM_LAZY_LOAD_NUMBER_OF_NODES : 0;
    return db_query_range($q, $start_value, MM_LAZY_LOAD_NUMBER_OF_NODES);
  }

  return db_query($q);
}

/**
 * Given a tree ID, return a SQL query for nodes that appear on it. Only nodes
 * that are owned by the user or are currently published are returned, and they
 * are sorted according to all of the various possible criteria.
 *
 * @param $mmtid
 *   The tree ID (or array of tree IDs) of the entry
 * @param $count_sql
 *   The SQL query for querying the count of matches
 * @param string $add_select
 *   Text to add to the SELECT part of the outer query (optional)
 * @param string $add_join
 *   Additional LEFT JOINs for the outer query (optional)
 * @param string $add_inner_where
 *   Text to add to the WHERE part of the inner query (optional)
 * @param string $add_outer_where
 *   Text to add to the WHERE part of the outer query (optional)
 * @param string $add_groupby
 *   Text to add to the GROUP BY part of the outer query (optional)
 * @param string $add_orderby
 *   Text to add to the ORDER BY part of the outer query (optional)
 * @return string
 *   The SQL query
 */
function mm_content_get_accessible_nodes_by_mmtid_query($mmtid, &$count_sql, $add_select = '', $add_join = '', $add_inner_where = '', $add_outer_where = '', $add_groupby = '', $add_orderby = '') {
  global $user;

  $mmtid = is_array($mmtid) ? 'IN(' . join(',', $mmtid) . ')' : "= $mmtid";
  // This includes the hack "n.changed AS created" to allow node_feed() to show
  // the changed date instead of the post date. It is called in _mm_render_pages().
  // Woe unto he who attempts to grok this.
  $now = REQUEST_TIME;
  $scheduled = "IFNULL((s.publish_on = 0 OR s.publish_on <= $now) AND (s.unpublish_on = 0 OR $now < s.unpublish_on), 1)";
  $inner =
    'FROM {mm_tree} tr ' .
      "INNER JOIN {mm_node2tree} t ON t.mmtid = tr.mmtid " .
      'INNER JOIN {node} n ON n.nid = t.nid ' .
      'LEFT JOIN {mm_node_schedule} s ON s.nid = n.nid ' .
      "LEFT JOIN {mm_node_reorder} r ON r.nid = n.nid AND r.mmtid = tr.mmtid ";
  $where = " WHERE tr.mmtid $mmtid";
  // skip some tests for users with 'bypass node access' permission
  if (!user_access('bypass node access')) {
    $node_writable = $user->uid > 0 ? " OR (n.uid = $user->uid OR gw.uid = $user->uid OR vw.uid = $user->uid)" : '';
    $inner .=
      'LEFT JOIN {mm_node_write} nw ON nw.nid = n.nid ' .
      'LEFT JOIN {mm_group} gw ON gw.gid = nw.gid ' .
      'LEFT JOIN {mm_virtual_group} vw ON vw.vgid = gw.vgid';
    $where .= " AND (n.status = 1 AND $scheduled$node_writable)$add_inner_where ";
  }
  elseif ($add_inner_where) {
    $where .= $add_inner_where;
  }
  $count_inner = $inner . $add_join . $where;
  $inner .= $where;
  if ($add_outer_where) {
    $count_inner .= $add_outer_where;
    $add_outer_where = ' WHERE' . preg_replace('/^\s*(\S+)/', '', $add_outer_where);    // Remove AND, OR, etc.
  }
  $count_sql = 'SELECT COUNT(DISTINCT n.nid) ' . $count_inner;

  return
    'SELECT n.nid, ' .
      'IF(n.set_change_date = 1 AND n.publish_on > 0, n.publish_on, n.changed) ' .
        'AS created, ' .                                               // creation date
      'n.sticky AND (n.uid = 1 OR n.owns_it OR ' .
        'COUNT(v.uid = n.uid OR g.vgid = 0 AND g.uid = n.uid)) AS stuck, ' . // node is sticky
      "n.scheduled, n.status$add_select " .
      'FROM ' .
        '(SELECT DISTINCT n.*, t.mmtid, r.weight, r.region, s.set_change_date, s.publish_on, ' .
          "$scheduled AS scheduled, " .
          '(n.uid = tr.uid) AS owns_it ' .                            // entry is owned by node's owner
          $inner .
        ') AS n ' .
      "$add_join " .
      "LEFT JOIN {mm_tree_access} a ON a.mode = '" . MM_PERMS_WRITE . "' AND a.mmtid = n.mmtid " .
      'LEFT JOIN {mm_group} g ON a.gid = g.gid ' .
      'LEFT JOIN {mm_virtual_group} v ON g.vgid = v.vgid ' .
        'AND (v.uid = n.uid OR g.vgid = 0 AND g.uid = n.uid) ' .
      $add_outer_where .
      "GROUP BY n.nid$add_groupby " .
      "ORDER BY stuck DESC, n.weight ASC, created DESC$add_orderby";
}

/**
 * Return whether or not the user has some type of access on a given Drupal
 * node. This takes into account both the permissions on the node itself (for
 * writing) and the permissions of the tree entry it's in (for everything else.)
 *
 * @param $node
 *   The node object on which the operation is to be performed.
 * @param $op
 *   The operation to be performed on the node. Possible values are:
 *   - "view"
 *   - "update"
 *   - "delete"
 * @param $account
 *   The user object on which the operation is to be performed. (optional)
 * @return
 *   TRUE if the operation may be performed.
 */
function mm_content_node_access($node, $op, $account = NULL) {
  global $user;
  static $recursive;

  switch ($op) {
    case 'view':
      foreach (mm_module_implements('mm_node_access') as $module) {
        $out = call_user_func_array($module . '_mm_node_access', array($op, $node, $account));
        if (isset($out)) {
          return $out;
        }
      }

      return mm_content_user_can_node($node, MM_PERMS_READ, $account);

    case 'update':
    case 'delete':
      if (!$account) {
        $account = $user;
      }

      if (empty($account->uid)) {
        // failed login
        return FALSE;
      }

      if ($account->uid == 1) {
        // admin user
        return TRUE;
      }

      if (user_access('bypass node access', $account)) {
        return TRUE;
      }

      foreach (mm_module_implements('mm_node_access') as $module) {
        $out = call_user_func_array($module . '_mm_node_access', array($op, $node, $account));
        if (isset($out)) {
          return $out;
        }
      }

      if (isset($node->uid) && $node->uid == $account->uid) {
        // regular owner
        return TRUE;
      }

      // being called recursively from node_access() call, below
      if ($recursive) {
        return;
      }

      if (mm_content_user_can_update_node($node, $account)) {
        $test_node = isset($node->type) ? clone($node) : node_load($node->nid);
        $test_node->uid = $account->uid;
        $recursive = TRUE;
        $ret = node_access($op, $test_node, $account);
        $recursive = FALSE;
        return $ret;
      }
  }
  return FALSE;
}

/**
 * Return whether or not the user can update (write to) a node, based solely on
 * the MM permissions of that node. Page-level permissions are not considered.
 *
 * @param $node
 *   The node object being queried.
 * @param $account
 *   The user to test. (optional)
 * @return
 *   TRUE if the user can update.
 */
function mm_content_user_can_update_node($node, $account = NULL) {
  global $user;
  if (!$account) {
    $account = $user;
  }

  $select = db_select('mm_node_write', 'nw');
  $select->leftJoin('mm_group', 'g', 'nw.gid = g.gid');
  $select->leftJoin('mm_virtual_group', 'v', 'v.vgid = g.vgid');
  $select->fields('nw', array('gid'))
    ->distinct()
    ->condition('nw.nid', $node->nid);

  // everyone, or this user is in a matching group
  if ($account->uid > 0) {
    $select->condition(db_or()
        ->condition('nw.gid', 0)
        ->condition('g.uid', $account->uid)
        ->condition('v.uid', $account->uid)
    );
  }
  else {
    $select->condition(db_or()
        ->condition('nw.gid', 0)
        ->condition('g.uid', 0)
        ->condition('v.uid', 0)
    );
  }

  return $select->countQuery()->execute()->fetchField() > 0;
}

/**
 * Flag a virtual group as needing its data regenerated. The actual update of
 * mm_virtual_group happens during monster_menus_cron().
 *
 * @param $mmtid
 *   Tree/Group ID (not virtual group ID!) of the virtual group to be updated.
 *   Omit or set to NULL to mark all groups for update.
 */
function mm_content_update_vgroup_view($mmtid = NULL) {
  if (!isset($mmtid)) {
    db_update('mm_vgroup_query')
      ->fields(array('dirty' => MM_VGROUP_DIRTY_NEXT_CRON))
      ->condition('dirty', MM_VGROUP_DIRTY_NOT)
      ->execute();
  }
  else {
    // UPDATE {mm_vgroup_query} q INNER JOIN {mm_group} g ON g.vgid = q.vgid
    // SET q.dirty = <MM_VGROUP_DIRTY_NEXT_CRON>
    // WHERE g.gid = $mmtid AND dirty = <MM_VGROUP_DIRTY_NOT>
    $group = db_select('mm_group', 'g')
      ->condition('g.gid', $mmtid)
      ->where('g.vgid = {mm_vgroup_query}.vgid');
    $group
      ->addExpression('COUNT(*)');
    db_update('mm_vgroup_query')
      ->condition($group, '0', '<>')
      ->condition('dirty', MM_VGROUP_DIRTY_NOT)
      ->fields(array('dirty' => MM_VGROUP_DIRTY_NEXT_CRON))
      ->execute();
  }
}

/**
 * Reset the sort order of nodes on a page without affecting their region
 * assignments.
 *
 * @param $mmtid
 *   The Tree ID of the containing page.
 * @param $nid
 *   Optional ID of a particular node to alter. If unset, all nodes are altered.
 */
function mm_content_reset_custom_node_order($mmtid, $nid = NULL) {
  // Remove entries in the "content" region.
  $q = db_delete('mm_node_reorder')
    ->condition('mmtid', $mmtid)
    ->condition('region', NULL);
  if (isset($nid)) {
    $q->condition('nid', $nid);
  }
  $q->execute();

  // Reset order to 0 in all other places.
  $q = db_update('mm_node_reorder')
    ->condition('mmtid', $mmtid)
    ->fields(array('weight' => 0));
  if (isset($nid)) {
    $q->condition('nid', $nid);
  }
  $q->execute();
}

function _mm_content_active_regions() {
  $out = array();
  foreach (list_themes() as $data) {
    if ($data->status) {
      foreach (array_keys($data->info['regions']) as $region) {
        if (!isset($data->info['regions_hidden']) || !in_array($region, $data->info['regions_hidden'])) {
          $out[] = $region;
        }
      }
    }
  }
  return array_unique($out);
}

/**
 * Get a list of allowed content types in one or all regions.
 *
 * @param $region
 *   If set, return just the types for this one region. Otherwise, return an
 *   array indexed by region.
 * @return
 *   An array, as described above.
 */
function mm_content_get_perms_for_region($region = NULL) {
  if (is_null($region)) {
    $out = array();
    foreach (_mm_content_active_regions() as $region) {
      $out[$region] = mm_content_get_perms_for_region($region);
    }
    return $out;
  }

  $list = variable_get('mm_allowed_region_perms', array());
  if (isset($list[$region])) {
    return $list[$region];
  }
  return array('everyone' => $region == MM_UI_REGION_CONTENT, 'users' => array(), 'groups'=> array());
}

/**
 * Get a list of allowed content types in one or all regions.
 *
 * @param $region
 *   If set, return just the types for this one region. Otherwise, return an
 *   array indexed by region.
 * @return
 *   An array, as described above.
 */
function mm_content_get_allowed_types_for_region($region = NULL) {
  if (is_null($region)) {
    $out = array();
    foreach (_mm_content_active_regions() as $region) {
      $out[$region] = mm_content_get_allowed_types_for_region($region);
    }
    return $out;
  }

  $types = variable_get('mm_allowed_region_node_types', NULL);
  if (isset($types[$region])) {
    return $types[$region];
  }
  return 'all';
}

/**
 * Get a list of regions into which a particular user can place nodes.
 *
 * @param $account
 *   The user object to test, or NULL to use the current $user.
 * @param $type
 *   If set, the list is further limited to only those regions that are allowed
 *   for a specific content type.
 * @return
 *   An array containing the names of all allowed regions.
 */
function mm_content_get_allowed_regions_for_user($account = NULL, $type = NULL) {
  static $allowed = array();
  global $user;

  if (!isset($account)) {
    $account = $user;
  }
  $uid = $account->uid;
  $bypass = $uid == 1 || user_access('administer all menus', $account);
  if (!isset($allowed[$uid])) {
    foreach (_mm_content_active_regions() as $region) {
      $ok = FALSE;
      if ($uid) {
        if ($bypass) {
          $ok = TRUE;
        }
        else {
          $perms = mm_content_get_perms_for_region($region);
          if (!empty($perms['everyone']) || isset($perms['users'][MM_PERMS_WRITE]) && in_array($uid, $perms['users'][MM_PERMS_WRITE])) {
            $ok = TRUE;
          }
          else {
            if (!isset($user_groups)) {
              $user_groups = mm_content_get_uids_in_group(NULL, $uid, TRUE, TRUE, FALSE);
            }
            if (isset($perms['groups'][MM_PERMS_WRITE]) && array_intersect($perms['groups'][MM_PERMS_WRITE], $user_groups)) {
              $ok = TRUE;
            }
          }
        }
      }

      if ($ok) {
        $allowed[$uid][] = $region;
      }
    }
  }

  if ($type && !$bypass) {
    $list = $allowed[$uid];
    foreach ($list as $i => $region) {
      $types_for_region = mm_content_get_allowed_types_for_region($region);
      if ($types_for_region !== 'all' && !in_array($type, $types_for_region)) {
        unset($list[$i]);
      }
    }
    return $list;
  }

  return $allowed[$uid];
}

/**
 * Figure out if a given node is assigned to one or more hidden tree entries
 *
 * @param $nid
 *   The node object or node number being queried
 * @param $all_pages
 *   If TRUE, return TRUE when all pages on which the node appears are hidden.
 *   Otherwise, return TRUE if any page is hidden.
 * @return
 *   TRUE if the node is assigned to one or more hidden tree entries
 */
function mm_content_is_hidden_node($nid, $all_pages = TRUE) {
  if (is_object($nid)) {
    $nid = $nid->nid;
  }

  if ($all_pages) {
    $inner = db_select('mm_node2tree', 'n');
    $inner->leftJoin('mm_tree_parents', 'p', 'p.mmtid = n.mmtid');
    $inner->leftJoin('mm_tree', 't', 't.mmtid = p.parent OR t.mmtid = n.mmtid');
    $inner->addExpression('SUM(t.hidden) > 0', 'hidden');
    $inner->condition('n.nid', $nid);
    $inner->groupBy('p.mmtid');
    $select = db_select($inner, 'x');
    $select->addExpression('COUNT(*) = SUM(x.hidden)', 'is_hidden');
    return $select->execute()->fetchField() > 0;
  }

  $select = db_select('mm_node2tree', 'n');
  $select->leftJoin('mm_tree_parents', 'p', 'p.mmtid = n.mmtid');
  $select->leftJoin('mm_tree', 't', 't.mmtid = p.parent OR t.mmtid = n.mmtid');
  return $select->condition('n.nid', $nid)
    ->condition('t.hidden', 1)
    ->countQuery()->execute()->fetchField() > 0;
}

/**
 * Delete a recycling bin tree node, if it's empty
 *
 * @param $bin
 *   Tree ID of the bin to possibly delete
 * @return
 *   An error message, if an error occurs; otherwise, TRUE if the bin was deleted.
 */
function mm_content_delete_bin($bin) {
  $nodes = mm_content_get_nids_by_mmtid($bin, 1);
  if (!$nodes) {    // no nodes in the bin itself
    $tree = mm_content_get_tree($bin, array(MM_GET_TREE_DEPTH => 1));
    if (count($tree) == 1 && $tree[0]->name == MM_ENTRY_NAME_RECYCLE) {  // just the empty bin, and it's definitely a bin
      $err = mm_content_delete($bin, FALSE);
      return $err ? $err : TRUE;
    }
  }
  return FALSE;
}

/**
 * Move content to the recycle bin, creating the bin if needed
 *
 * @param $mmtids
 *   Array, or a single tree ID to move
 * @param $nids
 *   Array, or a single node ID to move. Either an ordered array or an
 *   associative array can be used. If an ordered array is used, then it
 *   contains a list of node IDs which will be moved into a recycle bin for
 *   each page to which they are assigned. If an associative array is used,
 *   then each key must be the node ID and each value must be an array of
 *   Tree IDs from which the node should be removed.
 * @return
 *   Either an error message or the MM Tree ID of the bin
 */
function mm_content_move_to_bin($mmtids = NULL, $nids = NULL) {
  $time = REQUEST_TIME;   // preset, just in case the clock changes during code below
  $bin = NULL;

  if (isset($mmtids)) {    // recycle one or more entries
    if (!is_array($mmtids)) {
      $mmtids = array($mmtids);
    }

    $txn = db_transaction();
    foreach ($mmtids as $mmtid) {
      $bin_parent = mm_content_get_parent($mmtid);
      if (!$bin_parent) {
        return;
      }

      $bin = _mm_content_make_recycle($bin_parent);
      if (!is_numeric($bin)) {
        return $bin;
      }
      $bin = intval($bin);

      if (!($tree = mm_content_get($mmtid))) {
        mm_content_delete_bin($bin);
        return 'error';
      }

      $n = 0;
      $name = $tree->name;
      $alias = $tree->alias;

      while (db_query("SELECT COUNT(*) FROM {mm_tree} WHERE (name = :name OR alias <> '' AND alias = :alias) AND parent = :parent", array(':name' => $name, ':alias' => $alias, ':parent' => $bin))->fetchField()) {
        $n++;
        $name = $tree->name . " ($n)";
        $alias = empty($tree->alias) ? '' : $tree->alias . "-$n";
      }
      if ($n) {
        mm_content_update_quick(array('name' => $name, 'alias' => $alias), array('mmtid' => $mmtid), $tree->parent);
      }

      // Make sure the sort index is up to date, then force a re-read of the
      // source tree entry.
      mm_content_update_sort_queue();
      mm_content_clear_caches($mmtid);

      $err = mm_content_move($mmtid, $bin, 'recycle');
      if ($err) {
        mm_content_delete_bin($bin);
        return $err;
      }

      db_insert('mm_recycle')
        ->fields(array(
          'type' => 'cat',
          'id' => $mmtid,
          'bin_mmtid' => $bin,
          'recycle_date' => $time,
        ))
        ->execute();
    }
  }
  elseif (isset($nids)) {    // recycle one or more nodes
    if (!is_array($nids)) {
      $nids = array($nids);
    }
    else if (!$nids) {
      return;
    }

    // Convert to an associative array, if needed.
    $assoc = array();
    $nid_list = isset($nids[0]) ? $nids : array_keys($nids);
    foreach ($nid_list as $nid) {
      $from_mmtids = mm_content_get_by_nid($nid);
      // If the node is not on any page, create the bin at the root.
      if (!$from_mmtids) {
        $from_mmtids = array(0);
      }
      else {
        // Exclude recycle bins
        foreach ($from_mmtids as $key => $from_mmtid) {
          if (mm_content_is_recycle_bin($from_mmtid)) {
            unset($from_mmtids[$key]);
          }
        }
      }
      // If it's already associative, make sure the supplied mmtid list is
      // valid.
      if (!isset($nids[0])) {
        $from_mmtids = array_intersect($from_mmtids, $nids[$nid]);
      }
      // Convert to associative nid => [array of mmtids] for each nid
      if ($from_mmtids) {
        $assoc[$nid] = $from_mmtids;
      }
    }

    $txn = db_transaction();
    foreach ($assoc as $nid => $from_mmtids) {
      foreach ($from_mmtids as $mmtid) {
        $bin = _mm_content_make_recycle($mmtid);
        if (!is_numeric($bin)) {
          return $bin;
        }
        $bin = intval($bin);

        // Remove from old page.
        db_delete('mm_node2tree')
          ->condition('nid', $nid)
          ->condition('mmtid', $mmtid)
          ->execute();
        // Clear any custom reordering.
        db_delete('mm_node_reorder')
          ->condition('nid', $nid)
          ->condition('mmtid', $mmtid)
          ->execute();
        // Store recovery state in mm_recycle.
        db_merge('mm_recycle')
          ->key(array(
            'type' => 'node',
            'id' => $nid,
            'from_mmtid' => $mmtid))
          ->fields(array(
            'bin_mmtid' => $bin,
            'recycle_date' => $time))
          ->execute();
        // Add to bin.
        db_insert('mm_node2tree')
          ->fields(array(
            'nid' => $nid,
            'mmtid' => $bin))
          ->execute();
        watchdog('mm', 'Recycled node=:nid from mmtid=:mmtid to bin=:bin', array(':nid' => $nid, ':mmtid' => $mmtid, ':bin' => $bin));
      }
    }
    // Clear the cache used by mm_content_get_by_nid.
    mm_content_get_by_nid(NULL, TRUE);
    // Commit.
    unset($txn);
  }

  return $bin;
}

/**
 * Move content out of the recycle bin
 *
 * @param $mmtids
 *   Array, or a single tree ID to move out
 * @param $nodes
 *   Array, or a single node object to move out.
 * @param $node_bin_mmtid
 *   If supplied, the nodes are restored from only this bin. Otherwise, they
 *   are restored from all bins at once; this is usually not the desired result.
 * @return
 *   Either an error message or the MM Tree ID of the bin
 */
function mm_content_move_from_bin($mmtids, $nodes = NULL, $node_bin_mmtid = NULL, $use_watchdog = TRUE) {
  if (isset($mmtids)) {
    if (!is_array($mmtids)) {
      $mmtids = array($mmtids);
    }

    $txn = db_transaction();
    foreach ($mmtids as $mmtid) {
      $bin_parent = mm_content_get_parent($bin = mm_content_get_parent($mmtid));
      $error = mm_content_move($mmtid, $bin_parent, 'restore');

      if (is_string($error)) {
        return $error;
      }

      db_delete('mm_recycle')
        ->condition('type', 'cat')
        ->condition('id', $mmtid)
        ->execute();
      $error = mm_content_delete_bin($bin);
      if (is_string($error)) {
        return $error;
      }
    }
  }
  else if (isset($nodes)) {
    if (!is_array($nodes)) {
      $nodes = array($nodes);
    }

    $txn = db_transaction();
    foreach ($nodes as $node) {
      if (!empty($node_bin_mmtid)) {
        $bins = array($node_bin_mmtid);
        $camefrom = db_query("SELECT from_mmtid FROM mm_recycle WHERE type = 'node' AND id = :nid AND bin_mmtid = :bin_mmtid",
            array(':nid' => $node->nid, ':bin_mmtid' => $node_bin_mmtid))->fetchCol();
      }
      else {
        $bins = $node->recycle_bins;
        $camefrom = $node->recycle_from_mmtids;
      }
      db_delete('mm_recycle')
        ->condition('type', 'node')
        ->condition('id', $node->nid)
        ->condition('bin_mmtid', $bins)
        ->execute();
      foreach ($camefrom as $mmtid) {
        if ($mmtid) {
          db_insert('mm_node2tree')
            ->fields(array('nid' => $node->nid, 'mmtid' => $mmtid))
            ->execute();
          if ($use_watchdog) {
            watchdog('mm', 'Restored node=:nid to :mmtid', array(':nid' => $node->nid, ':mmtid' => $mmtid));
          }
        }
      }

      foreach ($bins as $bin) {
        db_delete('mm_node2tree')
          ->condition('nid', $node->nid)
          ->condition('mmtid', $bin)
          ->execute();
        $err = mm_content_delete_bin($bin);
        if (is_string($err)) {
          return $err;
        }
      }
    }
  }
}

/**
 * Remove references to a node from a page. If the page is a recycle bin, it is
 * deleted if it becomes empty.
 *
 * Note that this function does not ensure that the removed nodes will still
 * appear on a page somewhere after the operation is complete. This is the
 * responsibility of the caller.
 *
 * @param $nids
 *   Array, or a single node ID to remove
 * @param $mmtids
 *   Array, or a single tree ID from which the node(s) should be removed
 * @return
 *   An error message, if there is an error
 */
function mm_content_remove_node_from_page($nids, $mmtids) {
  if (!is_array($nids)) {
    $nids = array($nids);
  }
  if (!is_array($mmtids)) {
    $mmtids = array($mmtids);
  }

  $txn = db_transaction();
  foreach ($mmtids as $mmtid) {
    db_delete('mm_node2tree')
      ->condition('nid', $nids)
      ->condition('mmtid', $mmtid)
      ->execute();
    if (mm_content_is_recycle_bin($mmtid)) {
      $bin = $mmtid;
    }
    else if (mm_content_is_recycled($mmtid)) {
      foreach (array_reverse(mm_content_get_parents($mmtid)) as $bin) {
        if (mm_content_is_recycle_bin($bin)) {
          break;
        }
      }
    }

    if (isset($bin)) {
      db_delete('mm_recycle')
        ->condition('type', 'node')
        ->condition('id', $nids)
        ->condition('bin_mmtid', $bin)
        ->execute();
      if ($bin == $mmtid) {
        $err = mm_content_delete_bin($mmtid);
        if (is_string($err)) {
          return $err;
        }
      }
    }
  }
}

function mm_content_recycle_enabled() {
  return variable_get('mm_recycle_auto_empty', 0) >= 0;
}

function mm_content_is_node_content_block($mmtid) {
  $select = db_select('mm_tree_block', 'tb');
  $select->join('mm_block', 'b', 'tb.bid = b.bid AND b.show_node_contents = :show', array(':show' => 1));
  $select->condition('tb.mmtid', $mmtid);
  return $select->countQuery()->execute()->fetchField();
}

/**
 * Implementation of hook_views_pre_render()
 *
 * Prevent users from seeing results in views they should not be able to. This
 * is imperfect because it removes data without considering pagination, so
 * result sets have an uneven number of results per page. It also does not
 * consider appearance schedule, so nodes may appear when they should not.
 * This code should be considered mostly as a failsafe, to prevent unwanted data
 * disclosure based on permission.
 */
function monster_menus_views_pre_render($view) {
  $cache = array();
  foreach ($view->result as $index => $result) {
    if (!empty($result->nid)) {
      if (!isset($cache[$result->nid])) {
        // Try the fully-loaded entity first, then the node info in the item.
        $entity = isset($result->_field_data['nid']['entity']) ? $result->_field_data['nid']['entity'] : (object)array('nid' => $result->nid);
        $cache[$result->nid] = mm_content_user_can_node($entity, MM_PERMS_READ);
      }
      if (!$cache[$result->nid]) {
        unset($view->result[$index]);
      }
    }
  }
}

/**
 * Implements hook_mm_tree_flags()
 */
function monster_menus_mm_tree_flags() {
  return array(
    'limit_alias' => array('#type' => 'checkbox', '#description' => t('Prevents non-admin users from changing the item\'s alias')),
    'limit_move' => array('#type' => 'checkbox', '#description' => t('Prevents non-admin users from moving the item')),
    'limit_delete' => array('#type' => 'checkbox', '#description' => t('Prevents non-admin users from deleting the item')),
    'limit_hidden' => array('#type' => 'checkbox', '#description' => t('Prevents non-admin users from changing "Don\'t show this page in the menu"')),
    'limit_location' => array('#type' => 'checkbox', '#description' => t('Prevents non-admin users from changing the item\'s location on screen')),
    'limit_name' => array('#type' => 'checkbox', '#description' => t('Prevents non-admin users from changing the item\'s name')),
    'limit_write' => array('#type' => 'checkbox', '#description' => t('Prevents non-admin users from changing "Delete or change settings"')),
    'no_breadcrumb' => array('#type' => 'checkbox', '#description' => t('Prevents the page breadcrumb from showing at this level'), '#flag_inherit' => TRUE),
    'no_index' => array('#type' => 'checkbox', '#description' => t('Adds a meta tag asking crawlers to not index the page'), '#flag_inherit' => TRUE),
    'user_home' => array('#type' => 'textfield', '#description' => t('If a user homepage, contains the uid'), '#flag_copy' => FALSE),
  );
}

/**
 * Insert or update an entry's flags.
 *
 * @param $mmtid
 *   The MM tree ID of the entry to change
 * @param $flags
 *   A single string or array of strings in flag => value format to be added to
 *   the entry
 * @param $clear_old
 *   If TRUE, remove any existing flags. Otherwise, add the new flags to the
 *   existing set. If the calling function has only just created the entry, use
 *   FALSE to avoid the overhead of trying to delete flags that aren't even set.
 */
function mm_content_set_flags($mmtid, $flags, $clear_old = TRUE) {
  if ($clear_old) {
    db_delete('mm_tree_flags')
      ->condition('mmtid', $mmtid)
      ->execute();
    mm_content_notify_change('clear_flags', $mmtid, NULL, $flags);
  }

  if (!empty($flags)) {
    if (!is_array($flags)) {
      $flags = array($flags => '');
    }

    foreach ($flags as $flag => $data) {
      db_insert('mm_tree_flags')
        ->fields(array(
          'mmtid' => $mmtid,
          'flag' => $flag,
          'data' => $data,
        ))
        ->execute();
    }

    mm_content_notify_change('insert_flags', $mmtid, NULL, $flags);
  }
}

/**
 * Get the permissions of an item in the MM tree. NOTE: The data returned by
 * this function should never be displayed directly in the UI, since there can
 * be reasons for it to be hidden from the user. The function
 * mm_content_get_users_in_group() takes this into account.
 *
 * @param $mmtid
 *   The MM tree ID of the entry to query
 * @param $users
 *   Return the permissions of individual users
 * @param $groups
 *   Return the permission groups
 * @param $group_names
 *   When returning groups, set the key to the gid, and the value to the name of
 *   the group. This option should be FALSE (default) if the data is to be
 *   passed to mm_content_set_perms() or mm_content_insert_or_update().
 * @return
 *   An array of arrays [MM_PERMS_READ, MM_PERMS_WRITE, MM_PERMS_SUB,
 *   MM_PERMS_APPLY]['groups', 'users']. All are optional. For 'groups', an
 *   array of gids mapped to their names is returned; for 'users' an array of
 *   uids is returned.
 */
function mm_content_get_perms($mmtid, $users = TRUE, $groups = TRUE, $group_names = FALSE) {
  $empty = array('groups' => array(), 'users' => array());
  $out = array(
    MM_PERMS_WRITE => $empty,
    MM_PERMS_SUB   => $empty,
    MM_PERMS_APPLY => $empty,
    MM_PERMS_READ  => $empty,
  );

  if ($users) {
    $select = db_query(
      'SELECT g.uid, a.mode FROM {mm_tree} t ' .
        'INNER JOIN {mm_tree_access} a ON a.mmtid = t.mmtid ' .
        'INNER JOIN {mm_group} g ON g.gid = a.gid ' .
      'WHERE a.mmtid = :mmtid AND a.gid < 0',
      array(':mmtid' => $mmtid));
    foreach ($select as $row) {
      $out[$row->mode]['users'][] = $row->uid;
    }
  }

  if ($groups) {
    $select = db_query(
      'SELECT a.gid, t2.name, GROUP_CONCAT(a.mode) AS modes FROM {mm_tree} t ' .
        'INNER JOIN {mm_tree_access} a ON a.mmtid = t.mmtid ' .
        'LEFT JOIN {mm_tree} t2 ON a.gid = t2.mmtid ' .
      'WHERE a.mmtid = :mmtid AND a.gid >= 0 ' .
      'GROUP BY a.gid ' .
      'ORDER BY t2.name',
      array(':mmtid' => $mmtid));
    foreach ($select as $row) {
      foreach (explode(',', $row->modes) as $mode) {
        if ($group_names) {
          $out[$mode]['groups'][$row->gid] = $row->name;
        }
        else {
          $out[$mode]['groups'][] = $row->gid;
        }
      }
    }
  }

  return $out;
}

/**
 * Set the permissions of an item in the MM tree
 *
 * @param $mmtid
 *   The MM tree ID of the entry to change
 * @param $perms
 *   An array of arrays [MM_PERMS_READ, MM_PERMS_WRITE, MM_PERMS_SUB,
 *   MM_PERMS_APPLY]['groups', 'users']. All are optional. For 'groups', provide
 *   an array of gids; for 'users' an array of uids.
 * @param $is_group
 *   TRUE if the item is a group
 * @param $clear_old
 *   If TRUE, remove any existing permissions. If the calling function has only
 *   just created the entry, use FALSE to avoid the overhead of trying to delete
 *   permissions that aren't even set.
 * @throws Exception
 *   Any exception occurring during the update
*/
function mm_content_set_perms($mmtid, $perms, $is_group = FALSE, $clear_old = TRUE) {
  foreach (array(MM_PERMS_WRITE, MM_PERMS_SUB, MM_PERMS_APPLY, MM_PERMS_READ) as $m) {
    if ($is_group && $m == MM_PERMS_APPLY) {
      continue;
    }

    if (isset($perms[$m]) && isset($perms[$m]['groups'])) {
      foreach ($perms[$m]['groups'] as $gid) {
        if (empty($gid)) {
          watchdog('mm', 'Empty gid found when setting permissions for mmtid=@mmtid', array('@mmtid' => $mmtid), WATCHDOG_ERROR, "mm/$mmtid");
          drupal_set_message(t('Permissions for this page could not be set, due to an error. Please check for groups that seem to have no name and try again.'), 'error');
          if (function_exists('Adebug')) Adebug();
          return;
        }
      }
    }
  }

  mm_module_invoke_all('mm_content_set_perms', $mmtid, $perms, $is_group, $clear_old);

  $txn = db_transaction();
  try {
    if ($clear_old) {
      if (!$is_group) {
        _mm_content_clear_access_cache($mmtid);
      }

      // Remove ad-hoc groups (gid<0) first
      // DELETE FROM {mm_group} WHERE
      //   (SELECT 1 FROM {mm_tree_access} a WHERE a.gid = {mm_group}.gid
      //     AND a.mmtid = :mmtid AND a.gid < 0)
      $adhoc = db_select('mm_tree_access', 'a');
      $adhoc->addExpression(1);
      $adhoc->where('a.gid = {mm_group}.gid')
        ->condition('a.mmtid', $mmtid)
        ->condition('a.gid', 0, '<');
      mm_retry_query(db_delete('mm_group')
        ->condition($adhoc));

      // Remove everything from mm_tree_access with this mmtid
      mm_retry_query(db_delete('mm_tree_access')
        ->condition('mmtid', $mmtid));
    }

    foreach (array(MM_PERMS_WRITE, MM_PERMS_SUB, MM_PERMS_APPLY, MM_PERMS_READ) as $m) {
      if ($is_group && $m == MM_PERMS_APPLY) {
        continue;
      }

      if (isset($perms[$m]) && isset($perms[$m]['groups'])) {
        foreach ($perms[$m]['groups'] as $gid) {
          if ($gid === 'self') {
            $gid = $mmtid;
          }
          mm_retry_query(db_insert('mm_tree_access')
            ->fields(array(
              'mmtid' => $mmtid,
              'gid' => $gid,
              'mode' => $m,
            )));
        }
      }

      $gid = '';
      if (isset($perms[$m]) && isset($perms[$m]['users'])) {
        foreach ($perms[$m]['users'] as $uid) {
          _mm_content_ad_hoc_group($gid, $uid);
        }
      }

      if ($gid !== '') {
        mm_retry_query(db_insert('mm_tree_access')
          ->fields(array(
            'mmtid' => $mmtid,
            'gid' => $gid,
            'mode' => $m,
          )));
      }
    }
  }
  catch (Exception $e) {
    $txn->rollback();
    throw $e;
  }
}

/**
 * Calculate the likely deletion time of an item in the recycle bin, based on
 * various settings.
 *
 * @param $when
 *   The time when the item was placed into the recycle bin
 * @param $what
 *   Translated string to become part of the result
 * @return
 *   A text string describing when the content will be removed
 */
function mm_content_get_recycle_autodel_time($when, $nid, $mmtids, $what) {
  $run_last = variable_get('mm_cron_run_last', 0);
  $run_since = variable_get('mm_cron_run_since', 0);
  $run_count = variable_get('mm_cron_run_count', 0);
  $interval = variable_get('mm_recycle_auto_empty', 0);
  if (!$run_last || !$run_since || !$run_count || $interval <= 0) {
    return '';
  }

  if (!$when) {
    if (!is_array($mmtids)) {
      $mmtids = !$mmtids ? array() : array($mmtids);
    }

    if ($nid) {
      $mmtids = array_merge($mmtids, mm_content_get_by_nid($nid));
    }

    $allparents = array();
    foreach ($mmtids as $t) {
      if (mm_content_user_can($t, MM_PERMS_IS_RECYCLED)) {
        $allparents = array_merge($allparents, mm_content_get_parents_with_self($t));
      }
    }

    if (!$allparents) {
      return '';
    }

    $select = db_select('mm_recycle', 'r');
    $select->addExpression('MIN(r.recycle_date)');
    $select->condition('r.type', 'cat')
      ->condition('r.id', $allparents)
      ->condition('r.recycle_date', 0, '>');
    $when = $select->execute()->fetchField();
  }
  if (!$when) {
    return '';
  }

  $avg_run = ($run_last - $run_since) / $run_count;
  $fudge = $avg_run / 100;
  $next_run = $run_last + $avg_run;
  if ($when + $interval - $fudge <= $next_run) {
    $which_run = $next_run;
  }
  else {
    $which_run = intval(($when + $interval - $run_since + $avg_run - 1) / $avg_run) * $avg_run + $run_since;
  }

//   debug_add_dump( "run_last=$run_last", "run_since=$run_since", "run_count=$run_count",
//       "interval=$interval", "avg_run=$avg_run", "next_run=$next_run",
//       "time=".REQUEST_TIME, "when=$when", "which_run=$which_run" );
  if (($which_run = $which_run - REQUEST_TIME) <= 0) {
    $when = t('very soon');
  }
  else {
    $when = t('in !when', array('!when' => format_interval($which_run)));
  }

  return t('!what will be automatically deleted !when.', array('!what' => $what, '!when' => $when));
}

/**
 * Based on values stored in a node object, set the correct permissions. This
 * function is usually called in hook_nodeapi() during the insert and update
 * phases.
 *
 * @param $node
 *   A node object
 * @throws Exception
 *   Any exception occurring during the update
 */
function mm_content_set_node_perms($node) {
  if (!empty($node->mm_skip_perms)) {
    return;
  }

  $everyone = !empty($node->mm_others_w_force) || user_access('administer all menus');
  $_mmcucn_cache = &drupal_static('_mmcucn_cache');
  $txn = db_transaction();
  try {
    if (!empty($node->others_w) && $everyone) {
      _mm_ui_delete_node_groups($node, TRUE);

      mm_retry_query(db_insert('mm_node_write')
        ->fields(array('nid' => $node->nid, 'gid' => 0)));
    }
    else {
      _mm_ui_delete_node_groups($node, $everyone);

      if (isset($node->groups_w) && is_array($node->groups_w)) {
        foreach ($node->groups_w as $gid => $name) {
          if ($gid) {
            mm_retry_query(db_insert('mm_node_write')
              ->fields(array('nid' => $node->nid, 'gid' => $gid)));
          }
        }
      }

      if (isset($node->users_w) && is_array($node->users_w)) {
        $adhoc_gid = '';
        foreach ($node->users_w as $uid => $name) {
          if (!empty($uid)) {
            _mm_content_ad_hoc_group($adhoc_gid, $uid);
          }
        }

        if ($adhoc_gid != '') {
          mm_retry_query(db_insert('mm_node_write')
            ->fields(array('nid' => $node->nid, 'gid' => $adhoc_gid)));
        }
      }
    }

    // Remove cached access rights.
    unset($_mmcucn_cache[$node->nid]);
    _mm_content_get_access_cache_object()->clearByNid($node->nid);
  }
  catch (Exception $e) {
    $txn->rollback();
    // Repeat the exception, but with the location below.
    throw new Exception($e->getMessage());
  }
  unset($txn);    // Commit

  mm_content_notify_change('update_node_perms', NULL, $node->nid, array($node->nid => $node));
}

function mm_content_test_showpage_mmtid($mmtid) {
  if (!class_exists('mmctsGetTreeIterator')) {
    class mmctsGetTreeIterator extends getTreeIterator {
      public $match;
      private $path, $router, $pindex;

      public function __construct($path) {
        $this->match = FALSE;
        $this->path = $path;
        $this->pindex = count($path) - 1;
        $this->router = array_keys(_mm_showpage_router());
      }

      public function iterate($item) {
        // function must return 1 if no error, 0 if error, -1 if this node
        // and any of its children should be skipped
        $this->path = array_slice($this->path, 0, $this->pindex + $item->level);
        $this->path[] = $item->alias;
        $txt_path = implode('/', $this->path);

        foreach ($this->router as $key) {
          if (preg_match($key, $txt_path)) {
            $this->match = $item->mmtid;
            return 0;   // stop iterating
          }
        }

        return 1;   // continue
      } // iterate
    }   // class
  }     // !class_exists

  $path = "mm/$mmtid";
  $options = array();
  mm_module_invoke_all_array('url_outbound_alter', array(&$path, &$options, $path));

  $iter = new mmctsGetTreeIterator(explode('/', $path));
  mm_content_get_tree($mmtid, array(MM_GET_TREE_ITERATOR => $iter));
  return $iter->match;
}

// ****************************************************************************
// * Private functions start here
// ****************************************************************************

/**
 * Create a new ad-hoc group, and add users to it
 *
 * @param &$gid
 *   ID of the group to add to. Before this function is called for the first
 *   time, set the passed parameter to ''. This function creates the group
 *   entry, adds the first user to it, and sets $gid to the ID of the new group.
 *   Later iterations reuse this ID.
 * @param $uid
 *   User ID to store in the group
 */
function _mm_content_ad_hoc_group(&$gid, $uid) {
  if ($gid === '') {
    // First time, so get the next gid to use.
    // Start a transaction, so $gid is valid until this function returns
    $txn = db_transaction();
    $gid = db_query('SELECT LEAST(-1, MIN(gid) - 1) FROM {mm_group}')->fetchField();
    if (empty($gid)) {
      $gid = -1;
    }
  }
  mm_retry_query(db_insert('mm_group')
    ->fields(array('gid' => $gid, 'uid' => $uid)));
}

function _mm_content_virtual_dir($mmtid, $par, $level, $state) {
  $ch = chr(-$mmtid);
  if (!ctype_alpha($ch)) {
    $name = function_exists('t') ? t('(other)') : '(other)';
    $alias = '~';
  }
  else {
    $name = $alias = $ch;
  }

  $perms = mm_content_user_can($par);
  $perms[MM_PERMS_WRITE] = $perms[MM_PERMS_APPLY] = FALSE;
  return (object)array(
    'name' => $name,
    'alias' => $alias,
    'mmtid' => $mmtid,
    'parent' => $par,
    'uid' => 1,
    'default_mode' => MM_PERMS_READ,
    'bid' => '',
    'max_depth' => -1,
    'max_parents' => -1,
    'perms' => $perms,
    'level' => $level,
    'is_group' => FALSE,
    'is_user' => TRUE,
    'is_dot' => FALSE,
    'is_virtual' => TRUE,
    'state' => $state,
  );
}

/**
 * Create a new recycling bin, or return the tree ID of the existing one
 *
 * @param $mmtid
 *   The tree ID in which to create the recycle bin. If 0, the user's home
 *   directory is used or, if possible, the top level of the tree.
 * @return
 *   Either the tree ID of the recycling bin or an error string. Use
 *   is_numeric() to evaluate.
 */
function _mm_content_make_recycle($mmtid = 0) {
  global $user;

  if (!$mmtid) {
    if ($user->user_mmtid && mm_content_user_can($user->user_mmtid, MM_PERMS_SUB)) {
      $mmtid = $user->user_mmtid;
    }
    elseif (mm_content_user_can(mm_home_mmtid(), MM_PERMS_SUB)) {
      $mmtid = mm_home_mmtid();
    }
    else {
      return t('Could not create a recycle bin');
    }
  }

  $found = mm_content_get(array('parent' => $mmtid, 'name' => MM_ENTRY_NAME_RECYCLE));
  if ($found) {
    return $found[0]->mmtid;
  }

  return mm_content_insert_or_update(TRUE, $mmtid, array(
    'name' => MM_ENTRY_NAME_RECYCLE,
    'alias' => t('-recycle'),
    'uid' => $user->uid,
  ));
}

function _mm_content_comments_readable($node) {
  if (variable_get('mm_finegrain_comment_readability', FALSE)) {
    $perm = empty($node->comments_readable) ? MM_COMMENT_READABILITY_DEFAULT : $node->comments_readable;
    return user_access($perm);
  }

  return user_access('access comments');
}

function _mm_content_insert_cascaded_setting($mmtid, $name, $desc, $array_key, $data) {
  if ($desc['data_type'] == 'int') {
    if ($data === '' || ($data = intval($data)) == -1) {
      return;
    }
  }
  elseif (!empty($desc['not_empty']) && empty($data)) {
    return;
  }

  if (!isset($desc['use_keys']) || !$desc['use_keys']) {
    $array_key = '';
  }

  db_insert('mm_cascaded_settings')
    ->fields(array(
      'mmtid' => $mmtid,
      'name' => $name,
      'data_type' => $desc['data_type'],
      'multiple' => empty($desc['multiple']) ? 0 : 1,
      'array_key' => $array_key,
      'data' => $data,
    ))
    ->execute();
}

class MMAccessCache extends DrupalDatabaseCache {
  function getMultiple(&$cids) {
    try {
      // Garbage collection necessary when enforcing a minimum cache lifetime.
      $this->garbageCollection($this->bin);

      // When serving cached pages, the overhead of using db_select() was found
      // to add around 30% overhead to the request. Since $this->bin is a
      // variable, this means the call to db_query() here uses a concatenated
      // string. This is highly discouraged under any other circumstances, and
      // is used here only due to the performance overhead we would incur
      // otherwise. When serving an uncached page, the overhead of using
      // db_select() is a much smaller proportion of the request.
      $result = db_query('SELECT cid, data, created, expire, uid, nid, serialized FROM {' . db_escape_table($this->bin) . '} WHERE cid IN (:cids)', array(':cids' => $cids));
      $cache = array();
      foreach ($result as $item) {
        $item = $this->prepareItem($item);
        if ($item) {
          $cache[$item->cid] = $item;
        }
      }
      $cids = array_diff($cids, array_keys($cache));
      return $cache;
    }
    catch (Exception $e) {
      // If the database is never going to be available, cache requests should
      // return FALSE in order to allow exception handling to occur.
      return array();
    }
  }

  function set($cid, $data, $expire = CACHE_PERMANENT, $uid = NULL, $nid = NULL, $mmtid = NULL) {
    $fields = array(
      'serialized' => 0,
      'created' => REQUEST_TIME,
      'expire' => $expire,
      'uid' => $uid,
      'nid' => $nid,
      'mmtid' => $mmtid,
    );
    if (!is_string($data)) {
      $fields['data'] = serialize($data);
      $fields['serialized'] = 1;
    }
    else {
      $fields['data'] = $data;
      $fields['serialized'] = 0;
    }

    try {
      db_merge($this->bin)
        ->key(array('cid' => $cid))
        ->fields($fields)
        ->execute();
    }
    catch (Exception $e) {
      // The database may not be available, so we'll ignore cache_set requests.
    }
  }

  /**
   * Clear cache entries for a set of pages.
   *
   * @param $mmtids
   *   Array of tree IDs to clear.
   */
  function clearByMmtid($mmtids) {
    mm_retry_query(db_delete('mm_access_cache')
      ->condition('mmtid', $mmtids, 'IN'));
  }

  /**
   * Clear cache entries for all nodes appearing on a set of pages and all of
   * their children.
   *
   * @param $mmtids
   *   Array of tree IDs containing the nodes to clear.
   */
  function clearNidsByMmtid($mmtids) {
    // db_delete() doesn't support JOINs, hence this mess.
    // DELETE FROM {mm_access_cache} WHERE
    //   nid IN (SELECT n.nid FROM {mm_node2tree} n
    //     INNER JOIN {mm_tree_parents} p ON p.mmtid = n.mmtid
    //     WHERE p.mmtid IN(:mmtids) OR p.parent IN(:mmtids))
    $inner = db_select('mm_node2tree', 'n');
    $inner->join('mm_tree_parents', 'p', 'p.mmtid = n.mmtid');
    $inner->condition(db_or()
      ->condition('p.mmtid', $mmtids, 'IN')
      ->condition('p.parent', $mmtids, 'IN')
    );
    $inner->fields('n', array('nid'));
    db_delete('mm_access_cache')
      ->condition('nid', $inner, 'IN')
      ->execute();
  }

  /**
   * Clear cache entries associated with a user ID.
   *
   * @param $uid
   *   User ID to clear data for.
   */
  function clearByUid($uid) {
    db_delete('mm_access_cache')->condition('uid', $uid)->execute();
  }

  /**
   * Clear cache entries for a particular node.
   *
   * @param $nid
   *   Node ID to clear data for.
   */
  function clearByNid($nid) {
    db_delete('mm_access_cache')->condition('nid', $nid)->execute();
  }
}

if (class_exists('MemCacheDrupal')) {
  class MMAccessCacheMemcache extends MemCacheDrupal {
    /**
     * Implements DrupalCacheInterface::set().
     */
    function set($cid, $data, $expire = CACHE_PERMANENT, $uid = NULL, $nid = NULL, $mmtid = NULL) {
      parent::set("mm_access:$cid", $data, $expire);
    }

    /**
     * Implements DrupalCacheInterface::get().
     */
    public function get($cid) {
      return parent::get("mm_access:$cid");
    }

    /**
     * Implements DrupalCacheInterface::getMultiple().
     */
    public function getMultiple(&$cids) {
      // Prepend a unique prefix ID to each cid.
      foreach ($cids as &$cid) {
        $cid = "mm_access:$cid";
      }
      $results = parent::getMultiple($cids);
      // Remove the unique prefix.
      $output = array();
      foreach ($results as $cid => $result) {
        $cid = substr($cid, 10);
        $output[$cid] = $result;
      }
      return $output;
    }

    /**
     * Implements DrupalCacheInterface::clear().
     */
    public function clear($cid = NULL, $wildcard = FALSE) {
      if (!empty($cid) && $cid != MEMCACHE_CONTENT_CLEAR) {
        $cid = "mm_access:$cid";
      }
      parent::clear($cid, $wildcard);
    }

    /**
     * Clear cache entries for a set of pages.
     *
     * @param $mmtids
     *   Array of tree IDs to clear.
     */
    function clearByMmtid($mmtids) {
      // If there are too many items, just clear the whole thing, since it's too
      // slow otherwise.
      if (count($mmtids) > variable_get('mm_access_cache_memcache_threshold', 50)) {
        $this->clear('*', TRUE);
      }
      else {
        foreach ($mmtids as $mmtid) {
          $this->clear("$mmtid:", TRUE);
        }
      }
    }

    /**
     * Clear cache entries for all nodes appearing on a set of pages and all of
     * those pages' children.
     *
     * @param $mmtids
     *   Array of tree IDs containing the nodes to clear.
     */
    function clearNidsByMmtid($mmtids) {
      // SELECT DISTINCT n.nid FROM {mm_node2tree} n
      //   INNER JOIN {mm_tree_parents} p ON p.mmtid = n.mmtid
      //   WHERE p.mmtid IN(:mmtids) OR p.parent IN(:mmtids)
      $query = db_select('mm_node2tree', 'n');
      $query->join('mm_tree_parents', 'p', 'p.mmtid = n.mmtid');
      $query->condition(db_or()
        ->condition('p.mmtid', $mmtids, 'IN')
        ->condition('p.parent', $mmtids, 'IN')
      );
      $query->distinct();
      $query->fields('n', array('nid'));
      // If there are too many items, just clear the whole thing, since it's too
      // slow otherwise.
      if ($query->countQuery()->execute()->fetchCol() > variable_get('mm_access_cache_memcache_threshold', 50)) {
        $this->clear('*', TRUE);
      }
      else {
        $result = $query->execute();
        foreach ($result as $row) {
          $this->clearByNid($row->nid);
        }
      }
    }

    /**
     * Clear cache entries associated with a user ID.
     *
     * @param $uid
     *   User ID to clear data for.
     */
    function clearByUid($uid) {
      // There's no way to do this with wildcards, so clear everything.
      $this->clear('*', TRUE);
    }

    /**
     * Clear cache entries for a particular node.
     *
     * @param $nid
     *   Node ID to clear data for.
     */
    function clearByNid($nid) {
      $this->clear(":$nid", TRUE);
    }
  }
}

function _mm_content_access_cache($cid, $data = NULL, $uid = NULL, $nid = NULL, $mmtid = NULL) {
  if ($cache_time = variable_get('mm_access_cache_time', 0)) {
    if (!empty($data)) {
      $expire = REQUEST_TIME + $cache_time;
      return _mm_content_get_access_cache_object()->set($cid, $data, $expire, $uid, $nid, $mmtid);
    }
    elseif ($cache = cache_get($cid, 'mm_access_cache')) {
      if ($cache->expire > REQUEST_TIME) {
        return $cache->data;
      }
    }
  }
  return FALSE;
}

function _mm_content_clear_access_cache($mmtid = NULL) {
  static $list = array(), $pagesize = 1000;
  // Make a list of pages whose permissions or location in the tree have
  // changed, then remove entries from mm_access_cache for all nodes appearing
  // on these pages and their children during hook_exit().
  if (!empty($mmtid) && variable_get('mm_access_cache_time', 0)) {
    if (!is_array($mmtid)) {
      $mmtid = array($mmtid);
    }
    foreach ($mmtid as $m) {
      $list[$m] = TRUE;
    }
    // Delete entries for children of this mmtid immediately, because the list
    // of parents might be changing.
    $cache_obj = _mm_content_get_access_cache_object();
    $page = 0;
    for (;;) {
      $query = db_select('mm_tree_parents', 'p')
        ->fields('p', array('mmtid'))
        ->condition('parent', $mmtid);
      if (count($mmtid) > 1) {
        $query->distinct();
      }
      // Paginate, to prevent possibly using lots of memory.
      $mmtids = $query
        ->range($page * $pagesize, $pagesize)
        ->execute()
        ->fetchCol();
      if ($page++ == 0) {
        $mmtids = array_merge($mmtids, $mmtid);
      }
      if ($mmtids) {
        $cache_obj->clearByMmtid($mmtids);
      }
      if (count($mmtids) < $pagesize) {
        break;
      }
    }
  }
  else {
    // hook_exit() can be called twice, so clear out the list and return the
    // original value. That way the next time we get here it will be empty.
    $return = array_keys($list);
    $list = array();
    return $return;
  }
}

function _mm_content_get_access_cache_object() {
  return _cache_get_object('mm_access_cache');
}
