<?php
// $Id: mm_workflow_access.install 3641 2009-12-10 21:59:47Z dan $

/**
 * @file
 * Installer for mm_workflow_access
 */

/**
 * Implementation of hook_install().
 */
function mm_workflow_access_install() {
  // Make sure our hooks get called after MM's. MM sets a weight of 100, so use 110.
  db_update('system')
    ->fields(array('weight' => '110'))
    ->condition('filename', '%/mm_workflow_access.module', 'LIKE')
    ->execute();
}

/**
 * Implementation of hook_schema().
 */
function mm_workflow_access_schema() {
  $schema['mm_workflow_access'] = array(
    'fields' => array(
      'sid' => array(
        'type' => 'int',
        'not null' => TRUE,
        'disp-width' => '11',
      ),
      'mode' => array(
        'type' => 'varchar',
        'length' => '1',
        'not null' => TRUE,
      ),
      'gid' => array(
        'type' => 'int',
        'not null' => TRUE,
        'disp-width' => '11',
      ),
    ),
    'primary key' => array('sid', 'mode', 'gid'),
    'foreign keys' => array(
      'mm_tree' => array(
        'table' => 'mm_tree',
        'columns' => array(
          'gid' => 'mmtid',
        ),
      ),
    ),
    'description' => 'Workflow permissions via MM groups',
  );
  $schema['mm_workflow_author'] = array(
    'fields' => array(
      'nid' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'disp-width' => '11',
      ),
      'uid' => array(
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'disp-width' => '11',
      ),
    ),
    'primary key' => array('nid'),
    'foreign keys' => array(
      'node' => array(
        'table' => 'node',
        'columns' => array(
          'nid' => 'nid',
        ),
      ),
      'users' => array(
        'table' => 'users',
        'columns' => array(
          'uid' => 'uid',
          'cuid' => 'uid',
        ),
      ),
    ),
    'indexes' => array(
      'uid' => array('uid'),
    ),
    'description' => 'Original author of a node in workflow',
  );
  return $schema;
}

/**
 * Implementation of hook_mm_verify_integrity()
 */
function mm_workflow_access_mm_verify_integrity() {
  return array('MM Workflow Access' => array(
    t('mm_workflow_access.sid refers to missing workflow_states.sid') =>
      "{mm_workflow_access} x LEFT JOIN {workflow_states} s ON s.sid=x.sid WHERE s.sid IS NULL",
    t('mm_workflow_access.gid refers to missing mm_tree.mmtid') =>
      "{mm_workflow_access} x LEFT JOIN {mm_tree} t ON t.mmtid=x.gid WHERE x.gid>0 AND t.mmtid IS NULL",

    t('mm_workflow_author.nid refers to missing node.nid') =>
      "{mm_workflow_author} x LEFT JOIN {node} n ON n.nid=x.nid WHERE n.nid IS NULL",
    t('mm_workflow_author.uid refers to missing users.uid') =>
      "{mm_workflow_author} x LEFT JOIN {users} u ON u.uid=x.uid WHERE u.uid IS NULL AND x.uid>0",
  ));
}

/**
 * Ensure that this module's idea of the author of all nodes having a workflow
 * matches the parent page's permissions.
 */
function mm_workflow_access_update_7000() {
  module_load_include('module', 'mm_workflow_access', 'mm_workflow_access');
  $types_with_wf = array();
  $result = db_query('SELECT DISTINCT type FROM {node}');
  foreach ($result as $node) {
    if (_mm_workflow_access_node_has_workflow($node)) {
      $types_with_wf[] = $node->type;
    }
  }
  if ($types_with_wf) {
    module_load_include('module', 'monster_menus', 'monster_menus');
    $cache = array();
    $result = db_query('SELECT n.nid, GROUP_CONCAT(t.mmtid) AS mmtids FROM {node} n INNER JOIN {mm_node2tree} t ON t.nid = n.nid WHERE n.type IN (:types) GROUP BY n.nid', array(':types' => $types_with_wf));
    foreach ($result as $node) {
      $all_groups = $all_users = array();
      foreach (explode(',', $node->mmtids) as $mmtid) {
        if (!isset($cache[$mmtid])) {
          mm_content_get_default_node_perms($mmtid, $grouplist, $userlist, 100);
          $cache[$mmtid] = array($grouplist, $userlist);
        }
        $all_groups += $cache[$mmtid][0];
        $all_users += $cache[$mmtid][1];
      }

      // The code below is mostly from mm_content_set_node_perms(), but
      // simplified a little and changed so as to not alter the "Everyone"
      // permission.
      $txn = db_transaction();
      try {
        _mm_ui_delete_node_groups($node, FALSE);

        foreach ($all_groups as $gid => $name) {
          if ($gid) {
            mm_retry_query(db_insert('mm_node_write')
              ->fields(array('nid' => $node->nid, 'gid' => $gid)));
          }
        }

        $adhoc_gid = '';
        foreach ($all_users as $uid => $name) {
          if (!empty($uid)) {
            _mm_content_ad_hoc_group($adhoc_gid, $uid);
          }
        }

        if ($adhoc_gid != '') {
          mm_retry_query(db_insert('mm_node_write')
            ->fields(array('nid' => $node->nid, 'gid' => $adhoc_gid)));
        }
      }
      catch (Exception $e) {
        $txn->rollback();
        // Repeat the exception, but with the location below.
        throw new Exception($e->getMessage());
      }
      unset($txn);
    }
  }
}

/**
 * Add missing entries to the mm_workflow_author table.
 */
function mm_workflow_access_update_7001() {
  $result = db_query('SELECT wn.* FROM {workflow_node} wn LEFT JOIN {mm_workflow_author} a ON a.nid = wn.nid WHERE a.nid IS NULL');
  foreach ($result as $row) {
    db_insert('mm_workflow_author')
      ->fields(array('nid' => $row->nid, 'uid' => $row->uid))
      ->execute();
  }
}
