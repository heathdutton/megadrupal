<?php

/**
 * @file
 *   Provides node access permissions based on workflow states.
 */

define('MM_WORKFLOW_PERMS_DELETE', 'd');

function mm_workflow_access_theme() {
  return array(
    'mm_workflow_access_form' => array(
      'render element' => 'form',
    ),
  );
}

function theme_mm_workflow_access_form($variables) {
  $form = $variables['form'];
  $rows = array();
  foreach ($form as $sid => $modes) {
    if (is_numeric($sid)) {
      $row = array(array('data' => '<h3>' . $modes['#title'] . '</h3>'));
      foreach (array(MM_PERMS_READ, MM_PERMS_WRITE, MM_WORKFLOW_PERMS_DELETE) as $mode) {
        $data = drupal_render($modes[$mode]);
        $row[] = array('data' => $data, 'class' => array('align-top'));
      }
      $rows[] = array('data' => $row);
    }
  }

  $header = array(
    t('Workflow state'),
    t('Who can <strong>read</strong> posts in this state'),
    t('Who can <strong>edit/read posts</strong> in this state'),
    t('Who can <strong>delete</strong> posts in this state'),
  );
  return theme('table', array('header' => $header, 'rows' => $rows)) . drupal_render($form['no_read']);
}

/**
 * Implements hook_form_alter().
 */
function mm_workflow_access_form_workflow_admin_ui_edit_form_alter(&$form, $form_state) {
  $form['basic']['instructions'] = array(
    '#type' => 'textarea',
    '#title' => t('Help text'),
    '#default_value' => variable_get('mm_workflow_access_instructions' . $form['wid']['#value'], ''),
    '#rows' => 4,
    '#description' => t('Instructions to the user editing a node, describing what to do with the workflow field')
  );
  $form['workflow_access'] = array(
    '#type' => 'fieldset',
    '#title' => t('Access control'),
    '#collapsible' => TRUE,
    '#tree' => TRUE,
    '#theme' => 'mm_workflow_access_form',
  );

  $perms = array();
  $select = db_select('mm_workflow_access', 'a');
  $select->join('workflow_states', 's', 's.sid = a.sid');
  $result = $select->condition('s.wid', $form['wid']['#value'])
    ->fields('a')
    ->execute();
  foreach ($result as $row) {
    if ($row->gid == 0) {
      $perms[$row->sid][$row->mode]['everyone'] = TRUE;
    }
    elseif ($row->gid < 0) {
      $perms[$row->sid][$row->mode]['author'] = TRUE;
    }
    else {
      $perms[$row->sid][$row->mode]['groups'][$row->gid] = mm_content_get_name($row->gid);
    }
  }

  $states = workflow_get_workflow_states_by_wid($form['wid']['#value']);
  foreach ($states as $state) {
    if (!$state->sysid) {
      $sid = $state->sid;
      $form['workflow_access'][$sid]['#title'] = $state->state;
      foreach (array(MM_PERMS_READ, MM_PERMS_WRITE, MM_WORKFLOW_PERMS_DELETE) as $mode) {
        $form['workflow_access'][$sid][$mode]['everyone'] = array(
          '#type' => 'checkbox',
          '#default_value' => isset($perms[$sid][$mode]['everyone']) ? $perms[$sid][$mode]['everyone'] : FALSE,
          '#name' => "workflow_access[$sid][$mode][everyone]",
          '#attributes' => array('class' => array('wfe-everyone')),
          '#title' => t('everyone'),
          '#weight' => 1,
        );
        $form['workflow_access'][$sid][$mode]['author'] = array(
          '#type' => 'checkbox',
          '#default_value' => isset($perms[$sid][$mode]['author']) ? $perms[$sid][$mode]['author'] : FALSE,
          '#title' => t('the author'),
          '#attributes' => array('class' => array('wfe-author')),
          '#name' => "workflow_access[$sid][$mode][author]",
          '#weight' => 2,
        );
        $form['workflow_access'][$sid][$mode]['groups'] = array(
          '#type' => 'mm_grouplist',
          '#mm_list_popup_start' => mm_content_groups_mmtid(),
          '#mm_list_other_name' => "workflow_access[$sid][$mode][everyone]",
          '#default_value' => isset($perms[$sid][$mode]['groups']) ? $perms[$sid][$mode]['groups'] : array(),
          '#name' => "workflow_access[$sid][$mode][groups]",
          '#weight' => 3,
        );
      }
    }
  }

  $form['#attached']['js'][] = array(
    'data' => <<<'JS'
(function ($) {
Drupal.behaviors.MMworkflowAccessEditForm = {
  attach: function(context) {
    $('input.wfe-everyone:not(.wfe-everyone-processed)', context)
      .addClass('wfe-everyone-processed')
      .click(function() {
        if (this.checked) {
          var p = this.parentNode.parentNode;
          $('input.wfe-author', p).removeAttr('checked');
          $('input:hidden', p)[0].delAll();
        }
      });
    $('input.wfe-author:not(.wfe-author-processed)', context)
      .addClass('wfe-author-processed')
      .click(function() {
        if (this.checked) {
          $('input.wfe-everyone', this.parentNode.parentNode)
            .removeAttr('checked');
        }
      });
  }
};
})(jQuery);
JS
    ,
    'type' => 'inline',
    'scope' => 'footer',
  );

  $form['workflow_access']['no_read'] = array(
    '#type' => 'textarea',
    '#title' => t('Message to users who aren\'t permitted to read the content'),
    '#default_value' => variable_get('mm_workflow_access_no_read' . $form['wid']['#value'], ''),
    '#rows' => 4,
  );

  // Place our block comfortably down the page.
  $form['submit']['#weight'] = 10;
  $form['permissions']['#weight'] = 11;
  $form['#submit'][] = 'mm_workflow_access_form_submit';
}

/**
 * Implements hook_workflow().
 *
 * Update permissions when a node changes workflow state.
 */
function mm_workflow_access_workflow($op, $old_sid, $sid, $node) {
  switch ($op) {
    case 'transition post':
      if ($old_sid != $sid) {
        _mm_workflow_access_set_node_perms($node, $sid);
        mm_content_set_node_perms($node);
        _mm_workflow_access_set_author($node);
        // If the transition is happening during node save, there's no reason to
        // repeat the permissions setting later on.
        $node->mm_skip_perms = TRUE;
      }
      break;

    case 'state delete':
      db_delete('mm_workflow_access')
        ->condition('sid', $old_sid)
        ->execute();
      break;

    case 'workflow delete':
      // $old_sid, here, is really the workflow ID (wid)
      variable_del('mm_workflow_access_instructions' . $old_sid);
      variable_del('mm_workflow_access_no_read' . $old_sid);
      break;
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function mm_workflow_access_form_node_form_alter(&$form, &$form_state, $form_id) {
  global $user;

  $node = $form['#node'];
  if (($wid = _mm_workflow_access_node_has_workflow($node)) !== FALSE) {
    $flow = workflow_get_workflows_by_wid($wid);
    $name = check_plain($flow->name);
    if (isset($form['workflow'][$name])) {
      $form['workflow'][$name]['#description'] = variable_get('mm_workflow_access_instructions' . $wid, '');
    }
    $form['settings_perms']['help1'] = array(
      '#weight' => -2,
      '#type' => 'item',
      '#description' => t('This content\'s permissions are controlled by a workflow.')
    );
    $form['settings_perms']['#title'] = t('Who can edit this content');

    $uid = isset($form['nid']['#value']) ? $node->workflow_author : $user->uid;
    if (isset($form['settings_perms']['table']['everyone'][0][0]['owner'])) {
      $form['workflow']['workflow_author-choose'] = array(
        '#type' => 'textfield',
        '#title' => t('Choose the author'),
        '#autocomplete_path' => 'mm-auto',
        '#description' => theme('mm_autocomplete_desc'),
        '#size' => 30, '#maxlength' => 40,
      );
      $form['workflow']['workflow_author'] = array(
        '#type' => 'mm_userlist',
        '#description' => t('In addition to appearing in the attribution, the content\'s author can be given special permissions within a workflow.'),
        '#title' => t('Author'),
        '#default_value' => array($uid => mm_ui_uid2name($uid)),
        '#mm_list_autocomplete_name' => 'workflow_author-choose',
        '#mm_list_min' => 1,
        '#mm_list_max' => 1,
      );
      $form['settings_perms']['owner'] = array(
        '#type' => 'value',
        '#value' => 1,
      );
    }
    else {
      $form['workflow']['workflow_author'] = array(
        '#type' => 'value',
        '#value' => array($uid => ''),
      );
    }

    if (isset($form['nid']['#value'])) {
      if (!empty($form['settings_perms']['table']['everyone'][0][0]['node-everyone']['#default_value'])) {
        $help2 = t('Everyone can edit this content while it is in the current workflow state.');
      }
      else {
        unset($form['settings_perms']['table']['everyone']);
        $help2 = t('These users and groups can edit this content while it is at the current stage of the workflow:');
        $form['settings_perms']['table']['#readonly'] = TRUE;
        $form['settings_perms']['table']['indiv_tbl'][0]['#mm_owner']['show'] = FALSE;
        if (empty($form['settings_perms']['table']['groups_tbl'][0]['#mm_groups']) && empty($form['settings_perms']['table']['indiv_tbl'][0]['#mm_users'])) {
          unset($form['settings_perms']['table']);
          unset($form['#attached']['js']['settings_perms_summary']);
          $help2 = t('Only administrators can edit this content while it is at the current stage of the workflow.');
        }
      }
    }
    else {
      unset($form['settings_perms']['table']);
      unset($form['#attached']['js']['settings_perms_summary']);
    }
    if (!empty($help2)) {
      $form['settings_perms']['help2'] = array(
        '#weight' => -1,
        '#type' => 'item',
        '#description' => $help2,
      );
    }
  }
}

/**
 * Store permission settings for workflow states.
 */
function mm_workflow_access_form_submit($form, $form_state) {
  variable_set('mm_workflow_access_instructions' . $form_state['values']['wid'], $form_state['values']['instructions']);
  variable_set('mm_workflow_access_no_read' . $form_state['values']['wid'], $form_state['values']['workflow_access']['no_read']);

  foreach ($form_state['values']['workflow_access'] as $sid => $access) {
    // Ignore irrelevant keys.
    if (!is_numeric($sid)) {
      continue;
    }

    $groups_w = array();
    $everyone = $author = FALSE;
    db_delete('mm_workflow_access')
      ->condition('sid', $sid)
      ->execute();

    foreach ($access as $mode => $perms) {
      if ($perms['everyone']) {
        db_insert('mm_workflow_access')
          ->fields(array('sid' => $sid, 'mode' => $mode, 'gid' => 0))
          ->execute();
        if ($mode == MM_PERMS_WRITE) {
          $everyone = TRUE;
        }
      }
      else {
        if ($perms['author']) {
          db_insert('mm_workflow_access')
            ->fields(array('sid' => $sid, 'mode' => $mode, 'gid' => -1))
            ->execute();
          if ($mode == MM_PERMS_WRITE) {
            $author = TRUE;
          }
        }
        foreach (array_keys($perms['groups']) as $gid) {
          db_insert('mm_workflow_access')
            ->fields(array('sid' => $sid, 'mode' => $mode, 'gid' => $gid))
            ->execute();
        }
        if ($mode == MM_PERMS_WRITE) {
          $groups_w = $perms['groups'];
        }
      }
    }

    // Update all nodes having same workflow state to reflect new settings.
    $select = db_select('node', 'n');
    $select->leftJoin('workflow_node', 'wn', 'wn.nid = n.nid');
    $result = $select->condition('wn.sid', $sid)
      ->fields('n', array('nid'))
      ->execute();
    foreach ($result as $node) {
      $node->users_w = NULL;
      $node->groups_w = $groups_w;
      $node->others_w = $everyone;
      $node->mm_others_w_force = TRUE;
      mm_content_set_node_perms($node);
      if ($author) {
        $node->uid = $node->workflow_author = _mm_workflow_access_get_author($node->nid);
        _mm_workflow_access_set_author($node);
      }
    }
  }
  drupal_set_message(t('Workflow access permissions updated.'));
}

/**
 * Implements hook_mm_delete().
 */
function mm_workflow_access_mm_delete($mmtids) {
  db_delete('mm_workflow_access')
    ->condition('gid', $mmtids, 'IN')
    ->execute();
}

/**
 * Implements hook_user_delete().
 */
function mm_workflow_access_user_delete($account) {
  db_delete('mm_workflow_author')
    ->condition('uid', $account->uid)
    ->execute();
}

/**
 * Implements hook_node_load().
 */
function mm_workflow_access_node_load($nodes, $types) {
  $nids = array();
  foreach ($nodes as &$node) {
    if (_mm_workflow_access_node_has_workflow($node) !== FALSE) {
      $nids[] = $node->nid;
    }
  }

  if ($nids) {
    foreach (_mm_workflow_access_get_author($nids) as $nid => $author) {
      $nodes[$nid]->workflow_author = $author;
      $account = user_load($author);
      $nodes[$nid]->workflow_author_name = $account->name;
    }
  }
}

/**
 * Implements hook_node_presave().
 */
function mm_workflow_access_node_presave($node) {
  if (isset($node->workflow_author) && is_array($node->workflow_author)) {
    // Convert workflow_author back to a single number
    $node->workflow_author = mm_ui_mmlist_key0($node->workflow_author);
  }
}

/**
 * Implements hook_node_update().
 */
function mm_workflow_access_node_update($node) {
  if (isset($node->workflow_author)) {
    db_merge('mm_workflow_author')
      ->key(array('nid' => $node->nid))
      ->fields(array('uid' => $node->workflow_author))
      ->execute();
  }
}

/**
 * Implements hook_node_insert().
 */
function mm_workflow_access_node_insert($node) {
  mm_workflow_access_node_update($node);
}

/**
 * Implements hook_node_delete().
 */
function mm_workflow_access_node_delete($node) {
  if (!empty($node->nid)) {
    db_delete('mm_workflow_author')
      ->condition('nid', $node->nid)
      ->execute();
  }
}

/**
 * Implements hook_node_view().
 */
function mm_workflow_access_node_view($node, $view_mode, $langcode) {
  // Prevent the user from seeing content based on their ability to read at
  // this stage of the workflow
  if (($wid = _mm_workflow_access_node_has_workflow($node)) !== FALSE && !_mm_workflow_access_get_user_perm($node, MM_PERMS_READ)) {
    $node->content = array('body' => array('#markup' => variable_get('mm_workflow_access_no_read' . $wid, '')));
    $node->mm_workflow_access_read_denied = TRUE;
  }
}

/**
 * Implements hook_link_alter().
 */
function mm_workflow_access_link_alter(&$links, $node) {
  if (!empty($node->mm_workflow_access_read_denied)) {
    unset($links['comment_add']);
  }
}

/**
 * Implements hook_mm_node_access().
 */
function mm_workflow_access_mm_node_access($op, $node, $account) {
  if ($node->nid && _mm_workflow_access_node_has_workflow($node)) {
    if ($op == 'view') {
      $mode = MM_PERMS_READ;
    }
    elseif ($op == 'update') {
      $mode = MM_PERMS_WRITE;
    }
    elseif ($op == 'delete') {
      $mode = MM_WORKFLOW_PERMS_DELETE;
    }
    else {
      return;
    }

    if (!isset($node->workflow)) {
      $node->workflow = workflow_node_current_state($node);
    }
    return _mm_workflow_access_get_user_perm($node, $mode, $account);
  }
}

/**
 * Implements hook_menu_alter().
 */
function mm_workflow_access_menu_alter(&$callbacks) {
  if (isset($callbacks['mm/%mm_mmtid/node/%node/workflow'])) {
    $callbacks['mm/%mm_mmtid/node/%node/workflow']['access callback'] = '_mm_workflow_access_tab_access';
  }
}

/**
 * Implements hook_preprocess_username().
 */
function mm_workflow_access_preprocess_username(&$variables) {
  $account = $variables['account'];
  // May be set in mm_workflow_access_node_load()
  if (isset($account->workflow_author_name)) {
    // Fix the workflow_author field during node edit preview.
    mm_workflow_access_node_presave($account);
    $variables['name'] = $account->workflow_author_name;
    $variables['uid'] = $account->workflow_author;
    $variables['account'] = user_load($variables['uid']);
    $variables['link_attributes'] = array();
    // Populate link path and attributes if appropriate.
    if ($variables['uid'] && $variables['profile_access']) {
      // We are linking to a local user.
      $variables['link_attributes'] = array('title' => t('View user profile.'));
      $variables['link_path'] = 'user/' . $variables['uid'];
    }
    elseif (!empty($account->homepage)) {
      // Like the 'class' attribute, the 'rel' attribute can hold a
      // space-separated set of values, so initialize it as an array to make it
      // easier for other preprocess functions to append to it.
      $variables['link_attributes'] = array('rel' => array('nofollow'));
      $variables['link_path'] = $account->homepage;
      $variables['homepage'] = $account->homepage;
    }
  }
}

/**
 * Menu access control callback. Determine access to Workflow tab.
 */
function _mm_workflow_access_tab_access($node = NULL) {
  global $user;

  if (user_access('bypass node access')) {
    return TRUE;
  }

  $roles = array_keys($user->roles);
  if (!empty($node->workflow_author) && $node->workflow_author == $user->uid) {
    $roles = array_merge(array('author'), $roles);
  }

  if ($obj = workflow_get_workflow_type_map_by_type($node->type)) {
    $workflow = workflow_get_workflows_by_wid($obj->wid);
    if ($workflow && !empty($workflow->tab_roles)) {
      if (array_intersect($roles, explode(',', $workflow->tab_roles))) {
        return TRUE;
      }
    }
  }

  return FALSE;
}

function _mm_workflow_access_set_author($node) {
  db_update('node')
    ->fields(array('uid' => $node->uid))
    ->condition('nid', $node->nid)
    ->execute();
}

function _mm_workflow_access_node_has_workflow($node) {
  static $cache;
  // Return TRUE only if the workflow form is to be displayed and a workflow
  // is assigned to this node type
  if (empty($node->type)) {
    return FALSE;
  }
  $type = $node->type;
  if (!isset($cache[$type])) {
    $cache[$type] = FALSE;
    if (!empty($node->type) && in_array('node', variable_get('workflow_' . $type, array('node')))) {
      $map = workflow_get_workflow_type_map_by_type($type);
      if (is_object($map) && workflow_get_workflow_states_by_wid($map->wid, array('status' => 1))) {
        $cache[$type] = $map->wid;
      }
    }
  }
  return $cache[$type];
}

function _mm_workflow_access_get_perms($node, $account = NULL) {
  global $user;
  static $cache;

  if (!isset($account)) {
    $account = $user;
  }
  if (!isset($account->uid) || !isset($node->workflow) || !isset($node->workflow_author) || !is_scalar($node->workflow_author)) {
    return array();
  }
  if (user_access('administer all menus', $account)) {
    return array(MM_PERMS_READ, MM_PERMS_WRITE, MM_WORKFLOW_PERMS_DELETE);
  }

  if (!isset($cache[$account->uid][$node->workflow][$node->workflow_author])) {
    $cache[$account->uid][$node->workflow][$node->workflow_author] = array();
    # gid = 0: everyone; gid = -1: author
    $select = db_select('mm_workflow_access', 'a');
    $select->leftJoin('mm_group', 'g', 'a.gid > 0 AND g.gid = a.gid');
    $select->leftJoin('mm_virtual_group', 'v', 'v.vgid = g.vgid');
    $select->fields('a', array('gid', 'mode'));
    $select->condition('a.sid', $node->workflow)
      ->condition(db_or()
        ->condition('v.uid', $account->uid)
        ->condition(db_and()
          ->condition('g.vgid', 0)
          ->condition('g.uid', $account->uid)
        )
        ->condition('a.gid', 0, '<=')
      );
    $result = $select->execute();
    foreach ($result as $mode) {
      if ($mode->gid >= 0 || $node->workflow_author == $account->uid) {
        $cache[$account->uid][$node->workflow][$node->workflow_author][] = $mode->mode;
      }
      else {
        // Author: If the user can add content to any page containing the node,
        // they can write to the node.
        foreach (mm_content_get_by_nid($node->nid) as $mmtid) {
          if (mm_content_user_can($mmtid, MM_PERMS_APPLY, $account)) {
            $cache[$account->uid][$node->workflow][$node->workflow_author][] = $mode->mode;
          }
        }
      }
    }

    if (user_access('view all menus', $account)) {
      $cache[$account->uid][$node->workflow][$node->workflow_author][] = MM_PERMS_READ;
    }
  }
  return $cache[$account->uid][$node->workflow][$node->workflow_author];
}

function _mm_workflow_access_get_user_perm($node, $mode, $account = NULL) {
  $list = _mm_workflow_access_get_perms($node, $account);
  // write also includes read
  if ($mode == MM_PERMS_READ && in_array(MM_PERMS_WRITE, $list)) {
    return TRUE;
  }
  return in_array($mode, $list);
}

function _mm_workflow_access_set_node_perms(&$node, $sid) {
  $node->users_w = $node->groups_w = array();
  $node->others_w = FALSE;
  $node->uid = 1;
  $select = db_select('mm_workflow_access', 'a')
    ->fields('a');
  $select->leftJoin('mm_group', 'g', 'a.gid > 0 AND g.gid = a.gid');
  $result = $select->condition('a.mode', MM_PERMS_WRITE)
    ->condition('a.sid', $sid)
    ->execute();
  foreach ($result as $row) {
    if ($row->gid == 0) {
      // Setting others_w_force makes the change apply in MM, even though
      // this user might not normally have permission
      $node->others_w = $node->mm_others_w_force = TRUE;
      break;
    }
    elseif ($row->gid > 0) {
      $node->groups_w[$row->gid] = '';
    }
    elseif (isset($node->workflow_author)) {
      $node->uid = $node->workflow_author;
    }
  }
}

function _mm_workflow_access_get_author($nids) {
  if (!is_array($nids)) {
    $single = TRUE;
    $nids = array($nids);
  }
  // Default to author uid=1
  $authors = array_fill_keys($nids, 1);
  $q = db_select('mm_workflow_author', 'a')
    ->fields('a', array('nid', 'uid'))
    ->condition('nid', $nids)
    ->execute();
  foreach ($q as $r) {
    $authors[$r->nid] = $r->uid;
  }
  return !empty($single) ? $authors[$nids[0]] : $authors;
}

/**
 * Implements hook_views_data().
 */
function mm_workflow_access_views_data() {
  $data = array();

  // ----------------------------------------------------------------------
  // mm_workflow_author table

  $data['mm_workflow_author']['table']['group'] = t('Workflow');
  // Explain how this table joins to others.
  $data['mm_workflow_author']['table']['join'] = array(
    'node' => array(
      'field' => 'nid',
      'left_field' => 'nid',
    ),
  );
  $data['mm_workflow_author']['table']['entity type'] = 'node';

  $data['mm_workflow_author']['uid'] = array(
    'title' => t('Original author'), // Appears in views UI.
    'help' => t('UID of the user who created the node'),
    'argument' => array(
      'handler' => 'views_handler_argument_user_uid',
      'label' => t('User who created the node'),
    ),
  );
  return $data;
}
