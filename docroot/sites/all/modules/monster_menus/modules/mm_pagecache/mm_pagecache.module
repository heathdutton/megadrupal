<?php

/**
 * @file
 * Receive notifications of node/page changes and purge caches accordingly.
 */

function mm_pagecache_form_system_performance_settings_alter(&$form, &$form_state) {
  $form['caching']['mm_pagecache_cache_page_clear'] = array(
    '#type' => 'checkbox',
    '#title' => t('Automatically clear the page cache for pages or nodes that change'),
    '#default_value' => variable_get('mm_pagecache_cache_page_clear', TRUE),
    '#description' => t('If enabled, any time a page or node is modified, the corresponsing page cache entries are removed. This way, content appears up to date for anonymous users.'),
    '#weight' => -1.5,
  );
  if (module_exists('varnish')) {
    $desc = '';
    if (variable_get('varnish_cache_clear', VARNISH_DEFAULT_CLEAR) != VARNISH_NO_CLEAR && variable_get('cache_class_cache_page') === 'VarnishCache') {
      $icon = theme('image', array('path' => 'misc/watchdog-warning.png', 'width' => 18, 'height' => 18, 'alt' => t('warning'), 'title' => t('warning')));
      $desc = t('<p>!icon In order for this feature to work properly, you must set <em>Varnish Cache Clearing</em> to <em>None</em> on the !link page.</p>', array('!icon' => $icon, '!link' => l(t('Varnish Configuration'), 'admin/config/development/varnish')));
    }
    $form['caching']['mm_pagecache_varnish_clear'] = array(
      '#type' => 'checkbox',
      '#title' => t('Automatically clear the Varnish page cache for pages or nodes that change'),
      '#default_value' => variable_get('mm_pagecache_varnish_clear', TRUE),
      '#description' => t('If enabled, any time a page or node is modified, the corresponsing Varnish cache entries are removed. This causes Varnish to request a new version of the page from Drupal the next time it is needed.') . $desc,
      '#weight' => -1.4,
    );
  }
}

/**
 * Implements hook_exit().
 */
function mm_pagecache_exit($destination = NULL) {
  global $base_root;

  // Purge any Drupal page cache entries that should be invalidated.
  $urls = array();
  foreach (mm_pagecache_mm_notify_change(NULL, NULL, NULL, NULL) as $mmtid) {
    $urls[] = url("mm/$mmtid", array('absolute' => TRUE));
  }

  // Cache clearing might be fairly costly, so sort the list and don't bother
  // to clear the cache for children of a parent that is also being cleared.
  sort($urls);
  $last = '';
  $last_len = 0;
  $use_varnish = module_exists('varnish') && variable_get('mm_pagecache_varnish_clear', TRUE);
  foreach ($urls as $url) {
    if ($last == '' || strcmp($url, $last) && (strncmp($url, $last, $last_len) || $url[$last_len] != '/')) {
      if (variable_get('mm_pagecache_cache_page_clear', TRUE)) {
        cache_clear_all($url, 'cache_page', TRUE);
      }

      if ($use_varnish) {
        if (empty($host)) {
          $host = _varnish_get_host();
          $length_limit = variable_get('varnish_cmdlength_limit', 7500);
        }
        $trunc_url = str_replace($base_root, '', $url);
        // Quote rexep meta-chars and then convert \ to \\
        $trunc_url = substr(str_replace('\\', '\\\\', preg_quote($trunc_url)), 0, $length_limit - 4);
        varnish_purge($host, '^' . $trunc_url . '.*$');
      }

      $last_len = strlen($last = $url);
    }
  }
}

/**
 * Implements hook_mm_notify_change().
 */
function mm_pagecache_mm_notify_change($type, $mmtids, $nids, $data) {
  static $needs_update = array();

  if (is_null($type)) {
    $out = array_keys($needs_update);
    $needs_update = array();
    return $out;
  }

  if (!variable_get('mm_pagecache_cache_page_clear', TRUE) && !variable_get('mm_pagecache_varnish_clear', TRUE)) {
    return;
  }

  $set = array();
  switch ($type) {
    case 'delete_node':
    case 'update_node':
    case 'insert_node':
    case 'update_node_perms':
      if ($nids) {
        if ($data) {
          if (!is_array($data)) {
            $data = array($data->nid => $data);
          }

          foreach ($nids as $nid) {
            if (isset($data[$nid]) && !empty($data[$nid]->mm_catlist) && is_array($data[$nid]->mm_catlist)) {
              $set = array_merge($set, array_keys($data[$nid]->mm_catlist));
            }
            else {
              $set = array_merge($set, mm_content_get_by_nid($nid));
            }
          }
        }
        else {
          foreach ($nids as $nid) {
            $set = array_merge($set, mm_content_get_by_nid($nid));
          }
        }
      }
      break;

    case 'delete_page':
    case 'update_page':
    case 'update_page_quick':
    case 'clear_cascaded':
    case 'insert_cascaded':
    case 'clear_flags':
    case 'insert_flags':
      if ($mmtids) {
        $parent = 0;
        if (is_array($data) && isset($data['parent'])) {
          $parent = $data['parent'];
        }

        if (count($mmtids) == 1 && $parent) {
          $set[] = $parent;
        }
        else {
          if ($parent) {
            $set[] = $parent;
          }

          $set = array_unique(array_merge($set, mm_content_get_parent($mmtids)));
        }
      }
      break;

    case 'move_page':
      $set[] = $data['old_parent'];
      $set[] = $data['new_parent'];
      break;

    case 'move_node':
      $set[] = $data['old_mmtid'];
      $set[] = $data['new_mmtid'];
      break;

    case 'insert_page':
      $set[] = $data['parent'];
      break;
  }

  foreach ($set as $mmtid) {
    $needs_update[$mmtid] = TRUE;
  }
}
