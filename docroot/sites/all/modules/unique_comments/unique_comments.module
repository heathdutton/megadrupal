<?php

/**
 * @file
 * Implements the functionality to ensure originality
 * by requiring unique comments
 */

/**
 * TODO: views integration
 * Exemption textfield autocomplete
 */

/**
 * Implements hook_help().
 */
function unique_comments_help($path, $arg) {
  switch ($path) {
    case 'admin/help#unique_comments':
      $output = '';
      $output .= t('<p>This module aims to address the issue of originality within comments on drupal sites. The configuration options on the !unique_comments_admin_location allow users with the right permissions to set which content types the module should act upon, as well as whether comment originality should stretch across the entire site or just on a per node basis.</p>', array('!unique_comments_admin_location' => l(t('administration page'), 'admin/config/content/unique_comments')));
      $output .= t('<p>Specifically the site wide setting will only allow completely unique comments to be posted on the site for content types that have unique comments enabled. The per node setting specifies that for content of content types that have been selected, comments may not be the same as any that have already been made for that node.</p>');

      $output .= t('<p>There are two overrides for unique comments that allows users to bypass any restrictions. If a node has a matching NID to one set in the configuration then it will not be affected. If a user has the permission "bypass unique comments" then they will not be subjected to the restrictions imposed by the module</p>');

      return $output;
      break;
  }
}

/**
 * Implements hook_permission().
 */
function unique_comments_permission() {
  return array(
    'bypass unique comments' => array(
      'title' => t('Bypass Unique Comments: Creating Comments'),
      'description' => t('Unique Comments does not apply to users with this permission'),
    ),
    'own node unique comments' => array(
      'title' => t('Bypass Unique Comments: Own Nodes'),
      'description' => t('Users with this role are able to set nodes they
create to bypass the Unique Comments validation. This adds the node ID to
an allow list.'),
    ),
    'all node unique comments' => array(
      'title' => t('Bypass Unique Comments: All Nodes'),
      'description' => t('Users with this role can set any node to bypass the
Unique Comments validation.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function unique_comments_menu() {
  $items['admin/config/content/unique_comments'] = array(
    'title' => 'Unique Comments',
    'description' => 'Administer global Unique Comments settings to ensure original comments only get posted.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('unique_comments_admin_form'),
    'access arguments' => array('administer comments'),
    'file' => 'unique_comments.admin.inc',
  );
  $items['admin/config/content/unique_comments/admin'] = array(
    'title' => 'Settings',
    'description' => 'Administer global Unique Comments settings to ensure original comments only get posted.',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/config/content/unique_comments/nodes'] = array(
    'title' => 'Exempt Nodes',
    'description' => 'List, create and delete node IDs that are exempt from Unique Comments',
    'page callback' => 'unique_comments_node_list',
    'access arguments' => array('administer comments'),
    'file' => 'unique_comments.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/config/content/unique_comments/delete'] = array(
    'title' => 'Delete Exemption',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('unique_comments_node_exemption_delete'),
    'access arguments' => array('administer comments'),
    'file' => 'unique_comments.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/content/unique_comments/add'] = array(
    'title' => 'Add new exemption',
    'description' => 'Exempt a node ID from being affected by Unique Comments',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('unique_comments_node_exemption_add'),
    'access arguments' => array('administer comments'),
    'file' => 'unique_comments.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  return $items;
}

/**
 * Implements hook_form_alter().
 *
 * To add in an additional validation
 * function for comments on ALL content types.
 */
function unique_comments_form_alter(&$form, &$form_state, $form_id) {
  // Check that it is a node edit form and the node has been created.
  if (drupal_substr($form_id, -9) == 'node_form') {

    $allowed = variable_get('unique_comments_content_types', array());
    $nodetype = $form['#node']->type;
    if (in_array($nodetype, $allowed, TRUE)) {
      $unique_comments = isset($form['nid']['#value']) ? unique_comments_node_is_disabled($form['nid']['#value']) : FALSE;
      $form['unique_comments_storage'] = array(
        '#type' => 'value',
        '#value' => $unique_comments,
      );

      global $user;
      if ($user->uid == $form['uid']['#value']) {
        $access = 'own node unique comments';
      }
      else {
        $access = 'all node unique comments';
      }
      $form['unique_comments'] = array(
        '#type' => 'fieldset',
        '#title' => t('Unique Comments'),
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
        '#group' => 'additional_settings',
        '#access' => user_access($access),
        'unique_comments_disable' => array(
          '#type' => 'checkbox',
          '#title' => t('Disable Unique Comments for this node.'),
          '#default_value' => $unique_comments,
        ),
        '#attributes' => array(
          'class' => array('unique-comments-node-settings-form'),
        ),
        '#attached' => array(
          'js' => array(drupal_get_path('module', 'unique_comments') . '/unique-comments-node-form.js'),
        ),
      );
    }
  }
  // Adds in comment validation on the comment forms so each comment
  // can be checked.
  if ($form['#id'] == 'comment-form') {
    $form['#validate'][] = 'unique_comments_comment_form_validate';
  }
  // The following acts on the admin/content page giving the column displaying
  // the status of Unique Comments for each node. Has to ignore confirm
  // forms as with no table on the confirm page it cannot format correctly.
  if ($form_id == 'node_admin_content' && !isset($form['confirm'])) {
    $form['admin']['nodes']['#header']['unique_comments'] = array('data' => 'Unique Comments');
    if (isset($form['admin']['nodes']['#options'])) {
      $key = '#options';
    }
    else {
      $key = '#rows';
    }
    $rows = $form['admin']['nodes'][$key];
    foreach ($rows as $nid => $row) {
      $status = unique_comments_node_is_disabled($nid) ? t('Disabled') : t('Enabled');
      $form['admin']['nodes'][$key][$nid]['unique_comments'] = array('data' => $status);
    }
  }
}

/**
 * Implements hook_node_insert().
 *
 * To save the NID if Unique Comments is disabled on a new node
 */
function unique_comments_node_insert($node) {
  if (isset($node->unique_comments_disable)) {
    if ($node->unique_comments_disable == 1 && !$node->unique_comments_storage) {
      unique_comments_act_on_node('add', $node);
      drupal_set_message(t('Unique Comments disabled for node @nid', array('@nid' => $node->nid)), 'status');
    }
  }
}

/**
 * Implements hook_node_update().
 *
 * To save/remove the NID if Unique Comments is disabled/enabled
 * on a node upon node update.
 */
function unique_comments_node_update($node) {
  // Have to load the user who is updating the node as it may be
  // different to the user that created the node ($node->uid).
  global $user;
  $node->uid = $user->uid;
  if (isset($node->unique_comments_disable)) {
    if ($node->unique_comments_disable == 1 && !$node->unique_comments_storage) {
      unique_comments_act_on_node('add', $node);
      drupal_set_message(t('Unique Comments disabled for node @nid', array('@nid' => $node->nid)), 'status');
    }
    elseif ($node->unique_comments_disable == 0 && $node->unique_comments_storage) {
      unique_comments_act_on_node('remove', $node);
      drupal_set_message(t('Unique Comments enabled for node @nid', array('@nid' => $node->nid)), 'status');
    }
  }
}

/**
 * Checking function for Unique Comments. Returns TRUE if Unique Comments
 * is disabled and FALSE if enabled (default)
 */
function unique_comments_node_is_disabled($nid) {
  // Check the $nid to see if it is in the Unique Comments db.
  $query = db_query('SELECT uc.nid FROM {unique_comments} uc WHERE uc.nid = :nid', array(':nid' => $nid));
  $disabled = $query->rowCount() ? TRUE : FALSE;
  return $disabled;
}

/**
 * Handles all adding and removing of NIDs from the disabled list.
 */
function unique_comments_act_on_node($op, $node) {
  switch ($op) {
    case 'add':
      // Add to the Unique Comments db.
      db_insert('unique_comments')
        ->fields(array(
          'nid' => $node->nid,
          'uid' => $node->uid,
          'added' => $node->changed,
        ))
        ->execute();
      break;

    case 'remove':
      // Remove from the Unique Comments db.
      db_delete('unique_comments')
        ->condition('nid', $node->nid)
        ->execute();
      break;
  }
}

/**
 * Validation function for Unique Comments comment submit.
 */
function unique_comments_comment_form_validate($form, &$form_state) {

  // Load up the Unique Comment settings on each validation
  // to decide if we need to validate or not.
  $status = variable_get('unique_comments_status');
  $allowed = variable_get('unique_comments_content_types', array());
  $nodetype = $form['#node']->type;
  $exempt_nodes = unique_comments_node_is_disabled($form['#node']->nid);

  // If the node type is one selected to receive validation
  // and the user can't bypass and the node isn't excepted.
  if (!empty($allowed[$nodetype]) && !user_access("bypass unique comments") && !$exempt_nodes) {
    foreach ($form_state['values']['comment_body'] as $lang => $v) {
      switch ($status) {
        case 'Site Wide':
          if (db_select('field_data_comment_body', 'cb')
          ->fields('cb', array('entity_type', 'comment_body_value'))
          ->condition('entity_type', array('comment'))
          ->condition('comment_body_value', array($v[0]['value']))
          ->execute()
          ->fetchAll()) {
            form_set_error('comment_body', t('Your comment lacks originality and has been submitted on this site before!'));
          }
          break;

        case 'Per Node':
          $query = db_select('field_data_comment_body', 'cb');
          $query->join('comment', 'c', 'cb.entity_id = c.cid');
          $result = $query
            ->fields('cb', array('entity_type', 'comment_body_value'))
            ->condition('entity_type', array('comment'))
            ->condition('comment_body_value', array($v[0]['value']))
            ->condition('nid', array($form_state['values']['nid']))
            ->execute();
          if ($result->fetchAll()) {
            form_set_error('comment_body', t('Your comment lacks originality and has been submitted on this on this piece of content before!'));
          }
          break;

        default:
          break;
      }
    }
  }
}
/**
 * Implements hook_node_operations().
 * Required to add in batch operations from the admin/content page
 */
function unique_comments_node_operations() {
  $operations = array(
    'unique_comments_exclude' => array(
      'label' => t('Disable Unique Comments for selected content'),
      'callback' => 'unique_comments_batch_process',
      'callback arguments' => array('operation' => 'add'),
    ),
    'unique_comments_include' => array(
      'label' => t('Enable Unique Comments for selected content'),
      'callback' => 'unique_comments_batch_process',
      'callback arguments' => array('operation' => 'remove'),
    ),
  );
  return $operations;
}

/**
 * Batch operations callback for updating multiple nodes at once
 */
function unique_comments_batch_process($node, $op) {
  $batch = array(
    'operations' => array(
      array('unique_comments_batch_operation', array($node, $op)),
    ),
    'finished' => 'unique_comments_batch_finished',
    'title' => t('Unique Comments Update Content.'),
    'init_message' => t('Initializing.'),
    'progress_message' => t(''),
    'error_message' => t('Error in Unique Comments batch operation.'),
  );
  batch_set($batch);

  batch_process('admin/content');
}

/**
 * The actual operation to update unique comments status for nodes.
 * Does both enabling and disabling for unique comments.
 */
function unique_comments_batch_operation($node, $op, &$context) {
  global $user;
  if (!isset($context['sandbox']['progress'])) {
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['current_node'] = 0;
    $context['sandbox']['nodes'] = $node;
    $context['sandbox']['max'] = count($node);
  }

  // Process nodes by groups of 5.
  $count = min(5, count($context['sandbox']['nodes']));

  for ($i = 1; $i <= $count; $i++) {
    $nid = array_shift($context['sandbox']['nodes']);

    if ($op == 'remove' || ($op == 'add' && !unique_comments_node_is_disabled($nid))) {

      $nodeobj = new stdClass;
      $nodeobj->nid = $nid;
      $nodeobj->uid = $user->uid;
      $nodeobj->changed = REQUEST_TIME;

      unique_comments_act_on_node($op, $nodeobj);
    }

    $context['results'][] = t('Finished @nid', array('@nid' => $nid));
    $context['sandbox']['progress']++;
    $context['sandbox']['current_node'] = $nid;
  }

  if ($context['sandbox']['progress'] != $context['sandbox']['max']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
}

/**
 * Finished callback for batch operations
 */
function unique_comments_batch_finished($success, $results, $operations) {
  if ($success) {
    $message = t('The update has been performed.');
    $message .= theme('item_list', $results);
    $status = 'status';
  }
  else {
    $error = reset($operations);
    $message = t('An error occured whilst processing %error with arguments: @arguments', array('%error' => $error[0], '@arguments' => print_r($error[1], TRUE)));
    $status = 'error';
  }
  drupal_set_message($message, $status);
}


/**
 * Implements hook_node_delete().
 *
 * Have to ensure that when the node is deleted, its record is also
 * deleted from the unique comments table.
 */
function unique_comments_node_delete($node) {
  unique_comments_act_on_node('remove', $node);
}
