<?php
/**
 * @file
 * Code for the Word link exchange module.
 */

/**
 * Implements hook_menu().
 */
function word_link_exchange_menu() {
  $items  = array();

  $items['admin/config/content/word-link/import'] = array(
    'title' => 'Import',
    'description' => 'Import from file or terms',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('word_link_exchange_import_form'),
    'access arguments' => array('create word link'),
    'weight' => 1,
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/config/content/word-link/export'] = array(
    'title' => 'Export',
    'description' => 'Export to file',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('word_link_exchange_export_form'),
    'access arguments' => array('view word link'),
    'weight' => 1,
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Implements hook_cron().
 */
function word_link_exchange_cron() {
  // Sccan public directory for word-link csv files and delete it.
  $file_list = file_scan_directory('public://', '/word_link_[0-9]{2}_[0-9]{2}_[0-9]{4}T[0-9]{2}_[0-9]{2}(|_[0-9]{1,2}).csv/');
  if (!empty($file_list)) {
    foreach ($file_list as $file) {
      file_unmanaged_delete($file->uri);
    }
  }
}

/**
 * Import form.
 */
function word_link_exchange_import_form() {
  $form = array();
  if (function_exists('taxonomy_get_vocabularies')) {
    $vocabularies = taxonomy_get_vocabularies();
  }
  $delimiter = array(
    'semicolon' => t('« ; » (Semicolon)'),
    'comma' => t('« , » (Comma)'),
    'tabulation' => t('«   » (Tabulation)'),
    'pipe' => t('« | » (Pipe)'),
    'space' => t('«   » (Space)'),
    'currency_sign' => t('« ¤ » (Currency sign)'),
    'custom_delimiter' => t('Custom delimiter'),
  );

  $form['override_defaults'] = array(
    '#type' => 'checkbox',
    '#title' => t('Override defaults'),
  );
  $form['override'] = array(
    '#type' => 'container',
    '#states' => array(
      'invisible' => array(
        ':input[name="override_defaults"]' => array('checked' => FALSE),
      ),
    ),
  );
  $form['override']['case_sensitive'] = array(
    '#type' => 'checkbox',
    '#title' => t('Case sensitive'),
  );

  // Show import from taxonomy only when we have vocabularies.
  if (!empty($vocabularies)) {
    $vids = array();
    foreach ($vocabularies as $vocabulary) {
      $vids[$vocabulary->vid] = $vocabulary->name . ' (vid:' . $vocabulary->vid . ')';
    }
    $form['taxonomy'] = array(
      '#type' => 'fieldset',
      '#title' => t('Import from taxonomy'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );
    $form['taxonomy']['vocabularies'] = array(
      '#type' => 'select',
      '#title' => t('Select vocabularies'),
      '#options' => $vids,
      '#multiple' => TRUE,
    );
    $form['taxonomy']['import_limit'] = array(
      '#type' => 'textfield',
      '#size' => 4,
      '#maxlenghth' => 4,
      '#default_value' => 250,
      '#title' => t('Import limit'),
      '#description' => t('This counts of terms will be processed by one page request.'),
    );
  }

  $form['import'] = array(
    '#type' => 'fieldset',
    '#title' => t('Import from file'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $form['import']['file'] = array(
    '#type' => 'file',
    '#title' => t('CSV file'),
    '#size' => 50,
    '#description' => t('A comma separated (<em>.csv</em>) file.'),
  );
  $form['import']['delimiter'] = array(
    '#type' => 'select',
    '#title' => t('Delimiter'),
    '#options' => $delimiter,
  );
  $form['import']['delimiter_custom'] = array(
    '#type' => 'textfield',
    '#title' => 'Custom delimiter',
    '#size' => 2,
    '#maxlength' => 1,
    '#description' => t('Specify your custom delimiter.'),
    '#states' => array(
      'visible' => array(
        ':input[name=delimiter]' => array('value' => 'custom_delimiter'),
      ),
    ),
  );
  $form['import']['update'] = array(
    '#type' => 'checkbox',
    '#title' => t('Only update values'),
    '#description' => t('If checked, new words will be added and old will be updated. If not, only new words will be added.'),
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Import'),
  );

  return $form;
}

/**
 * Validate for word_link_exchange_import_form.
 */
function word_link_exchange_import_form_validate($form, &$form_state) {
  // Preload file.
  $file = file_save_upload('file', array('file_validate_extensions' => array('csv txt')), FALSE, FILE_EXISTS_REPLACE);

  if (!empty($file)) {
    $file->filepath = drupal_realpath($file->uri);
    if (!empty($file->filepath)) {
      $content = file($file->filepath);
      $values = array();
      switch ($form_state['values']['delimiter']) {
        case 'comma':
          $delimiter = ',';
          break;

        case 'semicolon':
          $delimiter = ';';
          break;

        case 'tabulation':
          $delimiter = "\t";
          break;

        case 'pipe':
          $delimiter = '|';
          break;

        case 'space':
          $delimiter = ' ';
          break;

        case 'currency_sign':
          $delimiter = '¤';
          break;

        case 'custom_delimiter':
          if ($form_state['values']['delimiter_custom'] !== '') {
            $delimiter = $form_state['values']['delimiter_custom'];
          }
          else {
            $messages['delimiter_custom'] = t('Delimiter is required.');
          }
          break;
      }
      if (!isset($messages['delimiter_custom'])) {
        foreach ($content as $row) {
          $row = str_getcsv($row, $delimiter);
          if (count($row) == 10) {
            $values[] = $value = array(
              'text' => $row[0],
              'case_sensitive' => $row[1],
              'url' => $row[2],
              'url_title' => $row[3],
              'class' => $row[4],
              'visibility' => $row[5],
              'weight' => $row[6],
              'rel' => $row[7],
              'status' => $row[8],
              'except' => $row[9],
            );
          }
          else {
            $messages['file'] = t('Wrong file or delimiter.');
          }
        }
        $form_state['values']['file'] = $values;
      }
    }
  }
  if (isset($form['taxonomy'])) {
    if (empty($form_state['values']['import_limit']) || $form_state['values']['import_limit'] < 0) {
      $messages['import_limit'] = t('Import limit must be positive integer.');
    }

    if (empty($file) && empty($form_state['values']['vocabularies'])) {
      $messages['vocabularies'] = t('Please select something.');
      $messages['file'] = '';
    }
  }

  // Set error messages.
  if (isset($messages)) {
    foreach ($messages as $item => $message) {
      form_set_error(check_plain($item), filter_xss($message));
    }
  }
}

/**
 * Submit for word_link_exchange_import_form.
 */
function word_link_exchange_import_form_submit($form, &$form_state) {
  $operations = array();

  $case_sensitive = 'default';
  if ($form_state['values']['override_defaults']) {
    $case_sensitive = $form_state['values']['case_sensitive'];
  }

  // Set batch operation when import from file.
  if (!empty($form_state['values']['file'])) {
    $operations[] = array(
      'word_link_exchange_import_from_file',
      array(
        $form_state['values']['file'],
        $form_state['values']['update'],
        $case_sensitive,
      ),
    );
  }

  // Set batch operation when import from taxonomy.
  if (!empty($form_state['values']['vocabularies'])) {
    foreach ($form_state['values']['vocabularies'] as $vid) {
      $operations[] = array(
        'word_link_exchange_import_from_taxonomy',
        array(
          $vid,
          $form_state['values']['import_limit'],
          $case_sensitive,
        ),
      );
    }
  }

  $batch = array(
    'title' => t('Importing links...'),
    'operations' => $operations,
    'finished' => 'word_link_exchange_import_batch_finish',
  );
  batch_set($batch);
}

/**
 * Import links from file to DB.
 */
function word_link_exchange_import_from_file($values, $update, $case_sensitive, &$context) {
  if (empty($context['results'])) {
    $context['results']['created'] = 0;
    $context['results']['updated'] = 0;
    $context['results']['processed'] = 0;
  }
  foreach ($values as $value) {
    $value['case_sensitive'] = $case_sensitive !== 'default' ? $case_sensitive : $value['case_sensitive'];
    $exist = word_link_exists($value['text']);
    $value['except'] = str_replace('|', "\n", str_replace('"', '', trim($value['except'])));
    word_link_save($value);
    if (!$exist) {
      $context['results']['created']++;
    }
    elseif ($exist && $update) {
      $context['results']['updated']++;
    }
    $context['results']['processed']++;
    $context['message'] = t(
      'Created @created items. Updated @updated items. Processed @processed items.',
      array(
        '@created' => $context['results']['created'],
        '@updated' => $context['results']['updated'],
        '@processed' => $context['results']['processed'],
      )
    );
  }
}

/**
 * Import links from taxonomy terms to DB.
 */
function word_link_exchange_import_from_taxonomy($vid, $limit, $case_sensitive, &$context) {
  if (empty($context['sandbox'])) {
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['max'] = word_link_exchange_get_count_taxonomy_terms($vid);
  }
  if (empty($context['results'])) {
    $context['results']['processed'] = 0;
    $context['results']['created'] = 0;
  }
  $tree = word_link_exchange_get_taxonomy_terms($vid, $context['sandbox']['progress'], $limit);
  foreach ($tree as $term) {
    $exist = word_link_exists($term->name);
    if (!$exist) {
      $value = array(
        'text' => $term->name,
        'case_sensitive' => $case_sensitive !== 'default' ? $case_sensitive : 1,
        'url' => 'taxonomy/term/' . $term->tid,
        'url_title' => $term->name,
        'visibility' => 0,
        'except' => NULL,
      );
      word_link_save($value);
      $context['results']['created']++;
    }
    $context['results']['processed']++;
    $context['sandbox']['progress']++;
    $context['message'] = t(
      'Created @created items. Processed @processed items.',
      array(
        '@created' => $context['results']['created'],
        '@processed' => $context['results']['processed'],
      )
    );
  }
  if ($context['sandbox']['progress'] != $context['sandbox']['max']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
}

/**
 * Get count of taxonomy terms from DB.
 *
 * @param int $vid
 *   Vocabulary id.
 *
 * @return int
 *   Return count of terms.
 */
function word_link_exchange_get_count_taxonomy_terms($vid) {
  $query = db_select('taxonomy_term_data', 't');
  $query->condition('t.vid', $vid, '=');
  $result = $query->countQuery()->execute()->fetchField();

  return $result;
}

/**
 * Get taxonomy terms from DB.
 *
 * @param int $vid
 *   Vocabulary id.
 * @param int $from
 *   Start from.
 * @param int $limit
 *   Query limit.
 *
 * @return array
 *   Array with taxonomy terms.
 */
function word_link_exchange_get_taxonomy_terms($vid, $from, $limit) {
  $query = db_select('taxonomy_term_data', 't');
  $query->range($from, $limit);
  $result = $query->fields('t', array('name', 'tid'))->condition('t.vid', $vid)->orderBy('t.tid')->execute();

  foreach ($result as $term) {
    $terms[$term->tid] = $term;
  }
  return $terms;
}

/**
 * Batch import finish.
 */
function word_link_exchange_import_batch_finish($success, $results, $operations) {
  if ($success) {
    cache_clear_all('*', 'cache_filter', TRUE);
    field_cache_clear();
    drupal_set_message(format_plural($results['created'], 'One word imported.', '@count words imported.'));
    if (isset($results['updated'])) {
      drupal_set_message(format_plural($results['updated'], 'One word updated.', '@count words updated.'));
    }
    drupal_set_message(format_plural($results['processed'], 'One item processed.', '@count items processed.'));
  }
  else {
    drupal_set_message(t('Finished with an error.'), 'error');
  }
}

/**
 * Export taxonomy to word link form.
 */
function word_link_exchange_export_form() {
  $form = array();

  $delimiter = array(
    'semicolon' => t('« ; » (Semicolon)'),
    'comma' => t('« , » (Comma)'),
    'tabulation' => t('«   » (Tabulation)'),
    'pipe' => t('« | » (Pipe)'),
    'space' => t('«   » (Space)'),
    'currency_sign' => t('« ¤ » (Currency sign)'),
    'custom_delimiter' => t('Custom delimiter'),
  );
  $line_ending = array(
    'unix' => t('Unix / Linux'),
    'mac' => t('Apple Mac'),
    'ms' => t('Microsoft DOS'),
  );

  $form['export'] = array(
    '#type' => 'fieldset',
    '#title' => t('Export to CSV file'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  $form['export']['delimiter'] = array(
    '#type' => 'select',
    '#title' => t('Delimeter'),
    '#options' => $delimiter,
  );
  $form['export']['delimiter_custom'] = array(
    '#type' => 'textfield',
    '#title' => 'Custom delimiter',
    '#size' => 2,
    '#maxlength' => 1,
    '#description' => t('Specify your custom delimiter.'),
    '#states' => array(
      'visible' => array(
        ':input[name=delimiter]' => array('value' => 'custom_delimiter'),
      ),
    ),
  );
  $form['export']['line_ending'] = array(
    '#type'          => 'select',
    '#title'         => t('Line ending'),
    '#options'       => $line_ending,
    '#description'   => t('Choose the end of line to use.'),
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Export'),
  );

  return $form;
}

/**
 * Validate for export form.
 */
function word_link_exchange_export_form_validate($form, &$form_state) {
  // If custom delimiter is empty then show error.
  if ($form_state['values']['delimiter'] == 'custom_delimiter' && $form_state['values']['delimiter_custom'] === '') {
    form_set_error('delimiter_custom', t('Delimiter is required.'));
  }
}

/**
 * Submit for export form.
 */
function word_link_exchange_export_form_submit($form, &$form_state) {
  // This is the order of columns for our file.
  $values = array(
    'text',
    'case_sensitive',
    'url',
    'url_title',
    'class',
    'visibility',
    'weight',
    'rel',
    'status',
    'except',
  );

  // Get all words from DB.
  $words = word_link_load_all(FALSE);
  // Get right delimiter.
  switch ($form_state['values']['delimiter']) {
    case 'comma':
      $delimiter = ',';
      break;

    case 'semicolon':
      $delimiter = ';';
      break;

    case 'tabulation':
      $delimiter = "\t";
      break;

    case 'pipe':
      $delimiter = '|';
      break;

    case 'space':
      $delimiter = ' ';
      break;

    case 'currency_sign':
      $delimiter = '¤';
      break;

    case 'custom_delimiter':
      $delimiter = $form_state['values']['delimiter_custom'];
      break;
  }
  // Get right line ending.
  switch ($form_state['values']['line_ending']) {
    case 'unix':
      $line_ending = "\n";
      break;

    case 'mac':
      $line_ending = "\r";
      break;

    case 'ms':
      $line_ending = "\r\n";
      break;
  }
  // Check if there is write access and prepare file.
  $filename = file_unmanaged_save_data(
    '',
    'public://' . 'word_link_' . format_date(REQUEST_TIME, 'custom', 'd\_m\_Y\TH\_i') . '.csv',
    'FILE_EXISTS_REPLACE'
  );
  if ($filename) {
    $file = (object) array(
      'filename' => basename($filename),
      'filepath' => drupal_realpath($filename),
      'filesize' => filesize($filename),
    );
  }
  else {
    drupal_set_message(t('The file could not be created.'), 'error');
    return;
  }

  $operations = array();
  foreach ($words as $word) {
    $string = '';
    foreach ($values as $value) {
      if ($value != 'except') {
        $string .= $word->$value;
        $string .= $delimiter;
      }
      else {
        $except = str_replace(array("\r\n", "\n", "\r"), '|', trim($word->$value));
        $string .= !empty($except) ? $except : '""';
        $string .= $line_ending;
      }
    }
    $operations[] = array(
      'word_link_exchange_write_file',
      array(
        $string,
        $file,
      ),
    );
  }
  $batch = array(
    'title' => t('Exporting links...'),
    'operations' => $operations,
    'finished' => 'word_link_exchange_export_batch_finish',
  );
  batch_set($batch);
}

/**
 * Write data to csv file.
 */
function word_link_exchange_write_file($string, $file, &$context) {
  if (empty($context['results']['file'])) {
    $context['results']['file'] = $file;
  }
  // Write string to file.
  if (file_put_contents($file->filepath, $string, FILE_APPEND) === FALSE) {
    drupal_set_message(t('The file could not be created.'), 'error');
  }
  // It will be used to count total strings.
  $context['results']['total'][] = '';
}

/**
 * Batch export finish.
 */
function word_link_exchange_export_batch_finish($success, $results, $operations) {
  if (empty($results['total'])) {
    $message = t('There is nothing to export.');
  }
  elseif ($success && !empty($results['total'])) {
    $file = $results['file'];
    $message = t('@count words have been exported to file !link (!filesize). Click on link to view it or right click to download it.', array(
      '@count' => count($results['total']),
      '!link' => l($file->filename, file_create_url(file_build_uri($file->filename))),
      '!filesize' => format_size(filesize($file->filepath)),
    ));
  }
  else {
    $message = t('Finished with an error.');
  }
  drupal_set_message($message);
}
