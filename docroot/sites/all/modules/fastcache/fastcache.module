<?php
/**
 * @file
 * Fastcache module file.
 */

/**
 * Implements hook_ctools_plugin_directory().
 */
function fastcache_ctools_plugin_directory($module, $plugin) {
  return 'plugins/' . $plugin;
}

/**
 * Implements hook_menu_alter().
 *
 * We alter default views ajax callback for our own cache implementation.
 */
function fastcache_menu_alter(&$items) {
  if ($items['views/ajax']) {
    $items['views/ajax']['page callback'] = 'fastcache_views_ajax';
    $items['views/ajax']['file'] = 'fastcache.module';
    $items['views/ajax']['file path'] = drupal_get_path('module', 'fastcache');
  }
}

/**
 * Implements hook_node_insert().
 */
function fastcache_node_insert($node) {
  fastcache_clear_entity_caches($node);
}

/**
 * Implements hook_node_update().
 */
function fastcache_node_update($node) {
  fastcache_clear_entity_caches($node);
}

/**
 * Implements hook_node_delete().
 */
function fastcache_node_delete($node) {
  fastcache_clear_entity_caches($node);
}

/**
 * Implements hook_user_insert().
 */
function fastcache_user_insert(&$edit, $account, $category) {
  fastcache_clear_entity_caches($account);
}

/**
 * Implements hook_user_update().
 */
function fastcache_user_update(&$edit, $account, $category) {
  fastcache_clear_entity_caches($account);
}

/**
 * Implements hook_user_delete().
 */
function fastcache_user_delete($account) {
  fastcache_clear_entity_caches($account);
}

/**
 * Implements hook_flag_flag().
 *
 * This hook is implemented mainly to expire views that contain information
 * about a flag (number of likes, favorites etc.).
 */
function fastcache_flag_flag($flag, $entity_id, $account, $flagging) {
  fastcache_clear_flag_caches($flag, $entity_id, $account, $flagging);
}

/**
 * Implements hook_flag_unflag().
 *
 * This hook is implemented mainly to expire views that contain information
 * about a flag (number of likes, favorites etc.).
 */
function fastcache_flag_unflag($flag, $entity_id, $account, $flagging) {
  fastcache_clear_flag_caches($flag, $entity_id, $account, $flagging);
}

/**
 * Implements hook_flush_caches().
 */
function fastcache_flush_caches() {
  return array('cache_fastcache');
}

/**
 * Implements hook_views_post_render().
 *
 * We need to save cached view's results in order to access them later in our
 * panels cache plugin. Also, we prepare flag placeholders to be filled later by
 * actual links specific for user viewing the contents.
 */
function fastcache_views_post_render(&$view, &$output, &$cache) {
  $view_info = &drupal_static('fastcache_active_view_info', array('result' => array(), 'cached_output' => ''));
  $view_id = $view->name . ':' . $view->current_display;
  $view_cache = fastcache_get_cached_views($view_id);
  if ($view_cache) {
    if (in_array('user', $view_cache['entity_types'])) {
      $view_info['result'] = fastcache_get_result_uids($view);
    }
    else {
      $view_info['result'] = fastcache_get_result_nids($view);
    }

    // Prepare flag placeholders.
    // @todo: remove hardcode?
    if (!empty($view_cache['flag'])) {
      $cached_output = $output;
      $wrapper_tag = 'span';
      $wrapper_tag_len = strlen($wrapper_tag);
      $re = '|<' . $wrapper_tag . '[^>]+flag-\w+-(\d+)[^>]+>|im';
      $matches = array();
      $offset = 0;

      while (preg_match($re, $cached_output, $matches, 0, $offset)) {
        $entity_id = (int)$matches[1];
        $flag_start = stripos($cached_output, $matches[0]);
        $tag_offset = $flag_start + $wrapper_tag_len + 1;
        $opened = 1;
        // Find the closing tag of the wrapper. Consider that there may be one more
        // tag of the same name inside it, and only look for the matching tag.
        while ($opened) {
          $next_tag = stripos($cached_output, $wrapper_tag, $tag_offset);
          // We found an opening tag.
          if ($cached_output[$next_tag - 1] == '<') {
            $opened++;
          }
          // We found a closing tag
          elseif ($cached_output[$next_tag - 1] == '/') {
            $opened--;
          }
          $tag_offset = ($next_tag + $wrapper_tag_len);
        }

        // Replace the flag with a placeholder.
        $placeholder = '|FLAG-' . $entity_id . '|';
        $cached_output = substr_replace($cached_output, $placeholder, $flag_start, $next_tag + $wrapper_tag_len + 1 - $flag_start);
        $offset = strpos($cached_output, $placeholder);
      }

      // Save it here to be accessible later in fastcache_panels_set_cache().
      $view_info['cached_output'] = $cached_output;
    }
  }
}

/**
 * Implements hook_preprocess_pager_link().
 *
 * For 'user' cache type we have to transfer context (user whose content is
 * being viewed).
 */
function fastcache_preprocess_pager_link(&$variables) {
  $cache_context = drupal_static('fastcache_context', 0);
  if ($cache_context) {
    $variables['parameters']['context'] = $cache_context;
    drupal_static_reset('fastcache_context');
  }
}

/**
 * Implements hook_fastcache_get().
 *
 * When view is taken from cache we have to update user-specific flags.
 * Note: this method is only called when the view is rendered FROM cache.
 */
function fastcache_fastcache_get($view_name, $view_display, $cache) {
  $meta = fastcache_get_cached_views($view_name . ':' . $view_display);
  if (!empty($meta) && !empty($meta['flag'])) {
    $ids = $cache->data['result'];
    $entity_type = !in_array('user', $meta['entity_types']) ? 'node' : 'user';
    $output = NULL;
    // Cached output that is stored in panels_cache_object.
    if (is_object($cache->data['output'])) {
      $output = &$cache->data['output']->content->content;
    }
    // Cache is of views Ajax type.
    elseif (isset($cache->data['output']['#commands']) && is_array($cache->data['output']['#commands'])) {
      foreach ($cache->data['output']['#commands'] as $i => $command) {
        if (in_array($command['command'], array('insert', 'append'))
            && strpos($command['selector'], 'view-dom-id')) {
          $output = &$cache->data['output']['#commands'][$i]['data'];
          break;
        }
      }
    }

    // Initiate flag update.
    if ($output) {
      fastcache_update_user_flags($meta['flag'], $ids, $entity_type, $output);
    }
    else {
      // @todo: is such a situation possible?
      watchdog('fastcache', 'Unknown cache structure. Only panels and views caches are supported.');
    }
  }
}

/**
 * Replaces flag placeholders with actual flag links relevant for current user.
 */
function fastcache_update_user_flags($flag_name, $entity_ids, $entity_type, &$output) {
  global $user;
  $data = &drupal_static(__FUNCTION__, array());

  if (empty($entity_ids)) {
    return;
  }

  $entitycache = module_exists('entitycache');
  // Make sure current entity is cached by entitycache.
  if ($entitycache) {
    $cached_entity_types = array_keys(entitycache_supported_core_entities(TRUE));
    if (!in_array($entity_type, $cached_entity_types)) {
      $entitycache = FALSE;
    }
  }

  // Retrieve and save into cache user flagged content if it is not already saved.
  if (!isset($data[$flag_name])) {
    $uid = $user->uid;
    $cid = "flagcache:$flag_name:$uid";

    if ($cache = cache_get($cid, 'cache_fastcache')) {
      $data[$flag_name] = $cache->data;
    }
    else {
      $query = db_select('flagging', 'f');
      $query->condition('f.uid', $uid);
      $query->fields('f', array('entity_id', 'entity_type'));
      $data[$flag_name]['flag_content'] = $query->execute()->fetchAllKeyed();
      $data[$flag_name]['flag'] = flag_get_flag($flag_name);
      cache_set($cid, $data[$flag_name], 'cache_fastcache');
    }
  }

  // Create relevent flag link for each loading node.
  $relevant_entities = array_keys($data[$flag_name]['flag_content'], $entity_type);
  $replace = array();
  foreach ($entity_ids as $id) {
    // Set status for each created link.
    if (in_array($id, $relevant_entities)) {
      $status = 'unflag';
    }
    else {
      $status = 'flag';
    }

    // Cache the flag as call to theme() will result in undesired queries to
    // database unless entitycache module is enabled.
    if (!$entitycache) {
      $flag_cid = "flagcacheflags:$flag_name:$entity_type:$status:$id";
      if ($flag_cache = cache_get($flag_cid, 'cache_fastcache')) {
        $flag = $flag_cache->data;
      }
      else {
        $flag = $data[$flag_name]['flag']->theme($status, $id);
        cache_set($flag_cid, $flag, 'cache_fastcache');
      }
    }
    else {
      $flag = $data[$flag_name]['flag']->theme($status, $id);
    }
    $replace["|FLAG-$id|"] = $flag;
  }

  if (count($replace)) {
    $output = str_replace(array_keys($replace), array_values($replace), $output);
  }
}

/**
 * Clears views that contain relevant Drupal entities.
 */
function fastcache_clear_entity_caches($entity) {
  if (!fastcache_clear_allowed($entity)) {
    return;
  }

  global $language;
  $cached_views = fastcache_get_cached_views();
  foreach ($cached_views as $view => $cache) {
    $cid = NULL;
    // Clear only those views which trigger is set to entity.
    if (in_array('entity', $cache['clear_trigger'])) {
      // If page variant is cached we need to normalize it's cache key.
      if (strpos($view, '::')) {
        ctools_include('fastcache_panels_cache', 'fastcache', 'plugins/cache');
        $view = _fastcache_views_panels_cache_normalize_display_cache_key($view);
      }

      // Call custom CID generation callback if provided
      if (!empty($cache['cid_generator'])) {
        $cid_callback = $cache['cid_generator'];
        $cid = $cid_callback($view, $entity);
      }
      // Entity is node and its type is allowed to be cleared.
      elseif (isset($entity->type) && in_array($entity->type, $cache['entity_types'])) {
        $cid = "$view:$language->language:";
      }
      // Entity is user.
      elseif (isset($entity->uid) && in_array('user', $cache['entity_types'])) {
        $cid = "$view:$language->language:";
      }

      if ($cid) {
        // Allow other modules to react on cache expiration.
        foreach (module_implements('fastcache_clear_entity') as $module) {
          $function = $module . '_fastcache_clear_entity';
          $function($view, $cache, $entity);
        }
        cache_clear_all($cid, 'cache_fastcache', TRUE);
      }
    }
  }
}

function fastcache_clear_flag_caches($flag, $entity_id, $account, $flagging) {
  global $language;
  $cached_views = fastcache_get_cached_views();
  foreach ($cached_views as $view => $cache) {
    $cid = NULL;
    // Clear only those views which trigger is set to 'flag'.
    if (in_array('flag', $cache['clear_trigger'])) {
      // Load the flagged entity. It is loaded from static cache because flag
      // module has already loaded it in order to determine permissions.
      $entity = $flag->fetch_entity($entity_id);
      // Call custom CID generation callback if provided.
      if (!empty($cache['cid_generator'])) {
        $cid_callback = $cache['cid_generator'];
        $cid = $cid_callback($view, $flag, $entity_id, $account, $flagging);
      }
      // Flagged item is node.
      elseif (isset($entity->type)) {
        // View is showing nodes.
        if (in_array($entity->type, $cache['entity_types'])) {
          // Assumption: clear user specific cache of nodes for currently flagging/unflagging user.
          if ($cache['context_type'] == 'user') {
            $cid = $view . ":$language->language" . ":user/$account->uid";
          }
          else {
            $cid = $view . ":$language->language:";
          }
        }
        // View is showing users.
        elseif (in_array('user', $cache['entity_types'])) {
          // Assumption: current user flagged a node and node's landing page
          // shows a list of users who flagged it, so the list should be expired,
          if ($cache['context_type'] == 'path') {
            $cid = $view . "$language->language:node/$entity_id";
          }
        }
      }
      // Flagged item is user.
      elseif (in_array('user', $cache['entity_types']) && isset($entity->uid)) {
        if ($cache['context_type'] == 'user') {
          // Assumption: user A (un)flagged user B and related view
          // showing all users flagged by A should be expired.
          if ($cache['flag_action_type'] == 'active') {
            $cid = $view . ":$language->language:user/$account->uid";
          }
          // Assumption: user A was (un)flagged by user B and related view showing all
          // users who flagged user A should be expired.
          elseif ($cache['flag_action_type'] == 'passive') {
            $cid = $view . ":$language->language:user/$entity_id";
          }
        }
        else {
          $cid = $view . ':';
        }
        // @todo: do we need path context support?
      }

      if ($cid) {
        // Allow other modules to react on cache expiration.
        foreach (module_implements('fastcache_clear_flag') as $module) {
          $function = $module . '_fastcache_clear_flag';
          $function($view, $cache, $flag, $entity_id, $account, $flagging);
        }
        cache_clear_all($cid, 'cache_fastcache', TRUE);
      }
    }
  }

  // Clear user flag cache.
  global $user;
  cache_clear_all("flag:$flag->name:$user->uid", 'cache');
}

/**
 * Menu callback that loads a view via AJAX.
 *
 * The base code is taken from views/includes/ajax.inc.
 * @see fastcache_preprocess_pager_link()
 */
function fastcache_views_ajax() {
  global $language;
  module_load_include('inc', 'views', 'includes/ajax');

  // Get basic data about the view.
  if (!isset($_REQUEST['view_name']) || !isset($_REQUEST['view_display_id'])) {
    return;
  }
  $name = $_REQUEST['view_name'];
  $display_id = $_REQUEST['view_display_id'];
  $dom_id = isset($_REQUEST['view_dom_id']) ? preg_replace('/[^a-zA-Z0-9_-]+/', '-', $_REQUEST['view_dom_id']) : NULL;

  $cid_base = $name . ':' . $display_id;
  $cache_meta = fastcache_get_cached_views($cid_base);
  // If view is not cacheable call the default handler.
  if (!$cache_meta || !fastcache_cache_allowed($cache_meta)) {
    return views_ajax();
  }

  // Consider language.
  $cid_base .=  ':' . $language->language;

  // Anonymous content may differ from authenticated.
  if (user_is_anonymous()) {
    $cid_base .= ':anon';
  }

  // Check if context or any arguments are present.
  $cid_context = '';
  if (!empty($cache_meta['context_type'])) {
    if ($cache_meta['context_type'] == 'user' && !empty($_GET['context'])) {
      $cid_context = ':user/' . (int) $_GET['context'];
    }
    elseif ($cache_meta['context_type'] == 'path') {
      $cid_context = ':' . md5($_SERVER['REQUEST_URI']);;
    }
  }

  // Add arguments present when calling the view, but remove unwanted stuff from
  // request since it may generate false uniqueness.
  // Arguments here are pager, sorting, filtering
  $request = $_REQUEST;
  foreach (array('pager_element', 'ajax_html_ids', 'ajax_page_state', 'view_path', 'view_dom_id') as $key) {
    if (isset($request[$key])) {
      unset($request[$key]);
    }
  }
  $cid_args = ':' . md5(serialize($request));

  $cid = $cid_base . $cid_context . $cid_args;

  // Try to load data from cache.
  $cache = cache_get($cid, 'cache_fastcache');
  if ($cache) {
    // Allow other module react/alter cache before it is returned.
    foreach (module_implements('fastcache_get') as $module) {
      $function = $module . '_fastcache_get';
      $function($name, $display_id, $cache);
    }
    $output = $cache->data['output'];

    // Update views Dom ids in order to make it work.
    foreach ($output['#commands'] as $i => $command) {
      if (strpos($command['selector'], 'view-dom-id')) {
        $old_dom_id = str_replace('.', '', $output['#commands'][$i]['selector']);
        $output['#commands'][$i]['selector'] = '.view-dom-id-' . $dom_id;
        if (!empty($output['#commands'][$i]['data'])) {
          $output['#commands'][$i]['data'] = str_replace($old_dom_id, 'view-dom-id-' . $dom_id, $output['#commands'][$i]['data']);
        }
      }
    }
  }
  else {
    $output = views_ajax();
    // Save cached version with flag placeholders and result.
    $view_info = drupal_static('fastcache_active_view_info', array('result' => array(), 'cached_output' => ''));
    if (!empty($cache_meta['flag']) && !empty($view_info['cached_output'])) {
      $cached_output = $output;
      $cached_output['#commands'][1]['data'] = $view_info['cached_output'];
    }

    $cache = array(
      'output' => isset($cached_output) ? $cached_output : $output,
      'result' => $view_info['result'],
    );

    // @todo: call fastcache_set hook?
    cache_set($cid, $cache, 'cache_fastcache', fastcache_get_view_expire($name, $display_id));
  }

  return $output;
}

/**
 * Returns true or false if caching is allowed to happen.
 */
function fastcache_cache_allowed($cache_meta) {
  // Allow other modules to disable cache clear on node operations.
  foreach (module_implements('fastcache_cache_allowed') as $module) {
    $function = $module . '_fastcache_cache_allowed';
    $allow = $function($cache_meta);
    if (!$allow) {
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Returns false if there are modules that prohibit cache clear on entity operations.
 */
function fastcache_clear_allowed($node) {
  // Allow other modules to disable cache clear on node operations.
  foreach (module_implements('fastcache_clear_allowed') as $module) {
    $function = $module . '_fastcache_clear_allowed';
    $allow = $function($node);
    if (!$allow) {
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Extracts node IDs out of view result.
 * Note: the view must be configured to render entities (content) not fields.
 * @todo: this code probably handles search_api-related specifics and should be revised.
 */
function fastcache_get_result_nids($view) {
  // We do not save the whole result here but only nids.
  // This may be not an ideal solution, but it seems to be enough at the moment.
  $result = array();
  foreach ($view->result as $item) {
    if (isset($item->entity)) {
      if (is_int($item->entity)) {
        $result[] = $item->entity;
      }
      elseif (is_object($item->entity)) {
        $result[] = $item->entity->nid;
      }
    }
    elseif (isset($item->nid)) {
      $result[] = $item->nid;
    }
  }
  return $result;
}

/**
 * Extracts user IDs out of view result.
 * Note: the view must be configured to render entities not fields.
 * @todo: this code probably handles search_api-related specifics and should be revised.
 */
function fastcache_get_result_uids($view) {
  // We do not save the whole result here but only uids.
  // This may be not an ideal solution, but it seems to be enough at the moment.
  $result = array();
  foreach ($view->result as $item) {
    if (isset($item->entity)) {
      if (is_int($item->entity)) {
        $result[] = $item->entity;
      }
      elseif (is_object($item->entity)) {
        $result[] = $item->entity->uid;
      }
    }
    elseif (isset($item->uid)) {
      $result[] = $item->uid;
    }
  }
  return $result;
}

/**
 * Calculate a timestamp that determines expiration time for a given display.
 */
function fastcache_get_view_expire($view_name, $view_display) {
  $expire = CACHE_PERMANENT;
  $view_meta = fastcache_get_cached_views($view_name . ':' . $view_display);
  if ($view_meta && !empty($view_meta['lifetime'])) {
    $expire = time() + intval($view_meta['lifetime']);
  }
  return $expire;
}

/**
 * Determine the entity type that a given display returns in its result set.
 */
function fastcache_get_view_entity_type($view_name, $view_display) {
  $view_meta = fastcache_get_cached_views($view_name . ':' . $view_display);
  if ($view_meta) {
    return $view_meta['entity_types'] == array('user') ? 'user' : 'node';
  }
  else {
    return NULL;
  }
}

/**
 * Validates views definition.
 *
 * Also prepares them to be well-formed and easily accessible from static cache
 * on multiple calls.
 */
function fastcache_get_cached_views($view_name = NULL) {
  static $views = array();

  if (empty($views)) {
    $cached_views = module_invoke_all('fastcache_views');
    foreach ($cached_views as $view => $cache) {
      // Check context type.
      if (!empty($cache['context_type']) && !in_array($cache['context_type'], array('user', 'path'))) {
        throw new Exception("Wrong context type {$cache['context_type']} set for view $view");
      }
      elseif (!isset($cache['context_type'])) {
        $cache['context_type'] = FALSE;
      }
      // Check entity types.
      if (!isset($cache['entity_types'])) {
        throw new Exception("Missing entity type for view $view");
      }
      elseif (!is_array($cache['entity_types'])) {
        $cache['entity_types'] = array($cache['entity_types']);
      }
      else {
        if (count($cache['entity_types']) > 1 && in_array('user', $cache['entity_types'])) {
          throw new Exception("Invalid settings for view $view. Views can't combine both node and user entity types.");
        }
      }
      // Check clear trigger.
      if (!isset($cache['clear_trigger'])) {
        $cache['clear_trigger'] = array('entity');
      }
      elseif (!is_array($cache['clear_trigger'])) {
        $cache['clear_trigger'] = array($cache['clear_trigger']);
        if (!array_intersect($cache['clear_trigger'], array('entity', 'flag'))) {
          throw new Exception("Wrong cache clear trigger(s) " . implode(', ', $cache['cache_type']) . " set for view $view");
        }
      }
      // We always clear cache on entity change if entity_types are specified.
      if (!empty($cache['entity_types']) && !in_array('entity', $cache['clear_trigger'])) {
        $cache['clear_trigger'][] = 'entity';
      }
      // Check flag action type.
      if (in_array('flag', $cache['clear_trigger'])) {
        if (!isset($cache['flag_action_type'])) {
          $cache['flag_action_type'] = 'active';
        }
        elseif (!in_array($cache['flag_action_type'], array('active', 'passive'))) {
          throw new Exception("Invalid flag action type {$cache['flag_action_type']} set for view $view");
        }
      }
      // Check cid callback.
      if (!empty($cache['cid_clear_callback']) && !function_exists($cache['cid_clear_callback'])) {
        throw new Exception("Undefined cid clear callback {$cache['cid_clear_callback']} set for view $view");
      }
      $views[$view] = $cache;
    }
  }

  if ($view_name) {
    return isset($views[$view_name]) ? $views[$view_name] : NULL;
  }
  return $views;
}
