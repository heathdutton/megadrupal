<?php

/**
 * @file
 * Hooks and callback functions for the Shared Content client module.
 *
 * @todo ERROR Use the error message in the log event if one is present.
 */

/**
 * Default Shared Content field flag.
 *
 * @see sharedcontent_client_get_default_shared_content_field_name()
 */
define('SHAREDCONTENT_CLIENT_SHARED_CONTENT_FIELD_DEFAULT', 0);

define('SHAREDCONTENT_CLIENT_DEFAULT_SYNC_BATCH_SIZE', 100);

define('SHAREDCONTENT_CLIENT_ACTION_CONNECTION_ENABLE', 'enable');
define('SHAREDCONTENT_CLIENT_ACTION_CONNECTION_DISABLE', 'disable');
/**
 * Implements hook_menu().
 *
 * Provide client configuration, proxy, action links.
 */
function sharedcontent_client_menu() {
  $items = array();

  $items['admin/config/services/sharedcontent/connection/%services_client_connection'] = array(
    'page callback' => 'sharedcontent_client_configure_endpoints_connections',
    'page arguments' => array(5),
    'access arguments' => array('administer sharedcontent'),
    'file' => 'includes/sharedcontent_client.admin.inc',
  );

  $items['admin/config/services/sharedcontent/settings/linkables'] = array(
    'title' => 'Linkable entities',
    'type' => MENU_LOCAL_TASK,
    'description' => 'Configure the eintities which can be linked to Shared Content.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('sharedcontent_client_configure_linkables'),
    'access arguments' => array('administer sharedcontent'),
    'file' => 'includes/sharedcontent_client.admin.inc',
  );

  $items['admin/config/services/sharedcontent/status/synchronize'] = array(
    'title' => 'Synchronize all indexes',
    'description' => 'Trigger the synchronize the index for all connections.',
    'type' => MENU_LOCAL_ACTION,
    'page callback' => 'sharedcontent_client_manual_synchronize',
    'page arguments' => array('all'),
    'access arguments' => array('sharedcontent synchronize'),
  );

  $items['admin/config/services/sharedcontent/client/synchronize/%'] = array(
    'title' => 'Synchronize index',
    'description' => 'Manually synchronize the index with one or all connections.',
    'page callback' => 'sharedcontent_client_manual_synchronize',
    'page arguments' => array(6),
    'access arguments' => array('sharedcontent synchronize'),
  );

  // % is action
  $items['admin/content/sharedcontent/%/%sharedcontent_index/%sharedcontent_index'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'sharedcontent_client_link_content',
    'page arguments' => array(4, 5, 3),
    'access callback' => 'sharedcontent_client_link_access',
    'access arguments' => array(4, 5),
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function sharedcontent_client_permission() {
  return array(
    'sharedcontent synchronize' => array(
      'title' => t('Synchronize Shared Content'),
    ),
  );
}

/**
 * Determine if user can link and unlink content.
 *
 * @param $source
 * @param $target
 * @return
 *  TRUE if the user can link content, FALSE otherwise.
 *
 * @todo: call entity_access and field_access.
 */
function sharedcontent_client_link_access($source, $target) {
  return TRUE;
}

/**
 * Page callback: Link or unlink a remote to a local content.
 *
 * @param $source
 *   The source index record.
 * @param $target
 *   The sharedcontent_index target.
 * @param $action
 *   String defining the action 'link' or 'unlink'.
 */
function sharedcontent_client_link_content($source, $target, $action) {
  $placeholders = array(
    '%source' => $source->title,
    '%target' => $target->title,
  );
  $field = !empty($_GET['field']) ? $_GET['field'] : SHAREDCONTENT_CLIENT_SHARED_CONTENT_FIELD_DEFAULT;
  $arguments = array(
    'action' => $action,
    'source' => $source,
    'target' => $target,
    'field' => $field,
  );
  $error_options = array('severity' => WATCHDOG_ERROR);
  switch ($action) {
    case 'link':
      $success = sharedcontent_client_assign_index_to_local_content($target->id, $source->entity_id, $source->entity_type, $field);
      if ($success) {
        drupal_set_message(t('Linked %source with %target.', $placeholders));
        sharedcontent_event_save('sharedcontent_client', __FUNCTION__, 'Linked content', $arguments);
      }
      else {
        drupal_set_message(t('Could not link %source with %target.', $placeholders), 'error');
        sharedcontent_event_save('sharedcontent_client', __FUNCTION__, 'Could not link content', $arguments, $error_options);
      }
      break;
    case 'unlink':
      $success = sharedcontent_client_remove_index_from_local_content($target->id, $source->entity_id, $source->entity_type, $field);
      if ($success) {
        sharedcontent_event_save('sharedcontent_client', __FUNCTION__, 'Unlinked content', $arguments);
      }
      else {
        drupal_set_message(t('Could not unlink %source from %target.', $placeholders), 'error');
        sharedcontent_event_save('sharedcontent_client', __FUNCTION__, 'Could not unlink content', $arguments, $error_options);
      }
      break;
    default:
      drupal_set_message(t('Invalid action given. Action should either be <em>link</em> or <em>unlink</em>'), 'error');
      sharedcontent_event_save('sharedcontent_client', __FUNCTION__, 'Invalid action', $arguments, $error_options);
  }

  drupal_goto();
}

/**
 * Implements hook_theme().
 */
function sharedcontent_client_theme() {
  return array(
    'sharedcontent_view_linked_content' => array(
      'render element' => 'content',
      'file' => 'includes/sharedcontent_client.theme.inc',
    ),
  );
}

/**
 * Implements hook_rules_action_info().
 *
 * Define rules actions.
 * @see sharedcontent_client_rules_search()
 * @see sharedcontent_client_rule_content_link()
 * @see sharedcontent_client_rule_content_unlink()
 */
function sharedcontent_client_rules_action_info() {
  $info = array();

  $info['sharedcontent_client_rules_search'] = array(
    'label' => t('Execute a more like this search'),
    'help' => t('Executes a search that return more like the given index record and invokes the Shared Content Search Result rules event'),
    'group' => t('Shared Content'),
    'parameter' => array(
      'search_index' => array(
        'label' => t('Search Index'),
        'type' => 'search_api_index',
      ),
      'sharedcontent_index' => array(
        'label' => t('The Shared Content index that is being searched for'),
        'type' => 'sharedcontent_index',
      ),
      'limit' => array(
        'label' => t('Number of search results'),
        'type' => 'integer',
        'default value' => 5,
        'optional' => TRUE,
      ),
      'minimal_score' => array(
        'label' => t('Minimal search score to invoke the event. Ignored if empty.'),
        'type' => 'text',
        'default value' => '',
        'optional' => TRUE,
      ),
    ),
  );

  $info['sharedcontent_client_rule_content_link'] = array(
    'label' => t('Link local with remote content.'),
    'parameter' => array(
      'local_content' => array(
        'type' => 'sharedcontent_index',
        'label' => t('Local content'),
        'description' => t('The index record of the local content.'),
        'wrapped' => FALSE,
      ),
      'remote_content' => array(
        'type' => 'sharedcontent_index',
        'label' => t('Remote content'),
        'description' => t('The index record of the remote content'),
        'wrapped' => FALSE,
      ),
      'reference_fields' => array(
        'type' => 'list<text>',
        'label' => t('Reference fields'),
        'options list' => 'sharedcontent_client_rule_content_link_field_options',
        'description' => t('The entity reference fields to be used for linking.'),
      ),
    ),
    'group' => t('Shared Content'),
  );

  $info['sharedcontent_client_rule_content_unlink'] = array(
    'label' => t('Remove link from local content'),
    'parameter' => array(
      'local_content' => array(
        'type' => 'sharedcontent_index',
        'label' => t('Local content'),
        'description' => t('The local content entity.'),
      ),
      'remote_content' => array(
        'type' => 'sharedcontent_index',
        'label' => t('Remote content'),
        'description' => t('The index record of the remote content'),
      ),
      'reference_fields' => array(
        'type' => 'list<text>',
        'label' => t('Reference fields'),
        'options list' => 'sharedcontent_client_rule_content_link_field_options',
        'description' => t('The entity reference fields to be used for linking.'),
      ),
    ),
    'group' => t('Shared Content'),
  );

  return $info;
}

/**
 * Value callback for shared_content_field rules action parameter.
 *
 * Returns all Shared Content fields.
 *
 * @return
 *    Associative array with the field name as key and the field
 *    label as value.
 *
 * @todo Get the actual field labels.
 */
function sharedcontent_client_rule_content_link_field_options() {
  $names = sharedcontent_client_get_all_shared_content_field_names();
  return array_combine($names, $names);
}


/**
 * Link content rule.
 *
 * Rule action callback that links two content together.
 *
 * @param $local_content
 *    The index record of the local content.
 * @param $remote_content
 *    The index record of the remote content.
 * @param $reference_fields
 *    An array of field names to be used for linking.
 *
 * @see sharedcontent_client_assign_index_to_local_content()
 *
 * @todo Iterate parents until a linkable content is found.
 * @todo Needs tests.
 */
function sharedcontent_client_rule_content_link($local_content, $remote_content, $reference_fields) {
  $arguments = array(
    'local_content' => $local_content,
    'remote_content' => $remote_content,
    'reference_fields' => $reference_fields,
  );

  // We might deal with a chapter record that is not linkable.
  // If this is the case we load the parent record that is expected to be linkable.
  $linkable_local_content = $local_content;
  if (!empty($local_content->parent_uuid)) {
    $linkable_local_content = sharedcontent_index_load_by_uuid($local_content->parent_uuid);
    $arguments['linkable_local_content'] = $linkable_local_content;
  }

  $options = array('severity' => WATCHDOG_DEBUG);
  $message = 'Linked local and remote content';
  foreach ($reference_fields as $field) {
    $success = sharedcontent_client_assign_index_to_local_content($remote_content->id, $linkable_local_content->entity_id, $linkable_local_content->entity_type, $field);
    if (!$success) {
      $options['severity'] = WATCHDOG_ERROR;
      $message = 'Could not link local and remote content';
    }
    $arguments['fields'][$field] = $success;
  }
  sharedcontent_event_save('sharedcontent_client', __FUNCTION__, $message, $arguments, $options);
}

/**
 * Unlink content rule.
 *
 * Rule action callback that links two content together.
 *
 * @param $local_content
 *    The local content entity.
 * @param $remote_content
 *    The index record of the remote content.
 * @param $reference_fields
 *    An array of field names to be used for linking.
 *
 * @see sharedcontent_client_remove_index_from_local_content()
 */
function sharedcontent_client_rule_content_unlink($local_content, $remote_content, $reference_fields) {
  $arguments = array(
    'local_content' => $local_content,
    'remote_content' => $remote_content,
    'reference_fields' => $reference_fields,
  );
  $options = array('severity' => WATCHDOG_DEBUG);
  $message = 'Unlinked local and remote content';
  foreach ($reference_fields as $field) {
    $success = sharedcontent_client_remove_index_from_local_content($remote_content->id, $local_content->entity_id, $local_content->entity_type, $field);
    if (!$success) {
      $options['severity'] = WATCHDOG_ERROR;
      $message = 'Could not unlink local from remote content';
    }
    $arguments['fields'][$field] = $success;
  }
  sharedcontent_event_save('sharedcontent_client', __FUNCTION__, $message, $arguments, $options);
}

/**
 * Rules action callback: Search in index.
 *
 * @param $search_index
 *   Search API index entity.
 * @param $keywords
 *   String of keywords to search for.
 * @param $limit
 *   Search for and invoke rules callback for how many results.
 * @param $minimal_score
 *   Only invoke for search results with a higher score.
 * @param $sharedcontent_index
 *   The sharedcontent index object that is being used.
 */
function sharedcontent_client_rules_search($search_index, $sharedcontent_index, $limit, $minimal_score) {
  $arguments = array(
    'search_index' => $search_index->machine_name,
    'sharedcontent_index' => $sharedcontent_index->id,
    'limit' => $limit,
    'score-min' => $minimal_score,
  );
  sharedcontent_event_save('sharedcontent_client', __FUNCTION__, 'Search.', $arguments, array('severity' => WATCHDOG_DEBUG));

  $server = $search_index->server();
  if (!$server->supportsFeature('search_api_mlt')) {
    $class = search_api_get_service_info($server->class);
    throw new SearchApiException(t('The search service "@class" does not offer "More like this" functionality.',
      array('@class' => $class['name'])));
    return;
  }

  // Get query.
  $query = search_api_query($search_index->machine_name);

  // Get fields to search for.
  $fields = variable_get('sharedcontent_more_like_this_fields', array(
    'title',
    'keywords',
    'tags',
    'search_api_language',
  ));
  if (empty($fields)) {
    foreach ($search_index->options['fields'] as $key => $field) {
      $fields[] = $key;
    }
  }

  // Set more like this options.
  $mlt = array(
    'id' => entity_id('sharedcontent_index', $sharedcontent_index),
    'fields' => $fields,
  );
  $query->setOption('search_api_mlt', $mlt);

  // If this is a sharedcontent index, limit to local indexes.
  // @todo Make this more flexible.
  if ($search_index->item_type == 'sharedcontent_index') {
    $query->condition('origin', 'local');
  }

  $query->range(0, $limit);
  $results = $query->execute();
  if (!empty($results['results'])) {
    $entities = entity_load($search_index->item_type, array_keys($results['results']));
    // @todo log result / invocation
    foreach ($results['results'] as $id => $result) {
      if (empty($minimal_score) || $result['score'] > $minimal_score) {
        // @todo log result / invocation
        rules_invoke_event('sharedcontent_client_search_result', $search_index->machine_name, entity_metadata_wrapper($search_index->item_type, $entities[$id]), $result['score'], $sharedcontent_index);
      }
    }
  }
}

/**
 * Implements hook_rules_event_info().
 */
function sharedcontent_client_rules_event_info() {
  $info['sharedcontent_client_search_result'] = array(
    'label' => t('Search result'),
    'group' => t('Shared Content'),
    'variables' => array(
      'index_name' => array(
        'label' => t('Name of the search index'),
        'type' => 'text',
      ),
      'result' => array(
        'label' => t('Search match'),
        'type' => 'entity',
      ),
      'score' => array(
        'label' => t('Search score (0-1)'),
        'type' => 'decimal',
      ),
      'sharedcontent_index' => array(
        'label' => t('Searched Shared Content index'),
        'type' => 'sharedcontent_index',
      ),
    ),
  );

  $info['sharedcontent_assignment_local_link'] = array(
    'label' => t('Content was linked locally.'),
    'group' => t('Shared Content'),
    'variables' => array(
      'assignment' => array(
        'label' => t('Shared Content Assignment'),
        'type' => 'entity',
        'bundle' => SHAREDCONTENT_INDEX_BUNDLE_LOCAL,
        'description' => t('The assignment record describing the new linking.'),
        'skip save' => TRUE,
      ),
    ),
  );

  $info['sharedcontent_assignment_local_unlink'] = $info['sharedcontent_assignment_local_link'];
  $info['sharedcontent_assignment_local_unlink']['label'] = t('Content was unlinked locally');

  $info['sharedcontent_prepare_index_record'] = array(
    'label' => t('Prepare index record.'),
    'group' => t('Shared Content'),
    'variables' => array(
      'entity' => array(
        'label' => t('Entity'),
        'type' => 'entity',
        'description' => t('The entity the index record is prepared for.'),
        'skip save' => TRUE,
      ),
      'index' => array(
        'label' => t('Index record'),
        'type' => 'sharedcontent_index',
        'description' => t('The index record for the entity.'),
        'skip save' => TRUE,
      ),
    ),
  );

  return $info;
}

/**
 * Implements hook_field_formatter_info().
 *
 * New formatter:
 * * Rendered Remote Entity
 */
function sharedcontent_client_field_formatter_info() {
  return array(
    'sharedcontent' => array(
      'label' => t('Rendered Remote Entity'),
      'description' => t('Display the referenced remote entities.'),
      'field types' => array('entityreference'),
      'settings' => array(
        'mode' => 'sharedcontent_teaser',
        'link' => 'origin',
      ),
    ),
  );
}

/**
 * Implements hook_field_formatter_prepare_view().
 *
 * Remove invisible items and enrich the remaining ones with the uuid.
 */
function sharedcontent_client_field_formatter_prepare_view($entity_type, $entities, $field, $instances, $langcode, &$items, $displays) {
  $ids = array();
  foreach ($items as $item) {
    foreach ($item as $entry) {
      $ids[] = $entry['target_id'];
    }
  }

  if (!empty($ids)) {
    // Get the visible records
    $indexes = entity_load('sharedcontent_index', $ids, array(
      'status' => SHAREDCONTENT_INDEX_STATUS_VISIBLE,
    ));

    foreach ($items as $entity_id => $item) {
      foreach ($item as $delta => $entry) {
        // Add the uuid to the record
        if (isset($indexes[$entry['target_id']])) {
          $items[$entity_id][$delta]['index'] = $indexes[$entry['target_id']];
        }
        // Record is invisible so we remove it
        else {
          unset($items[$entity_id][$delta]);
        }
      }
    }
  }
}

/**
 * Implements hook_field_formatter_view().
 */
function sharedcontent_client_field_formatter_view($obj_type, $object, $field, $instance, $langcode, $items, $display) {
  $settings = $display['settings'];
  $elements = array();
  foreach ($items as $delta => $item) {
    $elements[$delta]['#theme'] = 'sharedcontent_view_linked_content';
    $elements[$delta]['#content'] = '';
    $subelem = sharedcontent_client_fetch_remote_content($item['index'], $settings['mode']);
    if (isset($subelem['#markup'])) {
      // pick markup and attached JS/CSS
      $elements[$delta]['#content'] = $subelem['#markup'];
    }
    if (isset($subelem['#attached'])) {
      $elements[$delta]['#attached'] = $subelem['#attached'];
    }
    if (!empty($settings['link'])) {
      $elements[$delta]['#url'] = $item['index']->url;
    }
    $elements[$delta]['#settings'] = $settings;
    $elements[$delta]['#article_classes'] = array(
      'sharedcontent-connection',
      'sharedcontent-connection-' . $item['index']->connection_name,
      // @todo Probably we should allow to add additional classes inside configuration.
    );
    if ($settings['link'] == 'overlay') {
      $elements[$delta]['#attached']['js'][] = drupal_get_path('module', 'sharedcontent_client') . '/js/overlay.js';
      $elements[$delta]['#attached']['js'][] = array(
        'data' => array('sharedcontent' => array('overlay_media_query' => variable_get('sharedcontent_overlay_media_query', '(min-width: 1024px)'))),
        'type' => 'setting',
      );
      $elements[$delta]['#article_classes'][] = 'sharedcontent-overlay';
    }
  }
  return $elements;
}

/**
 * Implements hook _field_formatter_settings_summary().
 */
function sharedcontent_client_field_formatter_settings_summary($field, $instance, $view_mode) {
  $settings = $instance['display'][$view_mode]['settings'];

  $summary = array();
  $modes = sharedcontent_client_formatter_modes();
  $links = sharedcontent_client_formatter_link();

  $summary[] = t('Display as: %mode', array('%mode' => $modes[$settings['mode']]));
  if (isset($links[$settings['link']])) {
    $summary[] = t('Link to: %link', array('%link' => $links[$settings['link']]));
  }

  return implode('<br />', $summary);
}

/**
 * Implements hook_client_field_formatter_settings_form().
 */
function sharedcontent_client_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $settings = $instance['display'][$view_mode]['settings'];

  $element = array();

  $element['mode'] = array(
    '#title' => t('Display as'),
    '#type' => 'select',
    '#default_value' => $settings['mode'],
    '#options' => sharedcontent_client_formatter_modes(FALSE),
  );

  $element['link'] = array(
    '#title' => t('Link to'),
    '#type' => 'select',
    '#default_value' => $settings['link'],
    '#empty_option' => t('Nothing'),
    '#options' => sharedcontent_client_formatter_link(),
  );

  return $element;
}

/**
 * Associative array of possible view modes.
 *
 * The value is the translated label of the view mode identified by the key.
 *
 * @param $include_empty
 *   TRUE if the result should include a empty entry. This is the default.
 * @return
 *   Array of view modes.
 */
function sharedcontent_client_formatter_modes($include_empty = TRUE) {
  $options = array();
  if ($include_empty) {
    $options[''] = t('<none>');
  }
  $options['sharedcontent_teaser'] = t('Teaser');
  $options['sharedcontent_inline'] = t('Inline full content');
  return $options;
}

/**
 * Associative array of possible link behaviour.
 *
 * The value is the translated label of the lin behaviour identified by the key.
 *
 * @param $include_empty
 *   TRUE if the result should include a empty entry. This is the default.
 * @return
 *   Array of link behaviours.
 */
function sharedcontent_client_formatter_link($include_empty = TRUE) {
  $options = array();
  if ($include_empty) {
    $options[''] = t('Nothing');
  }
  $options['origin'] = t('Origin');
  $options['overlay'] = t('Overlay');
  return $options;
}

/**
 * Implements hook_cronapi().
 *
 * For elysia_cron project:
 * http://drupal.org/project/elysia_cron
 */
function sharedcontent_client_cronapi($op, $job = NULL) {
  $items['sharedcontent_client_cron'] = array(
    'description' => 'Synchronize Shared Content index',
    'rule' => '*/15 * * * *',
  );

  return $items;
}

/**
 * Implements hook_cron().
 *
 * Sync connections: Fetch index
 *
 * @todo push the different cron actions into separate functions.
 */
function sharedcontent_client_cron() {
  global $base_url;
  $match = preg_match('|://([^/]+)|', $base_url, $matches);
  $skip = variable_get('sharedcontent_skip_domains', array(
    'localhost',
    'local',
    'dev',
  ));
  // Skip obviously wrong domains to prevent faulty urls in index.
  if ($match && in_array($matches[1], $skip)) {
    sharedcontent_event_save('sharedcontent_client', __FUNCTION__, 'Skipped cron: Invalid domain.', array('domain' => $base_url), array('severity' => WATCHDOG_ERROR));
    return;
  }

  // Prepare queuing in batch size.
  $batch_size = variable_get('sharedcontent_sync_batch_size', SHAREDCONTENT_CLIENT_DEFAULT_SYNC_BATCH_SIZE);

  foreach (sharedcontent_client_get_connections() as $config) {
    $queue = DrupalQueue::get('sharedcontent_sync_' . $config->name);
    // @todo LOW Only enqueue if queue of $connection_name is empty. Skip

    // delta sync since last sync, per connections.
    $changed = variable_get('sharedcontent_last_sync_' . $config->name, '0000-00-00 00:00');

    // The loc arguments
    $arguments = array(
      'connection' => $config->name,
      'start-time' => $changed,
    );
    $message = 'Queued items for sync';
    $severity = WATCHDOG_INFO;

    try {
      $count = sharedcontent_client_index_count($config, $changed);
      // @todo HIGH catch possible exception SharedContentException. This can lead to index inconsistencies
      // @todo HIGH log here.
      $offset = 0;

      // build queue in $batch_size chunks.
      while ($count > 0) {
        $queue->createItem(array(
          $config,
          $changed,
          $offset,
          $batch_size
        ));
        $offset += $batch_size;
        $count -= $batch_size;
      }

      // @todo HIGH pull assignments from server. Where is this done?

      // There might be additional records for the current second if it is not yet over.
      // Duplicate syncs are no problem - we have uuids.
      $current_time = date('Y-m-d H:i', REQUEST_TIME - 1);

      $arguments['count'] = $count;
      $arguments['end-time'] = $current_time;

      // @todo HIGH mark queue as done. This should possibly happen in the worker?
      // currently if a sync temporary fails, index records will be missing. see sharedcontent_client_queue_synchronization_run().
      variable_set('sharedcontent_last_sync_' . $config->name, $current_time);
    }
    catch (SharedContentCountIndexException $e) {
      $message = 'Failed to queue items for sync';
      $arguments['error'] = $e;
      $severity = WATCHDOG_WARNING;
    }
    sharedcontent_event_save('sharedcontent_client', __FUNCTION__, $message, $arguments, array('severity' => WATCHDOG_INFO));
  }
}

/**
 * Implements hook_cron_queue_info().
 */
function sharedcontent_client_cron_queue_info() {
  $info = array();

  foreach (services_client_connection_load_all() as $config) {
    $info['sharedcontent_sync_' . $config->name] = array(
      'worker callback' => 'sharedcontent_client_queue_synchronization_run',
    );
  }

  $info['sharedcontent_assignment_push'] = array(
    'worker callback' => 'sharedcontent_client_queue_assignment_push_run',
  );

  $info['sharedcontent_client_queue_crud_action'] = array(
    'worker callback' => 'sharedcontent_client_dequeue_assignment_update',
    'time' => 30,
  );

  return $info;
}

/**
 * Callback method for queued cron run.
 *
 * @param $params
 *   Array with the values passed to sharedcontent_client_index_synchronize().
 *
 * @see sharedcontent_client_index_synchronize()
 */
function sharedcontent_client_queue_synchronization_run(array $params) {
  try {
    call_user_func_array('sharedcontent_client_index_synchronize', $params);
  }
  catch (SharedContentSynchronizeException $e) {
    sharedcontent_event_save('sharedcontent_client', __FUNCTION__, $e->getMessage(), $e->getArguments(), array('severity' => WATCHDOG_ERROR));
    // @todo HIGH reschedule on failure?
    // @todo avoid endless loop (if server is unreachable) but gracefully cover temporary failure? Fail count with reset on success?
    // @todo sync is marked as done in any case!
  }
}

/**
 * Callback method for sharedcontent_assignment_push cron.
 *
 * @param array $params
 *    Array with the values passed to sharedcontent_client_push_assignments().
 *
 * @see sharedcontent_client_push_assignments()
 */
function sharedcontent_client_queue_assignment_push_run(array $params) {
  call_user_func_array('sharedcontent_client_push_assignments', $params);
  // @todo HIGH reschedule on failure
}

/**
 * Manually synchronize index.
 *
 * Callback method to manually synchronize one or all connections.
 *
 * @param $connection_name
 *   Name of the connection to be synchronized or all.
 *
 * @todo HIGH Use the cron queue to to the work instead of doing this
 * twice.
 * @todo HIGH Propagate failures. If the todo above is done this might
 * not be needed any more as long as this is taken care there which is
 * a must.
 */
function sharedcontent_client_manual_synchronize($connection_name) {

  // Take care we get back to the Shared Content status page when the
  // synchronization was triggered from there.
  if (!isset($_GET['destination']) && current_path() == 'admin/config/services/sharedcontent/status/synchronize') {
    $_GET['destination'] = 'admin/config/services/sharedcontent/status';
  }

  if (isset($_GET['reset']) && $_GET['reset'] == 'true') {
    variable_del('sharedcontent_last_sync_' . $connection_name);
  }

  $arguments = array(
    'connection' => $connection_name,
  );
  sharedcontent_event_save('sharedcontent_client', __FUNCTION__, 'Sync Manual.', $arguments, array('severity' => WATCHDOG_DEBUG));

  $connections = array();
  // Just synchronize specific connection
  if (drupal_strtolower($connection_name) == 'all') {
    $connections = sharedcontent_client_get_connections();
  }
  else {
    $all_connections = sharedcontent_client_get_connections();
    if (isset($all_connections[$connection_name])) {
      $connections[] = $all_connections[$connection_name];
    }
  }

  if (empty($connections)) {
    drupal_set_message(t('No connection found for name %name', array('%name' => $connection_name)), 'warning');
    sharedcontent_event_save('sharedcontent_client', __FUNCTION__, 'No connection found.', $arguments, array('severity' => WATCHDOG_ERROR));
    drupal_goto();
  }
  else {
    $batch_size = variable_get('sharedcontent_sync_batch_size', 100);
    foreach ($connections as $config) {
      // @todo log
      $changed = variable_get('sharedcontent_last_sync_' . $config->name, date('Y-m-d H:i', 0));
      $count = sharedcontent_client_index_count($config, $changed);
      // @todo HIGH catch possible exception SharedContentException. This can lead to index inconsistencies
      // @todo HIGH log error here.
      $max = $count;
      $offset = 0;

      // Build batch queue.
      while ($count > 0) {
        $replacements = array(
          '%connection' => $config->name,
          '@count' => $max,
          '@start-time' => $offset,
          '@end-time' => $offset + $batch_size,
        );
        $batch = array(
          'title' => t('Synchronize'),
          'operations' => array(
            array(
              'sharedcontent_client_index_synchronize',
              array($config, $changed, $offset, $batch_size)
            ),
          ),
          'finished' => 'sharedcontent_client_manual_synchronize_finished',
          'progress_message' => '',
          'init_message' => t('Synchronize @start-time to @end-time of @count - %connection.', $replacements),
        );
        batch_set($batch);
        $offset += $batch_size;
        $count -= $batch_size;
      }

      $current_time = date('Y-m-d H:i', REQUEST_TIME);
      $replacements = array(
        'connection' => $config->name,
        'count' => $count,
        'start-time' => $changed,
        'end-time' => $current_time,
      );
      sharedcontent_event_save('sharedcontent_client', __FUNCTION__, 'Queued items for sync', $replacements, array('severity' => WATCHDOG_INFO));

      variable_set('sharedcontent_last_sync_' . $config->name, $current_time);
    }
    // No batches were added.
    $batch = batch_get();
    if (empty($batch)) {
      drupal_set_message(t('Index already up to date.'));
      drupal_goto();
    }
    else {
      batch_process('');
    }
  }
}

/**
 * Finish method for the batched synchronization run.
 *
 * @param $success
 * @param $results
 * @param $operations
 * @param $elapsed
 *
 * @see sharedcontent_client_manual_synchronize()
 * @todo Improve the messages.
 */
function sharedcontent_client_manual_synchronize_finished($success, $results, $operations, $elapsed) {
  $arguments = array(//'connection' => $connection_name, // @todo we don't know here!
  );
  if ($success) {
    drupal_set_message(t('The synchronization run has completed in @elapsed.', array('@elapsed' => $elapsed)));
    sharedcontent_event_save('sharedcontent_client', __FUNCTION__, 'Sync Manual: Complete.', $arguments, array('severity' => WATCHDOG_DEBUG));
  }
  else {
    drupal_set_message(t('The synchronization run did not successfully complete.'), 'error');

    $arguments['results'] = $results;
    $arguments['operations'] = $operations;
    $arguments['elapsed'] = $elapsed;
    sharedcontent_event_save('sharedcontent_client', __FUNCTION__, 'Sync Manual: Fail.', $arguments, array('severity' => WATCHDOG_ERROR));
  }
}

/**
 * Count the items available for synchronization.
 *
 * @param $config
 *   Config of the connection to use.
 * @param $time_start
 *   Count only index records that are newer than the given time.
 *
 * @return int
 *   Positive integer with the amount of available records.
 *
 * @throws SharedContentCountIndexException
 */
function sharedcontent_client_index_count($config, $time_start = NULL) {
  $count = NULL;

  try {
    $connection = new ServicesClientConnection($config);
    $count = _index_count($connection, $config, $time_start);

    $arguments = array(
      'connection' => $config->name,
      'count' => $count,
    );
    sharedcontent_event_save('sharedcontent_client', __FUNCTION__, 'Index Count.', $arguments, array('severity' => WATCHDOG_DEBUG));
  }
  catch (ServicesClientConnectionResponseException $e) {
    throw new SharedContentCountIndexException($config->name, $time_start, date('Y-m-d H:i', REQUEST_TIME - 1), $e);
  }
  return $count;
}

/**
 * Count request.
 *
 * Bare request. The connection must be prepared externaly an there is no
 * exception handling done.
 *
 * @param $connection
 *   The connection to use.
 * @param $config
 * @param $time_start
 *   Count only index records that are newer than the given time.
 *
 * @return type
 *   Positive integer with the amount of available records.
 *
 * @todo Rename to _sharedcontent_client_index_count
 *
 * @todo add throw statements
 */
function _index_count($connection, $config, $time_start = NULL) {
  $filters = array(
    'changed' => $time_start ? $time_start : date('Y-m-d H:i', 0),
  );

  sharedcontent_event_save('sharedcontent_client', __FUNCTION__, 'Count start', array('name' => $config->admin_title), array('severity' => WATCHDOG_DEBUG));
  $count = (int) $connection->action('index', 'count', $filters);
  sharedcontent_event_save('sharedcontent_client', __FUNCTION__, 'Count end', array('name' => $config->admin_title), array('severity' => WATCHDOG_DEBUG));

  return $count;
}

/**
 * Fetch the index from a sharedcontent server and merge it with the local index.
 *
 * @param $connection_name
 *   Name of the connection to use.
 * @param $time_start
 *   Synchronize only index records that are newer than the given time.
 * @param $offset
 *   Start the synchronization with the record at the given offset position.
 * @param $limit
 *   Synchronize only the given count of items. If NULL all indexes are
 *   synchronized.
 *
 * @return
 *   TRUE if synchronization was completed successfully, FALSE otherwise.
 */
function sharedcontent_client_index_synchronize($config, $time_start = NULL, $offset = 0, $limit = 100) {

  // Include ctools plugin so we do not get a fatal when this is run by batch process.
  ctools_include('plugins');

  $log_arguments = array(
    'connection_name' => $config->name,
  );

  try {
    $connection = new ServicesClientConnection($config);
    $count = 0;

    if (is_null($limit)) {
      $limit = _index_count($connection, $config, $time_start);
    }

    $filters = array(
      'changed' => $time_start ? $time_start : '0000-00-00 00:00',
      'offset' => $offset,
      'limit' => $limit,
    );
    $log_arguments['filters'] = $filters;

   $result = $connection->get('index', NULL, $filters);
    if (!is_array($result)) {
      throw new ServicesClientException('Response is not an array.');
    }
    foreach ($result as $data) {
      $data['connection_name'] = $config->name;
      if (isset($data['uuid'])) {

        if (variable_get('sharedcontent_test', FALSE)) {
          $data['uuid'] = drupal_substr($data['entity_id'] . $data['entity_type'] . $config->name, 0, 37);
        }

        $log_arguments['received index records'][] = $data['uuid'];

        $record = sharedcontent_index_load_by_uuid($data['uuid']);

        if (!$record) {
          $record = entity_create('sharedcontent_index', $data);
          $log_arguments['created index records'][] = $record->uuid;
        }
        else {
          // update remote record. Possibly upgrade record if needed.
          $record->merge($data);
          $log_arguments['updated index records'][] = $record->uuid;
        }
        $record->connection_name = $config->name;

        // Possibly upgrade record if needed.
        if (!isset($record->orgin) || $record->orgin != SHAREDCONTENT_INDEX_BUNDLE_REMOTE) {
          $log_arguments['upgraded index records'][$record->uuid] = $record->origin;
        }
        $record->origin = SHAREDCONTENT_INDEX_BUNDLE_REMOTE;
        $record->save();
        $count++;
      }
      else {
        sharedcontent_event_save('sharedcontent_client', __FUNCTION__, 'Invalid data record received.', array(
          'connection_name' => $config->name,
          'filters' => $filters,
          'data' => $data,
        ), array('severity' => WATCHDOG_ERROR));
      }
    }
    $log_arguments['count'] = $count;
    sharedcontent_event_save('sharedcontent_client', __FUNCTION__, 'Successfully synchronized index', $log_arguments, array('severity' => WATCHDOG_INFO));
  }
  catch (Exception $e) {
    throw new SharedContentSynchronizeException($config->name, $log_arguments, $e);
  }
}

/**
 * Fetch the rendered content from the server.
 *
 * @param $uuid
 *   The uuid of the content.
 * @param $view_mode
 *   The view mode the content should be rendered in.
 * @param $language
 *   The language to be used for rendering.
 * @return
 *   Rendered remote content as string or NULL if no content could be found.
 *
 * @todo HIGH Use caching.
 */
function sharedcontent_client_fetch_remote_content($index, $view_mode = 'sharedcontent_teaser', $language = NULL, $ajax = FALSE) {
  $content = array();
  $arguments = array(
    'index' => $index,
    'view_mode' => $view_mode,
    'language' => $language ? : $GLOBALS['language']->language,
    'ajax' => $ajax
  );

  if ($index->connection_name == SHAREDCONTENT_LOCAL_CONNECTION_NAME) {
    // @todo also add css / js in content rendering via attach
    // in the local case it just returns markup
    $entity = sharedcontent_render_content($index, $view_mode, $language);
    $arguments['entity'] = $entity;
    // is it as simple as ..??
    // $content = $entity;
    // @todo check css / js stuff in this case with caching
    $content['#markup'] = drupal_render($entity);
    $arguments['content'] = $content;
    sharedcontent_event_save('sharedcontent_client', __FUNCTION__, 'Local content rendering', $arguments);
    return $content;
  }

  try {

    // Cache the rendered content for 5 minutes by default.
    $cache_lifetime = variable_get('sharedcontent_client_render_cache', 600);
    $cid = NULL;
    if ($cache_lifetime) {
      $cid = 'sharedcontent:' . $index->uuid . ':' . $arguments['language'] . ':' . $view_mode . ':' . $index->changed;
      if ($cache = cache_get($cid, 'cache_field')) {
        if (REQUEST_TIME < $cache->expire) {
          return $cache->data;
        }
      }
    }

    $config = services_client_connection_load($index->connection_name);
    $arguments['connection_config'] = $config;
    $connection = new ServicesClientConnection($config);
    $arguments['connection'] = $connection;

    $filters = array(
      'mode' => $view_mode,
      'lang' => $language,
    );
    $arguments['filters'] = $filters;

    $response = $connection->get('view', $index->uuid, $filters);
    $arguments['response'] = $response;
    $remote_url = isset($response['base_url']) ? $response['base_url'] : FALSE;
    $arguments['remote_url'] = $remote_url;
    if ($remote_url) {
      if (isset($response['css'])) {
        foreach ($response['css'] as $css) {
          $content['#attached']['css'][$remote_url . _sharedcontent_prepend_slash($css)] = array(
            'type' => 'external',
            'sharedcontent_original_path' => $css,
          );
        }
      }
      if (isset($response['js'])) {
        global $base_url;
        foreach ($response['js'] as $js) {
          // @todo encode the remote path, use url() here.
          // @todo create wrapper function for this
          // @todo deduplicate: remote files may also exists locally.
          $content['#attached']['js'][$remote_url . _sharedcontent_prepend_slash($js)] = array(
            'type' => 'external',
            'sharedcontent_original_path' => $js,
          );
        }
      }
      // @todo if a plugin puts local pathes into settings, we fail.
      // The server side plugin needs to make sure there are no local pathes.
      if (isset($response['settings'])) {
        $content['#attached']['js'][] = array(
          'data' => $response['settings'],
          'type' => 'setting',
        );
      }
      if (isset($response['inline_js'])) {
        foreach ($response['inline_js'] as $js) {
          $content['#attached']['js'][$js] = array('type' => 'inline');
        }
      }
      // No libraries by sharecontent support in general.
      // The plugin needs to care explicitly.
    }
    $content['#markup'] = isset($response['content']) ? $response['content'] : NULL;
    $arguments['content'] = $content;
    sharedcontent_event_save('sharedcontent_client', __FUNCTION__, 'Remote content rendering', $arguments, array('severity' => WATCHDOG_DEBUG));

    // Save the cached content into the cache if enabled.
    if ($cache_lifetime && $cid) {
      cache_set($cid, $content, 'cache_field', REQUEST_TIME + $cache_lifetime);
    }

    return $content;
  }
  catch (Exception $e) {
    $arguments['exception'] = $e;
    sharedcontent_event_save('sharedcontent_client', __FUNCTION__, 'Error on remote content rendering', $arguments, array('severity' => WATCHDOG_ERROR));
  }

  return NULL;
}

/**
 * Implements hook_sharedcontent_index_update().
 */
function sharedcontent_client_sharedcontent_index_update($sharedcontent_index) {
  // Clear the render cache on an index update.
  cache_clear_all('sharedcontent:' . $sharedcontent_index->uuid, 'cache_field', TRUE);
}

/**
 * Ensure that the string starts with a '/'.
 *
 * @param $path
 *   String of a path.
 * @return
 *   String with a '/' at the beginning.
 */
function _sharedcontent_prepend_slash($path) {
  if (strpos($path, '/') !== 0) {
    $path = '/' . $path;
  }
  return $path;
}

/**
 * Implements hook_services_client_connection_server().
 */
function sharedcontent_client_services_client_connection_request() {
  $path = drupal_get_path('module', 'sharedcontent_client') . '/plugins';
  return array(
    // @todo move this into test module
    'ServicesClientConnectionTestRequest' => array(
      'name' => 'Test Request',
      'description' => 'Dummy communication for testing purposes.',
      'handler' => array(
        'parent' => 'ServicesClientConnectionRequest',
        'class' => 'ServicesClientConnectionTestRequest',
        'file' => 'ServicesClientConnectionTestRequest.inc',
        'path' => $path,
      ),
    ),
  );
}

/**
 * Add reference field record for local content to existing index record.
 *
 * Create an index record for local content if missing.
 *
 * @param $index_record_id
 *    Entity id of the index record.
 * @param $local_content
 *   Local content entity object.
 * @param $local_content_type
 *   Type string of the local content entity.
 * @param $shared_content_field_name
 *   Shared content field name string. It uses the default field if omitted.
 * @return bool
 *
 * @ingroup sharedcontent_api
 */
function sharedcontent_client_assign_index_to_local_content($index_record_id, $local_content_id, $local_content_type = 'node', $shared_content_field_name = SHAREDCONTENT_CLIENT_SHARED_CONTENT_FIELD_DEFAULT) {
  // @todo this might fail!
  $local_content = entity_load_single($local_content_type, $local_content_id);
  // @todo index_record_id is redundant
  list(, , $local_entity_bundle) = entity_extract_ids($local_content_type, $local_content);

  $shared_content_field = sharedcontent_client_get_shared_content_field($local_content_type, $local_entity_bundle, $shared_content_field_name);

  if (!$shared_content_field) {
    // Missing Shared Content field.
    return FALSE;
  }

  $lang = sharedcontent_client_get_field_language($local_content_type, $shared_content_field, $local_content);
  if (!isset($local_content->{$shared_content_field['field_name']}[$lang])) {
    $local_content->{$shared_content_field['field_name']}[$lang] = array();
  }

  foreach ((array) $local_content->{$shared_content_field['field_name']}[$lang] as $value) {
    if ($value['target_id'] == $index_record_id) {
      // The shared entity is already referenced.
      return TRUE;
    }
  }

  // Add index record.
  $local_content->{$shared_content_field['field_name']}[$lang][] = array('target_id' => $index_record_id);
  entity_save($local_content_type, $local_content);

  return TRUE;
}

/**
 * Remove reference field record for local content to existing index record.
 *
 * @param $index_record_id
 *    Entity id of the index record.
 * @param $local_content
 *   Local content entity object.
 * @param $local_content_type
 *   Type string of the local content entity.
 * @param $shared_content_field_name
 *   Shared content field name string.
 * @return bool
 *   Success.
 *
 * @ingroup sharedcontent_api
 */
function sharedcontent_client_remove_index_from_local_content($index_record_id, $local_content_id, $local_content_type = 'node', $shared_content_field_name = SHAREDCONTENT_CLIENT_SHARED_CONTENT_FIELD_DEFAULT) {
  $local_content = entity_load_single($local_content_type, $local_content_id);
  list(, , $local_entity_bundle) = entity_extract_ids($local_content_type, $local_content);

  $shared_content_field = sharedcontent_client_get_shared_content_field($local_content_type, $local_entity_bundle, $shared_content_field_name);

  if (!$shared_content_field) {
    // Missing Shared Content field.
    return FALSE;
  }

  $lang = sharedcontent_client_get_field_language($local_content_type, $shared_content_field, $local_content);

  $changed = FALSE;

  foreach ((array) $local_content->{$shared_content_field['field_name']}[$lang] as $idx => $value) {
    if ($value['target_id'] == $index_record_id) {
      // Remove index record reference.
      unset($local_content->{$shared_content_field['field_name']}[$lang][$idx]);
      $changed = TRUE;
    }
  }
  if ($changed) {
    entity_save($local_content_type, $local_content);
  }

  return TRUE;
}

/**
 * Helper function to extract the field language.
 *
 * @param $entity_type
 *   Type string of the entity.
 * @param $field
 *   Field object of the entity.
 * @param $entity
 *   Entity object.
 * @return string
 *   Language code.
 *
 * @see sharedcontent_client_assign_index_to_local_content()
 * @see sharedcontent_client_remove_index_from_local_content()
 *
 * @todo Check Drupal 7 updates, it's gonna be in core: http://drupal.org/node/1260640.
 */
function sharedcontent_client_get_field_language($entity_type, $field, $entity) {
  if (isset($field['translatable']) && field_is_translatable($entity_type, $field) && isset($entity->language)) {
    return $entity->language;
  }
  elseif (!empty($entity->{$field['field_name']})) {
    return current(array_keys($entity->{$field['field_name']}));
  }

  return LANGUAGE_NONE;
}

/**
 * Helper function to get a Shared Content reference field - or default field - or all fields.
 *
 * @param $entity_type
 *   Type string of the entity.
 * @param $entity_bundle
 *   Bundle string of the entity.
 * @param $field_name
 *   Field name string, or field marker.
 *   Field marker: SHAREDCONTENT_CLIENT_SHARED_CONTENT_FIELD_DEFAULT.
 * @return object
 *   Single field object.
 */
function sharedcontent_client_get_shared_content_field($entity_type, $entity_bundle, $field_name = SHAREDCONTENT_CLIENT_SHARED_CONTENT_FIELD_DEFAULT) {
  if ($field_name == SHAREDCONTENT_CLIENT_SHARED_CONTENT_FIELD_DEFAULT) {
    $field_name = sharedcontent_client_get_default_shared_content_field_name();
  }

  return field_info_instance($entity_type, $field_name, $entity_bundle);
}

/**
 * Gets the default Shared Content reference field name.
 *
 * If the field does not exists, a new one gets created.
 *
 * @return string
 *   Field name string.
 *
 * @todo Do we really need to create a new field here?
 */
function sharedcontent_client_get_default_shared_content_field_name() {
  $field_names = sharedcontent_client_get_all_shared_content_field_names();
  $field_name = reset($field_names);
  $field = field_info_field($field_name);
  if (empty($field)) {
    module_load_include('inc', 'sharedcontent_client', 'includes/sharedcontent_client.admin');
    sharedcontent_client_create_shared_content_field($field_name);
  }
  return $field_name;
}

/**
 * Gets all Shared Content reference field names.
 *
 * @return array
 *   Array of field name strings.
 */
function sharedcontent_client_get_all_shared_content_field_names() {
  return variable_get('sharedcontent_reference_field', array('sharedcontent_reference'));
}

/**
 * Updates assignments on server.
 *
 * @param $connection_name
 *    Connection name of the connection to be use for updating.
 * @param $assignments
 *    Array of assignment entities to be updated.
 * @param $index
 *    Index of the source content for the assignments to be pushed.
 *
 * @todo HIGH Report failure.
 */
function sharedcontent_client_push_assignments($connection_name, $assignments, $index = NULL) {
  try {
    // The log argument
    $arguments = array(
      'index' => isset($index->uuid) ? $index->uuid : NULL,
      'assignments' => array(),
      'connection' => $connection_name,
    );
    foreach ($assignments as $assignment) {
      $arguments['assignments'][] = $assignment->uuid;
    }
    $severity = WATCHDOG_INFO;
    $message = 'Successfully pushed assignments and associated index';

    $config = services_client_connection_load($connection_name);
    if (is_null($config)) {
      throw new SharedContentConnectionNotFoundException($connection_name);
    }
    $connection = new ServicesClientConnection($config);

    if (!is_null($index)) {
      try {
        $data = $connection->get('index', $index->uuid);
        $data = array_shift($data);

        // @todo Move this into the entities update method.
        $data['uuid'] = $index->uuid;
        $data['entity_id'] = $index->entity_id;
        $data['entity_type'] = $index->entity_type;
        $data['entity_bundle'] = $index->entity_bundle;
        $data['title'] = $index->title;
        $data['keywords'] = $index->keywords;
        $data['tags'] = $index->tags;
        $data['language'] = $index->language;
        $data['url'] = $index->url;
        $data['entity_created'] = $index->entity_created;
        $data['entity_changed'] = $index->entity_changed;
        $data['created'] = $index->created;

        $connection->update('index', $index->uuid, $data);
      }
      catch (Exception $e) {
        // record including the associated assignments.
        throw new SharedContentPushIndexException($connection_name, $index, $e);
      }
    }

    foreach ($assignments as $assignment) {
      try {
        // @todo log
        $data = array();
        $data['uuid'] = $assignment->uuid;
        $data['source'] = $assignment->source;
        $data['target'] = $assignment->target;
        $data['url'] = $assignment->url;
        $data['status'] = $assignment->status;
        $data['created'] = $assignment->created;
        $data['changed'] = $assignment->changed;

        $connection->update('assignments', $assignment->uuid, $data);
      }
      catch (Exception $e) {
        $severity = WATCHDOG_ERROR;
        $arguments['exception'][] = $e;
        $arguments['failed assignments'][] = $assignment->uuid;
        $message = 'Failed to push some assignments.';
      }
    }
  }
  catch (ServicesClientConnectionResponseException $e) {
    $message = 'Failed to push assignments and associated index';
    $arguments['exception'] = $e;
    $severity = WATCHDOG_ERROR;
  }
  catch (Exception $e) {
    $message = $e->getMessage();
    $arguments['exception'] = $e;
    $severity = WATCHDOG_ERROR;
  }

  sharedcontent_event_save('sharedcontent_client', __FUNCTION__, $message, $arguments, array('severity' => $severity));
}

/**
 * Fetch remote entity bundle labels.
 *
 * @param $types
 *    Array of entity types the bundles should be fetched for.
 * @return
 *    Array with bundles as key and labels as value.
 *
 * @todo split per-server with overall loop.
 * @todo Deal with different labels for same bundle key.
 */
function sharedcontent_client_get_remote_entity_bundle_labels($types) {
  $labels = array();

  foreach (sharedcontent_client_get_connections() as $connection_config) {
    try {
      $connection = new ServicesClientConnection($connection_config);

      foreach ($types as $type => $bundles) {
        $result = $connection->get('labels', $type);
        if (!empty($result)) {
          foreach ($result as $key => $label) {
            if (in_array($key, $bundles)) {
              $labels += array($key => $label);
            }
          }
        }
      }

    }
    catch (Exception $e) {
      // This connection failed. Report failure and continue.
      sharedcontent_event_save('sharedcontent_client', __FUNCTION__, $e->getMessage(), array('exception' => $e), array('severity' => WATCHDOG_ERROR));
    }
  }

  return $labels;
}

/**
 * Update assignment records from sharedcontent fields.
 *
 * This function is called when ever an entity gets saved.
 * It updates the assignments based on the fields marked as Shared
 * Content reference fields.
 * If there is no such field present on the entity the function skips
 * execution.
 *
 * This function triggers the following rule events depending on if a
 * assignment is created or removed.
 *
 * * sharedcontent_assignment_local_link
 * * sharedcontent_assignment_local_unlink
 *
 * @param $entity
 *    The entity that was updated
 * @param $type
 *    The entity type that was updated.
 *
 * @todo after changing the fields, this needs reexecution over ALL entities.
 *
 * @see _sharedcontent_entity_is_linkable()
 * @see sharedcontent_client_get_all_shared_content_field_names()
 * @see sharedcontent_index_exists()
 * @see sharedcontent_create_or_update_index_for_entity()
 */
function _sharedcontent_client_update_assignments($entity, $type) {
  // Do nothing when the content type is not linkable.
  if (!_sharedcontent_entity_is_linkable($type)) {
    return;
  }

  // The referenced records keyed by their uuids.
  $targets = array();

  foreach (sharedcontent_client_get_all_shared_content_field_names() as $field_name) {
    // Get the referenced records.
    $items = field_get_items($type, $entity, $field_name);
    if (is_array($items) && !empty($items)) {
      foreach ($items as $item) {
        $target_index = entity_load_single('sharedcontent_index', $item['target_id']);
        // @todo HIGH this might fail (?)
        $targets[$target_index->uuid] = $target_index;
      }
    }
  }

  // Prevent index creation if there is nothing linked.
  // Also drop assignment if the index record is missing.
  if (empty($targets) && !sharedcontent_index_exists($entity, $type)) {
    return;
  }

  // Take care there is a valid index record for the source entity.
  // @todo log
  $source_index = sharedcontent_create_or_update_index_for_entity($entity, $type);

  // Get existing assignments for this source entity
  $assignments = entity_load('sharedcontent_assignment', FALSE, array(
    'source_id' => $source_index->id,
    'origin' => SHAREDCONTENT_INDEX_BUNDLE_LOCAL,
  ));

  // Assignments that have changed keyed by the connection name of the
  // target.
  $changed_assignments = array();

  foreach ($assignments as $assignment) {
    $changed = FALSE;
    // The assignment is active
    $target_exists = array_key_exists($assignment->target, $targets);
    if ($target_exists) {
      // @todo log
      $assignment->status = SHAREDCONTENT_ASSIGNMENT_ACTIVE;
      $changed = TRUE;
      rules_invoke_event('sharedcontent_assignment_local_link', $assignment);
    }
    // The assignment does no longer exists
    else {
      // @todo log
      $assignment->status = SHAREDCONTENT_ASSIGNMENT_DELETED;
      $changed = TRUE;
      rules_invoke_event('sharedcontent_assignment_local_unlink', $assignment);
    }

    if ($changed) {
      $assignment->save();
      if ($target_exists) {
        $connection_name = $targets[$assignment->target]->connection_name;
      }
      else {
        $entities = entity_load('sharedcontent_index', FALSE, array(
          'uuid' => $assignment->target,
        ));
        $target_index_entity = reset($entities);
        $connection_name = $target_index_entity->connection_name;
      }
      $changed_assignments[$connection_name][$assignment->id] = $assignment;
    }
    unset($targets[$assignment->target]);
  }

  // Create missing assignments.
  foreach ($targets as $target_index) {
    // @todo log
    $assignment = entity_create('sharedcontent_assignment', array(
      'source' => $source_index->uuid,
      'target' => $target_index->uuid,
    ));
    rules_invoke_event('sharedcontent_assignment_local_link', $assignment);
    $assignment->save();
    $changed_assignments[$target_index->connection_name][$assignment->id] = $assignment;
  }

  // Inform server about assignment.
  $queue = DrupalQueue::get('sharedcontent_assignment_push');
  foreach ($changed_assignments as $connection_name => $assignments) {
    // @todo log
    $queue->createItem(array(
      $connection_name,
      $assignments,
      $source_index
    ));
  }
}

/**
 * Determine if entity can link to Shared Content.
 *
 * @param $type
 *    Type of the entity as string.
 * @return
 *   TRUE if the entity is can link Shared Content, FALSE otherwise.
 */
function _sharedcontent_entity_is_linkable($type) {
  $is_linkable = & drupal_static(__FUNCTION__ . $type);
  if (!isset($is_linkable)) {
    $is_linkable = FALSE;
    $field_names = sharedcontent_client_get_all_shared_content_field_names();
    $instances = field_info_instances($type);
    foreach ($instances as $instance) {
      foreach ($field_names as $field_name) {
        if (array_key_exists($field_name, $instance)) {
          $is_linkable = TRUE;
          return $is_linkable;
        }
      }
    }
  }
  return $is_linkable;
}

/**
 * Implements hook_entity_insert().
 *
 * @see _sharedcontent_client_update_assignments()
 */
function sharedcontent_client_entity_insert($entity, $type) {
  sharedcontent_client_entity_manipulation($entity, $type);
}

/**
 * Implements hook_entity_update().
 *
 * @see _sharedcontent_client_update_assignments()
 */
function sharedcontent_client_entity_update($entity, $type) {
  sharedcontent_client_entity_manipulation($entity, $type);
}

/**
 * Implements hook_entity_delete().
 *
 * @see _sharedcontent_client_update_assignments()
 */
function sharedcontent_client_entity_delete($entity, $type) {
  sharedcontent_client_entity_manipulation($entity, $type);
}

/**
 * Wrapper function to queue CRUD actions if
 * corresponding setting is active.
 */
function sharedcontent_client_entity_manipulation($entity, $type) {
  list($entity_id, , $bundle) = entity_extract_ids($type, $entity);
  $indexed_entities = variable_get('sharedcontent_indexed_entities', array());
  if (isset($indexed_entities[$type][$bundle]) && $indexed_entities[$type][$bundle] == TRUE) {
    if (variable_get('sharedcontent_queue_indexed_entities', FALSE)) {
      $item = array(
        'entity_id' => $entity_id,
        'type' => $type,
      );
      $queue = DrupalQueue::get('sharedcontent_client_queue_crud_action');
      $queue->createItem($item);
    }
    else {
      _sharedcontent_client_update_assignments($entity, $type);
    }
  }
}

/**
 * Callback that executes the queued action for entities.
 */
function sharedcontent_client_dequeue_assignment_update($data) {
  $entity = entity_load_single($data['type'], $data['entity_id']);
  if ($entity) {
    _sharedcontent_client_update_assignments($entity, $data['type']);
  }
  else {
    sharedcontent_event_save('sharedcontent_client', __FUNCTION__, 'Failed to load entity', $data, array('severity' => WATCHDOG_WARNING));
  }
}

/**
 * Get connections.
 *
 * Get a set of services client connections.
 * The function allows to get all, only active and only Shared Content
 * enabled connections.
 *
 * @param $active_only
 *    Get only active connections, Defaults to TRUE.
 * @param $sc_only
 *    Get only Shared Content enabled connections.
 * @return
 *    Array with the connections machine name as key an the connection config as value.
 */
function sharedcontent_client_get_connections($active_only = TRUE, $sc_only = TRUE) {
  $sc_connections = variable_get('sharedcontent_endpoint_connections', array());
  $connections = array();

  foreach (services_client_connection_load_all() as $connection) {
    // Skip disabled connections.
    if ($active_only && !empty($connection->disabled)) {
      continue;
    }

    // Skip non sharedcontent connections.
    if ($sc_only && !in_array($connection->name, $sc_connections)) {
      continue;
    }

    // This does not seem to invoke the load hook, make sure he is always
    // called. We set a flag to prevent double execution.
    sharedcontent_services_client_connection_load($connection);

    $connections[$connection->name] = $connection;
  }
  return $connections;
}

/**
 * Implements hook_sharedcontent_connection_operations().
 */
function sharedcontent_client_sharedcontent_connection_operations($var) {
  $links = array();

  $query = drupal_get_destination();

  if ($var['pending_count'] == 0 && $var['is_active']) {
    $links['connection-sync'] = array(
      'title' => t('synchronize'),
      'href' => 'admin/config/services/sharedcontent/client/synchronize/' . $var['connection']->name,
      'query' => $query,
      'attributes' => array('class' => array('views-ajax-link')),
    );
    $links['connection-resync'] = $links['connection-sync'];
    $links['connection-resync']['title'] = t('resynchronize all');
    $links['connection-resync']['query']['reset'] = 'true';
  }

  $href = 'admin/config/services/sharedcontent/connection/' . $var['connection']->name;
  if ($var['is_active']) {
    $query['action'] = SHAREDCONTENT_CLIENT_ACTION_CONNECTION_DISABLE;
    $links['connection-disable'] = array(
      'title' => t('disable'),
      'href' => $href,
      'query' => $query,
      'attributes' => array('class' => array('views-ajax-link')),
    );
  }
  else {
    $query['action'] = SHAREDCONTENT_CLIENT_ACTION_CONNECTION_ENABLE;
    $links['connection-enable'] = array(
      'title' => t('enable'),
      'href' => $href,
      'query' => $query,
      'attributes' => array('class' => array('views-ajax-link')),
    );
  }

  $links['connection-edit'] = array(
    'title' => t('edit'),
    'href' => 'admin/structure/services_client/connection/list/' . $var['connection']->name . '/edit',
    'query' => $query,
    'attributes' => array('class' => array('views-ajax-link')),
  );

  return $links;
}

/**
 * Implements hook_field_extra_fields().
 */
function sharedcontent_client_field_extra_fields() {
  $field_info = field_info_fields();
  $extra_fields = array();
  foreach (field_info_instances() as $entity_type => $bundles) {
    foreach ($bundles as $bundle => $fields) {
      foreach ($fields as $field) {
        if ($field_info[$field['field_name']]['type'] == 'entityreference'
          && $field_info[$field['field_name']]['settings']['target_type'] == 'sharedcontent_index'
        ) {
          $extra_fields[$entity_type][$bundle]['display'][$field['field_name'] . ':sharedcontent_jump_links'] = array(
            'label' => t('@field_label: Jump Links', array('@field_label' => $field['label'])),
            'description' => t('Jump links to the refernced'),
            'weight' => $field['display']['default']['weight'],
            // Added in advance for being prepared once #1256368 gets committed.
            // @todo Remove comment once #1256368 got committed.
            'visible' => FALSE,
          );
        }
      }
    }
  }
  return $extra_fields;
}

/**
 * Implements hook_field_extra_fields_display_alter().
 *
 * This whole implementation is basically a hack because Drupal core does not
 * allow you to specify default visibility for extra fields. We don't want any
 * of the jump link extra fields to be visible by default in referencing
 * entities, so we have to alter the display settings at this point until such a
 * time as the settings have been updated for the given bundle.
 *
 * @todo Remove function once #1256368 got committed.
 */
function sharedcontent_client_field_extra_fields_display_alter(&$displays, $context) {
  // Load the bundle settings for the current bundle.
  $bundle_settings = field_bundle_settings($context['entity_type'], $context['bundle']);

  // Loop over the extra fields defined by Shared Content
  $extra_fields = field_info_extra_fields($context['entity_type'], $context['bundle'], 'display');

  // Prevent notices if there are no product types defined.
  if (empty($extra_fields)) {
    return;
  }

  foreach ($extra_fields as $extra_field_name => $extra_field) {
    // If the current extra field is represented in the $displays array...
    if (strpos($extra_field_name, ':sharedcontent_jump_links') !== FALSE) {
      // And no data yet exists for the extra field in the bundle settings...
      if (empty($bundle_settings['extra_fields']['display'][$extra_field_name]) ||
          (empty($bundle_settings['view_modes'][$context['view_mode']]['custom_settings']) && empty($bundle_settings['extra_fields']['display'][$extra_field_name]['default'])) ||
          (!empty($bundle_settings['view_modes'][$context['view_mode']]['custom_settings']) && empty($bundle_settings['extra_fields']['display'][$extra_field_name][$context['view_mode']]))
      ) {
        // Default the extra field to be invisible.
        $displays[$extra_field_name]['visible'] = FALSE;
      }
    }
  }
}

/**
 * Implements hook_field_attach_view_alter()
 */
function sharedcontent_client_field_attach_view_alter(&$output, $context) {
  if ($context['view_mode'] == '_custom') {
    // Do not attempt to attach something if view_mode is custom, that means
    // we are only rendering a single field with custom settings.
    return;
  }

  list(, , $bundle) = entity_extract_ids($context['entity_type'], $context['entity']);
  $extra_fields = field_extra_fields_get_display($context['entity_type'], $bundle, $context['view_mode']);
  foreach ($extra_fields as $name => $settings) {
    if (strpos($name, ':sharedcontent_jump_links') !== FALSE && !empty($settings['visible'])) {
      list($field_name, ) = explode(':', $name);
      $items = field_get_items($context['entity_type'], $context['entity'], $field_name);
      if ($items) {
        $list_items = array();

        foreach ($items as $item) {
          $index = FALSE;
          if (!empty($item['entity'])) {
            $index = $item['entity'];
          }
          elseif (!empty($item['target_id'])) {
            $index = entity_load_single('sharedcontent_index', $item['target_id']);
          }
          if ($index) {
            $uri = entity_uri($context['entity_type'], $context['entity']);
            $uri['options']['fragment'] = 'sharedcontent-' . $index->uuid;
            $uri['options']['attributes']['class'][] = 'sharedcontent-jumplink';
            $uri['options']['attributes']['class'][] = 'sharedcontent-jumplink-' . $index->entity_type;
            $uri['options']['attributes']['class'][] = 'sharedcontent-jumplink-' . $index->entity_type . '-' . $index->entity_bundle;
            $list_items[] = l($index->title, $uri['path'], $uri['options']);
          }
        }

        $output[$name] = array(
          '#theme' => 'item_list__sharedcontent_jump_links',
          '#items' => $list_items,
          '#weight' => $settings['weight'],
        );
      }
    }
  }
}
