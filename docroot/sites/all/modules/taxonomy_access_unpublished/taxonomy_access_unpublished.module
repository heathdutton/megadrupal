<?php
/**
 * @file
 * Extends Taxonomy Access Control grants to unpublished nodes.
 *
 * This module uses the Taxonomy Entity Index (TEI) to work around the fact 
 * that unpublished nodes are not maintained in core's {taxonomy_index} table.
 *
 * @see
 *    http://drupal.org/node/962664
 * @see
 *   http://drupal.org/node/1211688
 */

/**
 * Implements hook_enable().
 */
function taxonomy_access_unpublished_enable() {
  // Update node access if appropriate.
  _taxonomy_access_unpublished_update_node_access();
}

/**
 * Implements hook_disable().
 */
function taxonomy_access_unpublished_disable() {
  // Update node access if appropriate.
  _taxonomy_access_unpublished_update_node_access();
}

/**
 * Helper function to update node access when appropriate.
 *
 * For now we just check for unpublished nodes and roles with the permissions,
 * and flag node access for rebuild if there are both.
 *
 * A better solution would be to select unpublished nodes that should have
 * allow grants, but SelectQuery::having() is broken.
 * @see http://drupal.org/node/1258000
 */
function _taxonomy_access_unpublished_update_node_access() {
  // Check for unpublished nodes.
  $unpublished_nodes =
    db_query(
      "SELECT nid FROM {node} WHERE status <> :status",
      array(':status' => NODE_PUBLISHED)
    )
    ->fetchCol();

  $unpublished_roles = user_roles(FALSE, 'taxonomy access unpublished');

  if (!empty($unpublished_roles) && !empty($unpublished_nodes)) {
    _taxonomy_access_flag_rebuild();
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * This would be better done with a hook, but there isn't one we can use.
 */
function taxonomy_access_unpublished_form_user_admin_permissions_alter(&$form, &$form_state) {
  $form['#submit'][] = 'taxonomy_access_unpublished_user_admin_permissions_submit';
}

/**
 * Submit handler to update node access when module permissions are changed.
 *
 * For now we just check for unpublished nodes when a role's permission 
 * changes, and flag node access for rebuild if there are any.
 *
 * A better solution would be to select unpublished nodes that should have
 * allow grants, but SelectQuery::having() is broken.
 * @see http://drupal.org/node/1258000
 */
function taxonomy_access_unpublished_user_admin_permissions_submit($form, &$form_state) {
  // Check whether the permission has been changed in each case.
  foreach ($form_state['values']['role_names'] as $rid => $name) {

    // Check whether the permission is in the submitted values.
    $submitted = $form_state['values'][$rid]['taxonomy access unpublished'];
    
    // Check whether the permission was set in the original form.
    $original = in_array('taxonomy access unpublished', $form['checkboxes'][$rid]['#default_value']);

    // If the permission has changed, check for unpublished nodes.
    if (($original && !$submitted) || (!$original && $submitted)) {
      $unpublished_nodes =
        db_query(
          "SELECT nid FROM {node} WHERE status <> :status",
          array(':status' => NODE_PUBLISHED)
        )
        ->fetchCol();

      // Flag rebuild if there are any unpublished nodes.
      if (!empty($unpublished_nodes)) {
        _taxonomy_access_flag_rebuild();
      }
    }
  }
}

/**
 * Implements hook_permission().
 */
function taxonomy_access_unpublished_permission() {
  return array(
    'taxonomy access unpublished' => array(
      'title' => t('Use Taxonomy Access Control for unpublished nodes'),
      'description' => t('Allow the user access to unpublished nodes according to Taxonomy Access Control grants.  Without this permission, access to unpublished nodes is always denied.'),
      'restrict access' => TRUE,
    )
  );
}

/**
 * Implements hook_node_access_records_alter().
 */
function taxonomy_access_unpublished_node_access_records_alter(&$grants, $node) {
  // We alter grants for unpublished nodes only. 
  // Published nodes are handled by taxonomy_access itself.
  if (!$node->status) {
    $grant_records = _taxonomy_access_node_access_records($node->nid);

    $unpublished_roles =
      _taxonomy_access_user_roles('taxonomy access unpublished');

    // Only write grants for roles with the permission.
    foreach ($grant_records as $key => $record) {
      if (!in_array($record['gid'], array_keys($unpublished_roles))) {
        unset($grant_records[$key]);
      }
    }

    $grants = $grant_records;
  }
}

/**
 * Implements hook_query_TAG_alter().
 */
function taxonomy_access_unpublished_query_taxonomy_access_node_alter(QueryAlterableInterface $query) {
  // Alter taxonomy_access queries to use {taxonomy_entity_index}.
  if ($query->hasTag('taxonomy_access_node')) {
    // Iterate over tables and replace {taxonomy_index} with TEI.
    // Keep the table aliases used for {taxonomy_index} in $ti_aliases.
    $ti_aliases = array();
    $tables =& $query->getTables();
    foreach ($tables as &$tbl) {
      if ($tbl['table'] == 'taxonomy_index') {
        $ti_aliases[] = $tbl['alias'];
        $tbl['table'] = 'taxonomy_entity_index';
      }
    }
    // Don't alter if there is no reference to taxonomy_index.
    if (empty($ti_aliases)) {
      return;
    }

    // Select only node entities.
    $query
      ->condition(db_escape_table($ti_aliases[0]) . '.entity_type', 'node');

    // Select the most current revision since node access is not revisioned.
    $query
      ->join(
        'node', 'node',
        db_escape_table($ti_aliases[0]) . '.entity_id = node.nid AND '
        . db_escape_table($ti_aliases[0]) . '.revision_id = node.vid'
      );

    // Iterate over conditions in order to change alias.nid to alias.entity_id.
    $cond =& $query->conditions();
    foreach ($cond as &$c) {
      foreach ($ti_aliases as $alias) {
        if ($c['field'] == $alias.'.nid') {
          $c['field'] = $alias.'.entity_id';
          break;
        }
      }
    }
    // Iterate over fields in order to change alias.nid to alias.entity_id.
    $fields =& $query->getFields();
    foreach ($fields as &$f) {
      if ($f['field'] == 'nid' && in_array($f['table'], $ti_aliases)) {
        $f['field'] = 'entity_id';
      }
    }
  }
}

/**
 * Implements hook_help().
 */
function taxonomy_access_unpublished_help($path, $arg) {
  switch ($path) {
    case 'admin/help#taxonomy_access_unpublished':
      $message = '';
      $message .= ''
        . '<p>' 
        . t("The TAC Unpublished module is an extension module for <a href=\"@tac\">Taxonomy Access Control</a> (TAC).  It allows TAC's grants to control unpublished nodes.",
          array('@tac' => 'http://drupal.org/project/taxonomy_access'))
        . '</p>'
        . '<p>'
        . t("This module allows administrators to grant certain roles the <em>Use Taxonomy Access Control for unpublished nodes</em> permission.  Users with this permission can access unpublished nodes according to TAC's taxonomy-based grants.  Users without the permission are denied access for unpublished nodes.") 
        . '</p>'
        . '<p>' 
        . t('Because of a current limitation on taxonomy indexing and unpublished nodes, the module uses <a href="@tei">Taxonomy Entity Index</a> (TEI) as its term index.  TEI adds nontrivial overhead. This is probably not a huge concern for most sites, but large or high-traffic sites may wish to consider an alternate method.  For more information see this <a href="@drupal">drupal.org</a> issue: <a href="@issue">Taxonomy Index for unpublished entities</a>.  Once this issue is fixed, the functionality provided by this module will be merged into Taxonomy Access Control and TEI will no longer be necessary.',
          array(
            '@tei' => 'http://drupal.org/project/taxonomy_entity_index',
            '@drupal' => 'http://drupal.org',
            '@issue' => 'http://drupal.org/node/962664',
          ))
        . '</p>'
        ;
      return $message;
      break;
  }
}