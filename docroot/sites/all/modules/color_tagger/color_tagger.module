<?php

/**
 * @file
 * Color Tagger Module.
 */

/**
 * Implements hook_menu().
 */
function color_tagger_menu() {
  $items['admin/config/media/color-tagger'] = array(
    'title' => 'Color Tagger',
    'page callback' => 'color_tagger_admin_page',
    'access arguments' => array('administer color tagger'),
    'description' => 'Info page for Color Tagger module.',
    'access callback' => 'user_access',
    'file' => 'color_tagger.admin.inc',
  );
  $items['admin/config/media/color-tagger/info'] = array(
    'title' => 'Color Tagger Info',
    'page callback' => 'color_tagger_admin_page',
    'access arguments' => array('administer color tagger'),
    'description' => 'Info page for Color Tagger module.',
    'access callback' => 'user_access',
    'file' => 'color_tagger.admin.inc',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/config/media/color-tagger/settings'] = array(
    'title' => 'Color Tagger Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('color_tagger_admin_settings_form'),
    'access arguments' => array('administer color tagger'),
    'description' => 'Configure global settings for Color Tagger.',
    'access callback' => 'user_access',
    'file' => 'color_tagger.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  return $items;
}

/**
 * Implements hook_permission().
 */
function color_tagger_permission() {
  return array(
    'administer color tagger' => array(
      'title' => t('Administer Color Tagger Settings'),
    ),
  );
}

/**
 * Implements hook_field_attach_presave().
 */
function color_tagger_field_attach_presave($entity_type, $entity) {
  // Get bundle name.
  list(, , $bundle_name) = entity_extract_ids($entity_type, $entity);
  // Get all fields on entity with settings.
  $fields = field_info_instances($entity_type, $bundle_name);
  // Check if the entity has any fields we need to process.
  if ($color_tagger_fields = _color_tagger_get_color_tagger_fields($fields)) {
    $entity_wrapper = entity_metadata_wrapper($entity_type, $entity);
    // Loop through color tagger fields.
    foreach ($color_tagger_fields as $field_name => $color_tagger_settings) {
      // Check if field should be processed.
      $field = $entity_wrapper->$field_name->value();
      if (empty($field) || color_tagger_get_record('force_process', 0)) {
        // Get the associated image and process it.
        if ($image_uri = _color_tagger_get_image_uri($entity, $entity_wrapper, $color_tagger_settings['image_field'])) {
          // Load colors from vocabulary.
          if ($color_palette = _color_tagger_get_color_palette($color_tagger_settings['hex_code_field'], $color_tagger_settings['vocabulary'])) {
            // Process image.
            module_load_include('inc', 'color_tagger', 'ColorTaggerImage');
            $image = new ColorTaggerImage($image_uri, $color_palette);
            if ($colors = $image->getMatchedColors($color_tagger_settings['blacklist_colors'], TRUE)) {
              $entity_wrapper->$field_name->set(array_keys($colors));
            }
          }
        }
      }
    }
  }
}

/**
 * Gets all fields using the color tagger widget along with the widget settings.
 *
 * @param array $fields
 *   An array of fields on an entity returned from field_info_instances().
 *
 * @return mixed
 *   Returns FALSE if no fields using the color_tagger_widget are found.
 *   Otherwise, returns an array of settings from the color_tagger_widget.
 */
function _color_tagger_get_color_tagger_fields($fields) {
  $result = FALSE;
  foreach ($fields as $field_name => $field_value) {
    if ($field_value['widget']['type'] == 'color_tagger_widget') {
      // Check if image_field parameter is set.
      if (!empty($field_value['widget']['settings']['image_field'])) {
        $color_tagger_settings['image_field'] = $field_value['widget']['settings']['image_field'];
      }
      else {
        drupal_set_message(t('"image_field" parameter on color tagger widget for @field_name is not set.', array('@field_name' => $field_name)), 'error');
        return FALSE;
      }

      // Check if hex_code_field parameter is set.
      if (!empty($field_value['widget']['settings']['hex_code_field'])) {
        $color_tagger_settings['hex_code_field'] = $field_value['widget']['settings']['hex_code_field'];
      }
      else {
        drupal_set_message(t('"hex_code_field" parameter on color tagger widget for @field_name is not set.', array('@field_name' => $field_name)), 'error');
        return FALSE;
      }

      // Blacklist Colors.
      $color_tagger_settings['blacklist_colors'] = $field_value['widget']['settings']['blacklist_colors'];

      // Get vocabulary machine name.
      $field_info = field_info_field($field_name);
      $color_tagger_settings['vocabulary'] = $field_info['settings']['allowed_values'][0]['vocabulary'];

      $result[$field_name] = $color_tagger_settings;
    }
  }
  return $result;
}

/**
 * Gets the uri property of the image field for a particular color tagger field.
 */
function _color_tagger_get_image_uri($entity, $entity_wrapper, $image_field_name) {
  if (!isset($entity->$image_field_name)) {
    // Field doesn't exist.
    drupal_set_message(t("The field @image_field was not found. Could not process image for color tagging.", array('@image_field' => $image_field_name)), 'error');
    return FALSE;
  }
  else {
    $image_field = $entity_wrapper->$image_field_name->value();
    if (!$image_field) {
      // Field is empty.
      drupal_set_message(t("URI property of @image_field could not be determined. Field may be empty.", array('@image_field' => $image_field_name)), 'error');
      return FALSE;
    }
    else {
      // Return file URI.
      $file = file_load($image_field['fid']);
      return $file->uri;
    }
  }
}

/**
 * Gets all the color values of the terms in the $vocabulary_name vocabulary.
 *
 * @param string $hex_code_field
 *   The name of the field on the taxonomy that holds the hex code values.
 *
 * @param string $vocabulary_name
 *   The machine name of the vocabulary.
 *
 * @return array
 *   An array of RGB or LAB color values paired with term TIDs.
 */
function _color_tagger_get_color_palette($hex_code_field, $vocabulary_name) {
  $use_lab = color_tagger_get_record('use_lab', 1);
  $vocabulary = taxonomy_vocabulary_machine_name_load($vocabulary_name);
  $terms = taxonomy_get_tree($vocabulary->vid, 0, NULL, TRUE);
  // Check if field exists on terms.
  if (!isset($terms[0]->$hex_code_field)) {
    drupal_set_message(t('Field "@field" not found on terms in vocabulary "@vocab". Could not process image for color tagging.', array('@field' => $hex_code_field, '@vocab' => $vocabulary_name)), 'error');
    return FALSE;
  }
  // Loop through terms and load color values into $color_palette array.
  $color_palette = array();
  foreach ($terms as $term) {
    $term_wrapper = entity_metadata_wrapper('taxonomy_term', $term);
    if ($hex = $term_wrapper->$hex_code_field->value()) {
      // Loop through all values from $hex_code_field.
      foreach ((array) $hex as $hex_code) {
        if ($rgb = _color_tagger_hex_to_rgb($hex_code)) {
          $color_data = array(
            'tid' => $term->tid,
            'rgb' => $rgb,
          );
          if ($use_lab) {
            $lab = _color_tagger_rgb_to_lab($rgb);
            $color_data['lab'] = $lab;
          }
          $color_palette[] = $color_data;
        }
        else {
          // Property on term was an invalid hexadecimal value.
          drupal_set_message(t('Value of "@hex" on the term "@term_name" is an invalid hexadecimal value and could not be processed.', array('@hex' => $hex_code, '@term_name' => $term->name)), 'warning');
        }
      }
    }
    else {
      // $hex_code_field was empty.
      drupal_set_message(t('Field "@field" on term "@term_name" is empty and was ignored.', array('@term_name' => $term->name, '@field' => $hex_code_field)), 'warning');
    }
  }
  if ($color_palette) {
    return $color_palette;
  }
  else {
    // All terms missing hexcodes.
    drupal_set_message(t('No valid hexadecimal codes were found on the terms in the vocabulary "@vocab". Check that the values in field "@field" are valid hexadecimal values.', array('@field' => $hex_code_field, '@vocab' => $vocabulary_name)), 'error');
    return FALSE;
  }
}


/***********************************************
 * Color Tagger Color Calculation Functions.
 ***********************************************/

/**
 * Convert a hexadecimal color code to its RGB equivalent.
 *
 * @param string $hex
 *   Hexadecimal color value.
 *
 * @return array
 *   An array of RGB color values.
 */
function _color_tagger_hex_to_rgb($hex) {
  // Format hex string
  $hex = preg_replace("/[^0-9A-Fa-f]/", '', $hex);

  // If a 6 digit hex code, convert using bitwise operation.
  if (strlen($hex) == 6) {
    $color = hexdec($hex);
    $r = 0xFF & ($color >> 0x10);
    $g = 0xFF & ($color >> 0x8);
    $b = 0xFF & $color;
  }
  // Shorthand notation.
  elseif (strlen($hex) == 3) {
    $r = hexdec(str_repeat(substr($hex, 0, 1), 2));
    $g = hexdec(str_repeat(substr($hex, 1, 1), 2));
    $b = hexdec(str_repeat(substr($hex, 2, 1), 2));
  }
  else {
    // Invalid hex color code.
    return FALSE;
  }
  return array($r, $g, $b);
}

/**
 * Convert a RGB color array to its LAB equivalent.
 *
 * @param array $rgb
 *   An array of RGB color values.
 *
 * @return array
 *   An array of LAB color values.
 */
function _color_tagger_rgb_to_lab($rgb) {
  list($r, $g, $b) = $rgb;

  // First convert RGB to XYZ color format.
  $r = $r <= 0.04045 ? $r / 12.92 : pow(($r + 0.055) / 1.055, 2.4);
  $g = $g <= 0.04045 ? $g / 12.92 : pow(($g + 0.055) / 1.055, 2.4);
  $b = $b <= 0.04045 ? $b / 12.92 : pow(($b + 0.055) / 1.055, 2.4);
  $r *= 100;
  $g *= 100;
  $b *= 100;
  $x = $r * 0.412453 + $g * 0.357580 + $b * 0.180423;
  $y = $r * 0.212671 + $g * 0.715160 + $b * 0.072169;
  $z = $r * 0.019334 + $g * 0.119193 + $b * 0.950227;

  // Convert XYZ to LAB.
  $x /= 95.047;
  $y /= 100;
  $z /= 108.883;
  $x = $x > 0.008856 ? pow($x, 1 / 3) : $x * 7.787 + 16 / 116;
  $y = $y > 0.008856 ? pow($y, 1 / 3) : $y * 7.787 + 16 / 116;
  $z = $z > 0.008856 ? pow($z, 1 / 3) : $z * 7.787 + 16 / 116;
  $l = $y * 116 - 16;
  $a = ($x - $y) * 500;
  $b = ($y - $z) * 200;
  return array($l, $a, $b);
}

/**
 * Calculates distance between two RGB values.
 *
 * @param array $color1
 *   An array of RGB color values.
 *
 * @param array $color2
 *   An array of RGB color values.
 *
 * @return number
 *   The squared Euclidean distance between the two color values.
 */
function _color_tagger_calculate_color_distance_rgb($color1, $color2) {
  list($r1, $g1, $b1) = $color1;
  list($r2, $g2, $b2) = $color2;

  $delta_r = $r1 - $r2;
  $delta_g = $g1 - $g2;
  $delta_b = $b1 - $b2;

  return pow($delta_r, 2) + pow($delta_g, 2) + pow($delta_b, 2);
}

/**
 * Calculates distance between two LAB values using the CIEDE2000 formula.
 *
 * @link http://en.wikipedia.org/wiki/Color_difference#CIEDE2000
 *
 * @param array $color1
 *   An array of LAB color values.
 *
 * @param array $color2
 *   An array of LAB color values.
 *
 * @return number
 *   The CIEDE2000 Delta-E color difference value between the two colors.
 */
function _color_tagger_calculate_color_distance_lab_2000($color1, $color2) {
  list($L1, $a1, $b1) = $color1;
  list($L2, $a2, $b2) = $color2;

  $kl = $kc = $kh = 1;

  /**
   * 1. Calculate avg_Lp, c1p, c2p, avg_cp h1p, h2p, avg_hp.
   */
  $avg_Lp = ($L1 + $L2) / 2;

  $c1 = sqrt(pow($a1, 2) + pow($b1, 2));
  $c2 = sqrt(pow($a2, 2) + pow($b2, 2));
  $avg_c = ($c1 + $c2) / 2;

  $g = (1 - sqrt(pow($avg_c, 7) / (pow($avg_c, 7) + pow(25, 7)))) / 2;
  $a1p = $a1 * (1 + $g);
  $a2p = $a2 * (1 + $g);

  $c1p = sqrt(pow($a1p, 2) + pow($b1, 2));
  $c2p = sqrt(pow($a2p, 2) + pow($b2, 2));
  $avg_cp = ($c1p + $c2p) / 2;

  $h1p = rad2deg(atan2($b1, $a1p));
  if ($h1p < 0) {
    $h1p += 360;
  }
  $h2p = rad2deg(atan2($b2, $a2p));
  if ($h2p < 0) {
    $h2p += 360;
  }
  if (abs($h1p - $h2p) > 180) {
    $avg_hp = ($h1p + $h2p + 360) / 2;
  }
  else {
    $avg_hp = ($h1p + $h2p) / 2;
  }

  /**
   * 2. Calculate delta_Lp, delta_cp, delta_hp.
   */
  $delta_Lp = $L2 - $L1;

  $delta_cp = $c2p - $c1p;

  $delta_hp = $h2p - $h1p;
  if (abs($delta_hp) > 180) {
    if ($h2p <= $h1p) {
      $delta_hp += 360;
    }
    else {
      $delta_hp -= 360;
    }
  }
  $delta_hp = 2 * sqrt($c1p * $c2p) * sin(deg2rad($delta_hp) / 2);

  /**
   * 3. Calculate CIEDE2000 Delta-E value.
   */
  $t = 1 - 0.17 * cos(deg2rad($avg_hp - 30)) + 0.24 * cos(deg2rad(2 * $avg_hp)) + 0.32 * cos(deg2rad(3 * $avg_hp + 6)) - 0.2 * cos(deg2rad(4 * $avg_hp - 63));
  $delta_ro = 30 * exp(-(pow(($avg_hp - 275) / 25, 2)));
  $r_c = 2 * sqrt(pow($avg_cp, 7) / (pow($avg_cp, 7) + pow(25, 7)));
  $s_l = 1 + ((0.015 * pow($avg_Lp - 50, 2)) / sqrt(20 + pow($avg_Lp - 50, 2)));
  $s_c = 1 + 0.045 * $avg_cp;
  $s_h = 1 + 0.015 * $avg_cp * $t;
  $r_t = -$r_c * sin(2 * deg2rad($delta_ro));

  // Finding the true delta_e value would require finding the square root.
  // For this application, this unnecessary since we are only concerned with relative differences between the palette colors.
  $delta_e = pow($delta_Lp / ($s_l * $kl), 2) + pow($delta_cp / ($s_c * $kc), 2) + pow($delta_hp / ($s_h * $kh), 2) + $r_t * ($delta_cp / ($s_c * $kc)) * ($delta_hp / ($s_h * $kh));
  return $delta_e;
}


/***********************************************
 * Color Tagger Field Widget Settings.
 ***********************************************/

/**
 * Implements hook_field_widget_info().
 */
function color_tagger_field_widget_info() {
  return array(
    'color_tagger_widget' => array(
      'label' => t('Color Tagger Widget'),
      'description' => t('Field content is calculated from linked image field in the same content type'),
      'field types' => array('taxonomy_term_reference'),
      'settings' => array(
        'image_field' => '',
        'hex_code_field' => '',
        'blacklist_colors' => '',
        'autocomplete_path' => 'taxonomy/autocomplete',
        'size' => 60,
      ),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_form().
 */
function color_tagger_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $tags = array();
  foreach ($items as $item) {
    $tags[$item['tid']] = isset($item['taxonomy_term']) ? $item['taxonomy_term'] : taxonomy_term_load($item['tid']);
  }

  $element += array(
    '#tree' => TRUE,
    '#type' => 'textfield',
    '#default_value' => taxonomy_implode_tags($tags),
    '#autocomplete_path' => $instance['widget']['settings']['autocomplete_path'] . '/' . $field['field_name'],
    '#size' => $instance['widget']['settings']['size'],
    '#maxlength' => 1024,
    '#element_validate' => array('taxonomy_autocomplete_validate'),
    '#states' => array(
      'disabled' => array(
        '.field-widget-color-tagger-widget :input.form-checkbox' => array('value' => '0'),
      ),
    ),
  );

  $element['#description'] = t('Leave blank to auto tag taxonomy values based on colors in linked image.');

  return $element;
}

/**
 * Without this validation hook, the values from color_tagger_field_widget_form are not sent through.
 */
function color_tagger_field_widget_validate($element, &$form_state) {
  // DO NOT REMOVE.
}

/**
 * Implements hook_widget_settings().
 */
function color_tagger_field_widget_settings_form($field, $instance) {
  $widget = $instance['widget'];
  $form = array();
  if ($widget['type'] == 'color_tagger_widget') {
    $image_fields = _color_tagger_get_image_fields_from_bundle($instance['entity_type'], $instance['bundle']);
    $default_image_value = _color_tagger_get_image_field_default_value($widget, $image_fields);
    $form['image_field'] = array(
      '#type' => 'radios',
      '#title' => t('Image Field'),
      '#description' => t('Select the image field on this entity that should be processed to find matching colors.'),
      '#options' => $image_fields,
      '#default_value' => $default_image_value,
      '#element_validate' => array('_color_tagger_field_widget_image_field_validate'),
    );
    $hex_code_fields = _color_tagger_get_hex_code_fields_from_taxonomy($field['settings']['allowed_values'][0]['vocabulary']);
    $default_hex_code_value = _color_tagger_get_hex_code_field_default_value($widget, $hex_code_fields);
    $form['hex_code_field'] = array(
      '#type' => 'radios',
      '#title' => t('Hex Code Field'),
      '#description' => t('Select the field on the taxonomy term that contains the hexadecimal code values for the colors.'),
      '#options' => $hex_code_fields,
      '#default_value' => $default_hex_code_value,
      '#element_validate' => array('_color_tagger_field_widget_hex_code_field_validate'),
    );

    // Terms stored as TIDs. Load term objects to fill textfield with term names.
    $blacklist_colors = $widget['settings']['blacklist_colors'];
    $blacklist_colors = taxonomy_term_load_multiple($blacklist_colors);
    $form['blacklist_colors'] = array(
      '#type' => 'textfield',
      '#title' => t('Excluded colors'),
      '#description' => t("Enter the term names of any colors you want the color tagger to ignore."),
      '#default_value' => taxonomy_implode_tags($blacklist_colors),
      '#autocomplete_path' => 'taxonomy/autocomplete/' . $instance['field_name'],
      '#size' => 60,
      '#maxlength' => 1024,
      '#element_validate' => array('_color_tagger_field_widget_blacklist_validate'),
    );

  }
  return $form;
}

/**
 * Retrieve all image fields of the same content type (bundle).
 */
function _color_tagger_get_image_fields_from_bundle($entity_type, $bundle_name) {
  $instances = field_info_instances($entity_type, $bundle_name);
  $result = array();
  foreach ($instances as $field_name => $field_value) {
    if (is_array($field_value) && is_array($field_value['widget']) && $field_value['widget']['type'] == 'image_image') {
      $result[$field_name] = $field_value['label'] . " (" . $field_name . ")";
    }
  }
  if (empty($result)) {
    drupal_set_message(t('No valid image fields found on entity.'), 'error');
  }
  return $result;
}

/**
 * Calculate default value for image field setting of color tagger widget.
 */
function _color_tagger_get_image_field_default_value($widget, $image_fields) {
  $result = $widget['settings']['image_field'];
  if (empty($result)) {
    $temp = array_keys($image_fields);
    if (!empty($temp) && is_array($temp)) {
      $result = $temp[0];
    }
  }
  return $result;
}

/**
 * Retrieve all fields of the color tagger taxonomy term.
 */
function _color_tagger_get_hex_code_fields_from_taxonomy($vocabulary_name) {
  $instances = field_info_instances('taxonomy_term', $vocabulary_name);
  $result = array();
  foreach ($instances as $field_name => $field_value) {
    if (is_array($field_value) && is_array($field_value['widget'])) {
      $result[$field_name] = $field_value['label'] . " (" . $field_name . ")";
    }
  }
  if (empty($result)) {
    drupal_set_message(t('No valid hex code fields found on taxonomy term.'), 'error');
  }
  return $result;
}

/**
 * Calculate default value for hex code field setting of color tagger widget.
 */
function _color_tagger_get_hex_code_field_default_value($widget, $hex_code_fields) {
  $result = $widget['settings']['hex_code_field'];
  if (empty($result)) {
    $temp = array_keys($hex_code_fields);
    if (!empty($temp) && is_array($temp)) {
      $result = $temp[0];
    }
  }
  return $result;
}

/**
 * Form API #element_validate callback for image_field.
 */
function _color_tagger_field_widget_image_field_validate($element, &$form_state) {
  $image_field_settings = $form_state['values']['instance']['widget']['settings']['image_field'];
  if (empty($image_field_settings)) {
    form_error($element, t('You must choose an image field. If none exist, please add an image field to the entity.'));
  }
}

/**
 * Form API #element_validate callback for hex_code_field.
 */
function _color_tagger_field_widget_hex_code_field_validate($element, &$form_state) {
  $image_field_settings = $form_state['values']['instance']['widget']['settings']['hex_code_field'];
  if (empty($image_field_settings)) {
    form_error($element, t('You must choose an hex code field. If none exist, please add a field to the taxonomy term to store the hex code values.'));
  }
}

/**
 * Form API #element_validate callback for blacklist_colors.
 */
function _color_tagger_field_widget_blacklist_validate($element, &$form_state) {
  // Validate that names entered are valid term names.
  if ($tags = $element['#value']) {
    $vocabulary = taxonomy_vocabulary_machine_name_load($form_state['values']['field']['settings']['allowed_values'][0]['vocabulary']);
    $terms = taxonomy_get_tree($vocabulary->vid);
    $typed_terms = drupal_explode_tags($tags);

    // Store blacklist colors terms as TIDs instead of Term Names.
    $blacklist_colors_tids = array();
    foreach ($terms as $term) {
      if (in_array($term->name, $typed_terms)) {
        $blacklist_colors_tids[] = $term->tid;
      }
    }
    form_set_value($element, $blacklist_colors_tids, $form_state);
  }
}

/**
 * Implements hook_field_widget_error().
 */
function color_tagger_field_widget_error($element, $error, $form, &$form_state) {
  form_error($element, $error['message']);
}


/***********************************
 * Color Tagger Settings.
 ***********************************/

/**
 * Get the settings values from color_tagger table in the database.
 */
function color_tagger_get_record($setting_name, $default_value) {
  try {
    $query = db_select('color_tagger')
      ->fields('color_tagger', array('value'))
      ->condition('setting_name', $setting_name);
    $result = $query->execute()->fetchField();
    if ($result) {
      return $result;
    }
    else {
      return $default_value;
    }
  }
  catch (Exception $e) {
    drupal_set_message($e->getMessage(), 'error');
    return $default_value;
  }
}

/**
 * Saves the settings values to the color_tagger table in the database.
 */
function color_tagger_set_record($setting_name, $value) {
  try {
    $query = db_merge('color_tagger')
      ->key(array('setting_name' => $setting_name))
      ->fields(array(
        'setting_name' => $setting_name,
        'value' => $value,
      ));
    $query->execute();
  }
  catch (Exception $e) {
    throw $e;
  }
}
