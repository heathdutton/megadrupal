<?php

/**
 * @file
 * Commerce Estonian Payments.
 */

/**
 * Debug POST parameters to/from Estcard into Watchdog log
 */
define('ESTCARD_DEBUG', FALSE);

/**
 * Implements hook_commerce_payment_method_info().
 *
 * This function provides Drupal Commerce information
 * about Estcard payment method.
 *
 * @see hook_commerce_payment_method_info()
 *
 * @return array
 *   Info about the payment method.
 */
function commerce_estcard_commerce_payment_method_info() {

  $txt = t('Credit card payment', array(), array('context' => 'estcard'));
  $txt = check_plain($txt);
  $img = ''
    . base_path()
    . drupal_get_path('module', 'commerce_estcard')
    . '/cards.png'
  ;
  $img = "<img src=\"$img\" title=\"$txt\" alt=\"$txt\" />";
  $title = t(
    'Estcard (Nets Estonia)',
    array(),
    array('context' => 'estcard')
  );
  $desc = t(
    'Payment method for Estcard (Nets Estonia)',
    array(),
    array('context' => 'estcard')
  );

  return array(
    'estcard' => array(
      'title' => $title,
      'display_title' => $img,
      'short_title' => $title,
      'description' => $desc,
      'terminal' => FALSE,
      'offsite' => TRUE,
      'offsite_autoredirect' => FALSE,
    ),
  );

}



/**
 * Estcard Settings form.
 *
 * Here the Merchant enters details
 * necessary for communication with Estcard.
 * Specifically following fields:
 * - estcard_url: Estcard URL
 * - merchant_id: Merchant ID
 * - private_key: Private Key
 * - cert: Certificate
 *
 * @param array $settings
 *   Payment methods settings data
 *
 * @return array
 *   Settings form structure
 *
 * @todo Add checks for setting input
 */
function estcard_settings_form($settings = NULL) {

  $form = array();
  $settings = (array) $settings + array(
    'estcard_url' => '',
    'merchant_id' => '',
    'private_key' => '',
    'cert' => '',
  );
  $form['estcard_url'] = array(
    '#type' => 'textfield',
    '#title' => t('Estcard URL'),
    '#default_value' => $settings['estcard_url'],
  );
  $form['merchant_id'] = array(
    '#type' => 'textfield',
    '#title' => t('Merchant ID'),
    '#default_value' => $settings['merchant_id'],
  );
  $form['private_key'] = array(
    '#type' => 'textarea',
    '#title' => t('Private key'),
    '#default_value' => $settings['private_key'],
  );
  $form['cert'] = array(
    '#type' => 'textarea',
    '#title' => t('Certificate'),
    '#default_value' => $settings['cert'],
  );

  return $form;

}



/**
 * Form constructor for Estcard redirect form.
 *
 * Create form with 'hidden' parameters to be sent to Estcard
 * Then Estcard takes over.
 * This function returns FALSE if private key is invalid.
 *
 * @see commerce_estcard_commerce_payment_method_info()
 * @see estcard_redirect_form_validate()
 *
 * @param object $order
 *   Commerce order to be paid
 *
 * @param array $payment_method
 *   Method settings and details
 */
function estcard_redirect_form($form, &$form_state, $order, $payment_method) {

  // Get authorization form.
  // User will be provided with transaction authorization form.
  $action = 'gaf';

  // The protocol version (use 002 or 004)
  $ver = 4;

  // Merchant/user id in system, must be present with all operations.
  $id = $payment_method['settings']['merchant_id'];

  // Create unique transaction for ecuno which must be unique.
  // In addition this transaction will be finalised duting validate process.
  $wrapper = entity_metadata_wrapper('commerce_order', $order);
  $transaction = commerce_payment_transaction_new(
    $payment_method['method_id'], $order->order_id
  );
  $transaction->instance_id = $payment_method['instance_id'];
  $currency = $wrapper->commerce_order_total->currency_code->value();
  $transaction->currency_code = $currency;
  commerce_payment_transaction_save($transaction);

  // Merchant electronic order system unique transaction id
  // for e-commerce transaction.
  // ecuno must be more than 100000
  $ecuno = 100000 + $transaction->transaction_id;

  // Transaction amount provided by merchant
  // in minor currency units without decimals.
  $eamount = $wrapper->commerce_order_total->amount->value();

  // Transaction currency name (USD, EUR, EEK etc)
  $cur = $wrapper->commerce_order_total->currency_code->value();

  // The transaction date and time (timestamp)
  // YYYYMMDDHHmmss
  $datetime = date('YmdHis');

  // Optional. Specifies the interface language et – estonian, en - english
  // et, en
  $lang = $GLOBALS['language']->language;
  $lang = in_array($lang, array('et', 'en'))
    ? $lang
    : 'en'
  ;

  // Applicable for version 004.
  // The character encoding used to encode parameters
  // String up to ..16 UTF-8, ISO-8859-1
  $charEncoding = 'UTF-8';

  // The URL to send (POST) the payment confirmation at merchant shop.
  // Applicable for version 004
  $feedBackUrl = url(''
    . 'checkout/'
    . $order->order_id
    . '/payment/return/'
    . $order->data['payment_redirect_key'],
    array('absolute' => TRUE)
  );

  // Delivery method.
  // Applicable for version 004.
  // Values:
  // * S – Electronic delivery
  // * T – Physical delivery
  $delivery = 'S';

  // Calculate the message mac signature

  $data = ''
    . mb_sprintf('%03d', $ver)
    . mb_sprintf('%-10s', $id)
    . mb_sprintf('%012d', $ecuno)
    . mb_sprintf('%012d', $eamount)
    . mb_sprintf('%s', $cur)
    . mb_sprintf('%s', $datetime)
    . mb_sprintf('%-128s', $feedBackUrl)
    . mb_sprintF('%s', $delivery)
  ;

  $key = $payment_method['settings']['private_key'];
  $key = openssl_pkey_get_private($key);

  if ($key === FALSE) {
    watchdog(
      'estcard',
      'Failed to get private key.',
      array(),
      WATCHDOG_ERROR
    );
    drupal_set_message(t(
      'Failed to initiate payment. Incident logged.',
      array(),
      array('context' => 'estcard')
    ), 'error');
    return FALSE;
  }

  if (!openssl_sign($data, $signature, $key)) {
    watchdog(
      'estcard',
      'Failed to sign mac with private key.',
      array(),
      WATCHDOG_ERROR
    );
    drupal_set_message(t(
      'Failed to initiate payment. Incident logged.',
      array(),
      array('context' => 'estcard')
    ), 'error');
    return FALSE;
  }

  $mac = bin2hex($signature);

  openssl_free_key($key);


  // create form with hidden values to post to Estcard

  $form = array(
    'action' => $action,
    'ver' => $ver,
    'id' => $id,
    'ecuno' => $ecuno,
    'eamount' => $eamount,
    'cur' => $cur,
    'datetime' => $datetime,
    'mac' => $mac,
    'lang' => $lang,
    'charEncoding' => $charEncoding,
    'feedBackUrl' => $feedBackUrl,
    'delivery' => $delivery,
  );

  if (ESTCARD_DEBUG) {
    watchdog(
      'estcard',
      "To Estcard:<br/><pre>@data</pre>",
      array('@data' => print_r($form, TRUE)),
      WATCHDOG_DEBUG
    );
  }

  foreach ($form as $key => $value) {
    $form[$key] = array(
      '#type' => 'hidden',
      '#value' => $value,
    );
  }

  $merchant_url = $payment_method['settings']['estcard_url'];
  $form['#action'] = url($merchant_url);
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Submit Order', array(), array('context' => 'estcard')),
  );

  return $form;
}

/**
 * Helper function for error checking.
 *
 * Checks returning POST parameters.
 *
 * @see estcard_redirect_form_validate()
 *
 * @param bool $condition
 *   - TRUE: Write error message into $error
 *   - FALSE: Do nothing
 *
 * @param string $var
 *   A variable name. Same as key in $_POST array.
 *
 * @param string &$error
 *   If $condition is true then construct error message into $error
 *   based on $var and $_POST[]
 */
function estcard_errchk( $condition, $var, &$error ) {
  if (!$condition) {
    return;
  }
  $error = t(
    'Invalid "%var" = @value',
    array( '%var' => $var, '@value' => $_POST[$var] ),
    array( 'context' => 'estcard' )
  );
}

/**
 * Implements hook_redirect_form_validate().
 *
 * Validate and make payment for Estcard.
 * Buyer has finished with Estcard, Estcard comes back to us.
 *
 * @see commerce_estcard_commerce_payment_method_info()
 * @see estcard_redirect_form()
 *
 * @param object $order
 *   Commerce order to be paid
 *
 * @param array $payment_method
 *   Method settings and details
 *
 * @return string|false
 *   - Success: Affirmative text.
 *   - Failure: FALSE.
 */
function estcard_redirect_form_validate($order, $payment_method) {

  if (ESTCARD_DEBUG) {
    watchdog(
      'estcard',
      "From Estcard:<br/><pre>@data</pre>",
      array('@data' => print_r($_POST, TRUE)),
      WATCHDOG_DEBUG
    );
  }

  // Signature verification

  $key = $payment_method['settings']['cert'];
  $key = openssl_pkey_get_public($key);
  if ($key === FALSE) {
    watchdog(
      'estcard',
      'Failed to get public key.',
      array(),
      WATCHDOG_ERROR
    );
    drupal_set_message(t(
      'Failed to verify payment. Incident logged.',
      array(),
      array('context' => 'estcard')
    ), 'error');
    return FALSE;
  }

  if (!empty($_POST)) {
    extract($_POST);
  }

  mb_internal_encoding('UTF-8');

  $data = ''
    . mb_sprintf("%03d", $_POST['ver'])
    . mb_sprintf("%-10s", $_POST['id'])
    . mb_sprintf("%012d", $_POST['ecuno'])
    . mb_sprintf("%06d", $_POST['receipt_no'])
    . mb_sprintf("%012d", $_POST['eamount'])
    . mb_sprintf("%s", $_POST['cur'])
    . mb_sprintf("%s", $_POST['respcode'])
    . mb_sprintf("%s", $_POST['datetime'])
    . mb_sprintf("%-40s", $_POST['msgdata'])
    . mb_sprintf("%-40s", $_POST['actiontext'])
  ;

  $mac = pack('H*', $mac);

  if (openssl_verify($data, $mac, $key) != 1) {
    watchdog(
      'estcard',
      'Failed to verify mac with public key.',
      array(),
      WATCHDOG_ERROR
    );
    drupal_set_message(t(
      'Failed verify the payment. Incident logged.',
      array(),
      array('context' => 'estcard')
    ), 'error');
    return FALSE;
  }

  openssl_free_key($key);


  // Verify POST'ed parameters

  $merchant_id = $payment_method['settings']['merchant_id'];

  $error = NULL;

  $var = 'action';
  estcard_errchk( $_POST[$var] != 'afb', $var, $error );

  $var = 'ver';
  estcard_errchk( $_POST[$var] != 4, $var, $error );

  $var = 'id';
  estcard_errchk( $_POST[$var] != $merchant_id, $var, $error );

  $var = 'receipt_no';
  estcard_errchk( $_POST[$var] == 0, $var, $error );

  $var = 'respcode';
  estcard_errchk( $_POST[$var] != '000', $var, $error );

  $var = 'actiontext';
  estcard_errchk( $_POST[$var] != 'OK, approved', $var, $error );

  $var = 'charEncoding';
  estcard_errchk( $_POST[$var] != 'UTF-8', $var, $error );


  // Prepare for Success or Failure

  $transaction_id = $_POST['ecuno'] - 100000; // Return order id.
  $transaction = commerce_payment_transaction_load($transaction_id);
  $wrapper = entity_metadata_wrapper('commerce_order', $order);


  // Failure

  if (!empty($error)) {

    $transaction->amount = 0;
    $transaction->remote_status = t(
      'Failure',
      array(),
      array('context' => 'estcard')
    );
    $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
    $transaction->message = $error;
    commerce_payment_transaction_save($transaction);

    $order->status = 'checkout_review';
    commerce_order_save($order);

    watchdog(
      'estcard',
      "Payment failed: !error",
      array('!error' => $error),
      WATCHDOG_INFO
    );
    drupal_set_message(t(
     'Payment failed. Incident logged.',
     array(),
     array('context' => 'estcard')
    ), 'error');

    $uri = commerce_checkout_order_uri($order);
    drupal_goto($uri);
    return FALSE;
  }

  // Success

  $amount = $wrapper->commerce_order_total->amount->value();
  $transaction->amount = $amount;
  $transaction->remote_status = t(
    'Success',
    array(),
    array('context' => 'estcard')
  );
  $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
  $transaction->message = 'Payment received at @date';
  $transaction->message_variables = array(
    '@date' => date('d-m-Y H:i:s', REQUEST_TIME)
  );
  commerce_payment_transaction_save($transaction);

  watchdog(
    'estcard',
    "Payment successful.",
    array(),
    WATCHDOG_INFO
  );


  return t(
    'Your payment completed successfully. Thank You!',
    array(),
    array('context' => 'estcard')
  );

}



/* Following code ripped from PHP site
 * http://php.net/manual/en/function.sprintf.php#89020
 */


/**
 * Wrapper for Multi-Byte sprintf()
 *
 * Ripped from PHP site
 * http://php.net/manual/en/function.sprintf.php#89020
 *
 * @see mb_vsprintf()
 * @see http://php.net/manual/en/function.sprintf.php
 *
 * @param string $format
 *   sprintf() format string
 *
 * @param ... ...
 *   Format arguments according to sprintf().
 *
 * @return string
 *   Multi-Byte formatted string
 */
function mb_sprintf($format) {
  $argv = func_get_args() ;
  array_shift($argv) ;
  return mb_vsprintf($format, $argv) ;
}

/**
 * Wrapper for Multi-Byte sprintf()
 *
 * Ripped from PHP site
 * http://php.net/manual/en/function.sprintf.php#89020
 *
 * Works with all encodings in format and arguments.
 * Supported: Sign, padding, alignment, width and precision.
 * Not supported: Argument swapping.
 *
 * @see mb_sprintf()
 *
 * @param string $format
 *   sprintf() format string
 *
 * @param array $argv
 *   Format arguments according to sprintf().
 *
 * @param string $encoding
 *   Charset of $format and $argv
 *
 * @return string
 *   Multi-Byte formatted string
 */
function mb_vsprintf($format, $argv, $encoding = NULL) {

  if (is_null($encoding)) {
    $encoding = mb_internal_encoding();
  }

  // Use UTF-8 in the format so we can use the u flag in preg_split
  $format = mb_convert_encoding($format, 'UTF-8', $encoding);

  $newformat = ""; // build a new format in UTF-8
  $newargv = array(); // unhandled args in unchanged encoding

  while ($format !== "") {

    // Split the format in two parts: $pre and $post by the first %-directive
    // We get also the matched groups
    $rx = "!\%(\+?)('.|[0 ]|)(-?)([1-9][0-9]*|)(\.[1-9][0-9]*|)([%a-zA-Z])!u";
    list ($pre, $sign, $filler, $align, $size, $precision, $type, $post) =
      preg_split($rx, $format, 2, PREG_SPLIT_DELIM_CAPTURE) ;

    $newformat .= mb_convert_encoding($pre, $encoding, 'UTF-8');

    if ($type == '') {
      // didn't match. do nothing. this is the last iteration.
    }
    elseif ($type == '%') {
      // an escaped %
      $newformat .= '%%';
    }
    elseif ($type == 's') {
      $arg = array_shift($argv);
      $arg = mb_convert_encoding($arg, 'UTF-8', $encoding);
      $padding_pre = '';
      $padding_post = '';

      // truncate $arg
      if ($precision !== '') {
        $precision = intval(substr($precision, 1));
        if ($precision > 0 && mb_strlen($arg, $encoding) > $precision) {
          $arg = mb_substr($precision, 0, $precision, $encoding);
        }
      }

      // define padding
      if ($size > 0) {
        $arglen = mb_strlen($arg, $encoding);
        if ($arglen < $size) {
          if ($filler === '') {
              $filler = ' ';
          }
          if ($align == '-') {
              $padding_post = str_repeat($filler, $size - $arglen);
          }
          else {
              $padding_pre = str_repeat($filler, $size - $arglen);
          }
        }
      }

      // escape % and pass it forward
      $newformat .= ''
        . $padding_pre
        . str_replace('%', '%%', $arg)
        . $padding_post
      ;
    }
    else {
      // another type, pass forward
      $newformat .= "%$sign$filler$align$size$precision$type";
      $newargv[] = array_shift($argv);
    }
    $format = strval($post);
  }
  // Convert new format back from UTF-8 to the original encoding
  $newformat = mb_convert_encoding($newformat, $encoding, 'UTF-8');
  return vsprintf($newformat, $newargv);
}
