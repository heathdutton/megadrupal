<?php
/**
 * @file
 * Imports Drupal Commerce Entities from an XLS file.
 *
 * Returns an XLS file highlighting success and failures.
 */

define('COMMERCE_XLS_IMPORT_DATA_ERROR', 0);
define('COMMERCE_XLS_IMPORT_DATA_SUCCESS', 1);
define('COMMERCE_XLS_IMPORT_DATA_WARNING', 2);
define('COMMERCE_XLS_IMPORT_DATA_NONE', 3);

/**
 * Implements hook_menu().
 *
 * Adds menu items to generate the headers or begin the commerce XLS import.
 */
function commerce_xls_import_menu() {
  $items = array();

  $items['admin/commerce/products/import_commerce'] = array(
    'title' => 'Commerce Import',
    'description' => 'Import commerce XLS or generate XLS headers form',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_xls_import_start'),
    'access arguments' => array('administer commerce import'),
    'file' => 'includes/commerce_xls_import.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/commerce/products/import_commerce/export'] = array(
    'title' => 'Commerce Export',
    'description' => 'Export products to XLS.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_xls_import_start'),
    'access arguments' => array('administer commerce import'),
    'file' => 'includes/commerce_xls_import.export.inc',
  );

  $items['admin/commerce/products/import_commerce/get_import_status'] = array(
    'title' => 'Commerce Import Status Update',
    'description' => 'Update the status of the current commerce xls import',
    'page callback' => 'commerce_xls_import_current_status',
    'access arguments' => array('administer commerce import'),
    'file' => NULL,
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function commerce_xls_import_permission() {
  return array(
    'administer commerce import' => array(
      'title' => t('Administer Commerce XLS Import'),
      'description' => t('Perform an XLS import'),
    ),
  );
}

/**
 * Implements hook_theme().
 */
function commerce_xls_import_theme() {
  return array(
    'commerce_xls_import_instructions' => array(
      'file' => 'includes/commerce_xls_import.theme.inc',
      'template' => 'templates/commerce_xls_import_instructions',
      'variables' => array(),
    ),
  );
}

/**
 * Implements hook_phpexcel_export().
 */
function commerce_xls_import_phpexcel_export($op, &$data, &$phpexcel, $options, $column = NULL, $row = NULL) {

  switch ($op) {
    case 'headers':
      break;

    case 'new sheet':
      $phpexcel->getActiveSheet()->getProtection()->setSheet(FALSE);
      $phpexcel->getActiveSheet()->getProtection()->setSort(FALSE);
      break;

    case 'data':
      break;

    case 'pre cell':
      break;

    case 'post cell':
      $style_array = array();
      if ($row > 1) {
        // Have to convert header from number to column title to match with our
        // error recording there must be a more elegant way to do this but I
        // can't seem to figure one out.
        $headers = commerce_xls_import_get_headers($phpexcel);
        if (CommerceXlsImportVariables::isImport() || CommerceXlsImportVariables::isValidate()) {

          $error_status = commerce_xls_import_get_column_status($row, $headers[$column]);
          if (!CommerceXlsImportVariables::rowTitleHasError($row)) {
            if ($error_status == COMMERCE_XLS_IMPORT_DATA_ERROR) {
              if ($headers[$column] == 'title') {
                CommerceXlsImportVariables::setRowTitleErrorStatus($row, TRUE);
              }
              $style_array = array(
                'fill' => array(
                  'type' => PHPExcel_Style_Fill::FILL_SOLID,
                  'startcolor' => array('argb' => '00FF9999'),
                ),
                'borders' => array(
                  'allborders' => array(
                    'style' => PHPExcel_Style_Border::BORDER_THIN,
                    'color' => array('argb' => '00DA4141'),
                  ),
                ),
              );
            }
            elseif ($error_status == COMMERCE_XLS_IMPORT_DATA_WARNING) {
              $style_array = array(
                'fill' => array(
                  'type' => PHPExcel_Style_Fill::FILL_SOLID,
                  'startcolor' => array('argb' => '00FFFF66'),
                ),
                'borders' => array(
                  'allborders' => array(
                    'style' => PHPExcel_Style_Border::BORDER_THIN,
                    'color' => array('argb' => '00CCCC00'),
                  ),
                ),
              );
            }
            elseif ($error_status == COMMERCE_XLS_IMPORT_DATA_SUCCESS) {
              if ($headers[$column] == 'title') {
                CommerceXlsImportVariables::setRowTitleErrorStatus($row, FALSE);
              }
              $style_array = array(
                'fill' => array(
                  'type' => PHPExcel_Style_Fill::FILL_SOLID,
                  'startcolor' => array('argb' => '0078FAA3'),
                ),
                'borders' => array(
                  'allborders' => array(
                    'style' => PHPExcel_Style_Border::BORDER_THIN,
                    'color' => array('argb' => '0000994C'),
                  ),
                ),
              );
            }
            else {
              $style_array = array(
                'fill' => array(
                  'type' => PHPExcel_Style_Fill::FILL_NONE,
                ),
                'borders' => array(
                  'allborders' => array(
                    'style' => PHPExcel_Style_Border::BORDER_NONE,
                  ),
                ),
              );
            }
          }
          else {
            $style_array = array(
              'fill' => array(
                'type' => PHPExcel_Style_Fill::FILL_SOLID,
                'startcolor' => array('argb' => '00FFFF66'),
              ),
              'borders' => array(
                'allborders' => array(
                  'style' => PHPExcel_Style_Border::BORDER_THIN,
                  'color' => array('argb' => '00CCCC00'),
                ),
              ),
            );
          }
        }
        if (CommerceXlsImportVariables::isImport() && $GLOBALS['nid_column'] != $column) {
          $phpexcel->getStyleByColumnAndRow($column, $row)->getProtection()->setLocked(PHPExcel_Style_Protection::PROTECTION_UNPROTECTED);
        }
        else {
          $phpexcel->getStyleByColumnAndRow($column, $row)->getProtection()->setLocked(PHPExcel_Style_Protection::PROTECTION_PROTECTED);
        }

        $phpexcel->getStyleByColumnAndRow($column, $row)->applyFromArray($style_array);

      }
      else {
        // Header row - mark for variation or parent.
        $owner = commerce_xls_import_get_field_owner($data);

        // Mark nid row for locking.
        if ($data == 'nid') {
          $GLOBALS['nid_column'] = $column;
        }

        if ($owner == 'variation') {
          $style_array = array(
            'fill' => array(
              'type' => PHPExcel_Style_Fill::FILL_SOLID,
              'startcolor' => array('argb' => '00fac090'),
            ),
            'borders' => array(
              'allborders' => array(
                'style' => PHPExcel_Style_Border::BORDER_THIN,
                'color' => array('argb' => '00fac090'),
              ),
            ),
          );
        }
        elseif ($owner == 'parent') {
          $style_array = array(
            'fill' => array(
              'type' => PHPExcel_Style_Fill::FILL_SOLID,
              'startcolor' => array('argb' => '008db4e3'),
            ),
            'borders' => array(
              'allborders' => array(
                'style' => PHPExcel_Style_Border::BORDER_THIN,
                'color' => array('argb' => '008db4e3'),
              ),
            ),
          );
        }
        elseif ($owner == 'both') {
          $style_array = array(
            'fill' => array(
              'type' => PHPExcel_Style_Fill::FILL_SOLID,
              'startcolor' => array('argb' => '0024ABB7'),
            ),
            'borders' => array(
              'allborders' => array(
                'style' => PHPExcel_Style_Border::BORDER_THIN,
                'color' => array('argb' => '0024ABB7'),
              ),
            ),
          );
        }
        $phpexcel->getStyleByColumnAndRow($column, $row)->getProtection()->setLocked(PHPExcel_Style_Protection::PROTECTION_PROTECTED);
        $phpexcel->getStyleByColumnAndRow($column, $row)->applyFromArray($style_array);
      }
      break;
  }
}

/**
 * Determines whether an import is currently running in the background.
 *
 * Returns True if one is running, otherwise false.
 */
function commerce_xls_import_is_running() {
  $result = db_select('background_process', 'bp')
    ->fields('bp', array('callback', 'exec_status'))
    ->condition('callback', '%' . db_like('commerce_xls_import_import') . '%', 'LIKE')
    ->execute();

  if ($result->rowCount()) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Stops current import.
 */
function commerce_xls_import_stop_import() {
  // Set all updates to stopped status.
  $result = db_update('commerce_xls_import')
    ->fields(array(
      'status' => 'stopped',
    ))
    ->execute();

  if ($result) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Check to see if current import has been stopped.
 */
function commerce_xls_import_stopped() {
  $result = db_select('commerce_xls_import', 'i')
    ->fields('i', array('status'))
    ->execute()
    ->fetchAssoc();

  if ($result['status'] == 'stopped') {
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Main function for the drupal commerce XLS export.
 */
function commerce_xls_import_export($op, $product_info = NULL, $product_type = NULL, $nids = FALSE) {
  module_load_include('inc', 'phpexcel');
  module_load_include('inc', 'commerce_xls_import', 'includes/commerce_xls_import.errors');
  watchdog('aa', print_r($product_info, TRUE));

  // NOTE: This is required because the phpexcel module gives strict warnings
  // with its export functionality.
  error_reporting(E_ALL ^ E_STRICT);

  $data = array('Products' => array());
  $headers = commerce_xls_import_generate_headers($nids, $product_type);
  $options = array('format' => 'xls', 'title' => t('Product Import Template'));

  if ($product_info == NULL || $op == 'template') {
    $data['Products'][] = array();
  }
  else {
    $count = 1;
    foreach ($product_info[0] as $row) {
      $count++;
      $new_data_array = array();

      foreach ($row as $new) {
        $new_data_array[] = $new;
      }

      if (CommerceXlsImportVariables::isImport() && ($nids || commerce_xls_import_get_row_error($count))) {
        $array_pos = count($new_data_array) - 1;
        if ($headers['Products'][$array_pos] == 'nid') {
          $new_data_array[$array_pos] = $row['nid'];
        }
      }
      $data['Products'][] = $new_data_array;
    }
  }

  switch ($op) {
    case 'export':
      if (!commerce_xls_import_export_xls($product_type, $options, $headers, $data)) {
        // If error, refresh page to display error.
        drupal_goto("admin/commerce/products/import_commerce");
      }
      break;

    case 'errors':
      if (!commerce_xls_import_generate_errors_xls($options, $headers, $data)) {
        // If error, refresh page to display error.
        drupal_goto("admin/commerce/products/import_commerce");
      }
      break;

    case 'template':
      if (!commerce_xls_import_generate_template_xls($product_type, $headers, $data, $options)) {
        // If error, refresh page to display error.
        drupal_goto("admin/commerce/products/import_commerce");
      }

      break;
  }
}

/**
 * Generate template xls.
 *
 * @return bool
 *    Returns TRUE upon success and False upon failure.
 */
function commerce_xls_import_generate_template_xls($product_type, $headers, $data, $options) {
  $filename = $product_type . "_template.xls";
  $path = file_build_uri($filename);

  if (file_exists($path)) {
    file_unmanaged_delete($path);
  }
  $result = phpexcel_export($headers, $data, drupal_realpath($path), $options);

  if ($result == PHPEXCEL_SUCCESS) {
    header('Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    header('Content-Disposition: attachment;filename="' . $filename . '"');
    header('Cache-Control: max-age=0');

    return TRUE;
  }
  else {
    drupal_set_message(t('PHPExcel error @result', array('@result' => $result)), 'error');
    drupal_set_message(t('There was an error generating the template. If this persists, contact the system administrator'), 'error');

    return FALSE;
  }
}

/**
 * Generate product_import_results.xls.
 *
 * @return bool
 *    Returns TRUE upon success and False upon failure.
 */
function commerce_xls_import_generate_errors_xls($options, $headers, $data) {
  $filename = "product_import_results.xls";
  $path = file_build_uri($filename);
  $options['errors'] = TRUE;

  if (file_exists($path)) {
    file_unmanaged_delete($path);
  }
  $result = phpexcel_export($headers, $data, drupal_realpath($path), $options);

  if ($result == PHPEXCEL_SUCCESS) {
    header('Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    header('Content-Disposition: attachment;filename="' . $filename . '"');
    header('Cache-Control: max-age=0');

    return TRUE;
  }
  else {
    drupal_set_message(t('PHPExcel error @result', array('@result' => $result)), 'error');
    drupal_set_message(t('There was an error generating the import result document. Please try again. If this problem persists, contact the system administrator'), 'error');

    return FALSE;
  }
}

/**
 * Generate product_export.xls.
 *
 * @return bool
 *    Returns TRUE upon success and False upon failure.
 */
function commerce_xls_import_export_xls($product_type, $options, $headers, $data) {
  $filename = $product_type . "_export.xls";
  $path = file_build_uri($filename);

  if (file_exists($path)) {
    file_unmanaged_delete($path);
  }
  $result = phpexcel_export($headers, $data, drupal_realpath($path), $options);

  if ($result == PHPEXCEL_SUCCESS) {
    header('Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    header('Content-Disposition: attachment;filename="' . $filename . '"');
    header('Cache-Control: max-age=0');

    return TRUE;
  }
  else {
    drupal_set_message(t('PHPExcel error @result', array('@result' => $result)), 'error');
    drupal_set_message(t('There was an error generating the import result document. Please try again. If this problem persists, contact the system administrator'), 'error');

    return FALSE;
  }
}

/**
 * Main function for the drupal commerce XLS import.
 *
 * Extracts product_images.zip, then imports XLS file. If the XLS import is
 * successful the results will then be processed and the import will be started.
 *
 * @param null|array $file
 *   The XLS file info array containing product data to be imported.
 * @param bool $validate
 *   If true, don't create products. Otherwise create products.
 */
function commerce_xls_import_import(array $file = NULL, $validate = FALSE) {
  module_load_include('inc', 'phpexcel', 'phpexcel');
  module_load_include('inc', 'commerce_xls_import', 'includes/commerce_xls_import.errors');

  CommerceXlsImportVariables::setValidate($validate);
  variable_set('commerce_xls_import_error_count', 0);

  // Get the product type.
  $product_type = $file['product_type'];

  // Extract product images.
  $images_info = commerce_xls_import_extract_zip();

  // Import XLS.
  $result = phpexcel_import($file['uri']);

  $nids = array();

  // If an array, import function was successful.
  if (is_array($result)) {
    if (count($result) > 0) {
      $row = 1;
      foreach ($result as $sheet) {
        foreach ($sheet as $product) {
          if (commerce_xls_import_stopped()) {
            break;
          }
          $row++;

          // Set the import completion status.
          variable_set('commerce_xls_import_import_count_status', array('completed' => $row - 1, 'total' => count($sheet)));

          if ($product['title'] == NULL) {
            commerce_xls_import_set_error($row, 'title', "Product doesn't have a title");

            $has_errors = TRUE;
          }
          else {
            $has_errors = FALSE;
          }

          if (!$has_errors) {
            $values = commerce_xls_import_get_product_values($product, $product_type);
            if (!isset($product['nid']) || $product['nid'] == NULL) {
              // If nid is set it is a line from a resubmitted results.xls.
              $entity_info = commerce_xls_import_set_entity_values($product);
              $nid = commerce_xls_import_create_product($row, $values, $entity_info, $product_type, $images_info);
            }
            else {
              // If nid isn't null ignore it as it was already imported.
              $nid = $product['nid'];
              commerce_xls_import_set_error($row, 'nid', 'nis was already imported');
            }
          }
          else {
            $nid = NULL;
          }
          $nids[$row - 2] = $nid;
        }
      }
    }

    // Add NIDs to each product.
    if (CommerceXlsImportVariables::isImport()) {
      $count = 0;
      foreach ($nids as $nid) {
        $result[0][$count]['nid'] = $nid;
        $count++;
      }
    }

    $import_counts = variable_get('commerce_xls_import_import_count_status', '');
    variable_set('commerce_xls_import_last_import', array(
      'completed' => time(),
      'row' => $import_counts['completed'],
      'total' => $import_counts['total'],
    ));
    variable_del('commerce_xls_import_import_count_status');
    commerce_xls_import_export('errors', $result, $product_type, TRUE);
  }
  else {
    drupal_set_message(t("There was an error with the import, please try again. If this problem persists contact the system administrator"), "error");
  }
}

/**
 * Sets entity values.
 *
 * @param array $product
 *   The product array the entity is being created from.
 *
 * @return array
 *   An array containing all of the set entity values for the product.
 */
function commerce_xls_import_set_entity_values(array $product) {
  global $user;

  $entity_info = array(
    'status' => isset($product['status']) ? $product['status'] : NULL,
    'uid' => $user->uid,
    'sku' => isset($product['sku']) ? $product['sku'] : NULL,
    'title' => isset($product['title']) ? $product['title'] : NULL,
    'variation_title' => isset($product['variation_title']) ? $product['variation_title'] : (isset($product['title']) ? $product['title'] : NULL),
    'language' => isset($product['language']) ? $product['language'] : NULL,
    'categories' => isset($product['field_product_category']) ? $product['field_product_category'] : NULL,
    'body' => isset($product['body']) ? $product['body'] : NULL,
    'nid' => isset($product['nid']) ? $product['nid'] : NULL,
  );

  return $entity_info;
}

/**
 * Gets an array containing the set values of the product.
 *
 * Gets the field data from the product type and then creates an array that
 * contains the set data from the given product.
 *
 * @param array $product
 *   Product to be imported.
 * @param string $product_type
 *   The product type.
 *
 * @return array
 *   Returns the set values that correspond to the possible fields of the
 *   product type.
 */
function commerce_xls_import_get_product_values(array $product, $product_type) {
  $values = array(
    'currency_code' => commerce_default_currency(),
  );

  $possible_fields = commerce_xls_import_get_possible_fields($product_type);

  foreach ($possible_fields as $field) {
    if (isset($product[$field])) {
      $values[$field] = $product[$field];
    }
  }

  return $values;
}

/**
 * Checks to see if the language table exists.
 *
 * If it does then it checks the languages table for a corresponding language.
 *
 * Returns the language if a match is found, false if the table does not
 * exist or no language match found.
 */
function commerce_xls_import_validate_languages($language) {
  if (db_table_exists('languages')) {
    $result = db_select('languages', 'l')
      ->fields('l', array('language', 'name'))
      ->execute();
    while ($record = $result->fetchAssoc()) {
      if ((strtolower($record['language']) == strtolower($language)) || strtolower($language) == strtolower($record['name'])) {
        return $record['language'];
      }
    }
  }

  return FALSE;
}

/**
 * Validates the product by title and returns nid if it exists.
 *
 * If one or no products with the same name exists, return nid. Otherwise
 * return false.
 *
 * @return bool
 *    True if product is valid.
 */
function commerce_xls_import_validate_product($row, $entity_info) {
  $nid = NULL;

  if (!isset($entity_info['nid']) || $entity_info['nid'] == NULL) {
    $nid = commerce_xls_import_search_for_product($entity_info['title']);
  }
  else {
    $nid = $entity_info['nid'];
  }

  // Validate nid.
  if (is_array($nid)) {
    // Multiple possible nid's mark warning and do not proceed any further.
    commerce_xls_import_set_error($row, 'nid', COMMERCE_XLS_IMPORT_DATA_WARNING, "Multiple product matches found");

    return FALSE;
  }

  return $nid;
}

/**
 * Checks image validity and sets it in the form_state if valid.
 */
function commerce_xls_import_check_set_images($row, $field, &$form_state, $image_info, $key, $language) {
  // it's an image, check whether multiple uploads.
  $filenames = array($field);
  if (strpos($field, ',')) {
    $filenames = explode(',', $field);
  }

  foreach ($filenames as $filename) {
    if ($filename != "") {
      if (pathinfo($filename, PATHINFO_EXTENSION) == "") {
        if (commerce_xls_import_get_error($row, $key) == '') {
          commerce_xls_import_set_error($row, $key, "Entered image is missing extension");
        }
      }
      else {
        $file = file_load($image_info[trim($filename)]);
        if ($file !== FALSE) {
          $form_state['values'][$key][$language] = get_object_vars($file);
        }
        else {
          if (commerce_xls_import_get_error($row, $key) == '') {
            commerce_xls_import_set_error($row, $key, "File could not be loaded");
          }
        }
      }
    }
  }
}

/**
 * Validates the product's sku.
 *
 * If the product does not have a sku, return false. If the sku is not a valid
 * commerce sku, return false. If the sku is already in use, return false.
 * Otherwise, return true.
 *
 * @param string $sku
 *   The sku of the variation being created.
 *
 * @return bool
 *   True if valid.
 */
function commerce_xls_import_validate_sku($row, $sku) {

  if ($sku == NULL) {
    // Sku doesn't exist, mark this product as an error.
    commerce_xls_import_set_error($row, 'sku', "sku required");
    return FALSE;
  }

  // Validate sku. The "a" is added because commerce_product_validate_sku()
  // returns a false positive if the first character of $sku is a ','
  $sku_is_valid = commerce_product_validate_sku("a" . $sku);

  if (!$sku_is_valid) {
    commerce_xls_import_set_error($row, 'sku', "sku format invalid");
    return FALSE;
  }

  $sku_available = commerce_product_validate_sku_unique($sku, NULL);

  if (!$sku_available) {
    commerce_xls_import_set_error($row, 'sku', "sku already in use");
    return FALSE;
  }

  return TRUE;
}

/**
 * Gets the text format to be used in the body of the product.
 */
function commerce_xls_import_get_text_format($user) {
  $formats = filter_formats($user);

  if (isset($formats['full_html'])) {
    return "full_html";
  }
  elseif (isset($formats['filtered_html'])) {
    return "filtered_html";
  }

  return "plain_text";
}

/**
 * Creates the product.
 */
function commerce_xls_import_create_product($row, $values, $entity_info, $product_type, $image_info = array()) {
  module_load_include('inc', 'node');
  module_load_include('inc', 'node', 'node.pages');

  global $user;
  $form_state = array();

  $sku = $entity_info['sku'];
  $node = new stdClass();

  $language = commerce_xls_import_validate_languages($entity_info['language']);

  if (!$language) {
    // Language  not there, set to undefined.
    $language = LANGUAGE_NONE;
  }
  $node->language = $language;
  $new_language = $language;
  $language = LANGUAGE_NONE;

  $text_format = commerce_xls_import_get_text_format($user);

  // Set up form state.
  $form_state['values']['title'] = $entity_info['title'];
  $form_state['values']['language'] = $language;
  $form_state['values']['name'] = $user->name;
  $form_state['values']['body'] = array(
    "$language" => array(
      0 => array(
        'value' => $entity_info["body"],
        'format' => $text_format,
      ),
    ),
  );
  $form_state['values']['status'] = 1;
  $form_state['values']['promote'] = 0;
  $form_state['values']['sticky'] = 0;
  $form_state['values']['op'] = t('Save');

  $values['language'] = $language;

  $nid = commerce_xls_import_validate_product($row, $entity_info);

  if ($nid === FALSE) {
    // Product failed validation.
    return FALSE;
  }
  elseif ($nid == NULL) {

    // Prepare node.
    $node->type = $product_type;
    node_object_prepare($node);
    $node->title = $entity_info['title'];
    $node->language = $new_language;

    $node->body = array(
      "$language" => array(
        0 => array(
          'value' => $entity_info["body"],
          'format' => 'full_html',
        ),
      ),
    );

    commerce_xls_import_update_entity_info($row, $node, $entity_info, $values, $image_info, TRUE);

    // Create the form_state to use node validation.
    foreach ($values as $key => $field) {
      $field_info = field_info_field($key);
      if ($field_info['type'] == 'image') {

        // Validate Images.
        commerce_xls_import_check_set_images($row, $field, $form_state, $image_info, $key, $language);
      }
      else {
        $form_state['values'][$key] = array(
          "$language" => array(
            0 => $field,
          ),
        );
      }
    }

    $form_state['values']['language'] = $language;
  }
  else {
    $node = node_load($nid, NULL, TRUE);
    $node->language = $new_language;
  }

  // Validate sku.
  commerce_xls_import_validate_sku($row, $sku);

  $product = commerce_product_new($product_type);
  $product->created = time();
  commerce_xls_import_update_entity_info($row, $product, $entity_info, $values, $image_info);

  if (CommerceXlsImportVariables::isImport()) {
    if (!commerce_xls_import_get_row_error($row)) {
      // If no errors exist, save the variation and node.
      commerce_product_save($product);

      $node->field_product[LANGUAGE_NONE][]['product_id'] = $product->product_id;
      $node->language = $new_language;

      node_save($node);
      return $node->nid;
    }
    elseif (CommerceXlsImportVariables::isValidate()) {
      // Only validating products.
      return NULL;
    }
    else {
      // Don't create product or variation if there are errors.
      return NULL;
    }
  }
}

/**
 * Searches to see if the product if it already exists.
 *
 * If a product with the given title already exists, return its nid. If
 * multiple products with the given title exist, return an array containing
 * the nids of all matching products. Otherwise, if no products exist, return
 * null.
 *
 * @param string $title
 *   The title of the product to be queried.
 *
 * @return int|array|null
 *   Returns single nid if one product found.
 *   Returns array of nids if multiple products found.
 *   Returns null if no products found.
 */
function commerce_xls_import_search_for_product($title) {
  $nids = array();
  $count = 0;

  $result = db_select('node', 'n')
    ->fields('n', array('nid'))
    ->condition('n.title', $title, '=')
    ->execute();

  while ($record = $result->fetchAssoc()) {
    $nids[$count] = $record['nid'];
    $count++;
  }

  if ($count == 1) {
    return $nids[0];
  }
  elseif ($count > 1) {
    return $nids;
  }
  else {
    return NULL;
  }
}

/**
 * Gets an array of category terms.
 *
 * Function to use a comma separated list of category names to retrieve the
 * taxonomy terms.
 *
 * @return array
 *    An array containing category terms.
 */
function commerce_xls_import_get_category_id($category_names) {
  $term_list = explode(',', $category_names);
  $terms = array();

  foreach ($term_list as $term) {
    $tax_terms = taxonomy_get_term_by_name($term);
    foreach ($tax_terms as $term) {
      $terms[]['tid'] = $term->tid;
    }
  }

  return $terms;
}

/**
 * Updates the entity info.
 */
function commerce_xls_import_update_entity_info($row, $product, $entity_info, $values, $image_info, $a_node = FALSE) {
  $language = $values['language'];

  if (!$a_node) {
    foreach ($entity_info as $key => $value) {
      $product->$key = $value;
    }

    $product->changed = time();
    $product->language = $language;
    if ($entity_info['variation_title'] != NULL) {
      $product->title = $entity_info['variation_title'];
    }
    else {
      $product->title = $entity_info['title'];
    }
  }

  // Check for added fields.
  foreach ($values as $key => $field) {
    if (strpos($key, "field") === 0) {
      // it's an added field.
      $info = field_info_field($key);

      if ($info['type'] == 'image' && $image_info) {
        // This field contains an image
        // check for an apostrophe to see if multiple images.
        $filenames = array($field);
        if (strpos($field, ',')) {
          $filenames = explode(',', $field);
        }
        // Reset all the images to only use the ones provided.
        $product->{$key}[$language] = array();
        foreach ($filenames as $filename) {
          if ($filename == "") {
            // No image entered.
          }
          elseif (pathinfo($filename, PATHINFO_EXTENSION) == "") {
            if (commerce_xls_import_get_error($row, $key) == '') {
              commerce_xls_import_set_error($row, $key, "Image is missing extension");
            }
          }
          else {
            $file = file_load($image_info[trim($filename)]);

            if ($file !== FALSE) {
              $product->{$key}[$language][] = get_object_vars($file);
              file_usage_add($file, 'commerce_xls_import', 'user', 1);
            }
            else {
              if (commerce_xls_import_get_error($row, $key) == '') {
                commerce_xls_import_set_error($row, $key, "Invalid image data entered");
              }
            }
          }
        }
      }
      elseif ($info['type'] == 'entity_reference') {
        // Get nid from given entity name.
        if ($field != "") {
          // Break them up since multiples are comma delimited.
          $entity_references = explode(',', $field);

          // Reset the references to avoid adding duplicates.
          $product->{$key} = NULL;

          foreach ($entity_references as $entity_reference) {
            $nid = commerce_xls_import_get_entity_reference_nid(trim($entity_reference));

            if ($nid) {
              $product->{$key}[$language][]['target_id'] = $nid;
            }
          }
        }
      }
      elseif ($info['type'] == 'commerce_price') {
        if ($field != "") {
          $price = array(
            "$language" => array(
              0 => array(
                'amount' => $field * 100,
                'currency_code' => $values['currency_code'],
              ),
            ),
          );
          $product->{$key} = $price;
        }
      }
      elseif ($info['type'] == 'list_boolean') {
        $product->$key = array(
          "$language" => array(
            0 => array(
              'value' => $field,
            ),
          ),
        );
      }
      elseif ($info['type'] == 'taxonomy_term_reference') {
        $terms = commerce_xls_import_get_category_id($field);
        $product->$key = array(
          "$language" => $terms,
        );
      }
      else {
        $product->$key = array(
          "$language" => array(
            0 => array(
              'value' => $field,
            ),
          ),
        );
      }
    }
  }
  if (!$a_node) {
    // Set the price and currency.
    if (commerce_xls_import_validate_price($row, $values)) {
      $price = array(
        "$language" => array(
          0 => array(
            'amount' => $values['commerce_price'] * 100,
            'currency_code' => $values['currency_code'],
          ),
        ),
      );
      $product->commerce_price = $price;
    }
  }
}

/**
 * Validates that the products price.
 *
 * @param array $values
 *    An array containing the product values.
 *
 * @return bool
 *    False if no price entered or invalid price entered. Otherwise true.
 */
function commerce_xls_import_validate_price($row, array $values) {
  if (!isset($values['commerce_price']) || $values['commerce_price'] == NULL) {
    commerce_xls_import_set_error($row, 'commerce_price', "No Price Entered!");
    return FALSE;
  }

  if (!is_numeric($values['commerce_price'])) {
    commerce_xls_import_set_error($row, 'commerce_price', "Invalid Price Entered!");
    return FALSE;
  }

  return TRUE;
}

/**
 * Gets the entity reference nid.
 */
function commerce_xls_import_get_entity_reference_nid($field) {
  $result = db_select('node', 'n')
    ->fields('n', array("nid"))
    ->condition('title', $field, 'like')
    ->execute();

  $data = $result->fetchAssoc();

  return $data['nid'];
}

/**
 * Get headers from XLS.
 */
function commerce_xls_import_get_headers(&$phpexcel) {
  static $headers = NULL;

  if (!isset($headers)) {
    $headers = array();

    $last_column = $phpexcel->getHighestColumn();
    $headers_temp = $phpexcel->rangeToArray('A1:' . $last_column . '1', NULL, TRUE, TRUE, TRUE);
    $headers_temp = $headers_temp[1];
    foreach ($headers_temp as $key => $header) {
      // Use ascii to convert letter to number.
      // 66 is the offset.
      $numeric_key = ord($key) - 65;
      $headers[$numeric_key] = $header;
    }
  }

  return $headers;
}

/**
 * Handles the main zip extraction.
 */
function commerce_xls_import_extract_zip() {
  $dir = realpath(".") . "/" . variable_get('file_public_path', conf_path() . '/files');

  $import_successful = commerce_xls_import_unpack_zip($dir, 'product_images', "$dir");

  // Add new files to the file table.
  if ($import_successful) {
    return commerce_xls_import_create_image_database_entries("public://");
  }
  else {
    return FALSE;
  }
}

/**
 * Adds the any images in the base path directory to the file table.
 *
 * @param string $base_path
 *   The base path where the file is located.
 *
 * @return array
 *   An array containing the filename and fid pairs.
 */
function commerce_xls_import_create_image_database_entries($base_path) {
  global $user;
  $results = array();

  $filenames = scandir($base_path);

  foreach ($filenames as $filename) {
    // Check file table for entry for this file, if an entry, ignore.
    if ($filename != "." && $filename != ".." && !is_dir("$base_path/$filename")) {
      $uri = "$base_path/$filename";
      if ($fid = commerce_xls_import_file_entry_exists($uri)) {
        // File entry exists update it.
        $results[$filename] = $fid;
      }
      else {

        // doesn't exist, create file entry.
        $file = new stdClass();
        $file->uid = $user->uid;
        $file->filename = $filename;
        $file->uri = $uri;
        $file->filemime = mime_content_type($uri);
        $file->filesize = filesize($uri);
        $file->status = 1;

        $file = file_save($file);
        $results[$filename] = $file->fid;
      }
    }
  }

  return $results;
}

/**
 * Checks to see if file entry already exists.
 */
function commerce_xls_import_file_entry_exists($uri) {
  $result = db_select('file_managed', 'f')
    ->fields('f', array('uri', 'fid'))
    ->condition('f.uri', $uri, '=')
    ->execute();

  while ($record = $result->fetchAssoc()) {
    return $record['fid'];
  }
  return FALSE;
}

/**
 * Base function for unpacking a zip.
 *
 * Uses the command line to unpack .zip files and move to public files
 * directory.
 */
function commerce_xls_import_unpack_zip($zip_dir, $filename, $save_dir) {
  $file_directory = $save_dir;
  $command = "unzip -oq $zip_dir/$filename.zip -d $file_directory 2>&1";
  $output = array();
  exec($command, $output, $result);
  $error_message = implode("\r\n", $output);

  if ($result != 0) {
    drupal_set_message(t("There was an error extracting @filename.zip. Please try again, if the problem persists contact the system administrator", array("@filename" => $filename)), "error");
    watchdog('commerce_xls_import', "Error: " . $error_message);
    return FALSE;
  }
  else {
    drupal_set_message(t("@filename.zip extracted successfully to @save_dir", array("@filename" => $filename, "@save_dir" => $save_dir)));
    return TRUE;
  }
}

/**
 * Gets any fields that may apply to the product and (optionally) their type.
 *
 * @param string $product_type
 *   The product type.
 * @param bool $get_field_type
 *   Whether or not to include field type.
 *
 * @return array
 *   If $get_field_type is FALSE returns an array of all possible product types.
 *   If $get_field_type is TRUE returns an array of all possible product types
 *   as well as their field type.
 */
function commerce_xls_import_get_possible_fields($product_type, $get_field_type = FALSE) {
  $result = array();
  $fields = field_info_field_map();
  foreach ($fields as $key => $field) {

    if ((isset($field['bundles']['commerce_product']) && in_array($product_type, $field['bundles']['commerce_product']))
      || (isset($field['bundles']['node']) && in_array($product_type, $field['bundles']['node']))
    ) {
      // We don't want to include the product reference since the import will
      // take care of that for us.
      // Also don't want to include the field rating since it's based off user
      // comments and isn't something that can be set by a simple value.
      if ($key != 'field_product' && $key != 'field_rating' && $key != 'title_field') {
        if ($get_field_type) {
          $result[$key]['type'] = $field['type'];
        }
        else {
          $result[$key] = $key;
        }
      }
    }
  }
  return $result;
}

/**
 * Gets an array containing all product NIDs by the given type.
 *
 * @param string $product_type
 *   The product type.
 *
 * @return array
 *   An array containing the NIDs of the given product type.
 */
function commerce_xls_import_nids_of_type($product_type) {
  $products = array();

  $result = db_select('node', 'n')
    ->fields('n', array('nid'))
    ->condition('n.type', $product_type, '=')
    ->execute();
  $records = $result->fetchAllAssoc('nid');

  foreach ($records as $key => $record) {
    $products[] = $key;
  }

  return $products;
}

/**
 * Get the headers needed for the export and import template.
 */
function commerce_xls_import_generate_headers($nid = NULL, $product_type = NULL) {
  $headers = array();

  $product = commerce_xls_import_get_possible_fields($product_type);

  $headers['Products'][] = "title";
  $headers['Products'][] = "variation_title";
  $headers['Products'][] = "sku";
  $headers['Products'] = array_merge($headers['Products'], array_keys($product));
  $headers['Products'][] = "status";
  $headers['Products'][] = "language";
  if (CommerceXlsImportVariables::isImport() && $nid != NULL) {
    $headers['Products'][] = "nid";
  }

  return $headers;
}

/**
 * Exports an array containing data of all products of a given type.
 *
 * @param string $product_type
 *   The machine readable product type.
 *
 * @return array
 *   The data of all products of the given type.
 */
function commerce_xls_import_export_product_data($product_type) {
  $nids = commerce_xls_import_nids_of_type($product_type);
  $products = array();
  $field_info = commerce_xls_import_get_possible_fields($product_type, TRUE);

  $headers_list = commerce_xls_import_generate_headers(NULL, $product_type);
  $headers = array();

  // Set up headers array to match exported data.
  foreach ($headers_list['Products'] as $header) {
    $headers[$header] = '';
  }

  foreach ($nids as $nid) {

    $product_display = node_load($nid);

    // The entity wrapper.
    $wrapper = entity_metadata_wrapper('node', $product_display);

    $product_title = $wrapper->title->value(array('sanitize' => FALSE));
    $product_language = $wrapper->language->value(array('sanitize' => FALSE));
    $product_body = $wrapper->body->value(array('sanitize' => FALSE));

    // Array containing variation data.
    $variations = $wrapper->field_product->value(array('sanitize' => FALSE));

    foreach ($variations as $variation) {
      $data = array();
      $data['title'] = $product_title;
      $data['body'] = $product_body['value'];
      $data['language'] = $product_language;
      $data['variation_title'] = $variation->title;
      $data['sku'] = $variation->sku;
      $data['status'] = $variation->status;

      foreach ($field_info as $key => $field) {
        switch ($field['type']) {
          case 'commerce_price':
            $price = $variation->$key;
            $data[$key] = $price[$product_language][0]['amount'];
            break;

          case 'image':
            $filenames = '';
            $images = $variation->$key;

            if (!empty($images)) {
              $images = $images[$product_language];
              foreach ($images as $image) {
                $filenames = $filenames . $image['filename'] . ', ';
              }
              $filenames = substr($filenames, 0, -2);
            }

            $data[$key] = $filenames;
            break;

          case 'taxonomy_term_reference':
            $name = '';
            if (!empty($variation->$key)) {
              $term_reference = $variation->$key;
              $tid = $term_reference[$product_language][0]['tid'];
              $term = taxonomy_term_load($tid);
              $name = $term->name;
            }
            else {
              // Is a field from the product, not the variation.
              if (isset($wrapper->$key)) {
                $term_reference = $wrapper->$key->value(array('sanitize' => TRUE));
                if (!empty($term_reference)) {
                  $name = $term_reference->name;
                }
              }
            }
            $data[$key] = $name;
            break;

        }
      }

      // Put keys in proper order for export.
      $data = array_merge($headers, $data);

      $products[] = $data;
    }

  }

  return $products;
}

/**
 * Gets the owner of the form field.
 */
function commerce_xls_import_get_field_owner($field_name) {
  if ($field_name == 'title') {
    return 'parent';
  }
  elseif ($field_name == 'variation_title') {
    return 'variation';
  }
  elseif ($field_name == 'sku') {
    return 'variation';
  }
  elseif ($field_name == 'status') {
    return 'both';
  }
  elseif ($field_name == 'language') {
    return 'parent';
  }
  else {
    $field_info = field_info_field($field_name);
    if (isset($field_info['bundles']['commerce_product'])) {
      if (isset($field_info['bundles']['node'])) {
        return 'both';
      }
      else {
        return 'variation';
      }
    }
    else {
      return 'parent';
    }
  }
}

/**
 * Checks the status of the current import.
 */
function commerce_xls_import_current_status() {
  $current = variable_get('commerce_xls_import_import_count_status', '');

  $is_running = commerce_xls_import_is_running();

  if (($current == '' && $is_running)) {
    $message = t('Working...');
    $status = 0;
  }
  elseif ($current == '' && !$is_running) {
    $message = t('Done!');
    $status = 1;
    variable_set('commerce_xls_import_completed', 1);
  }
  else {
    $message = t("Status : @current/@total products evaluated with @errors errors",
      array(
        '@current' => $current['completed'],
        '@total' => $current['total'],
        '@errors' => variable_get('commerce_xls_import_error_count'),
      ));
    $message .= '<br /><progress id="commerce-xls-import-progress" value=' . $current['completed'] . ' max=' . $current['total'] . ' style="clear:both"></progress>';
    $status = 0;
  }

  if ($current == '') {
    $output = array(
      'completed' => 0,
      'total' => 0,
      'message' => $message,
      'status' => $status,
    );
  }
  else {
    $output = array(
      'completed' => $current['completed'],
      'total' => $current['total'],
      'message' => $message,
      'status' => $status,
    );
  }

  drupal_json_output($output);
}
