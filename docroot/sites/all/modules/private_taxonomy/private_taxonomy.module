<?php

/**
 * @file
 * A module to enable taxonomy terms per user.
 *
 * Vocabularies can be marked as private, enabling users to create and maintain
 * their own terms for those vocabularies.
 */

/**
 * Implements hook_permission().
 */
function private_taxonomy_permission() {
  $permissions = array(
    'administer own taxonomy' => array(
      'title' => t('Administer own taxonomy'),
      'description' => t('Allows the user to administer their terms in private vocabularies'),
    ),
    'view private taxonomies' => array(
      'title' => t('View private taxonomies'),
      'description' => t('Allows the user to view other users terms in private vocabularies'),
    ),
  );
  foreach (taxonomy_get_vocabularies() as $vocabulary) {
    if (private_taxonomy_is_vocabulary_private($vocabulary->vid)) {
      $permissions += array(
        'edit own terms in ' . $vocabulary->vid => array(
          'title' => t('Edit own terms in %vocabulary',
            array('%vocabulary' => $vocabulary->name)),
        ),
      );
      $permissions += array(
        'delete own terms in ' . $vocabulary->vid => array(
          'title' => t('Delete own terms from %vocabulary',
            array('%vocabulary' => $vocabulary->name)),
        ),
      );
    }
  }
  return $permissions;
}

/**
 * Enables access to certain taxonomy administration pages.
 *
 * Users with 'administer own taxonomy' permission require access to some
 * taxonomy administration pages to maintain their terms.
 *
 * @param string $string
 *   The permission, such as "administer nodes", being checked for.
 * @param object $account
 *   (optional) The account to check, if not given use currently logged in user.
 *
 * @return bool
 *   Boolean TRUE if the current user has the requested permission.
 */
function private_taxonomy_user_edit_access($string, $account = NULL) {
  return (user_access($string, $account) ||
          user_access('administer own taxonomy', $account));
}

/**
 * Enables access to certain taxonomy administration pages.
 *
 * Users with 'view private taxonomies' permission require access to some
 * taxonomy administration pages to view private vocabularies.
 *
 * @param string $string
 *   The permission, such as "administer nodes", being checked for.
 * @param object $account
 *   (optional) The account to check, if not given use currently logged in user.
 *
 * @return bool
 *   Boolean TRUE if the current user has the requested permission.
 */
function private_taxonomy_user_view_access($string, $account = NULL) {
  return (user_access($string, $account) ||
          user_access('administer own taxonomy', $account) ||
          user_access('view private taxonomies', $account));
}

/**
 * Implements hook_menu().
 */
function private_taxonomy_menu() {
  $items = array();

  $items['admin/structure/taxonomy/user'] = array(
    'title' => 'User taxonomy',
    'description' => 'Settings for cloning terms for users.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('private_taxonomy_form'),
    'access arguments' => array('administer taxonomy'),
    'type' => MENU_LOCAL_TASK,
    'parent' => 'admin/structure/taxonomy',
    'file' => 'private_taxonomy.admin.inc',
  );

  $items['admin/structure/taxonomy/user/create'] = array(
    'page callback' => 'private_taxonomy_default_taxonomy',
    'access arguments' => array('administer taxonomy'),
    'type' => MENU_CALLBACK,
  );

  $items['admin/structure/taxonomy/%taxonomy_vocabulary_machine_name/view'] = array(
    'title callback' => 'taxonomy_admin_vocabulary_title_callback',
    'title arguments' => array(3),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('private_taxonomy_view_terms', 3),
    'access arguments' => array('view private taxonomies'),
    'type' => MENU_CALLBACK,
  );

  $items['private_taxonomy/autocomplete'] = array(
    '#title' => 'Private term autocomplete',
    'page callback' => 'private_taxonomy_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function private_taxonomy_menu_alter(&$items) {
  $items['admin/structure/taxonomy']['access callback']
    = 'private_taxonomy_user_view_access';
  $items['admin/structure/taxonomy/%taxonomy_vocabulary_machine_name']['access callback'] = 'private_taxonomy_user_edit_access';
  $items['admin/structure/taxonomy/%taxonomy_vocabulary_machine_name/add']['access callback'] = 'private_taxonomy_user_edit_access';
  $items['taxonomy/term/%taxonomy_term/edit']['access callback']
    = 'private_taxonomy_term_edit_access';
}

/**
 * Implements hook_query_QUERY_ID_alter().
 *
 * For term_access.
 */
function private_taxonomy_query_term_access_alter($query) {
  $conditions =& $query->conditions();
  // Condition could be vocabulary ID or term ID.
  foreach ($conditions as $condition) {
    if (is_array($condition) && is_string($condition['field']) &&
      !empty($condition['field'])) {

      list($table, $field) = explode('.', $condition['field']);
      if ($field == 'vid') {
        $vid = $condition['value'];
        if (!private_taxonomy_is_vocabulary_private($vid)) {
          return;
        }
      }
      if ($field == 'tid') {
        $tid = $condition['value'];
        if (!private_taxonomy_is_term_private($tid)) {
          return;
        }
      }
      // Views exposed filter uses 'machine_name' instead of 'vid'.
      if ($field == 'machine_name') {
        $info = taxonomy_vocabulary_get_names();
        if (is_array($condition['value'])) {
          $flag = FALSE;
          foreach ($condition['value'] as $machine_name) {
            $vid = $info[$machine_name]->vid;
            if (private_taxonomy_is_vocabulary_private($vid)) {
              $flag = TRUE;
              break;
            }
          }
          if (!$flag) {
            return;
          }
        }
        else {
          $vid = $info[$condition['value']]->vid;
          if (!private_taxonomy_is_vocabulary_private($vid)) {
            return;
          }
        }
      }
    }
  }

  $tables =& $query->getTables();
  // Get the term alias.
  foreach ($tables as $table) {
    if ($table['table'] == 'taxonomy_term_data') {
      if (!is_array($table) || !is_string($table['alias'])) {
        // Should always exist but if it does not bail out.
        return;
      }
      $term_alias = $table['alias'];
    }
  }

  if (user_access('administer taxonomy') ||
    user_access('view private taxonomies')) {

    if (isset($_SESSION['private_taxonomy']['filter']) &&
      drupal_substr(current_path(), 0, 25) == 'admin/structure/taxonomy/') {

      $sql = 'SELECT uid FROM {users} WHERE name = :name';
      $name = $_SESSION['private_taxonomy']['filter'];
      $uid = db_query($sql, array(':name' => $name))->fetchField();;
      $query->leftJoin('user_term', 'user_term',
        $term_alias . '.tid=user_term.tid');
      $query->condition('user_term.uid', $uid);
    }
  }
  else {
    global $user;
    // Must have administer own taxonomy permission.
    $query->leftJoin('user_term', 'user_term',
      $term_alias . '.tid=user_term.tid');
    $query->condition('user_term.uid', $user->uid);
  }
}

/**
 * Implements hook_taxonomy_vocabulary_insert().
 */
function private_taxonomy_taxonomy_vocabulary_insert($vocabulary) {
  if (!property_exists($vocabulary, 'private')) {
    $vocabulary->private = 0;
  }
  $vid = db_insert('private_vocabularies')
    ->fields(array(
      'vid' => $vocabulary->vid,
      'private' => $vocabulary->private,
    ))
    ->execute();
}


/**
 * Implements hook_taxonomy_vocabulary_delete().
 */
function private_taxonomy_taxonomy_vocabulary_delete($vocabulary) {
  db_delete('private_vocabularies')
    ->condition('vid', $vocabulary->vid)
    ->execute();
}

/**
 * Implements hook_taxonomy_term_insert().
 */
function private_taxonomy_taxonomy_term_insert($term) {
  if (private_taxonomy_is_vocabulary_private($term->vid)) {
    global $user;
    if (property_exists($term, 'uid') && is_numeric($term->uid)) {
      $uid = $term->uid;
    }
    else {
      $uid = $user->uid;
    }
    $result = db_insert('user_term')
      ->fields(array(
        'uid' => $uid,
        'tid' => $term->tid,
      ))
      ->execute();
  }
}

/**
 * Implements hook_taxonomy_term_delete().
 */
function private_taxonomy_taxonomy_term_delete($term) {
  if (private_taxonomy_is_vocabulary_private($term->vid)) {
    db_delete('user_term')
      ->condition('tid', $term->tid)
      ->execute();
  }
}

/**
 * Retrieves the public or private status of a vocabulary.
 *
 * Returns TRUE if the vocabulary is private.
 *
 * @param int $vid
 *   Vocabulary Id.
 *
 * @return bool
 *   TRUE if the specified vocabulary is private; otherwise, FALSE.
 */
function private_taxonomy_is_vocabulary_private($vid) {
  $sql = 'SELECT private FROM {private_vocabularies} WHERE vid = :vid';
  $private = db_query($sql, array(':vid' => $vid))->fetchField();
  if (!is_null($private)) {
    return $private;
  }
  else {
    // Should only happen when the vocabulary hasn't been created yet.
    return FALSE;
  }
}

/**
 * Retrieves the public or private status of a vocabulary for terms.
 *
 * Returns TRUE if the terms belong to a private vocabulary.
 *
 * @param array/int $tid
 *   term Id(s).
 *
 * @return bool
 *   TRUE if the term(s) belong to a private vocabulary; otherwise, FALSE.
 */
function private_taxonomy_is_term_private($tid) {
  $sql = 'SELECT vid FROM {taxonomy_term_data} WHERE tid = :tid';
  if (is_array($tid)) {
    $vids = array();
    foreach ($tid as $value) {
      $vids[] = db_query($sql, array(':tid' => $value))->fetchField();
    }
    $vids = array_unique($vids);
    if (count($vids) > 1) {
      return FALSE;
    }
    else {
      $vid = $vids[0];
    }
  }
  else {
    $vid = db_query($sql, array(':tid' => $tid))->fetchField();
  }
  return private_taxonomy_is_vocabulary_private($vid);
}

/**
 * Retrieve the user that owns a term.
 *
 * Returns the user uid that owns a particular term in a private vocabulary.
 *
 * @param int $tid
 *   Term Id.
 *
 * @return int
 *   User uid.
 */
function private_taxonomy_term_get_user($tid) {
  $sql = 'SELECT uid FROM {user_term} WHERE tid = :tid';
  $uid = db_query($sql, array(':tid' => $tid))->fetchField();
  if ($uid) {
    return $uid;
  }
  else {
    return 0;
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for taxonomy_overview_vocabularies().
 */
function private_taxonomy_form_taxonomy_overview_vocabularies_alter(&$form,
  &$form_state, $form_id) {
  if (!user_access('administer taxonomy')) {
    foreach ($form as $key => $value) {
      if (is_numeric($key)) {
        if (!private_taxonomy_is_vocabulary_private($key)) {
          unset($form[$key]);
          continue;
        }
        if (user_access('administer own taxonomy')) {
          $form[$key]['edit']['#title'] = t('admin own terms');
          $form[$key]['edit']['#href'] = $form[$key]['list']['#href'];
        }
        else {
          unset($form[$key]['edit']);
          unset($form[$key]['add']);
        }
        if (user_access('view private taxonomies')) {
          $form[$key]['list']['#title'] = t('view all terms');
          $form[$key]['list']['#href'] .= '/view';
        }
        else {
          unset($form[$key]['list']);
        }
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter() for taxonomy_overview_terms().
 */
function private_taxonomy_form_taxonomy_overview_terms_alter(&$form,
  &$form_state, $form_id) {
  global $user;
  if (private_taxonomy_is_vocabulary_private($form['#vocabulary']->vid)) {
    if ($user->uid == 1 || user_access('administer taxonomy')) {
      // Users that can view terms for all users need filtering.
      $form['filter'] = array(
        '#type' => 'textfield',
        '#title' => t('Filter by user'),
        '#size' => 20,
        '#autocomplete_path' => 'user/autocomplete',
        '#weight' => 0,
      );
      if (isset($_SESSION['private_taxonomy']['filter'])) {
        $form['filter']['#default_value']
          = $_SESSION['private_taxonomy']['filter'];
      }
      // Need to add a column showing the owner of the term.
      foreach ($form as $key => $item) {
        if (drupal_substr($key, 0, 3) == 'tid') {
          $sql = 'SELECT name FROM {user_term} user_term
            LEFT JOIN {users} users ON user_term.uid=users.uid
            WHERE tid = :tid';
          $name = db_query($sql, array(':tid' => (int) $item['#term']['tid']))
            ->fetchField();
          // If there is no submit then there is only one term.
          if (isset($form['actions']['submit'])) {
            $form[$key]['weight']['#suffix'] = '<td>' . $name . '</td>';
          }
        }
      }
    }
    else {
      if (user_access('view private taxonomies')) {
        // Need to remove other users' terms.
        foreach ($form as $key => $item) {
          if (drupal_substr($key, 0, 3) == 'tid') {
            if (private_taxonomy_term_get_user($item['#term']['tid']) !=
                $user->uid) {
              unset($form[$key]['#term']);
              unset($form[$key]['view']);
              unset($form[$key]['weight']);
              unset($form[$key]['edit']);
            }
          }
        }
      }
    }
    // If there is only one term than taxonomy does not display the Save button.
    if (!isset($form['actions']['submit'])) {
      if (isset($form['filter'])) {
        $form['actions']['submit'] = array(
          '#type' => 'submit',
          '#value' => t('Save'),
        );
      }
      $form['#submit'] = array();
    }
    $form['#submit'][] = 'private_taxonomy_user_filter';
    $form['#post_render'][] = 'private_taxonomy_post_render';
  }
}

/**
 * Form post render handler for taxonomy_overview_terms().
 */
function private_taxonomy_post_render($form, &$form_state) {
  if (user_access('administer taxonomy')) {
    if (in_array('taxonomy_overview_terms_submit', $form_state['#submit'])) {
      // Add header column for owners.
      $form = str_replace('<th>Weight</th>', '<th>Weight</th><th>Owner</th>',
                          $form);
    }
    else {
      // Only one term so disable weights.
      $form = str_replace('<th>Weight</th>', '<th>Owner</th>', $form);
      $form = str_replace('draggable ', '', $form);
    }
  }
  else {
    if (!in_array('taxonomy_overview_terms_submit', $form_state['#submit'])) {
      // Only one term so remove the weights.
      $form = str_replace('draggable ', '', $form);
      $form = str_replace('<th>Weight</th>', '', $form);
    }
  }
  $form = str_replace('<td></td>', '', $form);
  return $form;
}

/**
 * Form submission handler for taxonomy_overview_terms().
 */
function private_taxonomy_user_filter($form, &$form_state) {
  if (!in_array('taxonomy_overview_terms_submit', $form['#submit'])) {
    // Taxonomy seems to complain when there is only one item.
    // This removes the message.
    drupal_get_messages();
  }
  if (isset($form_state['values']['filter'])) {
    if (drupal_strlen($form_state['values']['filter']) == 0) {
      unset($_SESSION['private_taxonomy']['filter']);
    }
    else {
      $_SESSION['private_taxonomy']['filter'] = $form_state['values']['filter'];
    }
  }
}

/**
 * Form builder for the private taxonomy terms view.
 *
 * Display a tree of all the terms in a vocabulary.
 *
 * @ingroup forms
 * @see private_taxonomy_view_terms_submit()
 * @see theme_private_taxonomy_view_terms()
 */
function private_taxonomy_view_terms($form, &$form_state, $vocabulary) {
  global $pager_page_array, $pager_total, $pager_total_items;

  $form['#vocabulary'] = $vocabulary;
  $form['#tree'] = TRUE;
  $form['#parent_fields'] = FALSE;

  $page            = isset($_GET['page']) ? $_GET['page'] : 0;
  // Number of terms per page.
  $page_increment  = variable_get('taxonomy_terms_per_page_admin', 100);
  // Elements shown on this page.
  $page_entries    = 0;
  // Elements at the root level before this page.
  $before_entries  = 0;
  // Elements at the root level after this page.
  $after_entries   = 0;
  // Elements at the root level on this page.
  $root_entries    = 0;

  // Terms from previous and next pages are shown if the term tree would have
  // been cut in the middle. Keep track of how many extra terms we show on each
  // page of terms.
  $back_step    = NULL;
  $forward_step = 0;

  // An array of the terms to be displayed on this page.
  $current_page = array();

  $delta = 0;
  $term_deltas = array();
  $tree = taxonomy_get_tree($vocabulary->vid);
  $term = current($tree);
  do {
    // In case this tree is completely empty.
    if (empty($term)) {
      break;
    }
    $delta++;
    // Count entries before the current page.
    if ($page && ($page * $page_increment) > $before_entries && !isset($back_step)) {
      $before_entries++;
      continue;
    }
    // Count entries after the current page.
    elseif ($page_entries > $page_increment && isset($complete_tree)) {
      $after_entries++;
      continue;
    }

    // Do not let a term start the page that is not at the root.
    if (isset($term->depth) && ($term->depth > 0) && !isset($back_step)) {
      $back_step = 0;
      while ($pterm = prev($tree)) {
        $before_entries--;
        $back_step++;
        if ($pterm->depth == 0) {
          prev($tree);
          // Jump back to the start of the root level parent.
          continue 2;
        }
      }
    }
    $back_step = isset($back_step) ? $back_step : 0;
    // Continue rendering the tree until we reach the a new root item.
    if ($page_entries >= $page_increment + $back_step + 1 && $term->depth == 0 && $root_entries > 1) {
      $complete_tree = TRUE;
      // This new item at the root level is the first item on the next page.
      $after_entries++;
      continue;
    }
    if ($page_entries >= $page_increment + $back_step) {
      $forward_step++;
    }

    // Finally, if we've gotten down this far, we're rendering a term on this
    // page.
    $page_entries++;
    $term_deltas[$term->tid] = isset($term_deltas[$term->tid]) ? $term_deltas[$term->tid] + 1 : 0;
    $key = 'tid:' . $term->tid . ':' . $term_deltas[$term->tid];
    // Keep track of the first term displayed on this page.
    if ($page_entries == 1) {
      $form['#first_tid'] = $term->tid;
    }
    // Keep a variable to make sure at least 2 root elements are displayed.
    if ($term->parents[0] == 0) {
      $root_entries++;
    }
    $current_page[$key] = $term;
  } while ($term = next($tree));

  // Because we didn't use a pager query, set the necessary pager variables.
  $total_entries = $before_entries + $page_entries + $after_entries;
  $pager_total_items[0] = $total_entries;
  $pager_page_array[0] = $page;
  $pager_total[0] = ceil($total_entries / $page_increment);

  // If this form was already submitted once, it's probably hit a validation
  // error. Ensure the form is rebuilt in the same order as the user submitted.
  if (!empty($form_state['input'])) {
    // Get the $_POST order.
    $order = array_flip(array_keys($form_state['input']));
    // Update our form wit  h the new order.
    $current_page = array_merge($order, $current_page);
    foreach ($current_page as $key => $term) {
      // Verify this is a term for the current page and set at the current
      // depth.
      if (is_array($form_state['input'][$key]) && is_numeric($form_state['input'][$key]['tid'])) {
        $current_page[$key]->depth = $form_state['input'][$key]['depth'];
      }
      else {
        unset($current_page[$key]);
      }
    }
  }
  // Build the actual form.
  foreach ($current_page as $key => $term) {
    // Save the term for the current page so we don't have to load it a
    // second time.
    $form[$key]['#term'] = (array) $term;
    if (isset($term->parents)) {
      $form[$key]['#term']['parent'] = $term->parent = $term->parents[0];
      unset($form[$key]['#term']['parents'], $term->parents);
    }

    $form[$key]['view'] = array(
      '#type' => 'link',
      '#title' => $term->name,
      '#href' => "taxonomy/term/$term->tid",
    );
    $sql = 'SELECT name FROM {user_term} user_term
      LEFT JOIN {users} users ON user_term.uid=users.uid
      WHERE tid = :tid';
    $name = db_query($sql, array(':tid' => $term->tid))
      ->fetchField();
    $form[$key]['owner'] = array('#type' => '#markup', '#suffix' => $name);
    if ($vocabulary->hierarchy < 2) {
      $form['#parent_fields'] = TRUE;
      $form[$key]['tid'] = array(
        '#type' => 'hidden',
        '#value' => $term->tid,
      );
      $form[$key]['parent'] = array(
        '#type' => 'hidden',
        // Yes, default_value on a hidden. It needs to be changeable by the
        // javascript.
        '#default_value' => $term->parent,
      );
      $form[$key]['depth'] = array(
        '#type' => 'hidden',
        // Same as above, the depth is modified by javascript, so it's a
        // default_value.
        '#default_value' => $term->depth,
      );
    }
  }

  $form['#total_entries'] = $total_entries;
  $form['#page_increment'] = $page_increment;
  $form['#page_entries'] = $page_entries;
  $form['#back_step'] = $back_step;
  $form['#forward_step'] = $forward_step;
  $form['#empty_text'] = t('No terms available.');

  $form['filter'] = array(
    '#type' => 'textfield',
    '#title' => t('Filter by user'),
    '#size' => 20,
    '#autocomplete_path' => 'user/autocomplete',
    '#weight' => 0,
  );

  if (isset($_SESSION['private_taxonomy']['filter'])) {
    $form['filter']['#default_value']
      = $_SESSION['private_taxonomy']['filter'];
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
  );
  $form_state['redirect'] = array($_GET['q'], (isset($_GET['page']) ? array('query' => array('page' => $_GET['page'])) : array()));

  return $form;
}

/**
 * Form submission handler for private_taxonomy_view_terms().
 */
function private_taxonomy_view_terms_submit($form, &$form_state) {
  if (drupal_strlen($form_state['values']['filter']) == 0) {
    unset($_SESSION['private_taxonomy']['filter']);
  }
  else {
    $_SESSION['private_taxonomy']['filter'] = $form_state['values']['filter'];
  }
}

/**
 * Returns HTML for a terms overview form as a sortable list of terms.
 *
 * @param array $variables
 *   An associative array containing:
 *   - form: A render element representing the form.
 *
 * @see private_taxonomy_view_terms()
 * @ingroup themeable
 */
function theme_private_taxonomy_view_terms($variables) {
  $form = $variables['form'];

  $page_increment  = $form['#page_increment'];
  $page_entries    = $form['#page_entries'];
  $back_step     = $form['#back_step'];
  $forward_step  = $form['#forward_step'];

  $errors = form_get_errors() != FALSE ? form_get_errors() : array();
  $rows = array();
  foreach (element_children($form) as $key) {
    if (isset($form[$key]['#term'])) {
      $term = &$form[$key];

      $row = array();
      $row[] = (isset($term['#term']['depth']) && $term['#term']['depth'] > 0 ?
        theme('indentation', array('size' => $term['#term']['depth'])) : '') .
        drupal_render($term['view']);
      if ($form['#parent_fields']) {
        $term['tid']['#attributes']['class'] = array('term-id');
        $term['parent']['#attributes']['class'] = array('term-parent');
        $term['depth']['#attributes']['class'] = array('term-depth');
        $row[0] .= drupal_render($term['parent']) .
          drupal_render($term['tid']) . drupal_render($term['depth']);
      }
      $row[] = drupal_render($term['owner']);
      $row = array('data' => $row);
      $rows[$key] = $row;
    }
  }

  // Add necessary classes to rows.
  $row_position = 0;
  foreach ($rows as $key => $row) {
    $rows[$key]['class'] = array();
    // Add classes that mark which terms belong to previous and next pages.
    if ($row_position < $back_step ||
      $row_position >= $page_entries - $forward_step) {
      $rows[$key]['class'][] = 'taxonomy-term-preview';
    }

    if ($row_position !== 0 && $row_position !== count($rows) - 1) {
      if ($row_position == $back_step - 1 ||
        $row_position == $page_entries - $forward_step - 1) {
        $rows[$key]['class'][] = 'taxonomy-term-divider-top';
      }
      elseif ($row_position == $back_step ||
        $row_position == $page_entries - $forward_step) {
        $rows[$key]['class'][] = 'taxonomy-term-divider-bottom';
      }
    }

    // Add an error class if this row contains a form error.
    foreach ($errors as $error_key => $error) {
      if (strpos($error_key, $key) === 0) {
        $rows[$key]['class'][] = 'error';
      }
    }
    $row_position++;
  }

  if (empty($rows)) {
    $rows[] = array(array('data' => $form['#empty_text'], 'colspan' => '3'));
  }

  $header = array(
    t('Name'),
    t('Owner'),
  );
  $output = theme('table', array(
    'header' => $header,
    'rows' => $rows,
    'attributes' => array('id' => 'taxonomy'),
  ));
  $output .= drupal_render_children($form);
  $output .= theme('pager');

  return $output;
}

/**
 * Implements hook_form_FORM_ID_alter() for taxonomy_form_vocabulary().
 */
function private_taxonomy_form_taxonomy_form_vocabulary_alter(&$form,
  &$form_state, $form_id) {
  if ($form_state['submitted'] == FALSE) {
    // Add the private field to the Vocabulary edit form.
    $form['private'] = array(
      '#type' => 'checkbox',
      '#title' => t('Private'),
      '#weight' => 1,
      '#description' => t('If enabled, user will be able to manage their own terms and only be able to see their own terms. <strong>Enabling this on an existing vocabulary will associate all existing terms with the enabling user.</strong>'),
    );
    if (array_key_exists('vid', $form)) {
      $vid = $form['vid']['#value'];
      $form['private']['#default_value']
        = private_taxonomy_is_vocabulary_private($vid);
    }
    // Push elements below our added field.
    $form['weight']['#weight'] = 2;
    $form['submit']['#weight'] = 3;
    $form['delete']['#weight'] = 3;
    // Add submit function.
    $form['#submit'][] = 'private_taxonomy_form_vocabulary_submit';
  }
}

/**
 * Form submission handler for taxonomy_form_vocabulary().
 *
 * Sets this vocabulary to be private, if necessary.
 */
function private_taxonomy_form_vocabulary_submit($form, &$form_state) {
  global $user;
  $vid = $form_state['values']['vid'];
  $private = $form_state['values']['private'];
  // we'll only arrive here after hook_taxonomy has been invoked, so even if
  // this vocabulary has just been created, we only need to update our table.
  // we pay for this with an extra DML operation but we gain simplicity.
  $update = db_update('private_vocabularies')
    ->fields(array(
      'private' => $private,
    ))
    ->condition('vid', $vid)
    ->execute();
  if ($private) {
    // Now we need to check if any terms exist for this vocabulary which don't
    // have records in the user_term table.
    $sql = 'SELECT tid FROM {taxonomy_term_data} t
      WHERE NOT EXISTS(SELECT 1 FROM {user_term} u
      WHERE u.tid = t.tid) AND vid = :vid';
    $result = db_query($sql, array(':vid' => $vid));
    foreach ($result as $term) {
      // Associate each term with the current user.
      $entry = db_insert('user_term')
        ->fields(array(
          'uid' => $user->uid,
          'tid' => $term->tid,
        ))
        ->execute();
    }
  }
  else {
    // Remove data for the current vocabulary from the user_term table.
    db_delete('user_term')
      ->where('EXISTS (SELECT 1 FROM {taxonomy_term_data} t WHERE t.tid = {user_term}.tid AND t.vid = :vid)', array(':vid' => $vid))
      ->execute();
  }
}

/**
 * Implements hook_form_alter().
 */
function private_taxonomy_form_alter(&$form, &$form_state, $form_id) {
  // This is left for sites that depend on the old restriction of terms in
  // the core widgets to the user's terms adding and editing content.
  if (!variable_get('private_taxonomy_deprecate', 0) &&
    preg_match('/node_form$/', $form_id)) {

    // Remove other users' terms so only the current user's terms are
    // displayed. This should be deprecated.
    global $user;
    foreach ($form as $key => $value) {
      if (is_array($value) &&
        isset($value['#attributes']['class'][0]) &&
        $value['#attributes']['class'][0] !=
          'field-type-private-taxonomy-term-reference'
        && isset($value['und']['#value_key']) &&
        $value['und']['#value_key'] == 'tid') {

        foreach ($value['und']['#options'] as $tid => $option) {
          if (is_numeric($tid)) {
            if (private_taxonomy_is_term_private($tid) &&
              private_taxonomy_term_get_user($tid) != $user->uid) {
              unset($form[$key]['und']['#options'][$tid]);
            }
          }
        }
      }
    }
  }
}

/**
 * Gets all private vocabularies from the database.
 *
 * Returns all the private vocabularies.
 *
 * @return array
 *   Array of vocabulary objects.
 */
function private_taxonomy_get_private_vocabularies() {
  $private_vocabularies = array();
  $sql = 'SELECT * FROM {taxonomy_vocabulary} v
    INNER JOIN {private_vocabularies} p
    WHERE p.vid = v.vid AND p.private = :private';
  $vocabularies = db_query($sql, array(':private' => 1));
  foreach ($vocabularies as $vocabulary) {
    $private_vocabularies[] = $vocabulary;
  }
  return $private_vocabularies;
}

/**
 * Implements hook_user_insert().
 */
function private_taxonomy_user_insert(&$edit, $account, $category) {
  if (variable_get('private_taxonomy_default_enabled', 0)) {
    private_taxonomy_clone_terms($account);
  }
}

/**
 * Implements hook_user_delete().
 */
function private_taxonomy_user_delete($account) {
  $sql = 'SELECT tid FROM {user_term} WHERE uid = :uid';
  $terms = db_query($sql, array(':uid' => $account->uid));
  foreach ($terms as $term) {
    taxonomy_term_delete($term->tid);
  }
}

/**
 * Installation function for cloning terms.
 *
 * Iterates over all the users other than the anonymous user.
 */
function private_taxonomy_default_taxonomy() {
  $sql = 'SELECT uid FROM {users} WHERE uid>0';
  $accounts = db_query($sql);
  foreach ($accounts as $account) {
    private_taxonomy_clone_terms($account);
  }
}

/**
 * Clone default terms to a user.
 *
 * Retrieves the terms for the default user and clones them for the user.
 *
 * @param object $account
 *   Account of the user for which the terms are to be generated. Must
 *   contain the uid of the user.
 */
function private_taxonomy_clone_terms($account) {
  watchdog('private_taxonomy', 'Cloning terms for :uid',
    array(':uid' => $account->uid));
  $user_name = variable_get('private_taxonomy_user_name', '');
  $sql = 'SELECT uid FROM {users} WHERE name = :name';
  $uid = db_query($sql, array(':name' => $user_name))->fetchField();
  if ($account->uid != $uid) {
    $vocabularies = private_taxonomy_get_private_vocabularies();
    foreach ($vocabularies as $vocabulary) {
      $mapping = array();
      $sql = 'SELECT term_data.tid AS tid
        FROM {taxonomy_term_data} term_data
        LEFT JOIN {user_term} user_term ON term_data.tid=user_term.tid
        WHERE uid = :uid AND vid = :vid';
      $results = db_query($sql,
        array(':uid' => $uid, ':vid' => $vocabulary->vid));
      foreach ($results as $item) {
        $term = taxonomy_term_load($item->tid);
        $term->tid = NULL;
        $term->uid = $account->uid;
        taxonomy_term_save($term);
        $mapping[$item->tid] = $term->tid;
      }
      $sql = 'SELECT term_data.tid AS tid, hierarchy.parent AS parent
        FROM {taxonomy_term_data} term_data
        LEFT JOIN {taxonomy_term_hierarchy} hierarchy
          ON hierarchy.tid=term_data.tid
        LEFT JOIN {user_term} user_term ON term_data.tid=user_term.tid
        WHERE hierarchy.parent != 0 AND uid = :uid AND vid = :vid';
      $results = db_query($sql,
        array(':uid' => $uid, ':vid' => $vocabulary->vid));
      foreach ($results as $item) {
        // Parent may not belong to the same user.
        if (isset($mapping[$item->parent])) {
          $sql = 'UPDATE {taxonomy_term_hierarchy} SET parent=:parent
            WHERE tid=:tid';
          $params = array(
            ':parent' => $mapping[$item->parent],
            ':tid' => $mapping[$item->tid],
          );
          db_query($sql, $params);
        }
      }
    }
  }
}

/**
 * Implements hook_theme().
 */
function private_taxonomy_theme() {
  return array(
    'private_taxonomy_view_terms' => array(
      'render element' => 'form',
    ),
  );
}

/**
 * Implements hook_field_info().
 *
 * Field settings:
 * - allowed_values: a list array of one or more vocabularies:
 *   - vocabulary: a vocabulary machine name.
 *   - user: This should be 'all' if all users' terms are allowed and 'owner'
 *     if just the owner's terms are allowed.
 */
function private_taxonomy_field_info() {
  return array(
    'private_taxonomy_term_reference' => array(
      'label' => t('Private term reference'),
      'description' => t('This field stores a reference to a private taxonomy term.'),
      'default_widget' => 'options_select',
      'default_formatter' => 'private_taxonomy_term_reference_link',
      'settings' => array(
        'allowed_values' => array(
          array(
            'vocabulary' => '',
            'users' => '',
          ),
        ),
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_info_alter().
 */
function private_taxonomy_field_widget_info_alter(&$info) {
  $info['options_select']['field types'][] = 'private_taxonomy_term_reference';
  $info['options_buttons']['field types'][] = 'private_taxonomy_term_reference';
}

/**
 * Implements hook_field_widget_info().
 */
function private_taxonomy_field_widget_info() {
  return array(
    'private_taxonomy_widget_autocomplete' => array(
      'label' => t('Autocomplete private term widget (tagging)'),
      'field types' => array('private_taxonomy_term_reference'),
      'settings' => array(
        'size' => 60,
        'autocomplete_path' => 'private_taxonomy/autocomplete',
      ),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
      ),
    ),
  );
}

/**
 * Implements hook_options_list().
 */
function private_taxonomy_options_list($field, $instance, $entity_type, $entity) {
  $function = !empty($field['settings']['options_list_callback']) ?
    $field['settings']['options_list_callback'] :
    'private_taxonomy_allowed_values';
  return $function($field);
}

/**
 * Returns the set of valid terms for a private taxonomy field.
 *
 * @param array $field
 *   The field definition.
 *
 * @return array
 *   The array of valid terms for this field, keyed by term id.
 */
function private_taxonomy_allowed_values($field) {
  global $user;
  if ($field['settings']['allowed_values'][0]['users'] == 'all') {
    $query = db_select('taxonomy_term_data', 't');
    $query->addTag('translatable');
    $query->addTag('term_access');
    $machine_name = $field['settings']['allowed_values'][0]['vocabulary'];
    $query->join('taxonomy_vocabulary', 'v',
      't.vid = v.vid AND v.machine_name = :machine_name',
      array(':machine_name' => $machine_name));
    $query->join('user_term', 'ut', 't.tid = ut.tid');
    $query->join('users', 'u', 'ut.uid = u.uid');
    $results = $query
      ->fields('t', array('tid', 'name'))
      ->fields('u', array('name'))
      ->execute();
    $options = array();
    foreach ($results as $option) {
      $options[$option->tid] = $option->name .
        ' (' . $option->u_name . ')';
    }
  }
  else {
    $query = db_select('taxonomy_term_data', 't');
    $query->addTag('translatable');
    $query->addTag('term_access');
    $machine_name = $field['settings']['allowed_values'][0]['vocabulary'];
    $query->join('taxonomy_vocabulary', 'v',
      't.vid = v.vid AND v.machine_name = :machine_name',
      array(':machine_name' => $machine_name));
    $query->join('user_term', 'ut', 't.tid = ut.tid AND ut.uid = :uid',
      array(':uid' => $user->uid));
    $options = $query
      ->fields('t', array('tid', 'name'))
      ->execute()
      ->fetchAllKeyed();
  }
  asort($options);
  return $options;
}

/**
 * Implements hook_field_widget_form().
 */
function private_taxonomy_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $tags = array();
  foreach ($items as $item) {
    $tags[$item['tid']] = isset($item['taxonomy_term']) ?
      $item['taxonomy_term'] : taxonomy_term_load($item['tid']);
  }

  $element += array(
    '#type' => 'textfield',
    '#default_value' => taxonomy_implode_tags($tags),
    '#autocomplete_path' => $instance['widget']['settings']['autocomplete_path'] . '/' . $field['field_name'],
    '#size' => $instance['widget']['settings']['size'],
    '#maxlength' => 1024,
    '#element_validate' => array('private_taxonomy_autocomplete_validate'),
  );

  return $element;
}

/**
 * Form element validate handler for private taxonomy term autocomplete.
 */
function private_taxonomy_autocomplete_validate($element, &$form_state) {
  global $user;
  // Autocomplete widgets do not send their tids in the form, so we must detect
  // them here and process them independently.
  $value = array();
  if ($tags = $element['#value']) {
    // Collect candidate vocabularies.
    $field = field_widget_field($element, $form_state);
    $vocabularies = array();
    foreach ($field['settings']['allowed_values'] as $tree) {
      if ($vocabulary
        = taxonomy_vocabulary_machine_name_load($tree['vocabulary'])) {

        $vocabularies[$vocabulary->vid] = $vocabulary;
      }
    }
  }

  // Translate term names into actual terms.
  $typed_terms = drupal_explode_tags($tags);
  $sql = 'SELECT uid FROM {users} WHERE name=:name';
  foreach ($typed_terms as $typed_term) {
    // If term matches term (user) pattern, remove the user name.
    $typed_term = trim($typed_term);
    $length = drupal_strlen($typed_term);
    $pos = strrpos($typed_term, ' (');
    $term_uid = 0;
    if (drupal_substr($typed_term, $length - 1, 1) == ')' && $pos !== FALSE) {
      $owner = drupal_substr($typed_term, $pos + 2, $length - $pos - 3);
      $term_uid = db_query($sql, array(':name' => $owner))->fetchField();
      if ($term_uid) {
        $typed_term = drupal_substr($typed_term, 0, $pos);
      }
    }
    // See if the term exists in the chosen vocabulary and return the tid;
    if ($possibilities = taxonomy_term_load_multiple(array(),
      array('name' => trim($typed_term), 'vid' => array_keys($vocabularies)))) {
      $term = NULL;
      $sql = 'SELECT uid FROM {user_term} WHERE tid=:tid';
      if ($term_uid) {
        foreach ($possibilities as $possibility) {
          $uid = db_query($sql, array(':tid' => $possibility->tid))
            ->fetchField();
          if ($uid == $term_uid) {
            $term = $possibility;
            break;
          }
        }
      }
      else {
        // If one of the possibilities is the user's, select that one.
        foreach ($possibilities as $possibility) {
          $uid = db_query($sql, array(':tid' => $possibility->tid))
            ->fetchField();
          if ($uid == $user->uid) {
            $term = $possibility;
            break;
          }
        }
        // Otherwise, just take the first one.
        if (is_null($term)) {
          if ($field['settings']['allowed_values'][0]['users'] == 'all') {
            $term = array_pop($possibilities);
          }
          else {
            $vocabulary = reset($vocabularies);
            $term = array(
              'tid' => 'autocreate',
              'vid' => $vocabulary->vid,
              'name' => $typed_term,
              'vocabulary_machine_name' => $vocabulary->machine_name,
            );
          }
        }
      }
    }
    else {
      $vocabulary = reset($vocabularies);
      $term = array(
        'tid' => 'autocreate',
        'vid' => $vocabulary->vid,
        'name' => $typed_term,
        'vocabulary_machine_name' => $vocabulary->machine_name,
      );
    }
    $value[] = (array) $term;
  }

  form_set_value($element, $value, $form_state);
}

/**
 * Implements hook_field_settings_form().
 */
function private_taxonomy_field_settings_form($field, $instance, $has_data) {
  // Get proper values for 'allowed_values_function', which is a core setting.
  $vocabularies = taxonomy_get_vocabularies();
  $vocabulary_options = array();
  foreach ($vocabularies as $vocabulary) {
    if (private_taxonomy_is_vocabulary_private($vocabulary->vid)) {
      $vocabulary_options[$vocabulary->machine_name] = $vocabulary->name;
    }
  }
  $users_options = array();
  $users_options['all'] = 'All';
  $users_options['owner'] = 'Owner';
  $form['allowed_values'] = array(
    '#tree' => TRUE,
  );

  foreach ($field['settings']['allowed_values'] as $delta => $tree) {
    $form['allowed_values'][$delta]['vocabulary'] = array(
      '#type' => 'select',
      '#title' => t('Vocabulary'),
      '#default_value' => $tree['vocabulary'],
      '#options' => $vocabulary_options,
      '#required' => TRUE,
      '#description' => t('The private vocabulary which supplies the options for this field.'),
      '#disabled' => $has_data,
    );
    $form['allowed_values'][$delta]['users'] = array(
      '#type' => 'select',
      '#title' => t('Users'),
      '#default_value' => $tree['users'],
      '#options' => $users_options,
      '#required' => TRUE,
      '#description' => t('The user whose terms are allowed to be used.'),
      '#disabled' => $has_data,
    );
  }

  return $form;
}

/**
 * Implements hook_field_is_empty().
 */
function private_taxonomy_field_is_empty($item, $field) {
  if (!is_array($item) || (empty($item['tid']) &&
    (string) $item['tid'] !== 0)) {

    return TRUE;
  }
  return FALSE;
}

/**
 * Return JSON for private taxonomy autocomplete suggestions.
 *
 * This callback outputs term name suggestions in response to AJAX requests
 * made by the private taxonomy autocomplete widget for private taxonomy term
 * reference fields.  The output is a JSON object of plain-text term
 * suggestions, keyed by the user-entered value with the completed term name
 * appended.  Term names containing commas are wrapped in quotes.
 *
 * @param string $field_name
 *   The name of the term reference field.
 * @param string $tags_typed
 *   (optional) A comma-separated list of term names entered in the
 *   autocomplete form element. Only the last term is used for autocompletion.
 *   Defaults to '' (an empty string).
 *
 * @see private_taxonomy_menu()
 * @see private_taxonomy_field_widget_info()
 */
function private_taxonomy_autocomplete($field_name, $tags_typed = '') {
  $field = field_info_field($field_name);
  // The user enters a comma-separated list of tags.  We only autocomplete the
  // last tag.
  $tags_typed = drupal_explode_tags($tags_typed);
  $tag_last = drupal_strtolower(array_pop($tags_typed));

  $matches = array();
  if ($tag_last != '') {
    global $user;
    // Part of the criteria for the query come from the field's own settings.
    $machine = $field['settings']['allowed_values'][0]['vocabulary'];

    $query = db_select('taxonomy_term_data', 't');
    $query->addTag('translatable');
    $query->addTag('term_access');

    // Do not select already entered terms.
    if (!empty($tags_typed)) {
      $query->condition('t.name', $tags_typed, 'NOT IN');
    }
    $query->join('taxonomy_vocabulary', 'v',
      't.vid = v.vid AND v.machine_name = :machine',
      array(':machine' => $machine));
    if ($field['settings']['allowed_values'][0]['users'] == 'all') {
      $query->join('user_term', 'ut', 't.tid = ut.tid');
      $query->join('users', 'u', 'ut.uid = u.uid');
      $results = $query
        ->fields('t', array('tid', 'name'))
        ->fields('u', array('name'))
        ->condition('t.name', '%' . db_like($tag_last) . '%', 'LIKE')
        ->range(0, 10)
        ->execute();
      $tags_return = array();
      foreach ($results as $option) {
        $tags_return[$option->tid] = $option->name .
          ' (' . $option->u_name . ')';
      }
    }
    else {
      $query->join('user_term', 'ut', 't.tid = ut.tid AND ut.uid = :uid',
        array(':uid' => $user->uid));
      $tags_return = $query
        ->fields('t', array('tid', 'name'))
        ->condition('t.name', '%' . db_like($tag_last) . '%', 'LIKE')
        ->range(0, 10)
        ->execute()
        ->fetchAllKeyed();
    }

    $prefix = count($tags_typed) ? drupal_implode_tags($tags_typed) . ', ' : '';

    $term_matches = array();
    foreach ($tags_return as $tid => $name) {
      $n = $name;
      // Term names containing commas or quotes must be wrapped in quotes.
      if (strpos($name, ',') !== FALSE || strpos($name, '"') !== FALSE) {
        $n = '"' . str_replace('"', '""', $name) . '"';
      }

      $term_matches[$prefix . $name] = check_plain($name);
    }
  }

  drupal_json_output($term_matches);
}

/**
 * Implements hook_field_presave().
 *
 * Create any new terms defined in a freetagging vocabulary.
 */
function private_taxonomy_field_presave($entity_type, $entity, $field,
  $instance, $langcode, &$items) {
  foreach ($items as $delta => $item) {
    if ($item['tid'] == 'autocreate') {
      $term = (object) $item;
      unset($term->tid);
      taxonomy_term_save($term);
      $items[$delta]['tid'] = $term->tid;
    }
  }
}

/**
 * Implements hook_field_formatter_info().
 */
function private_taxonomy_field_formatter_info() {
  return array(
    'private_taxonomy_term_reference_link' => array(
      'label' => t('Link'),
      'field types' => array('private_taxonomy_term_reference'),
    ),
    'private_taxonomy_term_reference_plain' => array(
      'label' => t('Plain text'),
      'field types' => array('private_taxonomy_term_reference'),
    ),
    'private_taxonomy_term_reference_rss_category' => array(
      'label' => t('RSS category'),
      'field types' => array('private_taxonomy_term_reference'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function private_taxonomy_field_formatter_view($entity_type, $entity, $field,
  $instance, $langcode, $items, $display) {
  $element = array();

  // Terms whose tid is 'autocreate' do not yet exist yet and
  // $item['taxonomy_term'] is not set.  Theme such terms as just their name.
  switch ($display['type']) {
    case 'private_taxonomy_term_reference_link':
      foreach ($items as $delta => $item) {
        if ($item['tid'] == 'autocreate') {
          $element[$delta] = array(
            '#markup' => check_plain($item['name']),
          );
        }
        else {
          $term = $item['taxonomy_term'];
          $uri = entity_uri('taxonomy_term', $term);
          $element[$delta] = array(
            '#type' => 'link',
            '#title' => $term->name,
            '#href' => $uri['path'],
            '#options' => $uri['options'],
          );
        }
      }
      break;

    case 'private_taxonomy_term_reference_plain':
      foreach ($items as $delta => $item) {
        $name = ($item['tid'] != 'autocreate' ? $item['taxonomy_term']->name : $item['name']);
        $element[$delta] = array(
          '#markup' => check_plain($name),
        );
      }
      break;

    case 'private_taxonomy_term_reference_rss_category';
      foreach ($items as $delta => $item) {
        $entity->rss_elements[] = array(
          'key' => 'category',
          'value' => $item['tid'] != 'autocreate' ? $item['taxonomy_term']->name : $item['name'],
          'attributes' => array(
            'domain' => $item['tid'] != 'autocreate' ? url('taxonomy/term/' . $item['tid'], array('absolute' => TRUE)) : '',
          ),
        );
      }
      break;
  }

  return $element;
}

/**
 * Implements hook_field_formatter_prepare_view().
 *
 * This preloads all taxonomy terms for multiple loaded objects at once and
 * unsets values for invalid terms that do not exist.
 */
function private_taxonomy_field_formatter_prepare_view($entity_type,
  $entities, $field, $instances, $langcode, &$items, $displays) {
  $tids = array();

  // Collect every possible term attached to any of the fieldable entities.
  foreach ($entities as $id => $entity) {
    foreach ($items[$id] as $delta => $item) {
      // Force the array key to prevent duplicates.
      if ($item['tid'] != 'autocreate') {
        $tids[$item['tid']] = $item['tid'];
      }
    }
  }
  if ($tids) {
    $terms = taxonomy_term_load_multiple($tids);

    // Iterate through the fieldable entities again to attach the loaded term
    // data.
    foreach ($entities as $id => $entity) {
      $rekey = FALSE;

      foreach ($items[$id] as $delta => $item) {
        // Check whether the taxonomy term field instance value could be loaded.
        if (isset($terms[$item['tid']])) {
          // Replace the instance value with the term data.
          $items[$id][$delta]['taxonomy_term'] = $terms[$item['tid']];
        }
        // Terms to be created are not in $terms, but are still legitimate.
        elseif ($item['tid'] == 'autocreate') {
          // Leave the item in place.
        }
        // Otherwise, unset the instance value, since the term does not exist.
        else {
          unset($items[$id][$delta]);
          $rekey = TRUE;
        }
      }

      if ($rekey) {
        // Rekey the items array.
        $items[$id] = array_values($items[$id]);
      }
    }
  }
}

/**
 * Implements hook_node_insert().
 */
function private_taxonomy_node_insert($node) {
  // Add taxonomy index entries for the node.
  private_taxonomy_build_node_index($node);
}

/**
 * Implements hook_node_update().
 */
function private_taxonomy_node_update($node) {
  // Always rebuild the node's taxonomy index entries on node save.
  // Taxonomy's delete function should work but the build specifically checks
  // for taxonomy fields and does not work.
  private_taxonomy_build_node_index($node);
}

/**
 * Implements hook_module_implements_alter().
 */
function private_taxonomy_module_implements_alter(&$module_list, $context) {
  // We need to have the core taxonomy update first so it does the delete
  // before the insert.
  if ($context === "node_update") {
    $temp = $module_list['private_taxonomy'];
    unset($module_list['private_taxonomy']);
    $module_list['private_taxonomy'] = $temp;
  }
}

/**
 * Builds and inserts taxonomy index entries for a given node.
 *
 * The index lists all terms that are related to a given node entity, and is
 * therefore maintained at the entity level.
 *
 * This is a copy of the function in the core taxonomy module.
 *
 * @param object $node
 *   The node object.
 */
function private_taxonomy_build_node_index($node) {
  // We maintain a denormalized table of term/node relationships, containing
  // only data for current, published nodes.
  $status = NULL;
  if (variable_get('taxonomy_maintain_index_table', TRUE)) {
    // If a node property is not set in the node object when node_save() is
    // called, the old value from $node->original is used.
    if (!empty($node->original)) {
      $status = (int) (!empty($node->status) || (!isset($node->status) &&
        !empty($node->original->status)));
      $sticky = (int) (!empty($node->sticky) || (!isset($node->sticky) &&
        !empty($node->original->sticky)));
    }
    else {
      $status = (int) (!empty($node->status));
      $sticky = (int) (!empty($node->sticky));
    }
  }
  // We only maintain the taxonomy index for published nodes.
  if ($status) {
    // Collect a unique list of all the term IDs from all node fields.
    $tid_all = array();
    foreach (field_info_instances('node', $node->type) as $instance) {
      $field_name = $instance['field_name'];
      $field = field_info_field($field_name);
      if ($field['module'] == 'private_taxonomy' &&
        $field['storage']['type'] == 'field_sql_storage') {

        // If a field value is not set in the node object when node_save() is
        // called, the old value from $node->original is used.
        if (isset($node->{$field_name})) {
          $items = $node->{$field_name};
        }
        elseif (isset($node->original->{$field_name})) {
          $items = $node->original->{$field_name};
        }
        else {
          continue;
        }
        foreach (field_available_languages('node', $field) as $langcode) {
          if (!empty($items[$langcode])) {
            foreach ($items[$langcode] as $item) {
              $tid_all[$item['tid']] = $item['tid'];
            }
          }
        }
      }
    }
    // Insert index entries for all the node's terms.
    if (!empty($tid_all)) {
      $query = db_insert('taxonomy_index')
        ->fields(array('nid', 'tid', 'sticky', 'created'));
      foreach ($tid_all as $tid) {
        $query->values(array(
          'nid' => $node->nid,
          'tid' => $tid,
          'sticky' => $sticky,
          'created' => $node->created,
        ));
      }
      $query->execute();
    }
  }
}

/**
 * Implements hook_views_api().
 */
function private_taxonomy_views_api() {
  return array(
    'api' => 3,
  );
}

/**
 * Return edit access for a given term.
 */
function private_taxonomy_term_edit_access($term) {
  global $user;
  if (private_taxonomy_is_vocabulary_private($term->vid) &&
    private_taxonomy_term_get_user($term->tid) == $user->uid &&
    user_access("edit own terms in $term->vid")) {

    return TRUE;
  }
  return user_access("edit terms in $term->vid") ||
    user_access('administer taxonomy');
}

/**
 * Implements hook_form_FORM_ID_alter() for taxonomy_form_term().
 */
function private_taxonomy_form_taxonomy_form_term_alter(&$form, &$form_state,
  $form_id) {

  global $user;
  if ($form['tid']['#value'] && isset($form['actions']['delete']['#access']) &&
    !$form['actions']['delete']['#access']) {

    $vid = $form['vid']['#value'];
    if (private_taxonomy_is_vocabulary_private($vid) &&
      private_taxonomy_term_get_user($form['tid']['#value']) == $user->uid &&
      user_access("delete own terms in $vid")) {

      $form['actions']['delete']['#access'] = TRUE;
    }
  }
}

/**
 * Implements hook_features_api().
 */
function private_taxonomy_features_api() {
  $components = array();

  $components['private_vocabulary'] = array(
    'name' => t('Private Vocabulary'),
    'default_hook' => 'private_vocabulary_default_vocabularies',
    'default_file' => FEATURES_DEFAULTS_INCLUDED,
    'file' => drupal_get_path('module', 'private_taxonomy') . '/private_taxonomy.features.inc',
  );

  if (module_exists('uuid')) {
    $components['private_term'] = array(
      'name' => t('Private Taxonomy Term'),
      'feature_source' => TRUE,
      'default_hook' => 'private_term_default_terms',
      'default_file' => FEATURES_DEFAULTS_INCLUDED,
      'file' => drupal_get_path('module', 'private_taxonomy') . '/private_taxonomy.features.inc',
    );
  }

  return $components;
}
