<?php
/**
 * @file
 * Base module file for rebuild_more
 *
 * @defgroup rebuild_more Rebuild More
 * @{
 */

/**
 * Default value for max nodes per single batch.
 */
define('REBUILD_MORE_BATCH_SIZE', 10000);

/**
 * @var REBUILD_MORE_CHUNK_SIZE
 *
 * How many nodes will be rebuilt each batch run?
 */
define('REBUILD_MORE_CHUNK_SIZE', 100);

// Path to the admin settings form
define('REBUILD_MORE_URL_SETTINGS', 'admin/config/system/rebuild-more');

/**
 * Default number of seconds for drupal_set_time_limit during a batch rebuild.
 */
define('REBUILD_MORE_TIME_LIMIT', 240);

/**
 * Implements hook_menu().
 */
function rebuild_more_menu() {
  $items = array();

  $items[REBUILD_MORE_URL_SETTINGS] = array(
   'title' => 'Rebuild More',
   'description' => 'Administer module configuration settings',
   'page callback' => 'drupal_get_form',
   'page arguments' => array('rebuild_more_admin_settings'),
   'file' => rebuild_more_include('admin', 2),
   'access arguments' => array('rebuild_more:administer'),
   'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * Include (or return include path to) a rebuild_more include file(s)
 *
 * @code
 *   'file' => rebuild_more_include('pages', 2),
 * @endcode
 *
 * @param... string
 *   Any number of include file keys to include
 *   For includes/rebuild_more.example.inc, set this to: example
 * @param int $action
 *   The final argument, if numeric is one of.  If omitted 1 is the default.
 *   1: include the module(s)
 *   2: return the path relative to the module, e.g., hook_menu()
 *   3: return the complete Drupal path per drupal_get_path()
 *   4: return the complete Drupal path to the includes folder, e.g. hook_views_api() call it like this: rebuild_more_include(4),
 *
 * @return string
 *   The path to the FIRST include file requested, but only if $return is set to TRUE
 */
function rebuild_more_include() {
  $includes = func_get_args();
  if (is_numeric(end($includes))) {
    $action = array_pop($includes);
  }
  else {
    $action = 1;
  }
  if ($action > 1) {
    $module = 'includes/rebuild_more.' .  reset($includes) . '.inc';
    switch ($action) {
      case 3:
        $module = drupal_get_path('module', 'rebuild_more') . '/' . $module;
        break;
      case 4:
        $module = drupal_get_path('module', 'rebuild_more') . '/includes';
        break;
    }
    return $module;
  }
  reset($includes);
  foreach ($includes as $include_name) {
    module_load_include('inc', 'rebuild_more', 'includes/rebuild_more.' . $include_name);
  }
}

/**
 * Implements hook_form_alter().
 */
function rebuild_more_form_node_configure_rebuild_confirm_alter(&$form, $form_state) {
  $node_types = node_type_get_names();
  $form['advanced'] = array(
    '#type' => 'fieldset',
    '#title' => t('Advanced Options'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  if (!count(module_implements('node_grants'))) {
    $form['advanced']['no_implement'] = array(
      '#markup' => t('There are no modules implementing <a href="@url">hook_node_grants</a>, therefore advanced options are disabled.', array(
        '@url' => 'http://api.drupal.org/api/drupal/modules!node!node.api.php/function/hook_node_grants',
      )),
    );
  }

  // We add our options if any modules implement node_grants
  else {
    $options = variable_get('rebuild_more_options', array()) + array(
      'purge' => TRUE,
      'types' => array_keys($node_types),
      'nids' => '',
      'parallelization' => 'all',
    );
    $form['advanced']['purge'] = array(
      '#type' => 'checkbox',
      '#title' => t('Purge all records first?'),
      '#description' => t('By default, drupal core will empty all node permissions at the beginning of this process (purge).  For sites with many nodes (10k+) this means that node access is denied for all nodes for the duration of the time it takes to get to said node in the rebuild process.  If your rebuild takes several hours, this can have negative effects on the user.  <strong>Uncheck this box and the node permission will not be deleted until right before it is rebuilt.</strong> If your permissions are highly corrupt, and you are concerned with security you might want to check this box.'),
      '#default_value' => $options['purge'],
    );
    $form['advanced']['types'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Node types to rebuild'),
      '#default_value' => $options['types'],
      '#options' => $node_types,
      '#description' => t('Choose all the node types you want to process.'),
    );
    $items = array(
      t('<strong>For individual nodes:</strong> Enter a list of nids (space or comma separated), e.g. <strong>100 101 102</strong>'),
      t('<strong>For a range of nids:</strong> Enter min and max separated by a hyphen, e.g. <strong>100-200</strong>'),
      t('<strong>For greater/less than:</strong> Enter like this: <strong>>100</strong> or <strong><100</strong> or <strong>>=100</strong> or <strong><=100</strong>'),
    );
    $form['advanced']['nids'] = array(
      '#type' => 'textarea',
      '#title' => t('NIDS'),
      '#default_value' => (string) $options['nids'],
      '#description' => theme("item_list", array('items' => $items)),
      '#rows' => 3,
    );

    // For parallel browser windows
    $form['advanced']['parallelization'] = array(
      '#type' => 'fieldset',
      '#title' => t('Parallelization'),
      '#collapsible' => TRUE,
      '#collapsed' => $options['parallelization'] === 'all',
    );
    $form['advanced']['parallelization']['parallelization'] = array(
      '#type' => 'radios',
      '#title' => t('Node selection'),
      '#default_value' => $options['parallelization'],
      '#options' => array(
        'all' => t('All'),
        'even' => t('Even NIDs only'),
        'odd' => t('Odd NIDS only'),
      ),
      '#description' => t('For large volumes of nodes, <a href="!url" target="_blank">open a second browser window</a>, set one to even and on to odd for parallel processing, and a shorter execution duration.', array(
          '!url' => url(current_path()), 
        )),
    );


    $index = array_search('node_configure_rebuild_confirm_submit', $form['#submit']);

    if (empty($form['#validate'])) {
      $form['#validate'] = array();
    }
    array_unshift($form['#validate'], 'rebuild_more_validate');
    $form['#submit'][$index] = 'rebuild_more_submit';
  }
}

/**
 * Form validation handler for rebuild_more_validate().
 */
function rebuild_more_validate($form, &$form_state) {
  if (!empty($form_state['values']['nids'])) {
    // Determine how the nids are represented
    if (($nids = trim($form_state['values']['nids'])) &&
        !($conditions = _rebuild_more_nid_conditions($nids))) {
      form_set_error('nids', t('Invalid format for nids; please see description below textfield for proper format.'));
    }
  }
}

/**
 * Build the nid conditions from the nids string
 *
 * @param string $nids
 *
 * @return array
 *   Three elements fit for ->condition()
 */
function _rebuild_more_nid_conditions($string) {
  $conditions = array();
  if (preg_match('/^([><]=?)(\d+)$/', $string, $found)) {
    $conditions[] = array('nid', $found[2], $found[1]);
  }
  elseif (preg_match('/^(\d+)\-(\d+)$/', $string, $found)) {
    $conditions[] = array('nid', $found[1], '>=');
    $conditions[] = array('nid', $found[2], '<=');
  }
  elseif (preg_match_all('/(\d+)[, ]?/', $string, $found)) {
    $in = array();
    foreach ($found[1] as $nid) {
      $in[] = $nid;
    }
    $conditions[] = array('nid', $in, 'IN');
  }
  return $conditions;
}


/**
 * Handler for wipe confirmation
 */
function rebuild_more_submit($form, &$form_state) {
  $options = array(
    'purge' => (bool) $form_state['values']['purge'],
    'nids' => $form_state['values']['nids'],
    'types' => array_filter($form_state['values']['types']),
    'parallelization' => $form_state['values']['parallelization'],
  );
  variable_set('rebuild_more_options', $options);
  rebuild_more_rebuild(TRUE, $options);
  $form_state['redirect'] = 'admin/reports/status';
}

/**
 * Make the necessary adjustments to memory and time limits based on settings.
 */
function _rebuild_more_ini_set() {
  drupal_set_time_limit(variable_get('rebuild_more_time_limit', REBUILD_MORE_TIME_LIMIT));

  if ($limit = variable_get('rebuild_more_memory_limit', FALSE)) {
    ini_set('memory_limit', $limit);
  }  
}

/**
 * Performs the grant processing on a single NID.
 *
 * @param  int $nid
 */
function _rebuild_more_rebuild_node($nid) {
  // To preserve database integrity, only acquire grants if the node
  // loads successfully.
  if (($node = node_load($nid, NULL, TRUE)) &&
    isset($node->nid) &&
    $node->nid == $nid) {
    node_access_acquire_grants($node);
  }
}

/**
 * Return the EXECUTED select query based on options
 *
 * @param array $options
 * - nids
 * - types
 *
 * @return object SelectQuery
 */
function _rebuild_more_db_select($options = array()) {
  $query = db_select('node', 'n')
    ->fields('n', array('nid'));
  if ($conditions = _rebuild_more_nid_conditions($options['nids'])) {
    foreach ($conditions as $value) {
      list($a1, $a2, $a3) = $value;
      $query->condition($a1, $a2, $a3);
    }
  }
  if ($options['types']) {
    $query->condition('type', $options['types'], 'IN');
  }
  if (($p = $options['parallelization']) !== 'all') {
    $query->where('MOD(nid, 2) = :value', array(':value' => $p === 'even' ? 0 : 1));
  }

  return $query->execute();
}

/**
 * Delete node access records for multiple nids.
 *
 * @param array $nids
 */
function _rebuild_more_db_delete($nids) {
  if ($nids) {
    db_delete('node_access')
    ->condition('nid', $nids, 'IN')
    ->execute();
  }
}


/**
 * Rebuild the node access database. This is occasionally needed by modules
 * that make system-wide changes to access levels.
 *
 * When the rebuild is required by an admin-triggered action (e.g module
 * settings form), calling node_access_needs_rebuild(TRUE) instead of
 * node_access_rebuild() lets the user perform his changes and actually
 * rebuild only once he is done.
 *
 * Note : As of Drupal 6, node access modules are not required to (and actually
 * should not) call node_access_rebuild() in hook_enable/disable anymore.
 *
 * @see node_access_needs_rebuild()
 *
 * @param $batch_mode
 *   Set to TRUE to process in 'batch' mode, spawning processing over several
 *   HTTP requests (thus avoiding the risk of PHP timeout if the site has a
 *   large number of nodes).
 *   hook_update_N and any form submit handler are safe contexts to use the
 *   'batch mode'. Less decidable cases (such as calls from hook_user,
 *   hook_taxonomy, etc...) might consider using the non-batch mode.
 * @param array $options
 *   - purge: bool Erase all records from node_access at start of process
 *   - nids: array of nids to limit the rebuild
 *   - types: array of node types to limit the rebuild
 */
function rebuild_more_rebuild($batch_mode = FALSE, $options = array()) {
  _rebuild_more_ini_set();

  // Default options
  $options += array(
    'purge' => TRUE,
    'nids' => array(),
    'types' => array(),
    'parallelization' => 'all',
  );

  // CUSTOM GRANTS USING NODE_GRANT MODULES.
  //
  //Only recalculate if the site is using a node_access module.
  if (count(module_implements('node_grants'))) {

    // Preprocess and get our list of nids.
    $nids = _rebuild_more_db_select($options)->fetchCol();

    // Purge first if asked.
    if ($options['purge']) {
      _rebuild_more_db_delete($nids);
    }    
    
    // Set up batches or run as one batch.
    if ($batch_mode) {
      $batch = array(
        'title' => t('Rebuilding content access permissions for @nodes.%parallelization', array(
          '@nodes' => format_plural(count($nids), '1 node', '@count nodes'),
          '%parallelization' => $options['parallelization'] === 'all' ? '' : ' (' . strtoupper($options['parallelization']) . ' NIDs)',
        )),
        'operations' => array(),
        'progress_message' => 'Elapsed time: @elapsed &dash; Estimated wait: @estimate<br />Batch progress: completed @current of @total.',
        'finished' => '_rebuild_more_rebuild_finished'
      );
      
      // Chunk our nids into separate batch operations.
      $batches = array_chunk($nids, variable_get('rebuild_more_batch_size', REBUILD_MORE_BATCH_SIZE), TRUE);
      foreach ($batches as $batch_nids) {
        $batch['operations'][] = array('_rebuild_more_rebuild', array($batch_nids, count($nids), $options));
      }
      batch_set($batch);
    }

    // Not in batch mode.
    else {     
      foreach ($nids as $nid) {
        _rebuild_more_rebuild_node($nid);
      }
    }
  }

  // DEFAULT GRANTS.
  //
  //Not using any node_access modules. Add the default grant.
  else {
    db_delete('node_access')->execute();
    db_insert('node_access')
      ->fields(array(
        'nid' => 0,
        'realm' => 'all',
        'gid' => 0,
        'grant_view' => 1,
        'grant_update' => 0,
        'grant_delete' => 0,
      ))
      ->execute();
  }

  if (!isset($batch)) {
    _rebuild_more_rebuild_finished(TRUE, array(), NULL);
  }
}

/**
 * Batch callback operation for media indexing
 *
 * @param array $context
 */
function _rebuild_more_rebuild($nids, $grand_total, $options, &$context) {
  _rebuild_more_ini_set();

  $context['message'] = array();

  /**
   * Initialize the batch process and vars
   */
  if (!isset($context['sandbox']['progress'])) {
    $context['sandbox']['options'] = $options;
    $context['sandbox']['nids'] = $nids;

    // This is the number of runs complete in the batch
    $context['sandbox']['progress'] = 0;

    // This is the total number of runs in the batch
    $context['sandbox']['max'] = count($context['sandbox']['nids']);

    //this var holds the decimal fraction of percentage complete; when this is 1
    //the batch is complete
    $context['finished'] = empty($context['sandbox']['nids']);

    // Appears below the status message
    $context['results'] = array();

    // If we're not finished go ahead and process first run
    if ($context['finished']) {
      return;
    }
  }

  /**
   * Do the actual work of this run
   */
  $chunk = variable_get('rebuild_more_chunk_size', REBUILD_MORE_CHUNK_SIZE);
  for ($i = 0; $i < $chunk; ++$i) {
    if (empty($context['sandbox']['nids'])) {
      break;
    }
    $nid = array_shift($context['sandbox']['nids']);
    _rebuild_more_rebuild_node($nid);
  }
  $context['sandbox']['progress'] = $context['sandbox']['max'] - count($context['sandbox']['nids']);

  /**
   * Measure if we're done
   */
  $context['finished'] = empty($context['sandbox']['nids']);
  if ($context['finished']) {
    $context['message'][] = t('This batch is complete.');
  }
  else {
    $context['message'][]= t('@count remaining in this batch.', array(
      '@count' => format_plural($context['sandbox']['max'] - $context['sandbox']['progress'], '1 record', '@count records'),
    ));
  }
  $context['message'] = implode(' <br /> ', $context['message']);
}

/**
 * Post-processing for rebuild_more_rebuild_batch.
 */
function _rebuild_more_rebuild_finished($success, $results, $operations) {
  if ($success) {
    drupal_set_message(t('The content access permissions have been rebuilt.'));
    node_access_needs_rebuild(FALSE);
  }
  else {
    drupal_set_message(t('The content access permissions have not been properly rebuilt.'), 'error');
  }
  cache_clear_all();
}
