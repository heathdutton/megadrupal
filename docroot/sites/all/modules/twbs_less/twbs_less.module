<?php

/**
 * @file
 * LESS support for Drupal.
 */

/**
 * Implements hook_help().
 */
function twbs_less_help($path, $arg) {
  $output = '';

  switch ($path) {
  case 'admin/help#twbs_less':
    return '<p>' . t('The dynamic stylesheet language.') . '</p>';
  }

  return $output;
}

/**
 * Implements hook_init().
 */
function twbs_less_init() {
  drupal_load('module', 'libraries');

  $libraries = twbs_less_libraries_info();
  foreach ($libraries as $name => $info) {
    libraries_load($name);
  }
}

/**
 * Implements hook_libraries_info().
 */
function twbs_less_libraries_info() {
  $libraries['less.js'] = array(
    'name' => 'less.js',
    'version' => '1.5.1',
    'vendor url' => 'http://lesscss.org/',
    'download url' => 'https://github.com/less/less.js/archive/v1.5.1.zip',
    'version arguments' => array(
      'file' => 'dist/less-1.5.1.min.js',
      'pattern' => '/LESS - Leaner CSS v([0-9a-zA-Z\.-]+)/',
    ),
    'files' => array(
      'js' => array(
        'inline' => array(
          'type' => 'inline',
          'data' => 'less = { env: "development", dumpLineNumbers: "all" };',
          'every_page' => TRUE,
          'group' => JS_LIBRARY,
          'weight' => 0,
        ),
        'dist/less-1.5.1.min.js' => array(
          'every_page' => TRUE,
          'group' => JS_LIBRARY,
          'weight' => 0.0001,
        ),
      ),
    ),
  );

  $libraries['less.php'] = array(
    'name' => 'less.php',
    'version' => '1.5.1.1',
    'vendor url' => 'http://lessphp.gpeasy.com/',
    'download url' => 'https://github.com/oyejorge/less.php/releases/download/v1.5.1.1/less.php_1.5.1.1.zip',
    'version arguments' => array(
      'file' => 'Less.php',
      'pattern' => '/const version = \'([0-9a-zA-Z\.-]+)\'/',
      'lines' => 50,
    ),
    'files' => array(
      'php' => array(
        'Less.php',
      ),
    ),
  );

  return $libraries;
}

/**
 * Implements hook_css_alter().
 */
function twbs_less_css_alter(&$css) {
  // Checks all LESS files currently added via drupal_add_css() and checks to
  // see if a related RTL LESS file should be included.
  // @see locale_css_alter().
  if ($GLOBALS['language']->direction == LANGUAGE_RTL) {
    foreach ($css as $key => $value) {
      if ($value['type'] == 'file') {
        $rtl_path = str_replace('.less', '-rtl.less', $value['data']);
        if (file_exists($rtl_path) && !isset($css[$rtl_path])) {
          $value['data'] = $rtl_path;
          $value['weight'] += 0.0001;
          $css[$rtl_path] = $value;
        }
      }
    }
  }

  // If Drupal CSS aggregation disable, set LESS as external and link with its
  // absolute URL, so will not group with @import and able to preform
  // client-side compile by less.js.
  if (!variable_get('preprocess_css', FALSE)) {
    foreach ($css as $key => $value) {
      if ($value['type'] == 'file') {
        if (preg_match('/\.less$/', $value['data'])) {
          $css[$key]['type'] = 'external';
          $css[$key]['data'] = file_create_url($value['data']);
        }
      }
    }
  }
}

/**
 * Implements hook_element_info_alter().
 */
function twbs_less_element_info_alter(&$type) {
  if (isset($type['styles'])) {
    // If Drupal CSS aggregation enabled, we should pre-compile .less into .css
    // before normal drupal_pre_render_styles().
    if (variable_get('preprocess_css', FALSE)) {
      array_unshift($type['styles']['#pre_render'], 'twbs_less_pre_render_styles');
    }
    // If Drupal CSS aggregation disable, we should alter .less rel after normal
    // drupal_pre_render_styles().
    else {
      array_push($type['styles']['#pre_render'], 'twbs_less_pre_render_styles');
    }
  }
}

/**
 * #pre_render callback for .less support.
 */
function twbs_less_pre_render_styles($elements) {
  // If Drupal CSS aggregation enabled, all .less will automatically convert as
  // .css before Drupal CSS aggregation.
  if (variable_get('preprocess_css', FALSE)) {
    foreach ($elements['#items'] as $key => $value) {
      if ($value['type'] == 'file') {
        $output_file = NULL;
        $output_data = NULL;

        // Use md5_file() as new filename seed.
        if (preg_match('/^.*\.less$/', $value['data']) && file_exists($value['data'])) {
          $md5_file = md5_file($value['data']);
          $output_file = 'public://css/css_' . drupal_hash_base64($md5_file) . '.css';
        }

        // If file not exists compile it with lessc().
        if (isset($output_file) && !file_exists($output_file)) {
          try {
            $parser = new Less_Parser();
            $parser->parseFile($value['data']);
            $output_data = $parser->getCss();
          }
          catch (Exception $e) {
            $message = 'TWBS LESS error: @message, %input_file';
            $message_vars = array('@message' => $e->getMessage(), '%input_file' => $input_file);
            watchdog('TWBS', $message, $message_vars, WATCHDOG_ERROR);
          }
        }

        // Anchor all paths in the CSS with its base URL, ignoring
        // external and absolute paths.
        // @see drupal_build_css_cache().
        if (isset($output_data)) {
          $css_base_url = file_create_url($value['data']);
          $css_base_url = substr($css_base_url, 0, strrpos($css_base_url, '/'));
          if (substr($css_base_url, 0, strlen($GLOBALS['base_root'])) == $GLOBALS['base_root']) {
            $css_base_url = substr($css_base_url, strlen($GLOBALS['base_root']));
          }
          _drupal_build_css_path(NULL, $css_base_url . '/');
          $output_data = preg_replace_callback(
            '/url\(\s*[\'"]?(?![a-z]+:|\/+)([^\'")]+)[\'"]?\s*\)/i',
            '_drupal_build_css_path',
            $output_data
          );

          file_unmanaged_save_data($output_data, $output_file, FILE_EXISTS_REPLACE);
        }

        // Replace original .less into new .css.
        if (isset($output_file) && file_exists($output_file)) {
          $elements['#items'][$key]['data'] = $output_file;
        }
      }
    }
  }
  // If Drupal CSS aggregation disabled, all .less will link with rel set to
  // "stylesheel/less" individually, so less.js will handle with client-side
  // compile.
  else {
    foreach ($elements as $key => $value) {
      if (isset($value['#tag'])
        && $value['#tag'] == 'link'
        && preg_match('/\.less$/', $value['#attributes']['href'])
      ) {
        $elements[$key]['#attributes']['rel'] = 'stylesheet/less';
      }
    }
  }

  return $elements;
}
