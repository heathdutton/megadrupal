<?php
/**
 * @file
 * Main module file for the Commerce ePDQ Payment module.
 */

/**
 * Implements hook_menu().
 */
function commerce_epdq_menu() {
  $items = array();

  // The ePDQ callback URL. Access is public, but checked via HTTP Basic
  // authentication inside the callback.
  $items['commerce-epdq/response'] = array(
    'page callback' => 'commerce_epdq_process_response',
    'page arguments' => array(),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  // A page which simply allows a second form redirect to be made to the
  // ePDQ CPI. This is a workaround, needed because the ePDQ "allowed URL"
  // cannot be dynamic, but Commerce  redirects to payment via a dynamic menu
  // callback (checkout/%commerce_order/payment).
  $items['commerce-epdq/pay'] = array(
    'title' => 'Payment',
    'page callback' => 'commerce_epdq_jump_page',
    'access arguments' => array('access checkout'),
    'type' => MENU_CALLBACK,
  );

  // The site-wide settings form. Other configuration can be found in the action
  // settings for the payment method rule.
  $items['admin/commerce/config/epdq'] = array(
    'title' => 'ePDQ settings',
    'description' => 'Configure site-wide settings for the Barclaycard ePDQ payment gateway integration.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_epdq_config'),
    'access arguments' => array('administer commerce epdq settings'),
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * Implements hook_commerce_payment_method_info().
 *
 * Inform Commerce about the ePDQ payment method.
 */
function commerce_epdq_commerce_payment_method_info() {
  $payment_methods = array();

  $payment_methods['epdq'] = array(
    'base' => 'commerce_epdq',
    'title' => t('Barclaycard ePDQ'),
    'short_title' => t('ePDQ'),
    'display_title' => variable_get('commerce_epdq_title', t('Credit or debit card via Barclays ePDQ')),
    'description' => t('Redirect to the Barclaycard ePDQ payment gateway.'),
    'terminal' => FALSE,
    'offsite' => TRUE,
    'offsite_autoredirect' => TRUE,
  );

  return $payment_methods;
}

/**
 * Load the default payment method settings.
 *
 * @see commerce_epdq_settings_form()
 */
function _commerce_epdq_default_settings() {
  return array(
    'mid' => '',
    'epdq_cpi_logo' => '',
    'epdq_url' => 'https://secure2.epdq.co.uk/cgi-bin/CcxBarclaysEpdq.e',
    'epdq_enc_url' => 'https://secure2.epdq.co.uk/cgi-bin/CcxBarclaysEpdqEncTool.e',
    'epdq_passphrase' => '',
    'epdq_merchant_display_name' => variable_get('site_name'),
    'epdq_mandate_csc' => 'yes',
  );
}

/**
 * Implements hook_permission().
 */
function commerce_epdq_permission() {
  return array(
    'administer commerce epdq settings' => array(
      'title' => t('Administer site-wide Commerce ePDQ settings'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_commerce_order_state_info().
 */
function commerce_epdq_commerce_order_state_info() {
  $order_states = array();
  $order_states['epdq_failed'] = array(
    'name' => 'epdq_failed',
    'title' => t('Payment failed'),
    'description' => t('Payment was attempted via Commerce ePDQ, but the payment failed.'),
    'default_status' => 'epdq_failed',
    'weight' => 20,
  );
  $order_states['paid'] = array(
    'name' => 'paid',
    'title' => t('Paid'),
    'description' => t('The order is paid in full.'),
    'default_status' => 'paid',
    'weight' => 30,
  );
  return $order_states;
}

/**
 * Implements hook_commerce_order_status_info().
 */
function commerce_epdq_commerce_order_status_info() {
  $order_statuses = array();

  // The customer was sent to ePDQ for payment.
  $order_statuses['epdq_processing'] = array(
    'name' => 'epdq_processing',
    'title' => t('Processing (Barclaycard ePDQ)'),
    'state' => 'pending',
  );

  // The customer was sent to ePDQ for payment but nothing has since happened
  // for a while.
  $order_statuses['epdq_abandoned'] = array(
    'name' => 'epdq_abandoned',
    'title' => t('Abandoned'),
    'state' => 'canceled',
  );

  // A payment was attempted through ePDQ but failed.
  $order_statuses['epdq_failed'] = array(
    'name' => 'epdq_failed',
    'title' => t('Payment failed'),
    'state' => 'epdq_failed',
  );

  // A payment was made through ePDQ but the order balance is greater than 0.
  $order_statuses['epdq_incomplete'] = array(
    'name' => 'epdq_incomplete',
    'title' => t('Incomplete'),
    'state' => 'pending',
  );

  // A successful payment was attempted through ePDQ.
  $order_statuses['paid'] = array(
    'name' => 'paid',
    'title' => t('Paid'),
    'state' => 'paid',
  );

  return $order_statuses;
}

/**
 * Implements hook_rules_event_info().
 */
function commerce_epdq_rules_event_info() {
  $events = array();
  $events['commerce_epdq_payment_failed'] = array(
    'label' => t('ePDQ payment failed'),
    'group' => t('Commerce ePDQ'),
    'variables' => array(
      'commerce_order' => array(
        'type' => 'commerce_order',
        'label' => t('Failed order', array(), array('context' => 'a drupal commerce order')),
      ),
    ),
    'access callback' => 'commerce_order_rules_access',
  );
  return $events;
}

/**
 * The site-wide settings form for the module.
 */
function commerce_epdq_config($form, &$form_state) {
  $form = array();

  $form['commerce_epdq_title'] = array(
    '#type' => 'textfield',
    '#title' => t('Payment method title'),
    '#description' => t('The method title that appears on the payment selection page.'),
    '#default_value' => variable_get('commerce_epdq_title', t('Credit or debit card via Barclays ePDQ')),
    '#required' => TRUE,
    '#size' => 30,
  );

  $form['commerce_epdq_cpi_auth_user'] = array(
    '#type' => 'textfield',
    '#title' => t('CPI response username'),
    '#size' => 10,
    '#max_length' => 20,
    '#default_value' => variable_get('commerce_epdq_cpi_auth_user', 'epdq'),
  );

  $current_password_hash = variable_get('commerce_epdq_cpi_auth_pw');

  $form['commerce_epdq_cpi_auth_pw'] = array(
    '#type' => 'password',
    '#title' => t('CPI response password'),
    '#description' => t('The password which ePDQ has to provide to the response URL.'),
    '#required' => TRUE,
    '#size' => 10,
    '#max_length' => 20,
  );

  if (!empty($current_password_hash)) {
    $form['commerce_epdq_cpi_auth_pw']['#required'] = FALSE;
    $form['commerce_epdq_cpi_auth_pw']['#description'] .= ' '
      . t('Leave blank to use the password you already set.');
  }

  $form['commerce_epdq_abandoned_order_interval'] = array(
    '#type' => 'select',
    '#title' => t('Abandoned order interval'),
    '#description' => t('The time after which an order is considered as "abandoned" after checkout, if it doesn\'t receive a payment success or failure notification. This allows orders to be cleaned up, for example, if the customer gets to the Barclays CPI but then navigates away before submitting final payment information. This feature requires a working cron setup.'),
    '#options' => array(
      0 => t('Never'),
      900 => t('15 minutes'),
      1800 => t('30 minutes'),
      3600 => t('One hour'),
      21600 => t('Six hours'),
      86400 => t('24 hours'),
    ),
    '#default_value' => variable_get('commerce_epdq_abandoned_order_interval', 900),
  );

  return system_settings_form($form);
}

/**
 * Validate the site-wide settings form.
 */
function commerce_epdq_config_validate($form, &$form_state) {

  // Encrypt the provided CPI response password. If the field is left blank, use
  // the password already set.
  if (empty($form_state['values']['commerce_epdq_cpi_auth_pw'])) {
    $current_password_hash = variable_get('commerce_epdq_cpi_auth_pw');
    $form_state['values']['commerce_epdq_cpi_auth_pw'] = $current_password_hash;
  }
  else {
    $form_state['values']['commerce_epdq_cpi_auth_pw'] = _commerce_epdq_encrypt_password(
      $form_state['values']['commerce_epdq_cpi_auth_pw']
    );
  }

}

/**
 * Implements CALLBACK_commerce_payment_method_settings_form().
 *
 * Returns a short Form API snippet, for the ePDQ payment method's
 * administrative settings.
 */
function commerce_epdq_settings_form($settings = NULL) {

  // Merge any given settings with this module's default settings.
  $settings = (array) $settings + _commerce_epdq_default_settings();

  // Build the settings form additions.
  $form = array();
  $form['epdq_merchant_display_name'] = array(
    '#type' => 'textfield',
    '#title' => t('Merchant display name'),
    '#default_value' => $settings['epdq_merchant_display_name'],
    '#required' => TRUE,
    '#size' => 30,
    '#description' => t('The trading name displayed to the user on the payment page.'),
  );
  $form['epdq_cpi_logo'] = array(
    '#type' => 'textfield',
    '#title' => t('Logo'),
    '#description' => t('URL (HTTPS only) to a JPEG, GIF, or PNG logo image for the payment page. The image must have width = 500px and height = 100px.'),
    '#default_value' => $settings['epdq_cpi_logo'],
    '#element_validate' => array('commerce_epdq_settings_form_validate_url'),
  );
  $form['mid'] = array(
    '#type' => 'textfield',
    '#title' => t('Store ID'),
    '#description' => t('Your ePDQ merchant ID.'),
    '#default_value' => $settings['mid'],
    '#size' => 10,
    '#required' => TRUE,
  );
  $form['epdq_passphrase'] = array(
    '#type' => 'textfield',
    '#title' => t('CPI passphrase'),
    '#description' => t('The unique identifier used by the encryption script to add a security layer to the encryption process.'),
    '#default_value' => $settings['epdq_passphrase'],
    '#required' => TRUE,
  );
  $form['epdq_url'] = array(
    '#type' => 'textfield',
    '#title' => t('ePDQ URL'),
    '#description' => t('The absolute URL to the ePDQ CPI payment page.'),
    '#default_value' => $settings['epdq_url'],
    '#required' => TRUE,
    '#element_validate' => array('commerce_epdq_settings_form_validate_url'),
  );
  $form['epdq_enc_url'] = array(
    '#type' => 'textfield',
    '#title' => t('ePDQ encryption tool URL'),
    '#description' => t('The absolute URL to the ePDQ data encryption tool.'),
    '#default_value' => $settings['epdq_enc_url'],
    '#required' => TRUE,
    '#element_validate' => array('commerce_epdq_settings_form_validate_url'),
  );
  $form['epdq_mandate_csc'] = array(
    '#type' => 'select',
    '#title' => t('Require Card Security Code'),
    '#options' => array('yes' => t('Yes'), 'no' => t('No')),
    '#required' => TRUE,
    '#default_value' => $settings['epdq_mandate_csc'],
    '#description' => t('This dictates whether the Card Security Code appears as a mandatory field on the CPI.'),
  );
  return $form;
}

/**
 * Validate URLs entered in the payment method rule settings form.
 *
 * @see commerce_epdq_settings_form()
 */
function commerce_epdq_settings_form_validate_url($element, $form, &$form_state) {
  if (!filter_var($element['#value'], FILTER_VALIDATE_URL, FILTER_FLAG_SCHEME_REQUIRED)) {
    form_error($element, t('Please enter a valid absolute URL.'));
  }
}

/**
 * Sanitize data before posting it to ePDQ.
 */
function _commerce_epdq_sanitize($str) {
  return trim(preg_replace('/\'/', '', $str));
}

/**
 * Menu callback allowing data to be sent from a single URL (commerce-epdq/pay).
 *
 * This function is a workaround because ePDQ requires a single, static,
 * predefined URL from which users are redirected to the payment page. So no
 * dynamic parameters can be provided in the URL. And nothing can be saved in
 * the session, because we might be processing on behalf of an anonymous user.
 */
function commerce_epdq_jump_page() {
  // Only posted values are relevant.
  if ($_SERVER['REQUEST_METHOD'] !== 'POST') {
    return MENU_NOT_FOUND;
  }
  // Only allow this to be called from the Commerce payment form.
  if (empty($_POST['form_id']) || $_POST['form_id'] != 'commerce_checkout_form_payment') {
    return MENU_NOT_FOUND;
  }
  // Protect against CSRF (as this is not a normal Drupal form process).
  if (empty($_POST['form_token']) || !drupal_valid_token($_POST['form_token'], $_POST['form_id'])) {
    return MENU_ACCESS_DENIED;
  }
  // The form is safe. Load the order from the provided order ID.
  $order = commerce_order_load($_POST['order_id']);
  // Load the payment method instance from the order.
  $payment_method = commerce_payment_method_instance_load($order->data['payment_method']);
  // Load the payment redirect form again.
  $form = drupal_get_form('commerce_epdq_redirect_form', $order, $payment_method);
  // Add autoredirect, if required.
  if (!empty($payment_method['offsite_autoredirect'])) {
    $form['#attached']['js'][] = drupal_get_path('module', 'commerce_payment') . '/commerce_payment.js';
    $form['help']['#markup'] = '<div class="checkout-help">' . t('Please wait while you are redirected to the payment server. If nothing happens within 10 seconds, please click on the button below.') . '</div>';
  }
  $form['#prefix'] = '<div class="payment-redirect-form">';
  $form['#suffix'] = '</div>';
  // Update the order status before redirect.
  commerce_order_status_update($order, 'epdq_processing');
  return $form;
}

/**
 * Implements CALLBACK_commerce_payment_method_redirect_form().
 */
function commerce_epdq_redirect_form($form, &$form_state, $order, $payment_method) {

  if (current_path() != 'commerce-epdq/pay') {
    $form['#action'] = url('commerce-epdq/pay');
    $form['order_id'] = array(
      '#type' => 'hidden',
      '#value' => $order->order_id,
    );
    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Continue'),
    );
    return $form;
  }

  $settings = $payment_method['settings'];

  // Get an Entity API object wrapper for the $order.
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

  // Get the billing address.
  $billing_address = $order_wrapper->commerce_customer_billing->commerce_customer_address->value();

  // Define the data to be sent via hidden form fields to the payment page.
  $hidden_data = array(
    'merchantdisplayname' => $settings['epdq_merchant_display_name'],
    // The truncate_utf8() calls here are because ePDQ treats the maximum length
    // of values very strictly: it fails and the customer sees a big error
    // message.
    'bfullname' => truncate_utf8($billing_address['name_line'], 30),
    'baddr1' => truncate_utf8(_commerce_epdq_sanitize($billing_address['thoroughfare']), 60),
    'baddr2' => truncate_utf8(_commerce_epdq_sanitize($billing_address['premise']), 60),
    'bcity' => truncate_utf8(_commerce_epdq_sanitize($billing_address['locality']), 25),
    'bcountyprovince' => truncate_utf8(_commerce_epdq_sanitize($billing_address['administrative_area']), 25),
    'bpostalcode' => truncate_utf8(_commerce_epdq_sanitize($billing_address['postal_code']), 9),
    'bcountry' => $billing_address['country'],
    'bemail' => $order->mail,
    'returnurl' => url('checkout/' . $order->order_id . '/payment/return/' . $order->data['payment_redirect_key'], array('absolute' => TRUE)),
  );

  // Get the shipping address, if available.
  if (isset($order_wrapper->commerce_customer_shipping)) {
    $shipping_address = $order_wrapper->commerce_customer_shipping->commerce_customer_address->value();
    $hidden_data += array(
      'sfullname' => truncate_utf8($shipping_address['name_line'], 30),
      'saddr1' => truncate_utf8(_commerce_epdq_sanitize($shipping_address['thoroughfare']), 60),
      'saddr2' => truncate_utf8(_commerce_epdq_sanitize($shipping_address['premise']), 60),
      'scity' => truncate_utf8(_commerce_epdq_sanitize($shipping_address['locality']), 25),
      'scountyprovince' => truncate_utf8(_commerce_epdq_sanitize($shipping_address['administrative_area']), 25),
      'spostalcode' => truncate_utf8(_commerce_epdq_sanitize($shipping_address['postal_code']), 9),
      'scountry' => $shipping_address['country'],
      'semail' => $order->mail,
    );
  }

  // Add the logo, only if provided.
  if (!empty($settings['epdq_cpi_logo'])) {
    $hidden_data['cpi_logo'] = $settings['epdq_cpi_logo'];
  }

  // Calculate the included tax (just for records), if commerce_tax is enabled.
  if (module_exists('commerce_tax')) {
    // Get the order's currency code (e.g. 'GBP').
    $cc = $order_wrapper->commerce_order_total->currency_code->value();
    $tax = 0;
    foreach ($order_wrapper->commerce_line_items as $line_item_wrapper) {
      $price = $line_item_wrapper->commerce_unit_price->data->value();
      $tax += commerce_tax_total_amount($price['components'], TRUE, $cc);
    }
    $hidden_data['tax'] = _commerce_epdq_amount_format($tax, $cc);
  }

  // Get the extra data which comes from the remote ePDQ encryption tool.
  $epdqdata = commerce_epdq_encrypt($order, $settings);
  if (!$epdqdata) {
    drupal_set_message(t('A technical error has occurred. No payment has been taken.'), 'warning');
    commerce_payment_redirect_pane_previous_page($order);
  }

  $hidden_data['epdqdata'] = preg_replace(
    '/<INPUT name\=epdqdata type\=hidden value\="([^"]+)">/',
    '$1',
    $epdqdata
  );

  // Add all this data to the form.
  foreach ($hidden_data as $key => $value) {
    $form[$key] = array('#type' => 'hidden', '#value' => $value);
  }

  $form['#action'] = $settings['epdq_url'];

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Continue to payment'),
    '#weight' => 100,
  );

  return $form;

}

/**
 * Contact the ePDQ encryption tool to get encrypted transaction data.
 *
 * @param stdClass $order
 *   The Commerce order object.
 * @param array $settings
 *   The payment method's settings array.
 *
 * @return string
 *   An HTML string consisting of a hidden INPUT element that contains the
 *   encrypted data.
 */
function commerce_epdq_encrypt(stdClass $order, array $settings) {

  // Get an Entity API object wrapper for the $order.
  $wrapper = entity_metadata_wrapper('commerce_order', $order);

  // Get the order's currency code (e.g. 'GBP').
  $cc = $wrapper->commerce_order_total->currency_code->value();
  // Get the corresponding ePDQ currency code (e.g. '826').
  $currencies = _commerce_epdq_currencies();
  if (!isset($currencies[$cc])) {
    watchdog('commerce_epdq', 'Unsupported currency: @cur', array('@cur' => $currency_code));
    return FALSE;
  }
  $epdq_currency_code = $currencies[$cc]['numcode'];

  // Get the order total.
  $order_total = $wrapper->commerce_order_total->amount->value();

  // Format the order total so it's friendly to ePDQ.
  $order_total = _commerce_epdq_amount_format($order_total, $cc);

  // Define the data to be provided to the ePDQ encryption tool.
  $post_data = array(
    'clientid' => $settings['mid'],
    'password' => $settings['epdq_passphrase'],
    'oid' => $order->order_number,
    'chargetype' => 'Auth',
    'currencycode' => $epdq_currency_code,
    'total' => $order_total,
    'mandatecsc' => ($settings['epdq_mandate_csc'] == 'no') ? 0 : 1,
  );

  // Post to the ePDQ encryption tool.
  $response = drupal_http_request($settings['epdq_enc_url'], array(
    'method' => 'POST',
    'headers' => array(
      'Content-Type' => 'application/x-www-form-urlencoded',
      'User-Agent' => 'Mozilla/4.0 (compatible; MSIE 5.01; Windows NT 5.0)',
    ),
    'data' => drupal_http_build_query($post_data),
    'max_redirects' => 0,
  ));

  if (isset($response->error)) {
    watchdog('commerce_epdq', 'ePDQ encryption call failed: @error', array('@error' => $response->error));
    return FALSE;
  }

  // Find the response line that contains the string 'epdqdata'.
  $response_lines = explode("\n", $response->data);
  foreach ($response_lines as $line) {
    if (strpos($line, 'epdqdata') !== FALSE) {
      return $line;
    }
  }

  return FALSE;

}

/**
 * Format a price for passing to ePDQ.
 */
function _commerce_epdq_amount_format($amount, $currency_code) {
  $amount = commerce_currency_amount_to_decimal($amount, $currency_code);
  $currency = commerce_currency_load($currency_code);
  return number_format(
    commerce_currency_round(abs($amount), $currency),
    $currency['decimals'],
    $currency['decimal_separator'],
    $currency['thousands_separator']
  );
}

/**
 * Get a list of supported currencies, and their mappings to ePDQ codes.
 *
 * See Barclays ePDQ CPI Integration guide, Appendix A.
 *
 * @return array
 *   An array of currency definitions, keyed by currency codes, in which
 *   'numcode' is the ePDQ numeric code, and 'dp' is the number of decimal
 *   places supported.
 */
function _commerce_epdq_currencies() {
  return array(
    // Australian Dollar.
    'AUD' => array('numcode' => '036', 'dp' => 2),
    // Canadian Dollar.
    'CAD' => array('numcode' => '124', 'dp' => 2),
    // China Yuan Renimbi.
    'CNY' => array('numcode' => '156', 'dp' => 2),
    // Cyprus Pound.
    'CYR' => array('numcode' => '196', 'dp' => 2),
    // Czech Koruna.
    'CZK' => array('numcode' => '203', 'dp' => 2),
    // Danish Krone.
    'DKK' => array('numcode' => '208', 'dp' => 2),
    // Estonian Kroon.
    'EEK' => array('numcode' => '233', 'dp' => 2),
    // Euro.
    'EUR' => array('numcode' => '978', 'dp' => 2),
    // Hong Kong Dollar.
    'HKD' => array('numcode' => '344', 'dp' => 2),
    // Hungarian Forint.
    'HUF' => array('numcode' => '348', 'dp' => 2),
    // Iceland Krona.
    'ISK' => array('numcode' => '352', 'dp' => 2),
    // Indian Rupee.
    'INR' => array('numcode' => '356', 'dp' => 2),
    // Israel New Shequel.
    'ILS' => array('numcode' => '376', 'dp' => 2),
    // Japanese Yen.
    'JPY' => array('numcode' => '392', 'dp' => 0),
    // Latvian Lat.
    'LVL' => array('numcode' => '428', 'dp' => 2),
    // Lithuanian Litas.
    'LTL' => array('numcode' => '440', 'dp' => 2),
    // Maltese Lira.
    'MTL' => array('numcode' => '470', 'dp' => 2),
    // Moroccan Dinah.
    'MAL' => array('numcode' => '504', 'dp' => 2),
    // New Zealand Dollar.
    'NZD' => array('numcode' => '554', 'dp' => 2),
    // Norwegian Krone.
    'NOK' => array('numcode' => '578', 'dp' => 2),
    // Polish Zlotych.
    'PLN' => array('numcode' => '985', 'dp' => 2),
    // Russian Ruble.
    'RUB' => array('numcode' => '643', 'dp' => 2),
    // Singapore Dollar.
    'SGD' => array('numcode' => '702', 'dp' => 2),
    // Slovak Koruna.
    'SKK' => array('numcode' => '703', 'dp' => 2),
    // South Korean Won.
    'KRW' => array('numcode' => '410', 'dp' => 0),
    // Swedish Krona.
    'SEK' => array('numcode' => '752', 'dp' => 2),
    // Swiss Francs.
    'CHF' => array('numcode' => '756', 'dp' => 2),
    // Sterling.
    'GBP' => array('numcode' => '826', 'dp' => 2),
    // US Dollars.
    'USD' => array('numcode' => '840', 'dp' => 2),
    // Saudi Riyal.
    'SAR' => array('numcode' => '682', 'dp' => 2),
    // South African Rand.
    'ZAR' => array('numcode' => '710', 'dp' => 2),
    // Thai Baht.
    'THB' => array('numcode' => '764', 'dp' => 2),
    // United Arab Emirates dirham.
    'AED' => array('numcode' => '784', 'dp' => 2),
  );
}

/**
 * Menu callback for 'commerce-epdq/response'.
 */
function commerce_epdq_process_response() {

  // The ePDQ CPI requires HTTP Basic authentication.
  if (!isset($_SERVER['PHP_AUTH_USER']) || !_commerce_epdq_cpi_auth_check($_SERVER['PHP_AUTH_USER'], $_SERVER['PHP_AUTH_PW'])) {
    header('WWW-Authenticate: Basic realm="ePDQ Client"');
    header('HTTP/1.0 401 Unauthorized');
    drupal_exit();
  }

  if ($_SERVER['REQUEST_METHOD'] !== 'POST' || empty($_POST['oid'])) {
    return MENU_NOT_FOUND;
  }

  $order = commerce_order_load_by_number($_POST['oid']);

  // @todo clarify and document order_id to order_number change
  $fields = array(
    'transaction_status' => $_POST['transactionstatus'],
    'order_number' => $order ? $order->order_number : $_POST['oid'],
    'order_id' => $order ? $order->order_id : NULL,
    'order_total' => $_POST['total'],
    'eci_status' => $_POST['ecistatus'],
    'card_prefix' => $_POST['cardprefix'],
    'timestamp' => $_POST['datetime'],
  );

  if (!$order) {
    watchdog('commerce_epdq', 'CPI returned data for nonexistent order number @on (status: @status).', array(
      '@on' => $fields['order_number'],
      '@status' => $fields['transaction_status'],
    ), WATCHDOG_WARNING);
    drupal_exit();
    return;
  }

  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  $currency_code = $order_wrapper->commerce_order_total->currency_code->value();

  // Create a new payment transaction for the order.
  $transaction = commerce_payment_transaction_new('epdq', $order->order_id);
  $transaction->remote_id = $_POST['oid'];
  $transaction->amount = commerce_currency_decimal_to_amount($_POST['total'], $currency_code);
  $transaction->currency_code = $currency_code;
  $transaction->payload[REQUEST_TIME] = $fields;
  $transaction->remote_status = $_POST['transactionstatus'];

  // The only good status message from ePDQ is "Success".
  switch ($_POST['transactionstatus']) {

    case 'Success':
      $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
      $transaction->message = t('Payment complete.');
      break;

    case 'DECLINED':
      $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
      $transaction->message = t('The payment failed: card declined.');
      break;

    default:
      $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
      $transaction->message = t('The payment failed with the message: @status.', array('@status' => $_POST['transactionstatus']));
      break;

  }

  // Save the transaction information.
  commerce_payment_transaction_save($transaction);

  // Update the order status.
  $log = t('Updated after transaction ID @txn_id.', array('@txn_id' => $transaction->transaction_id));
  switch ($transaction->status) {
    case COMMERCE_PAYMENT_STATUS_SUCCESS:
      $balance = commerce_payment_order_balance($order);
      $paid_in_full = ($balance && $balance['amount'] <= 0);
      if ($paid_in_full) {
        commerce_order_status_update($order, 'paid', FALSE, TRUE, $log);
        commerce_checkout_complete($order);
      }
      else {
        commerce_order_status_update($order, 'epdq_incomplete', FALSE, TRUE, $log);
      }
      break;

    case COMMERCE_PAYMENT_STATUS_FAILURE:
      commerce_order_status_update($order, 'epdq_failed', FALSE, TRUE, $log);
      rules_invoke_event('commerce_epdq_payment_failed', $order);
      break;

  }

  // No need to load the rest of the page: only the ePDQ server sees this.
  drupal_exit();

}

/**
 * Implements hook_cron().
 */
function commerce_epdq_cron() {
  // Mark stale orders as Abandoned.
  commerce_epdq_mark_orders_abandoned();
}

/**
 * Update the status of stale orders to 'Abandoned'.
 */
function commerce_epdq_mark_orders_abandoned($interval = NULL, $limit = 50) {
  if ($interval === NULL) {
    $interval = variable_get('commerce_epdq_abandoned_order_interval', 900);
  }
  if ($interval > 0) {
    $stale_orders = commerce_epdq_get_stale_orders($interval, $limit);
    foreach ($stale_orders as $order) {
      commerce_order_status_update(
        $order,
        'epdq_abandoned',
        FALSE,
        TRUE,
        t('Nothing has happened for @interval seconds after checkout.', array(
          '@interval' => (int) $interval,
        ))
      );
      watchdog('commerce_epdq', 'Order @oid marked as abandoned after @interval seconds', array(
        '@oid' => $order->order_id,
        '@interval' => (int) $interval,
      ));
    }
  }
}

/**
 * Get stale orders.
 *
 * These are any for which the user completed checkout, but payment notification
 * has not been received for whatever reason, usually because the user quit
 * before entering payment information. These orders will currently be stuck as
 * 'Processing'.
 *
 * @param int $interval
 *   Number of seconds after order's updated time before it's considered stale.
 *   Default is 900 (fifteen minutes).
 * @param int $limit
 *   Number of stale orders to get. The default limit is 50.
 *
 * @return array
 *   An array of all relevant commerce_order entities.
 */
function commerce_epdq_get_stale_orders($interval = 900, $limit = 50) {
  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'commerce_order', '=')
    ->propertyCondition('status', 'epdq_processing')
    ->propertyCondition('changed', REQUEST_TIME - $interval, '<');
  if ($limit) {
    $query->range(0, $limit);
  }
  $result = $query->execute();
  $orders = array();
  if (!empty($result['commerce_order'])) {
    $orders = entity_load('commerce_order', array_keys($result['commerce_order']));
  }
  return $orders;
}

/**
 * Check the authorization provided to the CPI response callback.
 */
function _commerce_epdq_cpi_auth_check($name, $pass) {
  if ($name !== variable_get('commerce_epdq_cpi_auth_user')) {
    return FALSE;
  }
  $stored_hash = variable_get('commerce_epdq_cpi_auth_pw');
  require_once DRUPAL_ROOT . '/includes/password.inc';
  $hash = _password_crypt('sha512', $pass, $stored_hash);
  return ($hash && $stored_hash == $hash);
}

/**
 * Generate a hash of a password.
 */
function _commerce_epdq_encrypt_password($pass) {
  require_once DRUPAL_ROOT . '/includes/password.inc';
  return _password_crypt('sha512', $pass, _password_generate_salt(DRUPAL_MIN_HASH_COUNT));
}
