<?php

/**
 * Implements hook_ctools_plugin_directory().
 */
function project_ctools_plugin_directory($module, $plugin) {
  if ($module == 'sampler') {
    switch ($plugin) {
      case 'metric':
        return 'metrics';
    }
  }
  if ($module == 'entityreference') {
    return 'plugins/entityreference_' . $plugin;
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Project adjustments to the field edit form.
 */
function project_form_field_ui_field_edit_form_alter(&$form) {
  // field_project_type has certain settings that project depends on, force
  // those here.
  if ($form['#field']['field_name'] == 'field_project_type') {
    $form['field']['#access'] = FALSE;
    $form['instance']['required']['#value'] = TRUE;
    $form['instance']['required']['#access'] = FALSE;
  }
}

/**
 * Implements hook_form_FORM_ID_alter(), altering
 * apachesolr_search_field_bias_form().
 */
function project_form_apachesolr_search_bias_form_alter(&$form) {
  if (isset($form['field_bias']['ss_field_project_machine_name'])) {
    $form['field_bias']['ss_field_project_machine_name']['#access'] = TRUE;
  }
}

/**
 * Determine whether or not a node is a project.
 *
 * @param $node
 *   A node to check.
 */
function project_node_is_project($node) {
  return !empty($node) && project_node_type_is_project($node->type);
}

/**
 * Determine whether or not a given node type behaves as a project.
 *
 * We just check the project_behavior_[node_type] setting for the given
 * node type to see if the type is configured to behave like a project.
 *
 * @param string $node_type
 *   The node type (machine name) to check.
 *
 * @return boolean
 *   Is the given node type a project node type or not?
 */
function project_node_type_is_project($node_type) {
  $project_behavior = variable_get('project_behavior_' . $node_type, '');
  return $project_behavior == 'project';
}

/**
 * Retrieve a list of node types that are considered projects.
 *
 * @return array
 *   An array of bundle names (aka node type names) that are configured to
 *   have project nature.
 *
 * @see project_project_node_type_is_project()
 */
function project_project_node_types() {
  $project_node_types = array();
  $node_types = node_type_get_types();
  foreach ($node_types as $type) {
    if (project_node_type_is_project($type->type)) {
      $project_node_types[] = $type->type;
    }
  }
  return $project_node_types;
}

/**
 * Get the list of node types assigned to a behavior.
 */
function project_node_types_by_behavior($behavior) {
  $behavior_node_types = array();
  $node_types = node_type_get_types();
  foreach ($node_types as $type) {
    if (variable_get('project_behavior_' . $type->type, FALSE) == $behavior) {
      $behavior_node_types[] = $type->type;
    }
  }
  return $behavior_node_types;
}

/**
 * Menu loader callback to load a project node.
 *
 * @param $arg
 *   The menu argument to attempt to load a project from.  Can be either a
 *   numeric node ID (nid), or a string machine name
 *   (field_project_machine_name).
 *
 * @return
 *   The loaded node object if the argument was a valid project, FALSE if not.
 */
function project_load($arg) {
  if (is_numeric($arg)) {
    $node = node_load($arg);
  }
  else {
    $query = new EntityFieldQuery();
    $result = $query->entityCondition('entity_type', 'node', '=')
      ->fieldCondition('field_project_machine_name', 'value', $arg, '=')
      ->execute();
    if (!empty($result['node'])) {
      $entities = entity_load('node', array_keys($result['node']));
      $node = reset($entities);
    }
  }
  if (!isset($node->type) || !project_node_is_project($node)) {
    return FALSE;
  }
  return $node;
}

/**
 * Menu argument loader: loads a project node type by string.
 */
function project_type_load($name) {
  $type = node_type_load($name);
  $project_types = project_project_node_types();

  // Return the type only if it's a project.
  if ($type && array_search($type->type, $project_types) !== FALSE) {
    return $type;
  }
  else {
    return FALSE;
  }
}

/**
 * Implements hook_views_api().
 */
function project_views_api() {
  return array(
    'api' => '3.0',
    'path' => drupal_get_path('module', 'project') .'/views',
  );
}

/**
 * Implements hook_ctools_plugin_api().
 */
function project_ctools_plugin_api($module, $api) {
  if ($module == 'field_group' && $api == 'field_group') {
    return array('version' => 1);
  }
}

/**
 * Implementats hook_menu().
 */
function project_menu() {
  $items = array();

  $items['node/%project/maintainers'] = array(
    'title' => 'Maintainers',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('project_maintainers_form', 1),
    'access callback' => 'project_user_access',
    'access arguments' => array(1, 'administer maintainers'),
    'file' => 'includes/project_maintainers.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 4,
  );

  $items['node/%project/maintainers/delete/%user'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('project_maintainer_delete_confirm', 1, 4),
    'access callback' => 'project_user_access',
    'access arguments' => array(1, 'administer maintainers'),
    'file' => 'includes/project_maintainers.inc',
    'type' => MENU_CALLBACK,
  );

  $items['node/%project/edit/promote'] = array(
    'title' => 'Promote',
    'page callback' => 'project_promote_project_page',
    'page arguments' => array(1),
    'access callback' => 'project_promote_project_access',
    'access arguments' => array(1),
    'file' => 'includes/project_promote.inc',
    'type' => MENU_LOCAL_TASK,
  );

  $items['node/%project/edit/promote/confirm'] = array(
    'title' => 'Promote',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('project_promote_project_confirm_form', 1),
    'access callback' => 'project_promote_project_access',
    'access arguments' => array(1),
    'file' => 'includes/project_promote.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/project'] = array(
    'title' => t('Project'),
    'access callback' => 'user_access',
    'access arguments' => array('administer projects'),
  );

  $items['admin/config/project/project-settings'] = array(
    'title' => t('Project settings'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('project_main_settings_form'),
    'access callback' => 'user_access',
    'access arguments' => array('administer projects'),
    'description' => t('Configure system-wide settings for the Project module.'),
  );

  $items['project/add'] = array(
    'title' => t('Create a project'),
    'page callback' => 'project_add_landing_page',
    'access callback' => 'project_user_can_create_project',
    'description' => t('Add a new project node.'),
  );

  return $items;
}

/**
 * Add default local task for project node edit page.
 */
function project_menu_alter(&$callbacks) {
  $callbacks['node/%node/edit/project'] = $callbacks['node/%node/edit'];
  $callbacks['node/%node/edit/project']['type'] = MENU_DEFAULT_LOCAL_TASK;
  $callbacks['node/%node/edit/project']['title'] = 'Project';
  // Only take over secondary local tasks for projects.
  $callbacks['node/%node/edit/project']['access callback'] = 'project_user_access';
  $callbacks['node/%node/edit/project']['access arguments'] = array(1, 'edit project');
}

/**
 * Menu access callback for the promote tab at node/%project/edit/promote.
 *
 * @param $node
 *   The project object to check access against.
 */
function project_promote_project_access($node) {
  // This callback is only valid for projects that are sandboxes. Further,
  // restrict to users with either 'administer projects' or users that have
  // access to edit the project and a valid 'create full projects' permission.
  return project_promote_project_is_sandbox($node) && (user_access('administer projects') || (project_user_access($node, 'edit project') && (user_access('create full projects') || user_access("create full {$node->type} projects"))));
}

/**
 * Page callback for promote subtab.
 */
function project_promote_project_page($node) {
  project_project_set_breadcrumb($node);
  drupal_set_title(check_plain($node->title));
  return drupal_get_form('project_promote_project_form', $node);
}

/**
 * Determine if a given node is a sandbox or full project.
 *
 * @param $node
 *   A fully-loaded node object representing the project.
 *
 * @return boolean
 *   TRUE if the given node is a sandbox project, FALSE if full.
 */
function project_promote_project_is_sandbox($node) {
  return !empty($node->field_project_type[LANGUAGE_NONE][0]['value'])
    && $node->field_project_type[LANGUAGE_NONE][0]['value'] == 'sandbox';
}

/**
 * Set project-specific breadcrumbs.
 *
 * @param $project
 *   A fully-loaded node object representing the project to generate
 *   breadcrumbs for.
 * @param boolean $include_project
 *   Should the breadcrumb trail include a link to the project itself?
 * @param array $extra
 *   An array of additional breadcrumb links to include after the main
 *   project breadcrumb items (e.g. for issue queues, releases, etc).
 *
 * @see drupal_set_breadcrumb()
 */
function project_project_set_breadcrumb($project = NULL, $include_project = FALSE, $extra = array()) {
  $breadcrumb = project_project_get_breadcrumb($project, $include_project, $extra);
  drupal_set_breadcrumb($breadcrumb);
}

/**
 * Return an array of breadcrumb links for a given project.
 *
 * @param $project
 *   A fully-loaded node object representing the project to generate
 *   breadcrumbs for.
 * @param boolean $include_project
 *   Should the breadcrumb trail include a link to the project itself?
 * @param array $extra
 *   An array of additional breadcrumb links to include after the main
 *   project breadcrumb items (e.g. for issue queues, releases, etc).
 *
 * @see drupal_set_breadcrumb()
 */
function project_project_get_breadcrumb($project = NULL, $include_project = FALSE, $extra = array()) {
  $breadcrumb = array();
  $breadcrumb[] = l(t('Home'), NULL);

  // If project_solr exists, inject breadcrumbs for its browsing pages.
  if (module_exists('project_solr')) {
    $breadcrumb[] = l(t('Project summary'), 'project');
    $type = node_type_load($project->type);
    $breadcrumb[] = l(check_plain($type->name), 'project/' . $type->type);
  }
  // else {
  // TODO: We want a link to the root of the project browsing, but we're not
  // yet providing views for that.

  // TODO: If the site has multiple project node types, we want a breadcrumb
  // entry here pointing to the way to browse all projects of the same type.
  // E.g. on Drupal.org if we're viewing a module project page, we'd want a
  // link to the module browsing section. However, we're not providing any
  // views for this.
  // }

  if ($include_project && !empty($project)) {
    $breadcrumb[] = l($project->title, 'node/' . $project->nid);
  }

  if (!empty($extra)) {
    $breadcrumb = array_merge($breadcrumb, $extra);
  }

  return $breadcrumb;
}

/**
 * Implements hook_node_view().
 */
function project_node_view($node, $view_mode, $langcode) {
  if ($view_mode === 'full' && project_node_is_project($node)) {
    project_project_set_breadcrumb($node);
  }
}

/**
 * Get the project node context from the currently active menu, if any.
 *
 * @return
 *   A fully loaded project $node object if the currently active menu has a
 *   project node context, or NULL if the menu isn't pointing to a project.
 */
function project_get_project_from_menu() {
  $node = menu_get_object('project');
  // If that didn't work, load it directly as a node and see if it's a project.
  if (empty($node)) {
    $node = menu_get_object();
    if (empty($node) || !project_node_is_project($node)) {
      $node = NULL;
    }
  }
  return $node;
}

function project_main_settings_form() {
  $form = array();

  $form['project_selection_widget'] = array(
    '#type' => 'radios',
    '#title' => t('Project selection widget'),
    '#options' => array(
      'select' => t('Select Menu'),
      'auto' => t('Autocomplete'),
    ),
    '#default_value' => variable_get('project_selection_widget', 'select'),
  );

  $form['project_allow_machinename_update'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow changing project shortnames'),
    '#default_value' => variable_get('project_allow_machinename_update', FALSE),
    '#description' => t('If checked, someone with the right permissions will be able to change the shortname of a project, which also changes the automatically generated URL of that project.'),
  );

  $form['project_require_lowercase_machinename'] = array(
    '#type' => 'checkbox',
    '#title' => t('Require lowercase project short names'),
    '#default_value' => variable_get('project_require_lowercase_machinename', FALSE),
    '#description' => t('If checked, validation will force to use lowercase letter on the project shortname.'),
  );

  $form['sandbox'] = array(
    '#type' => 'fieldset',
    '#title' => t('Sandbox settings'),
    '#collapsible' => TRUE,
  );
  $form['sandbox']['project_sandbox_numeric_shortname'] = array(
    '#title' => t('Auto generate short name for sandboxes'),
    '#type' => 'checkbox',
    '#default_value' => variable_get('project_sandbox_numeric_shortname', FALSE),
    '#description' => t('If checked, projects marked as sandboxes will be have their shortname automatically generated using a unique numeric identifier.'),
  );

  return system_settings_form($form);
}

/**
 * Implements hook_permission().
 */
function project_permission() {
  $permissions = array(
    'administer projects' => array(
      'title' => t('Administer projects'),
      'description' => t('Administer all projects.'),
      'restrict access' => TRUE,
    ),
    'create sandbox projects' => array(
      'title' => t('Create sandbox projects'),
      'description' => t('Create any type of projects as a sandbox. Users must also have the correct project-type create permission.'),
    ),
    'create full projects' => array(
      'title' => t('Create full projects (any type)'),
      'description' => t('Create any type of project as a full project. Users must also have the correct project-type create permission.'),
    ),
    'delete any full project' => array(
      'title' => t('Delete any full project'),
      'description' => t('Delete any type of full project. Users must also have the correct project-type delete permission.'),
    ),
    'delete own full project' => array(
      'title' => t('Delete own full project'),
      'description' => t('Delete full projects that the user owns. Users must also have the correct project-type delete permission.'),
    ),
    'delete any sandbox project' => array(
      'title' => t('Delete any sandbox project'),
      'description' => t('Delete any type of sandbox project. Users must also have the correct project-type delete permission.'),
    ),
    'delete own sandbox project' => array(
      'title' => t('Delete own sandbox project'),
      'description' => t('Delete sandbox projects that the user owns. Users must also have the correct project-type delete permission.'),
    ),
  );

  $node_type_names = node_type_get_names();
  foreach (project_project_node_types() as $type) {
    $permissions["create full $type projects"] = array(
      'title' => t('Create full %type projects', array('%type' => $node_type_names[$type])),
      'description' => t('Create %type type of project as a full project. Users must also have the %type: Create new content permission.', array('%type' => $node_type_names[$type])),
    );
  }

  return $permissions;
}

/**
 * Implements hook_node_load().
 */
function project_node_load($nodes, $types) {
  foreach ($nodes as $node) {
    if (project_node_is_project($node)) {
      $node->project = array();
      $node->project['maintainers'] = project_maintainer_project_load($node->nid);
    }
  }
}

/**
 * Implements hook_node_validate().
 */
function project_node_validate($node, $form, &$form_state) {
  if (!project_node_is_project($node)) {
    return;
  }
  if (!empty($form_state['clicked_button']) && $form_state['clicked_button']['#value'] == t('Delete')) {
    //Don't validate during deletion.
    return;
  }
  // Ensure title is unique across all projects.
  // Note: technically, it's theoretically an information disclosure to tell a
  // user that a given project name is in use if they don't have access to
  // view that issue. However, we don't have an alternative here, since we
  // have to ensure uniqueness. Hopefully the project name itself isn't too
  // much of a problem to disclose in this edge case.
  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', project_project_node_types(), 'IN')
    ->propertyCondition('title', $node->title);
  if ($node->nid) {
    $query->entityCondition('entity_id', $node->nid, '!=');
  }
  $count = $query->count()->execute();
  if ($count) {
    form_set_error('title', t('This project name is already in use.'));
  }
}

/**
 * Implements hook_theme().
 */
function project_theme() {
  return array(
    'project_maintainers_form' => array(
      'file' => 'includes/project_maintainers.inc',
      'render element' => 'element',
    ),
    'project_add_landing_page' => array(
      'variables' => array('types' => NULL),
    ),
  );
}

/**
 * Implements hook_node_insert().
 */
function project_node_insert($node) {
  if (project_node_is_project($node)) {
    $perms = array_fill_keys(array_keys(project_permission_load($node)), 1);
    project_maintainer_save($node->nid, $node->uid, $perms);
  }
}

/**
 * Implements hook_node_update().
 */
function project_node_update($node) {
  if (project_node_is_project($node)) {
    $perms = array_fill_keys(array_keys(project_permission_load($node)), 1);
    project_maintainer_save($node->nid, $node->uid, $perms);
  }
}

function project_field_storage_pre_insert($entity_type, $entity) {
  if ($entity_type === 'node' && project_node_is_project($entity)) {
    _project_pre_save($entity);
  }
}

function project_field_storage_pre_update($entity_type, $entity) {
  if ($entity_type === 'node' && project_node_is_project($entity)) {
    _project_pre_save($entity);
  }
}

function _project_pre_save($node) {
  if (variable_get('project_sandbox_numeric_shortname', FALSE) && project_promote_project_is_sandbox($node) && empty($node->field_project_machine_name[$node->language])) {
    $node->field_project_machine_name[$node->language][0]['value'] = $node->nid;
  }
}

/**
 * Implements hook_node_access().
 */
function project_node_access($node, $op, $account) {
  $type = is_string($node) ? $node : $node->type;
  if (project_node_type_is_project($type)) {
    switch ($op) {
      case 'create':
        if (!(user_access('create full projects') || user_access("create full $type projects"))
            && !user_access('create sandbox projects')) {
          return NODE_ACCESS_DENY;
        }
        break;

      case 'delete':
        $is_owner = $node->uid == $account->uid;
        if (project_promote_project_is_sandbox($node)) {
          $any_perm = user_access('delete any sandbox project');
          $own_perm = user_access('delete own sandbox project');
        }
        else {
          $any_perm = user_access('delete any full project');
          $own_perm = user_access('delete own full project');
        }
        if ($is_owner) {
          if (!$any_perm && !$own_perm) {
            return NODE_ACCESS_DENY;
          }
        }
        // Not the owner.
        else {
          if (!$any_perm) {
            return NODE_ACCESS_DENY;
          }
        }
        break;
    }

    // If we haven't already denied, and we're not trying to create, check the
    // per-project permissions for the given user.
    if ($op != 'create') {
      return (project_user_access($node, $op . ' project', $account)) ? NODE_ACCESS_ALLOW : NODE_ACCESS_IGNORE;
    }

  }
}

/**
 * Implements hook_node_delete().
 */
function project_node_delete($node) {
  if (project_node_is_project($node)) {
    db_query("DELETE FROM {project_maintainer} WHERE nid = :nid", array(':nid' => $node->nid));
  }
}

/**
 * Implements hook_user_cancel().
 */
function project_user_cancel($edit, $account, $method) {
  // Maintainership isn't content and should be deleted.
  project_user_delete($account);
}

/**
 * Implements hook_user_delete().
 */
function project_user_delete($account) {
  // Delete project maintainerships.
  foreach (db_query('SELECT nid FROM {project_maintainer} WHERE uid = :uid', array('uid' => $account->uid))->fetchCol() as $nid) {
    project_maintainer_remove($nid, $account->uid);
  }
}

/**
 * See if the current user has the given permission on a given project.
 *
 * @param $project
 *   The project to check access against. Can be either a numeric node ID
 *   (nid) or a fully-loaded $node object.
 * @param $permission
 *   The string representing the permission to check access for.
 */
function project_user_access($project, $permission, $account = NULL) {
  global $user;

  if ($account == NULL) {
    $account = $user;
  }

  if (empty($account->uid)) {
    return FALSE;
  }

  $project_obj = is_numeric($project) ? node_load($project) : $project;
  if (!isset($project_obj) || (isset($project_obj->type) && !project_node_is_project($project_obj))) {
    return FALSE;
  }

  // If the user has the site-wide admin permission, always grant access.
  if (user_access('administer projects')) {
     return TRUE;
  }

  // Project owners are treated as super users and can always access.
  if ($account->uid == $project_obj->uid) {
    return TRUE;
  }

  // Otherwise, see if the user has the right permission for this project.
  return !empty($project_obj->project['maintainers'][$account->uid]['permissions'][$permission]);

  // If we haven't granted access yet, deny it.
  return FALSE;
}

/**
 * Load all per-project permission information and return it.
 *
 * This invokes hook_project_permission_info() and
 * hook_project_permission_alter(), and caches the results in RAM.
 *
 * @param $project
 *   A project object to pass to hook_project_permission_info().
 *
 * @see hook_project_permission_info()
 * @see hook_project_permission_alter()
 * @see drupal_alter()
 */
function project_permission_load($project) {
  static $project_permissions = array();
  if (empty($project_permissions[$project->nid])) {
    $permissions = module_invoke_all('project_permission_info', $project);
    drupal_alter('project_permission', $permissions, $project);
    $project_permissions[$project->nid] = $permissions;
  }
  return $project_permissions[$project->nid];
}

/**
 * Implement hook_project_permission_info()
 */
function project_project_permission_info($project = NULL) {
  return array(
    'update project' => array(
      'title' => t('Edit project'),
      'description' => t('Allows a user to edit a project and modify its settings.'),
    ),
    'administer maintainers' => array(
      'title' => t('Administer maintainers'),
      'description' => t('Allows a user to add and remove other project maintainers and to modify their permissions.'),
    ),
  );
}

/**
 * Save the permissions associated with a maintainer for a given project.
 *
 * This creates a new maintainer record if none currently exists. Furthermore,
 * it invokes hook_project_maintainer_save() to give other modules a chance to
 * act on the fact that a maintainer is being saved.
 *
 * @param $nid
 *   The Project NID to update the maintainer for.
 * @param $uid
 *   The user ID of the maintainer to update.
 * @param array $permissions
 *   Associative array of which project-level permissions the maintainer
 *   should have. The keys are permission names, and the values are if the
 *   permission should be granted or not.
 *
 * @see hook_project_maintainer_save()
 * @see hook_project_permission_info()
 */
function project_maintainer_save($nid, $uid, $permissions = array()) {
  // Try to update an existing record, if any.
  db_merge('project_maintainer')
    ->key(array('nid' => $nid, 'uid' => $uid))
    ->fields(array(
      'update_project' => $permissions['update project'],
      'administer_maintainers' => $permissions['administer maintainers']
    ))
    ->execute();

  // Invoke hook_project_maintainer_save() to let other modules know this
  // maintainer is being saved so they can take any actions or record any
  // data they need to.
  module_invoke_all('project_maintainer_save', $nid, $uid, $permissions);
}

/**
 * Remove a maintainer from a given project.
 *
 * @param $nid
 *   The Project NID to remove the maintainer from.
 * @param $uid
 *   The user ID of the maintainer to remove.
 */
function project_maintainer_remove($nid, $uid) {
  db_query("DELETE FROM {project_maintainer} WHERE nid = :nid and uid = :uid", array(':nid' => $nid, ':uid' => $uid));

  // Invoke hook_project_maintainer_remove() to let other modules know this
  // maintainer is being removed so they can take any actions or record any
  // data they need to.
  module_invoke_all('project_maintainer_remove', $nid, $uid);
}

/**
 * Load all the per-project maintainer info for a given project.
 *
 * @param $nid
 *   Node ID of the project to load maintainer info about.
 *
 * @return
 *   Array of maintainer info for the given project.
 *
 * @see hook_project_maintainer_project_load().
 */
function project_maintainer_project_load($nid) {
  $maintainers = array();

  // We don't want to load all the permissions here, just the ones that
  // Project itself is responsible for, so we use our implementation of the
  // hook, instead of the global load function.
  $project_perms = project_project_permission_info();
  $result = db_query('SELECT u.name, pm.* FROM {project_maintainer} pm INNER JOIN {users} u ON pm.uid = u.uid WHERE pm.nid = :nid ORDER BY u.name', array(':nid' => $nid));
  foreach ($result as $maintainer) {
    $maintainers[$maintainer->uid]['name'] = $maintainer->name;
    foreach ($project_perms as $perm_name => $perm_info) {
      $db_field = str_replace(' ', '_', $perm_name);
      $maintainers[$maintainer->uid]['permissions'][$perm_name] = $maintainer->$db_field;
    }
  }

  // Invoke hook_project_maintainer_project_load(). We can't use
  // module_invoke_all() since we want a reference to the $maintainers array.
  foreach (module_implements('project_maintainer_project_load') as $module) {
    $function_name = $module . '_project_maintainer_project_load';
    $function_name($nid, $maintainers);
  }

  return $maintainers;
}

/**
 * Get an array of projects for use in select form elements.
 *
 * The keys are the project nid, and the values are the project names. The
 * array will be sorted into the proper catagories with headers for each term,
 * based the node types of the projects.
 *
 * @param $conditions
 *   An array of conditions represented as an associative array. Each
 *   conditions' keys map to parameters for EntityFieldQuery::fieldCondition():
 *   - 'field', such as 'field_project_has_issue_queue' or
 *     'field_project_type', required.
 *   - 'column', default 'value'
 *   - 'value', default '1'
 *   - 'operator', default '='
 *   For example, to get sandbox projects with issue queues:
 *     array(
 *       array('field' => 'field_project_type', 'value' => 'sandbox'),
 *       array('field' => 'field_project_has_issue_queue'),
 *     )
 */
function project_projects_select_options(array $conditions = array()) {
  $projects = array();

  $project_node_types = project_project_node_types();
  if (empty($project_node_types)) {
    // If there are no project node types, just return the empty array here.
    return $projects;
  }

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node', '=')
    ->addTag('node_access');

  // Restrict the query to the node types that can be projects.
  $query->propertyCondition('type', $project_node_types);

  foreach ($conditions as $condition) {
    $query->fieldCondition($condition['field'],
      isset($condition['column']) ? $condition['column'] : 'value',
      isset($condition['value']) ? $condition['value'] : '1',
      isset($condition['operator']) ? $condition['operator'] : '='
    );
  }

  $result = $query->execute();
  foreach ($result as $entity_type => $project_entities) {
    $project_entities = entity_load($entity_type, array_keys($project_entities));
    foreach ($project_entities as $project) {
      $project_entity_ids = entity_extract_ids('node', $project);
      $projects[$project_entity_ids[0]] = $project->title;
    }
  }
  return $projects;
}

/**
 * Implements hook_FORM_ID_form_alter().
 *
 * This adds a 'Project settings' vertical tab to the node_type_form and the
 * initial choice of what behavior a given node type should have relative to
 * the Project* suite. This also invokes a hook that allows other Project*
 * modules to inject their own node-type-specific settings and form elements.
 *
 * @see hook_project_behavior_info()
 * @see node_type_form_submit()
 */
function project_form_node_type_form_alter(&$form) {
  $node_type = $form['#node_type']->type;
  $project_behavior = variable_get('project_behavior_' . $node_type, 'none');

  $form['project'] = array(
    '#type' => 'fieldset',
    '#title' => t('Project settings'),
    '#collapsible' => TRUE,
    '#group' => 'additional_settings',
  );

  $form['project']['project_behavior'] = array(
    '#title' => t('How does this content type relate to the Project system?'),
    '#type' => 'radios',
    '#default_value' => $project_behavior,
  );

  $project_behaviors = project_get_behavior_info();
  $project_behavior_choices = array();
  $project_behavior_settings = array();
  foreach ($project_behaviors as $module => $behavior_info) {
    $machine_name = $behavior_info['machine name'];
    $project_behavior_choices[$machine_name] = $behavior_info['label'];
    if (!empty($behavior_info['settings callback'])) {
      $form_elements = $behavior_info['settings callback']($node_type);
      foreach (element_children($form_elements) as $key) {
        // The form elements might define their own #states, so don't just
        // clobber it, but merge in our visibility state carefully.
        $visible = array(
          ':input[name="project_behavior"]' => array('value' => $machine_name),
        );
        if (!empty($form_elements[$key]['#states']['visible'])) {
          $visible = array_merge($form_elements[$key]['#states']['visible'], $visible);
        }
        $form_elements[$key]['#states']['visible'] = $visible;
        $form['project'][$machine_name][$key] = $form_elements[$key];
      }
    }
  }

  $form['project']['project_behavior']['#options'] = $project_behavior_choices;
}

/**
 * Invoke hook_project_behavior_info() and collect the results.
 */
function project_get_behavior_info() {
  static $project_behaviors = array();
  if (empty($project_behaviors)) {
    $project_behaviors = array(
      'none' => array(
        'label' => t('Not related to projects'),
        'machine name' => 'none',
      ),
    );
    // @todo: This is stupid. We want something like module_collate_info().
    // @see http://drupal.org/node/890660
    foreach (module_implements('project_behavior_info') as $module) {
      $function = "{$module}_project_behavior_info";
      $project_behaviors[$module] = $function();
    }
  }
  return $project_behaviors;
}

/**
 * Implements hook_project_behavior_info().
 *
 * For now, there are no project-specific settings, so there's no settings
 * callback.
 *
 * @return array
 *   Info about the 'project' project behavior.
 */
function project_project_behavior_info() {
  return array(
    'label' => t('Used for projects'),
    'machine name' => 'project',
  );
}

/**
 * Implements hook_form_alter().
 */
function project_form_node_form_alter(&$form, &$form_state) {
  $node = $form['#node'];
  if (project_node_type_is_project($node->type)) {
    // On node forms, if we're updating a project, don't let the user directly
    // manipulate field_project_type but force them to go through the promote
    // UI instead. Only display the project type field on initial creation.
    if (!empty($form['field_project_type']) && (!empty($node->field_project_type[LANGUAGE_NONE][0]['value']) || !(user_access('create full projects') || user_access("create full {$node->type} projects")))) {
      $form['field_project_type']['#access'] = FALSE;
      if (!isset($node->nid) && !(user_access('create full projects') || user_access("create full {$node->type} projects"))) {
        $form['field_project_type'][LANGUAGE_NONE]['#default_value'] = array('sandbox');
        if (variable_get('project_sandbox_numeric_shortname', FALSE)) {
          $form_state['input']['field_project_type'][LANGUAGE_NONE] = 'sandbox';
          $form['field_project_machine_name']['#access'] = FALSE;
        }
      }
    }

    if (!empty($form['field_project_machine_name'])) {
      $language = $form['field_project_machine_name']['#language'];
      $form['field_project_machine_name'][$language][0]['value']['#element_validate'][] = 'project_validate_project_shortname';

      if (variable_get('project_sandbox_numeric_shortname', FALSE)) {
        $form['field_project_machine_name'][$language][0]['value']['#states']['optional'] =
          $form['field_project_machine_name'][$language][0]['value']['#states']['invisible'] = array(
            ':input[name="field_project_type[' . $language . ']"]' => array('value' => 'sandbox'),
          );
        $form['field_project_machine_name'][$language][0]['value']['#after_build'][] = '_project_build_sandbox_machine_name';
      }
    }

    project_project_set_breadcrumb($node);
  }
}

/**
 * Validate the short name (machine name) of a project node.
 */
function project_validate_project_shortname($element, &$form_state, $form) {
  if (!empty($element['#value'])) {
    // Make sure machine name isn't already in use, or reserved.  Includes all
    // X from project/issues/X paths used in project_issues module
    $reserved_names = array('user', 'issues', 'releases', 'rss', 'subscribe-mail', 'search', 'add', 'update_project', 'statistics', 'comments', 'autocomplete', 'cvs', 'developers', 'usage');
    if (in_array(strtolower($element['#value']), $reserved_names)) {
      form_error($element, t('This project short name is reserved.'));
    }

    $existing_nid = project_get_nid_from_machinename($element['#value']);
    if (!empty($existing_nid) && (!isset($element['#entity']->nid) || $existing_nid != $element['#entity']->nid)) {
      form_error($element, t('This project short name is already in use.'));
    }
    if (variable_get('project_require_lowercase_machinename', FALSE) && $element['#value'] != drupal_strtolower($element['#value'])) {
      form_error($element, t('Please use lowercase for the project short name.'));
    }
  }
}

/**
 * Do not require machine name when we are going to generate a numeric one.
 */
function _project_build_sandbox_machine_name($element, $form_state) {
  if ((isset($form_state['input']['field_project_type']) && $form_state['input']['field_project_type'][$form_state['node']->language] === 'sandbox') || project_promote_project_is_sandbox($form_state['node'])) {
    $element['#required'] = FALSE;
  }
  return $element;
}

/**
 * Find a project node ID (nid) based on project machine name (shortname).
 *
 * @param $machinename
 *   The project machine name (shortname) to search for.
 *
 * @return
 *   The project node ID (nid) of the given project, or FALSE if not found.
 */
function project_get_nid_from_machinename($machinename) {
  // @TODO : is the static caching here useful at all ?  Does it ever "hit" or
  // is it just needless complication ?
  static $nids = array();
  if (isset($nids[$machinename])) {
    return $nids[$machinename];
  }

  $query = new EntityFieldQuery();
  $result = $query->entityCondition('entity_type', 'node', '=')
    ->fieldCondition('field_project_machine_name', 'value', $machinename, '=')
    ->execute();
  if (!empty($result['node'])) {
    foreach ($result['node'] as $matchingnid => $matchingobj) {
      // Check node type without doing an entity_load()
      if (!isset($matchingobj->type) || !project_node_type_is_project($matchingobj->type)) {
        continue;
      }
      $nids[$machinename] = $matchingnid;
    }
  }
  // return the nid
  if (array_key_exists($machinename, $nids)) {
    return $nids[$machinename];
  }
  else {
    return FALSE;
  }
}

/**
 * Implements hook_modules_enabled(). Sets default pathauto patterns.
 */
function project_project_modules_enabled($modules) {
  if (in_array('pathauto', $modules)) {
    _project_set_pathauto_defaults();
  }
}

/**
 * Set default pathauto patterns for project node types, if not already set.
 */
function _project_set_pathauto_defaults() {
  foreach (project_project_node_types() as $type) {
    if (variable_get('pathauto_node_' . $type . '_pattern', FALSE) === FALSE) {
      variable_set('pathauto_node_' . $type . '_pattern', 'project/[node:field_project_machine_name]');
    }
  }
}

/**
 * Add a separate pathauto pattern for each type's sandbox projects.
 */
function project_form_pathauto_patterns_form_alter(&$form, &$form_state) {
  $types = node_type_get_types();
  foreach (project_project_node_types() as $type) {
    $form['node']['pathauto_node_' . $type . '_pattern'] = array(
      'pathauto_node_' . $type . '_pattern' => $form['node']['pathauto_node_' . $type . '_pattern'],
      'pathauto_node_' . $type . '_pattern_sandbox' => array_merge(
        $form['node']['pathauto_node_' . $type . '_pattern'],
        array(
          '#title' => t('Pattern for @name <em>sandbox</em> paths', array('@name' => $types[$type]->name)),
          '#default_value' => variable_get('pathauto_node_' . $type . '_pattern_sandbox', ''),
          '#parents' => array('pathauto_node_' . $type . '_pattern_sandbox'),
        )
      ),
    );
  }
}

/**
 * Implements hook_pathauto_alias_alter(). If available, use the project type's
 * sandbox alias.
 */
function project_pathauto_alias_alter(&$alias, array &$context) {
  if ($context['module'] === 'node' && project_node_type_is_project($context['type']) && ($context['op'] === 'insert' || $context['op'] === 'update')) {
    $sandbox_pattern = variable_get('pathauto_node_' . $context['type'] . '_pattern_sandbox', '');
    if (!empty($sandbox_pattern) && project_promote_project_is_sandbox($context['data']['node'])) {
      $context['pattern'] = $sandbox_pattern;

      // Replace any tokens in the pattern. Uses callback option to clean
      // replacements. No sanitization.
      $new_alias = token_replace($context['pattern'], $context['data'], array(
        'sanitize' => FALSE,
        'clear' => TRUE,
        'callback' => 'pathauto_clean_token_values',
        'language' => (object) array('language' => $context['language']),
        'pathauto' => TRUE,
      ));

      // Check if the token replacement has not actually replaced any values.
      // If that is the case, then stop because we should not generate an
      // alias. See token_scan().
      $pattern_tokens_removed = preg_replace('/\[[^\s\]:]*:[^\s\]]*\]/', '', $context['pattern']);
      if ($new_alias !== $pattern_tokens_removed) {
        $alias = pathauto_clean_alias($new_alias);
      }
    }
  }
}

/**
 * Menu callback for 'project/add'.
 */
function project_add_landing_page() {
  $project_node_types = project_project_node_types();
  if (count($project_node_types) == 1) {
    $type = array_shift($project_node_types);
    $type_url_str = str_replace('_', '-', $type);
    return drupal_goto('node/add/' . $type_url_str);
  }
  return theme('project_add_landing_page', array('types' => array_intersect_key(node_type_get_types(), array_flip($project_node_types))));
}

/**
 * Returns HTML for a list of available project node types for creation.
 *
 * @param $variables
 *   An associative array containing:
 *   - 'types': An array of bundle machine names.
 *
 * @see theme_node_add_list()
 */
function theme_project_add_landing_page($variables) {
  $project_types = $variables['types'];
  $output = '';

  if (count($project_types) > 1) {
    $output = '<dl class="node-type-list">';
    foreach ($project_types as $project_type) {
      $type_url_str = str_replace('_', '-', $project_type->type);
      $output .= '<dt>' . l($project_type->name, 'node/add/' . $type_url_str) . '</dt>';
      $output .= '<dd>' . filter_xss_admin($project_type->description) . '</dd>';
    }
    $output .= '</dl>';
  }
  else {
    if (user_access('administer content types')) {
      $output = '<p>' . t('There are no content types configured to be projects. <a href="@configure-content-type">Configure</a> one of the available content types first.', array('@configure-content-type' => url('admin/structure/types'))) . '</p>';
    }
    else {
      $output = '<p>' . t('There are no content types configured to be projects.') . '</p>';
    }
  }
  return $output;
}

/**
 * Determines if an account can create projects.
 *
 * @param $account
 *   A user object. If not provided, the current user is used.
 *
 * @return boolean
 *   User can or cannot create a project.
 */
function project_user_can_create_project($account = NULL) {
  global $user;
  if (!isset($account)) {
    $account = $user;
  }
  // See if the account has a simple global permission to create any project.
  if (user_access('create full projects', $account) || user_access('create sandbox projects', $account)) {
    return TRUE;
  }
  else {
    // Check individual node type permissions.
    foreach (project_project_node_types() as $type) {
      if (user_access("create full {$type} projects", $account)) {
        return TRUE;
      }
    }
    // Otherwise the account did not have permission to create any projects.
    return FALSE;
  }
}
