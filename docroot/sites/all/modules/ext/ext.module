<?php

/**
 * @file
 * Provides integration functions for the Ext JS framework.
 */

define('EXT_NAMESPACE_DEFAULT', 'DrupalExt');

function ext_init() {
  //ext_load();
  $check = _ext_check_library();
  if ($check !== NULL) {
    drupal_set_message($check, 'error');
  }
  
  drupal_add_css(drupal_get_path('module', 'ext') . '/css/ext.admin.css', array('group' => CSS_DEFAULT, 'type' => 'file'));
}

function ext_page() {
  ext_load();
  return "coming soon...";
}

/**
 * Implementation of hook_menu.
 */
function ext_menu() {
  $items = array();

  $items['ext/page'] = array( // Loads the Ext page.
      'type' => MENU_CALLBACK,
      'page callback' => 'ext_page',
      'access callback' => TRUE,
  );

  $items['admin/build/ext'] = array(
      'title' => 'Ext',
      'description' => 'Adjust Ext settings.',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('ext_admin_form'),
      'access arguments' => array('administer site configuration'),
      'file' => 'includes/ext.ext.admin.inc',
      'weight' => 0,
  );

  $items['admin/build/ext/settings'] = array(
      'title' => 'Basic settings',
      'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $weight = 0;

  foreach (array('model' => 'Model', 'store' => 'Store') as $def_type => $def_type_label) {
    $items["admin/build/ext/{$def_type}s"] = array(
        'type' => MENU_LOCAL_TASK,
        'title' => "{$def_type_label}s",
        'description' => "Configure Ext {$def_type}s",
        'page callback' => "ext_admin_{$def_type}s_page",
        'access arguments' => array('administer site configuration'),
        'file' => 'includes/ext.ext.admin.inc',
        'weight' => $def_type == 'model' ? 1 : 2,
    );
    $items["admin/build/ext/{$def_type}s/list"] = array(
        'title' => "List {$def_type_label}s",
        'type' => MENU_DEFAULT_LOCAL_TASK,
        'weight' => 0,
    );

    $items["admin/build/ext/{$def_type}s/add"] = array(
        //$items["admin/build/ext/%s/add"] = array(

        'type' => MENU_LOCAL_TASK,
        'title' => "Add $def_type_label",
        'page callback' => 'drupal_get_form',
        'page arguments' => array("ext_admin_add_type_form", $def_type),
        //'page callback' => 'ext_admin_add_type_form',
        //'page arguments' => array(3),

        'access arguments' => array('administer site configuration'),
        'file' => 'includes/ext.ext.admin.inc',
        'weight' => 1,
    );

    $items["admin/build/ext/{$def_type}s/add/%"] = array(
        'type' => MENU_CALLBACK,
        'title' => "Add !type $def_type_label",
        'title arguments' => array('!type' => 5),
        'page callback' => 'drupal_get_form',
        'page arguments' => array("ext_admin_add_form", $def_type, 5),
        'access arguments' => array('administer site configuration'),
        'file' => 'includes/ext.ext.admin.inc',
    );
    $items["admin/build/ext/{$def_type}s/edit/%/%"] = array(
        'type' => MENU_CALLBACK,
        'title' => "Edit $def_type_label '!name'",
        'title arguments' => array('!name' => 6),
        'page callback' => 'drupal_get_form',
        'page arguments' => array("ext_admin_edit_form", $def_type, 5, 6),
        'access arguments' => array('administer site configuration'),
        'file' => 'includes/ext.ext.admin.inc',
    );
    $items["admin/build/ext/{$def_type}s/delete/%/%"] = array(
        'type' => MENU_CALLBACK,
        'title' => "Delete $def_type_label '!name'",
        'title arguments' => array('!name' => 6),
        'page callback' => 'drupal_get_form',
        'page arguments' => array("ext_admin_delete_form", $def_type, 5, 6),
        'access arguments' => array('administer site configuration'),
        'file' => 'includes/ext.ext.admin.inc',
    );
  }

  // RESTful API.
  $items['ext/rest/%/%'] = array( // For POST and PUT requests.
      'type' => MENU_CALLBACK,
      'page callback' => 'ext_rest',
      'page arguments' => array(2, 3),
      'access callback' => TRUE,
  );
  $items['ext/rest/%/%/%'] = array(  // For GET and DELETE requests.
      'type' => MENU_CALLBACK,
      'page callback' => 'ext_rest',
      'page arguments' => array(2, 3, 4),
      'access callback' => TRUE,
  );


  return $items;
}


function ext_enabled() {
  return variable_get('ext_enabled', TRUE);
}


/**
 * Load the Ext library and Drupal integration application.
 * @param $load Set to TRUE to load Ext, set to FALSE to get the current loaded state. Default: TRUE.
 * @return TRUE if the library is loaded, FALSE otherwise.
 */
function ext_load($load = TRUE) {
  static $loaded = FALSE;

  // Make sure the library is only loaded once.
  if (ext_enabled() && !$loaded) {
    $gen_js_path = ext_get_generated_js_path();
    $js_names = variable_get('ext_generated_files', FALSE);

    // Attempt to generate JS if it doesn't seem to have been generated yet.
    if (!$js_names) {
      _ext_generate_js();
    }
    $js_names = variable_get('ext_generated_files', FALSE);

    // Only attempt to load the Ext library if the generated JS is present.
    if ($gen_js_path && $js_names) {
      drupal_add_css(ext_get_path(). "/resources/css/ext-all.css");
      drupal_add_js(ext_get_path(). "/". variable_get('ext_library_file', 'ext-all.js'));

      // This (loading all generated files) is incorrect, Ext loads them again via its own "Loader".
      // We must either use dynamic class loading or the custom build facilities provided by Ext.
      //_ext_process_js('load', $gen_js_path, $js_names);

      // TODO: For now we just use dynamic class loading, in the future we
      // should allow use of the "custom build" option provided by Ext.
      drupal_add_js($gen_js_path. "/Application.js");

      //drupal_add_js(drupal_get_path('module', 'ext'). "/js/ext.test.js");
    }

    if (function_exists('admin_menu_suppress')) {
      admin_menu_suppress();
    }

    drupal_add_css(drupal_get_path('module', 'ext'). "/css/ext_drupal_reset.css");

    _ext_module_load_all_includes('ext', 'inc', 'includes');
    module_invoke_all('ext_load');

    $loaded = TRUE;
  }

  return $loaded;
}


/**
 * Returns the path to the Ext library or FALSE if not found.
 */
function ext_get_path() {
  // Below is taken from jquery_ui module.

  static $path;

  if (isset($path)) {
    return $path;
  }
  $path = FALSE;

  // Libraries API integration.
  if (function_exists('libraries_get_path')) {
    $path = libraries_get_path('ext');
    // Libraries API 1.x returns a default path; 2.x returns FALSE.
    if ($path !== FALSE && !file_exists($path)) {
      $path = FALSE;
    }
  }
  // Manually check sites/all/libraries in case Libraries API is not available.
  elseif (file_exists('./sites/all/libraries/ext')) {
    $path = 'sites/all/libraries/ext';
  }

  return $path;
}


/**
 * Returns the path, relative to the default files directory, to the directory
 * containing the generated javascript integration code.
 * This will also attempt to create required sub-directories if necessary.
 * If the required sub-directions could not be created FALSE is returned.
 */
function ext_get_generated_js_path() {
  //D6: $gen_js_path = file_directory_path() .'/ext';
  $gen_js_path = 'public://ext';//file_stream_wrapper_get_instance_by_uri('public://')->getDirectoryPath().'/ext';
  //D6 if (!file_check_directory($gen_js_path, FILE_CREATE_DIRECTORY))
  if (!file_prepare_directory($gen_js_path, FILE_CREATE_DIRECTORY))
    return FALSE;
  $gen_js_path .= '/'. ext_get_namespace();
  if (!file_prepare_directory($gen_js_path, FILE_CREATE_DIRECTORY))
    return FALSE;
  return $gen_js_path;
}


/**
 * Implementation of hook_form_alter.
 * Regenerates JS when relevant settings are updated.
 */
function ext_form_alter(&$form, $form_state, $form_id) {
  if (in_array($form_id, array('node_type_form', 'node_type_delete_confirm', 'content_field_edit_form', 'content_field_remove_form', 'views_ui_delete_confirm'))) {
    array_push ($form['#submit'], 'ext_regenerate_js');
  }

  if ($form_id == 'views_ui_edit_view_form') {
    array_push ($form['buttons']['save']['#submit'], 'ext_regenerate_js');
  }
}


/**
 * Regenerates all javascript integration code.
 */
function ext_regenerate_js() {
  _ext_generate_js(TRUE);
}


/**
 * Respond to requests made via the REST interface.
 */
function ext_rest($type, $name, $id = NULL) {
  if (function_exists('admin_menu_suppress')) {
    admin_menu_suppress();
  }

  $action = $_SERVER['REQUEST_METHOD'];
  $op = _ext_rest_to_op($action);

  $access = FALSE;
  $access_handler = "ext_access_{$type}_data";
  if ($type == 'model') {
    $access = ext_access_model_data($id, $name, $op);
  }
  elseif ($type == 'store') {
    $access = ext_access_store_data($name, $_REQUEST);
  }
  if (!$access) {
    drupal_access_denied();
    watchdog('ext', "A REST request was denied to !op !name !id.", array('!name' => $name,'!op' => $action, '!id' => $id), WATCHDOG_WARNING);
    return;
  }

  $return = NULL;
  if ($type == 'model') {
    $return = _ext_rest_model($op, $name, $id, $_REQUEST);
  }
  elseif ($type == 'store') {
    $return = _ext_rest_store($name, $_REQUEST);
  }

  $return = drupal_json_output($return);
  return $return;
}


/**
 * Translates from REST lingo to CRUD/Drupal lingo.
 */
function _ext_rest_to_op($rest_action) {
  static $rest_to_op = array(
      // Loading/getting the data requires 'view' permission as the
      // data will be available in the client-side JS.
      'GET' => 'view', // Also known as 'retrieve'.
      'PUT' => 'update',
      'POST' => 'create',
      'DELETE' => 'delete',
  );
  if (isset($rest_to_op[$rest_action]))
    return $rest_to_op[$rest_action];
  return FALSE;
}


/**
 * Helper function for ext_rest.
 * @param $action One of 'view', 'update', 'create', 'delete'.
 * @param $name The name of the Model.
 * @param $id Optional Model instance ID.
 * @param $options See ext_load_model_data().
 */
function _ext_rest_model($action, $name, $id = NULL, $options = array()) {
  $op = _ext_rest_to_op($action);
  $model = ext_get_models($name);
  $reader_root = $model['proxy']['reader']['root'];
  $return = array('success' => FALSE);

  if ($action == 'view') {
    $data = ext_load_model_data($id, $name, $options);
    if ($data) {
      $return['success'] = TRUE;
      $return[$reader_root] = $data;
    }
  }
  elseif ($action == 'update' || $action == 'create') {
    // Note: $id is ignored for PUT as it is in the JSON data.

    $data = NULL;
    if (function_exists('http_get_request_body')) {
      $data = http_get_request_body();
    }
    if ($data === NULL) {
      // Try alternate method in case http_get_request_body() wasn't available or failed.
      $data = @file_get_contents('php://input');
    }

    if (!$data) {
      watchdog('ext', "Missing JSON data in REST request for Model !model and instance ID !id",
      array('!model' => $name, '!id' => $id), WATCHDOG_ERROR);
      return;
    }

    // Decode JSON response, decoding any JSON objects as associative arrays.
    $data = json_decode($data, TRUE);
    if ($data === NULL) {
      watchdog('ext', "Badly formed JSON data in REST request for Model !model and instance ID !id",
      array('!model' => $name, '!id' => $id), WATCHDOG_ERROR);
      return;
    }

    if (ext_save_model_data($data, $name, $action == 'create', $options)) {
      $return['success'] = TRUE;
      $return[$reader_root] = $data;
    }
  }
  elseif ($action == 'delete') {
    $return['success'] = ext_delete_model_data($id, $name);
  }
  else {
    drupal_not_found();
  }
  return $return;
}


/**
 * Helper function for ext_rest.
 * @param $name The name of the Store.
 * @param $id Optional Model instance ID.
 */
function _ext_rest_store($name, $options = NULL) {
  // Decode filters, groupers and sorters, and our custom options.
  foreach (array('filter', 'group', 'sort', 'load_nested_max_depth') as $el) {
    if (isset($options[$el]) && is_string($options[$el])) {
      $options[$el] = json_decode($options[$el], TRUE);
    }
  }

  $store = ext_get_stores($name);
  $reader_root = $store['proxy']['reader']['root'];
  $return = array('success' => FALSE);
  $data = ext_load_store_data($name, $options);
  if ($data !== FALSE) {
    $return['success'] = TRUE;
    $return[$reader_root] = $data;
  }

  return $return;
}


function ext_get_namespace() {
  return variable_get('ext_namespace', EXT_NAMESPACE_DEFAULT);
}


/**
 * Determine if the current or given user has permission to perform the
 * specified operation on the specified Model data. This function provides a
 * unified interface for determining access permissions for all Model types.
 * hook_ext_access_model_data is invoked on the module defining the Model type.
 *
 * @param $model_instance_id Usually this will be an ID corresponding to the
 *   relevant Drupal "object", eg a node or user ID for a Node or User Model.
 * @param $model_name The name of the Model in question.
 * @param $op The operation in question, this can be one of 'create', 'view',
 *   'update' or 'delete'.
 * @param $account The account for the user in question. If not given defaults
 *   to the current user.
 * @return TRUE if the user is allowed to perform the operation on the Model
 *   (instance), FALSE otherwise.
 */
function ext_access_model_data($model_instance_id, $model_name, $op, $account = NULL) {
  if (!in_array($op, array('create', 'view', 'update', 'delete')))
    return FALSE;
  $model = ext_get_models($model_name);

  if (!$model)
    return FALSE;
  if (!$account) {
    global $user;
    $account = $user;
  }

  _ext_module_load_include($model['#module'], 'ext', 'inc', 'includes');
  return module_invoke($model['#module'], 'ext_access_model_data', $model_instance_id, $model_name, $op, $account);
}


/**
 * Load the data for an Ext Model instance or instances. This function provides a unified
 * interface for retrieving instance data for all Model types.
 * hook_ext_load_model_data is invoked on the module defining the Model type,
 * and then hook_ext_load_model_data_alter is invoked to allow other modules
 * to modify the instance data.
 * 
 * This method will automatically attempt to load associated data via an
 * appropriate Store if available if the 'load_nested_max_depth' option is
 * set in the $options parameter OR if '#load_nested_max_depth' is set
 * and greater than 0 for the association definition in the model definition.
 *
 * @param $model_instance_id Usually this will be an ID or array of IDs corresponding to the
 *   relevant piece of Drupal data, typically an entity, such as a node or user ID for a
 *   Node or User Model.
 * @param $model_name The name of the Model to load instance data for.
 * @param $options An array of options that may be used by some
 *   implementations of hook_ext_load_model_data. Options defined (and
 *   reserved) by the ext module are:
 *   
 *   'load_nested_max_depth': Optionally set the maximum number of levels
 *     of nested data to include (integer > 0), or force no nested to be
 *     included (-1). A value of 0 specifies use of the value defined in the
 *     relevant Model definition (in the '#load_nested_max_depth' property), or
 *     to load no nested data if this is not defined. This may also
 *     be an associative array keyed by the associationKey values of the relevant
 *     associations and with values specifying the maximum number of levels of
 *     nested data to include. If an array is given and it doesn't define a
 *     maximum depth for an association in the relevant Model then the default
 *     specified in the Model definition will be used if available, otherwise 0
 *     will be used. Default is 0.
 *   
 *   'load_nested_depth': Internal use (current depth of recursive calls).
 *   
 *   'load_nested_parent_id': When Model instance data is being loaded for the
 *     nested data via an association, this gives the ID of the parent Model
 *     instance.
 *   
 *   'load_nested_parent': When Model instance data is being loaded for the
 *     nested data via an association, this is the instance data for the parent
 *     Model instance (note that this may include some but not all nested data).
 *   
 *   'load_nested_limit': Optionally set the 'limit' option for the Store for nested 
 *     data specified by associations (see @link ext_load_store_data())
 *     A value of 0 specifies unlimited. This may also be an associative array 
 *     keyed by the associationKey values of the relevant associations. If an array 
 *     is given and it doesn't define a limit for an association in the relevant 
 *     Model then the default is used. Default is 100.
 *     
 *   'load_nested_start': Optionally set the 'start' option for the Store for nested 
 *     data specified by associations (see @link ext_load_store_data()). 
 *     This may also be an associative array keyed by the associationKey values of 
 *     the relevant associations. If an array is given and it doesn't define a
 *     start value for an association in the relevant Model then the default is
 *     used. Default is 0.
 *     
 *   'load_nested_sort': Optionally set the 'sort' option for the Store for nested 
 *     data specified by associations (see @link ext_load_store_data()). 
 *     This may also be an associative array of sort definition arrays, keyed by the 
 *     associationKey values of the relevant associations.
 *     
 *   'load_nested_filter': Optionally set the 'filter' option for the Store for nested 
 *     data specified by associations (see @link ext_load_store_data()).
 *     This may also be an associative array of filter definition arrays, keyed by the 
 *     associationKey values of the relevant associations.
 *     
 * @return If a single ID is passed then the model data array, otherwise an
 *   array of model data.
 */
function ext_load_model_data($model_instance_id, $model_name, $options = array()) {
  static $_store_for_has_many_association = array();

  $model = ext_get_models($model_name);
  if (!$model)
    return FALSE;

  _ext_module_load_all_includes('ext', 'inc', 'includes');
  $single = !is_array($model_instance_id);
  if ($single) $model_instance_id = array($model_instance_id);
  $model_data = module_invoke($model['#module'], 'ext_load_model_data', $model_instance_id, $model_name, $options);

  foreach ($model_data as &$data) {
    $id = $data[$model['idProperty']];
    $data = _ext_process_loaded_model_data($model, $id, $data, $options);
    drupal_alter('ext_load_model_data', $data, $model_name, $options);
  }

  return $single ? array_pop($model_data) : $model_data;
}

// Helper function for ext_load_model_data
function _ext_process_loaded_model_data($model, $model_instance_id, $data, $options = array()) {
  static $_store_for_has_many_association = array();

  // Populate new model instance with retrieved data.
  $model_data = array();
  foreach ($model['fields'] as $field) {
    $field_name = $field['name'];
    $model_data[$field_name] = isset($data[$field_name]) ? $data[$field_name] : NULL;
  }

  $load_nested_max_depth = isset($options['load_nested_max_depth']) ? $options['load_nested_max_depth'] : 0;
  $load_nested_depth = isset($options['load_nested_depth']) ? $options['load_nested_depth'] : 0;
  $options['load_nested_max_depth'] = $load_nested_max_depth;
  $options['load_nested_depth'] = $load_nested_depth;

  // If maximum depths are defined for individual associations, OR,
  // if we should use the maximum depth defined by the Model definition, OR
  // if a single maximum depth has been specified and it's greater than the current depth.
  if (is_array($load_nested_max_depth) || $load_nested_max_depth == 0 || $load_nested_max_depth > $load_nested_depth) {
    // Load nested data for associations if specified.
    if (isset($model['associations'])) {
      foreach ($model['associations'] as $assoc) {
        // Assume initially that we use the max depth defined by the Model def.
        $load_nested_max_depth_assoc = isset($assoc['#load_nested_max_depth']) ? $assoc['#load_nested_max_depth'] : 0;
        // If maximum depths are defined for individual associations.
        if (is_array($load_nested_max_depth)) {
          // If a maximum depth is defined for this association.
          if (isset ($load_nested_max_depth[$assoc['associationKey']])) {
            $load_nested_max_depth_assoc = $load_nested_max_depth[$assoc['associationKey']];
          }
        }
        // If we should use the single max depth specified in the function call.
        elseif ($load_nested_max_depth > 0) {
          $load_nested_max_depth_assoc = $load_nested_max_depth;
        }

        if ($load_nested_max_depth_assoc > $load_nested_depth) {
          $sub_options = $options;
          $sub_options['load_nested_parent_id'] = $model_instance_id;
          $sub_options['load_nested_parent'] = $model_data;
          if ($assoc['type'] == 'belongsTo') {
            // Load the associated Model instance.
            if (isset($model_data[$assoc['foreignKey']])) {
              $assoc_model_id = $model_data[$assoc['foreignKey']];
              $sub_options['load_nested_depth']++;
              $assoc_model_data = ext_load_model_data($assoc_model_id, $assoc['model'], $sub_options);
              if ($assoc_model_data) {
                $model_data[$assoc['associationKey']] = $assoc_model_data;
              }
            }
            else {
              $model_data[$assoc['associationKey']] = NULL;
            }
          }
          elseif ($assoc['type'] == 'hasMany') {
            // Find a Store to retreive the associated Model instances.
            // See if we've already cached which store to use for the associated Model and foreign key.
            if (!isset($_store_for_has_many_association[$assoc['model']]) || !isset($_store_for_has_many_association[$assoc['model']][$assoc['foreignKey']])) {
              $stores = _ext_get_stores_for_model($assoc['model'], array($assoc['foreignKey']));
              if (!empty($stores)) {
                // Stores are sorted by generic first, so use the first one.
                $_store_for_has_many_association[$assoc['model']][$assoc['foreignKey']] = $stores[0];
              }
            }

            if (isset($_store_for_has_many_association[$assoc['model']]) && isset($_store_for_has_many_association[$assoc['model']][$assoc['foreignKey']])) {
              $store = $_store_for_has_many_association[$assoc['model']][$assoc['foreignKey']];
              
              // Allow specifying some options for the store load for a hasMany association.
              // Or supply sensible defaults as necessary,
              foreach (array('start' => 0, 'limit' => 100) as $opt => $default) {
                $sub_options[$opt] = $default;
                if (isset($options["load_nested_$opt"])) {
                  if (is_array($options["load_nested_$opt"])) {
                    if (isset($options["load_nested_$opt"][$assoc['associationKey']])) {
                      $sub_options[$opt] = $options["load_nested_$opt"][$assoc['associationKey']];
                    }
                  }
                  else {
                    $sub_options[$opt] = $options["load_nested_$opt"];
                  }
                }
              }
              foreach (array('sort' => array(), 'filter' => array()) as $opt => $default) {
                $sub_options[$opt] = $default;
                if (isset($options["load_nested_$opt"])) {
                  if (is_array(array_shift(array_values($options["load_nested_$opt"])))) {
                    if (isset($options["load_nested_$opt"][$assoc['associationKey']])) {
                      $sub_options[$opt][] = $options["load_nested_$opt"][$assoc['associationKey']];
                    }
                  }
                  else {
                    $sub_options[$opt][] = $options["load_nested_$opt"];
                  }
                }
              }
              
              // Create filter for store to filter by the ID of the associated Model.
              $sub_options['filter'][] = array(
                  'property' => $assoc['foreignKey'],
                  'value' => $model_data[$assoc['primaryKey']],
              );
              
              $sub_options['load_nested_depth']++;
              
              $model_data[$assoc['associationKey']] = array_values(ext_load_store_data($store, $sub_options));
            }
          }
        }
      }
    }
  }

  return $model_data;
}



/**
 * Save the data for an Ext Model instance. This function provides a unified
 * interface for saving instance data for all Model types.
 * hook_ext_save_model_data_alter is invoked to allow other modules to modify
 * the instance data before hook_ext_save_model_data is invoked on the module
 * defining the Model type to allow it to actually save the data.
 *
 * @param $data The instance data to save. Should be an array keyed by the
 *   field names of the model $model_name. Any data added or altered during
 *   the save will be reflected in this variable upon completion.
 * @param $model_name The name of the Model to save instance data for.
 * @param $new If set to TRUE then a new instance will be created, otherwise
 *   an existing instance will be updated if the $data has the primary ID set.
 *   Defaults to FALSE.
 * @param $options An optional array of options that may be used by some
 *   implementations of hook_ext_save_model_data. See ext_load_model_data for 
 *   a list of reserved key values. Options are typically passed via the REST
 *   create/put request.
 * @return TRUE if the save was successful, FALSE otherwise.
 */
function ext_save_model_data(&$data, $model_name, $new = FALSE, $options = array()) {
  $model = ext_get_models($model_name);
  if (!$model)
    return FALSE;
  _ext_module_load_all_includes('ext', 'inc', 'includes');
  // Allow other modules to modify the data to save.
  drupal_alter('ext_save_model_data', $data, $model_name);
  $function = $model['#module']. '_ext_save_model_data';
  return $function($data, $model_name, $new, $options);
}


/**
 * Validate the given Model instance data. This function provides a unified
 * interface for validating instance data for all Model types.
 * This function invokes hook_ext_validate_model_data on all modules.
 *
 * @param $data The instance data to validate. Should be an array keyed by the
 *   field names of the model $model_name.
 * @param $model_name The name of the Model to validate instance data for.
 * @return An array keyed by field names containing translated error messages,
 *  or if there are no errors an empty array.
 */
function ext_validate_model_data(&$data, $model_name) {
  $model = ext_get_models($model_name);
  if (!$model)
    return FALSE;
  _ext_module_load_all_includes('ext', 'inc', 'includes');
  return module_invoke_all('ext_validate_model_data', $data, $model_name);
}


/**
 * Delete the given Model instance data. This function provides a unified
 * interface for deleting instance data for all Model types.
 *
 * @param $model_instance_id Usually this will be an ID corresponding to the
 *   relevant Drupal "object", eg a node or user ID for a Node or User Model.
 * @param $model_name The name of the Model to validate instance data for.
 * @return TRUE if the instance was deleted, FALSE otherwise.
 */
function ext_delete_model_data($model_instance_id, $model_name) {
  $model = ext_get_models($model_name);
  if (!$model)
    return FALSE;
  _ext_module_load_include($model['#module'], 'ext', 'inc', 'includes');
  return module_invoke($model['#module'], 'ext_delete_model_data', $model_instance_id, $model_name);
}


/**
 * Determine if the current or given user has permission to perform the
 * specified operation on the specified Store. This function provides a
 * unified interface for determining access permissions for all Model types.
 * hook_ext_access_store_data is invoked on the module defining the Store type.
 *
 * @param $store_name The name of the Model in question.
 * @param $options An associative array containing information that
 the module defining the Store needs to determine the result set (eg View
 arguments).
 * @param $account The account for the user in question. If not given defaults
 *   to the current user.
 * @return TRUE if the user is allowed to perform the operation on the Model
 *   (instance), FALSE otherwise.
 */
function ext_access_store_data($store_name, $options, $account = NULL) {
  $store = ext_get_stores($store_name);
  if (!$store)
    return FALSE;

  if (!$account) {
    global $user;
    $account = $user;
  }

  _ext_module_load_include($store['#module'], 'ext', 'inc', 'includes');
  return module_invoke($store['#module'], 'ext_access_store_data', $store_name, $options, $account);
}


/**
 * Load Model instances for an Ext Store. This function provides a unified
 * interface for retrieving Model instance data for all Store types.
 * hook_ext_load_store_data is invoked on the module defining the Store type.
 *
 * A custom option that may be specified in $options is 'load_nested_max_depth',
 * which specifies the depth of nested model data to include from associations.
 * See ext_load_model_data() for more information.
 *
 * @param $store_name The name of the Model to load instance data for.
 * @param $options An array of options used to query the store, such as 'limit',
 *   'start' and 'page' or filters and sorters.
 * @param $ids_only Set to TRUE to only retreive an array of Model instance
 *   IDs. Default is FALSE.
 */
function ext_load_store_data($store_name, $options = array(), $ids_only=FALSE) {
  $store = ext_get_stores($store_name);
  if (!$store)
    return FALSE;

  _ext_module_load_all_includes('ext', 'inc', 'includes');
  $data_or_ids = module_invoke($store['#module'], 'ext_load_store_data', $store_name, $options);
  if ($data_or_ids === FALSE)
    return FALSE;
  if (empty($data_or_ids))
    return $data_or_ids;

  $store_data = NULL;
  // hook_ext_load_store_data can return either Model instance IDs or
  // populated Model instances.
  if (is_numeric($data_or_ids[0])) {
    if ($ids_only) {
      return $data_or_ids;
    }

    // Load data for all instances.
    $store_data = ext_load_model_data($data_or_ids, $store['model'], $options);
  }
  else {
    if ($ids_only) {
      $model = ext_get_models($store['model']);
      return _ext_extract_values_from_sub_arrays_by_key($model['idProperty'], $data_or_ids);
    }
    $store_data = $data_or_ids;
  }

  return $store_data;
}


/**
 * Returns info for all defined Models.
 * @param Optionally specify a particular Model.
 * @return Array, keyed by Model names, of associative arrays containing info
 *   about each Model, or if $model_name is given and it exists then a single
 *   associative array containing info about the specified Model, otherwise
 *   FALSE.
 * @param $reset Whether to reset the cache.
 */
function ext_get_models($model_name = NULL, $reset = FALSE) {
  static $models;
  //$reset = true;
  if (empty($models) || $reset) {
    if (!$reset)
      $models = cache_get('ext_models');
    if (!$models || $reset) {
      _ext_module_load_all_includes('ext', 'inc', 'includes');
      $models = array();
      $types = array();
      foreach (module_implements('ext_models') as $module) {
        $result = call_user_func($module .'_ext_models');
        if (isset($result) && is_array($result)) {
          // Record which module implements each Model.
          foreach ($result as $name => &$model) {
            $model['#name'] = $name;
            $model['#enabled'] = ext_model_is_enabled($name, TRUE);
            $model['#module'] = $module; // Not necessary, but convenient.
            $model['#server_validate'] = isset($model['#server_validate']) ? $model['#server_validate'] : FALSE;
            $model['requires'] = isset($model['requires']) ? $model['requires'] : array();
            if (!isset($model['alternateClassName'])) {
              $model['alternateClassName'] = array("model.$name");
            }
            
            if (isset($model['associations'])) {
              $associations = array();
              foreach ($model['associations'] as &$assoc) {
                // Set default associationKey and function names if not set.
                ext_model_association_name($assoc);
                
                // Key assocations array by associationKey for convenience.
                // These keys are stripped when generating JS.
                $associations[$assoc['associationKey']] = $assoc;
              }
              $model['associations'] = $associations;
            }

            if (isset($model['fields'])) {
              // Key fields array by field names for convenience.
              // These keys are stripped when generating JS.
              $fields = array();
              foreach ($model['fields'] as $field) {
                $fields[$field['name']] = $field;
              }
              $model['fields'] = $fields;
            }

            if (!isset($model['proxy'])) {
              $model['proxy'] = array(
                  'type' => 'rest',
                  'url' => _path_from_uri( "ext/rest/model/$name"),
                  'reader' => array(
                      'type' => 'json',
                      'root' => isset($model['#proxy_reader_root']) ? $model['#proxy_reader_root'] : strtolower($name),
                  ),
                  'writer' => '<jscode>new Ext.data.writer.Json()</jscode>',
              );
              if (!in_array('Ext.data.writer.Json', $model['requires'])) {
                $model['requires'][] = 'Ext.data.writer.Json';
              }
              if (!in_array('Ext.data.proxy.Rest', $model['requires'])) {
                $model['requires'][] = 'Ext.data.proxy.Rest';
              }
            }
          }
          unset($model); // This is necessary due to the (not) bug described here: https://bugs.php.net/bug.php?id=29992
          $models = array_merge($models, $result);
        }

        // They should also have implemented hook_ext_model_types.
        $mod_types = module_invoke($module, 'ext_model_types');
        // Record which module implements each Model type.
        foreach ($mod_types as $type_name => $type) {
          $type['name'] = $type_name;
          $type['module'] = $module;
          $types[$type_name] = $type;
        }
      }
      
      // Inherit original associations here so we can generate reverse assocations for all extended models.
      // (We inherit all other properties (including reverse associations) after this).  
      _models_add_properties_from_extended($models, array('associations'));

      // Generate reverse associations for all association definitions.
      $reverse_associations = array();
      foreach ($models as $name => $model) {
        if (isset($model['associations'])) {
          foreach ($model['associations'] as $assoc_key => $assoc) {
            // If this isn't a reverse association we've already created and
            // reverse associations aren't suppressed for this association.
            if (empty($assoc['#reverse_of']) && empty($assoc['#no_reverse'])) {
              $reverse_assoc = array(
                  '#reverse_of' => $assoc['associationKey'],
                  'type' => $assoc['type'] == 'belongsTo' ? 'hasMany' : 'belongsTo',
                  'model' => $name,
                  //'primaryKey' => $model['idProperty'], // Primary ID of associated Model.
                  'primaryKey' => $assoc['primaryKey'], // Primary ID of associated Model.
                  'foreignKey' => $assoc['foreignKey'], // Remains the same.
              );
              //'primaryKey' => $primary_key, // Primary ID of associated Model.
              //'foreignKey' => $field_col_name, // Field name on this Model linking it to associated Model.
              // Set default associationKey and function names if not set.
              ext_model_association_name($reverse_assoc);

              // Add reverse association to associated Model.
              $assoc_name = $assoc['model'];
              if (!isset($models[$assoc_name]['associations'])) {
                $models[$assoc_name]['associations'] = array();
              }
              
              // Only add it if the association doesn't already exist.
              if (!isset($models[$assoc_name]['associations'][$reverse_assoc['associationKey']])) {
                $models[$assoc_name]['associations'][$reverse_assoc['associationKey']] = $reverse_assoc;
  
                // Record reverse association in original association.
                $models[$name]['associations'][$assoc_key]['#reverse_of'] = $reverse_assoc['associationKey'];
              }
            }
          }
        }
      }
      unset($model); // This is necessary due to the (not) bug described here: https://bugs.php.net/bug.php?id=29992
      
      // Inherit other properties.
      _models_add_properties_from_extended($models, array('fields', 'associations', 'validations'));

      // Allow modules to alter final Model definitions.
      drupal_alter('ext_models', $models);

      cache_set('ext_models', $models);
      cache_set('ext_model_types', $types);

      // Rebuild JS code in case definitions have changed.
      //_ext_generate_js($reset);  //Remove to prevent recursive function call
    }
    else {
      $models = $models->data;
    }
  }
  if ($model_name !== NULL) {
    if (isset($models[$model_name]))
      return $models[$model_name];
    return FALSE;
  }
  return $models;
}

// For each model add properties from extended models to it.
function _models_add_properties_from_extended(array &$models, array $properties) {
  // This isn't the most efficient method, but it only rarely gets run.
  foreach ($models as $name => &$model) {
    $current_model = &$model;
    $models_extended_list = array();
    while (isset($current_model['#extends'])) {
      $models_extended_list[$current_model['#name']] = $current_model['#name'];
      $current_model = &$models[$current_model['#extends']];

      if (isset($models_extended_list[$current_model['#name']])) {
        drupal_set_message(t("An error was found in a Model definition: a cycle was found in the hierarchy of Models extended by Model %name", array('%name' => $name)), 'error');
        watchdog('ext', "An error was found in a Model definition: a cycle was found in the hierarchy of Models extended by Model %name", array('%name' => $name), WATCHDOG_ERROR);
        break;
      }

      // Get list of currently defined field names.
      $field_names = array_keys($model['fields']);
      // Only inherit associations at this point.
      foreach ($properties as $key) {
        if (isset($current_model[$key])) {
          if (!isset($model[$key]))
            $model[$key] = array();

          if ($key == 'fields') {
            // Don't include fields from current extended Model that
            // have already been defined.
            foreach ($current_model[$key] as $field_name => $field_def) {
              if (!isset($field_names[$field_def['name']])) {
                $model[$key][$field_name] = $field_def;
              }
            }
          }
          else {
            $model[$key] = array_merge($model[$key], $current_model[$key]);
          }
        }
      }
      // We have to do server-side validation if any model in the chain
      // requires it.
      $model['#server_validate'] |= $current_model['#server_validate'];
    }
    
    // Remove duplicate association or validation definitions.
    $model = _ext_array_unique($model);
  }
}



/**
 * Returns info for all defined Stores.
 * @param Optionally specify a particular Store.
 * @return Array, keyed by Store names, of associative arrays containing info
 *   about each Store, or if $store_name is given and it exists then a single
 *   associative array containing info about the specified Store, otherwise
 *   FALSE.
 * @param $reset Whether to reset the cache.
 */
function ext_get_stores($store_name = NULL, $reset = FALSE) {
  static $stores;
  if (empty($stores) || $reset) {
    if (!$reset) {
      $stores = cache_get('ext_stores');
    }
    if (!$stores || $reset) {
      _ext_module_load_all_includes('ext', 'inc', 'includes');
      $stores = array();
      $types = array();
      // Create a Model to Store(s) map for efficient searching later on.
      $model_stores = array();
      foreach (module_implements('ext_stores') as $module) {
        $result = call_user_func($module .'_ext_stores');
        if (isset($result) && is_array($result)) {
          // Record which module implements each Store, set-up some other attributes.
          foreach ($result as $name => &$store) {
            $store['#name'] = $name;
            $store['#enabled'] = ext_store_is_enabled($name, TRUE);
            $store['#module'] = $module;
            $store['#class'] = isset($store['#class']) ? $store['#class'] : 'Ext.data.Store';
            $store['requires'] = isset($store['requires']) ? $store['requires'] : array();

            if (!isset($store['proxy'])) {
              $store['proxy'] = array(
                  'type' => 'rest',
                  'url' => _path_from_uri("ext/rest/store/$name"),
                  'reader' => array(
                      'type' => 'json',
                      'root' => isset($store['#proxy_reader_root']) ? $store['#proxy_reader_root'] : strtolower($name),
                  ),
                  'writer' => '<jscode>new Ext.data.writer.Json()</jscode>',
              );
              if (!in_array('Ext.data.proxy.Rest', $store['requires'])) {
                $store['requires'][] = 'Ext.data.proxy.Rest';
              }
              if (!in_array('Ext.data.writer.Json', $store['requires'])) {
                $store['requires'][] = 'Ext.data.writer.Json';
              }
              if (!in_array(ext_get_namespace(). ".model.". $store['model'], $store['requires'])) {
                $store['requires'][] = ext_get_namespace(). ".model.". $store['model'];
              }
            }

            $model = $store['model'];
            if (!isset($model_stores[$model])) {
              $model_stores[$model] = array();
            }
            $model_stores[$model][] = $name;
          }
          unset($store);
          $stores = array_merge($stores, $result);
        }

        // They should also have implemented hook_ext_store_types.
        $mod_types = module_invoke($module, 'ext_store_types');
        // Record which module implements each Model type.
        foreach ($mod_types as $type_name => $type) {
          $type['name'] = $type_name;
          $type['module'] = $module;
          $types[$type_name] = $type;
        }
      }

      // Allow modules to alter final Store definitions.
      drupal_alter('ext_stores', $stores);
      cache_set('ext_stores', $stores);
      cache_set('ext_store_types', $types);
      cache_set('ext_model_store_map', $model_stores);

      // Rebuild JS code in case definitions have changed.
      _ext_generate_js();
    }
    else {
      $stores = $stores->data;
    }
  }
  if ($store_name !== NULL) {
    if (isset($stores[$store_name]))
      return $stores[$store_name];
    return FALSE;
  }
  return $stores;
}


/**
 * Returns TRUE iff the Model with the given name is enabled.
 * @param $model_name The Model to query.
 */
function ext_model_is_enabled($model_name, $skip_exists_check=FALSE) {
  // Make sure the Model still exists.
  if (!$skip_exists_check && ext_get_models($model_name) === FALSE)
    return FALSE;
  $models_disabled = variable_get('ext_models_disabled', array());
  return (!isset($models_disabled[$model_name])) || !$models_disabled[$model_name];
}


/**
 * Returns TRUE iff the Store with the given name is enabled.
 * @param $store_name The Model to query.
 */
function ext_store_is_enabled($store_name, $skip_exists_check=FALSE) {
  // Make sure the Store still exists.
  if (!$skip_exists_check && ext_get_stores($store_name) === FALSE) {
    return FALSE;
  }
  $stores_disabled = variable_get('ext_stores_disabled', array());
  return (!isset($stores_disabled[$store_name])) || !$stores_disabled[$store_name];
}


/**
 * Returns info about the given Model type name, or all types if no type name
 * is specified.
 */
function ext_get_model_type($type=NULL, $reset=FALSE) {
  return _ext_get_type('model', $type, $reset);
}
/**
 * Returns info about the given Store type name, or all types if no type name
 * is specified.
 */
function ext_get_store_type($type=NULL, $reset=FALSE) {
  return _ext_get_type('store', $type, $reset);
}
function _ext_get_type($deftype, $type=NULL, $reset=FALSE) {
  static $all_types = array();
  if ($reset || !isset($all_types[$deftype])) {
    $cid = 'ext_'. $deftype. '_types';
    $cache = cache_get($cid);
    if (!$cache) {
      // This gets the Model or Store types and caches them.
      call_user_func('ext_get_'. $deftype. 's', NULL, TRUE);
      // Now we can retrieve them from cache.
      $cache = cache_get($cid);
    }
    $types = $cache->data;
    $all_types[$deftype] = $types;
  }
  if ($type != NULL) {
    return isset($all_types[$deftype][$type]) ? $all_types[$deftype][$type] : FALSE;
  }
  return $all_types[$deftype];
}


/**
 * Implementation of hook_ext_additional_js_files
 */
function ext_ext_additional_js_files() {
  return drupal_get_path('module', 'ext'). "/js/ext";
}



/**
 * Returns the names of Stores that handle the specifed Model. Allows
 * specifying fields that the Store(s) must be able to filter and sort on.
 * @param $model_name The name of the Model to get Stores for.
 * @param $filter_fields Optional. An array of field names that the Store needs to be able filter on.
 * @param $sort_fields Optional. An array of field names that the Store needs to be able sort on.
 * @return An array of Store names, with generic Stores first.
 */
function _ext_get_stores_for_model($model_name, $filter_fields = array(), $sort_fields = array()) {
  static $model_stores = array();
  if (empty($model_stores)) {
    $cache = cache_get('ext_model_store_map');
    if (!$cache) {
      // This will populate the ext_store_model_field_filterable_sortable array and caches it.
      ext_get_stores(NULL, TRUE);
      // Now we can retrieve them from cache.
      $cache = cache_get('ext_model_store_map');
    }
    $model_stores = $cache->data;
  }

  $matches = array();
  $matches_generic = array();
  if (isset($model_stores[$model_name])) {
    $stores = $model_stores[$model_name];
    foreach ($stores as $store_name) {
      $store = ext_get_stores($store_name);
      $store_filter_fields = isset($store['#filterable_fields']) ? $store['#filterable_fields'] : array();
      $store_sort_fields = isset($store['#sortable_fields']) ? $store['#sortable_fields'] : array();

      // Determine if the Store can filter and sort on all required fields.
      $diff_filter = array_diff($filter_fields, $store_filter_fields);
      $diff_sort = array_diff($sort_fields, $store_sort_fields);
      if (empty($diff_filter) && empty($diff_sort)) {
        if (empty($store['#generic'])) {
          $matches[] = $store_name;
        }
        else {
          $matches_generic[] = $store_name;
        }
      }
    }
  }
  $stores = array_merge($matches_generic, $matches);
  return $stores;
}


/**
 * Sets the associationKey and generated function names for an association
 * to a standard format. The foreignKey (the name of the field on the Model
 * defining the association) and the associated Model name are concatenated
 * to produce a name. If the foreignKey starts with 'field_' then this is
 * stripped from the generated name. The name is converted to CamelCase format.
 * If the association type is 'hasMany' then 'List' is appended to the name.
 *
 * The associationKey is then set to the name but with a lower case first
 * letter. If the association type is 'belongsTo' then the get and set
 * functions are set to the generic name prefixed with 'get' and 'set'
 * respectively. If the association type is 'hasMany' then the function name
 * (there's only one for 'hasMany' associations) is set to the generic name
 * with a lowercase first letter.
 *
 * @param $assoc The association definition to set standard associationKey
 *   and function names on.
 * @param $overwrite If set to TRUE then existing associationKey and function
 *   name settings will be overwritten.
 */
function ext_model_association_name(&$assoc, $overwrite = FALSE) {
  $model = $assoc['model'];
  $type = $assoc['type'];

  // The foreign key is the name of the field on the Model that defines the
  // association. We use this and the associated Model name to generate the
  // associationKey and names for the generated functions on the defining
  // Model. We strip 'field_' from the start of field names.
  $name = _ext_camelcase(preg_replace ('/^field_/' , '' , $assoc['foreignKey']). $model);

  if ($type == 'hasMany') {
    $name = _ext_lcfirst($name). 'List';
    if (!isset($assoc['associationKey']) || $overwrite) {
      $assoc['associationKey'] = $name;
    }
    if (!isset($assoc['name']) || $overwrite) {
      $assoc['name'] = $name;
    }
  }
  else { // $type == 'belongsTo'
    if (!isset($assoc['associationKey']) || $overwrite) {
      $assoc['associationKey'] = _ext_lcfirst($name);
    }
    if (!isset($assoc['getterName']) || $overwrite) {
      $assoc['getterName'] = "get". $name;
    }
    if (!isset($assoc['setterName']) || $overwrite) {
      $assoc['setterName'] = "set". $name;
    }
  }
}


/**
 * Checks for the existence of the Ext JS library.
 * @return NULL if the Ext JS library is found, otherwise a localised String describing how to install the library.
 */
function _ext_check_library() {
  $path = ext_get_path();
  if (!$path || !file_exists("./$path/ext-all.js")) {
    // This function can be called from ext_requirements, full Drupal API may not be available.
    $t = get_t();
    // Required library wasn't found. Provide instructions.
    $output = $t('The <a href="@ext">Ext</a> library is missing. <a href="@download">Download</a> and extract it into the <code>@directory</code> directory. Rename the extracted folder to <code>@library-folder</code>.', array(
        '@ext' => 'http://www.sencha.com/products/extjs',
        '@download' => 'http://www.sencha.com/products/extjs/download/',
        '@directory' => 'sites/all/libraries',
        '@library-folder' => 'ext',
    ));
    return $output;
  }
  return NULL;
}

function _path_from_uri($uri) {
  $urlpath = parse_url(file_create_url($uri));
  if( array_key_exists('path', $urlpath))
    return $urlpath['path'];
  else
    return null;
}

/**
 * Generates the integration javascript code. This includes Models, Stores
 * and Layout code.
 * @param $reset Whether to force reloading all data that goes into
 *   generating the code.
 */
function _ext_generate_js($reset = FALSE) {
  static $currently_regenerating = FALSE; // Prevent recursive calls.
  if ($currently_regenerating) return;
  $currently_regenerating = TRUE;
  
  // Get path to dir to contain generated files.
  $app_path = ext_get_generated_js_path();
  if (!$app_path) {
    drupal_set_message("Unable to generate directory path to store generated Ext integration code in.", 'error');
    watchdog('ext', "Unable to generate directory path to store generated Ext integration code in.", array(), WATCHDOG_ERROR);
  }

  _ext_module_load_all_includes('ext', 'inc', 'includes');

  // Delete previously generated files.
  $js_names = variable_get('ext_generated_files', FALSE);
  if ($js_names) {
    _ext_process_js('delete', $app_path, $js_names);
  }

  $namespace = ext_get_namespace();
  $models = ext_get_models(NULL, $reset);
  $stores = ext_get_stores(NULL, $reset);

  // Generate main app file.
  // We do this first so that it will get loaded first by drupal_add_js() in ext_load().
  $app_properties = module_invoke_all('ext_application_properties');
  $app_properties['name'] = "$namespace";

  $app_properties['appFolder'] = _path_from_uri($app_path);

  if (!isset($app_properties['requires'])) {
    $app_properties['requires'] = array();
  }
  $require = "$namespace.override.data.DEModel";
  if (!in_array($require, $app_properties['requires'])) {
    $app_properties['requires'][] = $require;
  }

  $js = "";
  $js .= "Ext.Loader.setConfig({enabled:true});\n";
  $js .= "Ext.Loader.setConfig({disableCaching:false});\n";
  $js .= "Ext.Loader.setPath('Ext', '". _path_from_uri( ext_get_path()."/src")."');\n";
  $js .= "Ext.Loader.setPath('$namespace', '". _path_from_uri($app_path)."');\n";
  $js .= "Ext.application(".  _ext_to_js($app_properties). ");";
  $all_js['Application.js'] = $js;
  
  // Generate Model code.
  $all_js['model'] = array();
  foreach ($models as $model_name => $model) {
    if( key_exists('#enabled', $model))
    {
      if ($model['#enabled']) {
        if (!isset($model['extend'])) {
          $model['extend'] = "Ext.data.Model";
        }
      }
      else
      {
        watchdog( 'ext', '#enabled not found in model');
      }

      if (isset($model['fields'])) {
        // Strip name keys (which were added for convenience) from fields array.
        $model['fields'] = array_values($model['fields']);
      }

      if (isset($model['associations'])) {
        foreach ($model['associations'] as $key => &$assoc) {
          // Prepend namespace to associated Model names.
          $assoc['model'] = "$namespace.model.". $assoc['model'];
        }
        // Strip name keys (which were added for convenience) from associations array.
        $model['associations'] = array_values($model['associations']);
      }
      /*      $model['constructor'] = "<jscode>function(config) {
       console.log('cons $model_name');
      this.callParent(arguments);
      }</jscode>";*/

      $js = "Ext.define('$namespace.model.$model_name', ";
      $js .= _ext_to_js($model, TRUE);
      $js .= ");\n\n";
      $all_js['model']["$model_name.js"] = $js;
    }
  }
  
  // Generate Store code.
  $all_js['store'] = array();
  foreach ($stores as $store_name => $store) {
    if ($store['#enabled']) {
      $store['model'] = "$namespace.model.". $store['model'];
      $store['storeId'] = $store_name;
      $store['alternateClassName'] = array("store.$store_name");
      $store['extend'] = $store['#class'];
      /*      $store['constructor'] = "<jscode>function(config) {
       console.log('cons $store_name');
      this.callParent(arguments);
      }</jscode>";*/

      // Convert to JS.
      //$js = "Ext.create('". $store['#class']. "', ";
      $js = "Ext.define('$namespace.store.$store_name', ";
      $js .= _ext_to_js($store, TRUE);
      $js .= ");\n\n";
      $all_js['store']["$store_name.js"] = $js;
    }
  }

  // Add custom code. We include these here so that other modules can alter
  // them if they really want to.
  $additional_js_paths = module_invoke_all('ext_additional_js_files');
  foreach ($additional_js_paths as $js_path) {
    $js_path = "./$js_path";
    foreach (scandir($js_path) as $file_name_orig) {
      // If this looks like a javascript file.
      if (is_file("$js_path/$file_name_orig") && substr($file_name_orig, -2) == 'js') {
        $file_namespace = explode('.', $file_name_orig);
        $file_ext = array_pop($file_namespace);
        $file_name = array_pop($file_namespace);
        $dir = &$all_js;
        foreach ($file_namespace as $name) {
          if (!isset($dir[$name])) {
            $dir[$name] = array();
          }
          $dir = &$dir[$name];
        }
        $file_contents = file_get_contents("$js_path/$file_name_orig");
        // If we're not using the default name space, update it in the code.
        if ($namespace != EXT_NAMESPACE_DEFAULT) {
          $file_contents = str_replace(EXT_NAMESPACE_DEFAULT, $namespace, $file_contents);
        }
        $dir["$file_name.$file_ext"] = $file_contents;
      }
    }
  }

  drupal_alter('ext_generated_js', $all_js);

  if (_ext_process_js('create', $app_path, $all_js)) {
    drupal_set_message("The Ext integration code has been regenerated.");
  }

  // Create array with same structure as $all_js but with actual code stripped.
  // This is used to delete the previously generated files next time
  // (so we don't destroy any files that were added by other processes).
  array_walk_recursive($all_js, '_ext_array_value_strip');
  variable_set('ext_generated_files', $all_js);

  $currently_regenerating = FALSE;
}
function _ext_array_value_strip(&$val, $key) {
  $val = '';
}


/**
 * Helper function for _ext_generate_js. Recursively processes an array
 * describing file and folder contents, either loading, creating or removing
 * JS files.
 */
function _ext_process_js($op, $path, $js) {
  foreach ($js as $name => $contents) {
    $full_path = "$path/$name";
     
    $contents_type = gettype($contents);
    if ($contents_type == 'string') {
      if ($op == 'load') {
        drupal_add_js($full_path);
      }
      elseif ($op == 'create') {
        // Use file_unmanaged_save_data() as file_save_data() is quite slow and we don't 
        // need a record of the file in the file_managed table or for the file_* hooks to be called.
        if (file_unmanaged_save_data($contents, $full_path, FILE_EXISTS_REPLACE)) {
          // Set standard file permissions for webserver-generated files.
          drupal_chmod($full_path, 0664);
        }
        else {
          drupal_set_message(t("Ext: unable to save file !path", array('!path' => $full_path)));
          watchdog('ext', "Unable to save file !path", array('!path' => $full_path), WATCHDOG_ERROR);
          return FALSE;
        }
      }
      elseif ($op == 'delete') {
        if (file_exists($full_path) && !unlink($full_path)) {
          drupal_set_message(t("Ext: unable to delete file !path", array('!path' => $full_path)));
          watchdog('ext', "Unable to save file !path", array('!path' => $full_path), WATCHDOG_ERROR);
        }
      }
    }
    elseif ($contents_type == 'array') {
      $dir_created = TRUE;
      // Skip checking for/creating directory for 'load' op.
      if ($op != 'load') {
        $dir_created = file_prepare_directory($full_path, FILE_CREATE_DIRECTORY);
      }
      if (!$dir_created) {
        drupal_set_message(t("Ext: unable to !op directory !path", array('!op' => $op, '!path' => $full_path)));
        watchdog('ext', "Unable to !op directory !path", array('!op' => $op, '!path' => $full_path), WATCHDOG_ERROR);
        return FALSE;
      }
      else {
        if (!_ext_process_js($op, $full_path, $contents)) {
          return FALSE;
        }
      }
    }
  }
  return TRUE;
}



/**
 * Converts a PHP variable into its Javascript equivalent. Arrays and Objects
 * are handled recursively.
 * This is modified version of drupal_to_js that ignores
 * array key/value pairs for keys that start with '#', and can
 * output human readable code (ie with line breaks and indents).
 * @param $var The variable to convert to JavaScript.
 * @param $human If TRUE then includes line breaks and indenting to improve
 *   readability. Default is FALSE.
 * @param $depth Typically for internal use only. Used to determine indent
 *   depth when $human is set to TRUE. Default is 0.
 * @return Generated JavaScript code as a String.
 */
function _ext_to_js($var, $human = FALSE, $depth = 0) {
  $indent = str_repeat('  ', $depth);

  switch (gettype($var)) {
    case 'boolean':
      return $var ? 'true' : 'false'; // Lowercase necessary!
    case 'integer':
    case 'double':
      return $var;
    case 'resource':
    case 'string':
      // Don't modify embedded code.
      if (strpos($var, '<jscode>') !== FALSE) {
        return str_replace(array('<jscode>', '</jscode>'), '', $var);
      }
      return '"'. str_replace(array("\r", "\n", "<", ">", "&"),
          array('\r', '\n', '\x3c', '\x3e', '\x26'),
          addslashes($var)) .'"';
    case 'array':
      // Arrays in JSON can't be associative. If the array is empty or if it
      // has sequential whole number keys starting with 0, it's not associative
      // so we can go ahead and convert it as an array.
      if (empty ($var) || array_keys($var) === range(0, sizeof($var) - 1)) {
        $output = array();
        foreach ($var as $v) {
          $output[] = "$indent  ". _ext_to_js($v, $human, $depth+1);
        }
        return "[\n". implode(",\n", $output). "\n$indent]";
      }
      // Otherwise, fall through to convert the array as an object.
    case 'object':
      $output = array();
      foreach ($var as $k => $v) {
        // Ignore keys starting with '#'.
        if ($k[0] != '#') {
          $output[] = "$indent  $k: ". _ext_to_js($v, $human, $depth+1);
        }
      }
      return "{". "\n". implode(",\n", $output). "\n$indent}";
    default:
      return 'null';
  }
}


function _ext_lcfirst($str) {
  return strtolower(substr($str, 0, 1)). substr($str, 1);
}


/**
 * An array_unique() function handling multi-dimensional arrays.
 * sub-arrays are processed recursively (depth-first).
 * All sub-arrays will be sorted by key.
 * @param $array The array to process.
 * @param $allow_dup_for_string_keys If TRUE then duplicate values associated
 *   with a string key will be ignored. Default is TRUE.
 * @return An array with duplicate values removed.
 */
function _ext_array_unique($array, $allow_dup_for_string_keys = TRUE) {
  if (!is_array($array)) {
    return FALSE;
  }
  if (empty($array)) {
    return array();
  }

  ksort($array);
  $values = array();
  $keys = array();
  foreach($array as $key => $val) {
    if (is_array($val)) {
      $val = _ext_array_unique($val, $allow_dup_for_string_keys);
    }

    // Determine an ID for the value that will be the same for all identical values.
    // Allow duplicate values when the key is a string.
    $id = ($allow_dup_for_string_keys && is_string($key) ? $key : ''). md5(serialize($val));
    if (!array_key_exists($id, $values)) {
      $values[$id] = $val;
      $keys[$id] = $key;
    }
  }
  return array_combine($keys, $values);
}

/**
 * Recursively sorts the given array and all sub-arrays by key.
 */
function _ext_ksort_recursive(&$array) {
  ksort($array);
  foreach ($array as $key => $val) {
    if (is_array($val)) {
      _ext_ksort_recursive($array[$key]);
    }
  }
}

/**
 * Given an array of associative sub-arrays, extract the values from the
 * sub-arrays for a particular key in the sub-arrays. The values in the sub-
 * array may be arrays.
 * @param $key The key to extract values for.
 * @param $array The array of associative sub-arrays to extract values from.
 * @param $key_by The returned array may be keyed by the value extracted
 *   ('value'), by the keys from the primary array ('primary'), or set to
 *   NULL for regular sequential numeric keys. Default is NULL.
 * @param $ignore_values A single value or array of values to ignore. To
 *   ignore no values use an empty array. Default is an empty array.
 * @param $ignore_values_strict Whether or not to use strict comparisons for
 *   the ignore value(s). Default is FALSE.
 */
/* Note that there is a change in value representation between D6 and D7 version
 * See http://drupal.org/node/728792 for more detail. This function has changed to find $key in $array recursively.
*/
/*
 function _ext_extract_values_from_sub_arrays_by_key($key, $array, $key_by=NULL, $ignore_values=array(), $ignore_values_strict=FALSE) {

$return = array();
if (!is_array($ignore_values)) {
$ignore_values = array($ignore_values);
}
foreach ($array as $sub_key => $sub_array) {
if (is_array($sub_array))
{
if( isset($sub_array[$key])) {
$value = $sub_array[$key];
if (!in_array($value, $ignore_values, $ignore_values_strict)) {
if ($key_by == 'value') {
$return[$value] = $value;
}
elseif ($key_by == 'primary') {
$return[$sub_key] = $value;
}
else {
$return[] = $value;
}
}
}
else
{ // recursively extract the value
$return = _ext_extract_values_from_sub_arrays_by_key($key, $sub_array, $key_by, $ignore_values, $ignore_values_strict);
if( isset($return )	)
  return $return;
}
}
}
return $return;
}
*/

function _ext_extract_values_from_sub_arrays_by_key($key, $array, $key_by=NULL, $ignore_values=array(), $ignore_values_strict=FALSE, $lang = 'und') {
  if( array_key_exists($lang, $array) && isset($lang))
    $array = $array[$lang];
  $return = array();
  if (!is_array($ignore_values)) {
    $ignore_values = array($ignore_values);
  }
  foreach ($array as $sub_key => $sub_array) {
    if (is_array($sub_array) && isset($sub_array[$key])) {
      $value = $sub_array[$key];
      if (!in_array($value, $ignore_values, $ignore_values_strict)) {
        if ($key_by == 'value') {
          $return[$value] = $value;
        }
        elseif ($key_by == 'primary') {
          $return[$sub_key] = $value;
        }
        else {
          $return[] = $value;
        }
      }
    }
  }
  return $return;
}

function _ext_get_sub_array_by_value_for_member($array, $key, $value, $get_key_instead=FALSE) {
  foreach ($array as $subkey => $subarray) {
    if (is_array($subarray) && isset($subarray[$key]) && $subarray[$key] == $value) {
      if ($get_key_instead) {
        return $subkey;
      }
      return $subarray;
    }
  }
  return FALSE;
}


/**
 * Load a module include file. This is a modified version of
 * module_load_include() providing more flexibility and different naming
 * conventions. It is assumed that all include files start with the name of
 * the module it belongs to followed by a '.'.
 *
 * Examples:
 * @code
 *   // Load mymodule.ext.inc from the mymodule module (include file is
 *   // located in 'mymodule/mymodule.ext.inc'
 *   module_load_include('mymodule', 'ext', 'inc');
 *   // Load mymodule.ext.inc from the mymodule module (include file is
 *   // located in 'mymodule/includes/mymodule.ext.inc'
 *   module_load_include('mymodule', 'ext', 'inc', 'includes');
 * @endcode
 *
 * @param $module The module to which the include file belongs.
 * @param $name The base file name (without the $type extension).
 * @param $type The include file's type (file extension), eg 'inc'.
 * @param $dir Optionally specify a sub-directory of the module that the
 *   include file is located in.
 * @return TRUE if the file was included, FALSE otherwise.
 */
function _ext_module_load_include($module, $name, $type, $dir = '') {
  $dir = $dir != '' ? "/$dir" : '';
  $file = './'. drupal_get_path('module', $module) ."$dir/$module.$name.$type";
  if (is_file($file)) {
    include_once $file;
    return TRUE;
  }
  return FALSE;
}

/**
 * Load an include file for each of the modules that have been enabled in
 * the system table. This is a modified version of module_load_all_includes()
 * providing more flexibility and different naming conventions. It is assumed
 * that all include files start with the name of the module it belongs to
 * followed by a '.'.
 * @param $name The base file name (without the $type extension).
 * @param $type The include file's type (file extension), eg 'inc'.
 * @param $dir Optionally specify a sub-directory of the module directories
 *   that the include files are located in.
 */
function _ext_module_load_all_includes($name, $type, $dir = '') {
  $modules = module_list();
  foreach ($modules as $module) {
    _ext_module_load_include($module, $name, $type, $dir);
  }
}


function _ext_camelcase($str) {
  if ($str) {
    $str[0] = strtoupper($str[0]); // Caps first letter.
    $func = create_function('$c', 'return strtoupper($c[1]);');
    return preg_replace_callback('/_([a-z0-9])/', $func, $str);
  }
  return '';
}

function _ext_uncamelcase($str) {
  if ($str) {
    $ucc = strtolower(preg_replace("/(?<=\\w)(?=[A-Z])/","_$1", $str));
    return strtolower(preg_replace("/(?<=\\w)(?=[A-Z])/","_$1", $str));
  }
  return '';
}