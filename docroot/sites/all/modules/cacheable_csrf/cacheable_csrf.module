<?php
/**
 * @file
 * Hook implementations for Cacheable CSRF.
 */

/**
 * Implements hook_menu().
 */
function cacheable_csrf_menu() {
  $items['cacheable-csrf'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'cacheable_csrf_set_token',
    'access arguments' => array('access content'),
  );
  return $items;
}

/**
 * Implements hook_page_build().
 */
function cacheable_csrf_page_build(&$page) {
  if (cacheable_csrf_get_paths()) {
    $page['footer']['#attached']['js'][] = drupal_get_path('module', 'cacheable_csrf') . '/js/cacheable_csrf.js';
    $page['footer']['#attached']['library'][] = array('system', 'jquery.cookie');
  }
}

/**
 * Get the paths to replace CSRF handling for.
 */
function cacheable_csrf_get_paths() {
  $paths = &drupal_static(__FUNCTION__, array());
  if (!$paths) {
    $paths = module_invoke_all('cacheable_csrf_paths');
  }
  return $paths;
}

/**
 * Implements hook_menu_alter().
 */
function cacheable_csrf_menu_alter(&$items) {
  $paths = cacheable_csrf_get_paths();
  foreach ($paths as $path => $data) {
    if (isset($items[$path])) {
      $items[$path]['access arguments'][] = $items[$path]['access callback'];
      // It seems silly to store the router path with the router item, but it's
      // not possible to call menu_get_item() inside an access callback since
      // that ends up in infinite recursion. We also need the string with the
      // actual placeholders from hook_menu(), which is not stored in the router
      // table.
      $items[$path]['access arguments'][] = $path;
      $items[$path]['access callback'] = '_cacheable_csrf_menu_access';
    }
  }

  $items['system/ajax']['page arguments'][] = $items['system/ajax']['page callback'];
  $items['system/ajax']['page callback'] = 'cacheable_csrf_ajax_form_callback';
}

/**
 * Implements hook_url_outbound_alter().
 */
function cacheable_csrf_url_outbound_alter(&$path, &$options, $original_path) {
  if (isset($options['query']['token']) && cacheable_csrf_supported_path($original_path)) {
    $options['query']['token'] = 'disabled';
    $options['query']['cacheable_csrf_token'] = 'cacheable_csrf_token_placeholder';
  }
}

/**
 * Helper to check whether a router item is supported by cacheable_csrf.
 *
 * Partial copy of menu_get_item() that avoids access checks.
 */
function cacheable_csrf_supported_path($path) {
  $router_items = &drupal_static(__FUNCTION__);
  if (!isset($router_items[$path]) && $paths = cacheable_csrf_get_paths()) {
    // Rebuild if we know it's needed, or if the menu masks are missing which
    // occurs rarely, likely due to a race condition of multiple rebuilds.
    if (variable_get('menu_rebuild_needed', FALSE) || !variable_get('menu_masks', array())) {
      menu_rebuild();
    }
    $original_map = arg(NULL, $path);

    $parts = array_slice($original_map, 0, MENU_MAX_PARTS);
    $ancestors = menu_get_ancestors($parts);
    $router_item = db_query_range('SELECT * FROM {menu_router} WHERE path IN (:ancestors) ORDER BY fit DESC', 0, 1, array(':ancestors' => $ancestors))->fetchAssoc();
    $access_arguments = unserialize($router_item['access_arguments']);
    $hook_menu_key = array_pop($access_arguments);
    $router_items[$path] = isset($paths[$hook_menu_key]);
  }
  return $router_items[$path];
}


/**
 * Access callback wrapper that does nasty things to CSRF tokens.
 */
function _cacheable_csrf_menu_access() {
  if (isset($_GET['cacheable_csrf_token'])) {
    $path_token = $_GET['cacheable_csrf_token'];
  }
  elseif (isset($_POST['cacheable_csrf_token'])) {
    $path_token = $_POST['cacheable_csrf_token'];
  }
  // If there's no token available, immediately return FALSE.
  if (empty($path_token)) {
    return FALSE;
  }

  // Check our own CSRF token handling prior to running the original access
  // callback.
  $current_token = drupal_get_token('cacheable_csrf');
  $cookie_token = isset($_COOKIE['cacheable_csrf_token']) ? $_COOKIE['cacheable_csrf_token'] : '';

  if ($path_token != $current_token || $cookie_token != $current_token) {
    // If any of the tokens does not match, set the cookie and return FALSE..
    // By setting the cookie, this should ensure that the next visit to this
    // path is successful.
    cacheable_csrf_set_cookie($current_token);
    // @todo: redirect back to the original page? dsm()?
    return FALSE;
  }

  $args = func_get_args();
  $path = array_pop($args);
  $access_callback = array_pop($args);
  // If our own CSRF handling has passed, call the original access callback.
  // CSRF token handling for router items in pluggable in 8.x, but in 7.x
  // drupal_valid_token() calls are embedded in access callbacks. We can trick
  // drupal_valid_token() into returning TRUE regardless of the actual token by
  // setting $_REQUEST['token'] prior to calling the original access callback.
  if (isset($_REQUEST['token'])) {
    $original_token = $_REQUEST['token'];
  }
  else {
    $original_token = 'disabled';
  }
  // Get the 'data' argument for the drupal_get_token() call.
  $paths = cacheable_csrf_get_paths();
  $data = $paths[$path]['data'];
  $fake_token = drupal_get_token($data);

  // Set both $_REQUEST and $_GET since we're not sure what access callbacks
  // will use..
  $_REQUEST['token'] = $fake_token;
  $_GET['token'] = $fake_token;
  // Having swapped out $_REQUEST token, we can now call the original access
  // callback in the knowledge that drupal_valid_token() will return TRUE. Any
  // other checks should return TRUE or FALSE as normal.
  $original_access = call_user_func_array($access_callback, $args);

  // Restore the token.
  $_REQUEST['token'] = $original_token;
  $_GET['token'] = $original_token;

  return $original_access;
}

/**
 * Get the form IDs to replace CSRF handling for.
 */
function cacheable_csrf_get_form_ids() {
  $form_ids = &drupal_static(__FUNCTION__, array());
  if (!$form_ids) {
    $form_ids = module_invoke_all('cacheable_csrf_form_ids');
  }
  return $form_ids;
}


/**
 * Implements hook_form_alter().
 */
function cacheable_csrf_form_alter(&$form, &$form_state, $form_id) {
  if (user_is_anonymous()) {
    return;
  }
  $base_form_id = isset($form_state['build_info']['base_form_id']) ? $form_state['build_info']['base_form_id'] : NULL;
  // Check for both form ID and base form ID if available.
  if (cacheable_csrf_form_id_enabled($form_id, $base_form_id)) {
    // Disable form caching. form_build_id is not going to be cacheable HTML
    // since it's unique each time the form is built in PHP. Note this means
    // this module cannot be used with multi-step forms or similar.
    $form_state['no_cache'] = TRUE;
    unset($form['#token']);

    // Disable CSRF protection.
    $form['#after_build'][] = 'cacheable_csrf_remove_user_specific_elements';

    $form['attached']['#attached']['js'] = array(
      drupal_get_path('module', 'cacheable_csrf') . '/js/cacheable_csrf.js',
    );
    $form['attached']['#attached']['library'] = array(
      array('system', 'jquery.cookie'),
    );
    $form['cacheable_csrf_token'] = array(
      '#type' => 'hidden',
      '#value' => '',
    );

    $form['cacheable_csrf_base_form_id'] = array(
      '#type' => 'hidden',
      '#value' => $base_form_id,
    );

    // Store the form callback arguments so that they can be retrieved during
    // AJAX form submissions.
    $args = $form_state['build_info']['args'];
    $cache_id = 'cacheable_csrf:' . md5(serialize($args));
    $form['cache_id'] = array(
      '#type' => 'hidden',
      '#value' => $cache_id,
    );
    // Cache this for 28 days, but only if it's not already cached or if it's
    // about to expire.
    $ttl = 86400 * 28;
    $cached = cache_get($cache_id, 'cache_form');
    if (!$cached || $cached->expire <= REQUEST_TIME + 86400) {
      cache_set($cache_id, $args, 'cache_form', REQUEST_TIME + $ttl);
    }

    // If there is a form submission, validate the token now. This ensures that
    // the CSRF validation happens before validate/submit handlers get to run.
    if (!$form_state['programmed'] && (!empty($form_state['input']) && (isset($form_state['input']['form_id']) && ($form_state['input']['form_id'] == $form_id)))) {
      $current_token = drupal_get_token('cacheable_csrf');
      $form_value_token = $form_state['input']['cacheable_csrf_token'];
      $cookie_token = isset($_COOKIE['cacheable_csrf_token']) ? $_COOKIE['cacheable_csrf_token'] : '';

      if ($form_value_token != $current_token || $cookie_token != $current_token) {
        // If any of the tokens does not match, set the cookie and fail validation.
        // By setting the cookie, this should ensure that the next form submission
        // is successful.
        cacheable_csrf_set_cookie($current_token);
        $form_state['input'] = array();
        form_set_error('cacheable_crsf_token', t('There was an error processing your form submission, please try again.'));
      }
    }
  }
}

/**
 * Determine whether a form_id is cacheable_csrf enabled.
 *
 * @param string $form_id
 *   The form ID to check.
 * @param string $base_form_id
 *   The $base_form_id if available.
 *
 * @return bool
 *   Whether cacheable_csrf is enabled for the form.
 */
function cacheable_csrf_form_id_enabled($form_id, $base_form_id = NULL) {
  $form_ids = cacheable_csrf_get_form_ids();
  $flipped = array_flip($form_ids);
  // Check for both form ID and base form ID if available.
  if (isset($flipped[$form_id])
  || ($base_form_id && isset($flipped[$base_form_id]))) {
    return TRUE;
  }
  return FALSE;
}


/**
 * After build callback.
 */
function cacheable_csrf_remove_user_specific_elements($form) {
  unset($form['#build_id'], $form['form_build_id'], $form['form_token']);
  return $form;
}

/**
 * Implements cacheable_csrf_form_ids().
 */
function cacheable_csrf_cacheable_csrf_form_ids() {
  return variable_get('cacheable_csrf_form_ids', array());
}

/**
 * Implements hook_user_login().
 */
function cacheable_csrf_user_login() {
  $token = drupal_get_token('cacheable_csrf');
  cacheable_csrf_set_cookie($token);
}

/**
 * Implements hook_user_logout().
 */
function cacheable_csrf_user_logout() {
  cacheable_csrf_set_cookie('', TRUE);
}

/**
 * Implements hook_init().
 */
function cacheable_csrf_init() {
  // Ensure that the token cookie is set whenever Drupal is fully bootstrapped.
  if (user_is_logged_in()) {
    $cookie_token = isset($_COOKIE['cacheable_csrf_token']) ? $_COOKIE['cacheable_csrf_token'] : FALSE;
    $token = drupal_get_token('cacheable_csrf');
    if ($cookie_token !== $token) {
      cacheable_csrf_set_cookie($token);
    }
  }
}

/**
 * Set the token cookie if it's not already set.
 */
function cacheable_csrf_set_token() {
  // If the user deletes their cookies or switches devices, form validation will
  // fail.
  drupal_add_http_header('Cache-control', 'no-cache, no-store');
  // Support Akamai Edge-control headers.
  drupal_add_http_header('Edge-control', 'bypass-cache');
  $token = drupal_get_token('cacheable_csrf');
  if (!isset($_COOKIE['cacheable_csrf_token']) || $_COOKIE['cacheable_csrf_token'] != $token) {
    cacheable_csrf_set_cookie($token);
  }
  // Just print nothing and return.
  print '';
  drupal_exit();
}

/**
 * Alternative implementation of ajax_form_callback().
 *
 * ajax_form_callback() relies on the form cache to discover AJAX forms. This is
 * incompatible with render caching of forms, so provide an alternative
 * implementation that skips the form cache check for cacheable_csrf-enabled
 * forms.
 *
 * @todo: normal form callbacks don't bail out in quite the same way. ajax.inc
 * mentions security but I'd expect CSRF token handling to be enough for that.
 */
function cacheable_csrf_ajax_form_callback() {
  $form_id = $_POST['form_id'];
  $base_form_id = isset($_POST['cacheable_csrf_base_form_id']) ? $_POST['cacheable_csrf_base_form_id'] : NULL;
  // If cacheable_csrf is not enabled for this form, fall back to
  // ajax_form_callback().
  if (!cacheable_csrf_form_id_enabled($form_id, $base_form_id)) {
    $args = func_get_args();
    $callback = array_pop($args);
    return call_user_func_array($callback, $args);
  }

  // Retrieve $form_state['build_info']['args'] from cache.
  $cache_id = isset($_POST['cache_id']) ? $_POST['cache_id'] : '';
  if ($cache_id && $cached = cache_get($cache_id, 'cache_form')) {
    $args = $cached->data;
  }
  else {
    // @todo: nice error message? The form will be corrupt if the original args
    // are not available.
  }
  $form_state['build_info']['args'] = $args;
  // Ensure drupal_build_form() does not redirect.
  $form_state['no_redirect'] = TRUE;
  $form = drupal_build_form($form_id, $form_state);

  if (!empty($form_state['triggering_element'])) {
    $callback = $form_state['triggering_element']['#ajax']['callback'];
  }
  if (!empty($callback) && function_exists($callback)) {
    return $callback($form, $form_state);
  }
}

/**
 * Set the token cookie.
 */
function cacheable_csrf_set_cookie($token, $remove = FALSE) {
  // Support Akamai Edge-control headers.
  drupal_add_http_header('Edge-Control', 'bypass-cache');
  $params = session_get_cookie_params();
  if ($remove) {
    $expire = REQUEST_TIME - 86400;
  }
  else {
    $expire = $params['lifetime'] ? REQUEST_TIME + $params['lifetime'] : 0;
  }
  setcookie('cacheable_csrf_token', $token, $expire, $params['path'], $params['domain'], $params['secure']);
}
