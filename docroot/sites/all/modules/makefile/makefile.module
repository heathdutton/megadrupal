<?php

/**
 * @file
 * Drush Make file entity
 */

include_once 'makefile.features.inc';

/**
 * Implements hook_entity_property_info_alter().
 */
function makefile_entity_property_info_alter(&$info) {
  if (isset($info['file']) and isset($info['file']['bundles']['drush_make']['properties'])) {

    // @see http://drush.ws/docs/make.txt
    $info['file']['bundles']['drush_make']['properties']['projects'] = array(
      'label' => t('Projects'),
      'description' => t('List of projects mentioned in the make file.'),
      'type' => 'struct',
      'property info' => array(
        'version' => array(
          'label' => t('Version'),
          'description' => t('Specifies the version of the project to retrieve. This can be as loose as the major branch number or as specific as a particular point release.'),
          'type' => 'text',
          'computed' => TRUE,
        ),
        //'patch' => array(),
        'subdir' => array(
          'label' => t('Subdirectory'),
          'description' => t('Place a project within a subdirectory of the `--contrib-destination` specified. In the example below, `cck` will be placed in `sites/all/modules/contrib` instead of the default `sites/all/modules`.'),
          'type' => 'text',
          'computed' => TRUE,
        ),
        'location' => array(
          'label' => t('Location'),
          'description' => t('URL of an alternate project update XML server to use. Allows project XML data to be retrieved from sites other than `updates.drupal.org`.'),
          'type' => 'uri',
          'computed' => TRUE,
        ),
        'type' => array(
          'label' => t('Type'),
          'description' => t('The project type. Must be provided if an update XML source is not specified and/or using version control or direct retrieval for a project. May be one of the following values: core, module, profile, theme.'),
          'type' => 'list<text>',
          'computed' => TRUE,
          'options list' => '_makefile_property_info_type_options',
        ),
        'directory_name' => array(
          'label' => t('Directory Name'),
          'description' => t('Provide an alternative directory name for this project. By default, the project name is used.'),
          'type' => 'text',
          'computed' => TRUE,
        ),
        'l10n_path' => array(
          'label' => t('Localization Path'),
          'description' => t('Specific URL (can include tokens) to a translation. Allows translations to be retrieved from l10n servers other than `localize.drupal.org`.'),
          'type' => 'uri',
          'computed' => TRUE,
        ),
        'l10n_url' => array(
          'label' => t('Localization URL'),
          'description' => t('URL to an l10n server XML info file. Allows translations to be retrieved from l10n servers other than `localize.drupal.org`.'),
          'type' => 'uri',
          'computed' => TRUE,
        ),
        'overwrite' => array(
          'label' => t('Overwrite'),
          'description' => t('Allows the project to be installed in a directory that is not empty. If not specified this is treated as FALSE, drush_make sets an error when the directory is not empty. If specified TRUE, drush_make will continue and use the existing directory. Useful when adding extra files and folders to existing folders in libraries or module extensions.'),
          'type' => 'boolean',
          'computed' => TRUE,
        ),
        'translations' => array(
          'label' => t('Translations'),
          'description' => t('Retrieve translations for the specified language, if available, for all projects.'),
          'type' => 'list<text>',
          'computed' => TRUE,
        ),
        'download' => _makefile_entity_property_info_download(),
      ),
      'computed' => TRUE,
      'entity token' => TRUE,
      'getter callback' => 'makefile_entity_property_get_projects',
      'access callback' => 'makefile_access',
      'queryable' => FALSE,
      'required' => FALSE,
      'entity views field' => FALSE,
      'clear' => array('libraries'),
      'propert info alter' => 'makefile_property_info_projects_alter',
      'translatable' => FALSE,
    );

    $properties['libraries'] = array(
      'label' => t('Libraries'),
      'description' => t('List of libraries mentioned in the make file.'),
      'type' => 'struct',
      'property info' => array(
        'destination' => array(
          'label' => t('Destination'),
          'description' => t('The target path to which this library should be moved. The path is relative to that specified by the `--contrib-destination` option. By default, libraries are placed in the `libraries` directory.'),
          'type' => 'text',
          'computed' => TRUE,
        ),
        'download' => _makefile_entity_property_info_download(),
        'directory_name' => array(
          'label' => t('Directory Name'),
          'description' => t('Provide an alternative directory name for this project. By default, the project name is used.'),
          'type' => 'text',
          'computed' => TRUE,
        ),
        'subdir' => array(
          'label' => t('Subdirectory'),
          'description' => t('Place a project within a subdirectory of the `--contrib-destination` specified. In the example below, `cck` will be placed in `sites/all/modules/contrib` instead of the default `sites/all/modules`.'),
          'type' => 'text',
          'computed' => TRUE,
        ),
      ),
      'computed' => TRUE,
      'entity token' => TRUE,
      'getter callback' => 'makefile_entity_property_get_libraries',
      'access callback' => 'makefile_access',
      'queryable' => FALSE,
      'required' => FALSE,
      'entity views field' => FALSE,
      'clear' => array('projects'),
      'propert info alter' => 'makefile_property_info_projects_alter',
      'translatable' => FALSE,
    );
    // @todo add "includes" property
  }
}

/**
 * Getter callback for entity property 'projects'
 *
 * @see entity_property_verbatim_get().
 */
function makefile_entity_property_get_projects($data, array $options, $name, $type, $info) {
  $settings = makefile_parse_file($data);

  // Ensure the empty array exists
  if (empty($settings['projects'])) {
    $settings['projects'] = array();
  }

  return $settings['projects'];
}

/**
 * Getter callback for entity property 'libraries'
 *
 * @see entity_property_verbatim_get().
 */
function makefile_entity_property_get_libraries($data, array $options, $name, $type, $info) {
  $settings = makefile_parse_file($data);

  // Ensure the empty array exists
  if (empty($settings['libraries'])) {
    $settings['libraries'] = array();
  }

  return $settings['libraries'];
}

/**
 * Implements hook_permission().
 */
function makefile_permission() {
  return array(
    'administer makefile' =>  array(
      'title' => t('Administer Make File Entity'),
      'description' => t('Perform administration tasks for makefile module.'),
    ),
    'create makefile' =>  array(
      'title' => t('Create Make File Entity'),
      'description' => t('Perform administration tasks for makefile module.'),
    ),
    'edit own makefile' =>  array(
      'title' => t('Edit own Make File Entity'),
      'description' => t('Perform administration tasks for makefile module.'),
    ),
    'edit any makefile' =>  array(
      'title' => t('Edit any Make File Entity'),
      'description' => t('Perform administration tasks for makefile module.'),
    ),
    'delete own makefile' =>  array(
      'title' => t('Delete own Make File Entity'),
      'description' => t('Perform administration tasks for makefile module.'),
    ),
    'delete any makefile' =>  array(
      'title' => t('Delete any Make File Entity'),
      'description' => t('Perform administration tasks for makefile module.'),
    ),
  );
}

/**
 * Implements hook_entity_presave().
 */
function makefile_entity_presave($entity, $type) {
  if ($type == 'file') {
    $data = makefile_parse_file($entity);
    if (!empty($data)) {
      $wrapper = entity_metadata_wrapper('file', $entity);
      $wrapper->field_drush_api_version->set($data['api']);
      $wrapper->field_drush_core_api_version->set($data['core']);
    }
  }
}

/**
 * Implements hook_entity_load().
 */
function makefile_entity_load($entities, $type) {
  // @todo see if we should switch this to an entity property
  // I don't think we should since we can't query the list anyways
  if ($type == 'file') {
    foreach ($entities as $key => $entity) {
      if ($entity->type == 'drush_make') {
        $data = makefile_parse_file($entity);
        $entity->projects = array();
        $entity->libraries = array();

        if (!empty($data['projects'])) {
          $entity->projects = $data['projects'];
          // Scan projects for the download 'type' key and replace it
          // to avoid issues with reserved words in entity property info
          foreach ($entity->projects as $project => $data) {
            if (isset($data['download']['type'])) {
              $entity->projects[$project]['download']['download_type'] = $data['download']['type'];
              unset($entity->projects[$project]['download']['type']);
            }
          }
        }
        if (!empty($data['libraries'])) {
          $entity->libraries = $data['libraries'];
          // Scan libraries for the download 'type' key and replace it
          // to avoid issues with reserved words in entity property info
          foreach ($entity->libraries as $library => $data) {
            if (isset($data['download']['type'])) {
              $entity->libraries[$library]['download']['download_type'] = $data['download']['type'];
              unset($entity->libraries['download']['type']);
            }
          }
        }
      }
    }
  }
}

/**
 * Parse the file data from a given file entity and set entity properties
 *
 * @param object $entity [reference]
 *  File Entity of type drush_make
 * @return boolean
 *  Returns TRUE if the data was successfully applied to the entity, FALSE otherwise.
 */
function makefile_parse_file(&$entity) {
  if (isset($entity->type) and $entity->type == 'drush_make') {
    if (!empty($entity->uri)) {

      // Parse the contents of the file and update the entity data as needed
      module_load_include('inc', 'makefile');

      // We put the realpath in a variable to avoid Strict Warning on referenced variables
      $realpath = drupal_realpath($entity->uri);
      // Open the file and get the contents
      $streamwrapper = file_stream_wrapper_get_instance_by_uri($entity->uri);
      $data = $streamwrapper->stream_open($entity->uri, 'r', STREAM_USE_PATH & STREAM_REPORT_ERRORS, $realpath);
      if (TRUE === $data) {
        $data = $streamwrapper->stream_read($entity->filesize);
        $streamwrapper->stream_close();
        $data = _makefile_drush_drupal_parse_info_file($data);

        // Clean out any stray quotes or doubld quotes (especially important for version parsing).
        makefile_array_walk_recursive_referential($data, 'trim', array("'"));
        makefile_array_walk_recursive_referential($data, 'trim', array('"'));
        return $data;
      }
    }
  }
}

/**
 * This function acts exactly like array_walk_recursive, except that it pretends that the function
 * its calling replaces the value with its result.
 *
 * @param $array The first value of the array will be passed into $function as the primary argument
 * @param $function The function to be called on each element in the array, recursively
 * @param $parameters An optional array of the additional parameters to be appeneded to the function
 *
 * @see http://www.php.net/manual/en/function.array-walk-recursive.php#99639
 *
 * Example usage to alter $array to get the second, third and fourth character from each value
 *     array_walk_recursive_referential($array, "substr", array("1","3"));
 */
function makefile_array_walk_recursive_referential(&$array, $function, $parameters = array()) {
  $reference_function = function(&$value, $key, $userdata) {
    $parameters = array_merge(array($value), $userdata[1]);
    $value = call_user_func_array($userdata[0], $parameters);
  };
  array_walk_recursive($array, $reference_function, array($function, $parameters));
}

/**
 * Check if an makefile of the given name exists
 *
 * @param string $name
 *  Machine name
 * @return boolean
 *  Returns TRUE if the makefile exists, FALSE otherwise.
 */
function makefile_exists($name) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'file')
    ->entityCondition('bundle', 'drush_make')
    ->fieldCondition('field_drush_make_name', $name);

  $result = $query->execute();

  return !empty($result);
}

/**
 * Load an makefile entity by name
 *
 * @param string $name
 *  Machine name
 * @return object|boolean
 *  Returns the policy object, FALSE otherwise.
 */
function makefile_load_by_name($name) {
  $query = new EntityFieldQuery();

  $query->entityCondition('entity_type', 'file')
    ->entityCondition('bundle', 'drush_make')
    ->fieldCondition('field_drush_make_name', $name);

  $result = $query->execute();

  foreach ($result as $make) {
    return entity_load_single(reset($make)->fid);
  }

  return FALSE;
}

/**
 * Access callback for makefile entities
 */
function makefile_access($op, $makefile, $account = NULL, $entity_type = NULL) {
  global $user;

  if (!isset($account)) {
    $account = $user;
  }

  if (user_access('administer makefile', $account)) {
    return TRUE;
  }

  switch ($op) {
    case 'create':
      return user_access('create makefile', $account);
    case 'view':
      return user_access('view makefile', $account);
    case 'edit':
      return user_access('edit any makefile')
          || (user_access('edit own makefile') && ($makefile->uid == $account->uid));
    case 'delete':
      return user_access('delete any makefile', $account)
          || (user_access('delete own makefile') && ($makefile->uid == $account->uid));
  }
}

/**
 * Defines the struct for the download property
 *
 * @return array
 *  Returns an array representing the download property structure
 */
function _makefile_entity_property_info_download() {
  return array(
    'label' => t('Download'),
    'description' => t('List of download settings for the given project.'),
    'type' => 'struct',
    'property info' => array(
      'download_type' => array(
        'label' => t('Type'),
        'type' => 'list<text>',
        'options list' => '_makefile_entity_property_info_download_options',
        'computed' => TRUE,
      ),
      'url' => array(
        'label' => t('URI'),
        'description' => t('The URL of the file.'),
        'type' => 'uri',
        'computed' => TRUE,
      ),
      // @todo add   `md5`, `sha1`, `sha256`, or `sha512` - one or more checksums for the file.
      'request_type' => array(
        'type' => 'list<text>',
        'computed' => TRUE,
        'label' => t('Request Type'),
        'description' => t('The request type - get or post. post depends on http://drupal.org/project/make_post'),
        'options list' => '_makefile_entity_property_info_download_request_type_options',
      ),
      'data' => array(
        'label' => t('Post Data'),
        'description' => t('The post data to be submitted with the request. Should be a valid URL query string. Requires http://drupal.org/project/make_post.'),
        'computed' => TRUE,
        'type' => 'text',
      ),
      'filename' => array(
        'label' => t('Filename'),
        'description' => t('What to name the file, if it\'s not an archive.'),
        'computed' => TRUE,
        'type' => 'text',
      ),
      'subtree' => array(
        'label' => t('Subtree'),
        'description' => t('If the download is an archive, only this subtree within the archive will be copied to the target destination.'),
        'computed' => TRUE,
        'type' => 'text',
      ),
      'branch' => array(
        'label' => t('Branch'),
        'type' => 'text',
        'computed' => TRUE,
      ),
      'revision' => array(
        'label' => t('Revision'),
        'type' => 'text',
        'computed' => TRUE,
      ),
      'tag' => array(
        'label' => t('Tag'),
        'type' => 'text',
        'computed' => TRUE,
      ),
      'refspec' => array(
        'label' => t('Refspec'),
        'description' => t('the git reference to fetch and checkout. If this is set, it will have priority over tag, revision and branch options'),
        'type' => 'text',
        'computed' => TRUE,
      ),
      'interactive' => array(
        'label' => t('Interactive'),
        'description' => t('Whether to prompt the user for authentication credentials when using a private repository. Allows username and/or password options to be omitted.'),
        'type' => 'boolean',
        'computed' => TRUE,
      ),
      'username' => array(
        'label' => t('Username'),
        'description' => t('the username to use when retrieving an SVN project as a working copy or from a private repository.'),
        'type' => 'text',
        'computed' => TRUE,
      ),
      'password' => array(
        'label' => t('Password'),
        'description' => t('the password to use when retrieving an SVN project as a working copy or from a private repository.'),
        'type' => 'text',
        'computed' => TRUE,
      ),
    ),
  );
}

/**
 * Defines the list of options available for the "download" property
 */
function _makefile_entity_property_info_download_options() {
  return array(
    'file' => t('File'),
    'bzr' => t('Bazaar'),
    'git' => t('Git'),
    'svn' => t('Subversion'),
  );
}

/**
 * Defines the list of options available for the "type" property
 */
function _makefile_property_info_type_options() {
  return array(
    'module' => t('Module'),
    'theme' => t('Theme'),
    'core' => t('Core'),
    'profile' => t('Install Profile'),
  );
}

/**
 * Defines the list of options availabl for the "request_type" property
 */
function _makefile_entity_property_info_download_request_type_options() {
  return array(
    'get' => t('GET'),
    'post' => t('POST'),
  );
}