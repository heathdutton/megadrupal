<?php
define('MENU_DICTATOR_VAR', 'menu_css_dictator_menu_settings');

function menu_css_dictator_form_alter(&$form, &$form_state, $form_id) {
  if($form_id == 'menu_edit_item') {
    // Customize the menu edit item form to inject our custom form fields.
    menu_css_dictator_alter_menu_form($form, $form_state);
  }
  else if($form_id == 'menu_item_delete_form') {
    $form['#submit'][] = 'menu_css_dictator_menu_form_delete';
  }
}

/**
 * Adds our custom fields to the menu edit form.
 *
 * @param array $form
 * @param array $form_state
 */
function menu_css_dictator_alter_menu_form(&$form, &$form_state) {

  $default_value = false;
  if(!empty($form['mlid']['#value'])) {
    $menu_item_id = $form['mlid']['#value'];

    // We're dealing with an existing menu item so there is a chance we'll have a default value to display.
    $settings = variable_get(MENU_DICTATOR_VAR, array());
    if(array_key_exists($menu_item_id, $settings)) {
      $default_value = $settings[$menu_item_id];
    }
  }

  $form['menu_dictator_css_class'] = array(
    '#type' => 'textfield',
    '#title' => t('CSS to apply to page'),
    '#description' => t('Provide a CSS class to apply to the body element of the page when this menu item is being viewed.'),
    '#default_value' => ($default_value ? $default_value : ''),
  );
  $form['#submit'][] = 'menu_css_dictator_menu_form_submit';
}

/**
 * The submit callback added to the menu_edit_item form.
 * This is where we'll save the CSS class that should be applied to the page for a menu item.
 *
 * @param array $form
 * @param array $form_state
 */
function menu_css_dictator_menu_form_submit(&$form, &$form_state) {
  // Get the menu item ID that we're working with.
  $menu_id = $form_state['values']['mlid'];

  // Get our existing config and ready it to receive our additional value for this menu item.
  $settings = variable_get(MENU_DICTATOR_VAR, array());

  // If a value was provided for this menu item then add it to our settings storage.
  if(!empty($form_state['values']['menu_dictator_css_class'])) {
    $settings[$menu_id] = $form_state['values']['menu_dictator_css_class'];
  }
  else {
    // Remove a potentially previously set value.
    unset($settings[$menu_id]);
  }

  // Save our altered settings back to the DB.
  variable_set(MENU_DICTATOR_VAR, $settings);
}

function menu_css_dictator_menu_form_delete(&$form, &$form_state) {
  $test = 'ss';

  // Get our menu class settings.
  $settings = variable_get(MENU_DICTATOR_VAR, array());

  // Get the menu item ID that is being deleted.
  $menu_item_id = $form['#item']['mlid'];
  if(array_key_exists($menu_item_id, $settings)) {

    // Delete the menu item that the user is currently deleting.
    unset($settings[$menu_item_id]);

    // Save our altered settings back to the DB.
    variable_set(MENU_DICTATOR_VAR, $settings);
  }
}

/**
 * Implements template_preprocess_html
 */
function menu_css_dictator_preprocess_html(&$variables) {
  // Get our menu class settings.
  $settings = variable_get(MENU_DICTATOR_VAR, array());

  // Get the current active trail.
  $active_menu_trail = menu_get_active_trail();

  // Loop over the current trail from the end and working our way backwards.
  for($i = count($active_menu_trail); $i > 0; $i--) {
    $menu_item = $active_menu_trail[$i - 1];

    // If we have a value for this menu item
    if(array_key_exists('mlid', $menu_item) && array_key_exists($menu_item['mlid'], $settings)) {
      // Get the class for this menu item from our saved settings.
      $class = $settings[$menu_item['mlid']];
      // Add our custom CSS class to the page's classes_array.
      $variables['classes_array'][] = $class;

      // Currently we're only interested in adding the first found match.
      // Leave now that we found a match, leave.
      break;
    }
  }
}