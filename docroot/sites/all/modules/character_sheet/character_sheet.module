<?php

/**
 * @file
 * Handles character ownership behaviors and provides trigger to plugins.
 */

// Include code for character sheet feature: Workflow.
// Workflow handles the moderation states, play states and other features of a game system.
include_once('character_sheet.features.inc');

/**
 * Field level controls. Use these constants to map field level permissions.
 */
define('HIDE_SHEET', 'hide');
define('DISABLE_SHEET', 'disable');
define('LIMIT_SHEET', 'limit');

/**
 * Implements hook_menu().
 */
function character_sheet_menu() {
  $items['admin/config/system/character_sheet'] = array(
    'title' => 'Character sheet',
    'description' => 'Configure settings for character sheets, and enable character sheet systems.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('character_sheet_admin_settings'),
    'access arguments' => array('administer character sheet'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'character_sheet.admin.inc',
  );
  $items['node/%node/character_sheet'] = array(
    'title' => 'Sheet',
    'type' => MENU_LOCAL_TASK,
    'access callback' => '_character_sheet_management_access',
    'access arguments' => array(1),
    'page callback' => '_character_sheet_management',
    'page arguments' => array(1),
    'weight' => 3,
  );
  return $items;
}

/**
 * Menu access callback.
 */
function _character_sheet_management_access($node) {
  if (_character_sheet_is_enabled($node)) {
    return ( _character_sheet_owner($node) || _character_sheet_xp_access($node));
  }
  return FALSE;
}

function _character_sheet_owner($node) {
  if (_character_sheet_is_enabled($node)) {
    global $user;
    if ($user->uid == $node->uid) {
      return TRUE;
    }
  }
  return FALSE;
}

function _character_sheet_xp_access($node) {
  if (_character_sheet_is_enabled($node)) {
    global $user;
    if ( $user->uid != $node->uid && user_access('add xp to character sheet')
      || ($user->uid == $node->uid && user_access('add xp to own character sheet'))
      ) {
      return TRUE;
    }
  }
  return FALSE;
}

function _character_sheet_xp_remove_access($node) {
  if (_character_sheet_is_enabled($node)) {
    global $user;
    if ( $user->uid != $node->uid && user_access('remove xp from character sheet')
      || ($user->uid == $node->uid && user_access('remove xp from own character sheet'))
      ) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Implements hook_permission().
 */
function character_sheet_permission() {
  return array(
    'administer character sheet' => array(
      'title' => t('administer character sheet'),
      'description' => t('Administer character sheet systems.'),
    ),
    'view character sheet log' => array(
      'title' => t('view character sheet log'),
      'description' => t('View character sheet change log.'),
    ),
    'add xp to character sheet' => array(
      'title' => t('add xp to character sheet'),
      'description' => t('Add XP to a character.'),
    ),
    'add xp to own character sheet' => array(
      'title' => t('add xp to own character sheet'),
      'description' => t('Add XP to own character.'),
    ),
    'remove xp from character sheet' => array(
      'title' => t('remove xp from character sheet'),
      'description' => t('Remove xp from a character.'),
    ),
    'remove xp from own character sheet' => array(
      'title' => t('remove xp from own character sheet'),
      'description' => t('Remove xp from own character.'),
    ),
    // Permissions to edit a character sheet is handled by standard node edit permissions.
    // As edit and edit own.
  );
}

/**
 * Implements hook_views_api(). From Views module.
 */
function character_sheet_views_api() {
  return array(
    'api' => 2,
  );
}

/*
 * Character sheet content type processing, enabling character sheets for a content type.
 */

/**
 * Implements hook_form_FORMID_alter().
 *
 * Alter content type settings to add "Enable character sheet management?" checkbox.
 */
function character_sheet_form_node_type_form_alter(&$form, &$form_state) {
  if (isset($form['type'])) {
    $form['character_sheet'] = array(
      '#type' => 'fieldset',
      '#title' => t('Character sheet settings'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#group' => 'additional_settings',
    );
    $character_sheet_types = variable_get('character_sheet_types', array());
    $default_active = FALSE;
    $default_system = '';
    if (isset($character_sheet_types[$form['#node_type']->type])) {
      $default_active = TRUE;
      $default_system = $character_sheet_types[$form['#node_type']->type];
    }
    $form['character_sheet']['character_sheet'] = array(
      '#type' => 'checkbox',
      '#title' => t('Enable character sheet management?'),
      '#default_value' => $default_active,
      '#description' => t('Enable this checkbox if you want to provide a character sheets with this content type.'),
    );
    // Tell character sheet what system to use for this content type.
    $systems = variable_get('character_sheet_systems', array());
    if (!empty($systems)) {
      $system_select = array('-1' => '<none>');
      foreach ($systems as $system) {
        $this_system = module_invoke($system, 'character_sheet_register_systems');
        $system_select[$system] = $this_system[$system]['name'];
      }
      $form['character_sheet']['character_sheet_system'] = array(
        '#type' => 'select',
        '#title' => t('Game system'),
        '#options' => $system_select,
        '#default_value' => $default_system,
        '#description' => t('Select the game system this content type will be used with.'),
      );
    }
    // Add submission to the form so we can pick up the system setting.
    $form['#submit'][] = '_character_sheet_form_node_type_form_alter_submit';
  }
}

/**
 * Submission callback, from character_sheet_form_node_type_form_alter.
 */
function _character_sheet_form_node_type_form_alter_submit($form, &$form_state) {
  $values = $form_state['values'];
  if ($values['character_sheet'] != TRUE) {
    // This is no longer a character sheet type. Remove from list, and clear fields.
    $character_sheet_types = variable_get('character_sheet_types', array());
    unset($character_sheet_types[$values['type']]);
    variable_set('character_sheet_types', $character_sheet_types);
    // Now remove from workflow settings.
    workflow_delete_workflow_type_map_by_type($values['type']); // From workflow.module.
    variable_del('workflow_' . $values['type']);
    menu_rebuild();
    return;
  }
  else {
    // This is a character sheet type, add to the list.
    $character_sheet_types = variable_get('character_sheet_types', array());
    $old_system = isset($character_sheet_types[$values['type']]) ? $character_sheet_types[$values['type']] : FALSE;
    $character_sheet_types[$values['type']] = isset($values['character_sheet_system']) ? $values['character_sheet_system'] : TRUE;
    variable_set('character_sheet_types', $character_sheet_types);
    // Check for old sheet types to update.
    if (isset($values['character_sheet_system']) &&
      $old_system != $values['character_sheet_system'] && $old_system != FALSE) {
      // This was a sheet, but is now a different sheet type, give warning.
      drupal_set_message(t('You have changed the game system for this content type. ' .
        'Be aware that this will affect sheets created under the old setting. ' .
        'If you already have data, it is best to make a new content type for new systems.'));
    }
    // Now add workflow settings.
    $workflow = _character_sheet_get_workflow();
    if ($workflow) {
      $record = array('wid' => $workflow->wid, 'type' => $values['type']);
      workflow_insert_workflow_type_map($record); // From workflow.module.
      variable_set('workflow_' . $values['type'], array('node'));
      menu_rebuild();
    }
    else {
      drupal_set_message(t('Character sheets do not have a default workflow associated. Have an administrator ' .
        'check the settings.'));
    }
  }
}

/**
 * For the most part the API we use is meant as a wrapper on the regular nodeapi API.
 * This may sound like it's a lot of trouble, and skilled coders may want to just code a
 * module to get into the node directly. You could. But this is meant to cut down on the
 * error checking a sheet implementation must make. By calling through the wrappers we
 * get all the character sheet behavior operating as you would expect, and we know we are
 * calling the system on a node of the right type, that is an active character sheet and
 * specifically associated to this system. No guess work. Think of this as OO style extends.
 */

/**
 * Implements hook_node_delete().
 */
function character_sheet_node_delete($node) {
  if (_character_sheet_is_enabled($node)) {
    if (!empty($node->character_sheet_system) && $node->character_sheet_system != -1) {
      module_invoke($node->character_sheet_system, 'character_sheet_delete_sheet', $node);
    }
    // Delete records of the sheet from the log.
    _character_sheet_delete_log($node->nid);
    // Delete XP for the sheet.
    _character_sheet_delete_xp($node->nid);
  }
}

/**
 * Implements hook_node_insert().
 */
function character_sheet_node_insert($node) {
  if (_character_sheet_is_enabled($node)) {
    $character_sheet_system = '';
    $character_sheet_types = variable_get('character_sheet_types', array());
    if (is_string($character_sheet_types[$node->type])) {
      $character_sheet_system = $character_sheet_types[$node->type];
    }
    if (!empty($character_sheet_system) && $character_sheet_system != -1) {
      module_invoke($character_sheet_system, 'character_sheet_insert_sheet', $node);
    }
    // Update sheet log record to record creation. After insert.
    $character_sheet_presave_node = variable_get('character_sheet_presave_node', array());
    $character_sheet_presave_cost = variable_get('character_sheet_presave_cost', array());
    unset($character_sheet_presave_node[ $node->nid ]);
    unset($character_sheet_presave_cost[ $node->nid ]);
    variable_set('character_sheet_presave_node', $character_sheet_presave_node);
    variable_set('character_sheet_presave_cost', $character_sheet_presave_cost);
    // Set to log.
    global $user;
    $node_user = user_load($node->uid);
    _character_sheet_update_log($node->nid, 'new', 'This sheet was created by !user, owned by !owner.',
      array('!user' => $user->name, '!owner' => $node_user->name));
  }
}

/**
 * Implements hook_node_load().
 */
function character_sheet_node_load($nodes, $types) {
  foreach ($nodes as $node) {
    if (_character_sheet_is_enabled($node)) {
      // Add character sheet type if it's set.
      $character_sheet_types = variable_get('character_sheet_types', array());
      if (is_string($character_sheet_types[$node->type])) {
        $node->character_sheet_system = $character_sheet_types[$node->type];
      }
      if (!empty($node->character_sheet_system) && $node->character_sheet_system != -1) {
        // Add XP values for this sheet system.
        $system = module_invoke($node->character_sheet_system, 'character_sheet_register_systems');
        $system = $system[$node->character_sheet_system];
        $xp_types = isset($system['xp']['types']) ? $system['xp']['types'] : array('xp');
        $xp_list = array();
        foreach ($xp_types as $xp_type) {
          $this_xp = _character_sheet_get_xp($node->nid, $xp_type);
          $node->xp[$xp_type] = $this_xp;
          $xp_list[] = t('%xp %type XP.', array('%xp' => $this_xp, '%type' => $xp_type));
        }
        $node->xp_themed = theme('item_list', array('items' => $xp_list));
        // Pull any additional calculated values from sheet api (calculated values by system).
        module_invoke($node->character_sheet_system, 'character_sheet_load_sheet', $node);
      }
    }
  }
}

/*
 * Implements hook_node_presave().
 */
function character_sheet_node_presave($node) {
  if (module_exists('rules')) {
    global $user;
    $player = $user;
    rules_invoke_event('character_sheet_event_updated', $node, $player);
  }
  if (_character_sheet_is_enabled($node)) {
    // Run sheet api to update values as needed based on changed values.
    $old_node = FALSE;
    if (isset($node->nid)) {
      $old_node = node_load($node->nid);
      $character_sheet_presave_node = variable_get('character_sheet_presave_node', array());
      $character_sheet_presave_node[ $node->nid ] = $old_node;
      variable_set('character_sheet_presave_node', $character_sheet_presave_node);
    }
    // Add character sheet type if it's set.
    $character_sheet_types = variable_get('character_sheet_types', array());
    if (is_string($character_sheet_types[$node->type])) {
      $node->character_sheet_system = $character_sheet_types[$node->type];
    }
    if (!empty($node->character_sheet_system) && $node->character_sheet_system != -1) {
      module_invoke($node->character_sheet_system, 'character_sheet_presave_sheet', $node, $old_node);
    }
  }
}

/*
 * Implements hook_node_update().
 */
function character_sheet_node_update($node) {
  if (_character_sheet_is_enabled($node)) {
    // Get old node.
    $character_sheet_presave_node = variable_get('character_sheet_presave_node', array());
    $old_node = isset($character_sheet_presave_node[ $node->nid ]) ? $character_sheet_presave_node[ $node->nid ] : 0;
    unset($character_sheet_presave_node[ $node->nid ]);
    variable_set('character_sheet_presave_node', $character_sheet_presave_node);
    // Get old cost.
    $character_sheet_presave_cost = variable_get('character_sheet_presave_cost', array());
    $old_cost = isset($character_sheet_presave_cost[ $node->nid ]) ? $character_sheet_presave_cost[ $node->nid ] : 0;
    unset($character_sheet_presave_cost[ $node->nid ]);
    variable_set('character_sheet_presave_cost', $character_sheet_presave_cost);
    // Do the calculations.
    if (empty($old_node)) {
      // We have a critical failure.
      watchdog('character_sheet', 'Unable to retrieve old node during update.');
      return;
    }
    // Check for transfer of ownership and update owner.
    if (!empty($old_node) && $old_node->uid != $node->uid) {
      $old_user = user_load($old_node->uid);
      $new_user = user_load($node->uid);
      _character_sheet_update_log($node->nid, 'ownership', 'This sheet changed owners from !old_owner to !new_owner.',
        array('!old_owner' => $old_user->name, '!new_owner' => $new_user->name));
    }
    if (!empty($node->character_sheet_system) && $node->character_sheet_system != -1) {
      // Check for XP updates. Only players get charged XP for updates made on their sheets.
      // Anyone else going in and tweaking something is doing so outside of the XP system.
      global $user;
      if ($old_cost != 0 && _character_sheet_is_playable($node) && $node->uid == $user->uid) {
        $charged = _character_sheet_charge_xp($node, _character_sheet_total_xp($node), $old_cost);
        if ($charged == FALSE) {
          // We have a critical failure.
          watchdog('character_sheet', 'Unable to charge for cost during update.');
          return;
        }
      }
      // If we weren't able to charge when we should have, we bailed before we got here.
      module_invoke($node->character_sheet_system, 'character_sheet_update_sheet', $node, $old_node);
    }
  }
}

/*
 * Implements hook_node_validate().
 */
function character_sheet_node_validate($node, $form, &$form_state) {
  if (_character_sheet_is_enabled($node)) {
    // Last check on the math according to the expected values from sheet api.
    $error = FALSE;
    $old_node = node_load($node->nid);
    $character_sheet_types = variable_get('character_sheet_types', array());
    // If the right type, get the workflow from the old node to the new version.
    if (is_string($character_sheet_types[$node->type])) {
      $node->character_sheet_system = $character_sheet_types[$node->type];
      if (isset($old_node->workflow)) {
        $node->workflow = $old_node->workflow;
      }
    }
    // Make sure we have an active system.
    if (!empty($node->character_sheet_system) && $node->character_sheet_system != -1) {
      // Check for XP amounts.
      global $user;
      // Check if the character is playable, and how much the XP currently is.
      if (_character_sheet_is_playable($node) && $node->uid == $user->uid) {
        $error = _character_sheet_validate_xp($node, $old_node);
      }
      // Error? Bail out with message.
      if ($error) {
        form_set_error($error['field'], $error['message']);
        return;
      }
      // Run any additional checked by system.
      $error = module_invoke($node->character_sheet_system, 'character_sheet_validate_sheet',
        $node, $old_node, $form, $form_state);
      // Error? Bail out with message.
      if ($error) {
        form_set_error($error['field'], $error['message']);
        return;
      }
      // No error? We're ready to go! Save the costs and values.
      if (!($error)) {
        $old_cost = _character_sheet_total_xp($old_node);
        if (isset($old_node->workflow)) {
          // Hey! NOT brand new. That means we should be able to get a cost out of the old one.
          if (empty($old_cost)) {
            // Problem. We have a critical error here, unable to calculate what the old cost was / is.
            form_set_error('', t('Unable to determine the value of the previous version of this sheet.'));
            return;
          }
        }
        $character_sheet_presave_cost = variable_get('character_sheet_presave_cost', array());
        $character_sheet_presave_cost[ $old_node->nid ] = $old_cost;
        variable_set('character_sheet_presave_cost', $character_sheet_presave_cost);
      }
    }
  }
}

/*
 * Implements hook_node_view().
 */
function character_sheet_node_view($node, $view_mode, $langcode) {
  if (_character_sheet_is_enabled($node)) {
    if (user_access('view character sheet log')) {
      $logs = _character_sheet_get_log($node->nid);
      $node->content['character_sheet_log'] = array(
        '#type' => 'item',
        '#title' => t('Moderation log'),
        '#markup' => theme('item_list', array('items' => $logs)),
        '#weight' => 100,
      );
    }
    // Calculate any values modified on the fly but not during load (equipment mods etc).
    // These are for values not intended to be used during field calculation or editting, purely display results.
    if (!empty($node->character_sheet_system) && $node->character_sheet_system != -1) {
      module_invoke($node->character_sheet_system, 'character_sheet_view_sheet', $node);
    }
  }
}

/*
 * Character sheet, field level controls for players and moderators according to character sheet defs.
 */
function character_sheet_form_node_form_alter(&$form, &$form_state, $form_id) {
  $node = $form['#node'];
  // Only do this if this is a character sheet in play.
  if (_character_sheet_is_enabled($node) && _character_sheet_is_playable($node)) {
    // Loop for each field and start checking for display limits against the workflow.
    $fields = _character_sheet_get_field_info($node);
    $lang = $form['language']['#value'];
    // Execute field control against every child form field. Recursive.
    $form = _character_sheet_field_control($form, $node, $fields, $lang);
  }
}

/**
 * Execute field control, recursively for all form elements.
 */
function _character_sheet_field_control($form, $node, $fields, $lang) {
  // If a user is at this stage, then they have permission to edit this sheet.
  // They are either the sheet's owner, or a permissioned user such as a
  // character evaluator or GM. So we only have to deal with one of two types of user.
  global $user;
  foreach (element_children($form) as $key) {
    // Check if there are settings for this key. If there aren't we can just keep going.
    if (isset($fields[$key])) {
      // Set custom validation if it exists.
      if (isset($fields[$key]['validation_callback']) && function_exists($fields[$key]['validation_callback'])) {
        foreach (element_children($form[$key][$lang]) as $index) {
          $form[$key][$lang][$index]['value']['#element_validate'] = $fields[$key]['validation_callback'];
        }
      }
      // Set custom submit if it exists.
      if (isset($fields[$key]['submit_callback']) && function_exists($fields[$key]['submit_callback'])) {
        $form['#submit'][] = $fields[$key]['submit_callback'];
      }
      // Check if a system defined a function for handling permissions.
      if (isset($fields[$key]['permissions_callback']) && function_exists($fields[$key]['permissions_callback'])) {
        call_user_func_array($fields[$key]['permissions_callback'], array( $form[$key][$lang][0]['value'], $user, $lang ));
      }
      elseif (isset($fields[$key]['permissions'])) {
        // We might be using character sheet's own controls.
        // Determine user access to this field by user and setting.
        $permission = '';
        // Check user as owner permissions, else check for other.
        if ($node->uid == $user->uid && isset($fields[$key]['permissions']['owner'])) {
          $permission = $fields[$key]['permissions']['owner'];
        }
        elseif (isset($fields[$key]['permissions']['other'])) {
          $permission = $fields[$key]['permissions']['other'];
        }
        // Else, do nothing.
        if (!empty($permission)) {
          // Get the field first.
          if (isset($form[$key])) {
            if (isset($form[$key][$lang][0]['value'])) {
              foreach (element_children($form[$key][$lang]) as $index) {
                $field =& $form[$key][$lang][$index]['value'];
                // And apply the change for each.
                switch ($permission) {
                  case HIDE_SHEET:
                    // Disable access.
                    _character_sheet_field_control_hide($field);
                  break;
                  case DISABLE_SHEET:
                    // Disable interface.
                    _character_sheet_field_control_disable($field);
                    if (isset($form[$key][$lang]['add_more'])) {
                      $form[$key][$lang]['add_more']['#access'] = FALSE;
                    }
                  break;
                  case LIMIT_SHEET:
                    // Display as select, with limit on options.
                    // Check if a system defined a function for handling options.
                    if (isset($fields[$key]['costs']['costs_callback']) && function_exists($fields[$key]['costs']['costs_callback'])) {
                      call_user_func_array($fields[$key]['costs']['costs_callback'], array( $field, $user, $node, $lang ));
                    }
                    else {
                      // Figure out what our options are based on current value, available xp, system settings.
                        _character_sheet_field_control_options($field, $node, $fields[$key]);
                    }
                  break;
                  default:
                  // Do nothing.
                  break;
                }
              }
            }
            else {
              if (isset($form[$key][$lang]['#options'])) {
                $field =& $form[$key][$lang];
              }
              else {
                $field =& $form[$key];
              }
              // And apply the change.
              switch ($permission) {
                case HIDE_SHEET:
                  // Disable access.
                  _character_sheet_field_control_hide($field);
                break;
                case DISABLE_SHEET:
                  // Disable interface.
                  _character_sheet_field_control_disable($field);
                  if (isset($form[$key][$lang]['add_more'])) {
                    $form[$key][$lang]['add_more']['#access'] = FALSE;
                  }
                break;
                case LIMIT_SHEET:
                  // Display as select, with limit on options.
                  // Check if a system defined a function for handling options.
                  if (isset($fields[$key]['costs']['costs_callback']) && function_exists($fields[$key]['costs']['costs_callback'])) {
                    call_user_func_array($fields[$key]['costs']['costs_callback'], array( $field, $user, $node, $lang ));
                  }
                  else {
                    // Figure out what our options are based on current value, available xp, system settings.
                      _character_sheet_field_control_options($field, $node, $fields[$key]);
                  }
                break;
                default:
                // Do nothing.
                break;
              }
            }
          }
        }
      }
      // Else, do nothing - we have no field level permissions.
    }
    // Else, do nothing - we're not under field level control.
    // ALERT: recursion occurs here. If this child has other children edit them as well.
    foreach (element_children($form[$key]) as $child_key) {
      $form[$key] = _character_sheet_field_control($form[$key], $node, $fields, $lang);
      // Pass the submit key upwards.
      if (isset($form[$key]['#submit'])) {
        $form['#submit'] = isset($form['#submit']) ? (array) $form['#submit'] : array();
        $form['#submit'] = array_merge($form['#submit'], $form[$key]['#submit']);
        unset($form[$key]['#submit']);
      }
    }
  }
  // Done with the loop.
  return $form;
}

/**
 * XP function, get types of XP.
 *
 * NOTE: Many systems handle experience in a wide variety of ways. Some have none. Some have points
 * and values that cost more or less points on a linear scale, some on an exponential scale, some even
 * on no scale.
 *
 * Given this infinate flexibility, I expect each system implementation to have to define one or more
 * types of XP. I suggest you only *ADDS* XP values. For systems where points are 'spent', two values are
 * tracked: XP and spent XP (automatically). This way you can calculate the difference between the two to determine the
 * correct total of unspent XP and how much a specific improvement costs during validation.
 * Though the system may describe points as 'spent' - always simply add to the 'spent' type of XP instead.
 * All numerically driven systems should be able to be converted to a like approach.
 * For example: D&D feats can be thought of as gaining a feat-xp point every few levels or class levels.
 * So the XP types would be: feat and spent_feat - or fighter_feat and spent_fighter_feat.
 *
 * A clever programmer may consider using User Points for this. If so - please contact me and we can
 * develop a patch to allow for User Points to drive XP systems.
 */

/**
 * Helper function, determine how many points a sheet has spent.
 * ALERT: RECURSIVE. BE CAREFUL HERE.
 */
function _character_sheet_get_field_value($node, $field_key, $field_info, $nodes_seen = array()) {
  if (isset($node->nid)) {
    $nodes_seen[] = $node->nid;
  }
  if (isset($node->item_id)) {
    $nodes_seen[] = $node->item_id;
  }
  $total = 0;
  // Given a node, find the key and patch to the information for that key.
  $total = 0;
  $language = isset($node->language) ? $node->language : 'und';
  $walkable_node = (array) $node;
  if (isset($walkable_node[$field_key]) && is_array($walkable_node[$field_key][$language])) {
    // Found it on the top level.
    // Grab all deltas and total them up.
    foreach ($walkable_node[$field_key][$language] as $delta => $delta_field) {
      if (isset($delta_field['value']) && is_numeric($delta_field['value'])) {
        // Otherwise, let's build up the value point by point according to the given cost.
        if (isset($field_info['costs']['value_callback']) && function_exists($field_info['costs']['value_callback'])) {
          // If there's a value function, use that to figure out the value of the key.
          $total += call_user_func_array($field_info['costs']['value_callback'], array( $field_info, $delta_field['value'] ));
        }
        elseif (isset($delta_field['value']) && !empty($delta_field['value']) && is_numeric($delta_field['value'])) {
          // Otherwise, let's build up the value point by point according to the given cost.
          $total += _character_sheet_calculate_field_value($field_info, $delta_field['value']);
        }
      }
    }
  }
  else {
    // We didn't find it on the top level. So it may be in a child somewhere.
    // Go looking.
    foreach (element_children($walkable_node) as $this_child) {
      $child = (array) $walkable_node[$this_child];
      if (isset($child[$language]) && is_array($child[$language])) {
        foreach ($child[$language] as $delta => $delta_field) {
          $sub_node = '';
          if (isset($delta_field['nid'])) {
            // We have a node reference subnode.
            $sub_node = node_load($delta_field['nid']);
          }
          else {
            $child_field_info = field_info_field($this_child);
            if ($child_field_info['type'] == 'field_collection') {
              if (isset($delta_field['value'])) {
                // Checking on an already saved node (probably old_node).
                $sub_node = field_collection_item_load($delta_field['value']);
              }
              elseif (isset($delta_field['entity']->item_id)) {
                // New node, has a differnt format. Not saved, so we can't just load it.
                // We have to grab it from the form's submitted data.
                $sub_node = $delta_field['entity'];
              }
            }
          }
          // If we found a subnode at this this child, check it.
          if (!empty($sub_node)) {
            $sub_node_id = '';
            if (isset($sub_node->nid)) {
              $sub_node_id = $sub_node->nid;
            }
            if (isset($sub_node->item_id)) {
              $sub_node_id = $sub_node->item_id;
            }
            if (!in_array($sub_node_id, $nodes_seen)) {
              $total += _character_sheet_get_field_value($sub_node, $field_key, $field_info, $nodes_seen);
            }
          }
        }
      }
    }
  }
  return $total;
}

/**
 * Helper function, build the cost up from 0 points in it. Figure price, per point.
 */
function _character_sheet_calculate_field_value($field_info, $value) {
  if (!isset($value)) {
    return 0;
  }
  if (isset($field_info['costs']['cost_mode']) && $field_info['costs']['cost_mode'] == 'flat') {
    $total = $value * $field_info['costs']['cost'];
  }
  else {
    $total = 0;
    $current = 0;
    $cost_modifier = isset($field_info['costs']['cost']) ? $field_info['costs']['cost'] : 1;
    $step = isset($field_info['costs']['step']) ? $field_info['costs']['step'] : 1;
    while ($current < $value) {
      $current += $step;
      $total += $current * $cost_modifier;
    }
  }
  return $total;
}

/**
 * Validate XP spent per field based on changes.
 */
function _character_sheet_validate_xp($node, $old_node) {
  // We don't really care if there is an abstract baseline value underlayng this.
  // Because all we really need to find id the difference between the old and new.
  $fields_info = _character_sheet_get_field_info($node);
  $spent_xp = array();
  foreach ($fields_info as $field_key => $field_info) {
    if (isset($field_info['costs']['xp_type'])) {
      // Calculate cost difference.
      $old_value = _character_sheet_get_field_value($old_node, $field_key, $field_info);
      $new_value = _character_sheet_get_field_value($node, $field_key, $field_info);
      // Add the debt to the ongoing total for this type.
      $xp_type = $field_info['costs']['xp_type'];
      if (!isset($spent_xp[$xp_type])) {
        $spent_xp[$xp_type] = 0;
      }
      $cost = $new_value - $old_value;
      $spent_xp[$xp_type] += $cost;
      // Find available XP for this field xp type.
      $available_xp = _character_sheet_field_available_xp($node, $field_info);
      if ($spent_xp[$xp_type] > 0 && $spent_xp[$xp_type] > $available_xp) {
        return $error = array('field' => '', 'message' =>
          t('You have spent %spent_xp xp out of %available_xp available xp. Please revise your sheet.',
            array('%spent_xp' => $spent_xp[$xp_type], '%available_xp' => $available_xp)));
      }
    }
  }
  drupal_set_message(t('Your sheet has been updated with spent XP.'));
  return FALSE;
}

/**
 * Charge XP per field based on changes.
 */
function _character_sheet_charge_xp($node, $curr_cost, $old_cost) {
  // There has been a critical error. You only charge XP once the character is in
  // play, so there should NEVER be an empty previous value for the character.
  if (empty($node) || empty($curr_cost)) {
      return FALSE;
  }
  if (empty($old_cost) && $old_cost != 0) {
      return FALSE;
  }
  // We don't really care if there is an abstract baseline value underlayng this.
  // Because all we really need to find id the difference between the old and new.
  $spent_xp = array();
  foreach ($curr_cost as $xp_key => $new_value) {
    if (isset($old_cost[$xp_key]) && !empty($old_cost[$xp_key])) {
      $old_value = $old_cost[$xp_key];
      // Calculate cost difference.
      $spent_xp = $new_value - $old_value;
      // Mark the spent XP type to track spent XP.
      // If spent XP > XP then the character sheet is in debt.
      if ($spent_xp > 0) {
        drupal_set_message('Charging ' . $spent_xp . ' ' . $xp_key . ' to character sheet.');
        _character_sheet_update_xp($node->nid, $spent_xp, 'spent_' . $xp_key);
        global $user;
        $message = t('@xp @type XP spent on @title by @user.',
          array('@xp' => $spent_xp, '@type' => $xp_key, '@title' => $node->title, '@user' => $user->name));
        _character_sheet_update_log($node->nid, $xp_key, $message, $variables = array());
      }
    }
  }
  return TRUE;
}

/**
 * Figure out value of sheet as a total.
 */
function _character_sheet_total_xp($node) {
  if (empty($node)) {
    return 0;
  }
  $total = array();
  $fields_info = _character_sheet_get_field_info($node);
  $spent_xp = array();
  foreach ($fields_info as $field_key => $field_info) {
    if (isset($field_info['costs']['xp_type'])) {
      if (empty($total[ $field_info['costs']['xp_type'] ])) {
        $total[ $field_info['costs']['xp_type'] ] = 0;
      }
      $total[ $field_info['costs']['xp_type'] ] += _character_sheet_get_field_value($node, $field_key, $field_info);
    }
  }
  return $total;
}

/**
 * Character sheet, callbacks and functions.
 */

/**
 * Menu callback, transfer ownership pages for characters.
 */
function _character_sheet_management($node) {
  $output = '';
  $form = drupal_get_form('_character_sheet_xp_form', $node);
  $output .= drupal_render($form);
  return $output;
}

/*
 * Form callback function from node view, adds ownership form to node display.
 */
function _character_sheet_xp_form($form, &$form_state, $node) {

  // Display XP totals.
  $form['node_info'] = array(
    '#type' => 'fieldset',
    '#title' => t('XP information'),
  );
  $form['node_info']['xp'] = array(
    '#type' => 'item',
    '#title' => t('XP Totals:'),
    '#markup' => $node->xp_themed,
  );
  $form['node_info']['nid'] = array(
    '#type' => 'value',
    '#value' => $node->nid,
  );
  // Allow for adding XP.
  global $user;
  if (_character_sheet_xp_access($node)) {
    $form['add_xp'] = array(
      '#type' => 'fieldset',
      '#title' => 'Add XP',
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
    );
    $bottom = 0;
    $top = 10;
    if (_character_sheet_xp_remove_access($node)) {
      $bottom = -100;
      $top = 100;
    }
    $xp_add = range($bottom, $top);
    $form['add_xp']['xp'] = array(
      '#type' => 'select',
      '#title' => t('Add XP'),
      '#options' => array_combine($xp_add, $xp_add),
      '#default_value' => 0,
      '#description' => t('Add XP to this character sheet.'),
    );
    $system = module_invoke($node->character_sheet_system, 'character_sheet_register_systems');
    $system = $system[$node->character_sheet_system];
    $types = isset($system['xp']['types']) ? $system['xp']['types'] : array('xp');
    $options = array_combine($types, $types);
    $form['add_xp']['type'] = array(
      '#type' => 'select',
      '#title' => t('Type'),
      '#options' => $options,
      '#description' => t('Add XP to this character sheet.'),
    );
    $form['add_xp']['submit_xp'] = array(
      '#type' => 'submit',
      '#value' => t('Add XP'),
      '#submit' => array('_character_sheet_xp_form_submit'),
    );
  }
  return $form;
}

/**
 * Submit callback for adding XP.
 */
function _character_sheet_xp_form_submit($form, $form_state) {
  $values = $form_state['values'];
  if ($values['xp'] > 0 ) {
    $node = node_load($values['nid']);
    $system = module_invoke($node->character_sheet_system, 'character_sheet_register_systems');
    $system = $system[$node->character_sheet_system];
    if (function_exists($system['xp']['add_callback'])) {
      // If there's a add function, use that to assing xp.
      call_user_func_array($system['xp']['add_callback'], array( $node->nid, $values['xp'], $values['type'] ));
    }
    else {
      // Otherwise, use our own.
      _character_sheet_update_xp($node->nid, $values['xp'], $values['type']);
    }
  }
}

/**
 * Helper functions, calculate total character sheet values - for systems that use points.
 */

/**
 * Helper function, return the entire workflow object for the default sheet workflow.
 */
function _character_sheet_get_workflow() {
  $name = variable_get('character_sheet_default_workflow', 'Character evaluation');
  return workflow_get_workflows_by_name($name);
}

/**
 * Helper function, invoke field information from system implementations. This field info provides
 * a list of access restricted fields (limited by permission), as well as rendering suggestions.
 */
function _character_sheet_get_field_info($node) {
  return module_invoke($node->character_sheet_system, 'character_sheet_field_info');
}

/**
 * Helper function, determine if a content type is a character sheet.
 */
function _character_sheet_is_enabled($node) {
  $character_sheet_types = variable_get('character_sheet_types', array());
  return isset($character_sheet_types[$node->type]) ? TRUE : FALSE;
}

/**
 * Helper function, determine if a character sheet is in a playable mode.
 */
function _character_sheet_is_playable($node) {
  if (!isset($node->nid)) {
    return FALSE;
  }
  if (!isset($node->character_sheet_system) || !isset($node->workflow)) {
    $node = node_load($node->nid);
  }
  // Figure out the workflow for the node.
  $playable_states = variable_get('character_sheet_' . $node->character_sheet_system . '_playable', '');
  if (isset($node->workflow, $playable_states)) {
    return in_array($node->workflow, $playable_states) ? TRUE : FALSE;
  }
  return TRUE;
}

/**
 * Helper function, hide a given field in a node form.
 */
function _character_sheet_field_control_hide(&$field) {
  $field['#access'] = FALSE;
  if (isset($field['#default_value'])) {
    $field['#value'] = $field['#default_value'];
  }
}

/**
 * Helper function, disable a given field in a node form.
 */
function _character_sheet_field_control_disable(&$field) {
  $field['#disabled'] = TRUE;
  if (isset($field['#default_value'])) {
    $field['#value'] = $field['#default_value'];
  }
}

/**
 * Helper function, get available XP for a given set of xp.
 */
function _character_sheet_field_available_xp($node, $field_info) {
  $xp_type = isset($field_info['costs']['xp_type']) ? $field_info['costs']['xp_type'] : 'xp';
  $spent_xp_type = isset($field_info['costs']['xp_type']) ? 'spent_' . $field_info['costs']['xp_type'] : 'spent_xp';
  $xp = _character_sheet_get_xp($node->nid, $xp_type);
  $spent_xp = _character_sheet_get_xp($node->nid, $spent_xp_type);
  return $xp - $spent_xp;
}

/**
 * Helper function, set available options for a given field in a node form.
 */
function _character_sheet_field_control_options(&$field, $node, $field_info) {
  $options = array();
  $current = $original = isset($field['#default_value']) ? $field['#default_value'] : '';
  $options[$current] = $current . ' (cost 0)';
  if (isset($current) && is_numeric($current)) {
    // Figure out the available XP for spending.
    $available_xp = _character_sheet_field_available_xp($node, $field_info);
    // Calculate the max available option by cost.
    $cost_modifier = isset($field_info['costs']['cost']) ? $field_info['costs']['cost'] : 1;
    $step = isset($field_info['costs']['step']) ? $field_info['costs']['step'] : 1;
    $cum_cost = 0;
    // Figure out how many steps up we can go before we're out of available XP.
    while ($available_xp > 0) {
      if (isset($field_info['costs']['value_callback']) && function_exists($field_info['costs']['value_callback'])) {
        // If there's a value function, use that to figure out the value of the key.
        $old_cost = call_user_func_array($field_info['costs']['value_callback'], array( $field_info, $current));
        $current += $step;
        $new_cost = call_user_func_array($field_info['costs']['value_callback'], array( $field_info, $current));
        $next_cost = $new_cost - $old_cost;
      }
      elseif (isset($current) && is_numeric($current)) {
        // Otherwise, let's build up the value point by point according to the given cost.
        $old_cost = _character_sheet_calculate_field_value($field_info, $current);
        $current += $step;
        $new_cost = _character_sheet_calculate_field_value($field_info, $current);
        $next_cost = $new_cost - $old_cost;
      }
      $cum_cost = $cum_cost + $next_cost;
      $available_xp = $available_xp - $next_cost;
      if ($available_xp >= 0) {
        $options[$current] = $current . ' (cost ' . number_format($cum_cost, 2) . ')';
      }
    }
  }
  // Limited fields, are numeric. And only go up.
  $field['#type'] = 'select';
  $field['#size'] = 1;
  $field['#options'] = array();
  if (empty($options)) {
    $field['#disabled'] = TRUE;
    $field['#value'] = $original;
  }
  $field['#options'] = $options;
  $field['#default_value'] = $original;
}

/*
 * Database related functions.
 *
 * NOTE: Sheet status is implemented using Workflow. So no tables will be listed here for that.
 * It is unwise to reinvent the wheel.
 */

/**
 * DB function, insert XP count to the database.
 */
function _character_sheet_update_xp($nid, $xp, $type = 'xp') {
  if ($xp == 0) {
    return;
  }
  $record = array(
    'xp' => (float) $xp,
    'nid' => $nid,
    'type' => $type,
  );
  $current_xp = _character_sheet_is_set_xp($nid, $type);
  if (isset($current_xp[0]->nid)) {
    $record['xp'] += (float) $current_xp[0]->xp;
    // Update current xp total to track.
    drupal_write_record('character_sheet_xp', $record, array('nid', 'type'));
  }
  else {
    // Insert new total.
    drupal_write_record('character_sheet_xp', $record);
  }
  // Clear the cache if need be.
  if (module_exists('entitycache')) {
    cache_clear_all($nid, 'cache_entity_node');
  }
}

/**
 * DB function, delete XP count in the database.
 */
function _character_sheet_delete_xp($nid) {
  db_query('DELETE FROM {character_sheet_xp} WHERE nid = :nid', array(':nid' => $nid));
}

/**
 * DB function, check if type is set for this node.
 */
function _character_sheet_is_set_xp($nid, $type='xp') {
  $type_query = 'SELECT * FROM {character_sheet_xp} WHERE nid = :nid AND type = :type';
  $args = array(':nid' => $nid, ':type' => $type);
  return db_query($type_query, $args)->fetchAll();
}

/**
 * DB function, get XP count from the database.
 */
function _character_sheet_get_xp($nid, $type = 'xp') {
  $type_query = 'SELECT xp FROM {character_sheet_xp} WHERE nid = :nid';
  $args = array(':nid' => $nid);
  // Filter for the type.
  if ($type != 'all') {
    $type_query .= ' AND type=:type';
    $args[':type'] = $type;
  }
  // Make the query.
  $total = 0;
  $results = db_query($type_query, $args);
  foreach ($results as $result) {
    if (!empty($result->xp)) {
      $total = $result->xp;
    }
  }
  return $total;
}

/*
 * Database helper function, get log matching a given nid.
 */
function _character_sheet_get_log($nid, $limit = 20) {
  $logs = array();
  $count = 0;
  $results = db_query("SELECT * FROM {character_sheet_log} WHERE nid = :nid ORDER BY timestamp DESC", array(':nid' => $nid));
  foreach ($results as $result) {
    if ($count < $limit) {
      $result = (array) $result;
      $message = '[' . format_date($result['timestamp']) . ' ] ' . $result['message'];
      $logs[] = $message;
      $count++;
    }
  }
  return $logs;
}

/*
 * Database helper function, delete all logs matching a given nid.
 */
function _character_sheet_delete_log($nid) {
  db_delete('character_sheet_log')
  ->condition('nid', $nid)
  ->execute();
}

/*
 * Database helper function, insert a new log entry.
 */
function _character_sheet_update_log($nid, $type, $message, $variables = array()) {
  global $user;
  $record = array(
    'uid' => $user->uid,
    'type' => $type,
    'message' => t($message, $variables),
    'nid' => $nid,
    'hostname' => ip_address(),
    'timestamp' => REQUEST_TIME,
  );
  drupal_write_record('character_sheet_log', $record);
}

/*
IMPLEMENT AS FEATURES.
 9b) White Wolf - for prism.
 10) Next implementation - eclipsephase - X ep per skill, attribute - and categories of mods.
 10b) Record the options and their cost in a data file: CVS? category, name, desc, cost, requires-name, requires-min, requires-max
 11) GURPS?
 12) DnD - uses nmultple types of sub-XP to control stat points, feats, skill points, etc. (Chit system.)
 13) Format output by templates.
 */
