<?php

/**
 * @file
 * The module file of the PowerTagging module.
 */

include_once dirname(__FILE__) . '/includes/powertagging.field.inc';
include_once dirname(__FILE__) . '/includes/powertagging_solr_search.inc';

/**
 * Implements hook_permission().
 */
function powertagging_permission() {
  return array(
    'administer powertagging' => array(
      'title' => t('Administer PowerTagging'),
      'description' => t('Perform administration tasks for PowerTagging.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function powertagging_menu() {
  $items['admin/config/services/powertagging'] = array(
    'title' => 'PowerTagging',
    'description' => 'Manage PowerTagging configurations',
    'page callback' => 'powertagging_list',
    'access arguments' => array('administer powertagging'),
    'file' => 'includes/powertagging.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/config/services/powertagging/add'] = array(
    'title' => 'Add a PowerTagging configuration',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('powertagging_form'),
    'access arguments' => array('administer powertagging'),
    'file' => 'includes/powertagging.admin.inc',
    'type' => MENU_LOCAL_ACTION,
  );
  $items['admin/config/services/powertagging/%powertagging_config'] = array(
    'title callback' => 'powertagging_config_title',
    'title arguments' => array(4),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('powertagging_form', 4),
    'access arguments' => array('administer powertagging'),
    'file' => 'includes/powertagging.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/config/services/powertagging/%powertagging_config/edit'] = array(
    'title' => 'Edit a PowerTagging configuration',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('powertagging_form', 4),
    'access arguments' => array('administer powertagging'),
    'file' => 'includes/powertagging.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/services/powertagging/%powertagging_config/delete'] = array(
    'title' => 'Delete a PowerTagging configuration',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('powertagging_delete_form', 4),
    'access arguments' => array('administer powertagging'),
    'file' => 'includes/powertagging.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/services/powertagging/%powertagging_config/index_project/%'] = array(
    'title callback' => 'powertagging_bulk_indexing_title',
    'title arguments' => array(4, 6),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('powertagging_indexProject_form', 4, 6),
    'access arguments' => array('administer powertagging'),
    'file' => 'includes/powertagging.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/services/powertagging/%powertagging_config/synchronize_project/%'] = array(
    'title callback' => 'powertagging_project_synchronization_title',
    'title arguments' => array(4, 6),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('powertagging_synchronizeProject_form', 4, 6),
    'access arguments' => array('administer powertagging'),
    'file' => 'includes/powertagging.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/config/services/powertagging/%/available'] = array(
    'title' => 'Check if PoolParty server is available',
    'page callback' => 'powertagging_available',
    'page arguments' => array(4),
    'access arguments' => array('administer powertagging'),
    'file' => 'includes/powertagging.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['powertagging/extract'] = array(
    'title' => 'Extract concepts and terms from content',
    'page callback' => 'powertagging_extract',
    'access callback' => 'user_is_logged_in',
    'file' => 'includes/powertagging.field.inc',
    'type' => MENU_CALLBACK,
  );

  $items['powertagging/autocomplete_tags/%powertagging_config/%/%'] = array(
    'title' => 'Get the tags for a given project matching a string',
    'page callback' => 'powertagging_autocomplete_tags',
    'access callback' => TRUE,
    'page arguments' => array(2, 3, 4),
    'type' => MENU_CALLBACK,
  );

  $items['powertagging/autocomplete_taxonomies'] = array(
    'title' => 'Get the taxonomies matching a string',
    'page callback' => 'powertagging_autocomplete_taxonomies',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_admin_menu_map().
 */
function powertagging_admin_menu_map() {
  // Add awareness to the administration menu of the various PowerTagging
  // configurations so they are included in the dropdown menu.
  if (!user_access('administer powertagging')) {
    return;
  }
  $configs = powertagging_config_load();
  $powertagging_ids = array();
  foreach ($configs as $config) {
    $powertagging_ids[] = $config->powertagging_id;
  }
  $map['admin/config/services/powertagging/%powertagging_config'] = array(
    'parent' => 'admin/config/services/powertagging',
    'arguments' => array(
      array('%powertagging_config' => $powertagging_ids),
    ),
  );

  return $map;
}

/**
 * Title callback for PowerTagging configurations.
 *
 * @param object $config
 *   The PowerTagging deserialized configuration object.
 * @return string
 *   The title.
 */
function powertagging_config_title($config) {
  if (empty($config)) {
    return t('Edit PowerTagging configuration "unknown"');
  }
  return t('Edit PowerTagging configuration "!title"', array('!title' => $config->title));
}

/**
 * Implements hook_form_alter().
 */
function powertagging_form_alter(&$form, &$form_state, $form_id) {
  // Alter the field instance configuration of the powertagging field.
  if ($form_id == 'field_ui_field_edit_form' && $form['#field']['type'] == 'powertagging') {
    // Fix the cardinality to "Unlimited".
    $form['field']['cardinality']['#options'] = array(
      FIELD_CARDINALITY_UNLIMITED => $form['field']['cardinality']['#options'][FIELD_CARDINALITY_UNLIMITED],
    );
    $form['field']['cardinality']['#default_value'] = FIELD_CARDINALITY_UNLIMITED;
  }
}

/**
 * Implements hook_taxonomy_term_update().
 *
 * @todo:
 *   * Check if entity is indexed
 */
function powertagging_taxonomy_term_update($term) {
  $entity_ids = powertagging_get_entity_ids($term);
  powertagging_update_solr_index($entity_ids);
}

/**
 * Implements hook_taxonomy_term_delete().
 */
function powertagging_taxonomy_term_delete($term) {
  // Get the PowerTagging field names.
  $entity_ids = powertagging_get_entity_ids($term);
  $field_names = powertagging_get_field_name();
  foreach ($field_names as $field_name) {
    $table = 'field_data_' . $field_name;
    $column = $field_name . '_tid';

    // Delete the reference from a PowerTagging field to this term.
    db_delete($table)
      ->condition($column, $term->tid)
      ->execute();
  }

  // Clean up the {taxonomy_index} table when terms are deleted.
  if (variable_get('taxonomy_maintain_index_table', TRUE)) {
    db_delete('taxonomy_index')->condition('tid', $term->tid)->execute();
  }

  powertagging_update_solr_index($entity_ids);
}

/**
 * Loads all PowerTagging configurations or one if $powertagging_id is given.
 *
 * @param int $powertagging_id
 *   ID of the PowerTagging configuration.
 * @param bool $only_available_services
 *   Get only PoolParty servers, which currently can be reached.
 *
 * @return array
 *   Return a array with all (or one) configuration set.
 */
function powertagging_config_load($powertagging_id = NULL, $only_available_services = FALSE) {
  if (is_null($powertagging_id) || (int) $powertagging_id <= 0) {
    $result = db_query("SELECT * FROM {powertagging} ORDER BY powertagging_id");
  }
  else {
    $result = db_query("SELECT * FROM {powertagging} WHERE powertagging_id = :powertagging_id", array(':powertagging_id' => $powertagging_id));
  }

  $conf = array();
  if ($only_available_services) {
    foreach ($result as $record) {
      $pp_api = powertagging_getPoolPartyApi($record->powertagging_id);
      $availability = $pp_api->available();
      if ($availability['success']) {
        $conf[] = $record;
      }
    }
  }
  else {
    foreach ($result as $record) {
      $conf[] = $record;
    }
  }

  foreach ($conf as &$single_conf) {
    $single_conf->config = unserialize($single_conf->config);
    if ($single_conf->config === FALSE) {
      $single_conf->config = array();
    }
    $single_conf = (object) powertagging_array_merge_recursive_simple((array) powertagging_default_config_load(), (array) $single_conf);
    $single_conf->connection = SemanticConnector::getConnection('pp_server', $single_conf->connection_id);

    // Get for each project the taxonomy name if taxonomy id is given.
    // The taxonomy name can by changed in the meantime.
    if (!empty($single_conf->config['projects'])) {
      foreach ($single_conf->config['projects'] as &$project) {
        if (isset($project['taxonomy_id']) && $project['taxonomy_id'] > 0) {
          $taxonomy = taxonomy_vocabulary_load($project['taxonomy_id']);
          $project['taxonomy_name'] = ($taxonomy !== FALSE && property_exists($taxonomy, 'name') ? $taxonomy->name : '');
        }
      }
    }
    unset($single_conf);
  }

  return (is_null($powertagging_id) || !isset($conf[0])) ? $conf : $conf[0];
}

/**
 * Loads the default values for a PowerTagging configuration.
 *
 * @return array
 *   Return a array with a configuration set.
 */
function powertagging_default_config_load() {
  $conf = new StdClass();
  $conf->title = '';
  $conf->connection_id = 0;
  $conf->connection = SemanticConnector::getConnection('pp_server', $conf->connection_id);
  $conf->config = array(
    'concepts_per_extraction' => 20,
    'concepts_threshold' => 10,
    'freeterms_per_extraction' => 0,
    'freeterms_threshold' => 50,
  );

  return $conf;
}

/**
 * Adds the form for the global limits.
 *
 * @param array $form
 *   The form where the global limits form will be added.
 * @param int $concepts_per_extraction
 *   The value of the max concepts per extraction.
 * @param int $concepts_threshold
 *   The threshold level for the concepts.
 * @param int $freeterms_per_extraction
 *   The value of the max concepts per extraction.
 * @param int $freeterms_threshold
 *   The threshold level for the free terms.
 * @param array $parents
 *   Explicit parents for all the fields if required.
 */
function powertagging_global_limits_form(array &$form, $concepts_per_extraction, $concepts_threshold, $freeterms_per_extraction, $freeterms_threshold, array $parents = array()) {
  $form['concepts'] = array(
    '#type' => 'fieldset',
    '#title' => t('Concept settings'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
    '#description' => t('Concepts are available in the thesaurus.'),
    '#tree' => FALSE,
  );

  $form['concepts']['concepts_per_extraction'] = array(
    '#title' => t('Max concepts per extraction'),
    '#type' => 'slider',
    '#default_value' => $concepts_per_extraction,
    '#slider_style' => 'concept',
    '#range' => 'min',
    '#min' => 0,
    '#max' => 100,
    '#step' => 1,
    '#display_inputs' => FALSE,
    '#display_values' => TRUE,
    '#slider_length' => '500px',
    '#description' => t('Maximum number of concepts to be displayed as a tagging result.'),
  );

  $form['concepts']['concepts_threshold'] = array(
    '#title' => t('Threshold level for the concepts'),
    '#type' => 'slider',
    '#default_value' => $concepts_threshold,
    '#slider_style' => 'concept',
    '#range' => 'min',
    '#min' => 1,
    '#max' => 100,
    '#step' => 1,
    '#display_inputs' => FALSE,
    '#display_values' => TRUE,
    '#slider_length' => '500px',
    '#description' => t('Only concepts with a minimum score of the chosen value will be displayed as a tagging result.'),
  );

  $form['freeterms'] = array(
    '#type' => 'fieldset',
    '#title' => t('Free term settings'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
    '#description' => t('Free terms are extracted terms, which are not available in the thesaurus.'),
    '#tree' => FALSE,
  );

  $form['freeterms']['freeterms_per_extraction'] = array(
    '#title' => t('Max free terms per extraction'),
    '#type' => 'slider',
    '#default_value' => $freeterms_per_extraction,
    '#slider_style' => 'freeterm',
    '#range' => 'min',
    '#min' => 0,
    '#max' => 100,
    '#step' => 1,
    '#display_inputs' => FALSE,
    '#display_values' => TRUE,
    '#slider_length' => '500px',
    '#description' => t('Maximum number of free terms for tagging.'),
  );

  $form['freeterms']['freeterms_threshold'] = array(
    '#title' => t('Threshold level for the free terms'),
    '#type' => 'slider',
    '#default_value' => $freeterms_threshold,
    '#slider_style' => 'freeterm',
    '#range' => 'min',
    '#min' => 1,
    '#max' => 100,
    '#step' => 1,
    '#display_inputs' => FALSE,
    '#display_values' => TRUE,
    '#slider_length' => '500px',
    '#description' => t('Only free terms with a minimum score of the chosen value will be used for tagging.!linebreakWARNING: A threshold below 40 may reduce the quality of free term extractions!', array('!linebreak' => '<br />')),
  );

  if (!empty($parents)) {
    $form['concepts']['concepts_per_extraction']['#parents'] = array_merge($parents, array('concepts_per_extraction'));
    $form['concepts']['concepts_threshold']['#parents'] = array_merge($parents, array('concepts_threshold'));
    $form['freeterms']['freeterms_per_extraction']['#parents'] = array_merge($parents, array('freeterms_per_extraction'));
    $form['freeterms']['freeterms_threshold']['#parents'] = array_merge($parents, array('freeterms_threshold'));
  }
}

/**
 * Deletes a PowerTagging configuration.
 *
 * @param int $powertagging_id
 *   ID of the PowerTagging configuration.
 */
function powertagging_conf_delete($powertagging_id) {
  $powertagging_id = (int) $powertagging_id;
  if ($powertagging_id > 0) {
    db_delete('powertagging')
      ->condition('powertagging_id', $powertagging_id)
      ->execute();
  }
}

/**
 * Get a PoolPartyApi-object from a powerTagging-config-id.
 *
 * @param int $config_id
 *   The ID of the PowerTagging config.
 *
 * @return object
 *   The PoolPartyApi-object.
 */
function powertagging_getPoolPartyApi($config_id) {
  $config = powertagging_config_load($config_id);
  return $config->connection->getAPI('PPX');
}

/**
 * Start the indexing-process for a PoolParty project.
 *
 * @param object $powertagging_conf
 *   The powertagging configuration.
 * @param string $project_id
 *   The ID of the PoolParty project.
 * @param array $settings
 *   Array of indexing settings --> Required settings: "content_types" and
 *   "skip_tagged_content".
 * @param string $batch_finished_callback
 *   The function to call after the batch is finished.
 *
 * @return bool
 *   TRUE on success, FALSE on error.
 */
function powertagging_indexProject($powertagging_conf, $project_id, array $settings, $batch_finished_callback = 'powertagging_update_entity_tags_finished') {
  if (!isset($settings['content_types']) || !isset($settings['skip_tagged_content'])) {
    watchdog('PowerTagging', 'Incorrect settings-configuration in "powertagging_indexProject"', array(), WATCHDOG_ERROR);
    return FALSE;
  }

  $batch_operations = array();
  foreach ($settings['content_types'] as $content_type) {
    $exploded_content_type = explode(' ', $content_type);
    $entity_type = $exploded_content_type[0];
    $bundle = $exploded_content_type[1];
    $fieldname = $exploded_content_type[2];
    $instance = field_info_instance($entity_type, $fieldname, $bundle);

    $tag_fields = array();
    foreach ($instance['settings']['fields'] as $tag_field_title) {
      if ($tag_field_title) {
        $tag_fields[] = $tag_field_title;
      }
    }

    $tag_settings = array(
      'project_id' => $project_id,
      'powertagging_id' => $powertagging_conf->powertagging_id,
      'taxonomy_id' => $powertagging_conf->config['projects'][$project_id]['taxonomy_id'],
      'concepts_per_extraction' => $instance['settings']['concepts_per_extraction']['value'],
      'concepts_threshold' => $instance['settings']['concepts_threshold']['value'],
      'freeterms_per_extraction' => $instance['settings']['freeterms_per_extraction']['value'],
      'freeterms_threshold' => $instance['settings']['freeterms_threshold']['value'],
      'fields' => $tag_fields,
      'skip_tagged_content' => $settings['skip_tagged_content'],
      'default_tags_field' => (isset($instance['settings']['default_tags_field']) ? $instance['settings']['default_tags_field'] : ''),
    );

    // If the entity type is not supported, throw an error and continue.
    if (!in_array($entity_type, array('node', 'user', 'taxonomy_term'))) {
      drupal_set_message(t('Entity type "%entitytype" is not supported in Bulk tagging.', array('%entitytype' => $entity_type)), 'error');
      continue;
    }

    // Get all entities for the given content type.
    switch ($entity_type) {
      case 'node':
        $entity_ids = db_select('node', 'n')
          ->fields('n', array('nid'))
          ->condition('type', $bundle)
          ->execute()
          ->fetchCol(0);
        break;

      case 'user':
        $entity_ids = db_select('users', 'u')
          ->fields('u', array('uid'))
          ->condition('status', 0, '>')
          ->execute()
          ->fetchCol(0);
        break;

      case 'taxonomy_term':
        $entity_ids = db_query(
          'SELECT t.tid
          FROM taxonomy_term_data t, taxonomy_vocabulary v
          WHERE t.vid = v.vid
          AND v.machine_name = :machine_name', array(':machine_name' => $bundle))
          ->fetchCol(0);
        break;
    }

    $batch_infos = array(
      'total' => count($entity_ids),
      'start_time' => time(),
      'entities_per_request' => $settings['entities_per_request'],
    );

    // Add a batch-operation for every entity.
    $operation_entities = array();
    for ($entity_count = 1; $entity_count <= count($entity_ids); $entity_count++) {
      $operation_entities[] = $entity_ids[$entity_count - 1];

      if (($entity_count % $settings['entities_per_request']) == 0 || $entity_count == (count($entity_ids))) {
        $batch_operations[] = array(
          'powertagging_update_entity_tags',
          array($operation_entities, $entity_type, $fieldname, $tag_settings, $batch_infos),
        );
        $operation_entities = array();
      }
    }
  }

  $batch = array(
    'operations' => $batch_operations,
    'progress_message' => '',
    'init_message' => t('Preparing the bulk tagging process.'),
    'finished' => $batch_finished_callback,
  );

  batch_set($batch);
  return TRUE;
}

/**
 * Update the powertagging tags of one powertagging field of a single entity.
 *
 * @param array $entity_ids
 *   A single ID or an array of IDs of entitys, depending on the entity type
 *   (e.g. nid, uid, ...).
 * @param string $entity_type
 *   The entity type of the entity (e.g. node, user, ...).
 * @param string $fieldname
 *   The field name of the powertagging field.
 * @param array $tag_settings
 *   An array of settings used during the process of extraction.
 * @param array $batch_infos
 *   An associative array of information about the batch process.
 * @param array $context
 *   The Batch context to transmit data between different calls.
 */
function powertagging_update_entity_tags($entity_ids, $entity_type, $fieldname, array $tag_settings, array $batch_infos, &$context) {
  if (!isset($context['results']['processed'])) {
    $context['results']['processed'] = 0;
    $context['results']['tagged'] = 0;
    $context['results']['skipped'] = 0;
  }

  // If the entity type is not supported, throw an error and return.
  if (!in_array($entity_type, array('node', 'user', 'taxonomy_term'))) {
    drupal_set_message(t('Entity type "%entitytype" is not supported in Bulk tagging.', array('%entitytype' => $entity_type)), 'error');
    return;
  }

  if (!is_array($entity_ids)) {
    $entity_ids = array($entity_ids);
  }

  // Load the entities.
  switch ($entity_type) {
    case 'node':
      $entities = node_load_multiple($entity_ids);
      break;

    case 'user':
      $entities = user_load_multiple($entity_ids);
      break;

    case 'taxonomy_term':
      $entities = taxonomy_term_load_multiple($entity_ids);
      break;
  }

  foreach ($entities as $entity) {
    $context['results']['processed']++;

    // Return if this entity does not need to be tagged.
    if (isset($entity->{$fieldname})) {
      if ((!isset($tag_settings['skip_tagged_content']) || $tag_settings['skip_tagged_content']) && !empty($entity->{$fieldname})) {
        $context['results']['skipped']++;
        continue;
      }
    }

    // Build the content.
    $tag_contents = array();
    $file_ids = array();
    foreach ($tag_settings['fields'] as $field_id) {
      if (property_exists($entity, $field_id)) {
        // String fields like "title".
        if (is_string($entity->{$field_id})) {
          $tag_content = strip_tags($entity->{$field_id});
          if (!empty($tag_content)) {
            $tag_contents[] = $entity->{$field_id};
          }
        }
        // More complex fields.
        elseif (!empty($entity->{$field_id})) {
          $language_keys = array_keys($entity->{$field_id});
          $field_value_language = $entity->{$field_id}[$language_keys[0]];
          if (!empty($field_value_language) && is_array($field_value_language[0])) {
            // Body field --> include summary.
            if ($field_id == 'body') {
              // Add the summary.
              if ($field_value_language[0]['summary'] != $field_value_language[0]['value']) {
                $summary = strip_tags($field_value_language[0]['summary']);
                if (!empty($summary)) {
                  $tag_contents[] = $summary;
                }
              }

              // Add the normal field value.
              $normal_value = strip_tags($field_value_language[0]['value']);
              if (!empty($normal_value)) {
                $tag_contents[] = $normal_value;
              }
            }
            // Files.
            elseif (isset($field_value_language[0]['fid'])) {
              foreach ($field_value_language as $file) {
                $file_ids[] = $file['fid'];
              }
            }
            // Any other content.
            else {
              $tag_content = strip_tags(render(field_view_field($entity_type, $entity, $field_id, array(
                'label' => 'hidden',
              ))));
              if (!empty($tag_content)) {
                $tag_contents[] = $tag_content;
              }
            }
          }
        }
      }
    }

    // Get the language of the entity.
    $tag_settings['entity_language'] = ((powertagging_translation_possible() && isset($entity->language)) ? $entity->language : LANGUAGE_NONE);

    // Get the concepts for the entity.
    $extraction_result = powertagging_extract(implode(' ', $tag_contents), $file_ids, $tag_settings, 'array');

    // Add already existing terms if required.
    if (isset($tag_settings['default_tags_field']) && !empty($tag_settings['default_tags_field'])) {
      if (isset($entity->{$tag_settings['default_tags_field']}) && !empty($entity->{$tag_settings['default_tags_field']})) {
        $language_keys = array_keys($entity->{$tag_settings['default_tags_field']});
        $field_values = $entity->{$tag_settings['default_tags_field']}[$language_keys[0]];
        if (!empty($field_values)) {
          $default_terms_ids = array();
          foreach ($field_values as $field_value) {
            if (isset($field_value['tid'])) {
              $default_terms_ids[] = $field_value['tid'];
            }
          }

          $terms = taxonomy_term_load_multiple($default_terms_ids);
          foreach ($terms as $term) {
            $low_term_name = strtolower($term->name);
            $unique = TRUE;
            foreach ($extraction_result['suggestion']['concepts'] as $concept) {
              if (strtolower($concept['label']) == $low_term_name) {
                $unique = FALSE;
              }
            }
            if ($unique) {
              foreach ($extraction_result['suggestion']['freeterms'] as $freeterm) {
                if (strtolower($freeterm['label']) == $low_term_name) {
                  $unique = FALSE;
                }
              }
              if ($unique) {
                $extraction_result['suggestion']['freeterms'][] = array(
                  'tid' => 0,
                  'uri' => '',
                  'label' => $term->name,
                  'score' => 100,
                  'type' => 'freeterm',
                );
              }
            }
          }
        }
      }
    }

    $tids = powertagging_extraction_result_to_tids($extraction_result, $tag_settings['taxonomy_id'], $tag_settings['entity_language']);

    // Bring the tids into the correct format for a entity.
    $field_value_tids = array();
    foreach ($tids as $tid) {
      $field_value_tids[] = array(
        'tid' => (string) $tid,
      );
    }

    // Save the PowerTagging tags to the entity.
    switch ($entity_type) {
      case 'node':
        if (!empty($field_value_tids)) {
          $entity->{$fieldname}[LANGUAGE_NONE] = $field_value_tids;
        }
        else {
          $entity->{$fieldname} = array();
        }
        node_save($entity);

        //drupal_set_message(t('Node "%entitytitle" was retagged successfully.', array('%entitytitle' => $entity->title)));
        break;

      case 'user':
        $user_edit_data = array();
        if (!empty($field_value_tids)) {
          $user_edit_data[$fieldname][LANGUAGE_NONE] = $field_value_tids;
        }
        else {
          $user_edit_data[$fieldname] = array();
        }
        user_save($entity, $user_edit_data);

        //drupal_set_message(t('User "%entitytitle" was retagged successfully.', array('%entitytitle' => $entity->name)));
        break;

      case 'taxonomy_term':
        if (!empty($field_value_tids)) {
          $entity->{$fieldname}[LANGUAGE_NONE] = $field_value_tids;
        }
        else {
          $entity->{$fieldname} = array();
        }
        taxonomy_term_save($entity);

        //drupal_set_message(t('Taxonomy term "%entitytitle" was retagged successfully.', array('%entitytitle' => $entity->name)));
        break;
    }

    $context['results']['tagged']++;
  }

  // Show the remaining time as a batch message.
  $time_string = '';
  if ($context['results']['processed'] > 0) {
    $remaining_time = floor((time() - $batch_infos['start_time']) / $context['results']['processed'] * ($batch_infos['total'] - $context['results']['processed']));
    if ($remaining_time > 0) {
      $time_string = (floor($remaining_time / 86400)) . 'd ' . (floor($remaining_time / 3600) % 24) . 'h ' . (floor($remaining_time / 60) % 60) . 'm ' . ($remaining_time % 60) . 's';
    }
    else {
      $time_string = t('Done.');
    }
  }

  $context['message'] = t('Processed entities: %currententities of %totalentities. (Tagged: %taggedentities, Skipped: %skippedentities)', array(
    '%currententities' => $context['results']['processed'],
    '%taggedentities' => $context['results']['tagged'],
    '%skippedentities' => $context['results']['skipped'],
    '%totalentities' => $batch_infos['total'])
  ) . '<br />' . t('Remaining time: %remainingtime.', array('%remainingtime' => $time_string));
}

/**
 * Batch 'finished' callback used by PowerTagging Bulk Tagging.
 */
function powertagging_update_entity_tags_finished($success, $results, $operations) {
  drupal_set_message(t('Successfully finished bulk tagging of %totalentities entities. (Tagged: %taggedentities, Skipped: %skippedentities)', array('%totalentities' => $results['processed'], '%taggedentities' => $results['tagged'], '%skippedentities' => $results['skipped'])));
}

/**
 * Get the taxonomy term ids of an extraction result.
 *
 * @param array $extraction_result
 *   The extracted terms (result of powertagging_extract()).
 * @param int $taxonomy_id
 *   The ID of the taxonomy to save the terms in.
 * @param string $language
 *   The language of terms that need to be created.
 *
 * @return array
 *   Array of taxonomy term ids for the extracted concepts.
 */
function powertagging_extraction_result_to_tids(array $extraction_result, $taxonomy_id, $language) {
  $tids = array();
  $new_terms = array();
  // Add tids of concepts.
  foreach ($extraction_result["suggestion"]['concepts'] as $concept) {
    if ($concept['tid'] > 0) {
      $tids[] = $concept['tid'];
    }
    else {
      $new_terms[] = $concept['label'] . '|' . $concept['uri'];
    }
  }
  // Add tids of freeterms.
  foreach ($extraction_result["suggestion"]['freeterms'] as $concept) {
    if ($concept['tid'] > 0) {
      $tids[] = $concept['tid'];
    }
    else {
      $new_terms[] = $concept['label'] . '|';
    }
  }

  // Create taxonomy terms for new tags.
  if (!empty($new_terms)) {
    $new_term_ids = powertagging_add_new_tag($new_terms, $taxonomy_id, $language);
    // Merge existing and new terms.
    $tids = array_merge($tids, $new_term_ids);
  }

  return $tids;
}

/**
 * Returns one or all field names with the type 'poolparty'.
 *
 * @param string $bundle
 *   The name of a bundle.
 *
 * @return array | string
 *   All field names or only one depending on the $bundle.
 */
function powertagging_get_field_name($bundle = '') {
  $field_names = &drupal_static(__FUNCTION__);
  if (!isset($field_names)) {
    $field_names = array();
  }
  if (empty($bundle)) {
    $bundle = '#all';
    if (!isset($field_names[$bundle])) {
      $field_map = field_info_field_map();
      $field_names[$bundle] = array();
      foreach ($field_map as $field_name => $map) {
        if ($map['type'] != 'powertagging') {
          continue;
        }
        $field_names[$bundle][] = $field_name;
      }
      $field_names[$bundle] = array_unique($field_names[$bundle]);
    }
  }
  else {
    if (!isset($field_names[$bundle])) {
      $field_names[$bundle] = '';
      $fields = field_read_fields(array('bundle' => $bundle));
      foreach ($fields as $field) {
        if ($field['type'] == 'powertagging') {
          $field_names[$bundle] = $field['field_name'];
          break;
        }
      }
    }
  }

  return $field_names[$bundle];
}

/**
 * Get all powertagging field instances.
 *
 * @param int $powertagging_id
 *   The ID of the powertagging configuration to filter for.
 * @param string $project_id
 *   The ID of the PP project to filter for.
 *
 * @return array
 *   Array of field instances that match the filters.
 */
function powertagging_get_tagging_field_instances($powertagging_id = 0, $project_id = "") {
  $fields = field_read_fields(array('type' => 'powertagging'));

  $field_options = array();
  foreach ($fields as $field_name => $field_data) {
    if ($powertagging_id > 0 && $field_data['settings']['powertagging_id'] != $powertagging_id) {
      continue;
    }

    $field_instances = field_read_instances(array('field_name' => $field_name));
    foreach ($field_instances as $field_instance) {
      if (empty($project_id) || (isset($field_instance['settings']['project_id']) && $field_instance['settings']['project_id'] == $project_id && powertagging_check_field_instance($field_instance))) {
        $field_options[] = $field_instance;
      }
    }
  }

  return $field_options;
}

/**
 * Check if a powertagging-field-instance is correctly configured to allow tags.
 *
 * @param array $instance
 *   The field instance to check.
 *
 * @return bool
 *   TRUE if the field instance was configured correctly, FALSE if not.
 */
function powertagging_check_field_instance(array $instance) {
  if ($instance['widget']['type'] == 'powertagging_ui') {
    // Check if the "Number of values" was set to "Unlimited".
    $field = field_info_field($instance['field_name']);
    if ($field['cardinality'] == FIELD_CARDINALITY_UNLIMITED) {
      // Project-ID is set.
      if (isset($instance['settings']['project_id']) && !empty($instance['settings']['project_id'])) {
        // Check if fields are set.
        $fields_to_check = array();
        foreach ($instance['settings']['fields'] as $field_id) {
          if ($field_id != FALSE) {
            $fields_to_check[] = $field_id;
          }
        }
        if (!empty($fields_to_check)) {
          return TRUE;
        }
      }
    }
  }

  return FALSE;
}

/**
 * Get the title for a bulk indexing page.
 *
 * @param object $powertagging_conf
 *   The PowerTagging configuration.
 * @param string $project_id
 *   The ID of the PoolParty project that is used for indexing.
 *
 * @return string
 *   The title of the bulk indexing page.
 */
function powertagging_bulk_indexing_title($powertagging_conf, $project_id) {
  return 'Bulk indexing of project "' . $powertagging_conf->config['projects'][$project_id]['label'] . '" in PowerTagging configuration "' . $powertagging_conf->title . '"';
}

/**
 * Get the title for a project synchronization page.
 *
 * @param object $powertagging_conf
 *   The PowerTagging configuration.
 * @param string $project_id
 *   The ID of the PoolParty project that is used for indexing.
 *
 * @return string
 *   The title of the project synchronization page.
 */
function powertagging_project_synchronization_title($powertagging_conf, $project_id) {
  return 'Taxonomy synchronization of project "' . $powertagging_conf->config['projects'][$project_id]['label'] . '" in PowerTagging configuration "' . $powertagging_conf->title . '"';
}

/**
 * Get the matching concepts for GET-parameter "term".
 *
 * @param object $powertagging_conf
 *   The PowerTagging configuration.
 * @param int $project_id
 *   The ID of the PoolParty thesaurus to look for matching concepts in.
 * @param string $language
 *   The iso-code of the language you want your suggestions in.
 */
function powertagging_autocomplete_tags($powertagging_conf, $project_id, $language) {
  $string = check_plain($_GET['term']);
  $terms = array();

  if (!empty($string)) {
    $project_languages = $powertagging_conf->config['projects'][$project_id]['languages'];
    if (isset($project_languages[$language]) && !empty($project_languages[$language])) {
      $pp_api = powertagging_getPoolPartyApi($powertagging_conf->powertagging_id);
      $suggested_concepts = $pp_api->suggest($string, $project_languages[$language], $project_id);
      if (!empty($suggested_concepts)) {
        // Add the Drupal taxonomy ID if it needs to be added.
        if (!property_exists($suggested_concepts[0], 'tid')) {
          powertagging_add_tid_to_concept($suggested_concepts, (int) $powertagging_conf->config['projects'][$project_id]['taxonomy_id'], 'concepts', $project_languages[$language]);
        }
        foreach ($suggested_concepts as $concept) {
          $terms[] = array(
            'tid' => $concept->tid,
            'uri' => $concept->uri,
            'name' => $concept->prefLabel,
            'value' => $concept->prefLabel,
            'type' => 'concept',
          );
        }
      }
    }
  }

  // Sort the terms: concepts on top and free terms to the bottom.
  if (!empty($terms)) {
    usort($terms, 'powertagging_autocomplete_tags_sort');
  }

  drupal_json_output($terms);
}

/**
 * Callback function to sort the autocomplete tags.
 */
function powertagging_autocomplete_tags_sort($a, $b) {
  if ((empty($a['uri']) && empty($b['uri'])) || (!empty($a['uri']) && !empty($b['uri']))) {
    return strcasecmp($a['name'], $b['name']);
  }

  return empty($a['uri']) ? 1 : -1;
}

/**
 * Callback function for the autocomplete field to search taxonomies.
 *
 * @param string $string
 *   The search string.
 */
function powertagging_autocomplete_taxonomies($string) {
  $taxonomy_names = array();
  $result = db_select('taxonomy_vocabulary', 'v')
    ->fields('v', array('name'))
    ->condition('name', '%' . db_like($string) . '%', 'LIKE')
    ->range(0, 10)
    ->orderBy('name')
    ->execute();

  foreach ($result as $row) {
    $taxonomy_names[$row->name] = check_plain($row->name);
  }

  drupal_json_output($taxonomy_names);
}

/**
 * Check if translation of powertagging-concepts is possible in Drupal.
 *
 * @return bool
 *   TRUE if taxonomy translation is available, FALSE if not.
 */
function powertagging_translation_possible() {
  return module_exists('i18n_taxonomy');
}

/**
 * Check if there are any unfulfilled requirements of this module.
 *
 * @return array
 *   Array of error-messages if there are unfulfilled requirements.
 */
function powertagging_check_requirements() {
  $errors = array();

  if (!function_exists('curl_version')) {
    $errors[] = t('cURL needs to be installed on the server to use this module.');
  }

  return $errors;
}

/**
 * Merge an array recursively, but the way normal array_merge() works.
 */
function powertagging_array_merge_recursive_simple() {
  if (func_num_args() < 2) {
    trigger_error(__FUNCTION__  . ' needs two or more array arguments', E_USER_WARNING);
    return;
  }
  $arrays = func_get_args();
  $merged = array();
  while ($arrays) {
    $array = array_shift($arrays);
    if (!is_array($array)) {
      trigger_error(__FUNCTION__  . ' encountered a non array argument', E_USER_WARNING);
      return;
    }

    if (!$array) {
      continue;
    }

    foreach ($array as $key => $value) {
      if (is_string($key)) {
        if (is_array($value) && array_key_exists($key, $merged) && is_array($merged[$key])) {
          $merged[$key] = call_user_func(__FUNCTION__, $merged[$key], $value);
        }
        else {
          $merged[$key] = $value;
        }
      }
      else {
        $merged[] = $value;
      }
    }
  }
  return $merged;
}

/**
 * @defgroup powertagging_taxonomy_index Taxonomy indexing
 * @{
 * Functions to maintain taxonomy indexing.
 *
 * @see taxonomy_build_node_index
 */

/**
 * Implements hook_node_insert().
 */
function powertagging_node_insert($node) {
  // Add taxonomy index entries for the node.
  powertagging_taxonomy_build_node_index($node);
}

/**
 * Implements hook_entity_update().
 *
 * @info It was taken the hook_entity_update() instead of hook_node_update()
 * because the taxonomy module has removed the data after the insertion.
 */
function powertagging_entity_update($entity, $type) {
  // Always rebuild the node's taxonomy index entries on node save.
  if ($type == 'node') {
    powertagging_taxonomy_delete_node_index($entity);
    powertagging_taxonomy_build_node_index($entity);
  }
}

/**
 * Implements hook_node_delete().
 */
function powertagging_node_delete($node) {
  // Clean up the {taxonomy_index} table when nodes are deleted.
  powertagging_taxonomy_delete_node_index($node);
}

/**
 * Builds and inserts taxonomy index entries for a given node.
 *
 * The index lists all terms that are related to a given node entity, and is
 * therefore maintained at the entity level.
 *
 * @param $node
 *   The node object.
 */
function powertagging_taxonomy_build_node_index($node) {
  // We maintain a denormalized table of term/node relationships, containing
  // only data for current, published nodes.
  $status = NULL;
  if (variable_get('taxonomy_maintain_index_table', TRUE)) {
    // If a node property is not set in the node object when node_save() is
    // called, the old value from $node->original is used.
    if (!empty($node->original)) {
      $status = (int)(!empty($node->status) || (!isset($node->status) && !empty($node->original->status)));
      $sticky = (int)(!empty($node->sticky) || (!isset($node->sticky) && !empty($node->original->sticky)));
    }
    else {
      $status = (int)(!empty($node->status));
      $sticky = (int)(!empty($node->sticky));
    }
  }
  // We only maintain the taxonomy index for published nodes.
  if ($status) {
    // Collect a unique list of all the term IDs from all node fields.
    $tid_all = array();
    foreach (field_info_instances('node', $node->type) as $instance) {
      $field_name = $instance['field_name'];
      $field = field_info_field($field_name);
      if ($field['module'] == 'powertagging' && $field['storage']['type'] == 'field_sql_storage') {
        // If a field value is not set in the node object when node_save() is
        // called, the old value from $node->original is used.
        if (isset($node->{$field_name})) {
          $items = $node->{$field_name};
        }
        elseif (isset($node->original->{$field_name})) {
          $items = $node->original->{$field_name};
        }
        else {
          continue;
        }
        foreach (field_available_languages('node', $field) as $langcode) {
          if (!empty($items[$langcode])) {
            foreach ($items[$langcode] as $item) {
              $tid_all[$item['tid']] = $item['tid'];
            }
          }
        }
      }
    }
    // Insert index entries for all the node's terms.
    if (!empty($tid_all)) {
      $query = db_insert('taxonomy_index')->fields(array('nid', 'tid', 'sticky', 'created'));
      foreach ($tid_all as $tid) {
        $query->values(array(
          'nid' => $node->nid,
          'tid' => $tid,
          'sticky' => $sticky,
          'created' => $node->created,
        ));
      }
      $query->execute();
    }
  }
}

/**
 * Deletes taxonomy index entries for a given node.
 *
 * @param $node
 *   The node object.
 */
function powertagging_taxonomy_delete_node_index($node) {
  if (variable_get('taxonomy_maintain_index_table', TRUE)) {
    // Get the the term ids for the given node.
    $tid_all = array();
    foreach (field_info_instances('node', $node->type) as $instance) {
      $field_name = $instance['field_name'];
      $field = field_info_field($field_name);
      if ($field['module'] == 'powertagging' && $field['storage']['type'] == 'field_sql_storage') {
        // If a field value is not set in the node object when node_save() is
        // called, the old value from $node->original is used.
        if (isset($node->{$field_name})) {
          $items = $node->{$field_name};
        }
        elseif (isset($node->original->{$field_name})) {
          $items = $node->original->{$field_name};
        }
        else {
          continue;
        }
        foreach (field_available_languages('node', $field) as $langcode) {
          if (!empty($items[$langcode])) {
            foreach ($items[$langcode] as $item) {
              $tid_all[$item['tid']] = $item['tid'];
            }
          }
        }
      }
    }

    if (!empty($tid_all)) {
      // Remove the selected terms from the taxonomy index.
      db_delete('taxonomy_index')
        ->condition('nid', $node->nid)
        ->condition('tid', $tid_all)
        ->execute();
    }
  }
}

/**
 * @} End of "defgroup powertagging_taxonomy_index".
 */
