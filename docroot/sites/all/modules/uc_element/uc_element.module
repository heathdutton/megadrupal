<?php
/**
 * @file
 * Ubercart Payment gateway for Element Payment Services.
 */

/**
 * Implements hook_menu().
 */
function uc_element_menu() {
  $items = array();
  // List of stored cards for a customer.
  $items['user/%/cards'] = array(
    'title' => 'Stored Credit Cards',
    'page callback' => 'uc_element_user_card_list',
    'page arguments' => array(1),
    'access callback' => '_uc_element_validate_user',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
    'file' => 'uc_element.pages.inc',
  );
  // Page to allow deleting stored cards.
  $items['user/%/cards/delete'] = array(
    'title' => 'Delete Stored Card',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('uc_element_delete_form', 1),
    'access callback' => '_uc_element_validate_user',
    'access arguments' => array(1),
    'file' => 'uc_element.pages.inc',
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function uc_element_permission() {
  // Defining permissions for accessing and modifying stored credit cards.
  return array(
    'administer stored credit cards' => array(
      'title' => t('Administer Stored Credit Cards'),
      'description' => t('Perform administration tasks for Element stored credit cards.'),
    ),
  );
}

/**
 * Access callback for manipulating stored card data.
 *
 * Here we check to see if the user accessing the page has the proper access.
 *
 * @param int $uid
 *   User ID of the user whose content is being accessed.
 *
 * @return bool
 *   boolean indicating if the user has access to this content.
 */
function _uc_element_validate_user($uid) {
  global $user;
  return ((user_access('administer stored credit cards') || $uid == $user->uid) && $user->uid != 0);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function uc_element_form_uc_cart_checkout_form_alter(&$form, &$form_state, $form_id) {
  // Attaching the css for credit card form.
  $form['#attached']['css'][] = drupal_get_path('module', 'uc_element') . '/uc_element.css';
  // If we store cards, allow those options.
  if (variable_get('uc_element_allow_stored_cards', FALSE) && isset($form['panes']['payment']['payment_method']['#options']['element_stored'])) {
    // Here we hide the "Stored Credit Card" gateway if it is not appropriate.
    global $user;
    // Check if user is logged in.
    if ($user->uid) {
      $row = _uc_element_card_get($user->uid);
      $form['panes']['payment']['payment_method']['#options']['element_stored'] .= ' (****' . $row->last_4 . ')';
    }
  }
}

/**
 * Implements hook_uc_payment_method().
 */
function uc_element_uc_payment_method() {
  $methods['element_stored'] = array(
    'name' => t('Stored Credit Card'),
    'title' => t('Stored Credit Card'),
    'desc' => t('Pay using stored credit card.'),
    'callback' => 'uc_element_payment_method_stored',
    'weight' => 1,
    'checkout'  => TRUE,
    'no_gateway' => TRUE,
  );
  return $methods;
}

/**
 * Callback method for stored payment methods.
 */
function uc_element_payment_method_stored($op, &$order) {
  switch ($op) {
    case 'cart-details':
      $build['policy'] = array(
        '#markup' => t('This method will charge your card ending in @lastfour. If you do not have a card on file or you wish to use an alternate credit card, please choose the "Credit Card" method and enter your payment information. You may choose to store your new card at that time.', array('@lastfour' => _uc_element_last4_get($order->uid))),
      );
      return $build;

    case 'order-submit':
      $charge_settings = array(
        'txn_type' => variable_get('uc_pg_elementgateway_cc_txn_type', UC_CREDIT_AUTH_ONLY),
        'charge_stored_card' => TRUE,
      );
      $data = uc_element_charge($order->order_id, $order->order_total, $charge_settings);
      if (!$data['success']) {
        $result[] = array(
          'pass' => FALSE,
          'message' => t('We were unable to process your credit card payment. Please verify your card details and try again. If the problem persists, contact us to complete your order.'),
        );
        return $result;
      }

      break;
  }
}

/**
 * Implements hook_uc_payment_method_alter().
 */
function uc_element_uc_payment_method_alter(&$methods) {
  // Add the "Store credit card?" option by adding our own callback.
  $methods['credit']['callback'] = 'uc_element_method_credit';
}

/**
 * Callback function for Element credit card option.
 */
function uc_element_method_credit($op, &$order, $form = NULL, &$form_state = NULL) {
  // Get the normal callback results (we just want to modify them).
  $credit_results = uc_payment_method_credit($op, $order, $form, $form_state);
  // If this is the cart-details, just add the store card checkbox.
  if ($op == 'cart-details') {
    $credit_results['cc_store'] = array(
      '#type' => 'checkbox',
      '#title' => t('Store Credit Card?'),
      '#attributes' => array(
        'checked' => 'checked',
      ),
    );
    // Reorder the fields.
    $new_results = array(
      'cc_type' => $credit_results['cc_policy'],
      'cc_policy' => $credit_results['cc_policy'],
      'cc_number' => $credit_results['cc_number'],
      'cc_cvv' => $credit_results['cc_cvv'],
      'cc_exp_month' => $credit_results['cc_exp_month'],
      'cc_exp_year' => $credit_results['cc_exp_year'],
      'cc_owner' => $credit_results['cc_owner'],
      'cc_store' => $credit_results['cc_store'],
    );
    // Hide the credit card type.
    $new_results['cc_type']['#title'] = '';
    $new_results['cc_type']['#type'] = 'hidden';
    $new_results['cc_type']['#default_value'] = '';
    unset($new_results['cc_type']['#options']);
    // Rewrite fields a bit.
    $new_results['cc_owner']['#title'] = t('Name on card');
    $new_results['cc_number']['#prefix'] = '<div id="card_frame_holder"><div id="card_frame" class="generic">';
    $new_results['cc_owner']['#suffix'] = '</div>';
    $new_results['cc_store']['#suffix'] = '</div>';

    $new_results['cc_number']['#attributes'] = array(
      'placeholder' => t('Card Number'),
      'autocomplete' => 'cc-number',
      'required' => '',
    );
    $new_results['cc_owner']['#attributes'] = array(
      'placeholder' => t('Cardholder Name'),
      'autocomplete' => 'cc-name',
      'required' => '',
    );
    $new_results['cc_cvv']['#attributes'] = array(
      'placeholder' => t('CVV'),
      'autocomplete' => 'cc-csc',
      'required' => '',
    );
    $new_results['cc_exp_month']['#attributes'] = array(
      'autocomplete' => 'cc-exp-month',
      'required' => '',
    );
    $new_results['cc_exp_year']['#attributes'] = array(
      'autocomplete' => 'cc-exp-year',
      'required' => '',
    );
    return $new_results;
  }
  else {
    return $credit_results;
  }
}

/**
 * Implements hook_uc_payment_gateway().
 *
 * Exposes Element Payment Gateway to Ubercart..
 */
function uc_element_uc_payment_gateway() {
  $gateways['element_gateway'] = array(
    'title' => t('Element Payment Gateway'),
    'description' => t('Process credit card payments using Element Payment Gateway.'),
    'settings' => 'uc_element_settings_form',
    'credit' => 'uc_element_charge',
    'credit_txn_types' => array(UC_CREDIT_AUTH_ONLY, UC_CREDIT_AUTH_CAPTURE),
  );
  return $gateways;
}

/**
 * Payment gateway administrative settings.
 */
function uc_element_settings_form() {
  $form['uc_element_email'] = array(
    '#type' => 'textfield',
    '#title' => t('Email address to receive error information'),
    '#default_value' => variable_get('uc_element_email', ''),
    '#description' => t('This email will receive alerts when there are errors processing payment. Leave blank to disable'),
  );
  $form['uc_element_allow_stored_cards'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow Stored Cards'),
    '#default_value' => variable_get('uc_element_allow_stored_cards', FALSE),
    '#description' => t('Set whether or not this site will store cards (requires Services Gateway below)'),
  );
  $form['avs'] = array(
    '#type' => 'fieldset',
    '#title' => t('Element Address Verification System'),
    '#description' => t('Settings for the Element Address Verification System (see http://en.wikipedia.org/wiki/Address_Verification_System)'),
  );
  $form['avs']['uc_element_AVS'] = array(
    '#type' => 'checkbox',
    '#title' => t('Use Address Verification System?'),
    '#default_value' => variable_get('uc_element_AVS', FALSE),
    '#description' => t('Check this to use the Element address verification system (United States and Canada)'),
  );
  $form['avs']['uc_element_CVV'] = array(
    '#type' => 'checkbox',
    '#title' => t('Use CVV check?'),
    '#default_value' => variable_get('uc_element_CVV', FALSE),
    '#description' => t('Check this to use the Element address verification system to check CVV validity on all orders'),
  );
  $form['avs']['uc_element_ignore_AVS'] = array(
    '#type' => 'checkbox',
    '#title' => t('Ignore Address Verification System results?'),
    '#default_value' => variable_get('uc_element_ignore_AVS', FALSE),
    '#description' => t('Check this to ignore the AVS results. Useful if you want to be able to later check AVS results, but want orders to pass no matter what AVS returns.'),
  );
  $form['api_id_key'] = array(
    '#type' => 'fieldset',
    '#title' => t('Element Transaction API Information'),
    '#description' => t('This information is required for Ubercart to interact with Element'),
  );
  $form['api_id_key']['uc_element_gateway_url'] = array(
    '#type' => 'textfield',
    '#title' => t('Element Gateway URL'),
    '#default_value' => variable_get('uc_element_gateway_url', 'https://certtransaction.elementexpress.com/express.asmx?WSDL'),
    '#description' => t('Element Payment Services transaction gateway. URL should end in "?WSDL"'),
  );
  $form['api_id_key']['uc_element_gateway_url_backup'] = array(
    '#type' => 'textfield',
    '#title' => t('Element Gateway URL Backup'),
    '#default_value' => variable_get('uc_element_gateway_url_backup', 'https://certtransaction.elementexpress.com/express.asmx?WSDL'),
    '#description' => t('Backup URL for the Element Gateway - this is used in the event that the original gateway URL is down (happens occasionally). Leave blank to ignore'),
  );
  $form['api_id_key']['uc_element_services_gateway_url'] = array(
    '#type' => 'textfield',
    '#title' => t('Element Services Gateway URL'),
    '#default_value' => variable_get('uc_element_services_gateway_url', 'https://certservices.elementexpress.com/express.asmx?WSDL'),
    '#description' => t('Element Payment Services service gateway. URL should end in "?WSDL"'),
  );
  $form['api_id_key']['uc_element_services_gateway_url_backup'] = array(
    '#type' => 'textfield',
    '#title' => t('Element Services Gateway URL Backup'),
    '#default_value' => variable_get('uc_element_services_gateway_url_backup', 'https://certservices.elementexpress.com/express.asmx?WSDL'),
    '#description' => t('Backup URL for the Element Services Gateway - this is used in the event that the original services gateway URL is down (happens occasionally). Leave blank to ignore'),
  );
  $form['api_id_key']['uc_element_account_id'] = array(
    '#type' => 'textfield',
    '#title' => t('Element Account ID'),
    '#default_value' => variable_get('uc_element_account_id', ''),
  );
  $form['api_id_key']['uc_element_account_token'] = array(
    '#type' => 'textfield',
    '#title' => t('Element Account Token'),
    '#default_value' => variable_get('uc_element_account_token', ''),
  );
  $form['api_id_key']['uc_element_acceptor_id'] = array(
    '#type' => 'textfield',
    '#title' => t('Element Acceptor ID'),
    '#default_value' => variable_get('uc_element_acceptor_id', ''),
  );
  $form['api_id_key']['uc_element_application_id'] = array(
    '#type' => 'textfield',
    '#title' => t('Element Application ID'),
    '#default_value' => variable_get('uc_element_application_id', ''),
  );

  return $form;
}

/**
 * Main handler for processing credit card transactions.
 *
 * @param int $order_id
 *   The order id of the order connected to the credit card to be charged.
 * @param string $amount
 *   The amount to charge the credit card.
 * @param array $data
 *   Transactional information.
 *
 * @return array
 *   An array containing a success/failure boolean along with response message.
 */
function uc_element_charge($order_id, $amount, array $data) {
  if (!isset($data['charge_stored_card'])) {
    $data['charge_stored_card'] = FALSE;
  }

  // Convert the amount to the proper format.
  $amount = round($amount, 2);
  $amount = number_format($amount, 2, '.', '');

  if ($amount <= 0) {
    return array('success' => TRUE);
  }

  // Load the order.
  $order = uc_order_load($order_id);

  global $user;

  // If using stored card and we don't allow it, throw an error.
  if (!(variable_get('uc_element_allow_stored_cards', FALSE)) && $data['charge_stored_card']) {
    $error = t('Please choose a valid payment method');
    drupal_set_message($error, 'error');
    return array('success' => FALSE, 'message' => $error);
  }

  // Connect to the Element Express payment gateway via SOAP.
  try {
    $soap_location = variable_get('uc_element_gateway_url', 'https://transaction.elementexpress.com/express.asmx?WSDL');
    $connection_settings = array(
      'soap_version' => SOAP_1_1,
      'cache_wsdl' => WSDL_CACHE_NONE,
      'location' => $soap_location,
      'uri' => 'https://transaction.elementexpress.com',
      'trace' => TRUE,
    );
    $element_soap_client = new SoapClient($soap_location, $connection_settings);
  }
  catch (Exception $e) {
    try {
      // Try the backup.
      $soap_location = variable_get('uc_element_gateway_url_backup', 'https://transaction.elementexpress.com/express.asmx?WSDL');
      $connection_settings = array(
        'soap_version' => SOAP_1_1,
        'cache_wsdl' => WSDL_CACHE_NONE,
        'location' => $soap_location,
        'uri' => 'https://transaction.elementexpress.com',
        'trace' => TRUE,
      );
      $element_soap_client = new SoapClient($soap_location, $connection_settings);
    }
    catch (Exception $e) {
      $error = t('Unable to connect to the credit card processor');
      drupal_set_message($error, 'error');
      return array('success' => FALSE, 'message' => $error);
    }
  }

  // If we are using a stored card, we need to connect to the Services API.
  if (variable_get('uc_element_allow_stored_cards', FALSE) && ((isset($order->payment_details) && $order->payment_details['cc_store'] == 1) || $data['charge_stored_card'])) {
    // Connect to the Element Express services gateway via SOAP.
    try {
      $soap_location = variable_get('uc_element_services_gateway_url', '');
      $connection_settings = array(
        'soap_version' => SOAP_1_1,
        'cache_wsdl' => WSDL_CACHE_NONE,
        'location' => $soap_location,
        'uri' => 'https://transaction.elementexpress.com',
        'trace' => TRUE,
      );
      $element_pass_soap_client = new SoapClient($soap_location, $connection_settings);
    }
    catch (Exception $e) {
      try {
        // Try the backup.
        $soap_location = variable_get('uc_element_services_gateway_url_backup', '');
        $connection_settings = array(
          'soap_version' => SOAP_1_1,
          'cache_wsdl' => WSDL_CACHE_NONE,
          'location' => $soap_location,
          'uri' => 'https://transaction.elementexpress.com',
          'trace' => TRUE,
        );
        $element_soap_client = new SoapClient($soap_location, $connection_settings);
      }
      catch (Exception $e) {
        $error = t('Unable to connect to the credit card processor');
        drupal_set_message($error, 'error');
        return array('success' => FALSE, 'message' => $error);
      }
    }
  }

  // If we are charging a stored credit card.
  if (variable_get('uc_element_allow_stored_cards', FALSE) && $data['charge_stored_card']) {
    // Generate the charge data.
    $soap_charge_request = _uc_element_generate_pass_request($order, $amount, _uc_element_token_get($order->uid));
  }
  // If we are charging a new credit card.
  else {
    // Performing Address Verification on new cards if it is set by the client.
    // We only perform AVS requests on valid countries - USA/Canada/UK.
    if (variable_get('uc_element_AVS', FALSE) && ($order->billing_country == '840' || $order->billing_country == '124' || $order->billing_country == '826')) {
      // Attempt to send the Address Verification request to Element.
      $resp = _uc_element_avs_call($element_soap_client, $order);
      if (!$resp['success']) {
        return $resp;
      }
      $soap_avs_response = $resp['data'];

      // If we are not ignoring AVS results.
      if (!(variable_get('uc_element_ignore_AVS', FALSE))) {
        // Error check the AVS response.
        $resp = _uc_element_avs_error_check($soap_avs_response);
        if (!$resp['success']) {
          return $resp;
        }
      }
    }
    // Performing CVV check if it is set by the client.
    if (variable_get('uc_element_CVV', FALSE)) {
      // If we have not performed an AVS, we do in order to get CVV response.
      if (empty($soap_avs_response)) {
        $resp = _uc_element_avs_call($element_soap_client, $order);
        if (!$resp['success']) {
          return $resp;
        }
        $resp = _uc_element_cvv_error_check($resp['data']);
      }
      // Pull CVV from existing AVS if possible.
      else {
        $resp = _uc_element_cvv_error_check($soap_avs_response);
      }
      // At this point we have the CVV check either way.
      if (!$resp['success']) {
        return $resp;
      }
    }

    // Generate the charge data.
    $soap_charge_request = _uc_element_generate_request($order, $amount);
  }

  // Authorize and/or charge the card through the Element gateway.
  try {
    // Send a request based on what kind of transaction we are performing.
    switch ($data['txn_type']) {
      // Authorization of the credit card only.
      case UC_CREDIT_AUTH_ONLY:
        $charge_type = t('Authorization only');
        $soap_charge_response = $element_soap_client->CreditCardAuthorization($soap_charge_request);
        break;

      // Authorization and capture of funds from the credit card.
      case UC_CREDIT_AUTH_CAPTURE:
        $charge_type = t('Authorization and capture');
        $soap_charge_response = $element_soap_client->CreditCardSale($soap_charge_request);
        break;

    }
  }
  catch (Exception $e) {
    $error = t('Unable to call the charge function');
    drupal_set_message($error, 'error');
    return array('success' => FALSE, 'message' => $error);
  }

  /*
   * TODO: this should probably process as a credit card reversal.
   * Fail if response codes 1001 or 1002 are received.
   */

  // Handle the card authorization and/or charge response from Element.
  // A response of '0' indicates a successful transaction has occurred.
  $charge_transaction_response_code = $soap_charge_response->response->ExpressResponseCode;
  // Transaction failed for some reason.
  if ($charge_transaction_response_code != '0') {
    $error = _uc_element_response($charge_transaction_response_code) . ': ' . $soap_charge_response->response->ExpressResponseMessage;
    drupal_set_message($error, 'error');
    // Send mail if this is a bad error.
    $uc_element_email = variable_get('uc_element_email', '');
    if (!empty($uc_element_email) && $charge_transaction_response_code == '101' && $error != 'Invalid data sent to Element: INVALID CARD INFO') {
      $from = variable_get('site_mail', '');
      if (!empty($from)) {
        $message = array(
          'id' => 'uc_element_invalid_data',
          'to' => $uc_element_email,
          'subject' => t('Element Error: Invalid Data'),
          'body' => t('Amount: "@amount". Error: @error', array('@amount' => $amount, '@error' => $error)),
          'headers' => array(
            'From' => $from,
            'Sender' => $from,
            'Return-Path' => $from,
          ),
          'key' => 'invalid_data',
          'module' => 'uc_element',
        );
        $system = drupal_mail_system('uc_element', 'invalid_data');
        $message = $system->format($message);
        $system->mail($message);
      }
    }
    return array('success' => FALSE, 'message' => $error);
  }
  else {
    $transaction_id = $soap_charge_response->response->Transaction->TransactionID;
    $approval_number = $soap_charge_response->response->Transaction->ApprovalNumber;
    $token = _uc_element_token_get($order->uid);

    // Successful transaction has occurred - messages are being returned.
    $message = t('Type: @type', array('@type' => $charge_type)) . '<br/>' . t('Token: @token', array('@token' => $token)) . '<br/>' . t('Transaction ID: @id', array('@id' => $transaction_id)) . '<br/>' . t('Approval Number: @approve', array('@approve' => $approval_number));

    $send_avs_response = '';
    if (isset($soap_avs_response->response->Card->AVSResponseCode)) {
      $send_avs_response = $soap_avs_response->response->Card->AVSResponseCode;
    }
    $receipt_data = array(
      'module' => 'uc_element',
      'charge_type' => $charge_type,
      'transaction_id' => $transaction_id,
      'approval_number' => $approval_number,
      'token' => $token,
      'avs_response' => $send_avs_response,
    );
    if ($data['charge_stored_card']) {
      $receipt_data['last_4'] = _uc_element_last4_get($order->uid);
    }
    // Log data.
    db_insert('uc_payment_receipts')
      ->fields(array(
        'order_id' => $order->order_id,
        'method' => t('Credit card'),
        'amount' => $amount,
        'uid' => $order->uid,
        'data' => serialize($receipt_data),
        'comment' => $message,
        'received' => REQUEST_TIME,
      ))
      ->execute();
    db_update('uc_orders')
      ->fields(array(
        'order_status' => 'payment_received',
      ))
      ->condition('order_id', $order->order_id)
      ->execute();

    // Create a stored Payment account if the customer has chosen to store one.
    // Deal with storing the credit card if the customer is using a credit card.
    if (variable_get('uc_element_allow_stored_cards', FALSE) && (!$data['charge_stored_card'] && $order->payment_details['cc_store'] == 1)) {
      _uc_element_create_pass($element_pass_soap_client, $order);
    }

    $send_avs_response = '';
    if (isset($send_avs_response->response->Card->AVSResponseCode)) {
      $send_avs_response = $soap_avs_response->response->Card->AVSResponseCode;
    }
    // Return successful order message.
    return array(
      'success' => TRUE,
      'comment' => $message,
      'message' => $message,
      'data' => array(
        'module' => 'uc_element',
        'charge_type' => $charge_type,
        'transaction_id' => $transaction_id,
        'approval_number' => $approval_number,
        'token' => $token,
        'avs_response' => $send_avs_response,
      ),
      'uid' => $user->uid,
    );
  }
}

/**
 * Helper function for creating and storing an Element PASS account.
 *
 * @param object $client
 *   SoapClient object used to call functions.
 * @param object $order
 *   Array containing order information.
 */
function _uc_element_create_pass($client, $order) {
  $token = _uc_element_token_get($order->uid);

  // If this customer already has a token.
  if (!empty($token)) {
    // Delete old account from Element.
    $client->PaymentAccountDelete(_uc_element_delete_pass_account($token));
    // Delete token from table.
    _uc_element_token_delete($order->uid);
  }

  // Create the PASS account.
  try {
    $soap_account_creation_request = _uc_element_generate_pass_account($order);
    $soap_account_creation_response = $client->PaymentAccountCreate($soap_account_creation_request);
  }
  catch (Exception $e) {
    drupal_set_message(t('Order successfully placed. However, we were unable to store credit card details for future use.'), 'status');
  }
  $account_creation_response_code = $soap_account_creation_response->response->ExpressResponseCode;
  if ($account_creation_response_code == '0') {
    // Store the token in the database.
    $account_id = drupal_strtolower($soap_account_creation_response->response->PaymentAccount->PaymentAccountID);
    $last_four = drupal_substr($order->payment_details['cc_number'], drupal_strlen($order->payment_details['cc_number']) - 4, 4);
    _uc_element_token_set($order->uid, $account_id, $last_four, $order->payment_details['cc_exp_year'], $order->payment_details['cc_exp_month']);
  }
  else {
    drupal_set_message(t('Order successfully placed. However, we were unable to store credit card details for future use.'), 'status');
  }
}

/**
 * Helper function for deleting an Element token.
 *
 * @param int $uid
 *   User ID of the user whose card we are deleting..
 */
function _uc_element_token_delete($uid) {
  db_delete('uc_element_tokens')
    ->condition('uid', $uid)
    ->execute();
}

/**
 * Helper function for getting a user's Element stored token.
 *
 * @param int $uid
 *   User ID of the user whose card we are requesting.
 *
 * @return string
 *   The Element token representing the stored card.
 */
function _uc_element_token_get($uid) {
  $card = _uc_element_card_get($uid);
  if (isset($card->token)) {
    return $card->token;
  }
  else {
    return '';
  }
}

/**
 * Helper function for getting the last 4 digits of a customer's stored card.
 *
 * @param int $uid
 *   User ID of the user whose card we are requesting.
 *
 * @return string
 *   The last four digits of a stored card.
 */
function _uc_element_last4_get($uid) {
  $card = _uc_element_card_get($uid);
  if (isset($card->last_4)) {
    return $card->last_4;
  }
  else {
    return '';
  }
}

/**
 * Helper function for getting the stored card details for a user's stored card.
 *
 * @param int $uid
 *   User ID of the user whose card we are requesting.
 *
 * @return object
 *   An object containing information on a stored card.
 */
function _uc_element_card_get($uid) {
  return db_query("
      SELECT
	    token,
	    last_4,
	    exp_month,
	    exp_year,
	    added
      FROM {uc_element_tokens}
	  WHERE
	    uid = :uid
	  ",
      array(
        ':uid' => $uid,
      )
    )->fetchObject();
}

/**
 * Helper function for storing an Element token.
 *
 * @param int $uid
 *   User ID of the user storing the card.
 * @param string $token
 *   The Element token for this stored card.
 * @param string $lastfour
 *   Last four digits of the card.
 * @param string $exp_year
 *   Expiration year of the card.
 * @param string $exp_month
 *   Expiration month of the card.
 */
function _uc_element_token_set($uid, $token, $lastfour, $exp_year, $exp_month) {
  db_insert('uc_element_tokens')
    ->fields(array(
      'uid' => $uid,
      'token' => $token,
      'last_4' => $lastfour,
      'exp_year' => $exp_year,
      'exp_month' => $exp_month,
      'added' => date('m.d.Y'),
    ))
    ->execute();
}

/**
 * Helper function for generating an Element AVS call.
 *
 * @param object $client
 *   SoapClient object used to call functions.
 * @param object $order
 *   Array containing order information.
 *
 * @return array
 *   An array containing information on the success or failure of the code.
 */
function _uc_element_avs_call($client, $order) {
  try {
    $avs_request = _uc_element_generate_request($order, '0.00', 'AVS');
    $soap_avs_response = $client->CreditCardAVSOnly($avs_request);
    return array('success' => TRUE, 'data' => $soap_avs_response);
  }
  catch (Exception $e) {
    $error = t('Unable to call the AVS function');
    drupal_set_message($error, 'error');
    return array('success' => FALSE, 'message' => $error);
  }
}

/**
 * Helper function for error checking the results of an Element AVS call.
 *
 * @param string $soap_avs_response
 *   The AVS response code being evaluated.
 *
 * @return array
 *   An array containing information on the success or failure of the code.
 */
function _uc_element_avs_error_check($soap_avs_response) {
  // Handle the Address Verification response from Element.
  // A response of '0' indicates a successful transaction has occurred.
  $avs_transaction_response_code = $soap_avs_response->response->ExpressResponseCode;
  if ($avs_transaction_response_code == '0') {
    $avs_card_response_code = $soap_avs_response->response->Card->AVSResponseCode;
    // Check the card type.
    $avs_card_type = $soap_avs_response->response->Card->CardLogo;
    // Check response code for Address Verification.
    $avs_discover_card_failure = $avs_card_response_code == 'A' && $avs_card_type != 'Discover';
    $avs_failure_response_codes = array(
      'A',
      'B',
      'C',
      'L',
      'N',
      'O',
      'P',
      'R',
      'T',
      'W',
      'Z',
    );
    if ($avs_discover_card_failure || in_array($avs_card_response_code, $avs_failure_response_codes)) {
      $error = _uc_element_avs($avs_card_response_code);
      drupal_set_message($error, 'error');
      return array('success' => FALSE, 'message' => $error);
    }
  }
  else {
    $error = _uc_element_response($avs_transaction_response_code) . ': ' . $soap_avs_response->response->ExpressResponseMessage;
    drupal_set_message($error, 'error');
    return array('success' => FALSE, 'message' => $error);
  }
  return array('success' => TRUE);
}

/**
 * Helper function for error checking the validity of a card's CVV.
 */
function _uc_element_cvv_error_check($cvv_response) {
  // Handle the Address Verification response from Element.
  // A response of '0' indicates a successful transaction has occurred.
  if (isset($cvv_response->response->Card->CVVResponseCode) && $cvv_response->response->Card->CVVResponseCode == 'N') {
    $error = t('Incorrect CVV or Expiration Date provided for card.');
    drupal_set_message($error, 'error');
    return array('success' => FALSE, 'message' => $error);
  }
  return array('success' => TRUE);
}

/**
 * Generates properly formatted SOAP PASS account deletion requests.
 *
 * @param string $token
 *   A string holding the token value which we are going to delete.
 *
 * @return array
 *   An array containing a properly formatted SOAP account deletion request.
 *
 * @see http://www.elementps.com/software-providers/
 */
function _uc_element_delete_pass_account($token) {

  $soap_request = array(
    'credentials' => array(
      'AccountID' => variable_get('uc_element_account_id', ''),
      'AccountToken' => variable_get('uc_element_account_token', ''),
      'AcceptorID' => variable_get('uc_element_acceptor_id', ''),
    ),
    'application' => array(
      'ApplicationID' => variable_get('uc_element_application_id', ''),
      'ApplicationName' => 'Ubercart',
      'ApplicationVersion' => '1.1.1',
    ),
    'paymentAccount' => array(
      'PaymentAccountID' => $token,
      'PaymentAccountType' => 'CreditCard',
      'PASSUpdaterBatchStatus' => 'Null',
      'PASSUpdaterOption' => 'AutoUpdateEnabled',
    ),
  );

  return $soap_request;
}

/**
 * Generates properly formatted SOAP PASS account query requests.
 *
 * @param string $token
 *   A string holding the token value which we are going to delete.
 *
 * @return array
 *   An array containing a properly formatted SOAP account query request.
 *
 * @see http://www.elementps.com/software-providers/
 */
function _uc_element_query_pass_account($token) {
  $soap_request = array(
    'credentials' => array(
      'AccountID' => variable_get('uc_element_account_id', ''),
      'AccountToken' => variable_get('uc_element_account_token', ''),
      'AcceptorID' => variable_get('uc_element_acceptor_id', ''),
    ),
    'application' => array(
      'ApplicationID' => variable_get('uc_element_application_id', ''),
      'ApplicationName' => 'Ubercart',
      'ApplicationVersion' => '1.1.1',
    ),
    'paymentAccountParameters' => array(
      'PaymentAccountID' => $token,
      'PaymentAccountType' => 'CreditCard',
      'PASSUpdaterStatus' => 'Null',
      'PASSUpdaterBatchStatus' => 'Null',
    ),
  );

  return $soap_request;
}

/**
 * Generates properly formatted SOAP PASS account creation requests.
 *
 * @param object $order
 *   An array holding order details for the request.
 *
 * @return array
 *   An array containing a properly formatted SOAP account creation request.
 *
 * @see http://www.elementps.com/software-providers/
 */
function _uc_element_generate_pass_account($order) {

  $soap_request = array(
    'credentials' => array(
      'AccountID' => variable_get('uc_element_account_id', ''),
      'AccountToken' => variable_get('uc_element_account_token', ''),
      'AcceptorID' => variable_get('uc_element_acceptor_id', ''),
    ),
    'application' => array(
      'ApplicationID' => variable_get('uc_element_application_id', ''),
      'ApplicationName' => 'Ubercart',
      'ApplicationVersion' => '1.1.1',
    ),
    'card' => array(
      'CardNumber' => $order->payment_details['cc_number'],
      'ExpirationMonth' => str_pad($order->payment_details['cc_exp_month'], 2, '0', STR_PAD_LEFT),
      'ExpirationYear' => drupal_substr($order->payment_details['cc_exp_year'], drupal_strlen($order->payment_details['cc_exp_year']) - 2, 2),
      'CardholderName' => $order->payment_details['cc_owner'],
      'CVV' => $order->payment_details['cc_cvv'],
      'EncryptedFormat' => 'Default',
    ),
    'address' => array(
      'BillingName' => drupal_substr($order->billing_first_name, 0, 50) . ' ' . drupal_substr($order->billing_last_name, 0, 50),
      'BillingAddress1' => drupal_substr($order->billing_street1, 0, 60),
      'BillingAddress2' => drupal_substr($order->billing_street2, 0, 60),
      'BillingCity' => drupal_substr($order->billing_city, 0, 40),
      'BillingState' => drupal_substr(uc_get_zone_code($order->billing_zone), 0, 40),
      'BillingZipcode' => drupal_substr($order->billing_postal_code, 0, 20),
      'BillingEmail' => drupal_substr($order->primary_email, 0, 255),
      'BillingPhone' => drupal_substr($order->billing_phone, 0, 20),
    ),
    'paymentAccount' => array(
      'PaymentAccountType' => 'CreditCard',
      'PaymentAccountReferenceNumber' => $order->uid,
      'PASSUpdaterBatchStatus' => 'Null',
      'PASSUpdaterOption' => 'Null',
    ),
    'demandDepositAccount' => array(
      'PASSUpdaterBatchStatus' => 'Null',
      'PASSUpdaterOption' => 'Null',
      'DDAAccountType' => 'Checking',
      'CheckType' => 'Personal',
    ),
  );

  return $soap_request;
}

/**
 * Generates properly formatted SOAP PASS requests.
 *
 * @param object $order
 *   An array holding order details for the request.
 * @param string $amount
 *   The amount to charge the credit card.
 * @param string $token
 *   The token for the stored account being charged.
 *
 * @return array
 *   An array containing a properly formatted SOAP PASS charge or AVS request.
 *
 * @see http://www.elementps.com/software-providers/
 */
function _uc_element_generate_pass_request($order, $amount, $token) {

  // Generate the request data to be sent to Element.
  $soap_request = array(
    'credentials' => array(
      'AccountID' => variable_get('uc_element_account_id', ''),
      'AccountToken' => variable_get('uc_element_account_token', ''),
      'AcceptorID' => variable_get('uc_element_acceptor_id', ''),
    ),
    'application' => array(
      'ApplicationID' => variable_get('uc_element_application_id', ''),
      'ApplicationName' => 'Ubercart',
      'ApplicationVersion' => '1.1.1',
    ),
    'terminal' => array(
      'TerminalID' => variable_get('uc_store_name', ''),
      'TerminalType' => 'ECommerce',
      'CardPresentCode' => 'NotPresent',
      'CardholderPresentCode' => 'ECommerce',
      'CardInputCode' => 'ManualKeyed',
      'CVVPresenceCode' => 'NotProvided',
      'TerminalCapabilityCode' => 'KeyEntered',
      'TerminalEnvironmentCode' => 'ECommerce',
      'MotoECICode' => 'NonAuthenticatedSecureECommerceTransaction',
      'CVVResponseType' => 'Regular',
      'ConsentCode' => 'Internet',
      'TerminalEncryptionFormat' => 'Default',
    ),
    'card' => array(
      'EncryptedFormat' => 'Default',
    ),
    'transaction' => array(
      'TransactionAmount' => $amount,
      'ReferenceNumber' => $order->order_id,
      'TicketNumber' => $order->order_id,
      'TotalAuthorizedAmount' => $amount,
      'ReversalType' => 'Full',
      'MarketCode' => 'ECommerce',
      'BillPaymentFlag' => 'False',
      'DuplicateCheckDisableFlag' => 'False',
      'DuplicateOverrideFlag' => 'False',
      'RecurringFlag' => 'False',
      'PartialApprovedFlag' => 'False',
      'CVVRequired' => 'False',
      'EMVEncryptionFormat' => 'Default',
      'ReversalReason' => 'Unknown',
    ),
    'address' => array(
      'BillingName' => drupal_substr($order->billing_company, 0, 50),
      'BillingAddress1' => drupal_substr($order->billing_street1, 0, 60),
      'BillingAddress2' => drupal_substr($order->billing_street2, 0, 60),
      'BillingCity' => drupal_substr($order->billing_city, 0, 40),
      'BillingState' => drupal_substr(uc_get_zone_code($order->billing_zone), 0, 40),
      'BillingZipcode' => drupal_substr($order->billing_postal_code, 0, 20),
      'BillingEmail' => drupal_substr($order->primary_email, 0, 255),
      'BillingPhone' => drupal_substr($order->billing_phone, 0, 20),
    ),
    'extendedParameters' => array(
      'ExtendedParameters' => array(
        'Key' => 'PaymentAccount',
        'Value' => new SoapVar(array(
          'PaymentAccountID' => $token,
          'PaymentAccountType' => 'CreditCard',
          'PASSUpdaterBatchStatus' => 'Null',
          'PASSUpdaterOption' => 'Null',
        ), SOAP_ENC_OBJECT, "PaymentAccount", "https://transaction.elementexpress.com"),
      ),
    ),
  );

  return $soap_request;
}

/**
 * Generates properly formatted SOAP requests.
 *
 * @param object $order
 *   An array holding order details for the request.
 * @param string $amount
 *   The amount to charge the credit card.
 * @param string $type
 *   The type of request being generated.
 *
 * @return array
 *   An array containing a properly formatted SOAP charge or AVS request.
 *
 * @see http://www.elementps.com/software-providers/
 */
function _uc_element_generate_request($order, $amount, $type = 'charge') {
  // For charge requests we set the amount equal to the value from the order.
  if ($type != 'AVS') {
    $amount = round($amount, 2);
    $amount = number_format($amount, 2, '.', '');
  }

  // Generate the request data to be sent to Element.
  $soap_request = array(
    'credentials' => array(
      'AccountID' => variable_get('uc_element_account_id', ''),
      'AccountToken' => variable_get('uc_element_account_token', ''),
      'AcceptorID' => variable_get('uc_element_acceptor_id', ''),
    ),
    'application' => array(
      'ApplicationID' => variable_get('uc_element_application_id', ''),
      'ApplicationName' => 'Ubercart',
      'ApplicationVersion' => '1.1.1',
    ),
    'terminal' => array(
      'TerminalID' => variable_get('uc_store_name', ''),
      'TerminalType' => 'ECommerce',
      'CardPresentCode' => 'NotPresent',
      'CardholderPresentCode' => 'ECommerce',
      'CardInputCode' => 'ManualKeyed',
      'CVVPresenceCode' => 'Provided',
      'TerminalCapabilityCode' => 'KeyEntered',
      'TerminalEnvironmentCode' => 'ECommerce',
      'MotoECICode' => 'NonAuthenticatedSecureECommerceTransaction',
      'CVVResponseType' => 'Regular',
      'ConsentCode' => 'Internet',
      'TerminalEncryptionFormat' => 'Default',
    ),
    'card' => array(
      'CardNumber' => $order->payment_details['cc_number'],
      'ExpirationMonth' => str_pad($order->payment_details['cc_exp_month'], 2, '0', STR_PAD_LEFT),
      'ExpirationYear' => drupal_substr($order->payment_details['cc_exp_year'], drupal_strlen($order->payment_details['cc_exp_year']) - 2, 2),
      'CardholderName' => $order->payment_details['cc_owner'],
      'CVV' => $order->payment_details['cc_cvv'],
      'EncryptedFormat' => 'Default',
    ),
    'transaction' => array(
      'TransactionAmount' => $amount,
      'ReferenceNumber' => $order->order_id,
      'TotalAuthorizedAmount' => $amount,
      'ReversalType' => 'Full',
      'MarketCode' => 'ECommerce',
      'BillPaymentFlag' => 'False',
      'DuplicateCheckDisableFlag' => 'False',
      'DuplicateOverrideFlag' => 'False',
      'RecurringFlag' => 'False',
      'PartialApprovedFlag' => 'False',
      'CVVRequired' => 'True',
      'EMVEncryptionFormat' => 'Default',
      'ReversalReason' => 'Unknown',
    ),
    'address' => array(
      'BillingName' => drupal_substr($order->billing_company, 0, 50),
      'BillingAddress1' => drupal_substr($order->billing_street1, 0, 60),
      'BillingAddress2' => (string) drupal_substr($order->billing_street2, 0, 60),
      'BillingCity' => drupal_substr($order->billing_city, 0, 40),
      'BillingState' => drupal_substr(uc_get_zone_code($order->billing_zone), 0, 40),
      'BillingZipcode' => drupal_substr($order->billing_postal_code, 0, 20),
      'BillingEmail' => (string) drupal_substr($order->primary_email, 0, 255),
      'BillingPhone' => (string) drupal_substr($order->billing_phone, 0, 20),
    ),
    'extendedParameters' => array(),
  );
  return $soap_request;
}

/**
 * Generates responses based on Element Express transaction response codes.
 *
 * @param string $code
 *   The Element Express transaction response code.
 *
 * @return string
 *   The appropriate response message for the transaction response code.
 */
function _uc_element_response($code) {
  switch ($code) {
    case '0':
      // This is an order approval.
      $response = t('Approved/Success');
      break;

    case '5':
      $response = t('Partial Approval');
      break;

    case '20':
      $response = t('Card Issuer has declined the transaction');
      break;

    case '21':
      $response = t('Expired Card');
      break;

    case '22':
      // This is an order approval.
      $response = t('Duplicate Approved');
      break;

    case '23':
      $response = t('Duplicate');
      break;

    case '24':
      $response = t('Card issuer has declined the transaction and wants to recover the card');
      break;

    case '25':
      $response = t('Referral/Call Issuer');
      break;

    case '90':
      $response = t('Not defined');
      break;

    case '101':
      $response = t('Invalid data sent to Element');
      break;

    case '102':
      $response = t('Invalid Element account');
      break;

    case '103':
      $response = t('Invalid Request');
      break;

    case '104':
      $response = t('Authorization failed');
      break;

    case '105':
      $response = t('Not allowed');
      break;

    case '120':
      $response = t('Out of balance');
      break;

    case '1001':
      $response = t('Communication error');
      break;

    case '1002':
      $response = t('Host error');
      break;

    case '1009':
      $response = t('Error');
      break;

    default:
      $response = t('Unknown Error');
      break;

  }
  return $response;
}

/**
 * Generates responses based on Element Express CVV response code.
 *
 * @param string $code
 *   The Element Express CVV match response code.
 *
 * @return string
 *   The appropriate response message for the CVV match response code.
 */
function _uc_element_cvv($code) {
  switch ($code) {
    case 'M':
      $response_code_message = t('Match');
      break;

    case 'N':
      $response_code_message = t('No Match');
      break;

    case 'P':
      $response_code_message = t('Not Processed');
      break;

    case 'S':
      $response_code_message = t('Should have been present');
      break;

    case 'U':
      $response_code_message = t('Issuer unable to process request');
      break;

  }
  return $code . ' - ' . $response_code_message;
}

/**
 * Generates responses based on Element Express AVS code.
 *
 * @param string $code
 *   The Element Express Address Verification Services response code.
 *
 * @return string
 *   The appropriate response message.
 */
function _uc_element_avs($code) {

  switch ($code) {
    case 'A':
      // This code results in a fail state.
      $response_code_message = t('Street address matches, but postal code does not match.');
      break;

    case 'B':
      // This code results in a fail state.
      $response_code_message = t('Street address matches, but postal code not verified.');
      break;

    case 'C':
      // This code results in a fail state.
      $response_code_message = t('Street address and postal code do not match.');
      break;

    case 'D':
      $response_code_message = t('Street address and postal code match.');
      break;

    case 'E':
      $response_code_message = t('AVS data is invalid or AVS is not allowed for this card type.');
      break;

    case 'F':
      $response_code_message = t('International Transaction: street addresses and postal codes match');
      break;

    case 'G':
      $response_code_message = t('Non-U.S. issuing bank does not support AVS.');
      break;

    case 'H':
      $response_code_message = t('Card member name does not match. Street address and postal code match.');
      break;

    case 'I':
      $response_code_message = t('International Transaction: address information not verified on international transactions');
      break;

    case 'J':
      $response_code_message = t('American Express: AVS confirmed through fraud protection program');
      break;

    case 'K':
      $response_code_message = t('American Express: AVS confirmed through standard method');
      break;

    case 'L':
      // This code results in a fail state.
      $response_code_message = t('Card member name and billing postal code match, but billing address does not match.');
      break;

    case 'M':
      $response_code_message = t('Street address and postal code match.');
      break;

    case 'N':
      // This code results in a fail state.
      $response_code_message = t('Street address and postal code do not match.');
      break;

    case 'O':
      // This code results in a fail state.
      $response_code_message = t('Card member name and billing address match, but billing postal code does not match.');
      break;

    case 'P':
      // This code results in a fail state.
      $response_code_message = t('Postal code matches, but street address not verified.');
      break;

    case 'Q':
      $response_code_message = t('Card member name, billing address, and postal code match.');
      break;

    case 'R':
      // This code results in a fail state.
      $response_code_message = t('Retry: System unavailable');
      break;

    case 'S':
      $response_code_message = t('Card issuer does not support address verification');
      break;

    case 'T':
      // This code results in a fail state.
      $response_code_message = t('Nine-digit zip matches, address does not match');
      break;

    case 'U':
      $response_code_message = t('Unavailable: address information not verified for domestic transaction');
      break;

    case 'V':
      $response_code_message = t('Card member name, billing address, and billing postal code match.');
      break;

    case 'W':
      // This code results in a fail state.
      $response_code_message = t('Street address does not match, but 9-digit postal code matches.');
      break;

    case 'X':
      $response_code_message = t('Street address and 9-digit postal code match.');
      break;

    case 'Y':
      $response_code_message = t('Street address and 5-digit postal code match.');
      break;

    case 'Z':
      // This code results in a fail state.
      $response_code_message = t('Street address does not match, but 5-digit postal code matches.');
      break;

  }
  return t('@code - Billing Address Error: @message', array('@code' => $code, '@message' => $response_code_message));
}
