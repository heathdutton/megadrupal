<?php

/**
 * @file
 * Integrates Cloudwords with the Contnent translation module.
 */

/**
 * Implements hook_menu_alter().
 *
 * Take control of node/%node/translate.
 */
function cloudwords_translation_menu_alter(&$items) {
  $items['node/%node/translate']['page callback'] = 'cloudwords_translation_node_overview_page';
  $items['node/%node/translate']['file'] = 'cloudwords_translation.pages.inc';
  $items['node/%node/translate']['file path'] = drupal_get_path('module', 'cloudwords_translation');
  $items['node/%node/translate']['module'] = 'cloudwords_translation';
}

/**
 * Implements hook_module_implements_alter().
 *
 * Move our hook_menu_alter() to the end.
 */
function cloudwords_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'menu_alter') {
    $group = $implementations['cloudwords_translation'];
    unset($implementations['cloudwords_translation']);
    $implementations['cloudwords_translation'] = $group;
  }
}

/**
 * Implements hook_cloudwords_translatable_info().
 */
function cloudwords_translation_cloudwords_translatable_info() {
  $supported_types = array_filter(variable_get('entity_translation_entity_types', array()));

  //Remove entities that are handled by other cloudwords submodules
  $remove_entities = array('node','taxonomy_term','user','comment');
  foreach($remove_entities as $entity_name){
    if(isset($supported_types[$entity_name])){ 
      unset($supported_types[$entity_name]);
    }
  }
  
  $entity_controllers = array();
  $entity_controllers['node_content'] = array(
      'controller class' => 'CloudwordsNodeSourceController',
  );
  foreach($supported_types as $supported_type){
    $entity_controllers[$supported_type] = array(
        'controller class' => 'CloudwordsEntitySourceController',
    );    
  }
  
  return $entity_controllers;
}

/**
 * Populates a field on an object with the provided field values.
 *
 * @param stdClass $entity
 *   The object to be populated.
 * @param array $data
 *   An array of values.
 * @param string $language
 *   The field language.
 */
function cloudwords_field_populate_entity($entity, array $data, $language, $hostLanguage) {

  $attachableEntityTypes = array('field_collection');

  //load source entity to map field meta data
  if(isset($entity->tnid)){
    $source = entity_load_single('node', $entity->tnid);
  }else{
    $source = $entity;
  }

  foreach (element_children($data) as $field_name) {
    if ($info = field_info_field($field_name)) {
      foreach (element_children($data[$field_name]) as $delta) {
        $langcode = $info['translatable'] ? $language : LANGUAGE_NONE;

        // Make sure the array_merge() gets an array as a first parameter.
        if (!isset($entity->{$field_name}[$langcode][$delta])) {
          $entity->{$field_name}[$langcode][$delta] = array();
        }
        
        //check if field collection
        if(in_array($info['type'],$attachableEntityTypes)){
          $aData = (isset($data[$field_name][$delta]['value'])) ? $data[$field_name][$delta]['value'] : array();
          reset($aData);
          $entity_id = key($aData);
           if(($info['type'] == 'field_collection') && ($aEntity = entity_load_single('field_collection_item', $entity_id))){
             cloudwords_field_populate_entity($aEntity, $aData[$entity_id], $language, $hostLanguage);
             $aEntity->save();
           }
           //get columns from host entity
           if(isset($entity->{$field_name}[$hostLanguage])){
             $columns = $entity->{$field_name}[$hostLanguage][$delta];
           }else{
             $columns = $entity->{$field_name}[LANGUAGE_NONE][$delta];
           }
           $entity->{$field_name}[$langcode][$delta] = $columns;
        }
        
        //non entity mapping
        if(!in_array($info['type'],$attachableEntityTypes)){
          
          $columns = array();
          foreach (element_children($data[$field_name][$delta]) as $column) {
            if (isset($data[$field_name][$delta][$column]['#translation']['#text'])) {
              $columns[$column] = $data[$field_name][$delta][$column]['#translation']['#text'];
            }
            // For elements which are not translatable, keep using the original
            // value.
            elseif (isset($data[$field_name][$delta][$column]['#translate']) && $data[$field_name][$delta][$column]['#translate'] == FALSE) {
              $columns[$column] = $data[$field_name][$delta][$column]['#text'];
            }
          }

          $entity->{$field_name}[$langcode][$delta] = array_merge($entity->{$field_name}[$langcode][$delta], $columns);
          
          //map field metadata: format
          if(array_key_exists('format',$source->{$field_name}[$source->language][$delta])){
            $entity->{$field_name}[$langcode][$delta]['format'] = $source->{$field_name}[$source->language][$delta]['format'];
          }
        }

      }
    }
  }
}

/**
 * Implements hook_cloudwords_source_translation_structure().
 *
 * This hook is implemented on behalf of the core text module.
 */
function text_cloudwords_source_translation_structure($field_name, $entity_type, $entity, $field_instance) {
  $field_lang = field_language($entity_type, $entity, $field_name);
  $structure = array();
  if (!empty($entity->{$field_name}[$field_lang])) {
    $field_info = field_info_field($field_name);
    $structure['#label'] = check_plain($field_instance['label']);
    foreach ($entity->{$field_name}[$field_lang] as $delta => $value) {
      $structure[$delta]['#label'] = t('Delta #@delta', array('@delta' => $delta));
      $structure[$delta]['value'] = array(
        '#label' => $structure['#label'],
        '#text' => $value['value'],
        '#translate' => TRUE,
      );
      // Add format.
      $structure[$delta]['format'] = array(
        '#label' => '',
        '#text' => $value['format'],
        '#translate' => FALSE,
      );
      if ($field_info['type'] == 'text_with_summary' && !empty($value['summary'])) {
        $structure[$delta]['summary'] = array(
          '#label' => t('Summary'),
          '#text' => $value['summary'],
          '#translate' => TRUE,
        );
      }
    }
  }

  return $structure;
}

/**
 * Implements hook_cloudwords_source_translation_structure().
 *
 * Translate the title field of a link
 */
function link_cloudwords_source_translation_structure($field_name, $entity_type, $entity, $field_instance) {
  $field_lang = field_language($entity_type, $entity, $field_name);
  $structure = array();
  if (!empty($entity->{$field_name}[$field_lang])) {
    $structure['#label'] = check_plain($field_instance['label']);
    foreach ($entity->{$field_name}[$field_lang] as $delta => $value) {
      $structure[$delta]['#label'] = t('Delta #@delta', array('@delta' => $delta));
      $structure[$delta]['title'] = array(
        '#label' => 'Title',
        '#text' => $value['title'],
        '#translate' => TRUE,
      );
    }
  }

  return $structure;
}

/**
 * Implements hook_cloudwords_source_translation_structure().
 *
 * This hook is implemented on behalf of the field_collection module.
 */
function field_collection_cloudwords_source_translation_structure($field_name, $entity_type, $entity, $field_instance) {
  $field_lang = field_language($entity_type, $entity, $field_name);
  $structure = array();
  if (!empty($entity->{$field_name}[$field_lang])) {
    $field_info = field_info_field($field_name);
    $structure['#label'] = check_plain($field_instance['label']);
    foreach ($entity->{$field_name}[$field_lang] as $delta => $value) {
      $fc = entity_load('field_collection_item',array($value['value']));
      $fc = reset($fc);
      $fc_structure = cloudwords_field_get_source_data('field_collection_item', $fc);
      $structure[$delta]['#label'] = t('Delta #@delta', array('@delta' => $delta));
      $structure[$delta]['value'] = array(
        '#label' => $structure['#label'],
        $fc->item_id => $fc_structure,
        '#translate' => TRUE,
      );
    }
  }

  return $structure;
}

/**
 * Helper function for retrieving all translatable field values from an entity.
 *
 * @param string $entity_type
 *   The entity type.
 * @param object $entity
 *   An entity object.
 *
 * @return array
 *   The structured field data for all translatable fields
 */
function cloudwords_field_get_source_data($entity_type, $entity, $field_translation = FALSE) {
  try {
    list(, , $bundle) = entity_extract_ids($entity_type, $entity);
  }
  catch (Exception $e) {
    watchdog_exception('cloudwords field', $e);
    return array();
  }

  $fields = array();
  foreach (field_info_instances($entity_type, $bundle) as $field_name => $field_instance) {
    $info = field_info_field($field_name);
         
    if ((!$field_translation || $info['translatable']) && $data = module_invoke($info['module'], 'cloudwords_source_translation_structure', $field_name, $entity_type, $entity, $field_instance)) {
      $fields[$field_name] = $data;
    }
  }

  return $fields;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function cloudwords_translation_form_node_form_alter(&$form, &$form_state) {
  global $user;
  $node = $form['#node'];

  // workaround/fix for translation.module line 164, where the groups are not taken into consideration
  $languages = language_list('enabled');
  $disabled_languages = isset($languages[0]) ? $languages[0] : FALSE;
  $translator_widget = $disabled_languages && user_access('translate content');
  $groups = array(t('Disabled'), t('Enabled'));
  if (!empty($node->nid) && !empty($node->tnid)) {
    // Disable languages for existing translations, so it is not possible to switch this
    // node to some language which is already in the translation set. Also remove the
    // language neutral option.
    if ($translator_widget) {
      foreach ($groups as $group) {
        unset($form['language']['#options'][$group][LANGUAGE_NONE]);
      }
    }
    else {
      unset($form['language']['#options'][LANGUAGE_NONE]);
    }
  }
  // end of fix


  // prevent primary node from switching to neutral if active translatables exist
  if (!empty($node->nid)) {
    $translatables = cloudwords_get_translatables_by_property(array(
      'type' => 'node_content',
      'textgroup' => 'node',
      'objectid' => !empty($node->tnid) ? $node->tnid : $node->nid,
    ), 'language');

    $allow_neutral = TRUE;
    $disabled_langs = array();
    foreach ($translatables as $langcode => $translatable) {
      if ($translatable->status != CLOUDWORDS_QUEUE_NOT_IN_QUEUE || $translatable->uid != 0) {
        $disabled_langs[] = $langcode;
        $allow_neutral = FALSE;
      }
    }

    if (!$allow_neutral) {
      if ($translator_widget) {
        foreach ($groups as $group) {
          unset($form['language']['#options'][$group][LANGUAGE_NONE]);
          foreach ($disabled_langs as $disabled_lang) {
            unset($form['language']['#options'][$group][$disabled_lang]);
          }
        }
      }
      else {
        unset($form['language']['#options'][LANGUAGE_NONE]);
        foreach ($disabled_langs as $disabled_lang) {
          unset($form['language']['#options'][$disabled_lang]);
        }
      }
    }
  }

  $element = array(
    '#type' => 'checkbox',
    '#title' => t('Mark all languages for translation.'),
    '#states' => array(
      'invisible' => array(
        ':input[name="language"]' => array(
          'value' => 'und',
        ),
      ),
    ),
  );

  if (empty($node->nid) && empty($node->translation_source) && cloudwords_translation_supported_type($node->type)) {
    $form['cloudwords_add_to_queue'] = $element;
  }
  elseif (cloudwords_translation_supported_type($node->type)) {
    $form['cloudwords_add_to_queue'] = $element;
  }
}

/**
 * Determines if the node is the primary node in a translation set.
 *
 * @param stdClass $node
 *   A node object.
 *
 * @return bool
 *   TRUE if the node is the primary node, and FALSE if not.
 */
function cloudwords_translation_is_primary_node(stdClass $node) {
  return !$node->tnid || $node->tnid == $node->nid;
}

/**
 * Implements hook_node_insert().
 */
function cloudwords_translation_node_insert($node) {
  if (cloudwords_translation_supported_type($node->type)) {
    
    $queue_status = !empty($node->cloudwords_add_to_queue) ? CLOUDWORDS_QUEUE_QUEUED : CLOUDWORDS_QUEUE_NOT_IN_QUEUE;

    if ($node->language != LANGUAGE_NONE) {
      // We're inserting a new primary node.
      if (empty($node->translation_source)) {
        foreach (cloudwords_language_list() as $langcode => $language) {
          if ($node->language != $langcode) {

            $translatable = cloudwords_translatable_create(array(
              'textgroup' => 'node',
              'type' => 'node_content',
              'objectid' => $node->nid,
              'language' => $langcode,
              'label' => $node->title,
              'status' => $queue_status,
            ));

            $translatable->save();
          }
        }
      }
      else {
        $translatables = cloudwords_get_translatables_by_property(array(
          'textgroup' => 'node',
          'type' => 'node_content',
          'objectid' => $node->tnid,
        ), 'language');

        $translatables[$node->language]->translation_status = CLOUDWORDS_TRANSLATION_STATUS_TRANSLATION_EXISTS;
        foreach ($translatables as $translatable) {
          $translatable->status = $queue_status;
          $translatable->save();
        }
      }
    }
  }
}

/**
 * Implements hook_node_update().
 */
function cloudwords_translation_node_update($node) {
  if (cloudwords_translation_supported_type($node->type)) {

    $queue_status = !empty($node->cloudwords_add_to_queue) ? CLOUDWORDS_QUEUE_QUEUED : CLOUDWORDS_QUEUE_NOT_IN_QUEUE;

    if (cloudwords_translation_is_primary_node($node)) {
      
      $translatables = cloudwords_get_translatables_by_property(array(
        'textgroup' => 'node',
        'type' => 'node_content',
        'objectid' => $node->nid,
      ), 'language');

      // Updating the primary node's language.
      if ($node->language != $node->original->language) {
        if ($node->language == LANGUAGE_NONE) {
          foreach ($translatables as $langcode => $translable) {
            // remove translatables that have not been added to a project yet
            if ($translable->status == 0 && $translable->uid == 0) {
              cloudwords_translatable_delete($translable->ctid);
              unset($translatables[$langcode]);
            }
          }
        }
        elseif ($node->original->language == LANGUAGE_NONE) {
          foreach (array_keys(cloudwords_language_list()) as $langcode) {
            if ($langcode != $node->language && !isset($translatables[$langcode])) {
              $translatables[$langcode] = cloudwords_translatable_create(array(
                'textgroup' => 'node',
                'type' => 'node_content',
                'objectid' => $node->nid,
                'label' => $node->title,
                'language' => $langcode,
              ));
            }
          }
        }
        elseif (isset($translatables[$node->language])) {
          $translatables[$node->language]->language = $node->original->language;
        }
      }
      foreach ($translatables as $translatable) {
        if (!empty($node->translation['retranslate']) && $translatable->translation_status == 1) {
          $translatable->translation_status = 2;
        }
        $translatable->label = $node->title;
        $translatable->status = $queue_status;
        $translatable->save();
      }
    }

    else {
      $primary = node_load($node->tnid);
      $translatables = cloudwords_get_translatables_by_property(array(
        'type' => 'node_content',
        'textgroup' => 'node',
        'objectid' => $node->tnid,
      ), 'language');

      if (!empty($node->translation['status']) && $translatables[$node->language]->translation_status == 1) {
        $translatables[$node->language]->translation_status = 2;
      }
      elseif ($translatables[$node->language]->translation_status == 2) {
        $translatables[$node->language]->translation_status = 1;
      }
      foreach ($translatables as $translatable) {
        $translatable->label = $primary->title;
        $translatable->status = $queue_status;
        $translatable->save();
      }
    }
  }
}

/**
 * Implements hook_node_delete().
 */
function cloudwords_translation_node_delete($node) {
  if (entity_language('node', $node) != LANGUAGE_NONE && cloudwords_translation_supported_type($node->type)) {
    $tnid = FALSE;
    $translations = translation_node_get_translations($node->tnid);

    if (empty($node->tnid)) {
      $tnid = $node->nid;
    }
    elseif (count($translations) === 0) {
      $tnid = $node->tnid;
    }
    if ($tnid) {
      cloudwords_translatable_delete_by_property(array(
        'type' => 'node_content',
        'textgroup' => 'node',
        'objectid' => $tnid,
      ));
    }

    // Deleting the primary translation node. We need switch to a different one.
    if (count($translations) > 1 && $node->tnid == $node->nid) {
      unset($translations[$node->language]);
      $new_primary = reset($translations);

      db_update('cloudwords_translatable')
        ->condition('type', 'node_content')
        ->condition('textgroup', 'node')
        ->condition('objectid', $node->nid)
        ->condition('language', $new_primary->language)
        ->fields(array(
          'language' => $node->language,
          'label' => $new_primary->title,
        ))
        ->execute();

      db_update('cloudwords_translatable')
        ->condition('type', 'node_content')
        ->condition('textgroup', 'node')
        ->condition('objectid', $node->nid)
        ->fields(array(
          'objectid' => $new_primary->nid,
          'label' => $new_primary->title,
        ))
        ->execute();
    }

    if ($node->tnid && $node->tnid != $node->nid) {
      db_update('cloudwords_translatable')
        ->condition('type', 'node_content')
        ->condition('textgroup', 'node')
        ->condition('objectid', $node->tnid)
        ->condition('language', $node->language)
        ->fields(array(
          'translation_status' => 0,
        ))
        ->execute();
    }
  }
}

/**
 * Implements hook_cloudwords_refresh_translatables().
 */
function cloudwords_translation_cloudwords_refresh_translatables(&$context) {

  $langcodes = array_keys(cloudwords_language_list());

  $context['finished'] = 0;
  if (!isset($context['sandbox']['total'])) {
    // Get all primary nodes.
    $context['sandbox']['total'] = db_query("SELECT count(nid) FROM {node} WHERE language IN (:langcodes) AND (tnid = 0 OR tnid = nid)", array(':langcodes' => $langcodes))->fetchField();
    $context['sandbox']['last'] = 0;
    $context['sandbox']['count'] = 0;
  }
  else {
    $found = FALSE;

    if ($context['sandbox']['total']) {

      $batch_size = 200;

      // using where() instead of condition()
      // condition() would take "n.nid" as a string value
      $or = db_or()->condition('n.tnid', 0)->where('n.tnid = n.nid');

      $nids = db_select('node', 'n')
          ->fields('n', array('nid'))
          ->condition('n.language', $langcodes)
          ->condition('n.nid', $context['sandbox']['last'], '>')
          ->condition($or)
          ->range(0, $batch_size)
          ->execute()
          ->fetchCol();

      foreach ($nids as $nid) {
        $langs = cloudwords_language_list();
        $found = TRUE;

        $node = node_load($nid);
        unset($langs[$node->language]);
        $langs = array_keys($langs);

        $translatables = cloudwords_get_translatables_by_property(array(
          'textgroup' => 'node',
          'type' => 'node_content',
          'objectid' => $nid,
            ), 'language');

        $trans_langs = array_keys($translatables);

        $missing = array_diff($langs, $trans_langs);

        if ($missing) {
          foreach ($missing as $langcode) {
            $new = cloudwords_translatable_create(array(
              'objectid' => $node->nid,
              'language' => $langcode,
              'label' => $node->title,
              'textgroup' => 'node',
              'type' => 'node_content',
            ));
            $new->save();
          }
        }

        $old = array_diff($trans_langs, $langs);
        if ($old) {
          $ctids = array();
          foreach ($old as $langcode) {
            $ctids[] = $translatables[$langcode]->ctid;
          }
          cloudwords_translatable_delete_multiple($ctids);
        }

        $context['sandbox']['last'] = $nid;
        $context['sandbox']['count']++;
      }

      $context['finished'] = min(0.99, $context['sandbox']['count'] / $context['sandbox']['total']);
    }

    if (!$found) {
      $context['finished'] = 1;
    }
  }
}

function cloudwords_translation_before_node_save(&$node, $data, $source_language, $translation_type) {
  foreach (module_implements('cloudwords_translation_before_node_save') as $module) {
    $function = $module . '_cloudwords_translation_before_node_save';
    $function($node, $data, $source_language, $translation_type);
  }
}

function cloudwords_translation_after_node_save(&$node, $data, $source_language, $translation_type) {
  foreach (module_implements('cloudwords_translation_after_node_save') as $module) {
    $function = $module . '_cloudwords_translation_after_node_save';
    $function($node, $data, $source_language, $translation_type);
  }
}

/**
 * Implements hook_entity_insert().
 */
function cloudwords_translation_entity_insert($entity, $type){
  $supported_types = array_filter(variable_get('entity_translation_entity_types', array()));

  //Remove entities that are handled by other cloudwords submodules
  $remove_entities = array('node','taxonomy_term','user','comment');
  foreach($remove_entities as $entity_name){
    if(isset($supported_types[$entity_name])){ 
      unset($supported_types[$entity_name]);
    }
  }

  //check if enabled for cloudwords
  if (array_key_exists($type, $supported_types)) {
    
    $queue_status = !empty($entity->cloudwords_add_to_queue) ? CLOUDWORDS_QUEUE_QUEUED : CLOUDWORDS_QUEUE_NOT_IN_QUEUE;
    $entity_ids = entity_extract_ids($type, $entity); 

    list($objectid, , $textgroup) = entity_extract_ids($type, $entity);
        
    $entity_info = entity_get_info($type);
    $all_entity_info = entity_get_info();
    foreach($all_entity_info as $k => $v){
      if($v['label'] == $entity_info['label']){
        $translatable_type = $k;
      }
    }

    $translatables = cloudwords_get_translatables_by_property(array(
      'textgroup' => $textgroup,
      'type' => $translatable_type,
      'objectid' => $objectid,
    ), 'language');

    $entity->language = (isset($entity->language)) ? $entity->language : $entity->translations->original;

    if ($entity->language != LANGUAGE_NONE && $translatable_type) {
      if (empty($entity->translation_source)) {
        foreach (cloudwords_language_list() as $langcode => $language) {
          if(!isset($translatables[$langcode]) && $entity->language != $langcode){

            $translatable = cloudwords_translatable_create(array(
              'textgroup' => $textgroup,
              'type' => $translatable_type,
              'objectid' => $objectid,
              'language' => $langcode,
              'label' => $entity->title,
              'status' => $queue_status,
            ));

            $translatable->save();
          }
        }
      }
      else {
        $translatables[$entity->language]->translation_status = CLOUDWORDS_TRANSLATION_STATUS_TRANSLATION_EXISTS;
        foreach ($translatables as $translatable) {
          $translatable->status = $queue_status;
          $translatable->save();
        }
      }
    }
  }
}

/**
 * Implements hook_node_update().
 */
function cloudwords_translation_entity_update($entity, $type) {
  $supported_types = array_filter(variable_get('entity_translation_entity_types', array()));
  
  //Remove entities that are handled by other cloudwords submodules
  $remove_entities = array('node','taxonomy_term','user','comment');
  foreach($remove_entities as $entity_name){
    if(isset($supported_types[$entity_name])){ 
      unset($supported_types[$entity_name]);
    }
  }
 
  //check if enabled for cloudwords
  if (array_key_exists($type, $supported_types)) {
    $queue_status = !empty($entity->cloudwords_add_to_queue) ? CLOUDWORDS_QUEUE_QUEUED : CLOUDWORDS_QUEUE_NOT_IN_QUEUE;
    $entity_ids = entity_extract_ids($type, $entity); 
    
    list($objectid, , $textgroup) = entity_extract_ids($type, $entity);
    
    $entity_info = entity_get_info($type);
    $all_entity_info = entity_get_info();
    foreach($all_entity_info as $k => $v){
      if($v['label'] == $entity_info['label']){
        $translatable_type = $k;
      }
    }

    $entity->language = (isset($entity->language)) ? $entity->language : $entity->translations->original;    
    if ($entity->language != LANGUAGE_NONE && $translatable_type) {

      $translatables = cloudwords_get_translatables_by_property(array(
        'textgroup' => $textgroup,
        'type' => $translatable_type,
        'objectid' => $objectid,
      ), 'language');
      
      
      foreach (cloudwords_language_list() as $langcode => $language) {
        if(!isset($translatables[$langcode]) && $entity->language != $langcode){
          $translatables[$langcode] = cloudwords_translatable_create(array(
            'textgroup' => $textgroup,
            'type' => $translatable_type,
            'objectid' => $objectid,
            'language' => $langcode,
            'label' => $entity->title,
          ));   
        }
      }
      
      foreach($translatables as $translatable){
        $translatable->title = $entity->title;
        $translatable->status = $queue_status;
        $translatable->save();          
      }
    }
  }
}

/**
 * Implements hook_node_delete().
 */
function cloudwords_translation_entity_delete($entity, $type) {
  $supported_types = array_filter(variable_get('entity_translation_entity_types', array()));
  
  //Remove entities that are handled by other cloudwords submodules
  $remove_entities = array('node','taxonomy_term','user','comment');
  foreach($remove_entities as $entity_name){
    if(isset($supported_types[$entity_name])){ 
      unset($supported_types[$entity_name]);
    }
  }
 
  //check if enabled for cloudwords
  if (array_key_exists($type, $supported_types)) {
    $entity_ids = entity_extract_ids($type, $entity); 
    $entity_info = entity_get_info($type);
    $all_entity_info = entity_get_info();
    foreach($all_entity_info as $k => $v){
      if($v['label'] == $entity_info['label']){
        $translatable_type = $k;
      }
    }
    if($translatable_type){  
      cloudwords_translatable_delete_by_property(array(
        'type' => $translatable_type,
        'textgroup' => $entity_ids[2],
        'objectid' => $entity_ids[0],
      ));
    }
  }
}

function cloudwords_translation_before_entity_save(&$node, $data, $source_language, $translation_type) {
  foreach (module_implements('cloudwords_translation_before_entity_save') as $module) {
    $function = $module . '_cloudwords_translation_before_entity_save';
    $function($node, $data, $source_language, $translation_type);
  }
}
