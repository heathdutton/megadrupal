<?php
/**
 * @file
 * Provides the underlying structure for the commerce booking system.
 *
 * @todo: Sensible access control for tickets.
 */

/**
 * Define some constants for the different state of events.
 */
define('COMMERCE_BOOKING_BOOKING_OPEN', 1);
define('COMMERCE_BOOKING_BOOKING_AUTO', 2);
define('COMMERCE_BOOKING_BOOKING_CLOSED', 3);
define('COMMERCE_BOOKING_BOOKING_DISABLED', 0);

/**
 * Implements hook_menu().
 */
function commerce_booking_menu() {
  $items['admin/commerce-booking'] = array(
    'title' => 'Bookings',
    'description' => 'Administer booking system.',
    'position' => 'right',
    'weight' => -8,
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('access administration pages'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
  );

  $items['commerce_booking/ticket/add/%commerce_order/%ctools_js'] = array(
    'title' => 'Add ticket',
    'page callback' => 'commerce_booking_edit_ticket',
    'page arguments' => array(4, NULL, 3),
    'access callback' => TRUE,
    'file' => 'commerce_booking.pages.inc',
    'type' => MENU_CALLBACK,
  );

  $items['commerce_booking/ticket/%commerce_booking_ticket/edit/%ctools_js'] = array(
    'title' => 'Edit ticket',
    'page callback' => 'commerce_booking_edit_ticket',
    'page arguments' => array(4, 2),
    'access arguments' => array('administer tickets'),
    'file' => 'commerce_booking.pages.inc',
    'type' => MENU_CALLBACK,
  );

  $items['commerce_booking/ticket/%commerce_booking_ticket/cancel/%ctools_js'] = array(
    'title' => 'Cancel ticket',
    'page callback' => 'commerce_booking_cancel_ticket',
    'page arguments' => array(4, 2),
    'access arguments' => array('administer tickets'),
    'file' => 'commerce_booking.pages.inc',
    'type' => MENU_CALLBACK,
  );

  $items['commerce_booking/ticket/%commerce_booking_ticket/confirm/%ctools_js'] = array(
    'title' => 'Confirm ticket',
    'page callback' => 'commerce_booking_confirm_ticket',
    'page arguments' => array(4, 2),
    'access arguments' => array('administer tickets'),
    'file' => 'commerce_booking.pages.inc',
    'type' => MENU_CALLBACK,
  );

  $items['commerce_booking/ticket/%commerce_booking_ticket/move/%ctools_js'] = array(
    'title' => 'Move ticket',
    'page callback' => 'commerce_booking_move_ticket',
    'page arguments' => array(4, 2),
    'access arguments' => array('administer tickets'),
    'file' => 'commerce_booking.pages.inc',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_views_api().
 */
function commerce_booking_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'commerce_booking') . '/views',
  );
}

/**
 * Access callback to wrap around views_access() for event subpages.
 *
 * @param $view_name
 *   The machine name of the view.
 * @param $display_id
 *   The id of the display.
 * @param $entity_type
 *   The entity type we are working with.
 * @param $entity
 *   The entity we are working with.
 * @param bool|callable $callback
 *   The original callback.
 *
 * @return bool
 */
function commerce_booking_views_access($view_name, $display_id, $entity_type, $entity, $callback = NULL) {
  // Get our fully loaded entity and bundle.
  $entity = entity_load_single($entity_type, $entity);
  list(,,$bundle) = entity_extract_ids($entity_type, $entity);

  // Check this is a valid event entity.
  $events = commerce_booking_get_event_entities();
  if (!isset($events[$entity_type][$bundle])) {
    return FALSE;
  }

  // Check we have edit access to the entity.
  if (!entity_access('update', $entity_type, $entity)) {
    return FALSE;
  }

  // Allow modules to add any custom checks.
  $access = module_invoke_all('commerce_booking_event_subpage_access', $view_name, $display_id, $entity_type, $entity);
  if (in_array(FALSE, $access, TRUE)) {
    return FALSE;
  }

  // Pass onto the normal callback.
  if (is_callable($callback)) {
    $arguments = array_slice(func_get_args(), 3);
    return call_user_func_array($callback, $arguments);
  }
  return $callback;
}

/**
 * Implements hook_entity_info().
 */
function commerce_booking_entity_info() {
  $info['commerce_booking_ticket'] = array(
    'label' => t('Ticket'),
    'plural label' => t('Tickets'),
    'description' => t('Ticket entity.'),
    'entity class' => 'CommerceBookingTicket',
    'controller class' => 'EntityAPIController',
    'base table' => 'commerce_booking_ticket',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'ticket_id',
      'bundle' => 'type',
    ),
    'bundles' => array(),
    'bundle keys' => array(
      'bundle' => 'type',
    ),
    'label callback' => 'entity_class_label',
    'uri callback' => 'entity_class_uri',
    'access callback' => 'commerce_booking_ticket_access',
    'module' => 'commerce_booking',
    // Disable redirect for tickets.
    'redirect' => FALSE,
  );

  // The ticket type entity. Used to export Ticket Type settings.
  $info['commerce_booking_ticket_type'] = array(
    'label' => t('Ticket type'),
    'plural label' => t('Ticket types'),
    'description' => t('Ticket types for Commerce Booking Tickets.'),
    'entity class' => 'CommerceBookingTicketType',
    'controller class' => 'EntityAPIControllerExportable',
    'base table' => 'commerce_booking_ticket_type',
    'fieldable' => FALSE,
    'bundle of' => 'commerce_booking_ticket',
    'exportable' => TRUE,
    'entity keys' => array(
      'id' => 'id',
      'name' => 'type',
      'label' => 'label',
    ),
    'module' => 'commerce_booking',
    'access callback' => 'commerce_booking_ticket_type_access',
    // Enable the entity API's admin UI.
    'admin ui' => array(
      'path' => 'admin/structure/tickets',
      'file' => 'commerce_booking_ticket_type.admin.inc',
      'controller class' => 'CommerceBookingTicketTypeUIController',
    ),
    // Disable redirect for tickets type.
    'redirect' => FALSE,
  );

  return $info;
}

/**
 * Implements hook_entity_info_alter().
 *
 * Add the ticket bundles and add a booking order type.
 */
function commerce_booking_entity_info_alter(&$info) {
  // Add the commerce booking_ticket_type
  foreach (entity_load('commerce_booking_ticket_type') as $type) {
    $info['commerce_booking_ticket']['bundles'][$type->type] = array(
      'label' => $type->label,
      'admin' => array(
        'path' => 'admin/structure/tickets/manage/%commerce_booking_ticket_type',
        'real path' => 'admin/structure/tickets/manage/' . $type->type,
        'bundle argument' => 4,
        'access arguments' => array('administer tickets'),
      ),
    );
  }
}

/**
 * Implements hook_default_commerce_order_type().
 */
function commerce_booking_default_commerce_order_type() {
  $types['commerce_booking'] = new CommerceOrderType(array(
    'type' => 'commerce_booking',
    'name' => 'Booking',
    'help' => 'A drupal commerce booking',
  ));

  return $types;
}

/**
 * Implements hook_entity_property_info_alter().
 */
function commerce_booking_entity_property_info_alter(&$info) {
  $properties = &$info['commerce_booking_ticket']['properties'];

  $properties['type']['required'] = TRUE;

  $properties['status'] += array(
    'label' => t('Ticket Status'),
    'type' => 'token',
    'description' => t("The status of the ticket"),
    'setter callback' => 'entity_property_verbatim_set',
    'options list' => 'commerce_booking_ticket_status_options',
    'required' => TRUE,
    'schema field' => 'status',
  );

  $properties['balance'] = array(
    'label' => t('Ticket Balance'),
    'type' => 'commerce_price',
    'description' => t('The balance remaining on the ticket.'),
    'computed' => TRUE,
    'getter callback' => 'commerce_booking_ticket_property_get',
  );

  $properties['paid'] = array(
    'label' => t('Amount Paid so Far'),
    'type' => 'commerce_price',
    'description' => t('The amount paid on the ticket so far.'),
    'computed' => TRUE,
    'getter callback' => 'commerce_booking_ticket_property_get',
  );

  $properties['deposit'] = array(
    'label' => t('Ticket Deposit'),
    'type' => 'commerce_price',
    'description' => t('The deposit on the ticket.'),
    'computed' => TRUE,
    'getter callback' => 'commerce_booking_ticket_property_get',
  );

  $properties['line_item'] = array(
    'label' => t('Line item'),
    'type' => 'commerce_line_item',
    'description' => t('The line item this ticket is on.'),
    'computed' => TRUE,
    'getter callback' => 'commerce_booking_ticket_property_get',
  );

  $line_item_properties = &$info['commerce_line_item']['properties'];

  $line_item_properties['balance'] = array(
    'label' => t('Line Item Balance'),
    'type' => 'commerce_price',
    'description' => t('The balance remaining on the line item.'),
    'computed' => TRUE,
    'getter callback' => 'commerce_booking_line_item_property_get',
  );

  $line_item_properties['paid'] = array(
    'label' => t('Amount Paid so Far'),
    'type' => 'commerce_price',
    'description' => t('The amount paid on the ticket so far.'),
    'computed' => TRUE,
    'getter callback' => 'commerce_booking_line_item_property_get',
  );
}

/**
 * Implements hook_permission().
 */
function commerce_booking_permission() {
  $permissions = array(
    'administer ticket types' => array(
      'title' => t('Administer ticket types'),
      'description' => t('Create and delete fields on commerce booking tickets, and set their permissions.'),
    ),
    'administer tickets' => array(
      'title' => t('Administer tickets'),
      'description' => t('Edit and view all tickets.'),
    ),
    'can bypass ticket locks' => array(
      'title' => t('Can Bypass Ticket Locks'),
      'description' => t('Edit tickets even when they are locked.'),
    ),
    'can book for events' => array(
      'title' => t('Can book for events'),
      'description' => t('Can use the booking manager to create and manage bookings for events.'),
    ),
    'can book for closed events' => array(
      'title' => t('Can book for closed events'),
      'description' => t('Can use the booking manager to book for events even when booking is not open'),
    ),
  );

  // Generate per project type permissions.
  foreach (entity_load('commerce_booking_ticket_type') as $type) {
    $type_label = entity_label('commerce_booking_ticket_type', $type);
    $permissions += array(
      "edit any {$type->type} ticket" => array(
        'title' => t('%type_name: Edit any ticket', array('%type_name' => $type_label)),
      ),
      "delete any {$type->type} ticket" => array(
        'title' => t('%type_name: Delete any ticket', array('%type_name' => $type_label)),
      ),
      "view any {$type->type} ticket" => array(
        'title' => t('%type_name: View any ticket', array('%type_name' => $type_label)),
      ),
      "create a {$type->type} ticket" => array(
        'title' => t('%type_name: Create a ticket', array('%type_name' => $type_label)),
      ),
    );
  }
  return $permissions;
}

/**
 * Implements hook_hook_info().
 */
function commerce_booking_hook_info() {
  $hooks['default_commerce_booking_ticket_type'] = array('group' => 'commerce_booking');
  $hooks['commerce_booking_ticket_status_info'] = array('group' => 'commerce_booking');
  $hooks['commerce_booking_ticket_status_info_alter'] = array('group' => 'commerce_booking');
  $hooks['commerce_booking_allow_booking'] = array('group' => 'commerce_booking');
  $hooks['commerce_booking_order_alter'] = array('group' => 'commerce_booking');
  $hooks['commerce_booking_ticket_is_locked'] = array('group' => 'commerce_booking');
  $hooks['commerce_booking_ticket_confirm'] = array('group' => 'commerce_booking');
  $hooks['commerce_booking_ticket_access'] = array('group' => 'commerce_booking');
  $hooks['commerce_booking_ticket_price_alter'] = array('group' => 'commerce_booking');
  $hooks['commerce_booking_ticket_process'] = array('group' => 'commerce_booking');
  $hooks['commerce_booking_views_event_subpage_access'] = array('group' => 'commerce_booking');
  return $hooks;
}

/**
 * Implements hook_field_attach_create_bundle().
 *
 * Add a commerce_booking_event field to new ticket bundles.
 */
function commerce_booking_field_attach_create_bundle($entity_type, $bundle) {
  if ($entity_type != 'commerce_booking_ticket') {
    return;
  }

  // Create an event reference field.
  if (!field_info_field('commerce_booking_event')) {
    $field = array(
      'type' => 'commerce_booking_event',
      'field_name' => 'commerce_booking_event',
      'cardinality' => 1,
    );
    field_create_field($field);
  }

  // Create an instance on ticket entity.
  if (!field_info_instance('commerce_booking_ticket', 'commerce_booking_event', $bundle)) {
    $instance = array(
      'entity_type' => 'commerce_booking_ticket',
      'bundle' => $bundle,
      'field_name' => 'commerce_booking_event',
      'label' => t('Event'),
      'description' => t('The event this ticket is for.'),
    );
    field_create_instance($instance);
  }

  // Create an ticket price field.
  if (!field_info_field('commerce_booking_ticket_price')) {
    $field = array(
      'type' => 'commerce_price',
      'field_name' => 'commerce_booking_ticket_price',
      'cardinality' => 1,
    );
    field_create_field($field);
  }

  // Create an instance on ticket entity.
  if (!field_info_instance('commerce_booking_ticket', 'commerce_booking_ticket_price', $bundle)) {
    $instance = array(
      'entity_type' => 'commerce_booking_ticket',
      'bundle' => $bundle,
      'field_name' => 'commerce_booking_ticket_price',
      'label' => t('Price'),
      'description' => t('The calculated price of this Ticket.'),
    );
    field_create_instance($instance);
  }
}

/**
 * Gets an array of all ticket types, keyed by the type name.
 *
 * @param string $type_name
 *   If set, the type with the given name is returned.
 *
 * @return CommerceBookingTicketType[]
 *   Depending whether $type isset, an array of ticket types or a single one.
 */
function commerce_booking_ticket_get_types($type_name = NULL) {
  $types = entity_load_multiple_by_name('commerce_booking_ticket_type', isset($type_name) ? array($type_name) : FALSE);
  return isset($type_name) ? reset($types) : $types;
}

/**
 * Load a commerce_booking_ticket_type.
 */
function commerce_booking_ticket_type_load($type_name) {
  return commerce_booking_ticket_get_types($type_name);
}

/**
 * Fetch a ticket object.
 *
 * @param int $ticket_id
 *   Integer specifying the ticket id.
 * @param bool $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return CommerceBookingTicket
 *   A fully-loaded $ticket object or FALSE if it cannot be loaded.
 */
function commerce_booking_ticket_load($ticket_id, $reset = FALSE) {
  return entity_load_single('commerce_booking_ticket', $ticket_id);
}

/**
 * Create a ticket for a given booking.
 */
function commerce_booking_ticket_create($booking) {
  // Get event information from booking.
  $event = commerce_booking_get_event_entity($booking);
  $event_type = commerce_booking_get_event_entity_type($booking);
  $field_name = commerce_booking_get_field_name($event_type, $event);

  $ticket_type = !empty($event->{$field_name}[LANGUAGE_NONE][0]['ticket_type']) ? $event->{$field_name}[LANGUAGE_NONE][0]['ticket_type'] : 'commerce_booking_ticket';
  $ticket = entity_create('commerce_booking_ticket', array(
    'type' => $ticket_type,
  ));
  $ticket->commerce_booking_event = $booking->commerce_booking_event;
  return $ticket;
}

/**
 * Checks if a ticket should be locked.
 *
 * @param CommerceBookingTicket $ticket
 *   An optional ticket. If not provided, no checks will be performed at a
 *   ticket level.
 * @param string $entity_type
 *   An optional event entity type. If $entity_type and $entity are provided,
 *   checks will be performed at an event level. This may be in addition to a
 *   ticket level if $ticket is provided. If not provided, we attempt to
 *   retrieve this information from the ticket, so this is normally only used
 *   when there is no specific ticket to check.
 * @param object $entity
 *   The object entity of the type $entity_type.
 *
 * @return boolean
 *   TRUE if locked, FALSE if not.
 */
function commerce_booking_ticket_is_locked(CommerceBookingTicket $ticket = NULL, $entity_type = NULL, $entity = NULL) {
  // If the user has bypass ticket locks, this trumps everything.
  if (user_access('can bypass ticket locks')) {
    return FALSE;
  }

  // First do our easy internal check on ticket status.
  if (isset($ticket) && $ticket->status == 'cancelled') {
    return TRUE;
  }

  if (!isset($entity_type) || !isset($entity)) {
    // See if we can sniff out the information from the ticket.
    // Get hold of the event.
    $ticket_wrapper = entity_metadata_wrapper('commerce_booking_ticket', $ticket);
    $event_wrapper = $ticket_wrapper->commerce_booking_event;
    $entity_type = $event_wrapper->type() ? $event_wrapper->type(): NULL;
    $entity = $event_wrapper->value() ? $event_wrapper->value(): NULL;
  }

  // Pass on to other modules to allow them to lock the ticket.
  $results = module_invoke_all('commerce_booking_ticket_is_locked', $ticket, $entity_type, $entity);
  if (in_array(TRUE, $results)) {
    return TRUE;
  }

  // If we've got here it's not locked.
  return FALSE;
}

/**
 * Process a ticket and calculate its price.
 *
 * @param array $options
 *   An array of options that get passed through to the implementations of
 *   the price and process hooks.
 *
 * @see hook_commerce_booking_ticket_price_alter()
 * @see hook_commerce_booking_ticket_process()
 */
function commerce_booking_ticket_process(CommerceBookingTicket $ticket, $options = array()) {
  $locked = commerce_booking_ticket_is_locked($ticket);

  // We don't process a ticket if it is locked.
  if ($locked) {
    return;
  }

  // Get hold of the event.
  $ticket_wrapper = entity_metadata_wrapper('commerce_booking_ticket', $ticket);
  $event_wrapper = $ticket_wrapper->commerce_booking_event;
  $event = $event_wrapper->value();
  $field_name = commerce_booking_get_field_name($event_wrapper->type(), $event_wrapper->value());

  // Run the price update.
  if ($field_name) {
    $instance = field_info_instance($event_wrapper->type(), $field_name, $event_wrapper->getBundle());
    $price_field = $instance['settings']['price_field'];
    if (!empty($event->{$price_field})) {
      // Only take the first value.
      $ticket->commerce_booking_ticket_price[LANGUAGE_NONE][0] = $event->{$price_field}[LANGUAGE_NONE][0];
    }
  }
  else {
    $ticket->commerce_booking_ticket_price[LANGUAGE_NONE][0] = array(
      'amount' => 0,
      'currency_code' => commerce_default_currency(),
    );
  }

  // Allow other modules to alter the price.
  drupal_alter('commerce_booking_ticket_price', $ticket->commerce_booking_ticket_price, $ticket, $options);

  // Allow other modules to do other ticket processing.
  foreach (module_implements('commerce_booking_ticket_process') as $module) {
    $function = $module . '_commerce_booking_ticket_process';
    $function($ticket, $options);
  }
}

/**
 * Calculate the balance reminaing on a ticket.
 */
function commerce_booking_ticket_balance($ticket, $type = 'balance') {
  $ticket_wrapper = entity_metadata_wrapper('commerce_booking_ticket', $ticket);
  $price = $ticket_wrapper->commerce_booking_ticket_price->value();
  if ($price) {
    $full_amount = $price;
  }
  else {
    $full_amount = array(
      'amount' => 0,
      'currency_code' => commerce_default_currency(),
    );
  }
  $paid_amount = array(
    'amount' => 0,
    'currency_code' => $price['currency_code'],
  );

  foreach ($ticket_wrapper->commerce_booking_ticket_payments as $item) {
    // If the item doesn't exist, let's catch it without it all going wrong.
    if (!$item->value()) {
      watchdog('commerce_booking', 'Missing ticket payment @id', array('@id' => $item->raw()), WATCHDOG_CRITICAL);
      continue;
    }

    // If the payment was successful, reduce the amount due.
    if ($payment = $item->cbt_payment_payment->value()) {
      if ($payment->status == COMMERCE_PAYMENT_STATUS_SUCCESS) {
        $item_value = $item->cbt_payment_value->value();
        $full_amount['amount'] -= commerce_currency_convert($item_value['amount'], $item_value['currency_code'], $full_amount['currency_code']);
        $paid_amount['amount'] += commerce_currency_convert($item_value['amount'], $item_value['currency_code'], $paid_amount['currency_code']);
      }
    }
  }

  if ($type == 'balance') {
    return $full_amount;
  }
  elseif ($type == 'paid') {
    return $paid_amount;
  }
}

/**
 * Property getter.
 */
function commerce_booking_ticket_property_get($ticket, $options, $name, $type, $info) {
  switch ($name) {
    case 'balance':
      return commerce_booking_ticket_balance($ticket);

    case 'paid':
      return commerce_booking_ticket_balance($ticket, 'paid');

    case 'deposit':
      // Get deposit information for the ticket from the commerce_booking field on
      // the event entity.
      $ticket_wrapper = entity_metadata_wrapper('commerce_booking_ticket', $ticket);
      $field_name = commerce_booking_get_field_name($ticket_wrapper->commerce_booking_event->type(), $ticket_wrapper->commerce_booking_event->value());
      $instance = field_info_instance($ticket_wrapper->commerce_booking_event->type(), $field_name, $ticket_wrapper->commerce_booking_event->getBundle());

      if (!empty($instance['settings']['deposit_field'])) {
        $deposit_field = $instance['settings']['deposit_field'];
        $deposit = $ticket_wrapper->commerce_booking_event->{$deposit_field}->value();
      }
      else {
        $deposit = array(
          'amount' => 0,
          'currency_code' => commerce_default_currency(),
        );
      }

      return $deposit;

    case 'line_item':
      return commerce_booking_get_line_item($ticket);
  }
}

/**
 * Calculate the balance reminaing on a line item.
 */
function commerce_booking_line_item_balance($line_item, $type = 'balance') {
  $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
  $price = $line_item_wrapper->commerce_total->value();
  if ($price) {
    $full_amount = $price;
  }
  else {
    $full_amount = array(
      'amount' => 0,
      'currency_code' => commerce_default_currency(),
    );
  }
  $paid_amount = array(
    'amount' => 0,
    'currency_code' => $price['currency_code'],
  );

  foreach ($line_item_wrapper->commerce_booking_ticket_payments as $item) {
    // If the item doesn't exist, let's catch it without it all going wrong.
    if (!$item->value()) {
      watchdog('commerce_booking', 'Missing payment @id', array('@id' => $item->raw()), WATCHDOG_CRITICAL);
      continue;
    }

    // If the payment was successful, reduce the amount due.
    if ($payment = $item->cbt_payment_payment->value()) {
      if ($payment->status == COMMERCE_PAYMENT_STATUS_SUCCESS) {
        $item_value = $item->cbt_payment_value->value();
        $full_amount['amount'] -= commerce_currency_convert($item_value['amount'], $item_value['currency_code'], $full_amount['currency_code']);
        $paid_amount['amount'] += commerce_currency_convert($item_value['amount'], $item_value['currency_code'], $paid_amount['currency_code']);
      }
    }
  }

  if ($type == 'balance') {
    return $full_amount;
  }
  elseif ($type == 'paid') {
    return $paid_amount;
  }
}

/**
 * Property getter.
 */
function commerce_booking_line_item_property_get($line_item, $options, $name, $type, $info) {
  switch ($name) {
    case 'balance':
      return commerce_booking_line_item_balance($line_item);

    case 'paid':
      return commerce_booking_line_item_balance($line_item, 'paid');
  }
}

/**
 * Determines whether the given user has access to a ticket.
 *
 * @param string $op
 *   The operation being performed. One of 'view', 'edit', 'create', 'delete',
 *   or 'cancel'.
 * @param CommerceBookingTicket $ticket
 *   (optional) A ticket to check access for. If nothing is given, access for
 *   all tickets is determined.
 * @param stdClass $account
 *   The user to check for. Leave it to NULL to check for the global user.
 *
 * @return bool
 *   Whether access is allowed or not.
 *
 * @see hook_commerce_booking_ticket_access()
 */
function commerce_booking_ticket_access($op, $ticket = NULL, $account = NULL) {
  // Admins can always bypass other access.
  if (user_access('administer tickets', $account)) {
    return TRUE;
  }

  // Locked ticket cannot be cancelled by non-admins.
  if ($op == 'cancel' && commerce_booking_ticket_is_locked($ticket)) {
    return FALSE;
  }

  // Make sure we have an account for the hooks.
  if ($account === NULL) {
    global $user;
    $account = $user;
  }

  // Allow modules to grant / deny access.
  $access = module_invoke_all('commerce_booking_ticket_access', $op, $ticket, $account);

  // Only grant access if at least one module granted access and no one denied
  // access.
  if (in_array(FALSE, $access, TRUE)) {
    return FALSE;
  }
  elseif (in_array(TRUE, $access, TRUE)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Get the options list for commerce_booking_ticket_statuses.
 */
function commerce_booking_ticket_status_options() {
  $options = array();

  foreach (commerce_booking_ticket_status_info() as $status => $info) {
    $options[$status] = $info['label'];
  }

  return $options;
}

/**
 * Get the statuses for commerce_booking_tickets.
 */
function commerce_booking_ticket_status_info() {
  $statuses = &drupal_static(__FUNCTION__);

  if (!empty($statuses)) {
    return $statuses;
  }
  else {
    $statuses = module_invoke_all('commerce_booking_ticket_status_info');

    // Alter the data sets with hook_party_data_set_info_alter().
    drupal_alter('commerce_booking_ticket_status_info', $statuses);
  }

  return $statuses;
}

/**
 * Access callback for the entity API.
 */
function commerce_booking_ticket_type_access($op, $type = NULL, $account = NULL) {
  return user_access('administer ticket types', $account);
}

/**
 * Get an event entity from a commerce_booking order or a ticket entity.
 *
 * @param Object $entity
 *   An order or ticket entity with a commerce_booking_event field.
 *
 * @return Object
 *   Fully loaded event entity.
 *
 * @todo: Make more generic - field names are hardcoded here.
 */
function commerce_booking_get_event_entity($entity) {
  if (empty($entity->commerce_booking_event)) {
    return FALSE;
  }

  if (!empty($entity->commerce_booking_event[LANGUAGE_NONE][0])) {
    $entity_type = $entity->commerce_booking_event[LANGUAGE_NONE][0]['entity_type'];
    $entity_id = $entity->commerce_booking_event[LANGUAGE_NONE][0]['entity_id'];
    return entity_load_single($entity_type, $entity_id);
  }

  return FALSE;
}

/**
 * Get an event entity type from a commerce_booking order or ticket entity.
 *
 * This currently only works if the event reference field is called
 * commerce_booking_event.
 *
 * @param Object $entity
 *   An order or ticket entity with a commerce_booking_event field.
 *
 * @return string
 *   The entity type of the referenced event entity.
 *
 * @todo: Make more generic - field names are hardcoded here.
 */
function commerce_booking_get_event_entity_type($entity) {
  if (empty($entity->commerce_booking_event)) {
    return FALSE;
  }

  if (!empty($entity->commerce_booking_event[LANGUAGE_NONE][0])) {
    return $entity->commerce_booking_event[LANGUAGE_NONE][0]['entity_type'];
  }

  return FALSE;
}

/**
 * Get the uri for an event entity from a commerce_order or ticket entity.
 *
 * This currently only works if the event reference field is called
 * commerce_booking_event.
 *
 * @param Object $entity
 *   An order or ticket entity with a commerce_booking_event field.
 *
 * @return string|NULL
 *   The URI of the referenced event entity.
 *
 * @see entity_uri()
 *
 * @todo: Make more generic - field names are hardcoded here.
 */
function commerce_booking_get_event_entity_uri($entity) {
  if (empty($entity->commerce_booking_event)) {
    return FALSE;
  }

  if (!empty($entity->commerce_booking_event[LANGUAGE_NONE][0])) {
    $entity_type = $entity->commerce_booking_event[LANGUAGE_NONE][0]['entity_type'];
    $entity_id = $entity->commerce_booking_event[LANGUAGE_NONE][0]['entity_id'];
    $entity = entity_load_single($entity_type, $entity_id);
    return $entity ? entity_uri($entity_type, $entity) : NULL;
  }
}

/**
 * Get the field name of the event entity's booking field.
 *
 * @param string $entity_type
 *   The entity type of $entity.
 * @param Object $entity
 *   The entity on which we want to find a field of type $type.
 * @param string $type
 *   The field type to look for. Defaults to 'commerce_booking'.
 *
 * @return string
 *   The field name of the first field on $entity that is of type $type.
 */
function commerce_booking_get_field_name($entity_type, $entity, $type = 'commerce_booking') {
  // Get the booking field options.
  list(,,$bundle) = entity_extract_ids($entity_type, $entity);

  // Find commerce price fields.
  $instances = field_info_instances($entity_type, $bundle);
  foreach ($instances as $field_name => $settings) {
    $info = field_info_field($field_name);
    if ($info['type'] == $type) {
      return $field_name;
    }
  }
}

/**
 * Get hold of all entities/bundles which have a booking field.
 *
 * @return
 *   An array with entity types as outer keys and an array of
 */
function commerce_booking_get_event_entities() {
  $entities = &drupal_static(__FUNCTION__);

  if (!isset($entities)) {
    // Iterate over the field map finding booking fields.
    foreach (field_info_field_map() as $field_info) {
      if ($field_info['type'] == 'commerce_booking') {
        // Merge in our entity types/bundles.
        foreach ($field_info['bundles'] as $entity_type => $bundles) {
          // Initiate our array if necessary.
          if (!isset($entities[$entity_type])) {
            $entities[$entity_type] = array();
          }

          $entities[$entity_type] += drupal_map_assoc($bundles);
        }
      }
    }
  }

  return $entities;
}

/**
 * Get a booking for a particular user and event.
 *
 * @param stdClass $user
 *   The user entity.
 * @param string $event_type
 *   The entity type of the event entity
 * @param Entity $event
 *   The event entity to find a booking for.
 *
 * @return stdClass
 *   A commerce_order entity if the user has a booking for the given event,
 *   FALSE otherwise.
 */
function commerce_booking_get_booking($user, $event_type, $event) {
  // We should never return an existing booking for an anonymous user.
  if ($user->uid == 0) {
    return FALSE;
  }

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_order')
    ->entityCondition('bundle', 'commerce_booking')
    ->propertyCondition('uid', $user->uid)
    ->fieldCondition('commerce_booking_event', 'entity_id', entity_id($event_type, $event))
    ->fieldCondition('commerce_booking_event', 'entity_type', $event_type);
  $entities = $query->execute();

  if (empty($entities['commerce_order'])) {
    return FALSE;
  }

  return entity_load_single('commerce_order', reset(array_keys($entities['commerce_order'])));
}

/**
 * Get the line_item of a given ticket entity.
 *
 * @return stdClass
 *   A line item for the given ticket. If none is found, return false.
 */
function commerce_booking_get_line_item($ticket) {
  $query = new EntityFieldQuery();
  $line_items = $query
    ->entityCondition('entity_type', 'commerce_line_item')
    ->fieldCondition('commerce_booking_ticket', 'target_id', $ticket->ticket_id)
    ->execute();

  // @todo: Create one?
  if (empty($line_items['commerce_line_item'])) {
    return FALSE;
  }

  return entity_load_single('commerce_line_item', reset($line_items['commerce_line_item'])->line_item_id);
}

/**
 * Implements hook_theme().
 */
function commerce_booking_theme($existing, $type, $theme, $path) {
  return array(
    'commerce_booking_ticket_table_form' => array(
      'file' => 'commerce_booking.checkout.inc',
      'render element' => 'form',
    ),
  );
}

/**
 * Implements hook_field_extra_fields().
 */
function commerce_booking_field_extra_fields() {
  $extra['commerce_order']['commerce_booking'] = array(
    'form' => array(
      'booking_reference' => array(
        'label' => t('Booking Reference'),
        'description' => t('The unique booking reference for this booking'),
        'weight' => -3,
      ),
    ),
    'display' => array(
      'booking_reference' => array(
        'label' => t('Booking Reference'),
        'description' => t('The unique booking reference for this booking'),
        'weight' => -3,
      ),
    ),
  );
}

/**
 * Implements hook_commerce_partial_payment_calculate_minimum_payment().
 */
function commerce_booking_commerce_partial_payment_calculate_minimum_payment($order) {
  if ($order->type != 'commerce_booking') {
    return;
  }

  // Get the order wrapper.
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

  $deposit = array(
    'amount' => 0,
    'currency_code' => 'GBP',
  );

  // Sum the deposits for each of the pending tickets.
  foreach ($order_wrapper->commerce_line_items as $line_item_wrapper) {
    // Only work on line items that are single ticket line items.
    if ($line_item_wrapper->type->value() != 'commerce_booking_ticket') {
      continue;
    }

    foreach ($line_item_wrapper->commerce_booking_ticket as $ticket_wrapper) {
      // Only count the deposits.
      if ($ticket_wrapper->status->value() != 'pending') {
        continue;
      }

      // Work out the deposit amount.
      $ticket_deposit = $ticket_wrapper->commerce_booking_event->field_event_deposit->value();
      $deposit['amount'] += $ticket_deposit['amount'];
    }
  }

  return $deposit;
}

/**
 * Implements hook_form_commerce_checkout_form_alter().
 */
function commerce_booking_form_commerce_checkout_form_alter(&$form, &$form_state, $form_id) {
  if ($form_state['order']->type == 'commerce_booking') {
    $form['buttons']['back']['#submit'] = array('commerce_booking_form_commerce_checkout_form_back_submit');
    $form['buttons']['cancel']['#access'] = FALSE;
  }
}

/**
 * Extra submit handler for the commerce checkout form.
 */
function commerce_booking_form_commerce_checkout_form_back_submit(&$form, &$form_state) {
  $form_state['redirect'] = url('checkout/' . $form_state['order']->order_id . '/' . $form_state['checkout_page']['prev_page']);
}

/**
 * Implements hook_entity_presave().
 *
 * Update the price of line items.
 */
function commerce_booking_entity_presave($entity, $type) {
  switch ($type) {
    case 'commerce_booking_ticket':
      // Recalculate the ticket price.
      commerce_booking_ticket_process($entity);

      // If the ticket has been set back to pending we should un-confirm it.
      if ($entity->status == 'pending'
        && $entity->original->status != 'pending') {
        $entity->confirmed = 0;
      }
      break;

    case 'commerce_line_item':
      if ($entity->type == 'commerce_booking_ticket') {
        // Need to re-calculate the price of the line item.
        module_load_include('inc', 'commerce_booking', 'commerce_booking.commerce');
        commerce_booking_line_item_ticket_process($entity);
      }
      break;
  }
}

/**
 * Implements hook_entity_insert().
 */
function commerce_booking_entity_insert($entity, $type) {
  _commerce_booking_entity_postsave($entity, $type);
}

/**
 * Implements hook_entity_update().
 */
function commerce_booking_entity_update($entity, $type) {
  _commerce_booking_entity_postsave($entity, $type);
}

/**
 * Implements hook_entity_delete().
 */
function commerce_booking_entity_delete($entity, $type) {
  _commerce_booking_entity_postsave($entity, $type);
}

/**
 * Entity post save callback (insert and update).
 */
function _commerce_booking_entity_postsave($entity, $type) {
  if ($type == 'commerce_booking_ticket') {
    // Recalculate the line item price.
    if ($line_item = commerce_booking_get_line_item($entity)) {
      commerce_line_item_save($line_item);
    }
  }
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function commerce_booking_ctools_plugin_directory($owner, $plugin_type) {
  if (($owner == 'panelizer' && $plugin_type == 'entity')
    || ($owner == 'ctools' && $plugin_type == 'relationships')) {
    return "plugins/$plugin_type";
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function commerce_booking_form_commerce_checkout_form_terms_conditions_alter(&$form, &$form_state) {
  $booking = $form_state['order'];

  $statuses = array(
    'checkout_tickets',
    'checkout_accommodation',
    'checkout_review',
    'checkout_payment',
    'checkout_complete',
  );

  // Only act if terms and conditions have been accepted.
  if (empty($booking->commerce_booking_tcs[LANGUAGE_NONE][0]['value'])
      && !in_array($booking->status, $statuses)) {
    return;
  }

  $form['buttons']['continue']['#submit'] = array('commerce_booking_checkout_terms_conditions_submit');
  $form['buttons']['cancel']['#submit'] = array();
}

/**
 * Submit handler for terms conditions step.
 */
function commerce_booking_checkout_terms_conditions_submit($form, &$form_state) {
  $checkout_page = $form_state['checkout_page'];

  // Load a fresh copy of the order stored in the form.
  $order = commerce_order_load($form_state['order']->order_id);

  // If the form was submitted via the continue button...
  if (end($form_state['triggering_element']['#array_parents']) == 'continue') {
    // If there is another checkout page...
    if ($checkout_page['next_page']) {
      // Update the order status to reflect the next checkout page.
      $order = commerce_order_status_update($order, $order->status, FALSE, TRUE, t('Customer continued to the next checkout page via a submit button.'));

      // If it happens to be the complete page, process completion now.
      if ($checkout_page['next_page'] == 'complete') {
        commerce_checkout_complete($order);
      }

      // Redirect to the next checkout page.
      $form_state['redirect'] = 'checkout/' . $order->order_id . '/' . $checkout_page['next_page'];
    }
  }
}

/**
 * Check whether a user can book for an event.
 *
 * @param string $entity_type
 *   The entity type of the even entity.
 * @param Object $entity
 *   The event entity.
 * @param stdClass $account
 *   Optionally the account to prepare the booking for. If NULL, the currently
 *   logged in user will be used.
 *
 * @return boolean
 */
function commerce_booking_can_book($entity_type, $entity, $account = NULL, $item = NULL) {
  if (!$item) {
    $booking_field = commerce_booking_get_field_name($entity_type, $entity);
    $items = field_get_items($entity_type, $entity, $booking_field);

    // If we don't have a status, assume it's disabled.
    if (!$items) {
      return FALSE;
    }

    $item = reset($items);
  }

  switch ($item['booking_open']) {
    // Open we allow.
    case COMMERCE_BOOKING_BOOKING_OPEN:
      return TRUE;

    // Closed depends on the permission.
    case COMMERCE_BOOKING_BOOKING_CLOSED:
      return user_access('can book for closed events', $account);

    // Anything else including COMMERCE_BOOKING_BOOKING_DISABLED, deny.
    default:
      return FALSE;
  }
}

/**
 * Prepare a booking for a given event entity and user.
 *
 * @param string $entity_type
 *   The entity type of the even entity.
 * @param Object $entity
 *   The event entity.
 * @param stdClass $account
 *   The account to prepare the booking for.
 * @param string $status
 *   Optionally provide an order status to default to on creation of a booking.
 *
 * @return NULL|stdClass
 *   A prepared (and saved) booking entity ready for the checkout process or
 *   NULL if unable to do so.
 */
function commerce_booking_prepare_booking($entity_type, $entity, $account, $status = 'checkout_terms_conditions') {
  // Try and find an order for the given entity and user.
  $booking = commerce_booking_get_booking($account, $entity_type, $entity);

  // If we couldn't find a booking for this event for the user, create one.
  if (!$booking) {
    // First check general access. This should be against the logged in user.
    if (!commerce_booking_can_book($entity_type, $entity)) {
      return;
    }

    // Allow other modules to prevent us continuing. An example would be a
    // module that links tickets to users and therefore wants to prevent
    // ticket holders booking again.
    $allow_booking = module_invoke_all('commerce_booking_allow_booking', $entity_type, $entity, $account);
    if (in_array(FALSE, $allow_booking, TRUE)) {
      return;
    }

    // Create an order.
    $booking = commerce_order_new($account->uid, $status, 'commerce_booking');
    $booking->commerce_booking_event[LANGUAGE_NONE][] = array(
      'entity_type' => $entity_type,
      'entity_id' => entity_id($entity_type, $entity),
    );
    entity_save('commerce_order', $booking);

    // Create the line item and add it.
    $line_item = commerce_line_item_new('commerce_booking_ticket', $booking->order_id);
    $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
    $line_item_wrapper->quantity = 1;
    $line_item_wrapper->save();
    $booking_wrapper = entity_metadata_wrapper('commerce_order', $booking);
    $booking_wrapper->commerce_line_items[] = $line_item;
    drupal_alter('commerce_booking_order', $booking);
    entity_save('commerce_order', $booking);
  }

  // Store this in the session so they have access.
  $_SESSION['commerce_cart_orders'][] = $booking->order_id;

  return $booking;
}

/**
 * Implements hook_field_access().
 */
function commerce_booking_field_access($op, $field, $entity_type, $entity, $account) {
  if ($op == 'edit' && $entity_type == 'commerce_booking_ticket') {
    switch ($field['field_name']) {
      case 'commerce_booking_event':
      case 'commerce_booking_ticket_price':
      case 'commerce_booking_ticket_status':
      case 'commerce_booking_ticket_payments':
        return FALSE;
    }
  }
}

/**
 * Implements hook_field_widget_form_alter().
 *
 * Prevent ticket line items being added directly.
 */
function commerce_booking_field_widget_form_alter(&$element, &$form_state, $context) {
  if ($context['instance']['widget']['type'] == 'commerce_line_item_manager') {
    unset($element['actions']['line_item_type']['#options']['commerce_booking_ticket']);
  }
}
