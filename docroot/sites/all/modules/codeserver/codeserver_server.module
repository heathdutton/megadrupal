<?php

/*
 * @file
 * Part of Code Server module for Drupal by netgenius.co.uk
 * https://www.drupal.org/project/codeserver
 *
 * This .module is intended to be compatible with D6, D7 and D8.
 * See codeserver_compat.inc for version-specific code.
 */

/*
 * Implement hook_menu().
 */
function codeserver_server_menu() {
  $items = array();

  $items['codeserver/server'] = array(
    'title' => 'Code Server',
    'page callback' => 'codeserver_server_page',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  return $items;
}

// Serve the page, handling decoding and encoding.
function codeserver_server_page($service_id = 'default') {

  // Include our Drupal compatibility file.
  module_load_include('inc', 'codeserver', 'codeserver_compat');

  // Get the configuration for this service.
  $config = codeserver_get_config($service_id, 'server');

  // Check access...
  // Default to no access.
  $allow_access = FALSE;
  if ($config) {
    // Check if client IP address is allowed access...
    $client_ip = ip_address();
    $allowed_ips = $config->allowed_ips;
    if (is_string($allowed_ips)) {
      $allow_access = ($client_ip == $allowed_ips || $allowed_ips == 'ALL');
    }
    elseif (is_array($allowed_ips)) {
      // If client IP is in the allowed list, allow access.
      $allow_access = in_array($client_ip, $allowed_ips);
    }
  }

  // If access not allowed, return a 403 result.
  // @todo Consider adding a setting in config to enable debug messages for access control.
  if (!$allow_access) {
    codeserver_report_error('allowed_ips');
    $result = '403 Forbidden';
    codeserver_set_header('Status', $result);
    echo $result;
    return;
  }

  // Access is allowed, contine...
  // Set a custom Content-Type header (handle both D7 and D6).
  codeserver_set_header('Content-Type', 'x-drupal-codeserver');

  // Fetch $request from POST data.
  $request = $_POST['request'];

  // Set up the packager.
  $packager = new CodeServerPackager($config);
  // Get the decoded request.
  $request = $packager->decode($request);

  // Process the request.
  $return = codeserver_server_access_check($request, $config);
  if ($return) {
    ob_start();
    $return = codeserver_server_execute($request, $config);
    $output = ob_get_contents();
    ob_end_clean();
  }
  else {
    $output = '';
  }

  // Get all messages and clear the message queue;
  $messages = drupal_get_messages(NULL, TRUE);
  // If disabled in config, don't return messages to the client.
  if (!codeserver_show_messages($config)) {
    $messages = array();
  }
  // Return $return value plus $messages.
  $result = (object) compact('return', 'messages', 'output');

  // Encode and output the result.
  echo $packager->encode($result);
}

// Log in if configured, and check permission.
function codeserver_server_access_check($request, $config) {

  // Check that the service is enabled.
  if (!$config->service_enabled) {
    return codeserver_report_error('service_enabled', $config);
  }

  // Log in if allowed and requested.
  $logged_in = FALSE;
  if (isset($request->options['login'])) {
    $login = $request->options['login'];
    if ($config->allow_login) {
      $logged_in = codeserver_server_login($login['id'], $login['password']);
      if (!$logged_in) {
        // @todo Move error report to codeserver_server_login() when refactored as a class.
        // For security, we don't specify whether the problem was id or password.
        $msg = sprintf('login (user %s)', $login['id']);
        codeserver_report_error($msg, $config, 'warning');
      }
    }
    else {
      $msg = sprintf('allow_login (user %s)', $login['id']);
      codeserver_report_error($msg, $config, 'warning');
    }
  }

  // Force log in if not already logged in and uid specified in config.
  if (!$logged_in && $config->set_uid != 0) {
    // Make sure session does not get saved. Ref: https://www.drupal.org/node/218104
    drupal_save_session(FALSE);
    // Force login with specified uid.
    $logged_in = codeserver_server_login($config->set_uid, '', TRUE);
    if (!$logged_in) {
      // @todo Move error report to codeserver_server_login() when refactored as a class.
      $msg = sprintf('set_uid (user %s)', $config->set_uid);
      codeserver_report_error($msg, $config, 'warning');
    }
  }

  // Check permission if required.
  if ($config->require_permission) {
    $permission = 'codeserver access ' . $config->service_id;
    if (!user_access($permission)) {
      $msg = sprintf('permission (%s)', $permission);
      return codeserver_report_error($msg, $config);
    }
  }

  // User has permission or no permission needed.
  return TRUE;
}

// Process the request.
function codeserver_server_execute($request, $config) {

  // If the request is for a simple function call...
  if (isset($request->func)) {
    // Call this function if allowed.
    return codeserver_server_function_call($request->func, $request->args, $config);
  }
  // If the request is for multiple functions to call...
  elseif (isset($request->functions)) {
    $return = array();
    foreach ($request->functions as $key => $args) {
      // Get the function name.
      $func = array_shift($args);
      // Call this function if allowed, appending the result to the $return array.
      $result = codeserver_server_function_call($func, $args, $config);
      // Pass back the result if a string key was given by the client.
      if (is_string($key)) {
        $return[$key] = $result;
      }
    }
    return $return;
  }
  // Else if we have code to evaluate ...
  elseif (isset($request->code)) {
    if ($config->allowed_functions == 'ALL') {
      // If allowed, evaluate code with variables.
      return codeserver_server_eval($request->code, $request->vars);
    }
    else {
      // Not allowed - report error and return FALSE.
      return codeserver_report_error('allowed_functions (ALL)', $config);
    }
  }

  // Something else? Report error and return FALSE.
  return codeserver_report_error('invalid request', $config);
}

// Process the request.
function codeserver_server_function_call($func, $args, $config) {
  // Check that this function is allowed.
  $allowed = $config->allowed_functions;

  // If $allowed is a string, it is either a single function name or 'ALL';
  if (is_string($allowed)) {
    if ($func == $allowed || $allowed == 'ALL') {
      return call_user_func_array($func, $args);
    }
  }
  else {
    // If this function is in the list of allowed functions...
    if (array_search($func, $allowed) !== FALSE) {
      return call_user_func_array($func, $args);
    }
  }

  // Function is not allowed - report error and return FALSE.
  $msg = sprintf('allowed_functions (%s)', $func);
  return codeserver_report_error($msg, $config);
}

/*
 * Evaluate PHP code.
 *
 * $code may be an array in which case each element is evaluated in turn
 * and return values are passed back to the client as an array.
 * If the keys of $code array are strings, they are used as keys in the return array.
 * If they are numeric, the return values are discarded.
 * @todo Explain that better!
 *
 */

function codeserver_server_eval($code, $vars) {
  // Set up storage object for our local data. This avoids name conflicts with variables used in $code.
  // Name $_cs here does not confirm to Drupal coding standards - this is intentional!
  $_cs = (object) array(
    'multi' => is_array($code),
    'code' => is_array($code)? $code : array('code' => $code),
    'result' => array(),
  );

  // Extract variables form $vars.
  // Note, deliberately no name prefix here - caller may use any variable name except $_cs.
  if (is_array($vars)) {
    extract($vars);
  }

  // Loop through code to evaluate.
  foreach ($_cs->code as $_cs->item => $_cs->php) {
    // Evaluate the code...
    if (is_string($_cs->item)) {
      // Evaluate and store the result.
      $_cs->result[$_cs->item] = eval($_cs->php . ';');
    }
    else {
      // Just evaluate, discard the result.
      eval($_cs->php . ';');
    }

    // Check for parse error.
    $_cs->eval_error = error_get_last();
    if ($_cs->eval_error) {
      // Set up variables for t().
      $_cs->tvars = array(
        '!message'  => $_cs->eval_error['message'],
        '!line' => $_cs->eval_error['line'],
        '%item' => $_cs->item,
      );
      // Generate an error message.
      trigger_error( t('!message (item %item, line !line)', $_cs->tvars), E_USER_ERROR);
      // Halt processing here (just like normal PHP flow).
      break;
    }
  }
  // Return result as array or single value.
  return ($_cs->multi)? $_cs->result : $_cs->result['code'];
}

// Login (masquerade) as uid/username.
// Returns TRUE on success or FALSE on failure.
function codeserver_server_login($uid, $password, $force = FALSE) {

  // Special case, uid:0 or empty user name is invalid.
  if (empty($uid)) {
    return FALSE;
  }

  // Load user account by uid or name.
  $account = is_numeric($uid)? user_load($uid) : user_load_by_name($uid);

  // If user record was found and account is not blocked...
  if ($account && $account->status) {
    // If login forced or password (hash) is correct.
    $login_ok = ($force || $password == $account->pass);

    // If the password was not correct, assume it's the plain password, not hash.
    // Check it with user_check_password().
    if (!$login_ok) {
      // See: https://api.drupal.org/api/drupal/modules!user!user.module/function/user_authenticate/7
      // @todo Maybe use user_authenticate() instead. But that would need an extra db query.
      require_once DRUPAL_ROOT . '/' . variable_get('password_inc', 'includes/password.inc');
      $login_ok = user_check_password($password, $account);
    }
    // If login is ok, set global $user object and return TRUE.
    if ($login_ok) {
      $GLOBALS['user'] = $account;
      return TRUE;
    }
  }
  // Not logged in, return FALSE.
  return FALSE;
}

// Implement hook_permission().
function codeserver_server_permission() {
  $permissions = array();
  foreach (array_keys(codeserver_configs()) as $config_name) {
    // Get config object with default values.
    $config = codeserver_get_config($config_name);
    if ($config->require_permission) {
      $permission = 'codeserver access ' . $config->service_id;
      $permissions[$permission] = array(
        'title' => t('Access the %name service', array('%name' => $config_name)),
        'restrict access' => TRUE,
      );
    }
  }
  return $permissions;
}
