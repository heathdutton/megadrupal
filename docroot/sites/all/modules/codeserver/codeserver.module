<?php
/*
 * @file
 * Part of Code Server module for Drupal by netgenius.co.uk
 * https://www.drupal.org/project/codeserver
 *
 * This .module is intended to be compatible with D6, D7 and D8.
 * See codeserver_compat.inc for version-specific code.
 */

/*
 * CodeServerPackager class.
 */

class CodeServerPackager {

  // Initialise.
  function __construct($config) {
    $this->config = $config;
  }

  // Encode data.
  public function encode($data) {
    if ($this->config->safe_serialize) {
      $encoded_data = $this->encrypt(gzcompress($this->safe_serialize($data)));
    }
    else {
      $encoded_data = $this->encrypt(gzcompress(serialize($data)));
    }
    return $encoded_data;
  }

  // Decode data.
  public function decode($encoded_data) {
    // Decrypt and test for failure.
    $decoded_data = $this->decrypt($encoded_data);
    if ($decoded_data === FALSE) {
      return $this->report_error('decrypt');
    }

    // Uncompress and test for failure.
    $uncompressed_data = gzuncompress($decoded_data);
    if ($uncompressed_data === FALSE) {
      return $this->report_error('uncompress');
    }

    // Unserialize and test for failure.
    if ($this->config->safe_serialize) {
      $data = $this->safe_unserialize($uncompressed_data);
    }
    else {
      $data = unserialize($uncompressed_data);
    }
    if ($data === FALSE) {
      return $this->report_error('unserialize');
    }

    return $data;
  }

  // Utility to report error.
  private function report_error($msg) {
    return codeserver_report_error($msg, $this->config);
  }

  // Encrypt and encode.
  private function encrypt($data) {
    $config = $this->config;
    return openssl_encrypt($data , $config->encrypt_method, $config->encrypt_key, 0, $config->encrypt_iv);
  }

  // Decode and decrypt.
  private function decrypt($data) {
    $config = $this->config;
    return openssl_decrypt($data , $config->encrypt_method, $config->encrypt_key, 0, $config->encrypt_iv);
  }

  // History used by safe_serialize() and safe_unserialize().
  private $history;

  // Safer alternative to serialize().
  private function safe_serialize($thing) {
    $this->history = array(array());
    return json_encode($this->_safe_serialize(array($thing)));
  }

  // Safer alternative to unserialize().
  private function safe_unserialize($encoded_thing) {
    $this->history = array(array());
    $decoded = $this->_safe_unserialize(json_decode($encoded_thing, TRUE));
    return $decoded[0];
  }

  // Sub-function for safe_serialize.
  private function _safe_serialize($thing) {
    $value = array();

    foreach ($thing as $key => $child) {
      $key = rawurlencode($key);
      if (is_string($child)) {
        $value[$key] = rawurlencode($child);
      }
      elseif (!is_array($child) && !is_object($child)) {
        $value[$key] = $child;
      }
      else {
        // If $child is already in $history, use a reference to the original.
        // This is needed for objects, and can improve performance for arrays.
        if ( ($ref = array_search($child, $this->history[0], TRUE)) !== FALSE) {
          $value[$key] = array('&', $ref);
        }
        else {
          $value[$key] = $this->_safe_serialize($child);
        }
      }
    }

    // Append to $history.
    $this->history[0][] = $thing;
    return array(gettype($thing), $value);
  }

  // Sub-function for safe_unserialize.
  private function _safe_unserialize($encoded_thing) {
    // Get $type and $value
    list($type, $value) = $encoded_thing;

    $thing = array();
    foreach ($value as $key => $child) {
      $key = rawurldecode($key);
      // If a string.
      if (is_string($child)) {
        $thing[$key] = rawurldecode($child);
      }
      // Other simple type (number, etc.)
      elseif (!is_array($child)) {
        $thing[$key] = $child;
      }
      // Else, object or array.
      else {
        // Extract child type and value.
        list($child_type, $child_value) = $child;
        // If child is a reference, handle it.
        if ($child_type == '&') {
          $thing[$key] = $this->history[0][$child_value];
        }
        // Otherwise, recurse.
        else {
          $thing[$key] = $this->_safe_unserialize($child);
        }
      }
    }
    // Convert array to object if necessary. (Note, a conditional is no faster.)
    settype($thing, $type);
    // Appened to $history.
    $this->history[0][] = $thing;

    return $thing;
  }
}


/*
 * Log an error.
 * @todo Generate more complete messages, triggering on the value of $process.
 */
function codeserver_report_error($process, $config = FALSE, $type = 'error') {
  $tvars = array(
    '!codeserver' => '[CodeServer]',
    '@process' => $process,
  );
  // Format a simple message.
  $message = '!codeserver Error: @process failed.';

  // Log the message in the watchdog log.
  _codeserver_log_message($message, $tvars, $type);

  // If the user has suitable access, display the message too.
  if (codeserver_show_messages($config)) {
    codeserver_set_message($message, $tvars, $type);
  }
  // Always return FALSE so that this can be used by caller as its own return value.
  return FALSE;
}

/*
 * Determine if messages should be shown.
 */
function codeserver_show_messages($config) {
  if (isset($config->show_messages)) {
    $show_messages = ($config->show_messages === TRUE)
                  || (is_string($config->show_messages) && user_access($config->show_messages))
                  || (is_array($config->show_messages) && array_filter($config->show_messages, 'user_access') != FALSE);
  }
  // No config available - just use 'access site reports' permission.
  else {
    $show_messages = user_access('access site reports');
  }
  return $show_messages;
}

/*
 * Wrapper for drupal_set_message
 */
function codeserver_set_message($message, $tvars = array(), $type = 'status') {
  $message = t( check_plain($message), $tvars);
  drupal_set_message( filter_xss($message), $type, FALSE);
}

// Load the configuration for the given service_id, or verify a given configuration.
function codeserver_get_config($config, $mode = 'server') {

  // If $config is a string, it specifies the id of an existing config.
  if (is_string($config)) {
    $configs = codeserver_configs();
    $service_id = $config;
    $config = isset($configs[$service_id])? $configs[$service_id] : FALSE;
  }
  else {
    // $config holds the config itself.
    $service_id = isset($config['service_id'])? $config['service_id'] : '';
  }

  // Check for validity, return FALSE if invalid.
  if (!is_array($config)) {
    $msg = sprintf('get config (%s)', $service_id);
    return codeserver_report_error($msg);
  }

  // Define required items (cannot be left blank).
  $required = array(
    'encrypt_method',
    'encrypt_key',
    'encrypt_iv',
  );
  // Add further items depending on $mode (server or client).
  if ($mode == 'client' || $mode == 'both') {
    $required[] = 'server';
    $required[] = 'service_id';
  }

  // Merge defaults.
  $config += codeserver_config_defaults($mode, $service_id);

  // Check that config has all the $required items.
  $failed = FALSE;
  foreach ($required as $item) {
    if (empty($config[$item])) {
      $msg = sprintf('config required (%s: %s)', $service_id, $item);
      codeserver_report_error($msg);
      $failed = TRUE;
    }
  }

  // Return config as an object.
  return ($failed)? FALSE : (object) $config;
}

// Get default configuration values.
function codeserver_config_defaults($mode, $service_id = '') {

  // Common defaults.
  $defaults = array(
    'service_id' => $service_id,
    'service_name' => $service_id,
    'service_enabled' => TRUE,
    'show_messages' => TRUE,
    //'show_messages' => 'access content',
    //'show_messages' => array('access content', 'something else'),
    'safe_serialize' => TRUE,
    'encrypt_method' => 'AES256',
    'encrypt_key' => '',
    'encrypt_iv' => '',
  );

  // Add further items depending on $mode (server or client).
  if ($mode == 'client' || $mode == 'both') {
    $defaults += array(
      'server' => $GLOBALS['base_url'],
      'request_timeout' => 10,
      'options' => array(),
    );
  }

  if ($mode == 'server' || $mode == 'both') {
    $defaults += array(
      'allowed_ips' => array('127.0.0.1'),
      'allowed_functions' => array('codeserver_test'),
      'require_permission' => FALSE,
      'allow_login' => FALSE,
      'set_uid' => 0,
    );
  }

  return $defaults;
}

// Load/save all configurations.
function codeserver_configs($save_configs = FALSE) {
  static $configs;

  // If $config is already cached, just return it.
  if ($save_configs === FALSE && isset($configs)) {
    return $configs;
  }

  // Make sure the compatibility include file is loaded.
  module_load_include('inc', 'codeserver', 'codeserver_compat');

  // Set up a packager to encode/decode the configs.
  // For a little extra security, configs are not stored in plaintext in the db.
  // But of course, anyone with full access to the db can still decrypt them.
  $key = drupal_get_private_key();
  $pconfig = (object) array(
    'encrypt_method' => 'AES256',
    'encrypt_key' => substr($key, 0, 16),
    'encrypt_iv' => substr($key, -16),
    'safe_serialize' => FALSE,
  );
  $packager = new CodeServerPackager($pconfig);
  $varname = 'codeserver_configs';

  // Load configs.
  if ($save_configs === FALSE) {
    $configs = variable_get($varname, '');
    // Decode configs (encode and save old configs).
    if (!$configs) {
      $configs = array();
    }
    else {
      $configs = is_string($configs)? $packager->decode($configs) : codeserver_configs($configs);
    }
  }
  // Save configs.
  else {
    $configs = $save_configs;
    if (empty($configs)) {
      variable_del($varname);
    }
    else {
      variable_set($varname, $packager->encode($configs));
    }
  }
  return $configs;
}

// A basic test.
// Use, for example, to check that codeserver_test() == $remote->codeserver_test().
function codeserver_test($something = 12345) {
  return $something;
}

