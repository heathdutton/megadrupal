<?php

/**
 * @file
 * Cultura answer aggregation from completed questionnaires.
 */

/**
 * Define constant for status of Questionnaire builder with aggregated answers.
 */
define('CULTURA_ANSWER_QUESTIONNAIRE_BUILDER_ANSWERS_AGGREGATED', 2);

/**
 * Define constant for status of Questionnaire builder with published answers.
 */
define('CULTURA_ANSWER_QUESTIONNAIRE_BUILDER_ANSWERS_PUBLISHED', 3);

/**
 * Implements hook_block_info().
 */
function cultura_answer_block_info() {
  $blocks = array();

  $blocks['aggregate'] = array(
    'info' => t('Aggregate answers to questionnaires'),
    'cache' => DRUPAL_NO_CACHE,
  );

  $blocks['publish'] = array(
    'info' => t('Publish aggregated answers'),
    'cache' => DRUPAL_NO_CACHE,
  );

  $blocks['studentprogress'] = array(
    'info' => t('Student progress in answering questionnaires'),
    'cache' => DRUPAL_NO_CACHE,
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function cultura_answer_block_view($delta) {
  switch ($delta) {
    case 'aggregate':
      return cultura_answer_aggregate_block();

    case 'publish':
      return cultura_answer_publish_block();

    case 'studentprogress':
      return cultura_answer_student_progress_block();

  }
}

/**
 * Returns block of questionnaires and count of answers ready to be aggregated.
 *
 * Aggregation turns off the associated questionnaire webforms.
 */
function cultura_answer_aggregate_block() {
  $block['subject'] = t('Aggregate responses to questionnaires');
  $block['content'] = drupal_get_form('cultura_answer_aggregate_form');
  return $block;
}

/**
 * Returns block of aggregated answers ready to be published.
 */
function cultura_answer_publish_block() {
  $block['subject'] = t('Publish aggregated answers');
  $block['content'] = drupal_get_form('cultura_answer_publish_form');
  return $block;
}

/**
 * Form constructor to aggregate answers.
 *
 * @see cultura_answer_aggregate_form_submit()
 *
 * @ingroup forms
 */
function cultura_answer_aggregate_form() {
  $form = array();
  $form['#description'] = t('Aggregate answers when when all questionnaire webforms are submitted.');
  $unpublished = cultura_questionnaire_unpublished();
  if ($unpublished) {
    $form['unpublished'] = array(
      '#title' => t('Not-yet-published questionnaire pairs'),
      '#type' => 'radios',
      '#options' => cultura_answer_nodes_to_form_options($unpublished),
      '#disabled' => TRUE,
      '#description' => t('Press links above to edit and publish each pair of questionnaires.'),
    );
  }
  $unanswered = cultura_questionnaire_unanswered();
  if ($unanswered) {
    $form['no_answers'] = array(
      '#title' => t('Published questionnaire pairs with no responses yet'),
      '#type' => 'radios',
      '#options' => cultura_answer_nodes_to_form_options($unanswered),
      '#disabled' => TRUE,
    );
  }
  $answered = cultura_questionnaire_answered();
  if ($answered) {
    $form['options'] = array(
      '#title' => t('Published Questionnaires with at least some responses'),
      '#type' => 'radios',
      '#options' => cultura_answer_nodes_to_form_options($answered),
    );
    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Aggregate'),
      '#access' => user_access('publish button publish any cultura_questionnaire_builder'),
    );
  }
  else {
    $message = '';
    if ($unpublished) {
      $message .= t('Questionnaires must be published before students can provide answers to be aggregated.  Use links to not-yet-published questionnaire pairs above to edit and publish.');
    }
    if ($unanswered) {
      $message .= ' ' . t('Questionnaires must have responses before the answers can be aggregated. You can track student progress in the "Student progress in answering questionnaires" block to the right.');
    }
    if (!$message && !$unanswered) {
      $message = t('All responses are aggregated.');
    }
    // Message styling stolen from theme_status_messages().
    $output = "<div class=\"messages warning\">\n";
    $output .= '<h2 class="element-invisible">' . t('Warning message') . "</h2>\n";
    $output .= $message;
    $output .= "</div>\n";
    $form['nooptions']['#markup'] = $output;
  }
  return $form;
}

/**
 * Form constructor to publish answers.
 *
 * @see cultura_answer_publish_form_submit()
 *
 * @ingroup forms
 */
function cultura_answer_publish_form() {
  $form = array();
  $aggregated = cultura_answer_questionnaire_aggregated();
  if ($aggregated) {
    $form['options'] = array(
      '#title' => t('Aggregated answers ready to be published'),
      '#type' => 'radios',
      '#options' => cultura_answer_nodes_to_form_options($aggregated),
    );
    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Publish'),
      '#access' => user_access('publish button publish any cultura_questionnaire_builder'),
    );
  }
  else {
    $message = t('Questionnaire responses must be aggregated before they can be published.  After aggregating, take the opportunity to copy-edit answers before publishing.');
    // Message styling stolen from theme_status_messages().
    $output = "<div class=\"messages warning\">\n";
    $output .= '<h2 class="element-invisible">' . t('Warning message') . "</h2>\n";
    $output .= $message;
    $output .= "</div>\n";
    $form['nooptions']['#markup'] = $output;
  }
  return $form;
}

/**
 * Return Questionnaire builder nodes of questionnaires with aggregated answers.
 */
function cultura_answer_questionnaire_aggregated() {
  $nodes = array();
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', CULTURA_QUESTIONNAIRE_BUILDER_NODE_TYPE)
    ->propertyCondition('status', CULTURA_ANSWER_QUESTIONNAIRE_BUILDER_ANSWERS_AGGREGATED);
  $result = $query->execute();
  if (isset($result['node'])) {
    $node_ids = array_keys($result['node']);
    $nodes = entity_load('node', $node_ids);
  }
  return $nodes;
}

/**
 * Form submission handler for cultura_answer_aggregate_form().
 *
 * @see cultura_answer_aggregate_form()
 */
function cultura_answer_aggregate_form_submit($form, &$form_state) {
  $nid = $form_state['values']['options'];
  $questionnaire_builder = node_load($nid);
  drupal_set_message('Aggregating ' . $questionnaire_builder->title . '...');
  cultura_answer_compile_answers($questionnaire_builder);
}

/**
 * Form submission handler for cultura_answer_publish_form().
 *
 * @see cultura_answer_publish_form()
 */
function cultura_answer_publish_form_submit($form, &$form_state) {
  $nid = $form_state['values']['options'];
  $questionnaire_builder = node_load($nid);
  drupal_set_message('Publishing ' . $questionnaire_builder->title . '...');
  cultura_answer_publish_answers($questionnaire_builder);
}

/**
 * Returns student progress block showing who answered questionnaires.
 */
function cultura_answer_student_progress_block() {
  $block['subject'] = t('Student progress answering questionnaires');
  $results = cultura_questionnaire_all_students_with_answers_by_language_and_count();
  $content = array();
  foreach ($results as $language => $counts) {
    $content[strtolower($language)] = array();
    $fieldset =& $content[strtolower($language)];
    $fieldset = array(
      '#type' => 'fieldset',
      '#title' => $language,
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
    );
    foreach ($counts as $count => $accounts) {
      $fieldset[$count] = array();
      $list =& $fieldset[$count];
      $list['#theme'] = 'item_list';
      $list['#title'] = t('Students who have completed @count questionnaires',
        array('@count' => $count));
      $items = array();
      foreach ($accounts as $account) {
        $items[] = array(
          'data' => l($account->name, 'user/' . $account->uid),
        );
      }
      $list['#items'] = $items;
    }
  }
  // If no results, provide a brief message instead.
  if (!$content) {
    $content['#markup'] = t('No students have responded to a questionnaire yet.');
  }
  $block['content'] = $content;
  return $block;
}

/**
 * Produces unpublished discussion nodes from the compiled results of webforms.
 *
 * The Questionnaire builder consists of paired prompts, one for each language,
 * which produce two Questionnaire webforms, one for each language.  The results
 * for each language are brought back together into columns of the Answer double
 * field placed on Discussion nodes, with one node for each pair of prompts from
 * the original Questionnaire builder node.
 */
function cultura_answer_compile_answers($questionnaire_builder) {
  $questionnaire_webforms = cultura_questionnaire_webforms($questionnaire_builder);
  $answers = cultura_answer_aggregate_webform_responses($questionnaire_webforms);
  $discussions = cultura_answer_create_discussions($questionnaire_builder, $answers);
  $questionnaire_builder->status = CULTURA_ANSWER_QUESTIONNAIRE_BUILDER_ANSWERS_AGGREGATED;
  node_save($questionnaire_builder);
  cultura_answer_unpublish($questionnaire_webforms);
}

/**
 * Aggregate responses to a pair of Questionnaire webforms grouped by prompt.
 *
 * @param array $webforms
 *   The two Questionnaire webform objects.
 *
 * @return array
 *   An array of answers by component and language.
 */
function cultura_answer_aggregate_webform_responses($webforms) {
  $answers = array();
  foreach ($webforms as $webform) {
    // Get language for webform.
    $items = field_get_items('node', $webform, CULTURA_QUESTIONNAIRE_FIELD_LANGUAGE);
    $language = $items[0]['tid'];
    // Get submissions for webform.
    $submissions = cultura_answer_gather_webform_submissions($webform->nid);
    if (empty($submissions)) {
      continue;
    }
    // Get components for webform and use to build a submissions array.
    $components = $webform->webform['components'];
    foreach ($components as $component) {
      $cid = $component['cid'];
      $component_key = $component['form_key'];
      $component_name = $component['name'];
      $answers[$component_key][$language] = array(
        'prompt' => $component_name,
        'responses' => $submissions[$cid],
      );
    }
  }
  return $answers;
}

/**
 * Returns an array of all webform submissions, grouped by component id.
 */
function cultura_answer_gather_webform_submissions($nid) {
  $responses = array();
  // Specific submission ID.  Useless.
  // webform_get_submission($nid, $sid);
  module_load_include('inc', 'webform', 'includes/webform.submissions');
  $submissions = webform_get_submissions($nid);
  foreach ($submissions as $submission) {
    foreach ($submission->data as $cid => $data) {
      $responses[$cid][] = $data[0];
    }
  }
  return $responses;
}

/**
 * Formats an array of node objects suitable for radio button options.
 */
function cultura_answer_nodes_to_form_options($nodes) {
  $options = array();
  foreach ($nodes as $node) {
    $options[$node->nid] = l($node->title, 'node/' . $node->nid . '/edit');
    if (isset($node->cultura_answers)) {
      $options[$node->nid] .= ' ' . t('(@number responses)', array('@number' => $node->cultura_answers));
    }
  }
  return $options;
}

/**
 * Creates discussion nodes from answer array, questionnaire builder node.
 *
 * @see cultura_answer_compile_answers().
 */
function cultura_answer_create_discussions($questionnaire_builder, $answers, $account = NULL) {
  if (!$account) {
    $account = $GLOBALS['user'];
  }

  // Set node fields and properties shared among all discussions we will create.
  $node = new stdClass();
  $node->type = CULTURA_DISCUSSION_NODE_TYPE;
  // This sets the node object with the correct defaults for the node type.
  node_object_prepare($node);
  // Associate each discussion with the creating questionnaire builder node.
  // CULTURA_QUESTIONNAIRE_FIELD_QUESTIONNAIRE
  $node->cultura_questionnaire[LANGUAGE_NONE][0]['nid'] = $questionnaire_builder->nid;
  /*
  $intros = field_get_items('node', $questionnaire_builder, CULTURA_QUESTIONNAIRE_FIELD_INTROS);
  $body = $intros[0]['first'];
  $body .= ' / ';
  $body .= $intros[0]['second'];
  // Add body (introduction) field.
  $node->body[LANGUAGE_NONE][0] = array(
    'value' => $body,
    'summary' => '',
    'format' => 'full_html',
  );
   */
  // Record the question type for this discussion.
  $items = field_get_items('node', $questionnaire_builder, CULTURA_QUESTIONNAIRE_FIELD_QUESTION_TYPE);
  $question_term = ($items) ? taxonomy_term_load($items[0]['tid']) : FALSE;
  // CULTURA_QUESTIONNAIRE_FIELD_QUESTION_TYPE
  $node->cultura_question_type[LANGUAGE_NONE][0]['tid'] = $question_term->tid;
  $node->language = LANGUAGE_NONE;
  $node->uid = $account->uid;
  $node->status = NODE_NOT_PUBLISHED;

  foreach ($answers as $pair) {
    // Branch off the common elements of the node built so far.
    $discussion = clone $node;
    // Reset the title, which uses elements of both primary and secondary
    // languages (the tid below in each pair)
    $title = '';
    foreach ($pair as $tid => $result) {
      $output = '<ul>' . "\n";
      $responses = $result['responses'];
      natcasesort($responses);
      foreach ($responses as $response) {
        $output .= '<li>';
        $output .= $response;
        $output .= '</li>' . "\n";
      }
      $output .= '</ul>';
      if ($tid == variable_get(CULTURA_QUESTIONNAIRE_LANGUAGE_PRIMARY_TID)) {
        $column = 'first';
        $separator = ' / ';
      }
      elseif ($tid == variable_get(CULTURA_QUESTIONNAIRE_LANGUAGE_SECONDARY_TID)) {
        $column = 'second';
        $separator = '';
      }
      else {
        watchdog('cultura_answer', 'Unknown taxonomy term id :tid (does not match primary language term id, :ptid, nor secondary language term id, :stid.', array(
          ':tid' => $tid,
          ':ptid' => variable_get(CULTURA_QUESTIONNAIRE_LANGUAGE_PRIMARY_TID),
          ':stid' => variable_get(CULTURA_QUESTIONNAIRE_LANGUAGE_SECONDARY_TID),
        ), WATCHDOG_ALERT);
      }
      // 'CULTURA_QUESTIONNAIRE_FIELD_PROMPTS', 'cultura_questionnaire_prompts'
      $discussion->cultura_questionnaire_prompts[LANGUAGE_NONE][0][$column] = $result['prompt'];
      // 'CULTURA_DISCUSSION_FIELD_ANSWERS', 'cultura_discussion_answers'
      $discussion->cultura_discussion_answers[LANGUAGE_NONE][0][$column] = $output;
      $title .= truncate_utf8($result['prompt'], 110, TRUE, TRUE, 10);
      $title .= $separator;
    }
    $discussion->title = $title;

    // Save the discussion node.
    $discussions[] = node_save($discussion);
  }
}

/**
 * Publish answers (discussion nodes) associated with a Questionnaire builder.
 */
function cultura_answer_publish_answers($questionnaire_builder) {
  $discussions = cultura_answer_discussions($questionnaire_builder);
  foreach ($discussions as $discussion) {
    $discussion->status = NODE_PUBLISHED;
    node_save($discussion);
  }
  drupal_set_message(t('@count discussions published.', array(
    '@count' => count($discussions),
  )), 'success');
  $questionnaire_builder->status = CULTURA_ANSWER_QUESTIONNAIRE_BUILDER_ANSWERS_PUBLISHED;
  node_save($questionnaire_builder);
}

/**
 * Return all discussions for a given Questionnaire builder.
 *
 * Gather the discussions holding the answer results of questionnaires created
 * by the given Questionnaire builder node.
 */
function cultura_answer_discussions($questionnaire_builder) {
  $nodes = array();
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', CULTURA_DISCUSSION_NODE_TYPE)
    ->fieldCondition(CULTURA_QUESTIONNAIRE_FIELD_QUESTIONNAIRE, 'nid', $questionnaire_builder->nid);
  $result = $query->execute();
  if (isset($result['node'])) {
    $node_ids = array_keys($result['node']);
    $nodes = entity_load('node', $node_ids);
  }
  return $nodes;
}

/**
 * Unpublish each node in a given array of nodes.
 */
function cultura_answer_unpublish($nodes) {
  foreach ($nodes as $node) {
    $node->status = NODE_NOT_PUBLISHED;
    node_save($node);
  }
}