<?php
/**
 * @file
 * This module stores taxonomies as nested intervals.
 *
 * @todo Handle potential race condition on insert when determining insertion point
 * @todo Locate gap when inserting first sibling
 * @todo Improve deferred sort (re-sort only relevant nodes as opposed to a complete rebuild).
 */

// Put on your digits and scale the night away ...
define('TAXONOMY_NESTED_INTERVALS_FACTOR', '10000000000000000000');

// Scale (add gaps for less frequent sibling push and tree rebuilding).
define('TAXONOMY_NESTED_INTERVALS_SCALE', 1);

// Number of decimals for big numbers.
define('TAXONOMY_NESTED_INTERVALS_DECIMALS', 30);

// Method for generating fractions (Tropashko vs Hazel, defaults to Hazel).
define('TAXONOMY_NESTED_INTERVALS_CLASS', FALSE);

// Default sort method.
define('TAXONOMY_NESTED_INTERVALS_SORT', 1);

// Sort methods.
define('TAXONOMY_NESTED_INTERVALS_SORT_NONE', 0);
define('TAXONOMY_NESTED_INTERVALS_SORT_ALWAYS', 1);
define('TAXONOMY_NESTED_INTERVALS_SORT_DEFER', 2);

// Whether or not to ensure correct sibling enumeration when rebuilding tree.
define('TAXONOMY_NESTED_INTERVALS_REBUILD_SAFE_SIBLING', FALSE);

// Override term pages.
define('TAXONOMY_NESTED_INTERVALS_OVERRIDE_TERM_PAGES', FALSE);

// Default delete chunk size.
define('TAXONOMY_NESTED_INTERVALS_DELETE_CHUNKSIZE', 0);

require_once 'MatrixTree.class.php';

// ---------- HOOKS ----------

/**
 * Implements hook_cron().
 */
function taxonomy_nested_intervals_cron() {
  $vids = array();
  module_load_include('rebuild.inc', 'taxonomy_nested_intervals');
  foreach (taxonomy_get_vocabularies() as $vocabulary) {
    if (variable_get('taxonomy_nested_intervals_invalid_' . $vocabulary->vid)) {
      $vids[] = $vocabulary->vid;
    }
  }
  if ($vids) {
    taxonomy_nested_intervals_rebuild_batch($vids);
    $batch = &batch_get();
    $batch['progressive'] = FALSE;
    batch_process();
  }
}

/**
 * Implements hook_help().
 */
function taxonomy_nested_intervals_help($section) {
  switch ($section) {
    case 'admin/help#taxonomy_nested_intervals':
      // Return a line-break version of the module README.txt.
      return check_markup(file_get_contents(dirname(__FILE__) . "/README.txt"));
  }
}

/**
 * Implements hook_perm().
 */
function taxonomy_nested_intervals_permission() {
  return array(
    'administer taxonomy nested intervals' => array(
      'title' => t('Administer Taxonomy Nested Intervals'),
      'description' => t('Perform administration tasks for Taxonomy Nested Intervals.'),
    )
  );
}

/**
 * Implements hook_menu().
 */
function taxonomy_nested_intervals_menu() {
  $items = array();

  // Settings page.
  $items['admin/structure/taxonomy/nested_intervals'] = array(
    'title'            => 'Nested Intervals',
    'description'      => 'Administer taxonomy nested intervals',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('taxonomy_nested_intervals_settings_form'),
    'access arguments' => array('administer taxonomy nested intervals'),
    'type'             => MENU_LOCAL_TASK,
    'file'             => 'taxonomy_nested_intervals.admin.inc'
  );

  return $items;
}

/**
 * Load taxonomy nested intervals "fields" for a vocabulary.
 */
function taxonomy_nested_intervals_load_fields($vid = NULL) {
  $defaults = $fields = array(
    'class' => variable_get("taxonomy_nested_intervals_class", TAXONOMY_NESTED_INTERVALS_CLASS),
    'scale' => variable_get("taxonomy_nested_intervals_scale", TAXONOMY_NESTED_INTERVALS_SCALE),
    'factor' => variable_get("taxonomy_nested_intervals_factor", TAXONOMY_NESTED_INTERVALS_FACTOR),
    'sort' => variable_get("taxonomy_nested_intervals_sort", TAXONOMY_NESTED_INTERVALS_SORT),
  );
  if ($vid) {
    $fields = variable_get("taxonomy_nested_intervals_$vid", $defaults);
  }
  $fields += $defaults;
  return $fields;
}

/**
 * Implements hook_taxonomy_vocabulary_load().
 */
function taxonomy_nested_intervals_taxonomy_vocabulary_load($vocabularies) {
  foreach ($vocabularies as $vocabulary) {
    $vocabulary->taxonomy_nested_intervals = taxonomy_nested_intervals_load_fields($vocabulary->vid);
  }
}

/**
 * Implements hook_taxonomy_vocabulary_insert().
 */
function taxonomy_nested_intervals_taxonomy_vocabulary_insert($vocabulary) {
  $vid = $vocabulary->vid;
  if (empty($vocabulary->taxonomy_nested_intervals)) {
    $vocabulary->taxonomy_nested_intervals = taxonomy_nested_intervals_load_fields();
  }
  variable_set("taxonomy_nested_intervals_$vid", $vocabulary->taxonomy_nested_intervals);
  // Rebuild of intervals is needed.
  if ($vocabulary->taxonomy_nested_intervals['class']) {
    variable_set("taxonomy_nested_intervals_invalid_$vid", 1);
  }
}

/**
 * Implements hook_taxonomy_vocabulary_update().
 */
function taxonomy_nested_intervals_taxonomy_vocabulary_update($vocabulary) {
  $vid = $vocabulary->vid;
  $current = taxonomy_nested_intervals_load_fields($vid);
  if (empty($vocabulary->taxonomy_nested_intervals)) {
    $vocabulary->taxonomy_nested_intervals = $current;
  }
  variable_set("taxonomy_nested_intervals_$vid", $vocabulary->taxonomy_nested_intervals);
  if (
    // Rebuild of intervals is needed.
    $vocabulary->taxonomy_nested_intervals['class'] &&
    (
      $vocabulary->taxonomy_nested_intervals['class'] !== $current['class'] ||
      $vocabulary->taxonomy_nested_intervals['scale'] !== $current['scale'] ||
      $vocabulary->taxonomy_nested_intervals['sort'] !== $current['sort']
    )
  ) {
    variable_set("taxonomy_nested_intervals_invalid_$vid", 1);
  }
  elseif (
    // Rebuild of left/right values is needed.
    $vocabulary->taxonomy_nested_intervals['class'] &&
    $vocabulary->taxonomy_nested_intervals['factor'] !== $current['factor']
  ) {
    variable_set("taxonomy_nested_intervals_invalid_$vid", 2);
  }
}

/**
 * Implements hook_menu_alter().
 */
function taxonomy_nested_intervals_menu_alter(&$items) {
  // Bring /level and /all back into taxonomy pages and feeds.
  if (variable_get('taxonomy_nested_intervals_override_term_pages')) {
    $items['taxonomy/term/%taxonomy_term'] = array(
      'title' => 'Taxonomy term',
      'title callback' => 'taxonomy_term_title',
      'title arguments' => array(2),
      'page callback' => 'taxonomy_nested_intervals_term_page',
      'page arguments' => array(2, 3),
      'access arguments' => array('access content'),
      'file' => 'taxonomy_nested_intervals.pages.inc',
      'module' => 'taxonomy_nested_intervals',
    );
    $items['taxonomy/term/%taxonomy_term/%/feed'] = array(
      'title' => 'Taxonomy term',
      'title callback' => 'taxonomy_term_title',
      'title arguments' => array(2),
      'page callback' => 'taxonomy_nested_intervals_term_feed',
      'page arguments' => array(2, 3),
      'access arguments' => array('access content'),
      'file' => 'taxonomy_nested_intervals.pages.inc',
      'module' => 'taxonomy_nested_intervals',
    );
  }
}

/**
 * Implements hook_form_N_alter().
 */
function taxonomy_nested_intervals_form_taxonomy_form_vocabulary_alter(&$form, &$form_state) {
  if (!empty($form_state['input']['op'])) {
    if (
      $form_state['input']['op'] !== t('Save') &&
      $form_state['input']['op'] !== t('Save and rebuild intervals')
    ) {
      return;
    }
  }

  $vocabulary = $form_state['vocabulary'];
  if (!isset($vocabulary->taxonomy_nested_intervals)) {
    $vocabulary->taxonomy_nested_intervals = taxonomy_nested_intervals_load_fields();
  }
  $class = $vocabulary->taxonomy_nested_intervals['class'];
  $scale = $vocabulary->taxonomy_nested_intervals['scale'];
  $factor = $vocabulary->taxonomy_nested_intervals['factor'];
  $sort = $vocabulary->taxonomy_nested_intervals['sort'];
  $form['taxonomy_nested_intervals'] = array(
    '#title' => t('Nested Intervals'),
    '#type' => 'fieldset',
    '#tree' => TRUE,
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $form['taxonomy_nested_intervals']['class'] = array(
    '#title' => t('Encoding'),
    '#description' => t('Method of encoding'),
    '#type' => 'select',
    '#default_value' => $class,
    '#options' => array(
      0 => t('None'),
      'MatrixTreeTropashko' => t('Tropashko (defered sorted, space efficient)'),
      'MatrixTreeHazel' => t('Hazel (sorted, less space efficient, simpler, marginally faster)'),
    )
  );
  $form['taxonomy_nested_intervals']['sort_matrixtreetropashko'] = array(
    '#title' => t('Sorting'),
    '#description' => t('Sorting method.'),
    '#type' => 'select',
    '#default_value' => $sort,
    '#options' => array(
      TAXONOMY_NESTED_INTERVALS_SORT_NONE => t('None'),
      TAXONOMY_NESTED_INTERVALS_SORT_DEFER => t('Defer'),
    ),
    '#states' => array(
      'visible' => array(':input[name="taxonomy_nested_intervals[class]"]' => array('value' => 'MatrixTreeTropashko')),
    ),
  );
  $form['taxonomy_nested_intervals']['sort_matrixtreehazel'] = array(
    '#title' => t('Sorting'),
    '#description' => t('Sorting method.'),
    '#type' => 'select',
    '#default_value' => $sort,
    '#options' => array(
      TAXONOMY_NESTED_INTERVALS_SORT_NONE => t('None'),
      TAXONOMY_NESTED_INTERVALS_SORT_ALWAYS => t('Always'),
      TAXONOMY_NESTED_INTERVALS_SORT_DEFER => t('Defer'),
    ),
    '#states' => array(
      'visible' => array(':input[name="taxonomy_nested_intervals[class]"]' => array('value' => 'MatrixTreeHazel')),
    ),
  );
  $form['taxonomy_nested_intervals']['scale'] = array(
    '#title' => t('Scale'),
    '#type' => 'textfield',
    '#description' => t('Scale factor for siblings. Creates gaps between siblings which can help speed up tree update operations.'),
    '#default_value' => $scale,
    '#states' => array(
      'invisible' => array(':input[name="taxonomy_nested_intervals[class]"]' => array('value' => '0')),
    ),
  );
  $form['taxonomy_nested_intervals']['factor'] = array(
    '#title' => t('Factor'),
    '#description' => t('Scale factor for left/right values. Use low value for small trees with large depth and large values for trees large trees with small depth.'),
    '#type' => 'textfield',
    '#default_value' => $factor,
    '#states' => array(
      'invisible' => array(':input[name="taxonomy_nested_intervals[class]"]' => array('value' => '0')),
    ),
  );
  $form['actions']['taxonomy_nested_intervals_rebuild'] = array(
    '#type' => 'submit',
    '#value' => t('Save and rebuild intervals'),
    '#states' => array(
      'invisible' => array(':input[name="taxonomy_nested_intervals[class]"]' => array('value' => 0)),
    ),
  );

  array_unshift($form['#submit'], 'taxonomy_nested_intervals_form_taxonomy_form_vocabulary_alter_submit_pre');
  $form['#submit'][] = 'taxonomy_nested_intervals_form_taxonomy_form_vocabulary_alter_submit';
}

/**
 * Submit handler: Save vocabulary based nested intervals settings.
 */
function taxonomy_nested_intervals_form_taxonomy_form_vocabulary_alter_submit_pre($form, &$form_state) {
  $vocabulary = $form_state['vocabulary'];
  $form_state['values']['taxonomy_nested_intervals']['sort'] = TAXONOMY_NESTED_INTERVALS_SORT_NONE;
  if ($vocabulary) {
    if (!empty($form_state['values']['taxonomy_nested_intervals']['class'])) {
      $form_state['values']['taxonomy_nested_intervals']['sort'] = $form_state['values']['taxonomy_nested_intervals']['sort_' . strtolower($form_state['values']['taxonomy_nested_intervals']['class'])];
    }
  }
}

/**
 * Submit handler: Rebuild nested intervals if necessary.
 */
function taxonomy_nested_intervals_form_taxonomy_form_vocabulary_alter_submit($form, &$form_state) {
  $vocabulary = $form_state['vocabulary'];
  $vid = $vocabulary->vid;

  if ($form_state['triggering_element']['#value'] == $form_state['values']['taxonomy_nested_intervals_rebuild']) {
    $rebuild = 1;
  }
  else {
    $rebuild = variable_get("taxonomy_nested_intervals_invalid_$vid");
  }

  switch ($rebuild) {
    case 1:
      module_load_include('rebuild.inc', 'taxonomy_nested_intervals');
      taxonomy_nested_intervals_rebuild_batch(array($vid));
      break;

    case 2:
      module_load_include('rebuild.inc', 'taxonomy_nested_intervals');
      // Rebuild left/right values.
      $batch = array(
        'finished' => 'taxonomy_nested_intervals_rebuild_finished',
        'file' => drupal_get_path('module', 'taxonomy_nested_intervals') . '/taxonomy_nested_intervals.rebuild.inc',
        'title' => t('Rebuilding taxonomy nested intervals'),
        'init_message' => t('Rebuilding taxonomy nested intervals'),
      );
      $batch['operations'][] = array('taxonomy_nested_intervals_rebuild_left_right', array($vid));
      batch_set($batch);
      break;

  }
  return;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Override submit handler for overview terms form,
 * in order to support update of nested intervals
 * when changing order of terms.
 */
function taxonomy_nested_intervals_form_taxonomy_overview_terms_alter(&$form, &$form_state) {
  $vid = empty($form['#vocabulary']->vid) ? (empty($form['vid']['#value']) ? NULL : $form['vid']['#value']) : $form['#vocabulary']->vid;
  if (!$vid) {
    return;
  }
  if (!taxonomy_nested_intervals_get_option($vid, 'enabled')) {
    return;
  }

  $form['#submit'] = empty($form['#submit']) ? array() : $form['#submit'];
  $form['#submit'][] = 'taxonomy_nested_intervals_overview_terms_submit';
}

/**
 * Submit handler for terms overview form.
 *
 * Rebuild nested intervals completely when changing order.
 */
function taxonomy_nested_intervals_overview_terms_submit($form, &$form_state) {
  if ($form_state['rebuild']) {
    return;
  }
  $vid = empty($form['#vocabulary']->vid) ? (empty($form['vid']['#value']) ? NULL : $form['vid']['#value']) : $form['#vocabulary']->vid;

  if ($vid) {
    module_load_include('rebuild.inc', 'taxonomy_nested_intervals');
    taxonomy_nested_intervals_rebuild_batch(array($vid));
  }
}

/**
 * Implements hook_taxonomy_term_insert().
 */
function taxonomy_nested_intervals_taxonomy_term_insert($term) {
  if (!taxonomy_nested_intervals_get_option($term->vid, 'enabled')) {
    return;
  }
  $parents = _taxonomy_nested_intervals_unify_parents($term->parent);
  if ($parents) {
    $tx = db_transaction();
    foreach ($parents as $parent) {
      // Find insertion points.
      $points = _taxonomy_nested_intervals_find_insertion_points($term, $parent);

      if (empty($points)) {
        // If no points located, tree must be invalid ... rebuild?
        watchdog('taxonomy_nested_intervals', 'Tree for vocabulary: @vid is invalid', array('@vid' => $term->vid), WATCHDOG_ERROR);
        break;
      }

      // Insert the new points.
      foreach ($points as $point) {
        // Make sure $point fits into the tree.
        _taxonomy_nested_intervals_make_space($term->vid, $point['matrix']);

        // Insert the new path.
        $new_term = $term;
        $new_term->parent = $parent;
        _taxonomy_nested_intervals_insert_path($point['matrix'], $new_term);
      }
    }
    unset($tx);
  }
}

/**
 * Implements hook_taxonomy_term_update().
 */
function taxonomy_nested_intervals_taxonomy_term_update($term) {
  if (!taxonomy_nested_intervals_get_option($term->vid, 'enabled')) {
    return;
  }
  $class = taxonomy_nested_intervals_get_option($term->vid, 'class');
  $factor = taxonomy_nested_intervals_get_option($term->vid, 'factor');

  if (!isset($term->parent)) {
    // Parent not set, no need to update hierarchy.
    return;
  }

  // Derive proper parents.
  $parents = _taxonomy_nested_intervals_unify_parents($term->parent);

  // Begin transaction.
  $tx = db_transaction();

  // Get tree node info for the term (gives us its old parents and points).
  $old_points = db_select('taxonomy_nested_intervals', 'i')
    ->fields('i', array('id', 'lft', 'rgt', 'nv', 'dv', 'snv', 'sdv'))
    ->condition('i.tid', $term->tid)
    ->orderBy('i.lft', 'ASC')
    ->execute()
    ->fetchAllAssoc('lft', PDO::FETCH_ASSOC);

  // Locate new insertion points in tree.
  $new_points = array();
  foreach ($parents as $parent) {
    // Find insertion points.
    $new_points = array_merge($new_points, _taxonomy_nested_intervals_find_insertion_points($term, $parent));
  }


  // Intersect old and new points to determine which points should respectively deleted, moved or added.
  $del_points = $old_points;
  foreach ($del_points as &$point) {
    $point['matrix'] = $class::createFromAssoc($point);
  }

  $add_points = array();
  foreach ($new_points as &$point) {
    $lft = $point['lft'] = $point['matrix']->getLeft($factor);
    if (isset($del_points[$lft])) {
      unset($del_points[$lft]);
    }
    else {
      $add_points[$lft] = $point;
    }
  }
  $mov_points = array();
  reset($del_points);
  reset($add_points);
  while ($del_points && $add_points) {
    $mov_points[] = array(array_shift($del_points), array_shift($add_points));
  }

  // First we delete the ones that needs to be deleted. That will clear some space in tree, and if we're
  // lucky we don't need to push any siblings because of the gaps it will make.
  foreach ($del_points as $point) {
    $lft = $point['lft'];
    $rgt = $point['rgt'];
    db_query("DELETE FROM {taxonomy_nested_intervals} WHERE vid = :vid AND lft >= $lft AND lft < $rgt", array(
      ':vid' => $term->vid,
    ));
  }

  // Then we move the ones we can move (moving instead of delete/add saves us of some index re-calculation in the db).
  foreach ($mov_points as $mov_point) {
    $src = $mov_point[0];
    $dst = $mov_point[1];

    _taxonomy_nested_intervals_make_space($term->vid, $dst['matrix']);

    // Let's derive the delta depth.
    $delta_depth = $dst['matrix']->getDepth() - $src['matrix']->getDepth();

    // $matrices contain the new parent.
    $matrix = $src['matrix']->relocate($dst['matrix']);

    // Do the locomotion ...
    _taxonomy_nested_intervals_transform_paths($matrix, $delta_depth, $term->vid, $src['lft'], $src['rgt']);
    db_update('taxonomy_nested_intervals')
      ->fields(array(
        'parent' => $dst['parent']
      ))
      ->condition('id', $src['id'])
      ->execute();
  }

  // Then we add the new ones.
  // First we pick an existing subtree to use as a template for copying.
  $src = db_query_range("SELECT id, lft, rgt, nv, dv, snv, sdv, parent FROM {taxonomy_nested_intervals} WHERE tid = :tid", 0, 1, array(':tid' => $term->tid))->fetchAssoc();
  $src['matrix'] = $class::createFromAssoc($src);

  // Copy the template to the relevant destinations.
  foreach ($add_points as $dst) {
    _taxonomy_nested_intervals_make_space($term->vid, $dst['matrix']);

    // Let's derive the delta depth.
    $delta_depth = $dst['matrix']->getDepth() - $src['matrix']->getDepth();

    // $matrices contain the new parent.
    $matrix = $src['matrix']->relocate($dst['matrix']);

    // Do the locomotion ...
    _taxonomy_nested_intervals_copy_paths($matrix, $delta_depth, $term->vid, $src['lft'], $src['rgt']);

    // Update the parent column for the root node of the newly inserted subtree.
    $new_point = $matrix->multiply($src['matrix']);
    db_update('taxonomy_nested_intervals')
      ->fields(array(
        'parent' => $dst['parent']
      ))
      ->condition('vid', $term->vid)
      ->where("lft = " . $new_point->getLeft($factor))
      ->execute();
  }

  // Commit transaction.
  unset($tx);
}

/**
 * Implements hook_taxonomy_vocabulary_delete().
 */
function taxonomy_nested_intervals_taxonomy_vocabulary_delete($vocabulary) {
  $vocabulary_delete = &drupal_static('taxonomy_nested_intervals_taxonomy_vocabulary_delete_' . $vocabulary->vid, FALSE);
  $vocabulary_delete = TRUE;
  db_delete('taxonomy_nested_intervals')
    ->condition('vid', $vocabulary->vid)
    ->execute();
}

/**
 * Implements hook_taxonomy_term_delete().
 */
function taxonomy_nested_intervals_taxonomy_term_delete($term) {
  $vocabulary_delete = &drupal_static('taxonomy_nested_intervals_taxonomy_vocabulary_delete_' . $term->vid, FALSE);
  if ($vocabulary_delete) {
    return;
  }

  if (!taxonomy_nested_intervals_get_option($term->vid, 'enabled')) {
    return;
  }
  db_delete('taxonomy_nested_intervals')
    ->condition('tid', $term->tid)
    ->execute();
}

/**
 * Implements hook_form_N_alter().
 *
 * Fix missing parent=0 on multiparent edit
 */
function taxonomy_nested_intervals_form_taxonomy_form_term_alter(&$form, &$form_state) {
  if (!isset($form['relations']['parent']['#default_value'])) {
    return;
  }
  $term = $form['#term'];
  if ($term && $form['relations']['parent']['#default_value'] != array(0) && is_numeric($term['tid'])) {
    if (db_query("SELECT 1 FROM {taxonomy_term_hierarchy} WHERE tid = :tid AND parent = 0", array(':tid' => $term['tid']))->fetchField()) {
      array_unshift($form['relations']['parent']['#default_value'], 0);
    }
  }
}

// ---------- PRIVATE HELPER FUNCTIONS ----------

/**
 * Find insertion point(s) for a term.
 *
 * If we have the tree:
 * term1
 * term1 > term2
 * term1 > term3
 * term4
 * term4 > term1
 * term4 > term1 > term2
 * term4 > term1 > term3
 *
 * and we want to insert "term21" with the parent "term1", then this function will return
 * the nested interval points for:
 *
 * term1
 * term1 > term2
 * term1 > term21 (new point)
 * term1 > term3
 * term4
 * term4 > term1
 * term4 > term1 > term2
 * term4 > term1 > term21 (new point)
 * term4 > term1 > term3
 *
 * @param object $term
 *   Term to find insertion point(s) for. Must contain ->tid, ->name and ->weight
 * @param int $parent
 *   Parent term id for $term
 *
 * @return array
 *   Matrices of the new points for $term
 */
function _taxonomy_nested_intervals_find_insertion_points($term, $parent) {
  $points = array();
  $class = taxonomy_nested_intervals_get_option($term->vid, 'class');
  $factor = taxonomy_nested_intervals_get_option($term->vid, 'factor');
  $scale = taxonomy_nested_intervals_get_option($term->vid, 'scale');
  $sort = taxonomy_nested_intervals_get_option($term->vid, 'sort');

  if ($sort == TAXONOMY_NESTED_INTERVALS_SORT_DEFER) {
    // Queue recalc of $term + $parent here.
    $invalid = variable_get('taxonomy_nested_intervals_invalid_' . $term->vid, FALSE);
    if (!$invalid) {
      variable_set('taxonomy_nested_intervals_invalid_' . $term->vid, TRUE);
    }
    $sort = TAXONOMY_NESTED_INTERVALS_SORT_NONE;
  }

  // Find insertion points at specific level in tree (i.e. previous sibling for this parent).
  if ($sort) {
    $query = db_select('taxonomy_term_data', 'd')
      ->fields('d', array('tid'))
      ->condition('d.vid', $term->vid)
      ->condition('d.tid', $term->tid, '<>')
      ->orderBy('d.weight', 'DESC')
      ->orderBy('d.name', 'DESC')
      ->orderBy('d.tid', 'DESC')
      ->range(0, 1);
    $query->join('taxonomy_term_hierarchy', 'h', 'h.tid = d.tid AND h.parent = :parent', array(':parent' => $parent));
    $query->where('(d.weight < :weight1 OR (d.weight = :weight2 AND d.name <= :name))', array(
      ':weight1' => $term->weight,
      ':weight2' => $term->weight,
      ':name' => $term->name,
    ));
    $tid = $query->execute()->fetchField();
    if ($tid) {
      // Previous sibling found!
      $points = db_query("SELECT nv, dv, snv, sdv FROM {taxonomy_nested_intervals} WHERE tid = :tid AND parent = :parent", array(
        ':tid' => $tid,
        ':parent' => $parent,
      ))->fetchAll(PDO::FETCH_ASSOC);
    }
  }

  if ($points) {
    // We found points for the previous siblings, lets calculate our insertion point (sibling number).
    foreach ($points as &$point) {
      $matrix = $class::createFromAssoc($point);
      $depth = $matrix->getDepth();
      $point['matrix'] = $matrix;

      // Calculate parent (needed for sibling bump).
      $parent_matrix = $matrix->getSafeParent();

      // Polarity compensation. If reverse polarity, we need to bump the "previous" sibling as well.
      $sibling = $class::getPolarityByDistance($depth) == 1 ? 1 : 0;

      // Locate gap (i.e. is there a next sibling, and if so, how far away is it?
      $lft = $point['matrix']->getLeft($factor);
      $rgt = $depth > 0 ? 'AND lft < ' . $parent_matrix->getRight($factor) : '';
      $next_sibling = db_select('taxonomy_nested_intervals', 'i')
        ->fields('i', array('nv', 'dv', 'snv', 'sdv'))
        ->condition('i.vid', $term->vid)
        ->condition('i.distance', $depth)
        ->where("i.lft > $lft $rgt")
        ->orderBy('i.lft', 'ASC')
        ->range(0, 1)
        ->execute()
        ->fetchAssoc();

      if ($next_sibling) {
        // We found a sibling, calculate midpoint in the gap and use that.
        $next_sibling = $class::createFromAssoc($next_sibling);
        $gap = $next_sibling->getEnumeratedSibling() - $point['matrix']->getEnumeratedSibling();
        // The gap will be negative if this is a reverse order depth. We're interested in the size, so let's abs() it.
        if (abs($gap) > 2) {
          $sibling += (int) ($gap / 2) - $sibling;
        }
      }
      elseif ($sibling) {
        // We will only scale if this is not a reverse order, since the last sibling in that case will
        // actually be the "first" sibling.
        $sibling += $scale - $sibling;
      }

      // Bump sibling.
      $point['matrix'] = $matrix->generateSibling($matrix->getEnumeratedSibling() + $sibling);
      $point['parent'] = $parent;
    }
  }
  elseif ($parent == 0) {
    // No parent and no previous siblings ... so this must be the very top most node.
    if (!$sort) {
      // Locate the last sibling, so that we may just append the next term.
      $last_sibling = db_select('taxonomy_nested_intervals', 'i')
        ->fields('i', array('nv', 'dv', 'snv', 'sdv'))
        ->condition('i.vid', $term->vid)
        ->condition('i.distance', 0)
        ->orderBy('i.lft', 'DESC')
        ->range(0, 1)
        ->execute()
        ->fetchAssoc();

      if ($last_sibling) {
        $matrix = $class::createFromAssoc($last_sibling);
        $point['matrix'] = $matrix->generateSibling($matrix->getEnumeratedSibling() + $scale);
      }
      else {
        $point['matrix'] = $class::pathToMatrix($scale);
      }
    }
    else {
      // @todo Locate gap here. Until then we will just use the first entry in this depth (root).
      $point['matrix'] = $class::pathToMatrix("1");
    }
    $point['parent'] = $parent;
    $points = array($point);
  }
  else {
    // No previous siblings found, meaning that this term the first sibling in this level
    // Locate all points for parents of this level.
    $points = db_query("SELECT lft, rgt, distance, nv, dv, snv, sdv FROM {taxonomy_nested_intervals} WHERE tid = :tid", array(':tid' => $parent))->fetchAll(PDO::FETCH_ASSOC);

    foreach ($points as &$point) {
      $distance = $point['distance'];
      // Distance is that of the parent. Add one to get correct level.
      if (!$sort || $class::getPolarityByDistance($distance + 1) == -1) {
        // If we are not using a sorted tree OR this is a DESC order depth,
        // we need to locate the last sibling and append to that.
        $lft = $point['lft'];
        $rgt = $point['rgt'];

        // Distance is that of the parent. Add one to get correct level.
        $order = $class::getPolarityByDistance($distance + 1) == 1 ? 'DESC' : 'ASC';

        $last_sibling = db_select('taxonomy_nested_intervals', 'i')
          ->fields('i', array('nv', 'dv', 'snv', 'sdv'))
          ->condition('i.vid', $term->vid)
          ->condition('i.distance', $distance + 1)
          ->where("i.lft > $lft AND i.lft < $rgt")
          ->orderBy('i.lft', $order)
          ->range(0, 1)
          ->execute()
          ->fetchAssoc();
        if ($last_sibling) {
          $matrix = $class::createFromAssoc($last_sibling);
          $point['matrix'] = $matrix->generateSibling($matrix->getEnumeratedSibling() + $scale);
          $point['parent'] = $parent;
          continue;
        }
      }
      // Either sorted tree or no last sibling acquired ... we'll use the first entry.

      $matrix = $class::createFromAssoc($point);
      // Calculate current sibling (i.e. parents first sibling)
      // @todo Locate gap here. Until then we will just use the first entry in this depth.
      $point['matrix'] = $matrix->generateLeaf(1);
      $point['parent'] = $parent;
    }
  }
  return $points;
}

/**
 * Apply a matrix multiplication for all paths (matrices) in scope vid:[lft;rgt[.
 *
 * @param object $matrix
 *   Matrix to apply
 * @param int $vid
 *   Vocabulary ID of scope
 * @param string $lft
 *   Left of scope
 * @param string $rgt
 *   Right of scope (0 = inf: [lft;inf[)
 */
function _taxonomy_nested_intervals_transform_paths($matrix, $delta_depth, $vid, $lft, $rgt = 0) {
  $class = taxonomy_nested_intervals_get_option($vid, 'class');
  $factor = taxonomy_nested_intervals_get_option($vid, 'factor');
  $factor = BigNum::add($factor, 0, variable_get('taxonomy_nested_intervals_decimals', TAXONOMY_NESTED_INTERVALS_DECIMALS));

  // Column values are updated inline when using mysql, e.g. consider nv having the value 5 prior to update
  // SET nv = 2, dv = nv // mysql, dv now contains 2, pgsql, dv now contains 5
  $use_buffer = Database::getConnection()->databaseType() == 'mysql' ? TRUE : FALSE;

  $nv = BigNum::add($matrix->nv, 0, variable_get('taxonomy_nested_intervals_decimals', TAXONOMY_NESTED_INTERVALS_DECIMALS));
  $dv = BigNum::add($matrix->dv, 0, variable_get('taxonomy_nested_intervals_decimals', TAXONOMY_NESTED_INTERVALS_DECIMALS));
  $snv = BigNum::add($matrix->snv, 0, variable_get('taxonomy_nested_intervals_decimals', TAXONOMY_NESTED_INTERVALS_DECIMALS));
  $sdv = BigNum::add($matrix->sdv, 0, variable_get('taxonomy_nested_intervals_decimals', TAXONOMY_NESTED_INTERVALS_DECIMALS));

  $buffer_nv = $use_buffer ? 'buffer_nv' : 'nv';
  $buffer_snv = $use_buffer ? 'buffer_snv' : 'snv';

  $sql_nv = "($nv * $buffer_nv + $snv * dv)";
  $sql_dv = "($dv * $buffer_nv + $sdv * dv)";
  $sql_snv = "($nv * $buffer_snv + $snv * sdv)";
  $sql_sdv = "($dv * $buffer_snv + $sdv * sdv)";

  $result_nv = $use_buffer ? 'nv' : $sql_nv;
  $result_dv = $use_buffer ? 'dv' : $sql_dv;
  $result_snv = $use_buffer ? 'snv' : $sql_snv;
  $result_sdv = $use_buffer ? 'sdv' : $sql_sdv;

  // @todo Move this to the class file somehow.
  if ($class == 'MatrixTreeTropashko') {
    $sql_lft_org = $sql_lft = "ROUND($result_nv * $factor / $result_dv, " . variable_get('taxonomy_nested_intervals_decimals', TAXONOMY_NESTED_INTERVALS_DECIMALS) . ")";
    $sql_rgt = "ROUND(($result_nv + $result_snv) * $factor / ($result_dv + $result_sdv), " . variable_get('taxonomy_nested_intervals_decimals', TAXONOMY_NESTED_INTERVALS_DECIMALS) . ")";
    $sql_lft = "(CASE WHEN (distance + $delta_depth) % 2 = 0 THEN $sql_lft + (CASE WHEN ($result_snv = 1 AND $result_sdv <> 0 AND $result_dv = 1) OR FLOOR($result_nv / $result_snv) = 1 THEN 0.000000000000000000000000000001 ELSE 0 END) ELSE $sql_rgt END)";
    $sql_rgt = "(CASE WHEN (distance + $delta_depth) % 2 = 1 THEN $sql_lft_org ELSE $sql_rgt END)";
  }
  else {
    $sql_lft = "ROUND($result_nv * $factor / $result_dv, " . variable_get('taxonomy_nested_intervals_decimals', TAXONOMY_NESTED_INTERVALS_DECIMALS) . ")";
    $sql_rgt = "ROUND($result_snv * $factor / $result_sdv, " . variable_get('taxonomy_nested_intervals_decimals', TAXONOMY_NESTED_INTERVALS_DECIMALS) . ")";
  }

  $rgt = $rgt ? " AND lft < $rgt" : '';

  $query = db_update('taxonomy_nested_intervals');
  if ($use_buffer) {
    $query->expression('buffer_nv', 'nv');
    $query->expression('buffer_snv', 'snv');
  }
  $query
    ->expression('nv', $sql_nv)
    ->expression('dv', $sql_dv)
    ->expression('snv', $sql_snv)
    ->expression('sdv', $sql_sdv)
    ->expression('lft', $sql_lft)
    ->expression('rgt', $sql_rgt)
    ->expression('distance', 'distance + :delta_depth', array(':delta_depth' => $delta_depth))
    ->condition('vid', $vid)
    ->where("lft >= $lft $rgt")
    ->execute();
}

/**
 * Copy all paths (matrices) in scope vid:[lft;rgt[ while applying a matrix multiplication.
 *
 * @param object $matrix
 *   Matrix to apply
 * @param int $vid
 *   Vocabulary ID of scope
 * @param string $lft
 *   Left of scope
 * @param string $rgt
 *   Right of scope (0 = inf: [lft;inf[)
 */
function _taxonomy_nested_intervals_copy_paths($matrix, $delta_depth, $vid, $lft, $rgt = 0) {
  $class = taxonomy_nested_intervals_get_option($vid, 'class');
  $factor = taxonomy_nested_intervals_get_option($vid, 'factor');
  $factor = BigNum::add($factor, 0, variable_get('taxonomy_nested_intervals_decimals', TAXONOMY_NESTED_INTERVALS_DECIMALS));

  $nv = BigNum::add($matrix->nv, 0, variable_get('taxonomy_nested_intervals_decimals', TAXONOMY_NESTED_INTERVALS_DECIMALS));
  $dv = BigNum::add($matrix->dv, 0, variable_get('taxonomy_nested_intervals_decimals', TAXONOMY_NESTED_INTERVALS_DECIMALS));
  $snv = BigNum::add($matrix->snv, 0, variable_get('taxonomy_nested_intervals_decimals', TAXONOMY_NESTED_INTERVALS_DECIMALS));
  $sdv = BigNum::add($matrix->sdv, 0, variable_get('taxonomy_nested_intervals_decimals', TAXONOMY_NESTED_INTERVALS_DECIMALS));

  $sql_nv = "($nv * nv + $snv * dv)";
  $sql_dv = "($dv * nv + $sdv * dv)";
  $sql_snv = "($nv * snv + $snv * sdv)";
  $sql_sdv = "($dv * snv + $sdv * sdv)";

  // @todo Move this to the class file somehow.
  if ($class == 'MatrixTreeTropashko') {
    $sql_lft_org = $sql_lft = "ROUND($sql_nv * $factor / $sql_dv, " . variable_get('taxonomy_nested_intervals_decimals', TAXONOMY_NESTED_INTERVALS_DECIMALS) . ")";
    $sql_rgt = "ROUND(($sql_nv + $sql_snv) * $factor / ($sql_dv + $sql_sdv), " . variable_get('taxonomy_nested_intervals_decimals', TAXONOMY_NESTED_INTERVALS_DECIMALS) . ")";
    $sql_lft = "(CASE WHEN (distance + $delta_depth) % 2 = 0 THEN $sql_lft + (CASE WHEN (snv = 1 AND sdv <> 0 AND dv = 1) OR FLOOR(nv / snv) = 1 THEN 0.000000000000000000000000000001 ELSE 0 END) ELSE $sql_rgt END)";
    $sql_rgt = "(CASE WHEN (distance + $delta_depth) % 2 = 1 THEN $sql_lft_org ELSE $sql_rgt END)";
  }
  else {
    $sql_lft = "ROUND($sql_nv * $factor / $sql_dv, " . variable_get('taxonomy_nested_intervals_decimals', TAXONOMY_NESTED_INTERVALS_DECIMALS) . ")";
    $sql_rgt = "ROUND($sql_snv * $factor / $sql_sdv, " . variable_get('taxonomy_nested_intervals_decimals', TAXONOMY_NESTED_INTERVALS_DECIMALS) . ")";
  }

  $rgt = $rgt ? " AND lft < $rgt" : '';

  $query = db_select('taxonomy_nested_intervals', 'i')
    ->fields('i', array('vid', 'tid', 'parent'));
  $query->addExpression($sql_nv, 'nv');
  $query->addExpression($sql_dv, 'dv');
  $query->addExpression($sql_snv, 'snv');
  $query->addExpression($sql_sdv, 'sdv');
  $query->addExpression($sql_lft, 'lft');
  $query->addExpression($sql_rgt, 'rgt');
  $query->addExpression('distance + :delta_depth', 'distance', array(':delta_depth' => $delta_depth));
  $query->condition('vid', $vid);
  $query->where("lft >= $lft $rgt");

  db_insert('taxonomy_nested_intervals')
    ->from($query)
    ->execute();
}

/**
 * Insert term at a specific point.
 *
 * @param object $matrix
 *   Point in tree.
 * @param object $term
 *   Term to insert at the point.
 */
function _taxonomy_nested_intervals_insert_path($matrix, $term) {
  $factor = taxonomy_nested_intervals_get_option($term->vid, 'factor');
  // Insert new term.
  db_insert('taxonomy_nested_intervals')
    ->fields(array(
    'vid' => $term->vid,
    'tid' => $term->tid,
    'parent' => $term->parent,
    'nv' => $matrix->nv,
    'dv' => $matrix->dv,
    'snv' => $matrix->snv,
    'sdv' => $matrix->sdv,
    'distance' => $matrix->getDepth(),
    'lft' => $matrix->getLeft($factor),
    'rgt' => $matrix->getRight($factor)
    ))
    ->execute();
}

/**
 * Push siblings if necessary.
 *
 * If a point already exists at $point, then push that and all it's siblings (plus children),
 * to make room for the new $point.
 *
 * @param int $vid
 *   Vocabulary ID
 * @param object $matrix
 *   Matrix of point to make room for
 */
function _taxonomy_nested_intervals_make_space($vid, $matrix) {
  $class = taxonomy_nested_intervals_get_option($vid, 'class');
  $factor = taxonomy_nested_intervals_get_option($vid, 'factor');
  $scale = taxonomy_nested_intervals_get_option($vid, 'scale');

  // Calculate scope of sibling bump = [our left;parent right[
  $lft = $matrix->getLeft($factor);

  // Only bump if there is no gap.
  if (db_query("SELECT id FROM {taxonomy_nested_intervals} WHERE vid = :vid AND lft = $lft", array(':vid' => $vid))->fetchField()) {

    // Get proper scope (in case of polarity inversion).
    list($lft, $rgt) = $class::getScopeForBump($matrix, $factor);

    // Matrix for bumping siblings one step (parent * step * inverse parent).
    $bump = $matrix->relocate($matrix, $scale);

    // Transform that scope (bump siblings).
    _taxonomy_nested_intervals_transform_paths($bump, 0, $vid, $lft, $rgt);
  }
}

/**
 * Unify parents.
 *
 * @param mixed $parents
 *   Parents to unify.
 *
 * @return array
 *   Flattened array of parent term IDs
 */
function _taxonomy_nested_intervals_unify_parents($parents) {
  $parents = is_array($parents) ? $parents : array($parents);
  $new_parents = array();
  foreach ($parents as $parent) {
    if (is_array($parent)) {
      foreach ($parent as $new) {
        $new_parents[] = $new;
      }
    }
    else {
      $new_parents[] = $parent;
    }
  }
  return $new_parents;
}

/**
 * Cross db temporary table creation with indices.
 */
function _taxonomy_nested_intervals_db_create_temporary_table($data) {
  static $index = 0;

  $connection = Database::getConnection();
  $schema = $connection->schema();
  $method = new ReflectionMethod($schema, 'createTableSql');
  $method->setAccessible(TRUE);

  $tablename = "_db_temporary_" . $index++;
  $statements = $method->invoke($schema, $tablename, $data);
  $statements[0] = preg_replace('/^CREATE TABLE /', 'CREATE TEMPORARY TABLE ', $statements[0]);
  foreach ($statements as $statement) {
    $connection->query($statement);
  }
  return $tablename;
}

// ---------- PUBLIC HELPER FUNCTIONS ----------

/**
 * Get parent from nested intervals list.
 *
 * @param int $tid
 *   term id to get parent from.
 *
 * @return array
 *   array of array of term ids.
 */
function taxonomy_nested_intervals_get_parents($tid) {
  $points = db_query("SELECT vid, nv, dv, snv, sdv FROM {taxonomy_nested_intervals} WHERE tid = :tid", array(':tid' => $tid))->fetchAll(PDO::FETCH_OBJ);
  if (!$points) {
    return FALSE;
  }
  $vid = $points[0]->vid;
  $class = taxonomy_nested_intervals_get_option($vid, 'class');
  $factor = taxonomy_nested_intervals_get_option($vid, 'factor');

  $parents = array();
  foreach ($points as $point) {
    $parent = $class::createFromAssoc((array) $point);
    $lfts = array();
    while ($parent = $parent->getParent()) {
      $lfts[] = $parent->getLeft($factor);
    }
    if ($lfts) {
      $query = db_select('taxonomy_nested_intervals', 'i')
        ->fields('i', array('id', 'tid'))
        ->condition('i.vid', $vid)
        ->where("i.lft IN (" . join(',', $lfts) . ")")
        ->orderBy('i.lft', 'DESC');
      $parents[] = $query->execute()->fetchAllKeyed();
    }
  }
  return $parents;
}

/**
 * Get top term ids.
 *
 * @param int $tid
 *   Term ID to get top term ID from.
 *
 * @return array
 *   Top term IDs.
 */
function taxonomy_nested_intervals_get_top_tids($tid) {
  $points = db_query("SELECT vid, nv, dv, snv, sdv FROM {taxonomy_nested_intervals} WHERE tid = :tid", array(':tid' => $tid))->fetchAll(PDO::FETCH_OBJ);
  if (!$points) {
    return FALSE;
  }
  $vid = $points[0]->vid;
  $class = taxonomy_nested_intervals_get_option($vid, 'class');
  $factor = taxonomy_nested_intervals_get_option($vid, 'factor');
  while ($point = array_shift($points)) {
    $matrix = $class::createFromAssoc((array) $point);
    if ($parent = $matrix->getParent()) {
      if ($parent->getDepth() === 0) {
        $lfts[] = $parent->getLeft($factor);
      }
      $points[] = $parent;
    }
  }

  if ($lfts) {
    $query = db_select('taxonomy_nested_intervals', 'i')
      ->fields('i', array('id', 'tid'))
      ->condition('i.vid', $vid)
      ->where("i.lft IN (" . join(',', $lfts) . ")")
      ->orderBy('i.lft', 'ASC');

    $parents = $query->execute()->fetchAllKeyed();
    return $parents;
  }
  return array();
}

/**
 * Get top term id.
 *
 * @param int $tid
 *   Term ID to get top term ID from.
 *
 * @return int
 *   Top term ID.
 */
function taxonomy_nested_intervals_get_top_tid($tid) {
  if ($tids = taxonomy_nested_intervals_get_top_tids($tid)) {
    return reset($tids);
  }
  return $tids;
}

/**
 * Get intervals for term.
 *
 * @param int $tid
 *   Term ID to get intervals from.
 *
 * @return array
 *   Left and right values
 */
function taxonomy_nested_intervals_get_intervals($tid) {
  $intervals = db_select('taxonomy_nested_intervals', 'i')
    ->fields('i', array('lft', 'rgt'))
    ->condition('i.tid', $tid)
    ->execute()
    ->fetchAll(PDO::FETCH_OBJ);
  if (!$intervals) {
    return FALSE;
  }
  return $intervals;
}

/**
 * Get interval for term.
 *
 * @param int $tid
 *   Term ID to get the interval from
 *
 * @return array
 *   Left and right values.
 */
function taxonomy_nested_intervals_get_interval($tid) {
  $interval = db_select('taxonomy_nested_intervals', 'i')
    ->fields('i', array('lft', 'rgt'))
    ->condition('i.tid', $tid)
    ->range(0, 1)
    ->execute()
    ->fetchObject();
  if (!$interval) {
    return FALSE;
  }
  return $interval;
}

/**
 * Get max depth of a tree..
 *
 * @param int $vid
 *   Vocabulary ID.
 * @param int $parent
 *   (optional) Parent to get max depth of. Defaults to 0.
 *
 * @return int
 *   Max depth (distance)
 */
function taxonomy_nested_intervals_get_max_depth($vid = 0, $parent = 0) {
  if (!$vid) {
    $subquery = db_select('taxonomy_nested_intervals', 'i')
      ->fields('i', array('vid'))
      ->groupBy('i.vid');
    $subquery->addExpression('MAX(i.distance)', 'distance');
    $query = db_select($subquery, 'd');
    $query->addExpression('SUM(d.distance)', 'distance');
    return $query->execute()->fetchField();
  }
  if ($parent) {
    $point = db_query("SELECT vid, lft, rgt FROM {taxonomy_nested_intervals} WHERE tid = :parent", array(':parent' => $parent))->fetchObject();
    return db_query("SELECT MAX(distance) - :distance FROM {taxonomy_nested_intervals} WHERE vid = :vid AND lft > $point->lft AND lft < $point->rgt", array(
      ':vid' => $vid,
      ':distance' => intval($point->distance),
    ))->fetchField();
  }
  else {
    return db_query("SELECT MAX(distance) FROM {taxonomy_nested_intervals} WHERE vid = :vid", array(
      ':vid' => $vid
    ))->fetchField();
  }
}

/**
 * Get specific option for a vocabulary.
 *
 * @param int $vid
 *   Vocabulary ID.
 * @param string $option
 *   Option to get.
 *
 * @return mixed
 *   Value of option.
 */
function taxonomy_nested_intervals_get_option($vid, $option) {
  $options = taxonomy_nested_intervals_load_fields($vid);
  switch ($option) {
    case 'enabled':
      return !empty($options['class']);

    case 'class':
      return $options['class'];

    case 'factor':
      return $options['factor'];

    case 'scale':
      if ($options['sort']) {
        $scale = (int) $options['scale'];
        $scale = $scale > 0 ? $scale : 1;
        return $scale;
      }
      else {
        return 1;
      }

    case 'sort':
      return $options['sort'];

    default:
      throw new Exception(t("Invalid option %option requested", array('%option' => $option)));

  }
}

// ---------- CORE OVERRIDES ----------

/**
 * Reimplementation of taxonomy_get_tree().
 *
 * Limit db fetch to only specified parent.
 * @see taxonomy_get_tree()
 */
function taxonomy_nested_intervals_get_tree($vid, $parent = 0, $max_depth = NULL, $load_entities = FALSE) {
  if (taxonomy_nested_intervals_get_option($vid, 'enabled')) {
    module_load_include('core.inc', 'taxonomy_nested_intervals');
    return taxonomy_nested_intervals_core_get_tree($vid, $parent, $max_depth, $load_entities);
  }
  return FALSE;
}

/**
 * Reimplementation of taxonomy_select_nodes() re-allowing depth modifier.
 */
function taxonomy_nested_intervals_select_nodes($tid, $pager = TRUE, $limit = FALSE, $depth = 0, $order = NULL) {
  $vid = db_query("SELECT vid FROM {taxonomy_term_data} WHERE tid = :tid", array(':tid' => $tid))->fetchField();
  if (taxonomy_nested_intervals_get_option($vid, 'enabled')) {
    module_load_include('core.inc', 'taxonomy_nested_intervals');
    return taxonomy_nested_intervals_core_select_nodes($tid, $pager, $limit, $depth, $order);
  }
  return FALSE;
}
