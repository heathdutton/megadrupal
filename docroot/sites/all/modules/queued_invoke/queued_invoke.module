<?php
/**
 * @file
 *
 * Postpone hook implementations to queue processing.
 *
 * @code
 * function mymodule_taxonomy_term_insert_queued($term) {
 *   error_log("Hey, I'm a cron queue! $term->tid has been inserted, let's act on it!");
 * }
 * @endcode
 *
 *
 * Queue configuration (topdown precedence):
 * @code
 *
 * // "hook_taxonomy_term_insert_queued" in module "test" goes to the queue "my_queue_test_insert_queued"
 * $conf['queued_invoke_queues']['taxonomy_term_insert_queued']['test'] = 'my_queue_test_insert_queued';
 *
 * // "hook_taxonomy_term_insert_queued" in all other modules go to the queue "my_queue_insert_queued"
 * $conf['queued_invoke_queues']['taxonomy_term_insert_queued']['default'] = 'my_queue_insert_queued';
 *
 * // "hook_N_queued" in module "test" go to the queue "my_queue_test"
 * $conf['queued_invoke_queues']['default']['test'] = 'my_queue_test';
 *
 * // "hook_N_queued" in module "system" go to the queue "my_queue_system"
 * $conf['queued_invoke_queues']['default']['system'] = 'my_queue_system';
 *
 * // "hook_N_queued" in any module go to the queue "my_queue_default"
 * $conf['queued_invoke_queues']['default']['default'] = 'my_queue_default';
 *
 * Buffer size configuration 
 * // "my_queue_insert_queued" has a buffer size of 10
 * $conf['queued_invoke_buffer_sizes']['my_queue_insert_queued'] = 10;
 * @endcode
 */

/**
 * Default buffer size is 1 (i.e. no buffering)
 */
define('QUEUED_INVOKE_BUFFER_SIZE', 1);

// Implement the hooks that we support.
include 'queued_invoke.hooks.inc';

/**
 * Implements hook_cron_queue_info().
 */
function queued_invoke_cron_queue_info() {
  $queues = array(
    'queued_invoke' => array(
      'worker callback' => 'queued_invoke_cron_worker',
    )
  );
  return $queues;
}

/**
 * Implements hook_menu().
 */
function queued_invoke_menu() {
  $items = array();
  $items['admin/config/system/queued-invoke'] = array(
    'title' => 'Queued Invoke',
    'description' => 'Administer Qeued Invoke',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('queued_invoke_settings_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'queued_invoke.admin.inc',
  );
  return $items;
}

/**
 * Queue the hook requests.
 *
 * @param $hook
 *   Name of queued invokes hook implementation, e.g. 'taxonomy_term_insert_queued'.
 * @param $args
 *   Arguments that the hook was invoked with.
 */
function queued_invoke_queue_hooks($hook, $args, $callback = NULL) {
  foreach (module_implements($hook) as $module) {
    queued_invoke_queue_hook($module, $hook, $args, $callback);
  }
}

/**
 * Buffer the queued invoke
 */
function queued_invoke_queue_hook($module, $hook, $args, $callback = NULL) {
  static $shutdown_registered = FALSE;
  if (!$shutdown_registered) {
    drupal_register_shutdown_function('queued_invoke_buffer_flush');
    $shutdown_registered = TRUE;
  }

  $key = $hook.md5(serialize($args));
  $queue = queued_invoke_get_queue($module, $hook);
  $buffer = &drupal_static('queued_invoke_buffer', array());
  if (count($buffer[$queue]) >= queued_invoke_get_buffer_size($queue)) {
    queued_invoke_buffer_flush($queue);
  }
  $buffer[$queue][$key]['hook'] = $hook;
  $buffer[$queue][$key]['args'] = $args;
  $buffer[$queue][$key]['modules'][$module] = $callback;
}

/**
 * Flush the buffer (i.e. create queue item)
 */
function queued_invoke_buffer_flush($queue = NULL) {
  $buffer = &drupal_static('queued_invoke_buffer', array());
  $queues = $queue ? array($queue) : array_keys($buffer);

  foreach ($queues as $queue) {
    if (!empty($buffer[$queue])) {
      $queue_object = DrupalQueue::get($queue);
      $queue_object->createItem($buffer[$queue]);
      unset($buffer[$queue]);
    }
  }
}

/**
 * Cron worker callback. Invokes hooks for real.
 */
function queued_invoke_cron_worker($data) {
  foreach ($data as $options) {
    foreach ($options['modules'] as $module => $callback) {
      $callback = $callback ? $callback : $module . '_' . $options['hook'];
      call_user_func_array($callback, $options['args']);
    }
  }
}

/**
 * Convert a function name to its corresponding hook
 * @see queued_invoke.hooks.inc
 */
function queued_invoke_convert_to_hook($function) {
  return preg_replace('/^queued_invoke_/', '', $function) . '_queued';
}

/**
 * Get queue configuration with defaults.
 */
function queued_invoke_get_queues() {
  $queues = variable_get('queued_invoke_queues', array());
  $queues += array('default' => array('default' => 'queued_invoke'));
  return $queues;
}

/**
 * Get queue name for a hook.
 */
function queued_invoke_get_queue($module, $hook) {
  $cache = &drupal_static(__FUNCTION__, array());

  if (!isset($cache[$module][$hook])) {
    $queues = variable_get('queued_invoke_queues', array());
    $queues += array('default' => array('default' => 'queued_invoke'));
    if (!empty($queues[$hook][$module])) {
      // Hook + module specific queue
      $queue = $queues[$hook][$module];
    }
    elseif (!empty($queues[$hook]['default'])) {
      // Hook specific queue
      $queue = $queues[$hook]['default'];
    }
    elseif (!empty($queues['default'][$module])) {
      // Module specific queue
      $queue = $queues['default'][$module];
    }
    elseif (!empty( $queues['default']['default'])) {
      // Default queue
      $queue = $queues['default']['default'];
    }
    else {
      // Ultra hardcoded default queue fallback just in case
      $queue = 'queued_invoke';
    }
    $cache[$module][$hook] = $queue;
  }
  return $cache[$module][$hook];
}

/**
 * Get buffer size for a queue
 */
function queued_invoke_get_buffer_size($queue) {
  $buffer_sizes = variable_get('queued_invoke_buffer_sizes', array());
  return empty($buffer_sizes[$queue]) ? variable_get('queued_invoke_buffer_size', QUEUED_INVOKE_BUFFER_SIZE) : $buffer_sizes[$queue];
}

