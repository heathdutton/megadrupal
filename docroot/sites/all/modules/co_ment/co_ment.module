<?php

/**
 * @file
 * The co-ment module provides Drupal with an interface to co-ment®,
 * a Web service for submitting texts to comments and annotations.
 */

/**
 * Implements hook_field_info().
 *
 * Provides the description of the field.
 */
function co_ment_field_info() {
  return array(
    'co_mentable' => array(
      'label' => t('Co-mentable text'),
      'description' => t('A commentable text through co-ment®.'),
      'instance_settings' => array(
              'text_processing' => 1,
              'iframe_height' => 500,
      ),
      'default_widget' => 'text_textarea',
      'default_formatter' => 'co_mentable_text',
    ),
  );
}

/**
 * Implements hook_field_instance_settings_form().
 */
function co_ment_field_instance_settings_form($field, $instance) {
  $settings = $instance['settings'];

  $form['iframe_height'] = array(
    '#type' => 'textfield',
    '#title' => t('Height (in pixels) of the frame embedding the co-ment text.'),
    '#default_value' => $settings['iframe_height'],
  );

  return $form;
}
/**
 * Implements hook_field_widget_info_alter().
 *
 * co_mentable new field type re-use existing widget textarea.
 */
function co_ment_field_widget_info_alter(&$info) {
  $info['text_textarea']['field types'][] = 'co_mentable';
}

/**
 * Implements hook_field_widget_WIDGET_TYPE_form_alter().
 *
 * Specific validator should be called.
 *
 * @see co_ment_field_validate_handler()
 */
function co_ment_field_widget_text_textarea_form_alter(&$element, &$form_state, $context) {
  $element['#element_validate'][] = 'co_ment_field_validate_handler';
}

/**
 * Implements hook_field_formatter_info().
 */
function co_ment_field_formatter_info() {
  return array(
    'co_mentable_text' => array(
      'label' => t('Allows annotations with co-ment®.'),
      'field types' => array('co_mentable'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function co_ment_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $entity_info = entity_get_info($entity_type);
  $entity_id_key = $entity_info['entity keys']['id'];
  $entity_id = $entity->$entity_id_key;
  $entity_current = entity_load($entity_type, array($entity_id));
  // For entity types which have revisions, finds if this is the current revision.
  $is_current_revision = array_key_exists('vid', (array)$entity) ? ($entity_current[$entity->$entity_id_key]->vid == $entity->vid) : TRUE;
  if (array_key_exists('comment_id_key', $_GET)) {
    $comment_id_key_array = preg_split('/,/', $_GET['comment_id_key']);
  }
  if (array_key_exists('comment_op', $_GET)) {
    $comment_op_array = preg_split('/,/', $_GET['comment_op']);
  }

  $element = array();

  foreach ($items as $delta => $item) {
    // Prevents showing co-ment interface when search module indexes the node.
    $backtrace = array_map(create_function('$step', 'return $step["function"];'), debug_backtrace());
    if (!in_array('search_cron', $backtrace)) {
      $element[$delta] = array(
        '#theme' => 'co_ment_field',
        '#co_ment_key' => $item['co_ment_key'],
        '#co_ment_version' => $is_current_revision ? NULL : $item['co_ment_version'],
        '#comment_id' => (!empty($comment_id_key_array) && array_key_exists($delta, $comment_id_key_array) && !empty($comment_id_key_array[$delta])) ? $comment_id_key_array[$delta] : NULL,
        '#comment_op' => (!empty($comment_op_array) && array_key_exists($delta, $comment_op_array) && !empty($comment_op_array[$delta])) ? $comment_op_array[$delta] : NULL,
        '#entity_type' =>  $entity_type,
        '#entity_id' =>  $entity_id,
        '#delta' =>  $delta,
        // Adds 58px for co-ment toolbar and 25px for 'add comment' button.
        '#height' => $instance['settings']['iframe_height'] + 58 + 25,
      );
    }
    else {
      // Displays only text value when search module indexes the node
      $element[$delta] = array('#markup' => $item['co_ment_value']);
    }
  }

  return $element;
}

/**
 * Implements hook_field_is_empty().
 */
function co_ment_field_is_empty($item, $field) {
  return !isset($item['value']) || $item['value'] === '';
}

/**
 * Implements hook_field_load().
 *
 * Textarea widget needs 'value' and 'format' fields.
 */
function co_ment_field_load($entity_type, $entities, $field, $instances, $langcode, &$items, $age) {
  foreach ($items as $id => $item) {
    foreach ($item as $delta => $item_val) {
      if (!empty($items[$id][$delta]['co_ment_value'])) {
        $items[$id][$delta]['value'] = $items[$id][$delta]['co_ment_value'];
        $items[$id][$delta]['format'] = $items[$id][$delta]['co_ment_format'];
      }
    }
  }
}

/**
 * Validation handler.
 *
 * Cannot use hook_field_validate, since $form_state is needed
 * to set co_ment_key and co_ment_version and value/format fields
 * returned by text_textarea widget have to be copied into
 * co_ment_value/co_ment_format.
 */
function co_ment_field_validate_handler($element, &$form_state) {
  // Does not validate if it is a deletion.
  if (array_key_exists('delete', $form_state['values']) && $form_state['triggering_element']['#value'] == $form_state['values']['delete'])
    return;

  // Does not validate if it is a file upload.
  $triggering_button = $form_state['triggering_element']['#array_parents'][count($form_state['triggering_element']['#array_parents']) - 1];
  if ($triggering_button == 'upload_button' || $triggering_button == 'remove_button')
    return;

  // Validates only relevant input data.
  $current_field = field_info_field($element['#field_name']);
  if ($current_field['type'] != 'co_mentable' || !array_key_exists('value', $element) || !array_key_exists('format', $element))
    return;

  $delta = $element['#delta'];
  $field = $form_state['field'][$element['#field_name']][$element['#language']]['field'];
  $field_name = $field['field_name'];

  // Validate only non-empty text.
  if (array_key_exists('value', $form_state['values'][$field_name][$element['#language']][$delta]) && ! empty($form_state['values'][$field_name][$element['#language']][$delta]['value'])) {

    // Process import.
    if (array_key_exists('imported', $form_state['values'][$field_name][$element['#language']][$delta]) && $form_state['values'][$field_name][$element['#language']][$delta]['imported']) {
      $form_state['values'][$field_name][$element['#language']][$delta]['co_ment_value'] = $form_state['values'][$field_name][$element['#language']][$delta]['value'];
      $form_state['values'][$field_name][$element['#language']][$delta]['co_ment_format'] = $form_state['values'][$field_name][$element['#language']][$delta]['format'];
      return;
    }

    // Copies value/format fields into co_ment_value/co_ment_format.
    $form_state['values'][$field_name][$element['#language']][$delta]['co_ment_value'] = $form_state['values'][$field_name][$element['#language']][$delta]['value'];
    $form_state['values'][$field_name][$element['#language']][$delta]['co_ment_format'] = $form_state['values'][$field_name][$element['#language']][$delta]['format'];
  }
  else {
    return;
  }

  // Set some variables for co-ment server.
  $url = variable_get('co_ment_url', NULL);
  // Deletes ending slash.
  $url = rtrim($url, '/');
  $co_ment_user = variable_get('co_ment_editor_login', NULL);
  $passwd = variable_get('co_ment_editor_passwd', NULL);
  $title = array_key_exists('title', $form_state['values']) ? $form_state['values']['title'] : 'no title';
  $url = preg_replace('!://!', "://$co_ment_user:$passwd@", $url) . '/api/text/';
  $headers = array(
    'Content-Type' => 'application/x-www-form-urlencoded',
    'User-Agent' => 'co-ment Drupal Module',
  );

  global $user;

  // Field creation.
  $entity = $form_state[$element['#entity_type']];
  if (is_null($element['#default_value']) || !array_key_exists($field_name, (array)$entity) || !array_key_exists($element['#language'], $entity->$field_name) || !array_key_exists($delta, $entity->{$field_name}[$element['#language']])) {
    $content = check_markup($form_state['values'][$field_name][$element['#language']][$delta]['co_ment_value'], $form_state['values'][$field_name][$element['#language']][$delta]['co_ment_format'], $element['#language']);
    $data = array(
      'title' => $title,
      'format' => 'html',
      'content' => $content,
      'name' => strip_tags(theme('username', array('account' => $user))),
      'email' => $user->mail,
    );
    $response = drupal_http_request($url, array('headers' => $headers, 'method' => 'POST', 'data' => http_build_query($data, '', '&')));
    if ($response->code != 200) {
      form_set_error($element['#field_name'] . '][' . $element['#language'] . '][' . $delta, t('Error while creating text in co-ment server: !co_ment_error.', array('!co_ment_error' => $response->status_message)));
      return;
    }
    $return = json_decode($response->data);
    if (!isset($return->key)) {
      form_set_error($element['#field_name'] . '][' . $element['#language'] . '][' . $delta, t('Error while creating text in co-ment server: no key generated.'));
      return;
    }
    else {
      $form_state['values'][$field_name][$element['#language']][$delta]['co_ment_key'] = $return->key;
      $form_state['values'][$field_name][$element['#language']][$delta]['co_ment_version'] = $return->version_key;
    }
  }
  // Field update.
  else {
    $field_values = $entity->$field_name;
    // Returns in case value/format have not changed
    if ($element['format']['format']['#value'] == $element['format']['format']['#default_value'] && $element['value']['#value'] == $element['value']['#default_value']) {
      $form_state['values'][$field_name][$element['#language']][$delta]['co_ment_key'] = $field_values[$element['#language']][$delta]['co_ment_key'];
      $form_state['values'][$field_name][$element['#language']][$delta]['co_ment_version'] = $field_values[$element['#language']][$delta]['co_ment_version'];
      return;
    }

    $url .= $field_values[$element['#language']][$delta]['co_ment_key'] . '/edit/';
    $content = check_markup($form_state['values'][$field_name][$element['#language']][$delta]['co_ment_value'], $form_state['values'][$field_name][$element['#language']][$delta]['co_ment_format'], $element['#language']);

    $data = array(
      'title' => $title,
      'format' => 'html',
      'content' => $content,
      'new_version' => (array_key_exists('revision', $form_state['values']) && $form_state['values']['revision']) ? 1 : NULL,
      'keep_comments' => $form_state['values'][$field_name][$element['#language']][$delta]['keep_comments'] ? 1 : NULL,
      'cancel_modified_scopes' => $form_state['values'][$field_name][$element['#language']][$delta]['cancel_modified_scopes'],
      'name' => strip_tags(theme('username', array('account' => $user))),
      'email' => $user->mail,
    );
    $response = drupal_http_request($url, array('headers' => $headers, 'method' => 'POST', 'data' => http_build_query($data, '', '&')));
    if ($response->code != 200) {
      form_set_error($element['#field_name'] . '][' . $element['#language'] . '][' . $delta, t('Error while updating text in co-ment server: !co_ment_error.', array('!co_ment_error' => $response->status_message)));
      return;
    }
    $return = json_decode($response->data);
    if (!isset($return->version_key)) {
      form_set_error($element['#field_name'] . '][' . $element['#language'] . '][' . $delta, t('Error while updating text in co-ment server: no versionkey generated.'));
      return;
    }
    else {
      $form_state['values'][$field_name][$element['#language']][$delta]['co_ment_key'] = $field_values[$element['#language']][$delta]['co_ment_key'];
      $form_state['values'][$field_name][$element['#language']][$delta]['co_ment_version'] = $return->version_key;
      if ($return->nb_deleted) {
        drupal_set_message(format_plural($return->nb_deleted, "1 comment has been deleted, since either the 'Keep comments' option or the 'Detach comments' option was not checked.", "@count comments have been deleted, since either the 'Keep comments' option or the 'Detach comments' option was not checked."), 'warning');
      }
      if ($return->nb_scope_removed) {
        drupal_set_message(format_plural($return->nb_scope_removed, "1 comment affected by the edition has been detached, since the 'Detach comments' option was checked.", "@count comments affected by the edition have been detached, since the 'Detach comments' option was checked."), 'warning');
      }
    }
  }
}

/**
 * Implements hook_entity_delete().
 */
function co_ment_entity_delete($entity, $type) {
  $co_mentable_bundles = co_ment_bundles();
  if (array_key_exists('type', (array)$entity) && array_key_exists($entity->type, $co_mentable_bundles)) {
    $url = variable_get('co_ment_url', NULL);
    // Delete ending slash.
    $url = rtrim($url, '/');
    $user = variable_get('co_ment_editor_login', NULL);
    $passwd = variable_get('co_ment_editor_passwd', NULL);

    // Fetches each instance in the database, since some fields data
    // could have been deleted from last revision, and corresponding
    // co-ment texts should be deleted.
    $entity_info = entity_get_info($type);
    $entity_id = $entity_info['entity keys']['id'];

    $query = db_select('field_revision_' . $co_mentable_bundles[$entity->type], 'r')
            ->distinct()
            ->condition('entity_id', $entity->$entity_id);
    $query->addField('r', $co_mentable_bundles[$entity->type] . '_co_ment_key', 'co_ment_key');
    $keys = $query->execute();
    foreach ($keys as $key) {
      $version_url = preg_replace('!://!', "://$user:$passwd@", $url) . '/api/text/' . $key->co_ment_key . '/delete/';
      $headers = array(
        'Content-Type' => 'application/x-www-form-urlencoded',
        'User-Agent' => 'co-ment Drupal Module',
      );
      $response = drupal_http_request($version_url, array('headers' => $headers, 'method' => 'POST'));
      if ($response->code != 204) {
        throw new FieldException(t('Error while deleting text in co-ment server: !co_ment_error.', array('!co_ment_error' => $response->status_message)));
      }
    }
  }
}

/**
 * Implements hook_field_delete_revision().
 */
function co_ment_field_delete_revision($entity_type, $entity, $field, $instance, $langcode, &$items) {
  $url = variable_get('co_ment_url', NULL);
  // Delete ending slash.
  $url = rtrim($url, '/');
  $user = variable_get('co_ment_editor_login', NULL);
  $passwd = variable_get('co_ment_editor_passwd', NULL);

  foreach ($items as $delta => $field_value) {
    if (is_int($delta)) {
      $version_url = preg_replace('!://!', "://$user:$passwd@", $url) . '/api/text/' . $field_value['co_ment_key'] . '/' . $field_value['co_ment_version'] . '/delete/';
      $headers = array(
        'Content-Type' => 'application/x-www-form-urlencoded',
        'User-Agent' => 'co-ment Drupal Module',
      );
      $response = drupal_http_request($version_url, array('headers' => $headers, 'method' => 'POST'));
      if ($response->code != 200) {
        throw new FieldException(t('Error while deleting text (delta=!delta, key=!key, version=!version) in co-ment server: !co_ment_error.', array('!delta' => $delta, '!key' => $field_value['co_ment_key'], '!version' =>  $field_value['co_ment_version'], '!co_ment_error' => $response->status_message)));
      }
    }
  }
}

/**
 * Implements hook_field_update().
 *
 * Synchronise Drupal and co-ment revision when reverting.
 */
function co_ment_field_update($entity_type, $entity, $field, $instance, $langcode, &$items) {
  // Finds whether reverting or updating.
  $entity_info = entity_get_info($entity_type);
  $entity_revision_key = $entity_info['entity keys']['revision'];
  if (!array_key_exists('op', (array)$entity) && array_key_exists('old_' . $entity_revision_key, $entity)) {
    $url = variable_get('co_ment_url', NULL);
    // Deletes ending slash.
    $url = rtrim($url, '/');
    $user = variable_get('co_ment_editor_login', NULL);
    $passwd = variable_get('co_ment_editor_passwd', NULL);

    foreach ($items as $delta => $field_value) {
      if (is_int($delta)) {
        $version_url = preg_replace('!://!', "://$user:$passwd@", $url) . '/api/text/' . $field_value['co_ment_key'] . '/' . $field_value['co_ment_version'] . '/revert/';
        $headers = array(
          'Content-Type' => 'application/x-www-form-urlencoded',
          'User-Agent' => 'co-ment Drupal Module',
        );
        $response = drupal_http_request($version_url, array('headers' => $headers, 'method' => 'POST'));
        if ($response->code != 200) {
          throw new FieldException(t('Error while reverting text in co-ment server: !co_ment_error.', array('!co_ment_error' => $response->status_message)));
          return;
        }
      }
    }
  }
}

/**
 * Implements hook_node_info().
 *
 * Provides the description of the bundle (node type).
 */
function co_ment_node_info() {
  return array(
    'co_ment_text' => array(
      'name' => t('co-ment text'),
      'base' => 'co_ment',
      'description' => t('This type of content allowed to view/create/edit texts in co-ment®, a Web service for submitting texts to comments and annotations.'),
      'has_title' => TRUE,
      'title_label' => t('Title'),
    ),
  );
}

/**
 * Implements hook_permission().
 */
function co_ment_permission() {
  $perms = array(
    'administer co-ment' => array(
      'title' => t('Configure Co-ment settings'),
    ),
    'create co_ment_text content' => array(
      'title' => t('<em>co-ment text</em>: Create new content'),
    ),
    'post comments on co_ment_text content' => array(
      'title' => t('<em>co-mentable text fields</em>: Post comments'),
    ),
  );

  return $perms;
}

/**
 * Implements hook_node_access().
 */
function co_ment_node_access($node, $op, $account = NULL) {
  if (is_null($account)) {
    global $user;
    $account = $user;
  }
  switch ($op) {
    case 'create':
      return user_access('create co_ment_text content', $account) ? TRUE : NULL;
      break;
    case 'update':
      return user_access('edit any co_ment_text content', $account) || (user_access('edit own co_ment_text content', $account) && (($node->uid == $account->uid) || (function_exists('og_is_wiki_type') && og_is_wiki_type($node->type)))) ? TRUE : NULL;
      break;
    case 'delete':
      return user_access('delete any co_ment_text content', $account) || (user_access('delete own co_ment_text content', $account) && ($node->uid == $account->uid)) ? TRUE : NULL;
      break;
  }
}

/**
 * Implements hook_menu().
 */
function co_ment_menu() {
  $items = array();
  $items['admin/config/co-ment'] = array(
    'title' => 'Co-ment',
    'description' => 'Configure settings for your co-ment instance.',
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('administer co-ment'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
  );
  $items['admin/config/co-ment/settings'] = array(
    'title' => 'co-ment settings',
    'description' => 'Configure co-ment.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('co_ment_admin_settings'),
    'access arguments' => array('administer co-ment'),
  );

  $items['co-ment'] = array(
    'title' => 'co-ment proxy',
    'page callback' => '_co_ment_proxy',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Menu callback; Build the form presenting co-ment configuration options.
 */
function co_ment_admin_settings($form, &$form_state) {
  $form['intro'] = array(
    '#type' => 'item',
    '#value' => t('The co-ment module provides Drupal with an interface to co-ment®, a Web service for submitting texts to comments and annotations. You should either have an account on <a href="http://www.co-ment.com/">co-ment website</a> or run your <a href="http://www.co-ment.org/">own instance of co-ment</a>. From your co-ment workspace, you should create an user for each role (Editor, Commentator and Observer). Then, enter information about your account or instance of co-ment below.'),
  );

  $form['co_ment_url'] = array(
    '#type' => 'textfield',
    '#title' => t('URL of your co-ment account.'),
    '#default_value' => variable_get('co_ment_url', NULL),
    '#description' => t('The URL of your co-ment account (ex. https://account.co-ment.com/).'),
  );

  $form['co_ment_editor_login'] = array(
    '#type' => 'textfield',
    '#title' => t('Editor login'),
    '#default_value' => variable_get('co_ment_editor_login', NULL),
    '#description' => t('The login name of an editor user in your co-ment workspace.'),
  );

  $form['co_ment_editor_passwd'] = array(
    '#type' => 'password',
    '#title' => t('Editor password'),
    '#default_value' => variable_get('co_ment_editor_passwd', NULL),
    '#description' => t('The password of a editor user in your co-ment workspace.'),
  );

  $form['co_ment_commentator_login'] = array(
    '#type' => 'textfield',
    '#title' => t('Commentator login'),
    '#default_value' => variable_get('co_ment_commentator_login', NULL),
    '#description' => t('The login name of an commentator user in your co-ment workspace.'),
  );

  $form['co_ment_commentator_passwd'] = array(
    '#type' => 'password',
    '#title' => t('Commentator password'),
    '#default_value' => variable_get('co_ment_commentator_passwd', NULL),
    '#description' => t('The password of a commentator user in your co-ment workspace.'),
  );

  $form['co_ment_observer_login'] = array(
    '#type' => 'textfield',
    '#title' => t('Observer login'),
    '#default_value' => variable_get('co_ment_observer_login', NULL),
    '#description' => t('The login name of an observer user in your co-ment workspace.'),
  );

  $form['co_ment_observer_passwd'] = array(
    '#type' => 'password',
    '#title' => t('Observer password'),
    '#default_value' => variable_get('co_ment_observer_passwd', NULL),
    '#description' => t('The password of a observer user in your co-ment workspace.'),
  );

  return system_settings_form($form);
}

function co_ment_form(&$node, $form_state) {
  // Check configuration is OK.
  if (!(variable_get('co_ment_url', NULL))) {
    drupal_set_message(t('No co-ment instance has been configured yet, please <a href="@co_ment_admin_url">configure your co-ment instance</a>.', array('@co_ment_admin_url' => url('admin/config/co-ment'))), 'error');
    return FALSE;
  }
  if (!(variable_get('co_ment_editor_login', NULL))) {
    drupal_set_message(t('No co-ment editor user has been configured yet, please <a href="@co_ment_admin_url">configure your co-ment instance</a>.', array('@co_ment_admin_url' => url('admin/config/co-ment'))), 'error');
    return FALSE;
  }

  // The site admin can decide if this node type has a title and body, and how
  // the fields should be labeled. We need to load these settings so we can
  // build the node form correctly.
  $type = node_type_get_type($node);

  if ($type->has_title) {
    $form['title'] = array(
      '#type' => 'textfield',
      '#title' => check_plain($type->title_label),
      '#required' => TRUE,
      '#default_value' => $node->title,
      '#weight' => -5,
    );
  }
  return $form;
}

/**
/**
 * Implements hook_form_alter().
 *
 * We do not want preview.
 */
function co_ment_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'co_ment_text_node_form') {
    // No preview
    $form['actions']['preview']['#attributes'] = array('style' => 'display: none;');
  }

  $co_mentable_bundles = co_ment_bundles();
  if (array_key_exists('#bundle', $form) && array_key_exists($form['#bundle'], $co_mentable_bundles) && array_key_exists($co_mentable_bundles[$form['#bundle']], $form)) {
    // Checks that co-ment instance is configured.
    if (!(variable_get('co_ment_url', NULL))) {
      drupal_set_message(t('No co-ment instance has been configured yet, please <a href="@co_ment_admin_url">configure your co-ment instance</a>.', array('@co_ment_admin_url' => url('admin/config/co-ment'))), 'error');
      return FALSE;
    }
    if (!(variable_get('co_ment_editor_login', NULL))) {
      drupal_set_message(t('No co-ment editor user has been configured yet, please <a href="@co_ment_admin_url">configure your co-ment instance</a>.', array('@co_ment_admin_url' => url('admin/config/co-ment'))), 'error');
      return FALSE;
    }

    // Adds two checkboxes to node forms for each co_mentable field.
    foreach (element_children($form[$co_mentable_bundles[$form['#bundle']]]) as $language) {
      foreach (element_children($form[$co_mentable_bundles[$form['#bundle']]][$language]) as $delta) {
        if (is_int($delta)) {
          // Just for field update, no create
          $field_name = $co_mentable_bundles[$form['#bundle']];
          $entity_type = $form[$field_name][$language][$delta]['#entity_type'];
          if (array_key_exists($entity_type, $form_state)) {
            $entity = $form_state[$entity_type];
            if (!is_null($form[$field_name][$language][$delta]['#default_value']) && array_key_exists($field_name, (array)$entity) && array_key_exists($language, $entity->$field_name) && array_key_exists($delta, $entity->{$field_name}[$language])) {
              $form[$co_mentable_bundles[$form['#bundle']]][$language][$delta]['keep_comments'] = array(
                '#type' => 'checkbox',
                '#title' => t('Keep comments (which are not affected by the edition)'),
                '#description' => t('Comments which are not affected by the edition are kept if this option is checked, deleted otherwise.'),
                '#default_value' => TRUE,
                '#weight' => $form[$co_mentable_bundles[$form['#bundle']]][$language][$delta]['#weight'] + 1,
              );
              $form[$co_mentable_bundles[$form['#bundle']]][$language][$delta]['cancel_modified_scopes'] = array(
                '#type' => 'checkbox',
                '#title' => t('Detach comments (which are affected by the edition)'),
                '#description' => t("If some comments were attached to a chunck of text that is modified, check this option to keep these comments with no scope. Leave this option unchecked if you want that such comments be deleted. This option is ignored if the previous 'Keep comment' option is unchecked."),
                '#default_value' => TRUE,
                '#weight' => $form[$co_mentable_bundles[$form['#bundle']]][$language][$delta]['#weight'] + 2,
              );
            }
          }
        }
      }
    }
  }
}

/**
 * Implements hook_theme().
 *
 * Tells Drupal about our theme functions and their arguments.
 */
function co_ment_theme() {
  return array(
    'co_ment_field' => array(
      'variables' => array('co_ment_key' => NULL, 'co_ment_version' => NULL, 'comment_id' => NULL, 'comment_op' => NULL, 'entity_type' => 'node', 'entity_id' => NULL, 'delta' => NULL, 'height' => 500),
    ),
    'co_ment_last_comments' => array(),
  );
}

/**
 * Theme function for displaying a co-ment iframe.
 */
function theme_co_ment_field($variables) {
  $output = '<div class="co_ment_body" style="border: solid 1px #E7E7E7;">';
  if (is_null($variables['co_ment_version'])) {
    if (!array_key_exists('comment_id', $variables) or is_null($variables['comment_id'])) {
      $output .= ' <iframe  frameborder="0" src="' . base_path() . 'co-ment/text/' . $variables['co_ment_key'] . '/comments_frame?delta=' . $variables['delta'] . '&entity_type=' . $variables['entity_type'] . '&entity_id=' . $variables['entity_id'] . '" style="height: ' . $variables['height'] . 'px; width: 99.9%; position: relative; top: 0px;"></iframe>';
    }
    else {
      $output .= ' <iframe  frameborder="0" src="' . base_path() . 'co-ment/text/' . $variables['co_ment_key'] . '/comments_frame?delta=' . $variables['delta'] . '&entity_type=' . $variables['entity_type'] . '&entity_id=' . $variables['entity_id'] . '&comment_id_key=' . $variables['comment_id'] . (is_null($variables['comment_op']) ? '' : '&comment_op=' . $variables['comment_op']) . '" style="height: ' . $variables['height'] . 'px; width: 99.9%; position: relative; top: 0px;"></iframe>';
    }
  }
  else {
    $output .= ' <iframe  frameborder="0" src="' . base_path() . 'co-ment/text/' . $variables['co_ment_key'] . '/comments/' . $variables['co_ment_version'] . '?delta=' . $variables['delta'] . '&entity_type=' . $variables['entity_type'] . '&entity_id=' . $variables['entity_id'] . '" style="height: ' . $variables['height'] . 'px; width: 99.9%; position: relative; top: 0px;"></iframe>';
  }
  $output .= '</div>';
  return $output;
}

/**
 * Theme function for displaying an ordered list of last comments for co-mentable fields.
 */
function theme_co_ment_last_comments($variables) {
  $co_ment_texts = array();
  foreach (co_ment_bundles() as $bundle_name => $field_name) {
    $table_name = 'field_data_' . $field_name;
    $query = db_select($table_name, 'fr')
      ->condition('deleted', 0);
    $query->addField('fr', $field_name . '_co_ment_key', 'co_ment_key');
    $query->addField('fr', 'entity_type');
    $query->addField('fr', 'entity_id');
    $query->addField('fr', 'delta');
    $co_ment_texts += $query->execute()->fetchAllAssoc('co_ment_key');
  }

  if (! empty($co_ment_texts)) {
    $comments = co_ment_fetch_comments(array_keys($co_ment_texts));
    if (! empty($comments)) {
      usort($comments, create_function('$a, $b', 'if ($a->created == $b->created) return 0; else return ($a->created > $b->created) ? -1 : 1;')) ;
      foreach ($comments as $comment) {
        $entity_type = $co_ment_texts[$comment->text_version->text->key]->entity_type;
        $entity_id = $co_ment_texts[$comment->text_version->text->key]->entity_id;
        $entity_delta = $co_ment_texts[$comment->text_version->text->key]->delta;
        $entity = entity_load($entity_type, array($entity_id));
        $entity_uri = entity_uri($entity_type, $entity[$entity_id]);
        $comment_user = user_load_by_name($comment->name);
        $comment_id = str_repeat(',', $entity_delta) . $comment->id_key;
        $comment_title = l($comment->title, $entity_uri['path'], array('query' => array('comment_id_key' => $comment_id)));
        $comment_author = l($comment->name, 'user/' . $comment_user->uid);
        $comment_date = t('@time ago', array('@time' => format_interval(time() - strtotime($comment->created))));
        $items[] = $comment_title . ' ' . t('by') . ' ' . $comment_author . ', ' . $comment_date;
      }
      return theme('item_list', array('items' => $items));
    }
  }
  return NULL;
}

/*
 * Callback to send/receive requests to/from co-ment server.
 */
function _co_ment_proxy() {
  $req = $_GET['q'];
  $req_post = $_POST;
  $url = variable_get('co_ment_url', NULL);
  // Delete ending slash.
  $url = rtrim($url, '/');

  // Retrieve node.
  if ($req != 'co-ment/jsi18n') {
    if (!empty($_GET['entity_id']) || !empty($_GET['amp;entity_id'])) {
      $entity_type = (!empty($_GET['entity_type'])) ? $_GET['entity_type'] : $_GET['amp;entity_type'];
      $entity_id = (!empty($_GET['entity_id'])) ? $_GET['entity_id'] : $_GET['amp;entity_id'];
      $entities = entity_load($entity_type, array($entity_id));
      $entity = (!empty($entities) && count($entities) == 1) ? $entities[$entity_id] : NULL;
      if (!empty($_GET['delta']) || !empty($_GET['amp;delta']))
        $delta = (!empty($_GET['delta'])) ? $_GET['delta'] : $_GET['amp;delta'];
    }
  }

  // Choose appropriate commentator user
  global $user;
  if (isset($entity_id) && $entity->uid == $user->uid) {
    $co_ment_user = variable_get('co_ment_editor_login', NULL);
    $passwd = variable_get('co_ment_editor_passwd', NULL);
  }
  elseif (user_access('post comments on co_ment_text content')) {
    $co_ment_user = variable_get('co_ment_commentator_login', NULL);
    $passwd = variable_get('co_ment_commentator_passwd', NULL);
  }
  else {
    $co_ment_user = variable_get('co_ment_observer_login', NULL);
    $passwd = variable_get('co_ment_observer_passwd', NULL);
  }
  $url = preg_replace('!://!', "://$co_ment_user:$passwd@", $url);
  $url .= preg_replace('!^[^\/]+/!', "/api/", $req) . '/?' . (empty($delta) ? '' : "delta=$delta&") . 'prefix=' . base_path() . 'co-ment';
  foreach ($_GET as $key => $val) {
    if ($key != 'q' && $key != 'prefix' && $key != 'delta') {
      $url .= "&$key=" . urlencode($val);
    }
  }

  $lang = (!empty($entity) && $entity->language) ? $entity->language : ((property_exists($user, 'language') && $user->language) ? $user->language : ($_SERVER['HTTP_ACCEPT_LANGUAGE'] ? $_SERVER['HTTP_ACCEPT_LANGUAGE'] : 'en'));
  $headers = array(
    'Accept-Language' => $lang,
    'User-Agent' => 'co-ment Drupal Module',
  );

  if (! empty($req_post)) {
    $headers['Content-Type'] = 'application/x-www-form-urlencoded';
    $req_post['name'] = strip_tags(theme('username', array('account' => $user)));
    $req_post['email'] = $user->mail;
    $response = drupal_http_request($url, array('headers' => $headers, 'method' => 'POST', 'data' => http_build_query($req_post, '', '&')));
  }
  else {
    $user_param = '&name=' . urlencode(strip_tags(theme('username', array('account' => $user))));
    if (!strpos($url, $user_param)) {
      $url .= $user_param;
    }
    $response = drupal_http_request($url, array('headers' => $headers, 'method' => 'GET', 'timeout' => 60));
  }

  foreach ($response->headers as $key => $val) {
    // IE6 is buggy when Content-Type is text/javascript.
    if ($req == 'co-ment/jsi18n') {
      if ($key == 'Content-Type' && $val == 'text/javascript') {
        $val = 'application/javascript';
      }
    }
    header("$key: $val");
  }
  print $response->data;
  exit();
}

/**
 * API function to retrieve all bundles where co_mentable fields are attached.
 *
 * @return
 *  An array of field names keyed by bundle names.
 */
function co_ment_bundles() {
  $bundles = array();
  foreach (field_read_fields(array('type' => 'co_mentable')) as $field_name => $field) {
    foreach (field_read_instances(array('field_name' => $field_name)) as $instance) {
      $bundles[$instance['bundle']] = $field_name;
    }
  }
  return $bundles;
}

/*
 * API function to fetch comments from co-ment®.
 *
 * @param $texts
 *  (optional) An array of comma separated co-ment text keys
 *  filtering which co-ment texts comments are fetched from.
 *  Defaults to all texts.
 * @param $uid
 *  (optional) A user identifier filtering comments authored
 *  by this user are fetched. Defaults to comments from all authors.
 * @param $limit
 *  (optional) An integer indicating how many comments have to be
 *  fetched. Defaults to 10.
 * @param $comment_key
 *  (optional) A comment identifier indicating which specific
 *  comment has to be fetched. Defaults to no specific comment.
 *
 * @return
 *   An array of comment objects. Each comment object has the
 *   following structure:
 *     id_key: identifier of the comment
 *     title: title of the comment
 *     name: author's name of the comment
 *     format: format of the comment (markdown or html)
 *     created: date of the comment (ex: 2011-01-13 11:13:32)
 *     content: body of the comment
 *     text_version: object representing the version of the text
 *      key: identifier of the version of the text
 *      text: object representing the text
 *        key: identifier of the text
 *        title: title of the text
 *        created: creation date of the text
 *        modified: last updating date of the text
 *
 */
function co_ment_fetch_comments($texts = array(), $uid = NULL, $limit = 10, $comment_key = NULL) {
  $comments = array();
  $url = variable_get('co_ment_url', NULL);
  // Delete ending slash.
  $url = rtrim($url, '/');
  $co_ment_user = variable_get('co_ment_commentator_login', NULL);
  $passwd = variable_get('co_ment_commentator_passwd', NULL);
  $url = preg_replace('!://!', "://$co_ment_user:$passwd@", $url) . '/api/comments/';
  $headers = array(
    'User-Agent' => 'co-ment Drupal Module',
  );
  $data = array(
    'limit' => $limit,
  );
  if (!empty($texts)) {
    $data['keys'] = implode(',', $texts);
  }
  if (!is_null($uid)) {
    $user = user_load($uid);
    $data['user'] = $user->name;
  }
  if (!is_null($comment_key)) {
    $data['comment_key'] = $comment_key;
  }
  $url .= '?' . http_build_query($data, '', '&');
  $response = drupal_http_request($url, array('headers' => $headers));

  return (json_decode($response->data));
}
