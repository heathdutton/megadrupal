<?php
// $Id: aggregator.module,v 1.20 2008/07/21 18:33:26 aronnovak Exp $

/**
 * @file
 * Used to aggregate syndicated content (RSS, RDF, and Atom).
 */

/**
 * Implementation of hook_help().
 */
function aggregator_help($path, $arg) {
  switch ($path) {
    case 'admin/help#aggregator':
      $output = '<p>' . t('The aggregator is a powerful on-site syndicator and news reader that gathers fresh content from RSS-, RDF-, and Atom-based feeds made available across the web. Thousands of sites (particularly news sites and blogs) publish their latest headlines and posts in feeds, using a number of standardized XML-based formats. Formats supported by the aggregator include <a href="@rss">RSS</a>, <a href="@rdf">RDF</a>, and <a href="@atom">Atom</a>.', array('@rss' => 'http://cyber.law.harvard.edu/rss/', '@rdf' => 'http://www.w3.org/RDF/', '@atom' => 'http://www.atomenabled.org')) . '</p>';
      $output .= '<p>' . t('Feeds contain feed items, or individual posts published by the site providing the feed. Feeds may be grouped in categories, generally by topic. Users view feed items in the <a href="@aggregator">main aggregator display</a> or by <a href="@aggregator-sources">their source</a>. Administrators can <a href="@feededit">add, edit and delete feeds</a> and choose how often to check each feed for newly updated items. The most recent items in either a feed or category can be displayed as a block through the <a href="@admin-block">blocks administration page</a>. A <a href="@aggregator-opml">machine-readable OPML file</a> of all feeds is available. A correctly configured <a href="@cron">cron maintenance task</a> is required to update feeds automatically.', array('@aggregator' => url('aggregator'), '@aggregator-sources' => url('aggregator/sources'), '@feededit' => url('admin/content/aggregator'), '@admin-block' => url('admin/build/block'), '@aggregator-opml' => url('aggregator/opml'), '@cron' => url('admin/reports/status'))) . '</p>';
      $output .= '<p>' . t('For more information, see the online handbook entry for <a href="@aggregator">Aggregator module</a>.', array('@aggregator' => 'http://drupal.org/handbook/modules/aggregator/')) . '</p>';
      return $output;
    case 'aggregator/terms':
      $output = '<p>' . t('You can assign terms to a feed at node edit form. Aggregator uses a selected vocabulary for each content-type. It\'s possible to alter the selected content-type at the content-type edit page Feed Aggregator tab. The feed items gets the same taxonomy information like the feed nodes. For example if the feed node is assigned with term foo, all the feed items belong to that feed will appear under foo term page.') . '</p>';
      return $output;
  }
}

/**
 * Implementation of hook_theme().
 */
function aggregator_theme() {
  return array(
    'aggregator_wrapper' => array(
      'arguments' => array('content' => NULL),
      'file' => 'aggregator.pages.inc',
      'template' => 'aggregator-wrapper',
    ),
    'aggregator_categorize_items' => array(
      'arguments' => array('form' => NULL),
      'file' => 'aggregator.pages.inc',
    ),
    'aggregator_feed_source' => array(
      'arguments' => array('feed' => NULL),
      'file' => 'aggregator.pages.inc',
      'template' => 'aggregator-feed-source',
    ),
    'aggregator_block_item' => array(
      'arguments' => array('item' => NULL, 'feed' => 0),
    ),
    'aggregator_summary_items' => array(
      'arguments' => array('summary_items' => NULL, 'source' => NULL),
      'file' => 'aggregator.pages.inc',
      'template' => 'aggregator-summary-items',
    ),
    'aggregator_summary_item' => array(
      'arguments' => array('item' => NULL),
      'file' => 'aggregator.pages.inc',
      'template' => 'aggregator-summary-item',
    ),
    'aggregator_item' => array(
      'arguments' => array('item' => NULL),
      'file' => 'aggregator.pages.inc',
      'template' => 'aggregator-item',
    ),
    'aggregator_page_opml' => array(
      'arguments' => array('feeds' => NULL),
      'file' => 'aggregator.pages.inc',
    ),
    'aggregator_page_rss' => array(
      'arguments' => array('feeds' => NULL, 'category' => NULL),
      'file' => 'aggregator.pages.inc',
    ),
  );
}

/**
 * Implementation of hook_menu().
 */
function aggregator_menu() {
  $types = node_get_types('types', NULL, TRUE);
  foreach ($types as $type) {
    $in_url = str_replace('_', '-', $type->type);
    $items["admin/build/node-type/$in_url/aggregator"] = array(
      'title' => 'Feed aggregator',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('aggregator_settings_form', $type->type),
      'access arguments' => array('administer news feeds'),
      'type' => MENU_LOCAL_TASK,
      'parent' => "admin/build/node-type/$type->type",
    );
  }
  $items['node/%node/refresh'] = array(
    'title' => 'Refresh',
    'page callback' => 'aggregator_refresh_page',
    'page arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'access callback' => '_aggregator_perm_refresh',
    'access arguments' => array(1),
  );
  $items['aggregator'] = array(
    'title' => 'Feed aggregator',
    'page callback' => 'aggregator_page_last',
    'access arguments' => array('access content'),
    'weight' => 5,
  );
  $items['aggregator/sources'] = array(
    'title' => 'Sources',
    'page callback' => 'aggregator_page_sources',
    'access arguments' => array('access content'),
  );
    $items['aggregator/sources/%node'] = array(
    'page callback' => 'aggregator_page_source',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  $items['aggregator/terms'] = array(
    'title' => 'Terms',
    'page callback' => 'aggregator_page_terms',
    'access arguments' => array('access content'),
  );
  $items['aggregator/terms/%'] = array(
    'title' => 'Terms',
    'page callback' => 'aggregator_page_terms',
    'page arguments' => array(2),
    'access arguments' => array('access content'),
  );
  $items['aggregator/rss'] = array(
    'title' => 'RSS feed',
    'page callback' => 'aggregator_page_rss',
    'access arguments' => array('access news feeds'),
    'type' => MENU_CALLBACK,
  );
  $items['aggregator/opml'] = array(
    'title' => 'OPML feed',
    'page callback' => 'aggregator_page_opml',
    'access arguments' => array('access news feeds'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implementation of hook_nodeapi().
 */
function aggregator_nodeapi(&$node, $op, $teaser, $page) {
  if (isset($node->feed) || variable_get('aggregator_feed_' . $node->type, FALSE)) {
    switch ($op) {
      case 'presave':
        $node = aggregator_feed_create($node->url, $node->type, $node);
        $nodes_list = array($node);
        aggregator_feed_retrieve($nodes_list);
        $node = $nodes_list[0];
        if (empty($node->title)) {
          // The title could not be empty, so in emergency case, use the url.
          $node->title = !empty($node->feed->title) ? $node->feed->title : $node->feed->url;
        }
        if (empty($node->body)) {
          $node->body = isset($node->feed->description) ? $node->feed->description : '';
        }
        break;
      case 'insert':
      case 'update':
        aggregator_feed_save($node);
        break;
      case 'load':
        $node->feed = db_fetch_object(db_query("SELECT * FROM {aggregator_feed} WHERE nid = %d", $node->nid));
        break;
      case 'delete':
        db_query("DELETE FROM {aggregator_feed} WHERE nid = %d", $node->nid);
        break;
    }
  }
  if (aggregator_is_enabled('aggregator', $node->type)) {
    switch ($op) {
      case 'delete':
        db_query('DELETE FROM {aggregator_item} WHERE nid = %d', $node->nid);
        break;
    }
  }
}

/**
 * Implementation of hook_init().
 */
function aggregator_init() {
  drupal_add_css(drupal_get_path('module', 'aggregator') . '/aggregator.css');
}

/**
 * Implementation of hook_cron().
 *
 * Checks news feeds for updates once their refresh interval has elapsed.
 * Deletes expired items.
 */
function aggregator_cron() {
  $ready = FALSE;
  if (drupal_function_exists('_aggregator_light_delete_expired')) {
    _aggregator_light_delete_expired();
  }
  $types = node_get_types();
  $nids_not_refresh = array();
  $types_skip = array();
  // Collect the feeds where the refresh interval has not elapsed.
  $start = time();
  foreach ($types as $type) {
    $refresh = variable_get('aggregator_refresh_' . $type->type, 3600);
    if ($refresh == -1) {
      $types_skip[] = "'" . $type->type . "'";
      continue;
    }
    $result = db_query("SELECT f.nid FROM {aggregator_feed} f LEFT JOIN {node} n ON f.nid = n.nid WHERE n.type = '%s' AND (%d - f.checked) < %d", $type->type, $start, $refresh);
    while ($nid = db_fetch_array($result)) {
      $nids_not_refresh[] = $nid['nid'];
    }
  }
  // Query the feeds which should be refreshed and do the refresh.
  while(_aggregator_cron_time() || !$ready) {
    $sql = "SELECT f.nid FROM {aggregator_feed} f LEFT JOIN {node} n ON n.nid = f.nid WHERE f.checked <= %d";
    $sql .= count($nids_not_refresh) > 0 ? " AND f.nid NOT IN (" . implode(', ', $nids_not_refresh) . ")" : '';
    $sql .= count($types_skip) > 0 ? " AND n.type NOT IN (" . implode(', ', $types_skip) . ")" : '';
    $result = db_query_range($sql . " ORDER BY f.checked", $start, 0, 2);
    $nids = array();
    while ($nid = db_fetch_array($result)) {
      $nids[] = $nid['nid'];
    }
    if (count($nids) == 0) {
      $ready = TRUE;
    }
    else {
      aggregator_feed_refresh($nids);
    }
  }
}

/**
 * Implementation of hook_form_alter().
 */
function aggregator_form_alter(&$form, $form_state, $form_id) {
  // Alters node form in the case of aggregator-enabled content-types.
  if (isset($form['type']) && isset($form['#node']) && $form['type']['#value'] .'_node_form' == $form_id && variable_get('aggregator_feed_' . $form['type']['#value'], FALSE)) {
    $form['title']['#required'] = FALSE;
    $url = '';
    if (isset($form_state['values']) && $form_state['values']['url']) {
      $url = $form_state['values']['url'];
    }
    else if (isset($form['#node']->feed->url)) {
      $url = $form['#node']->feed->url;
    }
    $form['url'] = array(
      '#type' => 'textfield',
      '#title' => t('Feed URL'),
      '#description' => t('Enter the URL of the feed or the URL of the website where the feed can be found.'),
      '#default_value' => $url,
      '#maxlength' => 2048,
      '#weight' => -10,
      '#required' => TRUE,
    );
  }
  // Content-type tab form, add Aggregator Light processor specific settings.
  if ($form_id == 'aggregator_settings_form' && drupal_function_exists('_aggregator_light_form_settings')) {
    _aggregator_light_form_settings($form);
    return $form;
  }
}

/**
 * Implementation of hook_requirements().
 */
function aggregator_requirements($phase) {
  $t = get_t();
  $requirements['aggregagor'] = array(
    'title' => t('Aggregator'),
    );
  $modules = module_implements('aggregator_parse');
  if (count($modules)) {
    $requirements['aggregagor']['value'] = $t('Parser module(s) installed.');
    $requirements['aggregagor']['severity'] = REQUIREMENT_OK;
  }
  else {
    $requirements['aggregagor']['value'] = $t('!enable_link (e. g. Syndication Parser) for using aggregator.', array('!enable_link' => l($t('Enable at least one parser module'), 'admin/build/modules')));
    $requirements['aggregagor']['severity'] = REQUIREMENT_ERROR;
  }
  return $requirements;
}

/**
 * Downloads the given feeds, if changed, call the parsers, call the processors.
 *
 * @param $feeds
 *   Array of nid's of the feeds or array of node objects.
 */
function aggregator_feed_refresh($feeds) {
  $feed_nodes = array();
  foreach ($feeds as $nid) {
    if (!is_object($nid)) {
      $feed = node_load(array('nid' => $nid));
    }
    else {
      $feed = $nid;
    }
    $feed_nodes[] = $feed;
  }
  aggregator_feed_retrieve($feed_nodes);
  foreach ($feed_nodes as $node) {
    aggregator_feed_save($node);
  }
}

/**
 * Builds and initializes a feed object.
 * It does not download the feed. it just creates the basic structure
 * 
 * @param $url
 *   The URL of the feed.
 * @param $type
 *   The content-type of the feed node, this determines the feed configuration.
 * @return
 *   The node-feed object 
 */
function aggregator_feed_create($url, $type, $node_skeleton = NULL) {
  $node = $node_skeleton instanceof stdClass ? $node_skeleton : new stdClass();
  $node->feed = new stdClass();
  $node->type = $type;
  $node->feed->url = $url;
  return $node;
}

/**
 * Downloads and parses the feed. populates $feed object and add the items to it.
 * It does not save the feed nor the items. 
 *
 * @param $feed_nodes
 *   The node-feed object (come from aggregator_feed_create).
 */
function aggregator_feed_retrieve(&$feed_nodes) {
  // Collect the nodes into groups by content-type
  $node_group = array();
  foreach ($feed_nodes as $k => $node) {
    if (!isset($node_group[$node->type])) {
      $node_group[$node->type] = array();
    }
    $node_group[$node->type][$k] = $node;
  }
  foreach ($node_group as $type => $nodes) {
    $parser = variable_get('aggregator_parser_' . $type, FALSE);
    $parser_in = $nodes;
    $parser_out = module_invoke($parser, 'aggregator_parse', 'parse', $parser_in);
    foreach ($parser_out as $k => $feed) {
      if (is_string($feed)) {
        $url = isset($feed_nodes[$k]->url) ? $feed_nodes[$k]->url : $feed_nodes[$k]->feed->url;
        $feed_nodes[$k]->feed = new stdClass();
        $feed_nodes[$k]->feed->url = $url;
        $feed_nodes[$k]->feed->error = $feed;
      }
      else {
        $feed_nodes[$k]->feed = $feed;
        if (isset($feed_nodes[$k]->url) && !isset($feed_nodes[$k]->feed->url)) {
          $feed_nodes[$k]->feed->url = $feed_nodes[$k]->url;
        }
      }
      $feed_nodes[$k]->feed->hash = md5(serialize($feed));
    }
  }
}

/**
 * Save or update feed
 * It becomes a node and if there are items in the object, the processors are also called
 *
 * @param $node
 *   The node-feed object
 */
function aggregator_feed_save($node) {
  if (isset($node->feed->error)) {
    watchdog('aggregator', 'The feed from %site seems to be broken, due to "%error".', array('%site' => $node->title, '%error' => $node->feed->error), WATCHDOG_WARNING);
      drupal_set_message(t('The feed from %site seems to be broken, because of error "%error".', array('%site' => $node->title, '%error' => $node->feed->error)));
  }
  $hash_array = db_fetch_array(db_query("SELECT hash FROM {aggregator_feed} WHERE nid = %d", $node->nid));
  $hash = is_array($hash_array) ? array_pop($hash_array) : NULL;
  if (empty($hash)) {
    db_query("INSERT INTO {aggregator_feed} (nid, url, link, image, checked, hash) VALUES (%d, '%s', '%s', '%s', %d, '%s')", $node->nid, $node->feed->url, isset($node->feed->link) ? $node->feed->link : '', isset($node->feed->image) ? $node->feed->image : '', time(), isset($node->feed->hash) ? $node->feed->hash : '');
  }
  else {
    db_query("UPDATE {aggregator_feed} SET url = '%s', link = '%s', image = '%s', checked = '%s', hash = '%s' WHERE nid = %d", $node->feed->url, isset($node->feed->link) ? $node->feed->link : '', isset($node->feed->image) ? $node->feed->image : '', time(), isset($node->feed->hash) ? $node->feed->hash : '', $node->nid);
  }
  if (!isset($node->feed->error)) {
    if ($hash != $node->feed->hash) {
      $processors = variable_get('aggregator_processor_' . $node->type, array());
      $deduper = variable_get('aggregator_deduper_' . $node->type, FALSE);
      foreach ($processors as $processor) {
        if (count($processors) == 1 && $deduper != FALSE) {
          module_invoke($deduper, 'aggregator_process', 'unique', $node); 
        }
        else {
          module_invoke($processor, 'aggregator_process', 'unique', $node);
        }
        $items = module_invoke($processor, 'aggregator_process', 'save', $node);
        if ($items == 0 && is_numeric($items)) {
          drupal_set_message(t('There is no new syndicated content from %site.', array('%site' => $node->title)));
        }
        else if(is_numeric($items)) {
          watchdog('aggregator', 'There is new syndicated content from %site.', array('%site' => $node->title));
          drupal_set_message(t('There is new syndicated content from %site.', array('%site' => $node->title)));
        }
      }
    }
    else {
      return FALSE;
    }
  }
}

/**
 * Format an individual feed item for display in the block.
 *
 * @param $item
 *   The item to be displayed.
 * @param $feed
 *   Not used.
 * @return
 *   The item HTML.
 * @ingroup themeable
 */
function theme_aggregator_block_item($item, $feed = 0) {
  global $user;

  $output = '';
  if ($user->uid && module_exists('blog') && user_access('create blog entries')) {
    if ($image = theme('image', 'misc/blog.png', t('blog it'), t('blog it'))) {
      $output .= '<div class="icon">' . l($image, 'node/add/blog', array('attributes' => array('title' => t('Comment on this news item in your personal blog.'), 'class' => 'blog-it'), 'query' => "iid=$item->iid", 'html' => TRUE)) . '</div>';
    }
  }

  // Display the external link to the item.
  $output .= '<a href="' . check_url($item->link) . '">' . check_plain($item->title) . "</a>\n";

  return $output;
}

/**
 * Page callbacks for refreshing a feed.
 *
 * @param $node
 *   Feed node or array of feed nodes.
 * @param $destination_path
 *   Jumps here after the refresh.
 */
function aggregator_refresh_page($node, $destination_path = NULL) {
  $feed_nodes = array($node);
  aggregator_feed_refresh($feed_nodes);
  if ($destination_path) {
    drupal_goto($destination_path);
  }
  else {
    drupal_goto('node/'. $node->nid);
  }
}

/**
 * Tells if the given module is enabled for that content-type (as parser or as processor).
 * 
 * @param $module
 *   The name of the module.
 * @param $type
 *   The name of the content-type.
 * @return
 *   TRUE if enabled, FALSE if disabled.
 */
function aggregator_is_enabled($module, $type) {
  $types = node_get_types();
  $type = str_replace('-', '_', $type);
  if ($module == variable_get('aggregator_parser_' . $types[$type]->type, '')) {
    return TRUE;
  }
  $processors = array_values(variable_get('aggregator_processor_' . $types[$type]->type, array()));
  if (in_array($module, $processors, TRUE)) {
    return TRUE;
  }
  return FALSE;
}


/**
 * Determines if the current user can refresh the feed or not.
 */
function _aggregator_perm_refresh($node) {
  global $user;
  if (variable_get('aggregator_feed_' . $node->type, FALSE) && isset($node->feed) && (user_access("edit any $node->type content") || (user_access("edit own $node->type content") && $node->uid == $user->uid))) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Checks for time limits in cron processing.
 */
function _aggregator_cron_time() {
  static $time_limit;
  $execute_percentage = 0.5;
  if (!$time_limit) {
    $time_limit = time() + ($execute_percentage / 100) * ini_get('max_execution_time');
    // However, check for left time, maybe some other cron processing already occured.
    $time_limit = min($time_limit, variable_get('cron_semaphore', 0) + ini_get('max_execution_time'));
  }
  return max($time_limit - time(), 0);
}

/**
 * Decides if the item is new or not.
 * The decision is based on the original URL of the article.
 * This is the only simple and somewhat reliable way to do.
 * @todo: I'm not sure if I agree with that :) it can actually get more complex
 *   and depending on what you're trying to aggregate you can use many things in your feed item to
 *   determine duplicity - hence:
 * @todo:
 *   We might want to go back to a hook_aggregator_process operation 'unique' that
 *   allows any enabled processor to do additional duplicate checks. 
 *   Another option, but less attractive, could be to make it the processor's responsibility to
 *   provide an API for deduping to other modules.
 * Lots of feed use the guid totally wrong.
 * 
 * @param $nid
 *   Feed-node
 * @param $item
 *   Feed item
 * @return
 *   TRUE if it is a new item, FALSE if it is already in the database.
 *   
 */
function _aggregator_unique($nid, $item) {
  $result = db_fetch_array(db_query("SELECT COUNT(*) as same FROM {aggregator_item} WHERE link = '%s' AND nid = %d", $item->link, $nid));
  return $result['same'] == 0 ? TRUE : FALSE;
}

/**
 * Collect the terms from all the aggregator_light-enabled vocabularies
 */
function _aggregator_collect_terms() {
  $types = node_get_types();
  $terms = array();
  foreach ($types as $type) {
    $vid = variable_get('aggregator_vid_' . $type->type, 0);
    if (variable_get('aggregator_feed_' . $type->type, FALSE) && $vid != 0) {
      $result = db_query("SELECT tid, name FROM {term_data} WHERE vid = %d", $vid);
      while ($vocab = db_fetch_array($result)) {
        $terms[$vocab['tid']] = $vocab['name'];
      }
    }
  }
  return $terms;
}

/**
 * Helper function for drupal_map_assoc.
 *
 * @param $count
 *   Items count.
 * @return
 *   Plural-formatted "@count items"
 */
function _aggregator_items($count) {
  return format_plural($count, '1 item', '@count items');
}
