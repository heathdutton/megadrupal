<?php
// $Id: aggregator_node.module,v 1.9 2008/07/21 11:51:27 aronnovak Exp $

/**
 * @files
 *   Provides a processor for the aggregator module.
 *   It consumes parsed data and turns into node items
 */

/**
 * Implementation of hook_help().
 */
function aggregator_node_help($path, $arg) {
  switch ($path) {
    case 'admin/help#aggregator_node':
      $output = '<p>'. t('The Aggregator Node module provides a processor to the Aggregator. It produces fully featured nodes from the feed items.');
      return $output;
  }
}

/**
 * Implementation of hook_nodeapi().
 */
function aggregator_node_nodeapi(&$node, $op, $teaser) {
  switch ($op) {
    case 'load':
      $result = db_query("SELECT i.link AS item_link, f.url AS feed_site, n.title AS feed_title FROM {aggregator_node_item} i LEFT JOIN {aggregator_feed} f ON i.nid = f.nid LEFT JOIN {node} n ON n.nid = f.nid WHERE i.item_nid = %d", $node->nid);
      $item_data = db_fetch_array($result);
      if (!empty($item_data)) {
        //@todo: more elegant way?
        $node = (array)$node;
        $node = array_merge_recursive($node, $item_data);
        $node = (object)$node;
      }
      break;
    case 'delete':
      db_query("DELETE FROM {aggregator_node_item} WHERE item_nid = %d", $node->nid);
  }
}

/**
 * Implementation of hook_link().
 */
function aggregator_node_link($type, $node = NULL) {
  if ($type == 'node') {
    $links = array();
    if (!empty($node->feed_title) && !empty($node->feed_site)) {
      $links['aggregator_feed'] = array(
      'title' => t('Originating site:') .' '. $node->feed_title,
      'href' => $node->feed_site,
      );
    }
    if (!empty($node->item_link)) {
      $links['feedapi_original'] = array(
      'title' => t('Original article'),
      'href' => $node->item_link,
      );
    }
    return $links;
  }
}

/**
 * Implementation of hook_alter().
 */
function aggregator_node_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'aggregator_settings_form') {
    $types = node_get_types();
    $types_select = array();
    foreach ($types as $type) {
      // Do not allow a content-type for both the items and the feeds
      if (!variable_get('aggregator_feed_' . $type->type, FALSE)) {
        $types_select[$type->type] = $type->name;
      }
    }
    $info = module_invoke('aggregator_node', 'aggregator_process', 'info');
    $type = $form['type']['#value'];
    $form['modules']['aggregator_node'] = array(
      '#type' => 'fieldset',
      '#title' => t('Aggregator Node processor settings'),
      '#description' => $info['description'],
      '#collapsible' => TRUE,
      '#collapsed' => !aggregator_is_enabled('aggregator_node', $type),
    );
    $form['modules']['aggregator_node']['aggregator_node_type_' . $type] = array(
      '#type' => 'select',
      '#title' => t('Content-type of the items'),
      '#multiple' => FALSE,
      '#options' => $types_select,
      '#description' => t('Select a content-type for the items.'),
      '#default_value' => variable_get('aggregator_node_type_' . $type, 'article'),
    );
    $form['modules']['aggregator_node']['aggregator_node_taxonomy_' . $type] = array(
      '#type' => 'checkbox',
      '#title' => t('Inherit feeds taxonomy to its items'),
      '#description' => t('When the feed item is created, the actual feed taxonomy is assigned to the item too. After the item is created, the module does not alter the item taxonomy.'),
      '#default_value' => variable_get('aggregator_node_taxonomy_' . $type, FALSE),
    );
    return $form;
  }
}

/**
 * Implementation of hook_aggregator_process().
 * 
 * @param $op
 *   'save' The feed items should be updated or saved.
 *   'info' Metadata about the processor
 * @param $node
 *   The feed-node object.
 */
function aggregator_node_aggregator_process($op, $node = NULL) {
  switch ($op) {
    case 'save':
      if (is_array($node->feed->items)) {
        $parent_node = FALSE;
        if (variable_get('aggregator_node_taxonomy_' . $node->type, FALSE)) {
          $parent_node = new stdClass();
          $parent_node->type = $node->type;
          $parent_node->nid = $node->nid;
          $parent_node->taxonomy = $node->taxonomy;
        }
        $new_items = 0;
        foreach ($node->feed->items as $item) {
          if (drupal_function_exists('_aggregator_node_save')) {
            $item->body = $item->description;
            $item->uid = $node->uid;
            $item->type = variable_get('aggregator_node_type_' . $node->type, 'article');;
            if ($item->unique === TRUE) {
              $item_nid = _aggregator_node_save($item, $parent_node);
              db_query("INSERT INTO {aggregator_node_item} (item_nid, nid, link) VALUES (%d, %d, '%s')", $item_nid, $node->nid, $item->link);
              $new_items++;
            }
            else {
              $item->nid = $item->unique;
              $item_nid = _aggregator_node_save($item);
              db_query("UPDATE {aggregator_node_item} SET link = '%s' WHERE item_nid = %d", $item->link, $item_nid);
            }
          }
        }
        return $new_items;
      }
      break;
    case 'info':
      return array(
        'title' => t('Aggregator Node'),
        'description' => t('Provides node item processor for Aggregator.'),
      );
    case 'unique':
      foreach ($node->feed->items as $k => $item) {
        $nid = db_result(db_query("SELECT item_nid FROM {aggregator_node_item} WHERE link = '%s' AND nid = %d", $item->link, $node->nid));
        $node->feed->items[$k]->unique = ($nid == FALSE ? TRUE : $nid);
      }
      break;
  }
}

