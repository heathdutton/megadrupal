<?php
/**
 * @file
 * Context.IO main module file.
 */

/**
 * The name of the library.
 */
define('CONTEXTIO_LIBRARY_NAME', 'PHP-ContextIO');

/**
 * Filter for accounts which has invalid credentials.
 */
define('CONTEXTIO_FILTER_INVALID_CREDENTIALS', 'INVALID_CREDENTIALS');

/**
 * Filter for accounts for which the connection is not possible.
 */
define('CONTEXTIO_FILTER_CONNECTION_IMPOSSIBLE', 'CONNECTION_IMPOSSIBLE');

/**
 * Filter for accounts which has no access to all mail.
 */
define('CONTEXTIO_FILTER_NO_ACCESS_TO_ALL_MAIL', 'NO_ACCESS_TO_ALL_MAIL');

/**
 * Filter for acccounts for which the status is OK.
 */
define('CONTEXTIO_FILTER_OK', 'OK');

/**
 * Filter for temporary disabled accounts.
 */
define('CONTEXTIO_FILTER_TEMP_DISABLED', 'TEMP_DISABLED');

/**
 * Filter for disabled accounts.
 */
define('CONTEXTIO_FILTER_DISABLED', 'DISABLED');

/**
 * Contact related files.
 */
define('CONTEXTIO_CONTACT_TYPE_FILES', 0);

/**
 * Contact related messages.
 */
define('CONTEXTIO_CONTACT_TYPE_MESSAGES', 1);

/**
 * Contact related threads.
 */
define('CONTEXTIO_CONTACT_TYPE_THREADS', 2);

/**
 * String value.
 */
define('CONTEXTIO_STRING', 3);

/**
 * Email value.
 */
define('CONTEXTIO_EMAIL', 4);

/**
 * Int value.
 */
define('CONTEXTIO_INT', 5);

/**
 * Bool value.
 */
define('CONTEXTIO_BOOL', 6);

/**
 * Implements hook_libraries_info().
 */
function contextio_libraries_info() {
  $libraries = array();
  $libraries[CONTEXTIO_LIBRARY_NAME] = array(
    'name' => 'Context.IO API',
    'vendor url' => 'https://context.io/',
    'download url' => 'https://github.com/contextio/PHP-ContextIO',
    'version callback' => 'contextio_library_version',
    'files' => array(
      'php' => array(
        'vendor/autoload.php',
      ),
    ),
  );
  return $libraries;
}

/**
 * Version callback for contextio_libraries_info().
 */
function contextio_library_version() {
  // Just return TRUE, version cannot be determined from the library.
  return TRUE;
}

/**
 * Helper function encrypt data.
 *
 * @param string $data
 *   The data which needs to be encrypted.
 *
 * @return string
 *   The encrypted data.
 */
function contextio_encrypt($data) {
  // Generate a random initialization vector for the encryption.
  $iv = openssl_random_pseudo_bytes(16);

  // AES-256-GCM is not supported by PHP right now so we use CBC instead.
  return $iv . openssl_encrypt($data, 'aes-256-cbc', substr(drupal_get_hash_salt(), 0, 16), 0, $iv);
}

/**
 * Helper function to decrypt data.
 *
 * @param string $data
 *   The encrypted data which needs to be decrypted.
 *
 * @return string
 *   The decrypted data.
 */
function contextio_decrypt($data) {
  // Get the initialization vector and the encrypted private token.
  $iv = substr($data, 0, 16);
  $encrypted_string = substr($data, 16);

  // Decrypt the encrypted string.
  return openssl_decrypt($encrypted_string, 'aes-256-cbc', substr(drupal_get_hash_salt(), 0, 16), 0, $iv);
}

/**
 * Helper function to load the initialized ContextIO library.
 *
 * @param string $key
 *   (optional) Context.IO key for the connection.
 * @param string $secret
 *   (optional) Context.IO secret key for the connection.
 *
 * @return ContextIO
 *   ContextIO object.
 *
 * @throws Exception
 *   If one of the keys are missing or empty.
 */
function contextio_get_object($key = '', $secret = '') {
  libraries_load(CONTEXTIO_LIBRARY_NAME);

  if (empty($key)) {
    $key = contextio_decrypt(variable_get('contextio_key'));

    if (is_null($key)) {
      throw new Exception('Key is missing for authentication!');
    }
  }

  if (empty($secret)) {
    $secret = contextio_decrypt(variable_get('contextio_secret'));

    if (is_null($secret)) {
      throw new Exception('Secret is missing for authentication!');
    }
  }

  return new ContextIO($key, $secret);
}

/**
 * List accounts.
 *
 * @param array $filters
 *   An array of filters values. The following keys are available:
 *   - email (string): Only return account associated to this email address.
 *   - status (string): Only return accounts with sources whose status is of a
 *     specific value. If an account has many sources, only those matching
 *     the given value will be included in the response. Possible values are:
 *     - INVALID_CREDENTIALS
 *     - CONNECTION_IMPOSSIBLE
 *     - NO_ACCESS_TO_ALL_MAIL
 *     - OK
 *     - TEMP_DISABLED
 *     - DISABLED
 *   - status_ok (integer): Set to 0 to get all accounts with sources that are
 *     not working correctly. Set to 1 for the opposite. As for the status
 *     filter above, only sources matching the specific value are included
 *     in the response.
 *   - limit (integer): The maximum number of results to return. The maximum
 *     limit is 250.
 *   - offset (integer): Start the list at this offset (zero-based).
 * @param ContextIO $contextio
 *   Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts#get
 *
 * @return array
 *   The list of the accounts.
 *
 * @throws Exception
 *   If one of the filter values has invalid type or value.
 */
function contextio_accounts_list(array $filters = array(), ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  // If no filters defined list all accounts.
  if (empty($filters)) {
    $accounts = $contextio->listAccounts();
  }
  // Otherwise apply filters.
  else {
    $accounts = $contextio->listAccounts($filters);
  }

  if ($accounts !== FALSE) {
    return $accounts->getData();
  }
  else {
    $response = $contextio->getLastResponse();
    $data = $response->getData();
    throw new Exception(t('An error happend while trying to fetch the accounts list: !error, HTTP code: !code', array(
      '!error' => $data['value'],
      '!code' => $response->getHttpCode(),
    )));
  }
}

/**
 * Get single account by ID.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param ContextIO $contextio
 *   Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts#id-get
 *
 * @return array
 *   The fetched single account.
 *
 * @throws Exception
 *   If $id empty or not a string.
 */
function contextio_get_account($account_id, ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  $contextio_account = $contextio->getAccount($account_id);

  if ($contextio_account !== FALSE) {
    return $contextio_account->getData();
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return array();
    }

    $data = $response->getData();
    throw new Exception(t('An error happend while trying to fetch account: !error, HTTP code: !code', array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * Create new account.
 *
 * This will create a new account on Context.IO without any mailboxes.
 *
 * @param string $email_or_migrate_account_id
 *   (Currently only email supported in the API)
 *   The primary email address of the account holder or an existing user_id
 *   (from lite) you want to migrate to 2.0. Either migrate_account_id or email
 *   must be specified.
 * @param string $first_name
 *   (optional) First name of the account holder.
 * @param string $last_name
 *   (optional) Last name of the account holder.
 * @param ContextIO $contextio
 *   (optional) Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts#post
 *
 * @returns bool
 *   TRUE if the account was created successfully. Otherwise an exception will
 *   be thrown.
 *
 * @throws Exception
 *    If the parameters has invalid type.
 */
function contextio_create_new_account($email_or_migrate_account_id, $first_name = '', $last_name = '', ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  $params = array();
  if (filter_var($email_or_migrate_account_id, FILTER_VALIDATE_EMAIL)) {
    $params['email'] = $email_or_migrate_account_id;
  }
  else {
    // Not yet supported by the API, so throw an error for now.
    // $params['migrate_account_id'] = $email_or_migrate_account_id;
    throw new Exception(t('migrate_account_id is not supported by the Context.IO PHP API yet.'));
  }

  if (!empty($first_name)) {
    $params['first_name'] = $first_name;
  }

  if (!empty($last_name)) {
    $params['last_name'] = $last_name;
  }

  if ($contextio->addAccount($params) !== FALSE) {
    return TRUE;
  }
  else {
    $response = $contextio->getLastResponse();
    $data = $response->getData();
    throw new Exception(t('An error happened while trying to create a new account: !error, HTTP code: !code', array(
      '!error' => $data['value'],
      '!code' => $response->getHttpCode(),
    )));
  }
}

/**
 * Modify an existing account by ID.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param string $first_name
 *   First name of the account holder, either this or last_name must be
 *   specified.
 * @param string $last_name
 *   Last name of the account holder, either this or first_name must be
 *   specified.
 * @param ContextIO $contextio
 *   (optional) Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts#id-post
 *
 * @return bool
 *   TRUE if the account was modified successfully, FALSE if the account with
 *   the given ID is not found.
 *
 * @throws Exception
 *   If an error happened.
 */
function contextio_modify_account($account_id, $first_name = '', $last_name = '', ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  // Check if at least the first or last name is set.
  if (empty($first_name) && empty($last_name)) {
    throw new Exception(t('At least the first_name or the last_name must specified.'));
  }

  $params = array();
  if (!empty($first_name)) {
    $params['first_name'] = $first_name;
  }

  if (!empty($last_name)) {
    $params['last_name'] = $last_name;
  }

  if ($contextio->modifyAccount($account_id, $params) !== FALSE) {
    return TRUE;
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return FALSE;
    }

    $data = $response->getData();
    throw new Exception(t('An error happened while trying to modify the account: !error, HTTP code: !code', array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * Delete an account by ID.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param ContextIO $contextio
 *   (optional) Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts#id-delete
 *
 * @return bool
 *   TRUE if the account was successfully deleted, FALSE if the account with
 *   the given ID is not found.
 *
 * @throws Exception
 *   If an error happened.
 */
function contextio_delete_account($account_id, ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  if ($contextio->deleteAccount($account_id) !== FALSE) {
    return TRUE;
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return FALSE;
    }

    $data = $response->getData();
    throw new Exception(t('An error happened while trying to delete the account: !error, HTTP code: !code', array(
      '!error' => isset($data['value']) ? $data['value'] : '',
      '!code' => $code,
    )));
  }
}

/**
 * Add a new connect token.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param array $params
 *   Parameters array. The following keys are available:
 *   - callback_url (string): When the user's mailbox is connected to your API
 *       key, the browser will call this url (GET). This call will have a
 *       parameter called contextio_token indicating the connect_token related
 *       to this callback. You can then do a get on this connect_token to
 *       obtain details about the account and source created through that token
 *       and save that account id in your own user data.
 *   - email: (string, optional) The email address of the account to be added.
 *       If specified, the first step of the connect UI where users are
 *       prompted for their email address, first name and last name is skipped.
 *   - first_name: (string, optional) First name of the account holder.
 *   - last_name: (string, optional) Last name of the account holder.
 *   - source_callback_url: (string, optional) If specified, we'll make a POST
 *       request to this URL when the initial sync is completed.
 *   - source_expunge_on_deleted_flag: (string, optional) By default, we don't
 *       filter out messages flagged as deleted. Set this parameter to 1 to
 *       turn on this filtering.
 *   - source_sync_all_folders: (string optional) By default, we filter out
 *       some folders like 'Deleted Items' and 'Drafts'. Set this parameter to
 *       1 to turn off this filtering and show every single folder.
 *   - source_sync_folders: (string, optional) By default, we filter out some
 *       folders like 'Deleted Items' and 'Drafts'. Set this parameter to
 *       All,Trash to show the 'Deleted Items' folder.
 *   - source_sync_flags: (string optional) By default, we don't synchronize
 *       IMAP flags. Set this parameter to 1 to turn on IMAP flag syncing for
 *       the 'seen' and 'flagged' flags.
 *   - source_raw_file_list: (string, optional) By default, we filter out files
 *       like signature images or those winmail.dat files form the files list.
 *       Set this parameter to 1 to turn off this filtering and show every
 *       single file attachments.
 *   - status_callback_url: (string, optional) If specified, we'll make a POST
 *       request to this URL if the connection status of the source changes.
 * @param ContextIO $contextio
 *   (optional) Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/connect_tokens#post
 *
 * @return array
 *   An array of information about the connect token creation or an empty array
 *   if the the account with the given ID is not found.
 *
 * @throws Exception
 *   If an error happened.
 */
function contextio_add_connect_token($account_id, array $params, ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  if (empty($params['callback_url'])) {
    throw new Exception(t('The callback_url parameter must be provided and cannot be empty!'));
  }

  $connect_token = $contextio->addConnectToken($account_id, $params);

  if ($connect_token !== FALSE) {
    return $connect_token->getData();
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return array();
    }

    $data = $response->getData();
    throw new Exception(t('An error happened while trying to add a new connect token: !error, HTTP code: !code', array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * Get the list of connect tokens by account ID.
 *
 * @param string $account_id
 *   An id of the account the connect token used for.
 * @param ContextIO $contextio
 *   (optional) Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/connect_tokens#get
 *
 * @return array
 *   An array list of the connect tokens.
 */
function contextio_get_connect_token_list($account_id, ContextIO $contextio = NULL) {
  return contextio_get_connect_token($account_id, '', $contextio);
}

/**
 * Get connect token by account ID.
 *
 * @param string $account_id
 *   An id of the account the connect token used for.
 * @param string $token
 *   (optional) The unique connect token identifier.
 * @param ContextIO $contextio
 *   (optional) Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/connect_tokens#id-get
 *
 * @return array
 *   An array list of connect tokens if $token is left empty, otherwise a
 *   single token information will be returned.
 *
 * @throws Exception
 *   If an error happened.
 */
function contextio_get_connect_token($account_id, $token = '', ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  $connect_token = $contextio->getConnectToken($account_id, $token);

  if ($connect_token !== FALSE) {
    return $connect_token->getData();
  }
  else {
    $response = $contextio->getLastResponse();

    // Return an empty array if not found.
    if (($code = $response->getHttpCode()) == 404) {
      return array();
    }

    $data = $response->getData();
    throw new Exception(t('An error happened while trying to get a connect token: !error, HTTP code: !code', array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * Delete a connect token by account ID and token.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param string $token
 *   The unique random token used to add a second source to an existing
 *   account.
 * @param ContextIO $contextio
 *   (optional) Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/connect_tokens#id-delete
 *
 * @returns bool
 *   TRUE if the connect token was successfully deleted, FALSE if it is not
 *   found.
 *
 * @throws Exception
 *   If an error happened.
 */
function contextio_delete_connect_token($account_id, $token, ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  if ($contextio->deleteConnectToken($account_id, $token) !== FALSE) {
    return TRUE;
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return FALSE;
    }

    $data = $response->getData();
    throw new Exception(t('An error happened while trying to delete the connect token: !error, HTTP code: !code', array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * Get contacts list.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param array $filters
 *   (optional) List filters.
 *   Possible values:
 *     - search (string): String identifying the name or the email address of
 *         the contact(s) you are looking for.
 *     - active_before (integer, unix time): Only include contacts included in
 *         at least one email dated before a given time. This parameter should
 *         be a standard unix timestamp.
 *     - active_after (integer, unix time): Only include contacts included in
 *         at least one email dated after a given time. This parameter should
 *         be a standard unix timestamp.
 *     - sort_by (string): The field by which to sort the returned results.
 *         Possible values are email, count, received_count and sent_count.
 *     - sort_order (string): The sort order of the returned results.
 *         Possible values are asc and desc
 *     -limit (integer): The maximum number of results to return. The maximum
 *         limit is 250.
 *     -offset (integer): Start the list at this offset (zero-based).
 * @param ContextIO $contextio
 *   (optional) Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/contacts#get
 *
 * @return array
 *   The list of the contacts or an empty array if not found.
 *
 * @throws Exception
 *   If any of the filters type are not matched or an error happened.
 */
function contextio_contacts_list($account_id, array $filters = array(), ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  if (!empty($filters)) {
    $contacts_list = $contextio->listContacts($account_id, $filters);
  }
  else {
    $contacts_list = $contextio->listContacts($account_id);
  }

  if ($contacts_list !== FALSE) {
    return $contacts_list->getData();
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return array();
    }

    $data = $response->getData();
    throw new Exception(t('An error happened while trying to fetch the contact list: !error, HTTP code: !code', array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * Get a single contact.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param string $email
 *   Email address of a contact.
 * @param ContextIO $contextio
 *   (optional) Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/contacts#id-get
 *
 * @return array
 *   The contact information or an empty array if not found.
 *
 * @throws Exception
 *   If the account ID or email is not in the correct type or if an error
 *   happened.
 */
function contextio_get_contact($account_id, $email, ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  $contact = $contextio->getContact($account_id, $email);

  if ($contact !== FALSE) {
    return $contact->getData();
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return array();
    }

    $data = $response->getData();
    throw new Exception(t('An error happened while trying to get the contact: !error, HTTP code: !code', array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * Listing files exchanged with a contact.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param string $email
 *   Email address of a contact.
 * @param array $filters
 *   (optional) List filters.
 *   Possible values:
 *     - limit (integer): The maximum number of results to return. The maximum
 *         limit is 100.
 *     - offset (integer): Start the list at this offset (zero-based).
 * @param ContextIO $contextio
 *   (optional) Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/contacts/files#get
 *
 * @return array
 *   The list of the files exchanged with contact or empty array if not found
 *   any.
 *
 * @throws Exception
 *   If the account ID or email is not in the correct type or if an error
 *   happened.
 */
function contextio_contact_files_list($account_id, $email, array $filters = array(), ContextIO $contextio = NULL) {
  return contextio_get_contact_related_data(CONTEXTIO_CONTACT_TYPE_FILES, $account_id, $email, $filters, $contextio);
}

/**
 * Listing messages where a contact is present.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param string $email
 *   Email address of a contact.
 * @param array $filters
 *   (optional) List filters.
 *   Possible values:
 *     - limit (integer): The maximum number of results to return. The maximum
 *         limit is 100.
 *     - offset (integer): Start the list at this offset (zero-based).
 * @param ContextIO $contextio
 *   (optional) Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/contacts/messages#get
 *
 * @return array
 *   The list of messages where contact is exists or empty array if not found
 *   any.
 */
function contextio_contact_messages_list($account_id, $email, array $filters = array(), ContextIO $contextio = NULL) {
  return contextio_get_contact_related_data(CONTEXTIO_CONTACT_TYPE_MESSAGES, $account_id, $email, $filters, $contextio);
}

/**
 * Listing threads where a contact is present.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param string $email
 *   Email address of a contact.
 * @param array $filters
 *   (optional) List filters.
 *   Possible values:
 *     - limit (integer): The maximum number of results to return. The maximum
 *         limit is 100.
 *     - offset (integer): Start the list at this offset (zero-based).
 * @param ContextIO $contextio
 *   (optional) Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/contacts/threads#get
 *
 * @return array
 *   The list of messages where contact is exists or empty array if not found
 *   any.
 */
function contextio_contact_threads_list($account_id, $email, array $filters = array(), ContextIO $contextio = NULL) {
  return contextio_get_contact_related_data(CONTEXTIO_CONTACT_TYPE_THREADS, $account_id, $email, $filters, $contextio);
}

/**
 * Helper function to get a specific type of data from contact.
 *
 * @param string $type
 *   The type of the related data, possible values are:
 *     - CONTEXTIO_CONTACT_TYPE_FILES: related files.
 *     - CONTEXTIO_CONTACT_TYPE_MESSAGES: related messages.
 *     - CONTEXTIO_CONTACT_TYPE_THREADS: related threads.
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param string $email
 *   Email address of a contact.
 * @param array $filters
 *   (optional) List filters.
 *   Possible values:
 *     - limit (integer): The maximum number of results to return. The maximum
 *         limit is 100.
 *     - offset (integer): Start the list at this offset (zero-based).
 * @param ContextIO $contextio
 *   (optional) Initialized ContextIO object.
 *
 * @return array
 *   The list of the requested related contact data or empty array if not
 *   found.
 *
 * @throws Exception
 *   If the account ID or email is not in the correct type or if an error
 *   happened.
 */
function contextio_get_contact_related_data($type, $account_id, $email, array $filters = array(), ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  $possible_values = array(
    CONTEXTIO_CONTACT_TYPE_FILES,
    CONTEXTIO_CONTACT_TYPE_MESSAGES,
    CONTEXTIO_CONTACT_TYPE_THREADS,
  );
  if (!in_array($type, $possible_values)) {
    throw new Exception(t('$type must be either CONTEXTIO_CONTACT_TYPE_FILES, CONTEXTIO_CONTACT_TYPE_MESSAGES or CONTEXTIO_CONTACT_TYPE_THREADS!'));
  }

  if (!empty($filters)) {
    $filters['email'] = $email;
    switch ($type) {
      case CONTEXTIO_CONTACT_TYPE_FILES:
        $data = $contextio->listContactFiles($account_id, $filters);
        break;

      case CONTEXTIO_CONTACT_TYPE_MESSAGES:
        $data = $contextio->listContactMessages($account_id, $filters);
        break;

      case CONTEXTIO_CONTACT_TYPE_THREADS:
        $data = $contextio->listContactThreads($account_id, $filters);
        break;

      default:
        // This should never happen.
        $data = FALSE;
    }
  }
  else {
    switch ($type) {
      case CONTEXTIO_CONTACT_TYPE_FILES:
        $data = $contextio->listContactFiles($account_id, array('email' => $email));
        break;

      case CONTEXTIO_CONTACT_TYPE_MESSAGES:
        $data = $contextio->listContactMessages($account_id, array('email' => $email));
        break;

      case CONTEXTIO_CONTACT_TYPE_THREADS:
        $data = $contextio->listContactThreads($account_id, array('email' => $email));
        break;

      default:
        // This should never happen.
        $data = FALSE;
    }
  }

  if ($data !== FALSE) {
    return $data->getData();
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return array();
    }

    $data = $response->getData();
    throw new Exception(t('An error happened while trying to get the contact !type list: !error, HTTP code: !code', array(
      '!type' => $type,
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * List of email addresses used by an account.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param ContextIO $contextio
 *   (optional) Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/email_addresses#get
 *
 * @return array
 *   The list of the email addresses used by the given account.
 *
 * @throws Exception
 *   If the id is not string or if an error happened.
 */
function contextio_email_addresses_list($account_id, ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  $email_addresses = $contextio->listAccountEmailAddresses($account_id);

  if ($email_addresses !== FALSE) {
    return $email_addresses->getData();
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return array();
    }

    $data = $response->getData();
    throw new Exception(t('An error happened while trying to get the email addresses list: !error, HTTP code: !code', array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * Adding a new email addresses as an alias for an account.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param string $email
 *   An email address.
 * @param ContextIO $contextio
 *   (optional) Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/email_addresses#post
 *
 * @return array
 *   The status of the query or an empty array if the account is not found.
 *
 * @throws Exception
 *   If id or email is not have a valid type or if an error happened.
 */
function contextio_add_email_address_alias($account_id, $email, ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  $status = $contextio->addEmailAddressToAccount($account_id, array('email_address' => $email));

  if ($status !== FALSE) {
    return $status->getData();
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return array();
    }

    $data = $response->getData();
    throw new Exception(t('An error happened while trying to add a new email address for the account: !error, HTTP code: !code', array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * Make the given email address as primary for the given account.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param string $email
 *   The email address which needs to be set as primary.
 * @param ContextIO $contextio
 *   (optional) Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/email_addresses#id-post
 *
 * @return bool
 *   TRUE if the email was successfully set as primary and FALSE if the email
 *   address or account is not found.
 *
 * @throws Exception
 *   If id or email is not have a valid type or if an error happened.
 */
function contextio_set_email_address_primary($account_id, $email, ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  if ($contextio->setPrimaryEmailAddressForAccount($account_id, $email) !== FALSE) {
    return TRUE;
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return FALSE;
    }

    $data = $response->getData();
    throw new Exception(t('An error happened while trying to set the email address as primary: !error, HTTP code: !code', array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * Removing an email addresses form the aliases of an account.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param string $email
 *   The email address which needs to be set as primary.
 * @param ContextIO $contextio
 *   (optional) Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/email_addresses#id-delete
 *
 * @return bool
 *   TRUE if the email was successfully set as primary and FALSE if the email
 *   address or account is not found.
 *
 * @throws Exception
 *   If id or email is not have a valid type or if an error happened.
 */
function contextio_delete_email_address_alias($account_id, $email, ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  if ($contextio->deleteEmailAddressFromAccount($account_id, $email) !== FALSE) {
    return TRUE;
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return FALSE;
    }

    $data = $response->getData();
    throw new Exception(t('An error happened while trying to delete email address: !error, HTTP code: !code', array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * List of files which are found as email attachments.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param array $filters
 *   (optional) List filters.
 *   Possible values:
 *     - file_name (string): Search for files based on their name. You can
 *         filter names using typical shell wildcards such as *, ? and [] or
 *         regular expressions by enclosing the search expression in a
 *         leading / and trailing /. For example, *.pdf would give you all PDF
 *         files while /\.jpe?g$/ would return all files whose name ends with
 *         .jpg or .jpeg
 *     - file_size_min (integer): Search for files based on their size
 *         (in bytes).
 *     - file_size_max (integer): Search for files based on their size
 *         (in bytes).
 *     - email (string): Email address of the contact for whom you want the
 *         latest files exchanged with. By "exchanged with contact X" we mean
 *         any email received from contact X, sent to contact X or sent by
 *         anyone to both contact X and the source owner.
 *     - to (string): Email address of a contact files have been sent to.
 *     - from (string): Email address of a contact files have been received
 *         from.
 *     - cc (string): Email address of a contact CC'ed on the messages.
 *     - bcc (string): Email address of a contact BCC'ed on the messages.
 *     - date_before (integer, unix time): Only include files attached to
 *         messages sent before a given timestamp. The value this filter is
 *         applied to is the Date: header of the message which refers to the
 *         time the message is sent from the origin.
 *     - date_after (integer, unix time): Only include files attached to
 *         messages sent after a given timestamp. The value this filter is
 *         applied to is the Date: header of the message which refers to the
 *         time the message is sent from the origin.
 *     - indexed_before (integer, unix time): Only include files attached to
 *         messages indexed before a given timestamp. This is not the same as
 *         the date of the email, it is the time Context.IO indexed this
 *         message.
 *     - indexed_after (integer, unix time): Only include files attached to
 *         messages indexed after a given timestamp. This is not the same as
 *         the date of the email, it is the time Context.IO indexed this
 *         message.
 *     - source (string): Filter messages by the account source label.
 *     - sort_order (string): The sort order of the returned results. Possible
 *         values are asc and desc
 *     - limit (integer): The maximum number of results to return. The maximum
 *         limit is 100.
 *     - offset (integer): Start the list at this offset (zero-based).
 * @param ContextIO $contextio
 *   (optional) Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/files#get
 *
 * @return bool
 *   The list of the found attachments or an empty array if no files are found.
 *
 * @throws Exception
 *   If $id is a string or if one of the filters's type or requirements are not
 *   matched.
 *   Also if an error happened while trying to get the list.
 */
function contextio_files_list($account_id, array $filters = array(), ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  if (!empty($filters)) {
    $files = $contextio->listFiles($account_id, $filters);
  }
  else {
    $files = $contextio->listFiles($account_id);
  }

  if ($files !== FALSE) {
    return $files->getData();
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return array();
    }

    $data = $response->getData();
    throw new Exception(t('An error happened while trying to get the files list: !error, HTTP code: !code', array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * Get a single file details.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param string $file_id
 *   Unique id of a file.
 * @param ContextIO $contextio
 *   (optional) Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/files#id-get
 *
 * @return array
 *   The details of the found file or an empty array if not found.
 *
 * @throws Exception
 *   If $id or $file_id is not a string or if an error happened while trying to
 *   get the list.
 */
function contextio_get_file_details($account_id, $file_id, ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  $file = $contextio->getFile($account_id, $file_id);

  if ($file !== FALSE) {
    return $file->getData();
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return array();
    }

    $data = $response->getData();
    throw new Exception(t('An error happened while trying to get the file details: !error, HTTP code: !code', array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * List of other files related to a given file.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param string $file_id
 *   Unique id of a file.
 * @param ContextIO $contextio
 *   (optional) Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/files/related#get
 *
 * @return array
 *   The related list of files or an empty array if non found.
 *
 * @throws Exception
 *   If $id or $file_id is not a string or if an error happened while trying to
 *   get the list.
 */
function contextio_related_files_list($account_id, $file_id, ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  $related_file = $contextio->listFileRelated($account_id, $file_id);

  if ($related_file !== FALSE) {
    return $related_file->getData();
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return array();
    }

    $data = $response->getData();
    throw new Exception(t('An error happened while trying to get the file details: !error, HTTP code: !code', array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * Get messages by account ID.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param array $filters
 *   An array of filters. The following key are available:
 *   - subject (string): Get messages whose subject matches this search
 *     string. To use regular expressions instead of simple string matching,
 *     make sure the string starts and ends with /.
 *   - email (string): Only return account associated to this email address.
 *   - to (string): Email address of a contact messages have been sent to.
 *   - from (string): Email address of a contact messages have been received
 *     from.
 *   - cc (string): Email address of a contact CC'ed on the messages.
 *   - bcc (string): Email address of a contact BCC'ed on the messages.
 *   - folder (string): Filter messages by the folder (or Gmail label). This
 *     parameter can be the complete folder name with the appropriate
 *     hierarchy delimiter for the mail server being queried
 *     (eg. Inbox/My folder) or the "symbolic name" of the folder
 *     (eg. \Starred). The symbolic name refers to attributes used to refer
 *     to special use folders in a language-independent way. See RFC-6154.
 *   - source (string): Filter messages by the account source label.
 *   - file_name (string): Search for files based on their name. You can
 *     filter names using typical shell wildcards such as *, ? and [] or
 *     regular expressions by enclosing the search expression in a
 *     leading / and trailing /. For example, *.pdf would give you all PDF
 *     files while /\.jpe?g$/ would return all files whose name ends with
 *     .jpg or .jpeg.
 *   - file_size_min (integer): Search for files based on their size (in bytes).
 *   - file_size_max (integer): Search for files based on their size (in bytes).
 *   - date_before (unix time): Only include messages before a given
 *     timestamp. The value this filter is applied to is the Date: header of
 *     the message which refers to the time the message is sent from the
 *     origin.
 *   - date_after (unix time): Only include messages after a given timestamp.
 *     The value this filter is applied to is the Date: header of the
 *     message which refers to the time the message is sent from the origin.
 *   - indexed_before (unix time): Only include messages indexed before a
 *     given timestamp. This is not the same as the date of the email, it is
 *     the time Context.IO indexed this message.
 *   - indexed_after (unix time): Only include messages indexed after a given
 *     timestamp. This is not the same as the date of the email, it is the
 *     time Context.IO indexed this message.
 *   - include_thread_size (integer): Set to 1 to include thread size in the
 *     result.
 *   - include_body (integer): Set to 1 to include message bodies in the
 *     result. Since message bodies must be retrieved from the IMAP server,
 *     expect a performance hit when setting this parameter.
 *   - include_headers (mixed): Can be set to 0 (default), 1 or raw.
 *     If set to 1, complete message headers, parsed into an array, are
 *     included in the results. If set to raw, the headers are also included
 *     but as a raw unparsed string. Since full original headers bodies must
 *     be retrieved from the IMAP server, expect a performance hit when
 *     setting this parameter.
 *   - include_flags (integer): Set to 1 to include IMAP flags of messages in
 *     the result. Since message flags must be retrieved from the IMAP
 *     server, expect a performance hit when setting this parameter.
 *   - body_type (string): Used when include_body is set to get only body
 *     parts of a given MIME-type (for example text/html)
 *   - include_source (integer): Set to 1 to include message sources in the
 *     result. Since message sources must be retrieved from the IMAP server,
 *     expect a performance hit when setting this parameter.
 *   - sort_order (string): The sort order of the returned results. Possible
 *     values are asc and desc
 *   - limit (integer): The maximum number of results to return. The maximum
 *     limit is 100.
 *   - offset (integer): Start the list at this offset (zero-based).
 * @param ContextIO $contextio
 *   Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/messages#get
 *
 * @return array
 *   An array of messages or an empty array if the account with the given ID
 *   is not found.
 *
 * @throws Exception
 *   If an error happened.
 */
function contextio_get_messages($account_id, array $filters = array(), ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  if (empty($filters)) {
    $messages = $contextio->listMessages($account_id);
  }
  else {
    // Check for include_headers filter type.
    if (isset($filters['include_headers']) && !is_int($filters['include_headers']) || (isset($filters['include_headers']) && $filters['include_headers'] != 'raw')) {
      throw new Exception(t('include_headers must be an integer or raw!'));
    }

    $messages = $contextio->listMessages($account_id, $filters);
  }

  if ($messages !== FALSE) {
    return $messages->getData();
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return array();
    }

    $data = $response->getData();
    throw new Exception(t('An error happened while trying to fetch messages: !error, HTTP code: !code', array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * Get a single message by ID.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param string $message_id
 *   Unique id of a message. This can be the message_id or email_message_id
 *   property of the message. The gmail_message_id (prefixed with gm-) can also
 *   be used.
 * @param array $filters
 *   An array of filter values. The following keys are available:
 *   - include_thread_size (integer): Set to 1 to include thread size in the
 *     result.
 *   - include_body (integer): Set to 1 to include the message body in the
 *     result. Since the body must be retrieved from the IMAP server, expect
 *     a performance hit when setting this parameter.
 *   - include_headers (mixed): Can be set to 0 (default), 1 or raw.
 *     If set to 1, complete message headers, parsed into an array, are
 *     included in the results. If set to raw, the headers are also included
 *     but as a raw unparsed string. Since full original headers bodies must
 *     be retrieved from the IMAP server, expect a performance hit when
 *     setting this parameter.
 *   - include_flags (integer): Set to 1 to include IMAP flags for this
 *     message in the result. Since message flags must be retrieved from the
 *     IMAP server, expect a performance hit when setting this parameter.
 *   - body_type (string): Used when include_body is set to get only body
 *     parts of a given MIME-type (for example text/html)
 *   - include_source (integer): Set to 1 to include message sources in the
 *     result. Since message sources must be retrieved from the IMAP server,
 *     expect a performance hit when setting this parameter.
 * @param ContextIO $contextio
 *   Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/messages#id-get
 *
 * @return array
 *   An array of message properties or an empty array if no message found by
 *   either account ID or message ID.
 *
 * @throws Exception
 *   If an error happened.
 */
function contextio_get_message($account_id, $message_id, array $filters = array(), ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  if (empty($filters)) {
    $message = $contextio->getMessage($account_id, $message_id);
  }
  else {
    $filters += array('message_id' => $message_id);
    $message = $contextio->getMessage($account_id, $filters);
  }

  if ($message !== FALSE) {
    return $message->getData();
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return array();
    }

    $data = $response->getData();
    throw new Exception(t('An error happened while trying to fetch message: !error, HTTP code: !code', array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * Delete a message.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param string $message_id
 *   Unique id of a message. This can be the message_id or email_message_id
 *   property of the message. The gmail_message_id (prefixed with gm-) can also
 *   be used.
 * @param ContextIO $contextio
 *   Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/messages#id-delete
 *
 * @return bool
 *   TRUE if the message was successfully deleted or FALSE if not found.
 *
 * @throws Exception
 *   If an error happened.
 */
function contextio_delete_message($account_id, $message_id, ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  $status = $contextio->deleteMessage($account_id, $message_id);

  if ($status !== FALSE) {
    return TRUE;
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return FALSE;
    }

    $data = $response->getData();
    throw new Exception(t('An error happened while trying to delete the message: !error, HTTP code: !code', array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * Get a single message's body by ID.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param string $message_id
 *   Unique id of a message. This can be the message_id or email_message_id
 *   property of the message. The gmail_message_id (prefixed with gm-) can also
 *   be used.
 * @param string $type
 *   Many emails are sent with both rich text and plain text versions in the
 *   message body and by default, the response of this call will include both.
 *   It is possible to only get either the plain or rich text version by setting
 *   the type parameter to text/plain or text/html respectively.
 * @param ContextIO $contextio
 *   Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/messages/body#get
 *
 * @returns array
 *   The message's body for each type. If $type given then the matching type
 *   will be returned.
 *   An empty array will be returned if no message found by either account ID
 *   or message ID.
 *
 * @throws Exception
 *   If $id, $message_id or $type not a string.
 */
function contextio_get_message_body($account_id, $message_id, $type = '', ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  if (!empty($type)) {
    $params = array(
      'message_id' => $message_id,
      'type' => $type,
    );
  }
  else {
    $params = array(
      'message_id' => $message_id,
    );
  }

  $message = $contextio->getMessageBody($account_id, $params);

  if ($message !== FALSE) {
    return $message->getData();
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return array();
    }

    $data = $response->getData();
    throw new Exception(t("An error happened while trying to fetch message's body: !error, HTTP code: !code", array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * Get a single message's flag by ID.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param string $message_id
 *   Unique id of a message. This can be the message_id or email_message_id
 *   property of the message. The gmail_message_id (prefixed with gm-) can also
 *   be used.
 * @param ContextIO $contextio
 *   Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/messages/flags#get
 *
 * @returns array
 *   The message's flags or an empty array if no message found by either
 *   account ID or message ID.
 *
 * @throws Exception
 *   If $id or $message_id is not a string.
 */
function contextio_get_message_flags($account_id, $message_id, ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  $message = $contextio->getMessageFlags($account_id, array('message_id' => $message_id));

  if ($message !== FALSE) {
    return $message->getData();
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return array();
    }

    $data = $response->getData();
    throw new Exception(t("An error happened while trying to fetch message's flags: !error, HTTP code: !code", array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * Set single mail's flags.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param string $message_id
 *   Unique id of a message. This can be the message_id or email_message_id
 *   property of the message. The gmail_message_id (prefixed with gm-) can also
 *   be used.
 * @param array $flags
 *   The flags which are needs to be set.
 *   Possible values:
 *     - seen (integer): Message has been read. Set this parameter to 1 to set
 *         the flag, 0 to unset it.
 *     - answered (integer): Message has been answered. Set this parameter to 1
 *         to set the flag, 0 to unset it.
 *     - flagged (integer): Message is "flagged" for urgent/special attention.
 *         Set this parameter to 1 to set the flag, 0 to unset it.
 *     - deleted (integer): Message is "deleted" for later removal. An
 *         alternative way of deleting messages is to move it to the Trash
 *         folder. Set this parameter to 1 to set the flag, 0 to unset it.
 *     - draft (integer): Message has not completed composition (marked as a
 *         draft). Set this parameter to 1 to set the flag, 0 to unset it.
 * @param ContextIO $contextio
 *   Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/messages/flags#post
 *
 * @return array
 *   Status message and the changed flags or an empty array if the message was
 *   not found.
 *
 * @throws Exception
 *   If id, message_id or one of the flags are not has the correct type or if
 *   an error happened.
 */
function contextio_set_message_flags($account_id, $message_id, array $flags, ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  $params = array(
    'message_id' => $message_id,
  ) + $flags;
  $flags = $contextio->setMessageFlags($account_id, $params);

  if ($flags !== FALSE) {
    return $flags->getData();
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return array();
    }

    $data = $response->getData();
    throw new Exception(t("An error happened while trying to fetch message's flags: !error, HTTP code: !code", array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * Get a single message's folders by ID.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param string $message_id
 *   Unique id of a message. This can be the message_id or email_message_id
 *   property of the message. The gmail_message_id (prefixed with gm-) can also
 *   be used.
 * @param ContextIO $contextio
 *   Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/messages/folders#get
 *
 * @returns array
 *   The message's folders if no message found by either
 *   account ID or message ID.
 *
 * @throws Exception
 *   If $id or $message_id is not a string.
 */
function contextio_get_message_folders($account_id, $message_id, ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  $message = $contextio->getMessageFolders($account_id, array('message_id' => $message_id));

  if ($message !== FALSE) {
    return $message->getData();
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return array();
    }

    $data = $response->getData();
    throw new Exception(t("An error happened while trying to fetch message's folder: !error, HTTP code: !code", array(
      '!error' => $data,
      '!code' => $code,
    )));
  }
}

/**
 * Get a single message's headers by ID.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param string $message_id
 *   Unique id of a message. This can be the message_id or email_message_id
 *   property of the message. The gmail_message_id (prefixed with gm-) can also
 *   be used.
 * @param bool $raw
 *   By default, this returns messages headers parsed into an array. Set this
 *   parameter to TRUE to get raw unparsed headers. Default is FALSE.
 * @param ContextIO $contextio
 *   Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/messages/headers#get
 *
 * @returns array|string
 *   The message's headers. If $raw is set to TRUE, it will return string
 *   otherwise an array.
 *   An empty array will be returned if no message found by either account ID
 *   or message ID.
 *
 * @throws Exception
 *   If $id or $message_id is not a string.
 */
function contextio_get_message_headers($account_id, $message_id, $raw = FALSE, ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  if ($raw) {
    $params = array(
      'message_id' => $message_id,
      'raw' => 1,
    );
  }
  else {
    $params = array(
      'message_id' => $message_id,
    );
  }

  $message = $contextio->getMessageHeaders($account_id, $params);

  if ($message !== FALSE) {
    return $message->getData();
  }
  else {
    $response = $contextio->getLastResponse();

    // Strange... if raw requested we have to return it from here.
    if ($response->getHttpCode() == 200) {
      return $response->getRawResponse();
    }

    if (($code = $response->getHttpCode()) == 404) {
      return array();
    }

    $data = $response->getData();
    throw new Exception(t("An error happened while trying to fetch message's headers: !error, HTTP code: !code", array(
      '!error' => $data['value'],
      '!code' => $response->getHttpCode(),
    )));
  }
}

/**
 * Get a single message's source by ID.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param string $message_id
 *   Unique id of a message. This can be the message_id or email_message_id
 *   property of the message. The gmail_message_id (prefixed with gm-) can also
 *   be used.
 * @param ContextIO $contextio
 *   Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/messages/source#get
 *
 * @returns string
 *   The message's source or an empty string if no message found by either
 *   account ID or message ID.
 *
 * @throws Exception
 *   If $id or $message_id is not a string.
 */
function contextio_get_message_source($account_id, $message_id, ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  $message = $contextio->getMessageSource($account_id, array('message_id' => $message_id));

  if ($message !== FALSE) {
    return $message;
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return '';
    }

    $data = $response->getData();
    throw new Exception(t("An error happened while trying to fetch message's source: !error, HTTP code: !code", array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * Get a single message's thread by ID.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param string $message_id
 *   Unique id of a message. This can be the message_id or email_message_id
 *   property of the message. The gmail_message_id (prefixed with gm-) can also
 *   be used.
 * @param array $filters
 *   List of filters.
 *   Possible values:
 *     - include_body (integer): Set to 1 to include message bodies in the
 *         result. Since message bodies must be retrieved from the IMAP server,
 *         expect a performance hit when setting this parameter.
 *     - include_headers (mixed): Can be set to 0 (default), 1 or raw. If set
 *         to 1, complete message headers, parsed into an array, are included
 *         in the results. If set to raw, the headers are also included but as
 *         a raw unparsed string. Since full original headers bodies must be
 *         retrieved from the IMAP server, expect a performance hit when
 *         setting this parameter.
 *     - include_flags (integer): Set to 1 to include IMAP flags of messages in
 *         the result. Since message flags must be retrieved from the IMAP
 *         server, expect a performance hit when setting this parameter.
 *     - body_type (string): Used when include_body is set to get only body
 *         parts of a given MIME-type (for example text/html)
 *     - limit (integer): The maximum number of messages to include in the
 *         messages property of the response. The maximum limit is 100.
 *     - offset (integer): Start the list of messages at this offset
 *         (zero-based).
 * @param ContextIO $contextio
 *   Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/messages/thread#get
 *
 * @returns array
 *   The message's thread or an empty array if no message found by either
 *   account ID or message ID.
 *
 * @throws Exception
 *   If $id or $message_id is not a string.
 */
function contextio_get_message_thread($account_id, $message_id, array $filters = array(), ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  $filters += array('message_id' => $message_id);

  $message = $contextio->getMessageThread($account_id, $filters);

  if ($message !== FALSE) {
    return $message->getData();
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return array();
    }

    $data = $response->getData();
    throw new Exception(t("An error happened while trying to fetch message's folder: !error, HTTP code: !code", array(
      '!error' => $data['value'],
      '!code' => $response->getHttpCode(),
    )));
  }
}

/**
 * Get account sources.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param array $filters
 *   An array of filter values. The following keys are available:
 *   - status (string): Only return sources whose status is of a specific value.
 *     Possible values are:
 *     - CONTEXTIO_FILTER_INVALID_CREDENTIALS
 *     - CONTEXTIO_FILTER_CONNECTION_IMPOSSIBLE
 *     - CONTEXTIO_FILTER_NO_ACCESS_TO_ALL_MAIL
 *     - CONTEXTIO_FILTER_OK
 *     - CONTEXTIO_FILTER_TEMP_DISABLED
 *     - CONTEXTIO_FILTER_DISABLED
 *   - status_ok (integer): Set to 0 to get sources that are not working
 *     correctly. Set to 1 to get those that are.
 * @param ContextIO $contextio
 *   Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/sources#get
 *
 * @returns array
 *   Sources which are belongs to the account or an empty array if the account
 *   with the given ID is not found.
 *
 * @throws Exception
 *   If one of the filters or $id is not matched to its type.
 */
function contextio_get_sources($account_id, array $filters = array(), ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  $sources = $contextio->listSources($account_id, $filters);

  if ($sources !== FALSE) {
    return $sources->getData();
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return array();
    }

    $data = $response->getData();
    throw new Exception(t('An error happened while trying to fetch account sources: !error, HTTP code: !code', array(
      '!error' => $data,
      '!code' => $code,
    )));
  }
}

/**
 * Get account source by ID and label.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param string|int $label
 *   The label property of the source instance. You can use 0 as an alias for
 *   the first source of an account.
 * @param array $parameters
 *   List of parameters. The following keys are available:
 *   - status (integer): If the status of the source is TEMP_DISABLED or
 *     DISABLED. You can do a POST/PUT with status set to 1 to reset it.
 *   - force_status_check (integer): Set to 1 to create an IMAP connection and
 *     reset the source status to to one reported by the IMAP backend. Don't
 *     combine this with other parameters.
 *   - sync_all_folders (integer): By default, we filter out some folders like
 *     'Deleted Items' and 'Drafts'. Set this parameter to 1 to turn off this
 *     filtering and show every single folder.
 *   - expunge_on_deleted_flag (integer): By default, we don't filter out
 *     messages flagged as deleted. Set this parameter to 1 to turn on this
 *     filtering.
 *   - password (string): New password for this source. Ignored if any of the
 *     provider_* parameters are set below.
 *   - provider_refresh_token (string): An OAuth2 refresh token obtained from
 *     the IMAP account provider to authenticate this email account.
 *   - provider_consumer_key (string): The OAuth2 Client ID used to obtain the
 *     the refresh token for the above account. That consumer key and secret
 *     must be configured in your Context.IO account, see oauth_providers
 *   - status_callback_url (string, url): If specified, we'll make a POST
 *     request to this URL if the connection status of the source changes.
 * @param ContextIO $contextio
 *   Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/sources#id-get
 *
 * @returns array
 *   The source information in array or an empty array if the given account ID
 *   or label is not found.
 *
 * @throws Exception
 *   If an error happened.
 */
function contextio_get_source($account_id, $label = 0, array $parameters = array(), ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  $parameters += array('label' => $label);

  $source = $contextio->getSource($account_id, $parameters);

  if ($source !== FALSE) {
    return $source->getData();
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return array();
    }

    $data = $response->getData();
    throw new Exception(t('An error happened while trying to fetch account source: !error, HTTP code: !code', array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * Get sync status for all sources of the account.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param ContextIO $contextio
 *   Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/sync#get
 *
 * @return array
 *   The list of each sources sync status or empty array if the account is not
 *   found.
 *
 * @throws Exception
 *   If id does not match its type or an error happened.
 */
function contextio_get_sync_status($account_id, ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  $sync_status = $contextio->getSync($account_id);

  if ($sync_status !== FALSE) {
    return $sync_status->getData();
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return array();
    }

    $data = $response->getData();
    throw new Exception(t('An error happened while trying to fetch sync statues: !error, HTTP code: !code', array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * Trigger a sync of all sources on the account.
 *
 * @param string $account_id
 *   Unique id of an account accessible through your API key.
 * @param ContextIO $contextio
 *   Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/accounts/sync#post
 *
 * @return array
 *   Sync status or an empty array if the account is not found.
 *
 * @throws Exception
 *   If id does not match its type or an error happened.
 */
function contextio_sync($account_id, ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  $sync = $contextio->syncSource($account_id);

  if ($sync !== FALSE) {
    return $sync->getData();
  }
  else {
    $response = $contextio->getLastResponse();

    if (($code = $response->getHttpCode()) == 404) {
      return array();
    }

    $data = $response->getData();
    throw new Exception(t('An error happened while trying to sync sources: !error, HTTP code: !code', array(
      '!error' => $data['value'],
      '!code' => $code,
    )));
  }
}

/**
 * Attempts to discover IMAP settings for a given email address.
 *
 * @param string $email
 *   An email address you want to discover IMAP settings for.
 * @param ContextIO $contextio
 *   Initialized ContextIO object.
 *
 * @see https://context.io/docs/2.0/discovery#get
 *
 * @return array
 *   The discovered settings.
 *
 * @throws Exception
 *   If the email address is not valid or an error happened.
 */
function contextio_discovery($email, ContextIO $contextio = NULL) {
  // Check variable types.
  _contextio_check_types(__FUNCTION__, get_defined_vars());

  if (is_null($contextio)) {
    $contextio = contextio_get_object();
  }

  $discovered_settings = $contextio->discovery($email);

  if ($discovered_settings !== FALSE) {
    return $discovered_settings->getData();
  }
  else {
    $response = $contextio->getLastResponse();
    $data = $response->getData();
    throw new Exception(t('An error happened while trying to discover to settings: !error, HTTP code: !code', array(
      '!error' => $data['value'],
      '!code' => $response->getHttpCode(),
    )));
  }
}

/**
 * Helper function to force variable types.
 *
 * Make sure that all of the variables are have to required type before
 * calling the API.
 *
 * @param callable $function
 *   The name of the function which from this function called from.
 *   Use __FUNCTION__ magic variable.
 * @param array $func_args
 *   The arguments of the function.
 * @param string|NULL $array_var
 *   Inner variables of an array.
 *
 * @throws \Exception
 *   If one of the variables are not matched to its type.
 */
function _contextio_check_types(callable $function, array $func_args, $array_var = NULL) {
  // Map variables to their type or possible values.
  // No need to check for arrays and objects because they can be hinted.
  static $valid_values = array(
    'account_id' => CONTEXTIO_STRING,
    'email' => CONTEXTIO_EMAIL,
    'email_or_migrate_account_id' => CONTEXTIO_STRING,
    'file_id' => CONTEXTIO_STRING,
    'filters' => array(
      'active_after' => CONTEXTIO_INT,
      'active_before' => CONTEXTIO_INT,
      'bcc' => CONTEXTIO_EMAIL,
      'body_type' => CONTEXTIO_STRING,
      'cc' => CONTEXTIO_EMAIL,
      'date_before' => CONTEXTIO_INT,
      'date_after' => CONTEXTIO_INT,
      'file_name' => CONTEXTIO_STRING,
      'file_size_max' => CONTEXTIO_INT,
      'file_size_min' => CONTEXTIO_INT,
      'folder' => CONTEXTIO_STRING,
      'from' => CONTEXTIO_STRING,
      'include_body' => CONTEXTIO_INT,
      'include_flags' => CONTEXTIO_INT,
      'include_headers' => CONTEXTIO_INT,
      'include_source' => CONTEXTIO_INT,
      'include_thread_size' => CONTEXTIO_INT,
      'indexed_before' => CONTEXTIO_INT,
      'indexed_after' => CONTEXTIO_INT,
      'limit' => CONTEXTIO_INT,
      'offset' => CONTEXTIO_INT,
      'search' => CONTEXTIO_STRING,
      'sort_by' => array('email', 'count', 'received_count', 'sent_count'),
      'sort_order' => array('asc', 'desc'),
      'source' => CONTEXTIO_STRING,
      'status' => array(
        CONTEXTIO_FILTER_CONNECTION_IMPOSSIBLE,
        CONTEXTIO_FILTER_DISABLED,
        CONTEXTIO_FILTER_INVALID_CREDENTIALS,
        CONTEXTIO_FILTER_NO_ACCESS_TO_ALL_MAIL,
        CONTEXTIO_FILTER_OK,
        CONTEXTIO_FILTER_TEMP_DISABLED,
      ),
      'status_ok' => CONTEXTIO_INT,
      'subject' => CONTEXTIO_STRING,
      'to' => CONTEXTIO_STRING,
    ),
    'first_name' => CONTEXTIO_STRING,
    'last_name' => CONTEXTIO_STRING,
    'message_id' => CONTEXTIO_STRING,
    'params' => array(
      'back_url' => CONTEXTIO_STRING,
      'callback_url' => CONTEXTIO_STRING,
      'expunge_on_deleted_flag' => CONTEXTIO_INT,
      'first_name' => CONTEXTIO_STRING,
      'force_status_check' => CONTEXTIO_INT,
      'last_name' => CONTEXTIO_STRING,
      'password' => CONTEXTIO_STRING,
      'provider_refresh_token' => CONTEXTIO_INT,
      'source_call' => CONTEXTIO_STRING,
      'source_expunge_on_deleted_flag' => CONTEXTIO_STRING,
      'source_sync_folders' => CONTEXTIO_STRING,
      'source_sync_flags' => CONTEXTIO_STRING,
      'source_raw_file_list' => CONTEXTIO_STRING,
      'status' => CONTEXTIO_STRING,
      'status_callback_url' => CONTEXTIO_STRING,
      'sync_all_folders' => CONTEXTIO_STRING,
    ),
    'token' => CONTEXTIO_STRING,
    'type' => CONTEXTIO_STRING,
    'flags' => array(
      'answered' => CONTEXTIO_BOOL,
      'deleted' => CONTEXTIO_BOOL,
      'draft' => CONTEXTIO_BOOL,
      'flagged' => CONTEXTIO_BOOL,
      'seen' => CONTEXTIO_BOOL,
    ),
    'raw' => CONTEXTIO_BOOL,
  );

  static $args_allow_recursion = array(
    'params' => 0,
    'filters' => 1,
    'flags' => 2,
  );

  // Go through all defined function types.
  foreach ($func_args as $arg_name => $value) {
    if (!is_null($array_var)) {
      $local_valid_values = &$valid_values[$array_var];
    }
    else {
      $local_valid_values = &$valid_values;
    }

    if (isset($local_valid_values[$arg_name]) && is_array($local_valid_values[$arg_name]) && isset($args_allow_recursion[$arg_name])) {
      _contextio_check_types($function, $func_args[$arg_name], $arg_name);
    }
    elseif (isset($valid_values[$arg_name]) || isset($local_valid_values[$arg_name])) {
      $value_type = isset($local_valid_values[$arg_name]) ? $local_valid_values[$arg_name] : $valid_values[$arg_name];
      switch ($value_type) {
        // Check for string values.
        case CONTEXTIO_STRING:
          if (!is_string($value)) {
            if (!is_null($array_var)) {
              throw new Exception(t("The \$!arg argument array's !key key's value must be a string in !function!", array(
                '!arg' => $array_var,
                '!key' => $arg_name,
                '!function' => $function,
              )));
            }
            else {
              throw new Exception(t('The $!arg argument must be a string in !function!', array(
                '!arg' => $arg_name,
                '!function' => $function,
              )));
            }
          }
          break;

        // Check for email values.
        case CONTEXTIO_EMAIL:
          if (!is_string($value) || !filter_var($value, FILTER_VALIDATE_EMAIL)) {
            if (!is_null($array_var)) {
              throw new Exception(t("The \$!arg argument array's !key key's value must be a valid email address in !function!", array(
                '!arg' => $array_var,
                '!key' => $arg_name,
                '!function' => $function,
              )));
            }
            else {
              throw new Exception(t('The $!arg argument must be a valid email address in !function!', array(
                '!arg' => $arg_name,
                '!function' => $function,
              )));
            }
          }
          break;

        // Check for integer values.
        case CONTEXTIO_INT:
          // Check for special int cases.
          if (is_int($value) && $arg_name == 'limit' && $value > 250) {
            if (!is_null($array_var)) {
              throw new Exception(t("The \$!arg argument array's !key key's value cannot be larger than 250 in !function!", array(
                '!arg' => $array_var,
                '!key' => $arg_name,
                '!function' => $function,
              )));
            }
            else {
              throw new Exception(t("The \$!arg argument's value cannot be larger than 250 in !function!", array(
                '!arg' => $arg_name,
                '!function' => $function,
              )));
            }
          }

          if (!is_int($value)) {
            if (!is_null($array_var)) {
              throw new Exception(t("The \$!arg argument array's !key key's value must be an integer in !function!", array(
                '!arg' => $array_var,
                '!key' => $arg_name,
                '!function' => $function,
              )));
            }
            else {
              throw new Exception(t('The $!arg argument must be an integer in !function!', array(
                '!arg' => $arg_name,
                '!function' => $function,
              )));
            }
          }
          break;

        // Check for bool values.
        case CONTEXTIO_BOOL:
          if (!is_bool($value)) {
            if (!is_null($array_var)) {
              throw new Exception(t("The \$!arg argument array's !key key's value must a bool in !function!", array(
                '!arg' => $array_var,
                '!key' => $arg_name,
                '!function' => $function,
              )));
            }
            else {
              throw new Exception(t('The $!arg argument must be a bool in !function!', array(
                '!arg' => $arg_name,
                '!function' => $function,
              )));
            }
          }
          break;

        // Special case.
        default:
          if (is_array($value_type) && isset($args_allow_recursion[$array_var])) {
            if (!in_array($value, $values = ($not_array_var = is_null($array_var)) ? $local_valid_values[$arg_name] : $local_valid_values[$arg_name])) {
              if ($not_array_var) {
                throw new Exception(t('The $!arg argument must have one of the following values: !values in !function function!', array(
                  '!arg' => $arg_name,
                  '!values' => implode(', ', $values),
                  '!function' => $function,
                )));
              }
              else {
                throw new Exception(t("The \$!arg argument array's !key key's value must have one of the following values: !values in !function function!", array(
                  '!arg' => $array_var,
                  '!key' => $arg_name,
                  '!values' => implode(', ', $values),
                  '!function' => $function,
                )));
              }
            }
          }
      }
    }
  }
}
