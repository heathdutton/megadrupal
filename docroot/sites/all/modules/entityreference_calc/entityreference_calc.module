<?php

/**
 * @file
 * Defines a field type for calculating fields on referencing entities.
 */

/**
 * Implements hook_field_info().
 */
function entityreference_calc_field_info() {
  return array(
    'entityreference_calc' => array(
      'label' => t('Entity reference calc'),
      'description' => t('Store entity reference calculation data in the database.'),
      'settings' => array('precision' => 10, 'scale' => 2, 'decimal_separator' => '.'),
      'instance_settings' => array(
        'calculated_reference_field' => '',
        'calculated_reference_field_type' => array(),
        'calculated_field' => '',
        'aggregation_type' => 'sum',
        'calculate_only_published' => TRUE,
      ),
      'default_widget' => 'entityreference_calc_widget',
      'default_formatter' => 'entityreference_calc_formatter_default',
    ),
  );
}

/**
 * Generate a list of available node reference fields to calculate.
 *
 * @param $bundle
 *   The field instance bundle.
 * @return
 *   An array of nodereference fields that are available to calculate.
 */
function entityreference_calc_field_options($bundle) {
  $field_options = array();

  foreach (field_info_field_map() as $field_name => $data) {
    switch ($data['type']) {
      case 'entityreference':
        $field = field_info_field($field_name);
        if (isset($field['settings']['handler_settings']['target_bundles'][$bundle]) && $field['settings']['handler_settings']['target_bundles'][$bundle] === $bundle) {
          $field_options['entityreference'][$field['field_name']] = check_plain($field['field_name']);
          $entity_types = array_keys($data['bundles']);
          $field_options['entityreference_type'][$field['field_name']] = array_shift($entity_types);
        }
        break;
      case 'number_integer':
      case 'number_decimal':
      case 'list_integer':
      case 'computed':
        $field = field_info_field($field_name);
        $field_options['calculate_fields'][$field['field_name']] = check_plain($field['field_name'] . ' (' . $data['type'] . ')');
        break;
    }
  }

  return $field_options;
}

/**
 * Implements hook_field_settings_form().
 */
function entityreference_calc_field_settings_form($field, $instance, $has_data) {
  $settings = $field['settings'];
  $form = array();

  $form['precision'] = array(
    '#type' => 'select',
    '#title' => t('Precision'),
    '#options' => drupal_map_assoc(range(10, 32)),
    '#default_value' => $settings['precision'],
    '#description' => t('The total number of digits to store in the database, including those to the right of the decimal.'),
    '#disabled' => $has_data,
  );
  $form['scale'] = array(
    '#type' => 'select',
    '#title' => t('Scale'),
    '#options' => drupal_map_assoc(range(0, 10)),
    '#default_value' => $settings['scale'],
    '#description' => t('The number of digits to the right of the decimal.'),
    '#disabled' => $has_data,
  );
  $form['decimal_separator'] = array(
    '#type' => 'select',
    '#title' => t('Decimal marker'),
    '#options' => array('.' => t('Decimal point'), ',' => t('Comma')),
    '#default_value' => $settings['decimal_separator'],
    '#description' => t('The character users will input to mark the decimal point in forms.'),
  );

  return $form;
}

/**
 * Implements hook_field_instance_settings_form().
 */
function entityreference_calc_field_instance_settings_form($field, $instance) {
  $settings = $instance['settings'];
  $options = entityreference_calc_field_options($instance['bundle']);
  $form = array();

  if (empty($options['entityreference'])) {
    $form['calculated_reference_field_empty'] = array(
      '#prefix' => '<p>',
      '#markup' => t('There are no entity reference fields to calculate. If you wish to calculate the number of references to a entity of this type, add a entityreference field to another content type, allowing it to reference this content type.'),
      '#suffix' => '</p>',
    );
  }
  else {
    $form['calculated_reference_field'] = array(
      '#type' => 'select',
      '#title' => t('Entity reference fields that may be calculated'),
      '#description' => t('Select the entity refence fields that you would like to calculate.'),
      '#default_value' => $settings['calculated_reference_field'],
      '#options' => $options['entityreference'],
    );
    $form['calculated_reference_field_type'] = array(
      '#type' => 'hidden',
      '#value' => $options['entityreference_type'],
    );
    $form['calculated_field'] = array(
      '#type' => 'select',
      '#title' => t('Field on referencing entity to do calculation on.'),
      '#description' => t('Select the field on the referencing entity that you would like to do calculation on.'),
      '#default_value' => $settings['calculated_field'],
      '#options' => $options['calculate_fields'],
    );
    $form['aggregation_type'] = array(
      '#type' => 'select',
      '#title' => t('Aggregation'),
      '#description' => t('Select the aggregation type.'),
      '#default_value' => $settings['aggregation_type'],
      '#options' => array(
        'sum' => t('Sum'),
        'avg' => t('Average'),
        'min' => t('Minimum'),
        'max' => t('Maximum'),
      ),
    );
    $form['calculate_only_published'] = array(
      '#type' => 'checkbox',
      '#title' => t('Do not calculate references from unpublished nodes.'),
      '#default_value' => $settings['calculate_only_published'],
    );
  }

  return $form;
}

/**
 * Implements hook_field_is_empty().
 */
function entityreference_calc_field_is_empty($item, $field) {
  return is_null($item['calculated']);
}

/**
 * Implements hook_field_widget_info().
 */
function entityreference_calc_field_widget_info() {
  return array(
    'entityreference_calc_widget' => array(
      'label' => t('default'),
      'description' => t('The value is calculated, so there is no data to enter.'),
      'field types' => array('entityreference_calc'),
      'behaviors' => array(
        'default_value' => FIELD_BEHAVIOR_NONE,
      ),
    ),
  );
}

/**
 * Implements hook_field_formatter_info().
 */
function entityreference_calc_field_formatter_info() {
  return array(
    'entityreference_calc_default' => array(
      'label' => t('Default'),
      'field types' => array('entityreference_calc'),
    ),
    'entityreference_calc_nonzero' => array(
      'label' => t('Non-zero'),
      'field types' => array('entityreference_calc'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function entityreference_calc_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();

  switch ($display['type']) {
    case 'entityreference_calc_default':
      foreach ($items as $delta => $item) {
        $element[$delta] = array('#markup' => $item['calculated']);
      }
      break;

    case 'entityreference_calc_nonzero':
      foreach ($items as $delta => $item) {
        if ($item['calculated'] > 0) {
          $element[$delta] = array('#markup' => $item['calculated']);
        }
      }
      break;
  }

  return $element;
}

/**
 * Implements hook_field_presave().
 */
function entityreference_calc_field_presave($entity_type, $entity, $field, $instance, $langcode, &$items) {
  if ($field['type'] == 'entityreference_calc') {
    $items[0]['calculated'] = entityreference_calc_perform_calculation($instance['settings'], $entity_type, $entity);
  }
}

/**
 * Perform the calculation of entity references to a particular entity
 *
 * @param $settings
 *   The settings for this field instance.
 * @param $entity_type
 *   The type of entity being referenced
 * @param $entity
 *   The entity being referenced.
 * @return
 *   A calculation of the specified field on the references to the entity
 */
function entityreference_calc_perform_calculation($settings, $entity_type, $entity) {
  $output = 0;
  $item_ids = array();
  $calculated_values = array();

  // Get the entity info.
  $entity_info = entity_get_info($entity_type);
  $entity_key_id = $entity_info['entity keys']['id'];

  // If entity key id is not defined or no id is set then omit the calculation.
  if (empty($entity_info['entity keys']['id']) || !isset($entity->$entity_key_id)) {
    return;
  }

  $reference_type = $settings['calculated_reference_field_type'][$settings['calculated_reference_field']];

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', $reference_type)
        ->fieldCondition($settings['calculated_reference_field'], 'target_id', $entity->$entity_key_id, '=');
  if ($settings['calculate_only_published']) {
    $query->propertyCondition('status', 1);
  }
  $references = $query->execute();

  if (isset($references[$reference_type]) && !empty($references[$reference_type])) {
    $item_info = entity_get_info($reference_type);
    foreach ($references[$reference_type] as $item) {
      $item_key_id = $item_info['entity keys']['id'];
      $item_ids[] = $item->$item_key_id;
      // Clear entity cache if needed.
      if (isset($item_info['entity cache']) && !empty($item_info['entity cache'])) {
        entity_get_controller($reference_type)->resetCache(array($item->$item_key_id));
      }
    }

    $reference_entities = entity_load($reference_type, $item_ids);

    foreach ($reference_entities as $reference_entity) {
      $reference_wrapper = entity_metadata_wrapper($reference_type, $reference_entity);
      $calculated_values[] = $reference_wrapper->$settings['calculated_field']->value();
    }
  }

  if (!empty($calculated_values)) {
    switch ($settings['aggregation_type']) {
      case 'sum':
        foreach ($calculated_values as $value) {
          $output += $value;
        }
        break;
      case 'avg':
        $count = count($calculated_values);
        $total = 0;
        foreach ($calculated_values as $value) {
          $total += $value;
        }
        if ($total > 0) {
          $output = $total / $count;
        }
        break;
      case 'min':
        $output = min($calculated_values);
        break;
      case 'max':
        $output = max($calculated_values);
        break;
    }
  }

  return $output;
}

/**
 * Implements hook_entity_insert().
 */
function entityreference_calc_entity_insert($entity, $entity_type) {
  entityreference_calc_references_update($entity_type, $entity);
}

/**
 * Implements hook_entity_update().
 */
function entityreference_calc_entity_update($entity, $entity_type) {
  entityreference_calc_references_update($entity_type, $entity);
}

/**
 * Implements hook_entity_delete().
 *
 * hook_entity_delete() runs before database queries are executed, so
 * we cannot just update the calculations here or it will reflect the calculation
 * before anything has actually been deleted.
 *
 * The workaround is an ugly hack. We add a delay flag to
 * entityreference_calc_references_update(). This allows us to add ids
 * to a statically cached array instead of calculating them immediately.
 * The cached array can then be processed via hook_exit() after the
 * database updates are done so that we get a correct calculation.
 *
 * @see entityreference_calc_references_update().
 * @see entityreference_calc_delayed_entity_ids().
 * @see entityreference_calc_exit().
 */
function entityreference_calc_entity_delete($entity, $entity_type) {
  entityreference_calc_references_update($entity_type, $entity, TRUE);
}

/**
 * Get an array of entity reference fields for a particular entity bundle.
 *
 * @param $entity_type
 *   The entity type
 * @param $bundle
 *   The content type for which we want a list of entity reference fields.
 * @return
 *   An array of fields.
 */
function entityreference_calc_get_entityreference_fields($entity_type, $bundle) {
  $entityreference_fields = array();

  foreach (field_info_field_map() as $field_name => $data) {
    if ($data['type'] == 'entityreference' && isset($data['bundles'][$entity_type]) && in_array($bundle, $data['bundles'][$entity_type])) {
      $field = field_info_field($field_name);
      $entityreference_fields[$field['field_name']] = $field;
    }
  }

  return $entityreference_fields;
}

/**
 * From a set of entity reference fields get those that are calculated by a entityreference calc field.
 *
 * @param $entity_type
 *   The entity type
 * @param $entity_references
 *   An array of entity reference fields.
 * @return
 *   An array of field names.
 */
function entityreference_calc_get_calculated_entityreference_fields($entity_type, $entity_references) {
  $calculated_fields = array();

  foreach (field_info_field_map() as $field_name => $data) {
    if ($data['type'] == 'entityreference_calc') {
      foreach ($data['bundles'] as $type => $bundles) {
        foreach ($bundles as $bundle) {
          $instance = field_info_instance($type, $field_name, $bundle);
          if (isset($instance['settings']['calculated_reference_field'])) {
            foreach ($entity_references as $entity_reference) {
              if ($entity_reference['field_name'] == $instance['settings']['calculated_reference_field']) {
                $calculated_fields[$entity_reference['field_name']] = $entity_reference['settings']['target_type'];
              }
            }
          }
        }
      }
    }
  }

  return $calculated_fields;
}

/**
 * From a set of entity reference fields get all the target_ids that need to be updated.
 *
 * @param $entity
 *   The entity object.
 * @param $calculated_fields
 *   An array of entity reference fields.
 * @return
 *   An array of target_ids.
 */
function entityreference_calc_get_referenced_ids($entity, $calculated_fields) {
  $target_ids = array();

  foreach ($calculated_fields as $calculated_field => $target_type) {
    // Get all the updated target_ids.
    $updated_entityreferences = $entity->$calculated_field;

    foreach ($updated_entityreferences as $language => $deltas) {
      foreach ($deltas as $delta => $entityreference) {
        $target_ids[$entityreference['target_id']] = $target_type;
      }
    }

    // Get all the original ids.
    if (isset($entity->original)) {
      $original_entityreferences = $entity->original->$calculated_field;

      foreach ($original_entityreferences as $language => $deltas) {
        foreach ($deltas as $delta => $entityreference) {
          $target_ids[$entityreference['target_id']] = $target_type;
        }
      }
    }
  }

  return $target_ids;
}

/**
 * Identify calculated entity references on a entity and trigger an update of the referenced entity.
 *
 * @param $entity_type
 *   The entity type
 * @param $entity
 *   The entity object.
 * @param $delay
 *   Whether the actual calculation update should be delayed. See the hook_entity_delete
 *   implementation above for more info.
 */
function entityreference_calc_references_update($entity_type, $entity, $delay = FALSE) {
  if (!$entity_type || !isset($entity->type)) {
    return;
  }

  // Get all the entity reference fields for this content type.
  $entityreference_fields = entityreference_calc_get_entityreference_fields($entity_type, $entity->type);

  // If there are no entity references for this content type then there is nothing to calculate.
  if (empty($entityreference_fields)) {
    return;
  }

  // Get all the entity reference fields for this content type that are calculated by a entityreference calc field.
  $calculated_fields = entityreference_calc_get_calculated_entityreference_fields($entity_type, $entityreference_fields);

  // If there are no entity references being calculated for this content type then there is nothing to calculate.
  if (empty($calculated_fields)) {
    return;
  }

  // Get all the entity_ids that need to be updated.
  $entity_ids = entityreference_calc_get_referenced_ids($entity, $calculated_fields);

  // Update the calculations on the referenced entities.
  foreach ($entity_ids as $entity_id => $entity_type) {
    // Wait to update the calculation for this id.
    if ($delay) {
      entityreference_calc_delayed_entity_ids($entity_type, $entity_id);
    }
    // Update the calculation immediately.
    else {
      entityreference_calc_update_calculation($entity_type, $entity_id);
    }
  }
}

/**
 * Trigger an update of the fields on a particular entity.
 *
 * @param $entity_type
 *   The entity type being referenced.
 * @param $entity_id
 *   The entity_id of the entity being referenced.
 */
function entityreference_calc_update_calculation($entity_type, $entity_id) {
  $entity = entity_load($entity_type, array($entity_id));
  if (isset($entity[$entity_id])) {
    field_attach_presave($entity_type, $entity[$entity_id]);
    field_attach_update($entity_type, $entity[$entity_id]);
    entity_get_controller($entity_type)->resetCache(array($entity_id));
  }
}

/**
 * Statically cache any entity_ids that should have their calculation update delayed.
 *
 * @param $entity_id
 *   A entity_id that should be added to the cache.
 * @return
 *   An array of entity_ids.
 */
function entityreference_calc_delayed_entity_ids($entity_type = NULL, $entity_id = NULL) {
  $entity_ids = &drupal_static(__FUNCTION__, array());

  if (!is_null($entity_ids) && !isset($entity_ids[$entity_id]) && !is_null($entity_type)) {
    $entity_ids[$entity_id] = $entity_type;
  }

  return $entity_ids;
}

/**
 * Implements hook_exit().
 */
function entityreference_calc_exit() {
  $entity_ids = entityreference_calc_delayed_entity_ids();

  if (!empty($entity_ids)) {
    foreach ($entity_ids as $entity_id => $entity_type) {
      entityreference_calc_update_calculation($entity_type, $entity_id);
    }
  }
}
