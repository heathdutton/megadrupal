<?php

/**
 * @file
 * TODO.
 */

define('GCC_CONTEXT_DIRECT', 'direct');
define('GCC_CONTEXT_INDIRECT', 'indirect');

/* Hooks Implementation */

/**
 * Implements hook_menu().
 */
function gcc_context_menu() {

  $items = array();

  $items['admin/config/gcc/context'] = array(

    'title' => 'Context',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('gcc_context_admin'),
    'access arguments' => array('administer gcc configuration'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'gcc_context.admin.inc',
    'weight' => 5,
  );

  return $items;
}

/**
 * Implements hook_menu_get_item_alter().
 *
 * This function is used to store the original accessed router item
 * before any alteration (page not found, access denied, ...)
 */
function gcc_context_menu_get_item_alter(&$router_item, $path, $original_map) {

  static $recurse = FALSE;

  if ($recurse) {
    return;
  }

  if ($path == $_GET['q']) {

    $router_item['original_map'] = $original_map;
    _gcc_context_get_menu_item($router_item);

    if (isset($_GET['gcc_context_override'])) {

      $recurse = TRUE;
      _gcc_context_get_menu_item(menu_get_item($_GET['gcc_context_override']));
    }
  }
}

/**
 * Implements hook_gcc_context_context_detector().
 */
function gcc_context_gcc_context_context_detector() {

  $detectors = array();

  $detectors['group'] = array(

    'title' => t('Group'),
    'description' => t('Determine context by checking if the current entity is a group.'),
    'callback' => 'gcc_context_gcc_context_group_detector',
    'file' => drupal_get_path('module', 'gcc_context') . '/gcc_context.context_detector.inc',
  );

  $detectors['group_content'] = array(

    'title' => t('Group Content'),
    'description' => t('Determine context by checking if the current entity is a group content.'),
    'callback' => 'gcc_context_gcc_context_group_content_detector',
    'file' => drupal_get_path('module', 'gcc_context') . '/gcc_context.context_detector.inc',
  );

  return $detectors;
}

/**
 * Implements hook_gcc_context_entity_detector().
 */
function gcc_context_gcc_context_entity_detector() {

  $detectors = array();

  $detectors['url'] = array(

    'title' => t('Entity From URL'),
    'description' => t('Allow to detecte entity passed in the url.'),
    'callback' => 'gcc_context_url_entity_detector',
  );

  return $detectors;
}

/**
 * Entity detector for nodes.
 */
function gcc_context_url_entity_detector($menu_item) {

  if (isset($_GET['gcc_audience'][0])) {

    $item = explode(':', $_GET['gcc_audience'][0]);
    if (count($item) == 2) {

      $entity = entity_load($item[0], array($item[1]));
      $entity = reset($entity);

      if ($entity) {
        return array(

          'entity_type' => $item[0],
          'entity' => $entity,
        );
      }
    }
  }
}

/**
 * Implements hook_init().
 */
function gcc_context_init() {

  gcc_context_get_context();
}

/**
 * Implements hook_token_info().
 */
function gcc_context_token_info() {

  $types = array(

    'name' => t('GCC Context'),
    'description' => t('Tokens based on the current GCC Context.'),
  );

  $tokens['entity_id'] = array(

    'name' => t('Entity ID'),
    'description' => t('The current context entity id if present.'),
  );

  $tokens['entity_type'] = array(

    'name' => t('Entity Type'),
    'description' => t('The current context entity type if present.'),
  );

  return array(
    'types' => array('gcc_context' => $types),
    'tokens' => array('gcc_context' => $tokens),
  );
}

/**
 * Implements hook_tokens().
 */
function gcc_context_tokens($type, $tokens, array $data = array(), array $options = array()) {

  if ($type != 'gcc_context') {
    return array();
  }

  $replacements = array();
  $context = gcc_context_get_context();

  foreach ($tokens as $name => $original) {
    switch ($name) {

      case 'entity_id':
        $replacements[$original] = $context ? $context['entity_id'] : '';
        break;

      case 'entity_type':
        $replacements[$original] = $context ? $context['entity_type'] : '';
        break;
    }
  }

  return $replacements;
}

/* Context Functions */

/**
 * Return the current context or FALSE.
 */
function gcc_context_get_context($reset = FALSE) {

  static $context = NULL;

  if (!isset($context) || $reset) {
    $context = _gcc_context_determine();
  }

  return $context;
}

/**
 * Determine the current context using detectors.
 *
 * Return the determined context or FALSE.
 */
function _gcc_context_determine() {

  $entity_detectors = gcc_context_get_entity_detectors(TRUE);
  $context_detectors = gcc_context_get_context_detectors(TRUE);
  $menu_item = _gcc_context_get_menu_item();

  // First, determine the current entity from the path.
  $entity = FALSE;
  foreach ($entity_detectors as $detector) {

    if ($detector['file']) {
      require_once DRUPAL_ROOT . '/' . $detector['file'];
    }

    if (function_exists($detector['callback'])) {
      $result = $detector['callback']($menu_item);
    }

    if ($result) {

      $entity = $result;
      break;
    }
  }

  // No entity found, no context available.
  if (!$entity) {
    return FALSE;
  }

  // Next, determine the current contexts from the entity.
  $contexts = array();
  foreach ($context_detectors as $detector) {

    if ($detector['file']) {
      require_once DRUPAL_ROOT . '/' . $detector['file'];
    }

    if (function_exists($detector['callback'])) {
      $result = $detector['callback']($entity['entity_type'], $entity['entity']);
    }

    if ($result) {

      $contexts = $result;
      break;
    }
  }

  // No contexts found, no context available.
  if (empty($contexts)) {
    return FALSE;
  }

  // Only one context found, must be the good one.
  if (count($contexts) == 1) {
    $_SESSION['gcc_context_previous_context'] = $contexts[0];
    return $contexts[0];
  }

  // Multiple contexts found, try to find out from previous pages.
  if (isset($_SESSION['gcc_context_previous_context']) && variable_get('gcc_context_history', FALSE)) {
    foreach ($contexts as $context) {
      if ($context['entity_type'] == $_SESSION['gcc_context_previous_context']['entity_type']
          && $context['entity_id'] == $_SESSION['gcc_context_previous_context']['entity_id']) {
        return $context;
      }
    }
  }

  // Fallback to the first context of the list.
  $_SESSION['gcc_context_previous_context'] = reset($contexts);
  return $_SESSION['gcc_context_previous_context'];
}

/**
 * Function to retrieve the menu item used to determine the current context.
 */
function _gcc_context_get_menu_item($new_item = NULL) {

  static $item = NULL;

  // Save the new item.
  if ($new_item) {
    $item = $new_item;
  }

  // If an item has never been saved, lazy save one.
  if (!isset($item)) {
    menu_get_item();
  }

  return $item;
}

/* Entity Detectors Functions */

/**
 * Retrieve the list of entity detectors.
 */
function gcc_context_get_entity_detectors($enabled_only = FALSE) {

  $detectors = &drupal_static(__FUNCTION__, NULL);

  if (!isset($detectors)) {

    $detectors = module_invoke_all('gcc_context_entity_detector');
    $clone = $detectors;
    $detectors = drupal_array_merge_deep($detectors, variable_get('gcc_context_entity_detectors', array()));
    $detectors = array_intersect_key($detectors, $clone);

    foreach ($detectors as &$detector) {
      $detector += array(

        'file' => FALSE,
        'weight' => 0,
        'enabled' => FALSE,
        'callback' => '',
      );
    }

    uasort($detectors, 'drupal_sort_weight');
  }

  if ($enabled_only) {

    $list = array();
    foreach ($detectors as $key => $item) {
      if ($item['enabled']) {
        $list[$key] = $item;
      }
    }

    return $list;
  }

  return $detectors;
}

/* Context Detectors Functions */

/**
 * Retrieve the list of context detectors.
 */
function gcc_context_get_context_detectors($enabled_only = FALSE) {

  $detectors = &drupal_static(__FUNCTION__, NULL);

  if (!isset($detectors)) {

    $detectors = module_invoke_all('gcc_context_context_detector');
    $clone = $detectors;
    $detectors = drupal_array_merge_deep($detectors, variable_get('gcc_context_context_detectors', array()));
    $detectors = array_intersect_key($detectors, $clone);

    foreach ($detectors as &$detector) {
      $detector += array(

        'file' => FALSE,
        'weight' => 0,
        'enabled' => FALSE,
        'callback' => '',
      );
    }

    uasort($detectors, 'drupal_sort_weight');
  }

  if ($enabled_only) {

    $list = array();
    foreach ($detectors as $key => $item) {
      if ($item['enabled']) {
        $list[$key] = $item;
      }
    }

    return $list;
  }

  return $detectors;
}
