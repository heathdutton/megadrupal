<?php

/**
 * @file
 * Main module file for Mail save file.
 */

/**
 * Implements hook_menu().
 */
function mail_save_file_menu() {
  $items = array();

  $items['admin/config/system/mail-save-file'] = array(
    'title' => 'Mail save file',
    'description' => 'Configure mail save file module.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mail_save_file_admin_form'),
    'access arguments' => array('configure mail_save_file'),
    'file' => 'mail_save_file.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function mail_save_file_permission() {
  $perms = array();

  $perms['configure mail_save_file'] = array(
    'title' => t('Configure Mail save file module'),
    'description' => t('Allows access to the administration pages for Mail save file.'),
  );

  return $perms;
}

/**
 * Implements hook_mail_alter().
 */
function mail_save_file_mail_alter(&$message) {
  if (!empty($message['send']) && variable_get('mail_save_file_enabled', FALSE)) {
    if (mail_save_file_enabled_for_message($message)) {
      // Get formatted email, and determine language.
      $system = drupal_mail_system($message['module'], $message['key']);
      $logger = $system->format($message);
      $logger['date_sent'] = REQUEST_TIME;
      $language = NULL;
      if (isset($logger['language']) && is_object($logger['language'])) {
        $language = $logger['language'];
      }
      // Support our extra mapped-message-id parameter.
      $message['mapped-message-id'] = _mail_save_file_map_message_id($message['id']);
      // Allow token replacement in filename.
      $file_name = variable_get('mail_save_file_name', '[message:id]-[current-date:raw].txt');
      $token_data = !empty($logger['params']) ? $logger['params'] : array();
      $token_data['mail-save-file-message'] = $message;
      $file_name = token_replace($file_name, $token_data, array(
        'language' => $language,
        'callback' => '_mail_save_file_name_tokens',
        'sanitize' => FALSE,
        'clear' => TRUE,
      ));
      // Save file.
      if ($directory = variable_get('mail_save_file_directory', 'private://emails')) {
        $destination = rtrim($directory, '/') . '/' .  $file_name;
        // If the filename *itself* specifies a directory, then create it on the
        // fly. Dynamic directories are often used as a way of distributing many
        // files across multiple directories, to overcome OS limits.
        if ((strpos($file_name, '/') !== FALSE) && ($sub_dir = drupal_dirname($destination))) {
          // Only generate the directory on the fly if it resolves to a strict
          // sub-directory of our expected parent. This avoids security issues
          // relating to tokens resolving to malicious values.
          if (!_mail_save_file_directory_is_within_parent($directory, $sub_dir)) {
            watchdog('mail_save_file', 'Failed to save email to file. Refused to write to directory (@directory) because it resolved to a location outside the expected parent directory (@parent_dir).', array('@directory' => $sub_dir, '@parent_dir' => $directory));
          }
          elseif (!file_prepare_directory($sub_dir, FILE_CREATE_DIRECTORY | FILE_MODIFY_PERMISSIONS)) {
            watchdog('mail_save_file', 'Failed to save email to file. Could not create (or make writable) directory: @directory', array('@directory' => $sub_dir));
          }
        }
        if (!file_unmanaged_save_data($logger['body'], $destination, FILE_EXISTS_ERROR)) {
          watchdog('mail_save_file', 'Failed to save email to file. Could not write file: @destination', array('@destination' => $destination));
        }
      }
    }
  }
}

/**
 * Determines if a certain email message should be saved to file by this module.
 *
 * @param array $message
 *   As passed through hook_mail_alter().
 *
 * @return bool
 *   TRUE if a file should be saved for this message.
 */
function mail_save_file_enabled_for_message($message) {
  // Allow a custom flag to be set on the message to override all else.
  if (isset($message['mail_save_file']) && !$message['mail_save_file']) {
    return FALSE;
  }
  $enabled = TRUE;
  // Limit to whitelist, but only if a whitelist is specified.
  if ($whitelist = variable_get('mail_save_file_whitelist', array())) {
    $enabled = in_array($message['id'], $whitelist);
  }
  // Limit to blacklist, but only if a blacklist is specified.
  if ($blacklist = variable_get('mail_save_file_blacklist', array())) {
    if (in_array($message['id'], $blacklist)) {
      $enabled = FALSE;
    }
  }
  return $enabled;
}

/**
 * Tests if a directory resolves to a sub-path of a certain parent directory.
 *
 * If $parent_dir is a non-local stream, we always return TRUE.
 *
 * @param string $parent_dir
 *   The parent directory. May be an absolute path, or a stream wrapper.
 * @param string $dir
 *   The sub-directory. Must be an absolute or relative path.
 *
 * @return bool
 *   TRUE if $parent_dir is local, and $dir resolves to a sub-directory of it.
 *   FALSE otherwise.
 */
function _mail_save_file_directory_is_within_parent($parent_dir, $dir) {
  // If $parent_dir is non-local, then we cannot meaningfully do this check.
  if (_mail_save_file_directory_uri_is_local($parent_dir)) {
    return strpos($dir, $parent_dir) === 0;
  }
  return TRUE;
}

/**
 * Helper to test if a given $uri is a local path.
 *
 * @param string $uri
 *   May specify an absolute/relative path or a stream wrapper.
 *
 * @return bool
 *   TRUE if the URI resolves to a local location,
 *   FALSE otherwise.
 */
function _mail_save_file_directory_uri_is_local($uri) {
  if ($wrapper = file_stream_wrapper_get_instance_by_uri($uri)) {
    return $wrapper instanceof DrupalLocalStreamWrapper;
  }
  return TRUE;
}

/**
 * Helper which returns the configured string for this message ID.
 *
 * If no mapping is configured, the original message_id is returned.
 *
 * @param string $message_id
 *   The message ID.
 *
 * @return string
 *   The configured alternative, or the original message ID not present.
 */
function _mail_save_file_map_message_id($message_id) {
  $mapping = variable_get('mail_save_file_message_id_to_name_mapping', array());
  return isset($mapping[$message_id]) ? $mapping[$message_id] : $message_id;
}

/**
 * Token replace callback for mail save file names.
 *
 * We add in all scalar properties of message as tokens available for use. We
 * also arbitrarily recurse into complex properties and make sub-properties
 * available as well.
 */
function _mail_save_file_name_tokens(&$replacements, $data, $options) {
  if (!empty($data['mail-save-file-message'])) {
    _mail_save_file_name_tokens_recurse("message", $replacements, $data['mail-save-file-message'], $options, 3);
  }
}

/**
 * Helper for recursively walking the message and providing token replacements.
 */
function _mail_save_file_name_tokens_recurse($prefix, &$replacements, $message_data, $options, $depth_limit) {
  if ($depth_limit === 0) {
    return;
  }
  foreach ((array) $message_data as $key => $value) {
    if (is_scalar($value)) {
      $replacements["[$prefix:$key]"] = $options['sanitize'] ? check_plain($value) : $value;
    }
    else {
      _mail_save_file_name_tokens_recurse("$prefix:$key", $replacements, $value, $options, $depth_limit - 1);
    }
  }
}
