<?php
/**
 * @file
 * Code for the comment scoring module.
 */

/**
 * Implements hook_views_api().
 */
function comment_score_views_api($module = NULL, $api = NULL) {
  return array("api" => "3.0");
}

/**
 * Implements hook_module_implements_alter().
 */
function comment_score_module_implements_alter(&$implementations, $hook) {
  // Move comment_revisions to the end of the list to ensure comment_score
  // runs first.
  if (module_exists('comment_revisions') && $hook === 'comment_presave') {
    $group = $implementations['comment_revisions'];
    unset($implementations['comment_revisions']);
    $implementations['comment_revisions'] = $group;
  }
}

/**
 * Implements hook_schema_alter().
 */
function comment_score_schema_alter(&$schema) {
  $schema['comment']['fields']['score'] = array(
    'description' => 'The {comment} score for moderation purposes.',
    'type' => 'int',
    'unsigned' => FALSE,
    'not null' => TRUE,
    'default' => 0,
  );
}

/**
 * Implements hook_permission().
 */
function comment_score_permission() {
  return array(
    'administer comment_score' => array(
      'title' => t('Administer the forum moderation screen'),
      'description' => t('Allow administrators to configure the how the forum is moderated.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function comment_score_menu() {
  $items = array();

  // Administration settings for the moderation screens.
  $items['admin/config/content/comment-score'] = array(
    'title' => 'Comment score settings',
    'description' => 'Administration settings for comment scoring.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('comment_score_settings'),
    'file' => 'comment_score.admin.inc',
    'access arguments' => array('administer comment_score'),
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/config/content/comment-score/settings'] = array(
    'title' => 'Settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  // Test the comment scoring settings with some sample text.
  $items['admin/config/content/comment-score/test'] = array(
    'title' => 'Comment score test',
    'description' => 'Test the current comment scoring settings against some text.',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('comment_score_test'),
    'access arguments' => array('administer comment_score'),
    'file' => 'comment_score.admin.inc',
  );

  return $items;
}

/**
 * Implementation of hook_rules_event_info().
 * @ingroup rules
 */
function comment_score_rules_event_info() {
  return array(
    'comment_score_bad_comment' => array(
      'label' => t('User posted a comment that was outside thresholds (bad)'),
      'group' => t('Forum Moderation'),
      'module' => 'comment_score',
      'variables' => array(
        'comment' => array(
          'type' => 'comment',
          'label' => t('The comment.'),
        ),
      ),
    ),
    'comment_score_good_comment' => array(
      'label' => t('User posted a comment that was within thresholds (good)'),
      'group' => t('Forum Moderation'),
      'module' => 'comment_score',
      'variables' => array(
        'comment' => array(
          'type' => 'comment',
          'label' => t('The comment.'),
        ),
      ),
    ),
  );
}

/**
 * Implements hook_comment_presave().
 */
function comment_score_comment_presave($comment) {
  // Find out who wrote the comment.
  global $user;
  $author = user_load($comment->uid);

  // We find out the score for the comment.
  $text = trim($comment->comment_body[LANGUAGE_NONE][0]['value']);
  $score = comment_score_text($text, $author);

  $roles = user_roles();
  unset($roles[DRUPAL_ANONYMOUS_RID]);
  unset($roles[DRUPAL_AUTHENTICATED_RID]);
  $trusted_rid = variable_get('comment_score_trusted_role', array_search('trusted commenter', $roles) ?: '');
  $is_trusted = in_array($trusted_rid, array_keys($author->roles));
  if (!$is_trusted) {
    $limit = variable_get('comment_score_pre_threshold', -10);
  }
  else {
    $limit = variable_get('comment_score_pre_threshold_trusted', 25);
  }

  // Set the score
  $comment->score = (int) $score;

  $is_an_edit = !empty($comment->cid) && !empty($comment->original);
  $user_same_as_original_author = ($comment->uid == $user->uid);

  // If you are using VBO to moderate comments, you can set this flag upon the
  // comment to ensure the usual comment publish/unpublish code does not run.
  $in_moderation_process = isset($comment->in_moderation);

  // If this comment is in active moderation, then we do not want to alter the
  // comment status, as the moderation will be doing this. Lets also not get
  // into an infinite loop here either with Rules.
  if (!$in_moderation_process) {
    // Check if the comment author is allowed to instant publish comments.
    // User will either have permission "administer comments" or
    // will have the role of "unmoderated commenter".
    if (user_access('administer comments', $author) || in_array(array_search('unmoderated commenter', $roles), array_keys($author->roles))) {
      // Leave the comment status at the default setting (whatever it is at
      // present).
      drupal_set_message(t('Comment saved and the status not changed'), 'status');
    }
    // Check if this is an administrator manually editing a comment by another
    // user.
    else if ($is_an_edit && !$user_same_as_original_author && user_access('administer comments')) {
      // Leave the comment status at the default setting (whatever it is at
      // present).
      drupal_set_message(t('Comment edited and the status not changed'), 'status');
    }
    else {
      // If the comment has a score is greater than the allowed threshold, then
      // this comment falls into moderation. We also need to inform the user what
      // has happened so they know where their comment is.
      if ($score >= $limit) {
        $comment->status = COMMENT_NOT_PUBLISHED;

        // We need to revoke the role for anyone that posted a comment that ends
        // up in pre-moderation. Rules is used to perform this action.
        rules_invoke_event('comment_score_bad_comment', $comment);
      }
      else {
        $comment->status = COMMENT_PUBLISHED;

        rules_invoke_event('comment_score_good_comment', $comment);
      }
    }
  }
}

/**
 * Implements hook_comment_load().
 */
function comment_score_comment_load($comments) {
  $result = db_query('SELECT cid,score FROM {comment} WHERE cid IN (:cids)', array(':cids' => array_keys($comments)));
  foreach ($result as $record) {
    $comments[$record->cid]->score = $record->score;
  }
}

/**
 * Work out the comment's negative score based on the current rules and text
 * supplied
 */
function comment_score_text($text, $author, $debug = FALSE) {
  $score = 0;
  $score_debug = array();

  // Blacklisted words are first.
  $blacklist_penalty = variable_get('comment_score_blacklist_penalty', 25);
  $default_words = trim(file_get_contents(drupal_get_path('module', 'comment_score') . '/blacklist.txt'));
  $words = variable_get('comment_score_blacklist_words', $default_words);
  $words = explode(PHP_EOL, $words);
  $words = array_map('trim', $words);

  foreach ($words as $word) {
    $matches = array();
    preg_match_all("/" . $word . "/i", $text, $matches);
    $count = count($matches[0]);
    if ($count) {
      $score_debug['blacklist'][] = format_plural($count, 'regex pattern %pattern matched.', 'regex pattern %pattern matched @count times.', array(
        '%pattern' => $word,
        '@count' => $count
      ));
      $score += ($count * $blacklist_penalty);
    }
  }

  // Capitals. First find the percent of letters that are captialised.
  $number_of_capitals = strlen(preg_replace('![^A-Z]+!', '', $text));
  $number_of_lower = strlen(preg_replace('![^a-z]+!', '', $text));
  $number_of_letters = $number_of_capitals + $number_of_lower;
  $ratio = $number_of_letters > 0 ? round(($number_of_capitals / $number_of_letters) * 100) : 0;
  $bad_ratio = variable_get('comment_score_capital_bad_ratio', 25);
  $good_ratio = variable_get('comment_score_capital_good_ratio', 5);
  if ($ratio > $bad_ratio) {
    $score += $ratio - $bad_ratio;
    $score_debug['capitals'] = t('ratio of %ratio as above the bad limit of @bad.', array(
      '%ratio' => $ratio,
      '@bad' => $bad_ratio,
    ));
  }
  else if ($ratio < $good_ratio) {
   $score -= $good_ratio - $ratio;
   $score_debug['capitals'] = t('ratio of %ratio as below the good limit of @good.', array(
     '%ratio' => $ratio,
     '@good' => $good_ratio,
   ));
  }

  // URLs
  $matches = array();
  preg_match_all("/https?:\/\//i", $text, $matches);
  $number_of_urls = count($matches[0]);
  $number_of_urls_allowed = variable_get('comment_score_urls_allowed', 1);
  $bad_url_modifier = variable_get('comment_score_urls_modifier', 25);
  if ($number_of_urls > $number_of_urls_allowed) {
    $score += ($number_of_urls - $number_of_urls_allowed) * $bad_url_modifier;
    $score_debug['urls'] = t('number of urls %count is greater than the @limit allowed.', array(
      '%count' => $number_of_urls,
      '@limit' => $number_of_urls_allowed,
    ));
  }

  // Length.
  $minimum_length = variable_get('comment_score_length_minimum', 50);
  if ($number_of_letters < $minimum_length) {
    $score += $minimum_length - $number_of_letters;
    $score_debug['length'] = t('length of %length was below the minimum of @minimum.', array(
      '%length' => $number_of_letters,
      '@minimum' => $minimum_length,
    ));
  }

  // Allow other modules to add additional rules (and not alter the author).
  // @see comment_score.api.php.
  if (is_object($author)) {
    $author = clone $author;
  }
  drupal_alter('comment_score_text', $score, $score_debug, $author);

  if ($debug) {
    return array(
      'score' => $score,
      'debug' => $score_debug,
    );
  }

  return $score;
}
