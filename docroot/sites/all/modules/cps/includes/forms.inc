<?php
/**
 * @file
 * Form definitions for admin forms.
 */

/**
 * Form callback; changeset preview form.
 */
function cps_changeset_preview_form($form, &$form_state) {
  $changeset_id = cps_get_current_changeset(TRUE);

  if ($changeset_id == CPS_PUBLISHED_CHANGESET) {
    $changeset_state = CPS_LIVE_STATUS;
  }
  else {
    $changeset = cps_changeset_load($changeset_id);
    $changeset_state = $changeset->status;
    $changeset_mine = $changeset->uid == $GLOBALS['user']->uid;
  }

  $form['#attached']['css'][] =  drupal_get_path('module', 'cps') . '/css/cps.css';

  $form['#type'] = 'fieldset';
  $form['#title'] = t('Site version:');
  $form['#description'] = t('Preview the site in the context of this site version.');

  $form['changeset_id'] = array(
    '#type' => 'select',
    '#title' => t('Site version'),
    '#options' => cps_get_changesets(),
    '#default_value' => $changeset_id,
  );

  if (!empty($changeset) && entity_access('view', 'cps_changeset', $changeset)) {
    $uri = $changeset->uri();
    $form['configure'] = array(
      '#markup' => l(t('Site version'), $uri['path'], array(
        'attributes' => array(
          'class' => array('configure'),
          'title' => t('Manage site version'),
        ))),
    );
  }

  if ($changeset_state == CPS_LIVE_STATUS && entity_access('create', 'cps_changeset')) {
    $form['new'] = array(
      '#markup' => l(t('Create'), 'admin/structure/changesets/add', array(
        'query' => drupal_get_destination(),
        'attributes' => array(
          'class' => array('new'),
          'title' => t('Add new site version'),
        ))),
    );
  }

  $state_class = 'cps-preview-form--' . drupal_html_class($changeset_state);
  $mine_class = !empty($changeset_mine) ? 'cps-changeset--mine' : 'cps-changeset--not-mine';
  $form['#prefix'] = '<div class="cps-preview-form ' . $state_class . ' ' . $mine_class . ' clearfix">';
  $form['#suffix'] = '<span class="cps-preview-form-status">' . t('Status:  @changeset_status', array('@changeset_status' => ucfirst($changeset_state))) . '</span></div>';
  return $form;
}

/**
 * Basic edit form for the content entity.
 *
 * The entity being edited should be stored in $form_state['entity']
 * when this form is built.
 *
 * The name of this form is autogenerated as $entity_type . '_edit_form'.
 */
function cps_changeset_edit_form($form, &$form_state) {
  $entity = $form_state['entity'];

  $form['info']['name'] = array(
    '#type' => 'textfield',
    '#title' => t('Name'),
    '#description' => t('This will appear in the administrative interface to easily identify it.'),
    '#default_value' => $entity->name,
    '#required' => TRUE,
  );

  $form['info']['description'] = array(
    '#type' => 'textarea',
    '#title' => t('Description'),
    '#default_value' => $entity->description,
  );
  
  $form['info']['lock_in_select'] = array(
    '#type' => 'checkbox',
    '#title' => t('Lock in select'),
    '#description' => t('If checked all users will see this site version in the site version selector bar while unpublished.'),
    '#default_value' => $entity->lock_in_select,
  );

  $form['actions'] = array(
    '#type' => 'actions',
  );

  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
  );

  return $form;
}

/**
 * Validate callback for the content entity.
 */
function cps_changeset_edit_form_validate($form, &$form_state) {
}

/**
 * Submit callback for the content entity.
 */
function cps_changeset_edit_form_submit($form, &$form_state) {
  $entity = $form_state['entity'];
  $entity->name = $form_state['values']['name'];
  $entity->description = $form_state['values']['description'];
  $entity->lock_in_select = $form_state['values']['lock_in_select'];

  if (!empty($entity->is_new)) {
    // Automatically move us to the new changeset context.
    cps_set_current_changeset($entity->changeset_id);

    // If there is a destination, we have to remove the changeset ID from it.
    if (!empty($_GET['destination'])) {
      // We used drupal_get_destination() before because it may not have been
      // calculated; to directly modify it we will then need to get the
      // (now cached) static.
      $_GET['destination'] = preg_replace("/changeset_id=[^&]+/", 'changeset_id=' . $entity->changeset_id, $_GET['destination']);
    }
  }
}

/**
 * Form callback to display the publish changeset form.
 */
function cps_changeset_publish_changeset_form($form, &$form_state) {
  $form['warning'] = array(
    '#markup' => '<div class="publish-warning">' . t('Are you sure you want to publish this? This action cannot be undone!') . '</div>',
  );

  $form['actions']['publish'] = array(
    '#type' => 'submit',
    '#value' => t('Publish'),
  );

  $form['actions']['cancel'] = array(
    '#type' => 'submit',
    '#value' => t('Cancel'),
    '#limit_validation_errors' => array(),
    '#submit' => array('cps_changeset_publish_changeset_form_cancel'),
  );

  return $form;
}

/**
 * Submit handler to cancel the form.
 */
function cps_changeset_publish_changeset_form_cancel($form, &$form_state) {
  $form_state['redirect'] = $form_state['entity']->uri();
}

/**
 * Submit handler for the publish changeset form.
 */
function cps_changeset_publish_changeset_form_submit($form, &$form_state) {
  // This is handled as a traditional submit method rather than my usual
  // preference of divorcing work from the form itself due to the nature
  // of batch API.
  $batch = array(
    'operations' => array(
      array('cps_changeset_publish_batch_lock', array()),
      array('cps_changeset_publish_batch_entities', array($form_state['entity'])),
    ),
    'finished' => 'cps_changeset_publish_batch_finished',
    'title' => t('Publishing %changeset', array('%changeset' => $form_state['entity']->name)),
    'file' => drupal_get_path('module', 'cps') . '/includes/forms.inc',
  );

  if (variable_get('cps_override_variables', FALSE)) {
    $batch['operations'][] = array('cps_changeset_publish_batch_variables', array());
  }

  foreach (cps_get_supported() as $entity_type) {
    // For every entity type we support, add another operation for that entity type.
    $batch['operations'][] = array('cps_changeset_publish_batch_update', array($form_state['entity'], $entity_type));
  }

  drupal_alter('cps_publish_changeset_batch', $batch, $form_state);

  batch_set($batch);

  $form_state['redirect'] = $form_state['entity']->uri();
}


/**
 * Batch API callback to acquire a lock for publishing.
 *
 * @param $entity_ids
 *   An array of arrays. Each entry in the array is first entity_type, then entity_id.
 * @param $changeset
 * @param $context
 */
function cps_changeset_publish_batch_lock(&$context) {
  if (cps_publish_lock()) {
    $context['finished'] = TRUE;
  }
  else {
    sleep(1);
    $context['finished'] = FALSE;
    $context['message'] = t('Waiting for lock: @time', array('@time' => format_interval(cps_publish_lock_time())));
  }
}

/**
 * Batch API callback to publish the entities in a changeset.
 *
 * @param $changeset
 * @param $context
 */
function cps_changeset_publish_batch_entities($changeset, &$context) {
  cps_publish_changeset_entities($changeset->changeset_id);
  $context['results']['changeset'] = $changeset;
  $context['message'] = t('Publishing entities');
  $context['finished'] = TRUE;
  return $context;
}

/**
 * Batch API callback to publish the variables in a changeset.
 */
function cps_changeset_publish_batch_variables(&$context) {
  $item = $context['results']['entity'];
  foreach ($item->variables as $name => $value) {
    db_merge('variable')->key(array('name' => $name))->fields(array('value' => serialize($value)))->execute();
  }
  cache_clear_all('variables', 'cache_bootstrap');
  $context['message'] = t('Publishing variables');
}

/**
 * Batch API callback to put in changeset markers for items that exist but didn't change.
 * @param $entity_type
 * @param $context
 */
function cps_changeset_publish_batch_update($changeset, $entity_type, &$context) {
  $changeset_id = $changeset->changeset_id;

  // Use the $context['sandbox'] at your convenience to store the
  // information needed to track progression between successive calls.
  if (empty($context['sandbox'])) {
    $entity_info = entity_get_info($entity_type);
    $context['sandbox'] = array();
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['current_item'] = 0;
    $context['message'] = t('Marking unchanged @entity_type content', array('@entity_type' => $entity_info['label']));
  }

  $limit = 100;
  $count = cps_add_untracked_entities($changeset_id, $entity_type, $context['sandbox']['current_item'], $limit);

  $context['results']['changeset'] = $changeset;

  if (!$count) {
    $context['finished'] = TRUE;
  }
  else {
    $context['finished'] = FALSE;
    $context['sandbox']['current_item'] = $context['sandbox']['current_item'] + $count;
  }
}

/**
 * Batch API callback to finish the submission.
 *
 * @param $success
 * @param $results
 * @param $operations
 */
function cps_changeset_publish_batch_finished($success, $results, $operations) {
  if ($success) {
    $changeset = $results['changeset'];
    // Set the publication time on the item. We have to GET the item somehow.
    $changeset->published = REQUEST_TIME;
    $changeset->setStatus(CPS_ARCHIVED_STATUS);
    if (variable_get('cps_override_variables', FALSE)) {

      // Rebuild the variables in the same manner that the cache is built from variable_initialize.
      $changeset->variables = array_map('unserialize', db_query('SELECT name, value FROM {variable}')->fetchAllKeyed());
      // Go through and unset any whitelisted variables so that they aren't stored in the archive.
      foreach ($changeset->variables as $name => $value) {
        if (strpos($name, 'cache') !== FALSE) {
          unset($results['entity']->variables[$name]);
        }
      }
    }

    $changeset->save();

    module_invoke_all('cps_changeset_published', $changeset, 'published');

    // Switch them to the published changeset.
    cps_set_current_changeset(NULL);

    drupal_set_message(t('The site version %changeset has been published.', array('%changeset' => $changeset->name)));
  }

  cps_publish_unlock();
}

// -----------------------------------------------------------------------
// Unpublish form and handlers.

/**
 * Form callback to display the unpublish changeset form.
 */
function cps_changeset_unpublish_changeset_form($form, &$form_state) {
  $entity = $form_state['entity'];
  $form_state['previous'] = cps_changeset_load($entity->getPreviousChangeset());

  $form['warning'] = array(
    '#markup' => '<div class="unpublish-warning">' . t('<p>Are you sure you want to unpublish this?</p><p> This will revert content to the previous site version "%changeset".</p>', array('%changeset' => $form_state['previous']->name)) . '</div>',
  );

  $form['actions']['unpublish'] = array(
    '#type' => 'submit',
    '#value' => t('Revert'),
  );

  $form['actions']['cancel'] = array(
    '#type' => 'submit',
    '#value' => t('Cancel'),
    '#limit_validation_errors' => array(),
    // We re-use the publish_changeset_form_cancel here because all it does is redirect.
    '#submit' => array('cps_changeset_publish_changeset_form_cancel'),
  );

  return $form;
}

/**
 * Submit handler for the unpublish changeset form.
 */
function cps_changeset_unpublish_changeset_form_submit($form, &$form_state) {
  // We have to tell batch where to include this file.
  $batch = array(
    'operations' => array(
      array('cps_changeset_publish_batch_lock', array()),
      array('cps_changeset_unpublish_batch_variables', array($form_state['entity'], $form_state['previous'])),
      array('cps_changeset_unpublish_batch_entity', array()),
    ),
    'finished' => 'cps_changeset_unpublish_batch_finished',
    'title' => t('Reverting %changeset', array('%changeset' => $form_state['entity']->name)),
    'file' => drupal_get_path('module', 'cps') . '/includes/forms.inc',
  );

  drupal_alter('cps_unpublish_changeset_batch', $batch, $form_state);

  batch_set($batch);

  $form_state['redirect'] = $form_state['entity']->uri();
}

/**
 * Batch API callback to unpublish the entities in a changeset.
 */
function cps_changeset_unpublish_batch_variables($item, $previous, &$context) {
  // Use the $context['sandbox'] at your convenience to store the
  // information needed to track progression between successive calls.
  if (empty($context['sandbox'])) {
    $context['sandbox'] = array();
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['current_item'] = 0;
    $context['results']['entity'] = $item;
    $context['results']['previous'] = $previous;
  }

  if (variable_get('cps_override_variables', FALSE)) {

    $result = db_query("SELECT name, value FROM {variable}");
    $all_variables = array();
    while ($var = $result->fetchObject()) {
      $all_variables[$var->name] = unserialize($var->value);
    }

    foreach ($all_variables as $name => $value) {
      if (isset($previous->variables[$name]) && $previous->variables[$name] != $value) {
        db_merge('variable')->key(array('name' => $name))->fields(array('value' => serialize($previous->variables[$name])))->execute();
      }
      else {
        // If a variable is unchanged, unset it so we won't mistakenly report it as a change in the
        // reverted changeset.
        if (isset($item->variables[$name])) {
          unset($item->variables[$name]);
        }
      }
    }
    cache_clear_all('variables', 'cache_bootstrap');
  }

  $context['message'] = t('Reverting variables');
}

/**
 * Batch API callback to put in changeset markers for items that exist but didn't change.
 * @param $entity_type
 * @param $context
 */
function cps_changeset_unpublish_batch_entity(&$context) {
  $changeset_id = $context['results']['entity']->changeset_id;
  $previous = $context['results']['previous']->changeset_id;
  cps_unpublish_changeset_entities($changeset_id, $previous);
  cps_remove_untracked_entities($changeset_id);
}

/**
 * Batch API callback to finish the submission.
 *
 * @param $success
 * @param $results
 * @param $operations
 */
function cps_changeset_unpublish_batch_finished($success, $results, $operations) {
  if ($success) {
    // Set the publication time on the item. We have to GET the item somehow.
    $results['entity']->published = NULL;
    $results['entity']->setStatus('unpublished');
    $results['entity']->save();

    drupal_set_message(t('The site version %changeset has been unpublished.', array('%changeset' => $results['entity']->name)));
  }

  module_invoke_all('cps_changeset_published', $results['entity'], 'unpublished');

  cps_publish_unlock();
}

