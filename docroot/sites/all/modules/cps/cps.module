<?php

/**
 * @file
 * Main module file for the Content Preview System.
 */

define('CPS_PUBLISHED_CHANGESET', 'published');
define('CPS_INSTALLED_CHANGESET', 'installed');

define('CPS_LIVE_STATUS', 'live');
define('CPS_ARCHIVED_STATUS', 'archived');

require_once __DIR__ . '/includes/query.inc';

// -----------------------------------------------------------------------
// Drupal Core Hooks

/**
 * Implements hook_boot().
 */
function cps_boot() {
  // If we are looking at a changeset, load overridden variables and add
  // them into $conf.

  // This isn't using cps_changeset_load() because that loads a bunch of things
  // that don't exist during hook_boot.
  if (variable_get('cps_override_variables', FALSE)) {
    $changeset_id = cps_get_current_changeset();
    if ($changeset_id != CPS_PUBLISHED_CHANGESET) {
      $vars = db_query("SELECT variables FROM {cps_changeset} WHERE changeset_id = :changeset_id", array(':changeset_id' => $changeset_id))->fetchField();
      if ($vars) {
        global $conf;
        global $cps_conf;
        $cps_conf = unserialize($vars);

        if ($cps_conf) {
          foreach ($cps_conf as $name => $value) {
            $conf[$name] = $value;
          }
        }
      }
    }
  }
}

/**
 * Implements hook_exit().
 */
function cps_exit() {
  if (variable_get('cps_override_variables', FALSE)) {
    global $cps_conf_changed;
    if (!empty($cps_conf_changed)) {
      $changeset_id = cps_get_current_changeset(TRUE);
      if ($changeset_id != CPS_PUBLISHED_CHANGESET) {
        $changeset = cps_changeset_load($changeset_id);
        // Only write if $changeset->published is empty.
        if (empty($changeset->published)) {
          global $cps_conf;
          $changeset->variables = $cps_conf;
          $changeset->save();
        }
      }
    }
  }
}

/**
 * Implements hook_module_implements_alter().
 */
function cps_module_implements_alter(&$implementations, $hook) {
  if (in_array($hook, array('entity_query_alter', 'views_query_alter', 'field_attach_submit'))) {
    // Move CPS's query alter after entity reference's so we can remove the
    // checks for published status. Also move CPS's hook_field_attach_submit()
    // implementation last, so it can override what drafty_enforce does.
    $temp = $implementations['cps'];
    unset($implementations['cps']);
    $implementations['cps'] = $temp;
  }
}

/**
 * Implements of hook_permission()
 */
function cps_permission() {
  return array(
    'administer changesets' => array(
      'title' => t('Administer site versions'),
      'description' => t('Add, delete, edit and manipulate site versions.'),
    ),
    'edit all changesets' => array(
      'title' => t('Edit all site versions'),
      'description' => t('Can edit and delete site versions owned by other people.'),
    ),
    'view changesets' => array(
      'title' => t('View site versions'),
      'description' => t('View the site version widget and change the site preview accordingly.'),
    ),
    'preview changesets' => array(
      'title' => t('Preview site versions'),
      'description' => t('Preview site versions without being able to see the widget.'),
    ),
    'publish changesets' => array(
      'title' => t('Publish site versions'),
      'description' => t('Can publish site versions.'),
    ),
  );
}

/**
 * Implements hook_entity_info().
 */
function cps_entity_info() {
  $info = array();

  $info['cps_changeset'] = array(
    'label' => t('Site version'),
    'entity class' => 'CPSChangeset',
    'controller class' => 'CPSChangesetController',
    'views controller class' => 'EntityDefaultViewsController',
    'base table' => 'cps_changeset',
    // After variants this will change to FALSE
    'fieldable' => FALSE,
    'entity keys' => array(
      'id' => 'changeset_id',
      'label' => 'name',
    ),
    'bundles' => array(
      'cps_changeset' => array(
        'label' => t('Site version'),
      ),
    ),
    'view modes' => array(
      'full' => array(
        'label' => t('Full'),
        'custom settings' => FALSE,
      ),
      'embed' => array(
        'label' => t('Embedded'),
        'custom settings' => FALSE,
      ),
      'mail' => array(
        'label' => t('Mailed'),
        'custom settings' => FALSE,
      ),
    ),
    // entity module callbacks
    'label callback' => 'entity_class_label',
    'uri callback' => 'entity_class_uri',
    'view callback' => 'cps_changeset_view',
    'creation callback' => 'cps_changeset_create',
    'access callback' => 'cps_changeset_access',
    'save callback' => 'cps_changeset_save',
    'module' => 'cps',
    // Modified property name for entity_modified module.
    'modified property name' => 'changed',
  );

  return $info;
}

/**
 * Implements hook_menu().
 */
function cps_menu() {
  $items = array();
  $items['admin/structure/changesets/%cps_changeset'] = array(
    'title callback' => 'entity_label',
    'title arguments' => array('cps_changeset', 3),
    'page callback' => 'cps_changeset_view_page',
    'page arguments' => array(3, 'full'),
    'access callback' => 'entity_access',
    'access arguments' => array('view', 'cps_changeset', 3),
    'file' => 'includes/admin.inc',
  );

  $items['admin/structure/changesets/%cps_changeset/view'] = array(
    'title' => 'Status',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
    'file' => 'includes/admin.inc',
  );

  $items['admin/structure/changesets/%cps_changeset/edit'] = array(
    'title' => 'Edit',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page callback' => 'cps_changeset_edit_page',
    'page arguments' => array(3),
    'access callback' => 'entity_access',
    'access arguments' => array('update', 'cps_changeset', 3),
    'weight' => -9,
    'file' => 'includes/admin.inc',
  );

  $items['admin/structure/changesets/%cps_changeset/view-site'] = array(
    'title' => 'Switch to this version',
    'type' => MENU_LOCAL_ACTION,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page callback' => 'cps_changeset_view_site_page',
    'page arguments' => array(3),
    'access callback' => 'cps_changeset_view_site_access',
    'access arguments' => array(3),
    'file' => 'includes/admin.inc',
    'weight' => -10,
  );

  $items['admin/structure/changesets/%cps_changeset/publish'] = array(
    'title' => 'Publish',
    'type' => MENU_LOCAL_ACTION,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page callback' => 'cps_changeset_publish_page',
    'page arguments' => array(3),
    'access callback' => 'entity_access',
    'access arguments' => array('publish', 'cps_changeset', 3),
    'file' => 'includes/admin.inc',
  );

  $items['admin/structure/changesets/%cps_changeset/unpublish'] = array(
    'title' => 'Unpublish',
    'type' => MENU_LOCAL_ACTION,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page callback' => 'cps_changeset_unpublish_page',
    'page arguments' => array(3),
    'access callback' => 'entity_access',
    'access arguments' => array('unpublish', 'cps_changeset', 3),
    'file' => 'includes/admin.inc',
  );

  $items['admin/structure/changesets/%cps_changeset/delete'] = array(
    'title' => 'Delete',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('cps_changeset_delete_form', 3),
    'access callback' => 'entity_access',
    'access arguments' => array('delete', 'cps_changeset', 3),
    'weight' => -8,
    'file' => 'includes/admin.inc',
  );

  $items['admin/structure/changesets/%cps_changeset/remove/%/%'] = array(
    'title' => 'Remove',
    'type' => MENU_CALLBACK,
    'page callback' => 'cps_changeset_remove_page',
    'page arguments' => array(3, 5, 6),
    'access callback' => 'entity_access',
    'access arguments' => array('update', 'cps_changeset', 3),
    'file' => 'includes/admin.inc',
  );

  $items['admin/structure/changesets/%cps_changeset/move/%/%'] = array(
    'title' => 'Move',
    'type' => MENU_CALLBACK,
    'page callback' => 'cps_changeset_move_page',
    'page arguments' => array(3, 5, 6),
    // Handle access checking in the callback as its a bit complex for here.
    'access callback' => TRUE,
    'file' => 'includes/admin.inc',
  );

  if (module_exists('devel')) {
    $items['admin/structure/changesets/%cps_changeset/devel'] = array(
      'title' => 'Devel',
      'page callback' => 'devel_load_object',
      'page arguments' => array('cps_changeset', 3),
      'access arguments' => array('access devel information'),
      'type' => MENU_LOCAL_TASK,
      'weight' => 100,
      'file' => 'devel.pages.inc',
      'file path' => drupal_get_path('module', 'devel'),
    );

    $items['admin/structure/changesets/%cps_changeset/devel/load'] = array(
      'title' => 'Load',
      'type' => MENU_DEFAULT_LOCAL_TASK,
    );

    $items['admin/structure/changesets/%cps_changeset/devel/render'] = array(
      'title' => 'Render',
      'page callback' => 'devel_render_object',
      // Normally this would be the name of the entity type, but slightly
      // modified in order to call the right function.
      'page arguments' => array('cps_changeset', 3),
      'access arguments' => array('access devel information'),
      'file' => 'devel.pages.inc',
      'file path' => drupal_get_path('module', 'devel'),
      'type' => MENU_LOCAL_TASK,
      'weight' => 100,
    );
  }

  $items['admin/structure/changesets'] = array(
    'title' => 'Site versions',
    'description' => 'Manage changesets.',
    'page callback' => 'cps_changeset_list_page',
    'page arguments' => array('administer_changesets'),
    'file' => 'includes/admin.inc',
    'access arguments' => array('administer changesets'),
    'weight' => -10,
  );

  $items['admin/structure/changesets/open'] = array(
    'title' => 'Open',
    'weight' => -10,
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/structure/changesets/archived'] = array(
    'title' => 'Archive',
    'page callback' => 'cps_changeset_list_page',
    'page arguments' => array('archived_changesets'),
    'file' => 'includes/admin.inc',
    'access arguments' => array('administer changesets'),
    'weight' => 10,
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/structure/changesets/add'] = array(
    'title' => 'Add site version',
    'page callback' => 'cps_changeset_add_entity_page',
    'page arguments' => array(),
    'access callback' => 'entity_access',
    'access arguments' => array('create', 'cps_changeset'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'includes/admin.inc',
  );

  return $items;
}

/**
 * Implements hook_entity_load().
 */
function cps_entity_load(&$entities, $entity_type) {
  $changeset = cps_get_current_changeset();
  if ($changeset == CPS_PUBLISHED_CHANGESET) {
    return;
  }

  $entity_info = entity_get_info($entity_type);
  if (empty($entity_info['entity keys']['revision'])) {
    return;
  }

  // When a non-default revision is being loaded, don't overwrite any of the
  // contents of that revision.
  foreach ($entities as $entity) {
    // If a revision was requested, then there is only going to be one entity
    // in the list. We don't touch entity loading when a specific revision was
    // requested.
    // When the new drafty dependency is added, drafty module may not actually
    // be enabled, and this can cause fatal errors on sites that load entities
    // during bootstrap, so check for module existence.
    if (module_exists('drafty') && drafty()->wasRevisionRequested($entity)) {
      return;
    }
  }

  $revision_key = $entity_info['entity keys']['revision'];
  $keys = array_keys($entities);
  // We don't use cps_get_tracked_entities() because when viewing archived
  // changesets, would either have to load all the entities on the site or
  // would not correctly get entities that were tagged for their state at
  // the time of publication.
  $result = db_query('SELECT * FROM {cps_entity} WHERE entity_type = :entity_type AND entity_id IN (:ids) AND changeset_id = :changeset_id', array(':entity_type' => $entity_type, ':ids' => $keys, ':changeset_id' => $changeset));
  foreach ($result as $entity_state) {
    $tracked[$entity_state->entity_id] = $entity_state->revision_id;
  }

  foreach ($entities as $entity) {
    list($entity_id, $revision_id, $bundle) = entity_extract_ids($entity_type, $entity);

    // If this entity has a revision set for the current change set,
    // we need to swap it out for the correct revision.
    if (isset($tracked[$entity_id]) && $tracked[$entity_id] != $revision_id) {
      $swap_revision_id = $tracked[$entity_id];
      $draft_revisions = entity_load($entity_type, array($entity_id), array($revision_key => $swap_revision_id));

      // Swap the entity!
      if (!empty($draft_revisions[$entity_id])) {
        $new_entity = $entities[$entity_id] = $draft_revisions[$entity_id];
        // Store the current revision ID so we can tell later if we need to put it back.
        $new_entity->published_revision_id = $revision_id;
        $new_entity->published_revision = clone($entity);
        // Tell entity API not to save this as the default revision:
        $new_entity->default_revision = FALSE;
        $entities[$entity_id] = $new_entity;
      }
    }
  }
}

/**
 * Get all unpublished changesets.
 */
function cps_get_unpublished_changesets() {
  $changesets = &drupal_static(__FUNCTION__);
  if (!isset($changesets)) {
    $changesets = db_query('SELECT changeset_id FROM {cps_changeset} WHERE published = 0')->fetchCol();
  }
  return $changesets;
}

/**
 * Implements hook_entity_presave().
 */
function cps_entity_presave($entity, $entity_type) {
  if (cps_can_entity_be_tracked($entity_type, $entity)) {
    $initial = FALSE;
    $current_changeset = cps_get_current_changeset();
    if (!empty($entity->cps_initial_unpublished)) {
      $initial = TRUE;
      cps_override_changeset('initial');
    }
    else if ($current_changeset != CPS_PUBLISHED_CHANGESET) {
      // Force a draft revision to be created when updating entities within a
      // changeset. However respect the state of $entity->is_draft_revision if
      // it is already set since drafty uses this internally to re-save the
      // published version, and other modules may need the ability to override
      // this in specific circumstances.
      if (!isset($entity->is_draft_revision) && cps_is_entity_tracked($entity_type, $entity)) {
        $entity->is_draft_revision = TRUE;
      }
    }

    cps_set_revision_log($entity);

    if ($initial) {
      // Ordinarily we should use NULL to reset the override, but
      // we may have already been overridden when we got here so just
      // put back what we found instead.
      cps_override_changeset($current_changeset);
    }
  }
}

/**
 * Implements hook_entity_insert().
 */
function cps_entity_insert($entity, $entity_type) {
  if (!cps_can_entity_be_tracked($entity_type, $entity)) {
    return;
  }

  cps_insert_entity_tracking($entity_type, $entity);
}

/**
 * Inserts a CPS record for an entity that is not currently tracked by CPS.
 *
 * This function should only be used when saving an entity that can be tracked
 * by CPS but is not yet tracked in any changeset. (These conditions should be
 * verified by the caller prior to use.) A new CPS record will be added for the
 * current changeset as well as the special 'initial' changeset.
 *
 * @param string $entity_type
 *   The type of entity, e.g. 'node'.
 * @param object $entity
 *   The entity object.
 *
 * @see cps_update_entity_tracking()
 * @see cps_entity_insert()
 * @see cps_entity_update()
 */
function cps_insert_entity_tracking($entity_type, $entity) {
  $changeset = cps_get_current_changeset();
  list($entity_id, $revision_id) = entity_extract_ids($entity_type, $entity);

  // If a new entity is inserted with the live/published changeset active,
  // it is immediately live. Mark it as such in the most recently published
  // changeset. This handles making sure that there is a history for
  // programmatically created entities outside of changesets.
  if ($changeset == CPS_PUBLISHED_CHANGESET) {
    $changeset_id = db_query("SELECT changeset_id FROM {cps_changeset} ORDER BY published DESC LIMIT 1")->fetchCol();
    db_insert('cps_entity')
      ->fields(array(
        'entity_type' => $entity_type,
        'entity_id' => $entity_id,
        'revision_id' => $revision_id,
        'changeset_id' => $changeset_id,
        'published' => TRUE,
      ))->execute();

    return;
  }

  // When an new entity is inserted, we actually want two revisions to be saved.
  //  - An unpublished revision in the 'published' changeset, since CPS treats
  //    any entity that's never been published as 'unpublished'.
  //  - A draft revision in the current changeset with the published flag set to
  //    the same as on the node form.

  db_insert('cps_entity')
    ->fields(array(
      'entity_type' => $entity_type,
      'entity_id' => $entity_id,
      'changeset_id' => $changeset,
      'revision_id' => $revision_id,
   ))->execute();
  // Operate on a clone to avoid changing the entity prior to subsequent
  // hook_entity_insert() implementations.
  $live_revision = clone $entity;

  // The entity is no longer new.
  unset($live_revision->is_new);

  entity_status_set($entity_type, $live_revision, ENTITY_UNPUBLISHED);

  $live_revision->cps_initial_unpublished = TRUE;
  module_invoke_all('cps_live_revision_create', $entity_type, $live_revision);
  entity_save($entity_type, $live_revision);
}

/**
 * Implements hook_entity_update().
 */
function cps_entity_update($entity, $entity_type) {
  if (!cps_can_entity_be_tracked($entity_type, $entity)) {
    return;
  }

  if (cps_is_entity_tracked($entity_type, $entity)) {
    cps_update_entity_tracking($entity_type, $entity);
  }
  else {
    cps_insert_entity_tracking($entity_type, $entity);
  }
}

/**
 * Updates the CPS record for an entity that is already tracked by CPS.
 *
 * This function should be used whenever the entity is saved and already is
 * tracked by CPS, regardless of the changeset in which it is tracked. (These
 * conditions should be verified by the caller prior to use.) The CPS record
 * will be updated for the current active changeset.
 *
 * @param string $entity_type
 *   The type of entity, e.g. 'node'.
 * @param object $entity
 *   The entity object.
 *
 * @see cps_insert_entity_tracking()
 * @see cps_entity_update()
 */
function cps_update_entity_tracking($entity_type, $entity) {
  $changeset = cps_get_current_changeset();
  // If we are not on a change set, do nothing.
  if ($changeset == CPS_PUBLISHED_CHANGESET) {
    return;
  }

  // See cps_insert_entity_tracking().
  if (!empty($entity->cps_initial_unpublished)) {
    $changeset = 'initial';
  }

  // Only the 'initial' revision and draft revisions should be tracked in
  // changesets. Everything else is in the 'published' changeset which is
  // untracked.
  if ($changeset !== 'initial' && !drafty()->isDraftRevision($entity)) {
    return;
  }

  list($entity_id, $revision_id) = entity_extract_ids($entity_type, $entity);
  // Store state information.
  db_merge('cps_entity')
    ->key(array(
      'entity_type' => $entity_type,
      'entity_id' => $entity_id,
      'changeset_id' => $changeset,
    ))
    ->fields(array(
      'revision_id' => $revision_id,
    ))
    ->execute();
}

/**
 * Implements hook_field_attach_submit().
 */
function cps_field_attach_submit($entity_type, $entity, $form, &$form_state) {
  // If an existing entity is being tracked by CPS for the first time, prevent
  // Drafty from copying any older live revision back over it. This ensures
  // that the live revision will be set to an unpublished version of the entity
  // in the exact state it was in when it was first tracked by CPS, thereby
  // matching the behavior of entities that are tracked by CPS as soon as the
  // entity is created.
  list($entity_id) = entity_extract_ids($entity_type, $entity);
  if (isset($entity_id) && cps_can_entity_be_tracked($entity_type, $entity) && !cps_is_entity_tracked($entity_type, $entity)) {
    $entity->is_draft_revision = FALSE;
  }
}

/**
 * Implements hook_entity_delete().
 */
function cps_entity_delete($entity, $entity_type) {
  list($entity_id) = entity_extract_ids($entity_type, $entity);
  db_delete('cps_entity')
    ->condition('entity_type', $entity_type)
    ->condition('entity_id', $entity_id)
    ->execute();
}

/**
 * Implements hook_field_attach_delete_revision().
 */
function cps_field_attach_delete_revision($entity_type, $entity) {
  list($entity_id, $revision_id, $bundle) = entity_extract_ids($entity_type, $entity);
  db_delete('cps_entity')
    ->condition('entity_type', $entity_type)
    ->condition('revision_id', $revision_id)
    ->condition('entity_id', $entity_id)
    ->execute();
}

function cps_form_views_exposed_form_alter(&$form, &$form_state, $form_id) {
  if (isset($form_state['view']) && ($form_state['view']->tag == 'cps' || $form_state['view']->tag == 'only mine') && isset($form['uid_current'])) {
    $form['uid_current']['#options'] = array(
      'All' => t('All'),
      '1' => t('Only mine'),
    );
  }
}

// -----------------------------------------------------------------------
// Contrib Hooks

/**
 * Implements hook_ctools_plugin_directory().
 */
function cps_ctools_plugin_directory($module, $plugin) {
  if ($module == 'cps') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Implements hook_iib_page_item().
 */
function cps_iib_page_item() {
  if (user_access('view changesets')) {
    $path = drupal_get_path('module', 'cps');
    ctools_include('forms', 'cps');
    $items['left'] = array(
      '#weight' => -10,
      'form' => drupal_get_form('cps_changeset_preview_form'),
      '#attached' => array(
        'css' => array("$path/css/cps.css"),
        'js' => array(
          "$path/js/cps.js",
          array(
            'data' => array(
              'cps' => array('changeset_id' => cps_get_current_changeset(TRUE)),
            ),
            'type' => 'setting',
          ),
        ),
      ),
    );
    return $items;
  }
}

/**
 * Implements hook_iib_hidden_alter().
 */
function cps_iib_hidden_alter(&$hidden) {
  $hidden = FALSE;
}

/**
 * Implements hook_ctools_plugin_api().
 */
function cps_ctools_plugin_api($module, $api) {
  if ($module == 'cps' && $api == 'cps') {
    return array('version' => 1);
  }
}

/**
 * Implements hook_views_api().
 */
function cps_views_api() {
  return array(
    'path' => drupal_get_path('module', 'cps') . '/plugins/views',
    'api' => 3,
  );
}

/**
 * Sets the revision log for an entity.
 */
function cps_set_revision_log($entity) {
  $current_changeset = cps_get_current_changeset();
  if ($current_changeset != CPS_PUBLISHED_CHANGESET) {
    $changeset = cps_changeset_load($current_changeset);
    if ($changeset) {
      $name = $changeset->name;
    }
    else {
      $name = $current_changeset;
    }
  }
  else {
    $name = 'Published';
  }
  $entity->log = t('Revision for site version @changeset', array('@changeset' => $name));
}

/**
 * Implements hook_entity_property_info().
 */
function cps_entity_property_info() {
  return entity_get_controller('cps_changeset')->hook_entity_property_info();
}

/**
 * Implements hook_entitycache_load_alter().
 */
function cps_entitycache_load_alter(&$entities) {
  if (cps_get_current_changeset() !== CPS_PUBLISHED_CHANGESET) {
    // If the state is not empty, do not let entitycache load things from cache.
    $entities = array();
  }
}

/**
 * Implements hook_entitycache_save_alter().
 */
function cps_entitycache_save_alter(&$entities) {
  if (cps_get_current_changeset() !== CPS_PUBLISHED_CHANGESET) {
    // If the state is not empty, do not let entitycache save things in cache.
    $entities = array();
  }
}

// -----------------------------------------------------------------------
// Public API

/**
 * Fetch the currently in use changeset.
 *
 * @param $test
 *   If TRUE, test to ensure the changeset is valid.
 *
 * @return string
 *   The current changeset id.
 */
function cps_get_current_changeset($test = FALSE) {

  if (isset($GLOBALS['cps_override_changeset'])) {
    return $GLOBALS['cps_override_changeset'];
  }
  if (!function_exists('user_access')) {
    drupal_load('module', 'user');
  }

  if (!drupal_is_cli() && !user_access('preview changesets') && !user_access('view changesets') && !user_access('administer changesets')) {
    return CPS_PUBLISHED_CHANGESET;
  }

  if (isset($_GET['changeset_id'])) {
    $changeset_id = $_GET['changeset_id'];
    $_SESSION['changeset_id'] = $changeset_id;
  }
  elseif (isset($_SESSION['changeset_id'])) {
    $changeset_id = $_SESSION['changeset_id'];
  }
  else {
    $changeset_id = CPS_PUBLISHED_CHANGESET;
  }

  // Use a $test flag because there are phases where we do not want to invoke
  // a load.
  if ($test && $changeset_id != CPS_PUBLISHED_CHANGESET) {
    $changeset = cps_changeset_load($changeset_id);

    if (!$changeset) {
      // If no changeset was loaded, default to published.
      $changeset_id = CPS_PUBLISHED_CHANGESET;
    }
  }

  if ($changeset_id != CPS_PUBLISHED_CHANGESET) {
    // Record that we have touched this changeset.
    $_SESSION['touched changesets'][$changeset_id] = REQUEST_TIME;
  }

  return $changeset_id;
}

/**
 * Set the current changeset.
 *
 * @param string $changeset_id
 *   The changeset id.
 */
function cps_set_current_changeset($changeset_id) {
  if (isset($changeset_id)) {
    $_SESSION['changeset_id'] = $changeset_id;
  }
  elseif (isset($_SESSION['changeset_id'])) {
    unset($_SESSION['changeset_id']);
  }
}

/**
 * Set a global override for the current changeset.
 *
 * @param $changeset_id
 */
function cps_override_changeset($changeset_id) {
  global $cps_override_changeset;
  $cps_override_changeset = $changeset_id;

  // We have to reset the entity static cache because changing this could poison
  // the cache.
  foreach (entity_get_info() as $entity_type => $entity_info) {
    if (cps_is_supported($entity_type)) {
      entity_get_controller($entity_type)->resetCache();
    }
  }
}

/**
 * Check whether CPS is supported for an entit type.
 *
 * @param string $entity_type
 */
function cps_is_supported($entity_type) {
  $info = entity_get_info($entity_type);
  return !empty($info['cps']);
}

/**
 * Get supported entity types.
 */
function cps_get_supported() {
  $types = array();
  $info = entity_get_info();
  foreach ($info as $entity_type => $entity_info) {
    if (!empty($entity_info['cps'])) {
      $types[] =  $entity_type;
    }
  }
  return $types;
}

/**
 * @{inheritdoc}
 */
function cps_make_revision_published($entity_type, $entity_id, $changeset_id) {
  cps_override_changeset(CPS_PUBLISHED_CHANGESET);
  // Find the revision id.
  $revision_id = db_query('SELECT revision_id FROM {cps_entity} WHERE entity_type = :entity_type AND entity_id = :entity_id AND changeset_id = :changeset',
  array(
    ':entity_type' => $entity_type,
    ':entity_id' => $entity_id,
    ':changeset' => $changeset_id,
  ))->fetchField();

  drafty()->publishRevision($entity_type, $entity_id, $revision_id);
  cps_override_changeset(NULL);
}

/**
 * Return TRUE if the entity is in the changeset.
 *
 * @param $entity
 *   The entity to check.
 * @param $changeset_id
 *   A changeset ID.
 *
 * @return bool
 */
function cps_is_entity_in_changeset($entity_type, $entity, $changeset_id) {
  list($id) = entity_extract_ids($entity_type, $entity);
  $tracked = cps_get_tracked_entities($changeset_id);
  return isset($tracked[$entity_type][$id]);
}

/**
 * Returns TRUE if the entity is tracked by CPS in any changeset.
 *
 * @param string $entity_type
 *   The type of entity, e.g. 'node'.
 * @param object $entity
 *   The entity object.
 *
 * @return bool
 */
function cps_is_entity_tracked($entity_type, $entity) {
  list($entity_id) = entity_extract_ids($entity_type, $entity);

  // If this is a new entity, it can't have been tracked by CPS yet.
  if (!isset($entity_id)) {
    return FALSE;
  }

  // Although changeset information is attached to the entity in
  // hook_entity_load(), it is not attached under all conditions, nor for all
  // changesets, and it will not necessarily be up to date if the entity is in
  // the process of being saved. So this function always does a fresh check
  // instead.
  return (bool) db_query_range('SELECT 1 FROM {cps_entity} WHERE entity_type = :entity_type AND entity_id = :entity_id', 0, 1, array(':entity_type' => $entity_type, ':entity_id' => $entity_id))->fetchField();
}

/**
 * Returns TRUE if the entity is allowed to be tracked by CPS.
 *
 * @param string $entity_type
 *   The type of entity, e.g. 'node'.
 * @param object $entity
 *   The entity object.
 *
 * @return bool
 */
function cps_can_entity_be_tracked($entity_type, $entity) {
  // The entity can be tracked if the entity type is supported by CPS, and if
  // it already is tracked or if no module indicates that it should not be
  // tracked.
  return cps_is_supported($entity_type) && (cps_is_entity_tracked($entity_type, $entity) || !in_array(FALSE, module_invoke_all('cps_can_entity_be_tracked', $entity_type, $entity), TRUE));
}

/**
 * Get tracked entities in a changeset.
 *
 * @param $changeset_id
 *   A changeset ID.
 *
 * @return
 *   A nested array. First keyed by entity type, then by entity ID, with
 *   revision IDs as values.
 *   type.
 */
function cps_get_tracked_entities($changeset_id) {
  $cache = &drupal_static(__FUNCTION__, array());
  if (!isset($cache[$changeset_id])) {
    $cache[$changeset_id] = array();
    $result = db_query('SELECT entity_type, entity_id, revision_id  FROM {cps_entity} WHERE changeset_id = :changeset_id AND published = 0', array(':changeset_id' => $changeset_id));
    foreach ($result as $record) {
      $cache[$changeset_id][$record->entity_type][$record->entity_id] = $record->revision_id;
    }
  }
  return $cache[$changeset_id];
}

/**
 * Publish a changeset.
 *
 * @param $changeset_id
 *   A changeset ID.
 */
function cps_publish_changeset_entities($changeset_id) {
  // Get all tracked entities in the changeset.
  $changed = cps_get_tracked_entities($changeset_id);
  $transaction = db_transaction();
  try {
    foreach ($changed as $entity_type => $ids) {
      foreach ($ids as $entity_id => $revision_id) {
        cps_make_revision_published($entity_type, $entity_id, $changeset_id);
      }
    }
  }
  catch (Exception $e) {
    $transaction->rollback();
    trigger_error(t('Unable to publish entities in changeset'), E_USER_ERROR);
    watchdog_exception('CPS', $e);
  }
}

/**
 * Unpublish a changeset.
 *
 * @param $changeset_id
 *   A changeset ID.
 */
function cps_unpublish_changeset_entities($changeset_id, $previous_changeset_id) {
  $changed = cps_get_tracked_entities($changeset_id);
  $transaction = db_transaction();
  try {
    foreach ($changed as $entity_type => $ids) {
      foreach ($ids as $entity_id => $revision_id) {
        // If the entity existed in the previous changeset ID, use that version.
        $vid = db_query('SELECT revision_id FROM {cps_entity} WHERE entity_type = :entity_type AND entity_id = :entity_id AND changeset_id = :changeset_id', array(
          'entity_type' => $entity_type,
          'entity_id' => $entity_id,
          'changeset_id' => $previous_changeset_id,
        ))->fetchField();
        if ($vid) {
          cps_make_revision_published($entity_type, $entity_id, $previous_changeset_id);
        }
        // Otherwise assume the entity was new in the changeset, and publish the
        // 'initial' version.
        else {
          cps_make_revision_published($entity_type, $entity_id, 'initial');
        }
      }
    }
  }
  catch (Exception $e) {
    $transaction->rollback();
    trigger_error(t('Unable to unpublish entities in changeset'), E_USER_ERROR);
    watchdog_exception('CPS', $e);
  }
}

/**
 * Remove non-tracked items from a changeset.
 *
 * @param $changeset_id
 *   A changeset ID.
 */
function cps_remove_untracked_entities($changeset_id) {
  db_delete('cps_entity')
    ->condition('changeset_id', $changeset_id)
    ->condition('published', 1)
    ->execute();
}

/**
 * Record the published version ID for untracked entities.
 *
 * @param $changeset_id
 *   The changeset ID.
 * @param $entity_type
 *   Then entity type.
 * @param $start
 *   The entity ID to start the query from, defaults to 0.
 * @param $limit
 *   The number of entities to process.
 */
function cps_add_untracked_entities($changeset_id, $entity_type, $start = 0, $limit = 100) {

  // Ensure the EntityFieldQuery here does not get altered.
  cps_override_changeset(CPS_PUBLISHED_CHANGESET);
  $tracked = cps_get_tracked_entities($changeset_id);
  $info = entity_get_info($entity_type);

  $entity_query = new EntityFieldQuery();
  if (!empty($tracked[$entity_type])) {
    $entity_query->entityCondition('entity_id', array_keys($tracked[$entity_type]), 'NOT IN');
  }
  $results = $entity_query
    ->entityCondition('entity_type', $entity_type)
    ->entityOrderBy('entity_id', 'ASC')
    ->range($start, $limit)
    ->execute();

  // Reset the changeset
  cps_override_changeset(NULL);
  if (!empty($results[$entity_type])) {
    $query = db_insert('cps_entity')
      ->fields(array(
        'entity_type',
        'entity_id',
        'revision_id',
        'changeset_id',
        'published',
      ));
    foreach ($results[$entity_type] as $entity) {
      $query->values(array(
        'entity_type' => $entity_type,
        'entity_id' => $entity->{$info['entity keys']['id']},
        'revision_id' => $entity->{$info['entity keys']['revision']},
        'changeset_id' => $changeset_id,
        'published' => 1,
      ));
    }
    $query->execute();
    // Return the count of entities that were updated.
    return min($limit, count($results[$entity_type]));
  }
}

/**
 * Determine if entity editing is allowable.
 *
 * We disallow the editing or creation of entities and anything else managed by
 * changesets when viewing the published changeset (i.e, the live site) or when
 * viewing a previously published changeset (i.e, an archive view).
 *
 * @param $op
 *   The operation to check. Any $op which isn't view' is considered an edit,
 *   so non-privileged non-view operations should be filtered by the caller.
 * @param string $entity_type
 *   The type of entity to test.
 * @param $entity
 *   The entity to check.
 * @param $changeset_id
 *   The changeset to check against. If not specified the currently active changeset
 *   will be used.
 *
 * @return bool
 */
function cps_can_edit_entities($op, $entity_type, $entity, $changeset_id = NULL) {
  // Deletions can occur outside of a changeset if the content was never published.
  if ($op == 'delete') {
    return cps_can_delete_entity($entity_type, $entity);
  }

  if (!isset($changeset_id)) {
    $changeset_id = cps_get_current_changeset(TRUE);
  }

  if ($op == 'view') {
    if ($changeset_id != CPS_PUBLISHED_CHANGESET) {
      return TRUE;
    }

    if (entity_status_supported($entity_type)) {
      return entity_status_get($entity_type, $entity);
    }
    else {
      return TRUE;
    }
  }

  // The live changeset can never be edited for any reason, and we just bounce
  // it out early, without even letting other modules get involved.
  if ($changeset_id == CPS_PUBLISHED_CHANGESET) {
    return FALSE;
  }

  $changeset = cps_changeset_load($changeset_id);

  // Only unpublished changesets allow editing.
  $access = $changeset->status == 'unpublished';

  // Unless the user has edit all changesets, they can only make changes in
  // their own.
  if (!user_access('edit all changesets') && $GLOBALS['user']->uid != $changeset->uid) {
    $access = FALSE;
  }

  // If $op == 'move to' they cannot make this change if the entity already has
  // a revision in the changeset.
  if ($op == 'move to') {
    if ($entity && cps_is_entity_in_changeset($entity_type, $entity, $changeset_id)) {
      $access = FALSE;
    }
  }

  // Allow other modules to change this if needed.
  $context = array(
    'op' => $op,
    'entity_type' => $entity_type,
    'entity' => $entity,
    'changeset' => $changeset,
  );
  drupal_alter('cps_can_edit_entities', $access, $context);
  return $access;
}

/**
 * Determine if an entity can be deleted.
 *
 * Once an entity has appeared in a published changeset, the entity should
 * not be deletable so that the site history is preserved. Instead, entities
 * should be unpublished which will make them disappear from standard view.
 *
 * This method ONLY checks for CPS reasons, and the entity is expected
 * to do its own access control.
 *
 * @param string $entity_type
 *   The type of entity to test.
 * @param $entity
 *   The entity to check.
 * @return bool
 *   TRUE if the entity can be deleted, FALSE if not.
 */
function cps_can_delete_entity($entity_type, $entity) {
  list($entity_id) = entity_extract_ids($entity_type, $entity);

  // Fetch a list of revisions directly joining to the cps table to find
  // revisions that point to published changesets.
  $entity_info = entity_get_info($entity_type);
  $revision_table = $entity_info['revision table'];
  $id_field = $entity_info['entity keys']['id'];
  $revision_field = $entity_info['entity keys']['revision'];

  $result = db_query("SELECT DISTINCT base.$revision_field FROM " . "{" . $revision_table . "} base LEFT JOIN {cps_entity} c ON base.$id_field = c.entity_id AND base.$revision_field = c.revision_id AND c.entity_type = '$entity_type' LEFT JOIN {cps_changeset} cs ON cs.changeset_id = c.changeset_id WHERE base.$id_field = :entity_id AND cs.published <> 0", array(':entity_id' => $entity_id))->fetchCol();

  if (!$result) {
    return TRUE;
  }

  if (!entity_status_supported($entity_type)) {
    return FALSE;
  }

  // If we do have a result, go through each revision and see if any are published. If any are,
  // deny.
  foreach ($result as $revision_id) {
    $revision = entity_revision_load($entity_type, $revision_id);
    if ($revision && entity_status_get($entity_type, $revision)) {
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Gets the available changesets for the widget.
 *
 * @return string[]
 *   The list of available changesets, keyed by ID.
 */
function cps_get_changesets() {
  global $user;
  try {
    $query = new EntityFieldQuery();
    $results = $query->entityCondition('entity_type', 'cps_changeset')
      ->propertyCondition('status', CPS_ARCHIVED_STATUS, '<>')
      // Note that uid and locked check are in a db_or() in a query alter
      // because EFQ does not support OR.
      ->propertyOrderBy('name')
      // This tag allows another module to modify this list if necessary.
      ->addTag('cps_active_changeset_list')
      ->execute();
  }
  catch (Exception $e) {
    return array();
  }

  $changesets = array();
  if (!empty($results['cps_changeset'])) {
    $entities = cps_changeset_load_multiple(array_keys($results['cps_changeset']));
    foreach ($entities as $id => $entity) {
      $changesets[$id] = $entity->name;
      if ($entity->lock_in_select) {
        $locked[$id] = $entity->name;
      }
      // Assume if it's not locked it gets listed under 'mine'.
      else {
        $mine[$id] = $entity->name;
      }
    }
  }

  $published = array(
    0 => t('Live'),
  );

  $recent = array();
  $my_published = array();
  // Go through any changesets they have viewed within the last 24 hours
  // and create a list of them.
  if (!empty($_SESSION['touched changesets'])) {
    $recent_ids = array();
    foreach ($_SESSION['touched changesets'] as $id => $timestamp) {
      if ($timestamp + variable_get('cps_recent_changeset_max_age', 86400) < REQUEST_TIME) {
        unset($_SESSION['touched changesets'][$id]);
      }
      elseif (empty($changesets[$id])) {
        $recent_ids[] = $id;
      }
    }

    if ($recent_ids) {
      $entities = cps_changeset_load_multiple($recent_ids);
      $uids = array();
      foreach ($entities as $entity) {
        $uids[] = $entity->uid;
      }

      $accounts = user_load_multiple($uids);
      foreach ($entities as $id => $entity) {
        if ($entity->uid == $user->uid) {
          $my_published[$id] = $entity->name;
        }
        else {
          $recent[format_username($accounts[$entity->uid])][$id] = $entity->name;
        }
      }
    }
  }

  // Live changeset is always on top.
  $retval = $published;

  // Now my open changesets.
  if (!empty($locked)) {
    $retval += array(t('Locked open site versions') => $locked);
  }

  if (!empty($mine)) {
    $retval += array(t('My open site versions') => $mine);
  }

  // My published if I've looked at them recently.
  if ($my_published) {
    $retval += array(t('My published') => $my_published);
  }

  // And other people's changesets if I've been looking at them.
  if ($recent) {
    asort($recent);
    $retval += $recent;
  }

  return $retval;
}

/**
 * Implements hook_query_TAG_alter().
 */
function cps_query_cps_active_changeset_list_alter($query) {
  // Because EFQ doesn't support OR, this hack adds a db_or() to the underlying
  // query.
  $query->condition(db_or()
    ->condition('uid', $GLOBALS['user']->uid)
    ->condition('lock_in_select', TRUE)
  );
}

/**
 * Fetch a list of possible state types for changesets.
 *
 * @return string[]
 *   An array of state types named keyed by the internal name.
 */
function cps_changeset_get_state_types() {
  $types = &drupal_static(__FUNCTION__);
  if (!isset($types)) {
    $types = array(
      'open' => t('Open'),
      'closed' => t('Closed'),
    );

    drupal_alter('cps_changeset_state_types', $types);
  }


  return $types;
}

/**
 * Fetch a list of possible states for changesets.
 *
 * @return array[]
 *   An array of state named keyed by the internal name.
 */
function cps_changeset_get_states() {
  $states = &drupal_static(__FUNCTION__);
  if (!isset($states)) {
    $states = array(
      'unpublished' => array(
        'label' => t('Unpublished'),
        'weight' => 0,
        'type' => 'open',
      ),
      CPS_ARCHIVED_STATUS => array(
        'label' => t('Archived'),
        'weight' => 9,
        'type' => 'closed',
      ),
    );
    drupal_alter('cps_changeset_states', $states);

    uasort($states, 'drupal_sort_weight');
  }

  return $states;
}

/**
 * Fetch the labels for all changeset states.
 *
 * @return string[]
 */
function cps_changeset_get_state_labels() {
  $labels = &drupal_static(__FUNCTION__);
  if (!$labels) {
    $states = cps_changeset_get_states();

    $labels = array();
    foreach ($states as $state => $info) {
      $labels[$state] = $info['label'];
    }
  }

  return $labels;
}

/**
 * Provide a warning message if the entity has unpublished changes in another changeset.
 *
 * @param object $entity
 *   The entity to test.
 *
 * @return string|null
 *   A warning string or null.
 */
function cps_changeset_edit_warning($entity_type, $entity) {
  if (cps_entity_in_unpublished_changeset($entity_type, $entity, TRUE)) {
    // If anything else pops, put up a warning.
    return t('Warning, this content has unpublished changes in another site version! Whichever site version is published LAST will overwrite the other. Please see the History tab for details to help coordinate your changes.');
  }
}

/**
 * Determine whether an entity is in any published changeset.
 */
function cps_entity_in_published_changeset($entity_type, $entity) {
  list($id) = entity_extract_ids($entity_type, $entity);
  // Treat a changeset as published if the status is 'live' or 'archived'.
  $result = db_query('SELECT 1 FROM {cps_entity} ce INNER JOIN {cps_changeset} cc ON ce.changeset_id = cc.changeset_id AND cc.status IN (:published) WHERE ce.entity_type = :type AND ce.entity_id = :id', array(':published' => array(CPS_ARCHIVED_STATUS, 'published'), ':type' => $entity_type, ':id' => $id))->fetchField();

  return $result;
}

/**
 * Determine whether an entity is in any unpublished changeset.
 *
 * @param $entity_type
 *   The entity type.
 * @param $entity
 *   The entity object.
 * @param $exclude_current_changeset
 *   Whether the query should exclude the current active changeset, useful if
 *   checking whether an entity is in more than one pending changeset. Defaults
 *   to FALSE.
 *
 *   @return
 *     Boolean if the entity is in an unpublished changeset.
 */
function cps_entity_in_unpublished_changeset($entity_type, $entity, $exclude_current_changeset = FALSE) {
  // Treat a changeset as published if the status is 'live' or 'archived'.
  list($id) = entity_extract_ids($entity_type, $entity);
  $changeset = cps_get_current_changeset(TRUE);
  // Exclude the current changeset if requested, unless it's the published
  // changeset which is never in the database anyway.
  $query = db_select('cps_entity', 'ce');
  $query->join('cps_changeset', 'cc', 'ce.changeset_id = cc.changeset_id');
  $query->condition('cc.status', array(CPS_ARCHIVED_STATUS, 'published'), 'NOT IN')
    ->condition('ce.entity_type', $entity_type)
    ->condition('ce.entity_id', $id)
    ->range(0, 1)
    ->addExpression(1);

  if ($exclude_current_changeset && $changeset != CPS_PUBLISHED_CHANGESET) {
    $query->condition('ce.changeset_id', $changeset, '<>');
  }
  return $query->execute()->fetchField();
}


/**
 * Lock the CPS publishing system.
 *
 * @return bool
 *   TRUE if the lock can be acquired. FALSE if not.
 *
 * @see cps_publish_lock_time()
 */
function cps_publish_lock() {
  $time = cps_publish_lock_time();
  if ($time) {
    return FALSE;
  }
  // Set the lock to expire in 30 minutes.
  // This seems like a long time, but some publishing runs can be quite long, and we want
  // to make sure they finish and that a timeout truly represents an aborted publishing job,
  // for example because the user navigated away from the batch job before it completed.
  // Because this is intended to be used in batch processes (for which the lock needs to be
  // held for more than one page request, until the batch job is complete) it cannot use the
  // core lock API. Therefore it uses a variable instead.
  variable_set('cps_publishing_lock', REQUEST_TIME + variable_get('cps_publishing_lock_expire', 60 * 30));
  return TRUE;
}

/**
 * Unlock the CPS publishing system.
 */
function cps_publish_unlock() {
  variable_del('cps_publishing_lock');
}

/**
 * Test the CPS publishing lock.
 *
 * @return int
 *   The number of seconds remaining if publishing is locked, FALSE if it is not.
 */
function cps_publish_lock_time() {
  $lock = variable_get('cps_publishing_lock', 0);
  if ($lock > REQUEST_TIME) {
    return $lock - REQUEST_TIME;
  }

  return FALSE;
}

/**
 * Move or copy an entity from one changeset to another.
 *
 * It is the caller's responsibility to validate that this is okay.
 *
 * @param CPSChangeset $changeset_from
 *   The source changeset.
 * @param CPSChangeset $changeset_to
 *   The destination changeset.
 * @param string $entity_type
 *   The type of entity being moved.
 * @param object $entity
 *   The entity being moved.
 * @param string $move_type
 *   Either 'move' or 'copy'. 'copy' is the default if not known.
 */
function cps_move_changeset($changeset_from, $changeset_to, $entity_type, $entity, $move_type) {
  module_invoke_all('cps_move_changeset', $changeset_from, $changeset_to, $entity_type, $entity, $move_type);
  list($entity_id, $revision_id) = entity_extract_ids($entity_type, $entity);

  $transaction = db_transaction();
  try {
    // When moving just update the record for the old changeset to point to
    // the new one.
    if ($move_type == 'move') {
      db_update('cps_entity')
        ->condition('entity_type', $entity_type)
        ->condition('entity_id', $entity_id)
        ->condition('changeset_id', $changeset_from->changeset_id)
        ->fields(array('changeset_id' => $changeset_to->changeset_id))
        ->execute();
    }
    else {
      cps_override_changeset($changeset_to->changeset_id);
      // Otherwise save the entity in the new changeset - this will create a
      // new revision tracked in the new changeset, leaving the old revision
      // and cps_entity record intact.
      entity_save($entity_type, $entity);
      cps_override_changeset(NULL);
    }
  }
  catch (Exception $e) {
    drupal_set_message(nt('Unable to complete operation due to an internal error. Exception recorded to watchdog log.'));
    $transaction->rollback();
    watchdog_exception('cps', $e);
    return;
  }
}

// -------------------------------------------------------------------------
// Database and general entity API functions

/**
 * Changeset entity loader.
 *
 * @param string $changeset_id
 *   The changeset id.
 *
 * @return CPSChangeset
 *   The changeset, if found.
 *
 * @see entity_load()
 */
function cps_changeset_load($changeset_id) {
  $entities = cps_changeset_load_multiple(array($changeset_id));
  if ($entities) {
    return reset($entities);
  }
}

/**
 * Load multiple changesets.
 *
 * @param string[] $ids
 *   An array of IDs to load.
 * @param array $conditions
 *   (optional) An array of conditions.
 * @param bool $reset
 *   (optional) TRUE to force a load from database.
 *
 * @see entity_load_multiple()
 */
function cps_changeset_load_multiple($ids, $conditions = array(), $reset = FALSE) {
  return entity_load('cps_changeset', $ids, $conditions, $reset);
}

/**
 * Save a changeset entity.
 *
 * @param CPSChangeset $entity
 *   The entity to save.
 *
 * @see node_save()
 */
function cps_changeset_save(CPSChangeset $entity) {
  return entity_get_controller('cps_changeset')->save($entity);
}

/**
 * Delete a changeset entity.
 *
 * @param $changeset_id
 *   A changeset ID.
 */
function cps_changeset_delete($changeset_id) {
  cps_changeset_delete_multiple(array($changeset_id));
}

/**
 * Delete a revision for a changeset entity.
 *
 * @param $vid
 *   The revision id to delete.
 */
function cps_changeset_delete_revision($vid) {
  return entity_get_controller('cps_changeset')->deleteRevision($vid);
}

/**
 * Delete multiple changesets.
 *
 * @param string[] $changeset_ids
 *   An array of changeset IDs.
 */
function cps_changeset_delete_multiple(array $changeset_ids) {
  return entity_get_controller('cps_changeset')->delete($changeset_ids);
}

/**
 * View a changeset entity.
 *
 * @param CPSChangeset[] $entities
 *   The changeset entity.
 * @param string $view_mode
 *   The view mode to view.
 * @param string $langcode
 *   The language to use or NULL.
 *
 * @return array
 *   A Drupal renderable array.
 *
 * @see node_view()
 */
function cps_changeset_view($entities, $view_mode = 'full', $langcode = NULL) {
  // Allow a single view to work seamlessly.
  if (!is_array($entities)) {
    $entities = array($entities);
  }
  return entity_get_controller('cps_changeset')->view($entities, $view_mode, $langcode);
}

/**
 * Callback to create a new entity.
 *
 * @param array $values
 *   The initial values to seed the new entity with.
 *
 * @return CPSChangeset
 */
function cps_changeset_create($values = array()) {
  return entity_get_controller('cps_changeset')->create($values);
}

/**
 * Determine if the operation for the entity can be accessed.
 *
 * @param string $op
 *   The operation being performed. One of 'view', 'update', 'create' or
 *   'delete'. It may also be any changeset operation such as 'publish' or
 *   'unpublish'.
 * @param string|CPSChangeset $entity
 *   (optional) an entity to check access for. If no entity is given, it will be
 *   determined whether access is allowed for all entities of the given type.
 * @param stdClass|null $account
 *   The user to check for. Leave it to NULL to check for the global user.
 *
 * @return boolean
 *   Whether access is allowed or not. If the entity type does not specify any
 *   access information, NULL is returned.
 *
 * @see entity_access()
 */
function cps_changeset_access($op, $entity = NULL, $account = NULL) {
  return entity_get_controller('cps_changeset')->access($op, $entity, $account);
}

/**
 * Callback for getting content properties.
 *
 * @param CPSChangeset $changeset
 *   The changeset entity to get proprties for.
 * @param array $options
 *   The options provided by the caller.
 * @param $name
 *   The name of the property.
 *
 * @return mixed
 *   The result of the property.
 */
function cps_changeset_metadata_get_properties(CPSChangeset $changeset, array $options, $name) {
  switch ($name) {
    case 'is_new':
      return empty($changeset->changeset_id) || !empty($changeset->is_new);

    case 'edit_url':
      return url('admin/structure/changesets/' . $changeset->changeset_id . '/edit', $options);

    case 'delete_url':
      return url('admin/structure/changesets/' . $changeset->changeset_id . '/delete', $options);

    case 'author':
      return !empty($changeset->uid) ? $changeset->uid : drupal_anonymous_user();

    case 'operations':
      $build = cps_changeset_get_operations($changeset);
      return drupal_render($build);
  }
}

/**
 * Fetch a renderable array of changeset operations available for the changeset.
 *
 * @param CPSChangeset $changeset
 *   The changeset to get operations for.
 *
 * @return array
 *   A drupal Renderable array.
 */
function cps_changeset_get_operations(CPSChangeset $changeset) {
  $uri = $changeset->uri();
  $operations = array(
    '#type' => 'container',
    '#attributes' => array('class' => 'cps-changeset-operations'),
    'site' => array(
      '#theme' => 'link',
      '#text' => t('view site'),
      '#path' => '<front>',
      '#options' => array(
        'query' => array('changeset_id' => $changeset->changeset_id),
        'html' => TRUE,
        'attributes' => array('class' => array('cps-changeset-operation'))
      ),
      '#access' => user_access('preview changesets') || user_access('view changesets') || user_access('administer changesets'),
    ),
    'view' => array(
      '#theme' => 'link',
      '#text' => t('status'),
      '#path' => $uri['path'],
      '#options' => array(
        'html' => TRUE,
        'attributes' => array('class' => array('cps-changeset-operation'))
      ),
      '#access' => entity_access('view', 'cps_changeset', $changeset) && request_path() != $uri['path'],
    ),
    'edit' => array(
      '#theme' => 'link',
      '#text' => t('edit'),
      '#path' => $uri['path'] . '/edit',
      '#options' => array(
        'query' => drupal_get_destination(),
        'html' => TRUE,
        'attributes' => array('class' => array('cps-changeset-operation'))
      ),
      '#access' => entity_access('update', 'cps_changeset', $changeset),
    ),
    'delete' => array(
      '#theme' => 'link',
      '#text' => t('delete'),
      '#path' => $uri['path'] . '/delete',
      '#options' => array(
        'query' => drupal_get_destination(),
        'html' => TRUE,
        'attributes' => array('class' => array('cps-changeset-operation'))
      ),
      '#access' => entity_access('delete', 'cps_changeset', $changeset),
    ),
    'publish' => array(
      '#theme' => 'link',
      '#text' => t('publish'),
      '#path' => $uri['path'] . '/publish',
      '#options' => array(
        'query' => drupal_get_destination(),
        'html' => TRUE,
        'attributes' => array('class' => array('cps-changeset-operation'))
      ),
      '#access' => entity_access('publish', 'cps_changeset', $changeset),
    ),
    'unpublish' => array(
      '#theme' => 'link',
      '#text' => t('unpublish'),
      '#path' => $uri['path'] . '/unpublish',
      '#options' => array(
        'query' => drupal_get_destination(),
        'html' => TRUE,
        'attributes' => array('class' => array('cps-changeset-operation'))
      ),
      '#access' => entity_access('unpublish', 'cps_changeset', $changeset),
    ),
  );

  drupal_alter('cps_changeset_operations', $operations, $changeset);
  return $operations;
}

/**
 * Convenience function to test whether the current changeset is active.
 *
 * @return bool
 */
function cps_is_current_changeset_active() {
  return cps_get_current_changeset(TRUE) != CPS_PUBLISHED_CHANGESET;
}

// -----------------------------------------------------------------------
// Menu callbacks that must be in .module

/**
 * _to_arg callback to provide a default when one is not provided.
 *
 * This is present to make tabs work correctly, and has no real value other
 * than ensuring that warnings aren't given.
 */
function cps_changeset_optional_to_arg() {
  return cps_get_current_changeset();
}

/**
 * Menu _load callback for when cps_changeset is optional.
 *
 * @param string $changeset_id
 *   A changeset ID taken from the URL.
 *
 * @return CPSChangeset
 *   A changest object or NULL.
 */
function cps_changeset_optional_load($changeset_id) {
  if ($changeset_id) {
    return cps_changeset_load($changeset_id);
  }
}

/**
 * Determine if the 'switch to this site version' action should be visible.
 *
 * @param CPSChangeset $changeset
 *
 * @return bool
 */
function cps_changeset_view_site_access($changeset) {
  $current_changeset_id = cps_get_current_changeset();
  return $changeset && $current_changeset_id != $changeset->changeset_id && cps_changeset_access('view', $changeset);
}
