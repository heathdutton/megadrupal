<?php

/**
 * @file
 * Implements NetCommerce e-Bill (http://www.netcommerce.com.lb/ebill.asp)
 * in Drupal Commerce checkout.
 */

define('NETCOMMERCE_EBILL_REQUEST_ADD', 'add_sch');
define('NETCOMMERCE_EBILL_REQUEST_DEACTIVATE', 'dac_sch');
define('NETCOMMERCE_EBILL_REQUEST_REACTIVATE', 'rac_sch');
define('NETCOMMERCE_EBILL_REQUEST_DELETE', 'del_sch');
define('NETCOMMERCE_EBILL_SCHEDULE_STATUS_ACTIVE', 1);
define('NETCOMMERCE_EBILL_SCHEDULE_STATUS_INACTIVE', 0);
define('NETCOMMERCE_EBILL_SCHEDULE_HAS_END', 1);
define('NETCOMMERCE_EBILL_SCHEDULE_ENDLESS', 0);
define('NETCOMMERCE_EBILL_INSTANTPAYMENT_YES', 1);
define('NETCOMMERCE_EBILL_INSTANTPAYMENT_NO', 0);

/**
 * Implements hook_menu().
 */
function commerce_netcommerce_ebill_menu() {
  $items = array();

  $items['netcommerce-ebill-response/%'] = array(
    'page callback' => 'commerce_netcommerce_ebill_response_process',
    'page arguments' => array(1),
    'access callback' => 'commerce_netcommerce_ebill_response_validate',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK,
  );

  $items['netcommerce-ebill-cancel/%'] = array(
    'title' => 'Redirecting to NetCommerce e-Bill',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('netcommerce_ebill_schedule_cancel_redirect', 1),
    'access callback' => 'netcommerce_ebill_access',
    'access arguments' => array('cancel', 1),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function commerce_netcommerce_ebill_permission() {
  return array(
    'view own ebill schedules' => array(
      'title' => t('View own schedules'),
      'description' => t('View own e-Bill recurring payment schedules.'),
    ),
    'view any ebill schedules' => array(
      'title' => t('View any schedules'),
      'description' => t('View any e-Bill recurring payment schedules.'),
    ),
    'cancel own ebill schedules' => array(
      'title' => t('Cancel own schedules'),
      'description' => t('Cancel own e-Bill recurring payment schedules.'),
    ),
    'cancel any ebill schedules' => array(
      'title' => t('Cancel any schedules'),
      'description' => t('Cancel any e-Bill recurring payment schedules.'),
    ),
  );
}

/**
 * Implements hook_form_BASE_FORM_ID_form_alter()
 */
function commerce_netcommerce_ebill_form_commerce_cart_add_to_cart_form_alter(&$form, &$form_state, $form_id) {
  array_unshift($form['#validate'], 'commerce_netcommerce_ebill_check_cart_before_add');
}

/**
 * Validation callback to make sure that e-Bill products always get checked out individually.
 *
 * @param $form
 * @param $form_state
 */
function commerce_netcommerce_ebill_check_cart_before_add(&$form, &$form_state) {
  global $user;
  $order = commerce_cart_order_load($user->uid);

  if (!empty($order)) {
    $wrapper = entity_metadata_wrapper('commerce_order', $order);

    $quantity = 0;
    if (!empty($wrapper->commerce_line_items)) {
      $quantity = commerce_line_items_quantity($wrapper->commerce_line_items, commerce_product_line_item_types());
    }
    if ($quantity >= 1) {

      // First check if this product being added is recurring.
      // If so, it can't be added to cart.
      $product_being_added = commerce_product_load($form_state['values']['product_id']);
      if (!empty($product_being_added) && commerce_recurring_product_is_recurring($product_being_added)) {
        form_set_error('product_id', t('Recurring payments must be processed individually. Please !checkout or !clear_your_cart to proceed.',
          array('!checkout' => l('checkout with your order', 'checkout/' . $order->order_id), '!clear_your_cart' => l('clear your cart', 'cart'))));
        return;
      }

      // Now check if there is already a recurring item in the cart.
      // If so, nothing else can be added to the cart.
      $cart_has_recurring = FALSE;
      foreach ($wrapper->commerce_line_items as $line_item_wrapper) {
        if (commerce_recurring_product_is_recurring($line_item_wrapper->commerce_product->value())) {
          $cart_has_recurring = TRUE;
          break;
        }
      }
      if ($cart_has_recurring) {
        form_set_error('product_id', t('Recurring payments must be processed separately from one-time payments. Please !checkout or !clear_your_cart to proceed.',
          array('!checkout' => l('checkout with your order', 'checkout/' . $order->order_id), '!clear_your_cart' => l('clear your cart', 'cart'))));
      }
    }
  }
}

/**
 * Implements hook_commerce_payment_method_info().
 */
function commerce_netcommerce_ebill_commerce_payment_method_info() {
  $payment_methods = array();

  $icons = commerce_netcommerce_ebill_icons();
  $display_title = t('NetCommerce e-Bill');
  $display_title .= '<div class="commerce-netcommerce-logo">' .
    theme('image', array(
      'path' => drupal_get_path('module', 'commerce_netcommerce_ebill') . '/images/NCseal_S.gif',
      'title' => 'NetCommerce e-Bill',
      'alt' => 'NetCommerce e-Bill',
      'attributes' => array(
        'class' => array('commerce-netcommerce-ebill-logo'),
      ),
    )) .
    '</div>';
  $display_title .= '<div class="commerce-netcommerce-ebill-icons">' . implode(' ', $icons) . '</div>';

  $payment_methods['netcommerce_ebill'] = array(
    'base' => 'commerce_netcommerce_ebill',
    'title' => t('NetCommerce e-Bill'),
    'short_title' => t('NetCommerce e-Bill'),
    'display_title' => $display_title,
    'description' => t('NetCommerce e-Bill'),
    'terminal' => FALSE,
    'offsite' => TRUE,
    'offsite_autoredirect' => TRUE,
  );

  return $payment_methods;
}

/**
 * Returns the default settings for the NetCommerce e-Bill payment method.
 */
function commerce_netcommerce_ebill_default_settings() {
  return array(
    'merchant_number' => '',
    'sha_key' => '',
    'watchdog' => FALSE,
    'show_payment_instructions' => FALSE,
    'payment_instructions_text' => 'Continue with checkout to complete payment via NetCommerce e-Bill.',
    'payment_url' => 'https://www.netcommercepay.com/eBillSys/Default.asp',
  );
}

/**
 * Payment method callback: settings form.
 */
function commerce_netcommerce_ebill_settings_form($settings = array()) {
  $form = array();

  // Merge default settings into the stored settings array.
  $settings = (array) $settings + commerce_netcommerce_ebill_default_settings();

  $form['merchant_number'] = array(
    '#type' => 'textfield',
    '#title' => t('Merchant Number'),
    '#default_value' => $settings['merchant_number'],
  );
  $form['sha_key'] = array(
    '#type' => 'textfield',
    '#title' => t('MD5 Key'),
    '#default_value' => $settings['sha_key'],
  );
  $form['show_payment_instructions'] = array(
    '#type' => 'checkbox',
    '#title' => t('Show a message on the checkout form when NetCommerce e-Bill is selected.'),
    '#default_value' => $settings['show_payment_instructions'],
  );
  $form['payment_instructions_text'] = array(
    '#type' => 'textarea',
    '#title' => t('Message to display.'),
    '#default_value' => $settings['payment_instructions_text'],
  );
  $form['watchdog'] = array(
    '#type' => 'checkbox',
    '#title' => t('Log full transaction information from the NetCommerce e-Bill response to the system log.'),
    '#default_value' => $settings['watchdog'],
  );
  $form['payment_url'] = array(
    '#type' => 'textfield',
    '#title' => t('Payment URL'),
    '#default_value' => $settings['payment_url'],
  );

  return $form;
}

/**
 * Payment method callback: adds a message and CSS to the submission form if
 * enabled in the payment method settings.
 */
function commerce_netcommerce_ebill_submit_form($payment_method, $pane_values, $checkout_pane, $order) {
  $form = array();
  $address = array();
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  if (!empty($order_wrapper->commerce_customer_billing)) {

    $address = $order_wrapper->commerce_customer_billing->commerce_customer_address->value();

    if (!empty($address['name_line']) && empty($address['first_name']) && empty($address['last_name']) && strstr($address['name_line'], ' ')) {
      // Attempt to break up first name and last name.
      list($address['first_name'], $address['last_name']) = explode(' ', $address['name_line'], 2);
    }
    else {
      $address['first_name'] = $address['name_line'];
    }
  }


  $form['netcommerce_ebill'] = array(
    '#type' => 'fieldset',
    '#title' => t('Recurring Payment Information'),
    '#description' => t('Please verify the following information.'),
  );
  $form['netcommerce_ebill']['fname'] = array(
    '#type' => 'textfield',
    '#title' => t('First Name'),
    '#default_value' => !empty($address['first_name']) ? $address['first_name'] : '',
    '#required' => TRUE,
  );
  $form['netcommerce_ebill']['lname'] = array(
    '#type' => 'textfield',
    '#title' => t('Last Name'),
    '#default_value' => !empty($address['last_name']) ? $address['last_name'] : '',
    '#required' => TRUE,
  );
  $form['netcommerce_ebill']['phone'] = array(
    '#type' => 'textfield',
    '#title' => t('Phone Number'),
    '#required' => TRUE,
  );
  $form['netcommerce_ebill']['mobile'] = array(
    '#type' => 'textfield',
    '#title' => t('Mobile Number'),
    '#required' => TRUE,
  );
  $form['netcommerce_ebill']['email'] = array(
    '#type' => 'textfield',
    '#title' => t('Email'),
    '#default_value' => $order_wrapper->mail->value(),
    '#required' => TRUE,
  );
  $form['netcommerce_ebill']['address'] = array(
    '#type' => 'textfield',
    '#title' => t('Address'),
    '#default_value' => !empty($address['thoroughfare']) ? $address['thoroughfare'] : '',
    '#required' => TRUE,
  );
  $form['netcommerce_ebill']['city'] = array(
    '#type' => 'textfield',
    '#title' => t('City'),
    '#default_value' => !empty($address['locality']) ? $address['locality'] : '',
    '#required' => TRUE,
  );
  $form['netcommerce_ebill']['country'] = array(
    '#type' => 'textfield',
    '#title' => t('Country'),
    '#default_value' => !empty($address['country']) ? $address['country'] : '',
    '#required' => TRUE,
  );
  if (!empty($payment_method['settings']['show_payment_instructions'])) {
    $instructions = t('Continue with checkout to complete payment via NetCommerce.');
    if (!empty($payment_method['settings']['payment_instructions_text'])) {
      $instructions = $payment_method['settings']['payment_instructions_text'];
    }
    $form['netcommerce_ebill']['information'] = array(
      '#markup' => '<span class="commerce-netcommerce-info">' . $instructions . '</span>',
    );
  }

  return $form;
}

/**
 * Payment method callback: checkout form submission.
 */
function commerce_netcommerce_ebill_submit_form_submit(&$payment_method, $pane_form, $pane_values, $order, $charge) {

  // Prepare a transaction object to represent the transaction attempt.
  $transaction = commerce_payment_transaction_new('netcommerce_ebill', $order->order_id);

  $transaction->instance_id = $payment_method['instance_id'];
  $transaction->amount = $charge['amount'];
  $transaction->currency_code = $charge['currency_code'];

  $transaction->payload['pending'] = $pane_values['netcommerce_ebill'];
  $transaction->status = COMMERCE_PAYMENT_STATUS_PENDING;

  // Save the transaction information.
  commerce_payment_transaction_save($transaction);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function commerce_netcommerce_ebill_form_commerce_checkout_form_alter(&$form, &$form_state) {
  // If this checkout form contains the payment method radios...
  if (!empty($form['commerce_payment']['payment_method']['#options'])) {
    // Loop over its options array looking for a NetCommerce e-Bill option.
    foreach (array_keys($form['commerce_payment']['payment_method']['#options']) as $key) {
      list($method_id, $rule_name) = explode('|', $key);
      // If we find NetCommerce, include its CSS on the form and exit the loop.
      if ($method_id == 'netcommerce_ebill') {
        $form['commerce_payment']['payment_method']['#attached']['css'][] = drupal_get_path('module', 'commerce_netcommerce_ebill') . '/theme/commerce_netcommerce_ebill.theme.css';
        break;
      }
    }
  }
}

/**
 * Payment method callback: redirect form, a wrapper around the module's general
 *   use function for building a NetCommerce form.
 */
function commerce_netcommerce_ebill_redirect_form($form, &$form_state, $order, $payment_method) {
  // Return an error if the enabling action's settings haven't been configured.
  if (empty($payment_method['settings']['merchant_number']) || empty($payment_method['settings']['sha_key'])) {
    drupal_set_message(t('NetCommerce e-Bill is not configured for use.'), 'error');
    return array();
  }

  // e-Bill only supports a single item in the cart.
  $wrapper = entity_metadata_wrapper('commerce_order', $order);
  $line_items = $wrapper->commerce_line_items->value();
  if (count($line_items) != 1) {
    drupal_set_message(t('NetCommerce e-Bill only supports a single item at a time for checkout.'), 'error');
    return array();
  }

  // e-Bill only supports a recurring items.
  if (!commerce_recurring_product_is_recurring($wrapper->commerce_line_items[0]->commerce_product->value())) {
    drupal_set_message(t('e-Bill only supports recurring payment items for checkout.'), 'error');
    return array();
  }

  return commerce_netcommerce_ebill_order_form($form, $form_state, $order, $payment_method['settings']);
}

/**
 * Builds a NetCommerce form from an order object.
 *
 * @param $order
 *   The fully loaded order being paid for.
 * @param $settings
 *
 * @return
 *   A renderable form array.
 */
function commerce_netcommerce_ebill_order_form($form, &$form_state, $order, $settings) {
  $wrapper = entity_metadata_wrapper('commerce_order', $order);

  $currency_code = $wrapper->commerce_order_total->currency_code->value();

  // Ensure a default value for the payment_method setting.
  $settings += array('payment_method' => '');

  $transactions = commerce_payment_transaction_load_multiple(array(), array('order_id' => $order->order_id, 'payment_method' => 'netcommerce_ebill', 'status' => COMMERCE_PAYMENT_STATUS_PENDING));

  $transaction = NULL;
  if (!empty($transactions)) {
    $transaction = array_pop($transactions);
  }

  $payment = array(
    'initial_price' => 0,
    'initial_period' => array('interval' => 1, 'period' => 'month'),
    'initial_desc' => '',
    'recurring_price' => 0,
    'recurring_period' => 'monthly',
    'start_date' => '+1 day',  // e-Bill requires schedules to start on a future date.
    'end_date' => '',
    'schedule_id' => $order->order_id,
  );

  foreach ($wrapper->commerce_line_items as $line_item_wrapper) {
    // Currently, this is only designed to handle a single line item.

    // Schedule ID is the Order ID, since there should be only one recurring item per order.
    $payment['schedule_id'] = $order->order_id;

    // Calculate recurring period.
    if (!empty($line_item_wrapper->commerce_product->commerce_recurring_rec_period)) {
      $payment['recurring_period'] = _commerce_netcommerce_format_recurring_period($line_item_wrapper->commerce_product->commerce_recurring_rec_period->value());
    }

    // Calculate recurring price.
    if (!empty($line_item_wrapper->commerce_product->commerce_recurring_rec_price)) {
      $recurring_price = $line_item_wrapper->commerce_product->commerce_recurring_rec_price->value();
      $payment['recurring_price'] = commerce_currency_amount_to_decimal($recurring_price['amount'], $recurring_price['currency_code']);
    }

    // Calculate start date.
    if (!empty($line_item_wrapper->commerce_product->commerce_recurring_ini_period)) {
      $initial_period = $line_item_wrapper->commerce_product->commerce_recurring_ini_period->value();
      if (!empty($initial_period)) {
        $payment['start_date'] = '+' . $initial_period['interval'] . ' ' . $initial_period['period'];
      }
    }

    // Calculate end date and installments, if any.
    if (!empty($line_item_wrapper->commerce_product->commerce_recurring_end_period)) {
      $end_period = $line_item_wrapper->commerce_product->commerce_recurring_end_period->value();
      if (!empty($end_period)) {
        $payment['end_date'] = '+' . ($end_period['interval'] - 1) . ' ' . $end_period['period'];
        $payment['installments'] = _commerce_netcommerce_calculate_installments(strtotime($payment['start_date']), strtotime($payment['end_date'], strtotime($payment['start_date'])), $payment['recurring_period']);
      }
    }

    // Calculate instant payment price, if any.
    if (!empty($line_item_wrapper->commerce_product->commerce_recurring_ini_price)) {
      $initial_price = $line_item_wrapper->commerce_product->commerce_recurring_ini_price->value();
      $payment['initial_price'] = commerce_currency_amount_to_decimal($initial_price['amount'], $initial_price['currency_code']);
    }

    // Support for the Commerce Donate module. Override recurring and initial
    // prices with the user-selected price.
    if (module_exists('commerce_donate') && $line_item_wrapper->type->value() == 'commerce_donate') {
      $donation_price = $line_item_wrapper->commerce_total->value();
      $payment['recurring_price'] = commerce_currency_amount_to_decimal($donation_price['amount'], $donation_price['currency_code']);
      if (!empty($line_item_wrapper->commerce_product->commerce_recurring_ini_period)) {
        // Only set an initial price if there was an initial period set on the product.
        $initial_period = $line_item_wrapper->commerce_product->commerce_recurring_ini_period->value();
        if (!empty($initial_period)) {
          $payment['initial_price'] = $payment['recurring_price'];
        }
      }
    }

    // Calculate the instant payment description, if any.
    if (!empty($payment['initial_price'])) {
      if (!empty($line_item_wrapper->commerce_product->commerce_netcommerce_ebill_desc)) {
        $initial_payment_desc = $line_item_wrapper->commerce_product->commerce_netcommerce_ebill_desc->value();
        if (!empty($initial_payment_desc)) {
          $payment['initial_desc'] = $initial_payment_desc;
        }
      }
      if (empty($payment['initial_desc'])) {
        if (!empty($payment['recurring_period'])) {
          $payment['initial_desc'] = t('Initial @period payment', array('@period' => $payment['recurring_period']));
        }
        else {
          $payment['initial_desc'] = t('Initial payment');
        }
      }
    }
  }

  $data = array(
    // Essential transaction data.
    'txtFirstName' => $transaction->payload['pending']['fname'],
    'txtLastName' => $transaction->payload['pending']['lname'],
    'txtEmail' => $transaction->payload['pending']['email'],
    'txtPhone' => $transaction->payload['pending']['phone'],
    'txtMobile' => $transaction->payload['pending']['mobile'],
    'txtCountry' => $transaction->payload['pending']['country'],
    'txtCity' => $transaction->payload['pending']['city'],
    'txtAddress' => $transaction->payload['pending']['address'],
    'txtScheduleID' => $payment['schedule_id'],
    'Flag_ScheduleStatus' => NETCOMMERCE_EBILL_SCHEDULE_STATUS_ACTIVE,
    'txtStartPaymentDate' => format_date(strtotime($payment['start_date']), 'custom', 'dmY'),
    'Flag_IsPaymentEnds' => !empty($payment['end_date']) ? NETCOMMERCE_EBILL_SCHEDULE_HAS_END : NETCOMMERCE_EBILL_SCHEDULE_ENDLESS,
    'txtMerchReq' => NETCOMMERCE_EBILL_REQUEST_ADD,
    'Flag_IsInstantPayment' => !empty($payment['initial_price']) ? NETCOMMERCE_EBILL_INSTANTPAYMENT_YES : NETCOMMERCE_EBILL_INSTANTPAYMENT_NO,
    'txtRecurrentAmount' => $payment['recurring_price'],
    'txtRecurrentFreq' => $payment['recurring_period'],
    'txtNumInstallments' => !empty($payment['installments']) ? $payment['installments'] : NULL,
    'txtEndPaymentDate' => !empty($payment['end_date']) ? format_date(strtotime($payment['end_date'], strtotime($payment['start_date'])), 'custom', 'dmY') : NULL,
    'txtInstantAmount' => !empty($payment['initial_price']) ? $payment['initial_price'] : NULL,
    'txtInstantDescr' => !empty($payment['initial_desc']) ? $payment['initial_desc'] : NULL,
    'txtCurrency' => commerce_netcommerce_ebill_get_currency_id_by_code($currency_code),
    'txtMerchNum' => $settings['merchant_number'],
    'txthttp' => url('netcommerce-ebill-response/' . $wrapper->order_id->value(), array('absolute' => TRUE)),
  );

  // Calculate the signature.
  $data['signature'] = hash('md5',
    $data['txtMerchNum'] . $data['txtMerchReq'] . $data['txtScheduleID'] . $data['txthttp'] . $data['Flag_ScheduleStatus'] .
    $data['txtFirstName'] . $data['txtLastName'] . $data['txtEmail'] . $data['txtPhone'] . $data['txtMobile'] . $data['txtCountry'] .
    $data['txtCity'] . $data['txtAddress'] . $data['txtRecurrentAmount'] . $data['txtRecurrentFreq'] . $data['txtCurrency'] .
    $data['Flag_IsPaymentEnds'] . $data['txtNumInstallments'] . $data['txtStartPaymentDate'] . $data['txtEndPaymentDate'] .
    $data['Flag_IsInstantPayment'] . $data['txtInstantAmount'] . $data['txtInstantDescr'] . $settings['sha_key']
  );

  // Allow modules to alter parameters of the API request.
  drupal_alter('commerce_netcommerce_ebill_order_form_data', $data, $order);

  $form['#action'] = $settings['payment_url'];

  foreach ($data as $name => $value) {
    if (!is_null($value)) {
      $form[$name] = array('#type' => 'hidden', '#value' => $value);
    }
  }

  $form['netcommerce_seal'] = array(
    '#type' => 'markup',
    '#markup' => '<div class="commerce-netcommerce-logo">' .
    theme('image', array(
      'path' => drupal_get_path('module', 'commerce_netcommerce_ebill') . '/images/NCseal_S.gif',
      'title' => 'NetCommerce e-Bill',
      'alt' => 'NetCommerce e-Bill',
      'attributes' => array(
        'class' => array('commerce-netcommerce-ebill-logo'),
      ),
    )) .
    '</div>',
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Proceed to NetCommerce'),
  );

  return $form;
}

/**
 * Redirect form for a cancelling an e-Bill schedule. Will autoredirect
 * if javascript is active.
 *
 * @param $form
 * @param $form_state
 * @param $schedule_id
 * @return mixed
 */
function netcommerce_ebill_schedule_cancel_redirect($form, $form_state, $schedule_id) {

  $settings = commerce_netcommerce_ebill_get_settings();

  $form['#attached']['js'][] = drupal_get_path('module', 'commerce_netcommerce_ebill') . '/commerce_netcommerce_ebill.js';
  $form['txtMerchNum'] = array(
    '#type' => 'hidden',
    '#value' => $settings['merchant_number'],
  );
  $form['txtMerchReq'] = array(
    '#type' => 'hidden',
    '#value' => NETCOMMERCE_EBILL_REQUEST_DEACTIVATE,
  );
  $callback_url = url('netcommerce-ebill-response/' . $schedule_id, array('absolute' => TRUE));
  $form['txthttp'] = array(
    '#type' => 'hidden',
    '#value' => $callback_url,
  );
  $form['txtScheduleID'] = array(
    '#type' => 'hidden',
    '#value' => $schedule_id,
  );
  $form['signature'] = array(
    '#type' => 'hidden',
    '#value' => hash('md5', $settings['merchant_number'] . NETCOMMERCE_EBILL_REQUEST_DEACTIVATE .
      $schedule_id . $callback_url . $settings['sha_key']),
  );
  $form['description'] = array(
    '#markup' => t('Please wait to confirm your cancellation with NetCommerce e-Bill...'),
  );
  $form['actions'] = array('#type' => 'actions');
  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Proceed to NetCommerce e-Bill')
  );
  $form['#action'] = $settings['payment_url'];
  return $form;
}

/**
 * Validates an IPN-style callback from NetCommerce e-Bill.
 *
 * @return bool
 */
function commerce_netcommerce_ebill_response_validate($schedule_id) {

  $settings = commerce_netcommerce_ebill_get_settings();
  $expected_signature = commerce_netcommerce_ebill_generate_response_signature($_REQUEST['txtMerchReq'], $_REQUEST, $settings);

  if (!empty($settings['watchdog'])) {
    // Log full transaction data.
    watchdog('commerce_netcommerce_ebill', 'NetCommerce e-Bill Response @response', array('@response' => print_r($_REQUEST)));
  }

  // Match the global values.
  if ($schedule_id == $_REQUEST['txtScheduleID'] && $settings['merchant_number'] == $_REQUEST['txtMerchNum'] && $expected_signature == $_REQUEST['signature']) {
    // Then check that the we actually have a corresponding item in this system.
    if ($_REQUEST['txtMerchReq'] == NETCOMMERCE_EBILL_REQUEST_ADD) {
      // The Commerce Recurring entity doesn't exist yet, but schedule ID should match the order ID.
      $order = commerce_order_load($schedule_id);
      if (!empty($order)) {
        return TRUE;
      }
    }
    else  {
      $recurring_entities = commerce_netcommerce_ebill_get_recurring_from_schedule_id($schedule_id);
      if (!empty($recurring_entities)) {
        return TRUE;
      }
    }
  }

  return FALSE;
}

/**
 * Process a response call from NetCommerce.
 * @param $schedule_id
 */
function commerce_netcommerce_ebill_response_process($schedule_id) {

  switch ($_REQUEST['txtMerchReq']) {
    case NETCOMMERCE_EBILL_REQUEST_ADD:
      commerce_netcommerce_ebill_response_add_process($schedule_id);
      break;

    case NETCOMMERCE_EBILL_REQUEST_DEACTIVATE:
      commerce_netcommerce_ebill_response_cancel_process($schedule_id);
      break;
  }
}

/**
 * Process an add response call from e-Bill
 * @param $schedule_id
 */
function commerce_netcommerce_ebill_response_add_process($schedule_id) {

  // At this point, there is not a Commerce Recurring entity, but the schedule ID should be the order ID.
  $order = commerce_order_load($schedule_id);

  switch ($_REQUEST['RespCode']) {
    case '00':
      $transaction = NULL;
      // Check for a pending transaction
      $transactions = commerce_payment_transaction_load_multiple(array(), array('order_id' => $order->order_id, 'payment_method' => 'netcommerce_ebill', 'status' => COMMERCE_PAYMENT_STATUS_PENDING));
      if (!empty($transactions)) {
        $transaction = array_pop($transactions);
      }
      else {
        // Create a new payment transaction for the order.
        $transaction = commerce_payment_transaction_new('netcommerce_ebill', $order->order_id);
        $transaction->amount = commerce_currency_decimal_to_amount($_REQUEST['txtInstantAmount'], commerce_netcommerce_ebill_get_currency_code_by_id($_REQUEST['txtCurrency']));
        $transaction->currency_code = commerce_netcommerce_ebill_get_currency_code_by_id($_REQUEST['txtCurrency']);
      }
      $transaction->instance_id = commerce_netcommerce_ebill_get_method_instance_id();
      $transaction->remote_id = $_REQUEST['txtScheduleID'];
      $transaction->payload[REQUEST_TIME] = $_REQUEST;

      // Set the transaction's statuses based on the IPN's payment_status.
      $transaction->remote_status = 'Completed';
      $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
      $transaction->message = t('The payment has completed.');

      // Save the transaction information.
      commerce_payment_transaction_save($transaction);
      commerce_payment_redirect_pane_next_page($order);
      drupal_goto('checkout/' . $order->order_id . '/payment');
      break;

    default:
      drupal_set_message(t('Error processing payment: @reason.', array('@reason' => commerce_netcommerce_ebill_response_code_message($_REQUEST['RespCode']))), 'error');
      // Create a new payment transaction for the order.
      $transaction = commerce_payment_transaction_new('netcommerce_ebill', $order->order_id);
      $transaction->instance_id = commerce_netcommerce_ebill_get_method_instance_id();
      $transaction->remote_id = $_REQUEST['txtScheduleID'];
      $transaction->amount = commerce_currency_decimal_to_amount($_REQUEST['txtInstantAmount'], commerce_netcommerce_ebill_get_currency_code_by_id($_REQUEST['txtCurrency']));
      $transaction->currency_code = commerce_netcommerce_ebill_get_currency_code_by_id($_REQUEST['txtCurrency']);
      $transaction->payload[REQUEST_TIME] = $_REQUEST;

      // Set the transaction's statuses based on the IPN's payment_status.
      $transaction->remote_status = 'Failed';
      $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
      $transaction->message = t("The payment has failed with result: Code: @code, Message: @message",
        array('@code' => $_REQUEST['RespCode'], '@message' => commerce_netcommerce_ebill_response_code_message($_REQUEST['RespCode'])));

      // Save the transaction information.
      commerce_payment_transaction_save($transaction);
      commerce_payment_redirect_pane_previous_page($order);
      drupal_goto('checkout/' . $order->order_id . '/review');
      break;
  }
}

/**
 * Process a cancellation response call from e-Bill.
 */
function commerce_netcommerce_ebill_response_cancel_process($schedule_id) {

  switch ($_REQUEST['RespCode']) {
    case '00':
      $recurring_entities = commerce_netcommerce_ebill_get_recurring_from_schedule_id($schedule_id);
      foreach ($recurring_entities as $recurring) {
        $recurring->status = 0;
        entity_save('commerce_recurring', $recurring);
      }
      drupal_set_message(t('Recurring payment schedule @schedule_id deactivated.', array('@schedule_id' => $_REQUEST['txtScheduleID'])));

      drupal_goto('user/' . $GLOBALS['user']->uid . '/ebill-recurring');
      break;

    default:
      drupal_set_message(t('Error processing cancellation: @reason.', array('@reason' => commerce_netcommerce_ebill_response_code_message($_REQUEST['RespCode']))), 'error');

      drupal_goto('user/' . $GLOBALS['user']->uid . '/ebill-recurring');
      break;
  }
}

/**
 * Access control for e-Bill schedules.
 */
function netcommerce_ebill_access($op, $schedule_id) {
  $recurring_entities = commerce_netcommerce_ebill_get_recurring_from_schedule_id($schedule_id);
  if (!empty($recurring_entities)) {
    $recurring = array_pop($recurring_entities); // There should be only one.
    return user_access($op . ' any ebill schedules') ||
    (user_access($op . ' own ebill schedules') && $recurring->uid == $GLOBALS['user']->uid);
  }
  return FALSE;
}

/**
 * Returns the settings for this payment processor.
 *
 * @return array
 *   Settings for this payment processor
 */
function commerce_netcommerce_ebill_get_settings() {
  $settings = NULL;
  $instance = commerce_payment_method_instance_load(commerce_netcommerce_ebill_get_method_instance_id());
  if (!empty($instance['settings'])) {
    $settings = $instance['settings'];
  }
  return $settings;
}

/**
 * Returns the method instance ID of the payment processor.
 *
 * @return null|string
 *   Method Instance ID of the payment processor
 */
function commerce_netcommerce_ebill_get_method_instance_id() {

  $event = rules_get_cache('event_commerce_payment_methods');

  // Only build the options array if payment method Rules are enabled.
  if (!empty($event)) {
    foreach (commerce_payment_methods() as $method_id => $payment_method) {
      // Look for a Rule enabling this payment method.
      foreach ($event->getIterator() as $rule) {
        foreach ($rule->actions() as $action) {
          // If an action is found, get the settings for it.
          if ($method_id == 'netcommerce_ebill' && $action->getElementName() == 'commerce_payment_enable_' . $method_id) {
            return commerce_payment_method_instance_id($method_id, $rule);
          }
        }
      }
    }
  }
  return NULL;
}

/**
 * Translates e-Bill response error codes into messages from the documentation.
 *
 * @param null $code
 *   numeric code as a string. If NULL, will return array of messages keyed to code.
 * @return array|null|string
 *   the error message for the code or an array of all messages.
 */
function commerce_netcommerce_ebill_response_code_message($code = NULL) {
  $messages = array(
    '00' => t('Transaction Completed Successfully'),
    '01' => t('Incorrect or missing data from merchant'),
    '02' => t('Invalid merchant request'),
    '03' => t('Incorrect or missing user or schedule data from merchant'),
    '04' => t('Schedule ID already exists'),
    '05' => t('Incorrect or missing data processing at NetCommerce'),
    '06' => t('Schedule starting or ending payment date must be in the future'),
    '07' => t('Missing Instant payment details'),
    '08' => t('Number of installments is missing or wrong'),
    '09' => t('Signature value error'),
    '10' => t('Credit Card Declined'),
    '11' => t('Schedule ID does not exist or Deleted'),
    '12' => t('Action is cancelled by user'),
    '13' => t('Incorrect Date Format'),
    '14' => t('Merchant number does not exist or is not active'),
  );
  if (is_null($code)) {
    return $messages;
  }
  if (empty($messages[$code])) {
    return t('Unknown error: @code', array('@code' => $code));
  }
  return $messages[$code];
}

/**
 * Implements hook_entity_presave().
 */
function commerce_netcommerce_ebill_entity_presave($entity, $type) {
  if ($type == 'commerce_recurring') {
    // Save the Order ID as the Schedule ID.
    $wrapper = entity_metadata_wrapper('commerce_recurring', $entity);
    $order = $wrapper->commerce_recurring_order[0]->value();
    if (strstr($order->data['payment_method'], 'netcommerce_ebill')) {
      $wrapper->commerce_netcommerce_ebill_id->set($order->order_id);

      // @todo This seems to be a bug in Commerce Recurring.
      // Price is set to the initial price even if there's a
      // recurring price on the product.
      if (!empty($_REQUEST['txtRecurrentAmount']) && $wrapper->commerce_recurring_fixed_price->amount->value() == 0) {
        $amount = commerce_currency_decimal_to_amount($_REQUEST['txtRecurrentAmount'], $wrapper->commerce_recurring_fixed_price->currency_code->value());
        $wrapper->commerce_recurring_fixed_price->amount->set($amount);
      }
    }
  }

  if ($type == 'commerce_order') {
    // @todo Also an issue in Commerce Recurring.
    // Owner of the recurring entity is anonymous if order was initially anonymous
    $query = new EntityFieldQuery();
    $recurring_results =  $query->entityCondition('entity_type', 'commerce_recurring')
      ->fieldCondition('commerce_recurring_order', 'target_id', $entity->order_id)
      ->execute();
    if (!empty($recurring_results['commerce_recurring'])) {
      $recurring = entity_load('commerce_recurring', array_keys($recurring_results['commerce_recurring']));
      foreach ($recurring as $r) {
        $r->uid = $entity->uid;
        entity_save('commerce_recurring', $r);
      }
    }
  }
}

/**
 * Implements hook_enable()
 * Installs custom fields on Commerce Product and Commerce Recurring entities.
 */
function commerce_netcommerce_ebill_enable() {

  // Create instant payment description field.
  $fields = array(
    'commerce_product' => array(
      'commerce_netcommerce_ebill_desc' => array(
        'field_name' => 'commerce_netcommerce_ebill_desc',
        'cardinality' => 1,
        'type'        => 'text',
      ),
    ),
    'commerce_recurring' => array(
      'commerce_netcommerce_ebill_id' => array(
        'field_name' => 'commerce_netcommerce_ebill_id',
        'cardinality' => 1,
        'type'        => 'text',
      ),
    ),
  );
  // Set instance settings for the field.
  $instances = array(
    'commerce_product' => array(
      'recurring' => array(
        'commerce_netcommerce_ebill_desc' => array(
          'label' => t('Initial Payment Description'),
          'entity_type' => 'commerce_product',
          'bundle' => 'recurring',
          'widget' => array(
            'type' => 'text_textfield',
          ),
          'display' => array(
            'default' => array(
              'label' => 'hidden',
              'type' => 'text_default',
            ),
          ),
          'settings' => array(),
          'weight' => 0,
        ),
      ),
    ),
    'commerce_recurring' => array(
      'product' => array(
        'commerce_netcommerce_ebill_id' => array(
          'label' => t('e-Bill Schedule ID'),
          'entity_type' => 'commerce_recurring',
          'bundle' => 'product',
          'widget' => array(
            'type' => 'text_textfield',
          ),
          'display' => array(
            'default' => array(
              'label' => 'above',
              'type' => 'text_default',
            ),
          ),
          'settings' => array(),
          'weight' => 0,
        ),
      ),
    ),
  );

  // Create fields if necessary.
  foreach ($fields as $entity_type => $entity_fields) {
    foreach($entity_fields as $field_name => $field) {
      $info_field = field_info_field($field_name);

      if (empty($info_field)) {
        field_create_field($field);
      }

      foreach ($instances[$entity_type] as $bundle => $bundle_instances) {
        $instance = field_info_instance($entity_type, $field_name, $bundle);
        if (empty($instance)) {
          $instance = $bundle_instances[$field_name];
          $instance['field_name'] = $field_name;
          field_create_instance($instance);
        }
      }
    }
  }

}

/**
 * Get Commerce Recurring entities, given an e-Bill schedule ID.
 *
 * @param $schedule_id
 *   e-Bill schedule ID
 * @return array
 *   array of all matching Commerce Recurring entities
 */
function commerce_netcommerce_ebill_get_recurring_from_schedule_id($schedule_id) {
  $recurring = array();
  $query = new EntityFieldQuery();
  $recurring_results =  $query->entityCondition('entity_type', 'commerce_recurring')
    ->fieldCondition('commerce_netcommerce_ebill_id', 'value', $schedule_id)
    ->execute();
  if (!empty($recurring_results['commerce_recurring'])) {
    $recurring = entity_load('commerce_recurring', array_keys($recurring_results['commerce_recurring']));
  }
  return $recurring;
}

/**
 * Generate an expected signature from an e-Bill response.
 *
 * @param $op
 *   Request type
 * @param $request
 *   The $_REQUEST array
 * @param array $settings
 *   The settings for this payment processor
 * @return string
 *   The expected signature.
 */
function commerce_netcommerce_ebill_generate_response_signature($op, $request, $settings = NULL) {
  if (is_null($settings)) {
    $settings = commerce_netcommerce_ebill_get_settings();
  }
  switch ($op) {
    case NETCOMMERCE_EBILL_REQUEST_ADD:
      return hash('md5',
        $request['txtMerchNum'] . $request['txtMerchReq'] . $request['txtScheduleID'] . $request['txthttp'] .
        $request['Flag_ScheduleStatus'] . $request['txtRecurrentAmount'] . $request['txtRecurrentFreq'] .
        $request['txtCurrency'] . $request['Flag_IsPaymentEnds'] . $request['txtNumInstallments'] . $request['txtStartPaymentDate'] .
        $request['txtEndPaymentDate'] . $request['Flag_IsInstantPayment'] . $request['txtInstantAmount'] .
        $request['txtInstantDescr'] . $request['RespCode'] . $settings['sha_key']
      );

    case NETCOMMERCE_EBILL_REQUEST_DEACTIVATE:
      return hash('md5',
        $request['txtMerchNum'] . $request['txtMerchReq'] . $request['txtScheduleID'] . $request['txthttp'] .
        $request['Flag_ScheduleStatus'] . $request['RespCode'] . $settings['sha_key']
      );
  }
  return '';
}

/**
 * Returns an array of NetCommerce e-Bill payment method icon img elements.
 *
 * @return
 *   The array of themed payment method icons keyed by name: visa, mastercard
 */
function commerce_netcommerce_ebill_icons() {
  $icons = array();

  $payment_methods = array(
    'visa' => t('Visa'),
    'mastercard' => t('Mastercard'),
  );

  foreach ($payment_methods as $name => $title) {
    $variables = array(
      'path' => drupal_get_path('module', 'commerce_netcommerce_ebill') . '/images/' . $name . '.gif',
      'title' => $title,
      'alt' => $title,
      'attributes' => array(
        'class' => array('commerce-netcommerce-icon'),
      ),
    );
    $icons[$name] = theme('image', $variables);
  }

  return $icons;
}

/**
 * Implements hook_views_api().
 */
function commerce_netcommerce_ebill_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'commerce_netcommerce_ebill') . '/includes/views',
  );
}


/**
 * Returns the NetCommerce currency ID from the Drupal Commerce currency code.
 *
 * @param $currency_code
 *   Drupal Commerce currency code.
 * @return int
 *   NetCommerce currency ID
 */
function commerce_netcommerce_ebill_get_currency_id_by_code($currency_code) {
  switch ($currency_code) {
    case 'USD':
      return 840;
    case 'LBP':
      return 422;
    default:
      return 0;
  }
}

/**
 * Returns the Drupal Commerce currency code from the NetCommerce currency ID.
 *
 * @param $currency_id
 *   NetCommerce currency ID
 * @return string
 *   Drupal Commerce currency code
 */
function commerce_netcommerce_ebill_get_currency_code_by_id($currency_id) {
  switch ($currency_id) {
    case 840:
      return 'USD';
    case 422:
      return 'LBP';
    default:
      return '';
  }
}

/**
 * Helper method to take an interval field value and turn it in
 * a string compatible with e-Bill
 *
 * @param $period
 *   an interval value array with "interval" and "period" keys
 * @return bool|string
 *   a period formatted for e-Bill (monthly, quarterly, yearly, bi-yearly)
 */
function _commerce_netcommerce_format_recurring_period($period) {
  // e-Bill only takes 4 values: monthly, quarterly, yearly, bi-yearly.
  // We need to ensure the interval matches one of these.
  if ($period['period'] == 'month') {
    switch ($period['interval']) {
      case 1:
        return 'monthly';

      case 3:
        return 'quarterly';

      case 12:
        return 'yearly';

      case 24:
        return 'bi-yearly';
    }
  }
  else if ($period['period'] == 'year') {
    switch ($period['interval']) {
      case 1:
        return 'yearly';

      case 2:
        return 'bi-yearly';
    }
  }
  else if ($period['period'] == 'quarter') {
    switch ($period['interval']) {
      case 1:
        return 'quarterly';

      case 4:
        return 'yearly';

      case 8:
        return 'bi-yearly';
    }
  }
  return FALSE;
}

/**
 * Helper method to calculate the number of installments given a start date, end date
 * and recurring period.
 *
 * @param $start_date
 *   start date as Unix timestamp
 * @param $end_date
 *   end date as Unix timestamp
 * @param $recurring_period
 *   'monthly', 'quarterly', 'yearly', 'bi-yearly'
 * @return int
 *   the number of installments
 */
function _commerce_netcommerce_calculate_installments($start_date, $end_date, $recurring_period) {
  $num_installments = 0;
  $recurring_duration = FALSE;

  switch ($recurring_period) {
    case 'monthly':
      $recurring_duration = date_interval_create_from_date_string('1 month');
      break;
    case 'quarterly':
      $recurring_duration = date_interval_create_from_date_string('3 months');
      break;
    case 'yearly':
      $recurring_duration = date_interval_create_from_date_string('1 year');
      break;
    case 'bi-yearly':
      $recurring_duration = date_interval_create_from_date_string('2 years');
      break;
  }

  if (!empty($recurring_duration)) {
    $current_date = $start_date;
    while ($current_date <= $end_date) {
      $num_installments++;
      $date = date_create_from_format('U', $current_date, new DateTimeZone('UTC'));
      $date->add($recurring_duration);
      $current_date = $date->getTimestamp();
    }
  }
  return $num_installments;
}
