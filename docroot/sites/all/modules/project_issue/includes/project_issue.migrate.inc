<?php
/**
 * @file
 * Project issue D6 -> D7 migration.
 */

define('ISSUE_MIGRATE_TYPE_COMMENT', 0);
define('ISSUE_MIGRATE_TYPE_REVISION', 1);

define('ISSUE_MIGRATE_TIMELINE_OP', 0);
// Unfortunately, followups have to appear first so we have a semi-sane parent
// for existing revisions. The revisions will always appear later than reality,
// but since we don't know what reality IS due to revision corruption, there
// is not much we can do about it.
define('ISSUE_MIGRATE_TIMELINE_FOLLOWUP', 1);
define('ISSUE_MIGRATE_TIMELINE_REVISION', 2);
define('ISSUE_MIGRATE_TIMELINE_CURCHECK', 3);

// Uid used in cases of ambiguity -- Ownership of existing revisions is in doubt.
define('ISSUE_MIGRATE_SYSTEM_MIGRATION_USER', 180064); // Currently 'System Message'.

// Must not appear in file description field!
define('ISSUE_MIGRATE_FILE_DESCRIPTION_DELIMITER', '|||');
// Drupal.org specific!
define('ISSUE_MIGRATE_TAGS_VID', 9);

/**
 * Transfer initial uploads from upload to field_issue_files.
 */
class ProjectIssueFixInitFilesMigration extends MigrationBase {
  /**
   * General initialization of a ProjectIssueTimelineMigration object.
   */
  public function __construct($arguments = array()) {
    parent::__construct($arguments);
    $this->description = t('WIP: USE AT YOUR OWN RISK! Move uploaded files to the correct field.');
  }

  protected function import() {
    db_query('INSERT INTO {field_data_field_issue_files} (SELECT * FROM {field_data_upload} WHERE entity_type = :type AND bundle = :bundle)', array(':type' => 'node', ':bundle' => 'project_issue'));
    db_query('INSERT INTO {field_revision_field_issue_files} (SELECT * FROM {field_revision_upload} WHERE entity_type = :type AND bundle = :bundle)', array(':type' => 'node', ':bundle' => 'project_issue'));
    db_query('DELETE FROM {field_data_upload} WHERE entity_type = :type AND bundle = :bundle', array(':type' => 'node', ':bundle' => 'project_issue'));
    db_query('DELETE FROM {field_revision_upload} WHERE entity_type = :type AND bundle = :bundle', array(':type' => 'node', ':bundle' => 'project_issue'));

    field_cache_clear();

    // Remove the upload field from project issues -- the field that we use for issues is field_issue_files.
    $instance = field_read_instance('node', 'upload', 'project_issue');
    if ($instance) {
      field_delete_instance($instance);
    }
  }

  public function isComplete() {
    $count = db_query('SELECT COUNT(*) FROM {field_data_upload} WHERE bundle = :bundle', array(':bundle' => 'project_issue'))->fetchField();
    return (bool) ($count == 0);
  }
}

/**
 * Fix general drupal.org data problems.
 */
class ProjectIssueFixGenericCorruptionMigration extends MigrationBase {
  /**
   * General initialization of a ProjectIssueTimelineMigration object.
   */
  public function __construct($arguments = array()) {
    parent::__construct($arguments);
    $this->description = t('Fix general drupal.org data problems.');
    $this->dependencies = array('ProjectIssueRethreadIssueFollowups');
  }

  protected function import() {
    // @@@ Ensure node.created is sane.

    // Wipe autogenerated comment subjects.
    db_query("UPDATE {comment} c, {project_issue_comments} i SET c.subject = '' WHERE c.subject = CONCAT('#', i.comment_number) AND c.cid = i.cid");
  }

  public function isComplete() {
//    $count = db_query('SELECT COUNT(*) FROM {field_data_upload} WHERE bundle = :bundle', array(':bundle' => 'project_issue'))->fetchField();
//    return (bool) ($count == 0);
  }
}

/**
 * Rethread project_issue comments to match comment_number.
 */
class ProjectIssueRethreadIssueFollowupsMigration extends MigrationBase {
  public function __construct($arguments = array()) {
    parent::__construct($arguments);
    $this->description = t('WIP: USE AT YOUR OWN RISK! Rethread existing issue comments to match comment_number.');
    //$this->dependencies = array('ProjectIssuePhaseTwo');
  }

  protected function import() {
    if (db_table_exists('project_issue_migration_original_thread')) {
      db_drop_table('project_issue_migration_original_thread');
    }
    db_create_table('project_issue_migration_original_thread', array(
      'fields' => array(
        'cid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
        ),
        'thread' => array(
          'type' => 'varchar',
          'length' => 255,
          'not null' => TRUE,
          'default' => '',
        ),
      ),
      'primary key' => array('cid'),
    ));
    // Store original threads so we can recover from mishaps.
    db_query("INSERT INTO {project_issue_migration_original_thread} (cid, thread) (SELECT cid, thread FROM {comment})");

    db_query("UPDATE {comment} c, {project_issue_comments} i SET c.thread = LOWER(CONCAT(CAST((LENGTH(CAST(CONV(i.comment_number, 10, 36) AS CHAR)) - 1) AS CHAR), CAST(CONV(i.comment_number, 10, 36) AS CHAR), '/')) WHERE c.cid = i.cid");
  }

  public function isComplete() {
    return db_table_exists('project_issue_migration_original_thread');
  }
}

/**
 * Special migration to assemble our full timeline.
 * Part 1: Make original_issue_data accessible by the system.
 * STATUS: DONE
 */
class ProjectIssueTimelinePhaseOneMigration extends MigrationBase {

  public function __construct($arguments = array()) {
    parent::__construct($arguments);
    $this->description = t('Project issue timeline generator phase 1');
    $this->dependencies = array('ProjectIssueFixInitFiles');
  }

  protected function import() {
    if (db_table_exists('project_issue_migration_original_issue_data')) {
      db_drop_table('project_issue_migration_original_issue_data');
    }
    db_create_table('project_issue_migration_original_issue_data', array(
      'fields' => array(
        'nid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => TRUE,
        ),
        'orig_vid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'Initial revision ID assigned when creating issue. (Assumed to be the lowest vid.)'
        ),
        'first_cid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'The cid of the first comment added to the issue node. This is needed for sanity checking.',
        ),
        'title' => array(
          'type' => 'varchar',
          'length' => 255,
          'not null' => FALSE, // Detect missing titles in serialized data...
          'default' => NULL,
        ),
        'pid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => FALSE,
          'default' => NULL,
        ),
        'component' => array(
          'type' => 'varchar',
          'length' => 255,
          'not null' => FALSE,
          'default' => NULL,
        ),
        'category' => array(
          'type' => 'varchar',
          'length' => 255,
          'not null' => FALSE,
          'default' => NULL,
        ),
        'priority' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => FALSE,
          'default' => NULL,
        ),
        'assigned' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => FALSE,
          'default' => NULL,
        ),
        'sid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => FALSE,
          'default' => NULL,
        ),
        'rid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => FALSE,
          'default' => NULL,
        ),
      ),
      'primary key' => array('nid'),
      'indexes' => array(
        'orig_vid_idx' => array('orig_vid'),
      ),
    ));

    set_time_limit(0);
    // Step 1: Expand OP data.
    $insertQuery = db_insert('project_issue_migration_original_issue_data')
      ->fields(array('nid', 'orig_vid', 'first_cid', 'title', 'pid', 'component', 'category', 'priority', 'assigned', 'sid', 'rid'));

    // Expand in batches.
    $insertCounter = 0;
    $query = db_select('project_issues', 'p');
    $query->innerJoin('node_revision', 'r', 'p.nid = r.nid');
    $query->leftJoin('comment', 'c', 'p.nid = c.nid');
    $query->addField('p', 'nid');
    $query->addField('p', 'original_issue_data');
    $query->addExpression('MIN(r.vid)', 'orig_vid');
    $query->addExpression('MIN(c.cid)', 'first_cid');
    $query->groupBy('p.nid');
    $result = $query->execute();
    foreach ($result as $row) {
      $data = unserialize($row->original_issue_data);
      $data->nid = $row->nid;
      $insertQuery->values(array(
        'nid' => $data->nid,
        'orig_vid' => $row->orig_vid,
        'first_cid' => $row->first_cid,
        'title' => $data->title,
        'pid' => $data->pid,
        'component' => $data->component,
        'category' => $data->category,
        'priority' => $data->priority,
        'assigned' => $data->assigned,
        'sid' => $data->sid,
        'rid' => $data->rid,
      ));
      $insertCounter++;
      if ($insertCounter > 10000) {
        set_time_limit(0);
        $insertCounter = 0;
        // Flush the mulitple insert periodically.
        $insertQuery->execute();
      }
    }
    if ($insertCounter) {
      $insertQuery->execute();
    }
  }

  protected function rollback() {
    if (db_table_exists('project_issue_migration_original_issue_data')) {
      db_drop_table('project_issue_migration_original_issue_data');
    }
  }

  public function isComplete() {
    return db_table_exists('project_issue_migration_original_issue_data');
  }
}

/**
 * Special migration to assemble our full timeline.
 * Phase 2: Main table / OP injection
 * STATUS: IN PROGRESS
 */
class ProjectIssueTimelinePhaseTwoMigration extends MigrationBase {

  public function __construct($arguments = array()) {
    parent::__construct($arguments);
    $this->description = t('WIP: USE AT YOUR OWN RISK! Project issue timeline generator phase 2');
    $this->dependencies = array('ProjectIssueTimelinePhaseOne');
  }

  protected function import() {
    // Set a flag for ProjectIssueRebuildNodeFieldsMigration to easily know when it is not complete.
    variable_set('ProjectIssueRebuildNodeFieldsMigration_incomplete', TRUE);

    if (db_table_exists('project_issue_migration_timeline')) {
      db_drop_table('project_issue_migration_timeline');
    }

    $timeline_schema = array(
      'fields' => array(
        'nid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => TRUE,
        ),
        'prev_nid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'The nid of the previous row, used to speed up the fill algorithm.'
        ),
        'delta' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => TRUE,
          'default' => 0,
          'description' => 'The delta of this row on a per-node basis, used for the attachment algorithm.'
        ),
        'genid' => array(
          'type' => 'varchar',
          'length' => 255,
          'not null' => TRUE,
        ),
        'prev_genid' => array(
          'type' => 'varchar',
          'length' => 255,
        ),
        'prev_changed_genid' => array(
          'type' => 'varchar',
          'length' => 255,
          'description' => 'Previous genid that is considered changed.'
        ),
        'timestamp' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => TRUE,
        ),
        /*
        'prev_timestamp' => array(
          'type' => 'int',
          'unsigned' => TRUE,
        ),
        */
        'sort_timestamp' => array(
          'type' => 'int',
          'unsigned' => TRUE,
        ),
        'has_changes' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'size' => 'tiny',
          'not null' => TRUE,
          'default' => 0,
        ),
        'comment_number' => array(
          'type' => 'int',
          'unsigned' => TRUE,
        ),
        'vid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
        ),
        'cid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
        ),
        'tl' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => TRUE,
          'size' => 'tiny', // 8-bit is fine.
          'default' => ISSUE_MIGRATE_TIMELINE_OP,
          'description' => 'Role in timeline',
        ),
        'last_cid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'Previous cid, used to parent comments generated from existing revisions',
        ),
        // Project fields
        'cur_pid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'CURRENT project id',
        ),
        'prev_pid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'PREVIOUS project id',
        ),
        'cur_component' => array(
          'type' => 'varchar',
          'length' => 255,
          'description' => 'CURRENT component name',
        ),
        'prev_component' => array(
          'type' => 'varchar',
          'length' => 255,
          'description' => 'PREVIOUS component name'
        ),
        'cur_category' => array(
          'type' => 'varchar',
          'length' => 255,
          'description' => 'CURRENT category name'
        ),
        'prev_category' => array(
          'type' => 'varchar',
          'length' => 255,
          'description' => 'PREVIOUS category name'
        ),
        'cur_priority' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'CURRENT priority',
        ),
        'prev_priority' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'PREVIOUS priority',
        ),
        'cur_assigned' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'CURRENT assigned',
        ),
        'prev_assigned' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'PREVIOUS assigned',
        ),
        'cur_sid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'CURRENT state',
        ),
        'prev_sid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'PREVIOUS state',
        ),
        'cur_rid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'CURRENT rid',
        ),
        'prev_rid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'PREVIOUS rid',
        ),
        'cur_title' => array(
          'type' => 'varchar',
          'length' => 255,
          'description' => 'CURRENT title',
        ),
        'prev_title' => array(
          'type' => 'varchar',
          'length' => 255,
          'description' => 'PREVIOUS title',
        ),
        'cur_body_value' => array(
          'type' => 'text',
          'size' => 'big',
          'description' => 'CURRENT body value',
        ),
        'prev_body_value' => array(
          'type' => 'text',
          'size' => 'big',
          'description' => 'PREVIOUS body value',
        ),
        'cur_body_format' => array(
          'type' => 'varchar',
          'length' => 255,
          'description' => 'CURRENT body format',
        ),
        'prev_body_format' => array(
          'type' => 'varchar',
          'length' => 255,
          'description' => 'PREVIOUS body format',
        ),

        'cur_attachments' => array(
          'type' => 'text',
          'size' => 'medium',
          'description' => 'CURRENT attachments (fid,display,description. triple pipe delimited.)',
        ),
        'prev_attachments' => array(
          'type' => 'text',
          'size' => 'medium',
          'description' => 'PREVIOUS attachments (fid,display,description. triple pipe delimited.)',
        ),
        'cur_tags' => array(
          'type' => 'text',
          'description' => 'CURRENT vid 9 tids (comma separated)',
        ),
        'prev_tags' => array(
          'type' => 'text',
          'description' => 'PREVIOUS vid 9 tids (comma separated)',
        ),
        'comment_body_value' => array(
          'type' => 'text',
          'size' => 'big',
          'description' => 'Body value of comment.',
        ),
        'comment_body_format' => array(
          'type' => 'varchar',
          'length' => 255,
          'description' => 'Format of comment body.',
        ),
        'log' => array(
          'type' => 'text',
          'size' => 'big',
          'description' => 'Log entry for this row.',
        ),
        'uid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => TRUE,
          'default' => 0,
        ),
      ),
      'primary key' => array('genid'),
      'indexes' => array(
        'prev_genid_idx' => array('prev_genid'),
        'timestamp_idx' => array('nid', 'timestamp'),
        // Use TL in sorts to ensure that followups and revisions don't happen
        // in the wrong order due to the revision timestamp corruption.
        'sort_idx' => array('nid', 'sort_timestamp', 'tl'),
        'vid_idx' => array('vid'),
        'cid_idx' => array('cid'),
        'delta_idx' => array('delta'),
        'nid_delta_idx' => array('nid', 'delta'),
      ),
    );
    // We're creating two copies of the table to avoid a cursor glitch we
    // are encountering with the drupal.org data.
    db_create_table('project_issue_migration_timeline_init', $timeline_schema);
    db_create_table('project_issue_migration_timeline', $timeline_schema);

    set_time_limit(0);
    // Serious MySQLism.
    db_query('SET SESSION group_concat_max_len = 1048576');

    // Copy OP
    $query = db_select('project_issue_migration_original_issue_data', 'd');
    $query->innerJoin('node', 'n', 'd.nid = n.nid');
    $query->innerJoin('node_revision', 'r', 'r.vid = d.orig_vid');
    $query->innerJoin('field_revision_body', 'fb', 'r.vid = fb.revision_id AND fb.entity_type = :type', array(':type' => 'node'));
    $query->leftJoin('field_revision_field_issue_files', 'ff', 'r.vid = ff.revision_id AND ff.entity_type = :type', array(':type' => 'node'));
    $query->leftJoin('comment', 'c', 'd.first_cid = c.cid');
    // cid 0 is for the initial revision.
    // Since editing tags from the node edit form is inhibited, we can base our
    // tag conversion on {comment_alter_taxonomy} instead of worrying about
    // reconciling changes between it and the former {term_node} data.
    $query->leftJoin('comment_alter_taxonomy', 't', 'n.nid = t.nid AND t.cid = 0');

    $query->addField('d', 'nid');
    $query->addExpression('CONCAT(:vid, r.vid)', 'genid', array(':vid' => 'vid-'));
    $query->addField('r', 'vid');
    $query->addExpression("GROUP_CONCAT(CONCAT(ff.field_issue_files_fid, ',', ff.field_issue_files_display, ',', ff.field_issue_files_description) ORDER BY ff.delta ASC SEPARATOR :desc_delim)", 'cur_attachments', array(':desc_delim' => ISSUE_MIGRATE_FILE_DESCRIPTION_DELIMITER));
    $query->addExpression('IFNULL(GROUP_CONCAT(DISTINCT t.tid ORDER BY t.tid SEPARATOR :tags_delim), :tags_default)', 'cur_tags', array(':tags_default' => '', ':tags_delim' => ','));
    $query->addField('d', 'pid', 'cur_pid');
    $query->addField('d', 'component', 'cur_component');
    $query->addField('d', 'category', 'cur_category');
    $query->addExpression('d.priority', 'cur_priority');
    $query->addField('d', 'assigned', 'cur_assigned');
    $query->addField('d', 'sid', 'cur_sid');
    $query->addField('d', 'rid', 'cur_rid');
    $query->addField('d', 'title', 'cur_title');
    $query->addExpression('LEAST(n.created, r.timestamp, c.created)', 'sort_timestamp'); // Due to trimming and corruption, node.created is sometimes faulty.
//    $query->addField('n', 'created', 'sort_timestamp'); // Sort goes by creation time to ensure original revision comes first.
    $query->addField('r', 'timestamp');
    $query->addField('r', 'log');
    $query->addField('r', 'uid');
    $query->addField('fb', 'body_value', 'cur_body_value');
    $query->addField('fb', 'body_format', 'cur_body_format');
    $query->addExpression(':tl', 'tl', array(':tl' => ISSUE_MIGRATE_TIMELINE_OP));

    $query->groupBy('d.nid');
    $query->orderBy('NULL'); // Avoid GROUP BY's implied (file)sort.

    db_insert('project_issue_migration_timeline_init')
      ->from($query)
      ->execute();

    // Copy non-initial vids.
    $query = db_select('node_revision', 'r');
    $query->innerJoin('project_issues', 'p', 'r.nid = p.nid');
    $query->leftJoin('project_issue_migration_original_issue_data', 'v', 'r.vid = v.orig_vid');
    $query->innerJoin('field_revision_body', 'fb', 'r.vid = fb.revision_id AND fb.entity_type = :type', array(':type' => 'node'));
    $query->leftJoin('field_revision_field_issue_files', 'ff', 'r.vid = ff.revision_id AND ff.entity_type = :type', array(':type' => 'node'));
    // Ignore initial vid.
    $query->condition('v.orig_vid', NULL, 'IS NULL');

    $query->addField('r', 'nid');
    $query->addExpression('CONCAT(:vid, r.vid)', 'genid', array(':vid' => 'vid-'));
    $query->addField('r', 'vid');
    $query->addExpression("GROUP_CONCAT(CONCAT(ff.field_issue_files_fid, ',', ff.field_issue_files_display, ',', ff.field_issue_files_description) ORDER BY ff.delta ASC SEPARATOR :desc_delim)", 'cur_attachments', array(':desc_delim' => ISSUE_MIGRATE_FILE_DESCRIPTION_DELIMITER));
    $query->addField('p', 'pid', 'cur_pid');
    $query->addField('r', 'timestamp');
    $query->addField('r', 'timestamp', 'sort_timestamp'); // Unfortunately, node revisions don't keep track of their creation time.
    $query->addField('r', 'log');
    $query->addField('r', 'uid');
    $query->addField('fb', 'body_value', 'cur_body_value');
    $query->addField('fb', 'body_format', 'cur_body_format');
    $query->addExpression(':tl', 'tl', array(':tl' => ISSUE_MIGRATE_TIMELINE_REVISION));

    $query->groupBy('r.vid');
    $query->orderBy('NULL'); // Avoid GROUP BY's implied (file)sort.

    db_insert('project_issue_migration_timeline_init')
      ->from($query)
      ->execute();

    // Copy cids.
    $query = db_select('project_issue_comments', 'p');
    $query->innerJoin('comment', 'c', 'p.cid = c.cid');
    $query->leftJoin('comment_upload', 'cu', 'p.cid = cu.cid');
    $query->innerJoin('field_data_comment_body', 'fb', 'p.cid = fb.entity_id AND fb.entity_type = :type', array(':type' => 'comment'));
    $query->leftJoin('comment_alter_taxonomy', 't', 'p.nid = t.nid AND p.cid = t.cid');

    $query->addField('p', 'nid');
    $query->addExpression('CONCAT(:cid, p.cid)', 'genid', array(':cid' => 'cid-'));
    $query->addField('p', 'cid');
    $query->addExpression("GROUP_CONCAT(CONCAT(cu.fid, ',', cu.list, ',', cu.description) ORDER BY cu.weight ASC SEPARATOR :desc_delim)", 'cur_attachments', array(':desc_delim' => ISSUE_MIGRATE_FILE_DESCRIPTION_DELIMITER));
    $query->addExpression('IFNULL(GROUP_CONCAT(DISTINCT t.tid ORDER BY t.tid SEPARATOR :tags_delim), :tags_default)', 'cur_tags', array(':tags_default' => '', ':tags_delim' => ','));
    $query->addField('p', 'pid', 'cur_pid');
    $query->addField('p', 'component', 'cur_component');
    $query->addField('p', 'category', 'cur_category');
    $query->addExpression('p.priority', 'cur_priority');
    $query->addField('p', 'assigned', 'cur_assigned');
    $query->addField('p', 'sid', 'cur_sid');
    $query->addField('p', 'rid', 'cur_rid');
    $query->addField('p', 'title', 'cur_title');
    $query->addField('p', 'comment_number');
    $query->addField('c', 'changed', 'timestamp');
    $query->addField('c', 'created', 'sort_timestamp'); // Sort goes by creation time to ensure original revision comes first.
    //$query->addField('fb', 'comment_body_value', 'log');
    $query->addField('fb', 'comment_body_value', 'comment_body_value');
    $query->addField('fb', 'comment_body_format', 'comment_body_format');
    $query->addField('c', 'uid');
    $query->addExpression(':tl', 'tl', array(':tl' => ISSUE_MIGRATE_TIMELINE_FOLLOWUP));

    $query->groupBy('p.cid');
    $query->orderBy('NULL'); // Avoid GROUP BY's implied (file)sort.

    db_insert('project_issue_migration_timeline_init')
      ->from($query)
      ->execute();
  }

  protected function rollback() {
    if (db_table_exists('project_issue_migration_timeline_init')) {
      db_drop_table('project_issue_migration_timeline_init');
    }
  }

  public function isComplete() {
    return db_table_exists('project_issue_migration_timeline_init');
  }
}

/**
 * Special migration to assemble our full timeline.
 * Phase 2: Main table / OP injection
 * STATUS: IN PROGRESS
 */
class ProjectIssueTimelinePhaseThreeMigration extends MigrationBase {

  public function __construct($arguments = array()) {
    parent::__construct($arguments);
    $this->description = t('WIP: USE AT YOUR OWN RISK! Project issue timeline generator phase 3');
    $this->dependencies = array('ProjectIssueTimelinePhaseTwo');
  }

  protected function import() {
    $priorities = array(
      1 => 400, // Critical
      4 => 300, // Major
      2 => 200, // Normal
      3 => 100, // Minor
      0 => 200, // Old priorities
      5 => 200,
      6 => 200,
      7 => 200,
    );
    set_time_limit(0);
    // Serious MySQLism.
    db_query('SET SESSION group_concat_max_len = 1048576');

    // Iterate over all data for all issues.
    $p_nid = NULL;
    $result = db_query('SELECT nid, genid, vid, timestamp, sort_timestamp, comment_number, comment_body_value, comment_body_format, log, uid, cid, tl, cur_body_value, cur_body_format, cur_pid, cur_component, cur_category, cur_priority, cur_assigned, cur_sid, cur_rid, cur_title, cur_tags, cur_attachments FROM {project_issue_migration_timeline_init} ORDER BY nid ASC, sort_timestamp ASC, tl ASC');
    $insert = db_insert('project_issue_migration_timeline')
      ->fields(array(
        'nid', 'prev_nid', 'delta', 'genid', 'prev_genid', 'prev_changed_genid',
        'timestamp', 'sort_timestamp', 'has_changes', 'comment_number', 'vid',
        'cid', 'tl', 'last_cid', 'cur_pid', 'prev_pid', 'cur_component',
        'prev_component', 'cur_category', 'prev_category', 'cur_priority',
        'prev_priority', 'cur_assigned', 'prev_assigned', 'cur_sid', 'prev_sid',
        'cur_rid', 'prev_rid', 'cur_title', 'prev_title', 'cur_body_value',
        'prev_body_value', 'cur_body_format', 'prev_body_format',
        'cur_attachments', 'prev_attachments', 'cur_tags', 'prev_tags',
        'comment_body_value', 'comment_body_format', 'log', 'uid',
      ));
    $insert_count = 0;
    foreach ($result as $current) {
      if ($current->nid != $p_nid) {
        $p_genid = NULL;
        $c_delta = 0;

        $p_body_value = NULL;
        $p_body_format = NULL;
        $p_pid = NULL;
        $p_component = NULL;
        $p_category = NULL;
        $p_priority = NULL;
        $p_assigned = NULL;
        $p_sid = NULL;
        $p_rid = NULL;
        $p_title = NULL;
        $p_tags = NULL;
        $p_attachments = NULL;

        $c_lastcid = NULL;
        $p_changed_genid = NULL;

        $c_tags = $current->cur_tags;
      }

      if (!is_null($current->cid)) {
        $c_lastcid = $current->cid;
        $c_tags = $current->cur_tags;
      }

      // Carry over attachments from previous rows, accumulatng them all for each issue.
      if (is_null($current->cur_attachments)) {
        $current->cur_attachments = $p_attachments;
      }
      elseif ($current->cur_attachments != $p_attachments && !is_null($p_attachments)) {
        $current->cur_attachments = $p_attachments . ISSUE_MIGRATE_FILE_DESCRIPTION_DELIMITER . $current->cur_attachments;
      }

      // Carry forward persistant fields from previoius row.
      if (is_null($current->cur_body_value)) {
        $current->cur_body_value = $p_body_value;
      }
      if (is_null($current->cur_body_format)) {
        $current->cur_body_format = $p_body_format;
      }
      if (is_null($current->cur_pid)) {
        $current->cur_pid = $p_pid;
      }
      if (is_null($current->cur_component)) {
        $current->cur_component = $p_component;
      }
      if (is_null($current->cur_category)) {
        $current->cur_category = $p_category;
      }
      if (is_null($current->cur_priority)) {
        $current->cur_priority = $p_priority;
      }
      else {
        $current->cur_priority = $priorities[$current->cur_priority];
      }
      if (is_null($current->cur_assigned)) {
        $current->cur_assigned = $p_assigned;
      }
      if (is_null($current->cur_sid)) {
        $current->cur_sid = $p_sid;
      }
      if (is_null($current->cur_rid)) {
        $current->cur_rid = $p_rid;
      }
      if (is_null($current->cur_title)) {
        $current->cur_title = $p_title;
      }

      $c_haschanges = $current->cur_pid != $p_pid
        || $current->cur_component != $p_component
        || $current->cur_category != $p_category
        || $current->cur_priority != $p_priority
        || $current->cur_assigned != $p_assigned
        || $current->cur_sid != $p_sid
        || $current->cur_rid != $p_rid
        || $current->cur_title != $p_title
        || $current->cur_body_value != $p_body_value
        || $current->cur_body_format != $p_body_format
        || $current->cur_attachments != $p_attachments
        || $c_tags != $p_tags
        || $current->tl == ISSUE_MIGRATE_TIMELINE_OP;

      $insert->values(array(
        'nid' =>                 $current->nid,
        'prev_nid' =>            $p_nid,
        'delta' =>               $c_delta,
        'genid' =>               $current->genid,
        'prev_genid' =>          $p_genid,
        'prev_changed_genid' =>  $p_changed_genid,
        'timestamp' =>           $current->timestamp,
        'sort_timestamp' =>      $current->sort_timestamp,
        'has_changes' =>         (int) $c_haschanges,
        'comment_number' =>      $current->comment_number,
        'vid' =>                 $current->vid,
        'cid' =>                 $current->cid,
        'tl' =>                  $current->tl,
        'last_cid' =>            $c_lastcid,
        'cur_pid' =>             $current->cur_pid,
        'prev_pid' =>            $p_pid,
        'cur_component' =>       $current->cur_component,
        'prev_component' =>      $p_component,
        'cur_category' =>        $current->cur_category,
        'prev_category' =>       $p_category,
        'cur_priority' =>        $current->cur_priority,
        'prev_priority' =>       $p_priority,
        'cur_assigned' =>        $current->cur_assigned,
        'prev_assigned' =>       $p_assigned,
        'cur_sid' =>             $current->cur_sid,
        'prev_sid' =>            $p_sid,
        'cur_rid' =>             $current->cur_rid,
        'prev_rid' =>            $p_rid,
        'cur_title' =>           $current->cur_title,
        'prev_title' =>          $p_title,
        'cur_body_value' =>      $current->cur_body_value,
        'prev_body_value' =>     $p_body_value,
        'cur_body_format' =>     $current->cur_body_format,
        'prev_body_format' =>    $p_body_format,
        'cur_attachments' =>     $current->cur_attachments,
        'prev_attachments' =>    $p_attachments,
        'cur_tags' =>            $c_tags,
        'prev_tags' =>           $p_tags,
        'comment_body_value' =>  $current->comment_body_value,
        'comment_body_format' => $current->comment_body_format,
        'log' =>                 $current->log,
        'uid' =>                 $current->uid,
      ));
      // Write out rows in batches of 20.
      $insert_count += 1;
      if ($insert_count >= 20) {
        $insert->execute();
        $insert_count = 0;
      }

      $p_nid = $current->nid;
      $c_delta += 1;
      $p_genid = $current->genid;

      $p_body_value   = $current->cur_body_value;
      $p_body_format  = $current->cur_body_format;
      $p_pid          = $current->cur_pid;
      $p_component    = $current->cur_component;
      $p_category     = $current->cur_category;
      $p_priority     = $current->cur_priority;
      $p_assigned     = $current->cur_assigned;
      $p_sid          = $current->cur_sid;
      $p_rid          = $current->cur_rid;
      $p_title        = $current->cur_title;
      $p_tags         = $c_tags;
      $p_attachments  = $current->cur_attachments;

      if ($c_haschanges) {
        $p_changed_genid = $current->genid;
      }
    }

    // Write out any remaining rows.
    if ($insert_count > 0) {
      $insert->execute();
    }
  }

  protected function rollback() {
    if (db_table_exists('project_issue_migration_timeline')) {
      db_drop_table('project_issue_migration_timeline');
    }
  }

  public function isComplete() {
    return db_table_exists('project_issue_migration_timeline');
  }
}

/**
 * Generate stub node revisions.
 */
class ProjectIssueAllocateVidsMigration extends MigrationBase {
  public function __construct($arguments = array()) {
    parent::__construct($arguments);
    $this->description = t('WIP: USE AT YOUR OWN RISK! Bulk allocate node revisions for timeline.');
    $this->dependencies = array('ProjectIssueTimelinePhaseThree');
  }

  protected function import() {
    // We have to loop node by node because there is not unique identifier.
    // Double-posted comments get the same timestamp.
    $result = db_query('SELECT t.nid, t.timestamp, t.genid, t.cur_title as title, n.status, n.comment, n.promote, n.sticky, IFNULL(t.log, :logdesc) AS log, t.uid FROM {project_issue_migration_timeline} t INNER JOIN {node} n ON t.nid = n.nid WHERE t.has_changes = 1 AND t.vid IS NULL ORDER BY t.nid ASC, t.sort_timestamp ASC, t.tl ASC', array(':logdesc' => 'Automatically generated revision for <a href="https://drupal.org/faq#issue-revisions">Drupal 7 upgrade</a>'));
    foreach ($result as $row) {
      // Generate vid.
      drupal_write_record('node_revision', $row);
      db_update('project_issue_migration_timeline')
        ->fields(array('vid' => $row->vid))
        ->condition('genid', $row->genid)
        ->execute();
    }
    // Fixup current revision of issue nodes.
    db_query('UPDATE {node} n INNER JOIN (SELECT nid, MAX(vid) AS vid FROM {project_issue_migration_timeline} GROUP BY nid) AS t ON n.nid = t.nid SET n.vid = t.vid');
  }

  public function isComplete() {
    if (!db_table_exists('project_issue_migration_timeline')) {
      return FALSE;
    }
    return (db_query('SELECT COUNT(*) FROM {project_issue_migration_timeline} WHERE has_changes = 1 AND vid IS NULL')->fetchField() == 0);
  }
}

/**
 * Generate comments for changed node revisions.
 */
class ProjectIssueAllocateCidsMigration extends MigrationBase {
  public function __construct($arguments = array()) {
    parent::__construct($arguments);
    $this->description = t('WIP: USE AT YOUR OWN RISK! Bulk allocate comments for timeline.');
    $this->dependencies = array('ProjectIssueTimelinePhaseThree', 'ProjectIssueRethreadIssueFollowups');
  }

  protected function import() {
    $result = db_query('SELECT t.nid, t.timestamp, t.genid, t.uid, IFNULL(t.last_cid, 0) AS last_cid, c.thread, n.status FROM {project_issue_migration_timeline} t LEFT JOIN {comment} c ON c.cid = t.last_cid INNER JOIN {node} n ON t.nid = n.nid WHERE t.has_changes = 1 AND t.cid IS NULL AND tl <> 0 ORDER BY t.nid ASC, t.sort_timestamp ASC, t.tl ASC');
    $lastnid = -1;
    $threadpos = array();
    foreach ($result as $row) {
      if ($row->nid != $lastnid) {
        // Reset the thread positions array.
        $threadpos = array();
        $lastnid = $row->nid;
      }
      // Start counting at zero to match core behavior.
      if (!isset($threadpos[$row->last_cid])) {
        $threadpos[$row->last_cid] = 0;
      }
      else {
        $threadpos[$row->last_cid]++;
      }
      // Assemble the correct thread identifier.
      if (empty($row->thread)) {
        // If there are no comments up to this point in time, use a theoretical comment #0 as the parent.
        // This should prevent conflicts, since the counting would normally start from 1 for comments with parent 0.
        $row->thread = '00/';
      }
      $row->thread = rtrim($row->thread, '/');
      // We prevent conflicts between existing comments and existing revisions by
      // forcing comments generated for existing revisions to always have a parent
      // set. Since this does not happen for existing comments on issues (issues are flat),
      // we can guarantee that no two comments will have the same thread value.
      // This is important, as the thread value is being used in permalinks.
      $row->thread = $row->thread . '.' . int2vancode($threadpos[$row->last_cid]) . '/';

      $row->created = $row->timestamp;
      $row->changed = $row->timestamp;
      $row->subject = ''; // Comments on issues don't have a subject.
      $row->hostname = '127.0.0.1'; // @todo Is this correct?
      $row->language = '';

      // Generate cid.
      drupal_write_record('comment', $row);
      db_update('project_issue_migration_timeline')
        ->fields(array('cid' => $row->cid))
        ->condition('genid', $row->genid)
        ->execute();
    }
  }

  public function isComplete() {
    if (!db_table_exists('project_issue_migration_timeline')) {
      return FALSE;
    }
    return (db_query('SELECT COUNT(*) FROM {project_issue_migration_timeline} WHERE tl <> 0 AND has_changes = 1 AND cid IS NULL')->fetchField() == 0);
  }
}

/**
 * Rebuild comment fields.
 */
class ProjectIssueRebuildCommentFieldsMigration extends MigrationBase {
  public function __construct($arguments = array()) {
    parent::__construct($arguments);
    $this->description = t('WIP: USE AT YOUR OWN RISK! Inject fields for comments.');
    $this->dependencies = array('ProjectIssueAllocateCids');
  }

  protected function import() {
    // Part 1: Comments generated in ProjectIssueAllocateCids are missing the body field.
    $query = db_select('project_issue_migration_timeline', 't');
    // The rows to use are identified by the tl being revision.
    $query->condition('tl', ISSUE_MIGRATE_TIMELINE_REVISION);
    $query->condition('has_changes', 1);
    $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => 'comment'));
    $query->addExpression(':bundle', 'bundle', array(':bundle' => 'comment_node_project_issue'));
    $query->addExpression(':deleted', 'deleted', array(':deleted' => 0));
    $query->addField('t', 'cid', 'entity_id');
    $query->addField('t', 'cid', 'revision_id');
    $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
    $query->addExpression(':delta', 'delta', array(':delta' => 0));
    $query->addExpression('IFNULL(t.log, :defaultlog)', 'comment_body_value', array(':defaultlog' => ''));
    // @todo Ensure this is the correct format...
    $query->addExpression(':format', 'comment_body_format', array(':format' => 1));
    $query_c = clone($query);
    db_insert('field_data_comment_body')
      ->from($query)
      ->execute();
    db_insert('field_revision_comment_body')
      ->from($query_c)
      ->execute();

    // Part 2: Assemble field_issue_changes.

    $diff_field_name = nodechanges_get_field_name('comment_node_project_issue');
    $field_info = field_info_field($diff_field_name);

    // Main loop
    $result = db_query('SELECT DISTINCT nid FROM {project_issue_migration_timeline} ORDER BY nid ASC');
    db_query('ALTER TABLE {field_data_field_issue_changes} DISABLE KEYS');
    db_query('ALTER TABLE {field_revision_field_issue_changes} DISABLE KEYS');
    $c = 0;
    $insertfields = array('entity_type', 'bundle', 'deleted', 'entity_id', 'revision_id', 'language', 'delta', 'field_issue_changes_field_name', 'field_issue_changes_nid', 'field_issue_changes_vid', 'field_issue_changes_old_value', 'field_issue_changes_new_value');
    $dataq = db_insert('field_data_field_issue_changes')->fields($insertfields);
    $revisionq = db_insert('field_revision_field_issue_changes')->fields($insertfields);
    foreach ($result as $row) {
      // Loop per node.
      $items = array();
      $result2 = db_query('SELECT t.*, cur_r.version AS cur_version, prev_r.version AS prev_version FROM {project_issue_migration_timeline} t LEFT JOIN {project_release_nodes} cur_r ON t.cur_rid = cur_r.nid LEFT JOIN {project_release_nodes} prev_r ON t.prev_rid = prev_r.nid WHERE t.nid = :nid AND t.has_changes = 1 ORDER BY t.nid ASC, t.sort_timestamp ASC, t.tl ASC', array(':nid' => $row->nid));
      $lastvid = -1;
      foreach ($result2 as $data) {
        if ($data->tl == 0) {
          // The only thing we're using the OP for is to grab the original vid.
          $lastvid = $data->vid;
          continue;
        }
        $node = new stdClass;
        $unchanged = new stdClass;
        $items[$data->cid] = array();

        // Synthesise nodes from the data we loaded from the timeline.
        // We only care about the pieces that nodechanges looks at.
        $node->nid = $data->nid;
        $node->vid = $data->vid;
        $unchanged->vid = $lastvid;
        $node->language = LANGUAGE_NONE;
        $unchanged->language = LANGUAGE_NONE;
        $node->type = 'project_issue';
        $unchanged->type = 'project_issue';

        // Quick access arrays for data.
        $n = array(&$node, &$unchanged);
        $v = array();
        foreach (array_keys((array)$data) as $key) {
          if (substr($key, 0, 4) == 'cur_') {
            $v[0][substr($key, 4)] = $data->{$key};
          }
          if (substr($key, 0, 5) == 'prev_') {
            $v[1][substr($key, 5)] = $data->{$key};
          }
        }

        foreach (array(0, 1) as $noff) {
          $n[$noff]->body[LANGUAGE_NONE][] = array(
            'value' => $v[$noff]['body_value'],
          );
          $n[$noff]->title = $v[$noff]['title'];

          // @todo This is very d.o specific.
          // nodechanges expects a full term information.
          foreach (taxonomy_term_load_multiple(explode(',', $v[$noff]['tags'])) as $term) {
            $n[$noff]->taxonomy_vocabulary_9[LANGUAGE_NONE][] = (array) $term;
          }

          if (!empty($v[$noff]['attachments'])) {
            $tmp = explode(ISSUE_MIGRATE_FILE_DESCRIPTION_DELIMITER, $v[$noff]['attachments']);
            $seenfids = array();
            foreach ($tmp as $file) {
              list($fid, $display, $description) = explode(',', $file, 3);
              if (!isset($seenfids[$fid])) {
                $seenfids[$fid] = TRUE;
                $n[$noff]->field_issue_files[LANGUAGE_NONE][] = array(
                  'fid' => $fid,
                  'description' => $description,
                  'display' => $display,
                );
              }
            }
          }

          foreach (array('field_issue_category' => 'category', 'field_issue_component' => 'component', 'field_issue_priority' => 'priority', 'field_issue_status' => 'sid', 'field_issue_version' => 'version') as $tfield => $sfield) {
            $n[$noff]->{$tfield}[LANGUAGE_NONE][0]['value'] = $v[$noff][$sfield];
          }
          foreach (array('field_issue_assigned' => 'assigned', 'field_project' => 'pid') as $tfield => $sfield) {
            $n[$noff]->{$tfield}[LANGUAGE_NONE][0]['target_id'] = $v[$noff][$sfield];
          }
        }

        // Modified version of nodechanges_node_update(), skipping some loading
        // and tests which are not needed in this context.
        foreach ($field_info['settings']['properties'] as $property => $property_name) {
          $token_name = $property;
          // Match node property to token name
          $property = ($property == 'author') ? 'uid' : $property;
          $old_value = empty($unchanged->$property) ? NULL : $unchanged->$property;
          $new_value = empty($node->$property) ? NULL : $node->$property;
          $same = $old_value == $new_value;
          if (!$same && !empty($old_value) && !empty($new_value)) {
            $item = array(
              'field_name' => "node_property:$token_name",
              'nid' => $node->nid,
              'vid' => $node->vid,
            );
            $item['old_value'] = $unchanged->$property;
            $item['new_value'] = $node->$property;
            $items[$data->cid][] = $item;
          }
        }

        foreach (field_info_instances('node', $node->type) as $field_name => $instance) {
          $field = field_info_field($field_name);
          $old_value = empty($unchanged->{$field_name}[$unchanged->language]) ? NULL : $unchanged->{$field_name}[$unchanged->language];
          // Unlike nodechanges_node_update(), we do not do any additional term
          // loading. That is done for both old and new when we call
          // taxonomy_term_load_multiple() above.
          $new_value = empty($node->{$field_name}[$node->language]) ? NULL : $node->{$field_name}[$node->language];
          $same = empty($old_value) == empty($new_value);
          if ($same && !empty($old_value)) {
            $old_deltas = array_keys($old_value);
            $new_deltas = array_keys($new_value);
            $same = !array_diff($old_deltas, $new_deltas) && !array_diff($new_deltas, $old_deltas);
            if ($same) {
              $columns = array_keys($field['columns']);
              foreach ($old_value as $delta => $old_items) {
                foreach ($columns as $column) {
                  $set = isset($old_items[$column]);
                  if (($set != isset($new_value[$delta][$column])) || ($set && $old_items[$column] != $new_value[$delta][$column])) {
                    $same = FALSE;
                    break;
                  }
                }
              }
            }
          }
          if (!$same) {
            $item = array(
              'field_name' => $field_name,
              'nid' => $node->nid,
              'vid' => $node->vid,
            );
            if ($field['type'] == 'text_long' || $field['type'] == 'text_with_summary') {
              $item['old_value'] = $unchanged->vid;
              $item['new_value'] = $node->vid;
            }
            else {
              $item['old_value'] = serialize($old_value);
              $item['new_value'] = serialize($new_value);
            }
            $items[$data->cid][] = $item;
          }
        }
        // End code copied from nodechanges_node_update(), we save the changes
        // directly to field_issue_changes rather than using comment_save().
        $lastvid = $data->vid;
      }
      foreach ($items as $cid => $changes) {
        foreach ($changes as $delta => $change) {
          $record = array(
            'entity_type' => 'comment',
            'bundle' => 'comment_node_project_issue',
            'deleted' => 0,
            'entity_id' => $cid,
            'revision_id' => $cid,
            'language' => LANGUAGE_NONE,
            'delta' => $delta,
            'field_issue_changes_field_name' => $change['field_name'],
            'field_issue_changes_nid' => $change['nid'],
            'field_issue_changes_vid' => $change['vid'],
            'field_issue_changes_old_value' => $change['old_value'],
            'field_issue_changes_new_value' => $change['new_value'],
          );
          $dataq->values($record);
          $revisionq->values($record);
          $c += 1;
        }
      }
      if ($c > 100) {
        $dataq->execute();
        $revisionq->execute();
        $c = 0;
      }
    }
    if ($c > 0) {
      $dataq->execute();
      $revisionq->execute();
    }
    db_query('ALTER TABLE {field_data_field_issue_changes} ENABLE KEYS');
    db_query('ALTER TABLE {field_revision_field_issue_changes} ENABLE KEYS');
  }

  public function isComplete() {
    if (!db_table_exists('project_issue_migration_timeline')) {
      return FALSE;
    }
    return (db_query('SELECT COUNT(*) FROM {project_issue_migration_timeline} t LEFT JOIN {field_data_field_issue_changes} c ON t.cid = c.entity_id WHERE t.has_changes = 1 AND c.entity_id IS NULL')->fetchField() == 0);
  }
}

/**
 * Rebuild field tables for issue node revisions.
 */
class ProjectIssueRebuildNodeFieldsMigration extends MigrationBase {
  public function __construct($arguments = array()) {
    parent::__construct($arguments);
    $this->description = t('WIP: USE AT YOUR OWN RISK! Inject fields for node revisions.');
    $this->dependencies = array('ProjectIssueAllocateVids');
  }

  protected function import() {
    // Part 1: Clear and rebuild body field.
    /* Let's stick with the core field migration for body. Our latest revision is constructed for issue changes, simulating the past.
    db_query('DELETE field_data_body FROM field_data_body, node WHERE field_data_body.entity_id = node.nid AND field_data_body.entity_type = :entity_type AND node.type = :type', array(':entity_type' => 'node', ':type' => 'project_issue'));
    */
    db_query('DELETE field_revision_body FROM field_revision_body, node WHERE field_revision_body.entity_id = node.nid AND field_revision_body.entity_type = :entity_type AND node.type = :type', array(':entity_type' => 'node', ':type' => 'project_issue'));

    /*
    $query = db_select('project_issue_migration_timeline', 't');
    // Current revision only.
    $query->innerJoin('node', 'n', 't.vid = n.vid');
    $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => 'node'));
    $query->addExpression(':bundle', 'bundle', array(':bundle' => 'project_issue'));
    $query->addExpression(':deleted', 'deleted', array(':deleted' => 0));
    $query->addField('t', 'nid', 'entity_id');
    $query->addField('t', 'vid', 'revision_id');
    $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
    $query->addExpression(':delta', 'delta', array(':delta' => 0));
    $query->addField('t', 'cur_body_value', 'body_value');
    $query->addField('t', 'cur_body_format', 'body_format');
    db_insert('field_data_body')
      ->from($query)
      ->execute();
      */

    $query = db_select('project_issue_migration_timeline', 't');
    $query->condition('t.vid', NULL, 'IS NOT NULL');
    $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => 'node'));
    $query->addExpression(':bundle', 'bundle', array(':bundle' => 'project_issue'));
    $query->addExpression(':deleted', 'deleted', array(':deleted' => 0));
    $query->addField('t', 'nid', 'entity_id');
    $query->addField('t', 'vid', 'revision_id');
    $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
    $query->addExpression(':delta', 'delta', array(':delta' => 0));
    $query->addField('t', 'cur_body_value', 'body_value');
    $query->addExpression(':summary', 'body_summary', array(':summary' => ''));
    $query->addField('t', 'cur_body_format', 'body_format');
    db_insert('field_revision_body')
      ->from($query)
      ->execute();

    // Part 2: Load other fields.

    // Category field is stored as an integer. Bleh.
    db_delete('field_data_field_issue_category')->condition('bundle', 'project_issue')->execute();
    db_delete('field_revision_field_issue_category')->condition('bundle', 'project_issue')->execute();

    $query = db_select('project_issue_migration_timeline', 't');
    // Current revision only.
    $query->innerJoin('node', 'n', 't.vid = n.vid');
    // Omit nulls.
    $query->condition('cur_category', NULL, 'IS NOT NULL');
    $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => 'node'));
    $query->addExpression(':bundle', 'bundle', array(':bundle' => 'project_issue'));
    $query->addExpression(':deleted', 'deleted', array(':deleted' => 0));
    $query->addField('t', 'nid', 'entity_id');
    $query->addField('t', 'vid', 'revision_id');
    $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
    $query->addExpression(':delta', 'delta', array(':delta' => 0));
    // Category map in sql.
    $query->addExpression("CASE cur_category WHEN 'feature' THEN 3 WHEN 'bug' THEN 1 WHEN 'support' THEN 4 WHEN 'task' THEN 2 ELSE NULL END", 'field_issue_category_value');
    db_insert("field_data_field_issue_category")
      ->from($query)
      ->execute();

    $query = db_select('project_issue_migration_timeline', 't');
    $query->condition('t.vid', NULL, 'IS NOT NULL');
    // Omit nulls.
    $query->condition('cur_category', NULL, 'IS NOT NULL');
    $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => 'node'));
    $query->addExpression(':bundle', 'bundle', array(':bundle' => 'project_issue'));
    $query->addExpression(':deleted', 'deleted', array(':deleted' => 0));
    $query->addField('t', 'nid', 'entity_id');
    $query->addField('t', 'vid', 'revision_id');
    $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
    $query->addExpression(':delta', 'delta', array(':delta' => 0));
    // Category map in sql.
    $query->addExpression("CASE cur_category WHEN 'feature' THEN 3 WHEN 'bug' THEN 1 WHEN 'support' THEN 4 WHEN 'task' THEN 2 ELSE NULL END", 'field_issue_category_value');
    db_insert("field_revision_field_issue_category")
      ->from($query)
      ->execute();

    foreach (array('component' => 'component', 'priority' => 'priority', 'status' => 'sid') as $field => $source) {
      db_delete('field_data_field_issue_' . $field)->condition('bundle', 'project_issue')->execute();
      db_delete('field_revision_field_issue_' . $field)->condition('bundle', 'project_issue')->execute();

      $query = db_select('project_issue_migration_timeline', 't');
      // Current revision only.
      $query->innerJoin('node', 'n', 't.vid = n.vid');
      $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => 'node'));
      $query->addExpression(':bundle', 'bundle', array(':bundle' => 'project_issue'));
      $query->addExpression(':deleted', 'deleted', array(':deleted' => 0));
      $query->addField('t', 'nid', 'entity_id');
      $query->addField('t', 'vid', 'revision_id');
      $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
      $query->addExpression(':delta', 'delta', array(':delta' => 0));
      $query->addField('t', "cur_{$source}", "field_issue_{$field}_value");
      db_insert("field_data_field_issue_{$field}")
        ->from($query)
        ->execute();

      $query = db_select('project_issue_migration_timeline', 't');
      $query->condition('t.vid', NULL, 'IS NOT NULL');
      $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => 'node'));
      $query->addExpression(':bundle', 'bundle', array(':bundle' => 'project_issue'));
      $query->addExpression(':deleted', 'deleted', array(':deleted' => 0));
      $query->addField('t', 'nid', 'entity_id');
      $query->addField('t', 'vid', 'revision_id');
      $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
      $query->addExpression(':delta', 'delta', array(':delta' => 0));
      $query->addField('t', "cur_{$source}", "field_issue_{$field}_value");
      db_insert("field_revision_field_issue_{$field}")
        ->from($query)
        ->execute();
    }

    // For the version field, we need to join against {project_release_nodes}.
    db_delete('field_data_field_issue_version')->condition('bundle', 'project_issue')->execute();
    db_delete('field_revision_field_issue_version')->condition('bundle', 'project_issue')->execute();

    $query = db_select('project_issue_migration_timeline', 't');
    // Current revision only.
    $query->innerJoin('node', 'n', 't.vid = n.vid');
    // Join against {project_release_nodes} so we can map rid to version string.
    $query->innerJoin('project_release_nodes', 'x', 't.cur_rid = x.nid');
    $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => 'node'));
    $query->addExpression(':bundle', 'bundle', array(':bundle' => 'project_issue'));
    $query->addExpression(':deleted', 'deleted', array(':deleted' => 0));
    $query->addField('t', 'nid', 'entity_id');
    $query->addField('t', 'vid', 'revision_id');
    $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
    $query->addExpression(':delta', 'delta', array(':delta' => 0));
    $query->addField('x', 'version', 'field_issue_version_value');
    db_insert('field_data_field_issue_version')
      ->from($query)
      ->execute();

    $query = db_select('project_issue_migration_timeline', 't');
    $query->condition('t.vid', NULL, 'IS NOT NULL');
    // Join against {project_release_nodes} so we can map rid to version string.
    $query->innerJoin('project_release_nodes', 'x', 't.cur_rid = x.nid');
    $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => 'node'));
    $query->addExpression(':bundle', 'bundle', array(':bundle' => 'project_issue'));
    $query->addExpression(':deleted', 'deleted', array(':deleted' => 0));
    $query->addField('t', 'nid', 'entity_id');
    $query->addField('t', 'vid', 'revision_id');
    $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
    $query->addExpression(':delta', 'delta', array(':delta' => 0));
    $query->addField('x', 'version', 'field_issue_version_value');
    db_insert('field_revision_field_issue_version')
      ->from($query)
      ->execute();

    foreach (array('field_issue_assigned' => 'assigned', 'field_project' => 'pid') as $field => $source) {
      db_delete('field_data_' . $field)->condition('bundle', 'project_issue')->execute();
      db_delete('field_revision_' . $field)->condition('bundle', 'project_issue')->execute();

      $query = db_select('project_issue_migration_timeline', 't');
      // Current revision only.
      $query->innerJoin('node', 'n', 't.vid = n.vid');
      // No nulls.
      $query->condition("t.cur_{$source}", NULL, 'IS NOT NULL');
      $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => 'node'));
      $query->addExpression(':bundle', 'bundle', array(':bundle' => 'project_issue'));
      $query->addExpression(':deleted', 'deleted', array(':deleted' => 0));
      $query->addField('t', 'nid', 'entity_id');
      $query->addField('t', 'vid', 'revision_id');
      $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
      $query->addExpression(':delta', 'delta', array(':delta' => 0));
      $query->addField('t', "cur_{$source}", "{$field}_target_id");
      db_insert("field_data_{$field}")
        ->from($query)
        ->execute();

      $query = db_select('project_issue_migration_timeline', 't');
      $query->condition('t.vid', NULL, 'IS NOT NULL');
      // No nulls.
      $query->condition("t.cur_{$source}", NULL, 'IS NOT NULL');
      $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => 'node'));
      $query->addExpression(':bundle', 'bundle', array(':bundle' => 'project_issue'));
      $query->addExpression(':deleted', 'deleted', array(':deleted' => 0));
      $query->addField('t', 'nid', 'entity_id');
      $query->addField('t', 'vid', 'revision_id');
      $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
      $query->addExpression(':delta', 'delta', array(':delta' => 0));
      $query->addField('t', "cur_{$source}", "{$field}_target_id");
      db_insert("field_revision_{$field}")
        ->from($query)
        ->execute();
    }

    // Files
    db_delete('field_data_field_issue_files')->condition('bundle', 'project_issue')->execute();
    db_delete('field_revision_field_issue_files')->condition('bundle', 'project_issue')->execute();
    $result = db_query('SELECT t.nid, t.vid, n.vid AS n_vid, t.cur_attachments FROM {project_issue_migration_timeline} t INNER JOIN {node} n ON t.nid = n.nid WHERE t.vid IS NOT NULL and t.cur_attachments IS NOT NULL');
    $fields = array('entity_type', 'bundle', 'deleted', 'entity_id', 'revision_id', 'language', 'delta', 'field_issue_files_fid', 'field_issue_files_display', 'field_issue_files_description');
    foreach ($result as $row) {
      $values = array();
      $seenfids = array();
      foreach (explode(ISSUE_MIGRATE_FILE_DESCRIPTION_DELIMITER, $row->cur_attachments) as $delta => $data) {
        list($fid, $display, $description) = explode(',', $data, 3);
        if (!isset($seenfids[$fid])) {
          $seenfids[$fid] = TRUE;
          $values[] = array(
            'entity_type' => 'node',
            'bundle' => 'project_issue',
            'deleted' => 0,
            'entity_id' => $row->nid,
            'revision_id' => $row->vid,
            'language' => LANGUAGE_NONE,
            'delta' => $delta,
            'field_issue_files_fid' => $fid,
            'field_issue_files_display' => $display,
            'field_issue_files_description' => $description,
          );
        }
      }
      if (!empty($values)) {
        $insertq = db_insert('field_revision_field_issue_files')->fields($fields);
        foreach ($values as $value) {
          $insertq->values($value);
        }
        $insertq->execute();
        if ($row->vid == $row->n_vid) {
          // Copy the most recent revision to the field data.
          $insertq = db_insert('field_data_field_issue_files')->fields($fields);
          foreach ($values as $value) {
            $insertq->values($value);
          }
          $insertq->execute();
        }
      }
    }
    // Update file usage.
    db_query('DELETE {file_usage} FROM {file_usage}, {field_revision_field_issue_files} WHERE {file_usage}.fid = {field_revision_field_issue_files}.field_issue_files_fid');
    db_query("INSERT INTO {file_usage} (fid, module, type, id, count) (SELECT field_issue_files_fid, 'file', 'node', entity_id, COUNT(*) FROM {field_revision_field_issue_files} GROUP BY entity_id, field_issue_files_fid)");

    // @todo This is drupal.org specific.
    db_query('DELETE {taxonomy_index} FROM {taxonomy_index}, {node}, {taxonomy_term_data} WHERE {taxonomy_index}.nid = {node}.nid AND {taxonomy_index}.tid = {taxonomy_term_data}.tid AND {taxonomy_term_data}.vid = :vid AND {node}.type = :type', array(':vid' => ISSUE_MIGRATE_TAGS_VID, ':type' => 'project_issue'));
    db_delete('field_data_taxonomy_vocabulary_' . ISSUE_MIGRATE_TAGS_VID)->condition('bundle', 'project_issue')->execute();
    db_delete('field_revision_taxonomy_vocabulary_' . ISSUE_MIGRATE_TAGS_VID)->condition('bundle', 'project_issue')->execute();

    $result = db_query("SELECT t.nid, t.vid, n.vid AS n_vid, t.cur_tags FROM {project_issue_migration_timeline} t INNER JOIN {node} n ON t.nid = n.nid WHERE t.vid IS NOT NULL AND t.cur_tags IS NOT NULL AND t.cur_tags <> ''");
    $fields = array('entity_type', 'bundle', 'deleted', 'entity_id', 'revision_id', 'language', 'delta', 'taxonomy_vocabulary_' . ISSUE_MIGRATE_TAGS_VID . '_tid');
    foreach ($result as $row) {
      $values = array();
      foreach (explode(',', $row->cur_tags) as $delta => $tid) {
        $values[] = array(
          'entity_type' => 'node',
          'bundle' => 'project_issue',
          'deleted' => 0,
          'entity_id' => $row->nid,
          'revision_id' => $row->vid,
          'language' => LANGUAGE_NONE,
          'delta' => $delta,
          'taxonomy_vocabulary_' . ISSUE_MIGRATE_TAGS_VID . '_tid' => $tid,
        );
      }
      if (!empty($values)) {
        $insertq = db_insert('field_revision_taxonomy_vocabulary_' . ISSUE_MIGRATE_TAGS_VID)->fields($fields);
        foreach ($values as $value) {
          $insertq->values($value);
        }
        $insertq->execute();
        if ($row->vid == $row->n_vid) {
          // Copy the most recent revision to the field_data.
          $insertq = db_insert('field_data_taxonomy_vocabulary_' . ISSUE_MIGRATE_TAGS_VID)->fields($fields);
          foreach ($values as $value) {
            $insertq->values($value);
          }
          $insertq->execute();
        }
      }
    }
    // Bulk update {taxonomy_index}.
    db_query("INSERT INTO {taxonomy_index} (nid, tid, sticky, created) (SELECT f.entity_id, f.taxonomy_vocabulary_" . ISSUE_MIGRATE_TAGS_VID . "_tid, n.sticky, n.created FROM {field_data_taxonomy_vocabulary_" . ISSUE_MIGRATE_TAGS_VID . "} f INNER JOIN {node} n ON f.entity_id = n.nid AND f.entity_type = 'node' WHERE n.status = 1)");

    variable_del('ProjectIssueRebuildNodeFieldsMigration_incomplete');
  }

  public function isComplete() {
    if (!db_table_exists('project_issue_migration_timeline')) {
      return FALSE;
    }
    return is_null(variable_get('ProjectIssueRebuildNodeFieldsMigration_incomplete', NULL));
  }
}

/**
 * Map category names to integers.
 */
function _project_issue_map_category($value) {
  switch ($value) {
    case 'feature':
      return 3;
    case 'bug':
      return 1;
    case 'support':
      return 4;
    case 'task':
      return 2;
    default:
      return 0;
  }
}

/**
 * Map rids to version strings.
 */
function _project_issue_map_version($value) {
  static $vdata = array();
  if (!isset($vdata[$value])) {
    $vdata[$value] = db_query('SELECT version FROM {project_release_nodes} WHERE nid = :nid', array(':nid' => $value))->fetchField();
  }
  return $vdata[$value];
}
