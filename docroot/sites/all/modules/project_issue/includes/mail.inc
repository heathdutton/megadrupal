<?php

/**
 * @file
 * Project issue tracking email notifications system.
 */

/**
 * Send or enqueue e-mail notifications.
 *
 * If the site is configured to use a queue for issue notifications, this
 * function simply enqueues the issue update that needs notifications and
 * returns. Otherwise, it directly invokes the logic to process and send all
 * notifications immediately.
 *
 * @param integer $nid
 *   The node ID (nid) of an issue node to send notifications for.
 * @param integer $cid
 *   The comment ID (cid) of the comment generated for an update to the given
 *   node. If not set, we're dealing with the original posting of the issue.
 */
function project_issue_email_notify($nid, $cid = 0) {
  if (defined('PROJECT_NOMAIL')) {
    return;
  }

  $use_queue = variable_get('project_issue_notification_queue', FALSE);
  if (!empty($use_queue)) {
    $queue = DrupalQueue::get('project_issue_notifications');
    $item = array(
      'nid' => $nid,
      'cid' => $cid,
    );
    $queue->createItem($item);
  }
  // Otherwise, directly send any necessary notifications.
  else {
    _project_issue_email_notify($nid, $cid);
  }
}

/**
 * Actually send e-mail notifications.
 *
 * This is a private helper function invoked either directly via
 * project_issue_email_notify() or when draining the queue of pending issue
 * update notifications.
 *
 * @param integer $nid
 *   The node ID (nid) of an issue node to send notifications for.
 * @param integer $cid
 *   The comment ID (cid) of the comment generated for an update to the given
 *   node. If not set, we're dealing with the original posting of the issue.
 *
 * @see project_issue_email_notify().
 */
function _project_issue_email_notify($nid, $cid = 0) {
  $issue = node_load($nid);

  // User ID of the user responsible for the issue update.
  $update_uid = 0;

  // If we're generating a notification due to a new comment (either a "raw"
  // comment or one auto-generated by Node Changes based on an issue update),
  // we know the issue has some comments and we need to load those.
  if (!empty($cid)) {
    $thread = comment_get_thread($issue, COMMENT_MODE_FLAT, 1000);
    $comments = comment_load_multiple($thread);
    // If the node revision that generated the comment isn't the most recent
    // revision of the issue, we want to load the revision that generated
    // the comment (e.g. in case there were multiple revisions done
    // programatically in the same page load or if we're using a queue to
    // manage notifications).
    $comment = $comments[$cid];
    $nodechanges_field = nodechanges_get_field_name($comment->node_type);
    if (!empty($comment->{$nodechanges_field}[LANGUAGE_NONE][0]['vid'])) {
      $update_vid = $comment->{$nodechanges_field}[LANGUAGE_NONE][0]['vid'];
      if ($update_vid != $issue->vid) {
        $issue = node_load($nid, $update_vid, TRUE);
      }
    }
    $update_uid = $comment->uid;
  }
  else {
    // We want to send a notification for the original issue node. However,
    // It's possible other updates have already happened to this node, so we
    // need to find and reload the original revision.
    $original_vid = db_query('SELECT MIN(vid) FROM {node_revision} WHERE nid = :nid', array(':nid' => $nid))->fetchField();
    $issue = node_load($nid, $original_vid, TRUE);
    $comments = array();
    $update_uid = $issue->uid;
  }

  $update_user = user_load($update_uid);

  // We don't want any notifications for unpublished nodes.
  if (empty($issue) || empty($issue->status)) {
    return;
  }

  $project = node_load($issue->field_project[LANGUAGE_NONE][0]['target_id']);

  $recipients = project_issue_get_email_recipients($issue, $project, $comments);

  // Construct the sender for the e-mail.
  $sender = new stdClass;
  $sender->name = t('!name (!site)', array('!name' => $update_user->name, '!site' => variable_get('site_name', 'Drupal')));
  $reply_to = variable_get('project_issue_reply_to_' . $issue->type, variable_get('site_mail', ini_get('sendmail_from')));
  $machine_name = $project->field_project_machine_name[LANGUAGE_NONE][0]['value'];
  // Support a custom '%project' token in the sender's e-mail address.
  /// @todo This should probably use token_replace().
  $sender->mail = strtr($reply_to, array('%project' => $machine_name));

  // The sender name is enclosed by double quotes below
  // to satisfy RFC2822 <http://www.faqs.org/rfcs/rfc2822.html>,
  // which requires double quotes when special characters (including
  // some punctuation) are used.  See example in Appendix A.1.2.
  $from = '"' . mime_header_encode($sender->name) . "\" <$sender->mail>";

  // Stash what we care about for constructing the email via hook_mail().
  $params['issue'] = $issue;
  $params['project'] = $project;
  $params['comments'] = $comments;
  $params['comment_id'] = $cid;

  // We need to determine if node_access() checks are necessary.  The
  // check will be needed if any of the following is true:
  //   1. The node is not published.
  //   2. There is at least one node access control module enabled.
  $grants = module_implements('node_grants');
  $check_node_access = $issue->status != 1 || !empty($grants);

  // To save workload, check here if either the anonymous role or the
  // authenticated role has the 'view uploaded files' permission, since
  // we only need to process each user's file access permission if this
  // is NOT the case.
  // TODO: There is no such thing as "view uploaded files" in Drupal 7 so this
  // needs to be refactored for field access.

  if (!empty($recipients)) {
    $uids = array_keys($recipients);

    // Pre-load the e-mail notification preferences for all users in 1 query.
    $user_preferences = project_issue_notification_user_settings_load_multiple($uids);

    // To save work, only go through a user_load() if we need it.
    if ($check_node_access) {
      $recipients = user_load_multiple($uids);
    }
  }

  // Send notification to each recipient (who can and should get e-mail).
  foreach ($recipients as $uid => $recipient) {
    $language = !empty($recipient->language) ? user_preferred_language($recipient) : language_default();
    $recipient->project_issue_notification = $user_preferences[$uid];

    if ($check_node_access) {
      if (node_access('view', $issue, $recipient)) {
        // If we're enforcing access and the recipient does have it, impersonate them.
        if ($GLOBALS['user']->uid != $uid) {
          if (!isset($original_user)) {
            $original_user = $GLOBALS['user'];
          }
          $GLOBALS['user'] = $recipient;
        }
      }
      else {
        // If we're enforcing access and the recipient doesn't have it, skip them.
        continue;
      }
    }

    // If the recipient is the user that created the update, do not send e-mail
    // if they have disabled notifications for their own updates.
    if (($update_uid == $recipient->uid) && empty($recipient->project_issue_notification['notify_own_updates'])) {
      continue;
    }

    // TODO
    // $display_files = $check_file_perms ? user_access('view uploaded files', $recipient) : TRUE;
    $params['display_files'] = TRUE;
    $params['recipient'] = $recipient;
    drupal_mail('project_issue', 'project_issue_update_notification', $recipient->mail, $language, $params, $from);
  }

  // If needed, restore the user.
  if (isset($original_user)) {
    $GLOBALS['user'] = $original_user;
    drupal_save_session(TRUE);
  }
}

/**
 * Implementation of hook_mail().
 */
function _project_issue_mail($key, &$message, $params) {
  global $base_url;

  switch ($key) {
    case 'project_issue_update_notification':
      $issue      = $params['issue'];
      $project    = $params['project'];
      $comments   = $params['comments'];
      $comment_id = $params['comment_id'];
      $recipient  = $params['recipient'];

      $domain = preg_replace('|.+://([a-zA-Z0-9\._-]+).*|', '\1', $base_url);
      $machine_name = $project->field_project_machine_name[LANGUAGE_NONE][0]['value'];

      // === Set message headers ===
      $message['headers'] += array(
        'Date' => date('r'),
        'X-Mailer' => 'Drupal Project Issue Tracking module (https://drupal.org/project/project_issue)',
        'List-Id' => "$project->title <" . $machine_name . "-issues-$domain>",
        'List-Archive' => '<' . url('project/issues/' . $machine_name, array('absolute' => TRUE)) . '>',
        'List-Subscribe' => '<' . url('project/issues/subscribe-mail/' . $machine_name, array('absolute' => TRUE)) . '>',
        'List-Unsubscribe' => '<' . url('project/issues/subscribe-mail/' . $machine_name, array('absolute' => TRUE)) . '>',
      );
      // If there are comments, set In-Reply-To and References accordingly.
      if (!empty($comments)) {
        $cids = array_keys($comments);
        $cid_key = array_search($comment_id, $cids);
        if ($cid_key === FALSE) {
          // Should not happen, maybe add a warning?
        }
        else {
          $previous_cid = isset($cids[$cid_key - 1]) ? $cids[$cid_key - 1] : '';
          $message['headers']['Message-Id'] = "<type=project&nid=$issue->nid&cid=$comment_id&host=@$domain>";
          $message['headers']['In-Reply-To'] = "<type=project&nid=$issue->nid&host=@$domain>";
          $message['headers']['References'] = "<type=project&nid=$issue->nid&host=@$domain> <type=project&nid=$issue->nid&cid=$previous_cid&host=@$domain> <type=project&nid=$issue->nid&revcount=1&host=@$domain>";
        }
      }
      else {
        // Only original issue in this email.
        $message['headers']['Message-Id'] = "<type=project&nid=$issue->nid&host=@$domain>";
      }

      // === Set message subject ===
      // Construct the appropriate subject based on the user's preferences.
      $subject = array();
      $preferences = $params['recipient']->project_issue_notification;
      if (!empty($preferences['mail_subject_project'])) {
        $subject[] = '[!short_name]';
      }
      if (!empty($preferences['mail_subject_category'])) {
        $subject[] = '[!category]';
      }
      $subject[] = '!title';
      // We just want the category value itself, not the entire field output
      // with a label, etc.
      $category = field_view_value('node', $issue, 'field_issue_category', $issue->field_issue_category[LANGUAGE_NONE][0]);
      $subject_tokens = array(
        '!short_name' => $machine_name,
        '!category' => drupal_render($category),
        '!title' => $issue->title,
      );
      $message['subject'] = strtr(implode(' ', $subject), $subject_tokens);

      // === Set message body ===
      // Create links for the issue (view and update):
      $links[] = t('Issue status update for:');
      $links[] = url("node/$issue->nid", array('absolute' => TRUE));
      $links[] = t('Update issue:');
      $links[] = url("node/$issue->nid/edit", array('absolute' => TRUE));
      $message['body']['links'] = implode("\n", $links);

      // The content of the email is pretty simple if it's the initial post.
      if (empty($comment_id)) {
        $message['body']['metadata'] = project_issue_email_get_issue_metadata($issue);
        $message['body']['body'] = project_issue_email_get_issue_body($issue);
      }
      // Otherwise, generate the email for a new comment.
      else {
        $comment = $comments[$comment_id];
        $nodechanges_field = nodechanges_get_field_name($comment->node_type);
        $message['body']['comment-header'] = project_issue_email_get_comment_header($comment);
        if (!empty($comment->{$nodechanges_field})) {
          $message['body']['metadata-changes'] = project_issue_email_get_metadata_changes($comment);
          $message['body']['file-changes'] = project_issue_email_get_file_changes($comment);
        }
        $message['body']['body'] = project_issue_email_get_comment_body($issue, $comment);
        $message['body']['metadata'] = project_issue_email_get_issue_metadata($issue);
      }
      break;
  }
}

/**
 * Generate an ASCII representation of the current issue metadata.
 *
 * @param object $issue
 *   The fully-loaded node object for the revision of the issue we're
 *   generating a notification email for.
 *
 * @return string
 *   The current issue metadata values.
 */
function project_issue_email_get_issue_metadata($issue) {
  $cache = &drupal_static(__FUNCTION__);
  if (!isset($cache[$issue->nid][$issue->vid])) {
    $output = t('Current issue values:') . "\n";
    $metadata = node_view($issue, 'nodechanges');
    // Ignore a few things from the view mode we don't want in email.
    unset($metadata['update_link']);
    unset($metadata['jump_links']);
    unset($metadata['links']);
    // Also, we handle the body separately, so ignore that, too.
    unset($metadata['body']);
    // Add the author, if it would be shown normally.
    if (variable_get('node_submitted_' . $issue->type, 1)) {
      $author = user_load($issue->uid);
      $metadata['author']['#title'] = t('Author');
      $metadata['author']['#items'][0]['value'] = $author->name;
      $metadata['author'][0]['#markup'] = check_plain($author->name);
    }

    // This is slightly a hack, but first we walk through all the fields and
    // find the length of the longest label so we can pad everything
    // accordingly to let the values line up vertically.
    $max_label_length = 0;
    foreach (element_children($metadata) as $key) {
      if (isset($metadata[$key]['#title'])) {
        $max_label_length = max($max_label_length, strlen($metadata[$key]['#title']));
      }
    }

    // Instead of just calling drupal_render(), which gives us a ton of divs
    // and other junk we don't want, and might ignore field labels (based on
    // the site configuration), we just manually render this in ASCII and
    // always include the label.
    foreach (element_children($metadata) as $key) {
      if ($key === 'follow_link') {
        continue;
      }
      $output .= str_pad($metadata[$key]['#title'] . ':', $max_label_length+2);
      // We render multi-valued fields with a label on a separate line and
      // indent each value on its own line.
      if (count($metadata[$key]['#items']) > 1) {
        $output .= "\n";
        foreach (element_children($metadata[$key]) as $subkey) {
          $output .= '  ' . drupal_render($metadata[$key][$subkey]) . "\n";
        }
      }
      // Otherwise, just print the value inline with the label.
      else {
        $output .= drupal_render($metadata[$key][0]) . "\n";
      }
    }
    $cache[$issue->nid][$issue->vid] = $output;
  }
  return $cache[$issue->nid][$issue->vid];
}

/**
 * Generate an ASCII representation of the current issue summary/body.
 *
 * @param object $issue
 *   The fully-loaded node object for the revision of the issue we're
 *   generating a notification email for.
 *
 * @return string
 *   The current issue summary/body.
 */
function project_issue_email_get_issue_body($issue) {
  $cache = &drupal_static(__FUNCTION__);
  if (!isset($cache[$issue->nid][$issue->vid])) {
    $field = field_info_field('body');
    $langcode = field_is_translatable('node', $field) ? entity_language('node', $issue) : LANGUAGE_NONE;
    $issue_body = (!empty($issue->body[$langcode][0])) ? $issue->body[$langcode][0] : array('value' => '');
    if (isset($issue_body['format'])) {
      $issue_text = check_markup($issue_body['value'], $issue_body['format']);
    }
    else {
      $issue_text = check_plain($issue_body['value']);
    }
    $cache[$issue->nid][$issue->vid] = $issue_text;
  }
  return $cache[$issue->nid][$issue->vid];
}

/**
 * Generate a header identifying an issue comment.
 *
 * This includes the comment sequence number (not the comment ID), timestamp,
 * and the user who posted the comment.
 *
 * @param object $comment
 *   The fully-loaded comment object to generate the header for.
 *
 * @return string
 *   The comment header to include in the notificaiton email.
 */
function project_issue_email_get_comment_header($comment) {
  $header = '#' . project_issue_get_comment_thread_id($comment) . ' -- ';
  $header .= format_date($comment->created) . ' : ';
  $header .= $comment->name . "\n";
  $header .= url("node/$comment->nid", array('fragment' => "comment-$comment->cid", 'absolute' => TRUE));
  return $header;
}

/**
 * Generate an ASCII representation of issue metadata changes.
 *
 * Whenever an issue is updated, the Node Changes module is used to
 * auto-generate a comment about the metadata changes. We use this data to
 * render what fields have been changed with this update.
 *
 * @param object $comment
 *   The fully-loaded comment object that was auto-generated for the issue
 *   update we're generating a notification email for.
 *
 * @return string
 *   String representation of the metadata changes from a given issue update.
 *
 * @see theme_nodechanges_comment_changes()
 */
function project_issue_email_get_metadata_changes($comment) {
  $cache = &drupal_static(__FUNCTION__);
  if (!isset($cache[$comment->nid][$comment->cid])) {
    $output = "\n" . t('Issue changes:') . "\n";
    $variables = array('comment' => $comment);
    $changes = theme('nodechanges_comment_changes', $variables);
    if (empty($changes)) {
      $changes = t(' None');
    }
    $cache[$comment->nid][$comment->cid] = $output . $changes;
  }
  return $cache[$comment->nid][$comment->cid];
}

/**
 * Generate an ASCII representation of issue file changes.
 *
 * @param object $comment
 *   The fully-loaded comment object that was auto-generated for the issue
 *   update we're generating a notification email for, or NULL if this is
 *   an initial post.
 *
 * @return string
 *   String representation of the file changes from a given issue update.
 */
function project_issue_email_get_file_changes($comment) {
  $cache = &drupal_static(__FUNCTION__);
  if (!isset($cache[$comment->nid][$comment->cid])) {
    $files = array();
    $output = '';
    foreach ($comment->field_issue_changes[LANGUAGE_NONE] as $key => $change) {
      if ($change['field_name'] == 'field_issue_files') {
        $files = nodechanges_get_file_changes($change);
        foreach ($files as $key => $file) {
          $output .= ' ' . str_pad(ucfirst($file->file_status) . ':', 14) . file_create_url($file->uri) . ' (' . format_size($file->filesize) . ")\n";
        }
        break;
      }
    }
    // Add our label if there are changes to render.
    if (!empty($output)) {
      $output = "\n" . t("File changes:") . "\n" . $output;
    }
    $cache[$comment->nid][$comment->cid] = $output;
  }
  return $cache[$comment->nid][$comment->cid];
}

/**
 * Generate an ASCII representation of the body of a comment.
 *
 * @param object $issue
 *   The fully-loaded node object for the revision of the issue we're
 *   generating a notification email for.
 * @param object $comment
 *   The fully-loaded comment object that was added to the issue (either as a
 *   raw comment or one that was auto-generated by an issue update) that we're
 *   generating a notification email for.
 *
 * @return string
 *   String representation of the comment body for a notification email.
 */
function project_issue_email_get_comment_body($issue, $comment) {
  if (empty($comment->comment_body)){
    return '';
  }

  $cache = &drupal_static(__FUNCTION__);
  if (!isset($cache[$issue->nid][$comment->cid])) {
    $field = field_info_field('comment_body');
    $langcode = field_is_translatable('comment', $field) ? entity_language('comment', $comment) : LANGUAGE_NONE;
    $comment_body = $comment->comment_body[$langcode][0];
    if (isset($comment_body['format'])) {
      $comment_text = check_markup($comment_body['value'], $comment_body['format']);
    }
    else {
      $comment_text = check_plain($comment_body['value']);
    }
    $cache[$issue->nid][$comment->cid] = $comment_text;
  }
  return $cache[$issue->nid][$comment->cid];
}

/**
 * Return a list of recipients for issue e-mail notifications.
 *
 * @param object $issue
 *   The fully-loaded issue node to generate the notifications for.
 * @param object $project
 *   The fully-loaded project node the issue belongs to.
 * @param array $comments
 *   Array of issue comments (if any).
 *
 * @return array
 *   Array of pseudo user objects that should get notified, keyed by user ID,
 *   with uid, name and mail properties in each object.
 *
 * @see project_issue_email_notify()
 */
function project_issue_get_email_recipients($issue, $project, $comments) {
  // Array of user IDs for the users that consider this their "own" issue.
  $uids = array();

  // If flag integration is present, the list of users for 'own' issues will
  // be those that flagged the issue.
  $follow_flag = project_issue_get_follow_flag($issue);
  if (!empty($follow_flag)) {
    // Retrieve all users who flagged the issue.
    $flag_contents = flag_get_content_flags('node', $issue->nid, $follow_flag);
    $uids = array_keys($flag_contents);
  }
  // Without flag integration, we have to do this manually.
  else {
    // The node author.
    if (!empty($issue->uid)) {
      $uids[$issue->uid] = $issue->uid;
    }
    // The currently assigned user (if any).
    if (!empty($issue->field_issue_assigned[LANGUAGE_NONE][0]['target_id'])) {
      $assigned_uid = $issue->field_issue_assigned[LANGUAGE_NONE][0]['target_id'];
      $uids[$assigned_uid] = $assigned_uid;
    }
    // Everyone who posted a comment. Thanks to nodechanges, this will include
    // everyone who edited the issue to update it.
    foreach ($comments as $cid => $comment) {
      if (!empty($comment->uid)) {
        $uids[$comment->uid] = $comment->uid;
      }
    }
  }

  // Initialize the recipient list.  After compilation, the list will include
  // users that are:
  //  - subscribed to all issues of the project
  //  - subscribed to "own" issues of the project
  //  - subscribed to all issues by default (global default)
  //  - subscribed to "own" issues by default (global default)
  // Note that "own" changes meaning depending on if flag.module is enabled
  // and configured for following issues.
  $recipients = array();

  $filter_or = db_or();
  // 'All' level.
  $filter_or->condition('pi.level', PROJECT_ISSUE_NOTIFICATION_ALL);
  // 'Own' level using the list of users attached to the issue.
  if (!empty($uids)) {
    $filter_or->condition(
      db_and()
        ->condition('pi.level', PROJECT_ISSUE_NOTIFICATION_OWN)
        ->condition('u.uid', $uids, 'IN')
    );
  }

  $query = db_select('project_issue_notification_project', 'pi');
  $query->innerJoin('users', 'u', 'pi.uid = u.uid');
  $query
    ->condition('u.status', 1)
    ->condition('pi.nid', $project->nid)
    ->condition($filter_or);
  $query->addField('pi', 'uid');
  $query->addField('u', 'name');
  $query->addField('u', 'mail');
  $result = $query->execute();

  foreach ($result as $account) {
    $recipients[$account->uid] = $account;
  }

  // Pull users that want global notifications if they haven't defined a
  // per-project setting for this project.
  $query = db_select('project_issue_notification_global', 'pi');
  $query->leftJoin('project_issue_notification_project', 'pinp', 'pi.uid = pinp.uid AND pinp.nid = :pinp_nid', array(':pinp_nid' => $project->nid));
  $query->innerJoin('users', 'u', 'pi.uid = u.uid');
  $query
    ->condition('u.status', 1)
    ->isNull('pinp.level')
    ->condition($filter_or);
  $query->addField('pi', 'uid');
  $query->addField('u', 'name');
  $query->addField('u', 'mail');
  $result = $query->execute();
  foreach ($result as $account) {
    $recipients[$account->uid] = $account;
  }

  return $recipients;
}
