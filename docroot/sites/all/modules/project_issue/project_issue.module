<?php

/**
 * @file
 * Code for the Project Issue Tracking module.
 */

/// Default age in days of issues to auto close.
define('PROJECT_ISSUE_AUTO_CLOSE_DAYS', 14);
/// Project issue state = fixed.
define('PROJECT_ISSUE_STATE_FIXED', 2);
/// Project issue state = closed.
define('PROJECT_ISSUE_STATE_CLOSED', 7);

/**
 * Project issue notification level: No notification emails.
 */
define('PROJECT_ISSUE_NOTIFICATION_NONE', 0);

/**
 * Project issue notification level: Own/flagged issues.
 */
define('PROJECT_ISSUE_NOTIFICATION_OWN', 1);

/**
 * Project issue notification level: All issues.
 */
define('PROJECT_ISSUE_NOTIFICATION_ALL', 2);

/**
 * Implementation of hook_ctools_plugin_directory().
 */
function project_issue_ctools_plugin_directory($module, $plugin) {
  if ($module == 'sampler') {
    switch ($plugin) {
      case 'metric':
        return 'metrics';
    }
  }
  if ($module == 'entityreference') {
    return 'plugins/entityreference_' . $plugin;
  }
}

/**
 * Implementation of hook_search_api_alter_callback_info().
 */
function project_issue_search_api_alter_callback_info() {
  $callbacks = array(
    'project_issue_alter_participants' => array(
      'name' => t('Participants'),
      'description' => t('Add field for node and comment authors.'),
      'class' => 'ProjectIssueAlterParticipants',
    ),
  );
  if (module_exists('flag_tracker')) {
    foreach (project_issue_issue_node_types() as $bundle_name) {
      if (flag_tracker_get_tracker_flag($bundle_name)) {
        $callbacks['project_issue_alter_followers'] = array(
          'name' => t('Issue followers'),
          'description' => t('Add field for issue followers.'),
          'class' => 'ProjectIssueAlterFollowers',
        );
        break;
      }
    }
  }
  return $callbacks;
}

function project_issue_menu() {
  $items = array();

  $includes = drupal_get_path('module', 'project_issue') . '/includes';

  // Project issue notification.
  $items['project/issues/subscribe-mail/%project'] = array(
    'title' => 'Subscribe',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('project_issue_notification_project_form', 3),
    'access callback' => 'project_issue_menu_access',
    'access arguments' => array('auth'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'includes/notification.inc',
  );
  $items['user/%user/project-issue'] = array(
    'title' => 'Notifications',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('project_issue_notification_user_form', 1),
    'access callback' => 'user_edit_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'file' => 'includes/notification.inc',
  );
  $items['user/%user/project-issue/delete/%project'] = array(
    'page callback' => 'project_issue_notification_user_delete',
    'page arguments' => array(1, 4),
    'access callback' => 'user_edit_access',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK,
    'file' => 'includes/notification.inc',
  );

  // Administrative pages
  $items['admin/config/project/project-issue-settings'] = array(
    'title' => 'Project issue settings',
    'description' => 'Specify where attachments to issues should be stored on your site, and what filename extensions should be allowed.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('project_issue_settings_form'),
    'access arguments' => array('administer projects'),
    'weight' => 1,
    'type' => MENU_NORMAL_ITEM,
    'file' => 'includes/admin.settings.inc',
  );

  // Autocomplete paths.

  // Autocomplete a comma-separated list of projects that have issues enabled.
  $items['project/autocomplete/issue/project'] = array(
    'page callback' => 'project_issue_autocomplete_issue_project',
    'access callback' => 'project_issue_menu_access',
    'access arguments' => array('any'),
    'file' => 'autocomplete.inc',
    'file path' => $includes,
    'type' => MENU_CALLBACK,
  );

  // Autocomplete a comma-separated list of projects from all issues a user
  // has either submitted or commented on.
  $items['project/autocomplete/issue/user/%'] = array(
    'page callback' => 'project_issue_autocomplete_user_issue_project',
    'page arguments' => array(4, 5),
    'access callback' => 'project_issue_menu_access',
    'access arguments' => array('any'),
    'file' => 'autocomplete.inc',
    'file path' => $includes,
    'type' => MENU_CALLBACK,
  );

  // Autocomplete a comma-separated list of projects a user owns.
  $items['project/autocomplete/issue/owner/%'] = array(
    'page callback' => 'project_issue_autocomplete_project_user',
    'page arguments' => array(4, 5),
    'access callback' => 'project_issue_menu_access',
    'access arguments' => array('any'),
    'file' => 'autocomplete.inc',
    'file path' => $includes,
    'type' => MENU_CALLBACK,
  );

  // Autocomplete an issue nid from a user entered node ID or issue title.
  $items['project/autocomplete/issues/nodereference'] = array(
    'page callback' => 'project_issue_autocomplete_issues_nodereference',
    'access callback' => 'project_issue_menu_access',
    'access arguments' => array('any'),
    'file' => 'autocomplete.inc',
    'file path' => $includes,
    'type' => MENU_CALLBACK,
  );

  // Adding a project_issue node with the parent project specified in the URL.
  foreach (project_issue_issue_node_types() as $issue_type) {
    $type_url_str = str_replace('_', '-', $issue_type);
    $items['node/add/' . $type_url_str . '/%project'] = array(
      'page callback' => 'project_issue_node_add',
      'page arguments' => array($issue_type, 3),
      'access callback' => 'node_access',
      'access arguments' => array('create', $issue_type),
      'file' => 'includes/issue_node_add.inc',
      'type' => MENU_CALLBACK,
    );
  }

  return $items;
}

/**
 * Implementation of hook_menu_alter().
 *
 * A project_issue node requires a parent project, and also that a "component"
 * of that project is specified.  In order to have the pull-down for the
 * component be properly populated, we hook 'node/add/project-issue' and
 * have the user select a project there, and then a form on
 * 'node/add/project-issue/<projectname>' has the component widget properly
 * constructed.
 */
function project_issue_menu_alter(&$items) {
  foreach (project_issue_issue_node_types() as $issue_type) {
    $type_url_str = str_replace('_', '-', $issue_type);
    $items['node/add/' . $type_url_str]['page callback'] = 'drupal_get_form';
    $items['node/add/' . $type_url_str]['page arguments'] = array('project_issue_pick_project_form', $issue_type);
    $items['node/add/' . $type_url_str]['file'] = 'issue_node_add.inc';
    $items['node/add/' . $type_url_str]['file path'] = drupal_get_path('module', 'project_issue') . '/includes';
  }

  // Override the taxonomy autocomplete route for any taxonomy term fields
  // with the naming scheme "taxonomy_vocabulary_[vid]" where the vocabulary
  // they reference has project issue enabled. This allows us to override the
  // sorting for the data returned.
  foreach (taxonomy_get_vocabularies() as $vid => $vocabulary) {
    if (variable_get('project_issue_taxonomy_vocabulary_issue_queue_' . $vid, 0) === 'autocomplete') {
      $items['taxonomy/autocomplete/taxonomy_vocabulary_' . $vid] = array(
        'title' => 'Issue tags Autocomplete',
        'page callback' => 'project_issue_issue_tag_autocomplete',
        'access arguments' => array('access content'),
        'page arguments' => array((string) $vid),
        'type' => MENU_CALLBACK,
      );
      $items['admin/views/ajax/autocomplete/taxonomy/' . $vid] = $items['taxonomy/autocomplete/taxonomy_vocabulary_' . $vid];
    }
  }
}

/**
 * Determine access to a given type of menu item.
 *
 * @param $type
 *   Type of menu item to check access for, can be 'any' if the current user
 *   can access any issues, or 'auth' if the current user is authenticated and
 *   can accses any issues.
 */
function project_issue_menu_access($type) {
  global $user;
  if ($type == 'auth' && empty($user->uid)) {
    return FALSE;
  }
  return user_access('access content');
}

/**
 * Implementation of hook_theme().
 */
function project_issue_theme() {
  return array(
    'project_issue_issue_link' => array(
      'variables' => array(
        'node' => NULL,
        'comment_id' => NULL,
        'comment_number' => NULL,
        'include_assigned' => FALSE,
      ),
    ),
    'project_issue_issue_update_link' => array(
      'template' => 'theme/project-issue-issue-update-link',
      'variables' => array(
        'node' => NULL,
      ),
    ),
    'project_issue_issue_jump_links' => array(
      'template' => 'theme/project-issue-issue-jump-links',
      'variables' => array(
        'node' => NULL,
      ),
    ),
    'project_issue_issue_cockpit' => array(
      'template' => 'theme/project-issue-issue-cockpit',
      'file' => 'includes/issue_cockpit.inc',
      'variables' => array(
        'node' => NULL,
      ),
    ),
    'project_issue_notification_projects_table' => array(
      'file' => 'includes/notification.inc',
      'render element' => 'element',
    ),
    'project_issue_query_result_links' => array(
      'variables' => array(
        'links' => array(),
      ),
    ),
    'project_issue_auto_close_message' => array(
      'variables' => array(
        'auto_close_days' => NULL,
      ),
    ),
  );
}

/**
 * Implements hook_views_api().
 */
function project_issue_views_api() {
  return array(
    'api' => '3.0',
    'path' => drupal_get_path('module', 'project_issue') . '/views',
  );
}

/**
 * Implements hook_ctools_plugin_api().
 */
function project_issue_ctools_plugin_api($module, $api) {
  if ($module == 'field_group' && $api == 'field_group') {
    return array('version' => 1);
  }
}

/**
 * Implements hook_cron().
 */
function project_issue_cron() {
  // Automatically close issues marked as fixed for a specified number of days
  // and add a comment to each documenting the change.
  $auto_close_days = variable_get('project_issue_auto_close_days', PROJECT_ISSUE_AUTO_CLOSE_DAYS);
  $no_activity_limit = time() - $auto_close_days * 24 * 60 * 60;

  // Select all fixed issues which have not changed since the required date.
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'node')
    ->entityCondition('bundle', project_issue_issue_node_types())
    ->propertyCondition('changed', $no_activity_limit, '<')
    ->fieldCondition('field_issue_status', 'value', PROJECT_ISSUE_STATE_FIXED)
    ->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT');
  $result = $query->execute();

  if (!empty($result['node'])) {
    $comment = theme('project_issue_auto_close_message', array('auto_close_days' => $auto_close_days));
    $account = user_load(variable_get('project_issue_followup_user', 0));

    foreach (node_load_multiple(array_keys($result['node'])) as $node) {
      // Additionally, only close the issue if there have been no more comments
      // since the required date.
      if ($node->last_comment_timestamp < $no_activity_limit) {
        $node->field_issue_status[LANGUAGE_NONE][0]['value'] = PROJECT_ISSUE_STATE_CLOSED;
        $node->nodechanges_uid = $account->uid;
        $node->nodechanges_comment['comment_body'][LANGUAGE_NONE][0] = array(
          'value' => $comment,
          'format' => filter_default_format($account),
        );
        $node->nodechanges_comment_attributes = array(
          'project_issue_no_email' => TRUE,
        );
        node_save($node);
      }
    }
  }
}

function project_issue_form_project_issue_issue_cockpit_searchbox_alter(&$form) {
  // Since we're using a GET #action for this searchbox, unset the FAPI
  // cruft we don't want to see in the URL.
  unset($form['form_build_id']);
  unset($form['form_id']);
  unset($form['form_token']);
}

/**
 * Implements hook_node_presave().
 *
 * Adjust timestamps when running import code.
 */
function project_issue_node_presave($node) {
  if (isset($node->_project_issue_changed_timestamp)) {
    $node->changed = $node->_project_issue_changed_timestamp;
    $node->timestamp = $node->_project_issue_changed_timestamp;
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter() for node_form().
 *
 * Alters issue node forms to rebuild the form whenever the project changes.
 */
function project_issue_form_node_form_alter(&$form, &$form_state, $form_id) {
  // For project nodes, add custom validation for the 'Components' field.
  if (project_node_is_project($form['#node'])) {
    $form['#validate'][] = 'project_issue_field_project_components_validate';
    return;
  }
  // If not a project node, we're only interested in issue forms.
  if (!project_issue_node_is_issue($form['#node']) || empty($form['field_project'])) {
    return;
  }

  // Node preview and diff.module both use $form['prefix'], so we can't just
  // clobber it here. However, we still want our div to be the first thing, so
  // that *everything* gets replaced when you change the project. Otherwise,
  // once you preview, if you change the project, you get a second copy of the
  // preview text (the one from the original page load, and then the one
  // included in the form that we're replacing with). So, we still want our
  // div to be the outer-most thing, but we need to preserve $form['prefix']
  // and include it if it exists.
  $prefix = !empty($form['#prefix']) ? $form['#prefix'] : '';
  $form['#prefix'] = '<div id="project-issue-ajax-form">' . $prefix;

  if (empty($form['#suffix'])) {
    $form['#suffix'] = '';
  }
  $form['#suffix'] .= '</div>';
  $form['field_project'][LANGUAGE_NONE][0]['target_id']['#ajax'] = array(
    'callback' => 'project_issue_form_change_project',
    'wrapper' => 'project-issue-ajax-form',
  );
  $form['field_project'][LANGUAGE_NONE][0]['target_id']['#element_validate'][] = 'project_issue_field_project_validate';

  // Include the site-wide help text (if set) at the top of the create form.
  if (empty($form['#node']->nid)) {
    $global_help = variable_get('project_issue_site_help', '');
    if (!empty($global_help)) {
      $form['global_issue_help_text'] = array(
        '#prefix' => '<div class="messages status site">',
        '#markup' => filter_xss_admin($global_help),
        '#weight' => -10,
        '#suffix' => '</div>',
      );
    }
  }

  if (!empty($form_state['node']->field_project[LANGUAGE_NONE][0]['target_id'])) {
    $project = node_load($form_state['node']->field_project[LANGUAGE_NONE][0]['target_id']);
    project_issue_set_breadcrumb($form_state['node'], $project);
    // Include the project_specific new issue help text on the create form.
    if (empty($form['#node']->nid)) {
      if (!empty($project->field_project_issue_guidelines)) {
        $form['project_specific_help_text'] = array(
          '#prefix' => '<div class="messages status project">',
          '#markup' => check_markup($project->field_project_issue_guidelines[LANGUAGE_NONE][0]['value'], $project->field_project_issue_guidelines[LANGUAGE_NONE][0]['format']),
          '#weight' => -8,
          '#suffix' => '</div>',
        );
      }
    }
  }

  if (!empty($form['#node']->nodechanges_in_block)) {
    // Collapse issue metadata & relations.
    $form['#groups']['group_issue_metadata']->format_settings['formatter'] = 'collapsed';
    $form['#groups']['group_issue_relations']->format_settings['formatter'] = 'collapsed';

    // Remove vertical tabs and issue comment description.
    hide($form['additional_settings']);
    // Ensure checkbox options, especially status, are preserved.
    foreach (element_children($form['options']) as $key) {
      $form['options'][$key]['#value'] = $form['options'][$key]['#default_value'];
    }

    // Remove delete button to prevent risky misclicks.
    $form['actions']['delete']['#access'] = FALSE;
  }
}

/**
 * Ajax callback for issue node forms.
 * We return the entire form.
 */
function project_issue_form_change_project($form, $form_state) {
  return $form;
}

/**
 * Validation callback for the field_project_components field element.
 */
function project_issue_field_project_components_validate($element, &$form_state) {
  // Ensure we sanitize the component.
  if (!empty($form_state['values']['field_project_components'][LANGUAGE_NONE])) {
    foreach ($form_state['values']['field_project_components'][LANGUAGE_NONE] as $key => $component) {
      // Only work on numeric values: ignore the value that arises from the
      // 'add more' button.
      if (is_numeric($key)) {
        $form_state['values']['field_project_components'][LANGUAGE_NONE][$key]['value'] = check_plain($form_state['values']['field_project_components'][LANGUAGE_NONE][$key]['value']);
      }
    }
  }
}

/**
 * Validation callback for the field_project field element.
 */
function project_issue_field_project_validate($element, &$form_state) {
  // Always update the node entity saved in form_state in order to allow other
  // fields to be populated with correct values (e.g. 'field_issue_assigned').
  $form_state['node']->field_project[LANGUAGE_NONE][0]['target_id'] = $form_state['values']['field_project'][LANGUAGE_NONE][0]['target_id'];
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Project issue adjustments to the field edit form.
 *
 * Some of the fields implemented by project issue have certain settings that
 * the module depends on, so force those here.
 */
function project_issue_form_field_ui_field_edit_form_alter(&$form) {
  switch ($form['#field']['field_name']) {
    case 'field_project_has_issue_queue':
      $form['field']['#access'] = FALSE;
      $form['instance']['widget']['#access'] = FALSE;
      $form['instance']['required']['#value'] = FALSE;
      $form['instance']['required']['#access'] = FALSE;
      break;
    case 'field_issue_changes':
      $form['field']['#access'] = FALSE;
      $form['instance']['widget']['#access'] = FALSE;
      $form['instance']['default_value_widget']['#access'] = FALSE;
      $form['instance']['required']['#value'] = TRUE;
      $form['instance']['required']['#access'] = FALSE;
      break;
  }
}

/**
 * Implements hook_permission().
 */
function project_issue_permission() {
  return array(
    'assign and be assigned project issues' => array(
      'title' => t('Assign and be assigned project issues'),
      'description' => t('Allow users to assign issues to other users that have been granted this same permission.')
    ),
  );
}

/**
 * Implement hook_project_permission_info()
 */
function project_issue_project_permission_info($project = NULL) {
  return array(
    'maintain issues' => array(
      'title' => t('Maintain issues'),
      'description' => t('Allows a user to assign issues to other issue maintainers for this project.'),
    ),
  );
}

/**
 * Implement hook_project_maintainer_save()
 */
function project_issue_project_maintainer_save($nid, $uid, $permissions = array()) {
  db_merge('project_issue_project_maintainer')
    ->key(array('nid' => $nid, 'uid' => $uid))
    ->fields(array(
      'maintain_issues' => $permissions['maintain issues']
    ))
    ->execute();
}

/**
 * Implement hook_project_maintainer_remove()
 */
function project_issue_project_maintainer_remove($nid, $uid) {
  db_query("DELETE FROM {project_issue_project_maintainer} WHERE nid = :nid and uid = :uid", array(':nid' => $nid, ':uid' => $uid));
}

/**
 * Implement hook_project_maintainer_project_load().
 */
function project_issue_project_maintainer_project_load($nid, &$maintainers) {
  $result = db_query('SELECT u.name, pipm.* FROM {project_issue_project_maintainer} pipm INNER JOIN {users} u ON pipm.uid = u.uid WHERE pipm.nid = :nid ORDER BY u.name', array(':nid' => $nid));
  foreach ($result as $maintainer) {
    if (empty($maintainers[$maintainer->uid])) {
      $maintainers[$maintainer->uid]['name'] = $maintainer->name;
    }
    $maintainers[$maintainer->uid]['permissions']['maintain issues'] = $maintainer->maintain_issues;
  }
}

/**
 * Get the possible issue categories.
 */
function project_issue_categories() {
  $category_field = field_read_field('field_issue_category');
  if (!empty($category_field['settings']['allowed_values'])) {
    return $category_field['settings']['allowed_values'];
  }
  return array();
}

/**
 * Loads per-user account settings for project issue notifications.
 *
 * @param $account
 *   A user account object to attach project issue notification settings to.
 *   Required properties:
 *   - uid: The ID of the user account.
 *   Attached properties:
 *   - project_issue_notification: An associative array containing:
 *     - level: An integer denoting the user's global issue notification level:
 *       - PROJECT_ISSUE_NOTIFICATION_NONE
 *       - PROJECT_ISSUE_NOTIFICATION_OWN
 *       - PROJECT_ISSUE_NOTIFICATION_ALL
 *
 * @see project_issue_notification_user_settings_load_multiple()
 */
function project_issue_notification_user_settings_load(&$account) {
  $preferences = project_issue_notification_user_settings_load_multiple(array($account->uid));
  $account->project_issue_notification = $preferences[$account->uid];
}

/**
 * Loads per-account issue notifications preferences for a set of users.
 *
 * @param array $uids
 *   Array of user IDs to load preferences for.
 *
 * @return array
 *   An array of associative preference arrays indexed by uid.
 *
 * @see project_issue_notification_user_settings_load()
 */
function project_issue_notification_user_settings_load_multiple($uids) {
  // Setup defaults.
  $defaults = array(
    'level' => PROJECT_ISSUE_NOTIFICATION_NONE,
    'notify_own_updates' => TRUE,
    'mail_subject_project' => TRUE,
    'mail_subject_category' => TRUE,
  );
  $user_settings = array();
  $result = db_query('SELECT uid, level, notify_own_updates, mail_subject_project, mail_subject_category FROM {project_issue_notification_global} WHERE uid IN (:uids)', array(':uids' => $uids))->fetchAll(PDO::FETCH_ASSOC);
  foreach ($result as $settings) {
    $uid = $settings['uid'];
    unset($settings['uid']);
    $user_settings[$uid] = array_merge($defaults, $settings);
  }
  // Fill in defaults for any users that are still missing their preferences.
  $missing_uids = array_diff($uids, array_keys($user_settings));
  foreach ($missing_uids as $uid) {
    $user_settings[$uid] = $defaults;
  }
  return $user_settings;
}

/**
 * Saves per-user account settings for project issue notification.
 *
 * @param $account
 *   A user account object containing at least the properties:
 *   - uid: The ID of the user account.
 *   - project_issue_notification: An associative array containing:
 *     - level: An integer denoting the user's global issue notification level.
 *       - PROJECT_ISSUE_NOTIFICATION_NONE
 *       - PROJECT_ISSUE_NOTIFICATION_OWN
 *       - PROJECT_ISSUE_NOTIFICATION_ALL
 *     - notify_own_updates: A Boolean indicating if the wants to receive
 *       notifications for their own issue updates.
 *     - mail_subject_category: A Boolean indicating whether the user wants the
 *       issue category (bug, feature, etc) in the subject of e-mails.
 *     - mail_subject_project: A Boolean indicating whether the user wants the
 *       project name in the subject of e-mails.
 *
 * @see project_issue_notification_user_settings_load()
 */
function project_issue_notification_user_settings_save($account) {
  db_merge('project_issue_notification_global')
    ->key(array('uid' => $account->uid))
    ->fields(array(
      'level' => $account->project_issue_notification['level'],
      'notify_own_updates' => $account->project_issue_notification['notify_own_updates'],
      'mail_subject_category' => $account->project_issue_notification['mail_subject_category'],
      'mail_subject_project' => $account->project_issue_notification['mail_subject_project'],
    ))
    ->execute();
}

/**
 * Loads the project issue notification settings for a user account.
 *
 * @param $uid
 *   The ID of a user account.
 * @param $nid
 *   The node ID of a project node.
 *
 * @return
 *   An integer denoting the user's project issue notification level:
 *   - PROJECT_ISSUE_NOTIFICATION_NONE
 *   - PROJECT_ISSUE_NOTIFICATION_OWN
 *   - PROJECT_ISSUE_NOTIFICATION_ALL
 *
 * @see project_issue_notification_project_setting_save()
 */
function project_issue_notification_project_setting_load($uid, $nid) {
  $level = db_query('SELECT level FROM {project_issue_notification_project} WHERE uid = :uid AND nid = :nid', array(
    ':uid' => $uid,
    ':nid' => $nid,
  ))->fetchField();
  return ($level !== FALSE ? $level : PROJECT_ISSUE_NOTIFICATION_NONE);
}

/**
 * Saves project notification settings for a user account.
 *
 * @param $uid
 *   The ID of a user account.
 * @param $nid
 *   The node ID of a project node.
 * @param $level
 *   An integer denoting the user's project issue notification level:
 *   - PROJECT_ISSUE_NOTIFICATION_NONE
 *   - PROJECT_ISSUE_NOTIFICATION_OWN
 *   - PROJECT_ISSUE_NOTIFICATION_ALL
 *
 * @see project_issue_notification_project_setting_load()
 */
function project_issue_notification_project_setting_save($uid, $nid, $level) {
  db_merge('project_issue_notification_project')
    ->key(array(
      'uid' => $uid,
      'nid' => $nid,
    ))
    ->fields(array(
      'level' => $level,
    ))
    ->execute();
}

/**
 * Removes the project notification settings for a given user and project.
 *
 * @param $uid
 *   The ID of a user account.
 * @param $nid
 *   The node ID of a project node.
 */
function project_issue_notification_project_setting_delete($uid, $nid) {
  db_delete('project_issue_notification_project')
    ->condition('uid', $uid)
    ->condition('nid', $nid)
    ->execute();
}

/**
 * Implements hook_user_cancel().
 */
function project_issue_user_cancel($edit, $account, $method) {
  return project_issue_user_delete($account);
}

/**
 * Implements hook_user_delete().
 */
function project_issue_user_delete($account) {
  // Delete project maintainer assignments and all e-mail notification settings
  // in case a user account is deleted or disabled/banned.
  db_delete('project_issue_notification_global')->condition('uid', $account->uid)->execute();
  db_delete('project_issue_notification_project')->condition('uid', $account->uid)->execute();
  db_delete('project_issue_project_maintainer')->condition('uid', $account->uid)->execute();
}

/**
 * Implementation of hook_mail(). (stub function)
 */
function project_issue_mail($key, &$message, $params) {
  module_load_include('inc', 'project_issue', 'includes/mail');
  return _project_issue_mail($key, $message, $params);
}

/**
 * Implements hook_entity_info_alter().
 */
function project_issue_entity_info_alter(&$info) {
  $info['node']['view modes']['issuemetadata'] = array(
    'label' => t('Project issue meta data table'),
    'custom settings' => TRUE,
  );
  $info['taxonomy_term']['uri callback'] = 'project_issue_taxonomy_term_uri';
}

/**
 * Return the issue metadata fields for a given issue node.
 *
 * This relies on the 'issuemetadata' view mode for issue nodes.
 *
 * @param stdClass $issue
 *   A fully-loaded issue node object to build metadata for.
 *
 * @return array
 *   An array of issue metadata fields, suitable for use with drupal_render().
 *
 * @see drupal_render()
 * @see project_issue_entity_info_alter()
 */
function project_issue_metadata_build($issue) {
  if (empty($issue) || !project_issue_node_is_issue($issue)) {
    return array();
  }
  // Mostly, we just want the full node_view() using the right view mode.
  $build = node_view(clone($issue), 'issuemetadata');
  // However, we need to unset/hide some things usually injected into nodes
  // that isn't issue metadata itself.
  unset($build['#theme']);
  unset($build['#contextual_links']);
  $build['links']['#access'] = FALSE;
  return $build;
}

/**
 * Page callback function for the "Issues" subtab at the site-wide search page.
 */
function project_issue_search_page() {
  $view_info = variable_get('project_issue_search_issues_view', 'project_issue_search_all:default');
  $view_parts = explode(':', $view_info);
  $view = views_get_view($view_parts[0]);
  $view->override_path = 'search/issues';
  $output .=  $view->preview($view_parts[1]);
  return $output;
}

/**
 * Submit handler to adjust project issue metadata when comments are mass edited.
 */
function project_issue_comment_mass_update($form_id, $form_values) {
  // This filters non-numeric values, then empty values.
  $cids = array_filter(array_filter($form_values['comments'], 'is_numeric'));
  $issue_comments = db_query("SELECT n.nid, c.cid FROM {node} n INNER JOIN {comments} c ON n.nid = c.nid WHERE c.cid IN (" . implode(', ', $cids) . ") AND n.type = 'project_issue'");
  while ($issue_comment = db_fetch_object($issue_comments)) {
    project_issue_update_by_comment($issue_comment, 'update');
  }
}

/**
 * Set the breadcrumb trail for project issues and issue followups.
 *
 * Since the comment form and a full node view of an issue can appear
 * on both full issue pages and comment reply pages, this function checks
 * to see which page is being loaded, and sets the breadcrumb appropriately.
 *
 * @param $node
 *   The issue node object.
 * @param $project
 *   The project node object.
 */
function project_issue_set_breadcrumb($node, $project) {
  project_project_set_breadcrumb($project, TRUE, array(l(t('Issues'), 'project/issues/' . $project->field_project_machine_name[LANGUAGE_NONE][0]['value'])));
}

/**
 * Implements hook_node_view().
 *
 * This injects some pseudo fields for issue display (update and follow
 * links), and sets project breadcrumbs for full node view.
 */
function project_issue_node_view($node, $view_mode, $langcode) {
  if (project_issue_node_is_issue($node) && empty($node->in_preview)) {
    $node->content['update_link'] = array(
      '#attached' => array('css' => array(drupal_get_path('module', 'project_issue') . '/project_issue.css')),
      '#markup' => theme('project_issue_issue_update_link', array('node' => $node)),
    );
    $node->content['jump_links'] = array(
      '#markup' => theme('project_issue_issue_jump_links', array('node' => $node)),
    );
    if (module_exists('flag_tracker')) {
      $follow_flag = flag_tracker_get_tracker_flag($node->type);
      if (!empty($follow_flag)) {
        $node->content['follow_link'] = array(
          '#markup' => flag_create_link($follow_flag, $node->nid),
        );
      }
    }
    if ($view_mode === 'full' && !empty($node->field_project[LANGUAGE_NONE])) {
      project_issue_set_breadcrumb($node, node_load($node->field_project[LANGUAGE_NONE][0]['target_id']));
    }
  }
}

/**
 * Implements hook_preprocess_field().
 *
 * Whenever field_issue_status is being rendered, we want to give it an
 * additional class based on the value of the field so we can do status-based
 * background colors.
 */
function project_issue_preprocess_field(&$variables) {
  if ($variables['element']['#field_name'] == 'field_issue_status') {
    $issue_node = $variables['element']['#object'];
    $status_value = $issue_node->field_issue_status[LANGUAGE_NONE][0]['value'];
    $variables['classes_array'][] = 'field-issue-status-' . drupal_html_class($status_value);
  }
}

/**
 * @defgroup project_issue_filter Project Issue number to link filter.
 */

/**
 * Template preprocess callback for automatic Project Issue links.
 *
 * @param $node
 *   The issue node object to be linked.
 * @param $comment_id
 *   The comment id to be appended to the link, optional.
 * @param $comment_number
 *   The comment's number, as visible to users, optional.
 * @param $include_assigned
 *   Optional boolean to include the user the issue is assigned to.
 *
 * @ingroup project_issue_filter themeable
 */
function template_preprocess_project_issue_issue_link(&$variables, $hook) {
  // This theme function can also be invoked by Views.
  if (isset($variables['view'])) {
    $node = node_load($variables['row']->node_nid);
    $include_assigned = $variables['options']['include_assigned'];
  }
  else {
    $node = $variables['node'];
    $comment_id = $variables['comment_id'];
    $comment_number = $variables['comment_number'];
    $include_assigned = $variables['include_assigned'];
  }

  $node_wrapper = entity_metadata_wrapper('node', $node);

  if (!empty($comment_number)) {
    $path = "comment/$comment_id";
  }
  else {
    $path = "node/$node->nid";
  }

  // Try to get the value of the assigned variable, if the field does not exist
  // it will just pass over this and leave as null.
  try {
    $assigned_uid = $node_wrapper->field_issue_assigned->getIdentifier();
    if (!empty($assigned_uid)) {
      // Do not load the user entity. If the user has formatted text fields,
      // they may be rendered and can infinite loop.
      $username = db_query('SELECT name FROM {users} WHERE uid = :assigned_uid', array(':assigned_uid' => $assigned_uid))->fetchField();
    }
  }
  catch (Exception $e) {
    $assigned = NULL;
  }

  try {
    $status = $node_wrapper->field_issue_status->value();
    $status_field = field_info_field('field_issue_status');
    $status_str = $status_field['settings']['allowed_values'][$status];
  }
  catch (Exception $e) {
    $status = 0;
    $status_str = t('Unknown');
  }

  $variables['status_id'] = $status;
  $variables['status_label'] = $status_str;

  if (isset($username) && !$include_assigned) {
    // We have an assigned user, but we're not going to print it next to the
    // issue link, so include it in title. l() runs $attributes through
    // drupal_attributes() which escapes the value.
    $attributes = array('title' => t('Status: !status, Assigned to: !username', array('!status' => $status_str, '!username' => $username)));
  }
  else {
    // Just the status.
    $attributes = array('title' => t('Status: !status', array('!status' => $status_str)));
  }

  if (isset($comment_id)) {
    $title = "#$node->nid-$comment_number: $node->title";
    $link = l($title, $path, array('attributes' => $attributes, 'fragment' => "comment-$comment_id"));
  }
  else {
    $title = "#$node->nid: $node->title";
    $link = l($title, $path, array('attributes' => $attributes));
  }
  $variables['link'] = $link;

  // (Re)set HTML classes array, regardless of whether the link is themed as
  // function or template.
  // @see template_preprocess()
  $variables['classes_array'] = array(drupal_html_class($hook));

  $variables['classes_array'][] = 'project-issue-status-info';
  $variables['classes_array'][] = drupal_html_class('project-issue-status-' . $status);

  if ($include_assigned && isset($username)) {
    $variables['assigned_to'] = t('Assigned to: @username', array('@username' => $username));
  }
  else {
    $variables['assigned_to'] = '';
  }
}

/**
 * Formats a link to an issue for the [#nid] filter.
 *
 * Available variables:
 * - $node: Full node object. Contains data that may not be safe.
 * - $classes_array: Array of html class attribute values.
 * - $link: String containing the actual href link markup.
 * - $assigned_to: String containing text about who the issue is assigned to,
 *   if that information is to be printed.
 * - $status_id: The integer ID for the issue's current status.
 * - $status_label: The human-readable label of the issue's current status.
 *
 * @see template_preprocess_project_issue_issue_link()
 */
function theme_project_issue_issue_link($variables) {
  $output = '<span class="' . implode(' ', $variables['classes_array']) . '">' . $variables['link'];
  if ($variables['assigned_to']) {
    $output .= ' <span class="project-issue-assigned-user">' . $variables['assigned_to'] . '</span>';
  }
  $output .= '</span>';
  return $output;
}

/**
 * Template preprocess callback for the 'Update this issue' button/link.
 *
 * @param $node
 *   The issue node object to be updated.
 */
function template_preprocess_project_issue_issue_update_link(&$variables) {
  global $user;
  $node = $variables['node'];

  // Can update
  if (node_access('update', $node)) {
    $update_url = url('node/' . $node->nid . '/edit');
    $variables['update_link'] = t('<a class="issue-button" href="@update">Update this issue</a>', array('@update' => $update_url));
  }
  // Anonymous
  elseif (!$user->uid) {
    $destination = drupal_get_destination();
    $login_url = url('user/login', array('query' => $destination));
    if (variable_get('user_register', USER_REGISTER_VISITORS_ADMINISTRATIVE_APPROVAL)) {
      // Users can register themselves.
      $variables['update_link'] = t('<a href="@login">Log in</a> or <a href="@register">register</a> to update this issue', array('@login' => $login_url, '@register' => url('user/register', array('query' => $destination))));
    }
    else {
      // Only admins can add new users, no public registration.
      $variables['update_link'] = t('<a href="@login">Log in</a> to update this issue', array('@login' => $login_url));
    }
  }
  // Authenticated but without update permission.
  else {
    // TODO: Should we display anything here?
    $variables['update_link'] = '';
  }

  $variables['last_update'] = t('Last updated on %date', array('%date' => format_date($node->changed, 'short')));
}


/**
 * Template preprocess callback for the 'issue jump link' links.
 *
 * @param $node
 *   The issue node object to be updated.
 */
function template_preprocess_project_issue_issue_jump_links(&$variables) {
  $node = $variables['node'];
  $links = array();
  $variables['jumplinks'] = '';

  // Link to the first unread comment
  if (comment_num_new($node->nid)) {
    $query = db_select('comment', 'c')
      ->fields('c', array('cid'))
      ->condition('c.nid', $node->nid)
      ->condition('c.created', max(node_last_viewed($node->nid), NODE_NEW_LIMIT), '>')
      ->condition('c.status', COMMENT_PUBLISHED)
      ->orderBy('c.cid')
      ->range(0, 1);
    $uri = entity_uri('comment', comment_load($query->execute()->fetchField()));
    $links['first_unread_link'] = l(t('First unread comment'), $uri['path'], $uri['options']);
  }
  // Link to the most recent comment
  if (!empty($node->cid)) {
    $uri = entity_uri('comment', comment_load($node->cid));
    $links['most_recent_link'] = l(t('Most recent comment'), $uri['path'], $uri['options']);
  }
  // Link to the most recent patch
  if (!empty($node->field_issue_files)) {
    $file_cids = nodechanges_get_changed_cids_keyed($node, 'field_issue_files', 'fid');
    // Sort $file_cids to order by key
    ksort($file_cids);
    // Get the cid of the last element
    $file_cid = array_pop($file_cids);
    if (!empty($file_cid)) {
      $links['latest_file_link'] = l(t('Most recent attachment'), "node/$node->nid", array('fragment' => "comment-$file_cid"));
    }
  }

  if ($node->comment != COMMENT_NODE_CLOSED) {
    // Link straight to comment form.
    if ($node->comment == COMMENT_NODE_OPEN && (user_access('post comments') || user_access('post comments without approval'))) {
      $links['comment_form_link'] = l(t('Add new comment'), "node/$node->nid", array(
        'fragment' => (variable_get('comment_form_location_' . $node->type, COMMENT_FORM_BELOW) == COMMENT_FORM_BELOW) ? 'comment-form' : 'project-issue-ajax-form',
      ));
    }
  }

  // Allow modules to alter via hook_project_issue_internal_links_alter().
  drupal_alter('project_issue_internal_links', $links, $node);

  if (!empty($links)) {
    $jumplinks = array(
      'items' => $links,
      'title' => t('Jump to:'),
      'type' => 'ul',
      'attributes' => array(
        'class' => 'internal-links',
      ),
    );
    $variables['jumplinks'] = theme('item_list', $jumplinks);
  }
}

/**
 * Implements hook_filter_info().
 *
 * @ingroup project_issue_filter
 */
function project_issue_filter_info() {
  $filters['filter_project_issue_link'] = array(
    'title' => t('Project issue to link filter'),
    'description' => t('Converts references to project issues (in the form of [#12345]) into links. Caching should be disabled if node access control modules are used.'),
    'process callback' => '_project_issue_filter',
    'tips callback' => '_project_issue_filter_tips',
    // Do not cache when a node access module may deny access to linked issues.
    'cache' => !module_implements('node_grants'),
  );
  return $filters;
}


/**
 * Filter tips callback.
 *
 * @ingroup project_issue_filter
 */
function _project_issue_filter_tips($delta, $format, $long = FALSE) {
  if ($long) {
    return t("References to project issues in the form of [#1234] (or [#1234-2] for comments) turn into links automatically, with the title of the issue appended. The status of the issue is shown on hover. If '@' is appended (e.g. [#1234@]), the user the issue is assigned to will also be printed.");
  }
  else {
    return t('Project issue numbers (ex. [#12345]) turn into links automatically.');
  }
}

/**
 * Filter process callback.
 *
 * @ingroup project_issue_filter
 */
function _project_issue_filter($text, $filter, $format) {
  $regex = '(?:(?<!\w)\[#\d+(?:-[\d\.]+)?(@)?\](?!\w))|<pre>.*?<\/pre>|<code>.*?<\/code>|<a(?:[^>"\']|"[^"]*"|\'[^\']*\')*>.*?<\/a>';
  $text = preg_replace_callback("/$regex/s", 'project_issue_link_filter_callback', $text);
  return $text;
}

/**
 * Callback function used by preg_replace_callback().
 *
 * @ingroup project_issue_filter
 */
function project_issue_link_filter_callback($matches) {
  $parts = array();
  static $recursion = FALSE;
  // We cache entities ourselves because we are bypassing normal caching
  // to prevent corruption due to not fully following reference chains.
  $entities = &drupal_static(__FUNCTION__);

  // We do not want to act during a recursive load.
  if ($recursion) {
    // Return original text.
    return $matches[0];
  }

  if (preg_match('/^\[#(\d+)(?:-([\d\.]+))?(@)?\]$/', $matches[0], $parts)) {
    $nid = $parts[1];
    $include_assigned = isset($parts[3]);

    if (!isset($entities[$nid])) {
      // Fetch the vid. We are using the vid to force a non-cached load,
      // since fully loading the dependent nodes is nondeterminate
      // due to the possibility of arbitrarily long chains.
      $vid = db_query('SELECT vid FROM {node} WHERE nid = :nid', array(':nid' => $nid))->fetchField();

      // Mark that we are recursing.
      $recursion = TRUE;
      // Load with condition to prevent entity caching.
      $entity = entity_load('node', array($nid), array('vid' => $vid));
      $recursion = FALSE;
      $entities[$nid] = isset($entity[$nid]) ? $entity[$nid] : NULL;
    }

    if (!isset($entities[$nid])) {
      // Linked to nonexistent node. Return the original text.
      return $matches[0];
    }
    $node = $entities[$nid];

    if (project_issue_node_is_issue($node) && node_access('view', $node)) {
      if (!empty($parts[2])) {
        // Pull comment id based on the comment number if we have one.
        $comment_number = $parts[2];
        $thread = implode('.', array_map('int2vancode', explode('.', $comment_number))) . '/';
        $comment_id = db_query('SELECT cid FROM {comment} WHERE nid = :nid AND thread = :thread AND status = 1', array(':nid' => $nid, ':thread' => $thread))->fetchField();
        if ($comment_id) {
          return theme('project_issue_issue_link', array('node' => $node, 'comment_id' => $comment_id, 'comment_number' => $comment_number, 'include_assigned' => $include_assigned));
        }
      }
      // If we got this far there wasn't a valid comment number, so just link
      // to the node instead.
      return theme('project_issue_issue_link', array('node' => $node, 'include_assigned' => $include_assigned));
    }
  }
  // If we haven't already returned a replacement, return the original text.
  return $matches[0];
}

/**
 * Implementation of hook_requirements().
 *
 * Check for conflicts with:
 *   installed node access control modules,
 *   'access project issues' restrictions,
 *   filters escaping code with higher weight.
 *
 * @ingroup project_issue_filter
 */
function project_issue_requirements($phase) {
  $requirements = array();
  $input_formats = array();
  if ($phase == 'runtime') {

    $grants = module_implements('node_grants');
    $allowed_roles = user_roles(FALSE, 'access project issues');
    $conflict_anonymous = empty($allowed_roles[DRUPAL_ANONYMOUS_RID]);

    foreach (filter_formats() as $format => $input_format) {
      $filters = filter_list_format($format);
      if (isset($filters['project_issue/0'])) {
        if (!empty($grants) && filter_format_allowcache($format)) {
          $requirements[] = array(
            'title' => t('Project Issue to link filter'),
            'value' => t('Some module conflicts were detected.'),
            'description' => t('%issuefilter should not be enabled when a node access control is also in use. Users may be able to see cached titles of project issues they would otherwise not have access to. You should disable this filter in !inputformat input format.', array('%issuefilter' => t('Project Issue to link filter'), '!inputformat' => l($input_format->name, "admin/settings/filters/$format"))),
            'severity' => REQUIREMENT_ERROR,
          );
        }

        if ($conflict_anonymous && filter_format_allowcache($format)) {
          $requirements[] = array(
            'title' => t('Project Issue to link filter'),
            'value' => t('Some security conflicts were detected.'),
            'description' => t('%issuefilter conflicts with project issue access settings. Users who do not have access to all project issues may be able to see titles of project issues. You should disable this filter in !inputformat input format.', array('%issuefilter' => t('Project Issue to link filter'), '!inputformat' => l($input_format->name, "admin/settings/filters/$format"))),
            'severity' => REQUIREMENT_ERROR,
          );
        }

        // Put up an error when some code escaping filter's weight is higher.
        $low_filters = array('filter/0', 'filter/1', 'bbcode/0', 'codefilter/0', 'geshifilter/0');
        foreach ($low_filters as $lfilter) {
          if (isset($filters[$lfilter]) && $filters['project_issue/0']->weight <= $filters[$lfilter]->weight) {
            $description_names['%issuefilter'] = $filters['project_issue/0']->name;
            $description_names['%lowfilter']  = $filters[$lfilter]->name;
            $requirements[] = array(
              'title' => t('Project Issue to link filter'),
              'value' => t('Some filter conflicts were detected.'),
              'description' => t('%issuefilter should come after %lowfilter to prevent loss of layout and highlighting.', $description_names) . ' ' . l(t('Please rearrange the filters.'), "admin/settings/filters/$format/order"),
              'severity' => REQUIREMENT_ERROR,
            );
          }
        }

      }
    }

  }
  return $requirements;
}

function project_issue_form_views_exposed_form_alter(&$form, &$form_state) {
  switch ($form_state['view']->name) {
    case 'project_issue_search_all':
    case 'project_issue_search_project':
    case 'project_issue_user_projects':
      $user_filters = array('assigned', 'submitted', 'participant');
      foreach (element_children($form) as $element) {
        if ($form[$element]['#type'] == 'textfield') {
          if ($form_state['view']->name == 'project_issue_user_projects') {
            $form[$element]['#size'] = 16;
          }
          else {
            $form[$element]['#size'] = 32;
          }
        }
        elseif ($form[$element]['#type'] == 'select' && !empty($form[$element]['#multiple'])) {
          $form[$element]['#size'] = 5;
        }
        if (in_array($element, $user_filters)) {
          $form[$element]['#description'] = t('Enter a comma separated list of users.');
        }
      }
      break;
  }
  // Rename the "Apply" button to "Search" on all project_issue_* views.
  if (substr($form_state['view']->name, 0, 14) == 'project_issue_') {
    $form['submit']['#value'] = t('Search');
  }
}

/**
 * Implements hook_views_query_alter().
 */
function project_issue_views_query_alter(&$view, &$query) {
  switch ($view->name) {
    case 'project_issue_user_projects':
      if ($view->current_display === 'my_projects_list') {
        // Force the join on node_comment_statistics to be LEFT so that projects with no issues are shown.
        $query->table_queue['field_project_node__node_comment_statistics']['join']->type = 'LEFT';
      }
      break;
  }
}

/**
 * Implements hook_views_pre_render().
 */
function project_issue_views_pre_render(&$view) {
  switch ($view->name) {
    case 'project_issue_user_projects':
      if ($view->current_display === 'my_projects_list') {
        // If a user has access to create projects, append a link to do that.
        foreach (project_project_node_types() as $type) {
          if (node_access('create', $type)) {
            $view->attachment_after .= l(t('Add a new project'), 'project/add');
            break;
          }
        }
        foreach ($view->result as $result) {
          $result->field_field_project_type[0]['rendered']['#markup'] = str_replace('project', 'projects', $result->field_field_project_type[0]['rendered']['#markup']);
        }
      }
      break;
  }
}

/**
 * Add dynamic css classes to issue tables.
 */
function project_issue_preprocess_views_view_table(&$variables) {
  $view = $variables['view'];
  if ($view->plugin_name == 'project_issue_table') {
    foreach ($view->result as $num => $result) {
      if (isset($result->field_field_issue_status[0])) {
        // View of Content
        $variables['row_classes'][$num][] = 'state-' . check_plain($result->field_field_issue_status[0]['raw']['value']);
      }
      elseif (isset($result->_entity_properties['entity object']->field_issue_status[LANGUAGE_NONE][0])) {
        // View from SearchAPI
        $variables['row_classes'][$num][] = 'state-' . check_plain($result->_entity_properties['entity object']->field_issue_status[LANGUAGE_NONE][0]['value']);
      }
      if (isset($result->field_field_issue_priority[0])) {
        // View of Content
        $variables['row_classes'][$num][] = 'priority-' . check_plain($result->field_field_issue_priority[0]['raw']['value']);
      }
      elseif (isset($result->_entity_properties['entity object']->field_issue_priority[LANGUAGE_NONE][0])) {
        // View from SearchAPI
        $variables['row_classes'][$num][] = 'priority-' . check_plain($result->_entity_properties['entity object']->field_issue_priority[LANGUAGE_NONE][0]['value']);
      }
    }
    $variables['classes_array'][] = 'project-issue';
  }
}

/**
 * Generate the links used at the top of query result pages.
 *
 * @param $project_arg
 *   The node ID or project short name (uri) of the project to generate links
 *   for, or NULL if it's a page of site-wide issues.
 *
 * @return
 *   Themed HTML output for the list of links.
 *
 * @see theme_project_issue_query_result_links()
 */
function project_issue_query_result_links($project_arg = NULL) {
  global $user;
  $links = array();

  if (empty($project_arg)) {
    // These are site-wide links, not per-project
    $links['create'] = project_issue_get_create_link();
    $links['search'] = array(
      'title' => t('Advanced search'),
      'href' => "project/issues/search",
      'attributes' => array('title' => t('Use the advanced search page for finding issues.')),
    );
  }
  else {
    // We know the project, make project-specific links.
    $project = project_load($project_arg);
    $machine_name = $project->field_project_machine_name[LANGUAGE_NONE][0]['value'];

    $links['create'] = project_issue_get_create_link($project);
    $links['search'] = array(
      'title' => t('Advanced search'),
      'href' => "project/issues/search/$machine_name",
      'attributes' => array('title' => t('Use the advanced search page to find @project issues.', array('@project' => $project->title))),
    );
    if ($user->uid) {
      $links['subscribe'] = array(
        'title' => t('E-mail notifications'),
        'href' => "project/issues/subscribe-mail/$machine_name",
        'attributes' => array('title' => t('Manage e-mail notifications about @project issues.', array('@project' => $project->title))),
      );
    }
  }
  $variables = array(
    'links' => $links,
  );
  return theme('project_issue_query_result_links', $variables);
}

/**
 * Implement hook_preprocess_html().
 *
 * Add the issue number to the node head title only.
 */
function project_issue_preprocess_html(&$vars) {
  if ($node = menu_get_object()) {
    if (project_issue_node_type_is_issue($node->type)) {
      $vars['head_title'] = token_replace('[node:title] [#[node:nid]] | [site:name]', array('node' => $node));
    }
  }
}

/**
 * Helper function to return a link to create an issue.
 *
 * This has logic to check how many node types are configured to act like
 * issues.  If there's only one, this stuff is easy and we can just send users
 * to the node/add/X page. If there's more than one issue node type on the
 * system, this is a mess.  For now we just punt and send them to /node/add.
 *
 * @todo We need to make this smarter for sites with multiple issue node types.
 *
 * @param $project
 *   A fully-loaded node object representing a specific project to build the
 *   create link for, or NULL if we should go to the pick-a-project landing
 *   page first.
 *
 * @return array
 *   An array suitable for use with theme_links() the defines the appropriate
 *   'Create an issue' link for the current user and given project.
 *
 * @see theme_links()
 */
function project_issue_get_create_link($project = NULL) {
  $issue_types = project_issue_issue_node_types();
  // If there's only one node type, we can link directly.
  if (count($issue_types) == 1) {
    $issue_bundle = reset($issue_types);
    $issue_bundle_url = strtr($issue_bundle, array('_' => '-'));
    if (node_access('create', $issue_bundle)) {
      if (empty($project)) {
        $link = array(
          'title' => t('Create a new issue'),
          'href' => "node/add/$issue_bundle_url",
          'attributes' => array('title' => t('Create a new issue.')),
        );
      }
      else {
        $machine_name = $project->field_project_machine_name[LANGUAGE_NONE][0]['value'];
        $link = array(
          'title' => t('Create a new issue'),
          'href' => "node/add/$issue_bundle_url/$machine_name",
          'attributes' => array('title' => t('Create a new issue for @project.', array('@project' => $project->title))),
        );
      }
    }
    else {
      if (user_is_logged_in()) {
        $link = array();
      }
      else {
        $link = array(
          'html'  => TRUE,
        );
        // We cannot use drupal_get_destination() because these links sometimes
        // appear on /node and taxo listing pages.
        $destination = array('destination' => 'node/add/project-issue/');
        if (!empty($project)) {
          $destination['destination'] .= $project->field_project_machine_name[LANGUAGE_NONE][0]['value'];
        }
        if (variable_get('user_register', 1)) {
          $link['title'] = t('<a href="@login">Login</a> or <a href="@register">register</a> to create an issue', array('@login' => url('user/login', array('query' => $destination)), '@register' => url('user/register', array('query' => $destination))));
        }
        else {
          $link['title'] = t('<a href="@login">Login</a> to create an issue', array('@login' => url('user/login', array('query' => $destination))));
        }
      }
    }
  }
  // Woe is us, there are multiple node types configured to be issues.
  else {
    // TODO: We could attempt to be smarter here somehow, have a landing page.
    $link = array(
      'title' => t('Create a new issue'),
      'href' => "node/add",
      'attributes' => array('title' => t('Create a new issue.')),
    );
  }
  // Allow other modules to alter the link.
  drupal_alter('project_issue_create_link', $link, $project);
  return $link;
}

/**
 * Return the HTML to use for the links at the top of issue query pages.
 *
 * @param $variables
 *   An associative array containing:
 *   - links: An associative array of links to be themed, indexed by the
 *     action ('create', 'search', etc).
 *
 * @see project_issue_query_result()
 * @see theme_links()
 */
function theme_project_issue_query_result_links($variables) {
  return theme('links', $variables);
}

/**
 * Helper function to return an array of projects that meet a given constraint.
 *
 * @param $constraint
 *   Restrict the list of projects.  Valid options are 'all' (all projects
 *   with issue tracking enabled), 'owner' (all projects owned by a given
 *   user) and 'participant' (all projects from issues that a given user
 *   submitted or commented on.
 * @param $uid
 *   User ID to use for $constraint == 'owner' or 'participant'.
 *
 * @return
 *   Array of project titles, keyed by node ID (nid) that match the given
 *   constraint.
 */
function project_issue_get_projects($constraint = 'all', $uid = NULL) {
  $options = array();
  $join = '';

  $query = new EntityFieldQuery;
  $query
    // Projects are currently restricted to nodes!
    ->entityCondition('entity_type', 'node')

    // That are projects...
    ->entityCondition('bundle', project_project_node_types())

    // Only published projects.
    ->propertyCondition('status', 1)

    // That have issue tracking enabled.
    ->fieldCondition('field_project_has_issue_queue', 'value', 1);

  // Add extra conditions depending on the requested project source.
  switch ($constraint) {
    case 'owner':
      // The given uid must own each project.
      $query->propertyCondition('uid', $uid);
      break;

    case 'participant':
      // @todo This is silly. Maybe we should actually track who participates where...
      $subquery = db_select('node', 'n');
      $subquery->innerJoin('field_data_field_project', 'p', 'n.nid = p.field_project_target_id');
      $subquery->innerJoin('comment', 'c', 'c.nid = p.entity_id AND p.entity_type = :entity_type', array(':entity_type' => 'node'));
      $subquery
        ->condition('n.status', 1)
        ->condition('p.bundle', project_issue_issue_node_types(), 'IN')
        ->condition('c.uid', $uid)
        ->fields('n', array('nid'));
      $query->entityCondition('entity_id', $subquery->execute()->fetchCol());
      break;
  }

  $result = $query
    // Safety limit.
    ->range(0, 200)
    ->execute();

  if (isset($result['node'])) {
    $nids = array_keys($result['node']);
    $projects = entity_load('node', $nids);
    foreach ($projects as $project) {
      $options[$project->nid] = $project->title;
    }
  }
  return $options;
}

/**
 * Menu access callback for the project_issue_plugin_access_user_list plugin.
 */
function project_issue_views_user_access($view_name, $display_id, $argument_name) {
  $view = views_get_view($view_name);
  $view->set_display($display_id);
  $view->init_handlers();
  // Find the values for any arguments embedded in the path via '%'.
  $i = 0;
  $common_path = TRUE;
  foreach (explode('/', $view->display_handler->get_option('path')) as $element) {
    if ($element == '%') {
      $view->args[] = arg($i);
    }
    elseif ($element != arg($i)) {
      // Since we are checking a view not on the current path, checking
      // implicit arguments is nonsensical.
      $common_path = FALSE;
    }
    $i++;
  }
  if ($common_path) {
    // Now handle any implicit arguments from the end of the path.
    $num_arguments = count($view->argument);
    while (count($view->args) < $num_arguments) {
      $view->args[] = arg($i);
      $i++;
    }
  }

  $arg_uid = $view->argument[$argument_name]->get_value();
  return !empty($arg_uid);
}

/**
 * Return the views filter identifier for a given project issue vocabulary.
 */
function project_issue_views_filter_identifier($name) {
  return drupal_strtolower(preg_replace('/[^a-zA-Z0-9]/', '_', check_plain($name)));
}

/**
 * Implements hook_block_info().
 */
function project_issue_block_info() {
  return array(
    'issue_cockpit' => array(
      'info' => t('Project issue: Issue queue statistics'),
      'cache' => DRUPAL_CACHE_PER_ROLE | DRUPAL_CACHE_PER_PAGE,
    ),
    'issue-metadata' => array(
      'info' => t('Project issue: Per-issue metadata'),
      'cache' => DRUPAL_NO_CACHE,
    ),
  );
}

/**
 * Implements hook_block_configure().
 */
function project_issue_block_configure($delta = '') {
  if ($delta == 'issue_cockpit') {
    $options = array('All' => t('All issues')) + project_issue_categories();
    $form['project_issue_cockpit_categories'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Issue categories to display'),
      '#description' => t('Select which categories the block should display a summary of total vs. open issues.'),
      '#default_value' => variable_get('project_issue_cockpit_categories', array('All' => 'All', 1 => 'Bug report')),
      '#options' => $options,
    );
    return $form;
  }
}

/**
 * Implements hook_block_save().
 */
function project_issue_block_save($delta = '', $edit = array()) {
  if ($delta == 'issue_cockpit') {
    variable_set('project_issue_cockpit_categories', $edit['project_issue_cockpit_categories']);
    // Invalidate the cache for this block since the categories might change.
    cache_clear_all('project_issue_cockpit_block:', 'cache', TRUE);
  }
}

/**
 * Implements hook_block_view().
 */
function project_issue_block_view($delta = '', $block = NULL) {
  if ($delta == 'issue_cockpit') {
    // Homebox style call.
    if (isset($block)) {
      if (isset($block->nid)) {
        $node = node_load($block->nid);
      }
      else {
        return array(
          'subject' => t('Issues for '),
          'content' => t('<a href="javascript:void(0)" class="portlet-settings">Configure</a> to select a project.'),
        );
      }
    }
    else {
      $node = project_get_project_from_menu();
    }
    if (!empty($node) && !empty($node->field_project_has_issue_queue[LANGUAGE_NONE][0]['value']) && node_access('view', $node)) {
      // Use a special cache to keep this block loading quickly per-project,
      // independent of core's caching based on URL path.
      $cid = 'project_issue_cockpit_block:' . $node->nid . ':' . user_is_logged_in();
      if (($cache = cache_get($cid))) {
        $block = $cache->data;
      }
      else {
        module_load_include('inc', 'project_issue', 'includes/issue_cockpit');
        $content = array('content' => array(
          '#theme' => 'project_issue_issue_cockpit',
          '#node' => $node,
        ));
        // Render so template_preprocess_project_issue_issue_cockpit() is
        // executed and this is cached as HTML.
        // TODO move logic and queries to here, and look into D3's JS & CSS
        // attaching, so the render array can be cached.
        $block = array(
          'subject' => t('Issues for @project', array('@project' => $node->title)),
          'content' => array('#markup' => drupal_render($content)),
        );

        // D3 makes direct calls to drupal_add_js() and drupal_add_css(), which
        // don't get cached with the block. Pull those out of static caches and
        // add to #attached.
        if (module_exists('sampler') && module_exists('d3_sparkline')) {
          $js = &drupal_static('drupal_add_js', array());
          foreach ($js['settings']['data'] as $key => $setting) {
            if (isset($setting['d3'])) {
              $block['content']['#attached']['js'][] = array(
                'data' => $setting,
                'type' => 'setting',
              );
              unset($js['settings']['data'][$key]);
            }
          }
          foreach ($js as $key => $setting) {
            if ($setting['type'] === 'file' && !$setting['every_page'] && strpos($key, 'd3.') !== FALSE) {
              $block['content']['#attached']['js'][$key] = $setting;
              unset($js[$key]);
            }
          }
          $css = &drupal_static('drupal_add_css', array());
          foreach ($css as $key => $setting) {
            if ($setting['type'] === 'file' && !$setting['every_page'] && strpos($key, 'd3.') !== FALSE) {
              $block['content']['#attached']['css'][$key] = $setting;
              unset($css[$key]);
            }
          }
        }

        cache_set($cid, $block);
      }
      return $block;
    }
  }
  elseif ($delta == 'issue-metadata') {
    $node = menu_get_object();
    if (!empty($node) && project_issue_node_is_issue($node)) {
      return array(
        'subject' => t('Issue status'),
        'content' => project_issue_metadata_build($node),
      );
    }
  }
}

/**
 * Adds the project issue follow flag to a node for a user.
 *
 * @param nid
 *   The nid of the issue to flag.
 * @param uid
 *   The user to add the flag for, defaults to the current user.
 */
function project_issue_flag_issue($nid, $uid = NULL) {
  // Flagging an issue only needs to happen if:
  //  - flag is installed
  //  - An authorized user would be associated with the flag.
  //  - The user does not currently have a flag set for the issue.
  $node = node_load($nid);
  $flag_name = project_issue_get_follow_flag($node);

  // Special case for during the data migration. We want to enable
  // auto-flagging before we enable the rest of the follow functionality.
  if (empty($flag_name) && module_exists('flag')) {
    $flag_name = variable_get('project_issue_follow_flag_update_6015', FALSE);
  }

  if (!empty($flag_name)) {
    $account = isset($uid) ? user_load($uid) : $GLOBALS['user'];
    if (is_object($account) && $account->uid != 0) {
      $flag = flag_get_flag($flag_name);
      if (!$flag->is_flagged($nid, $account->uid)) {
        $flag->flag('flag', $nid, $account);
      }
    }
  }
}

/**
 * Provide a list of keys Homebox will store.
 */
function project_issue_homebox_block_keys($block) {
  return array('nid');
}

/**
 * Provide an edit form specific to homebox blocks.
 *
 * Allows switching what project is used.
 */
function project_issue_homebox_block_edit_form($block) {
  $form = array();

  if (!empty($block->nid)) {
    $node = node_load($block->nid);
  }
  $form['project_title'] = array(
    '#type' => 'textfield',
    '#title' => t('Project name'),
    '#size' => 20,
    '#autocomplete_path' => 'project/autocomplete/issue/project',
    '#default_value' => empty($node) ? '' : $node->title,
  );
  $form['#validate'][] = 'project_issue_homebox_block_edit_form_validate';

  return $form;
}

/**
 * Validation callback for editing the project issue cockpit block via homebox.
 *
 * Makes sure a valid project title was entered and populates the nid. The nid
 * is automatically saved by homebox if it's in $form_state['values'] so
 * there's no need for a submit callback.
 */
function project_issue_homebox_block_edit_form_validate($form, &$form_state) {
  $nid = db_query('SELECT nid FROM {node} WHERE title = :title AND type IN (:types)', array(':title' => $form_state['values']['project_title'], ':types' => project_project_node_types()))->fetchField();
  if (empty($nid)) {
    form_set_error('project_title', t('The name you entered (%title) is not a valid project.', array('%title' => $form_state['values']['project_title'])));
  }
  else {
    $form_state['values']['nid'] = $nid;
  }
}

/**
 * Implementation of hook_views_post_render().
 */
function project_issue_views_post_render(&$view, &$output, &$cache) {
  // Add links to the issue queue views.
  $query_link_views = variable_get('project_issue_query_link_views', array('project_issue_all_projects', 'project_issue_project', 'project_issue_search_all', 'project_issue_search_project', 'project_issue_user_issues'));
  if (in_array($view->name, $query_link_views) && strpos($view->current_display, 'page') === 0) {
    $arg = NULL;
    if (isset($view->argument['nid'])) {
      $arg = $view->argument['nid']->get_value();
    }
    elseif (isset($view->argument['field_project'])) {
      // Used in SearchAPI-based views.
      $arg = $view->argument['field_project']->get_value();
    }
    $output = project_issue_query_result_links($arg) . $output;
  }
}

/**
 * Implementation of hook_comment_view().
 *
 * This enforces the settings for hiding reply links and removing indentation
 * on threaded comments for issue-enabled node types.
 */
function project_issue_comment_view($comment, $view_mode, $langcode) {
  // Amazingly, $comment->node_type is really the comment bundle name, which
  // looks like 'comment_node_[node_type]', not just [node_type].
  $node_type = substr($comment->node_type, 13);
  if (project_issue_node_type_is_issue($node_type)) {
    if (!variable_get('project_issue_indent_threaded_comments_' . $node_type, TRUE)) {
      unset($comment->divs);
    }

    if (!variable_get('project_issue_show_comment_reply_link_' . $node_type, TRUE)) {
      unset($comment->content['links']['comment']['#links']['comment-reply']);
    }
  }
}

/**
 * Preprocess function for the comment theme template.
 *
 * This enforces the 'project_issue_show_comment_signatures' setting, and if
 * comment_easy_reply is not enabled, uses the per-issue comment number
 * (basically, the thread ID) as the comment permalink.
 */
function project_issue_preprocess_comment(&$variables) {
  $comment = &$variables['comment'];
  if (project_issue_node_type_is_issue($variables['node']->type)) {
    // Allow comment_easy_reply to take over if it exists.
    if (!module_exists('comment_easy_reply')) {
      $uri = entity_uri('comment', $comment);
      $uri['options'] += array('attributes' => array('class' => array('permalink'), 'rel' => 'bookmark'), 'html' => TRUE);
      // Use the thread as the link text for comment number.  During preview,
      // the comment thread property does not exist, so we estimate based on
      // the current $node->comment_count value.
      if (empty($comment->in_preview)) {
        $thread = project_issue_get_comment_thread_id($comment);
      }
      else {
        $thread = $variables['node']->comment_count + 1;
      }
      $variables['permalink'] = l(t('<span class="element-invisible">Comment </span>#@thread', array('@thread' => $thread)), $uri['path'], $uri['options']);
    }

    // Disable signatures if configured not to show.
    if (!variable_get('project_issue_show_comment_signatures_' . $variables['node']->type, 0)) {
      $variables['signature'] = '';
    }
  }
}

/**
 * Return the thread identifier for a given comment.
 *
 * @param stdObj $comment
 *   A fully-loaded comment entity object, as returned by comment_load().
 *
 * @return string
 *   The sequential thread ID for the comment in a given issue. This is the
 *   per-issue human-readable sequential comment number, starting from 1, not
 *   the site-wide unique comment ID.
 */
function project_issue_get_comment_thread_id($comment) {
  return implode('.', array_map('vancode2int', explode('.', substr($comment->thread, 0, -1))));
}

/**
 * @defgroup project_issue_solr Project Issue ApacheSolr integration
 * @{
 */

/**
 * Implementation of hook_apachesolr_update_index().
 *
 * This adds information about the sandbox vs. full status of the project an
 * issue is assigned to.
 *
 * Beware that this hook is invoked for all nodes, so we should be careful in
 * here to check that we're really dealing with a project_issue node before
 * trying to access any issue-specifc data.
 */
function project_issue_apachesolr_update_index(&$document, $node) {
  if ($node->type == 'project_issue') {
    $project = node_load($node->field_project[LANGUAGE_NONE][0]['value']);
    // The initial "is" is for integer/single.
    $document->is_project_sandbox = ($node->field_project_type[LANGAUGE_NONE][0]['value'] == 'sandbox') ? 1 : 0;
  }
}

/**
 * Implements hook_project_promote_sandbox().
 *
 * Marks all issues attached to the project that they need to be reindexed in
 * Solr now that the 'is_project_sandbox' value will be different.
 */
function project_issue_project_promote_sandbox($project) {
  if (module_exists('apachesolr')) {
    // Using apachesolr_entity_update() would be a performance disaster here
    // with separate queries for each issue. So, we just directly update the DB
    // here with a single query with a subselect and all is well.
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'node')
      ->entityCondition('bundle', project_issue_issue_node_types())
      ->fieldCondition('field_project', 'target_id', $project->nid)
      ->addTag('DANGEROUS_ACCESS_CHECK_OPT_OUT');
    $result = $query->execute();
    if (!empty($result)) {
      db_update(apachesolr_get_indexer_table('node'))
        ->fields(array('changed' => REQUEST_TIME))
        ->condition('entity_id', array_keys($result['node']))
        ->execute();
    }
  }
}

/**
 * @} End of "defgroup project_issue_solr".
 */

/**
 * Implementation of hook_widget_info().
 */
function project_issue_widget_info() {
  return array(
    // Widget key is limited to 32 chars.
    'project_issue_nodereference_auto' => array(
      'label' => t('Project issue autocomplete text field'),
      'field types' => array('nodereference'),
      'multiple values' => CONTENT_HANDLE_CORE,
      'callbacks' => array(
        'default value' => CONTENT_CALLBACK_DEFAULT,
      ),
    ),
  );
}

/**
 * Implementation of hook_widget().
 */
function project_issue_widget(&$form, &$form_state, $field, $items, $delta = 0) {
  switch ($field['widget']['type']) {
    case 'project_issue_nodereference_auto':
      // Get the default process function from hook_elements.
      $default_process = (($info = _element_info('nodereference_autocomplete')) && array_key_exists('#process', $info)) ? $info['#process'] : array();
      // Add our new process element to the default.
      $default_process[] = 'project_issue_nodereference_autocomplete_process';
      return array(
        '#type' => 'nodereference_autocomplete',
        '#default_value' => isset($items[$delta]) ? $items[$delta] : NULL,
        '#value_callback' => 'project_issue_nodereference_autocomplete_value',
        '#process' => $default_process,
      );
  }
}

/**
 * Returns the value for a project_issue_nodereference autocomplete widget.
 *
 * Finds the node title from the node ID, and returns a value containing both.
 *
 * @see nodereference_autocomplete_value()
 */
function project_issue_nodereference_autocomplete_value($element, $edit = FALSE) {
  $field_key = $element['#columns'][0];
  if (!empty($element['#default_value'][$field_key])) {
    $nid = (int) $element['#default_value'][$field_key];
    $value = '#' . $nid . ': ' . db_result(db_query(db_rewrite_sql('SELECT n.title FROM {node} n WHERE n.nid = %d'), $nid));
    return array($field_key => $value);
  }
  return array($field_key => NULL);
}

/**
 * Sets the validation and auto-complete path for the node reference widget.
 *
 * This is an additional process function for the
 * project_issue_nodereference_autocomplete widget. It runs after the
 * default, nodereference_autocomplete_process().
 */
function project_issue_nodereference_autocomplete_process($element, $edit, $form_state, $form) {
  // Get the field key, since the autocomplete element defined by nodereference
  // module just wraps a textfield.
  $field_key  = $element['#columns'][0];

  // Add our custom autocomplete callback.
  $element[$field_key]['#autocomplete_path'] = 'project/autocomplete/issues/nodereference';

  // Unset the default validate.
  $key = array_search('nodereference_autocomplete_validate', $element[$field_key]['#element_validate']);
  if ($key !== FALSE) {
    unset($element[$field_key]['#element_validate'][$key]);
  }

  // Add our custom validate callback.
  $element[$field_key]['#element_validate'][] = 'project_issue_nodereference_autocomplete_validate';

  return $element;
}

/**
 * Validates a project_issue_nodereference_autocomplete element.
 *
 * The field has valid input if it contains a node ID, a node title, or the
 * format supplied by the auto-complete function ('#NID: TITLE'), and if the
 * node is a project issue.
 */
function project_issue_nodereference_autocomplete_validate($element, &$form_state) {
  // Get field information from $element.
  $field_name = $element['#field_name'];
  $type_name = $element['#type_name'];
  $field = content_fields($field_name, $type_name);
  $field_key  = $element['#columns'][0];
  $value = $element['#value'][$field_key];
  $nid = NULL;
  $title = '';

  // Sanity check: we expect $value to be a string or number, so just make sure.
  if (!is_string($value) && !is_numeric($value)) {
    form_error($element[$field_key], t('%name: the value is not a valid issue title or node ID.', array('%name' => $field['widget']['label'])));
    return;
  }

  $value = trim($value);

  // Try to pick the node ID or title out of the information we have.
  // First try to match with auto-complete syntax ('#NID: TITLE') (we will be
  // ignoring the title, however). Make sure we have at least one non-zero
  // digit at the start of the NID.
  if (preg_match('/^#([1-9]\d*):/', $value, $matches)) {
    $nid = $matches[1];
  }
  // Autocomplete syntax didn't work, so see if we have a node ID.
  elseif (is_numeric($value)) {
    $nid = (int) $value;
    if ($nid <= 0) {
      $nid = NULL;
      form_error($element[$field_key], t('%name: Not a valid issue ID.', array('%name' => $field['widget']['label'])));
    }
  }
  // As a last resort, it could be a node title.
  else {
    $title = $value;
  }

  // Now validate either the node ID or the title, making sure it's a
  // published issue node.
  if (!empty($nid)) {
    if (!$nid = db_result(db_query(db_rewrite_sql("SELECT n.nid FROM {node} n WHERE n.type = 'project_issue' AND n.nid = %d AND status = 1"), $nid))) {
      form_error($element[$field_key], t('%name: Not a valid issue ID.', array('%name' => $field['widget']['label'])));
    }
  }
  elseif (!empty($title)) {
    if (!$nid = db_result(db_query(db_rewrite_sql("SELECT n.nid FROM {node} n WHERE n.type = 'project_issue' AND n.status = 1 AND n.title = '%s'"), $title))) {
      form_error($element[$field_key], t('%name: the value is not a valid issue ID or title.', array('%name' => $field['widget']['label'])));
    }
  }

  form_set_value($element, $nid, $form_state);
}

/**
 * Implements hook_field_extra_fields().
 */
function project_issue_field_extra_fields() {
  $extra = array();
  foreach (project_issue_issue_node_types() as $bundle_name) {
    $extra['node'][$bundle_name] =  array(
      'display' => array(
        'update_link' => array(
          'label' => t('Issue update link'),
          'description' => t('A link for updating the issue.'),
          'weight' => 100,
        ),
        'jump_links' => array(
          'label' => t('Issue jump links'),
          'description' => t('Internal "jump links" for navigating within an issue page.'),
          'weight' => 120,
        ),
      ),
    );
    if (module_exists('flag_tracker')) {
      $follow_flag = flag_tracker_get_tracker_flag($bundle_name);
      if (!empty($follow_flag)) {
        $extra['node'][$bundle_name]['display']['follow_link'] = array(
          'label' => t('Issue follow link'),
          'description' => t('A link to follow the issue.'),
          'weight' => 110,
        );
      }
    }
  }
  return $extra;
}

/**
 * Implements hook_field_formatter_info().
 *
 * Provides a formatter for nodereference fields that uses
 * theme_project_issue_issue_link().
 */
function project_issue_field_formatter_info() {
  return array(
    'issue_id' => array(
      'label' => t('Issue link styled with status metadata'),
      'field types' => array('entityreference'),
      'multiple values' => FIELD_BEHAVIOR_DEFAULT,
    ),
    'issue_id_assigned' => array(
      'label' => t('Issue link styled with status metadata and assignee'),
      'field types' => array('entityreference'),
      'multiple values' => FIELD_BEHAVIOR_DEFAULT,
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function project_issue_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $elements = array();

  $settings = $display['settings'];
  $include_assigned = $display['type'] == 'issue_id_assigned' ? TRUE : FALSE;

  $target_type = $field['settings']['target_type'];
  $target_ids = array();
  foreach ($items as $delta => $item) {
    $target_ids[] = $item['target_id'];
  }
  $entities = entity_load($target_type, $target_ids);

  foreach ($items as $delta => $item) {
    $id = $item['target_id'];
    $output = '';
    if (empty($entities[$id])) {
      // Normally we wouldn't hit this due to entityreference validation, but
      // we might be displaying a stale value that's still pointing at a node
      // that's been deleted or something.
      if ($target_type == 'node') {
        $output = t('Node ID %nid not found', array('%nid' => $id));
      }
      else {
        $output = t('Target ID %id not found', array('%id' => $id));
      }
    }
    elseif ($target_type != 'node') {
      // If our referenced entities aren't nodes, we have to do other things
      // to link to them and they obviously can't be issues so our desired
      // theme formatting won't work.
      $entity = $entities[$id];
      $uri = entity_uri($target_type, $entity);
      $label = entity_label($target_type, $entity);
      $output = l($label, $uri['path']);
    }
    else {
      // From now on, we can assume an existing node.
      $node = $entities[$id];
      if (!project_issue_node_is_issue($node)) {
        // If it's a node but not an issue, just create an unstyled link using
        // the nid as a prefix, and the node title (if it exists).
        if (isset($node->title)) {
          $label = t('#@nid: @title', array('@nid' => $node->nid, '@title' => $node->title));
        }
        else {
          $label = '#' . check_plain($node->nid);
        }
        $output = l($label, 'node/' . $node->nid, array('html' => TRUE));
      }
      else {
        // It's an existing issue, so reuse the theme function for created the
        // styled link (which does coloring based on status, etc).
        $output = theme('project_issue_issue_link', array('node' => $node, 'include_assigned' => $include_assigned));
      }
    }
    $elements[$delta] = array(
      '#markup' => $output,
    );
  }

  return $elements;
}

/**
 * Find the flag name for following issues for this issue type (if any).
 *
 * If the flag tracker module (http://drupal.org/project/flag_tracker) is
 * enabled, project_issue node types can be configured to use a flag for
 * following issues. This function consolidates the checks for if that's all
 * configured, and if so, returns the name of the flag being used for this
 * node type.
 *
 * @param
 *   Node object.
 *
 * @return string
 *   The name of the flag being used for following issues of a node type, or
 *   '' (an empty string) if flag_tracker.module isn't enabled or there's no
 *   flag configured for this purpose.
 */
function project_issue_get_follow_flag($node) {
  $flag = '';
  if (module_exists('flag_tracker')) {
    $flag = flag_tracker_get_tracker_flag($node->type);
  }
  return $flag;
}

/**
 *  Find all the flags that are being used to track issues.
 *
 *  @return
 *    An array of bundle names that are issues and have a tracker flag set.
 */
function project_issue_get_follow_flags() {
  $tracked_issue_types = array();
  if (module_exists('flag_tracker')) {
    $issue_types_to_check = project_issue_issue_node_types();
    foreach ($issue_types_to_check as $type) {
      if (flag_tracker_get_tracker_flag($type)) {
        $tracked_issue_types[$type] = flag_tracker_get_tracker_flag($type);
      }
    }
  }
  return $tracked_issue_types;
}

/**
 * Implement hook_flag_default_flags().
 */
function project_issue_flag_default_flags() {
  $flags = array();
  $flags['project_issue_follow'] = array(
    'content_type' => 'node',
    'title' => t('Follow'),
    'global' => '0',
    'types' => array(
      0 => 'project_issue',
    ),
    'flag_short' => t('Follow'),
    'flag_long' => '',
    'flag_message' => '',
    'unflag_short' => t('Unfollow'),
    'unflag_long' => '',
    'unflag_message' => '',
    'unflag_denied_text' => '',
    'link_type' => 'toggle',
    'roles' => array(
      'flag' => array(
        0 => 2,
      ),
      'unflag' => array(
        0 => 2,
      ),
    ),
    'show_on_page' => 0,
    'show_on_teaser' => 0,
    'show_on_form' => 0,
    'access_author' => '',
    'i18n' => 0,
    'api_version' => 2,
  );
  return $flags;
}

/**
 * Implement hook_flag().
 */
function project_issue_flag($op, $flag, $content_id, $account, $fcid) {
  if ($flag->module === 'project_issue' && module_exists('search_api')) {
    // Trigger index update for node for flag indexing.
    search_api_entity_update(node_load($content_id), 'node');
  }
}

/**
 * Implements hook_project_behavior_info().
 */
function project_issue_project_behavior_info() {
  return array(
    'machine name' => 'project_issue',
    'label' => t('Used for project issues'),
    'settings callback' => 'project_issue_project_behavior_settings',
  );
}

/**
 * Settings callback for node types configured to be issues.
 *
 * @see project_issue_project_behavior_info()
 */
function project_issue_project_behavior_settings($node_type) {
  return array(
    'project_issue_show_comment_signatures' => array(
      '#type' => 'checkbox',
      '#title' => t('Display user signatures on comments'),
      '#default_value' => variable_get('project_issue_show_comment_signatures_' . $node_type, 0),
    ),
    'project_issue_show_comment_reply_link' => array(
      '#type' => 'checkbox',
      '#title' => t('Display <em>Reply</em> links on comments'),
      '#default_value' => variable_get('project_issue_show_comment_reply_link_' . $node_type, 1),
    ),
    'project_issue_indent_threaded_comments' => array(
      '#type' => 'checkbox',
      '#title' => t('Indent threaded comments'),
      '#default_value' => variable_get('project_issue_indent_threaded_comments_' . $node_type, 1),
      // This setting only makes sense if the node type is configured to
      // display threaded comments.
      '#states' => array(
        'visible' => array(
          ':input[name="comment_default_mode"]' => array('checked' => TRUE),
        ),
      ),
    ),
    'project_issue_reply_to' => array(
      '#type' => 'textfield',
      '#title' => t('Reply-to address on e-mail notifications'),
      '#default_value' => variable_get('project_issue_reply_to_' . $node_type, variable_get('site_mail', ini_get('sendmail_from'))),
      '#description' => t("All issue notification e-mails will appear from this e-mail address. You can use %project as a placeholder which will be replaced with the machine name for the issue's current project.", array('%project' => '%project')),
    ),
  );
}

/**
 * Determine whether or not a node is an issue.
 *
 * @param $node
 *   A node to check.
 *
 * @return boolean
 *   Is the given node an issue or not?
 */
function project_issue_node_is_issue($node) {
  return project_issue_node_type_is_issue($node->type);
}

/**
 * Determine whether or not a given node type is an issue.
 *
 * Each node type has a setting that determines if it has "issue nature", so
 * we just have to check that setting for the given node type.
 *
 * @param string $node_type
 *   The node type to check.
 *
 * @return boolean
 *   Is the given node type an issue node type or not?
 */
function project_issue_node_type_is_issue($node_type) {
  return variable_get('project_behavior_' . $node_type, FALSE) == 'project_issue';
}

/**
 * Retrieve a list of node types that are considered issues.
 *
 * Each node type has a setting that determines if it has "issue nature", so
 * we just have to check that setting for each node type in the system.
 *
 * @return array
 *   An array of bundle names (aka node type names) that are configured to
 *   have issue nature.
 */
function project_issue_issue_node_types() {
  $issue_node_types = array();
  $node_type_names = node_type_get_names();
  foreach ($node_type_names as $machine_name => $label) {
    if (project_issue_node_type_is_issue($machine_name)) {
      $issue_node_types[] = $machine_name;
    }
  }
  return $issue_node_types;
}

/**
 * Get the list of open states.
 */
function project_issue_open_states() {
  // @todo This is the d.o defaults. Set up the d.o variable and fix this one to
  // be the vanilla defaults!!
  return variable_get('project_issue_open_states', array(1,2,4,8,13,14,15,16));
}

/**
 * Build an array of user IDs to whom an issue may be assigned.
 *
 * @param $issue
 *   A fully loaded issue node, may or may not be created.
 * @param $project
 *   A fully loaded project node.
 * @param $current
 *   The current value of the assigned field, or NULL.
 * @return
 *   An array containing, and keyed by, users IDs to whom an issue may be
 *   assigned.
 */
function project_issue_assigned_choices($issue, $project, $current = NULL) {
  // Setup the array of choices for who the issue is assigned to.
  // Always put uid 0 (what we use to mean Unassigned) at the top of the list.
  $assigned = array(0 => 0);
  foreach (module_implements('project_issue_assignees') as $module) {
    $function = "{$module}_project_issue_assignees";
    $assigned += $function($issue, $project, $current);
  }
  drupal_alter('project_issue_assignees', $assigned, $issue, $project);
  return $assigned;
}

/**
 * Implements hook_project_issue_assignees().
 */
function project_issue_project_issue_assignees($issue, $project, $current) {
  global $user;
  if ($user->uid) {
    if (isset($current) && $user->uid != $current) {
      // Assigned to someone else, add the currently assigned user.
      $assigned[$current] = $current;
    }
    // Always let the person replying assign it to themselves.
    $assigned[$user->uid] = $user->uid;

    // See if the current user is an issue maintainer for the current project.
    if (!is_null($project)) {
      $maintainers = $project->project['maintainers'];
      if (!empty($maintainers[$user->uid]['permissions']['maintain issues'])) {
        foreach ($maintainers as $uid => $maintainer) {
          if (!empty($maintainer['permissions']['maintain issues'])) {
            $assigned[$uid] = $uid;
          }
        }
      }
    }
  }

  if (user_access('assign and be assigned project issues')) {
    // All users are included if either anon or auth user has the perm.
    if (db_query("SELECT rid FROM {role_permission} WHERE permission  = :perm AND rid IN(:anon, :auth)", array(':perm' => 'assign and be assigned project issues', ':anon' => DRUPAL_ANONYMOUS_RID, ':auth' => DRUPAL_AUTHENTICATED_RID))->fetchField()) {
      $result = db_query("SELECT uid FROM {users}");
    }
    else {
      $result = db_query("SELECT u.uid FROM {users} u INNER JOIN {users_roles} ur ON u.uid = ur.uid INNER JOIN {role_permission} rp ON rp.rid = ur.rid WHERE rp.permission = :perm", array(':perm' => 'assign and be assigned project issues'));
    }

    foreach ($result as $row) {
      $assigned[$row->uid] = $row->uid;
    }
  }

  return $assigned;
}

/**
 * Implements hook_field_widget_form_alter().
 *
 * We use this to:
 * 1. swap the label for the uid 0 choice to be 'Unassigned' instead of the
 *    username (e.g. 'Anonymous'),
 * 2. swap the label for the default component 0 choice to be '- None (user
 *    must select) -' instead of 'None', and
 * 3. update the project_issue 'component' field to set the default value to
 *    the project's default component if one has been set.
 */
function project_issue_field_widget_form_alter(&$element, &$form_state, $context) {
  if ($context['field']['field_name'] == 'field_issue_assigned') {
    if (isset($element['#options'][0])) {
      $element['#options'][0] = t('Unassigned');
    }
  }
  elseif ($context['field']['field_name'] == 'field_project_default_component') {
    if (isset($element['#options']['_none'])) {
      $element['#options']['_none'] = t('- None (user must select) -');
    }
  }
  elseif ($context['field']['field_name'] == 'field_issue_component') {
    // Only act on an entity form (rather than default settings) and if there
    // is no value set.
    if (!empty($element['#entity']) && !empty($element['#entity']->field_project[LANGUAGE_NONE]) && empty($element['#default_value'])) {
      $pid = $element['#entity']->field_project[LANGUAGE_NONE][0]['target_id'];
      $project = node_load($pid);
      if (!empty($project->field_project_default_component[LANGUAGE_NONE][0]['value'])) {
        $default_component = $project->field_project_default_component[LANGUAGE_NONE][0]['value'];
        $element['#default_value'] = array(
          $default_component => $default_component,
        );
      }
    }
  }
}

/**
 * Implements hook_migrate_api().
 */
function project_issue_migrate_api() {
  $api = array(
    'api' => 2,
    'migrations' => array(
      'ProjectIssueFixInitFiles' => array('class_name' => 'ProjectIssueFixInitFilesMigration'),
      'ProjectIssueRethreadIssueFollowups' => array('class_name' => 'ProjectIssueRethreadIssueFollowupsMigration'),
      'ProjectIssueTimelinePhaseOne' => array('class_name' => 'ProjectIssueTimelinePhaseOneMigration'),
      'ProjectIssueTimelinePhaseTwo' => array('class_name' => 'ProjectIssueTimelinePhaseTwoMigration'),
      'ProjectIssueTimelinePhaseThree' => array('class_name' => 'ProjectIssueTimelinePhaseThreeMigration'),
      'ProjectIssueAllocateVids' => array('class_name' => 'ProjectIssueAllocateVidsMigration'),
      'ProjectIssueAllocateCids' => array('class_name' => 'ProjectIssueAllocateCidsMigration'),
      'ProjectIssueRebuildCommentFields' => array('class_name' => 'ProjectIssueRebuildCommentFieldsMigration'),
      'ProjectIssueRebuildNodeFields' => array('class_name' => 'ProjectIssueRebuildNodeFieldsMigration'),
//    'ProjectIssuePhaseTwo' => array('class_name' => 'ProjectIssuePhaseTwoMigration'),
      'ProjectIssueFixGenericCorruption' => array('class_name' => 'ProjectIssueFixGenericCorruptionMigration'),
    ),
  );
  return $api;
}

/**
 * Implements hook_node_insert().
 */
function project_issue_node_insert($node) {
  if (project_node_type_is_project($node->type)) {
    // By default, users should get e-mail notifications for all issues on newly
    // created projects.
    // @todo: This should probably be a preference at user/N/project-issue
    project_issue_notification_project_setting_save($node->uid, $node->nid, PROJECT_ISSUE_NOTIFICATION_ALL);
  }
  elseif (project_issue_node_type_is_issue($node->type)) {
    if (empty($node->project_issue_no_email)) {
      module_load_include('inc', 'project_issue', 'includes/mail');
      project_issue_email_notify($node->nid);
    }
    // Invalidate the "Issue cockpit" block cache for this project, since the
    // new issue will have altered the summary totals.
    $pid = $node->field_project[LANGUAGE_NONE][0]['target_id'];
    cache_clear_all('project_issue_cockpit_block:' . $pid, 'cache');

    // Assigned user should automatically follow the issue.
    if (!empty($node->field_issue_assigned[$node->language][0]['target_id'])) {
      project_issue_flag_issue($node->nid, $node->field_issue_assigned[$node->language][0]['target_id']);
    }
  }
}

/**
 * Implements hook_node_update().
 */
function project_issue_node_update($node) {
  if (project_issue_node_type_is_issue($node->type)) {
    // Invalidate the "Issue cockpit" block cache for this project.
    $pid = $node->field_project[LANGUAGE_NONE][0]['target_id'];
    cache_clear_all('project_issue_cockpit_block:' . $pid, 'cache');
    // If the issue was previously in a different project, clear that cache too.
    $original_pid = $node->original->field_project[LANGUAGE_NONE][0]['target_id'];
    if ($original_pid != $pid) {
      cache_clear_all('project_issue_cockpit_block:' . $original_pid, 'cache');
    }

    // Assigned user should automatically follow the issue.
    if (!empty($node->field_issue_assigned[$node->language][0]['target_id'])) {
      project_issue_flag_issue($node->nid, $node->field_issue_assigned[$node->language][0]['target_id']);
    }
  }
}

/**
 * Implements hook_comment_insert().
 */
function project_issue_comment_insert($comment) {
  // Reset static cache so that last_comment_timestamp is updated.
  $node = node_load($comment->nid, NULL, TRUE);
  if ($node && project_issue_node_type_is_issue($node->type)) {
    if (empty($comment->project_issue_no_email)) {
      module_load_include('inc', 'project_issue', 'includes/mail');
      project_issue_email_notify($node->nid, $comment->cid);
    }
    if (module_exists('search_api')) {
      // Trigger index update for node for comment indexing.
      search_api_entity_update($node, 'node');
    }
  }
}

/**
 * Helper function to find all taxonomy term reference fields on issue bundles.
 */
function _project_issue_get_issue_term_reference_fields() {
  $issue_term_references = array();
  foreach (field_info_field_map() as $field_name => $map) {
    if ($map['type'] == 'taxonomy_term_reference' && !empty($map['bundles']['node'])) {
      $field = field_info_field($field_name);
      foreach ($map['bundles']['node'] as $bundle) {
        if (project_issue_node_type_is_issue($bundle)) {
          if (empty($issue_term_references[$field_name])) {
            $issue_term_references[$field_name] = array(
              'vocabulary' => $field['settings']['allowed_values'][0]['vocabulary'],
            );
          }
          $issue_term_references[$field_name]['bundles'][] = $bundle;
        }
      }
    }
  }
  return $issue_term_references;
}

/**
 * Entity URI callback for taxonomy terms.
 *
 * If the term is from a vocabulary configured for use in the issue queues,
 * return a link to the right issue queue search, otherwise, fall back to the
 * default taxonomy term pages.
 */
function project_issue_taxonomy_term_uri($term) {
  $uri = array();
  $vocabulary_issue_queue = variable_get('project_issue_taxonomy_vocabulary_issue_queue_' . $term->vid, 0);
  if (!empty($vocabulary_issue_queue)) {
    $uri = array(
      'path' => 'project/issues/search',
      'options' => array(
        'query' => array(
          // We setup the default views such that the filter ID (key for the
          // query string) uses the vocabulary machine name since core is
          // inconsistent with field names between migrated taxonomy
          // vocabularies and newly created term reference fields.
          $term->vocabulary_machine_name => $vocabulary_issue_queue == 'autocomplete' ? $term->name : $term->tid,
        ),
      ),
    );
  }
  else {
    $uri = taxonomy_term_uri($term);
  }
  return $uri;
}

/**
 * Implements hook_form_FORM_ID_alter for taxonomy vocabulary forms.
 *
 * This injects a checkbox onto the form for taxonomy vocabularies to control
 * if that vocabulary should be used for the issue queue on the site. If so,
 * an exposed filter will be added to the advanced search views, and the uri
 * for terms in the vocabulary will link directly to the site-wide advanced
 * issue search.
 */
function project_issue_form_taxonomy_form_vocabulary_alter(&$form, &$form_state) {
  if ($form['#id'] == 'taxonomy_vocabulary_confirm_delete') {
    $form['#submit'][] = 'project_issue_taxonomy_vocabulary_delete_submit';
  }
  else {
    $form['project_issue_queue'] = array(
      '#type' => 'select',
      // TODO: better title?
      '#title' => t('Widget for the issue queue'),
      '#options' => array(
        0 => t('- None -'),
        'select' => t('Select drop-down'),
        'autocomplete' => t('Auto-complete text field'),
      ),
      // TODO: better description?
      '#description' => t('If a widget is defined for this vocabulary, an exposed filter will be add to the advanced search issue queue views, and terms will link to the issue queue search.'),
      '#default_value' => !empty($form['#vocabulary']->vid) ? variable_get('project_issue_taxonomy_vocabulary_issue_queue_' . $form['#vocabulary']->vid, 0) : 0,
    );
    $form['#submit'][] = 'project_issue_taxonomy_vocabulary_submit';
  }
}

/**
 * Form submit callback for the taxonomy vocabulary form.
 *
 * Saves the value of the 'project_issue_queue' checkbox and clears the views
 * cache so that the default views are rebuilt based on the setting.
 */
function project_issue_taxonomy_vocabulary_submit($form, &$form_state) {
  variable_set('project_issue_taxonomy_vocabulary_issue_queue_' . $form_state['values']['vid'], $form_state['values']['project_issue_queue']);
  views_invalidate_cache();
}

/**
 * Form submit callback for the taxonomy vocabulary delete confirmation form.
 *
 * Clears the value of the 'project_issue_queue' checkbox for the vocabulary
 * being deleted and clears the views cache so that the default views are
 * rebuilt to remove any exposed filters related to this vocabulary.
 */
function project_issue_taxonomy_vocabulary_delete_submit($form, &$form_state) {
  variable_del('project_issue_taxonomy_vocabulary_issue_queue_' . $form_state['values']['vid']);
  views_invalidate_cache();
}

/**
 * Theme preprocess function. Provide human-readable interval.
 */
function project_issue_preprocess_project_issue_auto_close_message(&$variables) {
  $variables['auto_close_interval'] = format_interval($variables['auto_close_days'] * 24 * 60 * 60, 2);
}

/**
 * Comment left when cron auto-closes an issue.
 *
 * @param $variables
 *   An associative array containing keys:
 *   - 'auto_close_days': The (minimum) number of days without activity before
 *     automatically closing a fixed issue.
 *   - 'auto_close_interval': Human-readable form of 'auto_close_days'.
 *
 * @return
 *   Message to be added as a comment to an issue when auto-closing that issue.
 */
function theme_project_issue_auto_close_message($variables) {
  return t('Automatically closed - issue fixed for !interval with no activity.', array('!interval' => $variables['auto_close_interval']));
}

/**
 * Allowed values callback for a project's 'default component' select box.
 */
function project_issue_default_component_allowed_values($field, $instance, $entity_type, $entity) {
  $return = array();
  if ($entity) {
    if (!empty($entity->field_project_components[$entity->language])) {
      foreach ($entity->field_project_components[$entity->language] as $component) {
        $return[$component['value']] = $component['value'];
      }
    }
  }
  return $return;
}

/**
 * Original function is taxonomy_autocomplete(), has been overridden to add sorting.
 *
 * Page callback: Outputs JSON for "Issue tags" taxonomy autocomplete suggestions.
 *
 * Path: taxonomy/autocomplete/taxonomy_vocabulary_*
 *
 * This callback outputs term name suggestions in response to Ajax requests
 * made by the taxonomy autocomplete widget for taxonomy term reference
 * fields. The output is a JSON object of plain-text term suggestions, keyed by
 * the user-entered value with the completed term name appended.  Term names
 * containing commas are wrapped in quotes.
 *
 * For example, suppose the user has entered the string 'red fish, blue' in the
 * field, and there are two taxonomy terms, 'blue fish' and 'blue moon'. The
 * JSON output would have the following structure:
 * @code
 *   {
 *     "red fish, blue fish": "blue fish",
 *     "red fish, blue moon": "blue moon",
 *   };
 * @endcode
 *
 * @param string $vid
 *   A taxonomy vocabulary ID.
 *
 * @param $tags_typed
 *   (optional) A comma-separated list of term names entered in the
 *   autocomplete form element. Only the last term is used for autocompletion.
 *   Defaults to '' (an empty string).
 *
 * @see taxonomy_autocomplete()
 * @see taxonomy_menu()
 * @see taxonomy_field_widget_info()
 */
function project_issue_issue_tag_autocomplete($vid, $tags_typed = '') {
  // Issues tag taxonomy vocabulary name
  $field_name = 'taxonomy_vocabulary_' . $vid;

  // The menu system can send an unknown number of arguments if a '/' was in
  // the search string.
  $args = func_get_args();

  // The first argument is $vid, which is not part of the search. Remove it.
  unset($args[0]);

  // If the menu system split the search into multiple arguments because '/' was
  // part of the search, restore the original search.
  $tags_typed = implode('/', $args);

  // Make sure the field exists and is a taxonomy field.
  if (!($field = field_info_field($field_name)) || $field['type'] !== 'taxonomy_term_reference') {
    // Error string. The JavaScript handler will realize this is not JSON and
    // will display it as debugging information.
    print t('Taxonomy field @field_name not found.', array('@field_name' => $field_name));
    exit;
  }

  // The user enters a comma-separated list of tags. We only autocomplete the last tag.
  $tags_typed = drupal_explode_tags($tags_typed);
  $tag_last = drupal_strtolower(array_pop($tags_typed));

  $term_matches = array();
  if ($tag_last != '') {

    // Part of the criteria for the query come from the field's own settings.
    $vids = array();
    $vocabularies = taxonomy_vocabulary_get_names();
    foreach ($field['settings']['allowed_values'] as $tree) {
      $vids[] = $vocabularies[$tree['vocabulary']]->vid;
    }

    $query = db_select('taxonomy_term_data', 't');
    $query->addTag('translatable');
    $query->addTag('term_access');

    // Do not select already entered terms.
    if (!empty($tags_typed)) {
      $query->condition('t.name', $tags_typed, 'NOT IN');
    }
    // Select rows that match by term name.
    $tags_return = $query
      ->fields('t', array('tid', 'name'));
    // Expression of issues count from taxonomy_index
    $tags_return->addExpression('COUNT(1)', 'c');
    $tags_return->leftJoin('taxonomy_index', 'i', 'i.tid = t.tid');
    $result = $tags_return->condition('t.vid', $vids)
      ->condition('t.name', '%' . db_like($tag_last) . '%', 'LIKE')
      ->range(0, 10)
      ->groupBy('t.tid')
      ->orderBy('c', 'DESC')
      ->execute()
      ->fetchAllKeyed();

    $prefix = count($tags_typed) ? drupal_implode_tags($tags_typed) . ', ' : '';

    foreach ($result as $tid => $name) {
      $n = $name;
      // Term names containing commas or quotes must be wrapped in quotes.
      if (strpos($name, ',') !== FALSE || strpos($name, '"') !== FALSE) {
        $n = '"' . str_replace('"', '""', $name) . '"';
      }
      $term_matches[$prefix . $n] = check_plain($name);
    }
  }

  drupal_json_output($term_matches);
}
