<?php

/**
 * @file
 * Integrates Millennium library catalogs with Drupal, automatically importing records and showing availability of items in nodes.
 */

define('MILLENNIUM_SETTINGS_PATH', 'admin/config/services/millennium');
define('MILLENNIUM_PERFORMANCE_HISTORY_SIZE', 20);
define('MILLENNIUM_RECORD_PREG_CHECKDIGIT', '/^[bi][0-9]{5,10}x?$/i');
define('MILLENNIUM_RECORD_PREG_NOCHECKDIGIT', '/^[bi][0-9]{5,10}$/i');
define('MILLENNIUM_SESSION_COOKIE_LIFETIME', 300);
define('MILLENNIUM_ITEM_AVAILABLE_STRINGS', 'AVAILABLE,IN LIBRARY');

/**
 * Implements hook_admin_paths().
 */
function millennium_admin_paths() {
  $paths = array(
    'node/*/millennium' => TRUE,
  );
  return $paths;
}

/**
 * Implements hook_init().
 */
function millennium_init() {
  global $_millennium_field_labels;
  global $_key_to_name; #xyz

  // Load CSS file
  drupal_add_css( drupal_get_path('module', 'millennium') . '/millennium.css');

  $_millennium_field_labels = array(
    'type' => t('Item type'),
    'title' => t('Title'),
    'title_head' => t('Title (head)'),
    'title_remainder' => t('Title (remainder)'),
    'title_author' => t('Title (author)'),
    'alternate_title' => t('Alternate title'),
    'short_title' => t('Short title'),
    'translated_title' => t('Translated title'),
    'authors' => t('Author(s)'),
    'corp_author' => t('Corporate author(s)'),
    'series' => t('Series'),
    'edition' => t('Edition'),
    'imprint' => t('Imprint'),
    'imprint_name' => t('Publisher'),
    'imprint_place' => t('Place published'),
    'imprint_date' => t('Date published'),
    'isbn' => t('ISBN'),
    'issn' => t('ISSN'),
    'volume' => t('Volume'),
    'lang' => t('Language'),
    'url' => t('URL'),
    'item_recnum' => t('Item record number'),
    'notes' => t('Notes'),
    'item_description' => t('Physical description'),
    'links' => t('Related links'),
    'other_number' => t('Other number'),
    'lcc' => t('LC call number'),
    'ddc' => t('Dewey call number'),
    'marc' => t('MARC record'),
  );

  $_key_to_name['lang'] = array(
    'aar' => t('Afar', array(), array('langcode' => 'en')),
    'abk' => t('Abkhaz', array(), array('langcode' => 'en')),
    'ace' => t('Achinese', array(), array('langcode' => 'en')),
    'ach' => t('Acoli', array(), array('langcode' => 'en')),
    'ada' => t('Adangme', array(), array('langcode' => 'en')),
    'ady' => t('Adygei', array(), array('langcode' => 'en')),
    'afa' => t('Afroasiatic', array(), array('langcode' => 'en')),
    'afh' => t('Afrihili', array(), array('langcode' => 'en')),
    'afr' => t('Afrikaans', array(), array('langcode' => 'en')),
    'ain' => t('Ainu', array(), array('langcode' => 'en')),
    'aka' => t('Akan', array(), array('langcode' => 'en')),
    'akk' => t('Akkadian', array(), array('langcode' => 'en')),
    'alb' => t('Albanian', array(), array('langcode' => 'en')),
    'ale' => t('Aleut', array(), array('langcode' => 'en')),
    'alg' => t('Algonquian', array(), array('langcode' => 'en')),
    'alt' => t('Altai', array(), array('langcode' => 'en')),
    'amh' => t('Amharic', array(), array('langcode' => 'en')),
    'ang' => t('English, Old', array(), array('langcode' => 'en')),
    'anp' => t('Angika', array(), array('langcode' => 'en')),
    'apa' => t('Apache languages', array(), array('langcode' => 'en')),
    'ara' => t('Arabic', array(), array('langcode' => 'en')),
    'arc' => t('Aramaic', array(), array('langcode' => 'en')),
    'arg' => t('Aragonese Spanish', array(), array('langcode' => 'en')),
    'arm' => t('Armenian', array(), array('langcode' => 'en')),
    'arn' => t('Mapuche', array(), array('langcode' => 'en')),
    'arp' => t('Arapaho', array(), array('langcode' => 'en')),
    'art' => t('Artificial', array(), array('langcode' => 'en')),
    'arw' => t('Arawak', array(), array('langcode' => 'en')),
    'asm' => t('Assamese', array(), array('langcode' => 'en')),
    'ast' => t('Bable', array(), array('langcode' => 'en')),
    'ath' => t('Athapascan', array(), array('langcode' => 'en')),
    'aus' => t('Australian languages', array(), array('langcode' => 'en')),
    'ava' => t('Avaric', array(), array('langcode' => 'en')),
    'ave' => t('Avestan', array(), array('langcode' => 'en')),
    'awa' => t('Awadhi', array(), array('langcode' => 'en')),
    'aym' => t('Aymara', array(), array('langcode' => 'en')),
    'aze' => t('Azerbaijani', array(), array('langcode' => 'en')),
    'bad' => t('Banda languages', array(), array('langcode' => 'en')),
    'bai' => t('Bamileke languages', array(), array('langcode' => 'en')),
    'bak' => t('Bashkir', array(), array('langcode' => 'en')),
    'bal' => t('Baluchi', array(), array('langcode' => 'en')),
    'bam' => t('Bambara', array(), array('langcode' => 'en')),
    'ban' => t('Balinese', array(), array('langcode' => 'en')),
    'baq' => t('Basque', array(), array('langcode' => 'en')),
    'bas' => t('Basa', array(), array('langcode' => 'en')),
    'bat' => t('Baltic', array(), array('langcode' => 'en')),
    'bej' => t('Beja', array(), array('langcode' => 'en')),
    'bel' => t('Belarusian', array(), array('langcode' => 'en')),
    'bem' => t('Bemba', array(), array('langcode' => 'en')),
    'ben' => t('Bengali', array(), array('langcode' => 'en')),
    'ber' => t('Berber', array(), array('langcode' => 'en')),
    'bho' => t('Bhojpuri', array(), array('langcode' => 'en')),
    'bih' => t('Bihari', array(), array('langcode' => 'en')),
    'bik' => t('Bikol', array(), array('langcode' => 'en')),
    'bin' => t('Edo', array(), array('langcode' => 'en')),
    'bis' => t('Bislama', array(), array('langcode' => 'en')),
    'bla' => t('Siksika', array(), array('langcode' => 'en')),
    'bnt' => t('Bantu', array(), array('langcode' => 'en')),
    'bos' => t('Bosnian', array(), array('langcode' => 'en')),
    'bra' => t('Braj', array(), array('langcode' => 'en')),
    'bre' => t('Breton', array(), array('langcode' => 'en')),
    'btk' => t('Batak', array(), array('langcode' => 'en')),
    'bua' => t('Buriat', array(), array('langcode' => 'en')),
    'bug' => t('Bugis', array(), array('langcode' => 'en')),
    'bul' => t('Bulgarian', array(), array('langcode' => 'en')),
    'bur' => t('Burmese', array(), array('langcode' => 'en')),
    'byn' => t('Bilin', array(), array('langcode' => 'en')),
    'cad' => t('Caddo', array(), array('langcode' => 'en')),
    'cai' => t('Central American Indian', array(), array('langcode' => 'en')),
    'car' => t('Carib', array(), array('langcode' => 'en')),
    'cat' => t('Catalan', array(), array('langcode' => 'en')),
    'cau' => t('Caucasian', array(), array('langcode' => 'en')),
    'ceb' => t('Cebuano', array(), array('langcode' => 'en')),
    'cel' => t('Celtic', array(), array('langcode' => 'en')),
    'cha' => t('Chamorro', array(), array('langcode' => 'en')),
    'chb' => t('Chibcha', array(), array('langcode' => 'en')),
    'che' => t('Chechen', array(), array('langcode' => 'en')),
    'chg' => t('Chagatai', array(), array('langcode' => 'en')),
    'chi' => t('Chinese', array(), array('langcode' => 'en')),
    'chk' => t('Chuukese', array(), array('langcode' => 'en')),
    'chm' => t('Mari', array(), array('langcode' => 'en')),
    'chn' => t('Chinook jargon', array(), array('langcode' => 'en')),
    'cho' => t('Choctaw', array(), array('langcode' => 'en')),
    'chp' => t('Chipewyan', array(), array('langcode' => 'en')),
    'chr' => t('Cherokee', array(), array('langcode' => 'en')),
    'chu' => t('Church Slavic', array(), array('langcode' => 'en')),
    'chv' => t('Chuvash', array(), array('langcode' => 'en')),
    'chy' => t('Cheyenne', array(), array('langcode' => 'en')),
    'cmc' => t('Chamic languages', array(), array('langcode' => 'en')),
    'cop' => t('Coptic', array(), array('langcode' => 'en')),
    'cor' => t('Cornish', array(), array('langcode' => 'en')),
    'cos' => t('Corsican', array(), array('langcode' => 'en')),
    'cpe' => t('Creoles and Pidgins, English-based', array(), array('langcode' => 'en')),
    'cpf' => t('Creoles and Pidgins, French-based', array(), array('langcode' => 'en')),
    'cpp' => t('Creoles and Pidgins, Portuguese-based', array(), array('langcode' => 'en')),
    'cre' => t('Cree', array(), array('langcode' => 'en')),
    'crh' => t('Crimean Tatar', array(), array('langcode' => 'en')),
    'crp' => t('Creoles and Pidgins', array(), array('langcode' => 'en')),
    'csb' => t('Kashubian', array(), array('langcode' => 'en')),
    'cus' => t('Cushitic', array(), array('langcode' => 'en')),
    'cze' => t('Czech', array(), array('langcode' => 'en')),
    'dak' => t('Dakota', array(), array('langcode' => 'en')),
    'dan' => t('Danish', array(), array('langcode' => 'en')),
    'dar' => t('Dargwa', array(), array('langcode' => 'en')),
    'day' => t('Dayak', array(), array('langcode' => 'en')),
    'del' => t('Delaware', array(), array('langcode' => 'en')),
    'den' => t('Slave', array(), array('langcode' => 'en')),
    'dgr' => t('Dogrib', array(), array('langcode' => 'en')),
    'din' => t('Dinka', array(), array('langcode' => 'en')),
    'div' => t('Divehi', array(), array('langcode' => 'en')),
    'doi' => t('Dogri', array(), array('langcode' => 'en')),
    'dra' => t('Dravidian', array(), array('langcode' => 'en')),
    'dsb' => t('Lower Sorbian', array(), array('langcode' => 'en')),
    'dua' => t('Duala', array(), array('langcode' => 'en')),
    'dum' => t('Dutch, Middle', array(), array('langcode' => 'en')),
    'dut' => t('Dutch', array(), array('langcode' => 'en')),
    'dyu' => t('Dyula', array(), array('langcode' => 'en')),
    'dzo' => t('Dzongkha', array(), array('langcode' => 'en')),
    'efi' => t('Efik', array(), array('langcode' => 'en')),
    'egy' => t('Egyptian', array(), array('langcode' => 'en')),
    'eka' => t('Ekajuk', array(), array('langcode' => 'en')),
    'elx' => t('Elamite', array(), array('langcode' => 'en')),
    'eng' => t('English', array(), array('langcode' => 'en')),
    'enm' => t('English, Middle', array(), array('langcode' => 'en')),
    'epo' => t('Esperanto', array(), array('langcode' => 'en')),
    'est' => t('Estonian', array(), array('langcode' => 'en')),
    'ewe' => t('Ewe', array(), array('langcode' => 'en')),
    'ewo' => t('Ewondo', array(), array('langcode' => 'en')),
    'fan' => t('Fang', array(), array('langcode' => 'en')),
    'fao' => t('Faroese', array(), array('langcode' => 'en')),
    'fat' => t('Fanti', array(), array('langcode' => 'en')),
    'fij' => t('Fijian', array(), array('langcode' => 'en')),
    'fil' => t('Filipino', array(), array('langcode' => 'en')),
    'fin' => t('Finnish', array(), array('langcode' => 'en')),
    'fiu' => t('Finno-Ugrian', array(), array('langcode' => 'en')),
    'fon' => t('Fon', array(), array('langcode' => 'en')),
    'fre' => t('French', array(), array('langcode' => 'en')),
    'frm' => t('French, Middle', array(), array('langcode' => 'en')),
    'fro' => t('French, Old', array(), array('langcode' => 'en')),
    'frr' => t('North Frisian', array(), array('langcode' => 'en')),
    'frs' => t('East Frisian', array(), array('langcode' => 'en')),
    'fry' => t('Frisian', array(), array('langcode' => 'en')),
    'ful' => t('Fula', array(), array('langcode' => 'en')),
    'fur' => t('Friulian', array(), array('langcode' => 'en')),
    'gaa' => t('Gã', array(), array('langcode' => 'en')),
    'gay' => t('Gayo', array(), array('langcode' => 'en')),
    'gba' => t('Gbaya', array(), array('langcode' => 'en')),
    'gem' => t('Germanic', array(), array('langcode' => 'en')),
    'geo' => t('Georgian', array(), array('langcode' => 'en')),
    'ger' => t('German', array(), array('langcode' => 'en')),
    'gez' => t('Ethiopic', array(), array('langcode' => 'en')),
    'gil' => t('Gilbertese', array(), array('langcode' => 'en')),
    'gla' => t('Scottish Gaelic', array(), array('langcode' => 'en')),
    'gle' => t('Irish', array(), array('langcode' => 'en')),
    'glg' => t('Galician', array(), array('langcode' => 'en')),
    'glv' => t('Manx', array(), array('langcode' => 'en')),
    'gmh' => t('German, Middle High', array(), array('langcode' => 'en')),
    'goh' => t('German, Old High', array(), array('langcode' => 'en')),
    'gon' => t('Gondi', array(), array('langcode' => 'en')),
    'gor' => t('Gorontalo', array(), array('langcode' => 'en')),
    'got' => t('Gothic', array(), array('langcode' => 'en')),
    'grb' => t('Grebo', array(), array('langcode' => 'en')),
    'grc' => t('Greek, Ancient', array(), array('langcode' => 'en')),
    'gre' => t('Greek, Modern', array(), array('langcode' => 'en')),
    'grn' => t('Guarani', array(), array('langcode' => 'en')),
    'gsw' => t('Swiss German', array(), array('langcode' => 'en')),
    'guj' => t('Gujarati', array(), array('langcode' => 'en')),
    'gwi' => t("Gwich'in", array(), array('langcode' => 'en')),
    'hai' => t('Haida', array(), array('langcode' => 'en')),
    'hat' => t('Haitian French Creole', array(), array('langcode' => 'en')),
    'hau' => t('Hausa', array(), array('langcode' => 'en')),
    'haw' => t('Hawaiian', array(), array('langcode' => 'en')),
    'heb' => t('Hebrew', array(), array('langcode' => 'en')),
    'her' => t('Herero', array(), array('langcode' => 'en')),
    'hil' => t('Hiligaynon', array(), array('langcode' => 'en')),
    'him' => t('Himachali', array(), array('langcode' => 'en')),
    'hin' => t('Hindi', array(), array('langcode' => 'en')),
    'hit' => t('Hittite', array(), array('langcode' => 'en')),
    'hmn' => t('Hmong', array(), array('langcode' => 'en')),
    'hmo' => t('Hiri Motu', array(), array('langcode' => 'en')),
    'hsb' => t('Upper Sorbian', array(), array('langcode' => 'en')),
    'hun' => t('Hungarian', array(), array('langcode' => 'en')),
    'hup' => t('Hupa', array(), array('langcode' => 'en')),
    'iba' => t('Iban', array(), array('langcode' => 'en')),
    'ibo' => t('Igbo', array(), array('langcode' => 'en')),
    'ice' => t('Icelandic', array(), array('langcode' => 'en')),
    'ido' => t('Ido', array(), array('langcode' => 'en')),
    'iii' => t('Sichuan Yi', array(), array('langcode' => 'en')),
    'ijo' => t('Ijo', array(), array('langcode' => 'en')),
    'iku' => t('Inuktitut', array(), array('langcode' => 'en')),
    'ile' => t('Interlingue', array(), array('langcode' => 'en')),
    'ilo' => t('Iloko', array(), array('langcode' => 'en')),
    'ina' => t('Interlingua', array(), array('langcode' => 'en')),
    'inc' => t('Indic', array(), array('langcode' => 'en')),
    'ind' => t('Indonesian', array(), array('langcode' => 'en')),
    'ine' => t('Indo-European', array(), array('langcode' => 'en')),
    'inh' => t('Ingush', array(), array('langcode' => 'en')),
    'ipk' => t('Inupiaq', array(), array('langcode' => 'en')),
    'ira' => t('Iranian', array(), array('langcode' => 'en')),
    'iro' => t('Iroquoian', array(), array('langcode' => 'en')),
    'ita' => t('Italian', array(), array('langcode' => 'en')),
    'jav' => t('Javanese', array(), array('langcode' => 'en')),
    'jbo' => t('Lojban', array(), array('langcode' => 'en')),
    'jpn' => t('Japanese', array(), array('langcode' => 'en')),
    'jpr' => t('Judeo-Persian', array(), array('langcode' => 'en')),
    'jrb' => t('Judeo-Arabic', array(), array('langcode' => 'en')),
    'kaa' => t('Kara-Kalpak', array(), array('langcode' => 'en')),
    'kab' => t('Kabyle', array(), array('langcode' => 'en')),
    'kac' => t('Kachin', array(), array('langcode' => 'en')),
    'kal' => t('Kalâtdlisut', array(), array('langcode' => 'en')),
    'kam' => t('Kamba', array(), array('langcode' => 'en')),
    'kan' => t('Kannada', array(), array('langcode' => 'en')),
    'kar' => t('Karen languages', array(), array('langcode' => 'en')),
    'kas' => t('Kashmiri', array(), array('langcode' => 'en')),
    'kau' => t('Kanuri', array(), array('langcode' => 'en')),
    'kaw' => t('Kawi', array(), array('langcode' => 'en')),
    'kaz' => t('Kazakh', array(), array('langcode' => 'en')),
    'kbd' => t('Kabardian', array(), array('langcode' => 'en')),
    'kha' => t('Khasi', array(), array('langcode' => 'en')),
    'khi' => t('Khoisan', array(), array('langcode' => 'en')),
    'khm' => t('Khmer', array(), array('langcode' => 'en')),
    'kho' => t('Khotanese', array(), array('langcode' => 'en')),
    'kik' => t('Kikuyu', array(), array('langcode' => 'en')),
    'kin' => t('Kinyarwanda', array(), array('langcode' => 'en')),
    'kir' => t('Kyrgyz', array(), array('langcode' => 'en')),
    'kmb' => t('Kimbundu', array(), array('langcode' => 'en')),
    'kok' => t('Konkani', array(), array('langcode' => 'en')),
    'kom' => t('Komi', array(), array('langcode' => 'en')),
    'kon' => t('Kongo', array(), array('langcode' => 'en')),
    'kor' => t('Korean', array(), array('langcode' => 'en')),
    'kos' => t('Kusaie', array(), array('langcode' => 'en')),
    'kpe' => t('Kpelle', array(), array('langcode' => 'en')),
    'krc' => t('Karachay-Balkar', array(), array('langcode' => 'en')),
    'krl' => t('Karelian', array(), array('langcode' => 'en')),
    'kro' => t('Kru', array(), array('langcode' => 'en')),
    'kru' => t('Kurukh', array(), array('langcode' => 'en')),
    'kua' => t('Kuanyama', array(), array('langcode' => 'en')),
    'kum' => t('Kumyk', array(), array('langcode' => 'en')),
    'kur' => t('Kurdish', array(), array('langcode' => 'en')),
    'kut' => t('Kootenai', array(), array('langcode' => 'en')),
    'lad' => t('Ladino', array(), array('langcode' => 'en')),
    'lah' => t('Lahnda', array(), array('langcode' => 'en')),
    'lam' => t('Lamba', array(), array('langcode' => 'en')),
    'lao' => t('Lao', array(), array('langcode' => 'en')),
    'lat' => t('Latin', array(), array('langcode' => 'en')),
    'lav' => t('Latvian', array(), array('langcode' => 'en')),
    'lez' => t('Lezgian', array(), array('langcode' => 'en')),
    'lim' => t('Limburgish', array(), array('langcode' => 'en')),
    'lin' => t('Lingala', array(), array('langcode' => 'en')),
    'lit' => t('Lithuanian', array(), array('langcode' => 'en')),
    'lol' => t('Mongo-Nkundu', array(), array('langcode' => 'en')),
    'loz' => t('Lozi', array(), array('langcode' => 'en')),
    'ltz' => t('Luxembourgish', array(), array('langcode' => 'en')),
    'lua' => t('Luba-Lulua', array(), array('langcode' => 'en')),
    'lub' => t('Luba-Katanga', array(), array('langcode' => 'en')),
    'lug' => t('Ganda', array(), array('langcode' => 'en')),
    'lui' => t('Luiseño', array(), array('langcode' => 'en')),
    'lun' => t('Lunda', array(), array('langcode' => 'en')),
    'luo' => t('Luo', array(), array('langcode' => 'en')),
    'lus' => t('Lushai', array(), array('langcode' => 'en')),
    'mac' => t('Macedonian', array(), array('langcode' => 'en')),
    'mad' => t('Madurese', array(), array('langcode' => 'en')),
    'mag' => t('Magahi', array(), array('langcode' => 'en')),
    'mah' => t('Marshallese', array(), array('langcode' => 'en')),
    'mai' => t('Maithili', array(), array('langcode' => 'en')),
    'mak' => t('Makasar', array(), array('langcode' => 'en')),
    'mal' => t('Malayalam', array(), array('langcode' => 'en')),
    'man' => t('Mandingo', array(), array('langcode' => 'en')),
    'mao' => t('Maori', array(), array('langcode' => 'en')),
    'map' => t('Austronesian', array(), array('langcode' => 'en')),
    'mar' => t('Marathi', array(), array('langcode' => 'en')),
    'mas' => t('Masai', array(), array('langcode' => 'en')),
    'may' => t('Malay', array(), array('langcode' => 'en')),
    'mdf' => t('Moksha', array(), array('langcode' => 'en')),
    'mdr' => t('Mandar', array(), array('langcode' => 'en')),
    'men' => t('Mende', array(), array('langcode' => 'en')),
    'mga' => t('Irish, Middle', array(), array('langcode' => 'en')),
    'mic' => t('Micmac', array(), array('langcode' => 'en')),
    'min' => t('Minangkabau', array(), array('langcode' => 'en')),
    'mis' => t('Miscellaneous languages', array(), array('langcode' => 'en')),
    'mkh' => t('Mon-Khmer', array(), array('langcode' => 'en')),
    'mlg' => t('Malagasy', array(), array('langcode' => 'en')),
    'mlt' => t('Maltese', array(), array('langcode' => 'en')),
    'mnc' => t('Manchu', array(), array('langcode' => 'en')),
    'mni' => t('Manipuri', array(), array('langcode' => 'en')),
    'mno' => t('Manobo languages', array(), array('langcode' => 'en')),
    'moh' => t('Mohawk', array(), array('langcode' => 'en')),
    // 'mol' => t('Moldavian', array(), 'en'),  #Removed as per http://catalogablog.blogspot.com/2009/01/changes-to-marc-code-list-for-languages.html (see 'rum', array(), 'en')
    'mon' => t('Mongolian', array(), array('langcode' => 'en')),
    'mos' => t('Mooré', array(), array('langcode' => 'en')),
    'mul' => t('Multiple languages', array(), array('langcode' => 'en')),
    'mun' => t('Munda', array(), array('langcode' => 'en')),
    'mus' => t('Creek', array(), array('langcode' => 'en')),
    'mwl' => t('Mirandese', array(), array('langcode' => 'en')),
    'mwr' => t('Marwari', array(), array('langcode' => 'en')),
    'myn' => t('Mayan languages', array(), array('langcode' => 'en')),
    'myv' => t('Erzya', array(), array('langcode' => 'en')),
    'nah' => t('Nahuatl', array(), array('langcode' => 'en')),
    'nai' => t('North American Indian', array(), array('langcode' => 'en')),
    'nap' => t('Neapolitan Italian', array(), array('langcode' => 'en')),
    'nau' => t('Nauru', array(), array('langcode' => 'en')),
    'nav' => t('Navajo', array(), array('langcode' => 'en')),
    'nbl' => t('Ndebele', array(), array('langcode' => 'en')),
    'nde' => t('Ndebele', array(), array('langcode' => 'en')),
    'ndo' => t('Ndonga', array(), array('langcode' => 'en')),
    'nds' => t('Low German', array(), array('langcode' => 'en')),
    'nep' => t('Nepali', array(), array('langcode' => 'en')),
    'new' => t('Newari', array(), array('langcode' => 'en')),
    'nia' => t('Nias', array(), array('langcode' => 'en')),
    'nic' => t('Niger-Kordofanian', array(), array('langcode' => 'en')),
    'niu' => t('Niuean', array(), array('langcode' => 'en')),
    'nno' => t('Norwegian', array(), array('langcode' => 'en')),
    'nob' => t('Norwegian', array(), array('langcode' => 'en')),
    'nog' => t('Nogai', array(), array('langcode' => 'en')),
    'non' => t('Old Norse', array(), array('langcode' => 'en')),
    'nor' => t('Norwegian', array(), array('langcode' => 'en')),
    'nqo' => t("N'Ko", array(), array('langcode' => 'en')),
    'nso' => t('Northern Sotho', array(), array('langcode' => 'en')),
    'nub' => t('Nubian languages', array(), array('langcode' => 'en')),
    'nwc' => t('Newari, Old', array(), array('langcode' => 'en')),
    'nya' => t('Nyanja', array(), array('langcode' => 'en')),
    'nym' => t('Nyamwezi', array(), array('langcode' => 'en')),
    'nyn' => t('Nyankole', array(), array('langcode' => 'en')),
    'nyo' => t('Nyoro', array(), array('langcode' => 'en')),
    'nzi' => t('Nzima', array(), array('langcode' => 'en')),
    'oci' => t('Occitan', array(), array('langcode' => 'en')),
    'oji' => t('Ojibwa', array(), array('langcode' => 'en')),
    'ori' => t('Oriya', array(), array('langcode' => 'en')),
    'orm' => t('Oromo', array(), array('langcode' => 'en')),
    'osa' => t('Osage', array(), array('langcode' => 'en')),
    'oss' => t('Ossetic', array(), array('langcode' => 'en')),
    'ota' => t('Turkish, Ottoman', array(), array('langcode' => 'en')),
    'oto' => t('Otomian languages', array(), array('langcode' => 'en')),
    'paa' => t('Papuan', array(), array('langcode' => 'en')),
    'pag' => t('Pangasinan', array(), array('langcode' => 'en')),
    'pal' => t('Pahlavi', array(), array('langcode' => 'en')),
    'pam' => t('Pampanga', array(), array('langcode' => 'en')),
    'pan' => t('Panjabi', array(), array('langcode' => 'en')),
    'pap' => t('Papiamento', array(), array('langcode' => 'en')),
    'pau' => t('Palauan', array(), array('langcode' => 'en')),
    'peo' => t('Old Persian', array(), array('langcode' => 'en')),
    'per' => t('Persian', array(), array('langcode' => 'en')),
    'phi' => t('Philippine', array(), array('langcode' => 'en')),
    'phn' => t('Phoenician', array(), array('langcode' => 'en')),
    'pli' => t('Pali', array(), array('langcode' => 'en')),
    'pol' => t('Polish', array(), array('langcode' => 'en')),
    'pon' => t('Ponape', array(), array('langcode' => 'en')),
    'por' => t('Portuguese', array(), array('langcode' => 'en')),
    'pra' => t('Prakrit languages', array(), array('langcode' => 'en')),
    'pro' => t('Provençal', array(), array('langcode' => 'en')),
    'pus' => t('Pushto', array(), array('langcode' => 'en')),
    'que' => t('Quechua', array(), array('langcode' => 'en')),
    'raj' => t('Rajasthani', array(), array('langcode' => 'en')),
    'rap' => t('Rapanui', array(), array('langcode' => 'en')),
    'rar' => t('Rarotongan', array(), array('langcode' => 'en')),
    'roa' => t('Romance', array(), array('langcode' => 'en')),
    'roh' => t('Raeto-Romance', array(), array('langcode' => 'en')),
    'rom' => t('Romani', array(), array('langcode' => 'en')),
    'rum' => t('Romanian', array(), array('langcode' => 'en')),
    'run' => t('Rundi', array(), array('langcode' => 'en')),
    'rup' => t('Aromanian', array(), array('langcode' => 'en')),
    'rus' => t('Russian', array(), array('langcode' => 'en')),
    'sad' => t('Sandawe', array(), array('langcode' => 'en')),
    'sag' => t('Sango', array(), array('langcode' => 'en')),
    'sah' => t('Yakut', array(), array('langcode' => 'en')),
    'sai' => t('South American Indian', array(), array('langcode' => 'en')),
    'sal' => t('Salishan languages', array(), array('langcode' => 'en')),
    'sam' => t('Samaritan Aramaic', array(), array('langcode' => 'en')),
    'san' => t('Sanskrit', array(), array('langcode' => 'en')),
    'sas' => t('Sasak', array(), array('langcode' => 'en')),
    'sat' => t('Santali', array(), array('langcode' => 'en')),
    'scc' => t('Serbian', array(), array('langcode' => 'en')),
    'scn' => t('Sicilian Italian', array(), array('langcode' => 'en')),
    'sco' => t('Scots', array(), array('langcode' => 'en')),
    'scr' => t('Croatian', array(), array('langcode' => 'en')),
    'sel' => t('Selkup', array(), array('langcode' => 'en')),
    'sem' => t('Semitic', array(), array('langcode' => 'en')),
    'sga' => t('Irish, Old', array(), array('langcode' => 'en')),
    'sgn' => t('Sign languages', array(), array('langcode' => 'en')),
    'shn' => t('Shan', array(), array('langcode' => 'en')),
    'sid' => t('Sidamo', array(), array('langcode' => 'en')),
    'sin' => t('Sinhalese', array(), array('langcode' => 'en')),
    'sio' => t('Siouan', array(), array('langcode' => 'en')),
    'sit' => t('Sino-Tibetan', array(), array('langcode' => 'en')),
    'sla' => t('Slavic', array(), array('langcode' => 'en')),
    'slo' => t('Slovak', array(), array('langcode' => 'en')),
    'slv' => t('Slovenian', array(), array('langcode' => 'en')),
    'sma' => t('Southern Sami', array(), array('langcode' => 'en')),
    'sme' => t('Northern Sami', array(), array('langcode' => 'en')),
    'smi' => t('Sami', array(), array('langcode' => 'en')),
    'smj' => t('Lule Sami', array(), array('langcode' => 'en')),
    'smn' => t('Inari Sami', array(), array('langcode' => 'en')),
    'smo' => t('Samoan', array(), array('langcode' => 'en')),
    'sms' => t('Skolt Sami', array(), array('langcode' => 'en')),
    'sna' => t('Shona', array(), array('langcode' => 'en')),
    'snd' => t('Sindhi', array(), array('langcode' => 'en')),
    'snk' => t('Soninke', array(), array('langcode' => 'en')),
    'sog' => t('Sogdian', array(), array('langcode' => 'en')),
    'som' => t('Somali', array(), array('langcode' => 'en')),
    'son' => t('Songhai', array(), array('langcode' => 'en')),
    'sot' => t('Sotho', array(), array('langcode' => 'en')),
    'spa' => t('Spanish', array(), array('langcode' => 'en')),
    'srd' => t('Sardinian', array(), array('langcode' => 'en')),
    'srn' => t('Sranan', array(), array('langcode' => 'en')),
    'srr' => t('Serer', array(), array('langcode' => 'en')),
    'ssa' => t('Nilo-Saharan', array(), array('langcode' => 'en')),
    'ssw' => t('Swazi', array(), array('langcode' => 'en')),
    'suk' => t('Sukuma', array(), array('langcode' => 'en')),
    'sun' => t('Sundanese', array(), array('langcode' => 'en')),
    'sus' => t('Susu', array(), array('langcode' => 'en')),
    'sux' => t('Sumerian', array(), array('langcode' => 'en')),
    'swa' => t('Swahili', array(), array('langcode' => 'en')),
    'swe' => t('Swedish', array(), array('langcode' => 'en')),
    'syc' => t('Syriac', array(), array('langcode' => 'en')),
    'syr' => t('Syriac, Modern', array(), array('langcode' => 'en')),
    'tah' => t('Tahitian', array(), array('langcode' => 'en')),
    'tai' => t('Tai', array(), array('langcode' => 'en')),
    'tam' => t('Tamil', array(), array('langcode' => 'en')),
    'tat' => t('Tatar', array(), array('langcode' => 'en')),
    'tel' => t('Telugu', array(), array('langcode' => 'en')),
    'tem' => t('Temne', array(), array('langcode' => 'en')),
    'ter' => t('Terena', array(), array('langcode' => 'en')),
    'tet' => t('Tetum', array(), array('langcode' => 'en')),
    'tgk' => t('Tajik', array(), array('langcode' => 'en')),
    'tgl' => t('Tagalog', array(), array('langcode' => 'en')),
    'tha' => t('Thai', array(), array('langcode' => 'en')),
    'tib' => t('Tibetan', array(), array('langcode' => 'en')),
    'tig' => t('Tigré', array(), array('langcode' => 'en')),
    'tir' => t('Tigrinya', array(), array('langcode' => 'en')),
    'tiv' => t('Tiv', array(), array('langcode' => 'en')),
    'tkl' => t('Tokelauan', array(), array('langcode' => 'en')),
    'tlh' => t('Klingon', array(), array('langcode' => 'en')),
    'tli' => t('Tlingit', array(), array('langcode' => 'en')),
    'tmh' => t('Tamashek', array(), array('langcode' => 'en')),
    'tog' => t('Tonga', array(), array('langcode' => 'en')),
    'ton' => t('Tongan', array(), array('langcode' => 'en')),
    'tpi' => t('Tok Pisin', array(), array('langcode' => 'en')),
    'tsi' => t('Tsimshian', array(), array('langcode' => 'en')),
    'tsn' => t('Tswana', array(), array('langcode' => 'en')),
    'tso' => t('Tsonga', array(), array('langcode' => 'en')),
    'tuk' => t('Turkmen', array(), array('langcode' => 'en')),
    'tum' => t('Tumbuka', array(), array('langcode' => 'en')),
    'tup' => t('Tupi languages', array(), array('langcode' => 'en')),
    'tur' => t('Turkish', array(), array('langcode' => 'en')),
    'tut' => t('Altaic', array(), array('langcode' => 'en')),
    'tvl' => t('Tuvaluan', array(), array('langcode' => 'en')),
    'twi' => t('Twi', array(), array('langcode' => 'en')),
    'tyv' => t('Tuvinian', array(), array('langcode' => 'en')),
    'udm' => t('Udmurt', array(), array('langcode' => 'en')),
    'uga' => t('Ugaritic', array(), array('langcode' => 'en')),
    'uig' => t('Uighur', array(), array('langcode' => 'en')),
    'ukr' => t('Ukrainian', array(), array('langcode' => 'en')),
    'umb' => t('Umbundu', array(), array('langcode' => 'en')),
    'und' => t('Undetermined', array(), array('langcode' => 'en')),
    'urd' => t('Urdu', array(), array('langcode' => 'en')),
    'uzb' => t('Uzbek', array(), array('langcode' => 'en')),
    'vai' => t('Vai', array(), array('langcode' => 'en')),
    'ven' => t('Venda', array(), array('langcode' => 'en')),
    'vie' => t('Vietnamese', array(), array('langcode' => 'en')),
    'vol' => t('Volapük', array(), array('langcode' => 'en')),
    'vot' => t('Votic', array(), array('langcode' => 'en')),
    'wak' => t('Wakashan languages', array(), array('langcode' => 'en')),
    'wal' => t('Wolayta', array(), array('langcode' => 'en')),
    'war' => t('Waray', array(), array('langcode' => 'en')),
    'was' => t('Washo', array(), array('langcode' => 'en')),
    'wel' => t('Welsh', array(), array('langcode' => 'en')),
    'wen' => t('Sorbian', array(), array('langcode' => 'en')),
    'wln' => t('Walloon', array(), array('langcode' => 'en')),
    'wol' => t('Wolof', array(), array('langcode' => 'en')),
    'xal' => t('Oirat', array(), array('langcode' => 'en')),
    'xho' => t('Xhosa', array(), array('langcode' => 'en')),
    'yao' => t('Yao', array(), array('langcode' => 'en')),
    'yap' => t('Yapese', array(), array('langcode' => 'en')),
    'yid' => t('Yiddish', array(), array('langcode' => 'en')),
    'yor' => t('Yoruba', array(), array('langcode' => 'en')),
    'ypk' => t('Yupik languages', array(), array('langcode' => 'en')),
    'zap' => t('Zapotec', array(), array('langcode' => 'en')),
    'zbl' => t('Blissymbolics', array(), array('langcode' => 'en')),
    'zen' => t('Zenaga', array(), array('langcode' => 'en')),
    'zha' => t('Zhuang', array(), array('langcode' => 'en')),
    'znd' => t('Zande languages', array(), array('langcode' => 'en')),
    'zul' => t('Zulu', array(), array('langcode' => 'en')),
    'zun' => t('Zuni', array(), array('langcode' => 'en')),
    'zxx' => t('No linguistic content', array(), array('langcode' => 'en')),
    'zza' => t('Zaza', array(), array('langcode' => 'en'))
  );

  $_key_to_name['type'] = array(
    'object' => t('Object', array(), array('langcode' => 'en')),
    'photo' => t('Photo', array(), array('langcode' => 'en')),
    'projected' => t('Projected medium', array(), array('langcode' => 'en')),
    'kit' => t('Kit', array(), array('langcode' => 'en')),
    'map' => t('Map', array(), array('langcode' => 'en')),
    'file' => t('Computer file', array(), array('langcode' => 'en')),
    'sheet' => t('Sheet music', array(), array('langcode' => 'en')),
    'periodical' => t('Periodical', array(), array('langcode' => 'en')),
    'book' => t('Book', array(), array('langcode' => 'en')),
    'sound' => t('Sound recording', array(), array('langcode' => 'en')),
    'music' => t('Music', array(), array('langcode' => 'en')),
    'manuscript' => t('Manuscript', array(), array('langcode' => 'en')),
    'dvd' => t('DVD', array(), array('langcode' => 'en')),
    'vhs' => t('VHS', array(), array('langcode' => 'en')),
    'cassette' => t('Cassette', array(), array('langcode' => 'en')),
    'cd' => t('CD', array(), array('langcode' => 'en'))
  );
}

/**
 * Implements hook_permission().
 */
function millennium_permission() {
  return array(
    'administer millennium' => array(
      'title' => t('administer millennium'),
      'description' => t('TODO Add a description for \'administer millennium\''),
    ),
    'use millennium mass import/refresh' => array(
      'title' => t('use millennium mass import/refresh'),
      'description' => t('TODO Add a description for \'use millennium mass import/refresh\''),
    ),
    'import single millennium items' => array(
      'title' => t('import single millennium items'),
      'description' => t('TODO Add a description for \'import single millennium items\''),
    ),
    'view millennium marc' => array(
      'title' => t('view millennium marc'),
      'description' => t('TODO Add a description for \'view millennium marc\''),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function millennium_menu() {
  $items = array();

  $items[MILLENNIUM_SETTINGS_PATH] = array(
    'title' => 'Millennium settings',
    'description' => 'Configure basic WebOPAC and crawl settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('millennium_admin_settings_form'),
    'access callback' => 'user_access',
    'access arguments' => array('administer millennium'),
    'file' => 'millennium.admin.inc',
  );

  $items[MILLENNIUM_SETTINGS_PATH . '/settings'] = array(
    'title' => 'General',
    'access arguments' => array('administer millennium'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items[MILLENNIUM_SETTINGS_PATH . '/crawl'] = array(
    'title' => 'Automatic crawl',
    'description' => 'Configure automatic crawl settings.',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('millennium_admin_crawl'),
    'access callback' => 'user_access',
    'access arguments' => array('administer millennium'),
    'file' => 'millennium.admin.inc',
  );
  $items[MILLENNIUM_SETTINGS_PATH . '/map'] = array(
    'title' => 'Taxonomy mapping',
    'description' => 'Configure MARC import mapping settings.',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('millennium_admin_mapping'),
    'access callback' => 'user_access',
    'access arguments' => array('administer millennium'),
    'file' => 'millennium.admin.inc',
  );
  $items[MILLENNIUM_SETTINGS_PATH . '/display'] = array(
    'title' => 'Display',
    'description' => 'Configure node view settings: cover images, holdings information, etc.',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('millennium_admin_display'),
    'access callback' => 'user_access',
    'access arguments' => array('administer millennium'),
    'file' => 'millennium.admin.inc',
  );

  $items['admin/content/millennium'] = array(
    'title' => 'Millennium batch import/refresh',
    'description' => "Mass import from catalog or refresh imported items' mappings.",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('millennium_admin_queue'),
    'access callback' => 'user_access',
    'access arguments' => array('use millennium mass import/refresh'),
    'file' => 'millennium.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['millennium/import'] = array(
    'title' => 'Millennium node import',
    'page callback' => 'millennium_node_import',
    'access callback' => 'user_access',
    'access arguments' => array('import single millennium items'),
    'type' => MENU_CALLBACK,
    'file' => 'millennium.pages.inc',
  );
  $items['millennium/preview'] = array(
    'title' => 'Millennium node import preview',
    'page callback' => 'millennium_preview_import',
    'access callback' => 'user_access',
    'access arguments' => array('import single millennium items'),
    'type' => MENU_CALLBACK,
    'file' => 'millennium.pages.inc',
  );

  $items['admin/reports/millennium'] = array(
    'title' => 'Millennium import statistics',
    'description' => 'Overview of Millennium module performance, number of imported items and latest history.',
    'page callback' => 'millennium_admin_status',
    'access arguments' => array('administer millennium'),
    'file' => 'millennium.pages.inc',
  );

  $items['millennium_ajax'] = array(
    'page callback' => 'millennium_ajax_handler',
    'type' => MENU_CALLBACK,
    'access arguments' => array('access content'),
    'file' => 'millennium.pages.inc',
  );
  $items['node/%node/millennium'] = array(
    'title' => 'Millennium Tools',
    'description' => 'Millennium tools for node',
    'page callback' => 'millennium_node_tools',
    'page arguments' => array(1),
    'access callback' => 'millennium_tools_tab_access',
    'access arguments' => array(1),
    'weight' => 10,
    'type' => MENU_LOCAL_TASK,
    'file' => 'millennium.pages.inc',
  );
  $items['node/%node/marc'] = array(
    'title' => 'MARC display',
    'description' => 'MARC display for node',
    'page callback' => 'millennium_node_marc_tab',
    'page arguments' => array(1),
    'access callback' => 'millennium_marc_tab_access',
    'access arguments' => array(1),
    'weight' => 0,
    'type' => MENU_LOCAL_TASK,
    'file' => 'millennium.pages.inc',
  );
  $items['node/%node/millennium/reimport'] = array(
    'title' => 'Millennium node reimport',
    'page callback' => 'millennium_node_reimport',
    'page arguments' => array(1),
    'access callback' => 'user_access',
    'access arguments' => array('import single millennium items'),
    'type' => MENU_CALLBACK,
    'file' => 'millennium.pages.inc',
  );
  return $items;
}

/**
 * Callback function from hook_menu to determine if marc tab should be shown
 */
function millennium_marc_tab_access($node) {
  if (isset($node->millennium_biblio_data) && $node->millennium_biblio_data["marc"] && user_access("view millennium marc")) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Callback function from hook_menu to determine if millennium tools tab should be shown
 */
function millennium_tools_tab_access($node) {
  $bib_recnum = millennium_bib_recnum_from_node($node->nid);
  if ($bib_recnum &&
    (user_access("administer millennium") || user_access("import single millennium items"))) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implements hook_cron().
 */
function millennium_cron() {
  module_load_include('inc', 'millennium', 'millennium.cron');
  millennium_cron_do();
}

/**
 * Implements hook_theme().
 */
function millennium_theme() {
  return array(
    'millennium_holdings' => array(
      'file' => 'millennium.theme.inc',
      'variables' => array(
        'nid' => NULL,
        'holdings' => NULL,
        'page' => TRUE,
      ),
    ),
    'millennium_biblio_data' => array(
      'file' => 'millennium.theme.inc',
      'variables' => array(
        'biblio_data' => NULL,
        'mode' => 'full',
      ),
    ),
    'millennium_coverimage_widget' => array(
      'file' => 'millennium.theme.inc',
      'variables' => array(
        'biblio_data' => NULL,
        'nid' => NULL,
      ),
    ),
  );
}

/**
 * Implements hook_node_load().
 */
function millennium_node_load($nodes, $types) {
  foreach ($nodes as $node) {;
    if (! isset($node->nid)) {
      return;
    }
    $biblio_data = millennium_get_biblio_data($node->nid);

    // Let other modules add/change custom bibliographic data when fetching it
    //   from the database.
    // Function signature: mymodule_millennium_load_biblio_data_alter($node, &$biblio)
    drupal_alter("millennium_load_biblio_data", $biblio_data, $node);
    $node->millennium_biblio_data = $biblio_data;
  }
}

/**
 * Implements hook_node_delete().
 */
function millennium_node_delete($node) {
  db_delete('millennium_node_bib')
    ->condition('nid', $node->nid)
    ->execute();
  db_delete('millennium_bib_item')
    ->condition('nid', $node->nid)
    ->execute();
}

/**
 * Implements hook_node_view().
 */
function millennium_node_view($node, $view_mode) {
  static $googleapi_js_included = FALSE;
  if (!isset($node->nid)) {
    return;
  }
  $bib_recnum = millennium_bib_recnum_from_node($node->nid);
  if (! $bib_recnum) {
    return;
  }
  switch ($view_mode) {
    case 'rss':
      $table = theme('millennium_biblio_data', array('biblio_data' => $node->millennium_biblio_data, 'mode' => "full"));
      $coverimage_widget = theme('millennium_coverimage_widget', array('biblio_data' => $node->millennium_biblio_data));
      $content = $coverimage_widget . $table;
      $node->rss_elements[] = array(
        'key' => 'description',
        'value' => $content,
      );
      // TODO: Add <enclosure> tag to RSS feeds: see API docs for node_feed()
    case 'full':
    case 'teaser':
      // Authors
      $authors_output = array();
      foreach (array('authors', 'corp_author') as $field) {
        if (isset($node->millennium_biblio_data[$field])) {
          $author = $node->millennium_biblio_data[$field];
          if (sizeof($author) > 0) {
            $authors_output = array_merge($authors_output, $author);
          }
        }
      }
      if (sizeof($authors_output)) {
        $node->content['millennium_authors'] = array(
              '#markup' => "<div class='millennium authors'>" . t('by @authors', array('@authors' => implode('; ', $authors_output))) . "</div>\n",
              '#weight' => millennium_element_weight('millennium_authors', $view_mode),
            );
      }

      // Type, year
      if (isset($node->millennium_biblio_data["imprint_date"])) {
        $year = intval($node->millennium_biblio_data["imprint_date"]);
        $year = ($year > 1400) ? " / {$year}" : "";
        $node->content['millennium_extra'] = array(
              '#markup' => "<div class='millennium extra'>" . _millennium_human_string($node->millennium_biblio_data, "type") . $year . "</div>\n",
              '#weight' => millennium_element_weight('millennium_extra', $view_mode),
            );
      }

      // Determine ISBN for Google Books API
      if (is_array($node->millennium_biblio_data["isbn"]) && sizeof($node->millennium_biblio_data["isbn"]) > 0) {
        $search_isbn = $node->millennium_biblio_data["isbn"][0];
      }
      else {
        $search_isbn = '';
      }

      // Add div and JS to handle links to google books
      $gbooks_flag = variable_get('millennium_googlebooks', FALSE);
      if ($search_isbn && $gbooks_flag !== FALSE) {
        if (
                ($view_mode == "teaser" && $gbooks_flag == "teaser") || ($view_mode == "full" && $gbooks_flag != "No")
              ) {
          drupal_add_js( drupal_get_path('module', 'millennium') . '/millennium_googlebooks.js');
          drupal_add_js(array('millennium' => array('gbooks' => array($node->nid => $search_isbn))), array('type' => 'setting', 'scope' => JS_DEFAULT));
          drupal_add_js(array('millennium' => array('gbooks_replace_covers' => variable_get('millennium_googlebooks_covers', TRUE))), array('type' => 'setting', 'scope' => JS_DEFAULT));
          $node->content['millennium_google_books'] = array(
                '#markup' => "<div id='gbooks-link-$search_isbn' class='millennium gbook'></div>",
                '#weight' => millennium_element_weight('millennium_google_books', $view_mode),
              );
        }
      }

      // Add div and JS to handle google embedded book reader widget
      if ($search_isbn && $view_mode == "full" && variable_get('millennium_googlebooks_widget', 0)) {
        drupal_add_js('http://www.google.com/jsapi', array('type' => 'external'));
        drupal_add_js('google.load("books", "0");', array('type' => 'inline', 'scope' => JS_DEFAULT));
        drupal_add_js( drupal_get_path('module', 'millennium') . '/millennium_googlebooks.js');
        $node->content['millennium_googlebookswidget'] = array(
              '#markup' => "<div id='gbooks-widget-$search_isbn'></div>", #'<div id="gbooks-widget-" style="width:100%; height:400px"></div>',
              '#weight' => millennium_element_weight('millennium_googlebookswidget', $view_mode),
            );
      }

      // Coverimage
      $coverimage_widget = theme('millennium_coverimage_widget', array('biblio_data' => $node->millennium_biblio_data));
      if ($coverimage_widget) {
        $node->content['millennium_coverimage'] = array(
              '#markup' => $coverimage_widget,
              '#weight' => millennium_element_weight('millennium_coverimage', $view_mode),
            );
      }

      //Show holdings information
      $show_holdings = variable_get("millennium_realtime_holdings", 'full');
      $holdings_widget = millennium_holdings_widget($node->nid, ($view_mode == 'full'), $show_holdings);
      if ($holdings_widget) {
        $node->content['millennium_holdings'] = array(
              '#markup' => $holdings_widget,
              '#weight' => millennium_element_weight('millennium_holdings', $view_mode),
            );
      }

      // Show biblio data table
      $biblio_table_flag = variable_get('millennium_display_biblio_data', 'teaser');
      if (
           ($view_mode != "full"  && $biblio_table_flag == "teaser")
            || ($view_mode == "full" && $biblio_table_flag !== "0")
          ) {
        $node->content['millennium_biblio_data'] = array(
              '#markup' => theme("millennium_biblio_data", array('biblio_data' => $node->millennium_biblio_data, 'mode' => $view_mode)),
              '#weight' => millennium_element_weight('millennium_biblio_data', $view_mode),
            );
      }
  }
}

/**
 * Implements hook_link().
 */
function millennium_link($type, $node = NULL, $teaser = FALSE) {
  $links = array();
  if (! $node || $teaser) {
    return $links;
  }
  $nid = $node->nid;

  // Place hold url
  //    http://example.com/search?/.i[item rec num]/.b[bib rec num]/1%2C1%2C1%2CB/request%7Eb[bib rec num]
  // Another example:
  //    http://example.com/search~S16?/.i[item rec num]/.b[bib rec num]/1%2C1%2C1%2CB/request~b2405160
  $bib_recnum = millennium_bib_recnum_from_node($nid);
  if (! $bib_recnum) {
    return $links;
  }

  $base_url = db_query("SELECT base_url FROM {millennium_node_bib} WHERE nid = :nid", array(':nid' => $nid))->fetchField();
  if (variable_get('millennium_display_hold_link', 1)) {
    $hold_url = millennium_permalink($bib_recnum, $base_url, "hold");
    $links["millennium_holds"] = array(
      'title' => t('Place hold or request delivery'),
      'href' => $hold_url,
      'attributes' => array(
        'title' => t('Reserve an unavailable item or request delivery of items from other locations'),
        'id' => 'millennium-hold-nid-' . $nid,
        'class' => array('millennium', 'hold'),
        'rel' => 'nofollow',
      ),
    );
  }
  if (variable_get('millennium_display_hold_link', 1)) {
    $record_url = millennium_permalink($bib_recnum, $base_url);
    $links["millennium_record"] = array(
      'title' => t('View source record'),
      'href' => $record_url,
      'attributes' => array(
        'title' => t('View the source record at the library catalog'),
        'id' => 'millennium-record-nid-' . $nid,
        'class' => array('millennium', 'record'),
        'rel' => 'nofollow',
      ),
    );
  }
  return $links;
}

/**
 * Implements hook_block_info().
 */
function millennium_block_info() {
  return array(
        'marc' => array('info' => t('Millennium: MARC')),
        //'citation' => array('info' => t('Millennium: APA citation')),
        'biblio_data' => array('info' => t('Millennium: bibliographic data table')),
      );
}

/**
 * Implements hook_block_view().
 */
function millennium_block_view($delta) {
  if (arg(0) != 'node' || !is_numeric(arg(1))) {
    return "";
  }
  $nid = arg(1);
  if (! $bib_recnum = millennium_bib_recnum_from_node($nid)) {
    return "";
  }
  $node = node_load($nid);
  $blocks = array();

  switch ($delta) {
    case "marc":
      $marc_text = $node->millennium_biblio_data['marc'];
      if (!$marc_text || !user_access("view marc")) {
        return FALSE;
      }
      return array(
            'subject' => t('Millennium: MARC'),
            'content' => '<pre class="millennium marc">' . $marc_text . '</pre>',
          );
      break;
    case 'biblio_data':
      $table = theme("millennium_biblio_data", array('biblio_data' => $node->millennium_biblio_data));
      return array(
            'subject' => t('Millennium: bibliographic data table'),
            'content' => $table,
          );
      break;
  }
  return $blocks;
}

/**
 * Implements hook_help().
 */
function millennium_help($path, $arg) {
  switch ($path) {
    case 'admin/help#millennium':
      $path = drupal_get_path('module', 'millennium') . '/docs';
      $help_contents = file_get_contents( $path . "/index.htm");
      // Extract the body.
      $help_contents = preg_replace('%^.*<body>.*</body>.*$%', '\1', $help_contents);
      // Rewrite <img> tag urls.
      $help_contents = str_replace('files/', url($path) . "/files/", $help_contents);
      // Rewrite admin urls.
      $base = url('<front>');
      $help_contents = preg_replace('%(admin/[a-z/]+|millennium/preview)%', "<a href={$base}\\1>\\1</a>", $help_contents);
      return $help_contents;
  }
}

/**
 * Implements hook_token_list().
 */
function millennium_token_list($type = 'all') {
  if ($type == 'node') {
    $tokens['node']['millennium-year']    = t("Millennium: Publication year");
    $tokens['node']['millennium-authors'] = t("Millennium: Authors");
    $tokens['node']['millennium-type']    = t("Millennium: Type Name (e.g.: book)");
    $tokens['node']['millennium-bib-recnum']    = t("Millennium: Bibliographic Record #");
    return $tokens;
  }
}

/**
 * Implements hook_token_values().
 */
function millennium_token_values($type, $object = NULL) {
  switch ($type) {
    case 'node':
      $bib_recnum = millennium_bib_recnum_from_node($object->nid);
      if (! $bib_recnum) {
        break;
      }
      $bib_recnum = millennium_bib_recnum_from_node($object->nid);
      $biblio_data = millennium_get_biblio_data($object->nid);
      $year = intval($biblio_data["imprint_date"]);
      $values['millennium-year']    = check_plain($year);
      $values['millennium-bib-recnum']     = check_plain($bib_recnum);
      $values['millennium-authors'] = check_plain(implode("-", $biblio_data["authors"]));
      $values['millennium-type']    = check_plain($biblio_data["type"]);
      return $values;
  }

  // No group info found. Return defaults.
  $values['millennium-bib-recnum'] = '';
  $values['millennium-year'] = '';
  $values['millennium-authors'] = '';
  $values['millennium-type'] = '';
  return $values;
}

function _millennium_human_string($biblio_data, $fieldkey, $translate = TRUE, $lang = NULL) {
  global $_key_to_name;
  if (!isset($biblio_data[$fieldkey])) {
    return '';
  }
  $string = $_key_to_name[$fieldkey][$biblio_data[$fieldkey]];

  // Note: passing a variable to t is permitted here because the strings are guaranteed
  // to be found as string literals in the array initialization code of $_key_to_name

  if ($string) {
    if ($translate) {
      if (!$lang) {
        // Return string translated to current site language
        return t($string);
      }
      // Return string translated to a predefined language
      // (usually site default language)
      return t($string, array(), array('langcode' => $lang));
    }
    // Return untranslated English string
    return $string;
  }
  return $biblio_data[$fieldkey];
}

/**
 * Validates that a parsed language code is actually a valid
 * MARC language code
 */
function millennium_valid_language($language_code) {
  global $_key_to_name;
  if (!isset($_key_to_name)) {
    millennium_init();
  }
  return array_key_exists($language_code, $_key_to_name['lang']);
}

/**
 * Main function that imports, updates or deletes item or bibliographic records.
 * It can optionally take in a MARC record to bypass harvesting from the WebOPAC.
 * @param $data
 *   An associative array of data for a record, with the following keys:
 *     - 'bib_recnum' (optional)
 *       Millennium record number (b123456) for the record to process.
 *     - 'item_recnum' (optional)
 *       A Millennium record number (i123456) for the record to process.
 *       If bib_recnum is also given, it is assumed it is the bib record
 *       associated with this item.
 *     - 'marc' (optional)
 *       MARC text as it is exported from the WebOPAC.
 * @param bool $force_update (Optional) States if the function should always update existing data.
 */
function millennium_process_record(&$data, $force_update = FALSE) {
  // Set defaults
  if (!isset($data['marc'])) {
    $data['marc'] = NULL;
  }
  if (!isset($data['item_recnum'])) {
    $data['item_recnum'] = NULL;
  }
  if (!isset($data['bib_recnum'])) {
    $data['bib_recnum'] = NULL;
  }
  #drupal_set_message("millennium_process_record():");
  #dpm($data);

  $type = "";
  // If only bib_recnum
  if ($data['bib_recnum'] && !$data['item_recnum']) {
    $type = "bib";
  }
  // If only item_recnum set, or if both record numbers set:
  if (
    (!$data['bib_recnum'] && $data['item_recnum']) ||
    ($data['bib_recnum'] && $data['item_recnum'])) {
    $type = "item";
  }

  switch ($type) {
    case "bib":
      $result = millennium_process_bib_record(
        $data,
        $force_update
      );
      break;
    case "item":
      $result = millennium_process_item_record(
        $data,
        $force_update
      );
      break;
    default:
      watchdog("Millennium", "millennium_process_record() unknown record type: @data", array('@data' => var_export($data, TRUE)));
      return array("success" => FALSE, "error" => "Could not determine function to call.");
  }

  if ($result["node"]) {
    $data["node"] = $result["node"];
  }
  #dpm($result);
  // Log errors
  if ($result['success'] !== TRUE) {
    watchdog("Millennium", "millennium_process_record() failed with error @error", array('@error' => $result['error']));
  }

  return array("success" => $result['success'], 'status' => $result['status'], 'error' => isset($result['error']) ? $result['error'] : '');
}

/**
 * Imports or updates Millennium item records in Drupal
 * @param array $data Millennium record information
 * @param bool $force_update (Optional) States if an existing node for that item record number should be updated.
 */
function millennium_process_item_record($data, $force_update = TRUE) {
  #drupal_set_message("millennium_process_item_record($item_recnum, $force_update, $marc_text, $bib_recnum)");

  if ($data['base_url']) {
    $base_url = $data['base_url'];
  }
  else {
    return array("success" => FALSE, "error" => "No base_url in item #" . $data['item_recnum']);
  }

  // Had we already imported this item record?
  $item_import_history = db_query("SELECT * FROM {millennium_bib_item} WHERE item_recnum = :item_recnum AND base_url = :base_url", array(':item_recnum' => $data['item_recnum'], ':base_url' => $base_url))->fetchObject();
  if ($item_import_history->nid) {
    #drupal_set_message("Item $item_recnum was imported before");
    // Item was imported before.
    $status = millennium_process_item_record_prev_imported($data, $item_import_history, $force_update = TRUE);
    $node = node_load($item_import_history->nid);
    return array(
      "success" => TRUE,
      "status" => $status['result'],
      "node" => $node,
      #"error" => t("This item #@item_number had already been imported under nid @nid", array("@item_number" => $item_recnum, "@nid" => $item_import_history->nid))
    );
  }
  else {
    // Item was not imported before.
    // If not given as the function's argument, get the item's bib record number.
    if ($bib_recnum == NULL) {
      $result = millennium_fetch_recordpage($data['item_recnum'], $base_url, 'plain');
      $record_html = $result->data;
      $ok = preg_match('/\/record=(b[0-9]+)/si', $record_html, $matches);
      if ($ok) {
        $bib_recnum = $matches[1];
      }
    }
  }

  if (!$bib_recnum) {
    return array("success" => FALSE, "error" => "Could not get bib_recnum for item #" . $data['item_recnum']);
  }

  // We have a bib_number by now.
  // Is there an existing node with this bib_number?
  $bib_import_history = db_query("SELECT * FROM {millennium_node_bib} WHERE bib_recnum = :bib_recnum AND base_url = :base_url", array(':bib_recnum' => $bib_recnum, ':base_url' => $base_url))->fetchObject();
  if (!$bib_import_history->nid) {
    // New item, new bib.
    // Must the node for the bib before the item can be imported.
    $data = array('bib_recnum' => $bib_recnum, 'marc' => $marc_text);
    $result = millennium_process_bib_record($data, $force_update);
    if ($result["success"] != TRUE) {
      return array("success" => FALSE, "error" => "Could not create a new node for item: " . $data['item_recnum'] . " and bib: " . $data['bib_recnum']);
    }
    else {
      $nid = $result["node"]->nid;
    }
  }
  else {
    $nid = $bib_import_history->nid;
  }

  // Do actual import of new item.
  $ok = millennium_process_item_record_new_import($data, $nid);
  if ($ok) {
    return array('success' => TRUE, 'status' => 'item_created');
  }
  else {
    return array('success' => FALSE, 'error' => "Could not create a new item for item $item_recnum");
  }
}

/**
 * Handle processing an item record when it had not been previously imported.
 */
function millennium_process_item_record_new_import($data, $nid) {
  // Link item to bib, node
  $record = array('nid' => $nid, 'bib_recnum' => $data['bib_recnum'], 'item_recnum' => $data['item_recnum'],
        'updated' => date("Y-m-d H:i:s"), 'created' => date("Y-m-d H:i:s"), 'base_url' => $data['base_url']);
  $result = drupal_write_record('millennium_bib_item', $record);
  if (!$result) {
    drupal_set_message("millennium_process_item_record_new_import: drupal_write_record('millennium_bib_item') returned FALSE");
    return FALSE;
  }
  // Re-publish node in case it had been unpublished.
  db_update('node')
    ->fields(array(
      'status' => 1,
    ))
    ->condition('nid', $nid)
    ->execute();
  return TRUE;
}

/**
 * Handle processing an item record when it had been previously imported.
 */
function millennium_process_item_record_prev_imported($data, $import_history, $force_update = TRUE) {
  static $xml_disabled = FALSE;

  $stale_record_age = (3600 * 24 * 30); // 30 days
  $is_stale = (REQUEST_TIME > (strtotime($import_history->updated) + $stale_record_age));
  if ($is_stale || $force_update) {
    // Update the item record.

    if ($xml_disabled == FALSE) {
      // Get the item's data
      $result = millennium_fetch_recordpage($data['item_recnum'], $data['base_url'], 'xml');
      $bib_xml = $result->data;
      if (stripos($item_xml, "403 Forbidden")) {
        drupal_set_message(t("XML disabled in WebOPAC."));
      }

      // Handle item not found
      if (stripos($item_xml, "Cannot find record=") > 0) {
        millennium_handle_deleted_item($data, $import_history);
        return array(
          "result" => "item_deleted",
          "error" => "Item " . $data['item_recnum'] . " was deleted.",
          );
      }

      // TODO: Do actual updating here...
      // From xrecord: Use ICODEs? LOCATION? OUT DATE? YTDCIRC? TOTCIRC?
      // From imported history: Expiry time? (millennium_bib_item.updated)
      // Extract last update date
      //  <LASTUPDATEDATE>26-09-2007</LASTUPDATEDATE>
      /*
      $ok = preg_match('/<LASTUPDATEDATE>(..)-(..)-(....)<\/LASTUPDATEDATE>/si', $bib_xml, $matches);
      if (!$ok) {
        #drupal_set_message("millennium_update_bibrecord(): Couldn't parse LASTUPDATEDATE from XML");
        return array(
          "success" => FALSE,
          "error" => "Couldn't parse LASTUPDATEDATE from XML for ". $bib_import_history->bib_recnum ." from item $item_recnum"
          );
      }
      $bib_lastupdate = $matches[3] ."-". $matches[2] ."-". $matches[1];
      */
    }

    // Update the node-bib relationship
    $record = array('id' => $import_history->id, 'updated' => date("Y-m-d H:i:s"));
    // Update millennium_node_bib using key 'id'
    $result = drupal_write_record('millennium_bib_item', $record, array('id'));
    if (!$result) {
      drupal_set_message("millennium_process_item_record_prev_imported: drupal_write_record('millennium_bib_item') returned FALSE");
      #dpm($record);
    }
    // Re-publish node in case it had been unpublished.
    db_update('node')
      ->fields(array(
          'status' => 1,
        ))
      ->condition('nid', $import_history->nid)
      ->execute();
    return array(
      "result" => "item_updated",
    );
  }

  return array(
    "result" => "item_untouched",
  );
}

/**
 * Imports a bibliographic record into a node from a given bib_recnum, updating existing nodes if stale,
 * and links the nodes, bib records and item record together.
 * Requires the bibliographic record number to be known.
 * Optionally, if the full marc record is passed, it is used directly instead of being fetched
 * from the WebOPAC.
 *
 * @param array $data Millennium record information
 * @param boolean $force_update
 *   Optional. If TRUE, forces the node to be updated when it already exists.
 */
function millennium_process_bib_record($data, $force_update = FALSE) {
  static $xml_disabled = FALSE;
  if ($data['base_url']) {
    $base_url = millennium_get_real_baseurl($data['base_url']);
  }
  else {
    return array("success" => FALSE, 'status' => '', 'node' => FALSE, "error" => "Could not get bib_recnum for bib #" . $data['bib_recnum']);
  }

  $bib_import_history = db_query("SELECT * FROM {millennium_node_bib} WHERE bib_recnum = :bib_recnum AND base_url = :base_url", array(':bib_recnum' => $data['bib_recnum'], ':base_url' => $base_url))->fetchObject();

  // Has this bib record been imported before?
  if ($bib_import_history && $bib_import_history->nid) {
    // There is an existing node for this bib record
    // Check if there is need to update the node.
    $stale_record_age = (3600 * 24 * 30); // 30 days
    $is_stale = (REQUEST_TIME > (strtotime($bib_import_history->updated) + $stale_record_age));

    if ($force_update != TRUE && !$is_stale) {
      $node = node_load($bib_import_history->nid);
      // Re-publish node in case it had been unpublished.
      db_update('node')
        ->fields(array(
              'status' => 1,
            ))
        ->condition('nid', $bib_import_history->nid)
        ->execute();
      return array("success" => TRUE, 'error' => '', 'status' => 'bib_untouched', "node" => $node);
    }
  }

  // We are here because an update is needed or was not previously imported.
  // Further down decide if the node is updated or created; the previous steps are the same:
  // - if no marc given, get marc is possible, if not handle deleted bib record
  // - convert to node
  // - Insert or update node
  if (!isset($data['marc'])) {
    // No marc given, try to fetch.
    $data['marc'] = millennium_fetch_marc($data['bib_recnum'], $base_url);
    if (!$data['marc']) {
      // Bib has been deleted!
      millennium_handle_deleted_bib($data);
      return array("success" => FALSE, 'status' => 'bib_deleted', "error" => "Could not fetch MARC record for " . $data['bib_recnum']);
    }
  }

  // Re-create a nodeobject from the MARC record
  $new_node = millennium_record_to_nodeobject($data['bib_recnum'], $base_url, $data['marc']);
  if (isset($new_node->success) && $new_node->success === FALSE) {
    #drupal_set_message("millennium_process_bib_record(): millennium_record_to_nodeobject() returned error ". $result["error"]);
    return array("success" => FALSE, 'status' => '', 'node' => FALSE, "error" => $new_node->error);
  }

  // Give other modules the chance to cancel processing this data
  // Function signature: millennium_continue_process_record($node, $data, $force_update)
  // where:
  //   $node is the node object generated from a Millennium record
  //   $data is the incoming Millennium record array
  //   $force_update is the current active setting to force updating existing
  //     records.
  $proceed = module_invoke_all('millennium_continue_process_record', $new_node, $data, $force_update);
  if (is_array($proceed) && in_array(FALSE, $proceed)) {
    return array('success' => TRUE, 'status' => 'bib_untouched');
  }

  // Now, decide if we are going to insert a new node, or update the existing node.
  if ($bib_import_history && $bib_import_history->nid) {
    // insert existing node's data into new_node and save node
    $new_node->nid = $bib_import_history->nid;
    // Clear node cache
    $oldnode = node_load($new_node->nid, NULL, TRUE);
    // Get vid from existing node.
    $new_node->vid = $oldnode->vid;
    // Fill in missing node info, and allow other modules to make changes
    $new_node->name = $oldnode->name;
    node_submit($new_node);
    // Store node in MySQL
    node_save($new_node);

    // Update the node-bib relationship
    $record = array(
      'nid' => $bib_import_history->nid,
      'bib_recnum' => $data['bib_recnum'],
      'biblio_data' => serialize($new_node->millennium_biblio_data),
      'updated' => date("Y-m-d H:i:s"),
      'base_url' => $base_url
    );
    #drupal_set_message("Will store this record:"); // DEBUG
    #dpm($record); // DEBUG
    // Update millennium_node_bib using key 'nid'
    $result = drupal_write_record('millennium_node_bib', $record, array('nid'));
    if (!$result) {
      drupal_set_message("drupal_write_record('millennium_node_bib') returned FALSE", "error");
      #dpm($record);
    }
    return array("success" => TRUE, 'status' => 'bib_updated', "node" => $new_node);
  }
  else {
    // Not imported before, insert a new node
    $new_node->is_new = 1;
    // Add authored by information, if given in $data array.
    if (isset($data['user'])) {
      $user = $data['user'];
    }
    else {
      global $user;
    }
    $new_node->uid = $user->uid;
    $new_node->name = $user->name;
    $new_node = node_submit($new_node);
    node_save($new_node);

    // Add node-bib relationship
    $record = array('nid' => $new_node->nid, 'bib_recnum' => $data['bib_recnum'],
      'biblio_data' => serialize($new_node->millennium_biblio_data),
      'updated' => date("Y-m-d H:i:s"), 'created' => date("Y-m-d H:i:s"), 'base_url' => $base_url);
    $result = drupal_write_record('millennium_node_bib', $record);
    if (!$result) {
      drupal_set_message("millennium_process_bib_record drupal_write_record('millennium_node_bib') returned FALSE");
      #dpm($record);
    }
    return array("success" => TRUE, 'status' => 'bib_created', "node" => $new_node);
  }
}

/**
 * Take action based on an item no longer found on the WebOPAC; delete item-node relationship
 * and the node itself if necessary.
 * @param array $data Millennium record information
 */
function millennium_handle_deleted_item($data, $import_history) {
  if ($data['base_url']) {
    $base_url = $data['base_url'];
  }
  else {
    return;
  }

  // Get bibrecord number and erase any existing node-item relationships
  if (!$data['nid'] || !$data['bib_recnum']) {
    $additional = db_query("SELECT nid, bib_recnum FROM {millennium_bib_item} WHERE item_recnum = :item_recnum AND base_url = :base_url", array(':item_recnum' => $data['item_recnum'], ':base_url' => $base_url))->fetchObject();
    $data['nid'] = $additional->nid;
    $data['bib_recnum'] = $additional->bib_recnum;
  }

  if ($data['bib_recnum']) {
    db_delete('millennium_bib_item')
      ->condition('item_recnum', $data['item_recnum'])
      ->condition('base_url', $base_url)
      ->execute();
    watchdog("Millennium", "Deleted node-item relationship for node @nid and item #@item.", array("@item" => $data['item_recnum'], "@nid" => $data['nid']));
    // Delete the node if no items remain for same bibrecord
    $count = db_query("SELECT count(*) FROM {millennium_bib_item} where bib_recnum='%s' AND base_url ='%s'", $data['bib_recnum'], $base_url)->fetchField();
    if ($count == 0) {
      // Check if bib record still exists
      $result = millennium_fetch_marc($import_history->bib_record, $base_url);
      if ($result == FALSE) {
        // Bib record not found.
        $action = variable_get("millennium_action_on_last_item_deleted", "unpublish");
        switch ($action) {
          case "delete":
            node_delete($data['nid']);
            break;
          case "unpublish":
            db_update('node')
              ->fields(array('status' => 0))
              ->condition('nid', $data['nid'])
              ->execute();
            break;
        }
        watchdog("Millennium", "Action: @action on node @nid because item #@item was deleted, and there were no remaining imported nodes for bib record #@bib.",
          array("@action" => $action, "@item" => $data['item_recnum'], "@bib" => $data['bib_recnum'], "@nid" => $data['nid'])
        );
      }
    }
  }
}

/**
 * Take action based on a bib no longer found on the WebOPAC; delete node and item-node, bib-node relationships
 * @param string $bib_recnum The bib record number (i123456x).
 */
function millennium_handle_deleted_bib($data) {
  if ($data['base_url']) {
    $base_url = $data['base_url'];
  }
  else {
    return;
  }

  $rows = db_delete('millennium_bib_item')
    ->condition('bib_recnum', $data['bib_recnum'])
    ->condition('base_url', $base_url)
    ->execute();
  if ($rows) {
    watchdog("Millennium", "Deleted bib-item relationships for bib_recnum #@bib.", array("@bib" => $data['bib_recnum']));
  }
  // Delete the node if no items remain for same bibrecord
  $nid = db_query("SELECT nid FROM {millennium_node_bib} where bib_recnum='%s' AND base_url ='%s'", $data['bib_recnum'], $base_url)->fetchField();
  if ($nid) {
    $action = variable_get("millennium_action_on_last_item_deleted", "unpublish");
    switch ($action) {
      case "delete":
        node_delete($nid);
        break;
      case "unpublish":
        db_update('node')
          ->fields(array(
            'status' => 0,
          ))
          ->condition('nid', $nid)
          ->execute();
        break;
    }
    watchdog("Millennium", "Action: @action on node @nid because bib record #@bib was not found on WebOPAC",
      array("@action" => $action, "@bib" => $data['bib_recnum'], "@nid" => $nid)
    );
  }
}

/**
 * Fetches information for a Millennium record and returns a populated nodeobject
 * @param recnum Millennium record number (b123456, i123456) to fetch
 * @param string $marc_text An optional MARC record to import from.
 */
function millennium_record_to_nodeobject($recnum, $base_url, $marc_text = NULL) {
  $result = new stdClass();
  if ($marc_text == NULL) {
    $marc_text = millennium_fetch_marc($recnum, $base_url);
    if (!$marc_text) {
      $result->success = FALSE;
      $result->error = "Could not fetch MARC for $recnum at $base_url";
      return $result;
    }
  }

  // Create a bibliographic information array from parsed MARC
  $biblio = millennium_marc_to_biblio($marc_text);
  if (!$biblio) {
    $result->success = FALSE;
    $result->error = "Could not convert MARC to biblio data for $recnum at $base_url";
    return $result;
  }

  // Add Millennium-only info
  $biblio["url"] = l(t('Link to original record'), millennium_permalink($recnum, $base_url, 'plain'));
  $biblio["recnum"] = $recnum;
  $biblio["base_url"] = $base_url;
  // If no LCC, try to get from item holdings
  /*
  if ($lcc == "" && $recnum) {
    $holdings = millennium_get_holdings_info($recnum, NULL, $base_url);
    // Look for first "classnumber" in items
    if (is_array($holdings)) {
      foreach ($holdings as $holding) {
        if (trim($holding["classnumber"])!= "") {
          $lcc = $holding["classnumber"];
          break;
        }
      }
    }
  }
  */

  $parsed_marc = millennium_parse_marc($marc_text);

  // Let other modules add custom bibliographic data
  //  function signature: mymodulename_millennium_biblio_data_alter($biblio, $marc)
  //  where:
  //    $biblio is the biblio information array
  //    $marc is the parsed MARC record
  drupal_alter('millennium_biblio_data', $biblio, $parsed_marc);

  // Create node array
  $log = 'Imported automatically by Millennium module on date ' . date('g:i:s a');

  $node = new stdClass();
  $node->type = variable_get('millennium_marc_node_type', 'page');
  node_object_prepare($node);
  $node->language = LANGUAGE_NONE; // TODO! use the proper language!
  $node->title = drupal_substr($biblio["title"], 0 ,255);
  $node->log = $log;

  // Store custom data in node
  $node->millennium_biblio_data = $biblio;

  // Add marc info to node's taxonomy
  millennium_add_taxonomy_to_node($node, $parsed_marc);

  // Add availability info to node's taxonomy
  millennium_add_availability_to_node($node, $recnum, $base_url);

  // Add OPAC name to node's taxonomy
  millennium_add_taxonomy_opacname_to_node($node, $base_url);

  // Let other modules alter the node object
  //  function signature: mymodulename_millennium_nodeobject_alter($nodeobject, $parsed_marc)
  //  where:
  //    $biblio is the biblio information array
  //    $parsed_marc is the parsed MARC record
  drupal_alter('millennium_nodeobject', $node, $parsed_marc);

  if (! $node) {
    $result->success = FALSE;
    $result->error = "Could not create node object from parsed MARC for $recnum";
    return $result;
  }

  return $node;
}

/**
 * Returns the user-defined base URL for the Millennium server (e.g. http://example.com/)
 */
function millennium_get_real_baseurl($base_url) {
  if ($base_url === FALSE || $base_url == '') {
    return FALSE;
  }
  $parts = @parse_url(trim($base_url));
  if (!isset($parts['host']) || !isset($parts['scheme'])) {
    return FALSE;
  }
  if ($parts['scheme'] != 'http' && $parts['scheme'] != 'https') {
    return FALSE;
  }
  $hostname = $parts['host'];
  if (!empty($parts['port'])) {
    $hostname .= ":" . $parts['port'];
  }
  return $parts['scheme'] . "://$hostname";
}

/**
 * Grabs Millennium record's HTML or XML
 * @param recnum Millennium record number (b123456, i123456) to fetch
 * @param mode String specifying type of view: plain, marc, items, xml
 */
function millennium_fetch_recordpage($recnum, $base_url, $mode = 'plain') {
  global $millennium_fetch_recordpage_cache;
  $key = $recnum . $mode . $base_url;
  #drupal_set_message("millennium_fetch_recordpage($recnum, $mode): key = $key");
  if (isset($millennium_fetch_recordpage_cache[$key])) {
    $result["data"] = $millennium_fetch_recordpage_cache[$key];
    return (object) $result;
  }

  // Get URL to fetch
  $url = millennium_permalink($recnum, $base_url, $mode);
  if ($url == FALSE) {
    return FALSE;
  }
  #drupal_set_message("millennium_fetch_recordpage($recnum, $mode): URL = $url");

  // Fetch bib record (if it exists) from URL
  #$start_microtime = microtime(TRUE);
  $result = millennium_http_request($url);

  $millennium_fetch_recordpage_cache[$recnum . $mode] = $result->data;
  return $result;
}

/**
 * Returns a URL for a certain item record view in Millennium
 */
function millennium_permalink($recnum, $base_url, $mode = 'plain') {
  // Determine if record is for an item or bib
  $recnum_type = substr($recnum, 0, 1);

  switch ($mode) {
    case "plain":
      $url = "{$base_url}/record={$recnum}&searchscope=0";
      break;
    case "xml":
      $url = "{$base_url}/xrecord={$recnum}&searchscope=0";
      break;
    case "marc":
    case "hold":
    case "items":
      if ($recnum_type == "i") {
        $bib_recnum = db_query("SELECT bib_recnum FROM {millennium_bib_item} WHERE item_recnum = :item_recnum AND base_url = :base_url", array(':item_recnum' => $recnum, ':base_url' => $base_url))->fetchField();
        $item_recnum = $recnum;
      }
      else {
        $bib_recnum = $recnum;
        $item_recnum = $recnum;
      }
      switch ($mode) {
        case "hold":
          $url = "{$base_url}/search*eng?/.{$item_recnum}/.{$bib_recnum}/1%2C1%2C1%2CB/request~{$bib_recnum}";
          break;
        case "marc":
          $url = "{$base_url}/search*eng?/.{$item_recnum}/.{$item_recnum}/1,1,1,B/marc~{$item_recnum}";
          break;
        case "items":
          $num = drupal_substr($item_recnum, 1); // e.g.: 123456
          $url = "{$base_url}/search*eng?/.{$item_recnum}/.{$bib_recnum}/1,1,1,B/holdings~{$num}&FF=&1,0,";
          break;
      }
  }
  #drupal_set_message("millennium_permalink($item_recnum, $mode): url: $url");
  return $url;
}

/**
 * Grabs a Millennium record's MARC equivalent in text version
 * @param bib_recnum Millennium record number (b123456) to fetch
 */
function millennium_fetch_marc($bib_recnum, $base_url) {
  $result = millennium_fetch_recordpage($bib_recnum, $base_url, "marc");
  if (! $result->data) {
    return FALSE;
  }
  $fetched_html = $result->data;

  /* This is an example of the MARC portion inside the fetched HTML:
  <div align="left"><pre>
  LEADER 00000cam  2200337Ia 4500
  001    tec011312166
  003    MX-MoT
  005    20070706103409.0
  008    070111s2007    njua     b
  [...]
  856 41 |zTabla de contenido|uhttp://www.loc.gov/catdir/toc/
         ecip078/2006103488.html
  929    cem /|bcemmzarza
  [...]
  </pre></div>
  */
  $ok = preg_match('/<div align="left"><pre>(.*)<\/pre><\/div>/si', $fetched_html, $matches);

  // If no match, $ok==0 (meaning record didn't exist)
  if ($ok == 1) {
    $marc_text = decode_entities(trim($matches[1]));
    return $marc_text;
  }
  else {
    return FALSE;
  }
}

/**
 * Takes a parsed marc record array and generates an array of bibliographic info
 * @param $marc
 *   MARC record (string if plaintext, array if parsed)
 */
function millennium_marc_to_biblio($marc_text) {
  global $_millennium_field_labels;

  $biblio = array();

  $marc = millennium_parse_marc($marc_text);
  if (!$marc) {
    #return array("success" => FALSE, "error" => "Could not parse MARC");
    return FALSE;
  }

  // LCC
  $lcc = trim(millennium_getFieldPlain($marc, "050"));
  if (!$lcc) {
    $lcc = trim(millennium_getFieldPlain($marc, "090"));
    if (!$lcc) {
      $lcc = trim(millennium_getFieldPlain($marc, "8520"));
    }
  }
  $biblio["lcc"] = $lcc;

  // DDC
  $biblio["ddc"] = trim(millennium_getFieldPlain($marc, "092"));

  // Notes
  $notes = array();
  $tmpfields = millennium_getFields_fixed($marc, "50");
  if (is_array($tmpfields)) {
    foreach ($tmpfields as $field) {
      if (trim($field["plaintext"])) {
        $notes[] = trim($field["plaintext"]);
      }
    }
  }
  $biblio["notes"] = $notes;

  // Links
  $links = array();
  $tmpfields = millennium_getFields_fixed($marc, "856");
  if (is_array($tmpfields)) {
    foreach ($tmpfields as $field) {
      $link_text = '';
      $link_url = '';
      #print_r($field);
      if ($tmp = millennium_getSubfields($field, "u")) {
        $link_url = preg_replace("/ /", "", $tmp[0]["data"]);
      }
      if ($tmp = millennium_getSubfields($field, "z")) {
        $link_text = $tmp[0]["data"];
      }
      elseif ($tmp = millennium_getSubfields($field, "3")) {
        $link_text = $tmp[0]["data"];
      }
      elseif ($link_url) {
        $link_text = $link_url;
      }
      if ($link_url) {
        $links[] = l($link_text, $link_url);
      }
    }
  }
  $biblio["links"] = $links;

  // Item description
  $item_description = "";
  $tmpfields = millennium_getFields_fixed($marc, "300");
  if ($tmpfields) {
    $item_description = $tmpfields[0]["plaintext"];
  }
  $biblio["item_description"] = $item_description;

  // Item type
  #$biblio["type_num"] = millennium_marcleader_to_bibtype($marc);
  $biblio["type"] = millennium_marcleader_to_mattype($marc);

  // Get all "a" subfields for several fields...
  $tags = array(
    "short_title" => "210",
    "alternate_title" => "246",
    "translated_title" => "242",
    "authors" => "(100|7[02]0)",
    "corp_author" => "(11[01]|71[01])",
    "edition" => "250",
    "title" => "245",           // Full, concatenated title
    "title_head" => "245",      // First part of multipart title
    "title_remainder" => "245", // Rest of multipart title
    "title_author" => "245",    // Statement of responsibility
    "isbn" => "020",
    "issn" => "022",
    #"pages" => "300",
    "volume" => "490",
    "other_number" => "024",
    "series" => "(830..|4900.|4[014][01])"
  );

  // Define subfield regexp for special cases
  // biblio field name => regexp
  $biblio_subfields = array(
    "title" => "[abp]",         // Full, concatenated title
    "title_head" => "[a]",      // First part of multipart title
    "title_remainder" => "[b]", // Rest of multipart title
    "title_author" => "[c]",    // Statement of responsibility
    "corp_author" => "[ab]",
    "alternate_title" => "[apb]",
    "translated_title" => "[apb]",
    "volume" => "[v]",
  );

  // Define repeatable fields
  $biblio_repeatable = array(
    'isbn', 'issn', 'authors', 'corp_author', 'alternate_title', 'series'
  );

  foreach ($tags as $fieldname => $tag) {
    $result = array();
    $found_data = millennium_getFields($marc, "$tag");
    if (is_array($found_data)) {
      foreach ($found_data as $data) {
        $subfield_re = isset($biblio_subfields[$fieldname]) ? $biblio_subfields[$fieldname] : "a";
        $subfields = millennium_getSubfields($data, $subfield_re);
        $value = "";
        if (is_array($subfields)) {
          foreach ($subfields as $subfield) {
            $value .= ($value != "" ? " " : "") . $subfield["data"];
          }
        }

        // Trim for isbn/issn
        if ($fieldname == "isbn" || $fieldname == "issn") {
          $value = preg_replace("/[ \(].*$/", "", $value);
        }

        #dprint_r($subfield_a);
        $value = millennium_trim_marc_value($value);

        // Store in array overwriting duplicates
        $result[$value] = $value;
      }
    }

    if (in_array($fieldname, $biblio_repeatable)) {
      // Store repeatable fields as an array
      $biblio[$fieldname] = array_values($result);
    }
    else {
      // Store non-repeatable fields as a string
      $biblio[$fieldname] = implode("; ", $result);
    }
  }

  // Check if author found
  if (!$biblio["authors"]) {
    if ($biblio["corp_author"]) {
      $biblio["authors"] = $biblio["corp_author"];
      unset($biblio["corp_author"]);
    }
  }

  // Imprint -> Editor, place, date edited
  $found_data = millennium_getFields_fixed($marc, "260");
  if (is_array($found_data)) {
    $data = $found_data[0];
    $place_publication = millennium_getSubfield_firstvalue($data, 'a');
    $place_manufacture = millennium_getSubfield_firstvalue($data, 'e');
    if ($place_manufacture || $place_publication) {
      $biblio["imprint_place"] = isset($place_publication['data']) ? $place_publication['data'] : $place_manufacture['data'];
      $biblio["imprint_place"] = str_replace(' :', '', $biblio["imprint_place"]);
    }

    $name_publisher    = millennium_getSubfield_firstvalue($data, 'b');
    $name_manufacturer = millennium_getSubfield_firstvalue($data, 'f');
    if ($name_publisher || $name_manufacturer) {
      $biblio["imprint_name"] = isset($name_publisher["data"]) ? $name_publisher["data"] : $name_manufacturer["data"];
    }

    $date_publication = millennium_getSubfield_firstvalue($data, 'c');
    $date_manufacture = millennium_getSubfield_firstvalue($data, 'g');
    if ($date_publication || $date_manufacture) {
      $biblio["imprint_date"] = isset($date_publication["data"]) ? $date_publication["data"] : $date_manufacture["data"];
      $biblio["imprint_date"] = preg_replace('/^.*?([12][0-9][0-9][0-9]).*$/i', '\\1', $biblio["imprint_date"]);
      if ($biblio["imprint_date"] < 1400) {
        $biblio["imprint_date"] = '';
      }
    }
  }

  // Language
  $tmpfields = millennium_getFields_fixed($marc, "008"); // get all 008s
  if ($tmpfields) {
    $lang_code = drupal_substr($tmpfields[0]["rawdata"], 35, 3);
    if (millennium_valid_language($lang_code)) {
      $biblio['lang'] = $lang_code;
    }
    else {
      $biblio['lang'] = NULL;
    }
  }

  if ($biblio["title"] == "") {
    return FALSE;
  }

  // Others
  #$biblio["bib_recnum"] = $bib_recnum;
  $biblio["imprint"] = $biblio["imprint_place"];
  $biblio["imprint"] .= isset($biblio["imprint_name"]) ? (' ' . $biblio["imprint_name"]) : '';
  $biblio["imprint"] .= isset($biblio["imprint_date"]) ? (' ' . $biblio["imprint_date"]) : '';
  $biblio["marc"] = $marc_text;

  /* These are for the Biblio module. As of today, that module is not yet released.
    "biblio_alternate_title" => $biblio["alternate_title"],
    "biblio_short_title" =>  str_replace(' /', '', $biblio["short_title"]),
    "biblio_translated_title" => $biblio["translated_title"],
    "biblio_notes" => $body,
    "biblio_type" => $biblio["type"],
    "biblio_authors" => $biblio["authors"],
    "biblio_corp_author" => $biblio["corp_author"],
    "biblio_secondary_authors" => $biblio["secondary_authors"],
    "biblio_edition" => $biblio["edition"],
    "biblio_publisher" => $biblio["imprint_name"],
    "biblio_place_published" => $biblio["imprint_place"],
    "biblio_year" => $biblio["imprint_date"],
    "biblio_isbn" => $biblio["isbn"],
    "biblio_issn" => $biblio["issn"],
    "biblio_other_number" => $biblio["other_number"],
    "biblio_pages" => $biblio["pages"],
    "biblio_volume" => $biblio["volume"],
    "biblio_call_number" => $biblio["lcc"],
    "biblio_lang" => $biblio["lang"],
    "biblio_url" => $biblio["url"],
    "biblio_custom7" => $biblio["bib_recnum"],
  */

  // Clean up (almost) every $biblio[] value
  $cant_touch_this = array('item_description', 'links', 'url');
  foreach ($biblio as $index => $value) {
    if (!in_array($index, $cant_touch_this) && is_string($value)) {
      $biblio[$index] = millennium_trim_marc_value($value);
    }
  }

  return $biblio;
}

/**
 * Gets the current holdings information for a recnum and converts it to
 * taxonomy terms added to the given node object.
 */
function millennium_add_availability_to_node(&$nodeobject, $recnum, $base_url) {
  static $availability_strings;
  if (!isset($availability_strings)) {
    // Get strings displayed in holdings table that mean "item is available"
    $availability_strings = explode(',', variable_get('millennium_availability_strings', MILLENNIUM_ITEM_AVAILABLE_STRINGS));
    foreach ($availability_strings as $index => $string) {
      $availability_strings[$index] = trim(drupal_strtolower($string));
    }
  }
  if (variable_get('millennium_availability_vid', -1) == -1) {
    return;
  }
  $locations_available = array();
  $holdings = millennium_get_holdings_info($recnum, $base_url);
  foreach ($holdings as $item) {
    if (
      !variable_get('millennium_map_available_only', FALSE)
       || in_array(trim(drupal_strtolower($item['status'])), $availability_strings)
      ) {
      $locations_available[$item['location']] = $item['location'];
    }
  }

  // Add taxonomy
  $location_names = array_keys($locations_available);
  sort($location_names);
  millennium_add_node_taxonomy_terms($nodeobject, variable_get('millennium_availability_vid', -1), $location_names);
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function millennium_add_taxonomy_opacname_to_node(&$nodeobject, $base_url) {
  if (variable_get('millennium_opacname_vid', -1) == -1) {
    return;
  }
  $sources = variable_get('millennium_sources', array());
  if (isset($sources[$base_url]) && $sources[$base_url]['name']) {
    millennium_add_node_taxonomy_terms($nodeobject, variable_get('millennium_opacname_vid', -1), array($sources[$base_url]['name']));
  }
}

/**
 * Helper function that eliminates trailing (nonessential) characters from MARC data
 */
function millennium_trim_marc_value($value) {
  $newvalue = $value;
  $newvalue = trim($value);
  $newvalue = preg_replace('/[\.,\/:;=]+$/u', '', $newvalue );
  return $newvalue;
}

/**
 * Scans a parsed MARC record array for important access points and relates them with taxonomy terms in vocabularies stored in module's config.
 * @param $nodeobject
 *   A drupal node object
 * @param $marc
 *   Array containing parsed marc record
 */
function millennium_add_taxonomy_to_node(&$nodeobject, $marc) {
  #drupal_set_message("millennium_add_taxonomy_to_node()");

  // Subfield codes from http://www.lib.noaa.gov/cataloging/Cataloging_Manual/650.html AND http://www.loc.gov/marc/bibliographic/ecbdsubj.html
  static $subjectsubfield_to_mapping = array(
    "a" => 'subject_kw',   // a=Main
    "v" => 'subject_form', // v=Form subdivision
    "x" => 'subject_kw',   // x=General subdivision
    "y" => 'subject_time', // y=Chronological subdivision
    "d" => 'subject_time', // d=Chronological subdivision
    "z" => 'subject_geo',  // z=Geographic subdivision
    "b" => 'subject_kw',
    "k" => 'subject_form', // Form subheading
  );

  $taxonomy_language = variable_get('millennium_taxonomy_language', 'english');

  if ($taxonomy_language == 'site_default') {
    $translate = TRUE;
    $language = language_default('language');
  }
  else {
    $translate = FALSE;
    $language = 'en';
  }

  // Material type
  $term_mat_type = _millennium_human_string($nodeobject->millennium_biblio_data, 'type', $translate, $language);

  if ($term_mat_type) {
    millennium_add_node_taxonomy_terms($nodeobject, variable_get('millennium_marc_vid_leader_item_type', -1), array($term_mat_type));
  }

  // Year
  if (isset($nodeobject->millennium_biblio_data["imprint_date"]) && $nodeobject->millennium_biblio_data["imprint_date"]) {
    $year = $nodeobject->millennium_biblio_data["imprint_date"];
    if ($year != "") {
      millennium_add_node_taxonomy_terms($nodeobject, variable_get('millennium_marc_vid_year', -1), array($year));
    }
  }

  // Language
  $lang_term = _millennium_human_string($nodeobject->millennium_biblio_data, 'lang', $translate, $language);
  if ($lang_term != "") {
    millennium_add_node_taxonomy_terms($nodeobject, variable_get('millennium_marc_vid_language', -1), array($lang_term));
  }

  // Authors
  $authors = array();
  foreach (array('authors', 'corp_author') as $field) {
    if (isset($nodeobject->millennium_biblio_data[$field])) {
      $authors = array_merge($authors, $nodeobject->millennium_biblio_data[$field]);
    }
  }
  if ($authors) {
    millennium_add_node_taxonomy_terms($nodeobject, variable_get('millennium_marc_vid_author', -1), $authors);
  }

  /**
   *  65x SUBJECTS:
   * Fetch all subject facets, by type (from subfield... v|x|etc)
   * http://www.loc.gov/marc/bibliographic/ecbdsubj.html#mrcb650
   * |v Form subdivision.
   * |x General subdivision.
   * |y Chronological subdivision.
   * |z Geographic subdivision.
   *
   * Also, some oversimplifications:
   *  |b is mostly topical, so it ends up in General
   *  |k is form subheading, so it ends up with Form subdivision
   */

  $facets = array();

  // Get all 65x's
  $tmpfields = millennium_getFields_fixed($marc, "65");
  // Other subjects: 600s, 61xs, 63xs
  $tmpfields = array_merge($tmpfields, millennium_getFields($marc, "6[013]..."));
  foreach ($tmpfields as $field) {
    foreach ($field["subfields"] as $subfield) {
      // Fix/normalize data: trim, remove trailing punctuation
      $text = millennium_trim_marc_value($subfield["data"]);
      $subfield_code = $subfield["code"];
      // Force subfield_code to |v (Form subdivision) for all 655 |a,|b and |v
      if (drupal_substr($field["tags"], 0, 3) == "655"
             && ($subfield_code == "a" || $subfield_code == "b")
          ) {
        $subfield_code = "v";
      }
      // Ignore numeric subfields
      if (is_numeric($subfield_code)) {
        continue;
      }
      // If necessary, initialize array
      if (!isset($facets[$subfield_code])) {
        $facets[$subfield_code] = array();
      }
      if (!in_array($text, $facets[$subfield_code]) ) {
        $facets[$subfield_code][] = $text;
      }
    }
  }

  if ($facets) {
    foreach ($facets as $subfield_code => $terms_array) {
      if (isset($subjectsubfield_to_mapping[$subfield_code])) {
        $map = $subjectsubfield_to_mapping[$subfield_code];
      }
      else {
        $map = 'subject_kw';
      }
      $vid = variable_get("millennium_marc_vid_$map", -1);
      sort($terms_array);
      millennium_add_node_taxonomy_terms($nodeobject, $vid, $terms_array);
    }
  }

  // Series
  #$tmpfields = millennium_getFields($marc, "4901."); // Only "traced" series; tag 490, indicators "1 "
  $tmpfields = millennium_getFields_fixed($marc, "830"); // 830 - Series Added Entry-Uniform Title
  foreach ($tmpfields as $field) {
    if ($tmpsub = millennium_getSubfield_firstvalue($field, "a")) {
      // Fix/normalize data: trim, remove trailing punctuation
      $series = millennium_trim_marc_value($tmpsub["data"]);
      #drupal_set_message("Will import facet series $series");
      millennium_add_node_taxonomy_terms($nodeobject, variable_get('millennium_marc_vid_series', -1), array($series));
    }
  }

  return TRUE;
}

/**
 * Associates nodes with taxonomy terms, importing new ones if necessary
 * @param int $nid
 * @param string $fieldname
 *   The name of the taxonomy reference field.
 * @param $term_names_array
 *   Array of strings, each one holding a term to add to this node
 */
function millennium_add_node_taxonomy_terms(&$nodeobject, $fieldname, $term_names_array) {
  static $field_errors = array();
  if ($fieldname == -1) {
    return;
  }

  $field = field_info_field($fieldname);

  // Validate this field exists in this nodetype.
  if (!isset($field['bundles']['node']) || !in_array($nodeobject->type, $field['bundles']['node'])) {
    // Log to watchdog (only once to avoid too many errors during batches)
    if (empty($field_errors[$fieldname])) {
      watchdog(
        "millennium",
        "Warning: Field @fieldname is not assigned to the @type node type",
        array(
          '@fieldname' => $fieldname,
          '@type' => $nodeobject->type
        ),
        WATCHDOG_NOTICE
      );
      $field_errors[$fieldname] = TRUE;
    }
    return;
  }
  
  // Get vocabulary info from fieldname and content_type
  $vocabulary_machine_name = $field['settings']['allowed_values'][0]['vocabulary']; // TODO: field might have multi-vocabulary settings!
  $vocabularies = taxonomy_vocabulary_get_names();
  $vid = $vocabularies[$vocabulary_machine_name]->vid;

  // Map terms.
  // See: http://fooninja.net/2011/04/13/guide-to-programmatic-node-creation-in-drupal-7/#comment-3339
  foreach ($term_names_array as $term_name) {
    $term_name = trim($term_name);
    // Skip empty strings.
    if (!$term_name) {
      continue;
    }
    $terms = taxonomy_get_term_by_name($term_name);
    // Discard terms that are not for this vid.
    $found = FALSE;
    foreach ($terms as $tid => $term) {
      // Only add terms that this field's vocabulary accepts.
      if ($term->vid == $vid) {
        $parents = taxonomy_get_parents($tid);
        // Only if term is first-level (has no parents).
        if (sizeof($parents) == 0) {
          $nodeobject->{$fieldname}[$nodeobject->language][]['tid'] = $term->tid;
          $found = TRUE;
          // Only add the first matching term.
          break;
        }
      }
    }
    // Handle non-found terms; create new terms.
    if ($found == FALSE) {
      $new_term = array(
        'vid' => $vid,
        'name' => drupal_substr($term_name, 0, 255),
        'tid' => 'autocreate',
        'vocabulary_machine_name' => $vocabulary_machine_name,
      );
      $nodeobject->{$fieldname}[$nodeobject->language][] = $new_term;
    }
  }
  return;
}

/**
 * Converts the text version of a MARC record into a parsed marc record array, for use with other functions.
 * @param marc_txt a string containing a text version of a MARC record.
 */
function millennium_parse_marc($marc_txt) {
  /* Generate an array of record contents from marc text:
  LEADER 00000pam  2200337 a 4500
  001    tec011312178
  003    MX-MoT
  005    20050208073018.0
  008    030930s2005    caua     b    001 0 eng
  010    2003113508
  020    0534378056 (encuadernado : ed. del estudiante)
  020    053449188X (ed. del instructor)
  020    0534491871 (CD-ROM)
  035    (DLC)13358247
  ...
  */
  #drupal_set_message("This is marc_txt, strlen=" . drupal_strlen($marc_txt)); // DEBUG
  #dpm($marc_txt); // DEBUG
  $record['LEADER'] = drupal_substr($marc_txt, 7, strpos($marc_txt, "\n") - 7);
  $ok = preg_match_all('/([\d ][\d ][\d ]) ([ \d])([ \d]) (.*)/i', $marc_txt, $matches, PREG_SET_ORDER);
  $record_index = 0;
  foreach ($matches as $match) {
    list($dummy, $tag, $ind1, $ind2, $rawdata) = $match;
    if (substr($tag, 0, 2) != '00') {
      $rawdata = trim($rawdata);
    }

    if ( $tag . $ind1 . $ind2 == "     ") {
      // Concatenate this data to the previous index
      $record[$record_index - 1]["rawdata"] .= (preg_match('/[a-z0-9]$/i', $record[$record_index - 1]["rawdata"]) === FALSE ? "" : " ") . $rawdata;
    }
    else {
      $record[$record_index]["tags"] = $tag . $ind1 . $ind2;
      $record[$record_index]["rawdata"] = $rawdata;
      $record_index++;
    }
  }

  // Put data into array using subfields
  foreach ($record as $index => $element) {
    if ($index == "LEADER") {
      continue;
    }
    $rawdata = $element["rawdata"];
    $ok = preg_match_all("/(?:^|\|(.))([^\|]*)/", $rawdata, $matches, PREG_SET_ORDER);

    #echo "<pre>$rawdata:::\n";print_r($matches);echo "</pre>";
    $plaintext = "";
    foreach ($matches as $match) {
      list($dummy, $subfield, $subfield_data) = $match;
      #echo "Subfield=='$subfield', subfield_data=$subfield_data'\n";
      if ($subfield == "") {
        $subfield = "a";
      }
      else {
        $plaintext .= " ";
      }
      if (!isset($record[$index]["subfields"])) {
        $record[$index]["subfields"] = array();
      }
      $record[$index]["subfields"][] = array("code" => $subfield, "data" => $subfield_data);
      $plaintext .= $subfield_data;
    }
    $record[$index]["plaintext"] = $plaintext;
  }

  //echo "<H2>millennium_parse_marc()::</h2><fieldset class=collapsible title='x'><pre>";
  //print_r($record);
  //echo "</pre></fieldset>";
  return $record;
}

/**
 * Return array of subfields inside field that match given subfield code
 * @param field a field array
 * @param subfield_regexp Regular expression for field code
 *
 */
function millennium_getSubfields($field, $subfield_regexp) {
  $results = array();
  if (isset($field['subfields']) && is_array($field['subfields'])) {
    foreach ($field["subfields"] as $subfield) {
      if (preg_match("/^$subfield_regexp/", $subfield["code"])) {
        $results[] = $subfield;
      }
    }
  }
  return $results;
}

/**
 * Return the first subfield for a given field and subfield code.
 *
 * @param array $field
 *  A field.
 * @param string $field_code
 *  Single character with subfield code.
 * @return mixed
 *  Return an array with the first subfield. If no subfield found then return
 *  FALSE;
 */
function millennium_getSubfield_firstvalue($field, $subfield_code) {
  if ($tmp = millennium_getSubfields($field, $subfield_code)) {
    return $tmp[0];
  }
  return FALSE;
}

/**
 * Return array of field contents
 * @param tag_regexp is a regular expression for tags; tags are formatted TTTXY where TTT is a zerofilled 3-digit marc tag, X is subfield 1 (either . or a number), and Y is subfield 2
 * @param record array containing a parsed marc record
 */
function millennium_getFields($record, $tag_regexp) {
  $results = array();
  if (!is_array($record)) {
    return FALSE;
  }
  // If no regexp in $tag_regexp, then call faster function
  if (strpos($tag_regexp, '|') === FALSE
       && strpos($tag_regexp, '.') === FALSE
       && strpos($tag_regexp, '[') === FALSE
       && strpos($tag_regexp, '(') === FALSE) {
    return millennium_getFields_fixed($record, $tag_regexp);
  }
  foreach ($record as $element) {
    if (isset($element["tags"]) && preg_match("/^$tag_regexp/", $element["tags"])) {
      $results[] = $element;
    }
  }
  return $results;
}

/**
 * Return array of field contents
 * @param tag_start is a substring for the starting characters in tags; tags are formatted TTTXY where TTT is a zerofilled 3-digit marc tag, X is subfield 1 (either . or a number), and Y is subfield 2
 * @param record array containing a parsed marc record
 */
function millennium_getFields_fixed($record, $tag_start) {
  $results = array();
  if (!is_array($record)) {
    return $results;
  }
  foreach ($record as $element) {
    if (strpos($element["tags"], $tag_start) === 0) {
      $results[] = $element;
    }
  }
  return $results;
}

/**
 * Returns the plaintext version of a parsed marc record
 * @param record array containing a parsed marc record
 */
function millennium_getFieldPlain($record, $tag_regexp) {
  $result = '';
  $tmp = millennium_getFields($record, $tag_regexp);
  if (isset($tmp[0]) && isset($tmp[0]["plaintext"])) {
    $result = $tmp[0]["plaintext"];
  }
  return $result;
}

/**
 * Implements hook_hilcc_lcc().
 */
function millennium_hilcc_lcc($node, $op = 'process') {
  if ($op == 'info') {
    return t("Returns LCC from MARC records imported from Millennium WebOPACs.");
  }
  if (!isset($node->nid)) {
    return FALSE;
  }
  #drupal_set_message("millennium_hilcc_lcc() for nid ". $node->nid);
  $biblio_data = millennium_get_biblio_data($node->nid);
  #dsm($biblio_data);
  if ($biblio_data["lcc"]) {
    return array($biblio_data["lcc"]);
  }
  else {
    return FALSE;
  }
}

/**
 * Return an array of  item record numbers for this node.
 * @param nid The node id.
 */
function millennium_item_recnums_from_node($nid) {
  static $cache;
  if (isset($cache[$nid])) {
    return $cache[$nid];
  }
  else {
    $recnums = array();
    $result = db_query("SELECT item_recnum FROM {millennium_bib_item} WHERE nid = :nid", array(':nid' => $nid));
    foreach ($result as $row) {
      $recnums[] = $row->item_recnum;
    }
    if (!empty($recnums)) {
      $cache[$nid] = $recnums;
      return $recnums;
    }
    else {
      return FALSE;
    }
  }
}

/**
 * Return the bib record number for node
 * @param nid node id
 */
function millennium_bib_recnum_from_node($nid) {
  static $cache;
  if (isset($cache[$nid])) {
    return $cache[$nid];
  }
  else {
    $recnum = db_query("SELECT bib_recnum FROM {millennium_node_bib} WHERE nid = :nid", array(':nid' => $nid))->fetchField();
    if ($recnum) {
      $cache[$nid] = $recnum;
      return $recnum;
    }
    else {
      return FALSE;
    }
  }
}

/**
 * Return the themed (html) widget showing the holdings information for the record contained in this node.
 * @param nid node id
 * @param page same as $page argument in hook_nodeapi()
 * @param option determine how to show the widget (full, teaser)
 */
function millennium_holdings_widget($nid, $page = FALSE, $option = "full") {
  static $settings_flag = FALSE;
  $output = "";
  $show = "recordlink";
  $msg = t("Show availability and holdings");
  $base_url = db_query("SELECT base_url FROM {millennium_node_bib} WHERE nid = :nid", array(':nid' => $nid))->fetchField();
  $show = FALSE;
  if (!$page) {
    // We are in teaser view
    switch ($option) {
      case "teaser":
        $show = "holdings";
        break;

      case "full":
        $show = "nodelink";
        break;

      default:
        break;
    }
  }
  else {
    // We are in full page view
    switch ($option) {
      case "teaser":
      case "full":
        $show = "holdings";
        break;

      default:
        break;
    }
  }

  switch ($show) {
    case "holdings":
      global $locale;
      if (empty($locale) || $locale == NULL || $locale == '') {
        $mil_locale = 'en';
      }
      else {
        $mil_locale = $locale;
      }
      $mil_page = $page ? "page" : "teaser";
      $bib_recnum = millennium_bib_recnum_from_node($nid);

      // Add settings and JS
      drupal_add_js( drupal_get_path('module', 'millennium') . '/millennium.js');
      if (!$settings_flag) {
        drupal_add_js(array('millennium' => array('locale' => $mil_locale, 'page' => $mil_page)), array('type' => 'setting', 'scope' => JS_DEFAULT));
        $settings_flag = TRUE;
      }

      // Check if holdings data exists in cache.
      $holdings = millennium_get_holdings_info($bib_recnum, $base_url, NULL, TRUE);
      if ($holdings !== FALSE) {
        // Output holdings data immediately.
        $output .= "<div class='millennium holdings'>";
        $output .= theme('millennium_holdings', array('nid' => $nid, 'holdings' => $holdings, 'page' => $mil_page));
        $output .= "</div>";
      }
      // Add div to be populated by AJAX call.
      else {
        $output .= "<div class='millennium holdings load' id='nid-$nid'>";
        $output .= l( $msg, millennium_permalink($bib_recnum, $base_url, 'plain'));
        $output .= "</div>";
      }
      break;

    case "nodelink":
      $node_link = l( $msg, "node/$nid");
      $output .= "<div class='millennium holdings'>" . $node_link . "</div>";
      break;

    case "recordlink":
      $bib_recnum = millennium_bib_recnum_from_node($nid);
      $record_link = l( $msg, millennium_permalink($bib_recnum, $base_url, 'plain'));
      $output .= "<div class='millennium holdings'>" . $record_link . "</div>";
      break;
  }

  return $output;
}

/**
 * Returns an array of arrays with holding information for a bib record
 * @param string $recnum
 *   Bibliographic or item record number
 * @param string $base_url
 *   Base URL of OPAC.
 * @param string $fetched_html
 *   Optional, HTML for record page containing a holdings table to parse.
 * @param boolean $cache_only
 *   Optional, only return data if it exists in cache; if not, return FALSE.
 * @return mixed
 *   A holdings array, or FALSE if $cache_only is FALSE and no data was
 *   available in the cache.
 */
function millennium_get_holdings_info($recnum, $base_url, $fetched_html = NULL, $cache_only = FALSE) {
  static $cache;
  // Build a cache id
  $parsed_url = parse_url($base_url);
  $cid = "millennium_get_holdings_info-{$recnum}-" . $parsed_url['host'];
  $items = array();

  if ($fetched_html == NULL) {
    // Check the static cache
    if (isset($cache[$cid])) {
      return $cache[$cid];
    }
    // Check Drupal's cache
    $cached_data = cache_get($cid);
    if ($cached_data && $cached_data->data && $cached_data->expire > REQUEST_TIME) {
      $cache[$cid] = $cached_data->data;
      return $cache[$cid];
    }
    // If called with $cache_only as TRUE, return as no cached data exists.
    if ($cache_only) {
      return FALSE;
    }
    // No cache, fetch the item information from WebOPAC
    $result = millennium_fetch_recordpage($recnum, $base_url, "items");
    if (! $result->data) {
      return FALSE;
    }
    $fetched_html = $result->data;
  }

  $items = millennium_parse_holdings_from_html($fetched_html);
  // Set static cache
  $cache[$cid] = $items;
  // Cache for one day
  cache_set($cid, $items, 'cache', REQUEST_TIME + (24 * 3600));
  return $items;
}

/**
 * Recieves html that contains a holdings table, and returns an array describing
 * its items.
 */
function millennium_parse_holdings_from_html($html) {
  static $code_2_human = array(
    '1' => 'location',
    '$' => 'location',
    '!' => 'message',
    '%' => 'status',
    'C' => 'classnumber',
    'v' => 'classvolume',
    '#' => 'copy',
    'y' => '????', // TODO: find out what field y is!
    'n' => '????', // TODO: find out what field n is!
  );
  $items = array();

  /*
  -- EXAMPLE 1 --
  <tr  class="bibItemsEntry">
  <td width="22%" > <!-- field 1 -->&nbsp; CEM GENERAL
  </td>
  <td width="33%" > <!-- field C -->&nbsp;<a href="/search*spi/cQA76.76.P37+M49+2007/cqa+++76.76+p37+m49+2007/-3,-1,,E/browse">QA76.76.P37 M49 2007</a>&nbsp; <!-- field v -->&nbsp;&nbsp; <!-- field # -->&nbsp;</td>
  <td width="22%" > <!-- field ! --></td>
  <td width="23%" > <!-- field % -->&nbsp; DISPONIBLE</td></tr>

  -- EXAMPLE 2 --
  <tr  class="bibItemsEntry">

  <td width="22%" > <!-- field 1 -->&nbsp; <a href="http://biblioteca.itesm.mx/">MTY Biblioteca Digital</a>
  </td>
  <td width="33%" > <!-- field C -->&nbsp;<a href="/search*spi/cRC346+.A3+2005b/crc++346+a3+2005+b/-3,-1,,E/browse">RC346 .A3 2005b</a>&nbsp; <!-- field v -->&nbsp;&nbsp; <!-- field # -->&nbsp;</td>
  <td width="22%" > <!-- field ! --></td>
  <td width="23%" > <!-- field % -->&nbsp; DISPONIBLE</td></tr><tr><td align="center" colspan="4">

  <a href="http://xxxxxxxxxxxxxxxxxxx/resourceTOC.aspx?resourceID=54">Consultar el servicio a través de la Biblioteca Digital
  </td></tr>

  -- EXAMPLE 3 --
  <tr  class="bibItemsEntry">

  <td width="28%" > <!-- field 1 -->&nbsp; CCM HEMEROTECA
  </td>

  <td width="42%" > <!-- field C -->&nbsp;<a href="/search*spi/cF1201+N49/cf++1201+n49/-3,-1,,E/browse">F1201 N49</a>&nbsp; <!-- field v -->15: 1992 Ene.-Mar.&nbsp; <!-- field # -->&nbsp;</td>
  <td width="30%" > <!-- field % -->&nbsp; DISPONIBLE</td></tr>

  -- EXAMPLE 4 --
  <tr  class="bibItemsEntry">

  <td width="30%" ><!-- field $ -->&nbsp;DEN Main
  </td>

  <td width="40%" ><!-- field C -->&nbsp;BP365 .E8 <!-- field # --><!-- field v -->&nbsp;1970 <!-- field ! --><!-- field y --><a href="/search~S6?/cBP365+.E8/cbp++365+e8/-3,-1,,E/browse"><strong>Show Nearby Items On Shelf</strong></a></td>
  <td width="30%" ><!-- field % -->&nbsp;CHECK SHELVES </td></tr>

  -- EXAMPLE 5 --
  http://catalog.waukeganpl.org/record=b1292762&searchscope=0
  <tr class="bibItemsEntry">

  <td width="35%"><!-- field 1 -->&nbsp;Children's Magazine
  </td>
  <td width="41%"><!-- field C -->&nbsp;MAGAZINE <!-- field v -->&nbsp;no.26 Nov 2008 <!-- field # -->&nbsp;<a href="/search~S7?/cMAGAZINE/cmagazine/-3,-1,,E/browse"><img border="0" alt="Nearby on shelf" src="/screens/bullet.gif"></a></td>
  <td width="24%"><!-- field % -->&nbsp;DUE 08-31-09BILLED </td></tr>

  */
  if (preg_match_all('/<tr +class="bibItemsEntry">(.*?<\/tr>(?:<tr>.*?<\/tr>|))/si', $html, $holding_matches, PREG_SET_ORDER)) {
    foreach ($holding_matches as $holding) {
      if (preg_match_all('/<!-- field (.) -->(?: *&nbsp; *|)(?:<a.*?' . '>|)(.*?)(?=<\/td|<!--)/si', $holding[1], $matches, PREG_SET_ORDER)) {
        // Initialize the item.
        $item = array();
        // Scan through all <!-- field X -->... matches.
        foreach ($matches as $match) {
          $name = $code_2_human[$match[1]];
          $value = trim(decode_entities(str_replace("&nbsp;", " ", strip_tags($match[2]))));
          $item[$name] = $value;
        }
        // There can also be a URL assigned to the item: look for it.
        $ok = preg_match('/colspan=".">.*?<a href="(http[^"]+).*?>([^<]+)</si', $holding[1], $matches);
        if ($ok) {
          $item['link']['url'] = $matches[1];
          $value = trim(decode_entities(str_replace("&nbsp;", " ", strip_tags($matches[2]))));
          $item['link']['title'] = $value;
        }
        $items[] = $item;
      }
    }
  }
  return $items;
}

/**
 * Returns the material type name from the MARC leader
 * @param array $marc A parsed marc record
 */
function millennium_marcleader_to_mattype($marc) {
  $format = '';
  if (!isset($marc['LEADER'])) {
    return '';
  }
  $record_type = drupal_substr($marc['LEADER'], 6, 1);
  $bibliographic_level = drupal_substr($marc['LEADER'], 7, 1);
  switch ($record_type) {
    case 'r':
      $format = 'object';
      break;
    case 'k':
      $format = 'photo';
      break;
    case 'g':
      $format = 'projected';
      break;
    case 'i':
      $format = 'sound';
      break;
    case 'j':
      $format = 'music';
      break;
    case 'o':
    case 'p':
      $format = 'kit';
      break;
    case 'e':
    case 'f':
      $format = 'map';
      break;
    case 'm':
      $format = 'file';
      break;
    case 'c':
    case 'd':
      $format = 'sheet';
      break;
    case 't':
      $format = 'manuscript';
      break;
    case 'a':
    default:
      if ($bibliographic_level == 's') {
        $format = 'periodical';
      }
      else {
        $format = 'book';
      }
  }

  $marc007 = millennium_getFields_fixed($marc, '007');
  if ($marc007) {
    $material_category = drupal_substr($marc007[0]['rawdata'], 0, 1);
    $material_designation = drupal_substr($marc007[0]['rawdata'], 1, 1);
    $video_format = drupal_substr($marc007[0]['rawdata'], 4, 1);

    if ($material_category == 'v') {
      if ($video_format == 'v') {
        $format = 'dvd';
      }
      else {
        $format = 'vhs';
      }
      if ($material_category == 's') {
        if ($material_designation == 's') {
          $format = 'cassette';
        }
        elseif ($material_designation == 's') {
          $format = 'cd';
        }
      }
    }
  }
  #drupal_set_message("Format = $format");
  return $format;
}

/**
 * Returns bibliographic data array associated with this nid.
 * @param nid node id
 */
function millennium_get_biblio_data($nid) {
  static $cache;
  if (isset($cache[$nid])) {
    return $cache[$nid];
  }
  $biblio_data = FALSE;
  $result = db_query("SELECT biblio_data FROM {millennium_node_bib} WHERE nid = :nid", array(':nid' => $nid))->fetchField();
  if ($result) {
    $biblio_data = unserialize($result);
  }
  $cache[$nid] = $biblio_data;
  return $biblio_data;
}

/**
 * Get first author from ;-separated string of authors
 */
 /*
function _millennium_first_author($biblio_authors) {
  $tmp = explode(";", $biblio_authors);
  if (is_array($tmp))
    return $tmp[0];
  else
    return "";
}
*/

/**
 * Check whether a valid WebOPAC exists at given base_url.
 */
function millennium_ping($base_url) {
  $response = millennium_http_request($base_url . '/search/X', array(), 'HEAD');
  if ($response->code != 200) {
    #drupal_set_message("$base_url code " . $response->code);
    return FALSE;
  }
  return TRUE;
}

/**
 * Store times for latest MILLENNIUM_PERFORMANCE_HISTORY_SIZE cron or batch import runs.

 */
function millennium_time_history($elapsed_node, $elapsed_crawl, $tot_attempted, $tot_notfound, $tot_imported) {
  $time_history = variable_get("millennium_time_history", array());
  if (!is_array($time_history)) {
    $time_history = array();
  }
  if (sizeof($time_history) >= MILLENNIUM_PERFORMANCE_HISTORY_SIZE) {
    array_shift($time_history);
  }
  $time_history[] = array(
    "timestamp" => REQUEST_TIME,
    "items" => $tot_attempted,
    "not_found" => $tot_notfound,
    "imported" => $tot_imported,
    "time" => $elapsed_crawl,
    "time_node" => $elapsed_node,
  );
  millennium_variable_set("millennium_time_history", $time_history);
}

/**
 * Proxy function for drupal_http_request() which uses and caches session
 * cookies from target OPACs.
 * @see drupal_http_request()
 */
function millennium_http_request($url, $headers = array(), $method  = 'GET', $data = NULL, $retry = 3) {
  static $cookie_static_cache = array();
  $session_cookie = "";

  $base_url = millennium_get_real_baseurl($url);
  $cid = "millennium_http_request_" . $base_url;

  #drupal_set_message("millennium_http_request(): start. URL =" . l($url, $url, array('attributes' => array('target' => 'webopac'))));

  // If no Cookie given in header, try to fetch one from cache
  if (isset($cookie_static_cache[$base_url])) {
    $session_cookie = $cookie_static_cache[$base_url];
    //drupal_set_message("millennium_http_request(): $base_url using static cookie $session_cookie");
  }
  else {
    // Try to get from cache first
    $cached = cache_get($cid);
    if ($cached && $cached->data && $cached->expire > REQUEST_TIME) {
      $session_cookie = $cached->data;
      //drupal_set_message("millennium_http_request(): $base_url using cached cookie $session_cookie");
    }
  }

  if ($session_cookie) {
    $headers['Cookie'] = $session_cookie;
    $cookie_static_cache[$base_url] = $session_cookie;
  }

  // Fire drupal_http_request()
  $result = drupal_http_request($url, array('headers' => $headers, 'method' => $method, 'data' => $data, 'max_redirects' => $retry));

  // Convert non-utf responses to UTF-8
  if (stripos($result->headers["content-type"], "charset=")) {
    $charset = preg_replace('/.*charset=([A-Z0-9-]+)($|;.*$)/i', '\\1', $result->headers["content-type"]);
    if ($charset != "UTF-8") {
      #drupal_set_message("Converting from charset $charset into UTF-8");
      $result->data = drupal_convert_to_utf8($result->data, $charset);
    }
  }
  else {
    // Assume ISO-8859-1 encoding.
    $result->data = utf8_encode($result->data);
  }

  // Cache the returned session cookie if one is returned
  if (isset($result->headers["set-cookie"])) {
    $cookstring = $result->headers["set-cookie"];
    $cookies = explode(",", $cookstring);

    $cookie_set = FALSE;
    $all = array();
    foreach ($cookies as $cookie) {
      $ok = preg_match_all('/III_[^=]+=[a-zA-Z0-9\.]+/', $cookie, $matches);
      if ($ok) {
        $cookie_set = TRUE;
      }
      else {
        $scope = preg_match_all('/SESSION_SCOPE=[0-9]+/', $cookie, $matches);
      }
      if ($ok || $scope) {
        $all[] = $matches[0][0];
      }
    }

    if ($cookie_set) {
      $session_cookie = implode("; ", $all);
      cache_set($cid, $session_cookie, 'cache', REQUEST_TIME + MILLENNIUM_SESSION_COOKIE_LIFETIME);
      $cookie_static_cache[$base_url] = $session_cookie;
      #drupal_set_message("millennium_http_request(): $base_url cache_set for cookie $session_cookie");
    }
  }

  return $result;
}

/**
 * Returns a sources array populated with an extra 'node_count' element per each
 * source.
 *
 * @return array
 *   A sources array derived from the millennium_sources Drupal variable
 */
function millennium_get_sources_count() {
  $sources = variable_get("millennium_sources", array());
  if (sizeof($sources) > 0) {
    // Build a counting query
    $result = db_query('SELECT count(1) n, base_url FROM {millennium_node_bib} GROUP BY base_url');
    foreach ($result as $data) {
      $sources[$data->base_url]['node_count'] = $data->n;
    }
  }
  return $sources;
}

/**
 * Implements hook_views_api().
 */
function millennium_views_api() {
  return array(
    'api' => 2,
  );
}

/**
 * Lightweight version of variable_set() that clears cache in hook_exit() call
 */
function millennium_variable_set($name, $value) {
  global $conf;

  db_merge('variable')->key(array('name' => $name))->fields(array('value' => serialize($value)))->execute();

  $conf[$name] = $value;

  // Set global flag to flush variables cache in millennium_exit()
  $conf['millennium_variable_set'] = TRUE;

}

/**
 * Implements hook_exit().
 */
function millennium_exit($destination = NULL) {
  global $conf;
  if (isset($conf['millennium_variable_set']) && $conf['millennium_variable_set'] == TRUE) {
    cache_clear_all('variables', 'cache_bootstrap');
  }
}

/**
 * Return a default username for variable millennium_newitems_author_name.
 */
function millennium_default_author() {
  $user = user_load(1);
  return $user->name;
}

/**
 * Implements hook_field_extra_fields().
 */
function millennium_field_extra_fields() {
  $type = variable_get('millennium_marc_node_type', 'page');
  $extra = array(
    'node' => array(
      $type => array(
        'display' => array(
          'millennium_coverimage' => array(
            'label' => 'Millennium: ' . t('Cover image'),
            'description' => '',
            'weight' => millennium_element_weight('millennium_coverimage'),
          ),
          'millennium_authors' => array(
            'label' => 'Millennium: ' . t('Authors'),
            'description' => '',
            'weight' => millennium_element_weight('millennium_authors'),
          ),
          'millennium_extra' => array(
            'label' => 'Millennium: ' . t('Item type and year published'),
            'description' => '',
            'weight' => millennium_element_weight('millennium_extra'),
          ),
          'millennium_google_books' => array(
            'label' => 'Millennium: ' . t('Link to Google Books'),
            'description' => '',
            'weight' => millennium_element_weight('millennium_google_books'),
          ),
          'millennium_holdings' => array(
            'label' => 'Millennium: ' . t('Holdings table'),
            'description' => '',
            'weight' => millennium_element_weight('millennium_holdings'),
          ),
          'millennium_biblio_data' => array(
            'label' => 'Millennium: ' . t('Biblio data table'),
            'description' => '',
            'weight' => millennium_element_weight('millennium_biblio_data'),
          ),
          'millennium_googlebookswidget' => array(
            'label' => 'Millennium: ' . t('Embedded Google Book view'),
            'description' => '',
            'weight' => millennium_element_weight('millennium_googlebookswidget'),
          ),
        ),
      ),
    ),
  );
  return $extra;
}

/**
 * Helper function to return the weight for elements added in
 * millennium_nodeapi() to the render array.
 *
 * @param $element_name
 *   Index of the element.
 * @param $view_mode
 *   The view mode being used. E.g. "full", "teaser".
 * @return int
 *   The weight.
 */
function millennium_element_weight($element_name, $view_mode = 'full') {
  $defaults = array(
    'millennium_coverimage' => -100,
    'millennium_authors' => -91,
    'millennium_extra' => -90,
    'millennium_google_books' => -80,
    'millennium_holdings' => -50,
    'millennium_biblio_data' => 0,
    'millennium_googlebookswidget' => 100,
  );
  $settings = field_extra_fields_get_display('node', variable_get('millennium_marc_node_type', 'page'), $view_mode);

  if (isset($settings[$element_name]['weight'])) {
    return $settings[$element_name]['weight'];
  }
  return $defaults[$element_name];
}
