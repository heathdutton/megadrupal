<?php
/**
 * @file
 * Per Page Queue module.
 */

/**
 * @section Hooks.
 */

/**
 * Implements hook_menu().
 */
function perpagequeue_menu() {
  $items = array();

  $items['admin/structure/nodequeue/%nodequeue/path'] = array(
    'title' => 'Active Paths',
    'page callback' => 'perpagequeue_admin_subqueues',
    'page arguments' => array(3),
    'access callback' => 'perpagequeue_manage_path_access',
    'access arguments' => array(3),
    'file' => 'pages/admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/structure/nodequeue/%nodequeue/path/%subqueue/delete'] = array(
    'title' => 'Delete Path',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('perpagequeue_admin_delete_subqueue', 3, 5),
    'access callback' => 'perpagequeue_manage_path_access',
    'access arguments' => array(3),
    'file' => 'pages/admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['admin/structure/nodequeue/%nodequeue/path/add'] = array(
    'title' => 'Add a New Path',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('perpagequeue_admin_add_subqueue', 3),
    'access callback' => 'perpagequeue_manage_path_access',
    'access arguments' => array(3),
    'file' => 'pages/admin.inc',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_forms().
 */
function perpagequeue_forms($form_id, $args) {
  $forms = array();

  if (preg_match('/^perpagequeue_block_form__.+$/', $form_id)) {
    $forms[$form_id] = array(
      'callback' => 'perpagequeue_block_form',
    );
  }

  return $forms;
}

/**
 * Implements hook_permission().
 */
function perpagequeue_permission() {
  return array(
    'manage page subqueue' => array(
      'title' => t('Create a Per Page Subqueue'),
      'description' => t('Manage all Per Page subqueues.'),
    ),
  );
}

/**
 * Implements hook_views_api().
 */
function perpagequeue_views_api() {
  return array(
    'api' => 3,
  );
}


/**
 * @section Block related hooks and functions.
 */

/**
 * Implements hook_block_info().
 */
function perpagequeue_block_info() {
  $blocks = array();

  foreach (nodequeue_load_queues(nodequeue_get_all_qids()) as $qid => $queue) {
    if ($queue->owner == 'perpagequeue') {

      // Administrative block
      $blocks[$qid . '@admin'] = array(
        'info' => t('Manage Per Page Queues for !queue', array('!queue' => $queue->title)),
        'cache' => DRUPAL_CACHE_PER_PAGE | DRUPAL_CACHE_PER_ROLE,
        'properties' => array(
          'administrative' => TRUE,
        ),
      );

      // Display block
      if (module_exists('views') && substr(views_api_version(), 0, 1) >= 3) {
        if ($queue->views_view != -1) {
          list($view_id, $display_id) = explode('@', $queue->views_view, 2);
          $view = views_get_view($view_id);

          $blocks[$qid . '@view'] = array(
            'info' => t('Per Page Queue Views block for !queue', array('!queue' => $queue->title)),
            'cache' => DRUPAL_CACHE_PER_PAGE | DRUPAL_CACHE_PER_ROLE,
          );
        }
      }

    }
  }

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function perpagequeue_block_view($delta = '') {
  list($qid, $block_type) = explode('@', $delta, 2);

  if (($queue = nodequeue_load($qid))) {

    switch ($block_type) {
      case 'admin':
        return perpagequeue_block_view_admin($queue);

      case 'view':
        return perpagequeue_block_view_view($queue);
    }
  }

  return array();
}

/**
 * Block builder for the Per Page Queue admin block.
 */
function perpagequeue_block_view_admin($queue) {
  $block = array();

  if (perpagequeue_manage_path_access($queue)) {

    $block['subject'] = check_plain($queue->title);
    $block['content'] = array();

    if ($queue->use_tokens) {
      $all_paths = _perpagequeue_path_permutations();
    }
    else {
      $all_paths = array(drupal_get_path_alias());
    }

    $subqueues = _perpagequeue_order_subqueues_by_paths(_perpagequeue_load_subqueues_by_paths($queue, $all_paths), $all_paths);

    $path_options = array_flip($all_paths);
    foreach ($subqueues as $subqueue) {
      unset($path_options[$subqueue->reference]);
    }
    $path_options = array_flip($path_options);
    $block['content'] = drupal_get_form('perpagequeue_block_form__' . $queue->name, $queue, $subqueues, $path_options, $all_paths);
  }

  return $block;
}

/**
 * Block builder for the Per Page Queue View block.
 */
function perpagequeue_block_view_view($queue) {
  $block = array();

  if ($queue->views_view != -1) {
    if (($subqueue = perpagequeue_load_subqueue_by_path($queue))) {
      list($view_id, $display_id) = explode('@', $queue->views_view, 2);

      $view = views_get_view($view_id);
      $block['content'] = $view->preview($display_id, array($subqueue->sqid));

      $substitutions = $view->build_info['substitutions'];
      $substitutions['%1'] = $subqueue->title;
      if (isset($view->build_info['title'])) {
        $block['subject'] = strtr($view->build_info['title'], $substitutions);
      }
    }
  }

  return $block;
}

/**
 * Form builder for the manage per page queue block form.
 */
function perpagequeue_block_form($form, &$form_state, $queue, $subqueues, $path_options, $all_paths) {
  $form = array();

  $form['queue'] = array(
    '#type' => 'value',
    '#value' => $queue,
  );

  if (!empty($path_options)) {
    $form['paths'] = array(
      '#type' => 'value',
      '#value' => $path_options,
    );

    if ($queue->use_tokens) {
      $form['path'] = array(
        '#type' => 'select',
        '#title' => t('Choose path reference'),
        '#description' => t('Choose which path reference to use when creating the new subqueue. The placeholder (%) will catch any text between two slashes.'),
        '#options' => $path_options,
      );
    }
    else {
      $form['path'] = array(
        '#type' => 'value',
        '#value' => '0',
      );
    }

    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Add subqueue for this page'),
    );
  }

  if (!empty($subqueues)) {
    $subqueue = array_shift($subqueues);

    $form['active_path'] = array(
      '#prefix' => '<div class="active-path">',
      '#markup' => t('The path <code>!path</code> is currently active on this page.', array('!path' => l($subqueue->reference, 'admin/structure/nodequeue/' . $queue->qid . '/view/' . $subqueue->sqid))),
      '#suffix' => '</div>',
    );

    if (!empty($subqueues)) {
      $items = array();
      foreach ($subqueues as $subqueue) {
        $items[] = l($subqueue->reference, 'admin/structure/nodequeue/' . $queue->qid . '/view/' . $subqueue->sqid);
      }

      $form['additional_paths'] = array(
        '#prefix' => '<div class="additional-paths">' . format_plural(
          count($items),
          'The following path is also active:',
          'The following paths are also active:'),
        '#markup' => theme('item_list', array('items' => $items)),
        '#suffix' => t('but will only display on this page if the above path is deleted.') . '</div>',
      );
    }

    $form['manage_paths'] = array(
      '#prefix' => '<div class="manage-paths">',
      '#markup' => l(t('Manage paths'), 'admin/structure/nodequeue/' . $queue->qid . '/path'),
      '#suffix' => '</div>',
    );

  }

  return $form;
}

/**
 * Form submit handler for perpagequeue_block_form.
 */
function perpagequeue_block_form_submit($form, &$form_state) {
  $queue = $form_state['values']['queue'];
  $path = $form_state['values']['paths'][$form_state['values']['path']];

  $subqueue = nodequeue_add_subqueue($queue, $path, $path);

  $form_state['redirect'] = 'admin/structure/nodequeue/' . $queue->qid . '/view/' . $subqueue->sqid;
}


/**
 * @section Nodequeue hooks and functions.
 */


/**
 * Implements hook_nodequeue_info().
 */
function perpagequeue_nodequeue_info() {
  return array(
    'perpagequeue' => array(
      'title' => t('Per Page Queue'),
      'description' => t('Subqueues based on a path.'),
    ),
  );
}

/**
 * Implements hook_nodequeue_form().
 */
function perpagequeue_nodequeue_form($queue, &$form) {
  $form['placeholder']['use_tokens'] = array(
    '#type' => 'checkbox',
    '#title' => t('Use Tokens'),
    '#description' => t('Check this box to enable the user of placeholder tokens (the <em>%</em> sign) in paths.'),
    '#default_value' => isset($queue->use_tokens) ? $queue->use_tokens : 0,
  );

  if (module_exists('views') && substr(views_api_version(), 0, 1) >= 3) {
    $all_views = views_get_all_views();
    $views = array(-1 => t('-- Do not use a view --'));
    foreach ($all_views as $view_name => $view) {

      if ($view->base_table == 'node' && (!isset($view->disabled) || !$view->disabled)) {
        // This module currently only supports nodes

        foreach ($view->display as $display_id => $display) {
          // Filter in only the block or default displays

          if (in_array($display->display_plugin, array('block', 'default'))) {
            $views[$view_name . '@' . $display_id] = (!empty($view->human_name) ? $view->human_name : $view_name) . ' (' . $display->display_title . ')';
          }
        }

      }

    }

    $form['placeholder']['views_view'] = array(
      '#type' => 'select',
      '#title' => t('Display View'),
      '#description' => t('Choose the view to use in the display block. The block will pass the Subqueue ID as the first and only. Filtering by the queue itself should be done in the view\'s relationship definition.'),
      '#default_value' => isset($queue->views_view) ? $queue->views_view : -1,
      '#options' => $views,
    );
  }
}

/**
 * Implements hook_nodequeue_form_submit().
 */
function perpagequeue_nodequeue_form_submit(&$queue, &$form_state) {
  variable_set('perpagequeue_' . $queue->name . '_use_tokens', (bool) $form_state['values']['use_tokens']);

  if (module_exists('views') && substr(views_api_version(), 0, 1) >= 3) {
    variable_set('perpagequeue_' . $queue->name . '_views_view', $form_state['values']['views_view']);
  }
}

/**
 * Implements hook_nodequeue_alter().
 */
function perpagequeue_nodequeue_alter(&$data, $type) {
  switch ($type) {
    case 'load_queues':
      foreach ($data as &$queue) {
        if ($queue->owner == 'perpagequeue') {
          $queue->use_tokens = variable_get('perpagequeue_' . $queue->name . '_use_tokens', FALSE);

          if (module_exists('views') && substr(views_api_version(), 0, 1) >= 3) {
            $queue->views_view = variable_get('perpagequeue_' . $queue->name . '_views_view', -1);
          }
        }
      }
      break;
  }
}

/**
 * Implements hook_nodequeue_subqueues().
 */
function perpagequeue_nodequeue_subqueues(&$queue, $node) {
  $subqueues = nodequeue_load_subqueues_by_queue($queue->qid);

  $references = array();
  foreach ($subqueues as $subqueue) {
    $references[$subqueue->sqid] = $subqueue->reference;
  }

  return $references;
}


/**
 * @section API and helper functions.
 */

/**
 * Filter access by making sure this is a Per Page Queue and that the user can manage page subqueues.
 */
function perpagequeue_manage_path_access($queue) {
  return nodequeue_queue_access($queue) && ($queue->owner == 'perpagequeue') && user_access('manage page subqueue');
}

/**
 * Get the best fitting subqueue for the given path.
 *
 * @param $queue
 *   The queue that the subqueues belong to
 * @param $path
 *   (optional) a string representing the path
 *
 * @return a subqueue object or FALSE if no matches.
 */
function perpagequeue_load_subqueue_by_path($queue, $path = '') {
  $paths = _perpagequeue_path_permutations($path);
  $subqueues = _perpagequeue_load_subqueues_by_paths($queue, $paths);

  foreach ($paths as $path) {
    foreach ($subqueues as $sqid => $subqueue) {
      if ($subqueue->reference == $path) {
        return $subqueue;
      }
    }
  }

  return FALSE;
}

/**
 * Generates token permutations for the given path in the precedence order.
 *
 * @param $path
 *   (optional) a string representing the path
 */
function _perpagequeue_path_permutations($path = '') {
  if (empty($path)) {
    $path = drupal_get_path_alias();
  }
  $path = explode('/', $path);

  $paths = array();

  $length = count($path);
  $max = pow(2, $length);
  for ($i = 0; $i < $max; $i++) {
    $path_copy = $path;
    for ($j = 0; $j < $length; $j++) {
      if ((1 << $j) & $i) {
        $path_copy[$length - $j - 1] = '%';
      }
    }
    $paths[] = implode('/', $path_copy);
  }

  return $paths;
}

/**
 * Loads all the subqueues that might belong to a paths list.
 *
 * @param $queue
 *   The queue that the subqueues belong to
 * @param $paths
 *   A list of paths
 */
function _perpagequeue_load_subqueues_by_paths($queue, $paths) {
  $query = db_select('nodequeue_subqueue', 's')
    ->fields('s')
    ->condition('qid', $queue->qid)
    ->condition('reference', $paths, 'IN');
  return $query->execute()->fetchAllAssoc('sqid');
}

/**
 * Orders subqueues by the paths list.
 *
 * Maintains correct association between keys (SQIDs) and values (Subqueue objects.)
 *
 * O(n^2). Finding a more efficient algorithm is left as an exercise to the reader.
 *
 * @param $subqueues
 *   An array of subqueues already fully loaded that we want to order
 * @param $paths
 *   An array of paths with which to order the subqueues
 */
function _perpagequeue_order_subqueues_by_paths($subqueues, $paths) {
  $ordered_subqueues = array();

  foreach ($paths as $path) {
    foreach ($subqueues as $sqid => $subqueue) {
      if ($subqueue->reference == $path) {
        $ordered_subqueues[$sqid] = $subqueue;
        break;
      }
    }
  }

  return $ordered_subqueues;
}
