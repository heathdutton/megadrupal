<?php

/**
 * @file
 * Provides an API for defining rules for rewriting the menu paths.
 *
 * @author Jimmy Berry ("boombatower", http://drupal.org/user/214218)
 */

/**
 * Get all the menu rewrite rules.
 *
 * @return array Associative array of rewrite rules where the key is the old
 *   path and the value is the new path.
 * @see hook_menu_rewrite_rule()
 */
function menu_rewrite_rule_get_all() {
  return module_invoke_all('menu_rewrite_rule');
}

/**
 * Get the rule that applies to the path, if any.
 *
 * @param string $path Path to check.
 * @return array Associative array representing the rewrite rule that applies
 *   to the path, containing keys: 'old' and 'new', otherwise FALSE.
 */
function menu_rewrite_rule_get($path) {
  $rules = menu_rewrite_rule_get_all();
  foreach ($rules as $old => $new) {
    if (substr($path, 0, strlen($old)) == $old) {
      return array('old' => $old, 'new' => $new);
    }
  }
  return FALSE;
}

/**
 * Apply the given rule to the path.
 *
 * @param string $path Path to apply rule to.
 * @param array $rule Menu rewrite rule.
 * @return string Rewritten path.
 */
function menu_rewrite_rule_apply($path, array $rule) {
  return str_replace($rule['old'], $rule['new'], $path, strlen($rule['old']));
}

/**
 * Get the argument offset for the given path.
 *
 * Rules may change the depth of a menu item. When the depth is changed
 * references to the arguments made in the menu item need to be offset. The
 * offset is determined by subtracting the number of levels in the 'old'
 * portion of the rewrite rule from the number of levels in the 'new' portion
 * of the rewrite rule.
 *
 * @param string $path Path to get offset for.
 * @param array $rule (Optional) Rewrite rule to determine offset for.
 * @return integer Argument offset.
 */
function menu_rewrite_argument_offset($path, $rule = FALSE) {
  if ($rule || ($rule = menu_rewrite_rule_get($path))) {
    return count(explode('/', $rule['new'])) - count(explode('/', $rule['old']));
  }
  return 0;
}

/**
 * Evaluate the menu rewrite rules given a set of menu items and create a map.
 *
 * The map will contain all the effected menu paths and their rewritten
 * counterparts. The map can be retrieved using menu_rewrite_map_get().
 *
 * @param array $items Menu items.
 * @see menu_rewrite_map_get()
 */
function menu_rewrite_rule_evaluate(array $items) {
  $rules = menu_rewrite_rule_get_all();
  $map = array();
  foreach ($rules as $old => $new) {
    foreach ($items as $path => $item) {
      if (substr($path, 0, strlen($old)) == $old) {
        $map[$path] = menu_rewrite_rule_apply($path, array('old' => $old, 'new' => $new));
      }
    }
  }

  // Store map for reference by alter functions.
  variable_set('menu_rewrite_map', $map);
}

/**
 * Get the map of menu paths.
 *
 * @return array Map of menu paths.
 * @see menu_rewrite_rule_evaluate()
 */
function menu_rewrite_map_get() {
  return variable_get('menu_rewrite_map', array());
}

/**
 * Correct the given path to point to the rewritten menu item.
 *
 * @param string $path Reference to path.
 */
function menu_rewrite_path_correct(&$path) {
  global $base_path;

  // Get the map map of rewrite rules.
  $map = menu_rewrite_map_get();

  // Determine if the path is relative and contains the $base_path and if so
  // remove the $base_path before processing.
  $relative = strpos($path, $base_path) === 0;
  $key = $relative ? substr($path, strlen($base_path)) : $path;

  // Determine if a rule applies to the $key.
  if ($rule = menu_rewrite_rule_get($key)) {
    // Apply the rule to the path and add the $base_path back if necessary.
    $path = menu_rewrite_rule_apply($path, $rule);
    if ($relative) {
      $path = $base_path . $path;
    }
  }
}

/**
 * Implements hook_menu_alter().
 */
function menu_rewrite_menu_alter(&$items) {
  // Evaluate rules to ensure map is up-to-date.
  menu_rewrite_rule_evaluate($items);

  // List of keys whose arguments need to be offset.
  $menu_keys = array(
    'title arguments',
    'page arguments',
    'access arguments',
    'theme arguments',
    'load arguments',
  );

  // Move items based on the map and offset keys.
  $map = menu_rewrite_map_get();
  foreach ($map as $old => $new) {
    // Move item.
    $items[$new] = $items[$old];
    unset($items[$old]);

    // If there is an offset the apply it to all applicable keys.
    if ($offset = menu_rewrite_argument_offset($old)) {
      foreach ($menu_keys as $menu_key) {
        if (!empty($items[$new][$menu_key])) {
          foreach ($items[$new][$menu_key] as &$key) {
            if (is_numeric($key)) {
              $key = $key + $offset;
            }
          }
        }
      }
    }
  }

  // Allow modules to make followup changes to rewritten menu items.
  drupal_alter('menu_rewrite', $items);
}

/**
 * Implements hook_drupal_goto_alter().
 */
function menu_rewrite_drupal_goto_alter(&$path, &$options, &$http_response_code) {
  menu_rewrite_path_correct($path);
}

/**
 * Implements hook_form_alter().
 */
function menu_rewrite_form_alter(&$form, &$form_state, $form_id) {
  menu_rewrite_path_correct($form['#action']);
}

/**
 * Implements hook_url_outbound_alter().
 */
function menu_rewrite_url_outbound_alter(&$path, &$options, $original_path) {
  menu_rewrite_path_correct($path);
}
