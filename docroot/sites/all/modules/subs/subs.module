<?php
/**
 * @file
 * Subs module.
 */
/**
 * Subscription status contstants.
 */
define('SUBS_STATUS_PENDING', 0);
define('SUBS_STATUS_ACTIVE', 1);
define('SUBS_STATUS_GRACE', 2);
define('SUBS_STATUS_EXPIRED', 3);
define('SUBS_STATUS_CANCELLED', 4);

/**
 * Subscription workflow constants.
 */
define('SUBS_WORKFLOW_ANY', 0);
define('SUBS_WORKFLOW_ONE', 1);
define('SUBS_WORKFLOW_TYPE', 2);

/**
 * Implements hook_permission().
 */
function subs_permission() {
  // General permissions.
  $permissions = array(
    'administer subs' => array(
      'title' => t('Administer subscriptions'),
    ),
    'administer subs types' => array(
      'title' => t('Administer subscription types'),
    ),
  );

  // Permissions per subscription type.
  foreach (subs_get_types() as $type) {
    $type_name = check_plain($type->name);
    $permissions += array(
      "create $type_name subscription" => array(
        'title' => t('%type_name: Create subscriptions', array('%type_name' => $type->label)),
      ),
      "edit own $type_name subscription" => array(
        'title' => t('%type_name: Edit own subscriptions', array('%type_name' => $type->label)),
      ),
      "edit any $type_name subscription" => array(
        'title' => t('%type_name: Edit any subscription', array('%type_name' => $type->label)),
      ),
      "delete own $type_name subscription" => array(
        'title' => t('%type_name: Delete own subscriptions', array('%type_name' => $type->label)),
      ),
      "delete any $type_name subscription" => array(
        'title' => t('%type_name: Delete any subscription', array('%type_name' => $type->label)),
      ),
      "view own $type_name subscription" => array(
        'title' => t('%type_name: View own subscriptions', array('%type_name' => $type->label)),
      ),
      "view any $type_name subscription" => array(
        'title' => t('%type_name: View any subscription', array('%type_name' => $type->label)),
      ),
    );
  }
  return $permissions;
}

/**
 * Implements hook_entity_info().
 */
function subs_entity_info() {
  $return = array();

  // Subscription Type entity.
  $return['subs_type'] = array(
    'label' => t('Subscription type'),
    'plural label' => t('Subscription types'),
    'entity class' => 'SubsType',
    'controller class' => 'SubsTypeController',
    'base table' => 'subs_type',
    'fieldable' => FALSE,
    'exportable' => TRUE,
    'entity keys' => array(
      'id' => 'id',
      'name' => 'name',
      'label' => 'label',
    ),
    'bundles' => array(),
    'bundle of' => 'subs',
    'access callback' => 'subs_type_access',
    'module' => 'subs',
    // Enable the Entity API's admin UI.
    'admin ui' => array(
      'path' => 'admin/structure/subscriptions',
      'file' => 'subs.admin.inc',
      'controller class' => 'SubsTypeUIController',
    ),
  );

  // Subscription entity.
  $return['subs'] = array(
    'label' => t('Subscription'),
    'plural label' => t('Subscriptions'),
    'entity class' => 'Subs',
    'controller class' => 'SubsController',
    'base table' => 'subs',
    'fieldable' => TRUE,
    'view modes' => array(
      'full' => array(
        'label' => t('Full'),
        'custom settings' => FALSE,
      ),
    ),
    'entity keys' => array(
      'id' => 'sid',
      'bundle' => 'type',
    ),
    'bundles' => array(),
    'bundle keys' => array(
      'bundle' => 'name',
    ),
    'uri callback' => 'entity_class_uri',
    'label callback' => 'entity_class_label',
    'access callback' => 'subs_access',
    'module' => 'subs',
    'metadata controller class' => 'SubsMetadataController',
    'views controller class' => 'SubsViewsController',
  );

  // Add bundle info but bypass entity_load() as we cannot use it here.
  $subscription_types = db_select('subs_type', 'st')
    ->fields('st')
    ->execute()
    ->fetchAllAssoc('name');

  foreach ($subscription_types as $type_name => $type) {
    $return['subs']['bundles'][$type_name] = array(
      'label' => $type->label,
      'description' => $type->description,
      'admin' => array(
        'path' => 'admin/structure/subscriptions/manage/%subs_type',
        'real path' => 'admin/structure/subscriptions/manage/' . $type->name,
        'bundle argument' => 4,
        'access arguments' => array('administer subs types'),
      ),
    );
  }

  // Support locale module.
  if (module_exists('locale')) {
    $return['subs_type']['translation']['locale'] = TRUE;
  }

  // Support entity cache module.
  if (module_exists('entitycache')) {
    $return['subs']['entity cache'] = TRUE;
    // Entity cache obsoletes field cache.
    $return['subs']['field cache'] = FALSE;
  }

  return $return;
}

/**
 * Implements hook_menu().
 */
function subs_menu() {
  $items = array();

  // Settings page.
  $items['admin/config/workflow/subs'] = array(
    'title' => 'Subs',
    'description' => 'Manage subscription settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('subs_settings_form'),
    'access arguments' => array('administer subs'),
    'file' => 'subs.admin.inc',
  );

  $items['admin/config/workflow/subs/default'] = array(
    'title' => 'Subs',
    'access arguments' => array('administer subs'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  // Manage subscription types local action in settings page.
  $items['admin/config/workflow/subs/structure'] = array(
    'title' => 'Manage subscription types',
    'page callback' => 'drupal_goto',
    'page arguments' => array('admin/structure/subscriptions'),
    'access arguments' => array('administer subs'),
    'type' => MENU_LOCAL_ACTION,
  );

  // Manage subscription types local action in settings page.
  $items['admin/config/workflow/subs/content'] = array(
    'title' => 'Manage subscriptions',
    'page callback' => 'drupal_goto',
    'page arguments' => array('admin/content/subscription'),
    'access arguments' => array('administer subs'),
    'type' => MENU_LOCAL_ACTION,
  );

  // Administer subscriptions page.
  $items['admin/content/subscription'] = array(
    'title' => 'Subscriptions',
    'page callback' => 'subs_list',
    'access arguments' => array('administer subs'),
    'file' => 'subs.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  // Add subscription local action in manage subs page.
  $items['admin/content/subscription/add'] = array(
    'title' => 'Create Subscription',
    'page callback' => 'drupal_goto',
    'page arguments' => array('subscription/add'),
    'access arguments' => array('administer subs'),
    'type' => MENU_LOCAL_ACTION,
  );

  // Manage subscription types local action in manage subs page.
  $items['admin/content/subscription/types'] = array(
    'title' => 'Manage subscription types',
    'page callback' => 'drupal_goto',
    'page arguments' => array('admin/structure/subscriptions'),
    'access arguments' => array('administer subs'),
    'type' => MENU_LOCAL_ACTION,
  );

  // Subscription settings local action in manage subs page.
  $items['admin/content/subscription/settings'] = array(
    'title' => 'Subscription settings',
    'page callback' => 'drupal_goto',
    'page arguments' => array('admin/config/workflow/subs'),
    'access arguments' => array('administer subs'),
    'type' => MENU_LOCAL_ACTION,
  );

  // Create subscription.
  $items['subscription/add'] = array(
    'title' => 'Create subscription',
    'page callback' => 'subs_add_page',
    'access arguments' => array('create subs'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'subs.pages.inc',
  );

  // Manage subscriptions local action in manage subscription types page.
  $items['admin/structure/subscriptions/content'] = array(
    'title' => 'Manage subscriptions',
    'page callback' => 'drupal_goto',
    'page arguments' => array('admin/content/subscription'),
    'access arguments' => array('administer subs'),
    'type' => MENU_LOCAL_ACTION,
  );

  // Subscription settings local action in manage subscription types page.
  $items['admin/structure/subscriptions/settings'] = array(
    'title' => 'Subscription settings',
    'page callback' => 'drupal_goto',
    'page arguments' => array('admin/config/workflow/subs'),
    'access arguments' => array('administer subs'),
    'type' => MENU_LOCAL_ACTION,
  );

  foreach (subs_get_types() as $type => $info) {
    $items['subscription/add/' . $type] = array(
      'title' => $info->getTranslation('label'),
      'description' => isset($info->description) ? $info->description : '',
      'page callback' => 'subs_add',
      'page arguments' => array(2),
      'access callback' => 'entity_access',
      'access arguments' => array('create', 'subs', $type),
      'file' => 'subs.pages.inc',
    );
  }

  // For the sake of convenience.
  $subscription_uri = 'subscription/%subs';
  $subscription_uri_argument_position = 1;

  // View subscription.
  $items[$subscription_uri] = array(
    'title callback' => 'subs_page_title',
    'title arguments' => array($subscription_uri_argument_position),
    'page callback' => 'subs_view',
    'page arguments' => array($subscription_uri_argument_position),
    'access callback' => 'entity_access',
    'access arguments' => array('view', 'subs', $subscription_uri_argument_position),
  );

  $items[$subscription_uri . '/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  // Edit subscription.
  $items[$subscription_uri . '/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('subs_form', $subscription_uri_argument_position),
    'access callback' => 'entity_access',
    'access arguments' => array('edit', 'subs', $subscription_uri_argument_position),
    'file' => 'subs.pages.inc',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
  );

  // Delete subscription.
  $items[$subscription_uri . '/delete'] = array(
    'title' => 'Delete subscription',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('subs_delete_form', $subscription_uri_argument_position),
    'access callback' => 'entity_access',
    'access arguments' => array('edit', 'subs', $subscription_uri_argument_position),
    'file' => 'subs.pages.inc',
  );

  // Devel integration.
  if (module_exists('devel')) {
    $devel_path = drupal_get_path('module', 'devel');
    $items[$subscription_uri . '/devel'] = array(
      'title' => 'Devel',
      'page callback' => 'devel_load_object',
      'file' => 'devel.pages.inc',
      'file path' => $devel_path,
      'page arguments' => array('subs', $subscription_uri_argument_position),
      'access arguments' => array('access devel information'),
      'type' => MENU_LOCAL_TASK,
      'weight' => 100,
    );

    $items[$subscription_uri . '/devel/load'] = array(
      'title' => 'Load',
      'type' => MENU_DEFAULT_LOCAL_TASK,
    );

    $items[$subscription_uri . '/devel/render'] = array(
      'title' => 'Render',
      'page callback' => 'devel_render_object',
      'page arguments' => array('subs', $subscription_uri_argument_position),
      'access arguments' => array('access devel information'),
      'file' => 'devel.pages.inc',
      'file path' => $devel_path,
      'type' => MENU_LOCAL_TASK,
      'weight' => 100,
    );
  }

  // My subscriptions tab.
  $items['user/%/subscriptions'] = array(
    'title' => 'My Subscriptions',
    'page callback' => 'subs_list',
    'page arguments' => array(1),
    'access arguments' => array('create subs'),
    'file' => 'subs.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function subs_theme() {
  return array(
    'subs' => array(
      'render element' => 'elements',
      'template' => 'subs',
    ),
    'subs_block_create' => array(
      'render element' => 'elements',
      'file' => 'subs.theme.inc',
    ),
    'subs_block_status' => array(
      'render element' => 'elements',
      'file' => 'subs.theme.inc',
    ),
  );
}

/**
 * Implements hook_views_api().
 */
function subs_views_api() {
  return array('version' => '3.0');
}

/**
 * Implements hook_user_delete().
 *
 * When a user account is deleted, cancel it's subscriptions.
 */
function subs_user_delete($account) {
  foreach (subs_load_by_user($account) as $subscription) {
    subs_delete($subscription);
  }
}

/**
 * Implements hook_user_update().
 *
 * When a user account is disabled, cancel it's subscriptions.
 */
function subs_user_update(&$edit, $account) {
  if ($account->status == NODE_NOT_PUBLISHED) {
    foreach (subs_load_by_user($account) as $subscription) {
      subs_set_cancelled($subscription);
    }
  }
}

/**
 * Implements hook_field_extra_fields().
 *
 * Add subscription properties to subscription type Manage Fields and
 * Manage Display forms.
 */
function subs_field_extra_fields() {
  $extra_fields = array();
  $fields = array(
    'uid' => array(
      'label' => t('User'),
      'description' => t('Subscription user'),
      'weight' => -5,
    ),
    'status' => array(
      'label' => t('Status'),
      'description' => t('Subscription status'),
      'weight' => -3,
    ),
    'date_start' => array(
      'label' => t('Start Date'),
      'description' => t('Subscription start date'),
      'weight' => -2,
    ),
    'date_end' => array(
      'label' => t('End Date'),
      'description' => t('Subscription end date'),
      'weight' => -1,
    ),
  );

  // Iterate through subscription type bundles.
  foreach (subs_get_types() as $bundle => $type) {
    $extra_fields['subs'][$bundle] = array(
      'form' => $fields,
      'display' => array(
      'type' => array(
        'label' => t('Type'),
        'description' => t('Subscription type'),
        'weight' => -4,
      ),
      ) + $fields,
    );
  }

  return $extra_fields;
}

/**
 * Implements hook_action_info().
 */
function subs_action_info() {
  return array(
    'subs_action_set_active' => array(
      'label' => t('Make subscription active'),
      'type' => 'subs',
      'configurable' => FALSE,
      'trigger' => array('any'),
      'behavior' => array('changes_property'),
    ),
    'subs_action_set_pending' => array(
      'label' => t('Make subscription pending'),
      'type' => 'subs',
      'configurable' => FALSE,
      'trigger' => array('any'),
      'behavior' => array('changes_property'),
    ),
    'subs_action_set_grace' => array(
      'label' => t('Change subscription to grace period'),
      'type' => 'subs',
      'configurable' => FALSE,
      'trigger' => array('any'),
      'behavior' => array('changes_property'),
    ),
    'subs_action_cancel' => array(
      'label' => t('Cancel subscription'),
      'type' => 'subs',
      'configurable' => FALSE,
      'trigger' => array('any'),
      'behavior' => array('changes_property'),
    ),
    'subs_action_delete' => array(
      'label' => t('Delete subscription'),
      'type' => 'subs',
      'configurable' => FALSE,
      'trigger' => array('any'),
      'behavior' => array('changes_property'),
    ),
    'subs_action_renew' => array(
      'label' => t('Renew subscription'),
      'type' => 'subs',
      'configurable' => FALSE,
      'trigger' => array('any'),
      'behavior' => array('changes_property'),
    ),
  );
}

/**
 * Makes a subscription active.
 *
 * @param $subscription
 *   An optional subscription object.
 * @param array $context
 *   Array with components:
 *   - 'sid': Subscription ID. Required if $subscription is not given.
 *
 * @ingroup actions
 */
function subs_action_set_active($subscription = NULL, $context = array()) {
  if (!$subscription instanceof Subs) {
    if (!isset($context['sid'])) {
      return FALSE;
    }
    $subscription = subs_load($context['sid']);
  }

  $subject = entity_label('subs', $subscription);

  if (subs_set_active($subscription) && variable_get('subs_dev', TRUE)) {
    watchdog('subs', 'VBO - Set subscription active: %subject.', array('%subject' => $subject), WATCHDOG_INFO);
  }
}

/**
 * Makes a subscription pending.
 *
 * @param $subscription
 *   An optional subscription object.
 * @param array $context
 *   Array with components:
 *   - 'sid': Subscription ID. Required if $subscription is not given.
 *
 * @ingroup actions
 */
function subs_action_set_pending($subscription = NULL, $context = array()) {
  if (!$subscription instanceof Subs) {
    if (!isset($context['sid'])) {
      return FALSE;
    }
    $subscription = subs_load($context['sid']);
  }

  $subject = entity_label('subs', $subscription);

  if (subs_set_pending($subscription) && variable_get('subs_dev', TRUE)) {
    watchdog('subs', 'VBO - Set subscription pending: %subject.', array('%subject' => $subject), WATCHDOG_INFO);
  }
}

/**
 * Change a subscription to grace period.
 *
 * @param $subscription
 *   An optional subscription object.
 * @param array $context
 *   Array with components:
 *   - 'sid': Subscription ID. Required if $subscription is not given.
 *
 * @ingroup actions
 */
function subs_action_set_grace($subscription = NULL, $context = array()) {
  if (!$subscription instanceof Subs) {
    if (!isset($context['sid'])) {
      return FALSE;
    }
    $subscription = subs_load($context['sid']);
  }

  $subject = entity_label('subs', $subscription);

  if (subs_set_grace($subscription) && variable_get('subs_dev', TRUE)) {
    watchdog('subs', 'VBO - Set subscription to grace period: %subject.', array('%subject' => $subject), WATCHDOG_INFO);
  }
}

/**
 * Cancel a subscription.
 *
 * @param $subscription
 *   An optional subscription object.
 * @param array $context
 *   Array with components:
 *   - 'sid': Subscription ID. Required if $subscription is not given.
 *
 * @ingroup actions
 */
function subs_action_cancel($subscription = NULL, $context = array()) {
  if (!$subscription instanceof Subs) {
    if (!isset($context['sid'])) {
      return FALSE;
    }
    $subscription = subs_load($context['sid']);
  }

  $subject = entity_label('subs', $subscription);

  if (subs_set_cancelled($subscription) && variable_get('subs_dev', TRUE)) {
    watchdog('subs', 'VBO - Cancelled subscription: %subject.', array('%subject' => $subject), WATCHDOG_INFO);
  }
}

/**
 * Delete a subscription.
 *
 * @param $subscription
 *   An optional subscription object.
 * @param array $context
 *   Array with components:
 *   - 'sid': Subscription ID. Required if $subscription is not given.
 *
 * @ingroup actions
 */
function subs_action_delete($subscription = NULL, $context = array()) {
  if (!$subscription instanceof Subs) {
    if (!isset($context['sid'])) {
      return FALSE;
    }
    $subscription = subs_load($context['sid']);
  }

  $subject = entity_label('subs', $subscription);

  if (subs_delete($subscription) && variable_get('subs_dev', TRUE)) {
    watchdog('subs', 'VBO - Deleted subscription: %subject.', array('%subject' => $subject), WATCHDOG_INFO);
  }
}

/**
 * Renew a subscription.
 *
 * @param $subscription
 *   An optional subscription object.
 * @param array $context
 *   Array with components:
 *   - 'sid': Subscription ID. Required if $subscription is not given.
 *
 * @ingroup actions
 */
function subs_action_renew($subscription = NULL, $context = array()) {
  if (!$subscription instanceof Subs) {
    if (!isset($context['sid'])) {
      return FALSE;
    }
    $subscription = subs_load($context['sid']);
  }

  $subject = entity_label('subs', $subscription);

  if (subs_renew($subscription) && variable_get('subs_dev', TRUE)) {
    watchdog('subs', 'VBO - Renewed subscription: %subject.', array('%subject' => $subject), WATCHDOG_INFO);
  }
}

/**
 * Implements hook_help().
 */
function subs_help($path, $arg) {
  switch ($path) {
    case 'admin/content/subscription':
      return t('Here you can view, edit and delete all subscriptions.');
    case 'admin/structure/subscriptions':
      return t('Here you can manage your subscription types.');
    case 'admin/help#subs':
      $output = '';
      $output .= '<p>' . t('Short for "Subscriptions", this module enables "site subscriptions".') . '</p>';
      $output .= '<p>' . t('This module aims at allowing users to subscribe to a site (or service). A subscription can have different types (bronze, silver, gold, etc) and can have different statuses (pending, active, grace period, exipred, cancelled) .') . '</p>';
      $output .= '<p>' . t('Each subscription type can define an optional length for subscriptions and also a grace period after subscriptions expire.') . '</p>';
      $output .= '<p>' . t('To get started, create a <a href="@link">subscription type</a>!', array('@link' => '/admin/structure/subscriptions')) . '</p>';
      return $output;
  }
}

/**
 * Implements hook_admin_paths().
 */
function subs_admin_paths() {
  $paths = array(
    'subscription/add' => TRUE,
    'subscription/add/*' => TRUE,
    'subscription/*/edit' => TRUE,
    'subscription/*/delete' => TRUE,
    'user/*/subscriptions' => TRUE,
  );
  return $paths;
}

/**
 * Implements hook_date_format_types().
 */
function subs_date_format_types() {
  return array(
    'subs' => t('Subscription'),
  );
}

/**
 * Implements hook_date_formats().
 */
function subs_date_formats() {
  return array(
    array(
      'type' => 'subs',
      'format' => 'Y-m-d',
    ),
    array(
      'type' => 'subs',
      'format' => 'd-m-Y',
    ),
    array(
      'type' => 'subs',
      'format' => 'd/m/Y',
    ),
    array(
      'type' => 'subs',
      'format' => 'Y/m/d',
    ),
  );
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function subs_form_field_ui_display_overview_form_alter(&$form, &$form_state, $form_id) {
  if ($form['#entity_type'] === 'subs') {
    // Add label settings for subscription properties.
    $label = array(
      '#type' => 'select',
      '#title' => t('Label display'),
      '#title_display' => 'invisible',
      '#options' => array(
        'above' => t('Above'),
        'inline' => t('Inline'),
        'hidden' => t('<Hidden>'),
      ),
    );

    $properties = array('type', 'uid', 'status', 'date_start', 'date_end');

    foreach ($form['fields'] as $key => $value) {
      if (in_array($key, $properties)) {
        $label['#default_value'] = variable_get("subs_{$key}_label", 'inline');
        $form['fields'][$key]['label'] = $label;
        unset($form['fields'][$key]['empty_cell']);
        $format = $form['fields'][$key]['format'];
        $settings_summary = $form['fields'][$key]['settings_summary'];
        $settings_edit = $form['fields'][$key]['settings_edit'];
        unset($form['fields'][$key]['format']);
        unset($form['fields'][$key]['settings_summary']);
        unset($form['fields'][$key]['settings_edit']);
        $form['fields'][$key]['format'] = $format;
        $form['fields'][$key]['settings_summary'] = $settings_summary;
        $form['fields'][$key]['settings_edit'] = $settings_edit;
      }
    }

    $form['#submit'][] = 'subs_field_ui_display_overview_form_submit';
  }
}

/**
 * Submit callback.
 *
 * @see subs_form_field_ui_display_overview_form_alter()
 */
function subs_field_ui_display_overview_form_submit(&$form, &$form_state) {
  $properties = array('type', 'uid', 'status', 'date_start', 'date_end');

  foreach ($form_state['values']['fields'] as $key => $value) {
    if (in_array($key, $properties)) {
      variable_set("subs_{$key}_label", $value['label']);
    }
  }
}

/**
 * Implements hook_block_info().
 */
function subs_block_info() {
  return array(
    'subs_create' => array(
      'info' => t('New subscription'),
      'cache' => DRUPAL_CACHE_GLOBAL,
    ),
    'subs_status' => array(
      'info' => t('Subscription status'),
      'cache' => DRUPAL_CACHE_PER_USER,
    ),
  );
}

/**
 * Implements hook_block_view().
 */
function subs_block_view($delta = '') {
  $block = array();

  switch ($delta) {
    case 'subs_create':
      $block['subject'] = t('New subscription');
      $block['content'] = array(
        '#theme' => 'subs_block_create',
      );
      break;
    case 'subs_status':
      $block['subject'] = t('Subscription status');
      $block['content'] = array(
        '#theme' => 'subs_block_status',
      );
      break;
  }

  return $block;
}

/**
 * Implements hook_cron().
 */
function subs_cron() {
  // Handle expirations for grace period subscriptions.
  $queue_grace = DrupalQueue::get('subs_queue_grace');
  foreach (subs_cron_get_grace() as $grace) {
    $queue_grace->createItem($grace);
  }

  // Handle expirations for active subscriptions.
  $queue_expired = DrupalQueue::get('subs_queue_expired');
  foreach (subs_cron_get_expired() as $expired) {
    $queue_expired->createItem($expired);
  }
}

/**
 * Implements hook_cron_queue_info().
 */
function subs_cron_queue_info() {
  return array(
    'subs_queue_grace' => array(
      'worker callback' => 'subs_cron_run_grace',
      'time' => 60,
    ),
    'subs_queue_expired' => array(
      'worker callback' => 'subs_cron_run_expired',
      'time' => 60,
    ),
  );
}

######################
### Cron Functions ###
######################

/**
 * Finds and returns grace period subscriptions ending today.
 *
 * @return array
 *   An array of subscription ids.
 *
 * @see subs_cron()
 */
function subs_cron_get_grace() {
  $today = time();
  $subscriptions = array();

  // Iterate through subscription types.
  // This is necessary since each type has different grace settings.
  foreach (subs_get_types() as $type) {
    // Ignore length property as we assume subscriptions here are already
    // in their grace period.
    // Grace set to 0 means no grace period.
    if ($type->grace != 0) {
      $query = new EntityFieldQuery();
      $query
        ->entityCondition('entity_type', 'subs')
        ->entityCondition('bundle', $type->name)
        ->propertyCondition('status', SUBS_STATUS_GRACE)
        ->propertyCondition('date_end', $today, '<');

      $entities = $query->execute();

      if (!empty($entities)) {
        $subscriptions += array_keys($entities['subs']);
      }
    }
  }

  return $subscriptions;
}

/**
 * Finds and returns active subscriptions ending today.
 *
 * @return array
 *   An array of subscription ids.
 *
 * @see subs_cron()
 */
function subs_cron_get_expired() {
  $today = time();
  $subscriptions = array();

  // Iterate through subscription types.
  // This is necessary since each type has different grace settings.
  foreach (subs_get_types() as $type) {
    // Length set to 0 means subscription doesn't expire.
    if ($type->length != 0) {
      $query = new EntityFieldQuery();
      $query
        ->entityCondition('entity_type', 'subs')
        ->entityCondition('bundle', $type->name)
        ->propertyCondition('status', SUBS_STATUS_ACTIVE)
        ->propertyCondition('date_end', $today, '<');

      $entities = $query->execute();

      if (!empty($entities)) {
        $subscriptions += array_keys($entities['subs']);
      }
    }
  }

  return $subscriptions;
}

#################
### Callbacks ###
#################

/**
 * Subscription view callback.
 * Displays a subscription entity.
 *
 * This is here as opposed to in subs.pages.inc because if Devel is enabled
 * clicking on Devel->Render will trigger an error as the include is not
 * automatically included in that case.
 *
 * @param Subs
 *   The $subscription we want to view.
 * @return string
 *   The rendered subscription entity.
 *
 * @see subs_menu()
 */
function subs_view(Subs $subscription) {
  drupal_set_title(entity_label('subs', $subscription));
  return entity_view('subs', array(entity_id('subs', $subscription) => $subscription), 'full');
}

/**
 * Menu title callback.
 * Returns page title for subscription-related menu items.
 *
 * @param Subs
 *   The $subscription we want to get a title for.
 * @return string
 *   The subscription's label.
 *
 * @see subs_menu()
 */
function subs_page_title(Subs $subscription) {
  return $subscription->label();
}

/**
 * Determines whether the given user has access to a subscription operation.
 *
 * @param $op
 *   The operation being performed. One of 'view', 'update', 'create', 'delete'
 *   or just 'edit' (being the same as 'create' or 'update').
 * @param $subscription
 *   Optionally a subscription object to check access for. If nothing is given,
 *    access for all subscriptions is determined.
 * @param $account
 *   The user to check for. Leave it NULL to check for the current user.
 * @return boolean
 *   Whether access is allowed or not.
 *
 * @see hook_subs_access()
 * @see subs_subs_access()
 */
function subs_access($op, $subscription = NULL, $account = NULL) {
  if (user_access('administer subs', $account)) {
    return TRUE;
  }

  // Allow modules to grant / deny access.
  $access = module_invoke_all('subs_access', $op, $subscription, $account);

  // Only grant access if at least one module granted access and no one denied
  // access.
  if (in_array(FALSE, $access, TRUE)) {
    return FALSE;
  }
  elseif (in_array(TRUE, $access, TRUE)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implements hook_subs_access().
 */
function subs_subs_access($op, $subscription = NULL, $account = NULL) {
  if (!isset($account)) {
    $account = user_uid_optional_load();
  }

  // If no subscription is specified, check access for all.
  if (!isset($subscription)) {
    return user_access('administer subs', $account);
  }
  else {
    $type_name = $subscription->type;
  }

  if ($op === 'create') {
    if (user_access("create $type_name subscription", $account)) {
      // Check workflow.
      switch (variable_get('subs_workflow', SUBS_WORKFLOW_ONE)) {
        case SUBS_WORKFLOW_ANY:
          return TRUE;
          break;
        case SUBS_WORKFLOW_ONE:
          // Check how many subscriptions the user has.
          if (!subs_load_by_user($account)) {
            return TRUE;
          }
          break;
        case SUBS_WORKFLOW_TYPE:
          // Check how many subscriptions the user has of this type.
          if (!subs_load_by_user($account, $type->name)) {
            return TRUE;
          }
          break;
      }
    }
    else {
      return FALSE;
    }
  }
  else {
    if (user_access("$op any $type_name subscription", $account)) {
      return TRUE;
    }

    if (isset($subscription->uid) && $subscription->uid == $account->uid && user_access("$op own $type_name subscription", $account)) {
      return TRUE;
    }
  }

  // We only explicitly deny access for the "create" operation, leave all
  // other permissions open so that other modules may still grant access.
}

/**
 * Determines whether the given user has access to a subscription type
 * operation.
 *
 * @param $op
 *   The operation being performed. One of 'view', 'update', 'create', 'delete'
 *   or just 'edit' (being the same as 'create' or 'update'). This isn't
 *   actually used as there is one global administer subs types permission.
 * @param $type
 *   The subscription type we want to check access for. This isn't
 *   actually used as there is one global administer subs types permission.
 * @param $account
 *   The user to check for. Leave it NULL to check for the current user.
 * @return bool
 *   Whether the user has access.
 */
function subs_type_access($op, $type = NULL, $account = NULL) {
  return user_access('administer subs types', $account);
}

/**
 * Worker callback.
 * Processes grace period subscriptions that have expired.
 *
 * @param int
 *   A subscription $id.
 *
 * @see subs_cron_queue_info()
 * @see subs_cron()
 */
function subs_cron_run_grace($sid) {
  if ($subscription = subs_load($sid)) {
    if (subs_set_expired($subscription) && variable_get('subs_dev', TRUE)) {
      watchdog('subs', 'Expired subscription with id !id.', array('!id' => $sid), WATCHDOG_INFO);
    }
    else {
      watchdog('subs', 'Error expiring subscription with id !id.', array('!id' => $sid), WATCHDOG_ERROR);
    }
  }
  else {
    watchdog('subs', 'Error loading subscription with id !id.', array('!id' => $sid), WATCHDOG_ERROR);
  }
}

/**
 * Worker callback.
 * Processes active subscriptions that have expired.
 *
 * Subscriptions of types with grace periods get changed to grace period and
 * subscriptions of types without grace periods get expired.
 *
 * @param int
 *   A subscription $id.
 *
 * @see subs_cron_queue_info()
 * @see subs_cron()
 */
function subs_cron_run_expired($sid) {
  if ($subscription = subs_load($sid)) {
    // Load subscription type.
    $subscription_type = subs_get_types($subscription->type);

    // If subscription has grace period, change status accordingly.
    if ($subscription_type->grace != 0) {
      if (subs_set_grace($subscription) && variable_get('subs_dev', TRUE)) {
        watchdog('subs', 'Changed subscription with id !id to grace period.', array('!id' => $sid), WATCHDOG_INFO);
      }
      else {
        watchdog('subs', 'Error changing subscription with id !id to grace period.', array('!id' => $sid), WATCHDOG_ERROR);
      }
    }
    // No grace period, just expire subscription.
    else {
      if (subs_set_expired($subscription) && variable_get('subs_dev', TRUE)) {
        watchdog('subs', 'Expired subscription with id !id.', array('!id' => $sid), WATCHDOG_INFO);
      }
      else {
        watchdog('subs', 'Error expiring subscription with id !id.', array('!id' => $sid), WATCHDOG_ERROR);
      }
    }
  }
  else {
    watchdog('subs', 'Error loading subscription with id !id.', array('!id' => $sid), WATCHDOG_ERROR);
  }
}

########################
### Helper Functions ###
########################

/**
 * Return the options lists for the subs status property.
 *
 * @return array
 *   A keyed array with subscription statuses as keys and labels
 *   as values.
 */
function subs_status_options_list() {
  return array(
    SUBS_STATUS_PENDING => t('Pending'),
    SUBS_STATUS_ACTIVE => t('Active'),
    SUBS_STATUS_GRACE => t('Grace Period'),
    SUBS_STATUS_EXPIRED => t('Expired'),
    SUBS_STATUS_CANCELLED => t('Cancelled'),
  );
}

############################
### API Functions - CRUD ###
############################

/**
 * Fetch a subscription object.
 *
 * @param $sid
 *   Integer specifying the subscription id.
 * @param $reset
 *   A boolean indicating that the internal cache should be reset.
 * @return
 *   A fully-loaded $subscription object or FALSE if it cannot be loaded.
 *
 * @see subs_load_multiple()
 */
function subs_load($sid, $reset = FALSE) {
  $subscriptions = subs_load_multiple(array($sid), array(), $reset);
  return reset($subscriptions);
}

/**
 * Load multiple subscriptions based on certain conditions.
 *
 * @param $sids
 *   An array of subscription IDs.
 * @param $conditions
 *   An array of conditions to match against the {subs} table.
 * @param $reset
 *   A boolean indicating that the internal cache should be reset.
 * @return array|FALSE
 *   An array of subscription objects, indexed by ID or FALSE of none were found.
 *
 * @see entity_load()
 * @see subs_load()
 * @see subs_load_by_user()
 */
function subs_load_multiple($sids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('subs', $sids, $conditions, $reset);
}

/**
 * Fetch subscriptions by account.
 *
 * @param $account
 *   The user account to load subscriptions for, or its uid.
 * @param $type_name
 *   To load subscriptions of a single type, specify it.
 * @param $reset
 *   To bypass the static cache set this to true.
 * @return Subs|array|FALSE
 *   Either a single subscription or an array of subscriptions keyed by
 *   subscription type or FALSE of no subscriptions found.
 *
 * @see subs_load_multiple()
 */
function subs_load_by_user($account, $type_name = NULL, $reset = FALSE) {
  // Use a separate query to determine all subscription ids per user and cache them.
  // That way we can look up subscriptions by id and benefit from the static cache
  // of the entity loader.
  $cache = &drupal_static(__FUNCTION__, array());
  $uid = is_object($account) ? $account->uid : $account;

  if (!isset($cache[$uid]) || $reset) {
    if (empty($type_name)) {
      $subscriptions = subs_load_multiple(FALSE, array('uid' => $uid));
      // Cache ids for further lookups.
      $cache[$uid] = array();
      foreach ($subscriptions as $sid => $subscription) {
        $cache[$uid][] = $sid;
      }
      return $subscriptions;
    }
    $cache[$uid] = db_select('subs', 's')
      ->fields('s', array('sid'))
      ->condition('uid', $uid)
      ->execute()
      ->fetchCol();
  }

  if (!empty($type_name)) {
    // Manually filter, as array_filter() can't take additional parameters.
    $subscriptions_filtered = array();

    foreach ($cache[$uid] as $sid) {
      if ($subscription = subs_load($sid)) {
        if ($subscription->type === $type_name) {
          $subscriptions_filtered[$sid] = $subscription;
        }
      }
    }

    return $subscriptions_filtered;
  }

  // Return an array containing subscriptions keyed by subscription id.
  return subs_load_multiple($cache[$uid]);
}

/**
 * Deletes a subscription.
 * Set it to cancelled before to trigger any relevant events.
 *
 * @param Subs
 *   The subscription object.
 */
function subs_delete(Subs $subscription) {
  subs_set_cancelled($subscription);
  $subscription->delete();
}

/**
 * Delete multiple subscriptions.
 *
 * @param array
 *   An array of subscription IDs.
 */
function subs_delete_multiple(array $sids) {
  // Bypass the traditional entity_get_controller() approach because we
  // need to cancel each subscription before its deleted.
  foreach ($sids as $sid) {
    if ($subscription = subs_load($sid)) {
      subs_delete($subscription);
    }
  }
}

/**
 * Create a new subscription object.
 *
 * @param $values
 *   An array of values to initialize the subscription with.
 * @return Subs
 *   The newly-created subscription object.
 */
function subs_create(array $values) {
  return new Subs($values);
}

/**
 * Saves a subscription.
 *
 * @param $subscription
 *   The subscription object.
 * @return boolean
 *   Whether the subscription was saved successfully.
 */
function subs_save(Subs $subscription) {
  return $subscription->save();
}

/**
 * Saves a subscription type.
 *
 * @param $type
 *   The subscription type object
 * @return boolean
 *   Whether the subscription type was saved successfully.
 */
function subs_type_save(SubsType $type) {
  return $type->save();
}

/**
 * Menu argument loader; Load a subscription type type by string.
 *
 * @param $type
 *   The machine-readable name of a subscription type to load.
 * @return
 *   A subscription type array or FALSE if $type does not exist.
 */
function subs_type_load($type) {
  return subs_get_types($type);
}

/**
 * Deletes a subscription type.
 *
 * @param $type
 *   The subscription type object
 */
function subs_type_delete(SubsType $type) {
  $type->delete();
}

/**
 * Returns an array of all subscription types, keyed by the type name.
 *
 * @param $type_name
 *   If set, the type with the given name is returned.
 * @return SubsType[]
 *   Depending whether $type isset, an array of subscription types or a
 *   single one.
 */
function subs_get_types($type_name = NULL) {
  $subs_types = &drupal_static(__FUNCTION__);

  if (empty($subs_types)) {
    $subs_types = entity_load_multiple_by_name('subs_type', FALSE);
  }

  if (isset($type_name)) {
    return isset($subs_types[$type_name]) ? $subs_types[$type_name] : FALSE;
  }
  else {
    return $subs_types;
  }
}

##############################
### API Functions - Search ###
##############################

/**
 * Find and return pending subscriptions.
 *
 * @param string
 *   If set, filter results by subscription $type.
 * @return Subs[]
 *   An array of subscription objects.
 *
 * @see subs_find()
 */
function subs_find_pending($type = NULL) {
  return subs_find($type, SUBS_STATUS_PENDING);
}

/**
 * Find and return active subscriptions.
 *
 * @param string
 *   If set, filter results by subscription $type.
 * @return Subs[]
 *   An array of subscription objects.
 *
 * @see subs_find()
 */
function subs_find_active($type = NULL) {
  return subs_find($type, SUBS_STATUS_ACTIVE);
}

/**
 * Find and return subscriptions in grace period.
 *
 * @param string
 *   If set, filter results by subscription $type.
 * @return Subs[]
 *   An array of subscription objects.
 *
 * @see subs_find()
 */
function subs_find_grace($type = NULL) {
  return subs_find($type, SUBS_STATUS_GRACE);
}

/**
 * Find and return expired subscriptions.
 *
 * @param string
 *   If set, filter results by subscription $type.
 * @return Subs[]
 *   An array of subscription objects.
 *
 * @see subs_find()
 */
function subs_find_expired($type = NULL) {
  return subs_find($type, SUBS_STATUS_EXPIRED);
}

/**
 * Find and return cancelled subscriptions.
 *
 * @param string
 *   If set, filter results by subscription $type.
 * @return Subs[]
 *   An array of subscription objects.
 *
 * @see subs_find()
 */
function subs_find_cancelled($type = NULL) {
  return subs_find($type, SUBS_STATUS_CANCELLED);
}

/**
 * Find and return subscriptions.
 * Orders by most recently changed first.
 *
 * @param string
 *   If set, filter results by subscription $type.
 * @param int
 *   If set, filter results by a subscription $status.
 * @param boolean
 *   If set, will execute the query and return results.  If not,
 *   return the query.
 */
function subs_find($type = NULL, $status = NULL, $execute = TRUE) {
  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'subs')
    ->propertyOrderBy('changed', 'DESC');

  if (isset($type)) {
    $query->entityCondition('bundle', $type);
  }

  if (isset($status)) {
    $query->propertyCondition('status', $status);
  }

  if ($execute) {
    $entities = $query->execute();
    return !empty($entities) ? subs_load_multiple(array_keys($entities['subs']))
        : array();
  }

  return $query;
}

##############################
### API Functions - Status ###
##############################

/**
 * Returns whether a subscription is in force (valid).
 * Active and grace period subscriptions are considered to be in force.
 *
 * @param $subscription
 *   The subscription object we want to check whether is still in force.
 * @return boolean
 *   Returns a boolean indicating whether the subscription is active.
 */
function subs_in_force(Subs $subscription) {
  return $subscription->status == SUBS_STATUS_ACTIVE || $subscription->status == SUBS_STATUS_GRACE;
}

/**
 * Changes a subscription to pending status.
 *
 * @param Subs
 *   The $subscription object we want to make pending.
 * @return boolean
 *   Whether the subscription was successfully changed to pending.
 */
function subs_set_pending(Subs $subscription) {
  $subscription->status = SUBS_STATUS_PENDING;

  // Try to save subscription.
  if (subs_save($subscription)) {
    // Invoke rules event.
    if (module_exists('rules')) {
      rules_invoke_event('subs_pending', $subscription);
    }

    return TRUE;
  }

  return FALSE;
}

/**
 * Changes a subscription to active status.
 *
 * @param Subs
 *   The $subscription object we want to make active.
 * @return boolean
 *   Whether the subscription was successfully changed to active.
 */
function subs_set_active(Subs $subscription) {
  $subscription->status = SUBS_STATUS_ACTIVE;

  // If the subscription's start date is 0, it is set to start once active.
  if ($subscription->date_start == 0) {
    // Set end start date.
    $subscription->date_start = strtotime('today');

    // Load subscription type.
    $subscription_type = subs_get_types($subscription->type);

    // Set end date if applicable.
    if ($subscription_type->length > 0) {
      $subscription->date_end = $subscription->date_start + $subscription_type->length;
    }
  }

  // Try to save subscription.
  if (subs_save($subscription)) {
    // Invoke rules event.
    if (module_exists('rules')) {
      rules_invoke_event('subs_activate', $subscription);
    }

    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Changes a subscription to grace period.
 *
 * @param Subs
 *   The $subscription object we want to change to grace period.
 * @param boolean
 *   If set, extends the subscription's end date by the grace period length.
 *   Extending the date is the default behavior.
 * @return boolean
 *   Whether the subscription was successfully changed to grace period.
 */
function subs_set_grace(Subs $subscription, $extend = TRUE) {
  $subscription->status = SUBS_STATUS_GRACE;
  // Extend the subscription's end date by the grace period.
  if ($extend) {
    $type = subs_get_types($subscription->type);
    $subscription->date_end = $subscription->date_end + $type->grace;
  }

  // Try to save subscription.
  if (subs_save($subscription)) {
    // Invoke rules event.
    if (module_exists('rules')) {
      rules_invoke_event('subs_grace', $subscription);
    }

    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Expires a given subscription.
 *
 * @param $subscription
 *   The subscription object we want to expire.
 * @return boolean
 *   Whether the subscription was successfully expired.
 */
function subs_set_expired(Subs $subscription) {
  $subscription->status = SUBS_STATUS_EXPIRED;

  // Try to save subscription.
  if (subs_save($subscription)) {
    // Invoke rules event.
    if (module_exists('rules')) {
      rules_invoke_event('subs_expire', $subscription);
    }

    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Cancels a subscription.
 *
 * @param Subs
 *   The $subscription object we want to cancel.
 * @return boolean
 *   Whether the subscription was successfully cancelled.
 */
function subs_set_cancelled(Subs $subscription) {
  $subscription->status = SUBS_STATUS_CANCELLED;

  // Try to save subscription.
  if (subs_save($subscription)) {
    // Invoke rules event.
    if (module_exists('rules')) {
      rules_invoke_event('subs_cancel', $subscription);
    }

    return TRUE;
  }

  return FALSE;
}

/**
 * Renews a subscription.
 *
 * @param Subs
 *   The $subscription object we want to renew.
 * @return boolean
 *  Whether the subscription was successfully renewed.
 */
function subs_renew(Subs $subscription) {
  // Load subscription's type.
  $subscription_type = subs_get_types($subscription->type);

  // If the subscription is active, just extend the end date.
  if ($subscription->status == SUBS_STATUS_ACTIVE) {
    $subscription->date_end += $subscription_type->length;
  }
  // If not, set a new end date from today and make it active.
  else {
    $subscription->date_end = strtotime('today') + $subscription_type->length;
    $subscription->status = SUBS_STATUS_ACTIVE;
  }

  // Invoke rules event.
  if (module_exists('rules')) {
    rules_invoke_event('subs_renew', $subscription);
  }

  return subs_save($subscription);
}

/**
 * Entity metadata callback to load subscriptions for the given user account.
 */
function subs_user_get_properties($account, array $options, $name) {
  // Remove the leading 'subs_' from the property name to get the type name.
  $subscriptions = subs_load_by_user($account, substr($name, 5));
  return $subscriptions ? $subscriptions : NULL;
}
