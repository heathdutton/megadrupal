<?php

/**
 * @file
 * Provide core xmlrpc testing functionality. Remote submission related functions are in include file.
 */

/**
 * Implements hook_menu().
 */
function xmlrpctester_menu() {
  $items = array();
  $items['admin/config/development/xmlrpctester'] = array(
    'title' => 'XML-RPC Testing',
    'description' => 'Developer tools for testing XML-RPC methods.',
    'page callback' => 'xmlrpctester_methods_list',
    'access arguments' => array('access xmlrpctester'),
    'file' => 'xmlrpctester.remote.inc',
  );

  $items['admin/config/development/xmlrpctester/list'] = array(
    'title' => 'Methods list',
    'description' => 'List available methods for this server.',
    'page callback' => 'xmlrpctester_methods_list',
    'access arguments' => array('access xmlrpctester'),
    'file' => 'xmlrpctester.remote.inc',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  $items['admin/config/development/xmlrpctester/settings'] = array(
    'title' => 'Settings',
    'description' => 'Configure XMLRPC tester settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xmlrpctester_settings'),
    'access arguments' => array('administer xmlrpctester'),
    'file' => 'xmlrpctester.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/config/development/xmlrpctester/add'] = array(
    'title' => 'Add a new method',
    'description' => 'Create a custom method locally',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xmlrpctester_custom_methods_form'),
    'access arguments' => array('access xmlrpctester'),
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/config/development/xmlrpctester/custom'] = array(
    'title' => 'Custom XML',
    'description' => 'Form for testing XML-RPC POST requests.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xmlrpctester_xmlsend_form'),
    'access arguments' => array('access xmlrpctester'),
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/config/development/xmlrpctester/%xmlrpctester_method/call'] = array(
    'title' => 'Call method',
    'description' => 'Call a stored custom method',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xmlrpctester_remote_call_form', 4),
    'access arguments' => array('access xmlrpctester'),
    'file' => 'xmlrpctester.remote.inc',
  );

  $items['admin/config/development/xmlrpctester/%xmlrpctester_method/edit'] = array(
    'title' => 'Edit method',
    'description' => 'Edit a custom method',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xmlrpctester_custom_methods_form', 4),
    'access arguments' => array('access xmlrpctester'),
  );

  $items['admin/config/development/xmlrpctester/%xmlrpctester_method/delete'] = array(
    'title' => 'Delete method',
    'description' => 'Delete a custom method',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xmlrpctester_custom_methods_delete', 4),
    'access arguments' => array('access xmlrpctester'),
    'file' => 'xmlrpctester.remote.inc',
  );

  return $items;
}


/**
 * Load a method.
 *
 * This can be a bit tricky, because we are not storing remote calls, therefore they don't have an id,
 * but we still call them via the /call callback. Of course we could implement separate callbacks for local and remote
 * calls, but that would be just too boring wouldn't it.
 *
 * @return
 *   Array of the method, in the usual format.
 */
function xmlrpctester_method_load($method_name) {
  // First see if this is a local method.
  $method = db_query('SELECT method, parameters, description FROM {xmlrpctester_methods} WHERE method = :method', array(':method' => $method_name))->fetch();
  // Not a local method, request a list of known remote methods based on system.listMethods.
  if (empty($method->method)) {
    $remote_methods = xmlrpctester_get_remote_methods(TRUE);
    foreach ($remote_methods as $method) {
      if ($method->method == $method_name) {
        return $method;
      }
    }
    // Not all servers implement system.listMethods, so we'll try to request a signature.
    // If this fails we'll get an error however.
    return xmlrpctester_get_remote_method($method_name);
  }
  elseif (isset($method->method)) {
    $method->parameters = unserialize($method->parameters);
    return $method;
  }
}

function xmlrpctester_custom_methods_form($form, $form_state, $method = NULL) {
  $form['method'] = array(
    '#title' => t('Method name'),
    '#type' => 'textfield',
    '#default_value' => '',
  );
  $types = array(
    'none' => t('None'),
    'int' => t('int'),
    'string' => t('string'),
    'struct' => t('struct'),
  );
  $form['return'] = array(
    '#title' => t('Return type'),
    '#type' => 'select',
    '#options' => $types,
    '#default_value' => 'none',
  );

  // TODO add nice AJAX here, for now its comma separated.
  $form['parameters'] = array(
    '#title' => t('Parameters'),
    '#type' => 'textfield',
    '#description' => t('Comma separated list of parameter types (possible values: string, int, struct).'),
    '#default_value' => '',
  );
  $form['description'] = array(
    '#title' => t('Description'),
    '#type' => 'textfield',
    '#default_value' => '',
  );
  $form['submit'] = array(
    '#value' => t('Save method'),
    '#type' => 'submit',
  );
  if (isset($method->method)) {
    $parameters = $method->parameters;
    $return = array_pop($parameters);
    $form['method']['#default_value'] = $method->method;
    $form['return']['#default_value'] = $return;
    $form['parameters']['#default_value'] = implode(', ', $parameters);
    $form['description']['#default_value'] = $method->description;
    $form['old_method'] = array(
      '#value' => $method->method,
      '#type' => 'value',
    );
    $return = array_shift($method->parameters);
  }
  return $form;
}

function xmlrpctester_custom_methods_form_submit(&$form, $form_state) {
  $data = new stdClass();
  $data->method = $form_state['values']['method'];

  $parameters = explode(',', $form_state['values']['parameters']);
  // Making sure that formatting is sort of all right. No validation, because we trust you, the holy developer.
  $parameters = array_map('trim', $parameters);
  $parameters = array_map('drupal_strtolower', $parameters);
  $data->parameters = serialize(array_merge(array($form_state['values']['return']), $parameters));
  $data->description = $form_state['values']['description'];

  // We delete the entry, because we allow method names to be overwritten.
  if (isset($form_state['values']['old_method'])) {
    $query = db_delete('xmlrpctester_methods')
      ->condition('method', $form_state['values']['_method'])
      ->execute();
  }
  else {
    drupal_write_record('xmlrpctester_methods', $data);
  }

  drupal_set_message(t('Method has been successfully saved.'));
  $form['#redirect'] = 'admin/config/development/xmlrpctester/' . $data->method . '/edit';
}

function xmlrpctester_custom_methods_delete($form, &$form_state, $method) {
  $form['_method'] = array('#type' => 'value', '#value' => $method->method);
  return confirm_form(
    $form,
    t('Are you sure you want to delete %method?', array('%method' => $method->method)),
    'admin/config/development/xmlrpctester/list',
    t('This action can not be undone. Thy methods shall be lost forever.'),
    t('Delete'), t('Cancel')
  );
}

function xmlrpctester_custom_methods_delete_submit($form, &$form_state) {
  $query = db_delete('xmlrpctester_methods')
    ->condition('method', $form_state['values']['_method'])
    ->execute();
    drupal_set_message(t('Method %method deleted.', array('%method' => $form_state['values']['_method'])));
  $form_state['redirect'] = 'admin/config/development/xmlrpctester/list';
}

/**
 * The form for the testing page
 */
function xmlrpctester_xmlsend_form($form) {
  $server = variable_get('xmlrpc_server_address', _xmlrpctester_default_server());

  $form['xml_field'] = array(
    '#type' => 'textarea',
    '#rows' => 10,
    '#required' => TRUE,
    '#description' => t('Test XML message. This will be sent using the POST method to the defined XMLRPC server: %server_url',
      array('%server_url' => $server)),
    '#default_value' => _xmlrpctester_default_message(),
  );

  $form['server_address'] = array(
    '#type' => 'value',
    '#value' => $server,
  );

  $form['test_submit'] = array(
    '#value' => t('Submit XML'),
    '#type' => 'submit'
  );

  $form['methods'] = array(
    '#type' => 'fieldset',
    '#title' => t('Available methods'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $form['methods']['list'] = array(
    '#markup' => xmlrpctester_methods_list(),
  );
  return $form;
}

function xmlrpctester_xmlsend_form_submit($form, $form_values) {
  $options = array(
    'headers' => array("Content-Type" => "text/xml"),
    'method' => 'POST',
    'data' => $form_values['values']['xml_field'],
  );
  $result = drupal_http_request($form_values['values']['server_address'], $options);

  if (isset($result->error)) {
    drupal_set_message(t('@error / error code: %code',
      array('@error' => $result->error, '%code' => $result->code)));
  }

  require_once './includes/xmlrpc.inc';
  require_once './includes/xmlrpcs.inc';
  /* from xmlrpc.inc _xmlrpc() */
  drupal_set_message(t('HTTP return code: %code', array('%code' => $result->code)));

  $message = xmlrpc_message($result->data);
  // Now parse what we've got back
  if (!xmlrpc_message_parse($message)) {
    // XML error
    drupal_set_message(t('Parse error. Not well formed.'));
    return;
  }
  // Is the message a fault?
  if ($message->messagetype == 'fault') {
    drupal_set_message(t('This message is a fault. Error code %code, %fault_string.',
      array('%code' => $message->fault_code, '%fault_string' => $message->fault_string)));
    return;
  }

  if (is_array($message->params[0])) {
    drupal_set_message(t('Content available and loaded'));
  }
  else {
    drupal_set_message($message->params[0]);
  }
}

/**
 * List list the methods available.
 */
function xmlrpctester_methods_list() {
  $remote_methods = xmlrpctester_get_remote_methods(TRUE);
  $header = array(
    t('Name'),
    t('Signature'),
    t('Description'),
  );
  $rows = array();
  foreach ($remote_methods as $method) {
    $rows[] = _xmlrpctester_prepare_row($method);
  }

  if (!count($rows)) {
    $rows[][] = array(
      'data' => t('No remote methods available, check !watchdog logs for errors.', array('!watchdog' => l(t('watchdog'), 'admin/reports/dblog'))),
      'colspan' => count($header),
    );
  }

  $output = theme('table', array('header' => $header, 'rows' => $rows, 'caption' => t('Remote methods')));

  $rows = array();
  $custom_methods = xmlrpctester_get_custom_methods(TRUE);
  $header[] = array('data' => t('Operation'), 'colspan' => 2);

  foreach ($custom_methods as $method) {
    $row = _xmlrpctester_prepare_row($method);
    $row[] = l(t('Edit'), 'admin/config/development/xmlrpctester/' . $method->method . '/edit');
    $row[] = l(t('Delete'), 'admin/config/development/xmlrpctester/' . $method->method . '/delete');
    $rows[] = $row;
  }

  if (!count($rows)) {
    $rows[][] = array('data' => t('No custom methods available, check !watchdog logs for errors.',
      array('!watchdog' => l(t('watchdog'), 'admin/reports/dblog'))), 'colspan' => count($header));
  }
  $output .= theme('table', array('header' => $header, 'rows' => $rows, 'caption' => t('Custom methods')));

  return $output;
}

/**
 * Format a table row for the method list callbacks.
 */
function _xmlrpctester_prepare_row($method) {
  $row = array();
  $row[] = l($method->method, 'admin/config/development/xmlrpctester/' . $method->method . '/call');

  if (is_array($method->parameters)) { // For example multicall has no return type.
    $return_type = array_shift($method->parameters);
    $arg_types = empty($method->parameters)? t('N/A') : implode(', ', $method->parameters);
  }
  else {
    $return_type = t('N/A');
  }
  if (isset($return_type)) {
    $signature = t('Return: %return_type.', array('%return_type' => $return_type));
  }
  if (isset($arg_types)) {
    $signature .= ' ';
    $signature .= t('Arguments: %arg_types.', array('%arg_types' => $arg_types));
  }
  $row[] = $signature;
  $row[] = $method->description ? $method->description : t('N/A');
  return $row;
}

/**
 * Methods are objects with three fields:
 * - method: method name,
 * - parameters: array of return + parameter types,
 * - description: the description defined for the method.
 */

/**
 * Fetch remote method details.
 * @param $name
 *   Name of the remote method, will be called.
 *
 * @return
 *   Standard method array (name, return + parameter types, description).
 */
function xmlrpctester_get_remote_method($name) {
  $server = _xmlrpctester_server();
  $method = new StdClass;
  $method->method = $name;
  $multiple_signatures = xmlrpc($server, array('system.methodSignature' => array($name)));
  $method->parameters = $multiple_signatures[0];
  $method->description = xmlrpc($server, array('system.methodHelp' => array($name)));
  return $method;
}

/**
 * Poll a remote server for available methods, then cache the results.
 */
function xmlrpctester_get_remote_methods($reset = FALSE) {
  $server = _xmlrpctester_server();
  static $methods = array();
  if (!isset($methods) || $reset) { // Not empty, because a server might not have any.
    $result = xmlrpc($server, array('system.listMethods' => array()));
    if ($error = xmlrpc_error()) {
      watchdog('xmlrpctester', 'Error when calling system.listMethods at server %server.
        Error code: %code, message: %message.',
        array('%server' => $server, '%code' => $error->code, '%message' => $error->message), WATCHDOG_ERROR);
      // TODO some more error handling if error code is -32700 perhaps?
    }
    else {
      foreach ($result as $key => $method) {
        $methods[] = xmlrpctester_get_remote_method($method);
      }
    }
  }
  return $methods;
}

function xmlrpctester_get_custom_methods($reset = FALSE) {
  $result = db_query('SELECT method, parameters, description FROM {xmlrpctester_methods}')->fetchAll();
  foreach ($result as &$method) {
    $method->parameters = unserialize($method->parameters);
  }
  return $result;
}

/**
 * Implements hook_xmlrpc().
 */
function xmlrpctester_xmlrpc() {
  module_load_include('inc', 'xmlrpctester', 'xmlrpctester.testmethods');
  $methods[] = array(
    'xmlrpctester.struct.string',
    'xmlrpctester_struct_string',
    array('struct', 'string'),
    t('Test structure return, string argument.'),
  );
  $methods[] = array(
    'xmlrpctester.struct.struct',
    'xmlrpctester_struct_struct',
    array('struct', 'struct'),
    t('Test structure return and input. Returns the arguments.'),
  );
  $methods[] = array(
    'xmlrpctester.string.int',
    'xmlrpctester_string_int',
    array('string', 'int'),
    t('Return the type of the argument as a string.'),
  );
  $methods[] = array(
    'xmlrpctester.int.boolean',
    'xmlrpctester_int_boolean',
    array('int', 'boolean'),
    t('Return the type of the argument as a string.'),
  );
  return $methods;
}

function _xmlrpctester_server() {
  $default = _xmlrpctester_default_server();
  return variable_get('xmlrpc_server_address', $default);
}

/**
 * The default server url is what the module sets by default
 */
function _xmlrpctester_default_server() {
  $index_path = $_SERVER['PHP_SELF'];
  $subdir = str_replace('index.php', '', $index_path);
  $url = 'http://' . $_SERVER['HTTP_HOST'] . $subdir;

  $xmlrpc_server = module_invoke('xmlrpc_server', 'server_info');
  if (isset($xmlrpc_server['#path'])) { // Server implemented by services module?
    $server_path = 'services/' . $xmlrpc_server['#path'];
  }
  else {
    $server_path = $url . 'xmlrpc.php';
  }
  return $server_path;
}

function _xmlrpctester_default_message() {
  $xml = <<<EOD
<?xml version="1.0"?>
<methodCall>
<methodName>node.load</methodName>
<params>
<param><value><int>1</int></value></param>
<param><value><array><data>
</data></array></value></param>
</params></methodCall>
EOD;
  return $xml;
}

/**
 * Default methods that are not listed in callback, but should be standard.
 */
function _xmlrpc_default_methods() {
  return array(
    'system.describeMethods' => t('Describe methods'),
    'system.listMethods' => t('List all methods.'),
  );
}
