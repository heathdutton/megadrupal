<?php

/**
 * @file
 * Implements hook_menu().
 */
function simplereference_menu() {
  $items['simplereference/autocomplete'] = array(
    'title' => 'Autocomplete simplereference',
    'page callback' => 'simplereference_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

function simplereference_field_info() {
  return array(
    'simplereference' => array(
      'label' => t('Simplereference'),
      'description' => t('This field stores entity_id, entity_bundle and entity_type in the database.'),
      'settings' => array('max_length' => 255),
      'instance_settings' => array('text_processing' => 0),
      'default_widget' => 'simplereference_autocomplete',
      'default_formatter' => 'simplereference_default',
    ),
  );
}


/**
 * Implements hook_field_settings_form().
 */
function simplereference_field_settings_form($field, $instance, $has_data) {

}

/**
 * Implements hook_field_instance_settings_form().
 */
function simplereference_field_instance_settings_form($field, $instance) {
  $settings = $instance['settings'];
  $entities = entity_get_info();
  if (isset($entities['node'])) {
    $form['node_bundles'] = array(
      '#type' => 'select',
      '#multiple' => TRUE,
      '#title' => t('Node bundles'),
      '#default_value' => (isset($settings['node_bundles']) ? $settings['node_bundles'] : ''),
      '#description' => t('Select nodes bundles that can be referenced'),
      '#options' => drupal_map_assoc(array_keys($entities['node']['bundles'])),
      '#element_validate' => array('_simplereference_validate_array'),
    );
  }
  if (isset($entities['taxonomy_term'])) {
    $form['taxonomy_term_bundles'] = array(
      '#type' => 'select',
      '#multiple' => TRUE,
      '#title' => t('Taxonomy terms bundles'),
      '#default_value' => (isset($settings['taxonomy_term_bundles']) ? $settings['taxonomy_term_bundles'] : ''),
      '#description' => t('Select taxonomy terms bundles that can be referenced'),
      '#options' => drupal_map_assoc(array_keys($entities['taxonomy_term']['bundles'])),
      // '#element_validate' => array('_simplereference_validate_array'),
    );
  }
  if (isset($entities['user'])) {
    $form['user_bundles'] = array(
      '#type' => 'select',
      '#multiple' => TRUE,
      '#title' => t('User bundles'),
      '#default_value' => (isset($settings['user_bundles']) ? $settings['user_bundles'] : 'user'),
      '#description' => t('Select user bundles that can be referenced'),
      '#options' => drupal_map_assoc(array('user')),
      // '#element_validate' => array('_simplereference_validate_array'),
    );
  }
  return $form;
}

/**
 * Custom validation function
 * @param  array $element
 * @param  array $form_state
 * @return array
 */
function _simplereference_validate_array($element, &$form_state) {
  $value = $element['#value'];
  if (empty($value)) {
    form_error($element, t('You must select a value or more for %value field', array('%value' => $element['#title'])));
  }
}

/**
 * Implements hook_field_validate().
 *
 * Possible error codes:
 * - 'text_value_max_length': The value exceeds the maximum length.
 * - 'text_summary_max_length': The summary exceeds the maximum length.
 */
function simplereference_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {

}

/**
 * Implements hook_field_load().
 *
 * Where possible, generate the sanitized version of each field early so that
 * it is cached in the field cache. This avoids looking up from the filter cache
 * separately.
 *
 * @see text_field_formatter_view()
 */
function simplereference_field_load($entity_type, $entities, $field, $instances, $langcode, &$items) {

}

/**
 * Implements hook_field_is_empty().
 */
function simplereference_field_is_empty($item, $field) {
  if (!isset($item['value']) || $item['value'] === '') {
    return TRUE;
  }
  return FALSE;
}

// formatter
/**
 * Implements hook_field_formatter_info().
 */
function simplereference_field_formatter_info() {
  return array(
    'simplereference_default' => array(
      'label' => t('Default'),
      'field types' => array('simplereference'),
    ),
  );
}

/**
 * Implements hook_field_formatter_settings_form().
 */
function simplereference_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $element = array();

  return $element;
}


/**
 * Implements hook_field_formatter_view().
 */
function simplereference_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  foreach ($items as $delta => $item) {
    $object = _simplereference_get_title_by_entity_id($item);
    $link = l($object->title, $object->path . '/' . $object->entity_id);
    $element[$delta] = array('#markup' => $link);
  }
  return $element;
}


// widget

/**
 * Implements hook_field_widget_info().
 */
function simplereference_field_widget_info() {
  return array(
    'simplereference_autocomplete' => array(
      'label' => t('Simplereference'),
      'field types' => array('simplereference'),
      'settings' => array(
        'size' => 60,
        'autocomplete_path' => 'simplereference/autocomplete',
      ),
      'multiple values' => FIELD_BEHAVIOR_DEFAULT,
    ),
  );
}

/**
 * Implements hook_field_widget_settings_form().
 */
function simplereference_field_widget_settings_form($field, $instance) {
  $form = array();
  $widget = $instance['widget'];
  $settings = $widget['settings'];
  return $form;
}


/**
 * Implements hook_field_widget_form().
 */
function simplereference_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  if (isset($items[$delta])) {
    $item = _simplereference_get_title_by_entity_id($items[$delta]);
  }
  $element += array(
    '#type' => 'textfield',
    '#default_value' => isset($item->title) ? $item->title : NULL,
    '#description' => 'Select entities',
    '#autocomplete_path' => $instance['widget']['settings']['autocomplete_path'] . '/' . $instance['entity_type'] . '/' . $instance['bundle'] . '/' . $field['field_name'],
    '#element_validate' =>  array('_simplereference_field_widget_validate'),
  );
  return array('value' => $element);

}

/**
 * Custom validation function
 * @param  array $element
 * @param  array $form_state
 * @return array
 */
function _simplereference_field_widget_validate($element, &$form_state) {
  $value = trim($element['#value'], '"');
  if ($value != '' && !is_numeric($value)) {
    $result = _simplereference_sql_select_stored_value($value);
    $row = $result->fetchCol();
      if (count($row) == 0) {
         form_error($element, t('The string %value is not part of reference list. Please enter a value stored in yor database', array('%value' => $value)));
      }
    }
}

/**
 * Implements hook_field_presave().
 */
function simplereference_field_presave($entity_type, $entity, $field, $instance, $langcode, &$items) {
  foreach ($items as $delta => $value) {
    _simplereference_get_entity_by_name($items[$delta], $delta, $field, $entity);
  }

}

/**
 * Retrieve stored data structure of a term
 * @param  array  $item
 * @param  integer $delta
 * @param  array  $field
 * @param  array  $entity
 * @return array
 *   data identifiers of a term
 */
function _simplereference_get_entity_by_name(&$item, $delta = 0, $field, $entity) {
  $title = trim($item['value'], '"');
  $result = _simplereference_sql_select_stored_value($title);
  if ($result) {
    while ($row = $result->fetchAssoc()) {
      $item['destination_entity_type'] = $row['entity_type'];
      $item['destination_entity_bundle'] = $row['entity_bundle'];
      $item['destination_entity_id'] = $row['entity_id'];
    }
  }
}


/**
 * SQL query which check if a term is stored in database
 * Join data from node, realname an taxonomy_term_data tables
 * @param  string $title
 * @return array
 */
function _simplereference_sql_select_stored_value($title) {
  $sql = "SELECT DISTINCT
  n.title as title, 'node' AS entity_type, n.type AS entity_bundle, n.nid AS entity_id
  FROM
  {node} n
  WHERE n.title LIKE '%' :string '%'
  UNION
  SELECT DISTINCT
  r.realname as title, 'user' AS entity_type, 'user' AS entity_bundle, r.uid AS entity_id
  FROM
  {realname} r
  WHERE r.realname LIKE '%' :string '%'
  UNION
  SELECT DISTINCT
  t.name as title, 'taxonomy_term' AS entity_type, v.machine_name AS entity_bundle, t.tid AS entity_id
  FROM
  {taxonomy_term_data} t
  INNER JOIN
  {taxonomy_vocabulary} v
  ON v.vid = t.vid
  WHERE t.name LIKE '%' :string '%'";

  $result = db_query($sql, array(':string' => $title));

  return $result;
}


/**
 * Provides terms for autocomplete search
 * @param  string $entity_type
 * @param  string $bundle
 * @param  string $field_name
 * @param  string $tags_typed
 * @return json data
 */
function simplereference_autocomplete($entity_type, $bundle, $field_name, $tags_typed = '') {
  // If the request has a '/' in the search text, then the menu system will have
  // split it into multiple arguments, recover the intended $tags_typed.
  $args = func_get_args();
  // Shift off the $field_name argument.
  $entity_type = array_shift($args);
  $bundle_name = array_shift($args);
  $field_name = array_shift($args);
  $tags_typed = implode('/', $args);

  $field_info_instance = field_info_instance($entity_type, $field_name, $bundle_name);
  $settings = $field_info_instance['settings'];

  // The user enters a comma-separated list of tags. We only autocomplete the last tag.
  $tags_typed = drupal_explode_tags($tags_typed);
  $tag_last = drupal_strtolower(array_pop($tags_typed));

  $matches = array();
  if ($tag_last != '') {

    $query1 = db_select('node', 'n');
    // Do not select already entered terms.
    if (!empty($tags_typed)) {
      $query1->condition('n.title', $tags_typed, 'NOT IN');
    }
    // Select rows that match by term name.
    $tags_return1 = $query1
      ->fields('n', array('nid', 'title'))
      ->condition('n.title', '%' . db_like($tag_last) . '%', 'LIKE')
      ->condition('n.type', array_keys($field_info_instance['settings']['node_bundles']), 'IN')
      ->range(0, 10)
      ->execute()
      ->fetchAllKeyed();

    $tags_return = $tags_return1;

    if (!empty($settings['user_bundles'])) {
      $query2 = db_select('realname', 'r');
      // Do not select already entered terms.
      if (!empty($tags_typed)) {
        $query2->condition('r.realname', $tags_typed, 'NOT IN');
      }
      // Select rows that match by term name.
      $tags_return2 = $query2
        ->fields('r', array('uid', 'realname'))
        ->condition('r.realname', '%' . db_like($tag_last) . '%', 'LIKE')
        ->range(0, 10)
        ->execute()
        ->fetchAllKeyed();
      $tags_return = $tags_return +  $tags_return2;
    }

    // Do not select already entered terms.
    if (!empty($settings['taxonomy_term_bundles'])) {
      $query3 = db_select('taxonomy_term_data', 't');
    // Do not select already entered terms.
      if (!empty($tags_typed)) {
        $query3->condition('t.name', $tags_typed, 'NOT IN');
      }
      // Select rows that match by term name.
      $tags_return3 = $query3
        ->fields('t', array('tid', 'name'))
        ->condition('t.name', '%' . db_like($tag_last) . '%', 'LIKE')
        ->condition('t.vid', _simplereference_get_vocabulary_array_vids($settings['taxonomy_term_bundles']), 'IN')
        ->range(0, 10)
        ->execute()
        ->fetchAllKeyed();
      $tags_return = $tags_return + $tags_return3;
    }

    $prefix = count($tags_typed) ? drupal_implode_tags($tags_typed) . ', ' : '';

    $term_matches = array();

    foreach ($tags_return as $nid => $title) {
      $n = $title;
      // Term names containing commas or quotes must be wrapped in quotes.
      if (strpos($title, ',') !== FALSE || strpos($title, '"') !== FALSE) {
        $n = '"' . str_replace('"', '""', $title) . '"';
      }
      $term_matches[$prefix . $n] = check_plain($title);
    }
  }
  drupal_json_output($term_matches);
}


/**
 *
 * @see drupal_explode_tags()
 */
function simplereference_implode_tags($items) {
  $typed_tags = array();
  foreach ($items as $item) {
      $object = _simplereference_get_title_by_entity_id($item);
      // Make sure we have a completed loaded taxonomy term.
      if (isset($object->title)) {
        // Commas and quotes in tag names are special cases, so encode 'em.
        if (strpos($object->title, ',') !== FALSE || strpos($object->title, '"') !== FALSE) {
          $typed_tags[] = '"' . str_replace('"', '""', $object->title) . '"';
        }
        else {
          $typed_tags[] = $object->title;
        }
      }
  }
  return implode(', ', $typed_tags);
}

/**
 * Provides title given entity id
 * @param  array $item
 * @return object
 *   title and path term
 */
function _simplereference_get_title_by_entity_id($item) {
  $object = new stdClass();
  $entity_type = $item['destination_entity_type'];
  $object->entity_id = $item['destination_entity_id'];
  $entity_array = entity_load($item['destination_entity_type'], array($item['destination_entity_id']));
  $entity = reset($entity_array);
  switch ($entity_type) {
    case 'node':
      $object->title = $entity->title;
      $object->path = $entity_type;
      break;
    case 'user':
      $object->title = $entity->realname;
      $object->path = $entity_type;
      break;
    case 'taxonomy_term':
      $object->title = $entity->name;
      $object->path = str_replace('_', '/', $entity_type);
      break;
  }
  return $object;
}

/**
 * Provides an array of vocabularies vids
 * @param  array $names
 * @return array
 *  vids
 */
function _simplereference_get_vocabulary_array_vids($names) {
  foreach ($names as $name) {
    $taxonomy = taxonomy_vocabulary_machine_name_load($name);
    $taxonomy_names_array[] = $taxonomy->vid;
  }
  return $taxonomy_names_array;
}
