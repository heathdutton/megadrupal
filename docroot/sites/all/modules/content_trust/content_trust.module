<?php

/**
 * Implements hook_menu().
 */
function content_trust_menu() {
  $items = array();

  $items['admin/config/content/content_trust'] = array(
    'title' => 'Content trust',
    'description' => 'Configuration for Content trust module',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('content_trust_admin_form'),
    'access arguments' => array('configure content trust'),
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function content_trust_permission() {
  return array(
    'configure content trust' => array(
      'title' => 'Configure content trust',
    ),
    'moderate via content trust' => array(
      'title' => 'Moderate via content trust',
    ),
  );
}

/**
 * Implements hook_views_api().
 */
function content_trust_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'content_trust') . '/includes/views',
  );
}

/**
 * Implements hook_comment_presave().
 */
function content_trust_comment_presave($comment) {

  // Skip if permissions allow auto-approval
  if (user_access('skip comment approval') || user_access('administer comments')) {
    return;
  }

  // Skip if content type is not moderated
  $node = node_load($comment->nid);
  $moderated_types = array_filter(variable_get('content_trust_moderate_comment_types', array()));
  if (!in_array($node->type, $moderated_types)) {
    return;
  }

  // If the threshold is met publish the comment
  if (_content_trust_useristrusted($comment->uid, array('cid' => $comment->cid))) {
    $comment->status = COMMENT_PUBLISHED;
    if (module_exists('mollom')) {
      if ($comment->mollom['moderate'] == 1) {
        $comment->status = 0;
      }
    }
  }
}

/**
 * Implements hook_node_presave().
 */
function content_trust_node_presave($node) {
  // Skip if content type is not moderated
  $moderated_types = array_filter(variable_get('content_trust_moderate_content_types', array()));
  if (!in_array($node->type, $moderated_types)) {
    return;
  }

  // Skip if permissions allow auto-approval
  if (user_access('administer nodes')) {
    return;
  }

  // If the threshold is not met, do not publish the node
  if (!_content_trust_useristrusted($node->uid, array('nid' => $node->nid))) {
    $node->status = 0;
    drupal_set_message('Your post has been queued for moderation by site administrators and will be published after approval.', 'status');
  }
}

/**
 * Return whether a user is to be trusted or not, based on their comments/posts
 * and the defined threshold.
 *
 * @var $uid int The user's UID to test trust score on
 * @var $exlude array An associative array of nodes to exclude when calculating trust score
 */

function _content_trust_useristrusted ($uid, $exclude = array()) {

  $query = db_select('comment', 'c')
    ->fields('c', array('cid'))
    ->condition('uid', $uid)
    ->condition('status', COMMENT_PUBLISHED);
  if (isset($exclude['cid'])) {
    $query->condition('cid', $exclude['cid'], '<>');
  }
  $comments = $query->countQuery()->execute()->fetchField();

  $query = db_select('node', 'n')
    ->fields('n', array('nid'))
    ->condition('uid', $uid)
    ->condition('status', 1);
  if (isset($exclude['nid'])) {
    $query->condition('nid', $exclude['nid'], '<>');
  }
  $nodes = $query->countQuery()->execute()->fetchField();

  $trustscore = $comments + $nodes;
  return $trustscore >= variable_get('content_trust_threshold', 3);
}

/**
 * Implements hook_action_info().
 */
function content_trust_action_info() {
  return array (
    'content_trust_delete_content_and_user_action' => array(
      'label' => t('Delete user and all content'),
      'type' => 'entity',
      'configurable' => FALSE,
      'aggregate' => TRUE,
    ),
  );
}


/**
 * Page callback: content trusted user settings
 */
function content_trust_admin_form() {
  $form = array();

  $form['content_trust_threshold'] = array(
    '#type' => 'select',
    '#title' => t('Threshold'),
    '#description' => t('After a user has this much published content, all subsequent content will bypass the trust queue.'),
    '#options' => drupal_map_assoc(array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)),
    '#default_value' => variable_get('content_trust_threshold', 1),
  );

  $form['content_trust_moderate_content_types'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Content types to moderate'),
    '#description' => t('Only the checked content types will be moderated.'),
    '#options' => node_type_get_names(),
    '#default_value' => variable_get('content_trust_moderate_content_types', array()),
  );

  $form['content_trust_moderate_comment_types'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Comment types to moderate'),
    '#description' => t('Only comments on the checked content types will be moderated.'),
    '#options' => node_type_get_names(),
    '#default_value' => variable_get('content_trust_moderate_comment_types', array()),
  );

  return system_settings_form($form);
}


/**
 * Implements hook_form_alter().
 *
 * Display a better confirmation page which shows the full list of entities affected by this action.
 */
function content_trust_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'views_form_content_trust_queue_nodes_page'
      || $form_id == 'views_form_content_trust_queue_comments_page') {

    // Check we're dealing with the content_trust action
    if (!isset($form_state['operation']->operationId)
        || $form_state['operation']->operationId != 'action::content_trust_delete_content_and_user_action') {
      return;
    }

    $type = $form_state['operation']->entityType;
    $ids = $form_state['selection'];
    $uids = _content_trust_get_author_uids_by_content_ids($type, $ids);
    $cursed = _content_trust_get_all_content_by_uids($uids, TRUE);

    $form['description'] = _content_trust_render_cursed_content($cursed);
  }
}


/**
 * Action: Deletes all content by the author of selected content and deletes the user account
 */
function content_trust_delete_content_and_user_action($entities, $context = array()) {
  $type = $context['entity_type'];
  $ids = array_keys($entities);

  $uids = _content_trust_get_author_uids_by_content_ids($type, $ids);
  $cursed = _content_trust_get_all_content_by_uids($uids);

  comment_delete_multiple(array_keys($cursed['comment']));
  node_delete_multiple(array_keys($cursed['node']));
  user_delete_multiple(array_keys($cursed['user']));

  $msg = t('Deleted @users users, @comments comments and @nodes nodes.', array(
    '@users' => count($cursed['user']),
    '@comments' => count($cursed['comment']),
    '@nodes' => count($cursed['node']),
    ));

  drupal_set_message($msg);
}


/**
 * Get all the content by a user
 *
 * @var $expanded Load all entities as well as returning their ID
 */
function _content_trust_get_all_content_by_uids($uids, $expanded = FALSE) {
  foreach ((array) $uids as $uid) {
    // Find the users
    $account = user_load($uid);
    $cursed['user'][$uid] = $account;

    // Find the nodes and comments
    foreach (array('comment', 'node') as $type) {
      $query = new EntityFieldQuery;
      $query->entityCondition('entity_type', $type);
      $query->propertyCondition('uid', $uid);
      $result = $query->execute();

      $cursed[$type] = isset($result[$type]) ? $result[$type] : array();

      if ($expanded === TRUE) {
        $cursed[$type] = entity_load($type, array_keys($cursed[$type]));
      }
    }
  }

  return $cursed;
}


/**
 * Take a bunch of content and return the authors
 */
function _content_trust_get_author_uids_by_content_ids($type, $ids) {
  $id_field_map = array(
    'node' => 'nid',
    'comment' => 'cid',
  );

  $query = new EntityFieldQuery;
  $query->entityCondition('entity_type', $type);
  $query->propertyCondition($id_field_map[$type], $ids);
  $result = $query->execute();

  $entities = entity_load($type, array_keys($result[$type]));
  $uids = array();
  foreach ($entities as $entity) {
    $uids[$entity->uid] = $entity->uid;
  }

  return $uids;
}


/**
 * 
 */
function _content_trust_render_cursed_content($cursed) {
  // Accounts
  if (!empty($cursed['user'])) {
    $rows = array();

    foreach ($cursed['user'] as $account) {
      $rows[] = $account->name;
    }

    $warning = '<p class="warning">'
      . t('The following user accounts will be deleted:')
      . '</p>';

    $message['user'] = array(
      '#prefix' => $warning,
      '#theme' => 'item_list',
      '#items' => $rows,
    );
  }

  // Content headers
  $headers = array(
    t('Created'),
    t('Type'),
    t('ID'),
    t('Author'),
    t('Title'),
  );

  // Comments
  if (!empty($cursed['comment'])) {
    $rows = array();

    foreach ($cursed['comment'] as $comment) {
      $rows[] = array(
        format_date($comment->created),
        $comment->node_type,
        $comment->cid,
        $comment->name,
        $comment->subject
      );
    }

    $warning = '<p class="warning">'
      . t('The following comments will be deleted:')
      . '</p>';

    $message['comment'] = array(
      '#prefix' => $warning,
      '#theme' => 'table',
      '#header' => $headers,
      '#rows' => $rows,
    );
  }

  // Nodes
  if (!empty($cursed['node'])) {
    $rows = array();

    foreach ($cursed['node'] as $node) {
      $rows[] = array(
        format_date($node->created),
        $node->type,
        $node->nid,
        $node->name,
        $node->title
      );
    }

    $warning = '<p class="warning">'
      . t('The following nodes will be deleted:')
      . '</p>';

    $message['node'] = array(
      '#prefix' => $warning,
      '#theme' => 'table',
      '#header' => $headers,
      '#rows' => $rows,
    );
  }

  return $message;
}
