<?php
/**
 * @file
 * Integration of the Australian Post Postage Assessment Calculator API.
 */

/**
 * Australia Post PAC/PCS API URL.
 */
define('UC_AUSPOST_PAC_API_URL', 'https://auspost.com.au/api/postage/');

/**
 * Markup types of fixed or percentage markup on the returned price.
 */
define('UC_AUSPOST_PAC_MARKUP_NONE', 0);
define('UC_AUSPOST_PAC_MARKUP_PERCENT', 1);
define('UC_AUSPOST_PAC_MARKUP_FIXED', 2);

/**
 * Internal represenation of "do not cache".
 */
define ('UC_AUSPOST_PAC_CACHE_NONE', -3);

/**
 * Implements hook_menu().
 */
function uc_auspost_pac_menu() {
  $items = array();

  $items['admin/store/settings/quotes/auspost-pac'] = array(
    'type' => MENU_LOCAL_TASK,
    'title' => 'Aus Post',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('uc_auspost_pac_config_form'),
    'access arguments' => array('uc auspost pac administer settings'),
    'file' => 'uc_auspost_pac.admin.inc',
    'weight' => 10,
  );

  // These are written in without wildcards in the URL so they can show up
  // as tabs under Aus Post in the Shipping quotes section.
  $methods = uc_auspost_pac_uc_shipping_method();
  foreach ($methods as $method_id => $method_info) {
    $items['admin/store/settings/quotes/auspost-pac/edit/' . $method_id] = array(
      'type' => MENU_LOCAL_TASK,
      'title' => $method_info['title'],
      'page callback' => 'drupal_get_form',
      'page arguments' => array('uc_auspost_pac_config_method_form', 6),
      'access arguments' => array('uc auspost pac administer settings'),
      'file' => 'uc_auspost_pac.admin.inc',
    );
  }

  // Wildcarded method of editing packing method settings.
  $items['admin/store/settings/quotes/auspost-pac/packing/%/%'] = array(
    'type' => MENU_CALLBACK | MENU_VISIBLE_IN_BREADCRUMB,
    'title' => 'Packing Method Settings',
    'page callback' => 'uc_auspost_pac_settings_wrapper',
    'page arguments' => array(6, 7),
    'access arguments' => array('uc auspost pac administer settings'),
    'file' => 'uc_auspost_pac.packing.inc',
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function uc_auspost_pac_permission() {
  $perms = array();

  $perms['uc auspost pac administer settings'] = array(
    'title' => t('Administer module settings'),
  );

  return $perms;
}

/**
 * Implements hook_hook_info().
 */
function uc_auspost_pac_hook_info() {
  $hook_info = array();

  $hook_info['packing_info'] = array(
    'group' => 'packing',
  );

  $hook_info['packing_info_alter'] = array(
    'group' => 'packing',
  );

  return $hook_info;
}

/**
 * Implements hook_flush_caches().
 */
function uc_auspost_pac_flush_caches() {
  $cache_tables = array('cache_uc_auspost_pac');

  // Add glacial cache table to the flush if manually flushed. This does not
  // fit in with the admin menu or drush flushing of caches.
  if (variable_get('uc_auspost_pac_flush_glacial_cache', FALSE)) {
    $cache_tables[] = 'cache_uc_auspost_pac_glacial';

    // Remove the variable to prevent it from constantely being cleared.
    variable_del('uc_auspost_pac_flush_glacial_cache');
  }

  return $cache_tables;
}

/**
 * Implements hook_uc_store_status().
 *
 * Let the administrator know that the AusPost API Key has not been entered.
 */
function uc_auspost_pac_uc_store_status() {
  $messages = array();

  $api_key_is_set = variable_get('uc_auspost_pac_var_api_key', FALSE) !== FALSE;

  if ($api_key_is_set) {
    $messages[] = array(
      'status' => 'ok',
      'title' => t('Australia Post PAC API'),
      'desc' => t('Information needed to access Australia Post PAC API has been entered.'),
    );
  }
  else {
    $messages[] = array(
      'status' => 'error',
      'title' => t('Australia Post PAC API'),
      'desc' => t('An API Key is needed to access Australia Post PAC API. Please enter it <a href="@url">here</a>.', array(
        '@url' => url('admin/store/settings/quotes/auspost-pac'),
      )),
    );
  }

  return $messages;
}

/**
 * Implements hook_uc_shipping_type().
 */
function uc_auspost_pac_uc_shipping_type() {
  $weight = variable_get('uc_quote_type_weight', array('auspost_letter' => -1, 'small_package' => 0));

  $types = array();

  $types['auspost_letter'] = array(
    'id' => 'auspost_letter',
    'title' => t('AusPost Envelope'),
    'weight' => isset($weight['auspost_letter']) ? $weight['auspost_letter'] : -1,
  );

  $types['small_package'] = array(
    'id' => 'small_package',
     'title' => t('Small package'),
    'weight' => isset($weight['small_package']) ? $weight['small_package'] : 0,
  );

  return $types;
}

/**
 * Implements hook_uc_shipping_method().
 */
function uc_auspost_pac_uc_shipping_method() {

  $methods = array();

  $methods['auspost_domestic_letter'] = array(
    'id' => 'auspost_domestic_letter',
    'module' => 'uc_auspost_pac',
    'title' => t('Aus Post Domestic Letter'),
    'description' => t('For items no larger than 260mm(l) x 360mm(w) x 20mm(t) x 500g.'),
    'operations' => array(
      'settings' => array(
        'title' => t('settings'),
        'href' => 'admin/store/settings/quotes/auspost-pac/edit/auspost_domestic_letter',
      ),
    ),
    'quote' => array(
      'type' => 'auspost_letter',
      'callback' => 'uc_auspost_pac_quote',
      'file' => 'uc_auspost_pac.quote.inc',
      'accessorials' => _uc_auspost_pac_method_accessorials_options('auspost_domestic_letter'),
    ),
    'enabled' => FALSE,
  );

  $methods['auspost_domestic_parcel'] = array(
    'id' => 'auspost_domestic_parcel',
    'module' => 'uc_auspost_pac',
    'title' => t('Aus Post Domestic Parcel'),
    'description' => t('For parcels up to 20kg, no larger than 105cm(l) x 105cm(w) x 105cm(h) but with a maximum girth(w x h) of 140cm. l is the longest dimension.'),
    'operations' => array(
      'settings' => array(
        'title' => t('settings'),
        'href' => 'admin/store/settings/quotes/auspost-pac/edit/auspost_domestic_parcel',
      ),
    ),
    'quote' => array(
      'type' => 'small_package',
      'callback' => 'uc_auspost_pac_quote',
      'file' => 'uc_auspost_pac.quote.inc',
      'accessorials' => _uc_auspost_pac_method_accessorials_options('auspost_domestic_parcel'),
    ),
    'enabled' => FALSE,
  );

  $methods['auspost_intnl_letter'] = array(
    'id' => 'auspost_intnl_letter',
    'module' => 'uc_auspost_pac',
    'title' => t('Aus Post International Letter'),
    'description' => t('For letters up to 500g.'),
    'operations' => array(
      'settings' => array(
        'title' => t('settings'),
        'href' => 'admin/store/settings/quotes/auspost-pac/edit/auspost_intnl_letter',
      ),
    ),
    'quote' => array(
      'type' => 'auspost_letter',
      'callback' => 'uc_auspost_pac_quote',
      'file' => 'uc_auspost_pac.quote.inc',
      'accessorials' => _uc_auspost_pac_method_accessorials_options('auspost_intnl_letter'),
    ),
    'enabled' => FALSE,
  );

  $methods['auspost_intnl_parcel'] = array(
    'id' => 'auspost_intnl_parcel',
    'module' => 'uc_auspost_pac',
    'title' => t('Aus Post International Parcel'),
    'description' => t('For parcels up to 20kg.'),
    'operations' => array(
      'settings' => array(
        'title' => t('settings'),
        'href' => 'admin/store/settings/quotes/auspost-pac/edit/auspost_intnl_parcel',
      ),
    ),
    'quote' => array(
      'type' => 'small_package',
      'callback' => 'uc_auspost_pac_quote',
      'file' => 'uc_auspost_pac.quote.inc',
      'accessorials' => _uc_auspost_pac_method_accessorials_options('auspost_intnl_parcel'),
    ),
    'enabled' => FALSE,
  );

  return $methods;
}

/**
 * Return accessorial list or full options list for the given method id. Once
 * generated, it is stored in the glacial cache. Source data is also in the
 * glacial cache and is mostly raw data from AusPostPAC API.
 * @todo Add support for full_options param.
 *
 * @param string $method_id
 *   Machine name of the method.
 * @param boolean $full_options
 *   If FALSE (default), will return just the accessorials list used by
 *   hook_shipping_method. If TRUE, return those accessorials but also every
 *   available option with those accessorials.
 * @param boolean $reset
 *   If TRUE, generate and reset all cached parts, except the original data in
 *   the glacial cache.
 *
 * @return array
 *   All accessorials for the method, or accessorials and all of their options.
 */
function _uc_auspost_pac_method_accessorials_options($method_id, $full_options = FALSE, $reset = FALSE) {
  $static_cache = &drupal_static(__FUNCTION__, array());

  if (!$reset && isset($static_cache[$method_id][$full_options])) {
    return $static_cache[$method_id][$full_options];
  }

  if (!$reset && $cache = cache_get('appac:accessorials:' . $method_id, 'cache_uc_auspost_pac')) {
    return $static_cache[$method_id][$full_options] = $cache->data;
  }

  // Not cached. Must generate. This item is expected to be in the cache at all
  // times as it is data either added at install time, or generated when the
  // API Key was set.
  if ($cache = cache_get('appac:' . $method_id, 'cache_uc_auspost_pac_glacial')) {
    $accessorials = array();

    foreach ($cache->data as $service_key => $service) {
      // If it has NO options, include as a basic service.
      if (!isset($service['options'])) {
        $accessorials[$service_key] = $service['name'];
      }

      // If it has an option of EXTRA_COVER, CONFIRM_DELIVERY, or PICKUP_METRO
      // also include as a basic service, but also exhaustively generate a list
      // of all combinations of options.
      // @todo Add and handle the options list. Right now, the client nor admin
      // can choose which of the options are to be included.
      elseif (_uc_auspost_pac_contains_add_on_option($service['options'])) {
        $accessorials[$service_key] = $service['name'];
      }

      // Or, they are mutually exclusive options that need to be each checked
      // for sub-options that may or may not need to be exhautively generated.
      // @todo Add and handle the sub-options list.
      else {
        foreach ($service['options'] as $option_key => $option) {
          $accessorials[$service_key . '+' . $option_key] = $service['name'] . ' -> ' . $option['name'];
        }
      }
    }

    // Add to cache and return.
    cache_set('appac:accessorials:' . $method_id, $accessorials, 'cache_uc_auspost_pac', CACHE_PERMANENT);
    return $static_cache[$method_id][$full_options] = $accessorials;
  }
  else {
    watchdog('uc_auspost_pac',
      'Items expected to be always present in the glacial cache are missing. Please re-install the module or re-generate them on the settings page.',
      array(),
      WATCHDOG_CRITICAL,
      l(t('settings'), 'admin/store/settings/quotes/auspost-pac')
    );
    return array(
      'error' => t('An error has occured in the AusPost shipping module. Please contact the administrator to rectify this issue.'),
    );
  }
}

/**
 * Helper function to find options/suboptions that force an addon/checkbox
 * selection for the given level of options. At least one of the array keys
 * must contain OPTION_EXTRA_COVER, CONFIRM_DELIVERY, or PICKUP_METRO for it
 * to return TRUE.
 *
 * @param array $options
 *   An options or suboptions array from the AusPostPAC API data.
 *
 * @return boolean
 *   TRUE if the array contains a key containing the above text.
 */
function _uc_auspost_pac_contains_add_on_option($options) {
  foreach ($options as $option_key => $option) {
    foreach (array('OPTION_EXTRA_COVER', 'CONFIRM_DELIVERY', 'PICKUP_METRO') as $addon)  {
      if (strpos($option_key, $addon) !== FALSE) {
        return TRUE;
      }
    }
  }

  return FALSE;
}

/**
 * Return the configured method settings.
 *
 * @param $method_id
 *   The method id for the method array.
 */
function _uc_auspost_pac_get_method_settings($method_id) {
  return array_merge(
    _uc_auspost_pac_get_method_settings_default($method_id),
    variable_get('uc_auspost_pac_var_method_' . $method_id, array())
  );
}

/**
 * Get the method default settings.
 *
 * @param $method_id
 *   The method id for the method array.
 */
function _uc_auspost_pac_get_method_settings_default($method_id) {
  $default = array(
    'packing_method' => 'do_not_pack',
    'enabled_services' => array(),
    'limits' => array(),
    'markup_type' => UC_AUSPOST_PAC_MARKUP_NONE,
    'markup_amount' => 0,
  );

  if ($method_id == 'auspost_domestic_letter') {
    $default['limits'] = array(
      'weight' => array('min' => 0, 'max' => 500, 'min_safe' => 0),
    );
  }
  elseif ($method_id == 'auspost_domestic_parcel') {
    $default['limits'] = array(
      'length' => array('min' => 1, 'max' => 1050, 'min_safe' => 50),
      'width' => array('min' => 1, 'max' => 1050, 'min_safe' => 50),
      'height' => array('min' => 1, 'max' => 1050, 'min_safe' => 30),
      'girth' => array('min' => 160, 'max' => 1400),
      'weight' => array('min' => 0.001, 'max' => 20000, 'min_safe' => 0.001),
    );
  }
  elseif ($method_id == 'auspost_intnl_letter') {
    $default['limits'] = array(
      'weight' => array('min' => 0, 'max' => 500, 'min_safe' => 0),
    );
  }
  elseif ($method_id == 'auspost_intnl_parcel') {
    $default['limits'] = array(
      'weight' => array('min' => 0.001, 'max' => 20000, 'min_safe' => 0.001),
    );
  }

  return $default;
}

/**
 * Retrieve all or a a specific packing method info.
 *
 * @param $packing_method_id optional
 *   The unique string id of the packing method to return.
 * @param $reset
 *   Force a reset of the static and db cached data.
 */
function uc_auspost_pac_get_packing_method($packing_method_id = NULL, $reset = FALSE) {
  $cached_methods = &drupal_static(__FUNCTION__, array());

  if (!$reset && $cached_methods) {
    if ($packing_method_id) {
      if (isset($cached_methods[$packing_method_id])) {
        return $cached_methods[$packing_method_id];
      }
      else {
        return NULL;
      }
    }
    else {
      return $cached_methods;
    }
  }

  if (!$reset && ($cache = cache_get('uc_auspost_pac:packing:methods', 'cache_uc_auspost_pac'))) {
    // No need to check expiry as it was stored as permanent as will be flushed
    // when modules are installed/disabled. Recurse to get appropriate answer.
    if ($cache->data) {
      $cached_methods = $cache->data;
      return uc_auspost_pac_get_packing_method($packing_method_id, FALSE);
    }
  }

  // Not in caches, or forced reset. Build from scratch.
  $methods = array();
  foreach (module_implements('packing_info') as $module) {
    foreach ((array) module_invoke($module, 'packing_info') as $method_id => $method) {
      $method['id'] = $method_id;
      $method['module'] = $module;
      if (!isset($method['file path'])) { 
        $method['file path'] = drupal_get_path('module', $module);
      }

      // Add to (or replace in) array of methods to be stored.
      $methods[$method_id] = $method;
    }
  }

  // Allow modules to alter the methods.
  drupal_alter('packing_info', $methods);

  // If there are no methods, add a marker to indicate such which also prevents
  // endless loops caused by the recursive calls.
  if (!$methods) {
    $methods['error'] = t('No methods available.');
  }

  // Cache the results.
  $cached_methods = $methods;
  cache_set('uc_auspost_pac:packing:methods', $methods, 'cache_uc_auspost_pac', CACHE_PERMANENT);

  // Return the result by recursing.
  return uc_auspost_pac_get_packing_method($packing_method_id, FALSE);
}

/**
 * Convert product dimensions to those used by AusPost and 99% of the developed
 * world. The ordering of the dimensions will be ordered from smallest to
 * largest which can be used by both the letter and package methods to put
 * them in the right order no matter the ordered entered.
 *
 * @return array
 *   The dimensions, converted to mm, ordered from smallest to largest.
 */
function uc_auspost_pac_convert_sort_dimensions($product) {
  // If this is an object, clone it to prevent changes, or convert it to an
  // object if we've been given an array.
  $local_product = is_object($product) ? clone $product : (object) $product;

  // Assume it's already in mm if the length_units is not in existance.
  $conversion_rate = 1;
  if (isset($local_product->length_units) && $local_product->length_units != 'mm') {
    $conversion_rate = uc_length_conversion($local_product->length_units, 'mm');
  }

  // For Domestic letters, the smallest value is the height/thickness. Next
  // largest is the length, followed by the width. 20mm, 260mm, 360mm max at
  // the time of coding. Dimensions outside the valid ranges need to be taken
  // care of by a support module.
  $dimensions = array(
    $local_product->height * $conversion_rate,
    $local_product->length * $conversion_rate,
    $local_product->width * $conversion_rate,
  );
  sort($dimensions, SORT_NUMERIC);

  return $dimensions;
}
