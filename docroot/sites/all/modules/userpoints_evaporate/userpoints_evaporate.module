<?php
/**
 * A few defines that the module wants to use.
 */
define('USERPOINTS_EVAPORATE_HOUR', 60 * 60);
define('USERPOINTS_EVAPORATE_DAY', 24 * USERPOINTS_EVAPORATE_HOUR);
define('USERPOINTS_EVAPORATE_WEEK', 7 * USERPOINTS_EVAPORATE_DAY);
define('USERPOINTS_EVAPORATE_MONTH', 30 * USERPOINTS_EVAPORATE_DAY);

// Run time offset - 3 minutes.
define('USERPOINTS_EVAPORATE_OFFSET', 60 * 3);

/**
 * Implementation of hook_menu()
 *
 * Module administration
 */
function userpoints_evaporate_menu() {
  $items['admin/config/people/userpoints/evaporate'] = array(
    'title' => 'Evaporation',
    'description' => 'Change settings for the userpoints_evaporate module.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('userpoints_evaporate_admin_settings'),
    'access callback' => 'user_access',
    'access arguments' => array('administer userpoints'),
    'file' => 'userpoints_evaporate.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,
  );
  return $items;
}

/**
 * Implementation of hook_cron()
 *
 * Do the actual work on cron run.
 */
function userpoints_evaporate_cron() {

  // Cycle through the meat of the module for each enabled points
  // taxonomy term.
  $terms = userpoints_get_categories();

  $settings = variable_get('userpoints_evaporate', array());

  foreach ($terms as $tid => $term) {
    // Skip this tid if it is new and/or has no stored settings. This fixes
    // a PHP array offset warning as per #1667962.
    if (empty($settings[$tid])) {
      continue;
    }
    $setting = $settings[$tid];

    // Early return if not enabled for this term or no interval is specified.
    if (empty($setting['enabled']) || empty($setting['interval']))
      continue;

    if (empty($setting['timestamp']))
      $setting['timestamp'] = 0;

    // If last run time plus interval is greater than now, it's not time to
    // run yet.
    if (($setting['timestamp'] + $setting['interval']) > time() ) {
      return;
    }

    $translation = userpoints_translation();
    $translation['%term'] = $translation['!term'] = $term;

    // Set a new timestamp.
    //
    // To avoid bug #733358 where due to variable run length the timestamp
    // isn't always the same interval of seconds apart, let's say we ran 3
    // minutes ago. Also, set the timestamp before the module runs its
    // queries, to avoid more time uncertainty.
    //
    // This will work fine unless you run cron every 4 minutes. So don't do
    // that. Ever.
    //
    // However, do NOT set the timestamp in the variable table until the
    // actual update queries complete. See #963908.
    $timestamp = time() - USERPOINTS_EVAPORATE_OFFSET;

    // Update the settings array with the new timestamp, so it's there when we
    // save it after the run completes.
    $settings[$tid]['timestamp'] = $timestamp;

    // I can can find no documentation at all that indicated dbtng is capable
    // selecting a static value as opposed to a table field. Thus we keep
    // using db_query() in this cron hook for now.

    // Create a query to add an entry in the {userpoints_txn} table for each
    // user we're about to evaporate some points from.
    $query_txn = "INSERT INTO {userpoints_txn} (uid, approver_uid, points, time_stamp, changed, description, tid, operation)
                SELECT up.uid, 1, :points, :timestamp, :changed, :description, :tid, :operation FROM {userpoints} AS up";
    $args_txn = array(
      ':points' => $setting['number'] * -1,
      ':timestamp' => time(),
      ':changed' => time(),
      ':description' => $setting['description'],
      ':tid' => $tid,
      ':operation' => 'evaporate',
    );

    // Create the query to remove points from the per-type total.
    $query_ttl = db_update('userpoints')
      ->expression('points', 'points - :number', array(':number' => $setting['number']))
      ->condition('tid', $tid);

    // If only for inactive users, check for last activity. This must be done
    // before checking for nonegative, as the INNER JOIN is more efficient than
    // a sub-query and the sub-query might not get cached.
    if ($setting['inactive']['enabled']) {
      // Calculate as a number of seconds.
      $delta  = $setting['inactive']['unit'];
      $delta *= $setting['inactive']['delta'];

      // Do an inner join on the users table to only get inactive ones.
      $query_txn .= " INNER JOIN {users} AS u ON (up.uid = u.uid AND u.access < :delta)";
      $args_txn[':delta'] = time() - $delta;

      // Add a subquery where clause to limit this to inactive users.
      $subquery_ttl = db_select('users', 'u')
        ->fields(array('uid'))
        ->condition('access', (time() - $delta), '<');

      $query_ttl->condition('uid', $subquery_ttl, 'IN');
    }

    // Limit tnx insert to records with the current tid only.
    $query_txn .= " WHERE up.tid = :tid";

    // There is no 7.x no_negative module, so use our own setting.
    if (!empty($setting['nonegative'])) {
      $query_txn .= " AND up.points >= :balance";
      $args_txn[':balance'] = $setting['number'];

      $query_ttl->condition('points', $setting['number'], '>=');
    }

    // Run the query to add relevant entries in the {userpoints_txn} table.
    db_query($query_txn, $args_txn);

    // Run the update query to evaporate some points from the {userpoints} table.
    $query_ttl->execute();

    // Now save the settings with the updated timestamp, so hook_cron knows
    // we ran and finished for this term.
    variable_set('userpoints_evaporate', $settings);

    // And write a log entry to the watchdog table.
    //
    watchdog('userpoints_evaporate', 'userpoints_evaporate cron run evaporated some !term !points', $translation, WATCHDOG_INFO);
  }

  // In userpoints 7.x there is a new table that stores a running over-all
  // points total for each user. Update that total the fast (lazy) way.
  db_query("UPDATE {userpoints_total} AS t SET points = (SELECT SUM(points) FROM {userpoints} AS u WHERE u.uid = t.uid)");
}

/**
 * Make an array of default settings.
 *
 * @return Array.
 *   A keyed array of per-tid default evaportion settings.
 */
function _userpoints_evaporate_default_settings() {
  return array(
    'enabled' => FALSE,
    'interval' => USERPOINTS_EVAPORATE_DAY,
    'number' => 1,
    'description' => '',
    'nonegative' => FALSE,
    'inactive' => array(
      'enabled' => FALSE,
      'delta' => 0,
      'unit' => USERPOINTS_EVAPORATE_DAY,
    ),
  );
}
