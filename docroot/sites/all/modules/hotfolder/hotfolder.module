<?php

/**
 * @file - Hotfolder
 */

/**
 * @file
 * Code for the Hotfolders feature.
 */

// Log levels.
define('HOTFOLDERS_LOG_NONE', 0);
define('HOTFOLDERS_LOG_PART', WATCHDOG_NOTICE);
define('HOTFOLDERS_LOG_WARN', WATCHDOG_WARNING);
define('HOTFOLDERS_LOG_DBUG', WATCHDOG_DEBUG);

include_once 'hotfolder.features.inc';

/**
 * Implements hook_permission().
 */
function hotfolder_permission() {
  return array(
    'administer hotfolder' => array(
      'title' => t('administer hotfolder'),
      'description' => t('administer hotfolder'),
    ),
    'run hotfolder watch' => array(
      'title' => t('run hotfolder watch'),
      'description' => t('run hotfolder watch'),
    ),
    'run hotfolder job' => array(
      'title' => t('run hotfolder job'),
      'description' => t('run hotfolder job'),
    ),
    'toggle hotfolder cron' => array(
      'title' => t('toggle hotfolder cron'),
      'description' => t('toggle hotfolder cron'),
    ),
    'reset hotfolder threads' => array(
      'title' => t('reset hotfolder threads'),
      'description' => t('reset hotfolder threads'),
    ),
    'run hotfolder cron' => array(
      'title' => t('run hotfolder cron'),
      'description' => t('run hotfolder cron'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function hotfolder_menu() {
  $items['admin/config/services/hotfolder'] = array(
    'title' => 'Hotfolder configurations',
    'description' => 'Administrative configurations for hotfolders.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('_hotfolder_admin'),
    'access arguments' => array('administer hotfolder'),
    'file' => 'hotfolder.admin.inc',
  );
  return $items;
}

/**
 * Implements hook_cron_queue_info().
 */
function hotfolder_cron_queue_info() {
  $queues['hotfolder_queue'] = array(
    'worker callback' => '_hotfolder_queue_job',
    'time' => 60,
  );
  return $queues;
}

/**
 * Wrapper around process for queue handling.
 */
function _hotfolder_queue_job($job) {
  // Process jobs in queue.
  $enabled = variable_get('hotfolder_enabled', TRUE);
  if ($enabled) {
    // Try not to repeat yourself too much.
    static $enabled_notice = 'Hotfolders enabled during cron. Starting queue run.';
    if (!empty($enabled_notice)) {
      _hotfolder_watchdog('hotfolder', $enabled_notice, array(), WATCHDOG_DEBUG);
      $enabled_notice = '';
    }
    _hotfolder_process_job($job);
  }
  else {
    // Try not to repeat yourself too much.
    static $disabled_notice = 'Hotfolders disabled during cron. No queued jobs run.';
    if (!empty($disabled_notice)) {
      _hotfolder_watchdog('hotfolder', $disabled_notice, array(), WATCHDOG_DEBUG);
      $disabled_notice = '';
    }
    // While paused, put this one back on the stack so we don't lose it.
    // This means we could be looping on this a LOT if the cron is paused for too long.
    _hotfolder_add_jobs_to_queue(array($job));
  }
}

/**
 * Implements hook_cron().
 */
function hotfolder_cron() {
  _hotfolder_watchdog('hotfolder', 'Hotfolders started cron.', array(), WATCHDOG_DEBUG);
  $enabled = variable_get('hotfolder_enabled', TRUE);
  if ($enabled) {
    _hotfolder_check_watches();
  }
  else {
    _hotfolder_watchdog('hotfolder', 'Hotfolders disabled during cron. No new jobs added.', array(), WATCHDOG_DEBUG);
  }
  _hotfolder_watchdog('hotfolder', 'Hotfolders ended cron.', array(), WATCHDOG_DEBUG);
}

/**
 * Implements hotfolder_stream_wrappers().
 */
function hotfolder_stream_wrappers() {
  $streams = array();
  $hotfolder_streams = _hotfolder_get_schemas();
  // Link schemas to the system.
  foreach ($hotfolder_streams as $name => $path) {
    $name = strtolower($name);
    $name = str_replace('://', '', $name);
    if ($name != 'public' && $name != 'private') {
      $streams[$name] = array(
        'name' => t('@name hotfolder', array('@name' => ucfirst($name))),
        'class' => 'HotfolderPrivateStreamWrapper',
        'description' => t('Hotfolder folder root used in watch configurations.'),
        'type' => STREAM_WRAPPERS_LOCAL_NORMAL,
      );
    }
  }
  return $streams;
}

/**
 * Implements hook_trigger_info().
 */
function hotfolder_trigger_info() {
  // Make triggers.
  $triggers['hotfolder'] = array();
  $triggers['hotfolder']['hotfolder_set_job'] = array(
      'label' => t('When a job is first detected.'),
  );
  $triggers['hotfolder']['hotfolder_call_job'] = array(
      'label' => t('When a job is called for processing.'),
  );
  // Get list of statuses.
  $statuses = _hotfolder_statuses();
  foreach ($statuses as $status_name => $status) {
    $triggers['hotfolder']['hotfolder_' . $status_name . '_status'] = array(
        'label' => t('When a job record is set to status: @status', array('@status' => $status['human name'])),
    );
  }
  // Get list of stages.
  $stages = _hotfolder_stages();
  foreach ($stages as $stage_name => $stage) {
    $triggers['hotfolder']['hotfolder_' . $stage_name . '_pre'] = array(
        'label' => t('When a job record is entering stage: @stage', array('@stage' => $stage['human name'])),
    );
    $triggers['hotfolder']['hotfolder_' . $stage_name . '_post'] = array(
        'label' => t('When a job record is leaving stage: @stage', array('@stage' => $stage['human name'])),
    );
  }
  return $triggers;
}

/**
 * Implements hook_rules_event_info().
 */
function hotfolder_rules_event_info() {
  // Make events.
  $defaults = array(
    'group' => t('hotfolder'),
    'module' => 'hotfolder',
  );
  $events = array();
  $events['hotfolder_set_job'] = $defaults + array(
    'label' => t('When a job is first detected.'),
    'variables' => array(
      'job' => array('type' => 'node', 'label' => t('job')),
      'watch' => array('type' => 'node', 'label' => t('watch')),
    ),
  );
  $events['hotfolder_call_job'] = $defaults + array(
    'label' => t('When a job is called for processing.'),
    'variables' => array(
      'job' => array('type' => 'node', 'label' => t('job')),
      'watch' => array('type' => 'node', 'label' => t('watch')),
    ),
  );
  // Get list of statuses.
  $statuses = _hotfolder_statuses();
  foreach ($statuses as $status_name => $status) {
    $events['hotfolder_' . $status_name . '_status'] = $defaults + array(
      'label' => t('When a job record is set to status: @status', array('@status' => $status['human name'])),
      'variables' => array(
        'job' => array('type' => 'node', 'label' => t('job')),
        'watch' => array('type' => 'node', 'label' => t('watch')),
      ),
    );
  }
  // Get list of stages.
  $stages = _hotfolder_stages();
  foreach ($stages as $stage_name => $stage) {
    $events['hotfolder_' . $stage_name . '_pre'] = $defaults + array(
      'label' => t('When a job record is entering stage: @stage', array('@stage' => $stage['human name'])),
      'variables' => array(
        'job' => array('type' => 'node', 'label' => t('job')),
        'watch' => array('type' => 'node', 'label' => t('watch')),
      ),
    );
    $events['hotfolder_' . $stage_name . '_post'] = $defaults + array(
      'label' => t('When a job record is leaving stage: @stage', array('@stage' => $stage['human name'])),
      'variables' => array(
        'job' => array('type' => 'node', 'label' => t('job')),
        'watch' => array('type' => 'node', 'label' => t('watch')),
      ),
    );
  }
  return $events;
}

/**
 * Implements hook_block_info().
 */
function hotfolder_block_info() {
  // This example comes from node.module.
  return array(
    'hotfolder_run_watches' => array(
      'info' => t('Run Watches'),
      'cache' => DRUPAL_NO_CACHE,
    ),
    'hotfolder_run_jobs' => array(
      'info' => t('Run Jobs'),
      'cache' => DRUPAL_NO_CACHE,
    ),
    'hotfolder_clear_threads' => array(
      'info' => t('Clear Threads'),
      'cache' => DRUPAL_NO_CACHE,
    ),
    'hotfolder_toggle_cron' => array(
      'info' => t('Watch Status'),
      'cache' => DRUPAL_NO_CACHE,
    ),
    'hotfolder_run_cron' => array(
      'info' => t('Run Cron'),
      'cache' => DRUPAL_NO_CACHE,
    ),
    'hotfolder_run_cron' => array(
      'info' => t('Run Cron'),
    ),
  );
}

/**
 * Implements hook_block_view().
 */
function hotfolder_block_view($delta = '') {
  // Include the forms.
  module_load_include('inc', 'hotfolder', 'hotfolder.forms');
  // Get the block forms.
  $block = array();
  switch ($delta) {
    case 'hotfolder_run_watches':
      $block['subject'] = t('Run Watches');
      $block['content'] = drupal_get_form('_hotfolder_run_watches');
      break;

    case 'hotfolder_run_jobs':
      $block['subject'] = t('Run Jobs');
      $block['content'] = drupal_get_form('_hotfolder_run_jobs');
      break;

    case 'hotfolder_clear_threads':
      $block['subject'] = t('Clear Threads');
      $block['content'] = drupal_get_form('_hotfolder_reset_threads');
      break;

    case 'hotfolder_toggle_cron':
      if (variable_get('hotfolder_enabled', TRUE)) {
        $block['subject'] = t('Disable Watches');
      }
      else {
        $block['subject'] = t('Enable Watches');
      }
      $block['content'] = drupal_get_form('_hotfolder_toggle_cron');
      break;

    case 'hotfolder_run_cron':
      $block['subject'] = t('Run Cron');
      $block['content'] = drupal_get_form('_hotfolder_run_cron');
      break;

    default:
      break;
  }
  return $block;
}

/**
 * Implements hook_node_view().
 */
function hotfolder_node_view($node, $view_mode, $langcode) {
  // Add button to kick off a watch folder review by hand.
  if ($node->type == 'watch_configuration' && $view_mode == 'full') {
    $run_watch_form = drupal_get_form('_hotfolder_check_watch_form', $node->nid);
    if (!empty($run_watch_form)) {
      $node->content['_hotfolder_check_watch_form'] = $run_watch_form;
      $node->content['_hotfolder_check_watch_form']['#weight'] = 100;
    }
  }
  // Add button to kick off a job process by hand.
  if ($node->type == 'job_record' && $view_mode == 'full') {
    $run_job_form = drupal_get_form('_hotfolder_check_job_form', $node->nid);
    if (!empty($run_job_form)) {
      $node->content['_hotfolder_check_job_form'] = $run_job_form;
      $node->content['_hotfolder_check_job_form']['#weight'] = 100;
    }
    $reset_job_form = drupal_get_form('_hotfolder_reset_job_form', $node->nid);
    if (!empty($reset_job_form)) {
      $node->content['_hotfolder_reset_job_form'] = $reset_job_form;
      $node->content['_hotfolder_reset_job_form']['#weight'] = 120;
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function hotfolder_form_taxonomy_form_term_alter(&$form, &$form_state, $form_id) {
  // If this is the hotfolder vocab.
  $vocab = isset($form['#term']->vocabulary_machine_name) ? $form['#term']->vocabulary_machine_name : '';
  if ($vocab == 'hotfolder_streams') {
    $name = isset($form['#term']->name) ? $form['#term']->name : '';
    if ($name == 'public://' || $name == 'private://') {
      // And this is either private or public - don't allow change or delete.
      drupal_set_message(t('This stream cannot be changed - it represents a default Drupal stream.'));
      foreach (element_children($form) as $field_name) {
        $form[$field_name]['#disabled'] = TRUE;
      }
    }
  }
}

/**
 * Form.
 */
function _hotfolder_check_watch_form($form, &$form_state, $nid) {
  // Bail if user doesn't have permission. Potential data destruction so being careful.
  if (user_access('run hotfolder watch')) {
    $form['watch_nid'] = array(
      '#type' => 'hidden',
      '#value' => $nid,
    );
    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Run configuration'),
    );
    $form['submit_desc'] = array(
      '#type' => 'item',
      '#markup' => t('Run this watch configuration manually. Running will place jobs in the queue.'),
    );
  }
  return $form;
}

/**
 * Form submit handler.
 */
function _hotfolder_check_watch_form_submit(&$form, &$form_state) {
  // Bail if user doesn't have permission. Potential data destruction so being careful.
  if (user_access('run hotfolder watch')) {
    $nid = isset($form_state['values']['watch_nid']) ? $form_state['values']['watch_nid'] : FALSE;
    if ($nid) {
      $watch = node_load($nid);
      if ($watch && $watch->type == 'watch_configuration') {
        drupal_set_message(t('Running watch configuration.'));
        _hotfolder_watchdog('hotfolder', 'Manually running watch #@nid @title', array('@nid' => $nid, '@title' => $watch->title), WATCHDOG_NOTICE);
        $jobs = _hotfolder_detect_jobs($watch);
        _hotfolder_watchdog('hotfolder', 'Found @jobs job(s) while manually running watch.', array('@jobs' => count($jobs)), WATCHDOG_NOTICE);
        _hotfolder_add_jobs_to_queue($jobs);
      }
    }
  }
}

/**
 * Form.
 */
function _hotfolder_check_job_form($form, &$form_state, $nid) {
  // Bail if user doesn't have permission. Potential data destruction so being careful.
  if (user_access('run hotfolder job')) {
    $form['job_nid'] = array(
      '#type' => 'hidden',
      '#value' => $nid,
    );
    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Run Job'),
    );
    $form['submit_desc'] = array(
      '#type' => 'item',
      '#markup' => t('Run this job manually. Running will not remove the job from the queue, but will update job state before the next run.'),
    );
  }
  return $form;
}

/**
 * Form submit handler.
 */
function _hotfolder_check_job_form_submit(&$form, &$form_state) {
  // Bail if user doesn't have permission. Potential data destruction so being careful.
  if (user_access('run hotfolder job')) {
    $nid = isset($form_state['values']['job_nid']) ? $form_state['values']['job_nid'] : FALSE;
    if ($nid) {
      $job = node_load($nid);
      if ($job && $job->type == 'job_record') {
        drupal_set_message(t('Running job.'));
        _hotfolder_watchdog('hotfolder', 'Manually running job #@nid @title', array('@nid' => $nid, '@title' => $job->title), WATCHDOG_NOTICE);
        _hotfolder_process_job($job, FALSE);
      }
    }
  }
}

/**
 * Form.
 */
function _hotfolder_reset_job_form($form, &$form_state, $nid) {
  // Bail if user doesn't have permission. Potential data destruction so being careful.
  if (user_access('run hotfolder job')) {
    $job = node_load($nid);
    if (!_hotfolder_is_status($job, 'ready') || !_hotfolder_is_stage($job, _hotfolder_first_stage())) {
      $form['job_nid'] = array(
        '#type' => 'hidden',
        '#value' => $nid,
      );
      $form['submit'] = array(
        '#type' => 'submit',
        '#value' => t('Reset Job'),
      );
      $form['submit_desc'] = array(
        '#type' => 'item',
        '#markup' => t('Reset this job manually. This returns the job to initial configurations, but does not run set-up triggers.'),
      );
    }
  }
  return $form;
}

/**
 * Form submit handler.
 */
function _hotfolder_reset_job_form_submit(&$form, &$form_state) {
  // Bail if user doesn't have permission. Potential data destruction so being careful.
  if (user_access('run hotfolder job')) {
    $nid = isset($form_state['values']['job_nid']) ? $form_state['values']['job_nid'] : FALSE;
    if ($nid) {
      $job = node_load($nid);
      if ($job && $job->type == 'job_record') {
        drupal_set_message(t('Resetting job.'));
        _hotfolder_watchdog('hotfolder', 'Manually resetting job #@nid @title', array('@nid' => $nid, '@title' => $job->title), WATCHDOG_NOTICE);
        if (!_hotfolder_is_status($job, 'ready') || !_hotfolder_is_stage($job, _hotfolder_first_stage())) {
          // Set the job in the queue ONLY if not in ready.
          if (!_hotfolder_is_status($job, 'ready')) {
            _hotfolder_add_jobs_to_queue(array($job));
          }
          _hotfolder_set_status($job, 'ready');
          _hotfolder_set_stage($job, _hotfolder_first_stage());
          $job->field_job_record_retries[$job->language][0]['value'] = 0;
          // Reset the job log so it doesn't get too long.
          $job->field_job_log[$job->language][0]['value'] = '';
          // Make sure the file is in submit folder.
          $use_internal = variable_get('hotfolder_internal_folders', TRUE);
          // Check if we need to move the file, and if so if successful.
          if ($use_internal) {
            $fid = _hotfolder_get_field_fid($job, 'field_job_record_source_file');
            if (!empty($fid)) {
              // Pick up the submit and done folders to make sure we ignore them.
              $file = file_load($fid);
              // Then move original file from submitted folder to done folder.
              $field_watch_folder = $job->field_orig_watch_config_folder[$job->language][0]['value'];
              $folder_path = $field_watch_folder . '/' . variable_get('hotfolder_submitted_folder', 'hotfolder_submitted');
              $folder_path = file_stream_wrapper_uri_normalize($folder_path);
              _hotfolder_move_file($file, $folder_path);
            }
          }
          _hotfolder_job_log($job, 'hotfolder', 'Job #@job-nid has been reset to run again.',
            array('@job-nid' => $job->nid), WATCHDOG_NOTICE);
          // Save the job.
          node_save($job);
        }
      }
    }
  }
}

/**
 * Look for newly entered files per configuration. Called by cron.
 */
function _hotfolder_check_watches() {
  _hotfolder_watchdog('hotfolder', 'Adding jobs.', array(), WATCHDOG_DEBUG);
  // Get all configs currently set to active.
  $watches = _hotfolder_get_watch_configs();
  _hotfolder_watchdog('hotfolder', 'Found @configs config(s).', array('@configs' => count($watches)), WATCHDOG_DEBUG);
  $jobs = array();
  foreach ($watches as $watch) {
    $jobs = _hotfolder_detect_jobs($watch, $jobs);
  }
  _hotfolder_watchdog('hotfolder', 'Found @jobs job(s).', array('@jobs' => count($jobs)), WATCHDOG_DEBUG);
  _hotfolder_add_jobs_to_queue($jobs);
}

/**
 * Add jobs to the drupal queue. Called at cron, and for sleeping jobs.
 */
function _hotfolder_add_jobs_to_queue($jobs) {
  $queue = DrupalQueue::get('hotfolder_queue');
  foreach ($jobs as $job) {
    _hotfolder_job_log($job, 'hotfolder', 'Job #@job-nid has been added to the job queue.',
      array('@job-nid' => $job->nid), WATCHDOG_NOTICE);
    node_save($job);
    $queue->createItem($job);
  }
}

/**
 * Given a configuration, look for files that match it.
 */
function _hotfolder_detect_jobs($config, $jobs = array()) {
  // Get the watch.
  $watch = _hotfolder_get_watchfolder($config);
  if (empty($watch)) {
    _hotfolder_watchdog('hotfolder', 'No watch found for watch #@nid.', array('@nid' => $config->nid), WATCHDOG_ERROR);
  }
  $pattern = _hotfolder_get_field_value($config, 'field_watch_config_src_pattern');
  if (empty($pattern)) {
    _hotfolder_watchdog('hotfolder', 'No pattern found for watch #@nid.', array('@nid' => $config->nid), WATCHDOG_ERROR);
  }
  $watch_path = drupal_realpath($watch);
  _hotfolder_watchdog('hotfolder', 'Checking directory @directory ( @folder ) for jobs matching @pattern.',
    array('@directory' => $watch, '@folder' => $watch_path, '@pattern' => $pattern), WATCHDOG_DEBUG);
  // Check the pattern and watch have values.
  if (!empty($pattern) && !empty($watch)) {
    $ignore = array();
    // Check if we're using internal folders. If not, leave them blank.
    $use_internal = variable_get('hotfolder_internal_folders', TRUE);
    if ($use_internal) {
      $submit = variable_get('hotfolder_submitted_folder', 'hotfolder_submitted');
      $ignore[] = $watch . '/' . $submit;
      $done = variable_get('hotfolder_done_folder', 'hotfolder_done');
      $ignore[] = $watch . '/' . $done;
    }
    else {
      // Pick up the associated files already on record, don't double up.
      // Use the watch to filter things a little more tightly so we don't get EVERY file.
      $ignore = _hotfolder_get_detected_files($watch);
    }
    // Now check this folder for additional jobs.
    $jobs = _hotfolder_pickup_jobs($jobs, $watch, $config, $ignore);
  }
  else {
    _hotfolder_watchdog('hotfolder', 'Add job routine could not read job directory: @directory.',
      array('@directory' => $watch), WATCHDOG_ERROR);
  }
  return $jobs;
}

/**
 * Helper function, create job from files in a given folder.
 */
function _hotfolder_pickup_jobs($jobs, $watch, $config, $ignores = array()) {
  // A file may only answer to one configuration, once matched the file is
  // moved to submission. But a given configuration may do many many things.
  // Do not rely on order of configurations to filter what jobs go where.
  // And we do not have a reliable ordering when gathering configurations.
  // Always always always treat a job configuration as a singular setting.
  // Keep track of files already detected and added on this loop.
  static $processed_files = array();
  // Grab configs.
  $pattern = _hotfolder_get_field_value($config, 'field_watch_config_src_pattern');
  $recurse = _hotfolder_get_field_value($config, 'field_watch_config_recurse', FALSE);
  $delete = _hotfolder_get_field_value($config, 'field_watch_config_delete', FALSE);
  // Start getting our info.
  $all = _hotfolder_file_scan_directory($watch, '//', $ignores, $recurse);
  $matches = _hotfolder_file_scan_directory($watch, '/' . $pattern . '/', $ignores, $recurse);
  $not_matched = count($all) - count($matches);
  _hotfolder_watchdog('hotfolder', '@matched file(s) matched in folder.', array('@matched' => count($matches)), WATCHDOG_DEBUG);
  _hotfolder_watchdog('hotfolder', '@matched file(s) NOT matched in folder.', array('@matched' => $not_matched ), WATCHDOG_DEBUG);
  // Process detected files.
  foreach ($matches as $file_uri => $file) {
    if (!empty($file_uri) && !in_array($file_uri, $processed_files)) {
      $filename = basename($file_uri);
      // Create a job.
      $job = new stdClass();
      $job->type = 'job_record';
      node_object_prepare($job);
      $job->title = $filename;
      $job->language = $lang = LANGUAGE_NONE;
      $job->uid = $config->uid;
      node_save($job);
      _hotfolder_set_status($job, 'ready');
      _hotfolder_set_stage($job, _hotfolder_first_stage());
      // Update the title.
      $job->title = t('Job #@nid - @title', array('@nid' => $job->nid, '@title' => $job->title));
      // Save the name of the original dropoff file.
      $job->field_pickup_filename[$lang][0]['value'] = $filename;
      // Attach the watch.
      $job->field_job_record_watch[$lang][0]['target_id'] = $config->nid;
      // Why? Timing issues if the config is changed after job dropped,
      // before job completed. Save the original watch configuration folder
      // so the job can locate it's submitted and done folders.
      $job->field_orig_watch_config_folder[$lang][0]['value'] = $watch;
      // Attach actions to job from configuration.
      $job->field_job_record_actions = $config->field_watch_config_actions;
      // Settings.
      $job->field_watch_config_delete[$lang][0]['value'] = $delete;
      // Job is created, now to pick up the file.
      // Create the file object.
      $file = array(
        'uid' => 1,
        'uri' => $file_uri,
        'filemime' => file_get_mimetype($file_uri),
        'status' => 1,
        'display' => TRUE,
      );
      // Check if we need to move the file, and if so if successful.
      $moved = FALSE;
      $use_internal = variable_get('hotfolder_internal_folders', TRUE);
      if ($use_internal) {
        $folder_path = variable_get('hotfolder_submitted_folder', 'hotfolder_submitted');
        $moved = _hotfolder_move_file($file, $watch . '/' . $folder_path);
      }
      else {
        $file = file_save((object) $file);
        if ($file) {
          $moved = TRUE;
        }
      }
      // Attach the file to the job.
      if ($moved) {
        $job->field_job_record_source_file[$job->language][0] = (array) $file;
        $jobs[] = $job;
        _hotfolder_watchdog('hotfolder', 'Added job for file @file.', array('@file' => $file_uri), WATCHDOG_NOTICE);
      }
      node_save($job);
      _hotfolder_trigger('hotfolder_set_job', $job);
      $processed_files[] = $file_uri;
    } // End if file exists or not already added check.
  }
  // @todo: What do we do if a file just SITS in here cause there is no
  // matching config to it? Is it an orphan?
  // Check vs. file age and if old move to questionable?
  _hotfolder_watchdog('hotfolder', 'Add job routine complete on job directory: @directory.', array('@directory' => $watch), WATCHDOG_DEBUG);
  return $jobs;
}

/**
 * Process configured job per file. Called by cron_queue.
 */
function _hotfolder_process_job($job, $allow_add = TRUE) {
  // Load the job.
  $job = node_load($job->nid);
  // Accounts for if the job was deleted before execution.
  if (!$job) {
    _hotfolder_watchdog('hotfolder', 'Queued job was not found. Job may have been deleted while waiting in queue.', WATCHDOG_WARNING);
    // Short circuit. Return early.
    return;
  }
  _hotfolder_trigger('hotfolder_call_job', $job);
  _hotfolder_watchdog('hotfolder', 'Processing job #@nid.', array('@nid' => $job->nid), WATCHDOG_DEBUG);
  // Check job status for go ahead. If not, short circuit and return.
  if (_hotfolder_is_status($job, 'in progress')) {
    _hotfolder_watchdog('hotfolder', 'Job #@nid was not processed: Already in progress.', array('@nid' => $job->nid), WATCHDOG_WARNING);
    return;
  }
  if (_hotfolder_is_status($job, 'error')) {
    _hotfolder_watchdog('hotfolder', 'Job #@nid was not processed: Job is in error.', array('@nid' => $job->nid), WATCHDOG_WARNING);
    return;
  }
  if (_hotfolder_is_status($job, 'complete')) {
    _hotfolder_watchdog('hotfolder', 'Job #@nid was not processed: Already completed.', array('@nid' => $job->nid), WATCHDOG_WARNING);
    return;
  }
  if (!_hotfolder_is_status($job, 'ready')) {
    _hotfolder_watchdog('hotfolder', 'Job #@nid was not processed: Unknown status / not ready.', array('@nid' => $job->nid), WATCHDOG_WARNING);
    return;
  }
  // Check for max threads.
  if (variable_get('hotfolder_threading', TRUE)) {
    $max_threads = variable_get('hotfolder_threading_max', 16);
    $current_threads = variable_get('hotfolder_threading_current', 0);
    if ($current_threads >= $max_threads) {
      // We have too many jobs on the stack already put this one back in the queue.
      _hotfolder_watchdog('hotfolder', 'Job #@job-nid put back into queue for retry. Already at max threads.',
        array('@job-nid' => $job->nid), WATCHDOG_NOTICE);
      if ($allow_add) {
        _hotfolder_add_jobs_to_queue(array($job));
      }
      return;
    }
  }
  else {
    // We aren't threading, make sure the counts are set correctly.
    variable_set('hotfolder_threading_current', 0);
  }
  // Set job status as in progress. (To prevent multiple workers on the same job.)
  _hotfolder_job_log($job, 'hotfolder', 'Job #@job-nid pass started.', array('@job-nid' => $job->nid), WATCHDOG_NOTICE);
  _hotfolder_set_status($job, 'in progress');
  // Check configured actions, perform each.
  // When the job was created the actions were assigned, so no need to look back
  // at the configuration. This is to avoid timing error if configs are changed
  // mid flight.
  $action_set = array();
  if (isset($job->field_job_record_actions[$job->language])) {
    foreach ($job->field_job_record_actions[$job->language] as $action) {
      $action_set[] = _hotfolder_action_config_expand_action_config($action['action_settings']);
    }
  }
  // Context is scratch space.
  // Context can change with each stage progression. Users of the API should
  // watch carefully for conflicts between modules using context if they want to
  // use actions from multiple modules. Context uses action setting deltas to
  // keep the processes separated from each other, but users of the API should
  // always check the error state for each action just in case. Context sleep
  // set to true will allow all actions for this stage finish, then pause the
  // job to pick up on the next cron.
  $context = array(
    'job' => $job,
    'error' => FALSE,
    'error_message' => FALSE,
  );
  // Process the stages.
  _hotfolder_loop_process($job, $context, $action_set, $allow_add);
  // Done.
  _hotfolder_watchdog('hotfolder', 'Job #@nid : Done for this cron pass.', array('@nid' => $job->nid), WATCHDOG_DEBUG);
}

/**
 * Loop through all available stages.
 */
function _hotfolder_loop_process($job, $context, $action_set, $allow_add = TRUE) {
  // Gather data.
  $stages = _hotfolder_stages();
  $first_stage = _hotfolder_first_stage();
  $last_stage = _hotfolder_last_stage();
  $start_stage = _hotfolder_get_field_value($job, 'field_job_record_stage', $first_stage);
  // If the stage isn't in stages.
  if (!in_array($start_stage, array_keys($stages))) {
    _hotfolder_set_status($job, 'error');
    _hotfolder_job_log($job, 'hotfolder', 'Job #@job-nid is in an unrecognized status. It has NOT been put back into queue for retry.',
      array('@job-nid' => $job->nid), WATCHDOG_NOTICE);
  }
  // Loop through each stage.
  $in_progress = FALSE;
  set_time_limit(variable_get('hotfolder_timeout', 30));
  foreach ($stages as $stage_name => $stage) {
    // ONLY do things if we're in progress, not in error.
    if (($in_progress || $stage_name == $start_stage) && (!_hotfolder_is_status($job, 'error'))) {
      // Mark as picking up.
      $in_progress = TRUE;
      // Do special stuff before the first stage.
      if ($stage_name == $first_stage) {
        // Mark the thread.
        if (variable_get('hotfolder_threading', TRUE)) {
          $current_threads = variable_get('hotfolder_threading_current', 0);
          ++$current_threads;
          variable_set('hotfolder_threading_current', $current_threads);
        }
      }
      // Run this stage.
      _hotfolder_set_stage($job, $stage_name);
      if (!_hotfolder_execute_stage($job, $context, $action_set, $stage_name, $allow_add)) {
        _hotfolder_job_log($job, 'hotfolder', 'Job #@job-nid break at @stage.',
          array('@job-nid' => $job->nid, '@stage' => $stage_name), WATCHDOG_NOTICE);
        _hotfolder_watchdog('hotfolders', 'Break at @stage.', array('@stage' => $stage_name), WATCHDOG_DEBUG);
        $in_progress = FALSE;
        // If we broke in the first stage, then do some more special stuff.
        if ($stage_name == $first_stage) {
          // Unmark the thread.
          if (variable_get('hotfolder_threading', TRUE)) {
            $current_threads = variable_get('hotfolder_threading_current', 0);
            --$current_threads;
            $current_threads = ($current_threads > 0) ? $current_threads : 0;
            variable_set('hotfolder_threading_current', $current_threads);
            _hotfolder_watchdog('hotfolder', 'Currently active thread count is @count.', array('@count' => $current_threads), WATCHDOG_DEBUG);
          }
        }
      }
      // And save the job after each action.
      node_save($job);
    } // End if for a stage pass.
  } // End foreach stage.
  // Handle the after pass.
  _hotfolder_job_log($job, 'hotfolder', 'Job #@job-nid pass ended.', array('@job-nid' => $job->nid), WATCHDOG_NOTICE);
  // And save the job.
  node_save($job);
  // After the pass, update the status for the job.
  // If we're in error, or in the last stage, then we're done.
  if (_hotfolder_is_stage($job, $last_stage) || _hotfolder_is_status($job, 'error')) {
    // Mark as complete if we're not in error.
    if (!_hotfolder_is_status($job, 'error')) {
      _hotfolder_set_status($job, 'complete');
    }
    // Check for max threads.
    if (variable_get('hotfolder_threading', TRUE)) {
      $current_threads = variable_get('hotfolder_threading_current', 0);
      --$current_threads;
      // Make sure we never go below zero threads.
      $current_threads = ($current_threads > 0) ? $current_threads : 0;
      variable_set('hotfolder_threading_current', $current_threads);
      _hotfolder_watchdog('hotfolder', 'Currently active thread count is @count.', array('@count' => $current_threads), WATCHDOG_DEBUG);
    }
    // Find out if we're moving files or not.
    $use_internal = variable_get('hotfolder_internal_folders', TRUE);
    if ($use_internal) {
      $fid = _hotfolder_get_field_fid($job, 'field_job_record_source_file');
      if (!empty($fid)) {
        $file = file_load($fid);
        // Then move original file from submitted folder to done folder.
        $field_watch_folder = $job->field_orig_watch_config_folder[$job->language][0]['value'];
        $folder_path = $field_watch_folder . '/' . variable_get('hotfolder_done_folder', 'hotfolder_done');
        $folder_path = file_stream_wrapper_uri_normalize($folder_path);
        _hotfolder_move_file($file, $folder_path);
      }
      else {
        _hotfolder_watchdog('hotfolders', 'Done file #@fid not found.', array('@fid' => $fid), WATCHDOG_ERROR);
      }
    }
    // And save the job.
    node_save($job);
    // Delete the job if that's what we want at the end.
    if (_hotfolder_is_status($job, 'complete')) {
      $delete = _hotfolder_get_field_value($job, 'field_watch_config_delete', FALSE);
      if ($delete) {
        node_delete($job->nid);
        _hotfolder_watchdog('hotfolder', 'Job #@nid : Deleted after completion.', array('@nid' => $job->nid), WATCHDOG_NOTICE);
      }
    }
  }
}

/**
 * Execute the transition from one stage to another, calling triggers and sleep on the way.
 */
function _hotfolder_execute_stage(&$job, &$context, $action_set, $stage, $allow_add = TRUE) {
  // Handle pre triggers.
  _hotfolder_trigger('hotfolder_' . $stage . '_pre', $job);
  $sleep = $retry = $error = FALSE;
  $sleep_stage = '';
  $context[$stage] = array(); 
  // Process each action.
  foreach ($action_set as $action_index => $action_settings) {
    $action_callback = isset($action_settings[$stage . '_callback']) ? $action_settings[$stage . '_callback'] : '';
    if (!$sleep && !empty($action_callback) && function_exists($action_callback) && $context['error'] == FALSE) {
      if (empty($context['job']) || $context['error'] == TRUE) {
        // Check for obvious error situations - no job available or already in error.
         $context['error'] = TRUE;
         $context['message'] = 'No job configuration found.';
      }
      else {
        // No error? Call our callback.
        $result = call_user_func_array($action_callback, array($action_settings, $context));
        $context = array_merge($context, $result);
      }
      // Handle sleep settings.
      if (isset($context['sleep']) && !empty($context['sleep'])) {
        $sleep = TRUE;
        $sleep_stage = $context['sleep'];
      }
      // Handle errors.
      if (isset($context['error']) && !empty($context['error'])) {
        $error = TRUE;
        $action_name = isset($action_settings['human_name']) ? $action_settings['human_name'] : t('Unknown action.');
        $message = isset($context['message']) ? $context['message'] : t('Unknown error.');
        $nid = isset($job->nid) ? $job->nid : t('UNK');
        _hotfolder_job_log($job, 'hotfolder',
          'An error was detected in @stage action @action_name (@action_callback) while processing job #@job-nid: @error_message',
          array('@stage' => $stage, '@action_name' => $action_name, '@action_callback' => $action_callback,
            '@job-nid' => $nid, '@error_message' => $message),
          WATCHDOG_WARNING);
        // Figure out what to do now that we have an error.
        if (variable_get('hotfolder_error_retry', TRUE)) {
          $retries = _hotfolder_get_field_value($job, 'field_job_record_retries', 0);
          if ($retries < variable_get('hotfolder_error_retry_max', 3)) {
            $retry = TRUE;
          }
        }
      }
    }
  }
  // Set post triggers.
  _hotfolder_trigger('hotfolder_' . $stage . '_post', $job);
  // Determine response.
  $stage_status = TRUE;
  if ($sleep == TRUE) {
    // Check for sleeping.
    _hotfolder_set_stage($job, $sleep_stage);
    _hotfolder_set_status($job, 'ready');
    _hotfolder_job_log($job, 'hotfolder', 'Job #@job-nid has been put to sleep for later.',
      array('@job-nid' => $job->nid), WATCHDOG_DEBUG);
    if ($allow_add) {
      _hotfolder_add_jobs_to_queue(array($job));
    }
    $stage_status = FALSE;
  }
  elseif ($retry == TRUE) {
    // Only retry if we want to enable retries.
    $job->field_job_record_retries[$job->language][0]['value']++;
    // Check for retries.
    _hotfolder_set_status($job, 'ready');
    _hotfolder_job_log($job, 'hotfolder', 'Job #@job-nid put back into queue for retry.', array('@job-nid' => $job->nid), WATCHDOG_DEBUG);
    if ($allow_add) {
      _hotfolder_add_jobs_to_queue(array($job));
    }
    $stage_status = FALSE;
  }
  elseif ($error == TRUE) {
    // Check for errors.
    _hotfolder_set_status($job, 'error');
    _hotfolder_job_log($job, 'hotfolder', 'Job #@job-nid has NOT been put back into queue for retry.', array('@job-nid' => $job->nid), WATCHDOG_DEBUG);
    $stage_status = FALSE;
  }
  // Save the job at this point with updates and continue on.
  return $stage_status;
}

/**
 * Helper function, trigger actions and rules as job processes.
 */
function _hotfolder_trigger($op, $job) {
  // Run actions.
  if (function_exists('trigger_get_assigned_actions') && function_exists('actions_do')) {
    _hotfolder_watchdog('hotfolder', 'Triggers for @op triggered.', array('@op' => $op), WATCHDOG_DEBUG);
    $aids = trigger_get_assigned_actions('hotfolder');
    if (!$aids) {
      return;
    }
    $context = array(
      'group' => 'hotfolder',
      'hook' => $op,
    );
    actions_do($aids, $job, $context);
  }
  // Run rules.
  if (function_exists('rules_invoke_event')) {
    // Get the watch.
    $watch = _hotfolder_get_field_target_id($job, 'field_job_record_watch');
    $watch = node_load($watch);
    // Run the rule.
    _hotfolder_watchdog('hotfolder', 'Rules for @op triggered.', array('@op' => $op), WATCHDOG_DEBUG);
    rules_invoke_event($op, $job, $watch);
  }
}

/**
 * Helper function, mute debug watchdog messages.
 */
function _hotfolder_watchdog($type, $message, $variables = array(), $severity = WATCHDOG_NOTICE, $link = NULL) {
  if (_hotfolder_log_level($severity)) {
    $verbose = variable_get('hotfolder_error_verbose', FALSE);
    if ($verbose) {
      $mess_type = 'status';
      if ($severity <= WATCHDOG_WARNING) {
        $mess_type = 'warning';
      }
      if ($severity <= WATCHDOG_ERROR) {
        $mess_type = 'error';
      }
      $variables = (array) $variables;
      drupal_set_message(t($message, $variables), $mess_type);
    }
    watchdog($type, $message, $variables, $severity, $link);
  }
}

/**
 * Log error messages for jobs.
 */
function _hotfolder_job_log($job, $type, $message, $variables = array(), $severity = WATCHDOG_NOTICE, $link = NULL) {
  // Send to watchdog.
  _hotfolder_watchdog($type, $message, $variables, $severity, $link);
  // And handle the job log.
  if (_hotfolder_log_level($severity)) {
    // Grab only the last X number of logs.
    $max_log = variable_get('hotfolder_job_log_length', 2000);
    $log = !empty($job->field_job_log[$job->language][0]['value']) ? $job->field_job_log[$job->language][0]['value'] : '';
    // Trim log roughly within X characters of log.
    if (strlen($log) > $max_log) {
      $position = strrpos($log, "\n", $max_log);
      $log = substr($log, $position);
    }
    // Update log.
    $variables = (array) $variables;
    $log_message = "\n" . date('[Y-m-d H:i:s] ') . t($message, $variables);
    $job->field_job_log[$job->language][0]['value'] = $log . $log_message;
    node_save($job);
  }
}

/**
 * Helper function, check for signifigance for log.
 */
function _hotfolder_log_level($severity = WATCHDOG_NOTICE) {
  $level = variable_get('hotfolder_error_reporting', HOTFOLDERS_LOG_PART);
  if ($level > HOTFOLDERS_LOG_NONE) {
    if ($level >= $severity) {
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Helper function, set stage.
 */
function _hotfolder_set_stage($job, $stage) {
  _hotfolder_watchdog('hotfolder', 'Job #@nid : Stage @stage.', array('@nid' => $job->nid, '@stage' => $stage), WATCHDOG_DEBUG);
  $job->field_job_record_stage[$job->language][0]['value'] = $stage;
  node_save($job);
}

/**
 * Helper function, set status.
 */
function _hotfolder_set_status($job, $status) {
  _hotfolder_watchdog('hotfolder', 'Job #@nid : Status @sstatus.', array('@nid' => $job->nid, '@sstatus' => $status), WATCHDOG_DEBUG);
  $job->field_job_record_status[$job->language][0]['value'] = $status;
  _hotfolder_trigger('hotfolder_' . $status . '_status', $job);
  node_save($job);
}

/**
 * Helper function, get statuses.
 */
function _hotfolder_statuses() {
  return array(
    'ready' => array(
      'status' => 'ready',
      'human name' => 'ready',
    ),
    'in progress' => array(
      'status' => 'in progress',
      'human name' => 'in progress',
    ),
    'complete' => array(
      'status' => 'complete',
      'human name' => 'complete',
    ),
    'error' => array(
      'status' => 'error',
      'human name' => 'error',
    ),
  );
}

/**
 * Helper function, get stages.
 */
function _hotfolder_stages() {
  $stages = array(
    'prep' => array(
      'stage' => 'prep',
      'human name' => 'prep',
      'prep stage' => TRUE,
    ),
    'creation' => array(
      'stage' => 'creation',
      'human name' => 'creation',
      'prep stage' => FALSE,
    ),
    'post_creation' => array(
      'stage' => 'post_creation',
      'human name' => 'post creation',
      'prep stage' => FALSE,
    ),
    'drop_off' => array(
      'stage' => 'drop_off',
      'human name' => 'drop off',
      'prep stage' => FALSE,
    ),
    'cleanup' => array(
      'stage' => 'cleanup',
      'human name' => 'cleanup',
      'prep stage' => FALSE,
    ),
    'done' => array(
      'stage' => 'done',
      'human name' => 'done',
      'prep stage' => FALSE,
    ),
  );
  // Allow other modules to meddle.
  drupal_alter('hotfolder_stages', $stages);
  return $stages;
}

/**
 * Helper function, get first stage.
 */
function _hotfolder_first_stage() {
  $stages = _hotfolder_stages();
  $first = array_shift($stages);
  return $first['stage'];
}

/**
 * Helper function, get last stage.
 */
function _hotfolder_last_stage() {
  $stages = _hotfolder_stages();
  $last = array_pop($stages);
  return $last['stage'];
}

/**
 * Helper function, get the schema.
 */
function _hotfolder_get_schemas() {
  static $streams = array();
  if (!empty($streams)) {
    return $streams;
  }
  // Load the taxonomy.
  $vocabulary = taxonomy_vocabulary_machine_name_load('hotfolder_streams');
  if (empty($vocabulary)) {
    // We don't have the hotfolder_streams vocab setup. Set it up.
    _hotfolder_create_vocab();
  }
  taxonomy_terms_static_reset();
  $terms = taxonomy_term_load_multiple(array(), array('vid' => $vocabulary->vid));
  foreach ($terms as $tid => $term) {
    // Correct formatting.
    $name = str_replace('://', '', $term->name) . '://';
    $path = _hotfolder_get_field_value($term, 'field_stream_folder');
    $path = rtrim($path, '/');
    $streams[$name] = $path;
  }
  return $streams;
}

/**
 * Helper function.
 */
function _hotfolder_is_stage($job, $stage) {
  $current_stage = _hotfolder_get_field_value($job, 'field_job_record_stage');
  if ($current_stage == $stage) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Helper function.
 */
function _hotfolder_is_status($job, $status) {
  $current_status = _hotfolder_get_field_value($job, 'field_job_record_status');
  if ($current_status == $status) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Helper function, get the watch folder.
 */
function _hotfolder_get_watchfolder($config) {
  // Get stream.
  $stream = $config->field_watch_config_scheme[$config->language][0]['tid'];
  $stream = taxonomy_term_load($stream);
  $stream = str_replace('://', '', $stream->name);
  // Get watch.
  $watch = $config->field_watch_config_folder[$config->language][0]['value'];
  $watch = $stream . '://' . $watch;
  // Normalize the file path here, so that it can be used as a base in all other sub folders.
  // This will add public:// if it wasn't added in the original configuration.
  if (!file_stream_wrapper_valid_scheme($stream)) {
    $watch = file_build_uri($watch);
  }
  $watch = file_stream_wrapper_uri_normalize($watch);
  return $watch;
}

/**
 * Helper function, get the filepath.
 */
function _hotfolder_get_src_file($job, $get = 'uri') {
  // Settings are not reliable between long runs, reconstruct information.
  $this_file = _hotfolder_get_field_file($job, 'field_job_record_source_file');
  if (!empty($this_file)) {
    $file = drupal_realpath($this_file['uri']);
    // Make sure the file exists.
    if (file_exists($file) && is_file($file) && is_readable($file)) {
      return !empty($this_file[$get]) ? $this_file[$get] : '';
    }
    else {
      if (!file_exists($file)) {
        _hotfolder_watchdog('hotfolder', '@file found at job #@nid does not exist.',
          array('@file' => $file, '@nid' => $job->nid), WATCHDOG_WARNING);
      }
      if (!is_file($file)) {
        _hotfolder_watchdog('hotfolder', '@file found at job #@nid is not a file.',
          array('@file' => $file, '@nid' => $job->nid), WATCHDOG_WARNING);
      }
      if (!is_readable($file)) {
        _hotfolder_watchdog('hotfolder', '@file found at job #@nid is not readable.',
          array('@file' => $file, '@nid' => $job->nid), WATCHDOG_WARNING);
      }
    }
  }
  else {
    _hotfolder_watchdog('hotfolder', 'No source file found at job #@nid',
      array('@nid' => $job->nid), WATCHDOG_WARNING);
  }
  return FALSE;
}

/**
 * Helper function, get the field value.
 */
function _hotfolder_get_field_value($node, $field, $default = '') {
  $lang = !empty($node->language) ? $node->language : 'und';
  return isset($node->{$field}[$lang][0]['value']) ? $node->{$field}[$lang][0]['value'] : $default;
}

/**
 * Helper function, get the field target_id.
 */
function _hotfolder_get_field_target_id($node, $field, $default = '') {
  $lang = !empty($node->language) ? $node->language : 'und';
  return isset($node->{$field}[$lang][0]['target_id']) ? $node->{$field}[$lang][0]['target_id'] : $default;
}

/**
 * Helper function, get the field file info.
 */
function _hotfolder_get_field_fid($node, $field, $default = '') {
  $lang = !empty($node->language) ? $node->language : 'und';
  return isset($node->{$field}[$lang][0]['fid']) ? $node->{$field}[$lang][0]['fid'] : $default;
}

/**
 * Helper function, get the field file info.
 */
function _hotfolder_get_field_file($node, $field, $default = array()) {
  $lang = !empty($node->language) ? $node->language : 'und';
  return isset($node->{$field}[$lang][0]) ? $node->{$field}[$lang][0] : $default;
}

/**
 * Helper function, move a file to a path making sure path exists.
 */
function _hotfolder_move_file(&$file, $path) {
  $file = (object) $file;
  // First check for a path.
  if (!is_dir($path)) {
    _hotfolder_watchdog('hotfolder', 'Creating folder @path', array('@path' => $path), WATCHDOG_WARNING);
    file_prepare_directory($path, FILE_CREATE_DIRECTORY);
  }
  // Then move the file.
  $old_path = $file->uri;
  $new_path = $path . '/' . basename($file->uri);
  _hotfolder_watchdog('hotfolder', 'Attempting to move @file to folder @folder.',
    array('@file' => $old_path, '@folder' => $new_path), WATCHDOG_NOTICE);
  $file = file_move($file, $new_path, FILE_EXISTS_RENAME);
  if ($file) {
    _hotfolder_watchdog('hotfolder', 'Moved @file to folder @folder.',
      array('@file' => $old_path, '@folder' => $new_path), WATCHDOG_DEBUG);
    return TRUE;
  }
  else {
    _hotfolder_watchdog('hotfolders', 'File @file unable to be moved to @folder.',
      array('@file' => $old_path, '@folder' => $new_path), WATCHDOG_ERROR);
    return FALSE;
  }
}

/**
 * Helper function, allow for recursive dir scans accounting for dir path for ignores settings.
 */
function _hotfolder_file_scan_directory($dir, $mask, $ignores = array(), $recurse = FALSE) {
  // Now, ignores will include a full from schema uri.
  // But we need to make sure we only use them as needed.
  $this_ignore = array();
  $target_dir = file_uri_target($dir);
  $target_dir = rtrim($target_dir, '/');
  foreach ($ignores as $index => $file_uri) {
    // Only ignore if this file is in the same directory as given.
    $ignore_dir = file_uri_target($file_uri);
    $ignore_dir = dirname($ignore_dir);
    if ($target_dir == $ignore_dir) {
      $this_ignore[] = basename($file_uri);
    }
  }
  // Ok, ready to set things up for the scan.
  $this_ignore[] = '\.\.?';
  $this_ignore[] = 'CVS';
  $options = array(
    'nomask' => '/(' . implode('|', $this_ignore) . ')$/',
    'recurse' => FALSE,
  );
  // Do the current.
  $files = file_scan_directory($dir, $mask, $options);
  // Do the children if recursive.
  if ($recurse && is_dir($dir) && $handle = opendir($dir)) {
    while (FALSE !== ($filename = readdir($handle))) {
      if ($filename[0] != '.' && !in_array($filename, $this_ignore)) { // Ignore hidden and ignores.
        $uri = $dir . '/' . $filename;
        $uri = file_stream_wrapper_uri_normalize($uri);
        if (is_dir($uri)) {
          $files = array_merge(_hotfolder_file_scan_directory($uri, $mask, $ignores, $recurse), $files);
        }
      }
    }
    closedir($handle);
  }
  return $files;
}

/**
 * Helper function, get the correct filepath.
 */
function _hotfolder_realpath($path) {
  // Translate the path as needed between types of path given.
  if (DIRECTORY_SEPARATOR == '\\') {
    $path = str_replace('/', DIRECTORY_SEPARATOR, $path);
  }
  if (DIRECTORY_SEPARATOR == '/') {
    $path = str_replace('\\', DIRECTORY_SEPARATOR, $path);
  }
  return $path;
}

/**
 * Get watchfolder configurations.
 */
function _hotfolder_get_watch_configs() {
  $query = db_select('node', 'n');
  $query->fields('n', array('nid'))
    ->condition('n.type', 'watch_configuration')
    ->addTag('node_access')
    ->orderBy('n.created', 'DESC');
  $result = $query->execute();
  $watches = array();
  foreach ($result as $row) {
    if (!empty($row->nid)) {
      $watches[$row->nid] = node_load($row->nid);
    }
  }
  return $watches;
}

/**
 * Get watchfolder configurations.
 */
function _hotfolder_get_detected_files($watch_folder = '') {
  // Get all associated files for jobs in the system.
  // Filter by associated watch, if we have one.
  $sql = 'SELECT f.uri FROM file_managed f '.
    'LEFT JOIN field_data_field_job_record_source_file j ON j.field_job_record_source_file_fid = f.fid';
  $sql_args = array();
  if (!empty($watch)) {
    $sql .= ' ' .
      'LEFT JOIN field_data_field_orig_watch_config_folder w ' .
      'ON w.entity_id = j.entity_id AND  w.revision_id = j.revision_id ' .
      'WHERE w.field_orig_watch_config_folder_value = :watch_folder';
    $sql_args = array(':watch_folder' => $watch_folder);
  }
  $results = db_query($sql, $sql_args);
  $files = array();
  foreach ($results as $row) {
    if (!empty($row->uri)) {
      // Note: this path includes the schema in the uri.
      $files[] = $row->uri;
    }
  }
  return $files;
}

/**
 * Count how many jobs in the db.
 */
function _hotfolder_count_jobs() {
  return db_query('SELECT COUNT(item_id) FROM {queue} WHERE name = \'hotfolder_queue\' AND expire = 0')->fetchField();
}

/**
 * Helper function, make sure we have a working hotfolder stream taxonomy.
 */
function _hotfolder_create_vocab() {
  $vocabulary = new stdClass();
  $vocabulary->name = t('Hotfolder Streams');
  $vocabulary->machine_name = 'hotfolder_streams';
  $vocabulary->description = t('Streams for use with the Hotfolder Module');
  $vocabulary->hierarchy = 0;
  taxonomy_vocabulary_save($vocabulary);
  $vocabulary = taxonomy_vocabulary_machine_name_load('hotfolder_streams');
  // Remove existing fields if they exist.
  field_delete_field('field_stream_folder');
  // And add the field instance to the vocabulary.
  module_load_include('inc', 'hotfolder', 'hotfolder.features.field_base');
  $field_bases = hotfolder_field_default_field_bases();
  field_create_field($field_bases['field_stream_folder']);
  module_load_include('inc', 'hotfolder', 'hotfolder.features.field_instance');
  $field_instances = hotfolder_field_default_field_instances();
  field_create_instance($field_instances['taxonomy_term-hotfolder_streams-field_stream_folder']);
  // Now create our first two terms if we don't have them.
  $public = new stdClass();
  $public->name = 'public://';
  $public->description = t('Public file stream.');
  $public->vid = $vocabulary->vid;
  $public->field_stream_folder['und'][0]['value'] = '/';
  taxonomy_term_save($public);
  $private = new stdClass();
  $private->name = 'private://';
  $private->description = t('Private file stream.');
  $private->vid = $vocabulary->vid;
  $private->field_stream_folder['und'][0]['value'] = '/';
  taxonomy_term_save($private);
}
