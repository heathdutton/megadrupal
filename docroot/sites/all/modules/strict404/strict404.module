<?php

/**
 * implements hook_menu
 * @return array
 */
function strict404_menu() {
  $items['admin/config/strict404'] = array(
    'title' => 'Strict 404 Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('strict404_admin_settings'),
    'access arguments' => array('administer site configuration'),
  );
  
  return $items;
}

/**
 * callback for admin settings form
 * @return type
 */
function strict404_admin_settings() {
  $form['description'] = array(
    '#markup' => t('By default Drupal accepts optional arguments on any system path (e.g. !example) instead of returning 404 Not Found. ', array('!example' => l('/admin/any/random/path/arguments', 'admin/any/random/path/arguments')))
      . t('Strict 404 overrides this behavior and returns 404 Page Not Found for paths with optional arguments. ')
      . t('Some modules rely on the default behavior for administration pages so it is normally not recommended to enable Strict 404 on an entire site but to instead enforce it only on certain path patterns (usually vistor-facing pages).')
  );
  $form['strict404_patterns'] = array(
    '#type' => 'textarea',
    '#title' => t('Path patterns'),
    '#description' => t('Enforce strict 404 when any of the patterns above match the current page path. Put each path on a separate line. You can use the "*" character as a wildcard and ~ to exclude one or more paths. Use &lt;front&gt; for the site front page.'),
    '#default_value' => variable_get('strict404_patterns', '*'),
  );
  return system_settings_form($form);  
}

/**
 * implements hook_site_status_alter
 * @param string $menu_site_status
 * @param type $path
 */
function strict404_menu_site_status_alter(&$menu_site_status, $path) {
  //if the current path is not exact match for a menu item and if strict 404 should be enforced, return 404
  $item = menu_get_item();
  if ($_GET['q'] != $item['href'] && strict404_match_path_current(variable_get('strict404_patterns', '*'))) {
    $menu_site_status = MENU_NOT_FOUND;
  }
}

/**
 * match the current request path against enabled strint 404 patterns
 * @param type $patterns
 * @return type
 */
function strict404_match_path_current($patterns) {
  // Include both the path alias and system path for matching.
  $current_path = array(drupal_get_path_alias($_GET['q']));
  if ($current_path[0] != $_GET['q']) {
    $current_path[] = $_GET['q'];
  }
  
  return strict404_match_path($current_path, $patterns, TRUE);
}

/**
 * Match the subject against a set of regex patterns.
 * Similar to drupal_match_path() but also handles negation through the use
 * of the ~ character.
 *
 * @param mixed $subject
 *   The subject string or an array of strings to be matched.
 * @param array $patterns
 *   An array of patterns. Any patterns that begin with ~ are considered
 *   negative or excluded conditions.
 * @param boolean $path
 *   Whether the given subject should be matched as a Drupal path. If TRUE,
 *   '<front>' will be replaced with the site frontpage when matching against
 *   $patterns.
 */
function strict404_match_path($subject, $patterns, $path = FALSE) {
  static $regexps;
  
  //parse patterns string  
  $items = explode("\n", $patterns);
  $patterns = array();
  if (!empty($items)) {
    foreach ($items as $v) {
      $v = trim($v);
      if (!empty($v)) {
        $patterns[$v] = $v;
      }
    }
  }
  
  $match = FALSE;
  $positives = $negatives = 0;
  $subject = !is_array($subject) ? array($subject) : $subject;
  foreach ($patterns as $pattern) {
    if (strpos($pattern, '~') === 0) {
      $negate = TRUE;
      $negatives++;
    }
    else {
      $negate = FALSE;
      $positives++;
    }
    $pattern = ltrim($pattern, '~');
    if (!isset($regexps[$pattern])) {
      if ($path) {
        $regexps[$pattern] = '/^(' . preg_replace(array('/(\r\n?|\n)/', '/\\\\\*/', '/(^|\|)\\\\<front\\\\>($|\|)/'), array('|', '.*', '\1' . preg_quote(variable_get('site_frontpage', 'node'), '/') . '\2'), preg_quote($pattern, '/')) . ')$/';
      }
      else {
        $regexps[$pattern] = '/^(' . preg_replace(array('/(\r\n?|\n)/', '/\\\\\*/'), array('|', '.*'), preg_quote($pattern, '/')) . ')$/';
      }
    }
    foreach ($subject as $value) {
      if (preg_match($regexps[$pattern], $value)) {
        if ($negate) {
          return FALSE;
        }
        $match = TRUE;
      }
    }
  }
  // If there are **only** negative conditions and we've gotten this far none
  // we actually have a match.
  if ($positives === 0 && $negatives) {
    return TRUE;
  }
  return $match;
}


/**
 * the functions below were used in the past before we had hook_site_status_alter
 * which is a cleaner way to make our 404 check.  But keeping the code just in case
function strict404_menu_alter(&$items) {
  foreach ($items as $path => &$item) {
   if (is_array($item['page arguments'])) {
      array_unshift($item['page arguments'], $item['page callback']);
    }
    else {
      $item['page arguments'] = array($item['page callback']);
    }
    $item['page callback'] = 'strict404_callback_check';  
  }
  menu_execute_active_handler($path);
}

function strict404_callback_check() {
  $item = menu_get_item();
  $status = drupal_get_http_header("status");
  if ($status != '404 Not Found' && $_GET['q'] != $item['href']) {
    if (strict404_match_path_current(variable_get('strict404_patterns'))) {    
      return MENU_NOT_FOUND;
    }
  }
  
  $args = func_get_args();
  $func = array_shift($args);
  return call_user_func_array($func, $args);
}
 */