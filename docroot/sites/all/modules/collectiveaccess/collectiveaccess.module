<?php

/**
 * @file
 * CollectiveAccess API module that provides the basic interface between Drupal
 * and CollectiveAccess
 */

/**
 * Implement hook_entity_info().
 */
function collectiveaccess_entity_info() {
  $return = array(
    'collectiveaccess_instance' => array(
      'label' => t('CollectiveAccess instance'),
      'controller class' => 'EntityAPIControllerExportable',
      'entity class' => 'CollectiveAccessInstance',
      'base table' => 'collectiveaccess_instance',
      'fieldable' => FALSE,
      'exportable' => TRUE,
      'entity keys' => array(
        'id' => 'caid',
        'label' => 'description',
        'name' => 'name',
      ),
      'module' => 'collectiveaccess',
      'access callback' => 'collectiveaccess_instance_access',
      // Enable the entity API's admin UI.
      'admin ui' => array(
        'path' => 'admin/structure/collectiveaccess',
        'file' => 'collectiveaccess.admin.inc',
      ),
      'label callback' => 'entity_class_label',
    ),
  );
  return $return;
}

/**
 * Access callback for the collectiveaccess_instance entity.
 */
function collectiveaccess_instance_access($op, $entity, $account = NULL, $entity_type = 'collectiveaccess_instance') {
  return user_access('administer collectiveaccess');
}

/**
 * Implements hook_permission().
 */
function collectiveaccess_permission() {
  $permissions = array();
  $permissions['administer collectiveaccess'] = array(
    'title' => t('Administer CollectiveAccess'),
    'description' => t('Administer CollectiveAccess settings'),
  );
  return $permissions;
}

/**
 * Creates a CollectiveAccess instance
 *
 * If an instance with the same name already exists, an exception will be thrown.
 *
 * @return CollectiveAccessInstance
 *   Returns a new message type object.
 */
function collectiveaccess_instance_create($name, $values = array()) {
  // Make sure the name doesn't already exist, to prevent duplicate key error.
  if (collectiveaccess_instance_load($name)) {
    throw new Exception('CollectiveAccess instance ' . check_plain($name) . ' already exists.');
  }
  $values['name'] = $name;
  $return = entity_create('collectiveaccess_instance', $values);

  return $return;
}

/**
 * CollectiveAccess instance loader.
 *
 * @param $name
 *   (optional) The name for this CollectiveAccess instance.
 *   If no name is given all existing instances are returned.
 *
 * @return CollectiveAccessInstance
 *   Returns a fully-loaded collectiveaccess instance if a name is passed.
 *   Else an array containing all instances is returned.
 */
function collectiveaccess_instance_load($name = NULL) {
  // Replace dashes with underscores so this can be used as menu argument
  // loader too.
  $instances = entity_load_multiple_by_name('collectiveaccess_instance', isset($name) ? array(strtr($name, array('-' => '_'))) : FALSE);
  if (isset($name)) {
    return isset($instances[$name]) ? $instances[$name] : FALSE;
  }
  return $instances;
}

/**
 * Inserts or updates a CollectiveAccess instance object into the database.
 *
 * @param $instance
 *   The instance object to be inserted.
 *
 * @return
 *   Failure to write a record will return FALSE. Otherwise SAVED_NEW or
 *   SAVED_UPDATED is returned depending on the operation performed.
 */
function collectiveaccess_instance_save($instance) {
  return entity_save('collectiveaccess_instance', $instance);
}

/**
 * Deletes an existing CollectiveAccess instance.
 *
 * @param $message
 *   The instance object to be deleted.
 */
function collectiveaccess_instance_delete($instance) {
  return entity_delete('collectiveaccess_instance', $instance);
}

/**
 * Validate webservice URL for a CollectiveAccess instance
 */
function collectiveaccess_validate_webservice_url($webservice_url) {
  return preg_match('/^(http)(.*)(service\.php)$/', $webservice_url);
}

function collectiveaccess_get_instance_list() {
  $list = array();
  $instances = collectiveaccess_instance_load();
  if ($instances) {
    foreach ($instances as $name => $instance) {
      $list[$name] = $instance->description;
    }
  }
  return $list;
}

/**
 * Get a list of connector classes
 */
function collectiveaccess_get_connectors($reset = FALSE) {
  static $connectors;

  if (!$connectors || $reset) {
    $connectors = module_invoke_all('collectiveaccess_connector');
    if ($connectors) {
      // Remove connectors that don't have a valid class
      foreach ($connectors as $class => $label) {
        if (!class_exists($class)) {
          unset($connectors[$class]);
        }
      }
    }
  }

  return $connectors;
}

/**
 * Implements hook_collectiveaccess_connector().
 */
function collectiveaccess_collectiveaccess_connector() {
  return array(
    'CollectiveAccessSOAPConnector' => t('SOAP Webservice'),
    'CollectiveAccessRESTConnector' => t('REST Webservice'),
  );
}

/**
 * Get a list of available web service groups
 */
function collectiveaccess_get_services() {
  return array(
    'cataloguing' => 'Cataloguing',
    'iteminfo' => 'ItemInfo',
    'usercontent' => 'UserContent',
    'search' => 'Search',
    'browse' => 'Browse',
  );
}

/**
 * Helper function to temporarily store data retrieved from CollectiveAccess webservices
 */
function collectiveaccess_storage($item, $data = NULL) {
  $storage = &drupal_static(__FUNCTION__);
  // set data
  if (!isset($storage[$item]) && !empty($data)) {
    $storage[$item] = $data;
  }
  // get data
  if (!empty($storage[$item])) {
    return $storage[$item];
  }
  else {
    return FALSE;
  }
}

/**
 * Reset temporary storage
 */
function collectiveaccess_storage_reset($item) {
  drupal_static_reset($item);
}

/**
 * Helper function to get a list of item types that are available in CollectiveAccess.
 *
 * @return array with type information
 * Format: type name => information array
 * Array keys:
 * - name: readable name for type
 * - class: the class used to load an item of this type
 * - primary: whether this type can be used for first-class relations
 */
function collectiveaccess_get_types() {
  $types = array(
    'ca_objects' => array(
      'name' => t('Objects'),
      'class' => 'CollectiveAccessObject',
      'primary' => TRUE,
    ),
    'ca_entities' => array(
      'name' => t('Entities'),
      'class' => 'CollectiveAccessEntity',
      'primary' => TRUE
    ),
    'ca_list_items' => array(
      'name' => t('List Items'),
      'class' => 'CollectiveAccessListItem',
    ),
    'ca_sets' => array(
      'name' => t('Sets'),
      'class' => 'CollectiveAccessSets',
    ),
    /*'ca_places' => array(
      'name' => t('Places'),
      'primary' => TRUE,
    ),
    'ca_occurrences' =>
      array('name' => t('Occurrences'),
      'primary' => TRUE,
    ),
    'ca_collections' => array(
      'name' => t('Collections'),
      'primary' => TRUE,
    ),
    'ca_object_representations' => array(
      'name' => t('Object Representations')
    ),
    'ca_storage_locations' => array(
      'name' => t('Storage location')
    ),
    'ca_movements' => array(
      'name' => t('Movements'),
      'primary' => TRUE,
    ),
    'ca_loans' => array(
      'name' => t('Loans'),
      'primary' => TRUE
    ),
    'ca_tours' => array(
      'name' => t('Tours'),
      'primary' => TRUE
    ),
    'ca_tour_stops' => array(
      'name' => t('Tour Stops'),
      'primary' => TRUE,
    ),*/
  );
  // Allow other modules to alter the defined types through hook_collectiveaccess_primary_types_alter(&$types)
  drupal_alter('collectiveaccess_primary_types', $types);
  return $types;
}

/**
 * Get a list of CollectiveAccess types that can be used as first-class relations
 * in a format usable by Form API select lists
 */
function collectiveaccess_get_primary_types_relations_list() {
  $list = array();
  if ($types = collectiveaccess_get_types()) {
    foreach ($types as $key => $info) {
      if (isset($info['primary']) && $info['primary'] == TRUE && class_exists($info['class'])) {
        $list[$key] = $info['name'];
      }
    }
  }
  return $list;
}

/**
 * Get an array of types, keyed by the type item ID
 */
function collectiveaccess_get_type_ids() {
  $ids = array();
  if ($types = collectiveaccess_get_types()) {
    foreach ($types as $type_name => $type_info) {
      if (isset($type_info['id'])) {
        $type_info['key'] = $type_name;
        $ids[$type_info['id']] = $type_info;
      }
    }
  }
  return $ids;
}