<?php

/**
 * @file
 * Creates new image entities based on Manual Crop selections.
 */

/**
 * Implements hook_module_implements_alter().
 */
function truecrop_module_implements_alter(&$implementations, $hook) {
  // This module's hook_form_alter() and hook_field_widget_alter()
  // implementations must run after the Manual Crop module's implementations so
  // they can check for field settings and #process callbacks that Manual Crop
  // adds.
  if (in_array($hook, ['form_alter', 'field_widget_form_alter']) && isset($implementations['manualcrop']) && isset($implementations['truecrop'])) {
    $truecrop = $implementations['truecrop'];
    unset($implementations['truecrop']);
    $key = array_search('manualcrop', array_keys($implementations));
    $replacement = [
      'manualcrop' => $implementations['manualcrop'],
      'truecrop' => $truecrop,
    ];
    $implementations = array_merge(array_slice($implementations, 0, $key + 1, TRUE), $replacement, array_slice($implementations, $key + 1, NULL, TRUE));
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function truecrop_form_field_ui_field_edit_form_alter(&$form, &$form_state) {
  // Add a setting to use True Crop to the field instance configuration form
  // for any instance that allows Manual Crop to be configured.
  if (isset($form['instance']['settings']['manualcrop']['manualcrop_enable'])) {
    $manualcrop_settings = &$form['instance']['settings']['manualcrop'];
    $widget_settings = $form['#instance']['widget']['settings'];
    $is_disabled = !empty($manualcrop_settings['manualcrop_enable']['#disabled']);
    $truecrop_form_element = [
      'truecrop_enable' => [
        '#type' => 'checkbox',
        '#title' => t('Use "True Crop"'),
        '#description' => t('Saves a new file each time an image is cropped, and makes all related crops available for substitution within the Manual Crop interface.'),
        '#default_value' => !empty($widget_settings['truecrop_enable']) && !$is_disabled,
        // Disable the checkbox whenever Manual Crop is not enabled.
        '#disabled' => $is_disabled,
        '#states' => [
          'disabled' => [
            'input[name="instance[widget][settings][manualcrop_enable]"]' => ['checked' => FALSE],
          ],
        ],
      ],
    ];
    // Place the checkbox immediately after the checkbox for enabling Manual
    // Crop itself.
    $key = array_search('manualcrop_enable', array_keys($manualcrop_settings));
    $manualcrop_settings = array_merge(array_slice($manualcrop_settings, 0, $key + 1, TRUE), $truecrop_form_element, array_slice($manualcrop_settings, $key + 1, NULL, TRUE));
  }
}

/**
 * Implements hook_field_widget_form_alter().
 */
function truecrop_field_widget_form_alter(&$element, &$form_state, $context) {
  // Add a process function to enable True Crop whenever Manual Crop is being
  // used and the field is configured to allow True Crop.
  if (!empty($context['instance']['widget']['settings']['truecrop_enable'])) {
    foreach (element_children($element) as $key) {
      if (!empty($element[$key]['#process']) && in_array('manualcrop_widget_process', $element[$key]['#process'])) {
        $element[$key]['#process'][] = 'truecrop_widget_process';
      }
    }
  }
}

/**
 * Form API process function to add True Crop behavior to a Manual Crop widget.
 */
function truecrop_widget_process($element) {
  // If there are no Manual Crop styles associated with the widget (for
  // example, if a file has not been uploaded yet) do nothing.
  if (empty($element['manualcrop_selections'])) {
    return $element;
  }

  // Add True Crop JavaScript, with a weight such that it runs after the Manual
  // Crop JavaScript.
  $js_path = drupal_get_path('module', 'truecrop') . '/js/truecrop.js';
  $element['#attached']['js'][$js_path] = ['weight' => 1];

  // Change the theme function for the crop tool so it can display related
  // crops inside the cropping interface.
  foreach (element_children($element) as $key) {
    if (isset($element[$key]['#theme'])) {
      if ($element[$key]['#theme'] == 'manualcrop_croptool_overlay') {
        $element[$key]['#theme'] = 'truecrop_manualcrop_croptool_overlay';
      }
      elseif ($element[$key]['#theme'] == 'manualcrop_croptool_inline') {
        $element[$key]['#theme'] = 'truecrop_manualcrop_croptool_inline';
      }
    }
  }

  // Add a wrapping div to use for True Crop Ajax replacements.
  $element += [
    '#prefix' => '',
    '#suffix' => '',
  ];
  // The original prefix and suffix (before adding the new wrapping div) are
  // stored for later use in the Ajax callback.
  $element['#original_prefix'] = $element['#prefix'];
  $element['#original_suffix'] = $element['#suffix'];
  $id = $element['#id'] . '-truecrop-wrapper';
  $element['#prefix'] = '<div class="truecrop-wrapper" id="' . $id . '">' . $element['#prefix'];
  $element['#suffix'] .= '</div>';

  // Add a hidden select element and button which will run True Crop on the
  // selected style. This will be selected and triggered by JavaScript in the
  // Manual Crop interface.
  $element['truecrop_style'] = [
    '#type' => 'select',
    '#title' => t('Crop style'),
    '#empty_value' => '',
    '#attributes' => [
      'class' => [
        'truecrop-style',
      ],
    ],
    '#prefix' => '<div class="js-hide">',
    '#suffix' => '</div>',
  ];
  foreach (element_children($element['manualcrop_selections']) as $style_name) {
    $element['truecrop_style']['#options'][$style_name] = $style_name;
  }
  $element['truecrop_crop_and_replace_button'] = [
    '#type' => 'submit',
    '#value' => t('Crop and replace'),
    '#ajax' => [
      'callback' => 'truecrop_ajax_replace_widget',
      'wrapper' => $id,
      // This uses "html" to prevent the wrapper div itself from ever being
      // replaced. The True Crop JavaScript in truecrop.js relies on this to be
      // able to store the wrapper between Ajax requests and then search it for
      // new content. Because the wrapper div is not replaced via Ajax, the
      // Ajax callback function also has code to strip off the wrapper div
      // before returning the widget (see truecrop_ajax_replace_widget()) which
      // avoids an extra nested wrapper div being added to the page after each
      // Ajax request.
      'method' => 'html',
    ],
    // Set #name so the form API can distinguish which button was clicked in
    // the case where multiple True Crop widgets appear on the same page.
    '#name' => implode('_', $element['#parents']) . '_truecrop_crop_and_replace_button',
    '#limit_validation_errors' => [$element['#parents']],
    '#submit' => ['truecrop_widget_crop_submit'],
    '#attributes' => [
      'class' => [
        'truecrop-crop-and-replace-button',
        'js-hide',
      ],
    ],
  ];

  // Also add a button which simply rebuilds the widget. This is used by
  // JavaScript to force the widget to be rebuilt with an existing, related
  // crop image that the user has selected inside the Manual Crop interface.
  $element['truecrop_rebuild_button'] = [
    '#type' => 'submit',
    '#value' => t('Rebuild'),
    '#ajax' => [
      'callback' => 'truecrop_ajax_replace_widget',
      'wrapper' => $id,
      // Use "html" for similar reasons as on the "Crop and replace" button.
      'method' => 'html',
    ],
    // Set #name for similar reasons as on the "Crop and replace" button.
    '#name' => implode('_', $element['#parents']) . '_truecrop_rebuild_button',
    '#limit_validation_errors' => [$element['#parents']],
    // This is just a rebuild, so there is nothing to do on submit.
    '#submit' => [],
    '#attributes' => [
      'class' => [
        'truecrop-rebuild-button',
        'js-hide',
      ],
    ],
  ];

  return $element;
}

/**
 * Ajax callback for True Crop widget actions.
 */
function truecrop_ajax_replace_widget($form, $form_state) {
  // Find the widget which contains the element that triggered the True Crop
  // Ajax request.
  $array_parents = $form_state['triggering_element']['#array_parents'];
  array_pop($array_parents);
  $widget = drupal_array_get_nested_value($form, $array_parents);

  // Restore the original #prefix and #suffix to avoid multiple True Crop
  // wrapping divs being added to the page. See explanation in
  // truecrop_widget_process().
  $widget['#prefix'] = $widget['#original_prefix'];
  $widget['#suffix'] = $widget['#original_suffix'];

  return $widget;
}

/**
 * Custom submit handler for True Crop "crop and replace" functionality.
 */
function truecrop_widget_crop_submit($form, &$form_state) {
  // Find the submitted values corresponding to the widget that triggered the
  // submit.
  $parents = $form_state['triggering_element']['#parents'];
  array_pop($parents);
  $values = drupal_array_get_nested_value($form_state['values'], $parents);

  // Perform the crop using the requested style.
  if (!empty($values['truecrop_style'])) {
    $file = file_load($values['fid']);
    if ($file) {
      try {
        $style = $values['truecrop_style'];
        $fid = $values['fid'];
        $new_file = truecrop_generate($file, $style, $form_state['manualcrop_data']['selections'][$fid]['styles'][$style]);
        // Rebuild the form using the new file in place of the old one, and
        // with the previous crop selections removed (so that the new file uses
        // the default crop selection).
        drupal_array_set_nested_value($form_state['input'], array_merge($parents, ['fid']), $new_file->fid);
        $key_exists = NULL;
        $manualcrop_selections = &drupal_array_get_nested_value($form_state['input'], array_merge($parents, ['manualcrop_selections']), $key_exists);
        if ($key_exists && isset($manualcrop_selections[$style])) {
          unset($manualcrop_selections[$style]);
        }
        $form_state['rebuild'] = TRUE;
      }
      catch (Exception $e) {
        watchdog_exception('truecrop', $e);
      }
    }
  }
}

/**
 * Generates a True Crop derivative and saves associated files and menu links.
 *
 * This function creates a new file entity that is cropped based on the
 * passed-in settings. A reference to the file entity is also stored using the
 * menu API to allow a tree of all related cropped images to easily be
 * constructed.
 *
 * @param stdClass $file
 *   The file entity to crop.
 * @param string $style_name
 *   The name of the image style to use when cropping. This is expected to be
 *   an image style that is configured to use Manual Crop.
 * @param array $manualcrop_data
 *   An array of manualcrop data to use when cropping, including the keys 'x',
 *   'y', 'width' and 'height' representing the coordinates of the top-left
 *   corner of the cropping region, and its size.
 *
 * @return stdClass
 *   The new file entity that was created from the original based on the
 *   passed-in crop settings.
 *
 * @throws Exception
 */
function truecrop_generate($file, $style_name, $manualcrop_data) {
  // If this file has been cropped before, or was generated by cropping another
  // file, it will have an associated menu link entry. If not, save an initial
  // menu link to represent it.
  $menu_link = truecrop_load_menu_link($file->uri);
  if (!$menu_link) {
    $menu_link = [
      'module' => 'truecrop',
      // Using md5() returns a 32 character result which also happens to be the
      // maximum allowed size of a menu name.
      'menu_name' => md5($file->uri),
    ];
    $menu_link['link_title'] = $file->filename;
    $menu_link['link_path'] = _truecrop_menu_link_path_from_file_uri($file->uri);
    // Store the file ID as a data attribute so it's easily accessible by both
    // client-side and server-side code working with the menu link.
    $menu_link['options']['attributes']['data-fid'] = $file->fid;
    $mlid = menu_link_save($menu_link);
    if (!$mlid) {
      throw new Exception(format_string('Top-level menu link could not be saved for file with URI @uri and fid @fid.', ['@uri' => $file->uri, '@fid' => $file->fid]));
    }
  }

  // Find the original common source file for this series of crops.
  if ($menu_link['depth'] > 1) {
    $top_level_menu_tree = truecrop_menu_tree($menu_link['menu_name'], ['max_depth' => 1]);
    $top_level_menu_tree_element = array_shift($top_level_menu_tree);
    $top_level_menu_link = $top_level_menu_tree_element['link'];
  }
  else {
    $top_level_menu_link = $menu_link;
  }
  $fid = $top_level_menu_link['options']['attributes']['data-fid'];
  $original_source_file = file_load($fid);
  if (!$original_source_file) {
    throw new Exception(format_string('Top-level file could not be loaded for file with fid @fid.', ['@fid' => $fid]));
  }

  // Find any existing Manual Crop data associated with this file and image
  // style and retrieve it so it can be restored later.
  $original_manualcrop_data = manualcrop_load_crop_selection($file->uri, $style_name);

  // Save the new, temporary Manual Crop data so it can be used when creating
  // image derivatives below.
  manualcrop_save_crop_data($file, [$style_name => $manualcrop_data]);
  // Clear cached image paths like manualcrop_croptool_submit() does.
  if (variable_get('manualcrop_cache_control', TRUE)) {
    cache_clear_all('manualcrop:', 'cache', TRUE);
  }

  // Create an image derivative that crops the file based on the new Manual
  // Crop settings. This will be the source file that is copied to create the
  // new file entity.
  $source = image_style_path($style_name, $file->uri);
  $generated = image_style_create_derivative(image_style_load($style_name), $file->uri, $source);

  // Clean up after the image derivative generation by restoring the original
  // Manual Crop data for this file and image style. (If there was no original
  // crop data, an empty array is sent which will result in the temporary crop
  // data from above being deleted.)
  manualcrop_save_crop_data($file, [$style_name => $original_manualcrop_data ? $original_manualcrop_data : []]);
  // Clear cached image paths like manualcrop_croptool_submit() does.
  if (variable_get('manualcrop_cache_control', TRUE)) {
    cache_clear_all('manualcrop:', 'cache', TRUE);
  }

  if (!$generated) {
    throw new Exception(format_string('Image derivative could not be generated for URI @uri and style @style.', ['@uri' => $file->uri, '@style' => $style_name]));
  }

  // Determine an appropriate name and URI for the new file entity, based on
  // the original common source file for this series of crops, the style name,
  // and an increment (for example, crops descended from "picture.jpg" are
  // named like "picture_thumbnail.jpg", "picture_thumbnail_0.jpg",
  // "picture_thumbnail_1.jpg", "picture_hero_large.jpg", etc.) It is necessary
  // to calculate this separately for the filename rather than deriving it from
  // the URI because an original file with an admin-facing filename of
  // "picture.jpg" could actually have a URI like "picture_3.jpg" if other
  // copies existed before it was uploaded; in that case the desired
  // admin-facing name and URI of the newly-generated file would still be
  // "picture_thumbnail.jpg" (not "picture_3_thumbnail.jpg").
  $filename = $original_source_file->filename;
  list($prefix, $extension) = truecrop_pathinfo($filename);
  // Shorten the base filename if necessary. This provides a reasonably safe
  // margin which takes into account not only Drupal's 255 character limit in
  // the database, but also the various things that might be prepended and
  // appended to the basename as it becomes a filename, URI, and menu link
  // path.
  $max_length = 150;
  if (drupal_strlen($prefix) > $max_length) {
    $prefix = drupal_substr($prefix, 0, $max_length);
  }
  // Add the image style name as a suffix to the original filename.
  $filename = $prefix . '_' . $style_name . $extension;
  // For the filename, the increment must be added manually.
  $filename = truecrop_get_unique_filename($filename);
  // For the URI, just reuse the new filename. If an additional increment is
  // needed to keep it unique, Drupal will add it automatically when the file
  // is copied below using FILE_EXISTS_RENAME.
  $dirname = drupal_dirname($original_source_file->uri);
  if (substr($dirname, -1) != '/') {
    $dirname .= '/';
  }
  $destination_uri = $dirname . $filename;

  // Copy the file to the new location.
  $destination = file_unmanaged_copy($source, $destination_uri, FILE_EXISTS_RENAME);
  if (!$destination) {
    throw new Exception(format_string('Image derivative could not be copied from @source to @destination.', ['@source' => $source, '@destination' => $destination_uri]));
  }
  $destination_uri = $destination;

  // Save the file as a new file entity.
  $new_file = clone $file;
  $new_file->fid = NULL;
  $new_file->uri = $destination_uri;
  $new_file->filename = $filename;
  file_save($new_file);

  // Save a new menu link as a child of the parent.
  $child_menu_link = $menu_link;
  $child_menu_link['plid'] = $child_menu_link['mlid'];
  unset($child_menu_link['mlid']);
  $child_menu_link['link_title'] = $new_file->filename;
  $child_menu_link['link_path'] = _truecrop_menu_link_path_from_file_uri($new_file->uri);
  // Store the file ID and all information used to crop the file as data
  // attributes so they are easily accessible by both client-side and
  // server-side code working with the menu link.
  $data = $manualcrop_data;
  $data['fid'] = $new_file->fid;
  $data['style_name'] = $style_name;
  foreach ($data as $key => $value) {
    $child_menu_link['options']['attributes']["data-$key"] = $value;
  }
  $mlid = menu_link_save($child_menu_link);
  if (!$mlid) {
    throw new Exception(format_string('Child menu link could not be saved for file with URI @uri and fid @fid.', ['@uri' => $new_file->uri, '@fid' => $new_file->fid]));
  }

  return $new_file;
}

/**
 * Returns a new, unique "filename" property for a file entity.
 *
 * @param string $filename
 *   The original filename that the new one should be based on.
 *
 * @return string
 *   A unique, incremented filename suitable for use in a file entity's
 *   $file->filename property. For example, if "picture.jpg" is passed in, the
 *   return value could be:
 *   - picture.jpg
 *   - picture_0.jpg
 *   - picture_1.jpg
 *   - etc.
 */
function truecrop_get_unique_filename($filename) {
  $table = module_exists('file_entity_revisions') ? 'file_managed_revisions' : 'file_managed';

  // Keep incrementing the filename until one is found that doesn't exist yet.
  while (db_query_range('SELECT 1 FROM {' . $table . '} WHERE filename = :filename', 0, 1, array(':filename' => $filename))->fetchField()) {
    if (!isset($increment)) {
      list($prefix, $extension) = truecrop_pathinfo($filename);
      $increment = 2;
    }
    $filename = $prefix . '_' . $increment++ . $extension;
  }

  return $filename;
}

/**
 * Returns an array of path info about a given filename or URI.
 *
 * @param string $filename
 *   The filename or URI to return information about.
 *
 * @return array
 *   An array whose first element is everything before the file extension and
 *   whose second element is the extension (which could be an empty string if
 *   the file has no extension). For example, if "/path/to/picture.jpg" is
 *   passed in, ["/path/to/picture", ".jpg"] will be returned.
 */
function truecrop_pathinfo($filename) {
  // Strip off the file extension, if there is one. See file_create_filename().
  $dot_position = strrpos($filename, '.');
  if ($dot_position !== FALSE) {
    $prefix = substr($filename, 0, $dot_position);
    $extension = substr($filename, $dot_position);
  }
  else {
    $prefix = $filename;
    $extension = '';
  }
  return [$prefix, $extension];
}

/**
 * Loads a True Crop menu link associated with a file.

 * @param string $uri
 *   The URI of the file whose menu link should be loaded.
 *
 * @return array
 *   The menu link array, which may be empty if there is no menu link for the
 *   given file.
 */
function truecrop_load_menu_link($uri) {
  $link = db_query('SELECT * FROM {menu_links} WHERE module = :module AND link_path = :uri', [
    ':module' => 'truecrop',
    ':uri' => _truecrop_menu_link_path_from_file_uri($uri),
  ])->fetchAssoc();
  if (!$link) {
    return [];
  }
  // Unserialize the options like menu_link_load() does.
  if (!is_array($link['options'])) {
    $link['options'] = unserialize($link['options']);
  }
  return $link;
}

/**
 * Implements hook_file_delete().
 */
function truecrop_file_delete($file) {
  // When a file is deleted, delete its associated menu link also.
  $menu_link = truecrop_load_menu_link($file->uri);
  if ($menu_link) {
    menu_link_delete($menu_link['mlid']);
  }
}

/**
 * Implements hook_theme().
 */
function truecrop_theme() {
  return [
    'truecrop_menu_link' => [
      'render element' => 'element',
    ],
    'truecrop_manualcrop_croptool_overlay' => [
      'variables' => [
        'attributes' => NULL,
        'image' => NULL,
        'crop_info' => TRUE,
        'instant_preview' => FALSE,
      ],
    ],
    'truecrop_manualcrop_croptool_inline' => [
      'variables' => [
        'attributes' => NULL,
        'image' => NULL,
        'crop_info' => TRUE,
        'instant_preview' => FALSE,
      ],
    ],
  ];
}

/**
 * Returns HTML for a True Crop menu link.
 *
 * @param $variables
 *   An associative array containing:
 *   - element: Structured array data for a menu link.
 *
 * @ingroup themeable
 *
 * @see theme_menu_link()
 */
function theme_truecrop_menu_link($variables) {
  $element = $variables['element'];

  // Display the image in the Media module's thumbnail style if available.
  // Otherwise use the regular thumbnail style.
  $image_uri = $element['#original_link']['truecrop_file_uri'];
  $styles = image_styles();
  $style_name = isset($styles['media_thumbnail']) ? 'media_thumbnail' : 'thumbnail';
  $image = theme('image', ['path' => image_style_path($style_name, $image_uri)]);

  // Display the image and title as a link.
  $element['#localized_options']['attributes']['class'][] = 'truecrop-related-crop';
  $element['#localized_options']['html'] = TRUE;
  $output = l($image . check_plain($element['#title']), $element['#href'], $element['#localized_options']);

  // Output any link children.
  if ($element['#below']) {
    $output .= drupal_render($element['#below']);
  }

  return $output;
}

/**
 * Returns HTML for a Manual Crop overlay interface with related crops shown.
 *
 * @ingroup themeable
 *
 * @see theme_manualcrop_croptool_overlay()
 */
function theme_truecrop_manualcrop_croptool_overlay($variables) {
  $output = theme('manualcrop_croptool_overlay', $variables);
  return _truecrop_add_related_crops_to_crop_interface($output, $variables['image']['path']);
}

/**
 * Returns HTML for a Manual Crop inline interface with related crops shown.
 *
 * @ingroup themeable
 *
 * @see theme_manualcrop_croptool_overlay()
 */
function theme_truecrop_manualcrop_croptool_inline($variables) {
  $output = theme('manualcrop_croptool_inline', $variables);
  return _truecrop_add_related_crops_to_crop_interface($output, $variables['image']['path']);
}

/**
 * Adds a list of related crops to the Manual Crop cropping interface.
 *
 * @param string $manualcrop_html
 *   The themed HTML for the Manual Crop cropping interface.
 * @param string $file_uri
 *   The URI of a file whose related crops should be shown.
 *
 * @return string
 *   The themed HTML for the Manual Crop cropping interface, with the list of
 *   related crops (if there are any) displayed inside it.
 */
function _truecrop_add_related_crops_to_crop_interface($manualcrop_html, $file_uri) {
  $tree = truecrop_menu_tree_output_from_file_uri($file_uri);
  if ($tree) {
    // Render the menu tree inside a fieldset.
    $build = [
      '#type' => 'fieldset',
      '#title' => t('Related crops'),
      '#description' => t('Select an image to switch to it.'),
      '#prefix' => '<div class="truecrop-related-crops">',
      '#suffix' => '</div>',
      'tree' => $tree,
    ];
    $build['#attached']['css'][] = drupal_get_path('module', 'truecrop') . '/css/truecrop-related-crops.css';
    $tree_html = drupal_render($build);
    // Move the menu tree to the top of the style info container (which appears
    // in a convenient place at the lower left of the Manual Crop interface).
    $dom = filter_dom_load($manualcrop_html);
    $xpath = new DomXPath($dom);
    $style_info = $xpath->query("//*[contains(@class, 'manualcrop-style-info')]")->item(0);
    $fragment = $dom->createDocumentFragment();
    $fragment->appendXML($tree_html);
    $style_info->insertBefore($fragment, $style_info->firstChild);
    $manualcrop_html = filter_dom_serialize($dom);
  }
  return $manualcrop_html;
}

/**
 * Renders the True Crop menu tree render array for a particular file.
 *
 * Given a file URI, this function renders the menu tree which contains it (in
 * other words, the tree of all related crops that descend from the same common
 * source).
 *
 * @param string $uri
 *   The URI of the file whose menu tree should be rendered.
 *
 * @return array
 *   A render array representing the menu tree.
 */
function truecrop_menu_tree_output_from_file_uri($uri) {
  $link = truecrop_load_menu_link($uri);
  return $link ? truecrop_menu_tree_output($link['menu_name'], ['truecrop_active_file_uri' => $uri]) : [];
}

/**
 * Renders the menu tree of related crops that descend from a common source.
 *
 * @param string $menu_name
 *   The name of the True Crop menu name that stores the tree.
 * @param array $parameters
 *   (optional) An associative array of build parameters, the same as used by
 *   menu_build_tree(). The additional parameter "truecrop_active_file_uri" is
 *   also supported which allows passing in a file URI that, if it appears in
 *   the menu tree, will be given the "active-trail" HTML class.
 *
 * @return array
 *   A render array representing the menu tree.
 */
function truecrop_menu_tree_output($menu_name, $parameters = []) {
  // Find the active file URI, if there is one.
  $active_file_uri = NULL;
  if (isset($parameters['truecrop_active_file_uri'])) {
    $active_file_uri = $parameters['truecrop_active_file_uri'];
    unset($parameters['truecrop_active_file_uri']);
  }

  $tree = truecrop_menu_tree($menu_name, $parameters);

  // Convert the tree to a render array and modify the theme functions used to
  // render each link.
  $build = menu_tree_output($tree);
  _truecrop_modify_menu_tree_render_array($build, $active_file_uri);

  // Add a wrapper div around the tree so it can be identified.
  $build += [
    '#prefix' => '',
    '#suffix' => '',
  ];
  $build['#prefix'] = '<div class="truecrop-menu-tree">' . $build['#prefix'];
  $build['#suffix'] .= '</div>';

  return $build;
}

/**
 * Returns the menu tree of related crops that descend from a common source.
 *
 * @param string $menu_name
 *   The name of the True Crop menu name that stores the tree.
 * @param array $parameters
 *   (optional) An associative array of build parameters, the same as used by
 *   menu_build_tree().
 *
 * @return array
 *   A structured array representing the menu tree.
 */
function truecrop_menu_tree($menu_name, $parameters = []) {
  // Build the tree in a similar way as menu_build_tree() does, but call a
  // custom function to modify the links.
  $data = _menu_build_tree($menu_name, $parameters);
  _truecrop_modify_menu_tree_links($data['tree']);
  menu_tree_check_access($data['tree'], $data['node_links']);
  return $data['tree'];
}

/**
 * Modifies a menu tree that is being used to render True Crop file links.
 */
function _truecrop_modify_menu_tree_links(&$tree) {
  foreach ($tree as $key => &$item) {
    $link = &$item['link'];

    // Convert each link to a file URI and perform file API access checks on
    // it.
    $uri = _truecrop_file_uri_from_menu_link_path($link['link_path']);
    if (!in_array(file_uri_scheme($uri), variable_get('file_public_schema', array('public'))) && !file_download_access($uri)) {
      unset($tree[$key]);
      continue;
    }

    // Convert to an absolute URL and make sure the menu system will treat it
    // as external and not try to check access on it when building the tree.
    $link['link_path'] = file_create_url($uri);
    $link['external'] = TRUE;

    // Retain the file URI so other code can use it.
    $link['truecrop_file_uri'] = $uri;

    // Progress recursively down the tree.
    if ($item['below']) {
      _truecrop_modify_menu_tree_links($item['below']);
    }
  }
}

/**
 * Modifies a menu tree render array to add True Crop theming.
 *
 * @param array $build
 *   The menu tree render array.
 * @param string $active_file_uri
 *   (optional) A file URI that, if it appears in the menu tree, will be given
 *   the "active-trail" HTML class.
 */
function _truecrop_modify_menu_tree_render_array(&$build, $active_file_uri = NULL) {
  // Remove the theme wrapper which themes the tree as a nested <ul> list and
  // use a custom theme function for each menu link that will display it as a
  // standard list of thumbnail links.
  unset($build['#theme_wrappers']);
  foreach (element_children($build) as $key) {
    $link = &$build[$key];
    $link['#theme'] = 'truecrop_menu_link';
    if ($active_file_uri && $link['#original_link']['truecrop_file_uri'] == $active_file_uri) {
      $link['#localized_options']['attributes']['class'][] = 'active-trail';
    }
    if (!empty($link['#below'])) {
      _truecrop_modify_menu_tree_render_array($link['#below'], $active_file_uri);
    }
  }
}

/**
 * Generates a True Crop menu link path from a file URI.
 *
 * @see _truecrop_file_uri_from_menu_link_path()
 */
function _truecrop_menu_link_path_from_file_uri($uri) {
  // This module uses the menu system for its storage capabilities and in
  // particular its ability to generate trees of related items. But this module
  // does not work with actual Drupal paths, so the menu system's access checks
  // cannot be allowed to run on its items (if they did they would always
  // return FALSE). Therefore, file URIs are converted to fake external URLs
  // before storing them in the menu system, since Drupal does not do access
  // checks on external URLs.
  return 'http://example.com/' . $uri;
}

/**
 * Generates a file URI from a True Crop menu link path.
 *
 * @see _truecrop_menu_link_path_from_file_uri()
 */
function _truecrop_file_uri_from_menu_link_path($path) {
  // Remove the prefix that _truecrop_menu_link_path_from_file_uri() added.
  $prefix = 'http://example.com/';
  $str_length = strlen($prefix);
  if (substr($path, 0, $str_length) == $prefix) {
    $path = substr($path, $str_length);
  }
  return $path;
}
