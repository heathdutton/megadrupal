<?php

/**
 * @file
 * RDF vizualization. Creates pictures from scraped semantics.
 */

/**
 * Callback for fetching raw rdf.
 *
 * These pages return the requested results.
 *
 * Implements hook_menu().
 */
function rdfviz_menu() {
  return array(
    // Place the admin settings in the same section as rdfx does.
    'admin/config/services/rdfviz' => array(
      'title' => 'RDFViz rendering',
      'description' => 'Enable the rendering plugin styles used when rendering arbitrary RDF',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('rdfviz_settings_form'),
      'access arguments' => array('Administer RDFViz'),
      'type' => MENU_NORMAL_ITEM,
    ),
    'admin/config/services/rdfviz/rule' => array(
      'title' => 'RDFViz ruleset',
      'description' => 'Edit the rulesets',
      'page callback' => 'rdfviz_ruleset_form',
      'file' => 'rdfviz.ui.inc',
      'access arguments' => array('Administer RDFViz'),
      'type' => MENU_NORMAL_ITEM,
    ),
    'rdfviz' => array(
      'title' => 'RDF Vizualizer',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('rdfviz_select_form'),
      'description' => 'Front end to RDF vizualization tools',
      'access arguments' => array('access RDFViz'),
      'type' => MENU_CALLBACK,
    ),
    // The callbacks that render things.
    'rdfviz/raw' => array(
      'title' => 'RDF viewer',
      'page callback' => 'rdfviz_page',
      'page arguments' => array('raw'),
      'description' => 'Show just the RDF extracted from a path',
      'access arguments' => array('access RDFViz'),
      'type' => MENU_CALLBACK,
    ),
    'rdfviz/dot' => array(
      'title' => 'DOT viewer',
      'page callback' => 'rdfviz_page',
      'page arguments' => array('dot'),
      'description' => 'Show dot code representing objects found on this path',
      'access arguments' => array('access RDFViz'),
      'type' => MENU_CALLBACK,
    ),
    'rdfviz/png' => array(
      'title' => 'PNG viewer',
      'page callback' => 'rdfviz_page',
      'page arguments' => array('png'),
      'description' => 'Shows an image representing objects found on this path',
      'access arguments' => array('access RDFViz'),
      'type' => MENU_CALLBACK,
    ),
    'rdfviz/gif' => array(
      'title' => 'GIF viewer',
      'page callback' => 'rdfviz_page',
      'page arguments' => array('gif'),
      'description' => 'Shows an image representing objects found on this path',
      'access arguments' => array('access RDFViz'),
      'type' => MENU_CALLBACK,
    ),
    'rdfviz/svg' => array(
      'title' => 'SVG viewer',
      'page callback' => 'rdfviz_page',
      'page arguments' => array('svg'),
      'description' => 'Shows an svg diagram representing objects found on this path',
      'access arguments' => array('access RDFViz'),
      'type' => MENU_CALLBACK,
    ),
  );
}

/**
 * Display the available rendering rulesets.
 *
 * A FAPI form.
 */
function rdfviz_settings_form() {
  $form = array(
    '#tree' => TRUE,
  );
  $rdfviz_enabled_rulesets = variable_get('rdfviz_enabled_rulesets', array('default' => TRUE, 'users' => TRUE));

  ctools_include('plugins');
  $module = 'rdfviz';
  $type = 'rdfviz_ruleset';
  $available_rulesets = ctools_get_plugins($module, $type);

  foreach ($available_rulesets as $ruleset_id => $ruleset_description) {
    $form['rdfviz_enabled_rulesets'][$ruleset_id] = array(
      '#type' => 'checkbox',
      '#title' => $ruleset_description['title'],
      '#description' => isset($ruleset_description['description']) ? $ruleset_description['description'] : '',
      '#default_value' => !empty($rdfviz_enabled_rulesets[$ruleset_id]),
    );
  }

  $form['rdfvz_processing'] = array(
    '#prefix' => '<hr/>',
  );

  $form['rdfvz_strict_processing'] = array(
    '#type' => 'checkbox',
    '#title' => t('"Strict" rendering mode (reduce duplicates)'),
    '#description' => t("
        The graph renderer can either show <em>all</em> connections between two
        nodes, or just one.
        If one person is both the 'Author of' and 'Copyright holder of' the
        same book, should there be one line drawn between the two concepts
        (strict) or two (un-strict)?
        This becomes more difficult is your source data contains synonyms, or
        if you want to support more than one vocabulary at the same time,
        eg dc:creator & schema:author
    "),
    '#default_value' => variable_get('rdfvz_strict_processing', TRUE),
  );
  $form['rdfviz_engine'] = array(
    '#type' => 'select',
    '#options' => array_combine(rdfviz_commands(), rdfviz_commands()),
    '#title' => t('Which layout engine to use. "dot" is the default.'),
    '#description' => t('These can produce wildly different layouts, but all tell the same story. <a href="http://www.graphviz.org/Documentation.php">Reference</a>'),
    '#default_value' => variable_get('rdfviz_engine', 'dot'),
  );

  return system_settings_form($form);
}

/**
 * Implements hook_permission().
 */
function rdfviz_permission() {
  return array(
    'administer RDFViz' => array(
      'title' => t('Administer RDFViz'),
      'description' => t('Change settings for RDFViz.'),
    ),
    'access RDFViz' => array(
      'title' => t('Access RDFViz'),
      'description' => t('View RDFViz output.'),
    ),
  );
}

/**
 * Provide a FAPI form for selecting the vizualization method URL.
 */
function rdfviz_select_form() {
  $form = array();
  $form['format'] = array(
    '#title' => 'Format',
    '#type' => 'select',
    '#options' => array(
      'raw' => 'raw',
      'dot' => 'dot',
      'png' => 'png',
      'svg' => 'svg',
    ),
  );
  $form['url'] = array(
    '#title' => 'URL',
    '#type' => 'textfield',
  );
  $form['submit'] = array(
    '#value' => 'RDFViz',
    '#type' => 'submit',
  );

  return $form;
}

/**
 * Provide a FAPI form for selecting the vizualization method URL.
 */
function rdfviz_select_form_submit($form, $form_state) {
  dpm($form_state['values']);
  $parts = array(
    'rdfviz',
    $form_state['values']['format'],
    $form_state['values']['url'],
  );
  $url = implode('/', $parts);
  drupal_goto($url);
}

/**
 * Return an RDF representation of the given path.
 *
 * @param string $format
 *   Should be raw, dot, png or svg.
 *
 * @return array
 *   Renderable page result.
 */
function rdfviz_page($format) {
  $path_args = func_get_args();
  array_shift($path_args);
  $request_path = implode('/', $path_args);

  if (url_is_external($request_path)) {
    // What? we are being asked to parse someone elses thing?
    // Hey, why not? I CAN.
    // Hm. XSS attacks?
    $url = $request_path;
  }
  else {
    $url = url($request_path, array('absolute' => TRUE));
  }

  drupal_set_title(t("RDF extracted from !request_path", array('!request_path' => $request_path)));

  // Built for comfort, not built for speed.
  // Don't even think.
  // Fetch the page from myself
  // Get the tool to parse it.
  // See what we get.
  // This means we will see what the world sees,
  // so it's a handy syntax checker also.

  if (!rdfviz_load_arc()) {
    return "Failed to load ARC2";
  }

  $arc = rdfviz_parse_rdf($url);
  // $triples = $arc->getTriples();

  // Now render using whatever method we chose
  // Available engines are 'neato' etc.
  // @see rdfviz_commands()
  $command = variable_get('rdfviz_engine', 'dot');

  switch ($format) {
    case 'raw':
      return rdfviz_raw($arc);

    case 'dot':
    case 'png':
    case 'gif':
    case 'svg':
      return rdfviz_dot($arc, $format, $command);
  }
  return __FUNCTION__ . " Failed";
}

/**
 * I may find some extra namespaces useful.
 *
 * implements hook_rdf_namespaces()
 */
function rdfviz_rdf_namespaces() {
  return array(
    // xhtml/vocab manages the rel=icon thing, but also has a lot of webby/sioc
    // sorta words I could use.
    'xh' => "http://www.w3.org/1999/xhtml/vocab#",
    // This was left out - is dc suppoced to be dc/terms or dc/elements?
    // Core has chosen terms. I'm really not sure that's right.
    'dce' => 'http://purl.org/dc/elements/1.1/',
    // Arc automatically detects rel=tag as being mapped to poshrdf (defunct?)
    // Add the namespace so we can see a human name for it.
    // It seems to be parsing it wrong though.
    'mf' => 'http://poshrdf.org/ns/mf#',
    // DOAP - description of a project - is a handy test case.
    'doap' => 'http://usefulinc.com/ns/doap#',
  );
}

/**
 * Provide shortnames for Drupal URLs.
 *
 * Adding my own URLs as a namespace will may a lot of sense in the short term.
 * It certainly makes for shorter labels on the graph.
 * ARC creates dummy namespaces a lot otherwise.
 *
 * @param string $base_uri
 *   Nominal URI of the current site when providing local semantics.
 *   A pseudo namespace.
 *
 * @return array
 *   Namespace list, as used by rdf_namespaces().
 */
function rdfviz_extra_drupal_namespaces($base_uri = '') {
  return array(
    'site' => url($base_uri . '', array('absolute' => TRUE)),
    'node' => url($base_uri . 'node', array('absolute' => TRUE)) . '/',
    'user' => url($base_uri . 'user', array('absolute' => TRUE)) . '/',
    'term' => url($base_uri . 'taxonomy/term', array('absolute' => TRUE)) . '/',
  );
}

/**
 * Return an tabular RDF dump of the given path.
 *
 * List all the triples in a basic way.
 */
function rdfviz_raw(ARC2_RDFParser$arc) {
  $triples = $arc->getTriples();

  if (module_exists('devel')) {
    dpm($arc);
  }

  $rows = array();
  foreach ($triples as $triple) {
    $subject = $arc->getPName($triple['s']);
    if ($triple['s_type'] == 'uri') {
      $subject = l($subject, $triple['s']);
    }
    $object = $triple['o'];
    if ($triple['o_type'] == 'uri') {
      $object = l($arc->getPName($triple['o']), $triple['o']);
    }
    $rows[] = array(
      $subject,
      '<span title="' . $triple['p'] . '">' . $arc->getPName($triple['p']) . '</span>',
      $object,
    );
  }

  return theme('table', array('rows' => $rows));
}

/**
 * Return a dot file source dump of the given object.
 *
 * @param ARC2_RDFParser $arc
 *   Parser object.
 * @param string $format
 *   One of 'png', 'gif', 'svg' etc.
 * @param string $command
 *   One of 'dot', 'neato', 'osage', 'circo', 'twopi', 'sfdp'.
 *
 * @return string
 *   DOT syntax source.
 */
function rdfviz_dot($arc, $format = 'png', $command = 'dot') {
  $triples = $arc->getTriples();
  // $subjects = $arc->getSimpleIndex($triples, FALSE);

  // Setup the mapping, rendering rules.

  // Should objects that are mentioned but not processed
  // be displayed? If so, a few unconnected nodes may float around.
  // If not, you need to define the shape for anything you want to show.
  // $show_untyped = variable_get('rdfvz_show_untyped', TRUE);

  // Start building the graph.
  $directed = variable_get('rdfvz_directed_processing', TRUE);
  // Strict reduced all duplicate edges between the same nodes to one.
  // If you need to show them all, set it off,
  // but that is a mess if allowing synonyms.
  $strict = variable_get('rdfvz_strict_processing', TRUE);

  if (!$g = rdfviz_load_graphviz($directed, $strict)) {
    return "Failed to load Graphviz Pear library";
  }

  $g->addAttributes(array(
      // Neato rendering is pretty crap unless this is set.
      'overlap' => 'false',
      'splines' => 'polyline',
    ));

  $group = 'default';

  // Process the user-defined ruleset.
  $ruleset = rdfviz_node_rendering_ruleset();
  // dpm($triples);
  // dpm($ruleset);
  foreach ($triples as $triple) {
    $action = 'statement_process';
    // Cook the triple down to CURIEs so the condition checkers don't have to.
    if ($triple['s_type'] == 'uri') {
      $triple['s_curie'] = $arc->getPName($triple['s']);
    }
    $triple['p_curie'] = $arc->getPName($triple['p']);
    if ($triple['o_type'] == 'uri') {
      $triple['o_curie'] = $arc->getPName($triple['o']);
    }
    // If we need the local path to a specific file - eg an image icon
    // then the rule can use s_local or o_local to link to it.
    // This is always neccessary, as the process needs to be able to access the
    // image to read the dimensions.
    // An extra process lives in the svg render that makes the local image
    // links web-worthy.
    // @see the render_images rule example.
    $triple['s_local'] = str_replace(url('', array('absolute' => TRUE)), '', $triple['s']);
    $triple['o_local'] = str_replace(url('', array('absolute' => TRUE)), '', $triple['o']);

    foreach ($ruleset as $rule_id => $rule) {
      if (!is_array($rule['ON'])) {
        // Help debuggers. They'll probably get this wrong the first time.
        trigger_error("The 'ON' parameter to the rdfviz ruleset $rule_id must be an array");
        continue;
      }
      if (!in_array($action, $rule['ON'])) {
        continue;
      }
      $triggered = rdfviz_rule_check_all_conditions($rule['IF'], $triple, $rule_id);
      /*
      dpm("
        Processing $rule_id rule
        on a {$triple['p_curie']} statement
        about {$triple['s_curie']} . triggered:"
        . ($triggered ? 'TRUE' : 'FALSE')
      );
      */


      if (!$triggered) {
        continue;
      }

      // Got this far without continuing, this means the check passed.
      // dpm(array('rule' => $rule, 'statement' => $triple), 'MATCHED');
      // Now we do what we are told to do.
      foreach ($rule['DO'] as $action_id => $do_action) {
        // Add some explanations to anyone trying to build rules on their own.
        // Catch a common problem - list of actions not nested deep enough.
        if (!is_numeric($action_id)) {
          trigger_error("Function " . __FUNCTION__ . " called with unexpected arguments. Condition list is expected to by a numerically indexed array, got a text key '$action_id' instead. The structure of the rules being processed is probably wrong.");
        }
        foreach ($do_action as $action_callback => $args) {
          // Actions feed in pretty directly to the graphviz tool
          // dpm("Doing action $action_callback, triggered by $rule_id");

          if (!empty($args['reverse'])) {
            // This lets the rule apply to the OBJECT rather than the SUBJECT.
            // it swaps these two. Useful if you want to addNode to the target
            // end of a relationship.
            $temp = $triple;
            $temp['s'] = $triple['o'];
            $temp['s_curie'] = $triple['o_curie'];
            $temp['s_type'] = $triple['o_type'];
            $temp['o'] = $triple['s'];
            $temp['o_curie'] = $triple['s_curie'];
            $temp['o_type'] = $triple['s_type'];
            $triple = $temp;
          }

          if (empty($triple['s_curie'])) {
            // This was an anonymous internal bnode.
            // Probably not expected, but not illegal either.
            $id = $triple['s'];
          }
          else {
            $id = $triple['s_curie'];
          }
          // Rule args may use placeholders, eg 'title' => '%o'
          // Substitute those in from the statement.
          $substitutions = array();
          // There's probably a magic array way to do this.
          foreach ($triple as $key => $val) {
            $substitutions['!' . $key] = $val;
          }
          foreach ((array) $args['attributes'] as $key => $val) {
            $args['attributes'][$key] = format_string($val, $substitutions);
          }

          switch ($action_callback) {
            case 'addNode':
              $group = @$args['group'];
              // Whenever adding an item, it will have an URL. link that.
              $args['attributes'] += array('URL' => $triple['s']);

              // Some objects (dc:term that is just a string)
              // need to assign themselves their own ID.
              if (isset($args['attributes']['id'])) {
                $id = $args['attributes']['id'];
              }

              // Need word-wrapping on labels. They often get wide.
              if (!empty($args['attributes']['label'])) {
                // HTML formatters may introduce wacky whitespace.
                $args['attributes']['label'] = preg_replace('/\s+/', ' ', $args['attributes']['label']);
                $args['attributes']['label'] = wordwrap($args['attributes']['label'], strlen($args['attributes']['label']) / 2.5);
              }
              // Graphviz wil automatically use the ID as the label if not set.
              // That's cool, but word-wrap it if needed.
              #if (empty($args['attributes']['label'])) {
              #   $args['attributes']['label'] = wordwrap($triple['o'], strlen($triple['o']) / 2.5 );
              #}
              #// Hm, don't fill in data that's not defined yet,
              # // it interferes with the ability to merge later.

              // Add node wil always replace.
              // But often we just want to merge data.
              if (!empty($g->graph['nodes'][$group][$id])) {
                // This node $id already exists.
                // Merge attributes - later ones overwrite earlier.
                $g->graph['nodes'][$group][$id] = array_merge($g->graph['nodes'][$group][$id], $args['attributes']);
              }
              else {
                $g->addNode($id, $args['attributes'], $group);
              }
              break;

            case 'addEdge':
              // OK, if you want to add an edge that points to a literal,
              // Go on then.
              if (empty($triple['o_curie'])) {
                $triple['o_curie'] = $triple['o'];
              }

              // Edges can only be added when both the subject and the object
              // are URIs.
              if (empty($triple['o_curie'])) {
                trigger_error("The target URI '{$triple['o']}' did not resolve to a linkable object when processing '$rule_id'. Cannot create edge from $id to it.");
                // You probably picked the predicate that links to a string
                // (eg node dc:creator = "myname")
                // You really need to pick the predicate statement that links
                // to a URI - eg node sioc:has_creator = '/user/4'
                trigger_error("Problem processing rule " . print_r($rule, 1) . " on triple statement " . print_r($triple, 1));
              }
              else {
                // Although graphviz allows us to put the arrow on the other
                // end with 'dir'='back',
                // That's not the same as reversing the structural order of
                // things.
                // And when laying out, the structural order makes a lot of
                // difference to the shape.
                // Use a custom value 'reverse' to make this happen.
                // If doing that, don't use 'dir'='back'
                if (!empty($args['reverse'])) {
                  $g->addEdge(array($triple['o_curie'] => $id), @$args['attributes']);
                }
                else {
                  $new = $g->addEdge(array($id => $triple['o_curie']), $args['attributes']);
                }
              }
              break;

            default:
              trigger_error("Unsupported action. Don't know how to apply $action_callback to a graphViz object");
          }
          // Which action type.
        }
      }
      // Each action.
    }
    // Each rule.
  }
  // Each triple.

  /*
    // The library deals with grouping as a special case, as the graphviz api
    // takes it as a secondary argument.
    if (isset($subject_graphviz_args['group'])) {
      $group = $arc->getPName($subject_graphviz_args['group']);
      $subject_graphviz_args['group'] = $group;
    }

    // Most objects we render are nodes.
    $graphType = 'Node';
    // Alternatives are 'Subgraph' and 'Cluster'
    // Mixed results from these :-/
    if (isset($subject_graphviz_args['type'])) {
      // The processed rules want us to make a different type
      // EG, not a node, but a group
      $graphType = $subject_graphviz_args['type'];
      unset($subject_graphviz_args['type']);
    }

    if ($graphType == 'Subgraph') {
      $group = 'default';
      $G->addSubgraph($curie, $subject_graphviz_args['label'], $subject_graphviz_args, $group);
    }
    if ($graphType == 'Cluster') {
      $group = 'default';
      $G->addCluster($curie, $subject_graphviz_args['label'], $subject_graphviz_args, $group);
    }
  */


  // Ready to render.
  if ($format == 'dot') {
    // Return a text dump of the dot file.
    $dot = $g->parse();
    $renderable = array();
    $renderable['dot'] = array(
      '#type' => 'fieldset',
      '#title' => 'DOT file',
    );
    $renderable['dot']['content'] = array(
      '#markup' => $dot,
      '#prefix' => '<pre>',
      '#suffix' => '</pre>',
    );
    return $renderable;
  }

  // Otherwise, draw a picture.

  $graph = '';
  $commands = rdfviz_commands();
  if ($command == 'all') {
    foreach ($commands as $command) {
      $graph .= graphviz_render($g, $format, $command);
    }
  }
  else {
    if (!in_array($command, $commands)) {
      return "Unknown graphviz engine $command";
    }
    $graph .= graphviz_render($g, $format, $command);
  }

  $renderable['graph'] = array(
    '#markup' => $graph,
  );

  return $renderable;
}

/**
 * List of possible layout engines.
 *
 * To use anything but dot & neato, need to patch graphviz module.
 */
function rdfviz_commands() {
  return array('dot', 'neato', 'osage', 'circo', 'twopi', 'sfdp');
}

/**
 * Rewriting the rules array to be more like rules module.
 *
 * Returns a deeply nested array describing trigger conditions (IF)
 * and actions (DO) that are used to build the visual graph.
 *
 * IF element type is user account, THEN render it as an egg shape.
 * IF element has a dc:title property THEN use that as a label.
 * IF term is in the 'tags' vocab, THEN color it green.
 *
 * The IF side of things is made up by comparing the input data -
 * triple statements - with arguments specified in the rules here.
 * This is usually effected by callbacks, a couple of simple ones are provided.
 *
 * The THEN DO side of things is done by providing an array-shaped list of
 * attributes that are then applied to the graphViz objects, using a
 * combination of syntax from
 * http://pear.php.net/package/Image_GraphViz/docs/
 * and the 'dot' language documented at
 * http://www.graphviz.org/content/node-shapes
 *
 * Two actions are available: addNode and addEdge (per Image_GraphViz);
 * All attributes are optional, and the rendering engine will use some defaults
 * if not set.
 *
 * When told to addNode, the node in question is always the subject of the
 * predicate.
 * To addNode representing the *object*, such as when styling the target of a
 * rel statement that has a URI but little else,
 * use addObjectNode which is a unique wrapper we provide for this purpose.
 *
 * Although the terms are 'addNode' - they will actually merge attributes if
 * you try to add graphical elements more than once, with later additions
 * overwriting the earlier ones.
 * This means you can create rulesets that color all nodes Blue, then add a
 * rule that colors nodes tagged 'obselete' pink.
 *
 * The 'ON' parameter in rules is required for compatability with rules.module
 * and may be extended later with a more powerful class of rule processing
 * for 'subject' - not just triples.
 * For now, the 'ON' value MUST be set to an array containing the string
 * 'statement_process'.
 *
 * Pay attention to the array nesting. Conditions are often nested a little
 * more than you'd expect. This is to match the rules.module syntax, and
 * because it's actually neccessary in some cases. See the label_people rule.
 */
function rdfviz_node_rendering_ruleset() {
  $rules = array();

  // Fetch the chosen list of enabled rules.
  $rdfviz_enabled_rulesets = variable_get('rdfviz_enabled_rulesets', array('default' => TRUE, 'users' => TRUE));

  ctools_include('plugins');
  $module = 'rdfviz';
  $type = 'rdfviz_ruleset';
  // $available_rulesets = ctools_get_plugins($module, $type);

  foreach (array_filter($rdfviz_enabled_rulesets) as $ruleset_id => $on) {
    $ruleset_description = ctools_get_plugins($module, $type, $ruleset_id);
    $callback = $ruleset_description['ruleset_callback'];
    if (function_exists($callback)) {
      $rules += $callback();
    }
    else {
      watchdog('rdfviz', 'Invalid ruleset_callback. Could not find %callback that was defined in %ruleset_id', array('%callback' => $callback, '%ruleset_id' => $ruleset_id), WATCHDOG_ERROR);
    }
  }
  return $rules;
}

/**
 * Compare the condition check against the given data.
 *
 * By figuring out the
 * test to perform and calling the right callback.
 *
 * @param array $condition
 *   A an array with only one item.
 *   The key is the name of the test to apply,
 *   the value is a list of args to use.
 * @param array $data
 *   The data to check against (a triple statement).
 * @param string $rule_id
 *   Just for tracing & debugging messages.
 *
 * @return Bool
 *   Success depending if the triggers match.
 */
function rdfviz_rule_check_condition($condition, $data, $rule_id = '') {
  foreach ($condition as $check_callback => $args) {
    switch ($check_callback) {
      case 'AND':
        return rdfviz_rule_check_all_conditions($args, $data, $rule_id);

      case 'OR':
        return rdfviz_rule_check_any_conditions($args, $data, $rule_id);

      default:
        $callback_func = 'rdfviz_rule_check_' . $check_callback;
        // @see rdfviz_rule_check_predicate_is()
        // @see rdfviz_rule_check_object_is()
        // @see rdfviz_rule_check_type_is()

        if (function_exists($callback_func)) {
          return $callback_func($args, $data, $rule_id);
        }
        else {
          trigger_error("No callback called $callback_func() . Bad rule '$rule_id' tried to call it.");
        }
    }
    // Switch.
  }
  // Each callback (always only one unique?
  return NULL;
}

/**
 * Trigger handler for the 'AND' condition.
 *
 * @param array $args
 *   A list of conditions to check.- the IF clause from the ruleset.
 * @param array $data
 *   The data to check against (a triple statement)
 * @param string $rule_id
 *   Just for tracing & debugging messages.
 *
 * @return bool
 *   If any match correctly
 */
function rdfviz_rule_check_all_conditions($args, $data, $rule_id = "") {
  foreach ($args as $condition_id => $condition) {
    // Add some explanations to anyone trying to build rules on their own.
    if (!is_numeric($condition_id)) {
      trigger_error("Function " . __FUNCTION__ . " called with unexpected arguments from rule '$rule_id'. Condition list is expected to by a numerically indexed array, got a text key '$condition_id' instead. The structure of the rules being processed is probably wrong.");
      return FALSE;
    }
    if (!rdfviz_rule_check_condition($condition, $data, $rule_id)) {
      // Return on first failure.
      return FALSE;
    }
    // dpm(array($condition, $data), "$rule_id succeeded");
  }
  return TRUE;
}

/**
 * Trigger handler for the 'OR' condition.
 *
 * @param array $args
 *   A list of conditions to check.- the IF clause from the ruleset.
 * @param array $data
 *   The data to check against (a triple statement)
 * @param string $rule_id
 *   Just for tracing & debugging messages.
 *
 * @return bool
 *   If any match correctly
 */
function rdfviz_rule_check_any_conditions($args, $data, $rule_id = '') {
  foreach ($args as $condition_id => $condition) {

    // Add some explanations to anyone trying to build rules on their own.
    if (!is_numeric($condition_id)) {
      trigger_error("Function " . __FUNCTION__ . " called with unexpected arguments. Condition list is expected to by a numerically indexed array, got a text key '$condition_id' instead. The structure of the rules being processed is probably wrong.");
    }

    if (rdfviz_rule_check_condition($condition, $data, $rule_id)) {
      // Return on first success.
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Trigger handler for checking the predicate value of a triple.
 *
 * @param array $args
 *   Describes the value we want to match.
 * @param array $data
 *   An ARC2 style triple statement.
 *
 * @return bool
 *   If it matches.
 */
function rdfviz_rule_check_predicate_is($args, $data) {
  if ($check_value = $args['value']) {
    return $check_value == $data['p_curie'];
  }
  return FALSE;
}

/**
 * Trigger handler for checking the object value of a triple.
 *
 * If the object is of type uri, the CURIE will co compared,
 * otherwise, the literal value will be compared.
 *
 * @param array $args
 *   Describes the value we want to match.
 * @param array $data
 *   an ARC2 style triple statement.
 *
 * @return bool
 *   If it matches.
 */
function rdfviz_rule_check_object_is($args, $data) {
  if ($check_value = $args['value']) {
    return $check_value == (($data['o_type'] == 'uri') ? $data['o_curie'] : $data['o']);
  }
  return FALSE;
}

/**
 * Shortcut condition checker - is the type of the subject what we want.
 *
 * Shorthand for [predicate == "rdf:type" AND object == "?"]
 *
 * @param array $args
 *   Describes the value we want to match.
 * @param array $data
 *   an ARC2 style triple statement.
 *
 * @return bool
 *   If it matches.
 */
function rdfviz_rule_check_type_is($args, $data) {
  return rdfviz_rule_check_predicate_is(array('value' => 'rdf:type'), $data) && rdfviz_rule_check_object_is($args, $data);
}

/**
 * Use this to find and ignore bnodes if needed.
 *
 * Objects are usually uri or literal, but occasionally anonymous bnodes.
 *
 * Use this to check that the target is of the expected type, especially to
 * eliminate anonymous nodes that may be introduced by the parser.
 *
 * An example rule
 *   $rules['annotate_uris']['IF'][0]['object_type_is']['value'] = 'uri';
 *
 * @param array $args
 *   Describes the value we want to match.
 * @param array $data
 *   an ARC2 style triple statement.
 *
 * @return bool
 *   If it matches.
 */
function rdfviz_rule_check_object_type_is($args, $data) {
  if ($check_value = $args['value']) {
    return ($data['o_type'] == $check_value);
  }
  return FALSE;
}

/**
 * Trigger handler for checking any value in the triple against a value.
 *
 * eg
 * ['IF'][]['attribute_matches']['p_curie'] = 'dc:subject';
 * or
 * ['IF'][]['attribute_matches']['o_type'] = 'literal';
 * or multiples
 * ['IF'][]['attribute_matches'] => array(
 *   'p_curie' => 'dc:subject',
 *   'o_type' => 'literal',
 * );
 *
 * Available attributes are those from an ARC2 triple,
 * [s,p,o,s_type,o_type,s_curie,p_curie,o_curie]
 *
 * @param array $args
 *   Describes the value we want to match.
 * @param array $data
 *   an ARC2 style triple statement.
 *
 * @return bool
 *   If it matches
 */
function rdfviz_rule_check_attribute_matches($args, $data) {
  $match = TRUE;
  foreach ($args as $key => $val) {
    if ($data[$key] != $val) {
      $match = FALSE;
    }
  }
  return $match;
}

/**
 * Originally stolen from rdfx, then simplified.
 *
 * @param string $uri
 *   What to parse.
 *
 * @return ARC2_RDFParser
 *   A parser object.
 */
function rdfviz_parse_rdf($uri) {
  // Parser autodetects content, probably SemHTMLParser.
  $config = array('auto_extract' => 0);

  // I should get ARC to acknowledge all namespaces that Drupal knows about.
  if (function_exists('rdf_get_namespaces')) {
    #$config['ns'] = rdf_get_namespaces();
    ## Does not work as expected. These ns are registered but not actually used
  }

  /** @var ARC2_RDFParser $parser */
  $parser = ARC2::getRDFParser($config);

  // Honestly, I don't care if it's external or not.
  $parser->parse($uri);
  if ($errs = $parser->getErrors()) {
    trigger_error("When parsing $uri " . print_r($errs, 1));
    return $parser;
  }
  // However, ARC picks up on posh-rdf (defunct and wrong) when it sees rel=tag
  // so need to tell it not to extract that. just these wanted ones:
  // $parser->extractRDF('dc openid erdf rdfa microformats posh-rdf');
  // Blast. When I ask for microformats, I get posh also.
  // Well, rather have microformats than not.
  $parser->extractRDF('dc openid erdf rdfa microformats');

  // Even though the rel='tag' microformat fails.
  // <a rel="tag" href="/topic/centro">Centro</a>
  // returns [. mf:tag "Centro"]
  // But I wanted [. mf:tag ns:/topic/centro]
  // "rel" means the thing we are referring to is a LINK dammit.

  // Not sure why the $arc object doesn't remember its own namespaces.
  // Re-add them here.
  $namespaces = array();
  foreach ($parser->parser->nsp as $ns_uri => $prefix) {
    $namespaces[$prefix] = $ns_uri;
  }

  // Also, it may have added its own '0' or numbered namespace
  // for things it doesn't recognise byt we do.
  // Normalize the list.
  // This is fucked up. This case was found when reading a raw XML/RDF file
  // that had a default namespace.
  if (function_exists('rdf_get_namespaces')) {
    $rev_namespaces = array_flip($namespaces);
    $our_rev_namespaces = array_flip(rdf_get_namespaces());
    $namespaces = array_flip($our_rev_namespaces + $rev_namespaces);
  }

  // If it was RSS source, ns1 ichould be 'rss' :-/
  // RSS feeds (from many souces including Drupal) may not declare their
  // xmlns. We end up with rss:item as ns1. Can I hint at that?
  // Yes. Declare rss then alias ns1 to it.
  if (preg_match('@rss.xml@', $uri)) {
    $namespaces['rss'] = 'http://purl.org/rss/1.0/';
    $namespaces['ns1'] = 'http://purl.org/rss/1.0/';
  }

  // Chop http://some.thing/path/etc into just http://some.thing/
  // This ALSO works on myself, my own absolute siteroot.
  $base_url = preg_replace('|^([^/]*?//[^/]*)/?.*$|', '$1/', $uri);
  $namespaces += rdfviz_extra_drupal_namespaces($base_url);

  $parser->ns = $namespaces;

  return $parser;
}

/**
 * Render an Image_Graphviz graph.
 *
 *
 * @param Image_Graphviz $g
 * @param string $format
 * @param string $command
 *
 * @return null|string
 *   HTML snippet containing our image.
 */
function graphviz_render(&$g, $format = 'png', $command = 'dot') {
  $outdir = 'public://graphviz';
  $output = '';
  $dot = $g->parse();
  $slug = md5($dot);
  $outputfileuri = "$outdir/{$slug}.{$command}.{$format}";
  // Graphviz 2010-10-24 only allows neato & dot processing, but can be easily
  // patched to include the others.

  // Due to http://pear.php.net/bugs/bug.php?id=18227 (PHP5.3 - won't fix)
  // graphviz process may throw complaints, but still works for now.
  // Strict warning: Non-static method System::tmpdir()
  // should not be called statically.
  // So ignore complaints coming from inside Pear calls here.
  // All online troubleshooting answers seem to point at this as the only way.

  // Horrible bug. If running on Acquia dev desktop, it sets a custom path for
  // the dynamic link library. But 2012-04 that was OLDER than the libraries
  // My OS expected to use to run 'dot' with.
  // Reason: Incompatible library version:
  // dot requires version 10.0.0 or later,
  // but libltdl.7.dylib provides version 9.0.0
  //
  // UNSET the Acquia DYLD_LIBRARY_PATH before dropping to commandline to run
  // the dot command.
  $DYLD_LIBRARY_PATH = getenv("DYLD_LIBRARY_PATH");
  putenv("DYLD_LIBRARY_PATH=");
  $outfile = @$g->fetch($format, $command);
  // Put it back just in case it matters.
  putenv("DYLD_LIBRARY_PATH=$DYLD_LIBRARY_PATH");

  if (empty($outfile)) {
    trigger_error('Graphviz processing returned an empty result');
    return NULL;
  }

  if ($format == 'svg') {
    // Hey cool.
    // ALMOST
    // the output will be hard-linked to the wrong URLs.
    // Needed LOCAL image links when building the svg, need absolute ones when
    // displaying it. So ... translate all URLs.
    $xml = new DomDocument();
    $xlink_ns = "http://www.w3.org/1999/xlink";
    $xml->loadXML($outfile);
    $imgs = $xml->getElementsByTagName('image');

    /** @var $img DOMElement */
    foreach ($imgs as $img) {
      $img->setAttributeNS($xlink_ns, 'href', url($img->getAttributeNS($xlink_ns, 'href')));
    }
    $outfile = $xml->saveXML();
    // That wasn't so hard now ...

    $output .= '<embed type="image/svg+xml" >' . $outfile . '</embed>';
  }
  else {
    // Normal images, copy the binary to a visible spot and embed it.
    file_prepare_directory($outdir, FILE_CREATE_DIRECTORY);
    file_unmanaged_save_data($outfile, $outputfileuri, FILE_EXISTS_REPLACE);

    // Do the imagemap.
    $map = @$g->fetch('cmapx', $command);
    $id = 'G';
    $match = array();
    if (preg_match('/<map[^>]*id\s*=\s*"(.*?)"/', $map, $match)) {
      $id = $match[1];
    }
    $output .= $map;
    $image_atts['usemap'] = "#$id";

    $output .= theme('image', array('path' => file_create_url($outputfileuri), 'attributes' => $image_atts));
  }

  return $output;
}

/**
 * Find and include the required ARC2 library.
 */
function rdfviz_load_arc() {
  if (class_exists('ARC2')) {
    return TRUE;
  }

  // Possible paths to the ARC2 PHP library.
  $search_paths = array(
    'sites/all/libraries/arc',
    'sites/all/libraries/ARC2/arc',
    drupal_get_path('module', 'rdfx') . '/vendor/arc',
  );
  if (module_exists('libraries')) {
    $search_paths[] = libraries_get_path('ARC2') . '/arc';
  }
  $rdf_arc2_path = '';
  foreach ($search_paths as $rdf_arc2_path) {
    if (file_exists($rdf_arc2_path . '/ARC2.php')) {
      @include_once $rdf_arc2_path . '/ARC2.php';
      return TRUE;
    }
  }
  drupal_set_message(t("No ARC library found at %rdf_arc2_path", array('%rdf_arc2_path' => $rdf_arc2_path)));
  return FALSE;
}

/**
 * Find and include the required graphViz library from your Pear folder.
 */
function rdfviz_load_graphviz($directed = TRUE, $strict = TRUE) {
  $binPath = variable_get('rdfviz_binpath', '/usr/local/bin/');
  putenv('PATH=' . getenv('PATH') . PATH_SEPARATOR . $binPath);

  // Do we have Pear on the system?
  if (@include_once ('PEAR.php')) {
    // PEAR::setErrorHandling (PEAR_ERROR_TRIGGER);
    // PHP strict disallows this today.
    // "Non-static method PEAR::setErrorHandling()
    // should not be called statically".
  }

  if (@include_once ('Image/GraphViz.php')) {
    // Initialize a GraphViz Object
    // Trigger PEAR error on failure so we can debug it.
    $g = new Image_Graphviz($directed, NULL, NULL, $strict, TRUE);
    $g->binPath = $binPath;
    return $g;
  }
  // Look in libraries for it
  $search_paths = array(
    'sites/all/libraries/pear',
  );

  $search_path = 'No Search Path';
  foreach ($search_paths as $search_path) {
    if (file_exists($search_path . '/Image/GraphViz.php')) {
      set_include_path(get_include_path() . PATH_SEPARATOR . $search_path);
      @include_once'Image/GraphViz.php';
      // Initialize a GraphViz Object.
      $g = new Image_Graphviz($directed, NULL, 'G', $strict, FALSE);
      $g->binPath = $binPath;
      return $g;
    }
  }
  drupal_set_message(t("No Pear Graphviz library found at $search_path"));
  return FALSE;
}

/**
 * Trial a contrib graphviz visualization plugin
 *
 * This is ugly as sin.
 * Do not use!
 * https://github.com/semsol/arc2/wiki/Plugins:-Triples-Visualizer
 *
 * @param ARC2_RDFParser $arc
 *   ARC2 object.
 *
 * @return string
 *   HTML.
 */
function rdfviz_triplesvizualizerplugin($arc) {

  /* configuration */

  $config = array(
    /* path to dot */
    'graphviz_path' => '/usr/local/bin/dot',
    /* tmp dir (default: '/tmp/') */
    'graphviz_temp' => sys_get_temp_dir(),
    /* pre-defined namespace prefixes (optional) */
    'ns' => $arc->ns,
  );

  /** @var ARC2_TriplesVisualizerPlugin $viz */
  $viz = ARC2::getComponent('TriplesVisualizerPlugin', $config);
  $triples = $arc->getTriples();

  /* Display an svg image. */

  $svg = $viz->draw($triples, 'svg', 'base64');
  return '<embed type="image/svg+xml" src="data:image/svg+xml;base64,' . $svg . '"/>';
}


///////////////////////////////////////////////////////////////////////////////

/**
 * I will manage rendering rulesets as plugins.
 * Tell ctools about what I expect from plugins.
 *
 * Implements hook_ctools_plugin_type().
 */
function rdfviz_ctools_plugin_type() {
  $plugins['rdfviz_ruleset'] = array(
    'load themes' => TRUE,
  );

  return $plugins;
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function rdfviz_ctools_plugin_directory($owner, $plugin) {
  if ($owner == 'rdfviz' && !empty($plugin)) {
    return "plugins/$plugin";
  }
  return NULL;
}

