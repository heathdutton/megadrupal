<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
        "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Getting started</title>
</head>
<body>
<p>

    This tool takes <em>full web pages</em> as input.
    Although you can ask it to render a 'node', you won't get much out of it
    other
    than something a bit like an Entity Relationship Diagram.
</p>

<p>
    It's much more interesting if you point it at the output of a 'view',
    or a list of annotated teasers, because then you see what the relationships
    between entities are, and how they cluster.
</p>

<p>There is no front-end UI built yet, so far you just have to enter the URL
    you want.</p>

<p>A similar, but much more raw graph (using a similar method) is used for
    diagramming a number RDF concepts in formal ducumentation.
    An interactive version of that is available at <a
            href="http://inspector.sindice.com/">inspector.sindice.com</a>. Or
    using other techy tools like Tim BL's Tabulator or Simile's Fresnel
    (Unlinked as they are both now defunct).
    <br/>However, <a href="http://nopain2.org/archives/000058.html">"great big
    graphs" suck at communicating linked data</a>.
    <br><em>This</em> module introduces domain-specific rendering options that
    can be enabled to tell specific stories better and filter out the less
    important connections.</p>

<p>
    The RDFViz utility publishes RDF Visualizations (node-graphs) under the URL

    <code>/rdfviz/{method}/{source_url}</code>
    eg
    <code>/rdfviz/png/{source_url}</code>
</p>

<p>
    Settings are found at <code>/admin/config/services/rdfviz</code>
</p>

<h2>Rendering Rulesets</h2>

<p>There, you can choose from the available rulesets.
    As different data (stafflists, book indexes, structural information, social
    graphs)
    use different vocabularies and occasionally different meanings, you need to
    select (or create) the correct rules and rulesets to draw the picture that
    makes the most sense.
</p>

<p>
    For one visualization, you may wish to ensure that each author is linked
    with their content, or in another you may want to make sure that all content
    that is tagged is linked to its related content. Or both.
    As the data gets richer however, you should turn some of these off, as it
    gets messy fast.
</p>

<p>Specialist vocabularies, eg for a network diagram that describes routers,
    servers, clients and services, are not needed if trying to diagram FOAF
    relationships, and vice versa. Occasionally they may even conflict, as one
    mental model that uses (eg) rdfs:broader may be telling a different story
    with it than another that uses the same predicate.
</p>

<p>Short story: start with the default settings (every item is a blob) and then
    add the additional rules to start giving them visual meaning.</p>

<h3>Developing rulesets</h3>

<p>A good place to start, if you are expecting data to show up and it's not yet
    being rendered on screen, is to look at the 'raw' extracted semantics.
    EG,
    /rdfviz/raw/http://www-sop.inria.fr/acacia/fabien/tmp/grddl/rdfaprimer/RDFaExemple.html
</p>
<img src="raw_rdf_extracted_statements.png"/>
<img src="raw_rdf_untuned_diagram.png"/>

<p>
    If there is a statement there that's not exposed in the diagram - in this
    case the dc:creator link between the resource and the author, you should
    find a way of surfacing it.
    Visit the settings, and enable the rendering ruleset for 'users'. As well as
    slightly styling items that are identified as 'Person', it contains the rule
    to link dc:creator from author to an authors work.
</p>
<img src="raw_rdf_linked_diagram.png"/>

<h2>Rulesets</h2>
<p>
Rulesets are somewhat modelled on the format used by the Drupal 'Rules' module.
</p><p>

A ruleset is a list of labelled rules.
Each rule consists of an event trigger, a condition, and an action.
Each of these may be multiple, so each of these is a numeric array, even if only one of them exists.
</p><p>

So far only the 'statement_process' event is supported.
</p><p>

Conditions are sets of checks, that may be grouped using OR and AND, and may be nested.
Usually the checks then boil down to string matches against the subject or predicate, eg
  "is the predicate = 'dc:title'"
or
  "is the predicate = 'rdf:typeof' AND the object='foaf:Person' "
<pre>
  'AND' =>
    array(
      'check_predicate' => array('value' => 'rdf:typeof'),
      'check_object' => array('value' => 'foaf:Person'),
    )
</pre>
</p><p>

Actions are reflections of graphviz methods provided by the Image_Graphviz
component and usually boil down to the equivalent of function calls with
arguments, eg:
  "Add a node shaped like a note, and filled with solid color"
<pre>
  'addNode' => array('shape' => 'note', 'style' => 'filled' )
</pre>

</p><p>

Internally, that is a set of arrays that can be modelled in BNF format:
</p>
<blockquote><small><code>

<dl>
    <dt>&lt;ruleset&gt; ::=</dt>
    <dd>array( { "&lt;string&gt;" => &lt;rule&gt; } );</dd>
    <dt>&lt;rule&gt; ::=</dt>
    <dd>array( 'LABEL' => "&lt;string&gt;", 'ON' => array( { &lt;events&gt; } ), 'IF' => &lt;conditions&gt;, 'DO' => &lt;actions&gt; )</dd>

    <dt>&lt;events&gt; ::=</dt>
    <dd>array( { 'statement_process' } )</dd>

    <dt>&lt;conditions&gt; ::=</dt>
    <dd>array( { &lt;condition&gt; | &lt;nestedcondition&gt; } )</dd>
    <dt>&lt;condition&gt; ::=</dt>
    <dd>&lt;valuecheck&gt; => &lt;valuepair&gt; | &lt;multicheck&gt; => &lt;keypairs&gt;</dd>

    <dt>&lt;valuecheck&gt; ::=</dt>
    <dd>'predicate_is' | 'object_is' | 'object_type_is'</dd>
    <dt>&lt;valuepair&gt; ::=</dt>
    <dd>array( 'value' => "&lt;string&gt;" )</dd>

    <dt>&lt;multicheck&gt; ::=</dt>
    <dd>'attribute_matches'</dd>
    <dt>&lt;keypairs&gt; ::=</dt>
    <dd>array( { "&lt;string&gt;" => "&lt;string&gt;" } )</dd>

    <dt>&lt;nestedcondition&gt; ::=</dt>
    <dd>&lt;conditionbool&gt; => array( { &lt;conditions&gt; } )</dd>
    <dt>&lt;conditionbool&gt; ::=</dt>
    <dd>'AND' | 'OR' | 'NOT'</dd>


    <dt>&lt;actions&gt; ::=</dt>
    <dd>array( { &lt;action&gt; | &lt;actionoptions&gt; } )</dd>
    <dt>&lt;action&gt; ::=</dt>
    <dd>&lt;graphmethod&gt; => &lt;keypairs&gt; </dd>
    <dt>&lt;graphmethod&gt; ::=</dt>
    <dd>addNode | addEdge</dd>
    <dt>&lt;actionoptions&gt; ::=</dt>
    <dd>{ 'reverse => TRUE'  }</dd>


</dl>
</code></small></blockquote>

This grammar produces structures like:

<blockquote><small>
<pre>
  $rules['label_anything'] = array(
    'LABEL' => 'Anything with a dc:title should use that as a label',
    'ON' => array(0 => 'statement_process'),
    'IF' => array(
      0 => array(
        'predicate_is' => array(
          'value' => 'dc:title',
        ),
      ),
    ),
    'DO' => array(
      0 => array(
        'addNode' => array(
          'attributes' => array(
            'label' => '!o',
          ),
        ),
      ),
    ),
  );

</pre></small></blockquote>

See the plugin examples for more. The 'default' ones are heavily documented.

</h2>
</body>
</html>
