<?php

/**
 * @file
 * The base module.
 */

/**
 * Implements hook_views_api().
 */
function views_fast_forward_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'views_fast_forward') . '/views',
  );
}

/**
 * Implements hook_views_post_render().
 *
 * Go directly to the provided path if only one result is generated
 * and the Views Fast Forward option is configured (and we aren't editing the view).
 *
 * Using the "post_render" hook so live plugins, who rely on the actual
 * output via AJAX (such as an autocomplete), have a chance to
 * capture the results before being forwarded.
 */
function views_fast_forward_views_post_render(&$view, &$output, &$cache) {
  // Get the options of our current display.
  $options = $view->display_handler->extender['views_fast_forward']->get_options();
  $enabled = $options['ff_enabled'];
  $manual = $options['ff_manual'];
  $path = $options['ff_path'];
  $tokenized = $options['ff_tokenize'];

  // Check if we actually need to fast forward.
  if (!$enabled || count($view->result) != 1 || $view->editing == 1) {
    return;
  }

  // If entered manually, Check if the given path needs to be tokenized.
  if ($manual && $tokenized) {
    $path = $view->style_plugin->tokenize_value($path, 0);
  }

  // If the path is not given manually, try to detect it.
  if (!$manual) {
    $path = _detect_entity_path($view);
  }

  if ($path) {
    // We found a path, do the actual redirect.
    drupal_goto($path);
  }
  else {
    // We are unable to find a path automatically and non is given manually.
    // Write a message in the watchdog and do not perform a redirect,
    // simply show the View results as if this module never existed.
    $type = 'Views Fast Forward';
    $message = <<<'EOT'
      Views Fast Forward could not determine the path to your entity.
      Don't worry, the user was simply redirected to the search results page
      and did not notice a thing. If, however, you still wish to have the
      fast forward functionality, I suggest you manually construct the redirect
      path within you View display's settings. The display
      <a href="@display-link">@display</a> is reponsible for this message
      (located in the View <a href="@view-link">@view</a>).
EOT;
    $message = t($message, array(
                 '@display-link' => url('admin/structure/views/view/' . $view->name . '/edit/' . $view->current_display),
                 '@display' => $view->current_display,
                 '@view-link' => url('admin/structure/views/view/' . $view->name),
                 '@view' => $view->human_name));
    $severity = WATCHDOG_NOTICE;
    watchdog($type, $message, $variables = array(), $severity);

    // Do nothing and show the View results.
    return;
  }
}

/**
 * Helper to figure out the path to the entities used in Views.
 *
 * Using the "base_table" from views to determine which type of
 * entity we are dealing with. A lookup helper is used in case
 * we are dealing with non-core entities. Since such a lookup
 * comes with a small performance penalty, the basic core
 * entities are shortcut. Considered core entities:
 * - Node
 * - Taxonomy term
 * - User
 * - Comment
 *
 * Files are not included as what would fast forwarding
 * to a file mean ... ? Downloading it directly?
 */
function _detect_entity_path(&$view) {
  $path = NULL;

  // See if we are dealing with core entities, if so
  // then shortcut the lookup.
  switch ($view->base_table) {
    case 'node':
      $path = 'node/' . $view->result[0]->nid;
      break;

    case 'taxonomy_term_data':
      $path = 'taxonomy/term/' . $view->result[0]->tid;
      break;

    case 'users':
      $path = 'user/' . $view->result[0]->uid;
      break;

    case 'comment':
      $path = 'comment/' . $view->result[0]->cid;
      break;

  }

  // If not a core entity, try to find the correct path.
  if (!$path) {
    $path = _detect_foreign_entity_path($view);
  }

  return $path;
}

/**
 * Helper to figure out the path for foreign entities.
 *
 * Finding custom entity information via a View object is not so trivial in D7.
 *
 * For this we have to leverage the Ctools/Views helpers to load the different
 * Views-enabled entities with their base table information. We cross-reference
 * this information with the base table of our View to get the entity type.
 *
 * Next we fetch the ID name of the entity and search for the actual ID
 * in the View results. We then use this ID to load the entity and
 * use the Drupal core "entity_uri()" to fetch the actual path.
 *
 * This method *should* work for all D7 entities, for they all have to
 * adhere to a certain standard which is assumed in this function.
 *
 * Returns either the path if found, or leaves the path at NULL.
 */
function _detect_foreign_entity_path(&$view) {
  // Load in the necessary lookup functions from Views (Ctools) itself.
  module_load_include('inc', 'views', 'includes/admin');
  $entities = views_ui_get_wizards();

  $path = NULL;

  // Cross-reference the base table with the entity type key.
  foreach ($entities as $entity_type => $entity_extra) {
    if ($entity_extra['base_table'] === $view->base_table) {

      // The entity type name is found, now try to find the used entity ID name.
      if (entity_get_info($entity_type)['entity keys']['id']) {
        $entity_id_name = entity_get_info($entity_type)['entity keys']['id'];
      }
      else {
        // Entity ID name could not be found.
        break;

      }

      // Try to fetch the base URI the entity is using.
      if ($view->result[0]->$entity_id_name) {
        $entity_id = $view->result[0]->$entity_id_name;
      }
      else {
        // Entity ID could not be found.
        break;

      }

      // Try to load the actual entity itself.
      try {
        $entity = entity_load($entity_type, array($entity_id))[$entity_id];
      }
      catch (Exception $e) {
        // Entity could not be loaded.
        break;

      }

      // Try to find the path to the individual entity.
      try {
        $path = entity_uri($entity_type, $entity)['path'];
      }
      catch (Exception $e) {
        // Entity URI could not be found.
        break;
      }

      break;
    }
  }

  return $path;
}

/**
 * Implements hook_help().
 */
function views_fast_forward_help($path, $arg) {
  switch ($path) {
    case 'admin/help#views_fast_forward':

      $path = dirname(__FILE__) . '/README.md';
      if (file_exists($path)) {
        $readme = file_get_contents($path);
      }
      else {
        $path = dirname(__FILE__) . '/README.txt';
        if (file_exists($path)) {
          $readme = file_get_contents($path);
        }
      }
      if (!isset($readme)) {
        return NULL;
      }
      if (module_exists('markdown')) {
        $filters = module_invoke('markdown', 'filter_info');
        $info = $filters['filter_markdown'];

        if (function_exists($info['process callback'])) {
          $output = $info['process callback']($readme, NULL);
        }
        else {
          $output = '<pre>' . $readme . '</pre>';
        }
      }
      else {
        $output = '<pre>' . $readme . '</pre>';
      }

      return $output;
  }
}
