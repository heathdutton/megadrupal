<?php


/**
 * Implements hook_schema_alter().
 */
function language_hierarchy_schema_alter(&$schema) {
  $schema['languages']['fields']['parent'] = array(
    'type' => 'varchar',
    'length' => 12,
    'not null' => FALSE,
    'default' => 0,
    'description' => 'Code of parent language.',
  );
}

/**
 * Implements hook_menu_alter().
 *
 * Use our form instead of the default one from locale module.
 */
function language_hierarchy_menu_alter(&$items) {
  // Change the item values by reference.
  $items['admin/config/regional/language']['title'] = 'Language hierarchy';
  $items['admin/config/regional/language']['page arguments'] = array('language_hierarchy_form');
  $items['admin/config/regional/language']['file'] = 'language_hierarchy_form.inc';
  $items['admin/config/regional/language']['file path'] = drupal_get_path('module', 'language_hierarchy');
}

/**
 * Implements hook_theme().
 *
 * We need run our forms through custom theme functions in order to build the
 * table structure which is required by tabledrag.js.  Before we can use our
 * custom theme functions, we need to implement hook_theme in order to register
 * them with Drupal.
 *
 * We are defining our theme hooks with the same name as the form generation
 * function so that Drupal automatically calls our theming function when the
 * form is displayed.
 */
function language_hierarchy_theme() {
  return array(
    // Theme function for the 'simple' example.
    'language_hierarchy_form' => array(
      'render element' => 'form',
      'file' => 'language_hierarchy_form.inc',
    ),
  );
}



/**
 * Implementation of hook_form_FORM_ID_alter().
 *
 * We need to alter the language delete form to stop users from deleting parent languages.
 */
function language_hierarchy_form_locale_languages_delete_form_alter(&$form, &$form_state) {

  $language_code = isset($form['langcode']['#value']) ? $form['langcode']['#value'] : '' ;
  $descendants = language_hierarchy_get_descendants($language_code);

  // If the language is a parent, then we can't delete it. 
  if (isset($descendants->children) && sizeof($descendants->children) > 0 ) {
     $message = t('The @languagename language has @childlanguages child languages. These must be moved or deleted before you can delete this language. ', array('@languagename' => $descendants->name, '@childlanguages' => sizeof($descendants->children)));
     drupal_set_message($message, 'warning');
     drupal_goto('admin/config/regional/language');
  }

}


/**
 * Implementation of hook_form_FORM_ID_alter().
 *
 * Alter the predefined language add form to include language parent functionality.
 */
function language_hierarchy_form_locale_languages_predefined_form_alter(&$form, &$form_state) { 

  // Add language parent select list into the predefined add form fieldset.
  $form['language list']['parent_language_list'] = _language_hierarchy_add_language_parent_select_list();

  // Include a submit callback to update the parent language.
  $form['#submit'][] = 'language_hierarchy_language_add_form_submit_callback';
}


/**
 * Implementation of hook_form_FORM_ID_alter().
 *
 * Alter the custom language add form to include language parent functionality.
 */
function language_hierarchy_form_locale_languages_custom_form_alter(&$form, &$form_state) { 
  // Add language parent select list into the predefined add form fieldset.
  $form['custom language']['parent_language_list'] = _language_hierarchy_add_language_parent_select_list();

  // Include a submit callback to update the parent language.
  $form['#submit'][] = 'language_hierarchy_language_add_form_submit_callback';
}


/**
 * A common function to return laguage parent select list for use in language add forms.
 * 
 * @return array FAPI select list 
 */
function _language_hierarchy_add_language_parent_select_list() {
  $languages = language_hierarchy_language_list();
  $options = array('none' => 'No parent language');
  
  // Creation options for parent language select list.
  foreach ($languages as $language_code => $language) {
    $indent = str_repeat('- ', $language->depth);
    $options[$language_code] = t('@indent @language_name (@language_code)', array('@indent' => $indent, '@language_name' => $language->name, '@language_code' => $language->language ) ) ;
  }

  $select_list = array(
    '#type' => 'select',
    '#title' => 'Parent language',
    '#options' => $options,
    '#default_value' => 'none',
    '#description' => 'Select the parent language',
  );
  
  return $select_list;
}


/**
 *  An additional submition callback for the add predefined language form.
 */
function language_hierarchy_language_add_form_submit_callback($form, &$form_state) {
  if (isset($form_state['values']['parent_language_list']) && $form_state['values']['parent_language_list'] != 'none') {
    // Reset static cache language so the list is fetched from database
    drupal_static_reset('language_hierarchy_language_list');
    drupal_static_reset('language_hierarchy_get_children');
    drupal_static_reset('language_hierarchy_get_root_languages');

    // Update the parent information.
    db_update('languages')
      ->fields(array(
        'parent' => $form_state['values']['parent_language_list'],
      ))
      ->condition('language', $form_state['values']['langcode'], '=')
      ->execute();

    // Normalize weight, so languages are returned in correct order for flat lists.
    _language_hierarchy_normalize_weight();
  }
}


/**
 * Returns parent language of the provided language.
 *
 * @param $langcode
 *   Code of language you want to retrieve parent of.
 *
 * @return mixed
 *   Parent language, NULL otherwise
 */
function language_hierarchy_get_parent($langcode) {
  $languages = language_list();

  if (isset($languages[$langcode])
    && $languages[$langcode]->parent != NULL
    && isset($languages[$languages[$langcode]->parent])) {
    return $languages[$languages[$langcode]->parent];
  }
  else {
    return NULL;
  }
}

/**
 * Return children of the language provided
 *
 * @param $langcode
 *
 * @return array()
 *   Array with children languages
 */
function language_hierarchy_get_children($langcode) {
  $children = &drupal_static(__FUNCTION__);

  if (!isset($children[$langcode])) {
    $children[$langcode] = db_select('languages', 'l')
      ->fields('l')
      ->condition('parent', $langcode)
      ->orderBy('weight', 'ASC')
      ->orderBy('name', 'ASC')
      ->execute()
      ->fetchAllAssoc('language');
  }

  return $children[$langcode];
}

/**
 * Returns top level languages.
 *
 * @return array
 *   List of top level languages, keyed with language code
 */
function language_hierarchy_get_root_languages() {
  $top_level_languages = &drupal_static(__FUNCTION__);

  if (!isset($top_level_languages)) {
    $is_null = db_or()
      ->condition('parent', '')
      ->condition('parent', NULL);

    $top_level_languages = db_select('languages', 'l')
      ->fields('l')
      ->condition($is_null)
      ->orderBy('weight', 'ASC')
      ->orderBy('name', 'ASC')
      ->execute()
      ->fetchAllAssoc('language');
  }

  return $top_level_languages;
}

/**
 * Returns ancestors language code of the provided language.
 *
 * @param $langcode
 *   Code of language you want to retrieve parent of.
 *
 * @param $enabled_languages_only Boolean
 *   Determines wether only the enabled language ancestors will be shown.
 *
 * @return mixed
 *   Ordered array with all ancestors, most specific on the top.
 */
function language_hierarchy_get_ancestors($langcode, $enabled_languages_only = FALSE) {
  $ancestors = array();

  while($ancestor = language_hierarchy_get_parent($langcode)) {

    // Check conditions on wether to add the language ancestor to the results.
    if ($enabled_languages_only == FALSE || $ancestor->enabled == TRUE) {
      $ancestors[$ancestor->language] = $ancestor;  
    }

    $langcode = $ancestor->language;
  }

  return $ancestors;
}

/**
 * Returns tree of descendants for the provided language.
 *
 * @param $langcode
 *   Code of language you want to retrieve descendants of.
 *
 * @return mixed
 *   Requested language object with 'children' property containing the tree of descendants
 */
function language_hierarchy_get_descendants($langcode = NULL, &$language = NULL) {
  $languages = language_list();

  if (!empty($languages[$langcode])) {
    $language = $languages[$langcode];
    $children = language_hierarchy_get_children($langcode);
    foreach($children as $child_code => $child) {
      $language->children[$child_code] = language_hierarchy_get_descendants($child_code, $child);
    }
  }

  return $language;
}


/**
 * Returns flat list of languages with additional depth information, ordered in manner that is then usable by tablesort
 *
 * @return array()
 *   Language list
 */
function language_hierarchy_language_list() {
  $languages = &drupal_static(__FUNCTION__);

  if (empty($languages)) {
    $root_languages = language_hierarchy_get_root_languages();
    foreach($root_languages as $langcode => $language) {
      $language->depth = count(language_hierarchy_get_ancestors($langcode));
      $languages[$langcode] = $language;
      _language_hierarchy_language_list_descendants($langcode, $languages);
    }
  }

  return $languages;
}

/**
 * Sets a parent of specified language
 *
 * @param $language
 *   Code of the language you want to set parent for
 *
 * @param $parent_langcode
 *   Code of the language to set parent to
 */
function language_hierarchy_set_parent($langcode, $parent_langcode) {
  $languages = language_list();

  // Check if the language requested as new parent exists and is not one of the descendants of $langcode
  if (empty($languages[$parent_langcode])) {
    return FALSE;
  }

  if (!empty($languages[$langcode])) {
    db_update('languages')
      ->fields(array(
        'parent' => $parent_langcode,
      ))
      ->condition('language', $langcode)
      ->execute();

    return TRUE;
  }
  else {
    return FALSE;
  }
}


/**
 * Implements hook_language_fallback_candidates_alter().
 *
 * Alter the language fallbacks so that languages only fallback to their ancestors in the hierarchy tree.
 * Root items do not fall back to other root items, or English.
 * This allows constructions of languages where Spanish languages can fallback to a common Spanish ancestor content
 * while bypassing English content.
 */
function language_hierarchy_language_fallback_candidates_alter(array &$fallback_candidates) {

  // Get the ancestors of the currently request language. Use these as the fallback language candidates
  $fallback_languages = array_keys(language_hierarchy_get_ancestors($GLOBALS['language']->language, TRUE));
  // Language nuetral should always be the last item in the list. 
  $fallback_languages[] = LANGUAGE_NONE;

  // Overwrite the list of fallback languages with our own ordered, filtered set.
  $fallback_candidates = $fallback_languages;
}

/**
 * Recursion helper function that populates language_list in hierarchical order
 *
 * @param $langcode
 *   Code of language to request descendants of
 *
 * @param null $languages
 *   List to populate
 */
function _language_hierarchy_language_list_descendants($langcode, &$languages = NULL) {
  $children = language_hierarchy_get_children($langcode);
  foreach($children as $child_code => $child) {
    $child->depth = count(language_hierarchy_get_ancestors($child_code));
    $languages[$child_code] = $child;
    _language_hierarchy_language_list_descendants($child_code, $languages);
  }
}

/**
 * Normalizes weight of the languages so 'flat' functions like
 * language_list still return the languages in correct order.
 */
function _language_hierarchy_normalize_weight() {
  $languages = language_hierarchy_language_list();

  $mormalized_weight = -10;
  foreach($languages as $langcode => $language) {
    db_update('languages')
      ->fields(array(
        'weight' => $mormalized_weight,
      ))
      ->condition('language', $langcode, '=')
      ->execute();
    $mormalized_weight++;
  }
}