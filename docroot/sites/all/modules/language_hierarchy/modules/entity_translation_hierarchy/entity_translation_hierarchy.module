<?php

/**
 * Implements hook_menu_alter().
 */
function entity_translation_hierarchy_menu_alter(&$items) {
  $items['node/%node']['page callback'] = 'entity_translation_hierarchy_node_page_view';
  $items['node/%node']['access callback'] = 'entity_translation_hierarchy_node_access_callback';
}

/**
 *  * Custom anode access callback, used only when accessing the node directly via menu router.
 * In such a scenario we have to pass the access, so custom node_page_view callback can return 404 if there's a blocked language in the hierarchy chain.
 *
 * @param $op
 * @param $node
 * @param null $account
 * @return bool|string
 */
function entity_translation_hierarchy_node_access_callback($op, $node, $account = NULL) {
  if ($op == 'view') {
    global $language;

    if (entity_translation_hierarchy_is_blocked($node, 'node', $language->language)) {
      return NODE_ACCESS_ALLOW;
    }
  }

  return node_access($op, $node, $account);
}

/**
 * Custom node_page_view function that returns 404 if the translation fallback of a node is blocked.
 *
 * @param $node
 * @return array|int
 */
function entity_translation_hierarchy_node_page_view($node) {
  global $language;

  if (entity_translation_hierarchy_is_blocked($node, 'node', $language->language)) {
    return MENU_NOT_FOUND;
  }

  return node_page_view($node);
}

/**
 * Implements hook_node_access().
 *
 * In most node_access scenarios access to node with blocked translation should be denied.
 */
function entity_translation_node_access($node, $op, $account) {
  if ($op == 'view') {
    global $language;

    if (entity_translation_hierarchy_is_blocked($node, 'node', $language->language)) {
      return NODE_ACCESS_DENY;
    }
  }

  return NODE_ACCESS_IGNORE;
}

/**
 * Implements hook_field_attach_view_alter().
 *
 * Hide the entity if language fallback is enabled and there are no languages to fallback to for given node.
 */
function entity_translation_hierarchy_field_attach_view_alter(&$output, $context) {
  if (variable_get('locale_field_language_fallback', TRUE)
    && entity_translation_enabled($context['entity_type'])) {

    $handler = entity_translation_get_handler($context['entity_type'], $context['entity']);
    $translations = $handler->getTranslations();
    $langcode = !empty($context['language']) ? $context['language'] : $GLOBALS['language_content']->language;

    // If fallback is disabled we need to notify the user that the translation
    // is unavailable (missing or unpublished).
    if (!empty($translations->data)
      && ((!isset($translations->data[$langcode]) && !isset($translations->data[LANGUAGE_NONE]) && !entity_translation_hierarchy_get_candidate($context['entity'], $context['entity_type'], $langcode))
      || ((isset($translations->data[$langcode]) && !entity_translation_access($context['entity_type'], $translations->data[$langcode]) && !entity_translation_hierarchy_get_candidate($context['entity'], $context['entity_type'], $langcode))))) {

      $output['#view_mode'] = $context['view_mode'];
      $output['#entity'] = $context['entity'];
      $output['#bundle'] = isset($context['entity']->type) ? $context['entity']->type : NULL;
      $output['#entity_type'] = $context['entity_type'];
      // We perform theming here because the theming function might need to set
      // system messages. It would be too late in the #post_render callback.
      $output['#entity_translation_unavailable'] = theme('entity_translation_unavailable', array('element' => $output));
      // As we used a string key, other modules implementing
      // hook_field_attach_view_alter() may unset/override this.
      $output['#post_render']['entity_translation'] = 'entity_translation_unavailable';
    }
  }
}

/**
 * Implementation of hook_module_implements_alter().
 */
function entity_translation_hierarchy_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'form_alter' || $hook == 'menu_alter' || $hook == 'entity_load') {
    $group = $implementations['entity_translation_hierarchy'];
    unset($implementations['entity_translation_hierarchy']);
    $implementations['entity_translation_hierarchy'] = $group;
  }
}

/**
 * Implements hook_theme().
 */
function entity_translation_hierarchy_theme() {
  return array(
    'entity_translation_hierarchy_indent' => array(
      'variables' => array('depth' => 0, 'string' => ''),
    ),
  );
}

/**
* Implementation of hook_preprocess_entity_translation_overview().
*/
function entity_translation_hierarchy_preprocess_entity_translation_overview(&$variables) {
  // Get hierarchy, please. The order of languages in this list exactly the same as order in the table (or at least it's assumed that this is the case. We are not responsible for rouge modules that change this order on the theme level).
  // The reason we only take array_values is so the indexes of language list match the ones in $variables['rows']
  $node = menu_get_object();
  $languages = array_values(language_hierarchy_language_list());
  foreach ($languages as $index => $language) {
    $variables['rows'][$index]['data'][0] = theme('entity_translation_hierarchy_indent', array(
      'depth' => $language->depth,
      'string' => $variables['rows'][$index]['data'][0]));

    if ($node) {
      $blocking = entity_translation_hierarchy_is_blocking($node->nid, 'node', $language->language);
      if ($blocking) {
        $variables['rows'][$index]['data'][3] = t('Blocking');
      }
    }
  }
}

/**
* Renders a string with left indentation
*
* @param $variables
* @return string
*/
function theme_entity_translation_hierarchy_indent(&$variables) {
  return '<div style="margin-left:' . ($variables['depth'] * 1.5) . 'em">' .  $variables['string'] . '</div>';
}

/**
 * Implementation of hook_form_alter().
 */
function entity_translation_hierarchy_form_alter(&$form, &$form_state, $form_id) {
  // If we are on entity form and we have entity translation module enabled, please attach JS file that collapses translation list.
  if (isset($form['#entity_type']) && isset($form['#entity'])) {
    list($entity_id, $revision_id, $bundle) = entity_extract_ids($form['#entity_type'], $form['#entity']);
    $handler = entity_translation_get_handler($form['#entity_type'], $form['#entity'], TRUE);
    $translations = $handler->getTranslations();
    $form_langcode = $handler->getFormLanguage();
    $languages = language_hierarchy_get_root_languages();

    foreach($languages as $langcode => $language) {
      $languages[$langcode] = language_hierarchy_get_descendants($langcode, $language);
    }

    // Expose language hierarchy as JS variable, so JS code can pick it up.
    drupal_add_js(array('languageHierarchy' => language_hierarchy_language_list()), 'setting');

    if (!isset($form['#attached']['js'])) {
      $form['#attached']['js'] = array();
    }
    $form['#attached']['js'][] = drupal_get_path('module', 'entity_translation_hierarchy') . "/language_hierarchy.js";

    if (!isset($form['#attached']['css'])) {
      $form['#attached']['css'] = array();
    }
    $form['#attached']['css'][] = drupal_get_path('module', 'entity_translation_hierarchy') . "/language_hierarchy.css";

    // Add option to mark translation as blocking...
    if (isset($form['translation'])) {
      $form['translation']['blocking'] = array(
        '#type' => 'checkbox',
        '#title' => t('Flag translation as blocking'),
        '#description' => t('Mark this translation as blocking, so in the language fallback logic it will generate "404 - Page not found", instead of falling back to the parent language.'),
        '#default_value' => isset($translations->data[$form_langcode]['blocking']) ? $translations->data[$form_langcode]['blocking'] : 0,
        '#weight' => -98
      );

      $form['translation']['status']['#weight'] = -99;
    }

    array_unshift($form['#submit'], 'entity_translation_hierarchy_entity_form_submit');
  }
}

/**
 * Entity Translation Hierarchy entity submit handler
 *
 * @param $form
 * @param $form_state
 */
function entity_translation_hierarchy_entity_form_submit($form, &$form_state) {
  global $language;
  $form_langcode = $language->language;
  list($entity_id, $revision_id, $bundle) = entity_extract_ids($form['#entity_type'], $form['#entity']);

  // User is trying to save the translation
  if (isset($form_state['values']['translation']['blocking']) && !is_null($form_state['values']['translation']['blocking'])) {
    entity_translation_hierarchy_save($entity_id, $form['#entity_type'], $form_langcode, array('blocking' => $form_state['values']['translation']['blocking']));
  }

  // User has just deleted the translation.
  else {
    entity_translation_hierarchy_delete($entity_id, $form['#entity_type'], $form_langcode);
  }
}

/**
 * Implements hook_entity_load().
 */
function entity_translation_hierarchy_entity_load($entities, $type) {
  if (!entity_translation_enabled($type)) {
    return;
  }

  $entity_info = entity_get_info($type);
  if (isset($entity_info['entity keys']['translations'])){
    $translations_key = $entity_info['entity keys']['translations'];
  }
  else {
    // If no translations key is defined we cannot proceed.
    return;
  }

  $results = db_select('entity_translation_hierarchy', 'h')
    ->fields('h')
    ->condition('entity_type', $type)
    ->condition('entity_id', array_keys($entities), 'IN')
    ->orderBy('entity_id')
    ->execute();

  foreach ($results as $row) {
    $id = $row->entity_id;
    if (isset($entities[$id]->{$translations_key}->data[$row->language])) {
      $translation = $entities[$id]->{$translations_key}->data[$row->language];
      $entities[$id]->{$translations_key}->data[$row->language] = array_merge($translation, (array) $row);
    }
  }
}

/**
 * Implements hook_entity_delete().
 */
function entity_translation_hierarchy_entity_delete($entity, $type) {
  if (!entity_translation_enabled($type)) {
    return;
  }

  list($entity_id, $revision_id, $bundle) = entity_extract_ids($type, $entity);
  if ($handler = entity_translation_get_handler($type, $entity, TRUE)) {
    entity_translation_hierarchy_delete($entity_id, $type);
  }
}

/**
 * Saves entity_translation object
 *
 * @param $entity_id
 * @param $entity_type
 * @param $langcode
 * @param $properties
 */
function entity_translation_hierarchy_save($entity_id, $entity_type, $langcode, $object) {
  db_merge('entity_translation_hierarchy')
    ->key(array('entity_type' => $entity_type, 'entity_id' => $entity_id, 'language' => $langcode))
    ->fields((array) $object)
    ->execute();
}

/**
 * Deletes the object form the database
 *
 * @param $entity_id
 * @param $entity_type
 * @param $langcode
 */
function entity_translation_hierarchy_delete($entity_id, $entity_type, $langcode = NULL) {
  $query = db_delete('entity_translation_hierarchy')
    ->condition('entity_id', $entity_id)
    ->condition('entity_type', $entity_type);

  if ($langcode) {
    $query->condition('language', $langcode);
  }

  $query->execute();
}

/**
 * Loads entity translation hierarchy object from the database
 *
 * @param $entity_id
 * @param $entity_type
 * @param $langcode
 * @return mixed
 */
function entity_translation_hierarchy_load($entity_id, $entity_type, $langcode) {
  return db_select('entity_translation_hierarchy', 'h')
      ->fields('h')
      ->condition('entity_id', $entity_id)
      ->condition('entity_type', $entity_type)
      ->condition('language', $langcode)
      ->execute()
      ->fetchAllAssoc('language');
}

/**
 * Return TRUE is the given translation is blocking for selected entity
 *
 * @param $entity_id
 * @param $entity_type
 * @param $langcode
 * @return bool
 */
function entity_translation_hierarchy_is_blocking($entity_id, $entity_type, $translation_langcode) {
  if (!entity_translation_enabled($entity_type)) {
    return FALSE;
  }

  if ($properties = entity_translation_hierarchy_load($entity_id, $entity_type, $translation_langcode)) {
    return (bool) $properties[$translation_langcode]->blocking;
  }

  return FALSE;
}

/**
 * Returns candidate langcode
 *
 * @param $entity
 * @param $entity_type
 * @param $langcode
 */
function entity_translation_hierarchy_get_candidate($entity, $entity_type, $langcode) {
  if ($handler = entity_translation_get_handler($entity_type, $entity, TRUE)) {
    if ($translations = $handler->getTranslations()) {
      // Make a copy of this so we can operate on translation data without affecting the original.
      $translation_data = $translations->data;

      // Filter out unpublished or inaccessible translations.
      // We treat them as non existing - they can't block nor be displayed at all.
      // Inheritance process flows through them, so to speak...
      foreach($translation_data as $translation_langcode => $translation) {
        if (!entity_translation_access($entity_type, $translation)) {
          unset($translation_data[$translation_langcode]);
        }
      }

      $translation_candidates = array_keys($translation_data);
      $fallback_candidates = array_keys(language_hierarchy_get_ancestors($langcode));
      array_unshift($fallback_candidates, $langcode);
      $view_candidates = array_intersect($fallback_candidates, $translation_candidates);
      return current($view_candidates);
    }
  }

  return NULL;
}

/**
 * Checks if for given language the entity is blocked.
 *
 * @param $entity
 * @param $entity_type
 * @param $langcode
 * @return bool
 */
function entity_translation_hierarchy_is_blocked($entity, $entity_type, $langcode) {
  if (!entity_translation_enabled($entity_type)) {
    return FALSE;
  }

  list($entity_id, $revision_id, $bundle) = entity_extract_ids($entity_type, $entity);
  if ($handler = entity_translation_get_handler($entity_type, $entity, TRUE)) {
    // Get translations from the entity we're trying to view,
    // determine what are the translation candidates and figure out which candidate is going to be viewed.
    if ($translations = $handler->getTranslations()) {
      // If the node doesn't have any translation data associated we consider it non-blocking.
      if (!isset($translations) || !$translations->original || empty($translations->data)) {
        return FALSE;
      }

      $view_candidate = entity_translation_hierarchy_get_candidate($entity, $entity_type, $langcode);

      // If there's no view candidate at all (No parents have translations), then mark as blocking too.
      if (!$view_candidate) {
        return TRUE;
      }

      // If the view candidate is blocking, please display 404 - Page not found
      if (isset($translations->data[$view_candidate])
        && isset($translations->data[$view_candidate]['blocking'])
        && $translations->data[$view_candidate]['blocking']
        && !user_access("translate node entities")) {
        return TRUE;
      }
    }
  }

  return FALSE;
}
