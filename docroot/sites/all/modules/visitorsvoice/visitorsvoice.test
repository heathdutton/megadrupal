<?php

/**
 * @file
 * Contains test classes for the Visitors Voice module.
 */

/**
 * Provides a common base class for Visitors Voice class.
 *
 * Contains methods that can be useful for all types of tests (REST interface,
 * internal storage system, service class integrations).
 */
abstract class VisitorsvoiceTestBase extends DrupalWebTestCase {

  /**
   * Asserts that returned customizations are correct.
   *
   * Checks that all expected customizations of the given type are present, that
   * they follow the correct order (if given) and that no surplus customizations
   * of that type are present.
   *
   * @param VisitorsvoiceCustomizationInterface [][] $result
   *   The retrieved customizations, as returned by
   *   visitorsvoice_customizations_load().
   * @param array $expected
   *   The expected customizations of that type. The keys are the item IDs, the
   *   values are their order (if this should be checked, too). Specifying an
   *   order only makes sense when $type is
   *   VisitorsvoiceCustomizationInterface::TYPE_ORDER.
   * @param string $type
   *   The type to check for. One of the
   *   VisitorsvoiceCustomizationInterface::TYPE_* constants.
   * @param int $customization_id
   *   The ID of the expected customizations.
   */
  protected function assertCustomizations($result, $expected, $type, $customization_id) {
    $type_name = strtoupper($type);
    foreach ($result as $item_id => $customizations) {
      /** @var VisitorsvoiceCustomizationInterface $customization */
      foreach ($customizations as $customization) {
        // We only ever add customizations
        if ($customization->getCustomizationId() != $customization_id) {
          $id = $customization->getCustomizationId();
          $this->assert(FALSE, "Unexpected customization with ID $id was present.");
          continue;
        }
        if ($customization->getType() == $type) {
          if (!isset($expected[$item_id])) {
            $this->assert(FALSE, "Unexpected or duplicate $type_name customization found for item $item_id.");
          }
          else {
            if ($expected[$item_id]) {
              $order = $customization->getOrder();
              $this->assertEqual($order, $expected[$item_id], "Expected order {$expected[$item_id]} for item $item_id, got $order.");
            }
            unset($expected[$item_id]);
          }
        }
      }
    }
    if ($expected) {
      $message = "The $type_name customizations for the following IDs were not returned: " . implode(', ', array_keys($expected)) . '.';
    }
    else {
      $message = "All expected $type_name customizations were returned.";
    }
    $this->assertFalse((bool) $expected, $message);
  }

}

/**
 * Class for testing Visitors Voice REST functionality.
 */
class VisitorsvoiceRESTTest extends VisitorsvoiceTestBase {

  /**
   * The access key to use for tests.
   *
   * @var string
   */
  protected $access_key = 'test';

  /**
   * The last response received from the test site's Visitors Voice interface.
   *
   * @var object
   *
   * @see drupal_http_request()
   */
  protected $response;

  /**
   * The search index being used for these tests.
   *
   * @var SearchApiIndex
   */
  protected $index;

  /**
   * The term TID of the test taxonomy term to use.
   *
   * @var int
   */
  protected $test_term_tid;

  /**
   * Returns information about this test case.
   *
   * @return array
   *   An array with information about this test case.
   */
  public static function getInfo() {
    return array(
      'name' => 'REST Interface Test',
      'description' => 'Tests basic functions of the interface exposed to Visitors Voice, like authentication, retrieving search results and modifying them.',
      'group' => 'Visitors Voice',
    );
  }

  /**
   * {@inheritdoc}
   */
  public function setUp() {
    parent::setUp('user', 'node', 'taxonomy', 'entity', 'search_api', 'visitorsvoice', 'visitorsvoice_test');

    // Create our test index.
    $this->index = new VisitorsvoiceTestIndexMock(array('machine_name' => 'test_index'));
    $this->index->save();

    // The "GetPageIdFromUrl" tests also need some entities to work with.
    $type = (object) array(
      'type' => 'test',
      'base' => 'node_content',
      'module' => 'node',
      'locked' => '0',
      'disabled' => '0',
      'is_new' => TRUE,
    );
    node_type_save($type);
    $node = (object) array(
      'nid' => 17,
      'uid' => 1,
      'type' => 'test',
      'is_new' => TRUE,
    );
    node_save($node);
    $node = (object) array(
      'nid' => 14,
      'uid' => 1,
      'type' => 'test',
      'is_new' => TRUE,
    );
    node_save($node);
    $node = (object) array(
      'nid' => 12,
      'uid' => 1,
      'type' => 'test',
      'is_new' => TRUE,
    );
    node_save($node);
    $path = array(
      'source' => 'node/14',
      'alias' => 'content/test-node-alias',
    );
    path_save($path);

    $account = (object) array(
      'uid' => 30,
      'name' => 'foo',
      'is_new' => TRUE,
    );
    user_save($account);
    $account = (object) array(
      'uid' => 29,
      'name' => 'bar',
      'is_new' => TRUE,
    );
    user_save($account);

    $vocabulary = (object) array(
      'machine_name' => 'test',
    );
    taxonomy_vocabulary_save($vocabulary);
    $term = (object) array(
      'vid' => $vocabulary->vid,
      'name' => 'test1',
    );
    taxonomy_term_save($term);
    $term = (object) array(
      'vid' => $vocabulary->vid,
      'name' => 'test2',
    );
    taxonomy_term_save($term);
    $term = (object) array(
      'vid' => $vocabulary->vid,
      'name' => 'test3',
    );
    taxonomy_term_save($term);
    $this->test_term_tid = $term->tid;
  }

  /**
   * Executes all tests for this test case.
   *
   * These are all contained in a single test*() method to avoid having to
   * re-install Drupal for every test.
   */
  public function testREST() {
    $this->checkAuthenticationWithoutKey();
    $this->setAccessKey();
    $this->checkIncorrectAuthentication();
    $this->checkCheckAuthentication();
    $this->checkGetSearchResult();
    $this->checkGetPageSearchResult();
    $this->checkUpdateSearchResult();
    $this->checkGetPageIdFromUrl();
  }

  /**
   * Sends a request to the test site's Visitors Voice interface.
   *
   * @param string $operation
   *   (optional) The operation to execute.
   * @param array $params
   *   (optional) Additional GET parameters to use.
   * @param string|null $data
   *   (optional) POST data to add to the request as a body. If present, method
   *   "POST" will be used, "GET" otherwise.
   * @param int $expected_status
   *   (optional) The expected HTTP status code for the request.
   * @param string|null $alter_callback
   *   (optional) A method of this class that should be used for altering the
   *   request before sending. Can be used to test error handling.
   *
   * @return object|string
   *   If the response body forms correct JSON, the parsed JSON. Otherwise, the
   *   plain text response body.
   */
  protected function sendRequest($operation = 'CheckAuthentication', array $params = array(), $data = NULL, $expected_status = 200, $alter_callback = NULL) {
    $params += array(
      'id' => uniqid(),
    );
    $url_options['query'] = array_filter($params);
    $url_options['absolute'] = TRUE;
    $path = "visitorsvoice/$operation";
    $url = url($path, $url_options);

    if ($data) {
      if (is_array($data)) {
        $data = drupal_http_build_query($data);
      }
      $options['data'] = $data;
      $options['method'] = 'POST';
      $options['headers']['Content-Type'] = 'application/x-www-form-urlencoded';
    }

    $nonce = drupal_random_key();
    $string = $nonce;
    $string .= $path;
    $string .= $params['id'];
    $string .= $data;
    $hmac = hash_hmac('sha1', $string, $this->access_key);

    $options['headers']['Cookie'] = "visitorsvoice_nonce=$nonce; visitorsvoice_hmac=$hmac;";
    if ($alter_callback) {
      $this->$alter_callback($url, $options);
    }
    $this->response = drupal_http_request($url, $options);
    $this->assertEqual($expected_status, $this->response->code, format_string('HTTP response expected !code, actual !actual_code', array('!code' => $expected_status, '!actual_code' => $this->response->code)));

    $body = '';
    if ($this->response->code == 200) {
      $body = json_decode($this->response->data, TRUE);
    }
    if (!$body) {
      $body = $this->response->data;
      // Remove the stack trace.
      if ($pos = strpos($body, "\n")) {
        $body = substr($body, 0, $pos);
      }
    }
    return $body;
  }

  /**
   * Tests whether requests to the interface fail correctly when no key was set.
   */
  protected function checkAuthenticationWithoutKey() {
    $expected_msg = t('Access denied: no access key set in Drupal.');
    $msg = $this->sendRequest('CheckAuthentication', array(), NULL, 403);
    $this->assertEqual($msg, $expected_msg, 'Correct response when no key was set on Drupal site.');
  }

  /**
   * Uses the UI to set the VV access key.
   */
  protected function setAccessKey() {
    $this->drupalLogin($this->drupalCreateUser(array('administer visitorsvoice')));
    $edit['visitorsvoice_access_key'] = $this->access_key;
    $this->drupalPost('admin/config/search/visitorsvoice', $edit, t('Save configuration'));
    $this->assertText(t('The configuration options have been saved.'), 'The access key could successfully be saved.');
  }

  /**
   * Tests whether requests with wrong authorization fail correctly.
   */
  protected function checkIncorrectAuthentication() {
    // Fail because of missing ID.
    $msg = $this->sendRequest('CheckAuthentication', array('id' => ''), NULL, 403);
    $args['!given_id'] = t('none');
    $args['!last_id'] = '';
    $message = t('Access denied: ID needs to be greater than "!last_id", !given_id given.', $args);
    $this->assertEqual($msg, $message, 'Correct response when no "id" parameter was set for request.');

    // Fail because of old ID.
    $id = uniqid();
    $args['!given_id'] = '"' . $id . '"';
    $args['!last_id'] = uniqid();
    variable_set('visitorsvoice_last_access_id', $args['!last_id']);
    $message = t('Access denied: ID needs to be greater than "!last_id", !given_id given.', $args);
    $msg = $this->sendRequest('CheckAuthentication', array('id' => $id), NULL, 403);
    $this->assertEqual($msg, $message, 'Correct response when old "id" parameter was set for request.');
    variable_del('visitorsvoice_last_access_id');

    // Fail because of missing nonce.
    $msg = $this->sendRequest('CheckAuthentication', array(), NULL, 403, 'alterRequestRemoveNonce');
    $this->assertEqual($msg, t('Access denied: necessary cookies visitorsvoice_nonce and visitorsvoice_hmac not present.'), 'Correct response when nonce cookie was not set for request.');

    // Fail because of missing HMAC.
    $msg = $this->sendRequest('CheckAuthentication', array(), NULL, 403, 'alterRequestRemoveHmac');
    $this->assertEqual($msg, t('Access denied: necessary cookies visitorsvoice_nonce and visitorsvoice_hmac not present.'), 'Correct response when HMAC cookie was not set for request.');

    // Fail because of wrong HMAC.
    $msg = $this->sendRequest('CheckAuthentication', array(), NULL, 403, 'alterRequestChangeHmac');
    $this->assertEqual($msg, t('Access denied: HMAC did not match.'), 'Correct response when incorrect HMAC cookie was set for request.');

    // Ensure that unauthenticated requests don't change the "last access id"
    // state of the site.
    $this->refreshVariables();
    $this->assertIdentical(variable_get('visitorsvoice_last_access_id'), NULL, 'Incorrect requests did not change "last access id" state.');
  }

  /**
   * Removes the nonce cookie from the request.
   *
   * Used as a request alter callback in checkIncorrectAuthentication().
   *
   * @param string $url
   *   The request URL to alter.
   * @param array $options
   *   The request options to alter.
   *
   * @see drupal_http_request()
   */
  protected function alterRequestRemoveNonce(&$url, array &$options) {
    $options['headers']['Cookie'] = substr($options['headers']['Cookie'], strpos($options['headers']['Cookie'], ';') + 2);
  }

  /**
   * Removes the HMAC cookie from the request.
   *
   * Used as a request alter callback in checkIncorrectAuthentication().
   *
   * @param string $url
   *   The request URL to alter.
   * @param array $options
   *   The request options to alter.
   *
   * @see drupal_http_request()
   */
  protected function alterRequestRemoveHmac(&$url, array &$options) {
    $options['headers']['Cookie'] = substr($options['headers']['Cookie'], 0, strpos($options['headers']['Cookie'], ';') + 1);
  }

  /**
   * Sets a wrong HMAC cookie for the request.
   *
   * Used as a request alter callback in checkIncorrectAuthentication().
   *
   * @param string $url
   *   The request URL to alter.
   * @param array $options
   *   The request options to alter.
   *
   * @see drupal_http_request()
   */
  protected function alterRequestChangeHmac(&$url, array &$options) {
    $url_parts = parse_url($url);

    $nonce = drupal_random_key();
    $string = $nonce;
    $string .= '/' . $url_parts['path'] . '?' . $url_parts['query'];
    if (isset($options['data'])) {
      $string .= $options['data'];
    }
    $hmac = hash_hmac('sha1', $string, 'wrong_key');

    $options['headers']['Cookie'] = "visitorsvoice_nonce=$nonce; visitorsvoice_hmac=$hmac;";
  }

  /**
   * Tests whether "CheckAuthentication" requests work correctly.
   */
  protected function checkCheckAuthentication() {
    $response = $this->sendRequest();
    $this->assertEqual($response['Message'], 'ok', 'Correct response when checking authentication.');
  }

  /**
   * Tests whether "GetModuleVersion" requests work correctly.
   */
  protected function checkGetModuleVersion() {
    $response = $this->sendRequest();
    $this->assertEqual($response['Version'], '7.x-1.0', 'Correct response when retrieving module version.');
  }

  /**
   * Tests whether "GetSearchResult" requests work correctly.
   */
  protected function checkGetSearchResult() {
    $data = array(
      'SearchTerm' => 'foo',
      'PageNumber' => '1',
    );
    $response = $this->sendRequest('GetSearchResult', array(), $data);
    $expected = array(
      'SearchTerm' => 'foo',
      'TotalHitsCount' => 12,
      'HitList' => $this->getHitList(range(1, 10)),
    );
    $this->assertEqual($response, $expected, 'Correct response for search page 1.');

    $data = array(
      'SearchTerm' => 'foo',
      'PageNumber' => '2',
      'Facet' => array(),
    );
    $response = $this->sendRequest('GetSearchResult', array(), $data);
    $expected = array(
      'SearchTerm' => 'foo',
      'TotalHitsCount' => 12,
      'HitList' => $this->getHitList(range(11, 12)),
    );
    $this->assertEqual($response, $expected, 'Correct response for search page 2.');

    // Test exception handling.
    $response = $this->sendRequest('GetSearchResult', array(), NULL, 500);
    $this->assertEqual($response, t('No search term specified.'), 'Correct error response when omitting keywords.');

    variable_set('visitorsvoice_index', '');
    $data = array(
      'SearchTerm' => 'foo',
    );
    $response = $this->sendRequest('GetSearchResult', array(), $data, 500);
    $expected = t('Search index to use not configured.');
    $this->assertEqual($response, $expected, 'Correct error response when no index was set.');

    variable_set('visitorsvoice_index', 'unknown_index');
    $response = $this->sendRequest('GetSearchResult', array(), $data, 500);
    $expected = t('Could not load search index with ID "!index_id".', array('!index_id' => 'unknown_index'));
    $this->assertEqual($response, $expected, 'Correct error response when set index is unknown.');
    variable_set('visitorsvoice_index', $this->index->machine_name);

    // The "visitorsvoice_test_exceptions" variable can be used to trigger
    // exceptions in specified methods in the mock objects provided by our test
    // module.
    foreach (array('loadItems', 'query', 'execute') as $method) {
      variable_set('visitorsvoice_test_exceptions', array($method));
      $response = $this->sendRequest('GetSearchResult', array(), $data, 500);
      $this->assertEqual($response, $method, "Correct error response when $method() throws an exception.");
    }
    variable_del('visitorsvoice_test_exceptions');
  }

  /**
   * Tests whether "GetPageSearchResult" requests work correctly.
   */
  protected function checkGetPageSearchResult() {
    $data = array(
      'SearchTerm' => 'foo',
    );
    $response = $this->sendRequest('GetPageSearchResult', array(), $data);
    $expected = array(
      'SearchTerm' => 'foo',
      'TotalHitsCount' => 12,
      'HitList' => $this->getHitList(range(1, 12)),
    );
    $this->assertEqual($response, $expected, 'Correct response for title search.');

    $this->index->options['fields'] = $this->getFieldsArray(array(
      'description' => 3.0,
      'body' => 1.0,
      'title' => 13.0,
      'related_content' => 1.0,
    ));
    $this->index->save();

    // We can use the "visitorsvoice_test_lookup" variable to state how many
    // fields must be present on the query object for the query to succeed.
    variable_set('visitorsvoice_test_lookup', 1);
    $response = $this->sendRequest('GetPageSearchResult', array(), $data);
    $expected = array(
      'SearchTerm' => 'foo',
      'TotalHitsCount' => 1,
      'HitList' => $this->getHitList(array('title')),
    );
    $this->assertEqual($response, $expected, 'Correct response for single-field title search.');

    variable_set('visitorsvoice_test_lookup', 2);
    $response = $this->sendRequest('GetPageSearchResult', array(), $data);
    $expected = array(
      'SearchTerm' => 'foo',
      'TotalHitsCount' => 2,
      'HitList' => $this->getHitList(array('title', 'description')),
    );
    $this->assertEqual($response, $expected, 'Correct response for multi-field title search.');

    variable_set('visitorsvoice_test_lookup', 3);
    $response = $this->sendRequest('GetPageSearchResult', array(), $data);
    $expected = array(
      'SearchTerm' => 'foo',
      'TotalHitsCount' => 0,
      'HitList' => array(),
    );
    $this->assertEqual($response, $expected, 'Correct response for no-results title search.');

    $this->index->options['fields']['description']['boost'] = '1.0';
    $this->index->options['fields']['title']['boost'] = '1.0';
    $this->index->options['fields']['label'] = $this->index->options['fields']['title'];
    $this->index->save();
    variable_set('visitorsvoice_test_lookup', 1);
    $response = $this->sendRequest('GetPageSearchResult', array(), $data);
    $expected = array(
      'SearchTerm' => 'foo',
      'TotalHitsCount' => 1,
      'HitList' => $this->getHitList(array('title')),
    );
    $this->assertEqual($response, $expected, 'Correct response for single-field title search (without boost distinction).');

    variable_set('visitorsvoice_test_lookup', 2);
    $response = $this->sendRequest('GetPageSearchResult', array(), $data);
    $expected = array(
      'SearchTerm' => 'foo',
      'TotalHitsCount' => 2,
      'HitList' => $this->getHitList(array('title', 'label')),
    );
    $this->assertEqual($response, $expected, 'Correct response for multi-field title search (without boost distinction).');

    variable_set('visitorsvoice_test_lookup', 3);
    $response = $this->sendRequest('GetPageSearchResult', array(), $data);
    $expected = array(
      'SearchTerm' => 'foo',
      'TotalHitsCount' => 0,
      'HitList' => array(),
    );
    $this->assertEqual($response, $expected, 'Correct response for no-results title search (without boost distinction).');

    // Test exception handling.
    variable_del('visitorsvoice_test_lookup');
    $response = $this->sendRequest('GetSearchResult', array(), NULL, 500);
    $this->assertEqual($response, t('No search term specified.'), 'Correct error response when omitting keywords.');

    variable_set('visitorsvoice_index', '');
    $data = array(
      'SearchTerm' => 'foo',
    );
    $response = $this->sendRequest('GetSearchResult', array(), $data, 500);
    $expected = t('Search index to use not configured.');
    $this->assertEqual($response, $expected, 'Correct error response when no index was set.');

    variable_set('visitorsvoice_index', 'unknown_index');
    $response = $this->sendRequest('GetSearchResult', array(), $data, 500);
    $expected = t('Could not load search index with ID "!index_id".', array('!index_id' => 'unknown_index'));
    $this->assertEqual($response, $expected, 'Correct error response when set index is unknown.');
    variable_set('visitorsvoice_index', $this->index->machine_name);

    // The "visitorsvoice_test_exceptions" variable can be used to trigger
    // exceptions in specified methods in the mock objects provided by our test
    // module.
    foreach (array('loadItems', 'query', 'execute') as $method) {
      variable_set('visitorsvoice_test_exceptions', array($method));
      $response = $this->sendRequest('GetSearchResult', array(), $data, 500);
      $this->assertEqual($response, $method, "Correct error response when $method() throws an exception.");
    }
    variable_del('visitorsvoice_test_exceptions');
  }

  /**
   * Creates a "HitList" return value for given test item IDs.
   *
   * @param array $ids
   *   The item IDs returned in the result.
   *
   * @return array
   *   The "HitList" value to return for those IDs.
   */
  protected function getHitList(array $ids) {
    $hit_list = array();
    foreach ($ids as $num => $id) {
      $hit_list[] = array(
        'HitNumber' => ++$num,
        'HitId' => $id,
        'HitTitle' => "Item $id",
        'HitUrl' => url("visitorsvoice_test/$id", array('absolute' => TRUE)),
        'Meta' => array(),
      );
    }
    return $hit_list;
  }

  /**
   * Transforms field/boost mappings into a correct index "fields" option.
   *
   * @param array $field_boosts
   *   An array mapping fulltext field names to their boosts.
   *
   * @return array
   *   A valid index "fields" option array with those fulltext fields and
   *   boosts.
   */
  protected function getFieldsArray(array $field_boosts) {
    $fields = array();
    $type = 'text';
    foreach ($field_boosts as $field => $boost) {
      $fields[$field] = array(
        'type' => $type,
        'boost' => (string) $boost,
      );
      // Make the type a list type (of ever increasing nesting level) to test
      // whether this is also handled correctly (i.e., ignored).
      $type = "list<$type>";
    }
    return $fields;
  }

  /**
   * Tests whether "UpdateSearchResult" requests work correctly.
   */
  protected function checkUpdateSearchResult() {
    $index_id = $this->index->machine_name;
    $data = array(
      'SearchTerm' => 'foo',
      'PagesToRemove' => array(1, 2, 3),
      'PagesToReorder' => array(4, 5, 6, 7),
      'PagesToAdd' => array(7, 8, 9),
    );
    $response = $this->sendRequest('UpdateSearchResult', array(), $data);
    $this->assertEqual($response['Message'], 'ok', 'Correct response when updating SERP.');
    sort($response['Operations']);
    $this->assertEqual($response['Operations'], array('PagesToAdd', 'PagesToRemove', 'PagesToReorder'), 'Correct operations reported as executed when updating SERP.');

    // There should now be a customization ID for "foo".
    $customization_id = visitorsvoice_customization_id($index_id, 'foo');
    $this->assertNotIdentical($customization_id, FALSE, 'A new customization was created after the REST request.');

    // Assert ADDs are correct.
    $result = visitorsvoice_customizations_load($index_id);
    $expected = array_fill_keys(array(7, 8, 9), 0);
    $this->assertCustomizations($result, $expected, VisitorsvoiceCustomizationInterface::TYPE_ADD, $customization_id);

    // Assert ORDERs are correct.
    $result = visitorsvoice_customizations_load($index_id);
    $expected = array(4 => 1, 5 => 2, 6 => 3, 7 => 4, 8 => 5, 9 => 6);
    $this->assertCustomizations($result, $expected, VisitorsvoiceCustomizationInterface::TYPE_ORDER, $customization_id);

    // Assert REMOVEs are correct.
    $result = visitorsvoice_customizations_load($index_id);
    $expected = array_fill_keys(array(1, 2, 3), 0);
    $this->assertCustomizations($result, $expected, VisitorsvoiceCustomizationInterface::TYPE_REMOVE, $customization_id);

    // Test RESET request.
    $data = array(
      'SearchTerm' => 'foo',
    );
    $response = $this->sendRequest('UpdateSearchResult', array(), $data);
    $this->assertEqual($response['Message'], 'ok', 'Correct response when resetting customizations.');
    sort($response['Operations']);
    $this->assertEqual($response['Operations'], array('RESET'), 'Correct operations reported as executed when updating SERP.');

    // The customization for "foo" should now have been deleted.
    $customization_id = visitorsvoice_customization_id($index_id, 'foo');
    $this->assertIdentical($customization_id, FALSE, 'RESET correctly deleted the customization for "foo".');

    // Also, all individual customization settings should have been deleted.
    $count = db_query('SELECT COUNT(*) FROM {visitorsvoice_customization}')->fetchField();
    $this->assertEqual($count, 0, 'Individual customization settings were successfully deleted by RESET.');

    // Test exception handling.
    $response = $this->sendRequest('UpdateSearchResult', array(), NULL, 500);
    $this->assertEqual($response, t('No search term specified.'), 'Correct error response when omitting keywords.');

    variable_set('visitorsvoice_index', 'unknown_index');
    $data = array(
      'SearchTerm' => 'foo',
      'PagesToAdd' => array(1),
    );
    $response = $this->sendRequest('UpdateSearchResult', array(), $data, 500);
    $expected = t('Could not load search index with ID "!index_id".', array('!index_id' => 'unknown_index'));
    $this->assertEqual($response, $expected, 'Correct error response when set index is unknown.');
    variable_set('visitorsvoice_index', $index_id);
  }

  /**
   * Tests whether "GetPageIdFromUrl" requests work correctly.
   */
  protected function checkGetPageIdFromUrl() {
    $url_options = array('absolute' => TRUE);

    // Set entity type of index to "node" and test normal URL.
    variable_set('visitorsvoice_test_entity_type', 'node');
    $data = array(
      'PageUrl' => url('node/14', $url_options),
    );
    $response = $this->sendRequest('GetPageIdFromUrl', array(), $data);
    $this->assertEqual($response, 'id--14', 'Correct response when getting node ID from page.');

    // Test aliased URL.
    $data = array(
      'PageUrl' => url('content/test-node-alias', $url_options),
    );
    $response = $this->sendRequest('GetPageIdFromUrl', array(), $data);
    $this->assertEqual($response, 'id--14', 'Correct response when getting node ID from page with alias.');

    // Test the brute-force fallback which uses entity_load() to get all items.
    $data = array(
      'PageUrl' => url('visitorsvoice_test/12', $url_options),
    );
    $response = $this->sendRequest('GetPageIdFromUrl', array(), $data);
    $this->assertEqual($response, 'id--12', 'Correct response when getting item ID from page with entity_load() fallback.');

    // Test users.
    variable_set('visitorsvoice_test_entity_type', 'user');
    $data = array(
      'PageUrl' => url('user/29', $url_options),
    );
    $response = $this->sendRequest('GetPageIdFromUrl', array(), $data);
    $this->assertEqual($response, 'id--29', 'Correct response when getting user ID from page.');

    // Test taxonomy terms.
    variable_set('visitorsvoice_test_entity_type', 'taxonomy_term');
    $tid = $this->test_term_tid;
    $data = array(
      'PageUrl' => url("taxonomy/term/$tid", $url_options),
    );
    $response = $this->sendRequest('GetPageIdFromUrl', array(), $data);
    $this->assertEqual($response, "id--$tid", 'Correct response when getting taxonomy term ID from page.');

    // Test error response when URL for wrong entity type is used.
    $data = array(
      'PageUrl' => url('node/14', $url_options),
    );
    $response = $this->sendRequest('GetPageIdFromUrl', array(), $data, 500);
    $types = entity_get_info();
    $vars['!url_type'] = $types['node']['label'];
    $vars['!index_type'] = $types['taxonomy_term']['label'];
    $expected = t('The given URL points to an entity of type "!url_type", but index contains entities of type "!index_type".', $vars);
    $this->assertEqual($response, $expected, 'Correct error response when trying to get taxonomy term for node page.');

    // Test the fallbacks which don't use an entity type.
    variable_del('visitorsvoice_test_entity_type');

    // Test the handling of non-entities which do appear in the page arguments.
    $data = array(
      'PageUrl' => url('visitorsvoice_test/48', $url_options),
    );
    $response = $this->sendRequest('GetPageIdFromUrl', array(), $data);
    $this->assertEqual($response, 'id--48', 'Correct response when getting non-entity item ID from page arguments.');

    // Add a few "search_api_item" entries, and test the brute-force fallback
    // which uses that to retrieve the items.
    $insert = db_insert('search_api_item')
      ->fields(array('index_id', 'item_id', 'changed'));
    foreach (array(37, 34, 31) as $id) {
      $insert->values(array(
        'index_id' => $this->index->id,
        'item_id' => $id,
        'changed' => 0,
      ));
    }
    $insert->execute();
    $data = array(
      'PageUrl' => url('visitorsvoice_test/34', $url_options),
    );
    $response = $this->sendRequest('GetPageIdFromUrl', array(), $data);
    $this->assertEqual($response, 'id--34', 'Correct response when getting item ID from page with tracker fallback.');
    db_delete('search_api_item')->execute();

    // Test the brute-force fallback which uses a raw search query to retrieve
    // all items.
    $data = array(
      'PageUrl' => url('visitorsvoice_test/11', $url_options),
    );
    $response = $this->sendRequest('GetPageIdFromUrl', array(), $data);
    $this->assertEqual($response, 'id--11', 'Correct response when getting item ID from page with raw search fallback.');
  }

}

/**
 * Class for testing the storage functionality of search customizations.
 */
class VisitorsvoiceStorageTest extends VisitorsvoiceTestBase {

  /**
   * Returns information about this test case.
   *
   * @return array
   *   An array with information about this test case.
   */
  public static function getInfo() {
    return array(
      'name' => 'Customization Storage Test',
      'description' => 'Tests storage functionality of the search customizations.',
      'group' => 'Visitors Voice',
    );
  }

  /**
   * {@inheritdoc}
   */
  public function setUp() {
    parent::setUp('entity', 'search_api', 'visitorsvoice');
  }

  /**
   * Executes all tests for this test case.
   *
   * These are all contained in a single test*() method to avoid having to
   * re-install Drupal for every test.
   */
  public function testCustomizationStorage() {
    $this->checkAddResults();
    $this->reinstallModule();
    $this->checkReorderResults();
    $this->reinstallModule();
    $this->checkRemoveResults();
    $this->reinstallModule();
    $this->checkComplexCustomizations();
    $this->reinstallModule();
    $this->checkQueryPreprocessing();
    $this->reinstallModule();
    $this->checkIndexDelete();
  }

  /**
   * Re-installs the "visitorsvoice" module to have a clean environment.
   */
  protected function reinstallModule() {
    module_disable(array('visitorsvoice'), FALSE);
    drupal_uninstall_modules(array('visitorsvoice'), FALSE);
    module_enable(array('visitorsvoice'), FALSE);
  }

  /**
   * Checks the storage mechanism for "add results" customizations.
   *
   * @see visitorsvoice_customization_id()
   * @see visitorsvoice_customization_add()
   * @see visitorsvoice_customizations_load()
   */
  protected function checkAddResults() {
    $index_id = 'test_index';
    $customization_id = visitorsvoice_customization_id($index_id, 'foo', TRUE);

    // Test normal adding of results.
    $item_ids = array(1, 2, 3);

    $changed = visitorsvoice_customization_add($customization_id, $item_ids);
    ksort($changed);
    $this->assertEqual($changed, array(1 => 1, 2 => 2, 3 => 3), 'Correct IDs were returned as changed');

    $result = visitorsvoice_customizations_load($index_id);
    $expected = array_fill_keys($item_ids, 0);
    $this->assertCustomizations($result, $expected, VisitorsvoiceCustomizationInterface::TYPE_ADD, $customization_id);

    // Request specific set of items.
    $result = visitorsvoice_customizations_load($index_id, array(2, 3, 4, 5));
    unset($expected[1]);
    $this->assertCustomizations($result, $expected, VisitorsvoiceCustomizationInterface::TYPE_ADD, $customization_id);

    // Request only items without customizations.
    $result = visitorsvoice_customizations_load($index_id, array(4, 5, 6));
    $this->assertEqual($result, array(), 'Correctly returned empty result when retrieving customizations of unknown items.');

    // Request only items without customizations.
    $result = visitorsvoice_customizations_load($index_id . '_foo', $item_ids);
    $this->assertEqual($result, array(), 'Correctly returned empty result when retrieving customizations of unknown index.');

    // Test adding of results after other customizations have been made.
    $index_id .= '2';
    $customization_id = visitorsvoice_customization_id($index_id, 'foo', TRUE);

    $changed = visitorsvoice_customization_add($customization_id, array(1));
    ksort($changed);
    $this->assertEqual($changed, array(1 => 1), 'Correct IDs were returned as changed');

    visitorsvoice_customization_order($customization_id, array(3, 5));
    visitorsvoice_customization_remove($customization_id, array(4, 6));

    $changed = visitorsvoice_customization_add($customization_id, array(1, 2, 3, 4));
    ksort($changed);
    $this->assertEqual($changed, array(2 => 2, 3 => 3, 4 => 4), 'Correct IDs were returned as changed');

    $result = visitorsvoice_customizations_load($index_id);
    $expected = array_fill_keys(array(1, 2, 3, 4), 0);
    $this->assertCustomizations($result, $expected, VisitorsvoiceCustomizationInterface::TYPE_ADD, $customization_id);
    $expected[3] = 1;
    $expected[5] = 2;
    $this->assertCustomizations($result, $expected, VisitorsvoiceCustomizationInterface::TYPE_ORDER, $customization_id);
    $expected = array(6 => 0);
    $this->assertCustomizations($result, $expected, VisitorsvoiceCustomizationInterface::TYPE_REMOVE, $customization_id);

    // Try re-adding already added items.
    $changed = visitorsvoice_customization_add($customization_id, array(2, 3));
    ksort($changed);
    $this->assertEqual($changed, array(), 'Correct IDs were returned as changed');

    $result = visitorsvoice_customizations_load($index_id);
    $expected = array_fill_keys(array(1, 2, 3, 4), 0);
    $this->assertCustomizations($result, $expected, VisitorsvoiceCustomizationInterface::TYPE_ADD, $customization_id);
  }

  /**
   * Checks the storage mechanism for "reorder results" customizations.
   *
   * @see visitorsvoice_customization_id()
   * @see visitorsvoice_customization_order()
   * @see visitorsvoice_customizations_load()
   */
  protected function checkReorderResults() {
    $index_id = 'test_index';
    $customization_id = visitorsvoice_customization_id($index_id, 'foo', TRUE);

    // Test normal re-ordering of results.
    $item_ids = drupal_map_assoc(array(1, 2, 3));

    $changed = visitorsvoice_customization_order($customization_id, $item_ids);
    ksort($changed);
    $this->assertEqual($changed, $item_ids, 'Correct IDs were returned as changed');

    $result = visitorsvoice_customizations_load($index_id);
    $this->assertCustomizations($result, $item_ids, VisitorsvoiceCustomizationInterface::TYPE_ORDER, $customization_id);

    // Test re-ordering of results after other customizations have been made.
    $index_id .= '2';
    $customization_id = visitorsvoice_customization_id($index_id, 'foo', TRUE);
    visitorsvoice_customization_add($customization_id, array(1, 6));

    $changed = visitorsvoice_customization_order($customization_id, array(2, 5));
    ksort($changed);
    $this->assertEqual($changed, drupal_map_assoc(array(1, 2, 5, 6)), 'Correct IDs were returned as changed');

    visitorsvoice_customization_remove($customization_id, array(3, 7));

    $changed = visitorsvoice_customization_order($customization_id, array(1, 2, 3, 4));
    ksort($changed);
    $this->assertEqual($changed, drupal_map_assoc(array(1, 2, 3, 4, 5, 6)), 'Correct IDs were returned as changed');

    $result = visitorsvoice_customizations_load($index_id);
    $expected = drupal_map_assoc(array(1, 2, 3, 4, 5, 6));
    $this->assertCustomizations($result, $expected, VisitorsvoiceCustomizationInterface::TYPE_ORDER, $customization_id);
    $expected = array_fill_keys(array(1, 6), 0);
    $this->assertCustomizations($result, $expected, VisitorsvoiceCustomizationInterface::TYPE_ADD, $customization_id);
    $expected = array(7 => 0);
    $this->assertCustomizations($result, $expected, VisitorsvoiceCustomizationInterface::TYPE_REMOVE, $customization_id);
  }

  /**
   * Checks the storage mechanism for "remove results" customizations.
   *
   * @see visitorsvoice_customization_id()
   * @see visitorsvoice_customization_remove()
   * @see visitorsvoice_customizations_load()
   */
  protected function checkRemoveResults() {
    $index_id = 'test_index';
    $customization_id = visitorsvoice_customization_id($index_id, 'foo', TRUE);

    // Test normal removing of results.
    $item_ids = array(1, 2, 3);

    $changed = visitorsvoice_customization_remove($customization_id, $item_ids);
    ksort($changed);
    $this->assertEqual($changed, drupal_map_assoc($item_ids), 'Correct IDs were returned as changed');

    $result = visitorsvoice_customizations_load($index_id);
    $expected = array_fill_keys($item_ids, 0);
    $this->assertCustomizations($result, $expected, VisitorsvoiceCustomizationInterface::TYPE_REMOVE, $customization_id);

    // Test removing of results after other customizations have been made.
    $index_id .= '2';
    $customization_id = visitorsvoice_customization_id($index_id, 'foo', TRUE);

    $item_ids = array(1, 2, 3, 7);
    $changed = visitorsvoice_customization_remove($customization_id, $item_ids);
    ksort($changed);
    $this->assertEqual($changed, drupal_map_assoc($item_ids), 'Correct IDs were returned as changed');

    visitorsvoice_customization_add($customization_id, array(1, 6));
    visitorsvoice_customization_order($customization_id, array(2, 5));

    $changed = visitorsvoice_customization_remove($customization_id, array(1, 2, 3, 4));
    ksort($changed);
    $this->assertEqual($changed, drupal_map_assoc(array(1, 2, 4)), 'Correct IDs were returned as changed');

    $result = visitorsvoice_customizations_load($index_id);
    $expected = array_fill_keys(array(1, 2, 3, 4, 7), 0);
    $this->assertCustomizations($result, $expected, VisitorsvoiceCustomizationInterface::TYPE_REMOVE, $customization_id);
    $expected = array(6 => 0);
    $this->assertCustomizations($result, $expected, VisitorsvoiceCustomizationInterface::TYPE_ADD, $customization_id);
    $expected = array(5 => 2, 6 => 4);
    $this->assertCustomizations($result, $expected, VisitorsvoiceCustomizationInterface::TYPE_ORDER, $customization_id);
  }

  /**
   * Checks whether storage is still correct with several customizations.
   *
   * @see visitorsvoice_customization_id()
   * @see visitorsvoice_customization_add()
   * @see visitorsvoice_customization_order()
   * @see visitorsvoice_customization_remove()
   * @see visitorsvoice_customizations_load()
   */
  protected function checkComplexCustomizations() {
    $index1 = 'test_index';
    $index2 = 'test_index2';
    $keys1 = 'foo';
    $keys2 = 'foo bar';

    $c1 = visitorsvoice_customization_id($index1, $keys1, TRUE);
    $c2 = visitorsvoice_customization_id($index1, $keys2, TRUE);
    $c3 = visitorsvoice_customization_id($index2, $keys1, TRUE);
    $c4 = visitorsvoice_customization_id($index2, $keys2, TRUE);

    $return = visitorsvoice_customization_add($c1, array(1, 2, 3));
    $this->assertEqual($return, drupal_map_assoc(array(1, 2, 3)), 'Correct items marked for re-indexing after customization ADD.');
    $return = visitorsvoice_customization_order($c1, array(2, 5, 7));
    $this->assertEqual($return, drupal_map_assoc(array(1, 2, 3, 5, 7)), 'Correct items marked for re-indexing after customization ORDER.');
    $return = visitorsvoice_customization_remove($c1, array(6, 3, 8));
    $this->assertEqual($return, drupal_map_assoc(array(6, 3, 8)), 'Correct items marked for re-indexing after customization REMOVE.');
    $return = visitorsvoice_customization_add($c1, array(4, 5));
    $this->assertEqual($return, drupal_map_assoc(array(4, 5)), 'Correct items marked for re-indexing after customization ADD.');
    $return = visitorsvoice_customization_order($c1, array(3, 2));
    $this->assertEqual($return, drupal_map_assoc(array(3, 2, 1, 4, 5, 7)), 'Correct items marked for re-indexing after customization ORDER.');
    $return = visitorsvoice_customization_remove($c1, array(6, 7, 8));
    $this->assertEqual($return, drupal_map_assoc(array(7)), 'Correct items marked for re-indexing after customization REMOVE.');

    $return = visitorsvoice_customization_add($c2, array(4, 3, 5));
    $this->assertEqual($return, drupal_map_assoc(array(4, 3, 5)), 'Correct items marked for re-indexing after customization ADD.');
    $return = visitorsvoice_customization_remove($c2, array(2, 7, 6));
    $this->assertEqual($return, drupal_map_assoc(array(2, 7, 6)), 'Correct items marked for re-indexing after customization REMOVE.');
    $return = visitorsvoice_customization_order($c2, array(1, 5, 6, 7));
    $this->assertEqual($return, drupal_map_assoc(array(1, 3, 4, 5, 6, 7)), 'Correct items marked for re-indexing after customization ORDER.');
    $return = visitorsvoice_customization_order($c2, array(1, 2, 4));
    $this->assertEqual($return, drupal_map_assoc(array(2, 3, 4, 5, 6, 7)), 'Correct items marked for re-indexing after customization ORDER.');
    $return = visitorsvoice_customization_add($c2, array(5, 3, 8));
    $this->assertEqual($return, drupal_map_assoc(array(8)), 'Correct items marked for re-indexing after customization ADD.');
    $return = visitorsvoice_customization_remove($c2, array(7, 1, 4));
    $this->assertEqual($return, drupal_map_assoc(array(7, 1, 4)), 'Correct items marked for re-indexing after customization REMOVE.');

    $expecteds[1] = array(
      1 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ADD, $c1),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c1, 6),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_REMOVE, $c2),
      ),
      2 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ADD, $c1),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c1, 2),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c2, 2),
      ),
      3 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c1, 1),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ADD, $c2),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c2, 7),
      ),
      4 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ADD, $c1),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c1, 3),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_REMOVE, $c2),
      ),
      5 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ADD, $c1),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c1, 4),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ADD, $c2),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c2, 4),
      ),
      6 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_REMOVE, $c1),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c2, 5),
      ),
      7 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_REMOVE, $c1),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_REMOVE, $c2),
      ),
      8 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_REMOVE, $c1),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ADD, $c2),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c2, 1),
      ),
    );
    $results[1] = visitorsvoice_customizations_load($index1);

    $return = visitorsvoice_customization_order($c3, array(4, 5, 2));
    $this->assertEqual($return, drupal_map_assoc(array(4, 5, 2)), 'Correct items marked for re-indexing after customization ORDER.');
    $return = visitorsvoice_customization_remove($c3, array(1, 5, 3));
    $this->assertEqual($return, drupal_map_assoc(array(1, 5, 3)), 'Correct items marked for re-indexing after customization REMOVE.');
    $return = visitorsvoice_customization_add($c3, array(2, 4, 6));
    $this->assertEqual($return, drupal_map_assoc(array(2, 4, 6)), 'Correct items marked for re-indexing after customization ADD.');
    $return = visitorsvoice_customization_add($c3, array(1, 3, 4));
    $this->assertEqual($return, drupal_map_assoc(array(1, 3)), 'Correct items marked for re-indexing after customization ADD.');
    $return = visitorsvoice_customization_remove($c3, array(5, 2, 3));
    $this->assertEqual($return, drupal_map_assoc(array(2, 3)), 'Correct items marked for re-indexing after customization REMOVE.');
    $return = visitorsvoice_customization_order($c3, array(1, 4, 7));
    $this->assertEqual($return, drupal_map_assoc(array(4, 6, 7)), 'Correct items marked for re-indexing after customization ORDER.');

    $return = visitorsvoice_customization_remove($c4, array(4, 2, 1));
    $this->assertEqual($return, drupal_map_assoc(array(4, 2, 1)), 'Correct items marked for re-indexing after customization REMOVE.');
    $return = visitorsvoice_customization_add($c4, array(3, 7, 6));
    $this->assertEqual($return, drupal_map_assoc(array(3, 7, 6)), 'Correct items marked for re-indexing after customization ADD.');
    $return = visitorsvoice_customization_remove($c4, array(2, 8, 3));
    $this->assertEqual($return, drupal_map_assoc(array(8, 3)), 'Correct items marked for re-indexing after customization REMOVE.');
    $return = visitorsvoice_customization_add($c4, array(1, 7, 4));
    $this->assertEqual($return, drupal_map_assoc(array(1, 4)), 'Correct items marked for re-indexing after customization ADD.');
    $return = visitorsvoice_customization_order($c4, array(2, 3, 5));
    $this->assertEqual($return, drupal_map_assoc(array(1, 2, 3, 4, 5, 6, 7)), 'Correct items marked for re-indexing after customization ORDER.');
    $return = visitorsvoice_customization_order($c4, array(6, 7, 2, 3));
    $this->assertEqual($return, drupal_map_assoc(array(1, 2, 3, 4, 5, 6, 7)), 'Correct items marked for re-indexing after customization ORDER.');

    $expecteds[2] = array(
      1 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ADD, $c3),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c3, 1),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ADD, $c4),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c4, 6),
      ),
      2 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_REMOVE, $c3),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c4, 3),
      ),
      3 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_REMOVE, $c3),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c4, 4),
      ),
      4 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ADD, $c3),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c3, 2),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ADD, $c4),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c4, 7),
      ),
      5 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_REMOVE, $c3),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c4, 5),
      ),
      6 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ADD, $c3),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c3, 4),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ADD, $c4),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c4, 1),
      ),
      7 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c3, 3),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ADD, $c4),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c4, 2),
      ),
      8 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_REMOVE, $c4),
      ),
    );
    $results[2] = visitorsvoice_customizations_load($index2);

    // Check customization deletions.
    $return = visitorsvoice_customization_delete($index1, $keys1);
    $this->assertEqual($return, drupal_map_assoc(array(1, 2, 3, 4, 5, 6, 7, 8)), 'Correct items marked for re-indexing after customization DELETE.');

    $expecteds[3] = array(
      1 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_REMOVE, $c2),
      ),
      2 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c2, 2),
      ),
      3 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ADD, $c2),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c2, 7),
      ),
      4 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_REMOVE, $c2),
      ),
      5 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ADD, $c2),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c2, 4),
      ),
      6 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c2, 5),
      ),
      7 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_REMOVE, $c2),
      ),
      8 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ADD, $c2),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c2, 1),
      ),
    );
    $results[3] = visitorsvoice_customizations_load($index1);

    $return = visitorsvoice_customization_delete($index2, $keys2);
    $this->assertEqual($return, drupal_map_assoc(array(1, 2, 3, 4, 5, 6, 7, 8)), 'Correct items marked for re-indexing after customization DELETE.');

    $expecteds[4] = array(
      1 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ADD, $c3),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c3, 1),
      ),
      2 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_REMOVE, $c3),
      ),
      3 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_REMOVE, $c3),
      ),
      4 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ADD, $c3),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c3, 2),
      ),
      5 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_REMOVE, $c3),
      ),
      6 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ADD, $c3),
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c3, 4),
      ),
      7 => array(
        new VisitorsvoiceCustomization(VisitorsvoiceCustomizationInterface::TYPE_ORDER, $c3, 3),
      ),
    );
    $results[4] = visitorsvoice_customizations_load($index2);

    // Tests whether attempts to delete unknown customizations are just
    // silently ignored.
    $return = visitorsvoice_customization_delete($index2, 'unknown keys');
    $this->assertEqual($return, array(), 'Customization DELETE for unknown keys was correctly ignored.');

    // Compare results with expectations.
    foreach (array(1, 2, 3, 4) as $i) {
      $expected = $expecteds[$i];
      $result = $results[$i];
      foreach ($expected as $item_id => $customizations) {
        if (empty($result[$item_id])) {
          $this->assert(FALSE, "No customizations for item $item_id in index $i.");
          continue;
        }
        /** @var VisitorsvoiceCustomizationInterface $customization */
        foreach ($customizations as $customization) {
          $type = strtoupper($customization->getType());
          if ($customization->getOrder()) {
            $type .= '/' . $customization->getOrder();
          }
          $id = $customization->getCustomizationId();
          $pos = array_search($customization, $result[$item_id]);
          $this->assert($pos !== FALSE, "Found customization \"$id: $type\" for item $item_id in index $i.");
          if ($pos !== FALSE) {
            unset($result[$item_id][$pos]);
          }
        }
        foreach ($result[$item_id] as $customization) {
          $type = strtoupper($customization->getType());
          if ($customization->getOrder()) {
            $type .= '/' . $customization->getOrder();
          }
          $id = $customization->getCustomizationId();
          $this->assert(FALSE, "Found unexpected customization \"$id: $type\" for item $item_id in index $i.");
        }
        unset($result[$item_id]);
      }
      if ($result) {
        $ids = implode(', ', array_keys($result));
        $this->assert(FALSE, "Found unexpected customizations for index $i and item IDs: $ids.");
      }
    }
  }

  /**
   * Checks whether query preprocessing works as expected.
   *
   * The "visitorsvoice_customization" option should only be added to queries
   * with the right index and keywords. Re-ordering customizations should only
   * be active if the search was (primarily) sorted by descending relevance.
   *
   * @see visitorsvoice_search_api_query_alter()
   */
  protected function checkQueryPreprocessing() {
    $index_id = 'test_index';
    $keys = 'foo';
    /** @var SearchApiIndex $index */
    $index = entity_create('search_api_index', array(
      'machine_name' => $index_id,
      'server' => 'foo',
      'options' => array(
        'fields' => array(
          'id' => array(
            'type' => 'integer',
          ),
          'text' => array(
            'type' => 'text',
          ),
        ),
      ),
    ));

    visitorsvoice_customization_id($index_id, "$keys bar baz", TRUE);
    $customization_id = visitorsvoice_customization_id($index_id, $keys, TRUE);
    visitorsvoice_customization_id($index_id, "$keys brab tup", TRUE);

    $query = new SearchApiQuery($index);
    $query->keys($keys);
    $query->preExecute();
    $this->assertQueryOption($query, $customization_id);

    $query = new SearchApiQuery($index, array('parse mode' => 'direct'));
    $query->keys($keys);
    $query->preExecute();
    $this->assertQueryOption($query, $customization_id);

    $query = new SearchApiQuery($index, array('parse mode' => 'single'));
    $query->keys($keys);
    $query->preExecute();
    $this->assertQueryOption($query, $customization_id);

    $query = new SearchApiQuery($index);
    $query->keys($keys);
    $query->sort('search_api_relevance', 'DESC');
    $query->sort('id');
    $query->preExecute();
    $this->assertQueryOption($query, $customization_id);

    $query = new SearchApiQuery($index);
    $query->keys($keys);
    $query->sort('search_api_relevance');
    $query->preExecute();
    $this->assertQueryOption($query, $customization_id, FALSE);

    $query = new SearchApiQuery($index);
    $query->keys($keys);
    $query->sort('id', 'DESC');
    $query->preExecute();
    $this->assertQueryOption($query, $customization_id, FALSE);

    $query = new SearchApiQuery($index);
    $query->keys("$keys bar");
    $query->preExecute();
    $this->assertNull($query->getOption('visitorsvoice_customization'), 'Customizations were not set on query with wrong keys.');

    $index = clone $index;
    $index->machine_name .= '2';
    $query = new SearchApiQuery($index);
    $query->keys($keys);
    $query->preExecute();
    $this->assertNull($query->getOption('visitorsvoice_customization'), 'Customizations were not set on query of wrong index.');
  }

  /**
   * Asserts that the customization option has been set correctly on the query.
   *
   * @param SearchApiQueryInterface $query
   *   The query object to check.
   * @param int $customization_id
   *   The ID of the customization that should be set.
   * @param bool $with_reorder
   *   (optional) If TRUE, the VisitorsvoiceCustomizationInterface::TYPE_ORDER
   *   customization should be enabled on the query. Otherwise, only
   *   VisitorsvoiceCustomizationInterface::TYPE_ADD and
   *   VisitorsvoiceCustomizationInterface::TYPE_REMOVE are expected.
   */
  protected function assertQueryOption(SearchApiQueryInterface $query, $customization_id, $with_reorder = TRUE) {
    $option = $query->getOption('visitorsvoice_customization');
    $this->assert((bool) $option, '"visitorsvoice_customization" option was correctly set on query.');
    $this->assertEqual($option['id'], $customization_id, '"visitorsvoice_customization" option was set with the correct customization ID.');
    $types = array(
      VisitorsvoiceCustomizationInterface::TYPE_ADD,
      VisitorsvoiceCustomizationInterface::TYPE_REMOVE,
    );
    if ($with_reorder) {
      $types[] = VisitorsvoiceCustomizationInterface::TYPE_ORDER;
    }
    foreach ($types as $type) {
      $type_name = strtoupper($type);
      $pos = array_search($type, $option['customizations']);
      $not = '';
      if ($pos !== FALSE) {
        unset($option['customizations'][$pos]);
        $not = ' not';
      }
      $this->assert($pos !== FALSE, "$type_name customizations were$not correctly enabled for the query.");
    }
    $this->assertFalse($option['customizations'], 'There were only the expected customizations enabled for the query.');
  }

  /**
   * Checks whether deleting an index also deletes all its customizations.
   *
   * @see visitorsvoice_search_api_index_delete()
   */
  protected function checkIndexDelete() {
    $index_id = 'test_index';
    /** @var SearchApiIndex $index */
    $index = entity_create('search_api_index', array(
      'machine_name' => $index_id,
      'status' => ENTITY_IN_CODE,
    ));

    $c1 = visitorsvoice_customization_id($index_id, 'foo', TRUE);
    $c2 = visitorsvoice_customization_id($index_id, 'bar', TRUE);

    visitorsvoice_customization_add($c1, array(1, 2, 3));
    visitorsvoice_customization_order($c1, array(2, 5, 7));
    visitorsvoice_customization_remove($c1, array(6, 3, 8));

    visitorsvoice_customization_add($c2, array(4, 3, 5));
    visitorsvoice_customization_remove($c2, array(2, 7, 6));
    visitorsvoice_customization_order($c2, array(1, 2, 4));

    $count_k_1 = db_query('SELECT COUNT(*) FROM {visitorsvoice_keywords}')->fetchField();
    $count_c_1 = db_query('SELECT COUNT(*) FROM {visitorsvoice_customization}')->fetchField();
    module_invoke_all('search_api_index_delete', $index);
    $count_k_2 = db_query('SELECT COUNT(*) FROM {visitorsvoice_keywords}')->fetchField();
    $count_c_2 = db_query('SELECT COUNT(*) FROM {visitorsvoice_customization}')->fetchField();

    $this->assertEqual($count_k_1, $count_k_2, 'Reverting a search index did not delete any keywords customization settings.');
    $this->assertEqual($count_c_1, $count_c_2, 'Reverting a search index did not delete any customizations.');

    $index->status = ENTITY_CUSTOM;
    module_invoke_all('search_api_index_delete', $index);

    $count_k = db_query('SELECT COUNT(*) FROM {visitorsvoice_keywords} WHERE index_id = :index_id', array(':index_id' => $index_id))->fetchField();
    $count_c = db_query('SELECT COUNT(*) FROM {visitorsvoice_customization} WHERE customization_id IN (:customization_ids)', array(':customization_ids' => array($c1, $c2)))->fetchField();

    $this->assertEqual($count_k, 0, 'Deleting a search index deleted all its keywords customizations.');
    $this->assertEqual($count_c, 0, 'Deleting a search index deleted all its customization data.');
  }

}

/**
 * Tests the Solr integration for the search results customizations.
 */
class VisitorsvoiceSolrTest extends VisitorsvoiceTestBase {

  /**
   * The dummy index used for these tests.
   *
   * @var SearchApiIndex
   */
  protected $index;

  /**
   * The customizations created for this test case.
   *
   * Maps keywords to their customization IDs.
   *
   * @var array
   */
  protected $customizations = array();

  /**
   * Returns information about this test case.
   *
   * @return array
   *   An array with information about this test case.
   */
  public static function getInfo() {
    return array(
      'name' => 'Solr Integration Test',
      'description' => 'Tests the Solr integration for the search results customizations.',
      'group' => 'Visitors Voice',
    );
  }

  /**
   * {@inheritdoc}
   */
  public function setUp() {
    parent::setUp('entity', 'search_api', 'search_api_solr', 'visitorsvoice');

    $index_id = 'test_index';
    $this->index = entity_create('search_api_index', array(
      'machine_name' => $index_id,
      'server' => 'foo',
      'options' => array(
        'fields' => array(
          'id' => array(
            'type' => 'integer',
          ),
          'text' => array(
            'type' => 'text',
          ),
        ),
      ),
    ));

    $keys = 'foo';
    $id = visitorsvoice_customization_id($index_id, $keys, TRUE);
    $this->customizations[$keys] = $id;
    visitorsvoice_customization_add($id, array(1));
    visitorsvoice_customization_order($id, array(3, 2));
    visitorsvoice_customization_remove($id, array(4));

    $keys = 'bar';
    $id = visitorsvoice_customization_id($index_id, $keys, TRUE);
    $this->customizations[$keys] = $id;
    visitorsvoice_customization_add($id, array(4));
    visitorsvoice_customization_order($id, array(1, 2));
    visitorsvoice_customization_remove($id, array(3));
  }

  /**
   * Executes all tests for this test case.
   *
   * These are all contained in a single test*() method to avoid having to
   * re-install Drupal for every test.
   */
  public function testSolrIntegration() {
    $this->checkIndexing();
    $this->checkQuery();
  }

  /**
   * Asserts that documents sent to Solr for indexing are altered correctly.
   */
  protected function checkIndexing() {
    /** @var SearchApiSolrDocument[] $docs */
    $docs = array();
    $index_id = $this->index->machine_name;

    $doc = new SearchApiSolrDocument();
    $item_id = 1;
    $doc->setField('id', "$index_id-$item_id");
    $doc->setField('index_id', $index_id);
    $doc->setField('item_id', $item_id);
    $docs[$item_id] = $doc;

    $doc = new SearchApiSolrDocument();
    $item_id = 2;
    $doc->setField('id', "$index_id-$item_id");
    $doc->setField('index_id', $index_id);
    $doc->setField('item_id', $item_id);
    $docs[$item_id] = $doc;

    $doc = new SearchApiSolrDocument();
    $item_id = 3;
    $doc->setField('id', "$index_id-$item_id");
    $doc->setField('index_id', $index_id);
    $doc->setField('item_id', $item_id);
    $docs[$item_id] = $doc;

    $doc = new SearchApiSolrDocument();
    $item_id = 4;
    $doc->setField('id', "$index_id-$item_id");
    $doc->setField('index_id', $index_id);
    $doc->setField('item_id', $item_id);
    $docs[$item_id] = $doc;

    $items = array_fill_keys(array(1, 2, 3, 4), array());
    drupal_alter('search_api_solr_documents', $docs, $this->index, $items);

    $id_foo = $this->customizations['foo'];
    $id_bar = $this->customizations['bar'];

    $field = $docs[1]->getField("bs_visitorsvoice_custom_add_$id_foo");
    $this->assertEqual($field['value'], 'true', 'Item 1 added to result set for "foo".');
    $field = $docs[1]->getField("iss_visitorsvoice_custom_order_$id_foo");
    $this->assertEqual($field['value'], 3, 'Item 1 ordered correctly in result set for "foo".');
    $field = $docs[1]->getField("iss_visitorsvoice_custom_order_$id_bar");
    $this->assertEqual($field['value'], 1, 'Item 1 ordered correctly in result set for "bar".');

    $field = $docs[2]->getField("iss_visitorsvoice_custom_order_$id_foo");
    $this->assertEqual($field['value'], 2, 'Item 2 ordered correctly in result set for "foo".');
    $field = $docs[2]->getField("iss_visitorsvoice_custom_order_$id_bar");
    $this->assertEqual($field['value'], 2, 'Item 2 ordered correctly in result set for "bar".');

    $field = $docs[3]->getField("iss_visitorsvoice_custom_order_$id_foo");
    $this->assertEqual($field['value'], 1, 'Item 3 ordered correctly in result set for "foo".');
    $field = $docs[3]->getField("bs_visitorsvoice_custom_remove_$id_bar");
    $this->assertEqual($field['value'], 'true', 'Item 3 removed from result set for "bar".');

    $field = $docs[4]->getField("bs_visitorsvoice_custom_remove_$id_foo");
    $this->assertEqual($field['value'], 'true', 'Item 4 removed from result set for "foo".');
    $field = $docs[4]->getField("bs_visitorsvoice_custom_add_$id_bar");
    $this->assertEqual($field['value'], 'true', 'Item 4 added to result set for "bar".');
    $field = $docs[4]->getField("iss_visitorsvoice_custom_order_$id_bar");
    $this->assertEqual($field['value'], 3, 'Item 4 ordered correctly in result set for "bar".');
  }

  /**
   * Asserts that Solr search queries are altered correctly.
   */
  protected function checkQuery() {
    $keys = 'foo';
    $id = $this->customizations[$keys];
    $query = new SearchApiQuery($this->index);
    $query->keys($keys);
    $query->setOption('visitorsvoice_customization', array(
      'id' => $id,
      'customizations' => array(
        VisitorsvoiceCustomizationInterface::TYPE_ADD,
        VisitorsvoiceCustomizationInterface::TYPE_ORDER,
        VisitorsvoiceCustomizationInterface::TYPE_REMOVE,
      ),
    ));
    $call_args = array(
      'query' => $keys,
      'params' => array(),
      'method' => 'GET',
    );
    $expected = $call_args;
    $expected['query'] = "($keys) OR bs_visitorsvoice_custom_add_$id:true";
    $expected['params']['fq'] = array("-bs_visitorsvoice_custom_remove_$id:true");
    $expected['params']['sort'] = "iss_visitorsvoice_custom_order_$id asc, score desc";

    drupal_alter('search_api_solr_query', $call_args, $query);
    ksort($call_args['params']);
    $this->assertEqual($call_args, $expected, 'Solr query 1 was correctly altered.');

    $keys = 'bar';
    $id = $this->customizations[$keys];
    $query = new SearchApiQuery($this->index);
    $query->keys($keys);
    $query->setOption('visitorsvoice_customization', array(
      'id' => $id,
      'customizations' => array(
        VisitorsvoiceCustomizationInterface::TYPE_ADD,
        VisitorsvoiceCustomizationInterface::TYPE_ORDER,
        VisitorsvoiceCustomizationInterface::TYPE_REMOVE,
      ),
    ));
    $call_args = array(
      'query' => NULL,
      'params' => array(
        'fq' => array('index_id:' . $this->index->machine_name),
        'q' => $keys,
        'sort' => 'score desc, id asc',
      ),
      'method' => 'GET',
    );
    $expected = $call_args;
    $expected['params']['fq'][] = "-bs_visitorsvoice_custom_remove_$id:true";
    $expected['params']['q'] = "($keys) OR bs_visitorsvoice_custom_add_$id:true";
    $expected['params']['sort'] = "iss_visitorsvoice_custom_order_$id asc, score desc, id asc";

    drupal_alter('search_api_solr_query', $call_args, $query);
    ksort($call_args['params']);
    $this->assertEqual($call_args, $expected, 'Solr query 2 was correctly altered.');

    $keys = 'bar';
    $id = $this->customizations[$keys];
    $query = new SearchApiQuery($this->index);
    $query->keys($keys);
    $query->setOption('visitorsvoice_customization', array(
      'id' => $id,
      'customizations' => array(
        VisitorsvoiceCustomizationInterface::TYPE_ADD,
        VisitorsvoiceCustomizationInterface::TYPE_REMOVE,
      ),
    ));
    $call_args = array(
      'query' => NULL,
      'params' => array(
        'fq' => array('index_id:' . $this->index->machine_name),
        'q' => $keys,
        'sort' => 'id asc, score desc',
      ),
      'method' => 'GET',
    );
    $expected = $call_args;
    $expected['params']['fq'][] = "-bs_visitorsvoice_custom_remove_$id:true";
    $expected['params']['q'] = "($keys) OR bs_visitorsvoice_custom_add_$id:true";

    drupal_alter('search_api_solr_query', $call_args, $query);
    ksort($call_args['params']);
    $this->assertEqual($call_args, $expected, 'Solr query 3 was correctly altered.');
  }

}
