<?php
/**
 * @file migrate_parcel.module
 * Contains main hooks and module code.
 */

/**
 * Implements hook_help().
 */
function migrate_parcels_help($path, $arg) {
  switch ($path) {
    case 'admin/content/migrate/parcels-update':
      return t("Use this form to re-export existing parcels. You will need to manually move the exported files to replace the ones already in sites/all/parcels.");
  }
}

/**
 * Implements hook_menu().
 */
function migrate_parcel_menu() {
  $items['admin/content/migrate/parcels'] = array(
    'title' => 'Entity parcels',
    'page callback' => 'migrate_parcel_overview_page',
    'access arguments' => array('export parcels'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'migrate_parcel.admin.inc',
  );

  $items['admin/content/migrate/parcels/export'] = array(
    'title' => 'Export new entity parcel',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('migrate_parcel_export_form'),
    'access arguments' => array('view parcels'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'migrate_parcel.admin.inc',
  );

  $items['admin/content/migrate/parcels/parcel/%migrate_parcel'] = array(
    'title' => 'Entity parcel',
    'page callback' => 'migrate_parcel_view',
    'page arguments' => array(5),
    'access arguments' => array('view parcels'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'migrate_parcel.admin.inc',
  );

  $items['admin/content/migrate/parcels-update'] = array(
    'title' => 'Update entity parcels',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('migrate_parcel_update_form'),
    'access arguments' => array('export parcels'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'migrate_parcel.admin.inc',
  );

  $items['admin/content/migrate/parcels/parcel/%migrate_parcel/cleanup'] = array(
    'title' => 'Clean up entity parcel',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('migrate_parcel_cleanup_form', 5),
    'access arguments' => array('clean up parcels'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'migrate_parcel.admin.inc',
  );

  return $items;
}

/**
 * Menu loader.
 *
 * @param $parcel_name
 *  A parcel machine name.
 *
 * @return
 *  An array of parcel info, or FALSE if no parcel found.
 */
function migrate_parcel_load($parcel_name) {
  $files = drupal_system_listing('/^' . $parcel_name . '.info$/', 'parcels');
  if (count($files) == 1) {
    return migrate_parcel_get_parcel($parcel_name, reset($files));
  }
  return FALSE;
}

/**
 * Implements hook_permission().
 */
function migrate_parcels_permission() {
  return array(
    'view parcels' => array(
      'title' => t('View entity parcels'),
    ),
    'export parcels' => array(
      'title' => t('Export entity parcels'),
    ),
    'clean up parcels' => array(
      'title' => t('Clean up entity parcels'),
    ),
  );
}

/**
 * Implementation of hook_flush_caches().
 */
function migrate_parcel_flush_caches() {
  migrate_parcel_register_migrations();
}

/**
 * Register Migrations.
 */
function migrate_parcel_register_migrations() {
  $parcels = migrate_parcel_get_parcels();
  foreach ($parcels as $machine_name => $migration_arguments) {
    Migration::registerMigration('MigrateExportMigration', $machine_name, $migration_arguments);
  }
}

/**
 * Get all the parcels defined in by migration data packages.
 *
 * @return
 *  An array of parcel data with which to create migrations, keyed by machine
 *  name. Each item is an array of data.
 */
function migrate_parcel_get_parcels() {
  // Get entity info.
  $entity_info = entity_get_info();
  // Get the files from sites/all/parcels/.
  $files = drupal_system_listing('/.info$/', 'parcels');

  $parcels = array();
  foreach ($files as $file) {
    $machine_name = $file->name;

    $info = migrate_parcel_get_parcel($machine_name, $file);

    $parcels[$machine_name] = $info;

    // Skip entities and bundles that don't exist.
    if (!isset($entity_info[$info['entity']]) || !isset($entity_info[$info['entity']]['bundles'][$info['bundle']])) {
      drupal_set_message(t("The parcel %parcel has not been registered as a migration because the entity bundle %entity %bundle does not exist.", array(
        '%parcel' => $info['machine_name'],
        '%entity' => $info['entity'],
        '%bundle' => $info['bundle'],
      )));
      continue;
    }
  }

  return $parcels;
}

/**
 * Helper to load info for a single parcel.
 *
 * @param $machine_name
 *  The machine name of the parcel.
 * @param $file
 *  A file object as returned from drupal_system_listing().
 *
 * @return
 *  An info array.
 */
function migrate_parcel_get_parcel($machine_name, $file) {
  $info = drupal_parse_info_file($file->uri);
  // Merge in defaults for optional bits.
  $info += array(
    'mapping_defaults' => array(),
    // The CSV file is expected to have the same name and be in the same folder.
    'csv_file' => pathinfo($file->uri, PATHINFO_DIRNAME) . '/' . $machine_name . '.csv',
  );

  // Register the migration.
  $migration_arguments = array(
    'machine_name'      => $info['machine_name'],
    'description'       => $info['description'],
    'entity'            => $info['entity'],
    'bundle'            => $info['bundle'],
    'source_file'       => $info['csv_file'],
    'mapping_defaults'  => $info['mapping_defaults'],
  );

  if (isset($info['key'])) {
    $migration_arguments['key'] = $info['key'];
  }
  if (isset($info['dependencies'])) {
    $migration_arguments['dependencies'] = $info['dependencies'];
  }

  return $migration_arguments;
}

/**
 * Workaround until http://drupal.org/node/1054162 is fixed in core. WTF!
 */
function migrate_parcel_entity_query_alter($query) {
  $conditions = &$query->entityConditions;

  // Alter taxonomy term queries only.
  if (isset($conditions['entity_type']) && $conditions['entity_type']['value'] == 'taxonomy_term' && isset($conditions['bundle'])) {
    if (in_array($conditions['bundle']['operator'], array(NULL, '=', '!=', 'IN', 'NOT IN'))) {
      $vids = array();
      if (is_array($conditions['bundle']['value'])) {
        foreach ($conditions['bundle']['value'] as $vocabulary_machine_name) {
          $vocabulary = taxonomy_vocabulary_machine_name_load($vocabulary_machine_name);
          $vids[] = $vocabulary->vid;
        }
      }
      else {
        $vocabulary = taxonomy_vocabulary_machine_name_load($conditions['bundle']['value']);
        $vids = $vocabulary->vid;
      }

      $query->propertyCondition('vid', $vids, $conditions['bundle']['operator']);
      unset($conditions['bundle']);
    }
  }
}

/**
 * Helper to get the fields to output to the CSV.
 *
 * This lists the fields that Migrate knows about for the entity which have
 * some chance of also being available from the Entity Property API.
 *
 * @param $entity_type
 *  The type of the entity to get fields for.
 * @param $bundle_name
 *  The bundle machine name to get fields for.
 *
 * @return
 *  A flat array of field names.
 */
function migrate_parcel_get_fields($entity_type, $bundle_name) {
  $destination_class = MigrateExportMigration::getDestinationClass($entity_type);
  $destination_object = MigrateExportMigration::getDestinationObject($destination_class, $entity_type, $bundle_name);
  $fields = $destination_object->fields();

  // Remove subfields.
  foreach (array_keys($fields) as $field) {
    if (strpos($field, ':') !== FALSE) {
      unset($fields[$field]);
    }
  }

  // Allow other modules to alter fields.
  drupal_alter('migrate_parcel_fields', $fields, $entity_type, $bundle_name);

  return array_keys($fields);
}

/**
 * Implement hook_migrate_parcel_fields_alter().
 *
 * Remove properties that won't currently work.
 *
 * @param $fields
 *  An array of fields as returned by Migration destination class. Keys are
 *  field machine names, values are UI descriptions.
 * @param $entity_type
 *  The type of the entity to get fields for.
 * @param $bundle_name
 *  The bundle machine name to get fields for.
 */
function migrate_parcel_migrate_parcel_fields_alter(&$fields, $entity_type, $bundle_name) {
  if ($entity_type == 'taxonomy_term') {
    // Remove properties that EntityAPI seems to be missing. WTF?
    unset($fields['parent_name']);
    unset($fields['format']);
    // Stuff we can't handle anyway
    unset($fields['pathauto']);
    // Bug in Migrate.
    unset($fields['path']);
  }
}
