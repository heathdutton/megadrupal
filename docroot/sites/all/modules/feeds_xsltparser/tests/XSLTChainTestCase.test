<?php
/**
 * @file:   Test cases for XSLTChain
 */

class XSLTChainTestCase extends DrupalUnitTestCase {
  private $goodtotextproc;
  private $goodtoxmlproc;
  private $goodparamproc;
  private $badproc;
  private $goodmarkup;
  private $badmarkup;
  private $xsl_available;

  public static function getInfo() {
    return array(
      'name' => 'XSLTChain test',
      'description' => 'Test whether a simple XSLT chain consisting of a trivial stylesheet and input is executed correctly',
      'group' => 'XSLT Pipeline Parser',
    );
  }

  function setUp() {
    parent::setUp();

    $this->xsl_available = extension_loaded('xsl');

    if (!$this->xsl_available) {
        trigger_error('XSL Extension is not available on this system. Skipping this test.', E_USER_NOTICE);
        return;
    }

    // prevent auto loading cause that seems to involve database queries
    module_load_include('inc', 'feeds_xsltparser', 'include/LibXMLException');
    module_load_include('inc', 'feeds_xsltparser', 'include/XSLTPipe');
    module_load_include('inc', 'feeds_xsltparser', 'include/XSLTChain');

    $goodxsltoxml =
      '<?xml version="1.0" encoding="UTF-8"?>' .
      '<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">' .
      '<xsl:output method="xml" encoding="UTF-8"/>' .
      '<xsl:template match="/">' .
      '  <alsogood><xsl:value-of select="."/></alsogood>' .
      '</xsl:template>' .
      '</xsl:stylesheet>';
    $this->goodtoxmlproc = new XSLTProcessor();
    $doc = new DOMDocument();
    $doc->loadXML($goodxsltoxml);
    $this->goodtoxmlproc->importStylesheet($doc);

    $goodxsltotext =
      '<?xml version="1.0" encoding="UTF-8"?>' .
      '<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">' .
      '<xsl:output method="text" encoding="UTF-8"/>' .
      '<xsl:template match="/">' .
      '<xsl:value-of select="."/>' .
      '</xsl:template>' .
      '</xsl:stylesheet>';
    $this->goodtotextproc = new XSLTProcessor();
    $doc = new DOMDocument();
    $doc->loadXML($goodxsltotext);
    $this->goodtotextproc->importStylesheet($doc);

    $paramxslt =
      '<?xml version="1.0" encoding="UTF-8"?>' .
      '<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">' .
      '<xsl:output method="text" encoding="UTF-8"/>' .
      '<xsl:param name="testparam"/>' .
      '<xsl:template match="/">' .
      '<xsl:value-of select="$testparam"/>' .
      '</xsl:template>' .
      '</xsl:stylesheet>';
    $this->goodparamproc = new XSLTProcessor();
    $doc = new DOMDocument();
    $doc->loadXML($paramxslt);
    $this->goodparamproc->importStylesheet($doc);

    $badxslt =
      '<?xml version="1.0" encoding="UTF-8"?>' .
      '<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">' .
      '<xsl:output method="text" encoding="UTF-8"/>' .
      '<xsl:template match="/">' .
      '<xsl:message terminate="yes">Simulate runtime error</xsl:message>' .
      '</xsl:template>' .
      '</xsl:stylesheet>';
    $this->badproc = new XSLTProcessor();
    $doc = new DOMDocument();
    $doc->loadXML($badxslt);
    $this->badproc->importStylesheet($doc);

    $this->goodmarkup =
      '<?xml version="1.0" encoding="UTF-8"?>' .
      '<good>Heck, it works!</good>';

    $this->badmarkup =
      '<?xml version="1.0" encoding="UTF-8"?>' .
      '<really>not parsable</bad>';
  }


  /**
   * The original markup should be returned by the XSLTChain if no processor
   * was added to the chain.
   */
  function testChainWithoutAnyProcessorShouldReturnOriginalMarkup() {
    if (!$this->xsl_available) {
        return;
    }

    $chain = new XSLTChain();
    $result = $chain->run($this->goodmarkup);

    $this->assertEqual($this->goodmarkup, $result);
  }


  /**
   * Test wether the result of the XSLT transformation with one single
   * stylesheet is correct.
   */
  function testChanWithOneStylesheetShouldReturnCorrectResult() {
    if (!$this->xsl_available) {
        return;
    }

    $chain = new XSLTChain();
    $chain->addProcessor($this->goodtotextproc);
    $result = $chain->run($this->goodmarkup);

    $this->assertEqual('Heck, it works!', $result);
  }


  /**
   * Test wether the result of the XSLT transformation with two stylesheet
   * applied one on top of the results of the other is correct.
   */
  function testChanWithMultipleStylesheetsShouldReturnCorrectResult() {
    if (!$this->xsl_available) {
        return;
    }

    $chain = new XSLTChain();
    $chain->addProcessor($this->goodtoxmlproc);
    $chain->addProcessor($this->goodtotextproc);
    $result = $chain->run($this->goodmarkup);

    $this->assertEqual('Heck, it works!', $result);
  }


  /**
   * Test wether the result of the XSLT transformation with one single
   * stylesheet is correct.
   */
  function testChanWithParam() {
    if (!$this->xsl_available) {
        return;
    }

    $chain = new XSLTChain();
    $chain->addProcessor($this->goodparamproc);

    $result = $chain->run($this->goodmarkup, array('testparam' => 'first'));
    $this->assertEqual('first', $result);

    $result = $chain->run($this->goodmarkup, array('testparam' => 'second'));
    $this->assertEqual('second', $result);
  }


  /**
   * Ensure that an exception is thrown when the markup is incorrect.
   */
  function testChainExceptionOnInvalidMarkup() {
    if (!$this->xsl_available) {
        return;
    }

    $chain = new XSLTChain();
    $chain->addProcessor($this->goodtotextproc);

    try {
      $result = $chain->run($this->badmarkup);
      $this->fail('Expecting exception caused by invalid input markup');
    }
    catch (LibXMLException $e) {
      $this->pass('XSLTChain::run throws an exception when markup is invalid');
    }
  }


  /**
   * Ensure that an exception is thrown when a runtime error occures in the
   * XSLT transformation.
   */
  function testChainExceptionOnXSLTRuntimeError() {
    if (!$this->xsl_available) {
        return;
    }

    $chain = new XSLTChain();
    $chain->addProcessor($this->badproc);

    try {
      $result = $chain->run($this->goodmarkup);
      $this->fail('Expecting exception when XSLT stylesheet reports a runtime error');
    }
    catch (LibXMLException $e) {
      $this->pass('XSLTChain::run throws an exception when a runtime error occured during XSLT processing');
    }
  }


  /**
   * Ennsure that an XSLTChain with a stylesheet loaded from a given path
   * produces the expected results.
   */
  function testAddProcessorFromPath() {
    if (!$this->xsl_available) {
        return;
    }

    $path = DRUPAL_ROOT . '/' . drupal_get_path('module', 'feeds_xsltparser') .
      "/tests/fixture/goodtotext.xslt";
    $chain = new XSLTChain();
    $chain->addProcessorFromPath($path);

    $result = $chain->run($this->goodmarkup);

    $this->assertEqual('Heck, it works!', $result);
  }


  /**
   * When attempting to load an XML document which does not contain an XSLT
   * stylesheet, an exception should be thrown.
   */
  function testAddProcessorFromPathWithInvalidStylesheet() {
    if (!$this->xsl_available) {
        return;
    }

    $path = DRUPAL_ROOT . '/' . drupal_get_path('module', 'feeds_xsltparser') .
      "/tests/fixture/noxsl.xslt";
    $chain = new XSLTChain();

    try {
      $chain->addProcessorFromPath($path);
      $this->fail('Expecting exception when attempting to load an XML document which does not contain an XSLT stylesheet');
    }
    catch (LibXMLException $e) {
      $this->pass('XSLTChain::addProcessorFromPath throws an exception when attempting to load an XML file which does not contain an xsl:stylesheet');
    }
  }


  /**
   * When attempting to load a stylesheet from a path which does not exist.
   */
  function testAddProcessorFromPathFromNonExistingPath() {
    if (!$this->xsl_available) {
        return;
    }

    $path = DRUPAL_ROOT . '/' . drupal_get_path('module', 'feeds_xsltparser') .
      "/tests/fixture/path-does-not-exist";
    $chain = new XSLTChain();

    try {
      $chain->addProcessorFromPath($path);
      $this->fail('Expecting exception when attempting to load a stylesheet from a path which does not exist');
    }
    catch (Exception $e) {
      $this->pass('XSLTChain::addProcessorFromPath throws an exception when attempting to load a stylesheet from a path which does not exist');
    }
  }


  /**
   * When attempting to load an invalid XML document as an XSLT stylesheet, an
   * exception should be thrown.
   */
  function testAddProcessorFromPathWithInvalidXML() {
    if (!$this->xsl_available) {
        return;
    }

    $path = DRUPAL_ROOT . '/' . drupal_get_path('module', 'feeds_xsltparser') .
      "/tests/fixture/invalidxml.xslt";
    $chain = new XSLTChain();

    try {
      $chain->addProcessorFromPath($path);
      $this->fail('Expecting exception when attempting to load an XML document which does not contain an XSLT stylesheet');
    }
    catch (LibXMLException $e) {
      $this->pass('XSLTChain::addProcessorFromPath throws an exception when attempting to load a malformed XML file');
    }
  }
}
