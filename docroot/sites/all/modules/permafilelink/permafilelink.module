<?php
/**
 * @file
 * Manage inline links to managed files in formatted textareas.
 */

/**
 * The base path for permafilelinks. Maybe this should go into a variable.
 *
 * IDEA: We could maintain a list of PFL routes in a global setting, then
 *       let the sitebuilder select them on the filter settings.
 */
define('PERMAFILELINK_ROUTE', 'pfid');

/**
 * Implements hook_module_implements_alter().
 */
function permafilelink_module_implements_alter(&$implementations, $hook) {
  // We need to be late in the invoke chain for form_alter.
  if ($hook == 'form_alter') {
    $group = $implementations['permafilelink'];
    unset($implementations['permafilelink']);
    $implementations['permafilelink'] = $group;
  }
}

/**
 * Implements hook_help().
 */
function permafilelink_help($path, $arg) {
  $output = '';
  switch ($path) {
    case 'admin/config/media/permafilelink':
      $output = '<p>' . t('Enable verbose reporting on issues arising when
editing textareas with the permanent filelink filter enabled.') . '</p>';
      break;
  }
  return $output;
}

/**
 * Implements hook_menu().
 *
 * Hook the route so that permafilelinks will always work.
 */
function permafilelink_menu() {
  $items = array();

  // Hook up the PFL route. TODO: access issues?
  $items[PERMAFILELINK_ROUTE . '/%'] = array(
    'page callback' => '_permafilelink_pass_file',
    'page arguments' => array(1),
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  // Administration page.
  $items['admin/config/media/permafilelink'] = array(
    'title' => 'Permanent Filelink',
    'description' => 'Configure settings related to Permanent Filelink.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('permafilelink_settings_form'),
    'access arguments' => array('administer site configuration'),
    'file' => 'permafilelink.admin.inc',
  );

  return $items;
}

/**
 * File routing.
 */

/**
 * Callback for 'PERMAFILELINK_ROUTE/%' menu hook.
 *
 * Pass on $fid file if it exists.
 */
function _permafilelink_pass_file($fid) {

  // Rudimentary, but effective sanitizing of $fid.
  $fid = intval($fid);

  // Looking up the file.
  if ($file = file_load($fid)) {
    // It is there, but should we pass it on?
    if (file_download_access($file->uri)) {
      // Yes, the user may have it.
      $headers = array(
        'Content-Type' => $file->filemime,
      );
      file_transfer($file->uri, $headers);
    }
    else {
      drupal_access_denied();
    }
  }
  else {
    drupal_not_found();
  }

  drupal_exit();
}

/**
 * Form handling.
 */

/**
 * Implements hook_form_alter().
 *
 * We add the PFL submit handler to all interesting forms, i.e. those that
 * may have formatted textareas.
 */
function permafilelink_form_alter(&$form, &$form_state, $form_id) {
  /* Using 'array_unshift' instead of '$form['#submit'][] =' because some
   * modules (e.g. 'block') will save data before finishing submit handlers.
   */

  // Block administration forms.
  if ($form_id == 'block_admin_configure') {
    array_unshift($form['#submit'], '_permafilelink_form_submit');
    return;
  }

  // Display Suite custom field.
  if ($form_id == 'ds_edit_custom_field_form') {
    array_unshift($form['#submit'], '_permafilelink_form_submit');
    return;
  }

  // Entity create/update forms.
  if (isset($form['#entity_type'])) {
    array_unshift($form['#submit'], '_permafilelink_form_submit');
    return;
  }

  // Node create/update forms (redundant?)
  if (isset($form['#node_edit_form']) && $form['#node_edit_form']) {
    array_unshift($form['#submit'], '_permafilelink_form_submit');
    return;
  }
}

/**
 * Form submit handler. Attached to forms in hook_form_alter().
 */
function _permafilelink_form_submit($form, &$form_state) {
  _permafilelink_form_submit_process($form, $form_state);
}

/**
 * Traverse form child elements, depth-first recursive.
 *
 * If we find a text_format element, then we work it over.
 */
function _permafilelink_form_submit_process($form, &$form_state) {
  foreach (element_children($form) as $key) {
    if (isset($form[$key]) && $form[$key]) {
      if (isset($form[$key]['#type']) && $form[$key]['#type'] == 'text_format') {
        // Process element.
        _permafilelink_process_element($form[$key], $form_state);
      }
      else {
        // Descend to child elements.
        _permafilelink_form_submit_process($form[$key], $form_state);
      }
    }
  }
}

/**
 * Process the actual text_format element.
 */
function _permafilelink_process_element($element, &$form_state) {
  $field_value = drupal_array_get_nested_value($form_state['values'], $element['value']['#parents']);

  $field_value = _permafilelink_shorten_file_links($field_value);

  drupal_array_set_nested_value($form_state['values'], $element['value']['#parents'], $field_value, TRUE);
}

/**
 * Substitute file links.
 */

/**
 * Transforms canonical filelinks to permafilelinks.
 */
function _permafilelink_shorten_file_links($text) {
  $files_path_parts = _permafilelink_uri_parts();

  // Build search pattern (it's a regex).
  $pattern = '#"[^"]*' . preg_quote($files_path_parts['path'], '#') . '(?P<filepath>[^"]+)"#i';

  $matches = array();
  if (preg_match_all($pattern, $text, $matches)) {
    foreach ($matches['filepath'] as $key => $filepath) {
      $message = '';
      $match = $matches[0][$key];
      if ($fid = _permafilelink_fid_by_path($filepath)) {
        $short_uri = '"' . _permafilelink_route($fid) . '"';
        $text = str_replace($match, $short_uri, $text);
        $message = t('Replaced !filepath with !short_uri', array('!filepath' => $filepath, '!short_uri' => $short_uri));
      }
      else {
        // File probably isn't managed and consequently doesn't have a fid.
        // How to handle this?
        $message = t('!filepath is not a managed file', array('!filepath' => $filepath));
      }

      if (variable_get('permafilelink_verbose_reporting', FALSE)) {
        drupal_set_message($message);
      }
    }
  }

  return $text;
}

/**
 * Expand permafilelinks back to canonical form.
 *
 * Optionally compacting them according to http server rewrite rules.
 */
function _permafilelink_expand_file_links($text, $filter = FALSE) {

  $pattern = '#/' . PERMAFILELINK_ROUTE . '/(?P<fid>\d+)#';

  $matches = array();
  if (preg_match_all($pattern, $text, $matches)) {

    // Set up for reshorting, if applicable.
    if ($reshorting = $filter && $filter->settings['reshorting']) {
      $_uri_parts = _permafilelink_uri_parts();
      $short_path = $_uri_parts['path'];
      $short_base = filter_xss_bad_protocol($filter->settings['short_base']);
    }

    foreach ($matches['fid'] as $fid) {
      if ($file = file_load($fid)) {
        $org = _permafilelink_route($fid);
        $url = file_create_url($file->uri);

        // Reshorting?
        if ($reshorting) {
          $url = str_replace($short_path, $short_base, $url);
        }

        $text = str_replace($org, $url, $text);
      }
    }
  }
  return $text;
}

/**
 * Return file id (fid) from canonical file path.
 *
 * This may return FALSE if the file isn't managed.
 */
function _permafilelink_fid_by_path($path) {
  $path = urldecode($path);

  $uris = array(
    'public://' . $path,
    'private://' . $path,
  );

  $result = db_select('file_managed', 'fm')
    ->fields('fm', array('fid'))
    ->condition('uri', $uris, 'IN')
    ->execute();

  // Is this file managed?
  if ($result->rowCount() == 1) {
    return $result->fetchColumn();
  }

  return FALSE;
}

/**
 * Get default 'files' uri parts.
 */
function _permafilelink_uri_parts() {
  $uri = file_create_url(file_default_scheme() . '://');
  $parts = drupal_parse_url($uri);
  return $parts;
}

/**
 * Returns the permafilelink for the given fid.
 */
function _permafilelink_route($fid) {
  return '/' . PERMAFILELINK_ROUTE . '/' . $fid;
}

/**
 * Filter.
 */

/**
 * Implements hook_filter_info().
 */
function permafilelink_filter_info() {
  $filters['permafilelink'] = array(
    'title' => t('Permanent File Links'),
    'description' => t('Allows you to insert managed file links into content independently of actual path.'),
    'settings callback' => '_permafilelink_filter_settings',
    'default settings' => array(
      'reshorting' => FALSE,
      'short_base' => '/files/',
    ),
    'process callback' => '_permafilelink_filter_process',
    'cache' => FALSE,
    'tips callback' => '_permafilelink_filter_tips',
    'weight' => 0,
  );
  return $filters;
}

/**
 * Implements hook_filter_settings().
 */
function _permafilelink_filter_settings($form, &$form_state, $filter, $format, $defaults, $filters) {
  $filter->settings += $defaults;

  $full = _permafilelink_uri_parts();

  $elements = array();
  $elements['reshorting'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable further link shortening'),
    '#description' => t("On multisite installations, filelinks will often have the form '!fulldummy.doc', making them unreasonably long and confusing. With a litte webserver rewrite magic, such links can be shortened greatly. Enable link shortening to support this feature.", array('!full' => $full['path'])),
    '#default_value' => $filter->settings['reshorting'],
  );

  $elements['short_base'] = array(
    '#type' => 'textfield',
    '#title' => t('Shortening replacement pattern'),
    '#description' => t("Links of the form '!fulldummy.doc' will become '@shortdummy.doc'.", array('!full' => $full['path'], '@short' => $filter->settings['short_base'])),
    '#default_value' => $filter->settings['short_base'],
  );

  return $elements;
}

/**
 * Implements hook_filter_process().
 *
 * This is where the actual work is done.
 *
 * It will translate permafilelinks to canonical filelinks.
 */
function _permafilelink_filter_process($text, $filter, $format, $langcode, $cache, $cache_id) {
  return _permafilelink_expand_file_links($text, $filter);
}

/**
 * Implements hook_filter_tips().
 */
function _permafilelink_filter_tips($filter, $format, $long) {
  if ($long) {
    return t('Translates permanent file links into full paths.');
  }
  else {
    return t('Translates permanent file links into canonical file links.');
  }
}
