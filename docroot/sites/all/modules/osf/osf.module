<?php

use \StructuredDynamics\osf\php\api\ws\crud\read\CrudReadQuery;
use \StructuredDynamics\osf\php\api\ws\search\SearchQuery;
use \StructuredDynamics\osf\php\api\ws\ontology\read\GetLoadedOntologiesFunction;
use \StructuredDynamics\osf\php\api\ws\ontology\read\OntologyReadQuery;

/*! @defgroup OSFForDrupalModule OSF for Drupal Drupal Module */
//@{

/*! 	@file osf.module
 @brief Main OSF for Drupal module file.
 @details This file includes all the other PHP files needed to run this Drupal module.

 @author Frederick Giasson, Structured Dynamics LLC.

 \n\n\n
 */

use StructuredDynamics\osf\php\api\ws\auth\lister\AuthListerQuery;
use StructuredDynamics\osf\framework\Namespaces;

// Include the utilities function used by the hooks and tools
include_once __DIR__ . '/framework/utilities.php';

/**
 * Implements hook_boot().
 *
 * Integrate the OSF WS PHP API with xautoload.
 */
function osf_boot() {
  // Would ideally like to use libraries_get_path but the libraries module is not
  // loaded yet, and drupal_get_path is not available either.
  $path = 'sites/all/libraries/OSF-WS-PHP-API';
  if (is_dir($path)) {
    $finder = xautoload_get_finder();
    $finder->registerNamespaceRoot('StructuredDynamics', $path);
  }
}

/**
 * Callback function for 'osf'.
 *
 * @brief Main Drupal hook procedure
 * @details This hook is the first one called by Drupal when one of the module's page is accessed.
 * We use this hook to:
 * \li Get the URI that has been accessed by the user
 * \li Trigger the OSF for Drupal tool related to this URI by calling its main procedure.
 *
 * @return A string containing the HTML page description generated by the OSF for Drupal tool
 *
 * @author Frederick Giasson, Structured Dynamics LLC.
 */
function osf_main() {
  // TODO: Determine if this is necessary.
  cache_clear_all('variables', 'cache');

  drupal_add_css(drupal_get_path('module', 'osf') . '/css/style.css');

  // Get the extension of the URI requested to Drupal.
  $uri = $_GET['q'];

  if (stripos($uri, "osf/settings/cache") !== FALSE) {
    return osf_cache();
  }

  return array('#markup' => '<p>' . t("Check OSF for Drupal tools in the right sidebar") . '</p>');
}

/**
 * @brief Main Drupal hook procedure
 * @details This hook is the first one called by Drupal when one of the module's page is accessed.
 * We use this hook to:
 * \li Get the URI that has been accessed by the user
 * \li Trigger the OSF for Drupal tool related to this URI by calling its main procedure.
 *
 * @return A string containing the HTML page description generated by the OSF for Drupal tool
 *
 * @author Frederick Giasson, Structured Dynamics LLC.
 */
function osf_networks_main() {
  module_load_include('php', 'osf', 'framework/utilities');

  drupal_add_css(drupal_get_path('module', 'osf') . '/css/osf_networks_style.css');

  return (osf_networks());
}

/**
 * Implements hook_nenu().
 *
 * @brief Define menu items and page callbacks.
 * @details This hook enables modules to register paths, which determines whose requests are to be handled.
 * Depending on the type of registration requested by each path, a link is placed in the the navigation
 * block and/or an item appears in the menu administration page (q=admin/menu).
 *
 * @return An array of menu items. Each menu item has a key corresponding to the Drupal path being registered.
 * The item is an associative array.
 *
 * @author Frederick Giasson, Structured Dynamics LLC.
 *
 * @see http://api.drupal.org/api/function/hook_block
 *
 */
function osf_menu() {
  $items = array();

  // Registration of the OSF for Drupal module settings page path
  $items['admin/config/osf'] = array(
    'title' => t('OSF for Drupal Settings'),
    'type' => MENU_NORMAL_ITEM,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('osf_settings_redirect'),
    'access arguments' => array('administer osf'),
    'weight' => -1000,
  );

  $items['admin/config/osf/config'] = array(
    'title' => t('Configure OSF for Drupal modules'),
    'type' => MENU_NORMAL_ITEM,
    'description' => t('Configure all the OSF for Drupal modules settings options'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('osf_configure_redirect'),
    'access arguments' => array('administer osf'),
  );  

  $items['admin/config/osf/caching'] = array(
    'title' => t('Caching'),
    'description' => t('Caching related settings'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('osf_caching'),
    'access arguments' => array('administer osf'),
    'type' => MENU_LOCAL_TASK,
    'weight' => -19,    
  );

  // Define some debugging options for OSF for Drupal
  $items['admin/config/osf/development'] = array(
    'title' => t('Development'),
    'description' => t('OSF for Drupal settings related to the development of a new instance. 
                        All the debugging and theming development features are available in this
                        section.'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('osf_development_settings'),
    'access arguments' => array('administer osf'),
    'type' => MENU_LOCAL_TASK,
    'weight' => -20,    
  );

  // Register the Ajax callback function
  $items['osf/proxy'] = array(
    'page callback' => 'osf_proxy',
    'access arguments' => array('access osf proxy'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Proxy procedure that can be used by any external module.
 * This proxy is used to let other Drupal modules to send queries to a OSF
 * instance which cannot be queried directly by the users' browser.
 *
 * This proxy uses the POST method to get all the required information to properly
 * query a remote OSF instance. The post variables that should be used are:
 *
 *   (1) "params": parameters to send to the endpoint
 *   (2) "ws": the web service endpoint to query
 *   (3) "method": GET or POST to query end endpoint
 *   (4) "accept": the requested mime type for that query
 *
 * @see http://drupal.org/node/1354
 */
function osf_proxy() {
  global $user;

  $params = "";

  if (isset($_POST["params"])) {
    $params = $_POST["params"];
  }

  $ws = "";

  if (isset($_POST["ws"])) {
    $ws = $_POST["ws"];
  }

  $method = "";

  if (isset($_POST["method"])) {
    $method = $_POST["method"];
  }

  $accept = "";

  if (isset($_POST["accept"])) {
    $accept = $_POST["accept"];
  }

  include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'osf') . '/framework/WebServiceQuerier.php';

  // Add the reference to the requesting user.

  // Check to see what role the user has on the node
  $resultset =
        db_query('SELECT {role}.name FROM {users_roles} INNER JOIN {role} ON {role}.rid = {users_roles}.rid WHERE uid = :uid ', array(':uid' => $user->uid));

  $roleNames = array();

  // Get all WSF address still in use
  while ($roleName = $resultset->fetchField()) {
    array_push($roleNames, $roleName);
  }

  $wsq = new WebServiceQuerier($ws, $method, $accept, $params);

  header("HTTP/1.1 " . $wsq->getStatus() . " " . $wsq->getStatusMessage());
  header("Content-Type: " . $accept);

  if ($wsq->getStatus() == 200) {
    drupal_add_http_header('Content-Type', 'text/javascript; charset=utf-8');

    echo $wsq->getResultset();
  }
  else {
    drupal_add_http_header('Content-Type', 'text/javascript; charset=utf-8');

    echo $wsq->getStatusMessageDescription();
  }
}

/**
 * Implements hook_libraries_info()
 */
function osf_libraries_info() {
  $libraries['OSF-WS-PHP-API'] = array(
    'name' => t('OSF-WS-PHP-API Library'),
    'vendor url' => 'http://www.structureddynamics.com',
    'download url' => 'http://github.com/structureddynamics/OSF-WS-PHP-API',
    'version callback' => 'osf_phpapi_version',
    // Use this instead of hook_init once http://drupal.org/node/1781794 is resolved
    // Be sure to remove the autoload hookup from contruct_init when this is enabled.
    //'xautoload' => array(
    //  'namespace' => 'StructuredDynamics'
    //),
  );
  return $libraries;
}

/**
 * Return the version of the PHP API Library.
 *
 * TODO: Determine the version from a file within the lib.
 */
function osf_phpapi_version() {
  $path = libraries_get_path('OSF-WS-PHP-API');
  if (file_exists($path . '/.git')) {
    return t('Development (git checkout)');
  }
  return "1.0";
}

/**
 * Implements hook_block_info().
 *
 * @brief Declare a block or set of blocks.
 * @details 	Any module can export a block (or blocks) to be displayed by defining the _block hook. This hook
 * is called by theme.inc to display a block, and also by block.module to procure the list of available blocks.
 *
 * The functions mymodule_display_block_1 and 2, as used in the example, should of course be defined
 * somewhere in your module and return the content you want to display to your users. If the "content"
 * element is empty, no block will be displayed even if "subject" is present.
 *
 * After completing your blocks, do not forget to enable them in the block admin menu.
 *
 * @param[in] $op What kind of information to retrieve about the block or blocks. Possible values:
 * @li 'list': A list of all blocks defined by the module.
 * @li 'configure': Configuration form for the block.
 * @li 'save': Save the configuration options.
 * @li 'view': Process the block when enabled in a region in order to view its contents.
 *
 * @param[in] $delta Which block to return (not applicable if $op is 'list'). Although it is most commonly an integer starting at 0, this is not mandatory. For instance, aggregator.module uses string values for $delta.
 *
 * @param[in] $edit If $op is 'save', the submitted form data from the configuration form.
 *
 * @return If $op is 'list': An array of block descriptions. Each block description is an associative array.
 *
 * @author Frederick Giasson, Structured Dynamics LLC.
 *
 * @see http://api.drupal.org/api/function/hook_block
 */
function osf_block_info() {
  // TODO Rename block deltas (e.g. delta-0) to readable strings.

  // If $op is "list", we just need to return a list of block descriptions.
  // This is used to provide a list of possible blocks to the administrator,
  // end users will not see these descriptions.

  $blocks['contstuct'] = array(
    'info' => t('OSF for Drupal Settings'),
    'cache' => DRUPAL_NO_CACHE,
  );

  $blocks['osf_networks'] = array(
    'info' => t('OSF for Drupal Network Settings'),
    'cache' => DRUPAL_NO_CACHE,
  );

  return $blocks;
}

/**
 * Implements hook_block_configure().
 */
function osf_block_configure($delta) {
  // TODO Rename block deltas (e.g. delta-0) to readable strings.

  // If $op is "configure", we need to provide the administrator with a
  // configuration form. The $delta parameter tells us which block is being
  // configured. In this example, we'll allow the administrator to customize
  // the text of the first block.
  $form = array();
  if ($delta == 'delta-0') {
    // All we need to provide is a text field, Drupal will take care of
    // the other block configuration options and the save button.
    $form['block_example_string'] = array(
      '#type' => 'textfield',
      '#title' => t('Block contents'),
      '#size' => 100,
      '#description' => t('This string will appear in the OSF for Drupal Tools menu'),
      '#default_value' => '',
    );
  }

  return $form;
}

/**
 * Implements hook_block_view().
 */
function osf_block_view($delta) {
  // TODO Rename block deltas (e.g. delta-0) to readable strings.

  $block = array();
  // If $op is "view", then we need to generate the block for display
  // purposes. The $delta parameter tells us which block is being requested.
  switch ($delta) {
    case 'osf':
      // The subject is displayed at the top of the block. Note that it
      // should be passed through t() for translation.
      $block['subject'] = t('OSF for Drupal Tools');
      $block['content'] = osf_contents(1);
      break;

    case 'osf_networks':
      $block['subject'] = t('Contruct Network Tools');
      $block['content'] = osf_networks_contents(1);
  }

  return $block;
}

/**
 * @brief Display the OSF for Drupal side-bar menu items
 * @details 	This function is called to generate the HTML of the tool lists being displayed in the side-bar.
 *
 * @return A string where the HTML menus have been defined.
 *
 * @author Frederick Giasson, Structured Dynamics LLC.
 *
 */
function osf_contents($which_block) {
  if ($which_block == 1) {
    // Modules would typically perform some database queries to fetch the
    // content for their blocks. Here, we'll just use the variable set in the
    // block configuration or, if none has set, a default value.

    $icon = theme('image', array('path' => drupal_get_path("module", "osf") . '/imgs/kcontrol.png', 'attributes' => array('style' => 'padding-right:5px;')));
    $menuItems = array();

    // For a specific user
    $menuItems[] = l($icon . t("Settings"), 'admin/config/osf', array('html' => TRUE));

    /*! note: this procedure can have performence issue with big OSF instances (big datasets). */
    $menuItems[] = l($icon . t("Access Settings"), 'admin/config/osf/access', array('html' => TRUE));

    if (module_exists("osf_ontology")) {
      /*! note: this procedure can have performence issue with big OSF instances (big datasets). */
      $menuItems[] = l($icon . t("Ontology Settings"), 'admin/config/osf/osf_ontology', array('html' => TRUE));
    }

    return implode('<br />', $menuItems);
  }
}

/**
 * Implements hook_permissions().
 *
 * @brief Define user permissions.
 * @details 	This hook can supply permissions that the module defines, so that they can be selected on the user
 * permissions page and used to restrict access to actions the module performs.
 *
 * The permissions in the array do not need to be wrapped with the function t(), since the string extractor
 * takes care of extracting permission names defined in the perm hook for translation.
 *
 * Permissions are checked using user_access().
 *
 * @note Currently only two kind of users exist: (1) "access" and (2) "administer". However, we expect to have more
 * kind of users in the future for different node maintenance purposes
 *
 * @note Once new permissions are created, the node administrator has to set their permissions in the setting panel
 * of the node
 *
 * @return An array of permissions strings.
 *
 * @author Frederick Giasson, Structured Dynamics LLC.
 *
 * @see http://api.drupal.org/api/function/hook_perm
 */
function osf_permission() {
  return array(
    'access osf' => array(
      'title' => t('access osf'),
      'description' => t('Access OSF content'),
    ),
    'administer osf' => array(
      'title' => t('administer osf'),
      'description' => t('Administer OSF for Drupal'),
    ),
    'access osf proxy' => array(
      'title' => t('access osf proxy'),
      'description' => t('Accessing the OSF for Drupal proxy to enable some ajax features within some OSF for Drupal modules'),
    ),
  );
}

function osf_configure_redirect() {
  drupal_goto('admin/config/osf');
}

function osf_settings_redirect() {
  
  // Select the first tab when we reach this menu item
  
  if(module_exists('osf_configure'))
  {
    drupal_goto('admin/config/osf/networks_and_dataset');
  }
  elseif(module_exists('osf_searchapi'))
  {
    drupal_goto('admin/config/osf/osf_searchapi');  
  }
  elseif(module_exists('osf_entities'))
  {
    drupal_goto('admin/config/osf/entities');  
  }
  elseif(module_exists('osf_fieldstorage'))
  {
    drupal_goto('admin/config/osf/localstorage');  
  }
  elseif(module_exists('osf_ontology'))
  {
    drupal_goto('admin/config/osf/osf_ontology');  
  }
  
  
  
  
}


/**
 * @brief Define access restrictions.
 * @details 	This hook allows node modules to limit access to the node types they define.
 * The administrative account (user ID #1) always passes any access check, so this hook is not called in that case. If this
 * hook is not defined for a node type, all access checks will fail, so only the administrator will be able to see content of that
 * type. However, users with the "administer nodes" permission may always view and edit content through the
 * administrative interface.
 *
 * @warning The access hook is not yet implemented
 *
 * @param[in] $op The operation to be performed. Possible values:
 * @li "create"
 * @li "delete"
 * @li "update"
 * @li "view
 * @param[in] $node The node on which the operation is to be performed, or, if it does not yet exist, the type of node to be created.
 *
 * @param[in] $account A user object representing the user for whom the operation is to be performed.
 *
 * @return TRUE if the operation is to be allowed; FALSE if the operation is to be denied; NULL to not override the settings in the node_access table, or access control modules.
 *
 * @author Frederick Giasson, Structured Dynamics LLC.
 *
 * @todo Implementing the access hook properly
 *
 * @see http://api.drupal.org/api/function/hook_access
 */   

function osf_caching($form, &$form_state) {

  drupal_add_js("
    function checkUncheckAll(checkAllElement){
      var fieldsSet = jQuery(checkAllElement).parent().parent().find('input'), z = 0;
      for(z = 0; z < fieldsSet.length ; z++){
        if(fieldsSet[z].type == 'checkbox' && fieldsSet[z].name != 'checkall' && !fieldsSet[z].disabled){
          fieldsSet[z].checked = checkAllElement.checked;
        }
      }
    }
  ", 'inline');  
  
  if(module_exists(osf_entities))
  {
    $form['osf_entities_caching'] = array(
      '#type' => 'fieldset',
      '#title' => t('OSF Entities Caching'),
      '#description' => t('Pre-cache all the entities of a dataset on this Drupal instance.
                           With this feature, you can pre-cache a set of entities that exists in a
                           registered dataset after you flushed all the cache of the instance. 
                           This is a convenient way to greatly improve the experience of your 
                           users in a production site.<br/><br/>'),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,    
    );

    $datasets = osf_configure_dataset_load_util('all', TRUE);
    
    $options = array();
    
    foreach($datasets as $dataset)
    {
      $options[$dataset->uri] = $dataset->label;
    }
    
    asort($options, SORT_STRING);
    
    $form['osf_entities_caching']['checkall_datasets'] = array(
      '#type' => 'checkbox',
      '#title' => t('Select / Unselect all'),
      '#attributes' => array('onclick' => 'checkUncheckAll(this);'),
      '#weight' => -1,
    );    
    
    $form['osf_entities_caching']['osf_caching_settings_osf_entities_datasets'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Datasets'),
      '#options' => $options,
      "#default_value" => variable_get('osf_caching_settings_osf_entities_datasets', array())
    );          
    
    $loadedOntologies = osf_get_loaded_ontologies();
    $options = array();

    foreach($loadedOntologies as $uri => $ontology)
    {
      if(empty($ontology['prefLabel']))
      {
        $options[$uri] = $uri;
      }
      else
      {
        $options[$uri] = $ontology['prefLabel']; 
      }    
    }
    
    asort($options, SORT_STRING);
    
    $form['osf_entities_caching']['osf_caching_settings_osf_entities_ontologies'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Ontologies Datasets'),
      '#options' => $options,
      "#default_value" => variable_get('osf_caching_settings_osf_entities_ontologies', array())
    );      
    
    $form['osf_entities_caching']['submit_entities'] = array(  
      '#type' => 'submit', 
      '#value' => t('Pre-cache selected datasets entities'),
    );          
  }

  if(module_exists(osf_fieldstorage))
  {
    $form['osf_fieldstorage_caching'] = array(
      '#type' => 'fieldset',
      '#title' => t('OSF FieldStorage Caching'),
      '#description' => t('Pre-cache all the entities of an existing bundle on this Drupal instance.
                           With this feature, you can pre-cache a set of entities after
                           you flushed all the cache of the instance. This is a convenient way
                           to greatly improve the experience of your users in a production site.<br/><br/>'),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,    
    );
    
    $options = array();

    foreach(field_info_bundles('node') as $bundle => $desc)
    {
      $options[$bundle] = $desc['label'];
    }
    
    asort($options, SORT_STRING);
    
    $form['osf_fieldstorage_caching']['checkall'] = array(
      '#type' => 'checkbox',
      '#title' => t('Select / Unselect all'),
      '#attributes' => array('onclick' => 'checkUncheckAll(this);'),
      '#weight' => -1,
    );    

    $form['osf_fieldstorage_caching']['osf_caching_settings_osf_fieldstorage_bundles'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Bundles'),
      '#options' => $options,
      "#default_value" => variable_get('osf_caching_settings_osf_fieldstorage_bundles', array())
    );    
    
    $form['osf_fieldstorage_caching']['submit_fieldstorage'] = array(  
      '#type' => 'submit', 
      '#value' => t('Pre-cache selected bundles entities'),
    );      
  }
  
  $form['#submit'][] = 'osf_caching_submit';  
  
  return $form;
}

function osf_caching_submit($form, &$form_state) {
  if($form_state['clicked_button']['#id'] == 'edit-submit-fieldstorage')
  {
    $bundles = array();
    
    foreach($form_state['values']['osf_caching_settings_osf_fieldstorage_bundles'] as $bundle => $item)
    {
      if(!empty($item))
      {
        $bundles[] = $bundle;
      }
    }
    
    $batch = array('title' => t('Pre-cache Bundles Entities...'),
                   'operations' => array(
                     array('osf_batch_precache_bundle_entities', array($bundles)),
                   ),
                   'progress_message' => t(''),
                   'finished' => 'osf_batch_precache_bundle_entities_finished',
                   'file' => drupal_get_path('module', 'osf').'/osf.module');
                   
    batch_set($batch);    
  }
  else
  {
    $datasets = array();

    foreach($form_state['values']['osf_caching_settings_osf_entities_datasets'] as $dataset => $item)
    {
      if(!empty($item))
      {
        $datasets[] = $dataset;
      }
    }
    
    foreach($form_state['values']['osf_caching_settings_osf_entities_ontologies'] as $dataset => $item)
    {
      if(!empty($item))
      {
        $datasets[] = $dataset;
      }
    }    
    
    $batch = array('title' => t('Pre-cache Datasets Entities...'),
                   'operations' => array(
                     array('osf_batch_precache_datasets_entities', array($datasets)),
                   ),
                   'progress_message' => t(''),
                   'finished' => 'osf_batch_precache_datasets_entities_finished',
                   'file' => drupal_get_path('module', 'osf').'/osf.module');
                   
    batch_set($batch);    
  }
}

function osf_batch_precache_bundle_entities($bundles, &$context) 
{
  $nbEntities = 0;

  foreach($bundles as $bundle)
  {
    $nbEntities += db_query('SELECT COUNT(DISTINCT nid) FROM {node} WHERE type = :bundle', array(':bundle' => $bundle))->fetchField();
  }
  
  if(empty($context['sandbox'])) 
  {
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['current_node'] = 0;
    $context['sandbox']['max'] = $nbEntities;
  }
  
  $limit = 10;

  $or = db_or();
  
  foreach($bundles as $bundle)
  {  
    $or->condition('type', $bundle, '=');
  }    
    
  $result = db_select('node')->fields('node', array('nid'))
                             ->condition('nid', $context['sandbox']['current_node'], '>')
                             ->condition($or)
                             ->orderBy('nid')
                             ->range(0, $limit)
                             ->execute();

  $entities = array();
  $current_node = '';
  
  foreach($result as $row) 
  { 
    $entities[] = $row->nid;
        
    $context['results'][] = $row->nid;
    $current_node = $row->nid;
  }
   
  // Load the node to save
  //$node = node_load($row->nid, NULL, TRUE);
  $node = current(entity_load('node', $entities));
  
  $context['sandbox']['progress'] += $limit;
  $context['sandbox']['current_node'] = $current_node;
  $context['message'] = '<span style="padding-left: 3px;" />('.$context['sandbox']['progress'].'/'.$nbEntities.')<span style="padding-right: 30px;" />';
  
  if($context['sandbox']['progress'] != $context['sandbox']['max']) 
  {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
}  

function osf_batch_precache_bundle_entities_finished($success, $results, $operations) 
{
  // The 'success' parameter means no fatal PHP errors were detected. All
  // other error management should be handled using 'results'.
  if($success) 
  {
    $message = format_plural(count($results), 'One node processed.', '@count nodes processed.');
  }
  else 
  {
    $message = t('Finished with an error.');
  }
  
  drupal_set_message($message);
  
  // Providing data for the redirected page is done through $_SESSION.
  foreach ($results as $result) 
  {
    $items[] = t('Node pre-cached: %title.', array('%title' => $result));
  }
  
  $_SESSION['osf_batch_precache_bundle_entities'] = $items;
}
  
function osf_batch_precache_datasets_entities($datasets, &$context) 
{
  $nbEntities = 0;
  
  $defaultEndpoint = current(osf_configure_get_default_endpoint());
  
  $search = new SearchQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
  
  $search->datasetsFilters($datasets)
         ->includeAggregates()
         ->page(0)
         ->items(0)
         ->send(new DrupalQuerierExtension());
  
  if($search->isSuccessful())
  {
    $resultset = $search->getResultset()->getResultset();
    
    foreach($resultset['unspecified'] as $uri => $record)
    {
      if($record['type'][0] == Namespaces::$aggr.'Aggregate' &&
         $record[Namespaces::$aggr.'property'][0]['uri'] == Namespaces::$void.'Dataset')
      {
        $nbEntities = $record[Namespaces::$aggr.'count'][0]['value'];
        
        break;
      }
    }    
  }
  
  if(empty($context['sandbox'])) 
  {
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['max'] = $nbEntities;
  }
  
  $limit = 20;
  
  $search = new SearchQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
  
  $search->datasetsFilters($datasets)
         ->excludeAggregates()
         ->includeAttribute('uri')
         ->page($context['sandbox']['progress'])
         ->items($limit)
         ->send(new DrupalQuerierExtension());    
    
  $entities = array();
  
  $resultset = $search->getResultset()->getResultset();
  
  foreach($resultset as $dataset => $results) 
  {
    $entities = array_merge(array_keys($results), $entities);
  }
  
  foreach($entities as $uri => $entity)
  {
      $context['results'][] = $uri;
  }
  
  entity_load('resource_type', $entities);
  
  $context['sandbox']['progress'] += $limit;
  $context['message'] = '<span style="padding-left: 3px;" />('.$context['sandbox']['progress'].'/'.$nbEntities.')<span style="padding-right: 30px;" />';
  
  if($context['sandbox']['progress'] != $context['sandbox']['max']) 
  {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
}  

function osf_batch_precache_datasets_entities_finished($success, $results, $operations) 
{
  // The 'success' parameter means no fatal PHP errors were detected. All
  // other error management should be handled using 'results'.
  if($success) 
  {
    $message = format_plural(count($results), 'One entity processed.', '@count entities processed.');
  }
  else 
  {
    $message = t('Finished with an error.');
  }
  
  drupal_set_message($message);
  
  // Providing data for the redirected page is done through $_SESSION.
  foreach ($results as $result) 
  {
    $items[] = t('Entities pre-cached: %title.', array('%title' => $result));
  }
  
  $_SESSION['osf_batch_precache_datasets_entities'] = $items;
}

/**
 * @brief Development settings
 *
 * @note This procedure has been registered to Drupal in the osf_menu() procedure.
 *
 * @return A form object where all the settings have been defined.
 *
 * @author Frederick Giasson, Structured Dynamics LLC.
 *
 * @see http://drupal.org/node/206761
 * @see http://drupal.org/node/37775
 */
function osf_development_settings($form, &$form_state) {

  $form['theming'] = array(
    '#type' => 'fieldset',
    '#title' => t('Theming'),
    '#description' => t('Use the "Recreate theme registry" button to recreate the theme registry of your
                         Drupal instance. You should use that option when you are creating new templates
                         files that needs to be taken into account by Drupal. Instead of clearing
                         the whole cache of the system, you simply have to use this option in order
                         to avoid restarting caching everything that was previously cached just because
                         a new template is available to the system.<br /><br />'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,    
  );
  
  $form['theming']['osf_recreate_theme_registry_button'] = array(
    '#type' => 'button', 
    '#value' => t('Recreate theme registry'),
  );  
  
  $form['debugging'] = array(
    '#type' => 'fieldset',
    '#title' => t('Debugging'),
    '#description' => t(''),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,    
  );    
  
  $form['debugging']['osf_enable_osf_web_services_debug_for_admins'] = array(
    '#type' => 'checkbox',
    '#title' => t('Display all the calls being made by OSF for Drupal to OSF instance(s).'),
    '#description' => t(
    "These calls will only be displayed to logged-in admin users."),


    '#default_value' => variable_get('osf_enable_osf_web_services_debug_for_admins', 0),
  );

  $form['debugging']['osf_enable_entities_load_debug_for_admins'] = array(
    '#type' => 'checkbox',
    '#title' => t('Display loaded Resource Type entities.'),
    '#description' => t(
    "Display the description of all the Resource Type entities loaded by OSF Entities"),
    '#default_value' => variable_get('osf_enable_entities_load_debug_for_admins', 0),
  );
  
  return system_settings_form($form);
}

/** 
 * @brief Validate access settings
 * 
 * @param[in] $form Form to validate
 * @param[out] $form_state
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 * 
 * @see http://drupal.org/node/206761
 * @see http://drupal.org/node/37775
 */
function osf_development_settings_validate($form, &$form_state) {
  // We synchronize the structure
  if($form_state['clicked_button']['#parents']['0'] == "osf_recreate_theme_registry_button")
  {
    system_rebuild_theme_data();
    drupal_theme_rebuild();
    
    drupal_set_message(t('Theme registry rebuilt'));
  }  
}

/**
* Get all the loaded ontologies on this node.
*
* This function doesn't specify if the user has the rights to read/write/update/delete
* content within the ontology. Use osf_get_accessible_datasets() instead.
*
* @return An array of loaded ontologies descriptions
*
*/
function osf_get_loaded_ontologies()
{
  $loadedOntologies = cache_get('cache_loaded_ontologies');

  if(!$loadedOntologies || empty($loadedOntologies->data))
  {
    $loadedOntologies = array();

    $defaultEndpoint = current(osf_configure_get_default_endpoint());
    
    $ontologyRead = new OntologyReadQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());

    $getLoadedOntologiesFunction = new GetLoadedOntologiesFunction();
    $getLoadedOntologiesFunction->modeDescriptions();

    $ontologyRead->getLoadedOntologies($getLoadedOntologiesFunction)
                 ->send(new DrupalQuerierExtension());

    if($ontologyRead->isSuccessful())
    {
      $resultset = $ontologyRead->getResultset()->getResultset();

      if(isset($resultset['unspecified']))
      {
        $loadedOntologies = $resultset['unspecified'];
      }
    }
    else
    {
      drupal_set_message(t('Error getting loaded ontologies. <a href="/admin/ontology">Please make sure that ontologies are loaded</a>. If none appears in that list, then make sure the Ontologies web services are operational, and then click the "Reload all" button to reload all of them into Drupal.'), 'error');
    }

    cache_set('cache_loaded_ontologies', $loadedOntologies);
  }
  else
  {
    $loadedOntologies = $loadedOntologies->data;
  }

  return($loadedOntologies);
}

/**
* Get all the datasets URI and Labels accessible for 'create' (writable) by the user
*
* @param $include_ontologies Specify if we want to include the ontologies datasets into
*                                   the results to return.
*
* @param $exclude_non_ontologies Exclude all the datasets that are not ontologies dataset
*
* @return An array of accessible dataset and their titles. The keys of the array are the dataset
*         URIs, and the values are the preferred label for each dataset. Returns an empty array
*         if no dataset are accessible to that user.
*/

function osf_get_accessible_datasets($include_ontologies = FALSE, $exclude_non_ontologies = FALSE) {
  $accessibleDatasets = array();
  
  $exclude_ontologies = $include_ontologies ? FALSE : TRUE;

  $datasets = osf_configure_dataset_load_util('all', $exclude_ontologies, array('create' => TRUE));

  if($exclude_non_ontologies){
    foreach($datasets as $dataset) {
      if($dataset->info['ontology'] && $dataset->info['permissions']['create']) {
        $accessibleDatasets[$dataset->uri] = $dataset->uri;
      }
    }
  }
  else {
    foreach($datasets as $dataset) {
      if ($dataset->info['permissions']['create']) {
        $accessibleDatasets[$dataset->uri] = $dataset->uri;
      }
    }
  }

  return($accessibleDatasets);
}

/**
 * Utility for getting info about a property. Returns a Subject object
 * if property is known, FALSE if looking it up fails.
 *
 * Will attempt to use the osf_entities_properties variable for label
 * info but falls back to a read query when that isn't up to date
 */
function osf_structproperty_info($uri) {   
  
  $properties = variable_get('osf_entities_properties', array());
  
  if (!isset($properties[$uri])) {
    
    $property = &drupal_static('osf_entities_property_info_'.md5($uri));
    if(!isset($property)) 
    {
      if($cache = cache_get('osf_entities_property_info_'.md5($uri))) 
      {
        $property = $cache->data;
        
        return($property);
      }
    }
    else
    {
      return($property);
    } 
    
    if(!isset($property)) 
    {
      $defaultEndpoint = current(osf_configure_get_default_endpoint());
       
      $ob = new CrudReadQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
      
      $ob->uri($uri)
         ->excludeLinksback()
         ->excludeReification()
         ->send(new DrupalQuerierExtension());
         
      if($ob && $ob->getResultset()) 
      {
        $r = $ob->getResultset()->getSubjectByUri($uri);

        cache_set('osf_entities_property_info_'.md5($uri), $r, 'cache', CACHE_TEMPORARY);
        
        return $r;
      }
      else 
      {
        return FALSE;
      }
    }
  }
  else {
    return unserialize($properties[$uri]);
  }
}

/**
* @param  $default Specify the default language string to use if 'und' is defined in the Drupal instance.
*                  If this parameter is not set, then 'und' will be returned.
* @return Returns the language tag currently used by the user. If the setting of the portal is "Language neutral"
*         then "und" will be returned.
*/
function get_lang($default = '')
{
  global $language;
  
  if($default != '')
  {
    if($language->language == LANGUAGE_NONE)
    {
      return($default);
    }
  }
  
  return($language->language);
}

function get_enabled_languages()
{
  $langs = array_keys(current(language_list('enabled')));
  
  if(empty($langs))
  { 
    return(array(LANGUAGE_NONE));
  }
  else
  {
    return($langs);
  }
}

function is_site_multilingual()
{
  return(module_exists('locale'));
}

/**
* This function returns the default language string for this Drupal site.
* It checks if the site is setup for multilinguality. If it is, than it
* returns the default language selected for that site.
* 
* If it is not, then it checks if the language should be language neutral
* or the site's language ('en' by default).
* 
*/
function get_default_language()
{
  if(is_site_multilingual())
  {
    return(language_default('language'));
  }
  else
  {
    $option = variable_get('i18n_node_default_language_none', 0);
    
    if($option == 0)
    {
      return(language_default('language'));
    }
    else
    {
      return(LANGUAGE_NONE);
    }
  }
}

/**
* Create a OSF group URI to use in OSF to refer to a role in Drupal
* 
* @param mixed $role_id ID of the role
* @param mixed $role_name Name string of the role
*/
function osf_get_group_uri($role_id, $role_name)
{
  global $base_url;
  
  return($base_url.'/role/'.$role_id.'/'.preg_replace("/[^A-Za-z0-9]/", "_", $role_name));
}