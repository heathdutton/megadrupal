<?php

use \StructuredDynamics\osf\framework\Namespaces;
use \StructuredDynamics\osf\framework\Resultset;
use \StructuredDynamics\osf\framework\Subject;
use \StructuredDynamics\osf\php\api\ws\crud\read\CrudReadQuery;
use \StructuredDynamics\osf\php\api\ws\crud\create\CrudCreateQuery;
use \StructuredDynamics\osf\php\api\ws\crud\update\CrudUpdateQuery;
use \StructuredDynamics\osf\php\api\ws\crud\delete\CrudDeleteQuery;
use \StructuredDynamics\osf\php\api\ws\search\SearchQuery;
use \StructuredDynamics\osf\php\api\ws\revision\lister\RevisionListerQuery;
use \StructuredDynamics\osf\php\api\ws\revision\read\RevisionReadQuery;
use \StructuredDynamics\osf\php\api\ws\revision\delete\RevisionDeleteQuery;
use \StructuredDynamics\osf\php\api\ws\revision\update\RevisionUpdateQuery;

/**
 * @file
 * Default implementation of the field storage API.
 */
 
/**
 * Implements hook_menu().
 */
function osf_fieldstorage_menu() {
  $items = array();

  $items['admin/config/osf/localstorage'] = array(
    'title' => t('Local Storage'),
    'description' => t('Settings of the OSF FieldStorage Connector'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('osf_fieldstorage_settings'),
    'access arguments' => array('administer osf field storage'),
    'type' => MENU_LOCAL_TASK,
    'weight' => -35,    
  );  
  
  // Create tabs for all possible bundles.
  foreach (entity_get_info() as $entity_type => $info) {
    if ($info['fieldable']) {
      foreach ($info['bundles'] as $bundle_name => $bundle_info) {
        if (isset($bundle_info['admin'])) {
          // Extract informations from the bundle description.
          $path = $bundle_info['admin']['path'];
          $bundle_arg = isset($bundle_info['admin']['bundle argument']) ? $bundle_info['admin']['bundle argument'] : $bundle_name;
          $access = array_intersect_key($bundle_info['admin'], drupal_map_assoc(array('access callback', 'access arguments')));
          $instance_position = count(explode('/', $path)) + 1;

          if ($entity_type == 'node') {
            $title = t('RDF Mappings');
            $weight = 2;
          }
          elseif ($entity_type == 'comment') {
            continue;
            $title = t('Comment RDF Mappings');
            $weight = 60;
          }
          else {
            $title = t('RDF Mappings');
            $weight = 50;
          }

          $items["$path/rdf"] = array(
            'title' => $title,
            'page callback' => 'drupal_get_form',
            'page arguments' => array('osf_fieldstorage_admin_rdf_overview_form', $entity_type, $bundle_arg, $instance_position),
            'type' => MENU_LOCAL_TASK,
            'file' => 'osf_fieldstorage.admin.inc',
            'weight' => $weight,
          ) + $access;
                    
          $items["$path/sync"] = array(
            'title' => t('Synchronize'),
            'page callback' => 'drupal_get_form',
            'page arguments' => array('osf_fieldstorage_admin_sync_form', $entity_type, $bundle_arg, $instance_position),
            'type' => MENU_LOCAL_TASK,
            'file' => 'osf_fieldstorage.admin.inc',
            'weight' => 70,
            'access callback' => 'osf_fieldstorage_admin_sync_form_access',
            'access arguments' => array($bundle_arg),
          );
        }
      }
    }
  }

  $items['osf_fieldstorage/literal_predicates/autocomplete'] = array(
    'title' => t('RDF predicates autocomplete'),
    'page callback' => 'osf_fieldstorage_literal_predicates_autocomplete',
    'access arguments' => array('administer RDF field mappings for OSF for Drupal'),
    'file' => 'osf_fieldstorage.admin.inc',
    'type' => MENU_CALLBACK,
  );

  $items['osf_fieldstorage/relation_predicates/autocomplete'] = array(
    'title' => t('RDF predicates autocomplete'),
    'page callback' => 'osf_fieldstorage_relation_predicates_autocomplete',
    'access arguments' => array('administer RDF field mappings for OSF for Drupal'),
    'file' => 'osf_fieldstorage.admin.inc',
    'type' => MENU_CALLBACK,
  );
  
  $items['osf_fieldstorage/classes/autocomplete'] = array(
    'title' => t('RDF classes autocomplete'),
    'page callback' => 'osf_fieldstorage_classes_autocomplete',
    'access arguments' => array('administer RDF field mappings for OSF for Drupal'),
    'file' => 'osf_fieldstorage.admin.inc',
    'type' => MENU_CALLBACK,
  );  

  return $items;
} 

function osf_fieldstorage_admin_sync_form_access($bundle_arg) 
{
  if(user_access('osf fieldstorage bundle synchronization'))
  {
    // Make sure that there is at least one field that is of type 'osf_fieldstorage'
    // If there is none, then we cannot synchronize in OSF since the OSF FieldStorage
    // module won't be called
    $rdfMapping = rdf_mapping_load('node', $bundle_arg->type);

    foreach(field_info_instances('node', $bundle_arg->type) as $field => $value)
    {
      if(strpos($field, 'field_') !== FALSE)
      {
        $storageType = db_query('SELECT storage_type FROM {field_config} WHERE field_name = :field_name LIMIT 1', array(':field_name' => $field))->fetchField();

        if($storageType == 'osf_fieldstorage')
        {        
          if(isset($rdfMapping[$field]))
          {
            return(TRUE);
          }
        }
      }
    }    
  }
  
  return(FALSE);
} 

/**
 * Implements hook_permission().
 */
function osf_fieldstorage_permission() 
{
  $permissions = array(
    'osf fieldstorage bundle synchronization' => array(
      'title' => t('Synchronize bundles in OSF using OSF FieldStorage'),
      'description' => t('Allows users bulk synchronize all the instance of a bundle into OSF.'),
      'restrict access' => TRUE,
    ),
    'administer RDF field mappings for OSF for Drupal' => array(
      'title' => t('Change the RDF mappings for types and fields for OSF for Drupal'),
    ),    
  );

  return $permissions;
}

function osf_fieldstorage_settings() {

  $form['fieldstoragesystem'] = array(
    '#type' => 'fieldset',
    '#title' => t('Content Type Default Field Storage System'),
    '#description' => t('Change the default storage system of the Content Types to use
                         the <b>osf_fieldstorage</b> system by default instead. By
                         selecting this option, all the <b>future</b> field that will
                         be created for the Content Types will be using a OSF
                         instance as field data storage system.
                         
                         <br /><br />'),
    '#weight' => 3,
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );    
  
  $form['fieldstoragesystem']['osf_fieldstorage_default_storage_system'] = array(
    '#type' => 'checkbox',
    '#title' => t('Use a OSF instance as field data storage system'),
    '#default_value' => variable_get('osf_fieldstorage_default_storage_system', 0),
  );  

  $form['fields_rdf_mapping'] = array(
    '#type' => 'fieldset',
    '#title' => t('Fields RDF Mapping'),
    '#description' => t('By default, only the field that uses the <code>osf_fieldstorage</code> field
                         storage system will appear in the list of fields to be mapped in RDF under the 
                         <b>RDF MAPPING</b> tab. This means that only the mapped fields will be 
                         saved into the OSF instance.
                         
                         <br /><br />
                         
                         By enabling this option, you will see all the fields, whatever the field storage
                         system they are using to be mapped in RDF. All the mapped fields will be saved into
                         the OSF. This option should be used when synchronizing existing content on a Drupal
                         instance that is no in OSF but that needs to be there.
                         
                         <br /><br />'),
    '#weight' => 4,
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );    
  
  $form['fields_rdf_mapping']['osf_fieldstorage_show_all_fields_rdf_mapping'] = array(
    '#type' => 'checkbox',
    '#title' => t('All fields can be mapped into RDF and saved into OSF'),
    '#default_value' => variable_get('osf_fieldstorage_show_all_fields_rdf_mapping', 0),
  );  
  
  $form['dataset'] = array(
    '#type' => 'fieldset',
    '#title' => t('Local content storage Dataset'),
    '#description' => t('Select the dataset you want to use to save all the local 
                         content you are creating from this Drupal instance. The
                         local content is all the Content Types such as the Nodes,
                         Articles, Pages, etc.
                         
                         <br /><br />'),
    '#weight' => 5,
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );  
  
  $accessibleDatasets = osf_get_accessible_datasets();

  $datasets = array_merge(array('select' => 'Select a dataset'), $accessibleDatasets);  

  $form['dataset']['osf_fieldstorage_local_content_dataset'] = array(
    '#type' => 'select',
    '#options' => $datasets,
    '#required' => TRUE,
    '#title' => t('Dataset'),
    '#default_value' => variable_get('osf_fieldstorage_local_content_dataset', 0),
    '#description' => 'Dataset where to save local content'
  );         
  
  return system_settings_form($form);
}

function osf_fieldstorage_settings_validate($form, &$form_state) {
  if($form_state['values']['osf_fieldstorage_local_content_dataset'] == 'select')
  {
    form_set_error('osf_fieldstorage_local_content_dataset', t('Select a dataset where to save the local content'));
  }
  
  if($form_state['values']['osf_fieldstorage_default_storage_system'] == 1)
  {
    variable_set('field_storage_default', 'osf_fieldstorage');
  }
  else
  {
    variable_set('field_storage_default', 'field_sql_storage');
  }
}

/**
 * Implements hook_field_storage_info().
 * 
 * @see http://api.drupal.org/api/drupal/modules!field!field.api.php/function/hook_field_storage_info/7
 */
function osf_fieldstorage_field_storage_info() {
  return array(
    'osf_fieldstorage' => array(
      'label' => t('OSF Field Storage'),
      'description' => t('Field Storage system that uses a OSF instance to store fields information.'),
    ),
  );
}

/**
 * Implements hook_field_storage_create_field().
 * 
 * @see http://api.drupal.org/api/drupal/modules!field!field.api.php/function/hook_field_storage_create_field/7
 */
function osf_fieldstorage_field_storage_create_field($field) {
  // Nothing to do?
}

/**
 * Implements hook_field_update_forbid().
 *
 * Forbid any field update that changes column definitions if there is
 * any data.
 * 
 * @see http://api.drupal.org/api/drupal/modules!field!field.api.php/function/hook_field_update_forbid/7
 */
function osf_fieldstorage_field_update_forbid($field, $prior_field, $has_data) {
  // Nothing to do?
}

/**
 * Implements hook_field_storage_update_field().
 * 
 * @see http://api.drupal.org/api/drupal/modules!field!field.api.php/function/hook_field_storage_update_field/7
 */
function osf_fieldstorage_field_storage_update_field($field, $prior_field, $has_data) {
 // Nothing to do?
}

/**
 * Implements hook_field_storage_delete_field().
 * 
 * @see http://api.drupal.org/api/drupal/modules!field!field.api.php/function/hook_field_storage_delete_field/7
 */
function osf_fieldstorage_field_storage_delete_field($field) {
  // Ignore. All this is handled in osf_fieldstorage_field_storage_delete_instance()
}

/**
 * Implements hook_field_storage_purge().
 *
 * This function deletes data from the database for a single field on
 * an entity.
 * 
 * @see http://api.drupal.org/api/drupal/modules!field!field.api.php/function/hook_field_storage_purge/7
 */
function osf_fieldstorage_field_storage_purge($entity_type, $entity, $field, $instance) {
 // Ignore this call. All the purging activities are happening at the OSF FieldStorage API level
}

/**
 * Implements hook_field_storage_delete_instance().
 *
 * This function simply marks for deletion all data associated with the field.
 */
function osf_fieldstorage_field_storage_delete_instance($instance) {
  $mapping = rdf_mapping_load($instance['entity_type'], $instance['bundle']);
  
  // If no RDF mapping exists for a given field, it means that it never got
  // RDF mapped, which means that we have no data in OSF. So, this field
  // will get deleted without any impact in OSF (so, it won't be recorded
  // in that table).  
  if(isset($mapping[$instance['field_name']]))
  {
    foreach($mapping[$instance['field_name']]['predicates'] as $predicate)
    {  
      db_insert('osf_fieldstorage_pending_opts_fields')
                ->fields(array(
                  'bundle' => $instance['bundle'],
                  'field' => $instance['field_name'],
                  'rdfmapping' => '',
                  'prev_rdfmapping' => $predicate,
                  'operation' => 'deleted',
                  'date' => REQUEST_TIME,
                  'executed' => 0
                ))
                ->execute();    
    }  
  }
}

/**
 * Implements hook_field_storage_purge_field().
 *
 * All field data items and instances have already been purged, so all
 * that is left is to delete the table.
 * 
 * @see http://api.drupal.org/api/drupal/modules!field!field.api.php/function/hook_field_storage_purge_field/7
 */
function osf_fieldstorage_field_storage_purge_field($field) {
 // Ignore this call. All the purging activities are happening at the OSF FieldStorage API level
}

/**
 * Implements hook_field_storage_load().
 * 
 * @see http://api.drupal.org/api/drupal/modules!field!field.api.php/function/hook_field_storage_load/7
 */
function osf_fieldstorage_field_storage_load($entity_type, $entities, $age, $fields, $options) {
  global $base_url;
  
  $dataset = variable_get('osf_fieldstorage_local_content_dataset', '');
  $defaultEndpoint = osf_configure_get_endpoint_by_uri(osf_entities_get_network_from_dataset_uri($dataset));
  
  $namespaces = new Namespaces();

  foreach($entities as $nid => $entity)
  {
    $subject = FALSE;
    
    if($age == FIELD_LOAD_CURRENT)
    {
      if($entity->status > 0)
      {
        // Use the entity's language description.
        // If the language is "und", then we use OSF's
        // default language which is 'en'
        $lang = $entity->language;
        
        if($lang == LANGUAGE_NONE)
        {
          $lang = 'en';
        }        
        
        $uri = $base_url.'/'.$entity_type.'/'.$nid;
        
        $crudRead = new CrudReadQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
        
        $crudRead->excludeLinksback()
                 ->includeReification()
                 ->uri($uri)
                 ->lang($lang)
                 ->send(new DrupalQuerierExtension());
        
        if(!$crudRead->isSuccessful())
        {
          watchdog('osf_fieldstorage', 
                   'Can\'t read this local entity (@uri): [@error] @errorMsg - @errorDescription.', 
                   array("@uri" => $uri,
                         "@error" => $crudRead->getStatus(),
                         "@errorMsg" => $crudRead->getStatusMessage(),
                         "@errorDescription" => $crudRead->getStatusMessageDescription()));             
        }       
        else
        {
          $subject = $crudRead->getResultset()->getSubjectByUri($uri);     
        }
      }
      else
      {
        // The current version of the entity is unpublished (which means that there is no revision
        // currently published for this entity). We load the revision record instead
        
        $uri = $base_url.'/'.$entity_type.'/'.$nid;
        $revuri = db_query('SELECT revuri FROM {osf_fieldstorage_revisions_binding} WHERE timestamp = :timestamp LIMIT 1', array(':timestamp' => $entity->revision_timestamp))->fetchField();
        
        $revisionRead = new RevisionReadQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
        
        $revisionRead->revisionUri($revuri)
                     ->dataset($dataset)
                     ->getRecord()
                     ->send(new DrupalQuerierExtension());
        
        if($revisionRead->isSuccessful())
        {              
          $subject = $revisionRead->getResultset()->getSubjectByUri($uri); 
        }
        else
        {
          drupal_set_message(t("Couldn't get the revision record (@uri): [@error] @errorMsg - @errorDescription",
                             array("@uri" => $revuri,
                                   "@error" => $revisionRead->getStatus(),
                                   "@errorMsg" => $revisionRead->getStatusMessage(),
                                   "@errorDescription" => $revisionRead->getStatusMessageDescription())),
                             "error",
                             TRUE);
                             
          watchdog('osf_fieldstorage', 
                   'Couldn\'t get the revision record (@uri): [@error] @errorMsg - @errorDescription.', 
                   array("@uri" => $revuri,
                         "@error" => $revisionRead->getStatus(),
                         "@errorMsg" => $revisionRead->getStatusMessage(),
                         "@errorDescription" => $revisionRead->getStatusMessageDescription()));                   
        }        
      }
    }
    elseif($age == FIELD_LOAD_REVISION)
    {   
      $uri = $base_url.'/'.$entity_type.'/'.$nid;
      $revuri = db_query('SELECT revuri FROM {osf_fieldstorage_revisions_binding} WHERE timestamp = :timestamp LIMIT 1', array(':timestamp' => $entity->revision_timestamp))->fetchField();

      if($revuri !== FALSE)
      {
        $revisionRead = new RevisionReadQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
        
        $revisionRead->revisionUri($revuri)
                     ->dataset($dataset)
                     ->getRecord()
                     ->send(new DrupalQuerierExtension());
        
        if($revisionRead->isSuccessful())
        {              
          $subject = $revisionRead->getResultset()->getSubjectByUri($uri); 
        }
        else
        {
          drupal_set_message(t("Couldn't get the revision record (@uri): [@error] @errorMsg - @errorDescription",
                             array("@uri" => $revuri,
                                   "@error" => $revisionRead->getStatus(),
                                   "@errorMsg" => $revisionRead->getStatusMessage(),
                                   "@errorDescription" => $revisionRead->getStatusMessageDescription())),
                             "error",
                             TRUE);
                             
          watchdog('osf_fieldstorage', 
                   'Couldn\'t get the revision record (@uri): [@error] @errorMsg - @errorDescription.', 
                   array("@uri" => $revuri,
                         "@error" => $revisionRead->getStatus(),
                         "@errorMsg" => $revisionRead->getStatusMessage(),
                         "@errorDescription" => $revisionRead->getStatusMessageDescription()));                   
        }          
      }
    }
    
    if($subject !== FALSE)
    {
      $rdf_mapping = rdf_mapping_load($entity_type, $entity->type);

      foreach ($fields as $field_id => $ids) 
      {
        // Note: here $ids are the NID of the entities where this field is used
        $field = field_info_field_by_id($field_id);
        $field_name = $field['field_name'];
        
        if(!empty($rdf_mapping[$field_name]))
        {
          // We get a list of all the previous mappings for that field for which the
          // synchronization didn't occured yet. This means that we will check
          // in the table of mapping changes, and will try to get the "old" predicate where
          // we could find values from it. Then we will try to get values for them.
          $possible_prev_field_uris = _osf_fieldstorage_get_field_mapping_from_unexecuted_operations($field_name, $entity->type);
          
          $field_uri = array();
          
          $field_uri[] = $namespaces->getUnprefixedUri($rdf_mapping[$field_name]['predicates'][0]);
          $isObjectProperty = (!empty($rdf_mapping[$field_name]['type']) && $rdf_mapping[$field_name]['type'] == 'rel' ? TRUE : FALSE);
          
          $possible_prev_field_uris = $field_uri + $possible_prev_field_uris;
          
          foreach($possible_prev_field_uris as $field_uri)
          {
            if($isObjectProperty)
            {
              $values = $subject->getObjectPropertyValues($field_uri);
            }
            else
            {
              $values = $subject->getDataPropertyValues($field_uri);
            }
            
            if(!empty($values))
            {
              foreach($values as $value)
              {
                if(isset($value['reify']) && 
                   isset($value['reify']['http://purl.org/ontology/drupal#value']) &&
                   count($value['reify']['http://purl.org/ontology/drupal#value']) > 0)
                {
                  $entities[$nid]->{$field_name}[LANGUAGE_NONE][] = unserialize($value['reify']['http://purl.org/ontology/drupal#value'][0]);
                }
                else
                {
                  if(isset($value['value']))
                  {
                    $entities[$nid]->{$field_name}[LANGUAGE_NONE][] = array(
                      'value' => $value['value']
                    );
                  }
                  else
                  {
                    $entities[$nid]->{$field_name}[LANGUAGE_NONE][] = array(
                      'value' => $value['uri']
                    );
                  }
                }
              }
              
              // we found values, so we stop checking in the past predicates
              break;
            }
          }
        }        
      }    
    }    
  }
}

/**
* @param mixed $field_name
* 
* @return Return an empty array if nothing can be found. A list of possible properties otherwise
*/
function _osf_fieldstorage_get_field_mapping_from_unexecuted_operations($field_name, $bundle)
{
  $operations = db_query('SELECT rdfmapping, prev_rdfmapping FROM {osf_fieldstorage_pending_opts_fields} where executed = :executed and operation = :operation and bundle = :bundle and field = :field order by date',
                         array('executed' => 0,
                               'operation' => 'changed',
                               'bundle' => $bundle,
                               'field' => $field_name));

  $possibleProperties = array();                               
  
  $namespaces = new Namespaces();
                               
  while($operation = $operations->fetchAssoc())
  {
    $possibleProperties[] = $namespaces->getUnprefixedUri($operation['rdfmapping']);
  }
  
  return($possibleProperties);
}

/**
 * Implements hook_field_storage_write().
 * 
 * Note that this hook is only called once. So, if an entity get saved, it will list all the properties
 * that are being saved with the $fields parameter. The $fields are the one related to this storage system.
 * 
 * @param $entity_type This is the machine name of the bundle
 * @param $entity This is the entity instance with all the description of the entity (fields + values + others)
 * @param $fields This is the field ID of the "id" column of the "field_config" table
 * @param $op Operation currently being performed. With this hook, can be: "FIELD_STORAGE_INSERT" or "FIELD_STORAGE_UPDATE"
 * 
 * @see http://api.drupal.org/api/drupal/modules!field!field.api.php/function/hook_field_storage_write/7
 */
function osf_fieldstorage_field_storage_write($entity_type, $entity, $op, $fields) {
  $dataset = variable_get('osf_fieldstorage_local_content_dataset', '');

  $defaultEndpoint = osf_configure_get_endpoint_by_uri(osf_entities_get_network_from_dataset_uri($dataset));

  // If the user wants to save all the fields' information into OSF
  // then we have to add all the fields references in the $fields variable
  //
  // Note: only the supported field widget will work.
  if(variable_get('osf_fieldstorage_show_all_fields_rdf_mapping', 0))
  {
    $bundle = field_extract_bundle($entity_type, $entity->type);
    $fields_instances = field_info_instances($entity_type, $bundle);  
    
    foreach($fields_instances as $fi)
    {
      // @TODO make sure that all the fields widgets are supported
      $fields[$fi['field_id']] = $fi['field_id'];
    }  
  }
    
  switch($op)
  {
    case FIELD_STORAGE_INSERT:
      $crudCreate = new CrudCreateQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());

      $rdfDocument = osf_fieldstorage_get_rdf_entity($entity_type, $entity, $fields, "application/rdf+n3");

      if(empty($rdfDocument))
      {
        return(FALSE);
      }

      $crudCreate->dataset($dataset)
                 ->documentMimeIsRdfN3()
                 ->document($rdfDocument)
                 ->enableFullIndexationMode()
                 ->send(new DrupalQuerierExtension());

      if(!$crudCreate->isSuccessful())
      {
        drupal_set_message(t("Can't save this entity into this dataset (@uri): [@error] @errorMsg - @errorDescription",
                           array("@uri" => $dataset,
                                 "@error" => $crudCreate->getStatus(),
                                 "@errorMsg" => $crudCreate->getStatusMessage(),
                                 "@errorDescription" => $crudCreate->getStatusMessageDescription())),
                           "error",
                           TRUE);
                                   
        watchdog('osf_fieldstorage', 
                 'Can\'t save this entity into this dataset: [@error] @errorMsg - @errorDescription.', 
                 array("@error" => $crudCreate->getStatus(),
                       "@errorMsg" => $crudCreate->getStatusMessage(),
                       "@errorDescription" => $crudCreate->getStatusMessageDescription()));                       
      }
      else
      {
        // We have to clear the entity cache first if we want the users
        // to see the update's changes in the view page where they will
        // get redirected.
        cache_clear_all ($entity->nid, 'cache_entity_'.$entity_type);
        
        return;
      }
    break;
    
    case FIELD_STORAGE_UPDATE:
      $crudUpdate = new CrudUpdateQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());

      $rdfDocument = osf_fieldstorage_get_rdf_entity($entity_type, $entity, $fields, "application/rdf+n3");

      if(empty($rdfDocument))
      {
        return(FALSE);
      }

      $crudUpdate->dataset($dataset)
                 ->documentMimeIsRdfN3()
                 ->document($rdfDocument);

      // Check if the entity is revisioned or not
      if($entity->revision)
      {
        $crudUpdate->createRevision();
        
        if(isset($entity->revision_moderation) && $entity->revision_moderation)
        {
          $crudUpdate->isStaging();        
        }
        else
        {
          // If the revision is not moderated, it means that we create a new revision and
          // it gets immediately published and available to users
          $crudUpdate->isPublished();        
        }
      } 
      else
      {
        $crudUpdate->ignoreRevision();        
      }                
      
      $crudUpdate->dataset($dataset)
                 ->documentMimeIsRdfN3()
                 ->document($rdfDocument)
                 ->send(new DrupalQuerierExtension());     
                 
      if(!$crudUpdate->isSuccessful())
      {
        if(strpos($crudUpdate->getStatusMessageDescription(), 'WS-CRUD-UPDATE-315') !== FALSE)
        {
          // This means that we are trying to update an entity that never got created in the first place
          // so let's create it using CRUD: Create instead
          $crudCreate = new CrudCreateQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
          
          $crudCreate->dataset($dataset)
                     ->documentMimeIsRdfN3()
                     ->document($rdfDocument)
                     ->send(new DrupalQuerierExtension());

          if(!$crudCreate->isSuccessful())
          {          
            drupal_set_message(t("Can't save this entity into this dataset (@uri): [@error] @errorMsg - @errorDescription",
                               array("@uri" => $dataset,
                                     "@error" => $crudCreate->getStatus(),
                                     "@errorMsg" => $crudCreate->getStatusMessage(),
                                     "@errorDescription" => $crudCreate->getStatusMessageDescription())),
                               "error",
                               TRUE);
                               
            watchdog('osf_fieldstorage', 
                     'Can\'t save this entity into this dataset (@uri): [@error] @errorMsg - @errorDescription.', 
                     array("@uri" => $dataset,
                           "@error" => $crudCreate->getStatus(),
                           "@errorMsg" => $crudCreate->getStatusMessage(),
                           "@errorDescription" => $crudCreate->getStatusMessageDescription()));               
          }
        }
        else
        {
          drupal_set_message(t("Can't save this entity into this dataset (@uri): [@error] @errorMsg - @errorDescription",
                             array("@uri" => $dataset,
                                   "@error" => $crudUpdate->getStatus(),
                                   "@errorMsg" => $crudUpdate->getStatusMessage(),
                                   "@errorDescription" => $crudUpdate->getStatusMessageDescription())),
                             "error",
                             TRUE);
                             
          watchdog('osf_fieldstorage', 
                   'Can\'t save this entity into this dataset (@uri): [@error] @errorMsg - @errorDescription.', 
                   array("@uri" => $dataset,
                         "@error" => $crudUpdate->getStatus(),
                         "@errorMsg" => $crudUpdate->getStatusMessage(),
                         "@errorDescription" => $crudUpdate->getStatusMessageDescription()));               
        }                           
      }
      else
      {
        if($entity->revision)
        {
          // Let's get the revision record that got created for this record.
          // We will extract its revision timestamp and use it to update 
          // Drupal with it. This will become the unique ID of the revision
          // record that we will use to load revisions    
          global $base_url;
          
          $uri = $base_url.'/'.$entity_type.'/'.$entity->nid;
          
          $revisionLister = new RevisionListerQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
          
          $revisionLister->shortResults()
                         ->uri($uri)
                         ->dataset($dataset)
                         ->send(new DrupalQuerierExtension());
                         
          if($revisionLister->isSuccessful())
          {         
            $resultset = $revisionLister->getResultset()->getResultset();
            
            reset($resultset['unspecified']);
            
            db_insert('osf_fieldstorage_revisions_binding')
              ->fields(array(
                'timestamp' => $entity->timestamp,
                'revuri' => key($resultset['unspecified'])
              ))
              ->execute();            
            
            
            // Check if it was the first time a revision was created. If yes, then it means that we
            // have to update the timestamp of the initial version of this entity as well
            if(count($resultset['unspecified']) == 2)
            {
              // Get the first (initial) revision
              db_insert('osf_fieldstorage_revisions_binding')
                ->fields(array(
                  'timestamp' => $entity->revision_timestamp,
                  'revuri' => end(array_keys($resultset['unspecified']))
                ))
                ->execute();               
            }
          }
          else
          {
            drupal_set_message(t("Couldn't get the revisions of this record (@uri): [@error] @errorMsg - @errorDescription",
                               array("@uri" => $uri,
                                     "@error" => $revisionLister->getStatus(),
                                     "@errorMsg" => $revisionLister->getStatusMessage(),
                                     "@errorDescription" => $revisionLister->getStatusMessageDescription())),
                               "error",
                               TRUE);
                               
            watchdog('osf_fieldstorage', 
                     'Couldn\'t get the revisions of this record (@uri): [@error] @errorMsg - @errorDescription.', 
                     array("@uri" => $uri,
                           "@error" => $revisionLister->getStatus(),
                           "@errorMsg" => $revisionLister->getStatusMessage(),
                           "@errorDescription" => $revisionLister->getStatusMessageDescription()));               
          }
        }
        
        // We have to clear the entity cache first if we want the users
        // to see the update's changes in the view page where they will
        // get redirected.
        cache_clear_all($entity->nid, 'cache_entity_'.$entity_type);
        
        return;
      }    
    break;
  }
}

/**
* Implements hook_field_attach_validate
* 
* Check to make sure that all the fields using the osf_fieldstorage field storage system are
* mapped to a RDF property. If it is not the case for one or multiple fields, than errors
* are returned to give the opportunity to the user the map them before saving.
*/
function osf_fieldstorage_field_attach_validate($entity_type, $entity, &$errors)
{
  global $base_url;
  
  if(!isset($entity->type))
  {
    return;
  }
 
  $rdfMapping = rdf_mapping_load('node', $entity->type);

  foreach($entity as $field => $value)
  {
    if(strpos($field, 'field_') !== FALSE)
    {
      $storageType = db_query('SELECT storage_type FROM {field_config} WHERE field_name = :field_name LIMIT 1', array(':field_name' => $field))->fetchField();

      if($storageType == 'osf_fieldstorage'/* || variable_get('osf_fieldstorage_show_all_fields_rdf_mapping', 0)*/)
      {        
        if(!isset($rdfMapping[$field]))
        {
          // One of the OSF FieldStorage field is not mapped to any RDF property.
          // We return an error telling the user to map it before saving this entity.
          $errors[$field]['und'][0][] = array(
            'error' => $field,
            'message' => t('The field "'.$field.'" is not currently mapped into a RDF property. <a target="_blank" href="'.$base_url.'/admin/structure/types/manage/'.$entity->type.'/rdf">You have to property map this property to RDF before being able to save this content type.</a>'),
          );   
        }
      }
    }
  }
}
   
/**
* Returns a Content Type entity's description serialized in one of the RDF serialization
* supported by the system. 
* 
* @param mixed $entity_type The entity type of the entity to convert
* @param mixed $entity The Drupal Content Type entity for which we want its RDF representation
* @param mixed $fields The fields to get converted into RDF
* @param mixed $mime The serialization format we want this function to return.
*                    Can be one of:
*                      (1) "text/xml" (structXML) -- Default
*                      (2) "application/json" (structJSON)
*                      (3) "application/rdf+xml" (RDF+XML)
*                      (4) "application/rdf+n3" (N3/Turtle)
*                      (5) "application/iron+json" (irJSON)
*                      (6) "application/iron+csv" (commON) 
* @return Returns the serialized entity. Returns FALSE if the $mime format is not supported.
*/
function osf_fieldstorage_get_rdf_entity($entity_type, $entity, $fields, $mime = "text/xml")
{
  $fieldsNames = array('title', 'body');
  
  foreach($fields as $field_id)
  {
    $field = field_info_field_by_id($field_id);
    
    $fieldsNames[] = $field['field_name'];
  }
  
  // Use the entity's language description.
  // If the language is "und", then we use OSF's
  // default language which is 'en'
  $lang = $entity->language;
  
  if($lang == LANGUAGE_NONE)
  {
    $lang = 'en';
  }
  
  global $base_url;

  // We have a new resource into OSF
  $rdfMapping = rdf_mapping_load($entity_type, $entity->type);

  $namespaces = new Namespaces();

  $uri = $base_url.'/'.$entity_type.'/'.$entity->nid;  
  
  $subject = new Subject($uri);
  
  $subject->setType($namespaces->getUnprefixedUri($rdfMapping['rdftype'][0]));
  
  // Return FALSE if the mapping is not existing
  // It means we can't create a RDF representation for this entity
  if(empty($rdfMapping))
  {        
    return(FALSE);
  }

  foreach($entity as $property => $values)
  {  
    if(!isset($rdfMapping[$property]) || 
       $property == 'uid' ||
       !in_array($property, $fieldsNames))
    {
      continue;
    }
    
    // Set core 'title' field
    if($property == 'title' && !empty($values))
    {
      $subject->setDataAttribute(Namespaces::$iron.'prefLabel', $values, 'rdfs:Literal', $lang);
      continue;
    }
    
    // Set core 'body' field
    if($property == 'body' && !empty($values[LANGUAGE_NONE]))
    {
      $subject->setDataAttribute(Namespaces::$iron.'description', strip_tags($values[LANGUAGE_NONE][0]['value']), 'rdfs:Literal', $lang);
      $subject->setDataAttribute(Namespaces::$rdf.'value', $values[LANGUAGE_NONE][0]['value'], 'rdfs:Literal', $lang);
      continue;
    }
    
    $extProperty = $namespaces->getUnprefixedUri($rdfMapping[$property]['predicates'][0]);
    
    if(isset($rdfMapping[$property]) && !empty($values[LANGUAGE_NONE]))
    {
      $fieldInfo = field_info_field($property);
      $fieldInstance = field_read_instance('node', $property, $fieldInfo['bundles']['node'][0]);
        
      // Object property
      if($fieldInfo['type'] == 'entityreference' ||
         $fieldInfo['type'] == 'node_reference' ||
         ($fieldInfo['type'] == 'text' && $fieldInstance['widget']['type'] == 'osf_field_concept_reference') ||
         ($fieldInfo['type'] == 'text' && $fieldInstance['widget']['type'] == 'osf_field_entity_reference'))
      {      
        if(is_array($values[LANGUAGE_NONE]))
        {        
          foreach($values[LANGUAGE_NONE] as $key => $values)
          {
            $value = '';
            $valueType = 'rdfs:Literal';          
            
            switch($fieldInfo['type'])
            {          
              // For the moment, I don't think it is a good idea to use the url() function
              // to create the URI. The problem is that if someone changes the path of a record
              // it may break the URI references. So let's use the cannonical /node/ path for
              // referencing to these resources
              
              case 'entityreference':
                //$uri = url('node/' . $values['target_id'], array('absolute' => TRUE));                
                $uri = 'http://'.$_SERVER['SERVER_NAME'].'/node/'.$values['target_id'];
                
                $value = $uri;
              break;
              
              case 'node_reference':
                //$uri = url('node/' . $values['nid'], array('absolute' => TRUE));                
                $uri = 'http://'.$_SERVER['SERVER_NAME'].'/node/'.$values['nid'];
                
                $value = $uri;
              break;
              
              default:
                $value = $values['value'];
              break;            
            }
            
            // We reify the internal Drupal value structure to the subject
            $rei = array(
              'http://purl.org/ontology/drupal#value' => array(
                serialize($values)
              )
            );          
            
            $subject->setObjectAttribute($extProperty, $value, $rei);
          }
        }
      }
      else // Datatype property
      {
        if(is_array($values[LANGUAGE_NONE]))
        {
          foreach($values[LANGUAGE_NONE] as $key => $values)
          {
            $value = '';
            $valueType = 'rdfs:Literal';
            
            switch($fieldInfo['type'])
            {
              case 'link_field':
                $value = $values['url'];
              break;
              case 'list_integer':
                $valueType = 'http://www.w3.org/2001/XMLSchema#integer';
                $value = $values['value'];
              break;
              case 'number_integer':
                $valueType = 'http://www.w3.org/2001/XMLSchema#integer';
                $value = $values['value'];
              break;
              case 'number_float':
                $valueType = 'http://www.w3.org/2001/XMLSchema#float';
                $value = $values['value'];
              break;              
              case 'number_decimal':
                $valueType = 'http://www.w3.org/2001/XMLSchema#float';
                $value = $values['value'];
              break;              
              case 'datestamp':
                $valueType = 'http://www.w3.org/2001/XMLSchema#integer';
                $value = $values['value'];
              break;
              case 'date':
                $valueType = 'http://www.w3.org/2001/XMLSchema#dateTime';
                $value = $values['value'];
              break;
              case 'datetime':
                $valueType = 'http://www.w3.org/2001/XMLSchema#dateTime';
                $value = $values['value'];
              break;
              case 'list_boolean':
                $valueType = 'http://www.w3.org/2001/XMLSchema#integer';
                $value = $values['value'];
              break;      
              case 'list_float':
                $valueType = 'http://www.w3.org/2001/XMLSchema#float';
                $value = $values['value'];
              break;      
              case 'image':
                $uri = db_query('SELECT uri FROM {file_managed} WHERE fid = :fid LIMIT 1', array(':fid' => $values['fid']))->fetchField();
                
                $value = file_create_url($uri);
              break;
              case 'geolocation_latlng':
                $value = $values['lat'].','.$values['lng'];
              break;
              case 'file':
                $uri = db_query('SELECT uri FROM {file_managed} WHERE fid = :fid LIMIT 1', array(':fid' => $values['fid']))->fetchField();
                
                $value = file_create_url($uri);
              break;

              default:
                $value = $values['value'];
              break;                 
            }
            
            // We reify the internal Drupal value structure to the subject
            $rei = array(
              'http://purl.org/ontology/drupal#value' => array(
                serialize($values)
              )
            );
            
            $subject->setDataAttribute($extProperty, $value, $valueType, ($valueType == 'rdfs:Literal' ? $lang : ''), $rei);            
            
            /*
            if(isset($values['value']))
            {
              $valueType = 'rdfs:Literal';
              
              switch($fieldInfo['type'])
              {
                case 'list_integer':
                  $valueType = 'http://www.w3.org/2001/XMLSchema#integer';
                break;
                case 'list_float':
                  $valueType = 'http://www.w3.org/2001/XMLSchema#float';
                break;
              }
              
              $subject->setDataAttribute($extProperty, $values['value'], $valueType);
            }
            elseif($fieldInfo['type'] == 'link_field')
            {
              // We reify the internal Drupal value structure to the subject
              $rei = array(
                'http://purl.org/ontology/drupal#value' => array(
                  serialize($values)
                )
              );
              
              $subject->setDataAttribute($extProperty, $values['url'], 'rdfs:Literal', '', $rei);
            } 
            */
          }
        }
        elseif(!empty($values) && !is_array($values))
        {
          $subject->setDataAttribute($extProperty, $values, 'rdfs:Literal', $lang);
        }
      }
    }
  }

  $resultset = new Resultset();
  
  $dataset = rtrim(variable_get('osf_fieldstorage_local_content_dataset', 'http://localhost/datasets/local/'), '/').'/';
  
  $resultset->addSubject($subject, $dataset);

  switch($mime)
  {
    case "text/xml":
      return($resultset->getResultsetXML());
    break;
    case "application/json":
      return($resultset->getResultsetJSON());
    break;
    case "application/rdf+xml":
      return($resultset->getResultsetRDFXML());
    break;
    case "application/rdf+n3":
      return($resultset->getResultsetRDFN3());
    break;
    case "application/iron+json":
      return($resultset->getResultsetIronJSON());
    break;
    case "application/iron+csv":
      return($resultset->getResultsetIronCOMMON());
    break;
    
    default:
      return(FALSE);
    break;
  }
}
     
/**
 * Implements hook_field_storage_delete().
 *
 * This function deletes data for all fields for an entity from the database.
 * 
 * @see http://api.drupal.org/api/drupal/modules!field!field.api.php/function/hook_field_storage_delete/7
 */
function osf_fieldstorage_field_storage_delete($entity_type, $entity, $fields) {
  global $base_url;
  
  $dataset = variable_get('osf_fieldstorage_local_content_dataset', '');
  $defaultEndpoint = osf_configure_get_endpoint_by_uri(osf_entities_get_network_from_dataset_uri($dataset));
  
  $uri = $base_url.'/'.$entity_type.'/'.$entity->nid;
  
  $crudDelete = new CrudDeleteQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());

  $crudDelete->uri($uri)
             ->dataset($dataset)
             ->hard()
             ->send(new DrupalQuerierExtension());

  if(!$crudDelete->isSuccessful())
  {
    drupal_set_message(t("Can't delete this entity from the local content storage dataset: [@error] @errorMsg - @errorDescription",
                       array("@error" => $crudDelete->getStatus(),
                             "@errorMsg" => $crudDelete->getStatusMessage(),
                             "@errorDescription" => $crudDelete->getStatusMessageDescription())),
                       "error",
                       TRUE);
                       
    watchdog('osf_entities', 
             'Can\'t delete this entity from the local content storage dataset: [@error] @errorMsg - @errorDescription.', 
             array("@error" => $crudDelete->getStatus(),
                   "@errorMsg" => $crudDelete->getStatusMessage(),
                   "@errorDescription" => $crudDelete->getStatusMessageDescription()));                       
  }
  else
  {
    // Make sure to remove this entity from cache
    cache_clear_all($entity->nid, 'cache_entity_'.$entity_type);    
  }  
}

/**
 * Implements hook_field_storage_query().
 * 
 * @see http://api.drupal.org/api/drupal/modules!field!field.api.php/function/hook_field_storage_query/7
 */
function osf_fieldstorage_field_storage_query(EntityFieldQuery $query) {
 
  // @TODO implement when required. 
  
  /*
  if ($query->age == FIELD_LOAD_CURRENT) {
    $tablename_function = '_osf_fieldstorage_tablename';
    $id_key = 'entity_id';
  }
  else {
    $tablename_function = '_osf_fieldstorage_revision_tablename';
    $id_key = 'revision_id';
  }
  $table_aliases = array();
  // Add tables for the fields used.
  foreach ($query->fields as $key => $field) {
    $tablename = $tablename_function($field);
    // Every field needs a new table.
    $table_alias = $tablename . $key;
    $table_aliases[$key] = $table_alias;
    if ($key) {
      $select_query->join($tablename, $table_alias, "$table_alias.entity_type = $field_base_table.entity_type AND $table_alias.$id_key = $field_base_table.$id_key");
    }
    else {
      $select_query = db_select($tablename, $table_alias);
      // Allow queries internal to the Field API to opt out of the access
      // check, for situations where the query's results should not depend on
      // the access grants for the current user.
      if (!isset($query->tags['DANGEROUS_ACCESS_CHECK_OPT_OUT'])) {
        $select_query->addTag('entity_field_access');
      }
      $select_query->addMetaData('base_table', $tablename);
      $select_query->fields($table_alias, array('entity_type', 'entity_id', 'revision_id', 'bundle'));
      $field_base_table = $table_alias;
    }
    if ($field['cardinality'] != 1 || $field['translatable']) {
      $select_query->distinct();
    }
  }

  // Add field conditions. We need a fresh grouping cache.
  drupal_static_reset('_osf_fieldstorage_query_field_conditions');
  _osf_fieldstorage_query_field_conditions($query, $select_query, $query->fieldConditions, $table_aliases, '_osf_fieldstorage_columnname');

  // Add field meta conditions.
  _osf_fieldstorage_query_field_conditions($query, $select_query, $query->fieldMetaConditions, $table_aliases, '_osf_fieldstorage_query_columnname');

  if (isset($query->deleted)) {
    $select_query->condition("$field_base_table.deleted", (int) $query->deleted);
  }

  // Is there a need to sort the query by property?
  $has_property_order = FALSE;
  foreach ($query->order as $order) {
    if ($order['type'] == 'property') {
      $has_property_order = TRUE;
    }
  }

  if ($query->propertyConditions || $has_property_order) {
    if (empty($query->entityConditions['entity_type']['value'])) {
      throw new EntityFieldQueryException('Property conditions and orders must have an entity type defined.');
    }
    $entity_type = $query->entityConditions['entity_type']['value'];
    $entity_base_table = _osf_fieldstorage_query_join_entity($select_query, $entity_type, $field_base_table);
    $query->entityConditions['entity_type']['operator'] = '=';
    foreach ($query->propertyConditions as $property_condition) {
      $query->addCondition($select_query, "$entity_base_table." . $property_condition['column'], $property_condition);
    }
  }
  foreach ($query->entityConditions as $key => $condition) {
    $query->addCondition($select_query, "$field_base_table.$key", $condition);
  }

  // Order the query.
  foreach ($query->order as $order) {
    if ($order['type'] == 'entity') {
      $key = $order['specifier'];
      $select_query->orderBy("$field_base_table.$key", $order['direction']);
    }
    elseif ($order['type'] == 'field') {
      $specifier = $order['specifier'];
      $field = $specifier['field'];
      $table_alias = $table_aliases[$specifier['index']];
      $sql_field = "$table_alias." . _osf_fieldstorage_columnname($field['field_name'], $specifier['column']);
      $select_query->orderBy($sql_field, $order['direction']);
    }
    elseif ($order['type'] == 'property') {
      $select_query->orderBy("$entity_base_table." . $order['specifier'], $order['direction']);
    }
  }

  return $query->finishQuery($select_query, $id_key);
  */
}
       
/**
 * Implements hook_field_storage_delete_revision().
 *
 * This function actually deletes the data from the database.
 * 
 * @see http://api.drupal.org/api/drupal/modules!field!field.api.php/function/hook_field_storage_delete_revision/7
 */
function osf_fieldstorage_field_storage_delete_revision($entity_type, $entity, $fields) {
  $dataset = variable_get('osf_fieldstorage_local_content_dataset', '');
  
  $defaultEndpoint = osf_configure_get_endpoint_by_uri(osf_entities_get_network_from_dataset_uri($dataset));
  
  global $base_url;

  $uri = $base_url.'/'.$entity_type.'/'.$entity->nid;
  
  $revuri = $userName = db_query('SELECT revuri FROM {osf_fieldstorage_revisions_binding} WHERE timestamp = :timestamp LIMIT 1', array(':timestamp' => $entity->revision_timestamp))->fetchField();
  
  if($revuri !== FALSE)
  {
    $revisionDelete = new RevisionDeleteQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
    
    $revisionDelete->dataset($dataset)
                   ->revisionUri($revuri)
                   ->send(new DrupalQuerierExtension());
            
    if(!$revisionDelete->isSuccessful())
    {              
      drupal_set_message(t("Couldn't get delete the revision record (@uri) in OSF: [@error] @errorMsg - @errorDescription",
                         array("@uri" => $revuri,
                               "@error" => $revisionDelete->getStatus(),
                               "@errorMsg" => $revisionDelete->getStatusMessage(),
                               "@errorDescription" => $revisionDelete->getStatusMessageDescription())),
                         "error",
                         TRUE);
                         
      watchdog('osf_fieldstorage', 
               'Couldn\'t get delete the revision record (@uri) in OSF: [@error] @errorMsg - @errorDescription.', 
               array("@uri" => $revuri,
                     "@error" => $revisionDelete->getStatus(),
                     "@errorMsg" => $revisionDelete->getStatusMessage(),
                     "@errorDescription" => $revisionDelete->getStatusMessageDescription()));                   
    }    
  }
}

function osf_fieldstorage_form_revisioning_delete_archived_confirm_alter(&$form, &$form_state) {
  // Add our own hook to this confirm call to make sure we remove the revisions in OSF as well.  
  $form['#submit'][] = 'osf_fieldstorage_delete_archived_confirm_submit';
}      

function osf_fieldstorage_delete_archived_confirm_submit($form, &$form_state) {
  $dataset = variable_get('osf_fieldstorage_local_content_dataset', '');
  
  $defaultEndpoint = osf_configure_get_endpoint_by_uri(osf_entities_get_network_from_dataset_uri($dataset));
  
  global $base_url;

  $uri = $base_url.'/'.$form['node']['#parents'][0].'/'.$form['node']['#value']->nid;
  
  // Get all revisions for this record
  $revisionLister = new RevisionListerQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());

  $revisionLister->longResults()
                 ->uri($uri)
                 ->dataset($dataset)
                 ->send(new DrupalQuerierExtension());
                 
  if($revisionLister->isSuccessful())
  {
    // each of them that are not published get deleted
    $resultset = $revisionLister->getResultset()->getResultset();
    
    $revuri = '';
    
    foreach($resultset['unspecified'] as $revisionUri => $revision)
    {
      if($revision[Namespaces::$wsf.'status'][0]['uri'] != Namespaces::$wsf.'published')
      {
        $revisionDelete = new RevisionDeleteQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
        
        $revisionDelete->dataset($dataset)
                       ->revisionUri($revisionUri)
                       ->send(new DrupalQuerierExtension());
                
        if(!$revisionDelete->isSuccessful())
        {              
          drupal_set_message(t("Couldn't get delete the revision record (@uri) in OSF: [@error] @errorMsg - @errorDescription",
                             array("@uri" => $revuri,
                                   "@error" => $revisionDelete->getStatus(),
                                   "@errorMsg" => $revisionDelete->getStatusMessage(),
                                   "@errorDescription" => $revisionDelete->getStatusMessageDescription())),
                             "error",
                             TRUE);
                             
          watchdog('osf_fieldstorage', 
                   'Couldn\'t get delete the revision record (@uri) in OSF: [@error] @errorMsg - @errorDescription.', 
                   array("@uri" => $revuri,
                         "@error" => $revisionDelete->getStatus(),
                         "@errorMsg" => $revisionDelete->getStatusMessage(),
                         "@errorDescription" => $revisionDelete->getStatusMessageDescription()));                   
        }                    
      }
    }
  }
}


function osf_fieldstorage_form_alter(&$form, &$form_state) {

}

/**
 * Implements hook_field_attach_rename_bundle().
 * 
 * @see http://api.drupal.org/api/drupal/modules!field!field.api.php/function/hook_field_attach_rename_bundle/7
 */
function osf_fieldstorage_field_attach_rename_bundle($entity_type, $bundle_old, $bundle_new) {
  // Figure out what to do
}

/**
 * Implements hook_field_storage_details().
 * 
 * @see http://api.drupal.org/api/drupal/modules!field!field.api.php/function/hook_field_storage_details/7
 */
function osf_fieldstorage_field_storage_details($field) {
  
  // Return details about the property related to that field.
  
  /*
  $details = array();
  if (!empty($field['columns'])) {
     // Add field columns.
    foreach ($field['columns'] as $column_name => $attributes) {
      $real_name = _osf_fieldstorage_columnname($field['field_name'], $column_name);
      $columns[$column_name] = $real_name;
    }
    return array(
      'sql' => array(
        FIELD_LOAD_CURRENT => array(
          _osf_fieldstorage_tablename($field) => $columns,
        ),
        FIELD_LOAD_REVISION => array(
          _osf_fieldstorage_revision_tablename($field) => $columns,
        ),
      ),
    );
  }
  */
}

function osf_fieldstorage_synchronize_bundles_changes()
{ 
  $dataset = variable_get('osf_fieldstorage_local_content_dataset', '');
  $defaultEndpoint = osf_configure_get_endpoint_by_uri(osf_entities_get_network_from_dataset_uri($dataset));
  
  $operations = db_query('SELECT id, bundle, rdfmapping, prev_rdfmapping, operation FROM {osf_fieldstorage_pending_opts_bundles} where executed = :executed order by bundle, date',
                         array('executed' => 0));

  $namespaces = new Namespaces();
                         
  $operationsStacks = array();                   
    
  // Populate the operation stacks                             
  while($operation = $operations->fetchAssoc())
  {
    $bundle = $operation['bundle'];

    if(!isset($operationsStacks[$bundle]))
    {
      $operationsStacks[$bundle] = array();
    }
    
    if(!isset($operationsStacks[$bundle]))
    {
      $operationsStacks[$bundle] = array();
    }
    
    $operationsStacks[$bundle][$operation['id']] = array(
      'rdfmapping' => $operation['rdfmapping'],
      'prev_rdfmapping' => $operation['prev_rdfmapping'],
      'operation' => $operation['operation'],
      'operation_id' => $operation['id'],
    );
  }

  /*
    With the following algorithm, we make sure that even if different records get changed
    during different un-executed operations, that we are cleaning the local data dataset
    according to all the changes that happened, without forgetting any of them.
  
    --------------------------
    [changed:1]  <-- we get records that uses this type, we change the type URI for the latest change (#2)
    [changed:2]  <-- we get records that uses this type, we change the type URI for the latest change (#2)
    --------------------------
  */

  foreach($operationsStacks as $bundle => $operations)
  {
    $last_changed = _get_last_changed($operations);      
    
    foreach($operations as $key => $operation)
    {
      $nbRecords = 1;
      
      if($operation['operation'] != 'changed')
      {
        continue;
      }
      
      // (1) we get all the records that uses this property
      while($nbRecords > 0)
      {
        $search = new SearchQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_first_user_uri());
        
        $search->datasetFilter($dataset)  
               ->typeFilter($namespaces->getUnprefixedUri($operation['prev_rdfmapping']))
               ->includeAggregates()
               ->includeAttributes(array('uri'))
               ->items(20)
               ->send(new DrupalQuerierExtension());
               
        if($search->isSuccessful())
        {
          $resultset = $search->getResultset()->getResultset();
          
          if(!isset($resultset['unspecified']))
          {
            // There is no results, so we skip that change, it means it got executed
            break;
          }                        
          
          foreach($resultset['unspecified'] as $uri => $record)
          {
            if($record['type'][0] == Namespaces::$aggr.'Aggregate' &&
               $record[Namespaces::$aggr.'property'][0]['uri'] == Namespaces::$void.'Dataset')
            {
              $nbRecords = $record[Namespaces::$aggr.'count'][0]['value'];
              
              break;
            }
          }
          
          $uris = array();
          $datasets = array();
          
          foreach($resultset[$dataset] as $uri => $record)
          {
            $uris[] = $uri;
            $datasets[] = $dataset;
          }
          
          // Now, we have to aggregate all the URIs that come from the search endpoint
          // and to use the CRUD: Read endpoint to get the full description of all records
          $crudRead = new CrudReadQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_first_user_uri());
          
          $crudRead->excludeReification()
                   ->excludeLinksback()
                   ->dataset($datasets)
                   ->uri($uris)
                   ->lang('')
                   ->send(new DrupalQuerierExtension());
                   
          if($crudRead->isSuccessful())
          {
            $resultset = $crudRead->getResultset()->getResultset();
          }
          else
          {
            watchdog('osf_fieldstorage - fields synchronization', 
                     'Can\'t get the records description of the current operation: [@error] @errorMsg - @errorDescription.', 
                     array("@error" => $crudRead->getStatus(),
                           "@errorMsg" => $crudRead->getStatusMessage(),
                           "@errorDescription" => $crudRead->getStatusMessageDescription()));                       
            
            // Now we stop the execution of the synchronization since we cannot afford
            // to miss a few updates. Everything needs to be updated, in order or nothing.
            return(FALSE);                    
          }
          
          foreach($resultset[$dataset] as $uri => $record)
          {
            $rdfMappingProperty = $namespaces->getUnprefixedUri($operation['prev_rdfmapping']);
            $lastRdfMappingProperty = $namespaces->getUnprefixedUri($operations[$last_changed]['rdfmapping']);
            
            // (2) we remove the previous type
            foreach($record['type'] as $t_key => $type)
            {
              if($type == $rdfMappingProperty)
              {
                // (3) we update with the latest
                $record['type'][$t_key] = $lastRdfMappingProperty;
                break;
              }
            }
            
            // (4) we save that modified record back into OSF using CRUD: Update         

            // Also drop the dcterms:isPartOf property which is added by CRUD: Read but 
            // not part of the record's description
            unset($record[Namespaces::$dcterms.'isPartOf']);
            
            $subject = new Subject($uri);

            $subject->setSubject($record);
            
            $subjectResultset = new Resultset();
            
            $subjectResultset->addSubject($subject, $dataset);
            
            $crudUpdate = new CrudUpdateQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_first_user_uri());
            
            $crudUpdate->dataset($dataset)
                       ->document($subjectResultset->getResultsetRDFN3())
                       ->documentMimeIsRdfN3()
                       ->createRevision()
                       ->isPublished()
                       ->send(new DrupalQuerierExtension());
                       
            if(!$crudUpdate->isSuccessful())
            {
              watchdog('osf_fieldstorage - fields synchronization', 
                       'Can\'t synchronize the "@field" field from the "@bundle" bundle. Saving error when changing the "@prevproperty" for the "@nexproperty" property: [@error] @errorMsg - @errorDescription.', 
                       array("@field" => $field,
                             "@bundle" => $bundle,
                             "@nextproperty" => $lastRdfMappingProperty,
                             "@prevproperty" => $rdfMappingProperty,
                             "@error" => $crudUpdate->getStatus(),
                             "@errorMsg" => $crudUpdate->getStatusMessage(),
                             "@errorDescription" => $crudUpdate->getStatusMessageDescription()));                       

              // Now we stop the execution of the synchronization since we cannot afford
              // to miss a few updates. Everything needs to be updated, in order or nothing.
              return(FALSE);
            }
          }   
        }
        else
        {
          watchdog('osf_fieldstorage - fields synchronization', 
                   'Could not get records from number @num from the search endpoint: [@error] @errorMsg - @errorDescription.', 
                   array("@num" => $nbRecords,
                         "@error" => $search->getStatus(),
                         "@errorMsg" => $search->getStatusMessage(),
                         "@errorDescription" => $search->getStatusMessageDescription()));   
                         
          // Now we stop the execution of the synchronization since we cannot afford
          // to miss a few updates. Everything needs to be updated, in order or nothing.
          return(FALSE);              
        }            
      }
      
      // Now, we have to mark this operation as executed in the 'osf_fieldstorage_pending_opts_fields' table        
      db_update('osf_fieldstorage_pending_opts_bundles')
        ->fields(array(
          'executed' => 1,
        ))
        ->condition('id', $operation['operation_id'], '=')
        ->execute();
    }
  }
}

function osf_fieldstorage_synchronize_fields_changes()
{
  $dataset = variable_get('osf_fieldstorage_local_content_dataset', '');
  $defaultEndpoint = osf_configure_get_endpoint_by_uri(osf_entities_get_network_from_dataset_uri($dataset));
  
  $operations = db_query('SELECT id, bundle, field, rdfmapping, prev_rdfmapping, operation FROM {osf_fieldstorage_pending_opts_fields} where executed = :executed order by bundle, field, date',
                         array('executed' => 0));

  $namespaces = new Namespaces();
                         
  $operationsStacks = array();                   
    
  // Populate the operation stacks                             
  while($operation = $operations->fetchAssoc())
  {
    $bundle = $operation['bundle'];
    $field = $operation['field'];

    if(!isset($operationsStacks[$bundle]))
    {
      $operationsStacks[$bundle] = array();
    }
    
    if(!isset($operationsStacks[$bundle][$field]))
    {
      $operationsStacks[$bundle][$field] = array();
    }
    
    $operationsStacks[$bundle][$field][$operation['id']] = array(
      'rdfmapping' => $operation['rdfmapping'],
      'prev_rdfmapping' => $operation['prev_rdfmapping'],
      'operation' => $operation['operation'],
      'operation_id' => $operation['id'],
    );
  }

  /*
  
    With the following algorithm, we make sure that even if different records get changed
    during different un-executed operations, that we are cleaning the local data dataset
    according to all the changes that happened, without forgetting any of them.
  
    --------------------------
    [changed:1]  <-- we ignore
    [changed:2]  <-- we ignore
    [deleted:3]  <-- we ingore (because there is a deleted later in the stack)
    [changed:4]  <-- we ignore
    [changed:5]  <-- we ignore
    [deleted:6]  <-- we get records that uses properties specified by #1, #2, #4, #5 and we remove them from these records
    [changed:7]  <-- we get records that uses this property, we change the property URI for the latest change (#9)
    [changed:8]  <-- we get records that uses this property, we change the property URI for the latest change (#9) 
    [changed:9]  <-- we ignore
    --------------------------
  */
  
  foreach($operationsStacks as $bundle => $fields)
  {
    $mapping = rdf_mapping_load('node', $bundle);
    
    foreach($fields as $field => $operations)
    {
      $last_deleted = _get_last_deleted($operations);
      $last_changed = _get_last_changed($operations);      
      
      foreach($operations as $key => $operation)
      {
        $nbRecords = 1;
        
        if($operation['operation'] != 'changed' &&
           $operation['operation'] != 'deleted')
        {
          continue;
        }
        
        if($operation['rdfmapping'] == $operations[$last_changed]['rdfmapping'] && $key != $last_changed && $last_changed != -1)
        {
          // Changes loop detected, we skip this one
          continue;                
        } 
        
        // (1) we get all the records that uses this property
        while($nbRecords > 0)
        {
          $search = new SearchQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_first_user_uri());
          
          $search->datasetFilter($dataset)  
                 ->typeFilter($namespaces->getUnprefixedUri($mapping['rdftype'][0]))
                 ->attributeValuesFilters($namespaces->getUnprefixedUri($operation['prev_rdfmapping']))
                 ->includeAggregates()
                 ->includeAttributes(array('uri'))
                 ->items(20)
                 ->send(new DrupalQuerierExtension());
                 
          if($search->isSuccessful())
          {
            $resultset = $search->getResultset()->getResultset();
            
            if(!isset($resultset['unspecified']))
            {
              // There is no results, so we skip that change, it means it got executed
              break;
            }                        
            
            foreach($resultset['unspecified'] as $uri => $record)
            {
              if($record['type'][0] == Namespaces::$aggr.'Aggregate' &&
                 $record[Namespaces::$aggr.'property'][0]['uri'] == Namespaces::$void.'Dataset')
              {
                $nbRecords = $record[Namespaces::$aggr.'count'][0]['value'];
                
                break;
              }
            }
            
            $uris = array();
            $datasets = array();
            
            foreach($resultset[$dataset] as $uri => $record)
            {
              $uris[] = $uri;
              $datasets[] = $dataset;
            }
            
            // Now, we have to aggregate all the URIs that come from the search endpoint
            // and to use the CRUD: Read endpoint to get the full description of all records
            $crudRead = new CrudReadQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_first_user_uri());
            
            $crudRead->excludeReification()
                     ->excludeLinksback()
                     ->dataset($datasets)
                     ->uri($uris)
                     ->lang('')
                     ->send(new DrupalQuerierExtension());
                     
            if($crudRead->isSuccessful())
            {
              $resultset = $crudRead->getResultset()->getResultset();
            }
            else
            {
              watchdog('osf_fieldstorage - fields synchronization', 
                       'Can\'t get the records description of the current operation: [@error] @errorMsg - @errorDescription.', 
                       array("@error" => $crudRead->getStatus(),
                             "@errorMsg" => $crudRead->getStatusMessage(),
                             "@errorDescription" => $crudRead->getStatusMessageDescription()));                       
              
              // Now we stop the execution of the synchronization since we cannot afford
              // to miss a few updates. Everything needs to be updated, in order or nothing.
              return(FALSE);                    
            }
            
            foreach($resultset[$dataset] as $uri => $record)
            {
              $rdfMappingProperty = $namespaces->getUnprefixedUri($operation['prev_rdfmapping']);
              $lastRdfMappingProperty = $namespaces->getUnprefixedUri($operations[$last_changed]['rdfmapping']);
              
              switch($operation['operation'])
              {
                case "changed":
                  if($last_deleted != -1 && $key < $last_deleted)
                  {              
                    // We are changing [changed:1], [changed:2], [changed:4], [changed:5] in the scenario outlined above

                    // (2) we remove that property from the record's description                     
                    unset($record[$rdfMappingProperty]);                      
                  }
                  else
                  {
                    // We are changing [changed:7], [changed:8], [changed:9] in the scenario outlined above
                    
                    // (2) we remove that property from the record's description, and we save the value of that property                      
                    $values = $record[$rdfMappingProperty];
                    
                    unset($record[$rdfMappingProperty]);
                    
                    // (3) we add a new property, which is the 'rdfmapping' of the last changed operation, we use the save
                    //     value in (2) and we add it to the record                                          
                    $record[$lastRdfMappingProperty] = $values;
                  }                                          
                break;
                
                case "deleted":
                    // We are changing [changed:1], [changed:2], [changed:4], [changed:5] in the scenario outlined above

                    // (2) we remove that property from the record's description                     
                    unset($record[$rdfMappingProperty]);                      
                break;
              }
              
              // (4) we save that modified record back into OSF using CRUD: Update         

              // Also drop the dcterms:isPartOf property which is added by CRUD: Read but 
              // not part of the record's description
              unset($record[Namespaces::$dcterms.'isPartOf']);
              
              $subject = new Subject($uri);

              $subject->setSubject($record);
              
              $subjectResultset = new Resultset();
              
              $subjectResultset->addSubject($subject, $dataset);
              
              $crudUpdate = new CrudUpdateQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_first_user_uri());
              
              $crudUpdate->dataset($dataset)
                         ->document($subjectResultset->getResultsetRDFN3())
                         ->documentMimeIsRdfN3()
                         ->createRevision()
                         ->isPublished()
                         ->send(new DrupalQuerierExtension());
                         
              if(!$crudUpdate->isSuccessful())
              {
                watchdog('osf_fieldstorage - fields synchronization', 
                         'Can\'t synchronize the "@field" field from the "@bundle" bundle. Saving error when changing the "@prevproperty" for the "@nexproperty" property: [@error] @errorMsg - @errorDescription.', 
                         array("@field" => $field,
                               "@bundle" => $bundle,
                               "@nextproperty" => $lastRdfMappingProperty,
                               "@prevproperty" => $rdfMappingProperty,
                               "@error" => $crudUpdate->getStatus(),
                               "@errorMsg" => $crudUpdate->getStatusMessage(),
                               "@errorDescription" => $crudUpdate->getStatusMessageDescription()));                       

                // Now we stop the execution of the synchronization since we cannot afford
                // to miss a few updates. Everything needs to be updated, in order or nothing.
                return(FALSE);
              }
            }   
          }
          else
          {
            // If the Search endpoint returns the error 313, it means that the data is not available
            // anymore and so that we simply mark this operation as executed.
            if($search->error->id != 'WS-SEARCH-313')
            {
              watchdog('osf_fieldstorage - fields synchronization', 
                       'Could not get records from number @num from the search endpoint: [@error] @errorMsg - @errorDescription.', 
                       array("@num" => $nbRecords,
                             "@error" => $search->getStatus(),
                             "@errorMsg" => $search->getStatusMessage(),
                             "@errorDescription" => $search->getStatusMessageDescription()));   
                             
              // Now we stop the execution of the synchronization since we cannot afford
              // to miss a few updates. Everything needs to be updated, in order or nothing.
              return(FALSE);              
            }
            else
            {
              $nbRecords = 0;
            }
          }            
        }
        
        // Now, we have to mark this operation as executed in the 'osf_fieldstorage_pending_opts_fields' table        
        db_update('osf_fieldstorage_pending_opts_fields')
          ->fields(array(
            'executed' => 1,
          ))
          ->condition('id', $operation['operation_id'], '=')
          ->execute();
      }
    }
  }
}


/**
* 
* 
* @param mixed $stack
* 
* @return If no deleted operation have been found, then -1 is returned. The key of the last deleted operation 
*         within the stack will be returned otherwise.
*/
function _get_last_deleted($stack)
{
  $stack = array_reverse($stack, true);
  
  foreach($stack as $key => $operation)
  {
    if($operation['operation'] == 'deleted')
    {
      return($key);
    }
  }
  
  return(-1);
} 

/**
* 
* 
* @param mixed $stack
* 
* @return If no changed operation have been found, then -1 is returned. The key of the last changed operation 
*         within the stack will be returned otherwise.
*/
function _get_last_changed($stack)
{
  $stack = array_reverse($stack, true);
  
  foreach($stack as $key => $operation)
  {
    if($operation['operation'] == 'changed')
    {
      return($key);
    }
  }
  
  return(-1);
} 

/**
* Implements hook_cron()
* 
* This hook implementation is creating a new item into the Cron Queue.
* Since the synchronization process can take some time, we have to use the
* queue to have a better handling on the long running cron job in Drupal.
* 
*/
function osf_fieldstorage_cron() 
{ 
  $queue = DrupalQueue::get("osf_fieldstorage_sync");
  
  $items = array('bundles', 'fields');
  
  foreach($items as $item)
  {
    $queue->createItem($item); 
  }  
}

/**
* Implements hook_cron_queue_info()
* 
* Create the item within the Cron job queue.
* 
*/
function osf_fieldstorage_cron_queue_info() {
 $queues['osf_fieldstorage_sync'] = array (
    'worker callback' => 'osf_fieldstorage_cron_sync',
    'time' => 600,    // We give it 10 minutes. If it has to be beyond, it will continue at the next cron call.
  );
  
  return $queues;
}

/**
* Run the synchronization procedure to synchronize the bundles and the fields if the
* content type schemas (bundles and fields mapping) did change since the last Cron job.
* 
* If the procedure cannot finish during this cron call (for example, if it took too long)
* then the synchronization procedure take care of this and will simply resume where
* it left its processing.
* 
* @param mixed $data
*/
function osf_fieldstorage_cron_sync($item) 
{
  if($item == 'bundles')
  {
    watchdog('osf_fieldstorage - bundles synchronization', 
             'Cron synchronization started');                       
             
    osf_fieldstorage_synchronize_bundles_changes();
    
    watchdog('osf_fieldstorage - bundles synchronization', 
             'Cron synchronization finished');
  }
  
  if($item == 'fields')
  {
    watchdog('osf_fieldstorage - fields synchronization', 
             'Cron synchronization started');                       

    osf_fieldstorage_synchronize_fields_changes();
    
    watchdog('osf_fieldstorage - fields synchronization', 
             'Cron synchronization finished');
  }
  
}
             
function osf_fieldstorage_form_field_ui_field_overview_form_alter(&$form, &$form_state, $form_id)
{
  if(strpos(drupal_get_path_alias(), 'resource-types/manage') === FALSE)
  {  
    // Add a new column at the end of the field UI overview table
    array_splice($form['fields']['#header'], 7, 0, 'Storage Type' ); // splice in at position 3

    // Adding information about the storage system currently being used, and a possibility to change it.
    // We don't map body and title since they are handled by default and will always be mapped.    
    $form['fields']['_add_new_field']['storage_type'] = array('#markup' => '<b>'.variable_get('field_storage_default', 'field_sql_storage').'</b>');
    $form['fields']['_add_new_field']['label']['#prefix'] = '<div class="label-input"><div class="add-new-placeholder">Add new field <em>(using '.variable_get('field_storage_default', 'field_sql_storage').')</em></div>';

    foreach($form['#fields'] as $field)
    {
      if($field != 'body')
      {
        $storageType = db_query('SELECT storage_type FROM {field_config} WHERE field_name = :field_name LIMIT 1', array(':field_name' => $field))->fetchField();
        
        $form['fields'][$field]['storage_type'] = array('#markup' => '<b>'.$storageType.'</b>');
      }
    }
    
    // Fix the overview table to only keep the field widgets that are known to 
    // be working with the OSF FieldStorage module
    
    // Add a new section to enabled system administartor to create fields that are compatible
    // with OSF FieldStorage only
    $add_new_field_osf_fieldstorage = $form['fields']['_add_new_field'];
    
    $form['fields']['_add_new_field_osf_fieldstorage'] = $add_new_field_osf_fieldstorage;
    $form['fields']['_add_new_field_osf_fieldstorage']['field_name']['#machine_name']['source'][1] = '_add_new_field_osf_fieldstorage';
    $form['fields']['_add_new_field_osf_fieldstorage']['parent_wrapper']['parent']['#parent'][1] = '_add_new_field_osf_fieldstorage';
    $form['fields']['_add_new_field_osf_fieldstorage']['parent_wrapper']['hidden_name']['#default_value'][1] = '_add_new_field_osf_fieldstorage';
    $form['fields']['_add_new_field_osf_fieldstorage']['storage_type'] = array('#markup' => '<b>osf_fieldstorage</b>');
    $form['fields']['_add_new_field_osf_fieldstorage']['label']['#prefix'] = '<div class="label-input"><div class="add-new-placeholder">Add new field <em>(using osf_fieldstorage)</em></div>';
    
    // List all the supported fields types
    // Note: check field_ui.js to see the different widgets that can be used for each of these types
    $typeOptions = array(      
      'text' => 'Text',
      'text_with_summary' => 'Long text and summary',
      'text_long' => 'Long text',
      'list_boolean' => 'Boolean',
      'number_float' => 'Float',
      'number_decimal' => 'Decimal',
      'number_integer' => 'Integer',
      'link_field' => 'Link',
      'image' => 'Image',
      'file' => 'File',
      'entityreference' => 'Entity Reference',
      'datetime' => 'Date (ISO format)',
      'datestamp' => 'Date (Unix timestamp)',
      'date' => 'Date',
      'list_float' => 'List (float)',
      'list_text' => 'List (text)',
      'list_integer' => 'List (integer)',
      'geolocation_latlng' => 'Geolocation',
    );

    $form['fields']['_add_new_field_osf_fieldstorage']['type']['#options'] = $typeOptions;
    
    // Replace the field_ui.js file for a new version required for OSF FieldStorage to work property
    $form['#attached']['js'][0] = drupal_get_path('module', 'osf_fieldstorage') . '/js/field_ui.js';
    
    // Use a re-implementation of the field_ui_field_overview_form_submit() submit handler
    // that is used to specify the storage system of the new field that is being created
    $form['#submit'][0] = 'osf_fieldstorage_field_overview_form_submit';
    $form['#validate'][0] = 'osf_fieldstorage_field_overview_form_validate';
    
    if(variable_get('field_storage_default', 'field_sql_storage') == 'osf_fieldstorage')
    {
      // If the default field storage system is 'osf_fieldstorage' then we simply remove this
      // '_add_new_field' such that it doesn't get duplicated with '_add_new_field_osf_fieldstorage'
      unset($form['fields']['_add_new_field']);
    }  
  }
}

function osf_fieldstorage_field_overview_form_validate($form, &$form_state) 
{
  _field_ui_field_overview_form_validate_add_new($form, $form_state);
  _field_ui_field_overview_form_validate_add_existing($form, $form_state);  
}

/**
* Re-implementation of the field_ui_field_overview_form_submit() submit handle.
* 
* This is essential if we want to be able to handle more than one field storage system per field
* in the user interface.
* 
*/
function osf_fieldstorage_field_overview_form_submit($form, &$form_state)
{
  $form_values = $form_state['values']['fields'];
  $entity_type = $form['#entity_type'];
  $bundle = $form['#bundle'];
  $admin_path = _field_ui_bundle_admin_path($entity_type, $bundle);

  $bundle_settings = field_bundle_settings($entity_type, $bundle);

  // Update field weights.
  foreach ($form_values as $key => $values) {
    if (in_array($key, $form['#fields'])) {
      $instance = field_read_instance($entity_type, $key, $bundle);
      $instance['widget']['weight'] = $values['weight'];
      field_update_instance($instance);
    }
    elseif (in_array($key, $form['#extra'])) {
      $bundle_settings['extra_fields']['form'][$key]['weight'] = $values['weight'];
    }
  }

  field_bundle_settings($entity_type, $bundle, $bundle_settings);

  $destinations = array();

  // Create new 'field_sql_storage' field.
  $field = array();
  if (!empty($form_values['_add_new_field']['field_name'])) {
    $values = $form_values['_add_new_field'];

    $field = array(
      'field_name' => $values['field_name'],
      'type' => $values['type'],
      'translatable' => $values['translatable'],
    );
    $instance = array(
      'field_name' => $field['field_name'],
      'entity_type' => $entity_type,
      'bundle' => $bundle,
      'label' => $values['label'],
      'widget' => array(
        'type' => $values['widget_type'],
        'weight' => $values['weight'],
      ),
    );

    // Create the field and instance.
    try {
      field_create_field($field);
      field_create_instance($instance);

      $destinations[] = $admin_path . '/fields/' . $field['field_name'] . '/field-settings';
      $destinations[] = $admin_path . '/fields/' . $field['field_name'];

      // Store new field information for any additional submit handlers.
      $form_state['fields_added']['_add_new_field'] = $field['field_name'];
    }
    catch (Exception $e) {
      drupal_set_message(t('There was a problem creating field %label: !message', array('%label' => $instance['label'], '!message' => $e->getMessage())), 'error');
    }
  }
  
  // Create new 'osf_fieldstorage' field.
  $field = array();
  if (!empty($form_values['_add_new_field_osf_fieldstorage']['field_name'])) {
    $values = $form_values['_add_new_field_osf_fieldstorage'];

    // Make sure the field name starts with 'field_'
    if(substr($values['field_name'], 0, 6) !== 'field_')
    {
      $values['field_name'] = 'field_'.$values['field_name'];
    }
    
    $field = array(
      'field_name' => $values['field_name'],
      'type' => $values['type'],
      'translatable' => $values['translatable'],
    );
    $instance = array(
      'field_name' => $field['field_name'],
      'entity_type' => $entity_type,
      'bundle' => $bundle,
      'label' => $values['label'],
      'widget' => array(
        'type' => $values['widget_type'],
        'weight' => $values['weight'],
      ),
    );

    // Create the field and instance.
    try {
      // Force the usage of the osf_fieldstorage field storage system      
      $field['storage']['type'] = 'osf_fieldstorage';
      
      field_create_field($field);
      field_create_instance($instance);

      $destinations[] = $admin_path . '/fields/' . $field['field_name'] . '/field-settings';
      $destinations[] = $admin_path . '/fields/' . $field['field_name'];

      // Store new field information for any additional submit handlers.
      $form_state['fields_added']['_add_new_field_osf_fieldstorage'] = $field['field_name'];
    }
    catch (Exception $e) {
      drupal_set_message(t('There was a problem creating field %label: !message', array('%label' => $instance['label'], '!message' => $e->getMessage())), 'error');
    }
  }  

  // Add existing field.
  if (!empty($form_values['_add_existing_field']['field_name'])) {
    $values = $form_values['_add_existing_field'];
    $field = field_info_field($values['field_name']);
    if (!empty($field['locked'])) {
      drupal_set_message(t('The field %label cannot be added because it is locked.', array('%label' => $values['label'])), 'error');
    }
    else {
      $instance = array(
        'field_name' => $field['field_name'],
        'entity_type' => $entity_type,
        'bundle' => $bundle,
        'label' => $values['label'],
        'widget' => array(
          'type' => $values['widget_type'],
          'weight' => $values['weight'],
        ),
      );

      try {
        field_create_instance($instance);
        $destinations[] = $admin_path . '/fields/' . $instance['field_name'] . '/edit';
        // Store new field information for any additional submit handlers.
        $form_state['fields_added']['_add_existing_field'] = $instance['field_name'];
      }
      catch (Exception $e) {
        drupal_set_message(t('There was a problem creating field instance %label: @message.', array('%label' => $instance['label'], '@message' => $e->getMessage())), 'error');
      }
    }
  }

  if ($destinations) {
    $destination = drupal_get_destination();
    $destinations[] = $destination['destination'];
    unset($_GET['destination']);
    $form_state['redirect'] = field_ui_get_destinations($destinations);
  }
  else {
    drupal_set_message(t('Your settings have been saved.'));
  }
}

/**
* Implements hook_field_attach_preprocess_alter()
* 
* This is used to expose the fields that uses the osf_fieldstorage storage system to the theme/template engines.
* 
* @param mixed $variables
* @param mixed $context
*/
function osf_fieldstorage_field_attach_preprocess_alter(&$variables, $context)
{
  // Get the fields that are no in $variable['elements'] and create their render array
  foreach($variables as $var => $value)
  {
    if(is_array($value) && count($value) > 0)
    {
      // Check if this is a field
      $fieldInfo = field_info_field($var);

      if($fieldInfo !== NULL)
      {
        // Check if this field already belongs to $variable['elements]
        if(!isset($variables['elements'][$var]))
        {
          // If not, we add it to the proper places within $variable
          $field = field_view_field($context['entity_type'], $context['entity'], $var);
          
          $variables['elements'][] = $field;
          $variables['content'][] = $field;
        }
      }
    }
  }
}

/**
 * Implements hook_revisionapi().
 *
 * Act on various revision events.
 *
 * @param $op
 *  Operation
 * @param $node
 *  Node of current operation (loaded with vid of the operation).
 *
 * "Pre" operations can be useful to get values before they are lost or changed,
 * for example, to save a backup of revision before it's deleted.
 * Also, for "pre" operations vetoing mechanics could be implemented, so it
 * would be possible to veto an operation via hook_revisionapi(). For example,
 * when the hook is returning FALSE, operation will be vetoed.
 */
function osf_fieldstorage_revisionapi($op, $node) {
  global $base_url;
  
  $dataset = variable_get('osf_fieldstorage_local_content_dataset', '');
  $defaultEndpoint = osf_configure_get_endpoint_by_uri(osf_entities_get_network_from_dataset_uri($dataset));
  $uri = $base_url.'/node/'.$node->nid;
  
  switch ($op) {
    case 'post update':
    break;

    case 'pre publish':
    break;

    case 'post publish':
      // A revision got re-published

      // Republish revision
      $revuri = db_query('SELECT revuri FROM {osf_fieldstorage_revisions_binding} WHERE timestamp = :timestamp LIMIT 1', array(':timestamp' => $node->revision_timestamp))->fetchField();
      
      if($revuri !== FALSE)
      {      
        $revisionUpdate = new RevisionUpdateQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
        
        $revisionUpdate->dataset($dataset)
                       ->revisionUri($revuri)
                       ->isPublished()
                       ->send(new DrupalQuerierExtension());
        
        if(!$revisionUpdate->isSuccessful())
        {
          drupal_set_message(t("Can't publish this revision (@uri): [@error] @errorMsg - @errorDescription",
                             array("@uri" => $revuri,
                                   "@error" => $revisionUpdate->getStatus(),
                                   "@errorMsg" => $revisionUpdate->getStatusMessage(),
                                   "@errorDescription" => $revisionUpdate->getStatusMessageDescription())),
                             "error",
                             TRUE);
                             
          watchdog('osf_fieldstorage', 
                   'Can\'t publish this revision (@uri): [@error] @errorMsg - @errorDescription.', 
                   array("@uri" => $revuri,
                         "@error" => $revisionUpdate->getStatus(),
                         "@errorMsg" => $revisionUpdate->getStatusMessage(),
                         "@errorDescription" => $revisionUpdate->getStatusMessageDescription()));             
        } 
      }      
      
    break;

    case 'post unpublish':
      // The current published entity got unpublished
      
      // Find published record
      $revisionLister = new RevisionListerQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());

      $revisionLister->longResults()
                     ->uri($uri)
                     ->dataset($dataset)
                     ->send(new DrupalQuerierExtension());
                     
      if($revisionLister->isSuccessful())
      {         
        $resultset = $revisionLister->getResultset()->getResultset();
        
        $revuri = '';

        foreach($resultset['unspecified'] as $revisionUri => $revision)
        {
          if($revision[Namespaces::$wsf.'status'][0]['uri'] == Namespaces::$wsf.'published')
          {
            $revuri = $revisionUri;
            
            break;
          }
        }

        // Unpublish published record      
        $revisionUpdate = new RevisionUpdateQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
        
        $revisionUpdate->dataset($dataset)
                       ->revisionUri($revuri)
                       ->isArchive()
                       ->send(new DrupalQuerierExtension());
        
        if(!$revisionUpdate->isSuccessful())
        {
          drupal_set_message(t("Can't update the publication status of this entity (@uri): [@error] @errorMsg - @errorDescription",
                             array("@uri" => $uri,
                                   "@error" => $revisionUpdate->getStatus(),
                                   "@errorMsg" => $revisionUpdate->getStatusMessage(),
                                   "@errorDescription" => $revisionUpdate->getStatusMessageDescription())),
                             "error",
                             TRUE);
                             
          watchdog('osf_fieldstorage', 
                   'Can\'t update the publication status of this entity: [@error] @errorMsg - @errorDescription.', 
                   array("@uri" => $uri,
                         "@error" => $revisionUpdate->getStatus(),
                         "@errorMsg" => $revisionUpdate->getStatusMessage(),
                         "@errorDescription" => $revisionUpdate->getStatusMessageDescription()));             
        }      
      } 
    break;

    case 'pre revert':
    break;

    case 'post revert':
    break;

    case 'pre delete':
    break;

    case 'post delete':
    break;
  }
}