<?php

include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'osf') . '/framework/ClassHierarchy.php';
include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'osf') . '/framework/PropertyHierarchy.php';

use \StructuredDynamics\osf\php\api\ws\search\SearchQuery;
use \StructuredDynamics\osf\php\api\ws\search\ExtendedFiltersBuilder;
use \StructuredDynamics\osf\php\api\ws\sparql\SparqlQuery;
use \StructuredDynamics\osf\framework\Namespaces;
use \StructuredDynamics\osf\framework\Resultset;
use \StructuredDynamics\osf\framework\Subject;
use \StructuredDynamics\osf\ws\framework\ClassHierarchy;
use \StructuredDynamics\osf\ws\framework\PropertyHierarchy;
use \StructuredDynamics\osf\php\api\ws\crud\read\CrudReadQuery;
use \StructuredDynamics\osf\php\api\ws\revision\lister\RevisionListerQuery;
use \StructuredDynamics\osf\php\api\ws\ontology\read\OntologyReadQuery;
use \StructuredDynamics\osf\php\api\ws\ontology\read\GetSuperClassesFunction;
use \StructuredDynamics\osf\framework\Resource;




/**
* 
* (1) In Drupal, OSF Entities' synchronization determine what are the type of 
*     entities and their fields that get exposed to Drupal via the Entity API.
* (2) If an entity is found in OSF but that no resource type bundle are 
*     found for that entity's type, it won't be loaded by entity_load() even if 
*     it exists in OSF. To expose it, an admin will have to synchronize 
*     its type as resource type bundle.
* (3) The full description of an entity in OSF will always be available
*     via the 'obj' property of the entity's class instance.
* (4) If the fields associated with a resource type bundle are only partially
*     mapping all the properties/values existing for an entity, in OSF,
*     that is being updated, no information will be lost. The values of the
*     un-exposed fields will be re-saved in OSF without any modifications. 
* 
*/

/**
 * @file
 * Implementation of the field storage API for OSF for Drupal
 */

/**
 * Implements hook_field_storage_info().
 */
function osf_entities_field_storage_info() {
  return array(
    'osf_entities' => array(
      'label' => t('OSF field storage'),
      'description' => t('Stores nodes and fields in a OSF database.'),
    ),
  );
}
     
/**
* Delete all the bundles and fields created from the OSF structure.      
*/
function osf_entities_remove_structure()
{  
  // Delete all the RDF mappings
  foreach(osf_entities_get_rdf_mappings() as $mapping)
  {
    rdf_mapping_delete($mapping['type'], $mapping['bundle']);
  }  
  
  // Delete all the bundles
  db_delete('resource_type')->condition('module', 'osf_entities', '=')->execute();

  // Delete fields
  db_delete('field_config')->condition('storage_module', 'osf_entities')->execute();
  
  // Delete fields instances
  db_delete('field_config_instance')->condition('entity_type', 'resource')->execute();
  
  // Delete the cached structure of classes and properties
  variable_del("osf_entities_classes");
  variable_del("osf_entities_properties"); 
  variable_del("osf_entities_properties_by_field");
  variable_del("osf_entities_classes_by_bundles");
  variable_del("osf_entities_unused_properties_to_synchronize");
  variable_del("osf_entities_unused_classes_to_synchronize");
  variable_del("osf_entities_used_classes");
  variable_del("osf_entities_classes_to_synchronize");
  variable_del("osf_entities_properties_to_synchronize");
  variable_del('osf_entities_is_core_synchronized');
  
  drupal_flush_all_caches();  
}

/**
* Implements hook_entity_info().
*/
function osf_entities_entity_info() {
  $return = array(
    'resource' => array(
      'label' => t('Resource'),
      'entity class' => 'Resource',
      'controller class' => 'ResourceController',
      'base table' => 'resource',
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'rid',
        'bundle' => 'type',
      ),
      'bundle keys' => array(
        'bundle' => 'type',
      ),
      'bundles' => array(),
      'load hook' => 'osf_entities_load',
      'view modes' => array(
        'full' => array(
          'label' => t('Default'),
          'custom settings' => FALSE,
        ),
      ),
      'label callback' => 'entity_class_label',
      'uri callback' => 'entity_class_uri',
      'module' => 'osf_entities',
      'access callback' => 'osf_entities_access',
    ),
  );
  
  $return['resource_type'] = array(
    'label' => t('Resource Type'),
    'entity class' => 'ResourceType',
    'controller class' => 'ResourceTypeController',
    'base table' => 'resource_type',
    'field cache' => FALSE,
    'entity cache' => TRUE,
    'fieldable' => TRUE,
    'bundle of' => 'resource',
    'exportable' => TRUE,
    'entity keys' => array(
      'id' => 'id',
      'name' => 'type',
      'label' => 'label',
      'description' => 'description',
      'status' => 'status',
      'ignoreResource' => 'ignoreResource'
    ),
    'module' => 'osf_entities',
    
    // Enable the entity API's admin UI.        
    'admin ui' => array(
      'path' => 'admin/structure/resource-types',
      'file' => 'osf_entities.admin.inc',
      'controller class' => 'ResourceTypeUIController',
    ),    
    
    'access callback' => 'resource_type_access',
  );

  return $return;
}

/**
* Implements hook_entity_info_alter().
* 
* Let Drupal understand that entities of resource_type are bundles for resource.
*/
function osf_entities_entity_info_alter(&$entity_info) 
{                                                                              
  $classes = variable_get("osf_entities_classes", array());
                        
  $mappings = osf_entities_get_rdf_mappings();
  
  foreach($classes as $class => $classSubject) 
  {   
    $classSubject = unserialize($classSubject);
    
    $typeID = resource_type_get_id($class);
    
    $entity_info['resource']['bundles'][$typeID] = array(
      'label' => $classSubject->getPrefLabel(),
      'admin' => array(
        'path' => 'admin/structure/resource-types/manage/%resource_type',
        'real path' => 'admin/structure/resource-types/manage/' . $typeID,
        'bundle argument' => 4,
      ),      
      'rdf_mapping' => (empty($mappings[$typeID]["mapping"])) ? NULL : $mappings[$typeID]["mapping"],
    );
  }
}


/**
 * Implements hook_permission().
 */
function osf_entities_permission() 
{
  $permissions = array(
    'administer resource types' => array(
      'title' => t('Administer resource types'),
      'description' => t('Allows users to configure resource types and their fields.'),
      'restrict access' => TRUE,
    ),
    'view resource entities' => array(
      'title' => t('View resource'),
      'description' => t('Allows users to view resource entities.'),
      'restrict access' => TRUE,
    ),
    'edit resource entities' => array(
      'title' => t('Edit resource'),
      'description' => t('Allows users to edit resource entities.'),
      'restrict access' => TRUE,
    ),
    'export resource entities' => array(
      'title' => t('Export resource'),
      'description' => t('Allows users to export resource entities in different structured data formats.'),
      'restrict access' => TRUE,
    ),
    'advanced edit ontologies resource entities' => array(
      'title' => t('Advanced edition of ontologies resource'),
      'description' => t('Allows users to be able to edit the structural aspect of ontologies resources (classes and properties).'),
      'restrict access' => TRUE,
    ),
    'delete resource entities' => array(
      'title' => t('Delete resource'),
      'description' => t('Allows users to delete resource entities.'),
      'restrict access' => TRUE,
    ),
    'administer osf entities' => array(
      'title' => t('Administer OSF for Drupal Entities'),
    ),
    'add resource entity item' => array(
      'title' => t('Add Resource Entity Records'),
    ),
    'resource entities revisions' => array(
      'title' => t('View revisions of resource entities'),
    ),
    'resource entities translate' => array(
      'title' => t('Translate resource entities'),
    ),
    'resource entity revert revisions' => array(
      'title' => t('Revert revisions of resource entities'),
    ),
    'resource entity delete revisions' => array(
      'title' => t('Delete revisions of resource entities'),
    ),
    'resource entity unpublish revisions' => array(
      'title' => t('Unpublish revisions of resource entities'),
    ),
    'resource entity compare revisions' => array(
      'title' => t('Compare revisions of resource entities'),
    ),
  );

  return $permissions;
}


/**
 * Access callback for resource.
 */
function resource_access($op, $resource, $account = NULL, $entity_type = NULL) 
{
  global $user;

  if (!isset($account)) 
  {
    $account = $user;
  }
  
  switch ($op) 
  {
    case 'view':
      return user_access('administer resource entities', $account)
          || user_access('view resource entities', $account);

  }
}

function resource_type_access($op, $entity = NULL) 
{
  return user_access('administer resource types');
}

/**
 * List of resource Types.
 */
function resource_types($type_name = NULL) {
  $types = entity_load_multiple_by_name('resource_type', isset($type_name) ? array($type_name) : FALSE);
  return isset($type_name) ? reset($types) : $types;
}

/**
 * Save resource type entity.
 */
function resource_type_save($resource_type) {
  entity_save('resource_type', $resource_type);
}

/**
 * Delete single case type.
 */
function resource_type_delete($uri) {
  entity_delete('resource_type', $uri);
}

/**
* Load "resource_type" entity instance(s)
* 
* @param mixed $uri An entity URIs to load
* @return An associative array of "resource_type" entity instances keyed by the input URIs.
*/
function resource_type_load($uri)
{
  if(is_array($uri))
  {
    return(entity_load("resource_type", $uri));
  }
  else
  {
    $entities = entity_load("resource_type", array($uri));
    return array_shift($entities);
  }
}       

/**
* Performing content dereferencing for the entities URIs. To have the
* content dereferencing working, the URI of the entities have to be of the form:
* 
*    http://[domain]/datasets/[uri-fragments]
* 
*/
function osf_entities_resource_view()
{
  // If the URI parameter is not used, it means the user is trying to
  // directly access the record by its URI
  
  // Now we do content negotiation with the client to see what representation of the resource he is expecting to
  // get from the system.
 
  global $base_url;

  // Content Negotiation for this Resource.

  $accepts = array();
  $mimes = array();

  $queryStatus = 200;
  $queryStatusMsg = "OK";
  $queryMime = "";
  $queryStatusMsgExt = "";
  $queryLocation = "";
  
  $uri = "http://".$_SERVER["HTTP_HOST"].$_SERVER["REQUEST_URI"];
  
  $header = $_SERVER['HTTP_ACCEPT'];
   
  if (strlen($header) > 0)
  {
    // break up string into pieces (languages and q factors)
    preg_match_all('/([^,]+)/', $header, $accepts);

    // It is used to make a distinction in an array of mimes are doesn't have any weight value.
    // If the requester has 3 mimes, without any weight for them, then we want to keep the order
    // when we sort the mimes array. It is what this value is used for.
    $equalityDistinguisher = 0.0001;      
    
    foreach ($accepts[0] as $accept)
    {
      $foo = explode(";", str_replace(" ", "", $accept));

      if (isset($foo[1]))
      {
        if (stripos($foo[1], "q=") !== FALSE)
        {
          $foo[1] = str_replace("q=", "", $foo[1]);
                      
          /*
           This is to ensure that the "q=1" parameter will be prioritary on the "non-q" accept mimes.
           It is the reason why we set it to 3
           
           This is particularly interesting in some usecases when a user agent "highjack" the accept header sent by 
           another user agent. One good usecase is the one of a Flash Movie embedded in a FireFox Browser window.
           When using the HTTPService API, the FireFox browser will add its default accept mimes to the query
           sent by the embeded flash movie. By seting "q=1" for any flash movies that send a query, it ensures
           that that mime will be the one selected by the WS, and not the ones added by FireFox.
          */
          if($foo[1] == "1")
          {
            $foo[1] = 3;
          }            
        }
        else
        {
          $foo[1] = 1 - $equalityDistinguisher;
          
          $equalityDistinguisher += 0.0001;
        }
      }
      else
      {
        array_push($foo, 1 - $equalityDistinguisher);
        
        $equalityDistinguisher += 0.0001;
      }

      $mimes[$foo[0]] = $foo[1];
    }

    // In the case that there is a Accept: header, but that it is empty. We set it to: anything.
    if (count($mimes) <= 0)
    {
      $mimes["*/*"] = 1;
    }

    arsort($mimes, SORT_NUMERIC);
    
    $notAcceptable406 = TRUE;

    // Check if the user is requesting a xml or N3 rdf file description
    if (strpos($uri, ".rdf") !== FALSE)
    {
      foreach ($mimes as $mime => $q)
      {
        if ($mime == "application/rdf+xml" || $mime == "*/*")
        {
          $queryStatus = 200;
          $queryStatusMsg = "OK";
          $queryMime = "application/rdf+xml";
          $queryLocation = $uri;

          $notAcceptable406 = FALSE;

          break;
        }
      }
    }
    else if (strpos($uri, ".n3") !== FALSE)
    {
      foreach ($mimes as $mime => $q)
      {
        if ($mime == "application/rdf+n3" || $mime == "*/*")
        {
          $queryStatus = 200;
          $queryStatusMsg = "OK";
          $queryMime = "application/rdf+n3";
          $queryLocation = $uri;

          $notAcceptable406 = FALSE;

          break;
        }
      }
    }
    else if (strpos($uri, ".xml") !== FALSE)
    {
      foreach ($mimes as $mime => $q)
      {
        if ($mime == "text/xml" || $mime == "*/*") // structXML
        {
          $queryStatus = 200;
          $queryStatusMsg = "OK";
          $queryMime = "text/xml";
          $queryLocation = $uri;

          $notAcceptable406 = FALSE;

          break;
        }
      }
    }      
    else if (strpos($uri, ".json") !== FALSE)
    {
      foreach ($mimes as $mime => $q)
      {
        if ($mime == "application/json" || $mime == "*/*") // structJSON
        {
          $queryStatus = 200;
          $queryStatusMsg = "OK";
          $queryMime = "application/json";
          $queryLocation = $uri;

          $notAcceptable406 = FALSE;

          break;
        }
      }
    }      
    else if (strpos($uri, ".ironjson") !== FALSE)
    {
      foreach ($mimes as $mime => $q)
      {
        if ($mime == "application/iron+json" || $mime == "*/*") // ironJSON
        {
          $queryStatus = 200;
          $queryStatusMsg = "OK";
          $queryMime = "application/iron+json";
          $queryLocation = $uri;

          $notAcceptable406 = FALSE;

          break;
        }
      }
    }      
    else if (strpos($uri, ".csv") !== FALSE)
    {
      foreach ($mimes as $mime => $q)
      {
        if ($mime == "application/iron+csv" || $mime == "*/*") // commON
        {
          $queryStatus = 200;
          $queryStatusMsg = "OK";
          $queryMime = "application/iron+csv";
          $queryLocation = $uri;

          $notAcceptable406 = FALSE;

          break;
        }
      }
    }      
    else
    {
      foreach ($mimes as $mime => $q)
      {
        $mime = strtolower($mime);

        if ($mime == "application/rdf+xml")
        {
          $queryStatus = 303;
          $queryStatusMsg = "See Other";
          $queryMime = $mime;
          $queryLocation = $uri . ".rdf";

          $notAcceptable406 = FALSE;

          break;
        }

        if ($mime == "application/rdf+n3" || $mime == "application/*")
        {
          $queryStatus = 303;
          $queryStatusMsg = "See Other";
          $queryMime = $mime;
          $queryLocation = $uri . ".n3";

          $notAcceptable406 = FALSE;

          break;
        }

        if ($mime == "text/xml")
        {
          $queryStatus = 303;
          $queryStatusMsg = "See Other";
          $queryMime = $mime;
          $queryLocation = $uri . ".xml";

          $notAcceptable406 = FALSE;

          break;
        }

        if ($mime == "application/json")
        {
          $queryStatus = 303;
          $queryStatusMsg = "See Other";
          $queryMime = $mime;
          $queryLocation = $uri . ".json";

          $notAcceptable406 = FALSE;

          break;
        }

        if ($mime == "application/iron+json")
        {
          $queryStatus = 303;
          $queryStatusMsg = "See Other";
          $queryMime = $mime;
          $queryLocation = $uri . ".ironjson";

          $notAcceptable406 = FALSE;

          break;
        }
        
        if ($mime == "application/iron+csv")
        {
          $queryStatus = 303;
          $queryStatusMsg = "See Other";
          $queryMime = $mime;
          $queryLocation = $uri . ".csv";

          $notAcceptable406 = FALSE;

          break;
        }  
        
        if (($mime == "text/html" || $mime == "application/xhtml+xml") && strpos($uri, ".rdf") === FALSE
          && strpos($uri, ".n3") === FALSE && strpos($uri, ".xml") === FALSE && strpos($uri, ".json") === FALSE &&
          strpos($uri, ".ironjson") === FALSE && strpos($uri, ".csv") === FALSE)
        {
          $queryStatus = 303;
          $queryStatusMsg = "See Other";
          $queryMime = $mime;

          $notAcceptable406 = FALSE;

          break;
        }

        if ($mime == "*/*")
        {
          $queryStatus = 303;
          $queryStatusMsg = "See Other";
          $queryMime = "application/rdf+xml";
          $queryLocation = $uri . ".rdf";

          $notAcceptable406 = FALSE;

          break;
        }
      }
    }

    if ($notAcceptable406)
    {
      $queryStatus = 406;
      $queryStatusMsg = "Not Acceptable";
      $queryStatusMsgExt = "Unacceptable mime type requested";
    }
  }
  else
  {
    // If no access header specified; it means that the client accept *anything*
    // In such a case we send back rdf+xml

    $queryStatus = 303;
    $queryStatusMsg = "See Other";
    $queryMime = "text/html";
  }
  
  $redirect = FALSE;

  if ($queryMime == "application/rdf+xml" && strpos($uri, ".rdf"))
  {
    $uri = str_replace(".rdf", "", $uri);
    $redirect = TRUE;
  }
  
  if ($queryMime == "application/rdf+n3" && strpos($uri, ".n3"))
  {
    $uri = str_replace(".n3", "", $uri);
    $redirect = TRUE;
  }
  
  if ($queryMime == "text/xml" && strpos($uri, ".xml"))
  {
    $uri = str_replace(".xml", "", $uri);
    $redirect = TRUE;
  }    
  
  if ($queryMime == "application/json" && strpos($uri, ".json"))
  {
    $uri = str_replace(".json", "", $uri);
    $redirect = TRUE;
  }    
  
  if ($queryMime == "application/iron+json" && strpos($uri, ".ironjson"))
  {
    $uri = str_replace(".ironjson", "", $uri);
    $redirect = TRUE;
  }
  
  if ($queryMime == "application/iron+csv" && strpos($uri, ".csv"))
  {
    $uri = str_replace(".csv", "", $uri);
    $redirect = TRUE;
  }    
  
  if($redirect)
  {
    $networks = osf_configure_get_endpoints(NULL, FALSE, TRUE);
    
    foreach($networks as $network)
    {     
      $defaultEndpoint = osf_configure_get_endpoint_by_uri($network->uri);
      
      $crudRead = new CrudReadQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
      
      $crudRead->uri($uri)
               ->mime($queryMime)
               ->lang('')
               ->send(new DrupalQuerierExtension());
                      
      if($crudRead->isSuccessful()) {
        ob_clean();
        header("Content-Type: application/rdf+xml");

        echo $crudRead->getResultset();
        exit;
      }
      else
      {
        continue;
      }
    }    
  }
  elseif($queryMime == "text/html")
  {            
    drupal_goto('resources/'.rawurldecode(osf_entities_get_drid_from_uri($uri)));
  }
  else
  {
    ob_clean();
    header("HTTP/1.1 " . $queryStatus . " " . $queryStatusMsg);
    header("Content-Type: " . $queryMime);
    header("Location: $queryLocation");

    if ($queryStatusMsgExt != "")
    {
      echo $queryStatusMsgExt;
      exit;
    }         
  }    
}

/**
* Implements hook_theme()
* 
* @see http://api.drupal.org/api/drupal/modules!system!system.api.php/function/hook_theme/7
*/
function osf_entities_theme($existing, $type, $theme, $path) {
  
  // Here we have to define *all* the possible themes that can exists. These are the 
  // bundles that got synchronized in OSF Entities.
  
  global $base_path;
  
  $themes = array();
  
  // Add the core default theme
  // Make sure the template exists before adding it to the list of possible theme templates
  // The template can exists in one of the following folders:
  //
  //   (1) The 'templates' folder of the default theme
  //   (2) The osf_entities folder
  //  

  // Scan the directory of the theme's folder
  $templates = file_scan_directory(getcwd().'/'.drupal_get_path('theme', variable_get('theme_default', NULL)), '/resource_type.*.tpl.php/');
  foreach($templates as $template)
  {
    $template = str_replace('.tpl.php', '', $template->filename);
    
    if(strpos($template, '__search') === FALSE)
    {
      $themes[$template] = array('variables' => array('element' => NULL),
                                                      'template' => $template);
    }
  }  
  
  // Scan the directory of the OSF SearchAPI module
  $templates = file_scan_directory(getcwd().'/'.$path.'/', '/resource_type.*.tpl.php/');
  foreach($templates as $template)
  {
    $template = str_replace('.tpl.php', '', $template->filename);

    if(strpos($template, '__search') === FALSE)
    {
      // Use the templates from the theme before using the templates defined in the module    
      if(!isset($themes[$template]))
      {
        $themes[$template] = array('variables' => array('element' => NULL),
                                                        'template' => $template);
      }
    }
  }

  return($themes);
}


/**
* Implements hook_preprocess_THEME_ID()
* 
* This implementation is used to suggest templates to Drupal. The "theme_hook_suggestions"
* list is a FILO one: so, the first item of the list is the last one being selected by Drupal.
* 
* Depending the template files that are defined for the current theme, one of these
* template should be used. Otherwise, the default one will be used (resource_type.tpl.php)
* 
* @see http://api.drupal.org/api/drupal/modules!system!theme.api.php/function/hook_preprocess/7
*/
function osf_entities_preprocess_resource_type(&$vars, $hook) 
{
  $superClasses = array();

  // For each type of the resource, we get the list of its super-types. 
  // Then we will use that list to create the template suggestions.
  foreach($vars['element']->rdf_type as $type)
  {
    $superTypes = &drupal_static('osf_entities_class_type_supertypes_'.md5($type));
    
    if(!isset($superTypes)) 
    {
      if($cache = cache_get('osf_entities_class_type_supertypes_'.md5($type))) 
      {
        $superTypes = $cache->data;
      }
      else
      {
        $superTypes = osf_ontology_get_super_classes_hierarchy($type);
        
        cache_set('osf_entities_class_type_supertypes_'.md5($type), $superTypes, 'cache', CACHE_TEMPORARY);
      }
    }        
    
    $superClasses[$type] = $superTypes;
  }

  // Here we specify the priority order of all the templates that may be defined in osf_entities_theme()
  $vars['theme_hook_suggestions'][] = 'resource_type';
  
  $superTypesFILO = _osf_entities_get_filo_supertypes($superClasses);
  
  foreach($superTypesFILO as $st)
  {
    $vars['theme_hook_suggestions'][] = 'resource_type__'.resource_type_get_id($st);
    
    if(isset($vars['view_mode']))
    {
      $vars['theme_hook_suggestions'][] = 'resource_type__'.resource_type_get_id($st).'__'.$vars['view_mode'];
    }      
  }

  $vars["subject"] = $vars['element']->obj;
  $vars["entity"] = $vars['element'];
  
  $resource = new Resource($vars["subject"]->getUri());
  
  $currentLanguage = get_lang(get_default_language());
  
  $resource->importSubject($vars["subject"])
           ->setLanguage(($currentLanguage == 'und' ? NULL : $currentLanguage));
  
  $vars['resource'] = $resource;  
}

function _osf_entities_get_filo_supertypes($superTypes)
{
  $filo_types = array();
  
  foreach($superTypes as $type => $sts)
  {
    if(!empty($sts))
    {
      $filo_types = array_merge($filo_types, _osf_entities_get_filo_supertypes($sts));
    }
    
    $filo_types[] = $type;    
  }
  
  return($filo_types);
}

/** 
 * @brief Define menu items and page callbacks.
 * @details This hook enables modules to register paths, which determines whose requests are to be handled.
 * Depending on the type of registration requested by each path, a link is placed in the the navigation
 * block and/or an item appears in the menu administration page (q=admin/menu).
 * 
 * @return An array of menu items. Each menu item has a key corresponding to the Drupal path being registered.
 * The item is an associative array.
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 * 
 * @see http://api.drupal.org/api/function/hook_block
 */
function osf_entities_menu() {
  $items = array();

  $items['admin/config/osf/entities'] = array(
    'title' => t('Entities Connector'),
    'description' => t('Settings of the OSF Entities Connector'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('osf_entities_settings'),
    'access arguments' => array('administer osf entities'),
    'type' => MENU_LOCAL_TASK,
    'weight' => -40,
  );
    
  $items['osf/entities/ontologies/select'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('osf_entities_ontologies_select'),
    'access arguments' => array('administer osf entities'),
    'type' => MENU_CALLBACK,
  );  
  
  $items['osf/entities/ontologies/sync/classes'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('osf_entities_sync_structure_classes'),
    'access arguments' => array('administer osf entities'),
    'type' => MENU_CALLBACK,               
  );  
  
  $items['osf/entities/ontologies/sync/properties'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('osf_entities_sync_structure_properties'),
    'access arguments' => array('administer osf entities'),
    'type' => MENU_CALLBACK,
  );  
  
  $items['osf/entities/namespaces'] = array(
    'page callback' => 'osf_entities_manage_namespaces',
    'access arguments' => array('administer osf entities'),
    'type' => MENU_CALLBACK,
  );  

  // Add a new resource_type instance
  $items['resource/add'] = array(
    'title' => t('Add resources'),
    'description' => t('Add a new instance of this entity'),
    'page callback' => 'osf_entities_resource_add_page',
    'access arguments' => array('add resource entity item'),
    'file' => 'osf_entities.admin.inc',
  );  
  
  // Register menu paths for adding a new instance of a resource_type
  
  // IMPORTANT NOTE: here we cannot use resource_types(), otherwise we may have some 
  //                 unwanted behavior that occurs with the entity cache. In fact
  //                 during the synchronization phase we do use entity_load on
  //                 properties and it loads the properties entities into the cache.
  //                 However these are not wanted when we call resource_types() to
  //                 create the menu items. So we have to fallback on getting them 
  //                 directly from the table.
  $resource_types = array();
  
  $resultset = db_query('SELECT type FROM {resource_type}');

  while ($type = $resultset->fetchField()) 
  {
    $resource_types[] = $type;
  }

  foreach($resource_types as $type)
  {
    $info = entity_load('resource_type', array($type));
    $info = $info[key($info)];

    if(!$info->ignoreResource)
    {
      $items['resource/add/' . $type] = array(
        'title' => entity_label('resource_type', $info),
        'page callback' => 'osf_entities_resource_add',
        'page arguments' => array(2),
        'access callback' => 'entity_access',
        'access arguments' => array('create', 'resource_type', $type),
        'file' => 'osf_entities.admin.inc',
      );
    }
  } 
  
  // Create the top admin menu
  $items['admin/resource'] = array(
    'title' => t('Resource'),
    'weight' => -9,
    'description' => t('Administer resources'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('osf_entities_admin_content'),    
    'access arguments' => array('administer osf entities'),
    'file' => 'osf_entities.admin.inc',
  );   
  
  // Create the top admin menu
  $items['admin/resource/add'] = array(
    'title' => t('Add resource'),
    'description' => t('Add resource content'),
    'page callback' => 'osf_entities_resource_add_page',
    'access arguments' => array('add resource entity item'),
    'file' => 'osf_entities.admin.inc',
    'type' => MENU_CALLBACK,
  );   
  
  // Handle URI dereferencing of accessible entities.
  $items['datasets'] = array(
    'page callback' => 'osf_entities_resource_view',
    'access arguments' => array('export resource entities'),
    'type' => MENU_CALLBACK,
  );
     
  // Handle entity's view web page 
  $items['resources/%drid'] = array(
    'type' => MENU_CALLBACK,
    'page callback' => 'osf_entities_resource_page_view',
    'page arguments' => array(1),
    'access arguments' => array('view resource entities'),
    'file' => 'osf_entities.admin.inc',    
  );  

  $items['admin/resource/republish/%/%'] = array(
    'title' => t('Republish unpublished record'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('osf_entities_resource_republish', 3, 4),
    'access arguments' => array('resource entity revert revisions'),
    'file' => 'osf_entities.admin.inc',    
  );
  
  $items['resources/%drid/view'] = array(
    'title' => t('View'),
    'weight' => -11,
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'page callback' => 'osf_entities_resource_page_view',
    'page arguments' => array(1),
    'access arguments' => array('view resource entities'),
    'file' => 'osf_entities.admin.inc',    
  );
  
  $items['resources/%drid/edit'] = array(
    'title' => t('Edit'),
    'weight' => -10,    
    'page callback' => 'osf_entities_resource_edit',
    'page arguments' => array(1),
    'access arguments' => array('edit resource entities'),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'file' => 'osf_entities.admin.inc',    
  );
          
  $items['resources/%drid/revisions'] = array(
    'title' => t('Revisions'),
    'weight' => -8,    
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'osf_entities_resource_revisions',
    'page arguments' => array(1),
    'access callback' => 'osf_entities_resources_revisions_menu_access',
    'access arguments' => array(1),
    'file' => 'osf_entities.admin.inc',    
  );

          
  $items['resources/%drid/translate'] = array(
    'title' => t('Translate'),
    'weight' => -9,    
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'osf_entities_resource_translate',
    'page arguments' => array(1),
    'access callback' => 'osf_entities_resources_translate_menu_access',
    'access arguments' => array(1),
    'file' => 'osf_entities.admin.inc',    
  );  
  
  $items['resources/%drid/export'] = array(
    'title' => t('Export'),
    'weight' => -6,
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'osf_entities_resource_page_export',
    'page arguments' => array(1),
    'access arguments' => array('export resource entities'),
    'file' => 'osf_entities.admin.inc',    
  );

  $items['resources/%drid/expose'] = array(
    'title' => t('Expose'),
    'weight' => -20,
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'osf_entities_resource_page_redirect_expose',
    'page arguments' => array(1),
    'access callback' => 'osf_entities_resources_expose_menu_access',
    'access arguments' => array(1),
    'file' => 'osf_entities.admin.inc',    
  );

  $items['resources/%drid/%'] = array(
    'page callback' => 'osf_entities_resource_page_export_format',
    'page arguments' => array(1, 2),
    'access arguments' => array('export resource entities'),
    'file' => 'osf_entities.admin.inc',    
  );
  
  $items['resources/%drid/delete'] = array(
    'title' => t('Delete'),
    'weight' => -7,
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'osf_entities_resource_delete',
    'page arguments' => array(1),
    'access arguments' => array('delete resource entities'),
    'file' => 'osf_entities.admin.inc',    
  );  
          
  $items['resources/%drid/revisions/%revid/view'] = array(
    'title' => t('View'),
    'page callback' => 'osf_entities_resource_revisions_view',
    'page arguments' => array(1, 3),
    'access arguments' => array('resource entities revisions'),
    'file' => 'osf_entities.admin.inc', 
    'type' => MENU_LOCAL_TASK, 
  );

  $items['resources/%drid/revisions/%/revert'] = array(
    'title' => t('Revert to earlier revision'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('osf_entities_revision_revert_confirm', 1, 3),
    'access arguments' => array('resource entity revert revisions'),
    'file' => 'osf_entities.admin.inc',
  );
  
  $items['resources/%drid/revisions/%/delete'] = array(
    'title' => t('Delete revision'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('osf_entities_revision_delete_confirm', 1, 3),
    'access arguments' => array('resource entity delete revisions'),
    'file' => 'osf_entities.admin.inc',
  );    
  
  /*
  
  // The unpublish operations link needs to be better integrated in a Drupal moderation flow.
  // The issue is that when we unpublish it, it remains as revisions, but since we use entity_load()
  // it can't find it in the dataset (only in the revisions dataset). This means that we would have
  // to change _load() to check in the revisions graph if CrudRead() fails to try to get a unpublished
  // version of an entity. Then, we would have to make sure that only the proper people to have access
  // to the unpublished versions of that entity.
  
  $items['resources/%drid/revisions/%/unpublish'] = array(
    'title' => 'Unpublish revision',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('osf_entities_revision_unpublish_confirm', 1, 3),
    'access arguments' => array('resource entity unpublish revisions'),
    'file' => 'osf_entities.admin.inc',
  );
  */    
          
  $items['resources/%drid/revisions/compare/%/with/%'] = array(
    'title' => t('Compare revisions'),
    'page callback' => 'osf_entities_revisions_compare',
    'page arguments' => array(1,4,6),
    'access arguments' => array('resource entity compare revisions'),
    'file' => 'osf_entities.admin.inc',
  );
          
  $items['admin/structure/resource-types/synchronize'] = array(
    'title' => t('Organize existing resource type'),
    'type' => MENU_LOCAL_ACTION,
    'page callback' => 'osf_entities_resource_synchronize_existing',
    'access arguments' => array('administer osf entities'),
    'file' => 'osf_entities.admin.inc',   
    'weight' => 10 
  );  
  
  $items['admin/structure/resource-types/add-new'] = array(
    'title' => t('Add new resource type'),
    'type' => MENU_LOCAL_ACTION,
    'page callback' => 'osf_entities_resource_add_new',
    'access arguments' => array('administer osf entities'),
    'file' => 'osf_entities.admin.inc',    
    'weight' => 11 
  );

  
  $items['admin/structure/resource-types/manage/%resource_type/fields/synchronize'] = array(
    'title' => t('Organize existing resource type fields'),
    'type' => MENU_LOCAL_ACTION,
    'page callback' => 'osf_entities_resource_fields_synchronize_existing',
    'access arguments' => array('administer osf entities'),
    'file' => 'osf_entities.admin.inc',   
    'weight' => 10 
  );  
  
  $items['admin/structure/resource-types/manage/%resource_type/fields/add-new'] = array(
    'title' => t('Add new resource type field'),
    'type' => MENU_LOCAL_ACTION,
    'page callback' => 'osf_entities_resource_fields_add_new',
    'access arguments' => array('administer osf entities'),
    'file' => 'osf_entities.admin.inc',    
    'weight' => 11 
  );
  
  // Autocomplete for object properties
  $items['osf/entities/get/resources_references/%'] = array(
    'page callback' => 'osf_entities_resources_references_autocomplete',
    'page arguments' => array(4),
    'access arguments' => array('view resource entities'),
    'type' => MENU_CALLBACK
  );  
  
  // Autocomplete for datatype properties
  $items['osf/entities/get/resources_text/%'] = array(
    'page callback' => 'osf_entities_resources_text_autocomplete',
    'page arguments' => array(4),
    'access arguments' => array('view resource entities'),
    'type' => MENU_CALLBACK
  );  
  
  // Autocomplete for getting classes
  $items['osf/entities/get/classes/%'] = array(
    'page callback' => 'osf_entities_classes_autocomplete',
    'page arguments' => array(4),
    'access arguments' => array('view resource entities'),
    'type' => MENU_CALLBACK
  );            
  
  // Autocomplete for getting classes
  $items['osf/entities/get/properties/%'] = array(
    'page callback' => 'osf_entities_properties_autocomplete',
    'access arguments' => array('view resource entities'),
    'page arguments' => array(4),    
    'type' => MENU_CALLBACK
  );      
  return $items;
}   

function osf_entities_admin_paths() 
{
  $paths = array(
    'resources/*/revisions/compare/*/with/*' => TRUE,
    'resources/*/revisions/*/delete' => TRUE,
    'resources/*/revisions/*/revert' => TRUE,
    'resources/*/revisions/*/view' => TRUE,
    'resources/*/delete' => TRUE,
    'resources/*/*' => TRUE,
    'resources/*/expose' => TRUE,
    'resources/*/export' => TRUE,
    'resources/*/translate' => TRUE,
    'resources/*/revisions' => TRUE,
    'resources/*/edit' => TRUE,
    'resource/add/*' => TRUE,
    'osf/entities/ontologies/sync/classes' => TRUE,
    'osf/entities/ontologies/select' => TRUE,
    'osf/entities/ontologies/sync/properties' => TRUE,
    'osf/entities/namespaces' => TRUE
  );
    
  return $paths;
}

function revid_to_arg($arg, $map, $index)
{
  if(empty($arg)) 
  {
    $map = array();
  }
  
  return $arg;
}          
       
function osf_entities_resources_expose_menu_access($entity) 
{
  $entity = current($entity);
  
  if($entity->type[0] === 'owl_thing')
  {
    return(TRUE);
  }
  else
  {
    return(FALSE);
  }
}       
       
function osf_entities_resources_revisions_menu_access($entity) {
  
  // Make sure the user does have access to the revisioning
  if(user_access('resource entities revisions'))
  {  
    // If it does, then make sure there are revisions for that record.
    // If there is none, then we simply forgive access to it to hide
    // the menu task from the UI
    $entity = $entity[key($entity)];
    
    $defaultEndpoint = osf_configure_get_endpoint_by_uri(osf_entities_get_network_from_dataset_uri($entity->dataset));
    
    $revisionLister = new RevisionListerQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());

    $revisionLister->longResults()
                   ->uri($entity->uri)
                   ->dataset($entity->dataset)
                   ->send(new DrupalQuerierExtension());
                   
    if($revisionLister->isSuccessful())
    {
      // each of them that are not published get deleted
      $revisions = $revisionLister->getResultset()->getResultset();
      
      if(!empty($revisions))
      {
        return(TRUE);
      }
      else
      {
        return(FALSE);
      }
    } 
    else
    {
      return(FALSE);
    }    
  }
  else
  {
    return(FALSE);
  }
}          

function osf_entities_resources_translate_menu_access($entity) {
  
  // Make sure the user does have access to translate content
  if(user_access('resource entities translate'))
  {  
    if(is_site_multilingual())
    {
      return(TRUE);
    }    
    else
    {
      return(FALSE);
    }
  }
  else
  {
    return(FALSE);
  }
}   
      
function osf_entities_ontologies_select($form, &$form_state)
{
  module_load_include('inc', 'osf', 'osf.admin');
  
  $loadedOntologies = osf_get_loaded_ontologies();
  $options = array();
  
  foreach($loadedOntologies as $uri => $ontology)
  {
    if(empty($ontology['prefLabel']))
    {
      $options[$uri] = $uri;
    }
    else
    {
      $options[$uri] = $ontology['prefLabel']; 
    }    
  }
  
  $form['ontologies_selection'] = array(
    '#type' => 'fieldset',
    '#title' => t('Expose Entities'),
    '#description' => t('select all the ontologies you want to be ble to expose'),
    '#weight' => 3,
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );     
  
  $form['ontologies_selection']['ontologies'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Ontologies'),
    '#options' => $options,
    "#default_value" => variable_get('osf_osf_entities_ontologies_selected', array())
  );  
  
  return(system_settings_form($form));  
}

function osf_entities_ontologies_select_validate($form, &$form_state) {
  
  variable_set('osf_osf_entities_ontologies_selected', $form_state['input']['ontologies']);

  drupal_goto('admin/config/osf/entities');  
}

function osf_entities_sync_core_structure()
{
  $isCoreSynchronized = variable_get('osf_entities_is_core_synchronized', FALSE);
  
  if(!$isCoreSynchronized)
  {
    _osf_entities_create_bundle_from_class(Namespaces::$owl.'Class');
    _osf_entities_create_bundle_from_class(Namespaces::$owl.'DatatypeProperty');
    _osf_entities_create_bundle_from_class(Namespaces::$owl.'ObjectProperty');
    _osf_entities_create_bundle_from_class(Namespaces::$owl.'AnnotationProperty');
    _osf_entities_create_bundle_from_class(Namespaces::$owl.'Thing');  
    
    $usedClasses = variable_get('osf_entities_classes_to_synchronize', array());
    
    $usedClasses[Namespaces::$owl.'Class'] = Namespaces::$owl.'Class';
    $usedClasses[Namespaces::$owl.'DatatypeProperty'] = Namespaces::$owl.'DatatypeProperty';
    $usedClasses[Namespaces::$owl.'ObjectProperty'] = Namespaces::$owl.'ObjectProperty';
    $usedClasses[Namespaces::$owl.'AnnotationProperty'] = Namespaces::$owl.'AnnotationProperty';
    $usedClasses[Namespaces::$owl.'Thing'] = Namespaces::$owl.'Thing';       
    
    variable_set('osf_entities_classes_to_synchronize', $usedClasses);
    
    $num_updated = db_update('resource_type')
      ->fields(array(
        'ignoreResource' => 1
      ))
      ->condition('type', 'owl_class')
      ->execute();  
    
    $num_updated = db_update('resource_type')
      ->fields(array(
        'ignoreResource' => 1
      ))
      ->condition('type', 'owl_thing')
      ->execute();  
    
    $num_updated = db_update('resource_type')
      ->fields(array(
        'ignoreResource' => 1
      ))
      ->condition('type', 'owl_datatypeproperty')
      ->execute();  
    
    $num_updated = db_update('resource_type')
      ->fields(array(
        'ignoreResource' => 1
      ))
      ->condition('type', 'owl_annotationproperty')
      ->execute();  
    
    $num_updated = db_update('resource_type')
      ->fields(array(
        'ignoreResource' => 1
      ))
      ->condition('type', 'owl_objectproperty')
      ->execute();      

    _osf_entities_create_field_from_property(Namespaces::$iron.'prefLabel');
    _osf_entities_create_field_from_property(Namespaces::$iron.'description');
    
    _osf_entities_create_field_instance_by_property_class(Namespaces::$iron.'prefLabel', Namespaces::$owl.'Class');
    _osf_entities_create_field_instance_by_property_class(Namespaces::$iron.'description', Namespaces::$owl.'Class');
    _osf_entities_create_field_instance_by_property_class(Namespaces::$iron.'prefLabel', Namespaces::$owl.'DatatypeProperty');
    _osf_entities_create_field_instance_by_property_class(Namespaces::$iron.'description', Namespaces::$owl.'DatatypeProperty');
    _osf_entities_create_field_instance_by_property_class(Namespaces::$iron.'prefLabel', Namespaces::$owl.'ObjectProperty');
    _osf_entities_create_field_instance_by_property_class(Namespaces::$iron.'description', Namespaces::$owl.'ObjectProperty');
    _osf_entities_create_field_instance_by_property_class(Namespaces::$iron.'prefLabel', Namespaces::$owl.'AnnotationProperty');
    _osf_entities_create_field_instance_by_property_class(Namespaces::$iron.'description', Namespaces::$owl.'AnnotationProperty');
    _osf_entities_create_field_instance_by_property_class(Namespaces::$iron.'prefLabel', Namespaces::$owl.'Thing');
    _osf_entities_create_field_instance_by_property_class(Namespaces::$iron.'description', Namespaces::$owl.'Thing');
      
    drupal_flush_all_caches();  
    
    variable_set('osf_entities_is_core_synchronized', TRUE);
  }
}

function osf_entities_sync_structure_classes($form, &$form_state)
{
  // First thing to do: make sure that the core structure is loaded
  osf_entities_sync_core_structure();
  
  $form['used_classes'] = array(
    '#type' => 'fieldset',
    '#title' => t('Select Used Classes'),
    '#description' => t('Select all the ontologies classes you would like to expose in Drupal as Bundles. 
                         The following classes are the ones used to instantiate records in the OSF
                         instance.'),
    '#weight' => 3,
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );
  
  // List all the classes are that used across all the networks
  // Get the list of all the classes used to define records in the OSF instance
  $networks = osf_configure_get_endpoints(NULL, FALSE, TRUE);

  $dsets = osf_configure_dataset_load_util('all', FALSE);
        
  $classes = array();

  if($cache = cache_get('osf_entities_sync_classes')) 
  {
    $classes = $cache->data;
  }
  else 
  {  
    foreach($networks as $network)
    {
      $defaultEndpoint = osf_configure_get_endpoint_by_uri($network->uri);
            
      $sparql = new SparqlQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());

      $datasets = array();

      foreach($dsets as $key => $dataset)      
      {
        if($dataset->endpoint->machine_name == $defaultEndpoint->machine_name)
        {
          $datasets[] = $dataset->uri; 
        }
      }     
      
      $from = '';
      
      foreach($datasets as $dataset)
      {
        $from .= 'from <'.$dataset.'> ';
      }
      
      $sparql->mime("application/sparql-results+json")
             ->query('select ?type ?label
                      '.$from.'
                      where
                      {
                        {
                          select distinct ?type
                          where
                          {
                            ?s a ?type .
                          }
                        }
                        
                        optional
                        {
                          ?type ?p ?label .

                          filter(?p in (<http://www.w3.org/2000/01/rdf-schema#label>, <http://purl.org/ontology/iron#prefLabel>,<http://purl.org/dc/terms/title>,<http://purl.org/dc/elements/1.1/title>,<http://www.w3.org/2004/02/skos/core#prefLabel>,<http://www.w3.org/2008/05/skos#prefLabel>)) .
                          filter(lang(?label) = "'.get_lang(get_default_language()).'" || lang(?label) = "") .
                        }
                      }')
             ->send();
             
      if(!$sparql->isSuccessful())
      {
        drupal_set_message(t("Can't get the list of classes to expose: [@error] @errorMsg - @errorDescription", 
                           array("@error" => $sparql->getStatus(),
                                 "@errorMsg" => $sparql->getStatusMessage(),
                                 "@errorDescription" => $sparql->getStatusMessageDescription())), 
                           "error", 
                           TRUE);
                           
        watchdog('osf_entities', 
                 'Can\'t get the list of classes to expose: [@error] @errorMsg - @errorDescription.', 
                 array("@error" => $sparql->getStatus(),
                       "@errorMsg" => $sparql->getStatusMessage(),
                       "@errorDescription" => $sparql->getStatusMessageDescription()));                       
      } 
      else
      { 
        // @Todo: cache the resultset.
        
        $results = json_decode($sparql->getResultset(), TRUE);    
        
        foreach($results['results']['bindings'] as $result)
        {
          $type = $result['type']['value'];
          $label = '';
          
          if(isset($result['label']))
          {
            $label = $result['label']['value'];
          }
          else
          {
            // Find the base URI of the ontology
            $pos = strripos($type, "#");

            if ($pos === FALSE)
            {
              $pos = strripos($type, "/");
            }

            if ($pos !== FALSE)
            {
              $pos++;
            }

            $label = substr($type, $pos);
          }
          
          $classes[$type] = $label;
        }
      }    
    }    

    asort($classes, SORT_STRING);
    
    cache_set('osf_entities_sync_classes', $classes, 'cache', CACHE_TEMPORARY); 
  }
  
  // This list of available used classes is used by the autocompletion search
  // to exclude these from the results returned by the autocompletion search.
  variable_set('osf_entities_used_classes', array_keys($classes));

  $unusedClasses = variable_get('osf_entities_unused_classes_to_synchronize', array()); 
  $usedClasses = variable_get('osf_entities_classes_to_synchronize', array());
  
  // For each used classes, check if it appears in the unused classes structure.
  // If it does, it means that the class was unused and is now used in the OSF
  // instance. This means we have to check that box in the series of used classes and
  // to remove it from the unused classes structure.
  
  $namespaces = new Namespaces();
  
  foreach($classes as $usedUri => $usedLabel)
  {
    foreach($unusedClasses as $unusedKey => $unusedValue)
    {
      if(strpos($unusedValue, '('.$namespaces->getPrefixedUri($usedUri).')') !== FALSE)
      {
        // Check the checkbox of the used class
        $usedClasses[$usedUri] = $usedUri;
        
        // Remove the class in the unused classes structure
        array_splice($unusedClasses, $unusedKey, 1);
      }
    }
  }
  
  $bundlesClasses = variable_get("osf_entities_classes_by_bundles", array());
  
  // Now the opposite usecase: is a class was being used, but all the data that was using
  // it got deleted somehow. We then have to make it back available into the list
  // of unused classes
  foreach($bundlesClasses as $bundle => $class)
  {
    if(!isset($classes[$class]))
    {
      // make sure it is not existing in the list of unused classes
      $found = FALSE;
      
      foreach($unusedClasses as $unusedClass)
      {
        if(strpos($unusedClass, $namespaces->getPrefixedUri($class)) !== FALSE)
        {
          $found = TRUE;
          break;
        }
      }
      
      if(!$found)
      {
        $unusedClasses[] = get_label_from_uri($class).'   ('.$namespaces->getPrefixedUri($class).')';
      }
    }
  }

  // Save the potentially modified structures
  variable_set('osf_entities_unused_classes_to_synchronize', $unusedClasses); 
  variable_set('osf_entities_classes_to_synchronize', $usedClasses);
  
  $form['used_classes']['uclasses'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Used Classes'),
    '#options' => $classes,
    "#default_value" => $usedClasses
  );  
  
  $form['unused_classes'] = array(
    '#type' => 'fieldset',
    '#title' => t('Select Unused Classes'),
    '#description' => t('Select all the ontologies classes you would like to expose in Drupal as Bundles. 
                         The following classes are the not currently used to instantiate record
                         in the OSF instance.'),
    '#weight' => 4,
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    
    // Set up the wrapper so that AJAX will be able to replace the fieldset.
    '#prefix' => '<div id="unusedclasses-fieldset-wrapper">',
    '#suffix' => '</div>',    
  ); 
  
  if (empty($form_state['num_unusedclasses'])) 
  {
    $form_state['num_unusedclasses'] = count($unusedClasses) + 1;
  }
  
  for ($i = 0; $i < $form_state['num_unusedclasses']; $i++) 
  {
    $form['unused_classes']['unclass'][$i] = array(
      '#type' => 'textfield',
      '#default_value' => (isset($unusedClasses[$i]) ? $unusedClasses[$i] : ''),
      '#autocomplete_path' => 'osf/entities/get/classes/exclude_used',
      '#attributes' => array(
        // Fix the size of the input to make sure the throbber is properly displayed
        'style' => 'width: 80%',
        'onblur' => "if (this.value.indexOf('(') == -1 && this.value != '') {this.value = jQuery.data(this, 'previousdata')}",
        'onfocus' => "if (this.value != '') {jQuery.data(this, 'previousdata', this.value); var label = this.value.substring(0, this.value.indexOf('(') - 3); this.value = label;}"
      ),
    ); 
    
    if($i == 0)
    { 
      $form['unused_classes']['unclass'][$i]['#title'] = t('Unused class');   
    }
  }
  
  $form['unused_classes']['add_class'] = array(
    '#type' => 'submit',
    '#value' => t('Add more'),
    '#submit' => array('osf_entities_unusedclass_add_more'),

    // See the examples in ajax_example.module for more details on the
    // properties of #ajax.
    '#ajax' => array(
      'callback' => 'osf_entities_unusedclass_add_more_callback',
      'wrapper' => 'unusedclasses-fieldset-wrapper',
    ),
  );  
  
  if ($form_state['num_unusedclasses'] > 1) 
  {
    $form['unused_classes']['remove_class'] = array(
      '#type' => 'submit',
      '#value' => t('Remove last'),
      '#submit' => array('osf_entities_unusedclass_remove_last'),
      '#ajax' => array(
        'callback' => 'osf_entities_unusedclass_add_more_callback',
        'wrapper' => 'unusedclasses-fieldset-wrapper',
      ),
    );
  }  
  
  $form['select_properties'] = array(
    '#type' => 'submit',
    '#value' => t((isset($_GET['destination']) ? 'Expose' : 'Next, select properties')),
    '#name' => 'select_properties',
    '#weight' => 5
  );   
  
  $form['#attached']['js'] = array(
    drupal_get_path('module', 'osf_entities') . '/js/autocomplete.js',
  );
  
  return($form);    
}

function osf_entities_unusedclass_remove_last($form, &$form_state) {
  if ($form_state['num_unusedclasses'] > 1) {
    $form_state['num_unusedclasses']--;
  }
  $form_state['rebuild'] = TRUE;
}

function osf_entities_unusedclass_add_more_callback($form, $form_state) {
  return $form['unused_classes'];
}

function osf_entities_unusedclass_add_more($form, &$form_state) {
  $form_state['num_unusedclasses']++;
  $form_state['rebuild'] = TRUE;
}

function osf_entities_unusedproperty_remove_last($form, &$form_state) {
  $bundle = $form_state['triggering_element']['#name'];
  if ($form_state['num_unusedproperties'][$bundle] > 1) {
    $form_state['num_unusedproperties'][$bundle]--;
  }
  $form_state['rebuild'] = TRUE;
}

function osf_entities_unusedproperty_add_more_callback($form, $form_state) {
  $bundle = $form_state['triggering_element']['#name'];
  return $form[$bundle]['unused_properties_'.$bundle];
}


function osf_entities_unusedproperty_remove_callback($form, $form_state) { 
  $bundle = $form_state['triggering_element']['#name'];
  return $form[$bundle]['unused_properties_'.$bundle];
}

function osf_entities_unusedproperty_add_more($form, &$form_state) {
  $bundle = $form_state['triggering_element']['#name'];
  $form_state['num_unusedproperties'][$bundle]++;
  $form_state['rebuild'] = TRUE;
}

function _osf_entities_create_bundle_from_class($classUri)
{
  $typeID = resource_type_get_id($classUri);   

  // Make sure the bundle is not already existing in this Drupal instance.
  if(!db_query('SELECT * FROM {resource_type} WHERE type = :type LIMIT 1', array(':type' => $typeID))->fetchField())
  {                    
    $defaultEndpoint = current(osf_configure_get_default_endpoint());
    
    $crudRead = new CrudReadQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
    
    $crudRead->excludeLinksback()
             ->excludeReification()
             ->uri($classUri)
             ->send(new DrupalQuerierExtension());

    if($crudRead->isSuccessful())
    {
      $classSubject = $crudRead->getResultset()->getSubjectByUri($classUri);

      // Create the default webform type.
      $resource_type = array(
        'type' => $typeID,
        'label' => t($classSubject->getPrefLabel()),
        'description' => t($classSubject->getDescription()),
        'module' => "osf_entities"
      );   
                             
      $resource_type_entity = entity_create("resource_type", $resource_type);
        
      resource_type_save($resource_type_entity);       

      $bundlesClasses = variable_get("osf_entities_classes_by_bundles", array()); 

      $bundlesClasses[$typeID] = $classUri;

      variable_set("osf_entities_classes_by_bundles", $bundlesClasses);  

      $classesObj = variable_get('osf_entities_classes', array()); 
      
      $classesObj[$classUri] = serialize($classSubject);
      
      variable_set('osf_entities_classes', $classesObj);
    }
    else
    {
      drupal_set_message(t("The class <b>@class</b> is currently being used to describe information in the 
                            OSF instance, but it is not currently defined in any ontology. <a href=\"/admin/structure/resource-types/add-new?uri=".urlencode($classUri)."\">
                            You can create this new class in an ontology by using this form</a>. This class
                            won't appears in the list of bundles until it got created in an ontology.", 
                         array("@class" => $classUri)), 
                         "error", 
                         TRUE);           
                         
      watchdog('osf_entities', 
               'Can\'t find the class in OSF (@class): [@error] @errorMsg - @errorDescription.', 
               array("@error" => $crudRead->getStatus(),
                     "@class" => $classUri,                   
                     "@errorMsg" => $crudRead->getStatusMessage(),
                     "@errorDescription" => $crudRead->getStatusMessageDescription()));          
    }    
  }
}


function osf_entities_sync_structure_classes_validate($form, &$form_state) {
  if($form_state['clicked_button']['#parents']['0'] == "select_properties")
  {     
    // Save selected used classes
    variable_set('osf_entities_classes_to_synchronize', $form_state['values']['uclasses']);

    // Save selected un-used classes
    $unusedClasses = array();
    
    for($i = 0; $i < $form_state['num_unusedclasses']; $i++)
    {
      if(isset($form_state['values'][$i]) && !empty($form_state['values'][$i]))
      {
        $unusedClasses[] = $form_state['values'][$i];
      }
    }

    variable_set('osf_entities_unused_classes_to_synchronize', array_unique($unusedClasses));
    
    $classes = array();
    
    // Get the used classes URIs
    foreach($form_state['values']['uclasses'] as $uri => $selected)
    {
      if(!empty($selected))
      {
        $classes[] = $uri;
      }
    }
    
    $namespaces = new Namespaces();
    
    // Get the unused classes URIs
    foreach($unusedClasses as $uri)
    {
      $uri = substr($uri, strpos($uri, '(') + 1, strpos($uri, ')') - strpos($uri, '(') - 1);
      
      $classes[] = $namespaces->getUnprefixedUri($uri);
    }

    $bundlesClasses = array();
    
    // Create a bundle per class
    foreach($classes as $class) 
    {
      _osf_entities_create_bundle_from_class($class);
      
      $bundlesClasses[resource_type_get_id($class)] = $class;
    }

    variable_set("osf_entities_classes_by_bundles", $bundlesClasses);  
    
    // Delete bundles for which the classes got unselected  
    // Check to see what role the user has on the node
    $bundles = db_query('SELECT * FROM {resource_type}');

    // Get all WSF address still in use
    foreach($bundles as $bundle)
    {
      if(!isset($bundlesClasses[$bundle->type]))
      {
        // Delete all the bundles
        db_delete('resource_type')->condition('type', $bundle->type, '=')->execute();
        
        // Delete fields instances
        db_delete('field_config_instance')->condition('bundle', $bundle->type, '=')->execute();
        
        $unusedProperties = variable_get('osf_entities_unused_properties_to_synchronize', array());
        
        foreach($unusedProperties as $fieldID => $unsedProperty)
        {
          $b = substr($fieldID, 0, strrpos($fieldID, '_'));
          
          if($b == $bundle->type)  
          {
            unset($unusedProperties[$fieldID]);
          }            
        }
        
        variable_set('osf_entities_unused_properties_to_synchronize', $unusedProperties);
        
        $usedProperties = variable_get('osf_entities_properties_to_synchronize', array());
        
        unset($usedProperties['used_properties_'.$bundle->type]);
        
        variable_set('osf_entities_properties_to_synchronize', $usedProperties);               
      }
    }          
    
    if(isset($_GET['destination']))
    {        
      drupal_goto($_GET['destination']);
    }
    else
    {
      if(isset($_GET['full_destination']))
      {
        drupal_goto('osf/entities/ontologies/sync/properties', array('query' => array('destination' => $_GET['full_destination'])));
      }
      else
      {
        drupal_goto('osf/entities/ontologies/sync/properties');
      }
    }    
  }    
}

function osf_entities_form_osf_entities_sync_structure_classes_alter(&$form, &$form_state, $form_id)
{
  $form['used_classes']['uclasses']['#process'][] = 'osf_entities_disable_element';
  $form['used_classes']['uclasses']['#process'][] = 'form_process_autocomplete';
  
  if(isset($form['#attached']['css']))
  {
    $form['#attached']['css'][] = drupal_get_path('module', 'osf_entities') . '/css/osf_entities.css';
  }
  else
  {
    $form['#attached']['css'] = array(
      drupal_get_path('module', 'osf_entities') . '/css/osf_entities.css',
    );  
  }
}

function osf_entities_form_osf_entities_sync_structure_properties_alter(&$form, &$form_state, $form_id)
{
  foreach($form as $key => $field)
  {
    if(isset($field['#type']) && $field['#type'] == 'fieldset')
    {
      foreach($field as $key2 => $value)
      {
        if(strpos($key2, 'used_properties_') !== FALSE && strpos($key2, 'unused_properties_') === FALSE)
        {
          $form[$key][$key2]['#process'][] = 'osf_entities_disable_element';
          $form[$key][$key2]['#process'][] = 'form_process_autocomplete';
        }
      }
    }
  }
  
  if(isset($form['#attached']['css']))
  {
    $form['#attached']['css'][] = drupal_get_path('module', 'osf_entities') . '/css/osf_entities.css';
  }
  else
  {
    $form['#attached']['css'] = array(
      drupal_get_path('module', 'osf_entities') . '/css/osf_entities.css',
    );  
  }  
}

function osf_entities_disable_element($element) {
  $expanded =  form_process_checkboxes($element);

  $namespaces = new Namespaces();

  foreach($expanded as $key => $field)
  {
    if($key == Namespaces::$iron.'prefLabel' ||
       $key == Namespaces::$iron.'description' ||
       $key == Namespaces::$owl.'Class' ||
       $key == Namespaces::$owl.'DatatypeProperty' ||
       $key == Namespaces::$owl.'AnnotationProperty' ||
       $key == Namespaces::$owl.'ObjectProperty' ||
       $key == Namespaces::$owl.'Thing')
    {
      $expanded[$key]['#disabled'] = TRUE;
      $expanded[$key]['#checked'] = TRUE;
      $expanded[$key]['#default_value'] = $expanded[$key]['#return_value'];       
    }
    
    if(isset($expanded[$key]['#type']) && $expanded[$key]['#type'] == 'checkbox')
    {
      if(isset($expanded[$key]['#title']))
      {
        if(arg(5) == 'expose' && $key == urldecode(arg(6)))
        {
          $expanded[$key]['#title'] = t('<span class="expose-item">'.$expanded[$key]['#title'].'</span> <b>(the class you are considering exposing)</b>');
        }
      }
      
      if(isset($expanded[$key]['#attributes']))
      {
        $expanded[$key]['#attributes']['title'] = $namespaces->getPrefixedUri($key);
        
      }
      else
      {
        $expanded[$key]['#attributes'] = array('title' => $namespaces->getPrefixedUri($key));
      }
    }
  }

  return($expanded);
}

function osf_entities_sync_structure_properties($form, &$form_state)
{  
  drupal_add_js("
    function checkUncheckAll(checkAllElement){
      var fieldsSet = jQuery(checkAllElement).parent().parent().find('input'), z = 0;
      for(z = 0; z < fieldsSet.length ; z++){
        if(fieldsSet[z].type == 'checkbox' && fieldsSet[z].name != 'checkall' && !fieldsSet[z].disabled){
          fieldsSet[z].checked = checkAllElement.checked;
        }
      }
    }
  ", 'inline');  
  
  // Get the list of all the classes used to define records in the OSF instance
  $networks = osf_configure_get_endpoints(NULL, FALSE, TRUE);

  $weight = 3;
  
  $classesByBundles = variable_get("osf_entities_classes_by_bundles", array());
  
  $dsets = osf_configure_dataset_load_util('all', FALSE);
      
  foreach($classesByBundles as $bundle => $class)
  {
    $form[$bundle] = array(
      '#type' => 'fieldset',
      '#title' => get_label_from_uri($class).'  ('.$bundle.')',
      '#description' => t('Select all the ontologies properties you would like to expose in Drupal as Fields. The following properties are the ones used to instantiate records in the OSF instance.'),
      '#collapsible' => TRUE,   
      '#collapsed' => TRUE,
      '#weight' => $weight++,
    ); 
    
    $properties = array();
    
    if($cache = cache_get('osf_entities_sync_properties_'.$bundle)) 
    {
      $properties = $cache->data;
    }
    else 
    {
      foreach($networks as $network)
      {            
        $defaultEndpoint = osf_configure_get_endpoint_by_uri($network->uri);
        
        $sparql = new SparqlQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());

        $datasets = array();

        foreach($dsets as $key => $dataset)      
        {
          if($dataset->endpoint->machine_name == $defaultEndpoint->machine_name)
          {
            $datasets[] = $dataset->uri; 
          }
        }         
        
        $from = '';
        
        foreach($datasets as $dataset)
        {
          $from .= 'from <'.$dataset.'> ';
        }

        $filterLabelProperties = '';
        
        foreach(Namespaces::getLabelProperties() as $labelProperty)
        {
          $filterLabelProperties .= '<'.$labelProperty.'>,';
        }
        
        $filterLabelProperties = rtrim($filterLabelProperties, ',');

        $sparql->mime("application/sparql-results+json")
               ->query('select ?property ?label
                        '.$from.'
                        where
                        {
                          {
                            select distinct ?property
                            where
                            {
                              ?s a <'.$class.'> ;
                                 ?property ?o .
                            }
                          }
                          
                          optional
                          {
                            ?property ?p ?label .

                            filter(str(?p) = "http://www.w3.org/2000/01/rdf-schema#label>" || str(?p) = "http://purl.org/ontology/iron#prefLabel" && (lang(?label) = "'.get_lang(get_default_language()).'" || lang(?label) = "")) .
                          }
                        }')
               ->send();    

        if(!$sparql->isSuccessful())
        {
          drupal_set_message(t("Can't get the list of properties describing this class (@class): [@error] @errorMsg - @errorDescription", 
                             array("@error" => $sparql->getStatus(),
                                   "@class" => $class,
                                   "@errorMsg" => $sparql->getStatusMessage(),
                                   "@errorDescription" => $sparql->getStatusMessageDescription())), 
                             "error", 
                             TRUE);
                             
          watchdog('osf_entities', 
                   'Can\'t get the list of properties describing this class (@class): [@error] @errorMsg - @errorDescription.', 
                   array("@error" => $sparql->getStatus(),
                         "@class" => $class,                   
                         "@errorMsg" => $sparql->getStatusMessage(),
                         "@errorDescription" => $sparql->getStatusMessageDescription()));                                                    
        }
        else
        { 
          // @Todo: cache the resultset.
          
          $results = json_decode($sparql->getResultset(), TRUE);    
          
          foreach($results['results']['bindings'] as $result)
          {
            $property = $result['property']['value'];
            $label = '';
            
            // Skip some core properties that shouldn't be modified using the drupal interface
            if($property == Namespaces::$rdf."type")
            {
              // We don't permit multi-typing in drupal
              continue;
            }
            
            if($property == Namespaces::$dcterms."isPartOf")
            {
              // We skip the core attribute that specify where the record is indexed in OSF
              continue;
            }               
            
            if(isset($result['label']))
            {
              $label = $result['label']['value'];
            }
            else
            {
              // Find the base URI of the ontology
              $pos = strripos($property, "#");

              if ($pos === FALSE)
              {
                $pos = strripos($property, "/");
              }

              if ($pos !== FALSE)
              {
                $pos++;
              }

              $label = substr($property, $pos);
            }
            
            $properties[$property] = $label;
          }
        }    
      }
      
      // Make sure that the prefLabel and description default properties are in that list.
      if(!isset($properties[Namespaces::$iron.'prefLabel']))
      {
        $properties[Namespaces::$iron.'prefLabel'] = 'preferred label';
      }
      
      if(!isset($properties[Namespaces::$iron.'description']))
      {
        $properties[Namespaces::$iron.'description'] = 'description';
      }

      asort($properties, SORT_STRING);
      
      // Cache these search queries to make sure that all subsequent Ajax calls doesn't take 
      // to much time to resolve.
      cache_set('osf_entities_sync_properties_'.$bundle, $properties, 'cache', CACHE_TEMPORARY); 
    }
    
    $default_values = variable_get('osf_entities_properties_to_synchronize', array());

    $form[$bundle]['checkall_'.$bundle] = array(
      '#type' => 'checkbox',
      '#title' => t('Select / Unselect all'),
      '#attributes' => array('onclick' => 'checkUncheckAll(this);'),
      '#weight' => -1,
    );    
    
    $unusedProperties = variable_get('osf_entities_unused_properties_to_synchronize', array()); 
    $usedProperties = variable_get('osf_entities_properties_to_synchronize', array());
    
    // For each used classes, check if it appears in the unused classes structure.
    // If it does, it means that the class was unused and is now used in the OSF
    // instance. This means we have to check that box in the series of used classes and
    // to remove it from the unused classes structure.
    
    $namespaces = new Namespaces();
    
    $tempUnusedProperties = array();
    
    foreach($unusedProperties as $unusedKey => $unusedValue)
    {
      if(strpos($unusedKey, $bundle.'_') !== FALSE &&
         !empty($unusedValue[0]))
      {
        $found = FALSE;
        foreach($properties as $usedUri => $usedLabel)
        {
          if(strpos($unusedValue[0], '('.$namespaces->getPrefixedUri($usedUri).')'))
          {
            // Check the checkbox of the used class
            $usedProperties['used_properties_'.$bundle][$usedUri] = $usedUri;
            
            $found = TRUE;
          }
        }
        
        if(!$found)
        {
          $tempUnusedProperties[] = $unusedValue[0];
        }

        unset($unusedProperties[$unusedKey]);
      }
    }
    
    // Re-introduce the unused properties that are not yet used for this bundle
    if(!empty($tempUnusedProperties))
    {
      foreach($tempUnusedProperties as $key => $value)
      {
        $unusedProperties[$bundle.'_'.$key] = array($value);
      }
    }

    // Save the potentially modified structures
    variable_set('osf_entities_unused_properties_to_synchronize', $unusedProperties); 
    variable_set('osf_entities_properties_to_synchronize', $usedProperties);    
    
    $form[$bundle]['used_properties_'.$bundle] = array(
      '#type' => 'checkboxes',
      '#title' => t('Used Properties'),
      '#options' => $properties,
      '#default_value' => (isset($default_values['used_properties_'.$bundle]) ? $default_values['used_properties_'.$bundle] : array()) + array(Namespaces::$iron.'prefLabel' => Namespaces::$iron.'prefLabel', Namespaces::$iron.'description' => Namespaces::$iron.'description'),
      '#weight' => $weight++,
    );    

    $form[$bundle]['unused_properties_'.$bundle] = array(
      '#type' => 'fieldset',
      '#title' => t('Select Unused Properties'),
      '#description' => t('Select all the ontologies properties you would like to expose in Drupal as Fields. 
                           The following properties are the not currently used to instantiate record
                           in the OSF instance.'),
      '#weight' => $weight++,
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
      
      // Set up the wrapper so that AJAX will be able to replace the fieldset.
      '#prefix' => '<div id="unusedproperties-fieldset-wrapper-'.str_replace('_', '-', $bundle).'">',
      '#suffix' => '</div>',    
    ); 
    
    if(empty($form_state['num_unusedproperties'])) 
    {
      $form_state['num_unusedproperties'] = array();
    }
    
    $unusedProperties = variable_get('osf_entities_unused_properties_to_synchronize', array());    
    
    if(empty($form_state['num_unusedproperties'][$bundle])) 
    {   
      $nb = 0;
      for ($i = 0; $i < 255; $i++) 
      {
        if(isset($unusedProperties[$bundle.'_'.$i]))
        {
          $nb++;
        }
        else
        {
          break;
        }
      }
      
      if($nb == 0)
      {
        $nb = 1;
      }
      
      $form_state['num_unusedproperties'][$bundle] = $nb;                                                 
    }

    for ($i = 0; $i < $form_state['num_unusedproperties'][$bundle]; $i++) 
    {
      $default_value = '';
      
      if(isset($form_state['input'][$bundle.'_'.$i]))
      {
        $default_value = $form_state['input'][$bundle.'_'.$i];
      }
      else
      {
        if(isset($unusedProperties[$bundle.'_'.$i]))
        {
          $default_value = $unusedProperties[$bundle.'_'.$i];
        }
      }
      
      $form[$bundle]['unused_properties_'.$bundle][$i] = array(
        '#type' => 'textfield',
        '#weight' => $weight++,
        '#default_value' => $default_value,
        '#autocomplete_path' => 'osf/entities/get/properties/'.$bundle,
        '#name' => $bundle.'_'.$i,
        '#id' => $bundle.'_'.$i,
        '#attributes' => array(
          'id' => $bundle.'_'.$i,
          // Fix the size of the input to make sure the throbber is properly displayed
          'style' => 'width: 80%',
          'onblur' => "if (this.value.indexOf('(') == -1 && this.value != '') {this.value = jQuery.data(this, 'previousdata')}",
          'onfocus' => "if (this.value != '') {jQuery.data(this, 'previousdata', this.value); var label = this.value.substring(0, this.value.indexOf('(') - 3); this.value = label;}"
        ),
      ); 
      
      if($i == 0)
      { 
        $form[$bundle]['unused_properties_'.$bundle][$i]['#title'] = t('Unused property');   
      }
    }
    
    $form[$bundle]['unused_properties_'.$bundle]['add_property_'.$bundle] = array(
      '#type' => 'submit',
      '#weight' => $weight++,
      '#name' => $bundle,
      '#value' => t('Add more'),
      '#submit' => array('osf_entities_unusedproperty_add_more'),

      // See the examples in ajax_example.module for more details on the
      // properties of #ajax.
      '#ajax' => array(
        'callback' => 'osf_entities_unusedproperty_add_more_callback',
        'wrapper' => 'unusedproperties-fieldset-wrapper-'.str_replace('_', '-', $bundle),
      ),
    );  
    
    if ($form_state['num_unusedproperties'][$bundle] > 1) 
    {
      $form[$bundle]['unused_properties_'.$bundle]['remove_property_'.$bundle] = array(
        '#type' => 'submit',
        '#weight' => $weight++,
        '#name' => $bundle,
        '#value' => t('Remove last'),
        '#submit' => array('osf_entities_unusedproperty_remove_last'),
        '#ajax' => array(
          'callback' => 'osf_entities_unusedproperty_remove_callback',
          'wrapper' => 'unusedproperties-fieldset-wrapper-'.str_replace('_', '-', $bundle),
        ),
      );
    }      
  }
  
  $form['sync'] = array(
    '#type' => 'submit',
    '#value' => t('Expose'),
    '#name' => 'sync',
    '#weight' => $weight++
  );                    
  
  $form['#attached']['js'] = array(
    drupal_get_path('module', 'osf_entities') . '/js/autocomplete.js'
  );  
  
  return($form);    
}

function _osf_entities_create_field_from_property($propertyUri)
{
  $propertyID = resource_type_get_id($propertyUri);

  // Make sure the field doesn't already exists           
  if(field_read_field($propertyID) === FALSE)
  {
    $defaultEndpoint = current(osf_configure_get_default_endpoint());
    
    $crudRead = new CrudReadQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());

    $crudRead->excludeLinksback()
             ->excludeReification()
             ->uri($propertyUri)
             ->send(new DrupalQuerierExtension());
                    
    if($crudRead->isSuccessful())
    {
      $propertySubject = $crudRead->getResultset()->getSubjectByUri($propertyUri);
      
      $propertiesByField = variable_get('osf_entities_properties_by_field', array(
          'iron_preflabel' => Namespaces::$iron.'prefLabel',
          'iron_description' => Namespaces::$iron.'description'
      ));
      
      $fieldType = $propertySubject->getDataPropertyValues('http://purl.org/ontology/drupal#fieldType');

      if(!empty($fieldType))
      {
        switch($fieldType[0]['uri'])
        {
          case 'http://purl.org/ontology/drupal#ListText':
            $fieldType = 'list_text';
          break;
          case 'http://purl.org/ontology/drupal#LongTextAndSummary':
            $fieldType = 'text_with_summary';
          break;
          case 'http://purl.org/ontology/drupal#LongText':
            $fieldType = 'text_long';
          break;
          case 'http://purl.org/ontology/drupal#Float':
            $fieldType = 'number_float';
          break;
          case 'http://purl.org/ontology/drupal#Integer':
            $fieldType = 'number_integer';
          break;
          case 'http://purl.org/ontology/drupal#Decimal':
            $fieldType = 'number_decimal';
          break;
          case 'http://purl.org/ontology/drupal#Boolean':
            $fieldType = 'list_boolean';
          break;
          case 'http://purl.org/ontology/drupal#Geolocation':
            if(module_exists('geolocation'))
            {
              $fieldType = 'geolocation_latlng';
            }
            else
            {
              $fieldType = 'text';
            }
          break;
          case 'http://purl.org/ontology/drupal#Link':
            if(module_exists('link'))
            {
              $fieldType = 'link_field';
            }
            else
            {
              $fieldType = 'text';
            }
          break;
          case 'http://purl.org/ontology/drupal#Image':
            if(module_exists('image'))
            {
              $fieldType = 'image';
            }
            else
            {
              $fieldType = 'text';
            }          
          break;
          case 'http://purl.org/ontology/drupal#File':
            if(module_exists('file'))
            {
              $fieldType = 'file';
            }
            else
            {
              $fieldType = 'text';
            }
          break;
          case 'http://purl.org/ontology/drupal#Date':
            if(module_exists('date'))
            {
              $fieldType = 'datetime';
            }
            else
            {
              $fieldType = 'text';
            }
          break;
          case 'http://purl.org/ontology/drupal#DateUnixTimestamp':
            if(module_exists('date'))
            {
              $fieldType = 'datestamp';
            }
            else
            {
              $fieldType = 'text';
            }
          break;
          case 'http://purl.org/ontology/drupal#DateISO':
            if(module_exists('date'))
            {
              $fieldType = 'date';
            }
            else
            {
              $fieldType = 'text';
            }
          break;
          case 'http://purl.org/ontology/drupal#Text':
            $fieldType = 'text';
          break;
          case 'http://purl.org/ontology/drupal#ListFloat':
            $fieldType = 'list_float';
          break;
          case 'http://purl.org/ontology/drupal#ListInteger':
            $fieldType = 'list_integer';
          break;
          
          default:
            $fieldType = 'text';
          break;
        }
      }
      else
      {
        $fieldType = 'text';
      }
      
      $propertiesByField[$propertyID] = $propertyUri;

      variable_set('osf_entities_properties_by_field', $propertiesByField);

      field_create_field(array(
        'field_name' => $propertyID,
        'type' => $fieldType,
        'cardinality' => FIELD_CARDINALITY_UNLIMITED,
        'entity_types' => array("resource"),
        'storage' => array(
          'type' => 'osf_entities',
          'settings' => array()
        ),
        'settings' => array(
          'max_length' => 64000, 
        )
      ));

      $propertiesObj = variable_get('osf_entities_properties', array());   

      $propertiesObj[$propertyUri] = serialize($propertySubject);

      variable_set('osf_entities_properties', $propertiesObj);      
    }
    else
    {
      watchdog('osf_entities', 
               'Can\'t find the property in OSF (@property): [@error] @errorMsg - @errorDescription.', 
               array("@error" => $crudRead->getStatus(),
                     "@property" => $propertyUri,                   
                     "@errorMsg" => $crudRead->getStatusMessage(),
                     "@errorDescription" => $crudRead->getStatusMessageDescription()));          
    }           
  }  
}

function _osf_entities_create_field_instance_by_property_class($property, $class)
{
  $field = resource_type_get_id($property);     
  $bundle = resource_type_get_id($class);        
  
  if(field_read_instance("resource", $field, $bundle) === FALSE && field_read_field($field) !== FALSE)
  {
    $properties = variable_get('osf_entities_properties', array());  

    $property = unserialize($properties[$property]);
    
    if(!$property)
    {
      return;
    }

    $fieldWidget = array();
    
    if(array_search(Namespaces::$owl.'ObjectProperty', $property->getTypes()) !== FALSE)
    {
      $fieldWidget = array('widget' => array('type' => 'osf_field_entity_reference'));
    }
        
    if($property->getUri() == Namespaces::$geo.'lat' || $property->getUri() == Namespaces::$geo.'long')
    {
      $fieldWidget = array('widget' => array('type' => 'geolocation_googlemap'));
    }
    
    field_create_instance(array(
      'field_name' => $field,
      'entity_type' => "resource",
      'bundle' => $bundle,
      'label' => t($property->getPrefLabel()),
      'description' => t($property->getDescription()),
    ) + $fieldWidget);          
  }
  else
  {
    if(field_read_field($field) === FALSE)
    {
      drupal_set_message(t("The property <b>@property</b> is currently being used to describe information in the 
                            OSF instance, but it is not currently defined in any ontology. <a href=\"/admin/structure/resource-types/manage/".$bundle."/fields/add-new?uri=".urlencode($property)."\">
                            You can create this new property in an ontology by using this form</a>. This property
                            won't appear in the field of the <b>@bundle</b> bundle until it got created in an ontology.", 
                         array("@property" => $property,
                               "@bundle" => $bundle)), 
                         "error", 
                         TRUE);      
    }
  }  
}

function osf_entities_sync_structure_properties_validate($form, &$form_state) {
  if($form_state['clicked_button']['#parents']['0'] == "sync")
  {
    set_time_limit(2600);
    
    $classesByBundles = variable_get("osf_entities_classes_by_bundles", array());
    
    $usedProperties = array();
    $unusedProperties = array();
    
    foreach($classesByBundles as $bundle => $class)
    {
      // Save used properties
      $usedProperties['used_properties_'.$bundle] = $form_state['values']['used_properties_'.$bundle];
      
      // Save un-used properties
      for($i = 0; $i < 255; $i++)
      {
        if(isset($form_state['input'][$bundle.'_'.$i]))
        {
          $unusedProperties[$bundle.'_'.$i][] = $form_state['input'][$bundle.'_'.$i];
        }
        else
        {
          break;
        }
      }
    } 

    // Create an array with all the used/un-used properties to use for creating the fields
    $properties = array();
    
    foreach($usedProperties as $bundle => $props)
    {
      foreach($props as $prop)
      {
        if(!empty($prop))
        {
          $properties[] = $prop;
        }
      }
    }
    
    $namespaces = new Namespaces();
    foreach($unusedProperties as $props)
    {
      foreach($props as $prop)
      {
        if(!empty($prop))
        {
          $p = substr($prop, strpos($prop, '(') + 1, strpos($prop, ')') - (strpos($prop, '(') + 1));
          
          $properties[] = $namespaces->getUnprefixedUri($p);
        }
      }
    }
    
    $properties = array_unique($properties);

    $propertiesByField = array();
    
    // Pre-populate the strucentities_properties_by_field before doing anything else.
    // This is essential for the good functionning of the rdf_mapping we generated
    // later in the process.    
    variable_del('osf_entities_properties_by_field');
    $propertiesByField = array(
      'iron_preflabel' => Namespaces::$iron.'prefLabel',
      'iron_description' => Namespaces::$iron.'description'
    );
    
    foreach($properties as $property)
    {
      $propertyID = resource_type_get_id($property);

      $propertiesByField[$propertyID] = $property;
    }                                      
    
    variable_set('osf_entities_properties_by_field', $propertiesByField);
    
    // Create a field (if not already existing) for each of these properties
    // Create a field for each property used in OSF
    
    foreach($properties as $property)
    {
      _osf_entities_create_field_from_property($property);
    }                                      
    
    // Create the instances of the fields per bundle
    foreach($usedProperties as $bundle => $props)
    {
      foreach($props as $prop)
      {
        if(!empty($prop))
        {    
          _osf_entities_create_field_instance_by_property_class($prop, $classesByBundles[str_replace('used_properties_', '', $bundle)]);
        }
      }
    }
    
    $namespaces = new Namespaces();
    foreach($unusedProperties as $fieldID => $props)
    {
      foreach($props as $prop)
      {
        if(!empty($prop))
        {
          
          $prop = $namespaces->getUnprefixedUri(substr($prop, strpos($prop, '(') + 1, strpos($prop, ')') - (strpos($prop, '(') + 1)));

          $bundle = substr($fieldID, 0, strrpos($fieldID, '_'));
          
          _osf_entities_create_field_instance_by_property_class($prop, $classesByBundles[$bundle]);          
        }
      }
    }
    
    // Clean left over fields and fields instances
    $fields = field_read_fields(array('storage_type' => 'osf_entities'));

    foreach($fields as $name => $field)
    {
      if(!isset($propertiesByField[$name]))
      {
        // Delete field & its instances
        field_delete_field($name);        
      }
    }
    
    foreach($classesByBundles as $bundle => $class)
    {
      $instances = field_read_instances(array('bundle' => $bundle));
      
      // Check if that instance is still used in the bundle
      foreach($instances as $instance)
      {
        if(!isset($instance['field_name']))
        {
          continue;
        }          
        
        $found = FALSE;
        
        // checking within used properties
        foreach($usedProperties['used_properties_'.$bundle] as $property)
        {
          if(!empty($property) && ($property == $propertiesByField[$instance['field_name']]))
          {
            $found = TRUE;
          }
        }

        if(!$found)
        {
          // checking within the unused properties
          foreach($unusedProperties as $uPropField => $prop)
          {                        
            if(strpos($uPropField, $instance['bundle']) !== FALSE && !empty($prop))
            {
              $prop = $prop[0];
              
              $property = $namespaces->getUnprefixedUri(substr($prop, strpos($prop, '(') + 1, strpos($prop, ')') - (strpos($prop, '(') + 1)));
              
              if($property == $propertiesByField[$instance['field_name']])
              {
                $found = TRUE;
              }
            }
          }
        }     
        
        if(!$found)
        {
          field_delete_instance($instance);
        }   
      }
    }    
    
    field_purge_batch(512);
    
    // Create all the rdf mappings that will be saved in the {rdf_mapping} table
    foreach(osf_entities_get_rdf_mappings() as $mapping)
    {
      rdf_mapping_save($mapping);  
    }
    
    // Clear the cache_entity_resource_type cache bin
    cache_clear_all('*', 'cache_entity_resource_type', TRUE);
       
    // Save selected used properties
    variable_set('osf_entities_properties_to_synchronize', $usedProperties);
    
    // Save define un-used properties
    variable_set('osf_entities_unused_properties_to_synchronize', $unusedProperties);  
    
    if(isset($_GET['destination']))
    {
      drupal_goto($_GET['destination']);
    }
    else
    {
      drupal_goto('admin/config/osf/entities');
    }
  }
}


/**
* Callback function to handle the autocompletion action performed
* by the resource-type forms. This will return a list of entity
* references that can be used to relate entities to other kind
* of entities.
*/
function osf_entities_resources_references_autocomplete($range, $query)
{ 
  $query = trim($query);
  $range = urldecode($range);
  
  $networks = osf_configure_get_endpoints(NULL, FALSE, TRUE);

  $suggestions = array();
  
  foreach($networks as $network)
  {
    $defaultEndpoint = osf_configure_get_endpoint_by_uri($network->uri);
    
    $search = new SearchQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
    
    if($query == '')
    {
      $search->excludeAggregates()
             ->items(15)
             ->sort('preflabel', 'asc')
             ->enableInference()
             ->attributeValuesFilters(Namespaces::$iron.'prefLabel', '*');
    }
    else
    {
      $search->excludeAggregates()
             ->items(15)
             ->sort('preflabel', 'asc')
             ->enableInference()
             ->attributeValuesFilters(Namespaces::$iron.'prefLabel', '*'.$query.'**');
    }
           
    if($range != "" && $range != Namespaces::$owl."Thing")
    {
      $search->typeFilter($range);
    }
    
    $search->sourceInterface(variable_get("osf_searchapi_settings_interface_name", ''))
           ->send(new DrupalQuerierExtension());
    
    if(!$search->isSuccessful())
    {
      watchdog('osf_entities', 
               'Can\'t get the list of things to autocomplete: [@error] @errorMsg - @errorDescription.', 
               array("@error" => $search->getStatus(),                 
                     "@errorMsg" => $search->getStatusMessage(),
                     "@errorDescription" => $search->getStatusMessageDescription()));                       
                         
    }
    else
    {
      $resultset = $search->getResultset();
      
      $namespaces = new Namespaces();
      
      if(isset($resultset))
      {
        foreach($resultset->getResultset() as $dataset => $results)
        {
          foreach($results as $uri => $result)
          {
            $suggestions[$result['prefLabel'].'   ('.$namespaces->getPrefixedUri($uri).')'] = '<b>'.$result['prefLabel'].'</b>   <em>('.$namespaces->getPrefixedUri($uri).')</em>';
          }
        }
      }  
    }  
    
    // We we got more than 10 results, we stop querying for more networks
    if(count($suggestions) > 10)
    {
      break;
    }
  }
  
  if(module_exists('autocomplete_deluxe'))
  {
    // Prevent the "@ will be added..." behavior of this module.
    if(empty($suggestions))
    {
      $suggestions["none"] = "";
    }
  }
  
  drupal_json_output($suggestions);
}

/**
* Callback function to handle the autocompletion action performed
* by the resource-type forms. This will return a list of text
* values currently used by other records that uses this 
* property
*/
function osf_entities_resources_text_autocomplete($property, $query)
{
  $property = urldecode($property);
                      
  if(array_search($property, Namespaces::getLabelProperties()) !== FALSE)
  {
    $property = 'prefLabel';
  }
  
  if(array_search($property, Namespaces::getDescriptionProperties()) !== FALSE)
  {
    $property = 'description';
  }
  
  $networks = osf_configure_get_endpoints(NULL, FALSE, TRUE);

  $suggestions = array();
  
  foreach($networks as $network)
  {
    $defaultEndpoint = osf_configure_get_endpoint_by_uri($network->uri);
    
    $search = new SearchQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
    
    $labelProperties = Namespaces::getLabelProperties();

    if($query == '')
    {
      $search->excludeAggregates()
             ->sort('prefLabel', 'asc')
             ->items(15)
             ->attributeValuesFilters($property, '*');
    }
    else
    {
      $search->excludeAggregates()
             ->sort('prefLabel', 'asc')
             ->items(15)
             ->attributeValuesFilters($property, '*'.$query.'**');
    }
    
    $search->sourceInterface(variable_get("osf_searchapi_settings_interface_name", ''))
           ->send(new DrupalQuerierExtension());

    if(!$search->isSuccessful())
    {
      watchdog('osf_entities', 
               'Can\'t get the list of things to autocomplete: [@error] @errorMsg - @errorDescription.', 
               array("@error" => $search->getStatus(),                 
                     "@errorMsg" => $search->getStatusMessage(),
                     "@errorDescription" => $search->getStatusMessageDescription()));                       
                         
    }
    else
    {           
      $resultset = $search->getResultset();
      if(isset($resultset))
      {
        foreach($resultset->getResultset() as $dataset => $results)
        {
          foreach($results as $uri => $result)
          {
            if($property == 'prefLabel')
            {
              $val = $result[$property];
              $suggestions[$val] = $val;
            }
            else
            {
              $val = $result[$property][0]['value'];
              $suggestions[$val] = $val;
            }
          }
        }
      }
    }
        
    // We we got more than 10 results, we stop querying for more networks
    if(count($suggestions) > 10)
    {
      break;
    }    
  }
  
  drupal_json_output($suggestions);
}

/**
* Callback function to handle the autocompletion action performed
* to get the list of all available classes defined in the loaded
* ontologies.
*/
function osf_entities_classes_autocomplete($mode, $query)
{
  $networks = osf_configure_get_endpoints(NULL, FALSE, TRUE);
  
  $suggestions = array();
  
  $ontologies = variable_get('osf_osf_entities_ontologies_selected', array());
  
  $ontologiesFilters = array();
  
  foreach($ontologies as $ontology)
  {
    if($ontology != NULL)
    {
      array_push($ontologiesFilters, $ontology);
    }
  }

  $usedClasses = variable_get('osf_entities_used_classes', array());
  
  foreach($networks as $network)
  {
    $defaultEndpoint = osf_configure_get_endpoint_by_uri($network->uri);
    
    $search = new SearchQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
    
    if($query == '')
    {
      $search->excludeAggregates()
             ->sort('prefLabel', 'asc')
             ->items(15)
             ->attributeValuesFilters(Namespaces::$iron.'prefLabel', '*');
    }
    else
    {
      $search->excludeAggregates()
             ->sort('prefLabel', 'asc')
             ->items(15)
             ->attributeValuesFilters(Namespaces::$iron.'prefLabel', '*'.$query.'**');
    }
    
    // Make sure we exclude all the used classes from the returned results
    
    if($mode == 'exclude_used')
    {
      $extendedFiltersBuilder = new ExtendedFiltersBuilder();
      
      foreach($usedClasses as $key => $class)
      {
        if($key == 0)
        {
          $extendedFiltersBuilder->not_();  
        }
        else
        {
          $extendedFiltersBuilder->and_()
                                 ->not_();
        }
        
        $extendedFiltersBuilder->attributeValueFilter("uri", '"'.$class.'"', FALSE);
      }
    }
    
    $search->datasetsFilters($ontologiesFilters);
    
    if($mode == 'exclude_used')
    {
      $search->extendedFilters($extendedFiltersBuilder->getExtendedFilters());
    }
           
    $search->typeFilter(Namespaces::$owl.'Class')
           ->sourceInterface(variable_get("osf_searchapi_settings_interface_name", ''))
           ->send(new DrupalQuerierExtension());

    if(!$search->isSuccessful())
    {
      watchdog('osf_entities', 
               'Can\'t get the list of things to autocomplete: [@error] @errorMsg - @errorDescription.', 
               array("@error" => $search->getStatus(),                 
                     "@errorMsg" => $search->getStatusMessage(),
                     "@errorDescription" => $search->getStatusMessageDescription()));                       
                         
    }
    else
    {           
      $resultset = $search->getResultset();
     
      $namespaces = new Namespaces();
     
      if(isset($resultset))
      {
        foreach($resultset->getResultset() as $dataset => $results)
        {
          foreach($results as $uri => $result)
          {
            $suggestions[$result['prefLabel'] . '   ('.$namespaces->getPrefixedUri($uri).')'] = '<b>'.$result['prefLabel'] . '</b>   <em>('.$namespaces->getPrefixedUri($uri).')</em>';
          }
        }
      }
      
      // We we got more than 10 results, we stop querying for more networks
      if(count($suggestions) > 10)
      {
        break;
      } 
    }   
  }

  drupal_json_output($suggestions);       
}

/**
* Callback function to handle the autocompletion action performed
* to get the list of all available properties defined in the loaded
* ontologies.
*/
function osf_entities_properties_autocomplete($bundle, $query)
{
  // Get all the super classes of the target class
  $classesByBundles = variable_get("osf_entities_classes_by_bundles", array());

  $class = entity_load('resource_type', array($classesByBundles[$bundle]));
  
  $class = current($class);

  $defaultEndpoint = current(osf_configure_get_default_endpoint());
  
  $ontologyRead = new OntologyReadQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
  
  $getSuperClasses = new GetSuperClassesFunction();
  
  $getSuperClasses->allSuperClasses()
                  ->getClassesUris()
                  ->uri($class->uri);    
  
  $ontologyRead->getSuperClasses($getSuperClasses)
               ->ontology($class->dataset)
               ->enableReasoner()
               ->send(new DrupalQuerierExtension());  
  
  if($ontologyRead->isSuccessful())
  {
    $resultset = $ontologyRead->getResultset()->getResultset();
  }
  
  $classes = array($class->uri);
  
  foreach($resultset['unspecified'] as $uri => $c)
  {
    $classes[] = $uri;
  }

  // Find all the classes that have one of the inferred classes in their domain.
  // Note: all the classes should have a domain defined otherwise they will be ignored
  //       since we cannot returned records in Solr that doesn't have a field.  
  $search = new SearchQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_first_user_uri());
  
  $extendedSearch = new ExtendedFiltersBuilder();

  foreach($classes as $nb => $uri)
  {
    if($nb > 0)
    {
      $extendedSearch->or_();
    }
    
    $extendedSearch->attributeValueFilter('http://www.w3.org/2000/01/rdf-schema#domain', $uri, TRUE);
  }  
  
  $search->extendedFilters($extendedSearch->getExtendedFilters())
         ->attributeValuesFilters(Namespaces::$iron.'prefLabel', '*'.$query.'**')
         ->excludeAggregates()
         ->sourceInterface(variable_get("osf_searchapi_settings_interface_name", ''))
         ->mime('resultset')
         ->send(new DrupalQuerierExtension());        
         
  $properties = array();
       
  if($search->isSuccessful())
  {
    $resultset = $search->getResultset()->getResultset();
    
    foreach($resultset as $ontology => $predicates)
    {
      foreach($predicates as $uri => $property)
      {
        $properties[$uri] = $property['prefLabel'];
      }
    }
  }   
    
  $usedProperties = array();
  
  if($cache = cache_get('osf_entities_sync_properties_'.$bundle)) 
  {
    $usedProperties = array_keys($cache->data);
  }  

  $suggestions = array();  
  
  $namespaces = new Namespaces();
  
  $nbFound = 0;
  foreach($properties as $uri => $label)
  {
    if(($query == "" || stripos($label, $query) !== FALSE) && 
       array_search($uri, $usedProperties) === FALSE &&
       $uri != Namespaces::$rdf.'type')
    {
      $suggestions[$label . '   ('.$namespaces->getPrefixedUri($uri).')'] = '<b>'. $label . '</b>   <em>('.$namespaces->getPrefixedUri($uri).')</em>';
        
      $nbFound++;
      
      if($nbFound == 15)
      {
        break;
      }
    }    
  }
  
  asort($suggestions, SORT_STRING);
  
  drupal_json_output($suggestions);    
}

/**
* Load the entity related to a DRID (Drupal Resource ID)
*/
function drid_load($drid)
{
 
  // Check if the DRID is actually a URI
  // If it is, then we create a DRID from it and we redirect
  // the user to the drupal page using the generated DRID
  if(osf_entities_is_valid_iri(urldecode($drid)))
  { 
    $drid = osf_entities_get_drid_from_uri(urldecode($drid));
    
    drupal_goto('resources/'.$drid);
  }
  
  $uri = osf_entities_get_uri_from_drid($drid);

  if(!$uri)
  {
    // If the URI is FALSE, it means that there is currently no DRID for that URI.
    // What we do in this case, is to direct the user to the /admin/resource/add
    // page where they will be able to create a resource for that page

    drupal_goto('admin/resource/add/'.$drid);
  }

  // If there is a valid DRID, then we simply return the entity that will get
  // themed and displayed to the user down the pipe
  return(entity_load('resource_type', array($uri)));
}

/**
 * @brief Check if a string is a valid IRI
 * 
 * @param $iri String to check if it is a valid IRI or not
 * 
 * @return TRUE if the input string is a valid IRI, FALSE otherwise
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 */
function osf_entities_is_valid_iri($iri)
{
  return((bool) preg_match('/^[a-z](?:[-a-z0-9\+\.])*:(?:\/\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&\'\(\)\*\+,;=:])*@)?(?:\[(?:(?:(?:[0-9a-f]{1,4}:){6}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|::(?:[0-9a-f]{1,4}:){5}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:[0-9a-f]{1,4}:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3})|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|v[0-9a-f]+[-a-z0-9\._~!\$&\'\(\)\*\+,;=:]+)\]|(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\.(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])){3}|(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&\'\(\)\*\+,;=@])*)(?::[0-9]*)?(?:\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&\'\(\)\*\+,;=:@]))*)*|\/(?:(?:(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&\'\(\)\*\+,;=:@]))+)(?:\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&\'\(\)\*\+,;=:@]))*)*)?|(?:(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&\'\(\)\*\+,;=:@]))+)(?:\/(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&\'\(\)\*\+,;=:@]))*)*|(?!(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&\'\(\)\*\+,;=:@])))(?:\?(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&\'\(\)\*\+,;=:@])|[\x{E000}-\x{F8FF}\x{F0000}-\x{FFFFD}|\x{100000}-\x{10FFFD}\/\?])*)?(?:\#(?:(?:%[0-9a-f][0-9a-f]|[-a-z0-9\._~\x{A0}-\x{D7FF}\x{F900}-\x{FDCF}\x{FDF0}-\x{FFEF}\x{10000}-\x{1FFFD}\x{20000}-\x{2FFFD}\x{30000}-\x{3FFFD}\x{40000}-\x{4FFFD}\x{50000}-\x{5FFFD}\x{60000}-\x{6FFFD}\x{70000}-\x{7FFFD}\x{80000}-\x{8FFFD}\x{90000}-\x{9FFFD}\x{A0000}-\x{AFFFD}\x{B0000}-\x{BFFFD}\x{C0000}-\x{CFFFD}\x{D0000}-\x{DFFFD}\x{E1000}-\x{EFFFD}!\$&\'\(\)\*\+,;=:@])|[\/\?])*)?$/iu', $iri));
}

/**
 * @brief OSF Entities settings page
 * 
 * @note This procedure has been registered to Drupal in the osf_menu() procedure.
 * 
 * @return A form object where all the settings have been defined.
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 * 
 * @see http://drupal.org/node/206761
 * @see http://drupal.org/node/37775
 */
function osf_entities_settings() {
  
  $form['synchronization'] = array(
    '#type' => 'fieldset',
    '#title' => t('Expose Entities'),
    '#description' => t('These options let you expose the ontologies structures 
                         used to describe the content of your OSF instance into Drupal
                         as Entities and Fields. That way, you will be able to manipulate
                         the OSF records instances with the Drupal core API related
                         to these Entities and Fields.
                         
                         <br /><br />
                         
                         The <strong>Select Ontologies</strong> button is used to 
                         select all the ontologies you want to use in the exposition
                         process.
                         
                         <br /><br />
                         
                         The <strong>Expose Entities</strong> button
                         is used to select all the classes and properties that you want 
                         to expose as Bundles and Fields in Drupal.
                         
                         <br /><br />'),
    '#weight' => 3,
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );    

  $form['synchronization']['osf_entities_select_ontologies_button'] = array(
    '#type' => 'button', 
    '#value' => t('Select Ontologies'),
  );
  
  $form['synchronization']['osf_entities_sync_structure_button'] = array(
    '#type' => 'button', 
    '#value' => t('Expose Entities'),
  );
  
  $form['manage_namespaces'] = array(
    '#type' => 'fieldset',
    '#title' => t('Manage Namespaces'),
    '#description' => t('This setting let you manage the RDF namespaces used in Drupal. These are used, and are
                         accessible to all the modules that understand the code Drupal RDF API. These namespaces
                         are used to create the machine name of the Bundles and Fields that got synchronized,
                         but also within the generated Drupal page, etc.
                         
                         <br /><br />'),
    '#weight' => 4,
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );      

  $form['manage_namespaces']["osf_entities_sync_manage_namespaces"] = array(
    '#type' => 'button', 
    '#value' => t('Manage RDF Namespaces'),
  );

  $form['entities_settings'] = array(
    '#type' => 'fieldset',
    '#title' => t('Entities Settings'),
    '#description' => t('These settings let you define different behaviors of the entities
                         that got exposed.
                         
                         <br /><br />'),
    '#weight' => 5,
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );    
  
  $form['entities_settings']['osf_entities_enable_resource_edit_datatype_property_autocompletion'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable autocompletion fields for datatype properties values'),
    '#description' => t(
    "This option will enable autocompletion for all the datatype properties values. This means that when a user will click in a datatype property input text box, he will be prompted with a series of values that are currently being used in the registered OSF networks. If the user continues to type a value, the autocompletion feature of the input text field will continue to suggest new textual values currently being used."),
    '#default_value' => variable_get('osf_entities_enable_resource_edit_datatype_property_autocompletion', 0),
  );    
  
  return system_settings_form($form);
}


/** 
 * @brief Validate access settings
 * 
 * @param[in] $form Form to validate
 * @param[out] $form_state
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 * 
 * @see http://drupal.org/node/206761
 * @see http://drupal.org/node/37775
 */
function osf_entities_settings_validate($form, &$form_state) {
  
  // We synchronize the structure
  if($form_state['clicked_button']['#parents']['0'] == "osf_entities_sync_structure_button")
  {
    drupal_goto('osf/entities/ontologies/sync/classes');
  }
  
  if($form_state['clicked_button']['#parents']['0'] == "osf_entities_select_ontologies_button")
  {
    drupal_goto('osf/entities/ontologies/select');
  }  
  
  if($form_state['clicked_button']['#parents']['0'] == "osf_entities_sync_manage_namespaces")
  {
    drupal_goto('osf/entities/namespaces');
  }  
}

/**
 * Implements hook_field_storage_query().
 *
 * Execute an EntityFieldQuery.
 */
function osf_entities_field_storage_query($query) {}

/**
* Get the an ID reference used by the Resource Type entities
* from the URI of a class or a property. URIs are converted
* to Resource Type Entity ID by using the prefix representing
* a URI followed by an underscore and then the ending of the
* URI. All IDs are lowercase.
* 
* Example: the URI "http://xmlns.com/foaf/0.1/Person" becomes
*          foaf_person
* 
* @param mixed $uri URI of a class (bundle) or property (field)
* @return a bundle or field ID reference
*/
function resource_type_get_id($uri)
{
  $namespaces = new Namespaces();
  
  return(substr(strtolower(preg_replace("/[^a-zA-Z0-9]/", "_", $namespaces->getPrefixedUri($uri))), 0, 32));
}

/**
 * Implements hook_flush_caches().
 */
function osf_entities_flush_caches() {
  $tables = array();
  
  $tables[] = 'cache_entity_resource_type';
  
  return($tables);
}

/**
* Get an array of rdf mappings arrays. This list is used by rdf_mapping_CRUD() API.
*/
function osf_entities_get_rdf_mappings() {
  $fieldsByBundles = osf_entities_get_fields_by_bundles();
  $classesByBundles = variable_get("osf_entities_classes_by_bundles", NULL);
  $propertiesByFields = variable_get("osf_entities_properties_by_field", NULL);
  $properties = variable_get("osf_entities_properties", NULL);

  $mappings = array();  
  
  $namespaces = new Namespaces();
  
  if(!is_null($fieldsByBundles))
  {
    foreach($fieldsByBundles as $bundle => $fields) 
    {
      $bundle_mapping = array(
        'type' => 'resource',
        'bundle' => $bundle,
        'mapping' => array(
          'rdftype' => array($namespaces->getPrefixedUri($classesByBundles[$bundle]))
        )
      );
      
      foreach($fields as $field)
      {
        $isObjectProperty = FALSE;
        
        if(isset($propertiesByFields[$field]) && isset($properties[$propertiesByFields[$field]]))
        {
          if(isset($propertiesByFields[$field]))
          {
            $property = unserialize($properties[$propertiesByFields[$field]]);
            
            if($property)
            {
              foreach($property->getTypes() as $type)
              {
                if($type == Namespaces::$owl."ObjectProperty")
                {
                  $isObjectProperty = TRUE;
                  break;
                }
              }
            }
          }
        }
        
        if($isObjectProperty)
        {
          if(isset($propertiesByFields[$field]))
          {
            $bundle_mapping['mapping'][$field] = array(
              'predicates' => array($namespaces->getPrefixedUri($propertiesByFields[$field])),
              'type' => "rel"
            );
          }
        }
        else
        {         
          if(isset($propertiesByFields[$field]))
          {
            $bundle_mapping['mapping'][$field] = array(
              'predicates' => array($namespaces->getPrefixedUri($propertiesByFields[$field]))
            );
          }
        }
      }
      
      // Add some Drupal core fields to be mapped to RDF
      
      // label
      $bundle_mapping['mapping']['label'] = array(
        'predicates' => array('iron:prefLabel')
      );      
      
      $mappings[$bundle] = $bundle_mapping;
    }  
  }
  
  return($mappings); 
}

/**
* Implements hook_rdf_namespaces() 
*/
function osf_entities_rdf_namespaces()
{
  // We return all the prefixes/base-URIs that are defined in the Namespaces.php class
  return(Namespaces::getNamespaces());  
}

/**
* This creates the user interface to manage the namespaces needed by OSF for Drupal
*/
function osf_entities_manage_namespaces()
{
  $coreNamespaces = get_class_vars('\StructuredDynamics\osf\framework\Namespaces');
  
  $html = "";

  if (!empty($_GET["action"]) && $_GET["action"] == "add") {
    
    $namespacesCsvFile = $_SERVER['DOCUMENT_ROOT'].base_path().libraries_get_path('OSF-WS-PHP-API')."/StructuredDynamics/osf/framework/namespaces.csv";
    
    $prefix = $_GET["prefix"];
    $uri = $_GET["uri"];
    
    $namespaces = file_get_contents($namespacesCsvFile);
    
    $namespaces = "$prefix,$uri\n".$namespaces;
    
    file_put_contents($namespacesCsvFile, $namespaces);
        
  } elseif (!empty($_GET["action"]) && $_GET["action"] == "delete") {
    
    $namespacesCsvFile = $_SERVER['DOCUMENT_ROOT'].base_path().libraries_get_path('OSF-WS-PHP-API')."/StructuredDynamics/osf/framework/namespaces.csv";
    
    $prefix = $_GET["prefix"];
    $uri = $_GET["uri"];
    
    $namespaces = file_get_contents($namespacesCsvFile);
    
    if($namespaces)
    {        
      $namespaces = preg_replace('/^[\s]*'.str_replace('/', '\/', preg_quote($prefix)).'[\s]*,[\s]*'.str_replace('/', '\/', preg_quote($uri)).'[\s\r\n\t]*/im', "", $namespaces);
    }    
    
    file_put_contents($namespacesCsvFile, $namespaces);
  }

  $html .= "<h2>" . t("List of all custom namespaces used by OSF for Drupal") . "</h2>\n";

  $html .= "<br />\n";
  $html .= "<table>\n";
  $html .= "<tr>";
  $html .= "  <td><b>".t('prefix')."</b></td> <td><b>".t('URI')."</b></td> <td><b>".t('action')."</b></td>\n";
  $html .= "</tr>";
  
  $namespaces = Namespaces::getNamespaces();
 
  ksort($namespaces);
  
  $coreNsHtml = "";
  
  foreach($namespaces as $prefix => $uri)
  {
    $action = "";
    
    if(isset($coreNamespaces[$prefix]))
    {
      $coreNsHtml .= "<tr>";
      $coreNsHtml .= "  <td><b>$prefix</b></td> <td>$uri</td>\n";
      $coreNsHtml .= "</tr>";
    }
    else
    {
      $html .= "<tr>";
      $html .= "  <td><b>$prefix</b></td> <td>$uri</td> <td><a href=\"?action=delete&prefix=".urlencode($prefix)."&uri=" . urlencode($uri) . "\">".t('delete')."</a></td>\n";
      $html .= "</tr>";
    }
  }

  $html .= "</table>\n";
  
  $html .= "<h2>" . t("List of all core namespaces used by OSF for Drupal") . "</h2>\n";
  $html .= "<h4>" . t("<em>Note: these can't be deleted</em>") . "</h4>\n";
  
  $html .= "<table>$coreNsHtml</table>";
  

  $html .= "

    <br /><br /><br />

    <strong>".t('Add a new namespace:')."</strong>

    <form action=\"\" method=\"get\">

      <table>
        <tr>
          <td><b>".t('Prefix:')."</b></td>
          <td><input class=\"form-text\" name=\"prefix\" type=\"text\" size=\"30\" style=\"width:98%\" /></td>
        </tr>
        <tr>
          <td><b>".t('URI:')."</b></td>
          <td><input class=\"form-text\" name=\"uri\" type=\"text\" size=\"30\" style=\"width:98%\" /></td>
        </tr>
        <tr>
          <td colspan=\"2\"><center><input class=\"form-submit\" type=\"submit\" value=\"" . t("Add namespace") . "\" /></center></td>
        </tr>
      </table>

      <input name=\"action\" type=\"hidden\" value=\"add\" />
    </form>

  ";  

  return($html);  
}

function osf_entities_form_field_ui_field_overview_form_alter(&$form, &$form_state, $form_id)
{
  if(strpos(drupal_get_path_alias(), 'resource-types/manage'))
  {
    unset($form['fields']['_add_new_field']);
    unset($form['fields']['_add_existing_field']);
    
    foreach($form['fields'] as $fieldID => $field)
    {
      if(strpos($fieldID, '#') === FALSE)
      {
        /*
        $form['fields'][$fieldID]['delete']['#href'] = 'osf/entities/ontologies/sync/properties';
        $form['fields'][$fieldID]['delete']['#options']['query'] = array('destination' => drupal_get_path_alias());
        $form['fields'][$fieldID]['delete']['#title'] = 'organize';
        $form['fields'][$fieldID]['delete']['#options']['attributes']['title'] = 'Delete/Add fields for this Bundle';
        */
        unset($form['fields'][$fieldID]['delete']);        
      }
    }
    
    if(isset($form['fields']['#regions']['main']['message']) && 
       $form['fields']['#regions']['main']['message'] == 'No fields are present yet.')
    {
      $form['fields']['#regions']['main']['message'] = '<a href="/osf/entities/ontologies/sync/properties?destination='.drupal_get_path_alias().'">'.t('Add new fields for that bundle').'</a>';
    }
  }
}

/**
* Alter the resource_type_overview_form form to add the "ignore" tags for the ignored bundles by
* OSF for Drupal.
*/
function osf_entities_form_resource_type_overview_form_alter(&$form, &$form_state, $form_id)
{     
  // This could have been performed in "EntityDefaultUIController::overviewTableRow" as well
  foreach($form['table']['#rows'] as $row_key => $form_row)
  {
    // Mark as "ignored" into the list of resource_type
    $isIgnored = db_query('SELECT ignoreResource FROM {resource_type} WHERE type = :type LIMIT 1', array(':type' => $form['table']['#rows'][$row_key][0]['data']['#name']))->fetchField();

    if($isIgnored)
    {
      $form['table']['#rows'][$row_key][0]['data']['#label'] = "Ignored - ".$form['table']['#rows'][$row_key][0]['data']['#label'];
    }
    
    // Fix operations
    $nbOperationsRemoved = 0;
    foreach($form_row as $num => $value)
    {
      // Remove Export
      if((!is_array($value) && stripos($value, ">export<") !== FALSE) ||
         (!is_array($value) && stripos($value, ">clone<") !== FALSE))
      {
        array_splice($form['table']['#rows'][$row_key], $num - $nbOperationsRemoved, 1);

        $nbOperationsRemoved++;
      }
      
      // Change delete operation to direct the user to the synchronization interface.
      if((!is_array($value) && stripos($value, ">delete<") !== FALSE))
      {
        //$form['table']['#rows'][$row_key][$num - $nbOperationsRemoved] = '<a href="/osf/entities/ontologies/sync/classes?destination='.drupal_get_path_alias().'" title="Add/delete bundles">organize</a>';
        array_splice($form['table']['#rows'][$row_key], $num - $nbOperationsRemoved, 1);
        $nbOperationsRemoved++;
      }
    }    
  }
  
  // Fix the header colspan count
  $form['table']['#header'][2]['colspan'] = $form['table']['#header'][2]['colspan'] - 2;  
}

/**
* Alerter the resource_type_overview_form form to remove the create & export menu actions
*/
function osf_entities_menu_alter(&$items)
{
  // Remove these actions since they are not required/wanted for managing the resources
  unset($items['admin/structure/resource-types/add']);
  unset($items['admin/structure/resource-types/import']);
}

/**
* Returns an entity's description serialized in one of the RDF serialization
* supported by the system. 
* 
* @param mixed $entity The Drupal entity for which we want its RDF representation
* @param mixed $mime The serialization format we want this function to return.
*                    Can be one of:
*                      (1) "text/xml" (structXML) -- Default
*                      (2) "application/json" (structJSON)
*                      (3) "application/rdf+xml" (RDF+XML)
*                      (4) "application/rdf+n3" (N3/Turtle)
*                      (5) "application/iron+json" (irJSON)
*                      (6) "application/iron+csv" (commON) 
* @return Returns the serialized entity. Returns FALSE if the $mime format is not supported.
*/
function osf_entities_get_rdf_entity($entity, $mime = "text/xml")
{
  // We have a new resource into OSF
  $rdfMapping = osf_entities_get_rdf_mappings();

  $namespaces = new Namespaces();

  $subject = new Subject($entity->uri);
  
  // Focus on the rdf mapping for this current type
  // Make sure the type is existing as a bundle  
  if(is_array($entity->type))
  {
    foreach($entity->type as $type)
    {
      if(db_query('SELECT id FROM {resource_type} WHERE type = :type LIMIT 1', 
               array(':type' => $type))->fetchField() !== FALSE)
      {
        $entity->type = $type;
        break;
      }
    }
  }
  else
  {
    $entity->type = $entity->type;
  }

  $subject->setType($namespaces->getUnprefixedUri($rdfMapping[$entity->type]['mapping']['rdftype'][0]));
  
  $rdfMapping = $rdfMapping[$entity->type];
  
  $properties = variable_get('osf_entities_properties', array());
  
  // Return FALSE if the mapping is not existing
  // It means we can't create a RDF representation for this entity
  if(empty($rdfMapping))
  {
    return(FALSE);
  }
  
  foreach($entity as $property => $values)
  {   
    // If there is no mapping, or if the proper is "label", then we script it not to
    // duplicate the label triple.
    if(!isset($rdfMapping['mapping'][$property]) || $property == 'label')
    {
      continue;
    }
    
    $extProperty = $namespaces->getUnprefixedUri($rdfMapping['mapping'][$property]['predicates'][0]);

    $enabledLanguages = get_enabled_languages();
    $enabledLanguages[] = LANGUAGE_NONE;
    
    foreach($enabledLanguages as $lang)
    {
      if(isset($rdfMapping['mapping'][$property]) && !empty($values[$lang]))
      {
        // Object property
        if(isset($rdfMapping['mapping'][$property]['type']) && $rdfMapping['mapping'][$property]['type'] == 'rel')
        {
          foreach($values[$lang] as $key => $vals)
          { 
            $subject->setObjectAttribute($extProperty, $vals['value']);
          }
        }
        else // Datatype property
        {
          if(is_array($values[$lang]))
          {
            foreach($values[$lang] as $key => $vals)
            {
              $prop = current(entity_load('resource_type', array($extProperty)))->obj;
              
              if(!empty($prop))
              {
                $fieldType = $prop->getDataPropertyValues('http://purl.org/ontology/drupal#fieldType');
              }
              else
              {
                $fieldType = 'text';
              }
              
              $propertyValue = $vals['value'];

              if(!empty($fieldType))
              {
                switch($fieldType[0]['uri'])
                {
                  case 'http://purl.org/ontology/drupal#Link':
                    $propertyValue = $vals['url'];
                  break;
                  case 'http://purl.org/ontology/drupal#Geolocation':
                    if($extProperty != 'http://www.w3.org/2003/01/geo/wgs84_pos#lat' &&
                       $extProperty != 'http://www.w3.org/2003/01/geo/wgs84_pos#long')
                    {
                      $propertyValue = $vals['lat'].','.$vals['lng']; 
                    }
                    else
                    {
                      // Special hangling, see below...
                    }
                  break;
                  case 'http://purl.org/ontology/drupal#Image':
                    $propertyValue = file_create_url(db_query('SELECT uri FROM {file_managed} WHERE fid = :fid LIMIT 1', array(':fid' => $vals['fid']))->fetchField());
                  break;
                  case 'http://purl.org/ontology/drupal#File':
                    $propertyValue = file_create_url(db_query('SELECT uri FROM {file_managed} WHERE fid = :fid LIMIT 1', array(':fid' => $vals['fid']))->fetchField());
                  break;
                  case 'http://purl.org/ontology/drupal#ListText':
                  case 'http://purl.org/ontology/drupal#LongTextAndSummary':
                  case 'http://purl.org/ontology/drupal#LongText':
                  case 'http://purl.org/ontology/drupal#Float':
                  case 'http://purl.org/ontology/drupal#Integer':
                  case 'http://purl.org/ontology/drupal#Decimal':
                  case 'http://purl.org/ontology/drupal#Boolean':
                  case 'http://purl.org/ontology/drupal#DateISO':
                  case 'http://purl.org/ontology/drupal#DateUnixTimestamp':
                  case 'http://purl.org/ontology/drupal#Date':
                  case 'http://purl.org/ontology/drupal#Text':
                  case 'http://purl.org/ontology/drupal#ListFloat':
                    $propertyValue = $vals['value'];
                  break;
                  case 'http://purl.org/ontology/drupal#ListInteger':
                  break;
                }
              }              
              
              $rei = array(
                'http://purl.org/ontology/drupal#value' => array(
                  serialize($vals)
                )
              );                
              
              // Special handling for the geo-location (lat/long).
              // We use two properties to define the location of a Thing.
              if($fieldType[0]['uri'] == 'http://purl.org/ontology/drupal#Geolocation' && 
                 ($extProperty == 'http://www.w3.org/2003/01/geo/wgs84_pos#lat' ||
                  $extProperty == 'http://www.w3.org/2003/01/geo/wgs84_pos#long'))
              {
                $subject->setDataAttribute('http://www.w3.org/2003/01/geo/wgs84_pos#lat', $vals['lat'], 'rdfs:Literal', $lang, $rei);
                $subject->setDataAttribute('http://www.w3.org/2003/01/geo/wgs84_pos#long', $vals['lng'], 'rdfs:Literal', $lang, $rei);
              }
              else
              {
                $subject->setDataAttribute($extProperty, $propertyValue, 'rdfs:Literal', $lang, $rei);
              }
            }
          }
          elseif(!empty($values) && !is_array($values))
          {
            $subject->setDataAttribute($extProperty, $values, 'rdfs:Literal', $lang);
          }
        }
      }
    }
  }
  
  // We have to remember that the OSF Entities synchronization
  // enable the administrator of a site to expose the bundles and
  // fields he wants people to utilize (view, template, modify).
  // However, since not all properties may be synchronized,
  // we have to add the triples of the properties that haven't been
  // synchronized such that we don't loose any one triple for the
  // serialized version of an entity.  
  
  // Now re-introduce the triples that may be defined in the OSF subject
  // but that were not exposed to Drupal

  if(!empty($entity->obj))
  {
    foreach($entity->obj->getDataPropertiesUri() as $property)
    {
      if(!isset($rdfMapping['mapping'][resource_type_get_id($property)]) && $property != 'type')
      {
        // The property exists in the OSF instance, but it is not exposed in Drupal.
        // This means that we have to append these triples to that record description.
        $values = $entity->obj->getDataPropertyValues($property);
        
        foreach($values as $value)
        {
          $subject->setDataAttribute($property, $value['value'], $value['type'], $value['lang']);
        }
      }
    }
    
    foreach($entity->obj->getObjectPropertiesUri() as $property)
    {
      if(!isset($rdfMapping['mapping'][resource_type_get_id($property)]) && 
         $property != 'type' &&
         $property != Namespaces::$dcterms.'isPartOf')
      {
        // The property exists in the OSF instance, but it is not exposed in Drupal.
        // This means that we have to append these triples to that record description.
        $values = $entity->obj->getObjectPropertyValues($property);
        
        foreach($values as $value)
        {
          if(!isset($value['reify']))
          {
            $value['reify'] = '';
          }
          
          if(!isset($value['type']))
          {
            $value['type'] = '';
          }
          
          $subject->setObjectAttribute($property, $value['uri'], $value['reify'], $value['type']);
        }
      }
    }
  }
    
  $resultset = new Resultset();
  
  $resultset->addSubject($subject, $entity->dataset);
  
  switch($mime)
  {
    case "text/xml":
      return($resultset->getResultsetXML());
    break;
    case "application/json":
      return($resultset->getResultsetJSON());
    break;
    case "application/rdf+xml":
      return($resultset->getResultsetRDFXML());
    break;
    case "application/rdf+n3":
      return($resultset->getResultsetRDFN3());
    break;
    case "application/iron+json":
      return($resultset->getResultsetIronJSON());
    break;
    case "application/iron+csv":
      return($resultset->getResultsetIronCOMMON());
    break;
    
    default:
      return(FALSE);
    break;
  }
}

/**
* Get the Drupal local resource page URL from an entity's URI
* 
* @param $uri URI of the entity for which we want its local Drupal page
*/
function osf_entities_get_resource_page_url_from_entity_uri($uri)
{
  global $base_url;
  
  return($base_url.'/resources/'.rawurldecode(osf_entities_get_drid_from_uri($uri).'/'));
}

/**
* Get the URI of an Entity from its Drupal local page URL
* 
* @param mixed $url URL of the Drupal page for which we want its resource-type Entity URI
*/
function osf_entities_get_entity_uri_from_resource_page_url($url)
{
  global $base_url;
  
  $urlStartPos = strpos($url, '/resources/') + 11;
  $urlEndPos = strpos($url, '/', $urlStartPos + 1);
  
  $drid = substr($url, $urlStartPos, $urlEndPos);
  
  return(osf_entities_get_uri_from_drid($drid));
}

/**
* Get URI of a resource-type entity's URI from a DRID (Drupal Resource ID) 
* 
* @param mixed $drid DRID for which we want its related URI
*/
function osf_entities_get_uri_from_drid($drid)
{
  // What we do here is to make sure that if we get a DRID, that the DRID is properly
  // encoded. 
  $drid = osf_entities_get_drid_from_string($drid);
  
  return(db_query('SELECT uri FROM {osf_drid_registry} WHERE drid = :drid LIMIT 1', 
                  array(':drid' => $drid))->fetchField());
}

/**
* Get the DRID (Drupal Resource ID) of a URI
* 
* @param mixed $uri URI for which we want a local DRID
*/
function osf_entities_get_drid_from_uri($uri)
{
  $drid = db_query('SELECT drid FROM {osf_drid_registry} WHERE uri = :uri LIMIT 1', array(':uri' => $uri))->fetchField();

  if(!$drid)
  {
    // Create a new DRID if it is not already existing
    
    preg_match('/^.*\/datasets\/(.*)$/', $uri, $matches);
    
    if(!empty($matches))
    {
      $fragment = $matches[1];
      
      $fragment = str_replace('/', '-', $fragment);
    }
    else
    {
      $pos = strripos($uri, "#");

      if($pos === FALSE)
      {
        $pos = strripos($uri, "/");
      }

      if($pos !== FALSE)
      {
        $pos++;
      }

      $fragment = substr($uri, $pos);    
    }
    
    $drid = osf_entities_get_drid_from_string($fragment);
    
    // Make sure this DRID is not already existing for another URI. If it is the case, then
    // we happen an iterator at the end of the DRID to create a new unique one.
    
    if(db_query('SELECT uri FROM {osf_drid_registry} WHERE drid = :drid LIMIT 1', 
                   array(':drid' => $drid))->fetchField() !== FALSE)
    {
      $dridIterator = 0;
      
      while(db_query('SELECT uri FROM {osf_drid_registry} WHERE drid = :drid LIMIT 1', 
                     array(':drid' => $drid.'___'.$dridIterator))->fetchField() !== FALSE)
      {
        $dridIterator++;
      }
      
      $drid = $drid.'___'.$dridIterator;
    }
    
    // Save the new DRID into the osf_drid_registry table
    // Initializing $record array with values.
    $record = array (
      "drid" => $drid,
      "uri" => $uri,
    );
    
    // Inserting $record (data) into the database. Here $table variable contains the name of the table.
    drupal_write_record('osf_drid_registry', $record);
  }
  
  return($drid);
}

function osf_entities_get_drid_from_string($str, $replace = array(), $delimiter = '-')
{
  // Make sure the string is UTF-8
  if(extension_loaded("mbstring") && mb_detect_encoding($str, "UTF-8", TRUE) != "UTF-8")
  {                   
    $str = utf8_encode($str);
  }    
  
  if(!empty($replace)) 
  {
    $str = str_replace((array)$replace, ' ', $str);
  }

  $drid = iconv('UTF-8', 'ASCII//TRANSLIT', $str);
  $drid = preg_replace("/[^a-zA-Z0-9\/_|+ -]/", '', $drid);
  $drid = strtolower(trim(trim($drid), '-'));
  $drid = preg_replace("/[\/_|+ -]+/", $delimiter, $drid);

  return($drid);
}

/**
* Get the OSF base network URL from a dataset URI.
* 
* @param mixed $dataset Dataset URI for which we want its related OSF network
*/
function osf_entities_get_network_from_dataset_uri($dataset_uri) {
  $datasets = osf_configure_dataset_load_util('all', FALSE);
  foreach ($datasets as $dataset) {
    if($dataset_uri == $dataset->uri) {
      return($dataset->endpoint->uri);
    }
  }
  return FALSE;
}

/**
* Get all the resource_type IDs (bundle IDs) that are not ignored in OSF for Drupal.
* These resource_type are the one that hasn't been tagged as "ignored" by the
* system administrator
* 
* @return An array of resource_type IDs that are not ignore by OSF for Drupal
* 
*/
function osf_entities_get_exposed_resource_type_ids()
{
  return(db_query('SELECT type FROM {resource_type} WHERE ignoreResource = 0')->fetchCol());
}


/**
* Get a list of fields instances for a specific bundle.
* 
* @param mixed $bundle Bundle ID for which we want its associated field instances
* 
* @return return an array of fields instances' name for that target bundle
*/
function osf_entities_get_fields_by_bundle($bundle)
{
  $fields = &drupal_static(__FUNCTION__);
  
  if(!isset($fields)) 
  {  
    $fields = array();
        
    $resultset = db_query('SELECT field_name FROM {field_config_instance} WHERE bundle = :bundle ', array(':bundle' => $bundle));

    while ($field = $resultset->fetchField()) {
      array_push($fields, $field);
    }  
  }
  
  return($fields);
}
       
/**
* Get a series of fields organized by their bundles.
* 
* @return An array where the keys are the bundles and the values an array of associated fields name.
*        
*/
function osf_entities_get_fields_by_bundles()
{
  $fields = &drupal_static(__FUNCTION__);
  
  if(!isset($fields)) 
  {
    $fields = array();
    
    $resultset = db_query('SELECT field_name, bundle FROM {field_config_instance} WHERE entity_type = :et ', array(':et' => 'resource'));

    // Get all WSF address still in use
    while($values = $resultset->fetchAssoc()) 
    {
      if(!isset($fields[$values['bundle']]))
      {
        $fields[$values['bundle']] = array('iron_preflabel', 'iron_description');
      }

      if($values['field_name'] !== 'iron_preflabel' &&
         $values['field_name'] !== 'iron_description')      
      {
        $fields[$values['bundle']][] = $values['field_name'];
      }
    }
    
    $resultset = db_query('SELECT type FROM {resource_type}');

    // For each existing bundle, we make sure they are in that list.
    // Some may be missing if they don't have any fields
    // associated to them.
    // By default, we add the iron_preflabel and the iron_description ones.
    while($values = $resultset->fetchAssoc()) 
    {
      if(!isset($fields[$values['type']]))
      {
        $fields[$values['type']] = array('iron_preflabel', 'iron_description');
      }
    }      
  }
  
   
  return($fields);
}

function osf_entities_create_resource_type_class_from_resultset_subject_array($uri, $subject)
{
  $fieldsByBundles = osf_entities_get_fields_by_bundles();
  
  $result = array();

  $entityTypesUris = array();

  foreach($subject["type"] as $type)
  {
    if(!isset($result[resource_type_get_id(Namespaces::$rdf."type")]))
    {
      $result[resource_type_get_id(Namespaces::$rdf."type")] = array();
    }

    array_push($result[resource_type_get_id(Namespaces::$rdf."type")], $type);
    
    // Make sure that the type of this entity is exposed as a bundle in Drupal.
    // If not, we skip it.
    $bundleEntities = entity_load('resource_type', array(resource_type_get_id($type)));
    if(empty($bundleEntities))
    {
      continue;
    }                

    if(!isset($result["type"]))
    {
      $result["type"] = array();
    }

    $entityTypesUris[] = $type;
    array_push($result["type"], resource_type_get_id($type));
  }  
  
  // Keep the top (more specialized class) of the classes hierarchy currently loaded
  $result["type"] = array(resource_type_get_id(osf_entities_get_top_class($entityTypesUris)));
  
  // If there is no type/bundle exposed in Drupal for this entity, we define its bundle type
  // to be "owl_thing". To see if the entity is mapped or not, we only have to check the
  // difference between the ['type'] and the ['rdf_type] arrays
  if(empty($result["type"]))            
  {                                          
    $result["type"] = array();

    array_push($result["type"], resource_type_get_id(Namespaces::$owl."Thing"));
  }
  
  $obj = new Subject($uri);
  $obj->setSubject($subject);

  $result["uri"] = $uri;

  $result["drid"] = osf_entities_get_drid_from_uri($uri);

  $result["obj"] = $obj;

  // Make sure that we create a property, in the Entity's object instance
  // for each field that got mapped in OSF Entities. If no data come from
  // OSF for one of those fields, then the field will simply be empty.
  //
  // This is to keep the OSF Entities API consistent with what is
  // exposed as fields in OSF Entities. All the exposed fields will be
  // returned for all the entity_load() calls, but not all of them will
  // be populated with values. But at least, they will appear in the 
  // object's instance description.              
  if(!is_null($fieldsByBundles[$result["type"][0]]))
  {
    foreach($fieldsByBundles[$result["type"][0]] as $field_name)
    {
      $result[$field_name][LANGUAGE_NONE] = array();                
    }
  }

  if(isset($subject["prefLabel"]) && 
     $subject["prefLabel"] != "")
  {  
    $result["preflabel"] = array(LANGUAGE_NONE => array(array('value' => $subject["prefLabel"])));
    $result["label"] = $subject["prefLabel"];
    $result[resource_type_get_id(Namespaces::$iron."prefLabel")] = array(LANGUAGE_NONE => array(array('value' => $subject["prefLabel"])));
  }

  if(isset($subject["description"]) && 
     $subject["description"] != "")
  {
    $result["description"] = array(LANGUAGE_NONE => array(array('value' => $subject["description"])));
    $result[resource_type_get_id(Namespaces::$iron."description")] = array(LANGUAGE_NONE => array(array('value' => $subject["description"])));
  }
  
  if(isset($subject["altLabel"]) && 
     $subject["altLabel"] != "" &&
     !is_null($fieldsByBundles[$result["type"][0]]) &&
     in_array(resource_type_get_id(Namespaces::$iron."altLabel"), $fieldsByBundles[$result["type"][0]]))
  {
    $result["altLabel"] = array(LANGUAGE_NONE => array(array('value' => $subject["altLabel"])));
    $result[resource_type_get_id(Namespaces::$iron."altLabel")] = array(LANGUAGE_NONE => array(array('value' => $subject["altLabel"])));
  }

  if(isset($subject["prefURL"]) && 
     $subject["prefURL"] != "" &&
     !is_null($fieldsByBundles[$result["type"][0]]) &&
     in_array(resource_type_get_id(Namespaces::$iron."prefURL"), $fieldsByBundles[$result["type"][0]]))
  {
    $result["prefURL"] = array(LANGUAGE_NONE => array(array('value' => $subject["prefURL"])));
    $result[resource_type_get_id(Namespaces::$iron."prefURL")] = array(LANGUAGE_NONE => array(array('value' => $subject["prefURL"])));
  }

  if(isset($subject["lat"]) && 
     $subject["lat"] != "" && 
     !is_null($fieldsByBundles[$result["type"][0]]) &&
     in_array(resource_type_get_id(Namespaces::$geo."lat"), $fieldsByBundles[$result["type"][0]]))
  {
    $result["lat"] = array(LANGUAGE_NONE => array('value' => $subject[Namespaces::$geo."lat"][0]["value"]));
    $result[resource_type_get_id(Namespaces::$geo."lat")] = array(LANGUAGE_NONE => array('value' => $subject[Namespaces::$geo."lat"][0]["value"]));
  }

  if(isset($subject["long"]) && 
     $subject["long"] != "" &&
     !is_null($fieldsByBundles[$result["type"][0]]) &&
     in_array(resource_type_get_id(Namespaces::$geo."long"), $fieldsByBundles[$result["type"][0]]))
  {
    $result["long"] = array(LANGUAGE_NONE => array(array('value' => $subject[Namespaces::$geo."long"][0]["value"])));
    $result[resource_type_get_id(Namespaces::$geo."long")] = array(LANGUAGE_NONE => array(array('value' => $subject[Namespaces::$geo."long"][0]["value"])));
  }

  foreach($subject as $attributeUri => $values)
  { 
    if((!isset($fieldsByBundles[$result["type"][0]]) ||
        !in_array(resource_type_get_id($attributeUri), $fieldsByBundles[$result["type"][0]]))/* &&
        $attributeUri != Namespaces::$dcterms.'isPartOf'*/)
    {                 
      continue;
    }
          
    if($attributeUri == "type" ||
       $attributeUri == "prefLabel" ||
       $attributeUri == "description" ||
       $attributeUri == "altLabel" ||
       $attributeUri == "prefURL" ||
       $attributeUri == Namespaces::$iron."prefLabel" ||
       $attributeUri == Namespaces::$iron."altLabel" ||
       $attributeUri == Namespaces::$iron."prefURL" ||
       $attributeUri == Namespaces::$iron."description" ||
       $attributeUri == Namespaces::$geo."lat" ||
       $attributeUri == Namespaces::$geo."long")
    {
      continue;
    }

    if(is_array($values))
    {
      foreach($values as $value)
      {
        if(isset($value["value"]))
        {
          array_push($result[resource_type_get_id($attributeUri)][LANGUAGE_NONE], array('value' => $value["value"]));
        }
        else
        {
          array_push($result[resource_type_get_id($attributeUri)][LANGUAGE_NONE], array('value' => $value["uri"]));

          if(isset($value['reify']))
          {
            $result["reify_".resource_type_get_id($attributeUri)][LANGUAGE_NONE] = array(array('value' => $value['reify'][Namespaces::$wsf.'objectLabel'][0]));
          }
        }
      }
    }
  }
  
  // Use entity_create(...) to create the proper ResourceType
  return(entity_create('resource_type', $result));    
}

function osf_entities_get_top_class($classes)
{
  $cache_path = rtrim(variable_get('osf_OntologySettings_ontologies_cache_folder', '/tmp'), '/') . '/';
  $classHierarchy = unserialize(file_get_contents($cache_path . "classHierarchySerialized.srz"));
  
  $currentTopClass = '';
  
  foreach($classes as $class)
  {
    $parentClasses = $classHierarchy->getSuperClasses($class);
    
    $parentClassesURIs = array();
    
    foreach($parentClasses as $pc)
    {
      $parentClassesURIs[] = $pc->name;
    }
    
    if($currentTopClass == '' || array_search($currentTopClass, $parentClassesURIs))
    {
      $currentTopClass = $class;
    }
  }
  
  return($currentTopClass);
}

function osf_entities_field_widget_form_alter(&$element, &$form_state, $context) 
{
  // Modules such as field_collection add their own "Remove" button.
  if($context['field']['cardinality'] == FIELD_CARDINALITY_UNLIMITED && 
     !isset($element['remove_button']) &&
     isset($context['field']['type']) && 
     !in_array($context['field']['type'], array('file',
                                                'image',
                                                'list_float',
                                                'list_integer',
                                                'list_boolean',
                                                'list_text',
                                                'link',
                                                'osf_field_entity_reference',
                                                'osf_field_concept_reference',
                                                'geolocation_latlng'))) 
  {
    $element['value']['#attributes']['style'] = array('float: left; margin-top: 10px');

    // Add the 'remove' button.
    $element['field_remove_item'] = array(
      '#type' => 'button',
      '#value' => t('Remove'),
      '#name' => drupal_html_class(
        'op-remove-' . $context['field']['field_name'] . '-' . $context['langcode'] . '-' . $context['delta']),
      '#weight' => 10,
      '#submit' => 'osf_entities_ajax_callback',
      '#ajax' => array(
        'callback' => 'osf_entities_ajax_callback',
      ),
      '#limit_validation_errors' => array(),
      '#attributes' => array(
        'style' => array('float: right; margin-top: 10px'),
      ),
    );
  }
}

function osf_entities_ajax_callback(&$form, $form_state) 
{
  $wrapper = '.' . $form['#field_remove_item']['wrapper'];
  $field_name = $form['#field_remove_item']['field_name'];

  return array(
    '#type' => 'ajax',
    '#commands' => array(
      ajax_command_replace($wrapper, render($form[$field_name])),
    ),
  );
}

function osf_entities_form_alter(&$form, &$form_state, $form_id) 
{
  if(isset($form_state['triggering_element']['#parents'][3]) &&
     $form_state['triggering_element']['#parents'][3] == 'field_remove_item') 
  {
    $field_name = $form_state['triggering_element']['#parents'][0];
    $field_language = $form_state['triggering_element']['#parents'][1];
    $field_delta = substr($form_state['triggering_element']['#name'], strrpos($form_state['triggering_element']['#name'], '-') + 1);

    if($form[$field_name][$field_language]['#cardinality'] == FIELD_CARDINALITY_UNLIMITED) 
    {
      $form['#field_remove_item'] = array(
        'wrapper' => $form[$field_name]['#attributes']['class'][1],
        'field_name' => $field_name,
      );
      
      // Remove field item.
      unset($form[$field_name][$field_language][$field_delta]);

      if(!isset($form_state['#field_remove_item'])) 
      {
        $form_state['#field_remove_item'] = array();
      }
      
      // Memorize this removal.
      $form_state['#field_remove_item'][$field_name][$field_language][] = $field_delta;
    }
  }

  // Remove all items again in case the form submission fails validation.
  if(!empty($form_state['#field_remove_item'])) 
  {
    foreach($form_state['#field_remove_item'] as $field_name => $field_values) 
    {
      foreach($field_values as $field_language => $field_deltas) 
      {
        foreach($field_deltas as $field_delta) 
        {
          if(isset($form[$field_name][$field_language][$field_delta])) 
          {
            unset($form[$field_name][$field_language][$field_delta]);
          }
        }
      }
    }
  }
}

/**
* Get a Resource instance from a URI reference.
* 
* @param mixed $uri URI of the entity to return as a Resource
* @return {mixed|Resource} If the entity can be retrieved then the Resource will
*                          be returned. If it cannot, then an empty Resource will
*                          be returned.
*/
function osf_get_resource($uri)
{
  $entity = current(entity_load('resource_type', array($uri)));
  
  if(!empty($entity))
  {
    $resource = new Resource($uri);
    
    $currentLanguage = get_lang(get_default_language());
    
    $resource->importSubject($entity->obj)
             ->setLanguage(($currentLanguage == 'und' ? NULL : $currentLanguage));

    return($resource);
  }
  
  return(new Resource($uri));
}

function osf_dpm_resource(\StructuredDynamics\osf\framework\Resource $resource)
{
  $res = array();
  $namespaces = new Namespaces();
  
  foreach($resource->properties() as $property)
  {
    foreach($property->values() as $value)
    {
      if(!isset($res[$namespaces->getPrefixedUri($property->uri())]))
      {
        $res[$namespaces->getPrefixedUri($property->uri())] = array();
      }
      
      $res[$namespaces->getPrefixedUri($property->uri())][] = array('content' => $value->content(),
                                                                    'language' => $value->language(),
                                                                    'type' => $value->type());
      
    }
  }
  
  dpm($res, 'Debug information of the '.$namespaces->getPrefixedUri($resource->uri()).' Resource');
}