<?php

use \StructuredDynamics\osf\framework\Namespaces;
use \StructuredDynamics\osf\php\api\ws\search\SearchQuery;
use \StructuredDynamics\osf\framework\Subject;
use \StructuredDynamics\osf\php\api\ws\sparql\SparqlQuery;
use \StructuredDynamics\osf\framework\Resource;

function osf_searchapi_menu() {
  $items = array();

  // Register the OSF SearchAPI settings page
  $items['admin/config/osf/osf_searchapi'] =
    array(
    'title' => t('Search'),
    'description' => t('Settings of the OSF for Drupal Search API module'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('osf_searchapi_settings'),
    'access arguments' => array('administer osf osf_searchapi'),
    'type' => MENU_LOCAL_TASK,
    'weight' => -45
  );

  return $items;
}

function osf_searchapi_permission() {
  return array(
    'administer osf osf_searchapi' => array(
      'title' => t('administer osf osf_searchapi'),
      'description' => t('Access to administer OSF SearchAPI configuration options.
                          These configuration options are used to change the ranking
                          of the search results'),
    )
  );
}

function osf_searchapi_settings() {
  global $base_url;
  global $user;

  $form['inference'] = array(
    '#type' => 'fieldset',
    '#title' => t('Inference Settings'),
    '#description' => t(''),
    '#weight' => 2,
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );

  $form['inference']['osf_search_api_settings_inference'] = array(
    '#type' => 'radios',
    '#title' => t('Enable inference'),
    '#default_value' => variable_get("osf_search_api_settings_inference", 0),
    '#options' => array(1 => t('Enable'), 0 => t('Disable')),
    '#description' => t('Enable type inference on the Search API endpoint'),
  );  
  
  $form['operator'] = array(
    '#type' => 'fieldset',
    '#title' => t('Operator Settings'),
    '#description' => t('Settings for the default operator to use in the search queries'),
    '#weight' => 3,
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );

  $form['operator']['osf_searchapi_settings_op'] = array(
    '#type' => 'radios',
    '#title' => t('Default operator'),
    '#default_value' => variable_get("osf_searchapi_settings_op", 0),
    '#options' => array(0 => t('AND'), 1 => t('OR')),
    '#description' => t('Default operator to use between the search terms'),
  );

  $form['operator']["osf_searchapi_settings_or_criterion"] = array(
    '#type' => 'textfield',
    '#title' => t('OR criterion'),
    '#default_value' => variable_get("osf_searchapi_settings_or_criterion", '1'),
    '#size' => 64,
    '#maxlength' => 64,
    '#description' => t("If the OR operator is selected, this define the minimum number of terms that should matching the search query."),
    '#required' => FALSE,
  );

  $form['attributes_restrictions_and_boosting'] = array(
    '#type' => 'fieldset',
    '#title' => t('Attributes Restrictions & Boosting'),
    '#description' => t('The Attributes Restrictions and Boosting section allows you to filter search
                         results by attribute and to change boost values to affect the rankings of
                         the results set. The attribute filters work in conjunction with any other
                         specifications that have been made in these settings.'),
    '#weight' => 4,
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );

  $form['attributes_restrictions_and_boosting']['osf_searchapi_restrictions_and_boosting'] = array(
    '#title' => t('Restrictions & Boosting'),
    '#type' => 'textarea',
    '#description' => t ('This section enable you to define search restrictions and boosting. You can
                          define a series of properties (URI) or fields for which the search will be
                          constrained to. Additionally, you can define a weight for each of these
                          descriptions that will change the scoring of the results.
                          <br /><br />
                          The format of this field if the following: <strong>[property-uri OR field-machine-name] => [boosting factor]</strong>
                          <br/>
                          <em>each restriction/boosting should be seperated with a line feed</em>
                          <br /><br />
                          For example:
                          <ul>
                            <li>
                              <strong>http://purl.org/ontology/iron#prefLabel => 3</strong>
                            </li>
                            <li>
                              <strong>iron_preflabel => 3</strong>
                            </li>
                          </ul>'),

    '#default_value' => variable_get("osf_searchapi_restrictions_and_boosting", ""),
  );

  $form['phrase_treatment'] = array(
    '#type' => 'fieldset',
    '#title' => t('Phrase Treatment'),
    '#description' => t('The Phrase Treatment section allows you to specify that a property/field
                         is to be considered as a phrase search. Then the documents that matches
                         the search terms for the given distance parameter get a score boost.
                         The phrase treatment work in conjunction with any other specifications
                         that have been made in these settings.'),
    '#weight' => 5,
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );

  $form['phrase_treatment']["osf_searchapi_phrase_treatment_distance"] = array(
    '#type' => 'textfield',
    '#title' => t('Phrase terms distance'),
    '#default_value' => variable_get("osf_searchapi_phrase_treatment_distance", '3'),
    '#size' => 64,
    '#maxlength' => 64,
    '#description' => t("This is the maximum distance between the words of the searched terms. If
                         the search terms appears within that distance, then these records will
                         get a boost modifier and will score higher in the resultset."),
    '#required' => FALSE,
  );

  $form['phrase_treatment']['osf_searchapi_phrase_treatment'] = array(
    '#title' => t('Attribute Phrase Boost'),
    '#type' => 'textarea',
    '#description' => t ('This section enable you to define phrase treatment and boosting. You can
                          define a series of properties (URI) or fields for which the search will
                          consider to be a phrase search. Then you define a weight for each of these
                          treatment that will change the scoring of the results.
                          <br /><br />
                          The format of this field if the following: <strong>[property-uri OR field-machine-name] => [boosting factor]</strong>
                          <br/>
                          <em>each restriction/boosting should be seperated with a line feed</em>
                          <br /><br />
                          For example:
                          <ul>
                            <li>
                              <strong>http://purl.org/ontology/iron#prefLabel => 3</strong>
                            </li>
                            <li>
                              <strong>iron_preflabel => 3</strong>
                            </li>
                          </ul>'),

    '#default_value' => variable_get("osf_searchapi_phrase_treatment", ""),
  );

  $form['value_boosting'] = array(
    '#type' => 'fieldset',
    '#title' => t('Value Boosting'),
    '#description' => t('The Value Boosting section allows you to specify to boost the scoring
                         of the results based on an attribute and its value. The attribute value
                         boosting work in conjunction with any other specifications that have
                         been made in these settings.'),
    '#weight' => 6,
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );

  $form['value_boosting']['osf_searchapi_attribute_value_boosting'] = array(
    '#title' => t('Attribute Value Boosting'),
    '#type' => 'textarea',
    '#description' => t ('This section enable you to boost results with specific value(s) for specific
                          attribute(s). You can define a series of properties (URI) or fields for
                          and their value which the search will consider for score boosting. Then you define a
                          weight for each of these treatment that will change the scoring of the results.
                          <br /><br />
                          The format of this field if the following: <strong>[property-uri OR field-machine-name]::"[value]" => [boosting factor]</strong>
                          <br/>
                          <em>each restriction/boosting should be seperated with a line feed</em>
                          <br /><br />
                          For example:
                          <ul>
                            <li>
                              <strong>dataset::"http://myinstance.com/datasets/test/" => 3</strong>
                            </li>
                            <li>
                              <strong>iron_preflabel::"cancer" => 2</strong>
                            </li>
                            <li>
                              <strong>http://foo.com/ontology#partner::"http://mypartner.com/about/" => 6</strong>
                            </li>
                          </ul>'),

    '#default_value' => variable_get("osf_searchapi_attribute_value_boosting", ""),
  );

  $form['interface'] = array(
    '#type' => 'fieldset',
    '#title' => t('Search Endpoint Interface Settings'),
    '#description' => t('Different Search endpoint interfaces and versions can be specified in this section'),
    '#weight' => 7,
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );

  $form['interface']["osf_searchapi_settings_interface_name"] = array(
    '#type' => 'textfield',
    '#title' => t('Interface Name'),
    '#default_value' => variable_get("osf_searchapi_settings_interface_name", ''),
    '#size' => 64,
    '#maxlength' => 64,
    '#description' => t("Name of the Search Interface to use. This name is case sensitive. If this field is blank, the default interface will be used."),
    '#required' => FALSE,
  );

  $form['interface']["osf_searchapi_settings_interface_version"] = array(
    '#type' => 'textfield',
    '#title' => t('Interface Version'),
    '#default_value' => variable_get("osf_searchapi_settings_interface_version", ''),
    '#size' => 64,
    '#maxlength' => 64,
    '#description' => t("Version of the Search Interface to use. If this field is blank, the default version will be used."),
    '#required' => FALSE,
  );
  
  $form['facets'] = array(
    '#type' => 'fieldset',
    '#title' => t('Search API Available Facets'),
    '#description' => t('Select all the properties that are used to describe the resources in OSF that you want to expose to the SearchAPI as facets. All the properties that are checked in that list will appear as a facet candidate on that <a href="/admin/config/search/search_api/index/osf_search_index/facets">facets configuration page</a>.'),
    '#weight' => 8,
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );  
  
  $options = cache_get('osf_searchapi_facets_options');
  
  if(!$options)
  {
    $defaultEndpoint = osf_configure_get_endpoint_by_uri(osf_searchapi_get_endpoint_uri_from_server());
    
    if(!empty($defaultEndpoint))
    {
      $options = array();

      $search = new SearchQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());

      _osf_searchapi_apply_search_settings($search);

      // Just keep the datasets that are searchable
      $filterDatasets = array();
      $datasets = osf_configure_dataset_generate_config_searchable('configured-default');

      foreach($datasets as $dataset)
      {
        $filterDatasets[] = $dataset;
      }

      $search->datasetsFilters((empty($filterDatasets) ? array('none') : $filterDatasets));    
      
      $search->setAggregateAttributesObjectTypeToUriLiteral()
             ->includeAggregates()
             ->items(0)
             ->lang(get_lang('en'))
             ->send(new DrupalQuerierExtension());

      if($search && $search->getResultset()) 
      {
        $resultset = $search->getResultset()->getResultset();

        foreach($resultset as $items) 
        {
          foreach($items as $uri => $item) 
          {
            if($item['type'][0] != Namespaces::$aggr . 'Aggregate') 
            {
              continue;
            }
            
            $type = $item['http://purl.org/ontology/aggregate#property'][0]['uri'];
            $pkey = $item['http://purl.org/ontology/aggregate#object'][0]['uri'];
            
            if($type == 'http://www.w3.org/1999/02/22-rdf-syntax-ns#Property' && 
               $pkey != Namespaces::$void . 'Dataset') 
            {
              $pos = strripos($pkey, "#");

              if ($pos === FALSE)
              {
                $pos = strripos($pkey, "/");
              }

              if ($pos !== FALSE)
              {
                $pos++;
              }

              // Create a label, split the camel cases, and capitalize the first letter of the label
              $label = ucfirst(join(preg_split('/(?<=[a-z])(?=[A-Z])/x', substr($pkey, $pos)), " "));
              
              $options[$pkey] = '<strong>'.$label.'</strong> <em>('.$pkey.')</em>';
            }
          }
        }
      }
      
      asort($options);
      
      cache_set('osf_searchapi_facets_options', $options);
    }
  }
  else
  {
    $options = $options->data;
  }  
  
  $form['facets']['osf_searchapi_facets_selected'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Ontologies'),
    '#options' => $options,
    "#default_value" => variable_get('osf_searchapi_facets_selected', array())
  );   
  
  // Clear the facetapi:facet_info cache such that if the user changed the facet options, that the
  // blocks get re-generated in the searchapi facet tab.
  cache_clear_all('facetapi:facet_info:', 'cache', TRUE);

  return system_settings_form($form);
}

/**
 * Implements hook_search_api_service_info().
 *
 * Defines the OSF service.
 */
function osf_searchapi_search_api_service_info() {
  $services['osf_searchapi_service'] = array(
    'name' => t('OSF service'),
    'description' => t('<p>Connects to the OSF service to perform searches.</p>'),
    'class' => 'SearchApiStructService',
  );
  return $services;
}

/**
 * Implements hook_search_api_service_info().
 *
 * Defines the OSF item type ( which needs its own Datasource controller so we can override loadItems method. )
 */
function osf_searchapi_search_api_item_type_info() {
  return array('osf' => array(
    'name' => 'OSF',
    'datasource controller' => 'SearchApiStructDataSourceController',
  ));
}

/*
 * Given a $uri representing a property, return the facet configuration for
 * that property as an array with a single key => facet_info_data_structure
 * element
 *
 * Also supports Namespaces::$void . 'Dataset' as a $uri.
 */
function osf_searchapi_facet_config($uri) {
  if ($uri == Namespaces::$void . 'Dataset') {
    $ob = new Subject(Namespaces::$void . 'Dataset');
    $ob->setPrefLabel(t('Dataset'));
  }
  else {
    $ob = osf_structproperty_info($uri);
  }

  $read_name = ($ob) ? $ob->getPrefLabel() : t('Unknown label, property @u', array('@u' => $uri));
  $alias = substr($uri, strpos($uri, '#') + 1);
  return array(osf_searchapi_facet_key_hash($uri) => array(
    'name' => osf_searchapi_facet_key_hash($uri),
    'label' => t($read_name), // Human-Readable name displayed in settings forms
    'description' => t(':read_name. Property @uri', array(':read_name' => $read_name, '@uri' => $uri)),
    'field' => $uri,
    'field alias' => $alias,
    'field api name' => FALSE, // Machine name of Field API field data this facet is associated with.
    'field api bundles' => array(), // Array of entity names this field contains bundle info for.
    'query types' => array('term'),
    'dependency plugins' => array(),
    'default widget' => 'links',
    'allowed operators' => array(
      FACETAPI_OPERATOR_AND => TRUE,
      FACETAPI_OPERATOR_OR => TRUE,
    ),
    'facet missing allowed' => FALSE,
    'facet mincount allowed' => FALSE,
    'weight' => 0,
    'map callback' => FALSE,
    'map options' => array(),
    'hierarchy callback' => FALSE,
    'values callback' => FALSE,
    'min callback' => FALSE,
    'max callback' => FALSE,
    'default sorts' => array(
      array('active', SORT_DESC),
      array('count', SORT_DESC),
      array('display', SORT_ASC),
    ),
  ));
}

/*
 * Originall thought that facet keys should be as short as possible
 * as the facetapi table only supports 255 character facet names
 * which are formed generally as
 * search_api@index_machine_name:realm:facet_key
 *
 * A bit of research shows that generally this limit is not approached
 * so this normalizes the URIs to prevent errors due to splits
 * on colons and other "unexpected" machine name value characters and
 * adds a hash to accomodate that properties are case sensitive
 * while generally the formed facet names are not
 */
function osf_searchapi_facet_key_hash($uri) {
  static $seen = array();
  $hash = preg_replace('/[^a-zA-Z0-9]/', '_', $uri);
  $hash .= '_' . hash('crc32b', $uri);
  if (isset($seen[$hash]) && $seen[$hash] != $uri) {
    drupal_set_message(t('Hash collision in facet specification, property @a collides with @b.', array('@a' => $uri, '@b' => $seen[$hash])), 'error');
  }
  else {
    $seen[$hash] = $uri;
  }
  return $hash;
}

function _osf_searchapi_apply_search_settings(&$searchQuery)
{
  // Apply endpoint interface & version to use
  $searchQuery->sourceInterface(variable_get("osf_searchapi_settings_interface_name", 'default'));
  $searchQuery->sourceInterfaceVersion(variable_get("osf_searchapi_settings_interface_version", ''));

  // Apply the setting for the default operator to use
  $defaultOperator = 'AND';

  if(variable_get('osf_searchapi_settings_op', 0) == 0)
  {
    // Default operator AND
    $searchQuery->defaultOperatorAND();
  }
  else
  {
    // Default operator OR
    $searchQuery->defaultOperatorOR(variable_get('osf_searchapi_settings_or_criterion', '1'));
  }

  $propertiesByField = variable_get('osf_entities_properties_by_field', array());

  // Apply restrictions and boosting
  $restrictions = variable_get('osf_searchapi_restrictions_and_boosting', '');

  // Normalize carriage returns
  $restrictions = str_replace(array("\r\n", "\r"), "\n", $restrictions);
  $restrictions = preg_replace("/\n+/", "\n", $restrictions);
  $restrictions = trim($restrictions, "\n");

  $restrictions = explode("\n", $restrictions);

  foreach($restrictions as $restriction)
  {
    if($restriction == '')
    {
      continue;
    }

    $restriction = explode(' => ', $restriction);

    $property = $restriction[0];
    $boost = $restriction[1];

    // check if it is a URI or a FIELD
    if(isset($propertiesByField[$property]))
    {
      // A field was used in the rules, so we get its URI
      $property = $propertiesByField[$property];
    }

    $searchQuery->searchRestriction($property, $boost);
  }

  // Apply phrase treatment
  $searchQuery->phraseBoostDistance(variable_get('osf_searchapi_phrase_treatment_distance', '3'));

  $treatments = variable_get('osf_searchapi_phrase_treatment', '');

  // Normalize carriage returns
  $treatments = str_replace(array("\r\n", "\r"), "\n", $treatments);
  $treatments = preg_replace("/\n+/", "\n", $treatments);
  $treatments = trim($treatments, "\n");

  $treatments = explode("\n", $treatments);

  foreach($treatments as $treatment)
  {
    if($treatment == '')
    {
      continue;
    }

    $treatment = explode(' => ', $treatment);

    $property = $treatment[0];
    $boost = $treatment[1];

    // check if it is a URI or a FIELD
    if(isset($propertiesByField[$property]))
    {
      // A field was used in the rules, so we get its URI
      $property = $propertiesByField[$property];
    }

    $searchQuery->attributePhraseBoost($property, $boost);
  }

  // Apply attribute value boosting
  $rules = variable_get('osf_searchapi_attribute_value_boosting', '');

  // Normalize carriage returns
  $rules = str_replace(array("\r\n", "\r"), "\n", $rules);
  $rules = preg_replace("/\n+/", "\n", $rules);
  $rules = trim($rules, "\n");

  $rules = explode("\n", $rules);

  foreach($rules as $rule)
  {
    if($rule == '')
    {
      continue;
    }

    $rule = explode(' => ', $rule);

    $propertyValue = $rule[0];
    $boost = $rule[1];

    $propertyValue = explode('::', $propertyValue);

    $property = $propertyValue[0];
    $value = trim($propertyValue[1], '"');

    // check if it is a URI or a FIELD
    if(isset($propertiesByField[$property]))
    {
      // A field was used in the rules, so we get its URI
      $property = $propertiesByField[$property];
    }

    $searchQuery->attributeValueBoost($property, $boost, $value, osf_entities_is_valid_iri($value));
  }
}

function osf_searchapi_get_endpoint_uri_from_server()
{
  $options = db_query('SELECT options FROM {search_api_server} WHERE machine_name = \'osf_search\' LIMIT 1')->fetchField();
  $options = unserialize($options);
  return($options['network']);
}

/**
 * Implements hook_facetapi_facet_info().
 *
 * Returns information about all "fields" (properties/attributes) which are facetable
 */
function osf_searchapi_facetapi_facet_info(array $searcher_info) {
  static $facets = array();

  $defaultEndpoint = osf_configure_get_endpoint_by_uri(osf_searchapi_get_endpoint_uri_from_server());

  // Make sure that if there is no default endpoint available, that we return no facets.
  if(empty($defaultEndpoint))
  {
    return(array());
  }
  
  if (empty($facets)) {
    // The dataset an item belongs to is always available as a facet even though it isn't a property
    $facets += osf_searchapi_facet_config(Namespaces::$void . 'Dataset');

    // do an unbounded search requesting aggregates to determine all properties available
    $search = new SearchQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());

    _osf_searchapi_apply_search_settings($search);

    // Just keep the datasets that are searchable
    $filterDatasets = array();
    $datasets = osf_configure_dataset_generate_config_searchable('configured-default');

    foreach($datasets as $dataset)
    {
      $filterDatasets[] = $dataset;
    }
    
    $search->datasetsFilters((empty($filterDatasets) ? array('none') : $filterDatasets));    
    
    $search->includeAggregates()
           ->enableInference()
           ->items(0)
           ->lang(get_lang('en'))
           ->send(new DrupalQuerierExtension());

    $availableFacets = variable_get('osf_searchapi_facets_selected', array());  
    
    if ($search && $search->getResultset()) {
      $resultset = $search->getResultset()->getResultset();

      foreach ($resultset as $items) {
        foreach ($items as $uri => $item) {
          
          if($item['type'][0] != Namespaces::$aggr . 'Aggregate') {
            continue;
          }
          
          $type = $item['http://purl.org/ontology/aggregate#property'][0]['uri'];
          $pkey = $item['http://purl.org/ontology/aggregate#object'][0]['uri'];

          if(!isset($facets[osf_searchapi_facet_key_hash($pkey)]) && 
              $type == 'http://www.w3.org/1999/02/22-rdf-syntax-ns#Property' &&
              $availableFacets[$pkey] === $pkey) 
          {
            $facets += osf_searchapi_facet_config($pkey);
          }
        }
      }
    }
    else {
      return array();
    } 
  }

  // Creating a cache for all the properties/classes/datasets filters that could be used.
  $facetsUris = array();
  $properties = variable_get("osf_entities_properties", array());
  foreach($properties as $uri => $property) {
    $label = "";
    $propertySubject = unserialize($properties[$uri]);
    $label = $propertySubject->getPrefLabel();
    if($label == "") {
      $label = osf_searchapi_get_label_from_uri($uri);
    }
    $facetsUris[$uri] = $label;
  }
  
  cache_set('osf_searchapi_facets_properties_uris_labels', $facetsUris);

  $facetsUris = array();
  
  $loadedOntologies = osf_get_loaded_ontologies();
  
  $sparql = new SparqlQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_first_user_uri());
  
  $sparql->mime("application/sparql-results+json");
  
  $query = "select ?s ?label \n";

  foreach(array_keys($loadedOntologies) as $ontology)
  {
    $query .= "from <$ontology> \n";
  }
   
  $query .= 'where
             {
               ?s a <http://www.w3.org/2002/07/owl#Class> ;
                  ?p ?label .
             
               filter(?p in (<http://www.w3.org/2000/01/rdf-schema#label>, <http://purl.org/ontology/iron#prefLabel>,<http://purl.org/dc/terms/title>,<http://purl.org/dc/elements/1.1/title>,<http://www.w3.org/2004/02/skos/core#prefLabel>,<http://www.w3.org/2008/05/skos#prefLabel>)) .
             }
            ';
  
  $sparql->query($query);
  
  $sparql->send(new DrupalQuerierExtension());
  
  $results = array();  

  if(!$sparql->isSuccessful())
  {
    drupal_set_message(t("Can't get ontologies labels: [@error] @errorMsg - @errorDescription", 
                       array("@error" => $sparql->getStatus(),
                             "@errorMsg" => $sparql->getStatusMessage(),
                             "@errorDescription" => $sparql->getStatusMessageDescription())), 
                       "error", 
                       TRUE);
  }
  else
  {  
    $json = json_decode($sparql->getResultset(), true);
    
    foreach($json['results']['bindings'] as $result)
    {
      $facetsUris[$result['s']['value']] = $result['label']['value'];
    }
  }
  
  cache_set('osf_searchapi_facets_classes_uris_labels', $facetsUris);

  $facetsUris = osf_configure_dataset_generate_config_searchable('configured-default');
  cache_set('osf_searchapi_facets_datasets_uris_labels', $facetsUris);

  return $facets;
}

function osf_searchapi_get_label_from_uri($uri)
{
  $pos = strripos($uri, "#");

  if ($pos === FALSE)
  {
    $pos = strripos($uri, "/");
  }

  if ($pos !== FALSE)
  {
    $pos++;
  }

  $resource = substr($uri, $pos, strlen($uri) - $pos);

  return($resource);
}


/**
 * Implements hook_theme_registry_alter().
 *
 * Overrides the theme function for search_api_page_result to the function below.
 */
function osf_searchapi_theme_registry_alter(&$theme_registry) {
  // theme_search_api_page_result
  $theme_registry['search_api_page_result']['file'] = 'osf_searchapi.module';
  $theme_registry['search_api_page_result']['theme path'] = drupal_get_path('module', 'osf_searchapi');
  $theme_registry['search_api_page_result']['function'] = 'theme_osf_searchapi_search_api_page_result'; //theme_search_api_page_result
  $theme_registry['search_api_page_result']['includes'] = array(); //sites/all/modules/search_api_page/search_api_page.pages.inc
}


/**
 * Implements hook_theme().
 */
function osf_searchapi_theme($existing, $type, $theme, $path) {
  // Here we have to define *all* the possible themes that can exists. These are the 
  // bundles that got synchronized in OSF Entities.
  
  global $base_path;
  
  $themes = array();
  
  // Add the core default theme
  // Make sure the template exists before adding it to the list of possible theme templates
  // The template can exists in one of the following folders:
  //
  //   (1) The osf_searchapi folder
  //   (2) The 'templates' folder of the default theme
  //    
  if(file_exists(getcwd().'/'.$path.'/'.'resource_type__search.tpl.php') ||
     file_exists(getcwd().'/'.drupal_get_path('theme', variable_get('theme_default', NULL)).'/templates/resource_type__search.tpl.php'))
  {
    $themes['resource_type__search'] = array('variables' => array('entity' => NULL, 'item' => NULL, 'index' => NULL),
                                            'template' => 'resource_type__search');
  }

  // Scan the directory of the theme's folder
  $templates = file_scan_directory(getcwd().'/'.drupal_get_path('theme', variable_get('theme_default', NULL)), '/resource_type.*__search.tpl.php/');
  foreach($templates as $template)
  {
    $template = str_replace('.tpl.php', '', $template->filename);
    $themes[$template] = array('variables' => array('entity' => NULL, 'item' => NULL, 'index' => NULL),
                                                    'template' => $template.'.tpl.php.tpl.php');
  }  
  
  // Scan the directory of the OSF SearchAPI module
  $templates = file_scan_directory(getcwd().'/'.$path.'/', '/resource_type.*__search.tpl.php/');
  foreach($templates as $template)
  {
    $template = str_replace('.tpl.php', '', $template->filename);

    // Use the templates from the theme before using the templates defined in the module    
    if(!isset($themes[$template]))
    {
      $themes[$template] = array('variables' => array('entity' => NULL, 'item' => NULL, 'index' => NULL),
                                                      'template' => $template.'.tpl.php.tpl.php');
    }
  }
 
  return($themes);  
}

function osf_searchapi_preprocess_resource_type__search(&$vars, $hook) 
{
  $superClasses = array();

  // Expose the $subject variable to the search templates
  $vars['subject'] = $vars['entity']->obj;
  
  // Export the $resource variable to the search templates
  $resource = new Resource($vars['entity']->obj->getUri());

  $currentLanguage = get_lang(get_default_language());

  $resource->importSubject($vars['entity']->obj)
           ->setLanguage(($currentLanguage == 'und' ? NULL : $currentLanguage));
  
  $vars['resource'] = $resource;
  
  // For each type of the resource, we get the list of its super-types. 
  // Then we will use that list to create the template suggestions.
  foreach($vars['entity']->rdf_type as $type)
  {
    $superTypes = &drupal_static('osf_entities_class_type_supertypes_'.md5($type));
    
    if(!isset($superTypes)) 
    {
      if($cache = cache_get('osf_entities_class_type_supertypes_'.md5($type))) 
      {
        $superTypes = $cache->data;
      }
      else
      {
        $superTypes = osf_ontology_get_super_classes_hierarchy($type);
        
        cache_set('osf_entities_class_type_supertypes_'.md5($type), $superTypes, 'cache', CACHE_TEMPORARY);
      }
    }        
    
    $superClasses[$type] = $superTypes;
  }
  
  $vars['theme_hook_suggestions'] = array();
  
  // Here we specify the priority order of all the templates that may be defined in osf_entities_theme()
  $vars['theme_hook_suggestions'][] = 'resource_type__search';
  
  foreach($vars['entity']->type as $type)
  {    
    $superTypesFILO = _osf_entities_get_filo_supertypes($superClasses);
    
    foreach($superTypesFILO as $st)
    {
      $vars['theme_hook_suggestions'][] = 'resource_type__'.resource_type_get_id($st).'__search';
    }
  }
}

/**
 * Theme function for displaying search results.
 *
 * @param array $variables
 *   An associative array containing:
 *   - index: The index this search was executed on.
 *   - results: An array of search results, as returned by
 *     SearchApiQueryInterface::execute().
 *   - items: The loaded items for all results, in an array keyed by ID.
 *   - view_mode: The view mode to use for displaying the individual results,
 *     or the special mode "search_api_page_result" to use the theme function
 *     of the same name.
 *   - keys: The keywords of the executed search.
 */
function theme_osf_searchapi_search_api_page_result($variables) {
  $index = $variables['index'];
  $id = $variables['result']['id'];
  $entities = entity_load($variables['item']['type'], array($id));
  $entity = $entities[$id];

  $rendered_entity = theme('resource_type__search', array('entity' => $entity, 'item' => $variables['item'], 'index' => $index));

  return $rendered_entity;
}