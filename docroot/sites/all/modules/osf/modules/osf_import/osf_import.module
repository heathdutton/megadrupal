<?php

use \StructuredDynamics\osf\php\api\ws\crud\create\CrudCreateQuery;
use \StructuredDynamics\osf\php\api\ws\dataset\create\DatasetCreateQuery;
use \StructuredDynamics\osf\php\api\ws\dataset\delete\DatasetDeleteQuery;
use \StructuredDynamics\osf\php\api\ws\auth\lister\AuthListerQuery;
use \StructuredDynamics\osf\php\api\framework\CRUDPermission;
use \StructuredDynamics\osf\php\api\ws\auth\registrar\access\AuthRegistrarAccessQuery;

/** @defgroup OSFImportModule OSF Import Drupal Module */
//@{

// Include the utilities function used by the hooks and tools
include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'osf') . '/framework/utilities.php';
include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'osf') . '/framework/ClassHierarchy.php';
include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'osf') . '/framework/PropertyHierarchy.php';

use \StructuredDynamics\osf\ws\framework\ClassHierarchy;
use \StructuredDynamics\osf\ws\framework\ClassNode;
use \StructuredDynamics\osf\ws\framework\PropertyHierarchy;
use \StructuredDynamics\osf\ws\framework\PropertyNode;

/** 
 * @file osf_import.module
 * @brief The OSF Import module file.
 * @details This file includes all the other PHP files needed to run this Drupal module.
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 */

/** 
 * @brief Main Drupal hook procedure
 * @details This hook is the first one called by Drupal when one of the module's page is accessed.
 * We use this hook to:
 * \li Get the URI that has been accessed by the user
 * \li Trigger the OSF for Drupal tool related to this URI by calling its main procedure.
 * 
 * @return A string containing the HTML page description generated by the OSF for Drupal tool
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 */
function osf_import_main() {

  global $theme;

  drupal_add_css(drupal_get_path('theme', $theme) . 'style.css');  
  
  return (osf_import());
}

/** 
 * @brief Declare a block or set of blocks.
 * @details 	Any module can create a block (or blocks) to be displayed by defining the _block hook. This hook
 * is called by theme.inc to display a block, and also by block.module to procure the list of available blocks.
 * 
 * The functions mymodule_display_block_1 and 2, as used in the example, should of course be defined
 * somewhere in your module and return the content you want to display to your users. If the "content"
 * element is empty, no block will be displayed even if "subject" is present.
 * 
 * After completing your blocks, do not forget to enable them in the block admin menu.
 * 
 * @param[in] $op What kind of information to retrieve about the block or blocks. Possible values:
 * @li 'list': A list of all blocks defined by the module.
 * @li 'configure': Configuration form for the block.
 * @li 'save': Save the configuration options.
 * @li 'view': Process the block when enabled in a region in order to view its contents.
 * 
 * @param[in] $delta Which block to return (not applicable if $op is 'list'). Although it is most commonly an integer starting at 0, this is not mandatory. For instance, aggregator.module uses string values for $delta.
 * 
 * @param[in] $edit If $op is 'save', the submitted form data from the configuration form.
 * 
 * @return If $op is 'list': An array of block descriptions. Each block description is an associative array.
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 * 
 * @see http://api.drupal.org/api/function/hook_block
 */
function osf_import_block_info() {
  // TODO Rename block deltas (e.g. delta-0) to readable strings.

  // If $op is "list", we just need to return a list of block descriptions.
  // This is used to provide a list of possible blocks to the administrator,
  // end users will not see these descriptions.
  $blocks['delta-0']['info'] = t('OSF Import');
  return $blocks;
}

/**
 * Implements hook_block_configure().
 */
function osf_import_block_configure($delta) {
  // TODO Rename block deltas (e.g. delta-0) to readable strings. // If $op is "configure", we need to provide the administrator with a
  // configuration form. The $delta parameter tells us which block is being
  // configured. In this example, we'll allow the administrator to customize
  // the text of the first block.
  $form = array();
  if ($delta == 'delta-0') {
    // All we need to provide is a text field, Drupal will take care of
    // the other block configuration options and the save button.
    $form['block_example_string'] = array(
      '#type' => 'textfield',
      '#title' => t('Block contents'),
      '#size' => 100,
      '#description' => t('This string will appear in the t Tool Tools menu'),
      '#default_value' => '',
    );
  }

  return $form;
}

/**
 * Implements hook_block_save().
 */
function osf_import_block_save($delta, $edit) {
  // TODO Rename block deltas (e.g. delta-0) to readable strings.

  // If $op is "save", we need to save settings from the configuration form.
  // Since the first block is the only one that allows configuration, we
  // need to check $delta to make sure we only save it.
  if ($delta == 'delta-0' && isset($edit['osf_import_string'])) {
    // Have Drupal save the string to the database.
    variable_set('osf_import_string', $edit['osf_import_string']);
  }
  return;
}

/**
 * Implements hook_block_view().
 */
function osf_import_block_view($delta) {
  // TODO Rename block deltas (e.g. delta-0) to readable strings.

  // If $op is "view", then we need to generate the block for display
  // purposes. The $delta parameter tells us which block is being requested.
  switch ($delta) {
    case 'delta-0':
      // The subject is displayed at the top of the block. Note that it
      // should be passed through t() for translation.
      $block['subject'] = t('OSF Import');
      // The content of the block is typically generated by calling a custom
      // function.
      $block['content'] = osf_import_contents(1);
      break;
  }
  return $block;
}

/** 
 * @brief Display the t Tool side-bar menu items
 * @details 	This function is called to generate the HTML of the tool lists being displayed in the side-bar.
 * 
 * @return A string where the HTML menus have been defined.
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 */
function osf_import_contents($which_block) {
  global $base_url;

  if ($which_block == 1) {
    $menuItems = array();

    $icon = theme('image', array('path' => drupal_get_path("module", "osf_import") . '/imgs/view_detailed.png', 'attributes' => array('style' => 'padding-right:5px;')));
    $menuItems[] = l($icon . t("Import"), 'osf/import', array('html' => TRUE));

    return implode('<br />', $menuItems);
  }
}

/** 
 * @brief Define menu items and page callbacks.
 * @details 	This hook enables modules to register paths, which determines whose requests are to be handled.
 * Depending on the type of registration requested by each path, a link is placed in the the navigation
 * block and/or an item appears in the menu administration page (q=admin/menu).
 * 
 * @return An array of menu items. Each menu item has a key corresponding to the Drupal path being registered.
 * The item is an associative array.
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 * 
 * @see http://api.drupal.org/api/function/hook_block
 */
function osf_import_menu() {
  $items = array();

  // Registration of the main t Tool module page path
  $items['osf/import'] = array(
    'page callback' => 'osf_import_main',
    'access arguments' => array('access osf import'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

function osf_import_admin_paths() 
{
  $paths = array(
    'osf/import' => TRUE,
  );
    
  return $paths;
}


/** 
 * @brief Define user permissions.
 * @details 	This hook can supply permissions that the module defines, so that they can be selected on the user
 * permissions page and used to restrict access to actions the module performs.
 * 
 * The permissions in the array do not need to be wrapped with the function t(), since the string extractor
 * takes care of extracting permission names defined in the perm hook for translation.
 * 
 * Permissions are checked using user_access().
 * 
 * @note Currently only two kind of users exist: (1) "access" and (2) "administer". However, we expect to have more
 * kind of users in the future for different node maintenance purposes.
 * 
 * @note Depending on the user (access or administer), some part of this create module will be available to the user.
 * 
 * @note Once new permissions are created, the node administrator has to set their permissions in the setting panel
 * of the node
 * 
 * @return An array of permissions strings.
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 * 
 * @see http://api.drupal.org/api/function/hook_perm
 */
function osf_import_permission() {
  return array(
    'access osf import' => array(
      'title' => t('access osf import'),
      'description' => t('access osf import'),
    ),
    'administer osf import' => array(
      'title' => t('administer osf import'),
      'description' => t('administer osf import'),
    ),
  );
}


/** 
 * @brief Entry point of the "Import Tool"
 * @details 	The Import tool is used import datasets from files.
 * 
 * @return a string containing the HTML page generated by the Import tool.
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 */
function osf_import() {
  $html = "";

  // Check if a file has been uploaded
  if (isset($_FILES) && count($_FILES) > 0) {
    // Check if the upload of the file is sucessful
    if ($_FILES['userfile']['error'] == UPLOAD_ERR_OK) {
      // Once we start the importation process, we have to make sure that even if the server
      // loose the connection with the user the process will still finish.
      ignore_user_abort(true);

      // However, maybe there is an issue with the server handling that file tht lead to some kind of infinite or near
      // infinite loop; so we have to limit the execution time of this procedure to 45 mins.
      drupal_set_time_limit(2700);

      // upload ok
      include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'osf') . '/framework/WebServiceQuerier.php';
      include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'osf') . '/framework/ProcessorXML.php';

      if (!isset($_POST["token"]) ||
          !drupal_valid_token($_POST["token"], 'osf-import')) {
        return drupal_access_denied();                       
      }
      
      $contentType = "";
      if (isset($_POST["ctype"])) {
        $contentType = $_POST["ctype"];
      }

      $datasetName = t("Unnamed dataset");

      if (isset($_POST["dname"])) {
        $datasetName = $_POST["dname"];
      }

      $datasetDescription = t("Unnamed dataset");

      if (isset($_POST["ddescription"])) {
        $datasetDescription = $_POST["ddescription"];
      }

      $customURI = "";

      if (isset($_POST["duri"])) {
        $customURI = $_POST["duri"];
      }

      $targetRole = "3";

      if (isset($_POST["roles"])) {
        $targetRole = $_POST["roles"];
      }

      $wsfAddress = "http://localhost/ws/";

      if (isset($_POST["osf"])) {
        $wsfAddress = $_POST["osf"];
      }
      
      $defaultEndpoint = osf_configure_get_endpoint_by_uri($wsfAddress);

      $rdfDocument = "";
      
      // Make sure that someone couldn't move outside of the /tmp/ directory with that file
      if(strpos($_FILES['userfile']['name'], '..'))
      {
        return "";
      }

      // Get the extension of the file
      preg_match("/.*\.(.*)$/",$_FILES['userfile']['name'], $matches);
      
      $fileExtension = $matches[1];
      
      // Sanitize the name of the file
      $filename = substr($_FILES['userfile']['name'], 0, (strlen($_FILES['userfile']['name']) - (strlen($fileExtension) + 1)));
      
      $filename = preg_replace('/[^a-zA-Z0-9_\-]/', '', $filename) . "." . $fileExtension;
      
      if (!move_uploaded_file($_FILES['userfile']['tmp_name'], "/tmp/" . $filename)) {
        return "";
      }

      // Read file from the server
      $file = fopen("/tmp/" . $filename, "r");

      $fileContent = "";
      
      while (!feof($file)) {
        $fileContent .= fread($file, 8192);
      }

      fclose($file);

      unlink("/tmp/" . $filename);

      global $user;
      global $base_url;

      // Create a new dataset where to index the imported data.
      // Get the list of registered web services
      $webservices = osf_configure_osf_get_registered_webservices($defaultEndpoint);      
      
      $uri_ending = strtolower($datasetName);
      $uri_ending = preg_replace('@[^a-z0-9_]+@','_',$uri_ending);      
      
      $dataset = str_replace('/ws/', '', $wsfAddress) . "/wsf/datasets/" . $uri_ending . "/";

      if ($customURI != "") {
        $dataset = $customURI;
      }
      
      $datasetCreate = new DatasetCreateQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
      
      $datasetCreate->title($datasetName)
                    ->description($datasetDescription)
                    ->uri($dataset)
                    ->creator($base_url . "/user/" . $user->uid)
                    ->targetWebservices($webservices)
                    ->send(new DrupalQuerierExtension());
      
      if(!$datasetCreate->isSuccessful())      
      {
        if($datasetCreate->error->id == 'WS-DATASET-CREATE-202')
        {
          drupal_set_message(t("The dataset is already existing."), 'warning', TRUE);        
        }
        else
        {
          drupal_set_message(t("An error occured when we tried to create the new dataset where to import the dataset."), 'warning', TRUE);
        }
        return('');
      } 
      else
      {
        // Create FULL CRUD permissions for the user that created it.
        $crudPermissions = new CRUDPermission(TRUE, TRUE, TRUE, TRUE);

        $authRegistrarAccess = new AuthRegistrarAccessQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
        
        $authRegistrarAccess->create($targetRole, $dataset, $crudPermissions, osf_configure_osf_get_registered_webservices($defaultEndpoint))
                            ->mime('text/xml')
                            ->send(new DrupalQuerierExtension());
                             
        if(!$authRegistrarAccess->isSuccessful())
        {
          drupal_set_message(t("Couldn't create permissions on the imported datasets for the specified group."), 'warning', TRUE);        
        }
        
        // Create FULL CRUD permissions for the administrator group
        if($targetRole != osf_configure_get_administrator_group_uri())
        {
          $authRegistrarAccess = new AuthRegistrarAccessQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_first_user_uri());
          
          $authRegistrarAccess->create(osf_configure_get_administrator_group_uri(), $dataset, $crudPermissions, osf_configure_osf_get_registered_webservices($defaultEndpoint))
                              ->mime('text/xml')
                              ->send(new DrupalQuerierExtension());
                               
          if(!$authRegistrarAccess->isSuccessful())
          {
            drupal_set_message(t("Couldn't create permissions on the imported dataset for the administrator group."), 'warning', TRUE);        
          }            
        }
      }      
        
      // Handle conversion of the dataset if needed
      switch ($contentType) {
        case "irjson":
          $wsq = new WebServiceQuerier($wsfAddress . "converter/irjson/", "post", "application/rdf+xml",
            "document=" . urlencode($fileContent) .
          "&docmime=" . urlencode("application/iron+json"));
          
          if ($wsq->getStatus() != 200) {
            // In case of error, we have to delete the node we created above.
            $datasetDelete = new DatasetDeleteQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
            
            $datasetDelete->uri($dataset)
                          ->send(new DrupalQuerierExtension());
                          
            if(!$datasetDelete->isSuccessful())      
            {
              drupal_set_message(t("An error occured when we tried to delete the dataset that has been created to import the dataset."), 'warning', TRUE);
              return('');
            } 

            $wsq->displayError();

            return ("");
          }

          $rdfDocument = $wsq->getResultset();

          $contentType = "application/rdf+xml";

          unset($wsq);
          break;

        case "common":

          $wsq = new WebServiceQuerier($wsfAddress . "converter/common/", "post", "application/rdf+n3",
            "document=" . urlencode($fileContent) .
            "&docmime=" . urlencode("application/iron+csv"));

          if ($wsq->getStatus() != 200) {
            // In case of error, we have to delete the node we created above.
            $datasetDelete = new DatasetDeleteQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
            
            $datasetDelete->uri($dataset)
                          ->send(new DrupalQuerierExtension());
                          
            if(!$datasetDelete->isSuccessful())      
            {
              drupal_set_message(t("An error occured when we tried to delete the dataset that has been created to import the dataset."), 'warning', TRUE);
              return('');
            } 

            $wsq->displayError();

            return ("");
          }

          $rdfDocument = $wsq->getResultset();

          $contentType = "application/rdf+n3";

          unset($wsq);

          break;

        case "tsv":
          $wsq = new WebServiceQuerier($wsfAddress . "converter/tsv/", "post", "application/rdf+xml",
            "document=" . urlencode($fileContent) .
            "&docmime=" . urlencode("text/csv") .
            "&delimiter=\t" .
            "&base_uri=" . $dataset . "resource/");
            
          if ($wsq->getStatus() != 200) {
            // In case of error, we have to delete the node we created above.
            $datasetDelete = new DatasetDeleteQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
            
            $datasetDelete->uri($dataset)
                          ->send(new DrupalQuerierExtension());
                          
            if(!$datasetDelete->isSuccessful())      
            {
              drupal_set_message(t("An error occured when we tried to delete the dataset that has been created to import the dataset."), 'warning', TRUE);
              return('');
            } 

            $wsq->displayError();

            return ("");
          }

          $rdfDocument = $wsq->getResultset();
          $contentType = "application/rdf+xml";

          unset($wsq);
          break;

        case "csv":
          $wsq = new WebServiceQuerier($wsfAddress . "converter/tsv/", "post", "application/rdf+xml",
            "document=" . urlencode($fileContent) .
            "&docmime=" . urlencode("text/csv") .
            "&delimiter=" . urlencode(","),
            "&base_uri=" . $dataset . "resource/");
          if ($wsq->getStatus() != 200) {
            // In case of error, we have to delete the node we created above.
            $datasetDelete = new DatasetDeleteQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
            
            $datasetDelete->uri($dataset)
                          ->send(new DrupalQuerierExtension());
                          
            if(!$datasetDelete->isSuccessful())      
            {
              drupal_set_message(t("An error occured when we tried to delete the dataset that has been created to import the dataset."), 'warning', TRUE);
              return('');
            } 

            $wsq->displayError();

            return ("");
          }

          $rdfDocument = $wsq->getResultset();
          $contentType = "application/rdf+xml";

          unset($wsq);
          break;

        case "rdf_xml":
          $rdfDocument = $fileContent;
          $contentType = "application/rdf+xml";
          break;

        case "rdf_n3":
          $rdfDocument = $fileContent;
          $contentType = "application/rdf+n3";
          break;

        default:        
          // In case of error, we have to delete the node we created above.
          $datasetDelete = new DatasetDeleteQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
          
          $datasetDelete->uri($dataset)
                        ->send(new DrupalQuerierExtension());
                        
          if(!$datasetDelete->isSuccessful())      
          {
            drupal_set_message(t("An error occured when we tried to delete the dataset that has been created to import the dataset."), 'warning', TRUE);
            return('');
          }                           
          
          return "";
          break;
      }

      // Now check if some of the attributes/types imported  are not currently defined in the
      // internal ontological structure.
      if (isset($_POST["checkAT"]) && $_POST["checkAT"] == "on") {
        include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'osf') . '/framework/arc2/ARC2.php';

        $parser = ARC2::getRDFParser();
        $parser->parse("", $rdfDocument);

        if ($contentType == "application/rdf+xml") {
          $rdfxmlSerializer = ARC2::getRDFXMLSerializer();
        }

        if ($contentType == "application/rdf+n3") {
          $rdfxmlSerializer = ARC2::getNTriplesSerializer();
        }

        $resourceIndex = $parser->getSimpleIndex(0);

        $usedProperties = array();

        $usedTypes = array();

        // If we can read the generated rdf document with ARC2, we try to figure out if some
        // types/properties have been used which are not in the ontological structure.
        if (count($parser->getErrors()) <= 0 && $rdfxmlSerializer) {
          foreach ($resourceIndex as $resource => $description) {
            foreach ($description as $predicate => $values) {
              if ($predicate == "http://www.w3.org/1999/02/22-rdf-syntax-ns#type") {
                foreach ($values as $value) {
                  if ($value["type"] == "uri") {
                    if (array_search($value["value"], $usedTypes) === FALSE) {
                      array_push($usedTypes, $value["value"]);
                    }
                  }
                }
              }
              else {
                if (array_search($predicate, $usedProperties) === FALSE) {
                  array_push($usedProperties, $predicate);
                }
              }
            }
          }
        }
        unset($parser);
      }

      // Import dataset by using the CrudCreate web service
      $crudCreate = new CrudCreateQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
      
      $crudCreate->dataset($dataset)
                 ->document($rdfDocument);
                 
      if($contentType == 'application/rdf+xml')
      {
        $crudCreate->documentMimeIsRdfXml();
      }
      else
      {
        $crudCreate->documentMimeIsRdfN3();
      }
                 
      $crudCreate->send(new DrupalQuerierExtension());

      if (!$crudCreate->isSuccessful()) {        
        // In case of error, we have to delete the node we created above.
        $datasetDelete = new DatasetDeleteQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
        
        $datasetDelete->uri($dataset)
                      ->send(new DrupalQuerierExtension());
                      
        if(!$datasetDelete->isSuccessful())      
        {
          drupal_set_message(t("An error occured when we tried to delete the dataset that has been created to import the dataset."), 'warning', TRUE);
          return('');
        } 

        // The size of the converted document is too big.
        if (strpos($crudCreate->getStatusMessageDescription(), 'WSF-600') !== FALSE) {
          // In case of error, we have to delete the node we created above.
          $datasetDelete = new DatasetDeleteQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
          
          $datasetDelete->uri($dataset)
                        ->send(new DrupalQuerierExtension());
                        
          if(!$datasetDelete->isSuccessful())      
          {
            drupal_set_message(t("An error occured when we tried to delete the dataset that has been created to import the dataset."), 'warning', TRUE);
            return('');
          } 

          $uploadMaxFileSize = ini_get("post_max_size");
          $uploadMaxFileSize = str_replace("M", "000000", $uploadMaxFileSize);

          // The converted dataset is too big to be processed by this tool
          drupal_set_message(t("The converted dataset file is too big to be processed by
                               this import tool. You will have to split the file in multiple
                               slices that you will import using this tool, and then append
                               using the Append tool. Or you will have to create a new
                               procedure that can handle files of that size. The size of the
                               converted file is @sizeConverted bytes, and the autorized
                               file size is @sizeAuthorized bytes",
                               array(
            "@sizeConverted" => number_format(strlen($rdfDocument), 0, " ", " "),
            "@sizeAuthorized" => number_format($uploadMaxFileSize, 0, " ", " "),
          )),
                                     "error", TRUE);
        }
        else {
          echo "Creation failed: ".$crudCreate->getStatus()." (".$crudCreate->getStatusMessage().")\n";
          echo $crudCreate->getStatusMessageDescription();
        }

        return ("");
      }

      // Now that everything succeeded, we have to clear the cache such that the new
      // imported dataset become visible to structConf
      drupal_flush_all_caches();       
      
      $undefinedPredicates = array();
      $undefinedTypes = array();

      if (isset($_POST["checkAT"]) && $_POST["checkAT"] == "on") {
        // Now check to make sure that all the predicates and types are in the ontological structure.
        $cache_path = rtrim(variable_get('osf_OntologySettings_ontologies_cache_folder', '/tmp'), '/') . '/';
        $filename = $cache_path . 'classHierarchySerialized.srz';
        $file = fopen($filename, "r");
        $classHierarchy = fread($file, filesize($filename));
        $classHierarchy = unserialize($classHierarchy);
        fclose($file);

        $filename = $cache_path . 'propertyHierarchySerialized.srz';
        $file = fopen($filename, "r");
        $propertyHierarchy = fread($file, filesize($filename));
        $propertyHierarchy = unserialize($propertyHierarchy);
        fclose($file);

        foreach ($usedProperties as $usedPredicate) {
          $found = FALSE;
          foreach ($propertyHierarchy->properties as $property) {
            if ($property->name == $usedPredicate) {
              $found = TRUE;
              break;
            }
          }

          if ($found === FALSE) {
            array_push($undefinedPredicates, $usedPredicate);
          }
        }

        foreach ($usedTypes as $type) {
          $found = FALSE;
          foreach ($classHierarchy->classes as $class) {
            if ($class->name == $type) {
              $found = TRUE;
              break;
            }
          }

          if ($found === FALSE) {
            array_push($undefinedTypes, $type);
          }
        }
      }
      else {
        drupal_set_message(t("Checking of un-handled attributes and types has been disabled by the importer.
                              Make sure that all the types and attributes used to describe the imported
                              dataset are defined in the ontological structure of this node. Otherwise
                              unwelcome behaviors could happen."), "warning", TRUE);

        return("<form><input class=\"form-text\" type=\"button\" value=\"".t('Expose Imported Dataset')."\" onClick=\"parent.location='/admin/config/osf/networks_and_dataset/datasets/add?uri=".urlencode($dataset)."'\" /></form>");
      }

      if (count($undefinedPredicates) == 0 && count($undefinedTypes) == 0) {
        // Redirect OSF Configure to expose the dataset
        header("Location: /admin/config/osf/networks_and_dataset/datasets");
      }
      else {
        // We display the missing predicates & classes notices with a button

        $pErrors = "";

        if (count($undefinedPredicates) > 0) {
          $pErrors = "<h2>".t('Undefined Attributes')."</h2><ol>";
          foreach ($undefinedPredicates as $p) {
            $pErrors .= "<li>$p</li>";
          }
          $pErrors .= "</ol>";
        }

        $errorMsg = t("Warning: some types and attributes were used in the file that you were importing that are not
                     currently defined in the ontological structure of this system. Everything will works
                     fine, but some unexpected display behaviors could occurs for some usecase. We
                     suggest to take these attributes and types in node to define them in the ontological
                     structure in the future.");

        drupal_set_message(t("@warning", array("@warning" => $errorMsg)), "warning", TRUE);

        foreach ($undefinedPredicates as $p) {
          drupal_set_message(t("Undefined attributes: @warning", array("@warning" => $p)), "warning", TRUE);
        }

        foreach ($undefinedTypes as $t) {
          drupal_set_message(t("Undefined types: @warning", array("@warning" => $t)), "warning", TRUE);
        }

        return("<form><input class=\"form-text\" type=\"button\" value=\"".t('Expose Imported Dataset')."\" onClick=\"parent.location='/admin/config/osf/networks_and_dataset/datasets/add?uri=".urlencode($dataset)."'\" /></form>");
      }
    }
    else {
      drupal_set_message(t("File upload failed with error: @error",
        array("@error" => file_upload_error_message($_FILES['userfile']['error']))), "error", TRUE);

      return("");
    }
  }
  else {
    $html .= "<h2>".t('Import Dataset')."</h2>";

    // Get all available OSF instances available to this t Tool node
    $wsfRegistry = osf_configure_get_endpoints(NULL, FALSE, TRUE);

    $sidHtml = "";

    foreach ($wsfRegistry as $s => $wsfs) {
      $sidHtml .= "<option value=\"" . $wsfs->uri . "\" /> " . $wsfs->uri;
    }

    // If no SID are available, lets test if there is a local OSF instance available
    if ($sidHtml == "") {
      $ch = curl_init();

      curl_setopt($ch, CURLOPT_HEADER, 0);
      curl_setopt($ch, CURLOPT_URL, "http://localhost/ws/index.php");
      curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
      curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);

      $data = curl_exec($ch);

      if (curl_errno($ch)) {
        curl_close($ch);

        // no local SID are existing, so we send an error to the user.
        drupal_set_message(t("No OSF instance are available for this t Tool node. Please" .
          "contact the system administrator to link this t Tool instance" .
          "to a OSF instance."), "error", TRUE);

        return ("");
      }
      else {
        $sidHtml .= "<option value=\"http://localhost/ws/\" /> http://localhost/ws/";
      }

      curl_close($ch);
    }
    
    global $user;

    $rolesHtml = '';
    
    foreach($user->roles as $role_id => $role_name)
    {
      $groupURI = osf_get_group_uri($role_id, $role_name);
      
      $rolesHtml .= "<option value=\"$groupURI\" /> $role_name";
    }

    $html
      .= "	<form enctype=\"multipart/form-data\" action=\"\" method=\"POST\">
			
			          <input class=\"form-text\" type=\"hidden\" name=\"token\" value=\"".drupal_get_token('osf-import')."\" />
			
								<table width=\"100%\" border=\"0\">
								    <tr><td>&nbsp;</td><td>&nbsp;</td></tr>
								    <tr>
								        <td>
											".t('Dataset file to import:')."
								        </td>
								        <td>
											<input class=\"form-text\" name=\"userfile\" type=\"file\" size=\"61\" />
								        </td>
								    </tr>
								    <tr>
								        <td>
											".t('Content type:')."
								        </td>
								        <td>
											<select class=\"form-select\" name=\"ctype\" size=\"1\" style=\"width: 400px;\">
												<!--<option value=\"bibjson\" /> ".t('BibJSON')."-->
                        <option value=\"common\" /> ".t('commON (csv)')."
                        <option value=\"irjson\" /> ".t('irJSON')."
												<!--<option value=\"bibtex\" /> ".t('BibTex')."-->
												<option value=\"tsv\" /> ".t('N-Triples/TSV')."
												<option value=\"csv\" /> ".t('N-Triples/CSV')."
												<option value=\"rdf_xml\" /> ".t('RDF+XML')."
												<option value=\"rdf_n3\" /> ".t('RDF+N3')."
											</select>
								        </td>
								    </tr>
								    <tr>
								        <td>
											".t('Dataset name:')."
								        </td>
								        <td>
											<input class=\"form-text\" name=\"dname\" type=\"text\" size=\"64\" maxlength=\"256\" />
								        </td>
								    </tr>
                    <tr>
                        <td>
                      ".t('Dataset description:')."
                        </td>
                        <td>
                      <input class=\"form-text\" name=\"ddescription\" type=\"text\" size=\"64\" maxlength=\"256\" />
                        </td>
                    </tr>
                    <tr>
                        <td>
                      ".t('Custom Dataset URI (Optional):')."
                        </td>
                        <td>
                      <input class=\"form-text\" name=\"duri\" type=\"text\" size=\"64\" maxlength=\"2024\" />
                        </td>
                    </tr>
                    <tr>
                        <td>
                      ".t('Save dataset on this network:')."
                        </td>
                        <td>
                      <select class=\"form-select\" name=\"osf\" size=\"1\" style=\"width: 400px;\">
                        $sidHtml
                      </select>
                        </td>
                    </tr>
                    <tr>
                        <td>
                      ".t('Which role should have full permissions on this new dataset:')."
                        </td>
                        <td>
                      <select class=\"form-select\" name=\"roles\" size=\"1\" style=\"width: 400px;\">
                        $rolesHtml
                      </select>
                        </td>
                    </tr>
                    <tr>
                        <td style=\"padding-top: 15px;\">
                      ".t('Check attributes and types existance:')." <br>
                      <b>".t('Time consuming')."</b>
                        </td>
                        <td style=\"padding-top: 15px;\">
                        <input class=\"form-text\" type=\"checkbox\" name=\"checkAT\" checked> ".t('Check for missing attributes and types in the imported dataset. <br />This should be unchecked for big datasets because of the resources needed to make this check.')."
                        </td>
                    </tr>
									<tr><td>&nbsp;</td><td>&nbsp;</td></tr>
								    <tr>
								        <td colspan=\"2\" align=\"center\">
											<input class=\"form-text\" type=\"submit\" value=\"".t('Import Dataset')."\" />
								        </td>
								    </tr>
								</table>
							</form>	
						";
  }

  return ($html);
}

/**
 * @TODO document this function
 */
function file_upload_error_message($error_code) {
  switch ($error_code)   {
    case UPLOAD_ERR_INI_SIZE: 
        return t('File size is too big. The maximum file size is 8mb.');

    /*! @todo fix the size of the error message with the one of the setting of the node */
    case UPLOAD_ERR_FORM_SIZE:
      return t('File size is too big. The maximum file size is 8mb.');

    case UPLOAD_ERR_PARTIAL:
      return t('The uploaded file was only partially uploaded');

    case UPLOAD_ERR_NO_FILE:
        return t('No file was uploaded');

    case UPLOAD_ERR_NO_TMP_DIR:
        return t('Missing a temporary folder');

    case UPLOAD_ERR_CANT_WRITE:
        return t('Failed to write file to disk');

    case UPLOAD_ERR_EXTENSION:
        return t('File upload stopped by extension');

    default:
      return t('Unknown upload error');
  }
}
//@}
