<?php
use \StructuredDynamics\osf\php\api\ws\scones\SconesQuery;
use \StructuredDynamics\osf\php\api\ws\crud\read\CrudReadQuery;
use \StructuredDynamics\osf\framework\Namespaces;
use \StructuredDynamics\osf\php\api\ws\search\SearchQuery;


/**
 * implements hook_menu()
 *
 * add a autocomplete callback url
 */
function osf_field_menu() {
  $items['osf/field/get/%'] = array(
    'page callback' => 'osf_field_text_autocomplete',
    'page arguments' => array(3,4),
    'access arguments' => array('view resource entities'),
    'type' => MENU_CALLBACK
  );
  
  return $items;
}

/**
 * Implements hook_field_widget_info().
 */
function osf_field_field_widget_info() {
  return array(
    'osf_field_concept_reference' => array(
      'label' => t('OSF Concept Reference (Tagging)'),
      'settings' => array(
        'datasets' => array(),
        'ontologies_datasets' => array(),
        'scones_fields'=>array(),
        'max_count' => 20,
      ),
      'field types' => array('text'),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
      ),
    ),
    'osf_field_entity_reference' => array(
      'label' => t('OSF Entity Reference'),
      'settings' => array(
        'datasets' => array(),
        'ontologies_datasets' => array(),
        'scones_fields'=>array(),
        'filter' => '',
        'max_count' => 20,
      ),
      'field types' => array('text'),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
      ),
    ),    
  );
}

/**
 * implements hook_field_widget_settings_form()
 */
function osf_field_field_widget_settings_form($field, $instance) 
{             
  drupal_add_js("
    function checkUncheckAll(checkAllElement){
      var fieldsSet = jQuery(checkAllElement).parent().parent().find('input'), z = 0;
      for(z = 0; z < fieldsSet.length ; z++){
        if(fieldsSet[z].type == 'checkbox' && fieldsSet[z].name != 'checkall' && !fieldsSet[z].disabled){
          fieldsSet[z].checked = checkAllElement.checked;
        }
      }
    }
  ", 'inline');  
   
  $wtype = $instance['widget']['type'];
  $fields = field_info_instances($instance['entity_type'], $instance['bundle']);  

  // List the fields that can be used for the test input
  $options = array();
  
  foreach(osf_entities_get_fields_by_bundles()[$instance['bundle']] as $field)
  {
    $field = field_info_field($field);
    
    if($field['type'] == 'link_field' ||
       $field['type'] == 'text' ||
       $field['type'] == 'text_long')
    {
      $options[$field['field_name']] = $field['field_name'];
    }
  }
  
  foreach($fields as $key => $field) 
  {    
    if(in_array($field['widget']['type'], osf_field_acceptable_widgets())) 
    {
      $options["$key::{$field['widget']['type']}"] = $field['label'];
    }
  }
  
  if($wtype == 'osf_field_concept_reference') 
  {        
    $our_form['scones_fields'] = array(
      '#type' => 'checkboxes',
      '#options' => $options,
      '#default_value' => $instance['widget']['settings']['scones_fields'],
      '#title' => t('Fields to include in SCONES lookup'),
    );
    
    $our_form['max_count'] = array(
      '#type' => 'select',
      '#default_value' => $instance['widget']['settings']['max_count'],
      '#options' => array_combine(array(1,2,3,5,8,13,20,30,50), array(1,2,3,5,8,13,20,30,50)),
      '#title' => t('Max number of suggestions'),
    );
    
    $our_form['scones_type'] = array(
      '#type' => 'radios',
      '#required' => FALSE,
      '#title' => t('Scones tagger'),
      '#default_value' => (isset($instance['widget']['settings']['scones_type']) ? $instance['widget']['settings']['scones_type'] : 'plain'),
      '#options' => array(
                      'plain' => t('Plain'),
                      'noun' => t('Noun')
                    ),
      '#description' => t('Specify the type of Scones tagger to use for this field. The plain tagger will use
                           all the words of the input text as potential tag candicates. The noun tagger will
                           restrict the tagging to the words tha are considered nouns in the text.'),
    );     
    
    $our_form['stemming'] = array(
      '#type' => 'checkbox',
      '#title' => t('Use stemming'),
      '#default_value' => $instance['widget']['settings']['stemming'],
      '#description' => t('Specify if you want to use stemming when performing the Scones tagging.'),
    );    
  }
  
  if($wtype == 'osf_field_entity_reference') 
  {    
    $datasetsOptions = array();
    
    foreach(osf_configure_dataset_load_util('configured') as $dataset)
    {
      $datasetsOptions[$dataset->uri] = $dataset->label;
    }
    
    asort($datasetsOptions, SORT_STRING);
    
    $our_form['datasets_filters'] = array(
      '#type' => 'fieldset',
      '#title' => t('Datasets to use when searching for an entity to reference'),
      '#description' => t('Specify all the datasets where you want this field widget search for entity references.<br /><br />'),
      '#collapsible' => FALSE,
      '#collapsed' => FALSE,    
    );    
    
    $our_form['datasets_filters']['checkall_datasets'] = array(
      '#type' => 'checkbox',
      '#title' => t('Select / Unselect all'),
      '#attributes' => array('onclick' => 'checkUncheckAll(this);'),
      '#weight' => -1,
    );     
    
    $our_form['datasets_filters']['datasets'] = array(
      '#type' => 'checkboxes',
      '#options' => $datasetsOptions,
      '#default_value' => $instance['widget']['settings']['datasets_filters']['datasets'],
      '#title' => t(''),
    );
    
    $ontologiesDatasetsOptions = array();
    
    foreach(osf_get_loaded_ontologies() as $uri => $ontology)
    {
      $ontologiesDatasetsOptions[$uri] = $ontology['prefLabel'];
    }    
    
    asort($ontologiesDatasetsOptions, SORT_STRING);
    
    $our_form['ontologies_datasets_filters'] = array(
      '#type' => 'fieldset',
      '#title' => t('Ontologies datasets to use when searching for an entity to reference'),
      '#description' => t('Specify all the ontologies datasets where you want this field widget search for entity references.<br /><br />'),
      '#collapsible' => FALSE,
      '#collapsed' => FALSE,    
    );    
    
    $our_form['ontologies_datasets_filters']['checkall_datasets'] = array(
      '#type' => 'checkbox',
      '#title' => t('Select / Unselect all'),
      '#attributes' => array('onclick' => 'checkUncheckAll(this);'),
      '#weight' => -1,
    );     
    
    $our_form['ontologies_datasets_filters']['ontologies_datasets'] = array(
      '#type' => 'checkboxes',
      '#options' => $ontologiesDatasetsOptions,
      '#default_value' => $instance['widget']['settings']['ontologies_datasets_filters']['ontologies_datasets'],
      '#title' => t(''),
    );
    
    $our_form['filter'] = array(
      '#type' => 'textfield',
      '#default_value' => (!empty($instance['widget']['settings']['filter']) ? $instance['widget']['settings']['filter'] : 'http://www.w3.org/2002/07/owl#Thing'),
      '#description' => t('The type attribute to use while filtering the auto-complete options'),
      '#title' => t('Filter'),
    );      
  }
  
  if($wtype == 'osf_field_concept_reference')
  {
    $ontologiesOptions = array();
    
    foreach(osf_get_loaded_ontologies() as $uri => $ontology)
    {
      $ontologiesOptions[$uri] = $ontology['prefLabel'];
    }
    
    asort($ontologiesOptions, SORT_STRING);
    
    $our_form['ontologies_datasets_filters'] = array(
      '#type' => 'fieldset',
      '#title' => t('Ontologies datasets to use when searching for a concept to add'),
      '#description' => t('Specify all the ontologies datasets where you want this field widget search for concept reference.<br /><br />'),
      '#collapsible' => FALSE,
      '#collapsed' => FALSE,    
    );    
    
    $our_form['ontologies_datasets_filters']['checkall_datasets'] = array(
      '#type' => 'checkbox',
      '#title' => t('Select / Unselect all'),
      '#attributes' => array('onclick' => 'checkUncheckAll(this);'),
      '#weight' => -1,
    );     
    
    $our_form['ontologies_datasets_filters']['ontologies_datasets'] = array(
      '#type' => 'checkboxes',
      '#options' => $ontologiesOptions,
      '#default_value' => $instance['widget']['settings']['ontologies_datasets_filters']['ontologies_datasets'],
      '#title' => t(''),
    );    
  }
  
  return $our_form;
}

/**
 * implements hook_osf_field_extract
 *
 * @RETURN: an array which list 2 callback to extract value, one from
 * a form state imput and from from a form as well  as the widget on which
 * it works
 *
 * This are used to pull content out of fields on a form, so that it can be sent
 * to SCONES to get suggested tags
 *
 */
function osf_field_osf_field_extract() {
  return array(
    array(
      'input_callback' => 'osf_field_rec_extract_input',
      'form_callback' => 'osf_field_rec_extract_form',
      'widgets' => array( 'text_textarea_with_summary'),
    ),
    array(
      'input_callback' => 'osf_field_property_extract_input',
      'form_callback' => 'osf_field_property_extract_form',
      'widgets' => array( 'node_title'),
    )
  );
}

/**
 * @RETURN: a list of all widget type that can be used in the scones lookup
 */
function osf_field_acceptable_widgets() {
  $widgets = array();
  foreach(module_invoke_all("osf_field_extract") as $item) {
    foreach ($item['widgets'] as $w) {
      $widgets[$w] = $w;
    }
  }
  return $widgets;
}

/**
 * osf_field_extract_values use the hook_osf_field_extract system
 * to extract content from the fields on a drupal form.
 *
 * @PARAM $form: a drupal form
 * @PARAM $input: the input array from a drupal form_state
 * @PARAM $extract_identifiers: an array of strings of the from FIELDNAME::WIDGETTYPE
 * @RETURN a string containing all of the content for the FIELDNAME specified
 */
function osf_field_extract_values($form, $input, $fields) {
  $values = array();
  
  foreach($fields as $name)
  {
    if(!empty($input))
    {
      if(($name == 'iron_preflabel' ||
          $name == 'iron_description') &&
          !empty($input[$name]['#default_value']))
      {
        $values[] = $input[$name];
      }
      else
      {
        $langID = LANGUAGE_NONE;
        
        if(isset($input[$name][get_lang()]))
        {
          $langID = get_lang();
        }
        
        if(isset($input[$name][$langID][0]['url']))
        {
          // Handle link widget
          // In this case, we simply return that URL and ignore the other text.
          // we will provide the URL as the input to Scones
          $values[] = $input[$name][$langID][0]['url'];
        }      
        elseif(isset($input[$name][$langID][0]['value']))
        {
          // Handle text and text_long widgets
          $values[] = $input[$name][$langID][0]['value'];
        }
      }
    }
    else
    {
      if(($name == 'iron_preflabel' ||
          $name == 'iron_description') &&
          !empty($form[$name]['#default_value']))
      {
        $values[] = $form[$name]['#default_value'];
      }
      else
      {
        $langID = LANGUAGE_NONE;
        
        if(isset($form[$name][get_lang()]))
        {
          $langID = get_lang();
        }
        
        if(isset($form[$name][$langID][0]['#default_value']['url']))
        {
          // Handle link widget
          // In this case, we simply return that URL and ignore the other text.
          // we will provide the URL as the input to Scones
          $values[] = $form[$name][$langID][0]['#default_value']['url'];
        }      
        elseif(isset($form[$name][$langID][0]['value']['#default_value']))
        {
          // Handle text and text_long widgets
          $values[] = $form[$name][$langID][0]['value']['#default_value'];
        }
      }      
    }
  }
  
  return($values);
}

/**
 * a helper function for osf_field_extract_values()
 */
function _osf_field_extract_value($form, $input, $extract_identifier) {
  list($name, $widget) = explode("::", $extract_identifier);
  $values = array();
  if($extractors = osf_field_get_extractors($widget)) {
    if($input) {
      $values = $extractors['input_callback']($input[$name]);
    }
    else {
      $values = $extractors['form_callback']($form[$name]);
    }
  }
  return $values;
}

/**
 * osf_field_get_extractors find which extractor functions should be use for
 * a particlar widget
 *
 * @PARAM $widget: the widget type
 * @RETURN : an array from hook_osf_field_extract
 */
function osf_field_get_extractors($widget) {
  $widgets = array();
  foreach(module_invoke_all("osf_field_extract") as $item) {
    foreach ($item['widgets'] as $w) {
      $widgets[$w] = $item;
    }
  }

  return $widgets[$widget];
}

/**
 * a  hook_osf_field_extract callback
 */
function osf_field_rec_extract_input($tree) {
  return _osf_field_rec_extract($tree, 'value');
}

/**
 * a  hook_osf_field_extract callback
 */
function osf_field_rec_extract_form($tree) {
  return _osf_field_rec_extract($tree, '#default_value');
}

/**
 * a  hook_osf_field_extract callback
 */
function osf_field_property_extract_input($tree) {
  return array($tree);
}

/**
 * a  hook_osf_field_extract callback
 */
function osf_field_property_extract_form($tree) {
  return array($tree['#default_value']);
}

/**
 * search a element tree to find items of a paticular key
 *
 * @PARAM root_element : the element to transverse
 * @PARAM match_key : the key for which we are looking
 * @PARAM $ret : an array used for recurssion
 *
 * @return the values of all of the matched items
 */
function _osf_field_rec_extract($root_element, $match_key = '#default_value', $ret = array()) {
  foreach($root_element as $key => $element) {
    if(!is_numeric($key) && ($key == $match_key)) {
      $ret[] = $element;
    }
    elseif(is_array($element)) {
      $ret = _osf_field_rec_extract($element, $match_key, $ret);
    }
  }
  return $ret;
}

/**
 * Implements hook_field_widget_form().
 */
function osf_field_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $form_id = $form_state['build_info']['form_id'];


  //register fields that effect suggestions
  $field_name = $instance['field_name'];
  $osf_field_config = array(
    'label' => $instance['label'],
    'wtype' => $instance['widget']['type'],
    'cardinality' => $field['cardinality'],
    'filter' => $instance['widget']['settings']['filter'],
    'lang' => $langcode
  );

  if(isset($instance['widget']['settings']['max_count'])) {
    $osf_field_config['max_count'] = $instance['widget']['settings']['max_count'];
  }
  if(isset($instance['widget']['settings']['scones_fields'])) {
    $osf_field_config['fields'] = $instance['widget']['settings']['scones_fields'];
  }
  if(isset($instance['widget']['settings']['datasets_filters']['datasets'])) {
    $osf_field_config['datasets'] = $instance['widget']['settings']['datasets_filters']['datasets'];
  }
  if(isset($instance['widget']['settings']['ontologies_datasets_filters']['ontologies_datasets'])) {
    $osf_field_config['ontologies_datasets'] = $instance['widget']['settings']['ontologies_datasets_filters']['ontologies_datasets'];
  }
  if(isset($instance['widget']['settings']['scones_type'])) {
    $osf_field_config['scones_type'] = $instance['widget']['settings']['scones_type'];
  }
  if(isset($instance['widget']['settings']['stemming'])) {
    $osf_field_config['stemming'] = $instance['widget']['settings']['stemming'];
  }
  _osf_field_scones_fields($form_state, $field_name, $osf_field_config);

  $values = array();
  foreach($items as $item) {
    $values[] = $item['value'];
  }
  $element = array(
    '#title' => $instance['label'],
    '#type' => 'checkboxes',
    '#options' => array(),
    '#default_value' => $values,
    '#element_validate' => array('osf_field_validate'),
    '#description' => $instance['description'],
    '#suffix' => "<a class= 'osf-sconesfield-select-all' href='#'>select all</a> <a class = 'osf-sconesfield-clear-all' href='#'>clear all</a>",
    '#attached' => array(
      'css' => array(drupal_get_path("module", 'osf_field'). "/osf_field.css"),
      'js' => array(drupal_get_path("module", 'osf_field'). "/osf_field.js"),
    ),
  );



  return $element;
}

/**
 * set the form_state to transfer info from widget create to the form alter
 */
function _osf_field_scones_fields(&$form_state, $field = NULL, $config = NULL) {

  $form_id = $form_state['build_info']['form_id'];
  if ($form_id != 'field_ui_field_edit_form' && $field) {
    $form_state['osf_field'][$field]  = $config;
  }
  if(isset($form_state['osf_field'])) {
    return $form_state['osf_field'];
  }
}

/**
 * implements hook_form_alter()
 *
 * We need to alter the form so that we can collect the field data
 * and pass it to scones
 */
function osf_field_form_alter(&$form, &$form_state, $form_id) {
  if($osf_fields = _osf_field_scones_fields($form_state)) {
    foreach($osf_fields as $osf_field => $config) {
      $lang = $config['lang'];
      $do_process = TRUE;
      //if this is one of our triggering events and it is not for this field lets stop processing
      //to save time
      if(isset($form_state['triggering_element']['#field']) && $form_state['triggering_element']['#field'] != $osf_field) {
        //TODO: This is causing issue with mulitple fields
        //$do_process = FALSE;
      }
      if($do_process) {
        //if we have a value in the selector that is a uri then lets add it as a checked
        //uri and clear the selector field
        if(isset($form_state['values'][$osf_field]['selector']) &&
           preg_match("/^http/", $form_state['values'][$osf_field]['selector'])) {
          $new  = $form_state['values'][$osf_field]['selector'];
          
          if(!is_null($form_state['input'][$osf_field][$lang]))
          {
            if($config['cardinality'] == 1) {
              foreach($form_state['input'][$osf_field][$lang] as $k => $v) {
                $form_state['input'][$osf_field][$lang][$k] = FALSE;

              }

            }
          }
          
          $form_state['input'][$osf_field][$lang][$new] = $new;
          
          unset($form_state['input'][$osf_field]['selector']);
        }


        $uris = array();
        //lets grab the last set of urls we had.
        if(isset($form_state['osf_field_uris'][$osf_field])) {
          $uris = $form_state['osf_field_uris'][$osf_field];
        }
        $wtype = $config['wtype'];

        if($wtype == 'osf_field_concept_reference') {
          // retrive content that should be sent to scones   
          $docs = osf_field_extract_values($form, $form_state['input'], $config['fields']);

          // lets not hit scones if the querying element does not want it.
          if(!isset($form_state['triggering_element']['#osf_field_no_suggestion'])) {
            //put the uris from Scones if there is error tell the user and continue with no uri
            //suggestions
            try {
              $uris = _osf_field_scones_request($docs, $config['max_count'], $config['scones_type'], $config['stemming']);
            }
            catch(Exception $e) {
              drupal_set_message($e->getMessage(), 'error');
            }
          }
        }

        //get the current selected uri and insure they are part of the uri list
        $current_uris = isset($form_state['input'][$osf_field][$lang]) ?
          $form_state['input'][$osf_field][$lang] :
          $form[$osf_field][$lang]['#default_value'];
        foreach($current_uris as $c_uri) {
          if ($c_uri && !isset($uris[$c_uri])) {
            $uris[$c_uri] = t("No SCONES Match");
          }
        }
        $form_state['osf_field_uris'][$osf_field] = $uris;

        // get a map of the uri and there labels so we can display them
        // if there is an error let the user know and continue with the ones
        // we had cached and just uri for the rest
        $scale = array();
        if($wtype == 'osf_field_concept_reference' || $wtype == 'osf_field_entity_reference') {
          try {
            $map = _osf_field_uri_label_map($uris);
          }
          catch(Exception $e) {
            drupal_set_message(t("not all labels returned because %error",array('%error' => $e->getMessage())), 'error');
            $map = _osf_field_uri_label_map($uris, TRUE);
            foreach($uris as $uri => $label) {
              if (!isset($map[$uri])) {
                $map[$uri] = $uri;
              }
            }
          }

          //sort list alpha, and add count from scones before adding to field
          asort($map);
          $options = array();
          $defaultNetwork = current(osf_configure_get_default_endpoint());

          foreach($map as $uri => $label) {
            $options[$uri] = ($wtype == 'osf_field_concept_reference') ? "$label ({$uris[$uri]})" : $label;
            $max = max($uris);
            $scale[$uri] = is_numeric($uris[$uri]) ? $uris[$uri]/$max : 0;
            ctools_include('ajax');
            ctools_include('modal');
            ctools_modal_add_js();
            
            $tag = current(entity_load('resource_type', array($uri)));
            
            $query = array(
              'network' => $defaultNetwork->uri,
              'dataset' => $tag->dataset,
              'classUri' => $uri,
              'modal' => TRUE,
            );
            
            if($wtype == 'osf_field_concept_reference')
            {
              $options[$uri] .= ' ' . l('(?)', 'osf/ontology/view', array('query' => $query, 'attributes' => array('class' => 'ctools-use-modal')));
            }
          }
          $form[$osf_field][$lang]['#options'] = $options;
        }

        //move title to the container and make the container a fieldset
        $form[$osf_field]['#title'] = $form[$osf_field][$lang]['#title'];
        unset($form[$osf_field][$lang]['#title']);
        $form[$osf_field]['#type'] = 'fieldset';
        $form[$osf_field]['#attributes']['class'][] = 'field-widget-osf-scones-field';

        $form[$osf_field]['#attached']['js'][] = array(
        'data' => array("osf_field" => array('field-name-field-test' => $scale)),
        'type' => 'setting',
        );

        //wrapp field set for ajax calls
        $form[$osf_field]['#prefix']= "<div id= 'osf_field-term-holder-$osf_field'>";
        $form[$osf_field]['#suffix'] = "</div>";

        //add autocompete selector field
        $session_key = "for-{$form['#form_id']}-$osf_field";
        $_SESSION[$session_key] = $config;
        $form[$osf_field]['selector'] = array(
          '#type' => 'textfield',
          '#default_value' => '',
          '#autocomplete_path' => "osf/field/get/$session_key",
          '#weight' => -10,
          '#field' => $osf_field,
          '#osf_field_no_suggestion' => TRUE,
          '#ajax' => array(
            'callback' => 'osf_field_add_term',
            'wrapper' => "osf_field-term-holder-$osf_field",
            'method' => 'replace',
          ),
        );
        if($wtype == 'osf_field_concept_reference') {
          //add refresh button
          $form[$osf_field]['refresh'] = array(
            '#type' => 'button',
            '#value' => 'Recommend from SCONES',
            '#weight' => -11,
            '#field' => $osf_field,
            '#ajax' => array(
              'callback' => 'osf_field_add_term',
              'wrapper' => "osf_field-term-holder-$osf_field",
              'method' => 'replace',
              'effect' => 'fade',
            ),
          );
        }
        if($wtype == 'osf_field_concept_reference') {
          //add refresh from related content button
          ctools_include('ajax');
          ctools_include('modal');
          ctools_modal_add_js();

          // Add browse link
          $query = array(
            'modal' => TRUE,
            'browse' => TRUE,
          );
          $links = l('Browse & add', 'osf/ontology', array('query' => $query, 'attributes' => array('class' => 'ctools-use-modal')));

          // Add the links to the widget
          $form[$osf_field]['ontologylinks'] = array(
            '#weight' => -12,
            '#markup' => $links,
          );
        }
      }
    }
  }
}

/**
 * osf_field_add_term is a ajax callback
 * It returns the field specified in the triggering element
 */
function osf_field_add_term($form, &$form_state) {
  $element =  $form[$form_state['triggering_element']['#field']];
  return $element;
}

/**
 * validation function for the widget, Change the values to match those of
 * a multi field text field
 */
function osf_field_validate(&$element, &$form_state) {
  $values = array();
  foreach($element['#value'] as $uri => $title) {
    $values[] = array('value' =>$uri);
  }
  form_set_value($element, $values, $form_state);
      //form_set_error('field_text', "bob");
  return;

}



function _osf_field_scones_request($docs, $max_count = 64, $sconesType = 'plain', $stemming = FALSE) {    
  if(empty($docs)) {
    return array();
  }
  
  //ask scones for releated uris
  
  $defaultEndpoint = current(osf_configure_get_default_endpoint());
  
  $related_uris = array();
  
  foreach($docs as $content)
  {
    $scones = new SconesQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
    
    $scones->document($content);
    
    switch($sconesType)
    {
      case 'noun': 
       $scones->nounConceptTagger();
      break;
      case 'plain': 
      default:
       $scones->plainConceptTagger();
      break;
    }
           
    if($stemming)
    {
      $scones->withStemming();
    }           
           
    $scones->send(new DrupalQuerierExtension());
                     
    if(!$scones->isSuccessful()) {
      throw new Exception("{$scones->error->name}: {$scones->error->description}");
    }
    
    $json = json_decode($scones->getResultSet());
    
    if($json->{'pref-labels'})
    {
      foreach($json->{'pref-labels'} as $word => $tags)  
      {
        foreach($json->{'pref-labels'}->{$word}->{'concepts'} as $uri)  
        {
          if(!isset($related_uris[$uri])) 
          {
            $related_uris[$uri] = count($json->{'pref-labels'}->{$word}->{'indices'});
          }
          else
          {
            $related_uris[$uri] += count($json->{'pref-labels'}->{$word}->{'indices'});
          }
        }
      }
    } 
    
    if($json->{'alt-labels'})
    {
      foreach($json->{'alt-labels'} as $word => $tags)  
      {
        foreach($json->{'alt-labels'}->{$word}->{'concepts'} as $uri)  
        {
          if(!isset($related_uris[$uri])) 
          {
            $related_uris[$uri] = 1;
          }
          else
          {
            $related_uris[$uri]++;
          }
        }
      }      
    }
  }
  
  /*
  $search_xml = new SimpleXMLElement($scones->getResultSet());
  $annotations_xml = $search_xml->xpath("AnnotationSet[@Name='Tagged Concepts']/Annotation[Feature[Name='type']/Value = 'class']/Feature[Name='URI']/Value");
  $related_uris = array();
  foreach($annotations_xml as $node) {
    $uri = (string) $node;
    //insert the uri if we have not seen it yet
    if(!isset($related_uris[$uri])) {
      $related_uris[$uri] = 0;
    }
    //increment the number of times we have seen the url
    $related_uris[$uri] ++;
  }*/
  
  
  arsort($related_uris);
  return array_slice($related_uris, 0 , $max_count);
}

function _osf_field_uri_label_map($uris, $cache_only= FALSE) {
  //get the cache or just an array
  $cache = osf_field_uri_map_cache();

  $namespaces = new Namespaces();
  
  $missing_uris = array_diff(array_keys($uris), array_keys($cache));

  $defaultEndpoint = current(osf_configure_get_default_endpoint());
  
  if($missing_uris && !$cache_only) 
  {    
    $crudRead = new CrudReadQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
    $crudRead->excludeLinksback()
             ->excludeReification()
             ->uri($missing_uris)
             ->includeAttributes(array(Namespaces::$iron."prefLabel"))
             ->send(new DrupalQuerierExtension());
    
    $resultset = $crudRead->getResultset();

    if($crudRead->isSuccessful()) 
    {
      foreach($missing_uris as $missing_uri)
      {
        $subject = $resultset->getSubjectByUri($missing_uri);
        
        if($subject) 
        {
          $cache[$missing_uri] = $subject->getPrefLabel();
        }
        else
        {
          $cache[$missing_uri] = $namespaces->getPrefixedUri($missing_uri);
        }
      }
    }
    else
    {
      foreach($missing_uris as $missing_uri)
      {
        $cache[$missing_uri] = $namespaces->getPrefixedUri($missing_uri);
      }
    }
  }
  
  osf_field_uri_map_cache($cache);
  $map =  array_intersect_key($cache, $uris);
  return $map;
}

/**
 * implements a page callback
 *
 * This is an autocomplete page
 * @PARAM $session_key: the session key to use to look up field info
 * @PARAM $query: the text to match for autocomplete
 * @RETURN : JSON object with the uri as the key and teh prefLable as the value
 */
function osf_field_text_autocomplete($session_key, $query) {
  $config = isset($_SESSION[$session_key]) ? $_SESSION[$session_key] : array();

  $config = $config + array(
    'suggest_count' => 15,
  );

  //search across all networks
  $suggestions = array();
  $query = $query ? "$query**" : '*';

  $i = $total = 0;
  
  $defaultEndpoint = osf_configure_get_default_endpoint();
  
  $defaultEndpoint = current($defaultEndpoint);
  
  $search = new SearchQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
  $labelProperties = Namespaces::getLabelProperties();

  $search->excludeAggregates()
         ->sourceInterface(variable_get("osf_searchapi_settings_interface_name", ''))
         ->items(99) // Limit to 99 because 100+ just returns nothing.
         ->sort('preflabel', 'asc')
         ->attributeValuesFilters(Namespaces::$iron.'prefLabel', $query);
  
  if($config['wtype'] == 'osf_field_entity_reference') 
  {
    $search->typeFilter($config['filter'])
           ->enableInference();
  }         
  
  if($config['wtype'] == 'osf_field_concept_reference')
  {       
    $search->typeFilter(Namespaces::$owl."Class");
  }
  
  if(!empty($config['datasets'])) 
  {
    foreach($config['datasets'] as $dataset)
    {
      if(!empty($dataset))
      {
        $search->datasetFilter($dataset);
      }
    }
  }
  
  if(!empty($config['ontologies_datasets'])) 
  {
    foreach($config['ontologies_datasets'] as $dataset)
    {
      if(!empty($dataset))
      {
        $search->datasetFilter($dataset);
      }
    }
  }

  $search->send(new DrupalQuerierExtension());

  //extract the uri and prefLabel we want to return with jason
  $resultset = $search->getResultset();
  if(isset($resultset)) {
    foreach($resultset->getResultset() as $dataset => $results) {
      $total += count($results);
      foreach($results as $uri => $result) {
        // This is where we limit the number of suggestions, rather than in the query itself.
        if ($i >= $config['suggest_count']) {
          continue;
        }
        $i++;
        $suggestions[$uri] = $result['prefLabel'];
      }
    }
  }

  if($total > 0) {
    if ($total >= 99) {
      $total = '100+';
    }
    $suggestions[] = t('Showing 1-') . count($suggestions) . t(' of ') . $total . ' results.';
  }

  //lets cache this label_map so that we do not have to query for it later
  osf_field_uri_map_cache($suggestions);

  //incase we had result from multiple networks lets limit again to 15
  //$suggestions = array_splice($suggestions,0, $config['suggest_count']);

  drupal_json_output($suggestions);
}


/**
 * osf_field_uri_map_cache is used for setting and getting the cached hash of url to label
 *
 * we use the static if we have it and if not go look for the cache
 *
 * @PARAM $map: a assoc array of new uri to label mappings
 * @RETURN: the current full map of uri to labels
 */
function osf_field_uri_map_cache($map = NULL) {
  $static = &drupal_static(__FUNCTION__);
  if(!$static) {
    $static = ($call = cache_get(__FUNCTION__))? $call->data : array();
  }
  if(isset($map)) {
    $static = $map + $static;
    cache_set(__FUNCTION__, $static);
  }
  return $static;
}
