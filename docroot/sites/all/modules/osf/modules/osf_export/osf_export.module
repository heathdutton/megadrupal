<?php

/** @defgroup OSFExportModule OSF Export Drupal Module */
//@{

use \StructuredDynamics\osf\framework\Namespaces;
/**
 * @file osf_export.module
 * @brief The OSF Export module file.
 * @details This file includes all the other PHP files needed to run this Drupal module.
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 */

/** 
 * @brief Main Drupal hook procedure
 * @details This hook is the first one called by Drupal when one of the module's page is accessed.
 * We use this hook to:
 * \li Get the URI that has been accessed by the user
 * \li Trigger the OSF for Drupal tool related to this URI by calling its main procedure.
 * 
 * @return A string containing the HTML page description generated by the OSF for Drupal tool
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 */
function osf_export_main() {
  // Include the utilities function used by the hooks and tools
  module_load_include('php', 'osf', 'framework/utilities');

  global $theme;

  drupal_add_css(drupal_get_path('theme', $theme) . 'style.css');
  
  return (osf_export());
}

/** 
 * @brief Declare a block or set of blocks.
 * @details   Any module can create a block (or blocks) to be displayed by defining the _block hook. This hook
 * is called by theme.inc to display a block, and also by block.module to procure the list of available blocks.
 * 
 * The functions mymodule_display_block_1 and 2, as used in the example, should of course be defined
 * somewhere in your module and return the content you want to display to your users. If the "content"
 * element is empty, no block will be displayed even if "subject" is present.
 * 
 * After completing your blocks, do not forget to enable them in the block admin menu.
 * 
 * @param[in] $op What kind of information to retrieve about the block or blocks. Possible values:
 * @li 'list': A list of all blocks defined by the module.
 * @li 'configure': Configuration form for the block.
 * @li 'save': Save the configuration options.
 * @li 'view': Process the block when enabled in a region in order to view its contents.
 * 
 * @param[in] $delta Which block to return (not applicable if $op is 'list'). Although it is most commonly an integer starting at 0, this is not mandatory. For instance, aggregator.module uses string values for $delta.
 * 
 * @param[in] $edit If $op is 'save', the submitted form data from the configuration form.
 * 
 * @return If $op is 'list': An array of block descriptions. Each block description is an associative array.
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 * 
 * @see http://api.drupal.org/api/function/hook_block
 */
function osf_export_block_info() {
  // TODO Rename block deltas (e.g. delta-0) to readable strings.

  // If $op is "list", we just need to return a list of block descriptions.
  // This is used to provide a list of possible blocks to the administrator,
  // end users will not see these descriptions.
  $blocks['delta-0']['info'] = t('OSF Export');
  return $blocks;
}

/**
 * Implements hook_block_configure().
 */
function osf_export_block_configure($delta) {
  // TODO Rename block deltas (e.g. delta-0) to readable strings. // If $op is "configure", we need to provide the administrator with a
  // configuration form. The $delta parameter tells us which block is being
  // configured. In this example, we'll allow the administrator to customize
  // the text of the first block.
  $form = array();

  if ($delta == 'delta-0') {
    // All we need to provide is a text field, Drupal will take care of
    // the other block configuration options and the save button.
    $form['block_example_string'] = array(
      '#type' => 'textfield',
      '#title' => t('Block contents'),
      '#size' => 100,
      '#description' => t('This string will appear in the OSF for Drupal Tools menu'),
      '#default_value' => '',
    );
  }

  return $form;
}

/**
 * Implements hook_block_save().
 */
function osf_export_block_save($delta, $edit) {
  // TODO Rename block deltas (e.g. delta-0) to readable strings.

  // If $op is "save", we need to save settings from the configuration form.
  // Since the first block is the only one that allows configuration, we
  // need to check $delta to make sure we only save it.
  if ($delta == 'delta-0' && isset($edit['osf_export_string'])) {
    // Have Drupal save the string to the database.
    variable_set('osf_export_string', $edit['osf_export_string']);
  }
  return;
}

/**
 * Implements hook_block_view().
 */
function osf_export_block_view($delta) {
  // TODO Rename block deltas (e.g. delta-0) to readable strings. // If $op is "view", then we need to generate the block for display
  // purposes. The $delta parameter tells us which block is being requested.
  switch ($delta) {
    case 'delta-0':
      // The subject is displayed at the top of the block. Note that it
      // should be passed through t() for translation.
      $block['subject'] = t('OSF Export');
      // The content of the block is typically generated by calling a custom
      // function.
      $block['content'] = osf_export_contents(1);
      break;
  }
  return $block;
}

/** 
 * @brief Display the OSF for Drupal side-bar menu items
 * @details   This function is called to generate the HTML of the tool lists being displayed in the side-bar.
 * 
 * @return A string where the HTML menus have been defined.
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 */
function osf_export_contents($which_block) {
  global $base_url;

  if ($which_block == 1) {
    $menuItems = array();

    $icon = theme('image', array('path' => drupal_get_path("module", "osf_export") . '/imgs/export.png', 'attributes' => array('style' => 'padding-right:5px;')));
    $menuItems[] = l($icon . t("Export"), 'osf/export', array('html' => TRUE));

    return implode('<br />', $menuItems);
  }
}

/** 
 * @brief Define menu items and page callbacks.
 * @details   This hook enables modules to register paths, which determines whose requests are to be handled.
 * Depending on the type of registration requested by each path, a link is placed in the the navigation
 * block and/or an item appears in the menu administration page (q=admin/menu).
 * 
 * @return An array of menu items. Each menu item has a key corresponding to the Drupal path being registered.
 * The item is an associative array.
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 * 
 * @see http://api.drupal.org/api/function/hook_block
 */
function osf_export_menu() {
  $items = array();

  // Registration of the main OSF for Drupal module page path
  $items['osf/export'] = array(
    'page callback' => 'osf_export_main',
    'access arguments' => array('access osf export'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

function osf_export_admin_paths() 
{
  $paths = array(
    'osf/export' => TRUE,
  );
    
  return $paths;
}


/** @brief Define user permissions.
 * @details   This hook can supply permissions that the module defines, so that they can be selected on the user
 * permissions page and used to restrict access to actions the module performs.
 * 
 * The permissions in the array do not need to be wrapped with the function t(), since the string extractor
 * takes care of extracting permission names defined in the perm hook for translation.
 * 
 * Permissions are checked using user_access().
 * 
 * @note Currently only two kind of users exist: (1) "access" and (2) "administer". However, we expect to have more
 * kind of users in the future for different node maintenance purposes.
 * 
 * @note Depending on the user (access or administer), some part of this create module will be available to the user.
 * 
 * @note Once new permissions are created, the node administrator has to set their permissions in the setting panel
 * of the node
 * 
 * @return An array of permissions strings.
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 * 
 * @see http://api.drupal.org/api/function/hook_perm
 * 
 */
function osf_export_permission() {
  return array(
    'access osf export' => array(
      'title' => t('access osf export'),
      'description' => t('access osf export'),
    ),
    'administer osf export' => array(
      'title' => t('administer osf export'),
      'description' => t('administer osf export'),
    ),
  );
}


/** 
 * @brief Entry point of the "Export Tool"
 * @details   The Export tool is used export datasets from files.
 * 
 * @return a string containing the HTML page generated by the Export tool.
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 */
function osf_export() {
    include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'osf') . '/framework/WebServiceQuerier.php';
    include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'osf') . '/framework/ProcessorXML.php';

    $html = "";

    // Check if a file has been uploaded
    if (isset($_GET["scdid"]) && isset($_GET["format"])) {
      $format = "";

      if (isset($_GET["format"])) {
        $format = $_GET["format"];
      }

      $dataset;

      if (isset($_GET["scdid"])) {
        $scdid = $_GET["scdid"];
        
        foreach(osf_configure_dataset_load_util('configured') as $d)
        {
          if($d->scdid == $scdid)
          {
            $dataset = $d;
            break;
          }
        }
      }

      $slice = 0;

      if (isset($_GET["slice"])) {
        $slice = ($_GET["slice"] - 1);

        if ($slice < 0) {
          $slice = 0;
        }
      }

      $sliceSize = 1000;

      if (isset($_GET["slicesize"])) {
        $sliceSize = $_GET["slicesize"];

        if ($sliceSize < 0) {
          $sliceSize = 1;
        }

        if ($sliceSize > 1000) {
          $sliceSize = 1000;
        }
      }

      $mime = "";

      switch ($format) {
        case "irjson":
          $mime = "application/sparql-results+xml";
          break;

        case "common":
          $mime = "application/sparql-results+xml";
          break;

        case "xml":
        case "tsv":
        case "csv":
          $mime = "text/xml";
          break;

        case "json":
          $mime = "application/json";
          break;

        case "rdf_xml":
          $mime = "application/rdf+xml";
          break;

        case "rdf_n3":
          $mime = "application/rdf+n3";
          break;

        case "sparql_xml":
          $mime = "application/sparql-results+xml";
          break;

        case "sparql_json":
          $mime = "application/sparql-results+json";
          break;
      }

      $query =
        "select * where {{select distinct ?s where {?s a ?type.} limit $sliceSize offset " . ($slice * $sliceSize)
        . "} ?s ?p ?o}";

      // Export records by using the SPARQL web service
      $wsq = new WebServiceQuerier($dataset->endpoint->uri . "sparql/", "post", $mime,
        "query=" . urlencode(str_replace(array("\n", "\r", "\t"), " ", $query)) .
        "&dataset=" . urlencode($dataset->uri));

      if ($wsq->getStatus() != 200) {
        $wsq->displayError();

        return ("");
      }

      $document = $wsq->getResultset();

      unset($wsq);

      // If the format has to be converted, we have to the document to the conversion web service
      switch ($format) {
        case "irjson":
        case "common":
          // Add triples defining the Dataset

          $xml = new ProcessorXML();

          // Creation of the RESULTSET
          $resultset = $xml->createResultset();

          // Creation of the prefixes elements.
          $void = $xml->createPrefix("owl", "http://www.w3.org/2002/07/owl#");
          $resultset->appendChild($void);
          $rdf = $xml->createPrefix("rdf", "http://www.w3.org/1999/02/22-rdf-syntax-ns#");
          $resultset->appendChild($rdf);
          $dcterms = $xml->createPrefix("rdfs", "http://www.w3.org/2000/01/rdf-schema#");
          $resultset->appendChild($dcterms);
          $dcterms = $xml->createPrefix("wsf", "http://purl.org/ontology/wsf#");
          $resultset->appendChild($dcterms);

          // Read the XML file and populate the recordInstances variables

          $instanceRecordsObjectResource = array();
          $instanceRecordsObjectLiteral = array();

          $xmlInstanceRecords = xml2ary($document);

          unset($document);

          if (isset($xmlInstanceRecords["sparql"]["_c"]["results"]["_c"]["result"])) {
            foreach ($xmlInstanceRecords["sparql"]["_c"]["results"]["_c"]["result"] as $result) {
              $s = "";
              $p = "";
              $o = "";

              foreach ($result["_c"]["binding"] as $binding) {
                $boundVariable = $binding["_a"]["name"];

                $keys = array_keys($binding["_c"]);

                $boundType = $keys[0];
                $boundValue = $binding["_c"][$boundType]["_v"];

                switch ($boundVariable) {
                  case "s":
                    $s = $boundValue;
                    break;

                  case "p":
                    $p = $boundValue;
                    break;

                  case "o":
                    $o = $boundValue;
                    break;
                }
              }

              if ($boundType == "uri") {
                if (!isset($instanceRecordsObjectResource[$s][$p])) {
                  $instanceRecordsObjectResource[$s][$p] = array($o);
                }
                else {
                  array_push($instanceRecordsObjectResource[$s][$p], $o);
                }
              }

              if ($boundType == "literal") {
                if (!isset($instanceRecordsObjectLiteral[$s][$p])) {
                  $instanceRecordsObjectLiteral[$s][$p] = array($o);
                }
                else {
                  array_push($instanceRecordsObjectLiteral[$s][$p], $o);
                }
              }
            }
          }

          // Now add reification statements to the resultset
          $query = "  select ?rei_s ?rei_p ?rei_o ?rei_label ?rei_href
                    from named <" . $dataset->uri . ">
                    from named <" . $dataset->uri . "reification/>
                    where
                    {
                      graph <" . $dataset->uri . ">
                      {
                      {
                        select distinct ?rei_s where
                        {
                        ?rei_s a ?type.
                        }
                        limit $sliceSize offset  "
            . ($slice * $sliceSize) . "
                      }
                      }
                    
                      graph <" . $dataset->uri
            . "reification/>
                      {
                      ?rei a ?rei_type.
                      ?rei <http://www.w3.org/1999/02/22-rdf-syntax-ns#subject> ?rei_s.
                      ?rei <http://www.w3.org/1999/02/22-rdf-syntax-ns#predicate> ?rei_p.
                      ?rei <http://www.w3.org/1999/02/22-rdf-syntax-ns#object> ?rei_o.
                      OPTIONAL{?rei <http://www.w3.org/2000/01/rdf-schema#label> ?rei_label}.
                      OPTIONAL{?rei <http://purl.org/ontology/bibo/uri> ?rei_href}.
                      }
                    }";

          // Export records by using the SPARQL web service
          $wsq = new WebServiceQuerier($dataset->endpoint->uri . "sparql/", "post", "application/sparql-results+xml",
            "query=" . urlencode(str_replace(array("\n", "\r", "\t"), " ", $query)) .
            "&dataset=" . urlencode($dataset->uri));

          if ($wsq->getStatus() != 200) {
            $wsq->displayError();

            return ("");
          }

          $reificationsDocument = $wsq->getResultset();

          unset($wsq);


          // Add triples defining the Dataset
          $reificationsXmlDocument = new DomDocument("1.0", "utf-8");

          // Creation of the RESULTSET
          $reificationsXmlDocument->loadXML($reificationsDocument);

          $xpath = new DOMXPath($reificationsXmlDocument);
          $xpath->registerNamespace('sparql', "http://www.w3.org/2005/sparql-results#");

          $subject;

          foreach ($instanceRecordsObjectResource as $uri => $result) {
            // Assigning types
            if (isset($result["http://www.w3.org/1999/02/22-rdf-syntax-ns#type"])) {
              foreach ($result["http://www.w3.org/1999/02/22-rdf-syntax-ns#type"] as $key => $type) {
                if ($key > 0) {
                  $pred = $xml->createPredicate("http://www.w3.org/1999/02/22-rdf-syntax-ns#type");
                  $object = $xml->createObject("", $type);
                  $pred->appendChild($object);
                  $subject->appendChild($pred);
                }
                else {
                  $subject = $xml->createSubject($type, $uri);
                }
              }
            }
            else {
              $subject = $xml->createSubject("http://www.w3.org/2002/07/owl#Thing", $uri);
            }
            
            $labelProperties = Namespaces::getLabelProperties();

            // Assigning object resource properties
            foreach ($result as $property => $values) {
              if ($property != "http://www.w3.org/1999/02/22-rdf-syntax-ns#type") {
                foreach ($values as $value) {
                  $label = "";

                  foreach ($labelProperties as $labelProperty) {
                    if (isset($instanceRecordsObjectLiteral[$value])) {
                      // The object resource is part of the resultset
                      // This mainly occurs when we export complete datasets

                      if (isset($instanceRecordsObjectLiteral[$value][$labelProperty])) {
                        $label = $instanceRecordsObjectLiteral[$value][$labelProperty][0];
                        break;
                      }
                    }
                    else {
                      // The object resource is not part of the resultset
                      // In the future, we can send another sparql query to get its label.
                    }
                  }

                  $pred = $xml->createPredicate($property);
                  $object = $xml->createObject("", $value, ($label != "" ? $label : ""));


                  // Get reified labels & hrefs
                  $query =
                    '//*/sparql:result[sparql:binding[attribute::name="rei_s" and sparql:uri = "' . $uri
                    . '"] and sparql:binding[attribute::name="rei_p" and sparql:uri = "' . $property
                    . '"] and sparql:binding[attribute::name="rei_o" and sparql:uri = "' . $value
                    . '"] and (sparql:binding[attribute::name="rei_label"] or sparql:binding[attribute::name="rei_href"])]';

                  $reificationStatementsDom = $xpath->query($query);

                  foreach ($reificationStatementsDom as $statement) {
                    $nodes = $statement->childNodes;

                    foreach ($nodes as $node) {
                      if ($node->nodeType == 1 && $node->attributes->getNamedItem("name")->nodeValue == "rei_label") {
                        $reify = $xml->createReificationStatement("http://www.w3.org/2000/01/rdf-schema#label",
                          $node->nodeValue);
                        $object->appendChild($reify);
                      }

                      if ($node->nodeType == 1 && $node->attributes->getNamedItem("name")->nodeValue == "rei_href") {
                        $reify =
                          $xml->createReificationStatement("http://purl.org/ontology/bibo/uri", $node->nodeValue);
                        $object->appendChild($reify);
                      }
                    }
                  }

                  $pred->appendChild($object);
                  $subject->appendChild($pred);
                }
              }
            }

            // Assigning object literal properties
            if (isset($instanceRecordsObjectLiteral[$uri])) {
              foreach ($instanceRecordsObjectLiteral[$uri] as $property => $values) {
                if ($property != "http://www.w3.org/1999/02/22-rdf-syntax-ns#type") {
                  foreach ($values as $value) {
                    $pred = $xml->createPredicate($property);
                    $object = $xml->createObjectContent(xmlEncode($value));

                    // Get reified labels & hrefs
                    $query =
                      '//*/sparql:result[sparql:binding[attribute::name="rei_s" and sparql:uri = "' . $uri
                      . '"] and sparql:binding[attribute::name="rei_p" and sparql:uri = "' . $property
                      . '"] and sparql:binding[attribute::name="rei_o" and sparql:uri = "' . $value
                      . '"] and (sparql:binding[attribute::name="rei_label"] or sparql:binding[attribute::name="rei_href"])]';

                    $reificationStatementsDom = $xpath->query($query);

                    foreach ($reificationStatementsDom as $statement) {
                      $nodes = $statement->childNodes;

                      foreach ($nodes as $node) {
                        if ($node->nodeType == 1 && $node->attributes->getNamedItem("name")->nodeValue == "rei_label") {
                          $reify = $xml->createReificationStatement("http://www.w3.org/2000/01/rdf-schema#label",
                            $node->nodeValue);
                          $object->appendChild($reify);
                        }

                        if ($node->nodeType == 1 && $node->attributes->getNamedItem("name")->nodeValue == "rei_href") {
                          $reify =
                            $xml->createReificationStatement("http://purl.org/ontology/bibo/uri", $node->nodeValue);
                          $object->appendChild($reify);
                        }
                      }
                    }

                    $pred->appendChild($object);
                    $subject->appendChild($pred);
                  }
                }
              }

              $resultset->appendChild($subject);
            }
          }

          // Lets create a linkage and/or structure schema if needed.

          if ($format == "common") {
            $wsq = new WebServiceQuerier($dataset->endpoint->uri . "converter/common/",
              "post",
              "application/iron+csv", "document=" . urlencode($xml->saveXML($resultset)) .
              "&docmime=" . urlencode("text/xml") .
              "&base_uri=");
          }
          else {
            $wsq = new WebServiceQuerier($dataset->endpoint->uri . "converter/irjson/",
              "post",
              "application/iron+json", "document=" . urlencode($xml->saveXML($resultset)) .
              "&docmime=text/xml" .
              "&base_uri=");
          }

          if ($wsq->getStatus() != 200) {
            $wsq->displayError();

            return ("");
          }

          $document = $wsq->getResultset();

          if ($format == "common") {
            $mime = "application/iron+csv";
          }
          else {
            $mime = "application/iron+json";
          }

          unset($wsq);
          break;

        case "tsv":
          $wsq = new WebServiceQuerier($dataset->endpoint->uri . "converter/tsv/", "post", "text/tsv",
            "document=" . urlencode($document) .
            "&docmime=" . urlencode("text/xml") .
            "&delimiter=\t" .
            "&base_uri=");

          if ($wsq->getStatus() != 200) {
            $wsq->displayError();

            return ("");
          }

          $document = $wsq->getResultset();

          $mime = "text/tsv";

          unset($wsq);
          break;

        case "csv":
          $wsq = new WebServiceQuerier($dataset->endpoint->uri . "converter/tsv/", "post", "text/csv",
            "document=" . urlencode($document) .
            "&docmime=" . urlencode("text/xml") .
            "&delimiter=" . urlencode(",") .
            "&base_uri=");

          if ($wsq->getStatus() != 200) {
            $wsq->displayError();

            return ("");
          }

          $document = $wsq->getResultset();

          $mime = "text/csv";

          unset($wsq);
          break;
      }

      $fileextension = "";

      switch ($format) {
        case "irjson":
          $fileextension = "js";
          break;

        case "common":
          $fileextension = "csv";
          break;

        case "xml":
          $fileextension = "xml";
          break;

        case "json":
          $fileextension = "json";
          break;

        case "tsv":
          $fileextension = "tsv";
          break;

        case "csv":
          $fileextension = "csv";
          break;

        case "rdf_xml":
          $fileextension = "rdf";
          break;

        case "rdf_n3":
          $fileextension = "n3";
          break;

        case "sparql_xml":
        case "sparql_json":
          $fileextension = "sparql";
          break;
      }

      header("Content-Type: " . $mime . "; charset=utf-8");
      header("Content-Disposition: attachment; filename=" . preg_replace("[^A-Za-z0-9_]", "", $dataset->label) . "-slice-" . ($slice + 1) . "."
        . $fileextension);

      echo $document;

      return;
    }
    else {
      $html .= "<h2>".t('Export Dataset')."</h2>";

      $datasetHtml = "";

      foreach (osf_configure_dataset_load_util('configured') as $dataset) {
        $datasetHtml .= "<option value=\"" . $dataset->scdid . "\" /> " . check_plain($dataset->label) . "\n";
      }

      $html
        .= "  <form action=\"\" method=\"GET\">
        
                  <table width=\"100%\" border=\"0\">
                      <tr><td>&nbsp;</td><td>&nbsp;</td></tr>
                      <tr>
                          <td>
                        ".t('Export format:')."
                          </td>
                          <td>
                        <select class=\"form-select\" name=\"format\" size=\"1\" style=\"width: 400px;\">
                          <option value=\"irjson\" /> ".t('irJSON')."
                          <option value=\"common\" /> ".t('commON')."
                          <option value=\"xml\" /> ".t('WSF+XML')."
                          <option value=\"json\" /> ".t('WSF+JSON')."
                          <option value=\"tsv\" /> ".t('N-Triple/TSV')."
                          <option value=\"csv\" /> ".t('N-Triple/CSV')."
                          <option value=\"rdf_xml\" /> ".t('RDF+XML')."
                          <option value=\"rdf_n3\" /> ".t('RDF+N3')."
                          <option value=\"sparql_xml\" /> ".t('SPARQL in XML')."
                          <option value=\"sparql_json\" /> ".t('SPARQL in JSON')."
                        </select>
                          </td>
                      </tr>
                      <tr>
                          <td>
                        ".t('Dataset to export:')."
                          </td>
                          <td>
                        <select class=\"form-select\" name=\"scdid\" size=\"1\" style=\"width: 400px;\">
                          $datasetHtml
                        </select>
                          </td>
                      </tr>
                      <tr>
                          <td>
                        ".t('Number of records per slice (1-1000):')."
                          </td>
                          <td>
                        <input class=\"form-text\" type=\"text\" name=\"slicesize\" value=\"1000\" />
                          </td>
                      </tr>
                      <tr>
                          <td>
                        ".t('Slice number to export:')."
                          </td>
                          <td>
                        <input class=\"form-text\" type=\"text\" name=\"slice\" value=\"1\" />
                          </td>
                      </tr>
                      <tr>
                          <td colspan=\"2\">
                        <em>".t('Note: If you have 1000 records per slice the slice 1 will give you the records number 1 to 1000; the slice too the records number    to 2000; etc. ')."</em>
                          </td>
                      </tr>
                    <tr><td>&nbsp;</td><td>&nbsp;</td></tr>
                      <tr>
                          <td colspan=\"2\" align=\"center\">
                        <input class=\"form-text\" type=\"submit\" value=\"".t('Export')."\" />
                          </td>
                      </tr>
                  </table>
                </form>  
              ";
    }

    return ($html);

}

/** 
 * @brief Encode content to be included in XML files
 * 
 * @param[in] $string The content string to be encoded
 * 
 * @return returns the encoded string
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 */
function xmlEncode($string) {
  return str_replace(array("\\", "&", "<", ">"), array("%5C", "&amp;", "&lt;", "&gt;"), $string);
}

//@}


