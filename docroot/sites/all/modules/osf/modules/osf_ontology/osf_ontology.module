<?php

use \StructuredDynamics\osf\php\api\framework\CRUDPermission;
use \StructuredDynamics\osf\php\api\ws\auth\registrar\access\AuthRegistrarAccessQuery;
use \StructuredDynamics\osf\php\api\ws\ontology\create\OntologyCreateQuery;
use \StructuredDynamics\osf\php\api\ws\ontology\read\OntologyReadQuery;
use \StructuredDynamics\osf\php\api\ws\ontology\read\GetSuperClassesFunction;
use \StructuredDynamics\osf\framework\Namespaces;



/** @defgroup OSFOntologyModule OSF for Drupal Ontology Drupal Module */
//@{

/** 
 * @file osf_ontology.module
 * @brief The OSF Ontology module file.
 * @details This file includes all the other PHP files needed to run this Drupal module.
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 */

/** 
 * @brief Main Drupal hook procedure
 * @details This hook is the first one called by Drupal when one of the module's page is accessed.
 * We use this hook to:
 * \li Get the URI that has been accessed by the user
 * \li Trigger the OSF for Drupal tool related to this URI by calling its main procedure.
 * 
 * @return A string containing the HTML page description generated by the OSF for Drupal tool
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 */
function osf_ontology_main() { 
  global $base_url;
  
  // Include the utilities function used by the hooks and tools
  module_load_include('php', 'osf', 'framework/utilities');
  
  drupal_add_css(drupal_get_path('module', 'osf_ontology') . '/css/osf_ontology_style.css');
  drupal_add_css(drupal_get_path('module', 'osf_ontology') . '/css/jquery.contextMenu.css');

  drupal_add_js(drupal_get_path("module", "osf_ontology") . "/js/ontology.js");
  drupal_add_js(drupal_get_path("module", "osf_ontology") . "/js/hex_md5.js");
  drupal_add_js(drupal_get_path("module", "osf_ontology") . "/js/resultset.js");    
  
  $namespaces = Namespaces::getNamespaces();
  
  $jsNamespaces = 'var namespacesObj = {';

  foreach($namespaces as $prefix => $uri)
  {
    $jsNamespaces .= '"'.$prefix.'": "'.$uri.'",';
  }

  $jsNamespaces .= '};';
  
  drupal_add_js($jsNamespaces, 'inline');     
  
  global $theme;

  drupal_add_css(drupal_get_path('theme', $theme) . 'style.css');  
  
  $uri = "";

  if (isset($_GET["uri"])) {
    $uri = $_GET["uri"];
  }
  
  if(!user_access('access osf proxy'))
  {
    drupal_set_message(t("You don't have access to the OSF for Drupal proxy service"), 'error');
    return('');
  }

  // Check if the user is trying to search for something
  if (stripos(strtolower($_GET["q"]), "osf/ontology/search") !== FALSE) {
    drupal_add_js(drupal_get_path("module", "osf_ontology") . "/js/jquery.pagination.js");
    drupal_add_js(drupal_get_path("module", "osf_ontology") . "/js/ontologySearch.js");
    drupal_add_js(drupal_get_path("module", "osf_ontology") . "/js/jquery.autocomplete-ontology.js");

    $defaultNetwork = current(osf_configure_get_default_endpoint());  

    drupal_add_js(array('osfOntology' => array('osf_ontologyModuleFullPath' => $base_url . "/". drupal_get_path("module", "osf_ontology"))), 'setting');
    drupal_add_js(array('osfOntology' => array('searchURL' => $base_url . "/" . $_GET["q"] . "/search/")), 'setting');
    drupal_add_js(array('osfOntology' => array('network' => $defaultNetwork->uri)), 'setting');
    drupal_add_js(array('osfOntology' => array('initialDataset' => $_GET["dataset"])), 'setting');
    drupal_add_js(array('osfOntology' => array('structModulesBaseUrl' => $base_url . '/osf/')), 'setting');
    drupal_add_js(array('osfOntology' => array('OSFBaseURL' => $defaultNetwork->uri)), 'setting');
    
    drupal_add_js('
     var osf_ontologyModuleFullPath = Drupal.settings.osfOntology.osf_ontologyModuleFullPath;
     var searchURL = Drupal.settings.osfOntology.searchURL;
     var network = Drupal.settings.osfOntology.network;
     var initialDataset = Drupal.settings.osfOntology.initialDataset;
     var structModulesBaseUrl = Drupal.settings.osfOntology.structModulesBaseUrl;
     var OSFBaseURL = Drupal.settings.osfOntology.OSFBaseURL;', array('type' => 'inline', 'scope' => 'footer'));
 
    $html = "";

    $html .= '<div class="breadCrumb"><div class="breadCrumb"><a href="' . $base_url . "/"
      . str_replace("search", "", check_plain($_GET["q"])) . '">'.t('Ontologies').'</a> &gt; <a href="' . $base_url . '/' . check_plain($_GET["q"])
      . '/?query=' . check_plain($_GET["query"]) . '&network=' . $defaultNetwork->uri . '">'.t('Search Ontologies').'</a></div></div>';
    
    if (variable_get("osf_OntologySettings_enable_search", 1) && check_plain($_GET['modal']) != '' && empty($_POST['modal'])) {
      $html
        .= '<div class="searchBoxContainer"><input type="text" class="form-text searchBox" id="searchBox" onkeypress="return submitSearchEnter(this,event);" /><img src="'
        . $base_url . "/" . drupal_get_path("module", "osf_ontology")
          . '/imgs/magnifier.png" id="searchButtonImage" class="searchButtonImage" title="'.t('Search').'" alt="'.t('Search').'" onclick="search();" /></div>';

      $html .= '<script type="text/javascript">jQuery(document).ready(function() {readySearch("' . check_plain($_GET["query"])
        . '");});</script>';

      $html
        .= '
                  <table id="ontologySearch">
                    <tr id="headersContainer">
                      <td id="resultsetTitleContainer"></td>
                      <td id="filtersTitleContainer"></td>
                    </tr>
                    <tr id="contentContainer">
                      <td id="resultsetContainer" valign="top"></td>
                      <td id="filtersContainer" valign="top"></td>
                    </tr>
                    <tr id="paginatorContainer">
                      <td id="resultsetTitleContainer" colspan="2"><div id="Pagination" class="pagination"></div></td>
                    </tr>
                  </table>
        ';
    }
       
    return ($html);
  }

  // Check if the user is importing a new ontology
  if (isset($_FILES) && count($_FILES) > 0) {
    // Check if the upload of the file is sucessful
    if ($_FILES['userfile']['error'] == UPLOAD_ERR_OK) {
      // Once we start the ontology importation process, we have to make sure that even if the server
      // loose the connection with the user the process will still finish.
      ignore_user_abort(true);

      // However, maybe there is an issue with the server handling that file tht lead to some kind of infinite or near
      // infinite loop; so we have to limit the execution time of this procedure to 45 mins.
      drupal_set_time_limit(2700);

      if (!move_uploaded_file($_FILES['userfile']['tmp_name'],
         variable_get("osf_OntologySettings_ontologies_files_folder", "/tmp/") . $_FILES['userfile']['name'])) {
        drupal_set_message(
          t("Cannot read the imported file in \"@filepath\". Please contact the system administrator to check
             if the OWLAPI Tomcat server has the rights to read files created by the Apache web server.", array(
          "@filepath" => strip_tags(variable_get("osf_OntologySettings_ontologies_files_folder", "/tmp/") . $_FILES['userfile']['name']),
        )), "error", TRUE);
      }
      else {
        // Now, let's import the new ontology into the OWLAPI
        $defaultEndpoint = osf_configure_get_endpoint_by_uri($_POST["network"]);
        
        $ontologyURI = "file://localhost" . variable_get("osf_OntologySettings_ontologies_files_folder", "/tmp/") . $_FILES['userfile']['name'];

        // Now create the access permissions for the core Drupal user
        $crudPermissions = new CRUDPermission(TRUE, TRUE, TRUE, TRUE);
        
        $authRegistrarAccess = new AuthRegistrarAccessQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_first_user_uri());
        
        $authRegistrarAccess->create(osf_configure_get_administrator_group_uri(), $ontologyURI, $crudPermissions, osf_configure_osf_get_registered_webservices($defaultEndpoint))
                            ->mime('text/xml')
                            ->send(new DrupalQuerierExtension());
                             
        if(!$authRegistrarAccess->isSuccessful())
        {
          drupal_set_message(t("Couldn't create permissions on the imported ontology for the administrator group."), 'warning', TRUE);        
        }
        else
        {
          $ontologyCreate = new OntologyCreateQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
          
          $ontologyCreate->enableAdvancedIndexation()
                         ->uri($ontologyURI);
                         
          if(filter_var($_POST["reasoner"], FILTER_VALIDATE_BOOLEAN))
          {
            $ontologyCreate->enableReasoner();
          }
          else
          {
            $ontologyCreate->disableReasoner();
          }
          
          $ontologyCreate->send(new DrupalQuerierExtension());
          
          if(!$ontologyCreate->isSuccessful())
          {
            drupal_set_message(t("Can't import ontology: [@error] @errorMsg - @errorDescription", 
                     array("@error" => $ontologyCreate->getStatus(),
                           "@errorMsg" => $ontologyCreate->getStatusMessage(),
                           "@errorDescription" => $ontologyCreate->getStatusMessageDescription())), 
                     "error", 
                     TRUE);
          }
          else
          {
            // Register these permissions in drupal's permissions system
            user_role_grant_permissions(3, array(
              'create ontology '.md5($ontologyURI).' '.$defaultEndpoint->sceid,
              'read ontology '.md5($ontologyURI).' '.$defaultEndpoint->sceid,
              'update ontology '.md5($ontologyURI).' '.$defaultEndpoint->sceid,
              'delete ontology '.md5($ontologyURI).' '.$defaultEndpoint->sceid,
            ));
            
            // We have to clear the cache to make sure that we re-create the index of the
            // datasets that are datasets and the ones that are ontologies.
            cache_clear_all('cache_loaded_ontologies', 'cache');
            
            drupal_set_message(t("Ontology Imported")); 
          }         
        }
      }
    }
    else {
      $errorMessage = "";

      switch ($_FILES['userfile']['error']) {
        case "UPLOAD_ERR_OK":
          $errorMessage = t("There is no error, the file uploaded with success.");
          break;
        case "UPLOAD_ERR_INI_SIZE":
          $errorMessage = t("The uploaded file exceeds the upload_max_filesize directive in php.ini.");
          break;
        case "UPLOAD_ERR_FORM_SIZE":
          $errorMessage = t("The uploaded file exceeds the MAX_FILE_SIZE directive that was specified in the HTML form.");
          break;
        case "UPLOAD_ERR_PARTIAL":
          $errorMessage = t("The uploaded file was only partially uploaded.");
          break;
        case "UPLOAD_ERR_NO_FILE":
          $errorMessage = t("No file was uploaded.");
          break;
        case "UPLOAD_ERR_NO_TMP_DIR":
          $errorMessage = t("Missing a temporary folder. Introduced in PHP 4.3.10 and PHP 5.0.3.");
          break;
        case "UPLOAD_ERR_CANT_WRITE":
          $errorMessage = t("Failed to write file to disk. Introduced in PHP 5.1.0.");
          break;
        case "UPLOAD_ERR_EXTENSION":
          $errorMessage = t("A PHP extension stopped the file upload. PHP does not provide a way to ascertain which extension caused the file upload to stop; examining the list of loaded extensions with phpinfo() may help. Introduced in PHP 5.2.0.");
          break;
      }

      drupal_set_message(
        t("Cannot read the imported file in \"@filepath\". Please contact the system administrator to check
           if the OWLAPI Tomcat server has the rights to read files created by the Apache web server. The error to report is: $errorMessage.", array(
        "@filepath" => strip_tags(variable_get("osf_OntologySettings_ontologies_files_folder", "/tmp/") . $_FILES['userfile']['name']),
      )), "error", TRUE);
    }
  }

  // Check if we are exporting a dataset
  if (!empty($_GET["exportUri"]) && strlen($_GET["exportUri"]) > 0) {
    include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'osf') . '/framework/WebServiceQuerier.php';

    $defaultNetwork = current(osf_configure_get_default_endpoint());
    
    $wsq = new WebServiceQuerier(rtrim($defaultNetwork->uri, '/') . "/ontology/read/", "post", "application/rdf+xml",
      "ontology=" . check_plain($_GET["exportUri"]) . "&function=getSerialized");

    if ($wsq->getStatus() != 200) {
      $wsq->displayError();
      return ("");
    }
    else {
      // Clean the output PHP buffer in case that garbage chars crawled in that
      // would make serialized files invalid
      ob_clean();

      header("Content-Type: application/rdf+xml; charset=utf-8");
      header("Content-Disposition: attachment; filename=" . preg_replace("/[^A-Za-z0-9]/", "_", check_plain($_GET["exportUri"])) . ".xml");

      echo $wsq->getResultset();
    }

    unset($wsq);
    return;
  }

  // Check if we are deleting a dataset
  if (!empty($_POST["deleteUri"]) && strlen($_POST["deleteUri"]) > 0) {
    include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'osf') . '/framework/WebServiceQuerier.php';

    $wsq = new WebServiceQuerier(rtrim($_POST["network"], '/') . "/ontology/delete/", "post", "application/rdf+xml",
      "ontology=" . $_POST["deleteUri"] . "&function=deleteOntology");

    if ($wsq->getStatus() != 200) {
      $wsq->displayError();
    }
    else {
      // Invoke all the hooks that wants to do something when an ontology is removed.
      module_invoke_all('ontology_unload', $_POST["deleteUri"]);

      drupal_set_message(t("Ontology Unloaded"));
    }

    unset($wsq);
  }

  // Check if we are removing an ontology
  if (!empty($_POST["removeUri"]) && strlen($_POST["removeUri"]) > 0) {
    include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'osf') . '/framework/WebServiceQuerier.php';

    $wsq = new WebServiceQuerier(rtrim($_POST["network"], '/') . "/ontology/delete/", "post", "application/rdf+xml",
      "ontology=" . $_POST["removeUri"] . "&function=deleteOntology");

    if ($wsq->getStatus() != 200) {
      $wsq->displayError();
    }
    else {
      // Invoke all the hooks that wants to do something when an ontology is removed.
      module_invoke_all('ontology_remove', $_POST["removeUri"]);

      // Try to remove the file from the filesystem.
      @unlink(str_replace("file://localhost", "", $_POST["removeUri"]));

      drupal_set_message(t("Ontology removed from the system"));
    }

    unset($wsq);
  }

  // Check if we are removing the ontology from the entire system (loaded ontology & files (including versions))

  if (stripos($_GET['q'], "/ontology/view") !== FALSE) {
    
    // If the ontology viewer is run from the ctools modal windows,
    // then all queries that will be sent will be using the POST method.
    // What we need here, is just to transfer the POST to a GET
    if(isset($_POST['dataset']))
    {
      $_GET['dataset'] = $_POST['dataset'];
    }
    
    if(isset($_POST['browse']))
    {
      $_GET['browse'] = $_POST['browse'];
    }
    
    if(isset($_POST['modal']))
    {
      $_GET['modal'] = $_POST['modal'];
    }    
    
    if(isset($_POST['classUri']))
    {
      $_GET['classUri'] = $_POST['classUri'];
    }    
    
    if(isset($_POST['propertyUri']))
    {
      $_GET['propertyUri'] = $_POST['propertyUri'];
    }    
    
    if(isset($_POST['niUri']))
    {
      $_GET['niUri'] = $_POST['niUri'];
    }
    
    drupal_add_js(array('osf_ontology' => array(
      'browse' => !empty($_GET['browse']),
    )), 'setting');
    
    drupal_add_css(drupal_get_path('module', 'osf_ontology') . '/js/jstree/themes/default/style.css');
    drupal_add_js(drupal_get_path("module", "osf_ontology") . "/js/ontologyView.js");
    drupal_add_js(drupal_get_path("module", "osf_ontology") . "/js/propertiesTree.js");
    drupal_add_js(drupal_get_path("module", "osf_ontology") . "/js/individualsView.js");
    drupal_add_js(drupal_get_path("module", "osf_ontology") . "/js/jstree/jquery.jstree.js");
    drupal_add_js(drupal_get_path("module", "osf_ontology") . "/js/jquery.autocomplete.js");
    drupal_add_js(drupal_get_path("module", "osf_ontology") . "/js/jstree/_lib/jquery.hotkeys.js");
    drupal_add_js(drupal_get_path("module", "osf_ontology") . "/js/jquery.quicksearch.js");
    drupal_add_js(drupal_get_path("module", "osf_ontology") . "/js/jquery.contextMenu.js");
    drupal_add_js(drupal_get_path("module", "osf_ontology") . "/js/jquery.colorpicker.js");
    drupal_add_js(drupal_get_path("module", "osf_ontology") . "/js/jquery.colorpicker.eye.js");
    drupal_add_js(drupal_get_path("module", "osf_ontology") . "/js/jquery.colorpicker.layout.js");
    drupal_add_js(drupal_get_path("module", "osf_ontology") . "/js/jquery.colorpicker.utils.js");

    drupal_add_css(drupal_get_path('module', 'osf_ontology') . '/css/jquery.colorpicker.css');
    drupal_add_css(drupal_get_path('module', 'osf_ontology') . '/css/jquery.colorpicker.layout.css');

    $html = "";

    if (variable_get('osf_OntologySettings_enable_reasonner_by_default', 1) == 1) {
      drupal_add_js(array('osfOntology' => array('useReasoner' => true)), 'setting');
    }
    else {
      drupal_add_js(array('osfOntology' => array('useReasoner' => false)), 'setting');
    }
    
    drupal_add_js('var useReasoner = Drupal.settings.osfOntology.useReasoner;', array('type' => 'inline', 'scope' => 'footer'));

    if (!variable_get('osf_OntologySettings_read_mode', 1) && user_access('administer osf ontology') &&
        empty($_GET['modal']) && empty($_POST['modal'])) {
      drupal_add_js(array('osfOntology' => array('isAdmin' => true)), 'setting');
    }
    else {
      drupal_add_js(array('osfOntology' => array('isAdmin' => false)), 'setting');
    }
    
    drupal_add_js('var isAdmin = Drupal.settings.osfOntology.isAdmin;', array('type' => 'inline', 'scope' => 'footer'));      
    
    $defaultNetwork = current(osf_configure_get_default_endpoint());
    
    drupal_add_js(array('osfOntology' => array('structModulesBaseUrl' => $base_url . '/osf')), 'setting');
    drupal_add_js(array('osfOntology' => array('network' => $defaultNetwork->uri)), 'setting');
    drupal_add_js(array('osfOntology' => array('osf_ontologyModuleFullPath' => $base_url . "/" . drupal_get_path("module", "osf_ontology"))), 'setting');

    drupal_add_js('var structModulesBaseUrl = Drupal.settings.osfOntology.structModulesBaseUrl;', array('type' => 'inline', 'scope' => 'footer'));    
    drupal_add_js('var network = Drupal.settings.osfOntology.network;', array('type' => 'inline', 'scope' => 'footer'));    
    drupal_add_js('var osf_ontologyModuleFullPath = Drupal.settings.osfOntology.osf_ontologyModuleFullPath;', array('type' => 'inline', 'scope' => 'footer'));    

    
    if (!isset($_GET["classUri"])) {
      $_GET["classUri"] = "";
    }

    if (!isset($_GET["propertyUri"])) {
      $_GET["propertyUri"] = "";
    }

    if (!isset($_GET["niUri"])) {
      $_GET["niUri"] = "";
    }

    $html .= '<script type="text/javascript">
                jQuery(document).ready(function() {
                  readyView("' . check_plain($_GET["dataset"]) . '", "' . $defaultNetwork->uri . '", "' . check_plain($_GET["classUri"]) . '", "' . check_plain($_GET["propertyUri"]) . '", "' . check_plain($_GET["niUri"]) . '");
                });
              </script>';

    $html .= '
        <div id="messagesContainer"></div>

        <table id="ontologyViewTable">
          <tr style="height: 50px;">
            <td colspan="2" style="border: 0px">

              <div class="breadCrumb"><a href="'
      . $base_url . "/" . str_replace("view", "", check_plain($_GET["q"]))
      . '">'.t('Ontologies').'</a> &gt; <a id="breadCrumbOntologyName" href="' . $base_url . '/' . check_plain($_GET["q"]) . '/?network='
      . urlencode($defaultNetwork->uri) . '&dataset=' . urlencode(check_plain($_GET["dataset"])) . '"></a></div>';

    if ((boolean) variable_get("osf_OntologySettings_enable_search", TRUE) === TRUE &&
        empty($_GET['modal']) && empty($_POST['modal'])) {
      $html .= '<div class="searchBoxContainer">
                <input type="text" class="form-text searchBox" id="searchBox" onkeypress="return submitViewSearchEnter(this,event);" /><img src="'
      . $base_url . "/" . drupal_get_path("module", "osf_ontology")
      . '/imgs/magnifier.png" id="searchButtonImage" class="searchButtonImage" title="'.t('Search').'" alt="'.t('Search').'" onclick="viewSearch();" />
                <br />
                <div style="padding-top: 3px">
                  <!--input type="radio" name="option_layout" value="0" checked="checked" title="'.t('Search the active ontology').'" /> Active
                  <input type="radio" name="option_layout" value="1" title="'.t('Search for all ontologies').'" /> All
                  <br /-->
                  <a href="'
      . $base_url . "/" . str_replace("view", "search", check_plain($_GET["q"])) . '/?network=' . urlencode($defaultNetwork->uri)
      . '&dataset='
      . urlencode(check_plain($_GET["dataset"]))
      . '">'.t('Advanced Search').'</a>
                </div>
              </div>';
    }
    else {
      $html .=  '<input type="hidden" class="form-text searchBox" id="searchBox" />';
    }

    $html .=  '</td>
          </tr>
          <tr>
            <td colspan="2" class="tabsRow">
              <div id="classesTab" class="classesTabSelected" onclick="toggleClassesView();">Classes</div>
              <div id="propertiesTab" class="propertiesTabUnselected" onclick="togglePropertiesView();">Properties</div>
              <div id="individualsTab" class="individualsTabUnselected" onclick="toggleIndividualsView();">Individuals</div>
              ' . (variable_get('osf_OntologySettings_enable_reasonner_by_default', 1) == 1 ?
                '<div class="reasonerButtonDiv" onclick="toggleReasoner();"><table><tr><td><img id="reasonerBeaconImg" src="' . $base_url . "/" . drupal_get_path("module", "osf_ontology") . '/imgs/bullet_green.png" title="Reasoner currently enabled" /></td><td><img id="reasonerButtonImg" src="' . $base_url . "/" . drupal_get_path("module", "osf_ontology") . '/imgs/cog_delete.png" title="Disable Reasoner" /></td></tr></table></div>'
                :
                '<div class="reasonerButtonDiv" onclick="toggleReasoner();"><table><tr><td><img id="reasonerBeaconImg" src="' . $base_url . "/" . drupal_get_path("module", "osf_ontology") . '/imgs/bullet_red.png" title="Reasoner currently disabled" /></td><td><img id="reasonerButtonImg" src="' . $base_url . "/" . drupal_get_path("module", "osf_ontology") . '/imgs/cog_add.png" title="Enable Reasoner" /></td></tr></table></div>') .
              '
            </td>
          </tr>
          <tr>
            <td id="ontologyViewColumClass" valign="top"><div id="classesTree"></div><div id="propertiesTree"></div><div id="individualsList"></div></td>
            <td id="ontologyViewColumRecord" valign="top"></td>
          </tr>

        </table>

        <ul id="namedIndividualContentMenu" class="contextMenu">
            <li class="createNewIndividual">
                <a href="#createNewIndividual">'.t('Create new Individual...').'</a>
            </li>
            <li class="delete">
                <a href="#delete">'.t('Delete').'</a>
            </li>
            <li class="renameuri">
                <a href="#renameuri">'.t('Rename URI...').'</a>
            </li>
        </ul>

      ';

    if(!empty($_GET['modal'])) 
    {
      ctools_include('modal');
      ctools_include('ajax');
      ctools_modal_render(t('Ontology Browser'), $html);
    } 
    else 
    {
      return ($html);
    }
  }
  else if (strtolower($_GET['q']) == "osf/ontology") {
    // Check if we have to save this ontology
    if (isset($_POST["saveOntology"])) {
      // Save the ontology
      include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'osf') . '/framework/WebServiceQuerier.php';

      $wsq = new WebServiceQuerier(rtrim($_POST["network"], '/') . "/ontology/update/", "post", "application/rdf+xml",
        "ontology=" . $_POST["saveOntology"] . "&function=saveOntology");

      if ($wsq->getStatus() != 200) {
        $wsq->displayError();
        return ("");
      }

      unset($wsq);

      // Export the ontology to save on the file system.
      $wsq = new WebServiceQuerier(rtrim($_POST["network"], '/') . "/ontology/read/", "post", "application/rdf+xml",
        "ontology=" . $_POST["saveOntology"] . "&function=getSerialized");

      if ($wsq->getStatus() != 200) {
        $wsq->displayError();
        return ("");
      }
      else {
        $ontologySerialization = $wsq->getResultset();

        $fileName = "";

        if (strripos($_POST["saveOntology"], "#") != FALSE) {
          $fileName = substr($_POST["saveOntology"], strripos($_POST["saveOntology"], "#") + 1);
        }
        elseif (strripos($_POST["saveOntology"], "/") != FALSE) {
          $fileName = substr($_POST["saveOntology"], strripos($_POST["saveOntology"], "/") + 1);
        }

        if ($fileName != "") {
          // Write the new ontology file on the server
          file_put_contents(variable_get("osf_OntologySettings_ontologies_files_folder", "/tmp/") . $fileName,
            $ontologySerialization);
        }
        else {
          drupal_set_message(
            t("Ontology couldn't be saved. No file name has been found for it, please contact the site administrator."));
          return ("");
        }
      }

      unset($wsq);

      drupal_set_message(t("Ontology saved."));
    }

    // Check if we are creating a new ontology
    if (isset($_POST["createNewOntology"])) {
      // Get the new ontology OWL template file
      $newOntologyFile =
        file_get_contents(variable_get("osf_OntologySettings_ontologies_files_folder", "/tmp/") . "new.owl");

      // Now, put the new name, description and IRI into this template file

      // Replace all the possible entities by their character. That way, we won't "double encode"
      // these entities. Otherwise, we can endup with things such as "&amp;amp;" which some
      // XML parsers doesn't seem to like (and throws errors).
      $_POST["ontologyName"] =
        str_replace(array("%5C", "&amp;", "&lt;", "&gt;"), array("\\", "&", "<", ">"), $_POST["ontologyName"]);

      $newOntologyFile = str_replace("{{ONTOLOGY-NAME}}", xmlEncode($_POST["ontologyName"]), $newOntologyFile);

      $newOntologyFile =
        str_replace("{{ONTOLOGY-DESCRIPTION}}", xmlEncode($_POST["ontologyDescription"]), $newOntologyFile);

      $newOntologyFile = str_replace("{{ONTOLOGY-IRI}}", xmlEncode($_POST["ontologyUri"]), $newOntologyFile);

      // Compose the version IRI
      $versionIRI = $_POST["ontologyUri"];
      $fileName = "";

      if (substr($versionIRI, strlen($versionIRI) - 1, 1) == "#") {
        $fileName =
          substr($versionIRI, strrpos($versionIRI, "/") + 1, strlen($versionIRI) - strrpos($versionIRI, "/") - 2)
            . "-1.0.owl";

        $versionIRI = substr($versionIRI, 0, strlen($versionIRI) - 1);

        $versionIRI .= "/1.0#";
      }
      elseif (substr($versionIRI, strlen($versionIRI) - 1, 1) == "/") {
        $versionIRI = substr($versionIRI, 0, strlen($versionIRI) - 1);
        
        $fileName =
          substr($versionIRI, strrpos($versionIRI, "/") + 1, strlen($versionIRI) - strrpos($versionIRI, "/") - 1)
            . "-1.0.owl";

        $versionIRI .= "/1.0/";
      }
      else {
        $fileName = substr($versionIRI, strrpos($versionIRI, "/"), strlen($versionIRI) - strrpos($versionIRI, "/") - 1)
          . "-1.0.owl";

        $versionIRI = substr($versionIRI, 0, strlen($versionIRI) - 1);

        $versionIRI .= "1.0";
      }

      $newOntologyFile = str_replace("{{ONTOLOGY-VERSION-IRI}}", xmlEncode($versionIRI), $newOntologyFile);

      // Write the new ontology file on the server
      file_put_contents(variable_get("osf_OntologySettings_ontologies_files_folder", "/tmp/") . $fileName, $newOntologyFile);

      // Now, let's import the new ontology into the OWLAPI
      $defaultEndpoint = current(osf_configure_get_default_endpoint());
      
      $ontologyURI = "file://localhost" . variable_get("osf_OntologySettings_ontologies_files_folder", "/tmp/") . $fileName;

      // Now create the access permissions for the core Drupal user
      $crudPermissions = new CRUDPermission(TRUE, TRUE, TRUE, TRUE);
      
      $authRegistrarAccess = new AuthRegistrarAccessQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_first_user_uri());
      
      $authRegistrarAccess->create(osf_configure_get_administrator_group_uri(), $ontologyURI, $crudPermissions, osf_configure_osf_get_registered_webservices($defaultEndpoint))
                          ->mime('text/xml')
                          ->send(new DrupalQuerierExtension());
                           
      if(!$authRegistrarAccess->isSuccessful())
      {
        drupal_set_message(t("Couldn't create permissions on the imported ontology for the administrator group."), 'warning', TRUE);        
      }
      else
      {
        $ontologyCreate = new OntologyCreateQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_current_user_uri());
        
        $ontologyCreate->enableAdvancedIndexation()
                       ->uri($ontologyURI);
                       
        $ontologyCreate->send(new DrupalQuerierExtension());
        
        if(!$ontologyCreate->isSuccessful())
        {
          drupal_set_message(t("Can't import ontology: [@error] @errorMsg - @errorDescription", 
                   array("@error" => $ontologyCreate->getStatus(),
                         "@errorMsg" => $ontologyCreate->getStatusMessage(),
                         "@errorDescription" => $ontologyCreate->getStatusMessageDescription())), 
                   "error", 
                   TRUE);
        }
        else
        {
          // Register these permissions in drupal's permissions system
          user_role_grant_permissions(3, array(
            'create ontology '.md5($ontologyURI).' '.$defaultEndpoint->sceid,
            'read ontology '.md5($ontologyURI).' '.$defaultEndpoint->sceid,
            'update ontology '.md5($ontologyURI).' '.$defaultEndpoint->sceid,
            'delete ontology '.md5($ontologyURI).' '.$defaultEndpoint->sceid,
          ));
        
          drupal_set_message(t("New ontology created")); 
        }         
      }      
    }

    // Check if we have to reload all ontologies from the ontologies files folder on the server.
    if (isset($_POST["reload"])) {
      IndexOntologiesDirectory(variable_get("osf_OntologySettings_ontologies_files_folder", "/tmp/"),
        $_POST["network"]);
    }

    // Check if we have to serialize/cache the ontologie structures
    if (isset($_POST["updateCaches"])) {
      // Once we start the ontology importation process, we have to make sure that even if the server
      // loose the connection with the user the process will still finish.
      ignore_user_abort(true);

      // However, maybe there is an issue with the server handling that file tht lead to some kind of infinite or near
      // infinite loop; so we have to limit the execution time of this procedure to 45 mins.
      drupal_set_time_limit(2700);

      include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'osf') . '/framework/WebServiceQuerier.php';

      include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'osf') . '/framework/ProcessorXML.php';


      $loadedOntologies = array();

      $wsq = new WebServiceQuerier(rtrim($_POST["network"], '/') . "/ontology/read/", "post", "text/xml",
        "function=getLoadedOntologies&parameters=" . urlencode("mode=uris"));

      if ($wsq->getStatus() != 200) {
        $wsq->displayError();
      }
      else {
        $xml = new ProcessorXML();
        $xml->loadXML($wsq->getResultset());

        $records = $xml->getSubjectsByType("owl:Ontology");

        foreach ($records as $record) {
          array_push($loadedOntologies, $xml->getURI($record));
        }
      }

      unset($wsq);
      
      // Generate one ironXML Schema for each loaded ontologies.
      if (count($loadedOntologies) > 0) {
        foreach ($loadedOntologies as $onto) {
          
          watchdog('osf_ontology', 'getIronXMLSchema for ontology: %ontology', array('%ontology' => $onto), WATCHDOG_DEBUG);
          
          $wsq = new WebServiceQuerier(rtrim($_POST["network"], '/') . "/ontology/read/", "post", "text/xml",
            "function=getIronXMLSchema&ontology=" . urlencode($onto));

          if ($wsq->getStatus() != 200) {
            watchdog('osf_ontology', 'getIronXMLSchema error on %ontology. [%error] %errorMsg - %errorDescription.', 
                     array('%ontology' => $onto,
                           '%error' => $wsq->getStatus(),
                           '%errorMsg' => $wsq->getStatusMessage(),
                           '%errorDescription' => $wsq->getStatusMessageDescription()), WATCHDOG_ERROR);
            
            $wsq->displayError();
          }
          else {
            $folder = variable_get("osf_OntologySettings_ontologies_ironxml_cache_folder", "/tmp");

            $filename = substr($onto, strripos($onto, "/") + 1);

            $filename = substr($filename, 0, strripos($filename, "."));
            
            $filename = preg_replace("/[^A-Za-z0-9_]/", '_', $filename);

            $xml = new ProcessorXML();
            $xml->loadXML($wsq->getResultset());

            $records = $xml->getSubjectsByType("owl:Ontology");

            $ironXMLSchema = "";

            foreach ($records as $record) {
              
              watchdog('osf_ontology', 'getIronXMLSchema for ontology: %ontology', array('%ontology' => $onto), WATCHDOG_DEBUG);
              
              $predicates = $xml->getPredicatesByType($record, "http://purl.org/ontology/wsf#serializedIronXMLSchema");

              $objects = $xml->getObjectsByType($predicates->item(0), "rdfs:Literal");

              $ironXMLSchema = $xml->getContent($objects->item(0));
            }

            file_put_contents(rtrim($folder, "/") . "/" . $filename . ".xml", $ironXMLSchema);
          }

          unset($wsq);
        }
      }

      // Generate one ironJSON Schema for each loaded ontologies.
      if (count($loadedOntologies) > 0) {
        foreach ($loadedOntologies as $onto) {
          watchdog('osf_ontology', 'getIronJSONSchema for ontology: %ontology', array('%ontology' => $onto), WATCHDOG_DEBUG);
          $wsq = new WebServiceQuerier(rtrim($_POST["network"], '/') . "/ontology/read/", "post", "text/xml",
            "function=getIronJSONSchema&ontology=" . urlencode($onto));

          if ($wsq->getStatus() != 200) {
            watchdog('osf_ontology', 'getIronJSONSchema error on %ontology. [%error] %errorMsg - %errorDescription.', 
                     array('%ontology' => $onto,
                           '%error' => $wsq->getStatus(),
                           '%errorMsg' => $wsq->getStatusMessage(),
                           '%errorDescription' => $wsq->getStatusMessageDescription()), WATCHDOG_ERROR);
            
            
            $wsq->displayError();
          }
          else {
            $folder = variable_get("osf_OntologySettings_ontologies_ironjson_cache_folder", "/tmp");

            $filename = substr($onto, strripos($onto, "/") + 1);

            $filename = substr($filename, 0, strripos($filename, "."));
            
            $filename = preg_replace("/[^A-Za-z0-9_]/", '_', $filename);

            $xml = new ProcessorXML();
            $xml->loadXML($wsq->getResultset());

            $records = $xml->getSubjectsByType("owl:Ontology");

            $ironJSONSchema = "";

            foreach ($records as $record) {
              
              watchdog('osf_ontology', 'getIronJSONSchema record processing', array(), WATCHDOG_DEBUG);
              
              $predicates = $xml->getPredicatesByType($record, "http://purl.org/ontology/wsf#serializedIronJSONSchema");

              $objects = $xml->getObjectsByType($predicates->item(0), "rdfs:Literal");

              $ironJSONSchema = $xml->getContent($objects->item(0));
            }

            // Create the json file that can be loaded from anywhere
            file_put_contents(rtrim($folder, "/") . "/" . $filename . ".json", $ironJSONSchema);

            // Create the pre-existing JS script to load that schema in a Schema object.
            $ironJSONSchema = 'var ' . $filename . '_schema_srz = ' . $ironJSONSchema . ";";
            $ironJSONSchema .= 'var ' . $filename . '_schema = new Schema(' . $filename . '_schema_srz);';

            // Special handling: make sure to convert all "%5C" characters into "\". This has to be done because
            // of the way the ProcessorXML.php (so, the DOMDocument API) works, and how the xml-encoding currently
            // works. Enventually, we should use the simplexml API in the processorXML script to properly
            // manage the encoding, and decoding of the XML data, *AND* of the HTML entities (it is the HTML
            // entities that are strangely manipulated in the DOMDocument API).
            $ironJSONSchema = str_replace("%5C", '\\', $ironJSONSchema);

            file_put_contents(rtrim($folder, "/") . "/" . $filename . ".js", $ironJSONSchema);
          }

          unset($wsq);
        }

        // Create the JS schema file.

        $schemaJS = ' /* List of attribute URIs that are generally used for labeling entities in different ontologies */
                    var prefLabelAttributes = [
                      "http://www.w3.org/2004/02/skos/core#prefLabel",
                      "http://purl.org/ontology/iron#prefLabel",
                      "http://umbel.org/umbel#prefLabel",
                      "http://purl.org/dc/terms/title",
                      "http://purl.org/dc/elements/1.1/title",
                      "http://xmlns.com/foaf/0.1/name",
                      "http://xmlns.com/foaf/0.1/givenName",
                      "http://xmlns.com/foaf/0.1/family_name",
                      "http://www.geonames.org/ontology#name",
                      "http://www.w3.org/2000/01/rdf-schema#label"
                    ];

                    var altLabelAttributes = [
                      "http://www.w3.org/2004/02/skos/core#altLabel",
                      "http://purl.org/ontology/iron#altLabel",
                      "http://umbel.org/umbel#altLabel",
                    ];

                    var descriptionAttributes = [
                      "http://purl.org/ontology/iron#description",
                      "http://www.w3.org/2000/01/rdf-schema#comment",
                      "http://purl.org/dc/terms/description",
                      "http://purl.org/dc/elements/1.1/description",
                      "http://www.w3.org/2004/02/skos/core#definition"
                    ];


                    function Schema(sjson)
                    {
                      // Define all prefixes of this resultset
                      this.prefixes = sjson.schema.prefixList;

                      // Unprefixize all URIs of this Schema
                      var resultsetJsonText = JSON.stringify(sjson);

                      for(var prefix in this.prefixes)
                      {
                        if(this.prefixes.hasOwnProperty(prefix))
                        {
                          var pattern = new RegExp(prefix+"_", "igm");
                          resultsetJsonText = resultsetJsonText.replace(pattern, this.prefixes[prefix]);
                        }
                      }

                      sjson = JSON.parse(resultsetJsonText);

                      this.attributes = sjson.schema.attributeList;

                      this.types = sjson.schema.typeList;

                      // Extend all attributes of this schema with additional functions
                      for(var i = 0; i < this.attributes.length; i++)
                      {
                        this.attributes[i].prefixes = this.prefixes;
                      }

                      // Extend all types of this schema with additional functions
                      for(var i = 0; i < this.types.length; i++)
                      {
                        this.types[i].prefixes = this.prefixes;
                      }
                    }';

        file_put_contents(rtrim($folder, "/") . "/schema.js", $schemaJS);
      }

      // Generate the classes hierarchy file

      $serializedClassHierarchy = "";
      $serializedPropertiesHierarchy = "";

      watchdog('osf_ontology', 'getSerializedClassHierarchy request', array(), WATCHDOG_DEBUG);
      $wsq = new WebServiceQuerier(rtrim($_POST["network"], '/') . "/ontology/read/", "post", "text/xml",
        "function=getSerializedClassHierarchy");

      $cache_path = rtrim(variable_get('osf_OntologySettings_ontologies_cache_folder', '/tmp'), '/') . '/';

      if ($wsq->getStatus() != 200) {
        watchdog('osf_ontology', 'getSerializedClassHierarchy error. [%error] %errorMsg - %errorDescription.', 
                 array('%ontology' => $onto,
                       '%error' => $wsq->getStatus(),
                       '%errorMsg' => $wsq->getStatusMessage(),
                       '%errorDescription' => $wsq->getStatusMessageDescription()), WATCHDOG_ERROR);
        
        $wsq->displayError();
      }
      else {
        $xml = new ProcessorXML();
        $xml->loadXML($wsq->getResultset());

        $records = $xml->getSubjectsByType("owl:Ontology");

        foreach ($records as $record) {
          watchdog('osf_ontology', 'getSerializedClassHierarchy record processing', array(), WATCHDOG_DEBUG);
          $predicates = $xml->getPredicatesByType($record, "http://purl.org/ontology/wsf#serializedClassHierarchy");

          $objects = $xml->getObjectsByType($predicates->item(0), "rdfs:Literal");

          $serializedClassHierarchy = $xml->getContent($objects->item(0));
        }

        // Write the serialized structure to the cache file.
        file_put_contents($cache_path . "classHierarchySerialized.srz", $serializedClassHierarchy);

        drupal_set_message(
          t("The classes ontological structure's cache used by OSF for Drupal and OSF has been successfully updated."));
      }

      unset($wsq);

      watchdog('osf_ontology', 'getSerializedPropertyHierarchy request', array(), WATCHDOG_DEBUG);
      $wsq = new WebServiceQuerier(rtrim($_POST["network"], '/') . "/ontology/read/", "post", "text/xml",
        "function=getSerializedPropertyHierarchy");

      if ($wsq->getStatus() != 200) {
        watchdog('osf_ontology', 'getSerializedPropertyHierarchy error. [%error] %errorMsg - %errorDescription.', 
                 array('%ontology' => $onto,
                       '%error' => $wsq->getStatus(),
                       '%errorMsg' => $wsq->getStatusMessage(),
                       '%errorDescription' => $wsq->getStatusMessageDescription()), WATCHDOG_ERROR);

        $wsq->displayError();
      }
      else {

        $xml = new ProcessorXML();
        $xml->loadXML($wsq->getResultset());

        $records = $xml->getSubjectsByType("owl:Ontology");

        foreach ($records as $record) {
          watchdog('osf_ontology', 'getSerializedPropertyHierarchy record processing', array(), WATCHDOG_DEBUG);
          $predicates = $xml->getPredicatesByType($record, "http://purl.org/ontology/wsf#serializedPropertyHierarchy");

          $objects = $xml->getObjectsByType($predicates->item(0), "rdfs:Literal");

          $serializedPropertiesHierarchy = $xml->getContent($objects->item(0));
        }

        // Write the serialized structure to the cache file.
        file_put_contents($cache_path . "propertyHierarchySerialized.srz", $serializedPropertiesHierarchy);

        drupal_set_message(
          t("The properties ontological structure's cache used by OSF for Drupal and OSF has been successfully updated."));
      }

      unset($wsq);

      drupal_set_message(
        t("All ontologies structures caches have been re-created from these ontologies descriptions. OSF, OSF for Drupal and Semantic Components will take these new ontologies into account."));
    }

    $html = "";

    drupal_add_js(drupal_get_path("module", "osf_ontology") . "/js/ontologySearch.js");

    $defaultNetwork = current(osf_configure_get_default_endpoint());

    drupal_add_js(array('osfOntology' => array('structModulesBaseUrl' => $base_url . '/osf/')), 'setting');
    drupal_add_js(array('osfOntology' => array('network' => $defaultNetwork->uri)), 'setting');
    drupal_add_js(array('osfOntology' => array('osf_ontologyModuleFullPath' => $base_url . "/" . drupal_get_path("module", "osf_ontology"))), 'setting');
    drupal_add_js(array('osfOntology' => array('searchURL' => $base_url . "/" . $_GET["q"] . "/search/")), 'setting');

    
    drupal_add_js('var structModulesBaseUrl = Drupal.settings.osfOntology.structModulesBaseUrl;', array('type' => 'inline', 'scope' => 'footer'));    
    drupal_add_js('var network = Drupal.settings.osfOntology.network;', array('type' => 'inline', 'scope' => 'footer'));    
    drupal_add_js('var osf_ontologyModuleFullPath = Drupal.settings.osfOntology.osf_ontologyModuleFullPath;', array('type' => 'inline', 'scope' => 'footer'));    
    drupal_add_js('var searchURL = Drupal.settings.osfOntology.searchURL;', array('type' => 'inline', 'scope' => 'footer'));    


    if (!variable_get('osf_OntologySettings_read_mode', 1) && user_access('administer osf') &&
        empty($_GET['modal']) && empty($_POST['modal'])) {
      drupal_add_js(array('osfOntology' => array('isAdmin' => true)), 'setting');
    }
    else {
      drupal_add_js(array('osfOntology' => array('isAdmin' => false)), 'setting');
    }
    
    drupal_add_js('var isAdmin = Drupal.settings.osfOntology.isAdmin;', array('type' => 'inline', 'scope' => 'footer'));          

    $endpointSCEID = db_query('SELECT sceid FROM {osf_configure_endpoints} WHERE uri = :uri', 
                         array(':uri' => current(osf_configure_get_default_endpoint())->uri))->fetchField();
    
    drupal_add_js('var sceid = '.$endpointSCEID.';', 'inline');    

    $html .= '<div class="breadCrumb"><a href="">'.t('Ontologies').'</a></div>';

    if ((boolean) variable_get("osf_OntologySettings_enable_search", TRUE) === TRUE &&
        empty($_GET['modal']) && empty($_POST['modal'])) 
    {
      $html .= '<div class="searchBoxContainer">
                    <input type="text" class="form-text searchBox" id="searchBox" onkeypress="return submitSearchEnter(this,event);" />
                    <img src="'
        . $base_url . "/" . drupal_get_path("module", "osf_ontology")
        . '/imgs/magnifier.png" id="searchButtonImage" class="searchButtonImage" title="'.t('Search').'" alt="'.t('Search').'" onclick="search();" />
                    <br />
                    <div style="padding-top: 3px">
                      <input id="activeRadioButton" type="radio" name="option_layout" value="0" checked="checked" title="'.t('Search the active ontology').'" /> Active
                      <input id="allRadioButton" type="radio" name="option_layout" value="1" title="'.t('Search the active ontology').'" /> All
                    </div>
                  </div>';
    }
    else {
      $html .=  '<input type="hidden" class="form-text searchBox" id="searchBox" />';
    }


    // This is the main page where people can select loaded ontologies
    $html .= '  <div id="messagesContainer"></div>
                <table class="ontologiesListLayoutTable">
                  <tr>
                    <td>';

    $html .= '<div class="ontologiesListContainer" id="ontologiesListContainer"></div>';
    $html .= '<div class="ontologyEditContainer" id="ontologyEditContainer"></div>';

    drupal_add_js('var OSFBaseURL = "' . $defaultNetwork->uri . '";', 'inline');
    
    $html .= '<div class="ontologiesActionsContainer" id="ontologiesActionsContainer">';

    global $base_url;

    $viewButtonLabel = "";

    if (variable_get('osf_OntologySettings_read_mode', 1) || !user_access('administer osf') ||
        !empty($_GET['modal']) || !empty($_POST['modal'])) {
      $viewButtonLabel = t("View");
    }
    else {
      $viewButtonLabel = t("View/Annotate");
    }

    if(!empty($_GET['modal']) || !empty($_POST['modal'])) 
    {  
      $html .= '  <div class="actionsSectionHeader">User</div>
              <center>
                <form action="' . $base_url . '/osf/ontology/view/" method="GET">
                  <input name="network" type="hidden" value="'. $defaultNetwork->uri . '" />
                  <input name="dataset" type="hidden" value="" id="viewButtonIntputDataset" />
                  <input name="modal" type="hidden" value="1"/>
                  <input name="browse" type="hidden" value="1"/>
                  <input type="submit" value="' . $viewButtonLabel . '" class="actionViewButton" title="'.t('View the selected ontology').'" />                      
                </form>
              </center>';
    }
    else
    {
      $html .= '  <div class="actionsSectionHeader">User</div>
                    <center>
                      <form action="' . $base_url . '/osf/ontology/view/" method="GET">
                        <input name="network" type="hidden" value="'. $defaultNetwork->uri . '" />
                        <input name="dataset" type="hidden" value="" id="viewButtonIntputDataset" />
                        <input type="submit" value="' . $viewButtonLabel . '" class="actionViewButton" title="'.t('View the selected ontology').'" />                      
                      </form>
                      <form action="" method="GET">
                        <input name="network" type="hidden" value="' . $defaultNetwork->uri . '" />';

      if ((boolean) variable_get("osf_OntologySettings_enable_export", TRUE) === TRUE) {
        $html .= '           <input name="exportUri" type="hidden" value="" id="exportButtonIntputDataset" />';
        $html .= '             <input type="submit" value="'.t('Export').'" class="actionExportButton" title="'.t('Export te selected ontology').'" />';
      }

      $html .= '       </form>
                    </center>';
    }

    if(user_access('administer osf') && !variable_get('osf_OntologySettings_read_mode', 1) &&
       empty($_GET['modal']) && empty($_POST['modal'])) 
    {
      $html .= '  <br />
                    <div class="actionsSectionHeader">Admin</div>
                    <center>
                      <input type="button" value="'.t('Create').'" class="actionCreateNewButton" title="'.t('Create a new ontology').'" onclick="createNew();" />
                      <form action="" method="POST">
                        <input name="network" type="hidden" value="'
        . $defaultNetwork->uri . '" />
                        <input name="saveOntology" type="hidden" value="" id="saveButtonInputUri" />
                        <input type="submit" value="'.t('Save').'" class="actionSaveButton" title="'.t('Save this ontology').'" />
                      </form>
                      <!--form action="" method="POST" onsubmit="return confirm(\''.t('Are you sure you want to unload this ontology?').'\');">
                        <input name="network" type="hidden" value="'
        . $defaultNetwork->uri . '" />
                        <input name="deleteUri" type="hidden" value="" id="deleteButtonInputUri" />
                        <input type="submit" value="'.t('Unload').'" class="actionDeleteButton" title="'.t('Unload the selected ontology').'" />
                      </form-->
                      <form action="" method="POST" onsubmit="return confirm(\''.t('Are you sure you want to delete this ontology from the system?').'\');">
                        <input name="network" type="hidden" value="'
        . $defaultNetwork->uri . '" />
                        <input name="removeUri" type="hidden" value="" id="removeButtonInputUri" />
                        <input type="submit" value="'.t('Delete').'" class="actionRemoveButton" title="'.t('Remove the selected ontology from the system').'" />
                      </form>
                      <input type="button" value="'.t('Import').'" class="actionImportButton" onclick="toggleImportInput();" title="'.t('Import a new ontology').'" />
                      <form action="" method="POST">
                        <input name="network" type="hidden" value="'
        . $defaultNetwork->uri . '" />
                        <input name="updateCaches" type="hidden" value="" id="updateCachesInput" />
                        <input type="submit" value="Generate All" class="actionCacheButton" title="'.t('Update the ontologies caches used by OSF, OSF for Drupal and the Semantic Components').'" />
                      </form>
                      <form action="" method="POST">
                        <input name="network" type="hidden" value="'
        . $defaultNetwork->uri
        . '" />
                        <input name="reload" type="hidden" value="" id="updateReloadInput" />
                        <input type="submit" value="Reload All" class="actionReloadButton" title="'.t('Reload all ontologies from the Ontologies Files folder.').'" />
                      </form>
                    </center>
                    </div>
                    ';
    }

    $html .= '    </td>
                  </tr>';

    $html .= '  <tr>
                    <td>';

    $html .= '<script type="text/javascript">jQuery(document).ready(function() {readyListOntologies();});</script>';

    $html .= '
                  <div id="importBox">
                    <form enctype="multipart/form-data" action="" method="POST">
                       <input class="form-text" name="network" type="hidden" value="'
      . $defaultNetwork->uri
      . '" />
                       <input name="userfile" type="file" size="61" />
                       <input class="form-submit" type="submit" value="'.t('Import Ontology').'" />

                       <br />

                       <p>
                         Index using inference:&nbsp;&nbsp; <input name="reasoner" value="true" type="radio" checked /> '.t('Yes').' &nbsp;&nbsp; <input name="reasoner" value="false" type="radio" /> '.t('No').'
                       </p>
                    </form>
                  </div>
              ';

    $html .= '    </td>
                  </tr>
                </table>';

    if (!empty($_GET['modal'])) {
      ctools_include('modal');
      ctools_include('ajax');
      ctools_modal_render(t('Ontology Browser'), $html) ;
    } else {
      return ($html);
    }                
  }
  else {
    return ("");
  }
}

/** 
 * @brief Define user permissions.
 * @details 	This hook can supply permissions that the module defines, so that they can be selected on the user
 * permissions page and used to restrict access to actions the module performs.
 * 
 * The permissions in the array do not need to be wrapped with the function t(), since the string extractor
 * takes care of extracting permission names defined in the perm hook for translation.
 * 
 * Permissions are checked using user_access().
 * 
 * @note Currently only two kind of users exist: (1) "access" and (2) "administer". However, we expect to have more
 * kind of users in the future for different node maintenance purposes.
 * 
 * @note Depending on the user (access or administer), some part of this view module will be available to the user.
 * 
 * @note Once new permissions are created, the node administrator has to set their permissions in the setting panel
 * of the node
 * 
 * @return An array of permissions strings.
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 * 
 * @see http://api.drupal.org/api/function/hook_perm
 */
function osf_ontology_permission() {
  return array(
    'access osf ontology' => array(
      'title' => t('access osf ontology'),
      'description' => t('access osf ontology'),
    ),
    'administer osf ontology' => array(
      'title' => t('administer osf ontology'),
      'description' => t('administer osf ontology'),
    ),
  );
}


/** 
 * @brief Define menu items and page callbacks.
 * @details 	This hook enables modules to register paths, which determines whose requests are to be handled.
 * Depending on the type of registration requested by each path, a link is placed in the the navigation
 * block and/or an item appears in the menu administration page (q=admin/menu).
 * 
 * @return An array of menu items. Each menu item has a key corresponding to the Drupal path being registered.
 * The item is an associative array.
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 * 
 * @see http://api.drupal.org/api/function/hook_block
 */
function osf_ontology_menu() {
  $items = array();

  // Register the OSF Ontology settings page
  $items['admin/config/osf/osf_ontology'] =
    array(
    'title' => t('Ontology'),
    'description' => t('Settings of the Ontology plugin'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('osf_ontology_settings'),
    'access arguments' => array('administer osf ontology'),
    'type' => MENU_LOCAL_TASK,
    'weight' => -25,    
  );

  // Registration of the main OSF for Drupal module page path
  $items['osf/ontology'] =
    array(
    'page callback' => 'osf_ontology_main',
    'access arguments' => array('access osf ontology'),
    'type' => MENU_CALLBACK,
  );
  
  // Create the top admin menu for quickly accessing datasets
  $items['admin/ontology'] = array(
    'title' => t('Ontologies'),
    'weight' => -7,
    'description' => t('Administer OSF ontologies'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('osf_configure_ontologies_top_menu'),    
    'access arguments' => array('access osf ontology'),
  );  

  return $items;
}

function osf_ontology_admin_paths() 
{
  $paths = array(
    'osf/ontology' => TRUE,
    'osf/ontology/view' => TRUE,
    'osf/ontology/search' => TRUE,
  );
    
  return $paths;
}

function osf_configure_ontologies_top_menu($form, $form_state) {
  drupal_goto('osf/ontology');
}

/**
 * @brief Ontology settings page
 * 
 * @note This procedure has been registered to Drupal in the osf_menu() procedure.
 * 
 * @return A form object where all the settings have been defined.
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 * 
 * @see http://drupal.org/node/206761
 * @see http://drupal.org/node/37775
 * 
 */
function osf_ontology_settings() {
  global $base_url;
  global $user;
  
  $form['read-mode'] = array(
    '#type' => 'fieldset',
    '#title' => t('Read mode'),
    '#Description' => t('Force OSF Ontology to be in reading mode.'),
    '#weight' => 1,
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );  
  
  $form['read-mode']["osf_OntologySettings_read_mode"] = array(
    '#type' => 'checkbox',
    '#title' => t('Read mode'),
    '#description' => t(
    "This option force the read mode of the ontology management tool. All users, including system administrator will only be able to read and export ontologies from this user interface. All the administrative tasks, such as creating, deleting, saving, etc. ontologies will be done using the Ontology Management Tool command line utility."),
    '#default_value' => variable_get('osf_OntologySettings_read_mode', 1),
  );  
  
  $form['general'] = array(
    '#type' => 'fieldset',
    '#title' => t('General'),
    '#Description' => t('General OSF Ontology options to change some of its behaviors.'),
    '#weight' => 2,
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );   
  
  $form['general']["osf_OntologySettings_enable_reasonner_by_default"] = array(
    '#type' => 'textfield',
    '#title' => t('Enable ontology reasoner by default'),
    '#default_value' => variable_get("osf_OntologySettings_enable_reasonner_by_default", TRUE),
    '#size' => 60,
    '#maxlength' => 2048,
    '#description' => t(
      "This will enable the reasoner by default"),
    '#required' => FALSE,
  );

  $form['general']["osf_OntologySettings_enable_search"] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable ontology search'),
    '#description' => t(
    "This will enable the search feature embeded into the osf_ontology module. If this option is
       unchecked, all the search options will be disabled in the module. "),
    '#default_value' => variable_get('osf_OntologySettings_enable_search', 1),
  );

  $form['general']["osf_OntologySettings_enable_export"] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable ontology export'),
    '#description' => t(
    "This will enable the export feature embeded into the osf_ontology module. If this option is
       unchecked, the export button won't be displayed to the users. "),
    '#default_value' => variable_get('osf_OntologySettings_enable_export', 1),
  );

  $form['general']['osf_OntologySettings_enable_reasonner_by_default'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable ontology reasoner by default'),
    '#description' => t(
    "This will enable the reasoner by default when a osf_ontology view page is being opened by a user."),
    '#default_value' => variable_get('osf_OntologySettings_enable_reasonner_by_default', 1),
  );  
  
  $form['ontologies-files'] = array(
    '#type' => 'fieldset',
    '#title' => t('Ontologies files'),
    '#description' => t('The ontologies files and paths settings are used in a OSF (Open Semantic Framework) single server instance. These paths tells the OSF Ontology module where to save, load ontologies and where to generate sub-structures. These need to be properly configured when you want to use OSF Ontology to administer ontologies on your server.'),
    '#weight' => 3,
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );   
  
  $form['ontologies-files']["osf_OntologySettings_ontologies_files_folder"] = array(
    '#type' => 'textfield',
    '#title' => t('Ontologies Files Path folder'),
    '#default_value' => variable_get("osf_OntologySettings_ontologies_files_folder", "/tmp/"),
    '#size' => 60,
    '#maxlength' => 2048,
    '#description' => t("This is the path of the folder where ontologies files get saved on the server."),
    '#required' => FALSE,
  );

  $form['ontologies-files']["osf_OntologySettings_ontologies_cache_folder"] = array(
    '#type' => 'textfield',
    '#title' => t('Ontologies Cache Path folder'),
    '#default_value' => variable_get("osf_OntologySettings_ontologies_cache_folder", "/tmp/"),
    '#size' => 60,
    '#maxlength' => 2048,
    '#description' => t(
      "This is the path of the folder where ontologies cache files get saved on the server. This is used to to save the cache of the ontologies. These caches are used by OSF for Drupal and OSF."),
    '#required' => FALSE,
  );

  $form['ontologies-files']["osf_OntologySettings_ontologies_ironxml_cache_folder"] = array(
    '#type' => 'textfield',
    '#title' => t('Ontologies ironXML Schema Cache Path folder'),
    '#default_value' => variable_get("osf_OntologySettings_ontologies_ironxml_cache_folder", "/tmp/"),
    '#size' => 60,
    '#maxlength' => 2048,
    '#description' => t(
      "This is the path of the folder where ironXML Schemas cache files get saved on the server. This is used to to save the cache of the ontologies in ironXML schemas. These caches are mainly used by the semantic components. This folder should be accessible on the web so that any semantic component has access to them."),
    '#required' => FALSE,
  );

  $form['ontologies-files']["osf_OntologySettings_ontologies_ironjson_cache_folder"] = array(
    '#type' => 'textfield',
    '#title' => t('Ontologies ironJSON Schema Cache Path folder'),
    '#default_value' => variable_get("osf_OntologySettings_ontologies_ironjson_cache_folder", "/tmp/"),
    '#size' => 60,
    '#maxlength' => 2048,
    '#description' => t(
      "This is the path of the folder where ironJSON Schemas cache files get saved on the server. This is used to to save the cache of the ontologies in ironJSON schemas. These caches are normally used by some JavaScript applications. This folder should be accessible on the web so that any applications that uses these JSON schemas has access to them."),
    '#required' => FALSE,
  );

  return system_settings_form($form);
}


/** 
 * @brief Declare a block or set of blocks.
 * @details 	Any module can export a block (or blocks) to be displayed by defining the _block hook. This hook
 * is called by theme.inc to display a block, and also by block.module to procure the list of available blocks.
 * 
 * The functions mymodule_display_block_1 and 2, as used in the example, should of course be defined
 * somewhere in your module and return the content you want to display to your users. If the "content"
 * element is empty, no block will be displayed even if "subject" is present.
 * 
 * After completing your blocks, do not forget to enable them in the block admin menu.
 * 
 * @param[in] $op What kind of information to retrieve about the block or blocks. Possible values:
 * @li 'list': A list of all blocks defined by the module.
 * @li 'configure': Configuration form for the block.
 * @li 'save': Save the configuration options.
 * @li 'view': Process the block when enabled in a region in order to view its contents.
 * 
 * @param[in] $delta Which block to return (not applicable if $op is 'list'). Although it is most commonly an integer starting at 0, this is not mandatory. For instance, aggregator.module uses string values for $delta.
 * 
 * @param[in] $edit If $op is 'save', the submitted form data from the configuration form.
 * 
 * @return If $op is 'list': An array of block descriptions. Each block description is an associative array.
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 * 
 * @see http://api.drupal.org/api/function/hook_block
 * 
 */
function osf_ontology_block_info() {
  // TODO Rename block deltas (e.g. delta-0) to readable strings. // If $op is "list", we just need to return a list of block descriptions.
  // This is used to provide a list of possible blocks to the administrator,
  // end users will not see these descriptions.
  $blocks['delta-0']['info'] = t('OSF Ontology');
  return $blocks;
}

/**
 * Implements hook_block_configure().
 */
function osf_ontology_block_configure($delta) {
  // TODO Rename block deltas (e.g. delta-0) to readable strings. // If $op is "configure", we need to provide the administrator with a
  // configuration form. The $delta parameter tells us which block is being
  // configured. In this example, we'll allow the administrator to customize
  // the text of the first block.
  $form = array();

  if ($delta == 'delta-0') {
    // All we need to provide is a text field, Drupal will take care of
    // the other block configuration options and the save button.
    $form['block_example_string'] = array(
      '#type' => 'textfield',
      '#title' => t('Block contents'),
      '#size' => 100,
      '#description' => t('This string will appear in the OSF for Drupal Tools menu'),
      '#default_value' => '',
    );
  }
  return $form;
}

/**
 * Implements hook_block_save().
 */
function osf_ontology_block_save($delta, $edit) {
  // TODO Rename block deltas (e.g. delta-0) to readable strings. // If $op is "save", we need to save settings from the configuration form.
  // Since the first block is the only one that allows configuration, we
  // need to check $delta to make sure we only save it.
  if ($delta == 'delta-0' && isset($edit['osf_ontology_string'])) {
    // Have Drupal save the string to the database.
    variable_set('osf_ontology_string', $edit['osf_ontology_string']);
  }
  return;
}

/**
 * Implements hook_block_view().
 */
function osf_ontology_block_view($delta) {
  // TODO Rename block deltas (e.g. delta-0) to readable strings. // If $op is "view", then we need to generate the block for display
  // purposes. The $delta parameter tells us which block is being requested.
  switch ($delta) {
    case 'delta-0':
      // The subject is displayed at the top of the block. Note that it
      // should be passed through t() for translation.
      $block['subject'] = t('OSF Ontology');
      // The content of the block is typically generated by calling a custom
      // function.
      $block['content'] = osf_ontology_contents(1);
      break;
  }
  return $block;
}

/** 
 * @brief Display the OSF for Drupal side-bar menu items
 * @details 	This function is called to generate the HTML of the tool lists being displayed in the side-bar.
 * 
 * @return A string where the HTML menus have been defined.
 * 
 * \b Available \b variables:
 * - \b $localPath: The local path of the server where the images in the menu are located.
 * - \b $menuItems: A string where the HTML code is saved.
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 */
function osf_ontology_contents($which_block) {
  global $base_url;

  if ($which_block == 1) {
    $menuItems = array();

    $icon = theme('image', array('path' => drupal_get_path("module", "osf_ontology") . '/imgs/cog.png', 'attributes' => array('style' => 'padding-right:5px;')));
    $menuItems[] = l($icon . t("Ontology"), 'osf/ontology', array('html' => TRUE));

    return implode('<br />', $menuItems);
  }
}

/** 
 * @brief Index all ontologies if a given directory, recursively.
 * 
 * @param[in] $dir Root directory where ontologies files can be found.
 * @param[in] $baseWsfNetwork the base URL of the OSF network to query.
 * 
 * @return Nothing
 * 
 * @author Frederick Giasson, Structured Dynamics LLC.
 */
function IndexOntologiesDirectory($dir, $baseWsfNetwork) {
  include_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'osf') . '/framework/WebServiceQuerier.php';

  if ($handler = opendir($dir)) {
    while (($sub = readdir($handler)) !== FALSE) {
      if ($sub != "." && $sub != ".." && $sub != "new.owl") {
        if (is_file($dir . "/" . $sub)) {

          $ontylogyFileContent = file_get_contents($dir . "/" . $sub);

          $wsq = new WebServiceQuerier($baseWsfNetwork . "ontology/create/", "post", "application/rdf+xml",
            "advancedIndexation=true&uri=" . urlencode("file://localhost" . $dir . $sub));

          if ($wsq->getStatus() != 200) {
            
            if(strpos($wsq->getStatusMessageDescription(), 'WS-ONTOLOGY-CREATE-302') === FALSE)
            {            
              drupal_set_message(t("Web service error: (status: ") . strip_tags($wsq->getStatus()) . ") "
                . strip_tags($wsq->getStatusMessage()) . " - " . strip_tags($wsq->getStatusMessageDescription()),
                "error");
            }
            else
            {
              drupal_set_message(t("@sub - already loaded; ignored", array('@sub' => $sub)));
            }
          }
          else {
            drupal_set_message(t("@sub reloaded", array('@sub' => $sub)));
          }

          unset($wsq);
        }
        elseif (is_dir($dir . "/" . $sub)) {
          IndexOntologiesDirectory($dir . "/" . $sub, $baseWsfNetwork);
        }
      }
    }
    closedir($handler);
  }
}

function osf_ontology_is_ontology_dataset($uri)
{
  $loadedOntologies = osf_get_loaded_ontologies();

  if(array_key_exists($uri, $loadedOntologies) === FALSE)
  {
    return(FALSE);
  }
  else
  {
    return(TRUE);
  }
}

/**
* This utility functions help developers to know if a specific URI is defined in the ontologies
* synchronized to this OSF for Drupal instance. If it is, then it tells the developer if the
* type of the thing referenced by this URI is:
* 
*  - an Object Property
*  - a Datatype Property
*  - an Annotation Property
*  - a Class
* 
* @param $uri URI for which you want its "type"
* 
* @return Return FALSE if the URI is not defined in the synchronized ontologies. Returns "class" if
*         the type of the URI is an owl:Class. Returns "objectproperty" if the type of the URI is a
*         owl:ObjectProperty. Returns "datatypeproperty" if the type of the URI if a owl:DatatypeProperty.
*         Returns "annotationproperty" if the type of the URI is a owl:AnnotationProperty.
* 
*/
function osf_ontology_get_ontology_uri_type($uri)
{
  $properties = variable_get('osf_entities_properties', array());

  if(isset($properties[$uri]))
  {
    $property = unserialize($properties[$uri]);
    
    if(array_search(Namespaces::$owl.'ObjectProperty', $property->getTypes()) !== FALSE)  
    {
      return('objectproperty');
    }
    
    if(array_search(Namespaces::$owl.'DatatypeProperty', $property->getTypes()) !== FALSE)  
    {
      return('datatypeproperty');
    }
    
    if(array_search(Namespaces::$owl.'AnnotationProperty', $property->getTypes()) !== FALSE)  
    {
      return('annotationproperty');
    }
  }
  else
  {
    $classes = variable_get('osf_entities_classes', array());
    
    if(isset($classes[$uri]))
    {
      return('class');
    }
    else
    {
      return(FALSE);
    }
  }
  
  return(FALSE);  
}

/**
* Get an array that represents the super classes hierarchy of a class.
* 
* @param mixed $class
*/
function osf_ontology_get_super_classes_hierarchy($class)
{
  $superClasses = array();
  
  $classEntity = entity_load('resource_type', array($class));
  $ontologyDataset = $classEntity[key($classEntity)]->dataset;
  $defaultEndpoint = osf_configure_get_endpoint_by_uri(osf_entities_get_network_from_dataset_uri($ontologyDataset));
  
  $superClasses = array();
  
  _osf_ontology_get_super_classes_hierarchy_recur($class, $superClasses, $defaultEndpoint, $ontologyDataset);
  
  return($superClasses);
}

function _osf_ontology_get_super_classes_hierarchy_recur($class, &$superClasses, $defaultEndpoint, $ontologyDataset)
{
  $getSuperClasses = new GetSuperClassesFunction();
  
  $getSuperClasses->directSuperClasses()
                  ->getClassesUris()
                  ->uri($class);  
  
  $ontologyRead = new OntologyReadQuery($defaultEndpoint->uri, $defaultEndpoint->app_id, $defaultEndpoint->api_key, osf_configure_get_first_user_uri());

  $ontologyRead->getSuperClasses($getSuperClasses)
               ->ontology($ontologyDataset)
               ->enableReasoner()
               ->send(new DrupalQuerierExtension());
  
  if($ontologyRead->isSuccessful())
  {
    $resultset = $ontologyRead->getResultset()->getResultset();
    
    if(!isset($resultset['unspecified']))
    {
      return;
    }
    
    foreach($resultset['unspecified'] as $superClassURI => $sp)
    {
      if($superClassUri != 'http://www.w3.org/2002/07/owl#Thing')
      {
        $superClasses[$superClassURI] = array();
        
        _osf_ontology_get_super_classes_hierarchy_recur($superClassURI, $superClasses[$superClassURI], $defaultEndpoint, $ontologyDataset);
      }
    }
  }
  else
  {
    return;
  }
}

//@}
