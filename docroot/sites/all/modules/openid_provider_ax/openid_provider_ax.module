<?php

define('OPENID_PROVIDER_AX', 'http://openid.net/srv/ax/1.0');

/**
 * Implements hook_xrds().
 * Return a XRDS for Attribute Exchange service discovery
 */
function openid_provider_ax_xrds($account = NULL) {
  module_load_include('inc', 'openid');

  $types = array(OPENID_PROVIDER_AX);
  if ($account) {
    $types[] = OPENID_NS_2_0 .'/signon';
  }
  else {
    $types[] = OPENID_NS_2_0 .'/server';
  }

  $data = array(
    'Type' => $types,
    'URI' => array(openid_provider_url('openid/provider')),
  );
  if (isset($account->uid)) {
    $data['LocalID'] = array(openid_provider_url(openid_provider_user_path($account->uid)));
  }

  $xrds['openid_provider_ax'] = array(
    'services' => array(
      array(
        'priority' => 5,
        'data' => $data,
      ),
    ),
  );

  return $xrds;
}

/**
 * Implements hook_openid_provider().
 */
function openid_provider_ax_openid_provider($op = 'response', $response = NULL) {
  $args = func_get_args();
  switch ($op) {
    case 'response':
      if (count($args) < 3) {
        return FALSE;
      }
      return openid_provider_ax_response_process($args[1], $args[2]);
      break;
    case 'update':
      module_load_include('inc', 'openid_provider', 'openid_provider');

      $uid = array_pop($args);

      //TODO: refactor into own function
      $results = db_select('openid_provider_ax', 'opa')
                ->fields('opa')
                ->condition('uid', $uid)
                ->execute()
                ->fetchAll();
      $relying_parties = array();
      foreach ($results as $result) {
        $relying_party = array();
        $relying_party['request'] = unserialize($result->request);
        $relying_party['response'] = unserialize($result->response);
        $relying_parties[] = $relying_party;
      }

      foreach ($relying_parties as $rp) {
        $update_url = $rp['request']['openid.ax.update_url'];
        // unset($rp['request']['openid.ax.update_url']); Can this line being deleted?
        $response = openid_provider_ax_response_process($rp['response'], $rp['request'], $uid);
        $response['openid.response_nonce'] = _openid_provider_nonce();
        $response['openid.return_to'] = $update_url;
        $response = array_merge($rp['response'], $response);

        //FIXME: Workaround till better solution is found
        if (isset($response['openid.sreg.nickname']) && isset($response['openid.ax.value.friendly'])) {
          $response['openid.sreg.nickname'] = $response['openid.ax.value.friendly'];
        }
        if (isset($response['openid.sreg.email']) && isset($response['openid.ax.value.email'])) {
          $response['openid.sreg.email'] = $response['openid.ax.value.email'];
        }

        if (!openid_provider_unsolicited_assertion($update_url, $response)) {
          // We got a 404 and need to remove the update_url
          // TODO: Implement some kind of threshold (e.g. 5 times 404, then remove)
          db_delete('openid_provider_ax')
            ->condition('update_url', $update_url)
            ->execute();
        }
      }
      break;
    case 'signed':
      $signed = array();
      foreach ($response as $key => $value) {
        if (strpos($key, 'openid.ax') === 0 || strpos($key, 'openid.ns.') === 0) {
          $signed[] = str_replace('openid.', '', $key);
        }
      }
      return $signed;
  }
}


/**
 * Function processes the openid request that came in and will return the pertinent information
 *
 * @param $response
 *      Keyed array holding the response that will be sent back
 * @param $request
 *      Keyed array holding the request that was received
 */
function openid_provider_ax_response_process($response = array(), $request = array(), $uid = FALSE) {
  if (!$uid) {
    global $user;
    $uid = $user->uid;
  }

  $processed = array();
  // OPENID Attribute Exchange was requested hence get the alias per
  // OPENID specification and then determine the type of request it was
  if (in_array(OPENID_PROVIDER_AX, $request)) {
    // Retrieve the Alias that they were utilizing
    $alias = openid_provider_ax_alias($request, FALSE);
    $alias_key = openid_provider_ax_alias($request, TRUE);
    // Type of openid ax request Fetch or Store
    $request_type = $request[sprintf('openid%smode', $alias)];
    // Retrieve an associative array of all the ax attributes in the request
    $attributes = openid_provider_ax_parse_request($request, $alias);
    switch ($request_type) {
      case 'fetch_request':
        $processed = array_merge($processed, module_invoke_all('openid_provider_map', 'load', 'ax', $attributes, $uid));
        $processed = array_merge($processed, array($alias_key => OPENID_PROVIDER_AX, sprintf('openid%smode', $alias) => 'fetch_response'));

        // Relying Party asks for updates.
        if (isset($request['openid.ax.update_url']) && valid_url($request['openid.ax.update_url'])) {
          // Verify realm with update_url
          $realm_verified = ($request['openid.realm'] == substr($request[sprintf('openid%supdate_url', $alias)], 0, strlen($request['openid.realm']))) ? TRUE : FALSE;

          if ($realm_verified) {
            $claimed_id = $request['openid.claimed_id'];
            $update_url = $request['openid.ax.update_url'];

            $processed = array_merge($processed, array($alias_key => OPENID_PROVIDER_AX, sprintf('openid%supdate_url', $alias) => $update_url));
            $update = array();
            if (db_query("SELECT COUNT(uid) FROM {openid_provider_ax} WHERE update_url = :update_url AND uid = :uid", array(':update_url' => $update_url, ':uid' => $uid))->fetchField()) {
              $update = array('update_url', 'uid');
            }
            $record = new stdClass();
            $record->uid = $uid;
            $record->claimed_id = $claimed_id;
            $record->request = serialize($request);
            $record->response = serialize($response);
            $record->update_url = $update_url;
            drupal_write_record('openid_provider_ax', $record, $update);
          }
        }
        break;
      case 'store_request':
        // Determine the realm (openid.trust_root in 1.x)
        $realm = (empty($request['openid.realm'])) ? $request['openid.trust_root'] : $request['openid.realm'];
        $rp = _openid_provider_rp_load($user->uid, $realm);
        if ($rp->auto_release) {
          $response = openid_provider_ax_store($request, $user);
        }
        else {
          // Wait for openid_provider_form_submit() to execute
          $_SESSION['openid_provider_ax']['request'] = $request;
        }
        break;
    }
  }

  return $processed;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function openid_provider_ax_form_openid_provider_form_alter(&$form, &$form_state) {
  global $user;
  if (!isset($_SESSION['openid_provider_ax'])) {
    return;
  }
  drupal_set_title(t('OpenID store'));
  $request = $form_state['storage']['request'] = $_SESSION['openid_provider_ax']['request'];
  unset($_SESSION['openid_provider_ax']);

  $default_submits = $form['#submit'];
  $form['#submit'] = array('openid_provider_ax_openid_provider_form_submit');
  foreach ($default_submits as $submit) {
    $form['#submit'][] = $submit;
  }
  $always_submits = $form['submit_always']['#submit'];
  $form['submit_always']['#submit'] = array('openid_provider_ax_openid_provider_form_submit');
  foreach ($always_submits as $submit) {
    $form['submit_always']['#submit'][] = $submit;
  }
  //TODO: Display the data that will be stored.
  $form['intro']['#value'] = '<p>' . t('The Relying Party @relying asks for permission to store data into your profile, would you like to continue?',
                                       array('@relying' => $form_state['storage']['realm'])) . '</p>';
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function openid_provider_ax_openid_provider_form_submit($form, &$form_state) {
  global $user;
  if ($form_state['values']['op'] == t('Yes; just this once') ||
      $form_state['values']['op'] == t('Yes; always')) {
    $request = $form_state['storage']['request'];
    return openid_provider_ax_store($request, $user);
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function openid_provider_ax_store($request, $account) {
  // Update the profile data
  //TODO: Handle result success / failure
  module_invoke_all('openid_provider_map', 'store', 'ax', $request, $account->uid);
  $response['openid.ns.ax'] = 'http://openid.net/srv/ax/1.0';
  $response['openid.ax.mode'] = 'store_response_success';
  return $response;
}

/**
 * Function takes in the request and retrieves the alias per spec being utilized.
 *
 * @param $request
 *      Array holding the request that was received
 * @param $key
 *      Boolean, if TRUE will return the key else just the alias
 */
function openid_provider_ax_alias($request, $key = FALSE) {
  $alias_key = NULL;
  // Retrieve the Key in the request that the user is utilizing
  foreach ($request as $k => $v) {
    if ($v == OPENID_PROVIDER_AX) {
      $alias_key = $k;
      break;
    }
  }
  // Return the full key to the calling function if asked for
  if ($key === TRUE) {
    return $alias_key;
  }
  // Return just the alias to the calling function
  return strrchr($alias_key, '.') . '.';
}

/**
 * Separate the AX requests from the rest of $request
 *
 * @param $request
 *      Associative array of requests send to the OP
 * @param $alias
 *      Alias being utilized by this openid ax request
 *
 * @return
 *      Associative array with only requests containing openid.ns.axalias
 */
function openid_provider_ax_parse_request($request, $alias = NULL) {

  $attributes = array();
  $alias_key = openid_provider_ax_alias($request, TRUE);
  $attributes[$alias_key] = $request[$alias_key];

  if (is_null($alias)) {
    // Try and retrieve the alias if none was passed to this function
    // However this should have been done previously and hence it should
    // Never be null in this case since but this is just an added check
    $alias = openid_provider_ax_alias($request, FALSE);
  }

  // Foreach of the Attribute exchange keys in the request put them
  // Into an array making sure the value is decoded because or url encoding
  foreach ($request as $key => $val) {
    if (strpos($key, $alias)) {
      $attributes[$key] = urldecode($val);
    }
  }

  return $attributes;
}

