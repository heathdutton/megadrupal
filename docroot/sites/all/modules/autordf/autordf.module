<?php

require_once drupal_get_path('module', 'autordf'). '/autordf.rdf.inc';


define('AUTORDF_TAG_ALL', 0);

define('AUTORDF_TAG_MAX', 1);

define('AUTORDF_TAG_MIN', 2);

// C: Capitalization
/**
 * Flag for a word with no character in Capitals e.g "content"
 */
define('AUTORDF_NOCAP', 0);

/**
 * Flag for a word with first character in capitals e.g "Drupal"
 */
define('AUTORDF_FIRSTCAP', 1);

/**
 * Flag for a word with all characters in capitals e.g PHP
 */
define('AUTORDF_ALLCAP', 2);

/**
 * Mixed case
 */
define('AUTORDF_MIXED', 3);

/**
 * All Digits
 */
define('AUTORDF_NUMERIC', 4);

/**
 * Other
 */
define('AUTORDF_OTHER', 5);


/**
 * Implementation of hook_admin_paths()
 */
function autordf_admin_paths() {
	return array(
    'node/*/autordf' => TRUE,
  );
}

/**
 * Implementation of hook_theme()
 */
function autordf_theme() {
	return array(
    'autordf_topics' => array(
      'variables' => array('tags' => NULL),
    ),
  );
}
 
/**
 * Implementation of hook_menu()
 */
function autordf_menu() {
	$items['admin/config/autordf'] = array(
    'title' => 'Autordf',
    'description' => 'Settings for Autordf module',
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('administer autordf'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
    'position' => 'right',
  );

  $items['admin/config/autordf/settings'] = array(
    'title' => 'Autordf Settings',
    'description' => 'Configure Autordf Module',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('autordf_admin_settings'),
    'access arguments' => array('administer autordf'),
    'file' => 'autordf.admin.inc',
    'weight' => -10,
  );
  
    $items['admin/config/autordf/stopwords'] = array(
    'title' => 'Autordf stopwords settings',
    'description' => 'Configure settings for generation of stopwords/ignore list',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('autordf_admin_stopword_setting'),
    'access arguments' => array('administer autordf'),
    'file' => 'autordf.admin.inc',
    'weight' => -9,
  );
  
  $items['admin/config/autordf/vocabulary'] = array(
    'title' => 'Autordf Configure Vocabulary Settings',
    'description' => 'Configure different vocabularies associated with content',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('autordf_admin_vocab'),
    'access arguments' => array('administer autordf'),
    'file' => 'autordf.admin.inc',
    'weight' => -8,
  );
  
  $items['admin/config/autordf/rebuild'] = array(
    'title' => 'Rebuild Tagcloud',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('autordf_configure_rebuild_confirm'),
    'access arguments' => array('administer autordf'),
    'type' => MENU_CALLBACK,
    'file' => 'autordf.admin.inc',
  );
  
  $items['node/%node/autordf'] = array(
    'title' => 'Autordf',
    'page callback' => 'autordf_node_keywords',
    'page arguments' => array(1),
    'access callback' => 'autordf_access',
    'access arguments' => array(1),
    'weight' => 3,
    'theme callback' => '_node_custom_theme',
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'type' => MENU_LOCAL_TASK,
    'file' => 'autordf.admin.inc',
  );
  
  $items['autordf/autocomplete'] = array(
    'title' => 'Autocomplete taxonomy by Vocabulary',
    'page callback' => 'autordf_vocabulary_autocomplete',
    'access arguments' => array('access autordf tags'),
    'type' => MENU_CALLBACK,
  );
  
  $items['autordf'] = array(
    'title' => 'Automatic Tag Generation',
    'page callback' => 'autordf_page',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  $items['autordf/ajax/tags'] = array(
    'title' => 'Tag Suggestion',
    'page callback' => 'autordf_suggest_tags_ajax',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  
  return $items;
}

/**
 * Implements hook_help().
 */
function autordf_help($path, $arg) {
  switch ($path) {
    case 'admin/help#autordf':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Automatic tag generation from node content. This module will analyze the node content and will suggest possible tags.');
      return $output;
  }
}

/**
 * Implementation of hook_permission()
 */
function autordf_permission() {
	return array(
    'access autordf tags' =>  array(
    'title' => t('Access autordf tags'),
    ),  
    'administer autordf' =>  array(
    'title' => t('Administer autordf'),
    'restrict access' => TRUE,
    ),
  );
}

function autordf_access($node) {
  global $user;
	if ((user_access('access autordf tags') && $node->uid == $user->uid) || user_access('administer autordf')) {
	 return TRUE;	
	}
  return FALSE; 
}

/**
 * Find Taxonomy Fields 'Term reference' and language associated with a Bundle 
 * 
 * @param string $bundle
 *   The Bundle name
 * @param string $language
 *   The default language  
 */
function autordf_tax_field($bundle, $language = LANGUAGE_NONE) {
  $entity_type = 'node';
  $instances = field_info_instances($entity_type, $bundle);
  
  foreach($instances as $name => $instance) {
    if ($instance['widget']['module'] == 'taxonomy')
      $taxonomy_instances[$name] = $instance;
  }
  
  $vid_tags = variable_get('autordf_vocabulary', 1);
  $validate = FALSE;
  foreach($taxonomy_instances as $field_name => $instance) {
    $field = field_info_field($field_name);
    foreach ($field['settings']['allowed_values'] as $settings) {
      // check if the vocabulary id matches 
      if (isset($settings['vid']) && $settings['vid'] == $vid_tags) {
        $validate = TRUE;
        break 2;
      }
    }
  }
  
  $available_languages = field_available_languages($entity_type, $field);
  $languages = _field_language_suggestion($available_languages, $language, $field_name);
  $langcode = array_pop($languages);
  
  if (!$validate) {
  	$field_name = NULL;
  }
  return array($field_name, $langcode);
	
}

/**
 * Tag a node
 */
function autordf_tag($node, $op) {
  $fields = array();
  list($field_name, $langcode) = autordf_tax_field($node->type, $node->language);
  
  // No field instance found, return
  if (!isset($field_name)) {
  	return;
  }
  
  $body = '';
  foreach ($node->body[$node->language] as $info) { 
    $body .= $info['value'];
  }
  
  // Make text for parsing
  $text = '<title>' . check_plain($node->title) . '</title> ' . $body;
  $categorize = new AutordfTag($text, $node->type, $node->language);
  $tokens = $categorize->categorize();
  $vocab = $categorize->getVocabularies();
  
  // Separate out terms of vocabulary tags
  $field_tags = $vocab['tags'];
  unset($vocab['tags']);
  
  $list_vocab = variable_get('autordf_vocabulary_names', FALSE);
  foreach($vocab as $vocabulary => $terms) {
    $vid = $list_vocab[$vocabulary];
    if (!$terms) {
    	continue;
    }
    foreach ($terms as $key => $value) {
      // Add the term to vocabulary, if already exist return the term object
      $term = autordf_save_term($vid, $key);
      if(!($autordf_term = autordf_term_autordf_exist($term->tid))) {
        $autordf_term = new stdClass;
        $autordf_term->tdid = $term->tid;
        $autordf_term->name = $term->name;
        $autordf_term->vid = $term->vid;
        autordf_save_autordf_term($autordf_term);
      }
      autordf_save_autordf_term_node($autordf_term, $node->nid);
      // @todo: Either add information to taxonomy_index OR alter taxonomy_index query on taxonomy_select_nodes()
      // to add nodes on taxonomy/term/% pages for these vocabularies without field "Term reference"
    }    
  }
  
  // We dont need the scores now
  $new_terms = array_keys($field_tags);
  $vocabulary_tags_vid = variable_get('autordf_vocabulary', 1);
  $values = array();
  foreach ($new_terms as $typed_term) {
    $term = autordf_save_term($vocabulary_tags_vid, $typed_term);
    $values[] = $term->tid;
  }
  
  // Existing terms
  if (isset($node->{$field_name}[$langcode])) {
    foreach($node->{$field_name}[$langcode] as $tid) {
      $values[] = $tid['tid'];
    }
  }
  
  $value = options_array_transpose(array('tid' => array_unique($values)));
  
  // Attach terms to field
  $node->{$field_name}[$langcode] = $value;
  
  switch ($op) {
  	case 'batch':
      field_attach_update('node', $node);
      break;
    case 'presave':
      break;
  }

}

/**
 * Implementation of hook_node_presave()
 */
function autordf_node_presave($node) {
  if ($node->autordf['enabled']) {
    // If its an update operation
    if ($node->nid) {
      autordf_delete_autordf_term_node($node->nid);
    }
    autordf_tag($node, 'presave');  
  }
}

/**
 * Implementation of hook_node_delete()
 */
function autordf_node_delete($node) {
	autordf_delete_autordf_term_node($node->nid);
}


/**
 * Check for a term is the given Vocabulary. If term exist it return the term object
 * Otherwise it will add the term to the vocabulary
 */
function autordf_save_term($vid, $term_name) {
  // See if the term exists in the chosen vocabulary and return the tid;
  // otherwise, create a new term.
  if ($possibilities = taxonomy_term_load_multiple(array(), array('name' => trim($term_name), 'vid' => array($vid)))) {
    $term = array_pop($possibilities);
  }
  else {
    $vocabulary = taxonomy_vocabulary_load($vid);
    $term = (object) array(
      'vid' => $vid,
      'name' => trim($term_name),
      'vocabulary_machine_name' => $vocabulary->machine_name,
    );
    taxonomy_term_save($term);
  }  
  return $term;
}

/**
 * Save the term to {autordf_term} table
 */
function autordf_save_autordf_term($term) {
	if(empty($term->tid)) {
    drupal_write_record('autordf_term', $term);
  }
  else {
    drupal_write_record('autordf_term', $term, 'tid');
  }
}

/**
 * Helper function return the object from {autordf_term} table
 * 
 * @param $term
 *   Term id or term name
 * @param $vid
 *   Vocabulary id
 *  
 */
function autordf_term_autordf_exist($term, $vid = NULL) {
  if (is_numeric($term)) {
	  return db_query('SELECT * FROM autordf_term t WHERE t.tdid = :tid', array(':tid' => $term))
          ->fetch();
  }
  else {
  	$local_term = db_query('SELECT * FROM autordf_term t WHERE t.name = :name AND t.vid = :vid', array(':name' => $term, ':vid' => $vid))
          ->fetch();
    if ($local_term) {
    	return $local_term;
    }
  }
  return FALSE;
}

/**
 * Associate autordf term to a node
 */
function autordf_save_autordf_term_node($autordf_term, $nid) {
  $r = new stdClass;
  $r->tid = $autordf_term->tid;
  $r->nid = $nid;
  $exist = db_query('SELECT COUNT(*) FROM autordf_term_node t WHERE t.tid = :tid and t.nid = :nid', array(':tid' => $r->tid, ':nid' => $r->nid))->fetchField();
	if(!$exist) {
    drupal_write_record('autordf_term_node', $r);
  }
  else {
  	drupal_write_record('autordf_term_node', $r, array('nid', 'tid'));
  }
}

/**
 * Removes all autordf terms from a node 
 */
function autordf_delete_autordf_term_node($nid) {
	db_delete('autordf_term_node')
    ->condition('nid', $nid)
    ->execute();
}

/**
 * Return all terms associated with a node
 */
function autordf_get_node_keywords($nid) {
	$query = db_select('autordf_term', 't');
  $query->fields('t');
  $query->innerJoin('autordf_term_node', 'n', 't.tid = n.tid');
  $query->condition('n.nid', $nid);
  return $query->execute()->fetchAll();
}

/**
 * Autocomplete
 */
function autordf_vocabulary_autocomplete($nid, $typed_tags = '') {
  //  @TODO: Only filter out words that are already in node   
  // The user enters a comma-separated list of tags. We only autocomplete the last tag.
  $typed_tags = drupal_explode_tags($typed_tags);
  $tag_last = drupal_strtolower(array_pop($typed_tags));
  
  // Fetch formated content
  if ($cache = cache_get('autordf_fc_'. $nid, 'cache_page')) {
    $content = $cache->data;
  }
  else {
    $node = node_load($nid);
    $language = $node->language;
    $available_languages = field_available_languages('node', 'body');
    $languages = _field_language_suggestion($available_languages, $language, 'body');
    $langcode = array_pop($languages);
    $content = '';
    
    foreach($node->body[$langcode] as $body) {
      $content .= $body['value'] . ' ';
    }
    
    $content = strip_tags($content);
    $content = Autordf::formatContent($content);
    // $tokens = AutordfTokenizer::stringTokenizer($content);
        
    // Cache data for 5 minutes
    cache_set("autordf_fc_" . $nid, $content, 'cache_page', REQUEST_TIME + 300);
  }

  preg_match_all("/[^\s]*?" . $tag_last . "[^\s]+/i", $content, $matches);

  $prefix = count($typed_tags) ? implode(', ', $typed_tags) . ', ' : '';
  $term_matches = array();
  
  foreach ($matches[0] as $name) {
    if (drupal_strlen($name) < 3) {
    	continue;
    }
    
    $n = $name;
    // Term names containing commas or quotes must be wrapped in quotes.
    if (strpos($name, ',') !== FALSE || strpos($name, '"') !== FALSE) {
      $n = '"' . str_replace('"', '""', $name) . '"';
    }
    else {
      $term_matches[$prefix . $n] = check_plain($name);
    }
  }

  drupal_json_output($term_matches);
    
}

/**
 * Takes a CamelCase word and adds spaces to make it Camel Case
 *
 * @return an formated string
 */
function autordf_make_readable($name) {
	return preg_replace('/(.*?[a-z]{1})([A-Z]{1}.*?)/', '${1} ${2}', $name);
}

function autordf_make_machinename($v) {
	return preg_replace('/[\s-]+/', '_', strtolower($v));
}

/**
 * Creates a Vocabulary with Given name
 */
function autordf_create_entity_vocabulary($vname) {
  $vocabulary = new stdClass;
  $vocabulary->name = $vname;
  $vocabulary->machine_name = autordf_make_machinename($vname);
  $vocabulary->module = 'autordf';
  $vocabulary->description = t('Autordf Vocabulary: @name', array('@name' => $vname));
   
  $status = taxonomy_vocabulary_save($vocabulary);
  return $vocabulary->vid;
    
}

/**
 * Implementation of hook_form_alter()
 */
function autordf_form_alter(&$form, &$form_state, $form_id) {
  $bundles = variable_get('autordf_node_types', array('article'));
	if (isset($form['type']) && $form['type']['#value'] . '_node_form' == $form_id 
    && in_array($form['type']['#value'], $bundles, TRUE)) {
    
    $form['autordf'] = array(
      '#type' => 'fieldset',
      '#title' => t('Autordf settings'),
      '#access' => user_access('access autordf tags'),
      '#collapsible' => TRUE,
      '#group' => 'additional_settings',
      '#attached' => array(
//        'js' => array(drupal_get_path('module', 'autordf').'/autordf.js'),
      ),  
      '#tree' => TRUE,
      '#weight' => -2, 
      '#attributes' => array('class' => array('autordf-settings')),
    );  
    
    $form['autordf']['enabled'] = array(
      '#type' => 'checkbox',
      '#title' => t('Generate tags from all vocabularies on node save'),
      '#default_value' => (empty($form['nid']['#value'])),
    );
    
    // Suggest tags using ajax
    list($field_name, $langcode) = autordf_tax_field($form['type']['#value']);
    $form[$field_name]['#prefix'] = '<div id="autordf_suggest_tags">';
    $form[$field_name]['#suffix'] = '</div>';
    
    $form['autordf']['tag'] = array(
      '#type' => 'submit',
      '#value' => t("Suggest Tags"),
      '#ajax' => array(
        'callback' => 'autordf_suggest_tags_ajax',
        'wrapper' => 'autordf_suggest_tags',
      ),
    );
  }
}

function autordf_suggest_tags_ajax($form, $form_state) {

  list($field_name, $langcode) = autordf_tax_field($form['type']['#value']);
  
  $values = $form_state['values'];
  $title = $values['title'];
  $body = '';
  foreach ($values['body'][$values['language']] as $info) {
    $body .= $info['value'];
  }
  
  $content = '<title>'. check_plain($title) . '</title> '.$body;

  $autordf = new AutordfTag($content);
  $autordf->categorize(TRUE);
  $tags = $autordf->getVocabularies('tags');
  $tags = array_keys($tags);
  $tags = implode(', ', $tags);
  
  $form[$field_name][$langcode]['#value'] = $tags;  
  return $form[$field_name];

}


function autordf_get_all_entities() {
	return array(
    'Anniversary',
    'Acronyms',
    'City',
    'Company',
    'Country',
    'Currency',
    'EmailAddress',
    'Event',
    'Location',
    'Movie',
    'OperatingSystem',
    'Person',
    'PhoneNumber',
    'Position',
    'Product',
    'Region',
    'URL',
  );
}

/**
 * Sample test page
 */
function autordf_page() {
  $form = "<div id='autordf-tags'></div>";
  $test_form = drupal_get_form('autordf_test_form');
  $form .= drupal_render($test_form);
  return $form;	
}

function autordf_test_form($form, $form_state) {

  $form = array();
  
  $form['content'] = array(
    '#type' => 'textarea',
    '#rows' => '10',
    '#title' => 'Text',
    '#attached' => array(
      'js' => array('misc/tableheader.js'),
    )
  );
	$form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Auto Tag'),
    '#ajax' => array(
      'callback' => 'autordf_tag_ajax',
      'wrapper' => 'autordf-tags',
      'method' => 'html',
      'effect' => 'fade',
      'progress' => array(
        'type' => 'bar',
        'message' => t('Tagging...')
      ),
    ), 
  );
  
  $form['#attached']['css'][] = drupal_get_path('module', 'autordf'). '/autordf.css';
  
  return $form;
}

function autordf_tag_ajax($form, $form_state) {
	$content = $form_state['values']['content'];
  $autordf = new AutordfTag($content, 'test');
  $autordf->categorize();
  $vocab = $autordf->getVocabularies();
  $header = array(
    t('Vocabulary'),
    t('Tags'),
  );
  $rows = array();
  foreach($vocab as $name => $tags) {
  	if ($tags) {
      $rows[] = array('data' => array($name, implode(', ', array_keys($tags))));
    }
  }
  
  return theme('table', array('header' => $header, 'rows' => $rows, 'empty' => 'No Match Found'));
}

/**
 * Implementation of hook_cron
 */
function autordf_cron() {
  // The IDF value in {search_total} will not give accurate results for stopwords elimination
  // Let the search.module find dirty words first   
  drupal_register_shutdown_function('autordf_update_idf');
}

/**
 * This is called on shutdown the autordf_total count will always be upto date even on cron failure 
 */
function autordf_update_idf() {
  foreach (search_dirty() as $word => $dummy) {
    // Get total count
    $total = db_query("SELECT COUNT(score) FROM {search_index} WHERE word = :word", array(':word' => $word), array('target' => 'slave'))->fetchField();
    // Numeric values not allowed
    if (autordf_is_string($word)) {
      db_merge('autordf_total')
        ->key(array('word' => $word))
        ->fields(array('count' => $total))
        ->execute();
    }
  }
  autordf_generate_stopwords();
}

/**
 * Find out new stopwords and remove those who are below threshold
 */
function autordf_generate_stopwords() {
  $threshold = variable_get('autordf_stopword_threshold', 0.3);
  $total_document = db_query("SELECT COUNT(nid) FROM {node}")->fetchField();
  
  // Do not auto generate stopwords for sites having less than 5 nodes
  if ($total_document < 5) {
  	return;
  }
  
  $threshold *= $total_document;
  
  $query = db_select('autordf_total', 'a');
  $query->fields('a', array('word'));
  $query->condition('count', $threshold, '>');
  $stopwords = $query->execute()->fetchCol();
  
  variable_set('autordf_ignorelist_generated', $stopwords);

  // Clear cache
  autordf_ignorelist_all(TRUE);
  return $stopwords;
}

function autordf_is_string($var) {
	if(!is_numeric($var)){
		return TRUE;
	}
  else {
  	return FALSE;
  } 
}

/**
 * Rebuild the autordf_total table
 */
function autordf_stopword_rebuild() {
  drupal_set_time_limit(240);

  // Truncate autordf table
  db_truncate('autordf_total')->execute();
  
  $threshold = variable_get('autordf_stopword_threshold', 0.3);
  $total_document = db_query("SELECT COUNT(nid) FROM {node}")->fetchField();
  $threshold *= $total_document;
   
   
	$words = db_query("SELECT word FROM {search_total}")->fetchCol();
  $words = array_filter($words, 'autordf_is_string');
  foreach ($words as $word) {
  	$total = db_query("SELECT COUNT(score) FROM {search_index} WHERE word = :word", array(':word' => $word), array('target' => 'slave'))->fetchField();
    db_merge('autordf_total')
      ->key(array('word' => $word))
      ->fields(array('count' => $total))
      ->execute();
  } 
  autordf_generate_stopwords();
}


function _autordf_import_stopwords_list() {
  include_once DRUPAL_ROOT . '/includes/iso.inc';
  
	$dir = drupal_get_path('module', 'autordf') .'/stopwords/';
  
  $languages = _locale_get_predefined_list();
  $languages['pt'] = array('Portuguese', 'PortuguÃªs');
  
  if (is_dir($dir)) {
    if ($dh = opendir($dir)) {
      while (($file = readdir($dh)) !== FALSE) {
        switch (filetype($dir . $file)) {
          case 'file':
           if (substr($file, 0, 9) == 'stopwords') {
             $pieces = explode('_', substr($file, 0, strlen($file) - 4));
             $country_id = $pieces[1]; 
             $stopwords_lang[$country_id] = $languages[$country_id][0]. (isset($languages[$country_id][1]) ? ' ' . t('(@language)', array('@language' => $languages[$country_id][1])) : '');
           }
           break;
        }
      }
      closedir($dh);
    }
  }
  return $stopwords_lang;
}

/**
 * Implementation of hook_autordf_stopwords
 */
function autordf_autordf_stopwords($op) {
	switch ($op) {
		case 'list':
      return _autordf_import_stopwords_list();
      
    case 'prepare':
      $languages = variable_get('autordf_stopwords_list', array('en'));
      $return = array();
      foreach ($languages as $language) {
        if ($language) {
      	  $return += _autordf_stopword_import($language);
        }
      }
      return $return;
	}
  return;
}

function _autordf_stopword_import($lang_id) {
	require_once(drupal_get_path('module', 'autordf') ."/stopwords/stopwords_$lang_id.inc");
  
  $func = 'autordf_stopwords_'.$lang_id;
  if (function_exists($func)) {
  	return $func();
  }
}

/**
 * Invoke hook_autordf_stopwords to add to the list of stopwords
 * 
 * @param $op
 *   - list: Fetches a list of available languages
 *   - process: List of stopwords
 */
function autordf_stopwords($op) {
  $v = module_invoke_all('autordf_stopwords', $op);
  
  if ($op == 'prepare') {
  	return $v;
  }
  
  // if operation is list module_invoke_all might return nested arrays if
  // several modules return the same languages list
  // We will make the list flat and make sure it has strings and not arrays
  foreach ($v as $langcode => $language) {
  	if (is_array($language)) {
  		if (count(array_unique($language)) == 1) {
  			$v[$langcode] = $language[0];
  		}
      else {
        // Different names for same language code
      	$v[$langcode] = implode(',', $language);
      }
  	}
  }
  
  return $v;
}

function autordf_ignorelist_all($reset = FALSE) {
  if ($reset) {
    cache_clear_all('autordf_stopwords', 'cache');
    return;  
  }

  $ignore_list = array();
  if ($cache = cache_get('autordf_stopwords')) {
  	$ignore_list = $cache->data;
  }
  else {
    // Ignore list from imported list
    $stopwords = autordf_stopwords('prepare');
    foreach($stopwords as $langid => $list) {
    	$ignore_list = array_merge($ignore_list, $list);
    } 
    // User added list
    $user_ignore_list = array_map('trim', explode(',', variable_get('autordf_ignorelist_default', array())));
  
    // Ignore list generated from cron
    $cron_ignore_list = variable_get('autordf_ignorelist_generated', array());
  
    $ignore_list = array_merge($ignore_list, $user_ignore_list, $cron_ignore_list);
    
    $ignore_list = array_unique($ignore_list);
    cache_set("autordf_stopwords", $ignore_list);
  }
  return $ignore_list;      
}

/**
 * Implementation of hook_node_operations()
 */
function autordf_node_operations() {
	$operations = array(
    'autordf_tag' => array(
      'label' => t('Tag selected content (Autordf)'),
      'callback' => 'autordf_tag_nodes',
      'callback arguments' => NULL
    ), 
  );
  
  return $operations;
}

function autordf_tag_nodes($nids) {
  if (count($nids) > 5) {
   
	 $batch = array(
      'title' => t('Tagging Nodes'),
      'operations' => array(
        array('_autordf_batch_tag_nodes_process', array($nids)),
      ),
      'finished' => '_autordf_batch_tag_nodes_finished',
      'title' => t('Tagging'),
      'error message' => t('An error was encountered while tagging'),
    );
    batch_set($batch);
  }
  else {
    drupal_set_time_limit(240);
    $bundles = variable_get('autordf_node_types', array('article'));
    $nodes = node_load_multiple($nids, array('type' => $bundles));
  	foreach($nids as $nid) {
  		autordf_tag($nodes[$nid], 'update');
  	}
  }
}

function _autordf_batch_tag_nodes_process($nids, &$context) {
	if(!isset($context['sandbox']['progress'])) {
		$context['sandbox']['progress'] = 0;
    $context['sandbox']['max'] = count($nids);
    $context['sandbox']['nodes'] = $nids;
	}
  
  $bundles = variable_get('autordf_node_types', array('article'));
    
  $count = min(2, count($context['sandbox']['nodes']));
  for($i = 0; $i < $count; $i++) {
  	$nid = array_shift($context['sandbox']['nodes']);

    $node = node_load($nid);
    if (!in_array($node->type, $bundles, TRUE)) {
    	continue;
    }
    autordf_tag($node, 'batch');
    
    $context['results'][] = l($node->title, 'node/'.$node->nid);
    
    // updating progress bar
    $context['sandbox']['progress']++;
  }
  
  // Update batch engine
  if ($context['sandbox']['progress'] != $context['sandbox']['max']) {
  	$context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
}

function _autordf_batch_tag_nodes_finished($success, $results, $operations) {
	if ($success) {
		drupal_set_message(t('The selected nodes has been successfully tagged'));
	}
  else {
  	drupal_set_message(t('An error has occured while tagging. Following nodes has been successfully tagged'));
    $message .= theme('item_list',array('items' => $results));
    drupal_set_message($message);
  }
}

/**
 * Not needed anymore, added country.lst
 */
function autordf_countries() {
	$countries = 'Afghanistan, Albania, Algeria, American Samoa,' .
    ' Andorra, Angola, Anguilla, Antarctica, Antigua and Barbuda, Arctic Ocean,' .
    ' Argentina, Armenia, Aruba, Ashmore and Cartier Islands, Australia,' .
    ' Austria, Azerbaijan, Bahrain, Baker Island, Bangladesh, Barbados, Bassas' .
    ' da India, Belarus, Belize, Benin, Bermuda, Bhutan, Bolivia, Bosnia and' .
    ' Herzegovina, Botswana, Bouvet Island, Brazil, British Virgin Islands,' .
    ' Brunei, Bulgaria, Burkina Faso, Burma, Burundi, Cambodia, Cameroon,' .
    ' Canada, Cape Verde Cayman Islands, Central African Republic, Chad, Chile,' .
    ' China, Christmas Island, Clipperton Island, Cocos (Keeling) Islands,' .
    ' Colombia, Comoros, Congo, Cook Islands, Coral Sea Islands, Costa Rica,' .
    ' Croatia, Cuba, Cyprus, Czech Republic, Denmark, Djibouti, Dominica,' .
    ' Dominican Republic, Ecuador, Eire,Egypt, El Salvador, Equatorial Guinea,' .
    ' England, Eritrea, Estonia, Ethiopia, Europa Island, Falkland Islands,' .
    ' Islas Malvinas, Faroe Islands, Fiji, Finland, France, French Guiana,' .
    ' French Polynesia, French Southern and Antarctic Lands, Gabon, Gaza Strip,' .
    ' Georgia, Germany, Ghana, Gibraltar, Glorioso Islands, Greece, Greenland,' .
    ' Grenada, Guadeloupe, Guam, Guatemala, Guernsey, Guinea, Guinea-Bissau,' .
    ' Guyana, Haiti, Heard Island and McDonald Islands, Holy See (Vatican City),' .
    ' Honduras, Hong Kong, Howland Island, Hungary, Iceland, India, Indonesia,' .
    ' Iran, Iraq, Ireland, Israel, Italy, Ivory Coast, Jamaica, Jan Mayen,' .
    ' Japan, Jarvis Island, Jersey, Johnston Atoll, Jordan, Juan de Nova Island,' .
    ' Kazakstan, Kenya, Kingman Reef, Kiribati, Korea, Kuwait, Kyrgyzstan, Laos,' .
    ' Latvia, Lebanon, Lesotho, Liberia, Libya, Liechtenstein, Lithuania,' .
    ' Luxembourg, Macau, Macedonia The Former Yugoslav Republic of, Madagascar,' .
    ' Malawi, Malaysia, Maldives, Mali, Malta, Man Isle of, Marshall Islands,' .
    ' Martinique, Mauritania, Mauritius, Mayotte, Mexico, Micronesia Federated' .
    ' States of, Midway Islands, Moldova, Monaco, Mongolia, Montenegro,' .
    ' Montserrat, Morocco, Mozambique, Namibia, Nauru, Navassa Island, Nepal,' .
    ' Netherlands, Netherlands Antilles, New Caledonia, New Zealand,' .
    ' Nicaragua, Nigeria, Niue, Norfolk Island, Northern Ireland, Northern' .
    ' Mariana Islands, Norway, Oman, Pakistan, Palau, Palmyra Atoll, Panama,' .
    ' Papua New Guinea, Paracel Islands, Paraguay, Peru, Philippines, Pitcairn' .
    ' Islands, Poland, Portugal, Puerto Rico, Qatar, Reunion, Romania, Russia,' .
    ' Rwanda, Saint Helena, Saint Kitts and Nevis, Saint Lucia, Saint Pierre' .
    ' and Miquelon, Saint Vincent and the Grenadines, San Marino, Sao Tome and' .
    ' Principe, Saudi Arabia, Scotland, Senegal, Serbia, Seychelles, Sierra' .
    ' Leone, Singapore, Slovakia, Slovenia, Solomon Islands, Somalia, South' .
    ' Africa, South Georgia and the South Sandwich Islands, Spain, Spratly' .
    ' Islands, Sri Lanka, Sudan, Svalbard, Swaziland, Sweden, Switzerland,' .
    ' Syria, Taiwan, Tajikistan, Tanzania, Thailand, The Bahamas, The Gambia,' .
    ' Togo, Tokelau, Tonga, Trinidad and Tobago, Tromelin Island, Tunisia,' .
    ' Turkey, Turkmenistan, Turks and Caicos Islands, Tuvalu, Uganda, Ukraine,' .
    ' United Arab Emirates, UAE, United Kingdom, UK, United States of America,' .
    ' USA, Uruguay, Uzbekistan, Vanuatu, Venezuela, Vietnam, Virgin Islands,' .
    ' Wake Island, Wales, Wallis and Futuna, West Bank, Western Sahara, Western' .
    ' Samoa, Yemen, Zaire, Zambia, Zimbabwe, Europe, Western Europe, North' .
    ' America, South America, Asia, South East Asia, Central Asia, The Caucasus,' .
    ' Middle East, Far East, Scandinavia, Africa, North Africa, North Pole,' .
    ' South Pole, Central America, Caribbean';
  return $countries;
}