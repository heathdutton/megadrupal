<?php

/**
 * @file
 * osCaddie Alfresco Model module provides the mapping of Content-Types in Drupal
 * and Content Model in Alfresco and vice-versa.
 */

define('OSCADDIE_ALFRESCO_MODEL_MAP_DISABLED', 0);
define('OSCADDIE_ALFRESCO_MODEL_MAP_ENABLED', 1);
define('OSCADDIE_ALFRESCO_MODEL_MAP_ALTERED', 2);

define('OSCADDIE_ALFRESCO_MODEL_ACCESS_HIDDEN', '0');
define('OSCADDIE_ALFRESCO_MODEL_ACCESS_READ_ONLY', '1');
define('OSCADDIE_ALFRESCO_MODEL_ACCESS_FULL', '2');

/**
 * Sync model definition
 * 0: Changes made in Drupal content is not pushed to Alfresco.
 *    Content changes in Alfresco will be pushed to Drupal.
 * 1: Changes made in Drupal content will be pushed to Alfresco.
 *    Content changes in Alfresco will not be pushed to Drupal.
 * 2: Changes made in Drupal content will be updated in Alfresco, and vice-versa.
 */
define('OSCADDIE_ALFRESCO_MODEL_SYNC_READ', '0');
define('OSCADDIE_ALFRESCO_MODEL_SYNC_WRITE', '1');
define('OSCADDIE_ALFRESCO_MODEL_SYNC_FULL', '2');

/**
 * Implements hook_menu().
 */
function oscaddie_alfresco_model_menu() {
  $items['admin/oscaddie_alfresco/mapping'] = array(
    'title' => "Content Type Mapping",
    'access arguments' => array('administer site configuration'),
    'page callback' => 'oscaddie_alfresco_model__admin__mapping',
    'type' => MENU_NORMAL_ITEM,
    'file' => 'includes/oscaddie_alfresco_model.admin.inc',
    'weight' => 20,
    'menu_name' => 'management',
  );

  return $items;
}

/**
 * Implements hook_node_type_update().
 */
function oscaddie_alfresco_model_node_type_update($info) {
  // TODO: Trigger a re-map to Alfresco when a mapped content-type is updated.
}

/**
 * Implements hook_node_type_delete().
 */
function oscaddie_alfresco_model_node_type_delete($info) {
  // We only allow deletion of a type in Drupal only. Alfresco does not get
  // modified. Remove the entry so osCaddie Alfresco no longer associates with the type.
  oscaddie_alfresco_model__map_delete($info->type);
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function oscaddie_alfresco_model_form_node_type_form_alter(&$form, &$form_state, $form_id) {
  $form['oscaddie_alfresco_model'] = array(
    '#type' => 'fieldset',
    '#title' => t("osCaddie Alfresco"),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#tree' => TRUE,
    '#group' => 'additional_settings',
    '#weight' => -10,
  );

  $form['oscaddie_alfresco_model']['mapped'] = array(
    '#type' => 'item',
  );

  if ($status = oscaddie_alfresco_model__map_status($form['#node_type']->type)) {
    if ($status->status == OSCADDIE_ALFRESCO_MODEL_MAP_ENABLED) {
      $form['oscaddie_alfresco_model']['mapped']['#title'] = t("Enabled for osCaddie Alfresco");
      $form['oscaddie_alfresco_model']['mapped']['#description'] = t("This content type is currently being used with osCaddie Alfresco. Any Node operations done on this content-type will be reflected in Alfresco.");
      // TODO: Indicate which Alfresco Type is mapped to.
    }
    elseif ($status->status == OSCADDIE_ALFRESCO_MODEL_MAP_ALTERED) {
      $form['oscaddie_alfresco_model']['mapped']['#title'] = t("Enabled for osCaddie Alfresco");
      $form['oscaddie_alfresco_model']['mapped']['#description'] = t("This content type is currently being used with osCaddie Alfresco. Any Node operations done on this content-type will be reflected in Alfresco.");
      $form['oscaddie_alfresco_model']['mapped']['#description'] .= t("<p>Mapped to another content type in Alfresco.</p>");
    }
  }
  else {
    $form['oscaddie_alfresco_model']['mapped']['#title'] = t("Disabled for osCaddie Alfresco");
    $form['oscaddie_alfresco_model']['mapped']['#description'] = t("This content type is currently <strong>NOT</strong> being used with osCaddie Alfresco. If you want Alfresco to react to this content-type, please enable this content-type in osCaddie Alfresco settings page.");
  }
}

/**
 * Check if a given Node Type is enabled or disabled for osCaddie Alfresco.
 *
 * @param string $type
 *   Machine name of the Type for checking.
 * @param string $category
 *   - 'drupal' if the type for checking is a Drupal type.
 *   - 'alfresco' if the type for checking belongs to Alfresco.
 *
 * @return object
 *   The status object and mapping of the Type, otherwise FALSE if not found.
 */
function oscaddie_alfresco_model__map_status($type, $category = 'drupal') {
  try {
    $result = db_select('oscaddie_alfresco_model', 'm')
    ->fields('m')
    ->condition(
      'm.type_' . ($category == 'drupal'? 'd' : 'a'),
      $type
    )
    ->execute()
    ->fetchAssoc();

    return (!empty($result) ? (object) $result : FALSE);
  }
  catch (PDOException $e) {
    watchdog_exception('oscaddie_alfresco_model', $e);

    return FALSE;
  }
}

/**
 * Set Node Type enabled or disabled for osCaddie Alfresco and any mapping properties.
 *
 * @param string $type
 *   Machine name of the Drupal Type to map.
 * @param string $type_alfresco
 *   Machine name of the Alfresco Type to be mapped to.
 * @param int $sync
 *   Direction for syncing:
 *   - OSCADDIE_ALFRESCO_MODEL_SYNC_READ: '<---' push to Drupal only
 *   - OSCADDIE_ALFRESCO_MODEL_SYNC_WRITE: '--->' push to Alfresco only
 *   - OSCADDIE_ALFRESCO_MODEL_SYNC_FULL: '<--->' Bi-directional
 * @param int $status
 *   Status of the mapping:
 *   - OSCADDIE_ALFRESCO_MODEL_MAP_DISABLED: No mapping existed or the Drupal Type is not set for any mapping.
 *   - OSCADDIE_ALFRESCO_MODEL_MAP_ENABLED: Mapping exists and it's a 1-to-1 mapping with Alfresco.
 *   - OSCADDIE_ALFRESCO_MODEL_MAP_ALTERED: Mapping exists but its mapped to a different Type in Alfresco.
 */
function oscaddie_alfresco_model__map_set($type, $type_alfresco, $sync = OSCADDIE_ALFRESCO_MODEL_SYNC_FULL, $status = OSCADDIE_ALFRESCO_MODEL_MAP_ENABLED, $properties = array()) {

  if (empty($type) || empty($type_alfresco)) {
    return FALSE;
  }

  $data = array(
    'type_d'     => $type,
    'type_a'     => $type_alfresco,
    'status'     => $status,
    'sync'       => $sync,
    'properties' => serialize($properties),
  );

  try {
    $sql = "SELECT m.type_d FROM {oscaddie_alfresco_model} m WHERE m.type_d = :type";
    $result = db_query($sql, array(':type' => $type))->fetchObject();

    // Type does not exists we can INSERT a new record.
    // Else it is an update.
    if (empty($result->type_d)) {
      drupal_write_record('oscaddie_alfresco_model', $data);
    }
    else {
      drupal_write_record('oscaddie_alfresco_model', $data, 'type_d');
    }
  }
  catch (PDOException $e) {
    watchdog_exception('oscaddie_alfresco_model', $e);

    return FALSE;
  }
}

/**
 * Delete an entry in the model mapping table.
 *
 * @param string $type
 *   Machine name of the Drupal content-type to be deleted.
 * @param string $category
 *   - 'drupal' if the type to delete is a Drupal type.
 *   - 'alfresco' if the type to delete belongs to Alfresco.
 */
function oscaddie_alfresco_model__map_delete($type, $category = 'drupal') {
  if ($category == 'drupal') {
    $sql = "DELETE FROM {oscaddie_alfresco_model} WHERE type_d = :type";
  }
  elseif ($category == 'alfresco') {
    $sql = "DELETE FROM {oscaddie_alfresco_model} WHERE type_a = :type";
  }

  try {
    $row_count = db_query($sql, array(':type' => $type))->rowCount();

    return $row_count ? TRUE : FALSE;
  }
  catch (PDOException $e) {
    watchdog_exception('oscaddie_alfresco_model', $e);

    return FALSE;
  }
}

/**
 * Package the Mapping Definition schema into an Alfresco acceptable format.
 *
 * @param array $definitions
 *   An array containing the definitions of a Drupal content-type mapped
 *   to an Alfresco type.
 *
 * @return array
 *   An array of converted definitions objects. FALSE if error.
 */
function oscaddie_alfresco_model__map_definition_package($definitions) {
  if (empty($definitions) || !is_array($definitions)) {
    return FALSE;
  }

  $package = array();

  foreach ($definitions as $definition) {
    $properties = array();

    foreach ($definition['fields'] as $idx => $field) {
      $property = new stdClass();
      $property->drupalName = $field['field_name_drupal'];
      $property->alfrescoName = $field['field_name_alfresco'];

      $properties[] = $property;
    }

    $package[] = (object) array(
      'drupalName' => $definition['type_drupal'],
      'alfrescoName' => $definition['type_alfresco'],
      'syncModel' => !empty($definition['sync_model']) ? $definition['sync_model'] : "2",
      'creater' => $definition['creator'],
      'props' => $properties,
    );
  }

  return $package;
}

/**
 * Create a Drupal Content Type based on a Alfresco content model.
 *
 * @param string $machine_name
 *   Machine name of the Drupal type to create.
 * @param string $title
 *   Title of the Drupal type.
 * @param string $description
 *   (Optional) Description about the Drupal type.
 * @param bool $has_body
 *   (Optional) TRUE if the type will have a Body field, otherwise FALSE.
 * @param array $fields
 *   (Optional) Array of CCK fields to be attached to the type.
 *
 * @return object
 *   Drupal node type object along with any fields attached.
 */
function oscaddie_alfresco_model__drupal_type_create($machine_name, $title, $description = '', $has_body = TRUE, $fields = array()) {
  if (empty($machine_name) || empty($title)) {
    return FALSE;
  }
  // TODO: Config Alfresco to allow Title label to be saved.
  $info = array(
    'type'        => $machine_name,
    'name'        => $title,
    'base'        => 'node_content',
    'module'      => 'node',
    'has_title'   => TRUE,
    'title_label' => 'Title',
    'description' => $description,
    'custom'      => TRUE,
    'modified'    => TRUE,
    'locked'      => TRUE,
  );

  $info = node_type_set_defaults($info);

  if (node_type_save($info) == SAVED_NEW) {
    // Attach fields to the node type.
    if (!empty($fields) && is_array($fields)) {
      foreach ($fields as $field_name => $data) {
        if (isset($data['settings'])) {

          //  Simplify variable names to avoid cluster.
          $data_base   = $data['settings']['field'];
          $data_widget = $data['settings']['widget'];
          field_info_cache_clear();

          if (!($existing_field = field_info_field($field_name))) {
            $new_field = array(
              'field_name'  => $field_name,
              'type'        => $data_base['type'],
              'cardinality' => $data_base['cardinality'],
              'settings'    => (!empty($data_base['settings']) ? (array) $data_base['settings'] : array()),
            );
            field_create_field($new_field);
          }
          elseif ($existing_field['cardinality'] != $data_base['cardinality']) {
            //  We add the cardinality number to the field name to avoid going
            //  over 32 characters.
            $field_name .= '_' . ($data_base['cardinality'] != '-1' ? $data_base['cardinality'] : 'unl');
            $new_field = array(
              'field_name'  => $field_name,
              'type'        => $data_base['module'],
              'cardinality' => $data_base['cardinality'],
              'settings'    => (!empty($data_base['settings']) ? (array) $data_base['settings'] : array()),
            );
            if (!field_info_field($field_name)) {
              field_create_field($new_field);
            }
          }
          //  TODO: Maximum characters -> Is it being packaged?
          $instance = array(
            'bundle'        => $machine_name,
            'label'         => t($data['field_label']),
            'description'   => '',
            'required'      => $data['required'],
            'field_name'    => $field_name,
            'entity_type'   => $data_widget['entity_type'],
            'default_value' => array(
              array(
                'value' => isset($data['settings']['default']) ? $data['settings']['default'] : '',
              ),
            ),
            'widget'        => array(
              'module'   => $data_widget['widget']->module,
              'weight'   => $data_widget['widget']->weight,
              'active'   => $data_widget['widget']->active,
              'type'     => $data_widget['widget']->type,
              'settings' => (array) $data_widget['widget']->settings,
              ),
            'display'       => array(
              // 'default' => (array) $data_widget['display']->default,
              'default' => array(
                'label'  => !empty($data_widget['display']->default->label)  ? $data_widget['display']->default->label : '',
                'module' => !empty($data_widget['display']->default->module) ? $data_widget['display']->default->module : '',
                'type'   => !empty($data_widget['display']->default->type)   ? $data_widget['display']->default->type : '',
                'weight' => !empty($data_widget['display']->default->weight) ? $data_widget['display']->default->weight : '',
              ),
              'teaser'  => isset($data_widget['display']->teaser) ? array($data_widget['display']->teaser) : array(),
            ),
            'settings'  => !empty($data_widget['field']) ? array($data_widget['field']) : array(),
          );
          field_create_instance($instance);
        }
        //$info->fields[$field_name] = oscaddie_alfresco_model__drupal_type_create_cck($info->type, $data);
        $info->fields = $fields;
      }
    }
  }

  // Need to flush all cache.
  cache_clear_all();
  menu_rebuild();
  return $info;
}

/**
 * Create Field instancse and assign the correct Widget Type for a Node type.
 *
 * @param string $node_type
 *   Machine name of a Node type.
 * @param object $field_properties
 *   Field properties retrieved from Alfresco and required parameters as follows:
 *   - field_type:  Machine name of the CCK field module
 *   - widget_type: Machine name of the CCK widget belonging to the field module.
 *   - field_label: Label of the field.
 *   - field_name: Machine name of the field.
 *
 * @return array
 *   An array containing field information, otherwise FALSE.
 */
function oscaddie_alfresco_model__drupal_type_create_fields($node_type, $field_properties) {
  // We can only create CCK fields when the module actually exists.
  if (!module_exists('content')) {
    return FALSE;
  }

  // Determine if the passed field type actually exists in the system.
  $field_type_options = content_field_type_options();
  if (!array_key_exists($field_properties['settings']['field']['type'], $field_type_options)) {
    // Field type does not exists so we check if the default Text exists.
    if (array_key_exists('text', $field_type_options)) {
      $field_properties['settings']['field']['type'] = 'text';
    }
    else {
      // We can't create CCK fields when no field types exists.
      return FALSE;
    }
  }

  // Check if a widget type exists. If not use default.
  $widget_type_options = content_widget_type_options($field_properties['settings']['field']['type'], TRUE);
  if (!array_key_exists($field_properties['settings']['widget']['type'], $widget_type_options)) {
    // Widget type does not exists check if default exists.
    if (array_key_exists('text_textfield', $widget_type_options)) {
      $field_properties['settings']['widget']['type'] = 'text_textfield';
    }
    else {
      // We can't create the CCK field if no widget is available.
      return FALSE;
    }
  }

  $field = array(
    'label' => $field_properties['field_label'],
    'field_name' => $field_properties['field_name'],
    'type' => $field_properties['settings']['field']['type'],
    'type_name' => $node_type,
    'widget_type' => $field_properties['settings']['widget']['type'],
    'parent' => '',
    'weight' => $field_properties['settings']['widget']['weight'],
    'hidden_name' => '_add_new_field',
  );

  if ($field = content_field_instance_create($field)) {
    $settings_field = $field_properties['settings']['field'];
    $settings_widget = $field_properties['settings']['widget'];

    // Modify base settings.
    $field['required'] = $field_properties['required'];
    $field['multiple'] = $settings_field['multiple'];

    if (array_key_exists('allowed_values', $field)) {
      $field['allowed_values'] = isset($settings_field['allowed_values']) ? $settings_field['allowed_values'] : '';
    }

    if (array_key_exists('description', $field['widget'])) {
      $field['widget']['description'] = isset($settings_widget['description']) ? $settings_widget['description'] : '';
    }

    // Text field only.
    if ($field['module'] == 'text') {
      // Field settings.
      $field['max_length'] = isset($field_properties['max_length']) ? $field_properties['max_length'] : '';
      $field['text_processing'] = isset($settings_field['text_processing']) ? $settings_field['text_processing'] : '';

      // Widget settings.
      if (array_key_exists('rows', $field['widget'])) {
        $field['widget']['rows'] = $settings_widget['rows'];
      }

      if (array_key_exists('size', $field['widget'])) {
        $field['widget']['size'] = $settings_widget['size'];
      }
    }

    // Number field only.
    if ($field['module'] == 'number') {
      $field['min'] = isset($field_properties['min']) ? $field_properties['min'] : '';
      $field['max'] = isset($field_properties['max']) ? $field_properties['max'] : '';
      $field['prefix'] = isset($settings_field['prefix']) ? $settings_field['prefix'] : '';
      $field['suffix'] = isset($settings_field['suffix']) ? $settings_field['suffix'] : '';

      // Decimal.
      if ($field['type'] == 'number_decimal') {
        $field['scale'] = isset($settings_field['scale']) ? $settings_field['scale'] : '';
        $field['precision'] = isset($settings_field['precision']) ? $settings_field['precision'] : '';
        $field['decimal'] = isset($settings_field['decimal']) ? $settings_field['decimal'] : '';
      }
    }

    // Node Reference fields.
    elseif ($field['module'] == 'nodereference') {
      // Field settings.
      // TODO: Referenceable Types needs to be empty since other Drupal instance
      // does not have the content types and their node ID are not the same.
      // Site and type is the same owner then we restore the reference types.
      $field['referenceable_types'] = array();

      // Widget settings.
      $field['widget']['autocomplete_match'] = isset($settings_widget['autocomplete_match']) ? $settings_widget['autocomplete_match'] : '';
      $field['widget']['size'] = isset($settings_widget['size']) ? $settings_widget['size'] : '';
    }

    // User Reference fields.
    elseif ($field['module'] == 'userreference') {
      // Field settings.
      // TODO: Referenceable Roles needs to be empty since other Drupal instance
      // does not have the roles and their role ID are not the same.
      // Site and type is the same owner then we restore the reference roles.
      $field['referenceable_roles'] = array();
      $field['referenceable_status'] = isset($settings_field['referenceable_status']) ? $settings_field['referenceable_status'] : '';

      // Widget settings.
      $field['widget']['autocomplete_match'] = isset($settings_widget['autocomplete_match']) ? $settings_widget['autocomplete_match'] : '';
      $field['widget']['size'] = isset($settings_widget['size']) ? $settings_widget['size'] : '';
      $field['widget']['reverse_link'] = isset($settings_widget['reverse_link']) ? $settings_widget['reverse_link'] : '';
    }

    // Date fields.
    elseif ($field['module'] == 'date') {
      // Field settings.
      $field['granularity'] = isset($settings_field['granularity']) ? (array) $settings_field['granularity'] : array();
      $field['timezone_db'] = isset($settings_field['timezone_db']) ? $settings_field['timezone_db'] : '';
      $field['tz_handling'] = isset($settings_field['tz_handling']) ? $settings_field['tz_handling'] : '';
      $field['default_format'] = isset($settings_field['default_format']) ? $settings_field['default_format'] : '';
      $field['repeat'] = isset($settings_field['repeat']) ? $settings_field['repeat'] : '';
      $field['repeat_collapsed'] = isset($settings_field['repeat_collapsed']) ? $settings_field['repeat_collapsed'] : '';

      // Widget settings.
      $field['widget']['default_value'] = isset($settings_widget['default_value']) ? $settings_widget['default_value'] : '';
      $field['widget']['default_value_code'] = isset($settings_widget['default_value_code']) ? $settings_widget['default_value_code'] : '';
      $field['widget']['input_format'] = isset($settings_widget['input_format']) ? $settings_widget['input_format'] : '';
      $field['widget']['input_format_custom'] = isset($settings_widget['input_format_custom']) ? $settings_widget['input_format_custom'] : '';
      $field['widget']['increment'] = isset($settings_widget['increment']) ? $settings_widget['increment'] : '';
      $field['widget']['year_range'] = isset($settings_widget['year_range']) ? $settings_widget['year_range'] : '';
      $field['widget']['text_parts'] = isset($settings_widget['text_parts']) ? $settings_widget['text_parts'] : '';
    }

    // File/Images field.
    elseif ($field['module'] == 'filefield') {
      $field['list_field'] = isset($settings_field['list_field']) ? $settings_field['list_field'] : '';
      $field['list_default'] = isset($settings_field['list_default']) ? $settings_field['list_default'] : '';
      $field['description_field'] = isset($settings_field['description_field']) ? $settings_field['description_field'] : '';

      $field['widget']['file_extensions'] = isset($settings_widget['file_extensions']) ? $settings_widget['file_extensions'] : '';
      $field['widget']['file_path'] = isset($settings_widget['file_path']) ? $settings_widget['file_path'] : '';
      $field['widget']['progress_indicator'] = isset($settings_widget['progress_indicator']) ? $settings_widget['progress_indicator'] : '';
      $field['widget']['max_filesize_per_file'] = isset($settings_widget['max_filesize_per_file']) ? $settings_widget['max_filesize_per_file'] : '';
      $field['widget']['max_filesize_per_node'] = isset($settings_widget['max_filesize_per_node']) ? $settings_widget['max_filesize_per_node'] : '';

      if ($field['widget']['type'] == 'imagefield_widget') {
        $field['widget']['max_resolution'] = isset($settings_widget['max_resolution']) ? $settings_widget['max_resolution'] : '';
        $field['widget']['min_resolution'] = isset($settings_widget['min_resolution']) ? $settings_widget['min_resolution'] : '';
        $field['widget']['alt'] = isset($settings_widget['alt']) ? $settings_widget['alt'] : '';
        $field['widget']['custom_alt'] = isset($settings_widget['custom_alt']) ? $settings_widget['custom_alt'] : 0;
        $field['widget']['title'] = isset($settings_widget['title']) ? $settings_widget['title'] : '';
        $field['widget']['custom_title'] = isset($settings_widget['custom_title']) ? $settings_widget['custom_title'] : 0;
        $field['widget']['title_type'] = isset($settings_widget['title_type']) ? $settings_widget['title_type'] : '';
        $field['widget']['default_image'] = isset($settings_widget['default_image']) ? $settings_widget['default_image'] : NULL;
        $field['widget']['use_default_image'] = isset($settings_widget['use_default_image']) ? $settings_widget['use_default_image'] : 0;
      }
    }

    $field = content_field_instance_update($field);
  }
  else {
    drupal_set_message(t('There was a problem creating field %label.', array('%label' => $field['label'])));
  }

  return $field;
}

/**
 * Extract Node properties and CCK fields definition.
 *
 * Definition is a schema that can later be used with Alfresco.
 *
 * @param string $type
 *   Machine name of the content-type in Drupal.
 * @param string $sync
 *   Syncing mode between Drupal and Alfresco.
 * @param string $access
 *   Access mode for other Alfresco users accessing the content.
 *   Owner will always have full access.
 *
 * @return array
 *   An array consisting of 3 elements:
 *   - type: Machine name of the Drupal content-type.
 *   - name: Human readable name.
 *   - fields: An array of all possible fields of this content-type.
 *   FALSE if a given content-type does not exists.
 */
function oscaddie_alfresco_model__drupal_type_definition($type, $sync = OSCADDIE_ALFRESCO_MODEL_SYNC_FULL, $access = OSCADDIE_ALFRESCO_MODEL_ACCESS_FULL) {
  $properties = array();

  if (!($info = node_type_get_type($type))) {
    return FALSE;
  }

  //dpm($info, 'ENTITY');

  // Extract basic node properties.
  // Default properties and fields common to all Node.
  $properties['type'] = $info->type;
  $properties['name'] = check_plain($info->name);
  $properties['description'] = check_plain($info->description);
  $properties['sync_model'] = $sync;
  $properties['access'] = $access;

  $properties['fields'][] = array(
    'field_name' => 'status',
    'field_label' => 'Published',
    'data_type' => 'boolean',
  );

  $properties['fields'][] = array(
    'field_name' => 'promote',
    'field_label' => 'Promote',
    'data_type' => 'boolean',
  );

  $properties['fields'][] = array(
    'field_name' => 'sticky',
    'field_label' => 'Sticky',
    'data_type' => 'boolean',
  );

  $properties['fields'][] = array(
    'field_name' => 'language',
    'field_label' => 'Language',
    'data_type' => 'text',
  );

  $properties['fields'][] = array(
    'field_name' => 'title',
    'field_label' => 'Title',
    'data_type' => 'text',
  );

  $properties['fields'][] = array(
    'field_name' => 'title_label',
    'field_label' => 'Title Label',
    'data_type' => 'text',
  );

  // TODO: Save node bundle settings into a field properties. Necessary?
  // field_bundle_settings_node__x
  // node_options_x
  // node_preview_x
  // node_submitted_x

  $params = array('entity_type' => 'node', 'bundle' => $type);
  $fields = field_read_fields($params);
// dpm($fields, 'FIELDS');
  $params = array('entity_type' => 'node', 'bundle' => $type, 'deleted' => 0);
  $instances = field_read_instances($params);

// dpm($instances, 'INSTANCES');

  if (!empty($fields) && !empty($instances)) {
    foreach ($instances as $field_instance) {
      $property = array();

      // Field base properties.
      $field_name = $field_instance['field_name'];
      $cardinality = $fields[$field_name]['cardinality'];

      // Fill in Field base properties.
      $property['data_type'] = $fields[$field_name]['type'];

      $base_array = array(
        'type'        => $fields[$field_name]['type'],
        'module'      => $fields[$field_name]['module'],
        'cardinality' => $cardinality,
        'settings'    => (!empty($fields[$field_name]['settings']) ? $fields[$field_name]['settings'] : array())
      );
      $property['settings']['base'] = $base_array;

      // Extract global Field properties.
      $property['data_type']     = oscaddie_alfresco__drupal_type_conversion($fields[$field_name]['type']);
      $property['field_label']   = check_plain($field_instance['label']);
      $property['multiple']      = ($cardinality != 1 ? 'true' : 'false');
      $property['field_name']    = $field_name;
      $property['required']      = intval($field_instance['required']);
      $property['default_value'] = !empty($field_instance['default_value']) ? $field_instance['default_value'] : '';

      // TODO: Determine the conditions for multiple field.
      // TODO: Determine the conditions for maxlength.

      // Special treatment for Body field. We need to make it display
      // in Alfresco document teaser.
      if ($field_instance['field_name'] == 'body') {
        $property['field_name']  = 'teaser';
        $property['data_type']   = 'text';
        $property['field_label'] = 'Teaser';
      }

      // Extract Field settings.
      $instance_array = array(
        'entity_type' => $field_instance['entity_type'],
        'widget'      => $field_instance['widget'],
        'field'       => $field_instance['settings'],
        'display'     => $field_instance['display'],
      );
      $property['settings']['instance'] = $instance_array;

      $properties['fields'][] = $property;
    }
  }

  return $properties;
}

/**
 * Unpacks json file from Alfresco to Drupal readable format.
 * @param  json $definitions  Alfresco config file.
 */
function oscaddie_alfresco_model__alfresco_api__types_definition_unpackage($definitions) {
  if (empty($definitions) && !is_array($definitions)) {
    return FALSE;
  }

  $types = array();
  foreach ($definitions as $definition) {
    $type = array(
      'site_name'  => $definition->siteName,
      'title'      => t($definition->title),
      'type'       => $definition->name,
      'site_owner' => $definition->creater,
      'access'     => $definition->access,
      'fields'     => array(),
      'has_body'   => FALSE,
    );

    if (!empty($definition->props)) {

      $fields = array();

      foreach ($definition->props as $idx => $property) {
        $standard = array(
          'language',
          'promote',
          'status',
          'sticky',
          'teaser',
          'title',
        );

        if ($property->title == "Teaser") {
          $type['has_body'] == TRUE;
        }

        if (!in_array($property->name, $standard)) {
          $field = array();
          $field['field_label'] = t($property->title);
          $field['field_name']  = $property->name;
          if (!empty($property->mandatory)) {
            $field['required'] = $property->mandatory == 'true' ? TRUE : FALSE;
          }

          if (!empty($property->default)) {
            $field['settings']['default'] = $property->default;
          }

          if (!empty($property->settings->base)
          &&  !empty($property->settings->instance)) {
            //  Field settings common to Alfresco and Drupal.
            if (!empty($property->settings->instance->default_value)) {
              $field['default_value'] = $property->settings->instance->default_value;
            }
            $field['settings']['field']  = (array) $property->settings->base;
            $field['settings']['widget'] = (array) $property->settings->instance;
          }

          $fields[$property->name] = $field;
        }
      }

      $type['fields'] = $fields;
    }

    //  We will index all types of a user into a group.
    $types[$definition->creater][$definition->name] = $type;
  }
  return $types;
}

/**
 * Package the Drupal types definition schema into an Alfresco acceptable format.
 *
 * @param array $definitions
 *   An array of Drupal content-type definitions
 *
 * @return array
 *   An array of converted definitions objects. FALSE if error.
 */
function oscaddie_alfresco_model__drupal_type_definition_package($definitions) {
  if (empty($definitions) || !is_array($definitions)) {
    return FALSE;
  }

  $package = array();

  foreach ($definitions as $definition) {
    $properties = array();

    foreach ($definition['fields'] as $idx => $field) {
      $property = new stdClass();
      $property->name = $field['field_name'];
      $property->title = $field['field_label'];

      if (!empty($field['data_type'])) {
        $property->dataType = $field['data_type'];
      }

      if (isset($field['multiple'])) {
        $property->multiple = $field['multiple'];
      }

      if (isset($field['required'])) {
        $property->mandatory = $field['required'] ? "true" : "false";
      }

      if (!empty($field['default_value'])) {
        $default_value = array_pop($field['default_value']);
        $property->default = oscaddie_alfresco__enforce_types(array_pop($default_value), $field['data_type']);
      }

      if (!empty($field['settings']['base']['settings']['allowed_values']) && $field['data_type'] != 'boolean') {
        if ($field['data_type'] == 'text') {
          foreach ($field['settings']['base']['settings']['allowed_values'] as $label => $value) {
            $field['settings']['base']['settings']['allowed_values'][$label] = $label . '|' . $value;
          }
        }
        $property->listOptions = implode(',', $field['settings']['base']['settings']['allowed_values']);
      }

      if (isset($field['settings']['instance']['field']['min'])
      && $field['settings']['instance']['field']['min'] != NULL) {
        if ($field['settings']['instance']['field']['min'] == '0') {
          $property->min = '0';
        }
        else {
          $property->min = $field['settings']['instance']['field']['min'];
        }
      }

      if (isset($field['settings']['instance']['field']['max'])
      && $field['settings']['instance']['field']['max'] != NULL) {
        if ($field['settings']['instance']['field']['max'] == '0') {
          $property->max = '0';
        }
        else {
          $property->max = $field['settings']['instance']['field']['max'];
        }
      }

      if (isset($field['settings']['base']['settings']['max_length'])
      && $field['settings']['base']['settings']['max_length'] != NULL) {
        if ($field['settings']['base']['settings']['max_length'] == '0') {
          $property->max_length = '0';
        }
        else {
          $property->max_length = $field['settings']['base']['settings']['max_length'];
        }
      }

      if (isset($field['settings']['base']['settings']['precision'])
      && $field['settings']['base']['settings']['precision'] != NULL
      && isset($field['settings']['base']['settings']['scale'])
      && $field['settings']['base']['settings']['scale'] != NULL) {
        if ($field['settings']['base']['settings']['precision'] == '0') {
          $rx_precision = '0';
        }
        else {
          $rx_precision = $field['settings']['base']['settings']['precision'];
        }
        if ($field['settings']['base']['settings']['scale'] == '0') {
          $rx_scale = '0';
        }
        else {
          $rx_scale = $field['settings']['base']['settings']['scale'];
        }
        $property->reg_ex = '^(\d{0,' . $rx_precision . '}[' . $field['settings']['base']['settings']['decimal_separator'] . ']?)(\d{0,' . $rx_scale . '})$';
      }

      if (isset($field['settings'])) {
        $property->settings = $field['settings'];
      }

      $properties[] = $property;
    }

    $package[] = (object) array(
      'name' => $definition['type'],
      'title' => $definition['name'],
      'description' => $definition['description'],
      'access' => $definition['access'],
      'syncModel' => $definition['sync_model'],
      'props' => $properties,
    );
  }

  return $package;
}

/**
 * Unpackage the Alfresco Type definitions into a Drupal acceptable format.
 *
 * @param array $definitions
 *   An array of Alfresco type defintions.
 *
 * @return array
 *   An array of Alfresco type definitions converted into Drupal standards.
 */
function oscaddie_alfresco_model__alfresco_type_definition_unpackage($definitions) {
  if (empty($definitions) && !is_array($definitions)) {
    return FALSE;
  }

  $types = array();

  foreach ($definitions as $definition) {
    $type = array(
      'site_owner' => $definition->creater,
      'site_name' => $definition->siteName,
      'access' => $definition->access,
      'type' => $definition->name,
      'title' => htmlspecialchars_decode($definition->title),
      'has_body' => FALSE,
      'fields' => array(),
    );

    if (!empty($definition->props)) {
      $fields = array();

      foreach ($definition->props as $idx => $property) {
        // Teaser/Body are not CCK fields but they are optional so we extract first.
        if ($property->name == 'teaser') {
          $type['has_body'] = TRUE;
        }

        // We will ignore all standard Drupal fields.
        $standard = array(
          'status',
          'sticky',
          'promote',
          'language',
          'title',
          'teaser',
        );

        if (!in_array($property->name, $standard)) {
          $field = array();
          $field['field_label'] = htmlspecialchars_decode($property->title);
          $field['field_name'] = $property->name;

          if (!empty($property->settings->field->type) && !empty($property->settings->widget->type)) {
            $field['required'] = $property->mandatory == 'true' ? 1 : 0;
            $field['multiple'] = $property->multiple  == 'true' ? 1 : 0;

            // Field settings common to Alfresco and Drupal.
            if (!empty($property->default)) {
              $field['default_value'] = array(
                array(
                  $property->default
                )
              );
            }
            if (!empty($property->max_length)) {
              $field['max_length'] = $property->max_length;
            }

            $field['settings']['field']  = (array) $property->settings->field;
            $field['settings']['widget'] = (array) $property->settings->widget;
          }

          $fields[$property->name] = $field;
        }
      }

      $type['fields'] = $fields;
    }

    // We will index all types of a user into a group.
    $types[$definition->creater][$definition->name] = $type;
  }

  return $types;
}

/**
 * Simple DB query result.
 *
 * @param string $type
 *   Drupal CCK type.
 *
 * @return string
 *   Alfresco datatype corresponding to Drupal CCK type. FALSE if a conversion
 *   does not exists.
 */
function oscaddie_alfresco_model__return_sync_type($type) {
  return db_query("SELECT sync FROM {oscaddie_alfresco_model} WHERE type_d = :type", array(':type' => $type))->fetchField();
};

/**
 * Delete a content type from Alfresco.
 * @param  string  $type         Drupal Machine name for content type.
 * @param  boolean $del_db_entry Remove from {oscaddie_alfresco_model}
 */
function oscaddie_alfresco_model__delete_content_type($type, $del_db_entry = TRUE) {
  try {
    $result = oscaddie_alfresco__alfresco_api__send(OSCADDIE_ALFRESCO_CONTENT_TYPE_DELETE_TYPE, NULL, 'delete', array('type' => $type));
    if ($result->response->status == 'success' && $del_db_entry) {
      oscaddie_alfresco_model__map_delete($type);
    }
  }
  catch (Exception $e) {
    throw new Exception('Failed to delete content type.', 0, $e);
  }
}
