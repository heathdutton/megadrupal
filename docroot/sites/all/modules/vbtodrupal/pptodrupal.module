<?php

/**
 * @file
 * Imports the Photopost database into Drupal.
 */

/**
 * How many photo files to copy per pass.
 */
define('PPTODRUPAL_FILES_PER_PASS', 100);

/**
 * Photopost folder to import into, within Drupal's files directory.
 */
define('PPTODRUPAL_DIRECTORY', 'pp_pictures');

/**
 * Arbitrary number to add to database id values, stops record collisions.
 *
 * Must be different to vB to Drupal ids to stop id collisions with data
 * imported by that module.
 */
define('PPTODRUPAL_ADD_TO_IDS', 10000000);

/**
 * Content type name to create and import into.
 *
 * Makes it easier to import multiple galleries by bringing content into
 * different content types.
 */
define('PPTODRUPAL_CONTENT_TYPE', 'photopost');

/**
 * Name of the photo field attached to the photo node type.
 */
define('PPTODRUPAL_PHOTO_FIELD', 'pptodrupal_photo');

/**
 * Prefix of the 'extra' field to import from Photopost.
 */
define('PPTODRUPAL_EXTRA_FIELD', 'pptodrupal_extra');

/**
 * Name of main category taxonomy to import into.
 */
define('PPTODRUPAL_CATEGORIES_VOCABULARY', 'pptodrupal_categories');

/**
 * Name of keywords taxonomy to import into.
 */
define('PPTODRUPAL_KEYWORDS_TAXONOMY', 'pptodrupal_keywords');

/**
 * Implements hook_vbimportapi_importer().
 */
function pptodrupal_vbimportapi_importer() {
  return array(
    'title' => t('Photopost to Drupal'),
    'product' => 'Photopost',
    'menu items' => TRUE,
    'operations' => array(
      array('vbimportapi_import', array('taxonomy_vocabulary')),
      array('vbimportapi_import', array('image_style')),
      array('vbimportapi_import', array('node_type')),
      array('vbimportapi_import', array('users')),
      array('vbimportapi_import', array('new_users')),
      array('vbimportapi_import', array('new_users_linker')),
      array('vbimportapi_import', array('photos', PPTODRUPAL_FILES_PER_PASS)),
      array('vbimportapi_import', array('file_managed_photos')),
      array('vbimportapi_import', array('file_usage_photos')),
      array('vbimportapi_mime_types_repair', array(t('Determining file types of imported photos.'))),
      array('vbimportapi_import', array('photo_nodes')),
      array('vbimportapi_import', array('photo_node_revision')),
      array('vbimportapi_import', array('field_data_body_photos')),
      array('vbimportapi_import', array('field_revision_body_photos')),
      array('vbimportapi_import', array('field_data_pptodrupal_photo')),
      array('vbimportapi_import', array('field_revision_pptodrupal_photo')),
      array('vbimportapi_import', array('field_data_taxonomy_pptodrupal_categories')),
      array('vbimportapi_import', array('field_revision_taxonomy_pptodrupal_categories')),
      array('vbimportapi_import', array('taxonomy_term')),
      array('vbimportapi_import', array('taxonomy_hierarchy_children')),
      array('vbimportapi_import', array('taxonomy_hierarchy_top_level')),
      array('vbimportapi_import', array('taxonomy_index')),
      array('vbimportapi_import', array('keywords_taxonomy_term', ceil(VBIMPORTAPI_RECORDS_PER_PASS / 100))),
      array('vbimportapi_import', array('keywords_taxonomy_junk_term', 1)),
      array('pptodrupal_keywords_merge_import', array()),
      array('vbimportapi_import', array('keywords_hierarchy')),
      array('vbimportapi_import', array('comments')),
      array('vbimportapi_import', array('field_data_comment_body')),
      array('vbimportapi_import', array('field_revision_comment_body')),
    ),
  );
}

/**
 * Implementation of hook_pptodrupal_importer_alter().
 */
function pptodrupal_pptodrupal_importer_alter(&$importer) {
  // There are six 'extra' fields attached to every Photopost photo.
  // The import function is responsible for keeping track of which field it
  // should import next.
  for ($i = 0; $i <= 6; $i++) {
    $importer['operations'][] = array('vbimportapi_import', array('field_data_pptodrupal_extra'));
    $importer['operations'][] = array('vbimportapi_import', array('field_revision_pptodrupal_extra'));
  }
}

/**
 * Implements hook_vbimportapi_table_check().
 */
function pptodrupal_vbimportapi_table_check() {
  return array('photos', 'photoextras');
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function pptodrupal_form_vbimportapi_import_form_alter(&$form, &$form_state) {
  // @todo: pass control for this check to the API module, currently this
  // is just unseemly boiler plate.
  if ($form['module']['#value'] != 'pptodrupal') {
    return;
  }

  $scheme = file_default_scheme() . '://';
  if (!file_prepare_directory($scheme, FILE_CREATE_DIRECTORY)) {
    $form['pptodrupal_files_test'] = array(
      '#value' => '<h3>' . t('Testing file system') . '</h3>',
    );
    $form['pptodrupal_files_test']['result'] = array('#value' => '<p><strong class="marker">' . t('Test failed: the file system is not configured correctly, please correct the settings on the <a href="@system_file_system_settings">file system settings page</a>.', array('@system_file_system_settings' => url('admin/config/file-system', array('query' => drupal_get_destination())))) . '</strong></p>');
    $form['tests_passed']['#access'] = FALSE;
  }
}

/**
 * Implements hook_vbimportapi_delete().
 */
function pptodrupal_vbimportapi_delete() {
  drupal_cron_run();
  db_query("TRUNCATE TABLE {pptodrupal_users_linker}");

  $photos_min = variable_get('pptodrupal_photos_id_min', 0);
  $photos_max = variable_get('pptodrupal_photos_id_max', 0);
  db_delete('file_managed')
    ->condition('fid', $photos_min, '>=')
    ->condition('fid', $photos_max, '<=')
    ->execute();
  db_delete('file_usage')
    ->condition('fid', $photos_min, '>=')
    ->condition('fid', $photos_max, '<=')
    ->execute();
  db_delete('node')
    ->condition('nid', $photos_min, '>=')
    ->condition('nid', $photos_max, '<=')
    ->execute();
  db_delete('node_revision')
    ->condition('nid', $photos_min, '>=')
    ->condition('nid', $photos_max, '<=')
    ->execute();

  // @see: taxonomy_del_vocabulary().
  $categories_min = variable_get('pptodrupal_categories_id_min', 0);
  $categories_max = variable_get('pptodrupal_categories_id_max', 0);
  $categories_vocabulary = taxonomy_vocabulary_machine_name_load(PPTODRUPAL_CATEGORIES_VOCABULARY);
  if (!empty($categories_vocabulary)) {
    db_delete('taxonomy_term_data')
      ->condition('tid', $categories_min, '>=')
      ->condition('tid', $categories_max, '<=')
      ->condition('vid', $categories_vocabulary->vid)
      ->execute();
    db_delete('taxonomy_term_hierarchy')
      ->condition('tid', $categories_min, '>=')
      ->condition('tid', $categories_max, '<=')
      ->execute();
    db_delete('taxonomy_index')
      ->condition('tid', $categories_min, '>=')
      ->condition('tid', $categories_max, '<=')
      ->execute();
    db_delete('taxonomy_vocabulary')
      ->condition('vid', $categories_vocabulary->vid)
      ->execute();
  }

  // Delete keywords.
  $keywords_vocabulary = taxonomy_vocabulary_machine_name_load(PPTODRUPAL_KEYWORDS_TAXONOMY);
  $keywords_where = 'tid IN (SELECT tid FROM {taxonomy_term_data} WHERE vid = :vid)';
  if (!empty($keywords_vocabulary)) {
    db_delete('taxonomy_index')
      ->where($keywords_where, array(':vid' => $keywords_vocabulary->vid))
      ->execute();
    db_delete('taxonomy_term_hierarchy')
      ->where($keywords_where, array(':vid' => $keywords_vocabulary->vid))
      ->execute();
    db_delete('taxonomy_vocabulary')
      ->condition('vid', $keywords_vocabulary->vid)
      ->execute();
  }

  $comments_min = variable_get('pptodrupal_comments_id_min', 0);
  $comments_max = variable_get('pptodrupal_comments_id_max', 0);
  db_delete('comment')
    ->condition('cid', $comments_min, '>=')
    ->condition('cid', $comments_max, '<=')
    ->execute();

  // Delete node body, comment and taxonomy fields.
  $tables = array();
  $tables[] = 'field_data_body';
  $tables[] = 'field_revision_body';
  foreach ($tables as $table) {
    db_delete($table)
      ->condition('entity_id', $photos_min, '>=')
      ->condition('entity_id', $photos_max, '<=')
      ->execute();
  }

  $tables = array();
  $tables[] = 'field_data_comment_body';
  $tables[] = 'field_revision_comment_body';
  foreach ($tables as $table) {
    db_delete($table)
      ->condition('entity_id', $comments_min, '>=')
      ->condition('entity_id', $comments_max, '<=')
      ->execute();
  }

  if (!empty($categories_vocabulary)) {
    $field = 'taxonomy_' . PPTODRUPAL_CATEGORIES_VOCABULARY . '_tid';
    $tables = array();
    $tables[] = 'field_data_taxonomy_' . PPTODRUPAL_CATEGORIES_VOCABULARY;
    $tables[] = 'field_revision_taxonomy_' . PPTODRUPAL_CATEGORIES_VOCABULARY;

    foreach ($tables as $table) {
      db_delete($table)
        ->condition($field, $categories_min, '>=')
        ->condition($field, $categories_max, '<=')
        ->execute();
    }
  }

  if (!empty($keywords_vocabulary)) {
    $field = 'taxonomy_' . PPTODRUPAL_KEYWORDS_TAXONOMY . '_tid';
    $keywords_field_where = $field . ' IN (SELECT tid FROM {taxonomy_term_data} WHERE vid = :vid)';
    $tables = array();
    $tables[] = 'field_data_taxonomy_' . PPTODRUPAL_KEYWORDS_TAXONOMY;
    $tables[] = 'field_revision_taxonomy_' . PPTODRUPAL_KEYWORDS_TAXONOMY;

    foreach ($tables as $table) {
      db_delete($table)
        ->where($keywords_field_where, array(':vid' => $keywords_vocabulary->vid))
        ->execute();
    }

    // Cannot delete {taxonomy_term_data} until it's finished with.
    db_delete('taxonomy_term_data')
      ->condition('vid', $keywords_vocabulary->vid)
      ->execute();
  }

  foreach (array('thumb', 'medium') as $type) {
    // It's necessary to load the full style, since the delete feature
    // requires the 'isid' field.
    $style = image_style_load('photopost_' . $type);
    if (!empty($style)) {
      image_style_delete($style);
    }
  }

  foreach (_pptodrupal_installed_instances() as $instance) {
    if (field_read_instance($instance['entity_type'], $instance['field_name'], $instance['bundle'])) {
      field_delete_instance($instance['field_name']);
    }
  }

  foreach (_pptodrupal_installed_fields() as $field) {
    if (field_info_field($field['field_name'])) {
      field_delete_field($field['field_name']);
    }
  }

  // Delete files on disk.
  if (variable_get('pptodrupal_delete_files_on_disk', FALSE)) {
    _pptodrupal_recursive_rm(file_default_scheme() . '://' . PPTODRUPAL_DIRECTORY);
  }

  node_type_delete(PPTODRUPAL_CONTENT_TYPE);
  node_types_rebuild();
  menu_rebuild();

  drupal_cron_run();
}

/**
 * Create a taxonomy vocabulary for Photopost.
 */
function pptodrupal_taxonomy_vocabulary_import(&$context) {
  $context['message'] = t('Creating Photopost vocabulary.');
  $categories_vocabulary = taxonomy_vocabulary_machine_name_load(PPTODRUPAL_CATEGORIES_VOCABULARY);
  $keywords_vocabulary = taxonomy_vocabulary_machine_name_load(PPTODRUPAL_KEYWORDS_TAXONOMY);

  if (empty($categories_vocabulary)) {
    // The primary Photopost taxonomy.
    $edit = array(
      'name' => t('Photopost categories'),
      'machine_name' => PPTODRUPAL_CATEGORIES_VOCABULARY,
      'hierarchy' => 1,
      'module' => 'taxonomy',
    );
    $vocabulary = (object) $edit;
    taxonomy_vocabulary_save($vocabulary);
  }

  if (empty($keywords_vocabulary)) {
    // The Photopost taxonomy for keywords.
    $edit = array(
      'name' => t('Photopost keywords'),
      'machine_name' => PPTODRUPAL_KEYWORDS_TAXONOMY,
      'hierarchy' => 0,
      'module' => 'taxonomy',
    );
    $vocabulary = (object) $edit;
    taxonomy_vocabulary_save($vocabulary);
  }
}

/**
 * Create new image style and effects for Photopost photos.
 */
function pptodrupal_image_style_import(&$context) {
  $context['message'] = t('Creating image styles.');

  // Each item in this array is an image style and the default size for that
  // image style.
  foreach (array('thumb' => 160, 'medium' => 880) as $type => $size) {
    // Check if the style already exists.
    $style = image_style_load('photopost_' . $type);
    if (!empty($style)) {
      continue;
    }

    $style = image_style_save(array('name' => 'photopost_' . $type));

    $effect = array(
      'name' => 'image_scale_and_crop',
      'data' => array(
        'width' => variable_get('pptodrupal_' . $type . '_size', $size),
        'height' => variable_get('pptodrupal_' . $type . '_size', $size),
      ),
      'isid' => $style['isid'],
    );

    image_effect_save($effect);
  }
}

/**
 * Returns a structured array defining fields created for Photopost to Drupal.
 *
 * This is factored into this function so it can be used in both
 * pptodrupal_field_add(), pptodrupal_vbimportapi_delete() and elsewhere.
 */
function _pptodrupal_installed_fields() {
  module_load_include('inc', 'pptodrupal', 'pptodrupal_computed_field_code');

  $return = array(
    PPTODRUPAL_PHOTO_FIELD => array(
      'field_name' => PPTODRUPAL_PHOTO_FIELD,
      'type' => 'image',
    ),
    'taxonomy_' . PPTODRUPAL_CATEGORIES_VOCABULARY => array(
      'field_name' => 'taxonomy_' . PPTODRUPAL_CATEGORIES_VOCABULARY,
      'type' => 'taxonomy_term_reference',
      'settings' => array(
        'allowed_values' => array(
          'vocabulary' => PPTODRUPAL_CATEGORIES_VOCABULARY,
          'parent' => 0,
        ),
      ),
    ),
    'taxonomy_' . PPTODRUPAL_KEYWORDS_TAXONOMY => array(
      'field_name' => 'taxonomy_' . PPTODRUPAL_KEYWORDS_TAXONOMY,
      'type' => 'taxonomy_term_reference',
      'cardinality' => FIELD_CARDINALITY_UNLIMITED,
      'settings' => array(
        'allowed_values' => array(
          'vocabulary' => PPTODRUPAL_CATEGORIES_VOCABULARY,
          'parent' => 0,
        ),
      ),
    ),
    'pptodrupal_forum_code' => array(
      'field_name' => 'pptodrupal_forum_code',
      'type' => 'computed',
      'cardinality' => FIELD_CARDINALITY_UNLIMITED,
      'settings' => array(
        'code' => _pptodrupal_computed_field_forum_code(),
        'display_format' => _pptodrupal_computed_field_forum_display_format(),
      ),
    ),
  );

  $return = array_merge(_pptodrupal_get_extra_fields('field'), $return);

  return $return;
}

/**
 * Returns a structured array defining field instances created for vB to Drupal.
 *
 * This is factored into this function so it can be used in both
 * pptodrupal_field_add() and pptodrupal_vbimportapi_delete().
 */
function _pptodrupal_installed_instances() {
  $return = array(
    PPTODRUPAL_PHOTO_FIELD . '_node' => array(
      'field_name' => PPTODRUPAL_PHOTO_FIELD,
      'entity_type' => 'node',
      'bundle' => PPTODRUPAL_CONTENT_TYPE,
      'label' => t('Photopost photo file'),
      'widget' => array(
        'type' => 'image_image',
        'settings' => array(
          'preview_image_style' => 'photopost_thumb',
        ),
      ),
      'settings' => array(
        'file_directory' => PPTODRUPAL_DIRECTORY,
      ),
      'display' => array(
        'default' => array(
          'settings' => array(
            'image_style' => 'photopost_medium',
            'image_link' => 'file',
          ),
        ),
        'teaser' => array(
          'settings' => array(
            'image_style' => 'photopost_medium',
            'image_link' => 'content',
          ),
        ),
      ),
    ),
    'taxonomy_' . PPTODRUPAL_CATEGORIES_VOCABULARY . '_node' => array(
      'field_name' => 'taxonomy_' . PPTODRUPAL_CATEGORIES_VOCABULARY,
      'entity_type' => 'node',
      'bundle' => PPTODRUPAL_CONTENT_TYPE,
      'label' => t('Photopost categories'),
      'widget' => array(
        'type' => 'options_select',
      ),
    ),
    'taxonomy_' . PPTODRUPAL_KEYWORDS_TAXONOMY . '_node' => array(
      'field_name' => 'taxonomy_' . PPTODRUPAL_KEYWORDS_TAXONOMY,
      'entity_type' => 'node',
      'bundle' => PPTODRUPAL_CONTENT_TYPE,
      'label' => t('Photopost keywords'),
      'widget' => array(
        'type' => 'taxonomy_autocomplete',
      ),
    ),
    'pptodrupal_forum_code_node' => array(
      'field_name' => 'pptodrupal_forum_code',
      'entity_type' => 'node',
      'bundle' => PPTODRUPAL_CONTENT_TYPE,
      'label' => t('Forum code'),
    ),
  );

  $return = array_merge(_pptodrupal_get_extra_fields('instance'), $return);

  return $return;
}

/**
 * Get Photopost extra fields.
 *
 * Only retrieves extra fields if the import database has been setup.
 *
 * @param $type
 *   Either 'field' or 'instance', determines what field information should
 *   be retrieved.
 */
function _pptodrupal_get_extra_fields($type = 'field') {
  if (!in_array($type, array('field', 'instance'))) {
    return;
  }

  // There are six 'extra' fields in Photopost, the content is set by the user
  // when they upload a photo, the label is also dynamic and set per-category.
  // Since field labels cannot be changed per-taxonomy/term, get the most
  // popular for each 'extra' field and use that. Fields without any labels
  // will not be imported.

  $return = array();
  $check_table = vbimportapi_import_db_table_exists('categories');
  $saved_extras = variable_get('pptodrupal_extra_fields_' . $type, array());

  // This is so this function can be used, even when the import database has
  // not been set up. $check_table reports whether the 'categories' table
  // is available in the import_from database, if the database has not been
  // set up it will be zero (or the equivalent of FALSE in PHP).
  if (!$check_table && !empty($saved_extras)) {
    return $saved_extras;
  }
  else if (!$check_table && empty($saved_extras)) {
    return;
  }

  $extras = array();
  $populated_extras = array();

  for ($i = 1; $i <= 6; $i++) {
    $extras[$i] = _pptodrupal_get_extra_label($i);

    if (empty($extras[$i])) {
      continue;
    }

    $populated_extras[$i] = $i;

    switch ($type) {
      case 'field':
        $return[PPTODRUPAL_EXTRA_FIELD . $i] = array(
          'field_name' => PPTODRUPAL_EXTRA_FIELD . $i,
          'type' => 'text',
        );
        break;
      case 'instance':
        $return[PPTODRUPAL_EXTRA_FIELD . $i] = array(
          'field_name' => PPTODRUPAL_EXTRA_FIELD . $i,
          'entity_type' => 'node',
          'bundle' => PPTODRUPAL_CONTENT_TYPE,
          'label' => $extras[$i]['extra_name'],
          'widget' => array(
            'type' => 'text',
          ),
        );
        break;
    }
  }

  // Used during the import to see which 'extra' fields are in use and should
  // be imported.
  variable_set('pptodrupal_populated_extras', $populated_extras);

  // Save field information so it's accessible even when the import from
  // database is not set up.
  variable_set('pptodrupal_extra_fields_' . $type, $return);

  return $return;
}

/**
 * Find the label of a given Photopost 'extra' field.
 *
 * Statically caches the result for performance.
 */
function _pptodrupal_get_extra_label($index) {
  $extras = &drupal_static(__FUNCTION__);

  if (!isset($extras[$index])) {
    $query = db_select('categories', 'c')
      ->addTag('vbimport')
      ->groupBy("extra$index")
      ->orderBy('popularity', 'DESC');
    $query->addExpression('extra' . $index, 'extra_name');
    $query->addExpression('COUNT(id)', 'popularity');
    $query->where("extra$index <> ''");
    $query->range(0, 1);
    $extras[$index] = $query->execute()->fetchAssoc();
  }

  return $extras[$index];
}

/**
 * Create content type to import into.
 */
function pptodrupal_node_type_import(&$context) {
  $context['message'] = t('Creating content type.');

  $type = new stdClass();
  $type->type = PPTODRUPAL_CONTENT_TYPE;
  $type->name = t('Photopost photo');
  $type->base = 'node_content';
  $type->description = t('Photographs imported from Photopost');
  $type->custom = 1;
  $type->title_label = t('Add a title for the photo(s)');
  node_type_save($type);
  node_add_body_field($type, t('Enter a description for the photo(s)'));

  // Install field(s) and field instance(s).
  foreach (_pptodrupal_installed_fields() as $field) {
    if (!field_info_field($field['field_name'])) {
      field_create_field($field);
    }
  }

  foreach (_pptodrupal_installed_instances() as $instance) {
    if (!field_read_instance($instance['entity_type'], $instance['field_name'], $instance['bundle'])) {
      field_create_instance($instance);
    }
  }
}

/**
 * Import Users from Photopost.
 */
function pptodrupal_users_import(&$context) {
  $context['message'] = t('Importing users (part one of three).');

  if ($context['sandbox']['progress'] == 0) {
    db_truncate('pptodrupal_users_linker')->execute();
  }

  $context['query_insert'] = db_insert('pptodrupal_users_linker')
    ->fields(array('photopost_userid', 'drupal_uid'));

  $context['query_select'] = db_select('users', 'pu')
    ->addMetaData('import_into_tables', array('du'));
  $context['query_select']->addExpression('pu.userid', 'photopost_userid');
  $context['query_select']->addExpression('COALESCE(du.uid, 0)', 'drupal_uid');
  $context['query_select']->leftJoin('users', 'du', 'pu.username = du.name');
}

/**
 * Import users not already in Drupal.
 */
function pptodrupal_new_users_import(&$context) {
  $context['message'] = t('Importing users (part two of three).');

  $context['query_insert'] = db_insert('users')
    ->fields(array('name', 'pass', 'mail', 'created', 'access', 'login', 'signature', 'uid', 'status'));

  // Note: the password must not be blank in the Photopost {{users}} table,
  // a blank password (and email) denotes integration with another product
  // (such as vBulletin, phpBB, UBB etc.).
  $context['query_select'] = db_select('users', 'pu')
    ->where("pu.password <> '' AND ul.drupal_uid = 0")
    ->fields('pu', array('username', 'password', 'email', 'joindate', 'laston', 'laston'));

  $context['query_select']->join('pptodrupal_users_linker', 'ul', 'pu.userid = ul.photopost_userid');
  $context['query_select']->addMetaData('import_into_tables', array('ul'));
  $context['query_select']->addExpression("COALESCE(pu.signature, '')", 'signature');
  $context['query_select']->addExpression('pu.userid+:add_to_ids', 'uid', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS)); 
  $context['query_select']->addExpression('1', 'status');
}

/**
 * Links newly imported Drupal users to their records in Photopost.
 *
 * For linking the new users imported in step two by updating the user
 * linker table.
 *
 * @see pptodrupal_new_users_import().
 */
function pptodrupal_new_users_linker_import(&$context) {
  $context['message'] = t('Importing users (part three of three).');

  if ($context['sandbox']['max'] == 0) {
    $result = db_select('pptodrupal_users_linker', 'ul');
    $result->addMetaData('import_into_tables', array('ul'));
    $result->addExpression('MAX(ul.photopost_userid)', 'max_userid');
    $context['sandbox']['max'] = $result->execute()->fetchField();
  }
}

/**
 * Actually link new users to imported ones, main function is for preparation.
 */
function pptodrupal_new_users_linker_post_import(&$context) {
  $sql = "UPDATE {pptodrupal_users_linker} ul, {users} du
    SET ul.drupal_uid = du.uid
    WHERE ul.photopost_userid = du.uid-:add_to_ids AND ul.drupal_uid = 0
    AND ul.photopost_userid > :progress AND ul.photopost_userid <= :progress_plus";

  $result = db_query($sql, array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS, ':progress' => $context['sandbox']['progress'], ':progress_plus' => $context['sandbox']['progress'] + $context['sandbox']['records_per_pass']));
}

/**
 * Import Photopost data.
 */
function pptodrupal_photos_import(&$context) {
  // Advise the user exactly how far through we are, otherwise it may seem
  // that the process has stalled.
  $context['message'] = t('Importing photo files (@progress of @max).', array('@progress' => $context['sandbox']['progress'], '@max' => $context['sandbox']['max']));

  if ($context['sandbox']['progress'] == 0) {
    $context['sandbox']['message'] = t('Importing photo files');
    $context['sandbox']['pptodrupal_files_dir'] = file_default_scheme() . '://' . PPTODRUPAL_DIRECTORY;
    // Attempt to automatically create place for files to be imported to.
    if (!file_prepare_directory($context['sandbox']['pptodrupal_files_dir'], 3)) {
      drupal_set_message(t('Unable to create Photopost import directory.'), 'error', FALSE);
      return FALSE;
    }
    // Photopost directory is an absolute path.
    $context['sandbox']['photopost_files_dir'] = db_select('settings', 's')
      ->fields('s', array('setting'))
      ->condition('s.varname', 'datafull')
      ->addtag('vbimport')
      ->execute()
      ->fetchField();

    // Only create the directory structure, since copying files will take some
    // time and should be done in increments.
    _pptodrupal_copy_dir_structure($context['sandbox']['photopost_files_dir'], $context['sandbox']['pptodrupal_files_dir']);

    // The first photo id, plus the number added to imported ids, is the
    // minimum insert id of imported entries from Photopost. This is saved so
    // the entries in {files} may be deleted later.
    $result = db_select('photos', 'p')
      ->addTag('vbimport');
    $result->addExpression('MIN(p.id)+:add_to_ids', 'min', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
    $result->addExpression('MAX(p.id)+:add_to_ids', 'max', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
    $photos_bounds = $result->execute()->fetchAssoc();
    variable_set('pptodrupal_photos_id_min', $photos_bounds['min']);
    variable_set('pptodrupal_photos_id_max', $photos_bounds['max']);

    // Get thumbnail and medium dimensions from Photopost and save them
    // for use in ImageCache presets.
    $thumb_size = db_select('settings', 's')
      ->fields('s', array('setting'))
      ->addTag('vbimport')
      ->condition('s.varname', 'previewwidth')
      ->execute()
      ->fetchField();
    $medium_size = db_select('settings', 's')
      ->fields('s', array('setting'))
      ->addTag('vbimport')
      ->condition('s.varname', 'biggraphic')
      ->execute()
      ->fetchField();
    variable_set('pptodrupal_thumb_size', $thumb_size);
    variable_set('pptodrupal_medium_size', $medium_size);
  }

  $photos = db_select('photos', 'p')
    ->addTag('vbimport')
    ->fields('p', array('cat'));
  $photos->addField('p', 'bigimage');
  $photos->addExpression("CONCAT((p.id+:add_to_ids), '_', p.bigimage)", 'filename', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
  $photos->addExpression("CONCAT(:photopost_files_dir, '/', p.cat, '/', p.bigimage)", 'image', array(':photopost_files_dir' => $context['sandbox']['photopost_files_dir']));
  $photos->addExpression("CONCAT(:photopost_files_dir, '/', p.cat, '/thumbs/', p.bigimage)", 'thumbs', array(':photopost_files_dir' => $context['sandbox']['photopost_files_dir']));
  $photos->addExpression("CONCAT(:photopost_files_dir, '/', p.cat, '/medium/', p.bigimage)", 'medium', array(':photopost_files_dir' => $context['sandbox']['photopost_files_dir']));
  $photos->addExpression("CONCAT(:photopost_files_dir, '/', p.cat, '/mini/', p.bigimage)", 'mini', array(':photopost_files_dir' => $context['sandbox']['photopost_files_dir']));
  $photos->addExpression('p.medwidth + p.medheight', 'resizedexist');

  $context['query_select'] = clone $photos;

  $photos->range($context['sandbox']['progress'], $context['sandbox']['records_per_pass']);
  $result = $photos->execute();

  $files = array();

  foreach ($result as $photo) {
    // Get a reference to a new file array item.
    $file = &$files[];
    // Copy the full size image.
    $file['source'] = $photo->image;
    $file['destination'] = $context['sandbox']['pptodrupal_files_dir'] . '/' . $photo->cat . '/' . $photo->filename;

    // If resizedexist is 0 only the full sized image exists.
    if (!$photo->resizedexist) {
      continue;
    }
    foreach (array('thumbs', 'medium', 'mini') as $image_type) {
      $file = &$files[];
      $file['source'] = $photo->{$image_type};
      $file['destination'] = $context['sandbox']['pptodrupal_files_dir'] . '/' . $photo->cat . '/' . $image_type . '/' . $photo->filename;
    }
  }

  vbimportapi_multi_copy($files);
}

/**
 * Helper function that imports Photopost data to Drupal.
 */
function pptodrupal_file_managed_photos_import(&$context) {
  $context['query_insert'] = db_insert('file_managed')
    ->fields(array('filesize', 'timestamp', 'status', 'uid', 'fid', 'filename', 'uri', 'filemime'));

  $filepath = file_default_scheme() . '://' . PPTODRUPAL_DIRECTORY . '/';

  $context['query_select'] = db_select('photos', 'p')
    ->fields('p', array('filesize', 'date', 'approved'))
    ->fields('ul', array('drupal_uid'));
  $context['query_select']->join('pptodrupal_users_linker', 'ul', 'p.userid = ul.photopost_userid');
  $context['query_select']->addMetaData('import_into_tables', array('ul'));
  $context['query_select']->addExpression('p.id+:add_to_ids', 'fid', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
  $context['query_select']->addExpression("CONCAT((p.id+:add_to_ids), '_', p.bigimage)", 'filename', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
  $context['query_select']->addExpression("CONCAT(:filepath, p.cat, '/', (p.id+:add_to_ids), '_', p.bigimage)", 'uri', array(':filepath' => $filepath, ':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
  $context['query_select']->addExpression("'vbimportapi'", 'filemime');
}

/**
 * Create a file usage record to show which nodes a file is used by.
 */
function pptodrupal_file_usage_photos_import(&$context) {
  $context['message'] = t('Recording file usage records.');

  $context['query_insert'] = db_insert('file_usage')
    ->fields(array('fid', 'module', 'type', 'id', 'count'));

  $context['query_select'] = db_select('photos', 'p');
  $context['query_select']->join('pptodrupal_users_linker', 'ul', 'p.userid = ul.photopost_userid');
  $context['query_select']->addMetaData('import_into_tables', array('ul'));
  $context['query_select']->addExpression('p.id+:add_to_ids', 'fid', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
  $context['query_select']->addExpression("'file'", 'module');
  $context['query_select']->addExpression("'node'", 'type');
  $context['query_select']->addExpression('p.id+:add_to_ids', 'id', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
  $context['query_select']->addExpression(1, 'count');
}

/**
 * Creates nodes for photos.
 */
function pptodrupal_photo_nodes_import(&$context) {
  $context['message'] = t('Creating nodes (part one of two).');

  // Get the node type defaults.
  $node = new stdClass();
  $node->type = PPTODRUPAL_CONTENT_TYPE;
  node_object_prepare($node);

  $context['query_insert'] = db_insert('node')
    ->fields(array('uid', 'status', 'created', 'changed', 'comment', 'nid', 'vid', 'type', 'language', 'title', 'promote', 'sticky'));

  $context['query_select'] = db_select('photos', 'p')
    ->fields('ul', array('drupal_uid'))
    ->fields('p', array('approved', 'date', 'date', 'allowcoms'));

  $context['query_select']->join('pptodrupal_users_linker', 'ul', 'p.userid = ul.photopost_userid');
  $context['query_select']->addMetaData('import_into_tables', array('ul'));
  $context['query_select']->addExpression('p.id+:add_to_ids', 'nid', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS)); 
  $context['query_select']->addExpression('p.id+:add_to_ids', 'vid', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS)); 
  $context['query_select']->addExpression(':node_type', 'type', array(':node_type' => $node->type));
  $context['query_select']->addExpression("'und'", 'language');
  $context['query_select']->addExpression("REPLACE(REPLACE(REPLACE(REPLACE(p.title, '&amp;', '&'), '&quot;', '\"'), '&lt;', '<'), '&gt;', '>')", 'title');
  $context['query_select']->addExpression(':promote', 'promote', array(':promote' => $node->promote));
  $context['query_select']->addExpression(':sticky', 'sticky', array(':sticky' => $node->sticky));
}

/**
 * Create node revisions.
 */
function pptodrupal_photo_node_revision_import(&$context) {
  $context['message'] = t('Creating nodes (part two of two).');

  // Get the node type defaults.
  $node = new stdClass();
  $node->type = PPTODRUPAL_CONTENT_TYPE;
  node_object_prepare($node);

  $context['query_insert'] = db_insert('node_revision')
    ->fields(array('uid', 'timestamp', 'comment', 'nid', 'vid', 'title', 'log', 'promote', 'sticky'));

  $context['query_select'] = db_select('photos', 'p')
    ->fields('ul', array('drupal_uid'))
    ->fields('p', array('date', 'allowcoms'));

  $context['query_select']->join('pptodrupal_users_linker', 'ul', 'p.userid = ul.photopost_userid');
  $context['query_select']->addMetaData('import_into_tables', array('ul'));
  $context['query_select']->addExpression('p.id+:add_to_ids', 'nid', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS)); 
  $context['query_select']->addExpression('p.id+:add_to_ids', 'vid', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS)); 
  $context['query_select']->addExpression("REPLACE(REPLACE(REPLACE(REPLACE(p.title, '&amp;', '&'), '&quot;', '\"'), '&lt;', '<'), '&gt;', '>')", 'title');
  $context['query_select']->addExpression(':log', 'log', array(':log' => ''));
  $context['query_select']->addExpression(':promote', 'promote', array(':promote' => $node->promote));
  $context['query_select']->addExpression(':sticky', 'sticky', array(':sticky' => $node->sticky));
}

/**
 * Import photo node body field.
 */
function pptodrupal_field_data_body_photos_import(&$context) {
  $context['message'] = t('Importing photo descriptions.');

  _pptodrupal_field_body_photos_import_helper('field_data_body', $context);
}

/**
 * Import photo node body field revisions.
 */
function pptodrupal_field_revision_body_photos_import(&$context) {
  $context['message'] = t('Importing photo description revisions.');

  _pptodrupal_field_body_photos_import_helper('field_revision_body', $context);
}

/**
 * Helper to construct node body field data/revision import queries.
 */
function _pptodrupal_field_body_photos_import_helper($table, &$context) {
  $context['query_insert'] = db_insert($table)
    ->fields(array('body_value', 'entity_type', 'bundle', 'entity_id', 'revision_id', 'language', 'delta'));

  $context['query_select'] = db_select('photos', 'p');
  $context['query_select']->addExpression("REPLACE(REPLACE(REPLACE(REPLACE(description, '&amp;', '&'), '&quot;', '\"'), '&lt;', '<'), '&gt;', '>')");
  $context['query_select']->addExpression("'node'", 'entity_type');
  $context['query_select']->addExpression(':type', 'bundle', array(':type' => PPTODRUPAL_CONTENT_TYPE));
  $context['query_select']->addExpression('p.id+:add_to_ids', 'entity_id', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
  $context['query_select']->addExpression('p.id+:add_to_ids', 'revision_id', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
  $context['query_select']->addExpression("'und'", 'language');
  $context['query_select']->addExpression(0, 'delta');
}

/**
 * Import photo file field data.
 */
function pptodrupal_field_data_pptodrupal_photo_import(&$context) {
  $context['message'] = t('Importing photo field.');

  _pptodrupal_field_pptodrupal_photo_import_helper('field_data_pptodrupal_photo', $context);
}

/**
 * Import photo file field revisions.
 */
function pptodrupal_field_revision_pptodrupal_photo_import(&$context) {
  $context['message'] = t('Importing photo revisions.');

  _pptodrupal_field_pptodrupal_photo_import_helper('field_revision_pptodrupal_photo', $context);
}

/**
 * Helper to construct photo field data/revision import queries.
 */
function _pptodrupal_field_pptodrupal_photo_import_helper($table, &$context) {
  $context['query_insert'] = db_insert($table)
    ->fields(array('entity_type', 'bundle', 'entity_id', 'revision_id', 'language', 'delta', PPTODRUPAL_PHOTO_FIELD . '_fid', PPTODRUPAL_PHOTO_FIELD . '_alt'));

  $context['query_select'] = db_select('photos', 'p');
  $context['query_select']->addExpression("'node'", 'entity_type');
  $context['query_select']->addExpression(':type', 'bundle', array(':type' => PPTODRUPAL_CONTENT_TYPE));
  $context['query_select']->addExpression('p.id+:add_to_ids', 'entity_id', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
  $context['query_select']->addExpression('p.id+:add_to_ids', 'revision_id', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
  $context['query_select']->addExpression("'und'", 'language');
  $context['query_select']->addExpression('p.id', 'delta');
  $context['query_select']->addExpression('p.id+:add_to_ids', PPTODRUPAL_PHOTO_FIELD . '_fid', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
  $context['query_select']->addExpression("REPLACE(REPLACE(REPLACE(REPLACE(p.title, '&amp;', '&'), '&quot;', '\"'), '&lt;', '<'), '&gt;', '>')", PPTODRUPAL_PHOTO_FIELD . '_alt');
}

/**
 * Import taxonomy field data from Photopost categories.
 */
function pptodrupal_field_data_taxonomy_pptodrupal_categories_import(&$context) {
  $context['message'] = t('Importing category fields.');

  _pptodrupal_field_taxonomy_pptodrupal_categories_import_helper('field_data_taxonomy_' . PPTODRUPAL_CATEGORIES_VOCABULARY, $context);
}

/**
 * Import taxonomy field revisions from Photopost categories.
 */
function pptodrupal_field_revision_taxonomy_pptodrupal_categories_import(&$context) {
  $context['message'] = t('Importing category field revisions.');

  _pptodrupal_field_taxonomy_pptodrupal_categories_import_helper('field_revision_taxonomy_' . PPTODRUPAL_CATEGORIES_VOCABULARY, $context);
}

/**
 * Helper to construct category/keyword taxonomy field data/revision import queries.
 */
function _pptodrupal_field_taxonomy_pptodrupal_categories_import_helper($table, &$context) {
  $context['query_insert'] = db_insert($table)
    ->fields(array('entity_type', 'bundle', 'entity_id', 'revision_id', 'language', 'delta', 'taxonomy_' . PPTODRUPAL_CATEGORIES_VOCABULARY . '_tid'));

  $context['query_select'] = db_select('photos', 'p');
  $context['query_select']->addExpression("'node'", 'entity_type');
  $context['query_select']->addExpression(':type', 'bundle', array(':type' => PPTODRUPAL_CONTENT_TYPE));
  $context['query_select']->addExpression('p.id+:add_to_ids', 'entity_id', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
  $context['query_select']->addExpression('p.id+:add_to_ids', 'revision_id', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
  $context['query_select']->addExpression("'und'", 'language');
  $context['query_select']->addExpression('p.id', 'delta');
  $context['query_select']->addExpression('p.cat+:add_to_ids', 'taxonomy_' . PPTODRUPAL_CATEGORIES_VOCABULARY . '_tid', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
}

/**
 * Import 'extra' field data.
 */
function pptodrupal_field_data_pptodrupal_extra_import(&$context) {
  $context['message'] = t('Importing extra field data.');

  if (!isset($context['results']['extra_field_delta'])) {
    $context['results']['extra_field_delta'] = 1;
  }

  _pptodrupal_field_pptodrupal_extra_import_helper('field_data_' . PPTODRUPAL_EXTRA_FIELD . $context['results']['extra_field_delta'], $context['results']['extra_field_delta'], $context);
  $context['results']['extra_field_delta']++;
}

/**
 * Import 'extra' field revisions.
 */
function pptodrupal_field_revision_pptodrupal_extra_import(&$context) {
  $context['message'] = t('Importing extra field revisions.');

  if (!isset($context['results']['extra_revision_delta'])) {
    $context['results']['extra_revision_delta'] = 1;
  }

  _pptodrupal_field_pptodrupal_extra_import_helper('field_revision_' . PPTODRUPAL_EXTRA_FIELD . $context['results']['extra_revision_delta'], $context['results']['extra_revision_delta'], $context);
  $context['results']['extra_revision_delta']++;
}

/**
 * Helper to construct category/keyword taxonomy field data/revision import queries.
 */
function _pptodrupal_field_pptodrupal_extra_import_helper($table, $delta, &$context) {
  $populated_extras = variable_get('pptodrupal_populated_extras', array());
  if (empty($populated_extras[$delta])) {
    return;
  }

  $value_field = PPTODRUPAL_EXTRA_FIELD . $delta .  '_value';
  $context['query_insert'] = db_insert($table)
    ->fields(array('entity_type', 'bundle', 'entity_id', 'revision_id', 'language', 'delta', $value_field));

  $context['query_select'] = db_select('photos', 'p');
  $context['query_select']->addExpression("'node'", 'entity_type');
  $context['query_select']->addExpression(':type', 'bundle', array(':type' => PPTODRUPAL_CONTENT_TYPE));
  $context['query_select']->addExpression('p.id+:add_to_ids', 'entity_id', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
  $context['query_select']->addExpression('p.id+:add_to_ids', 'revision_id', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
  $context['query_select']->addExpression("'und'", 'language');
  $context['query_select']->addExpression('p.id', 'delta');
  $context['query_select']->addExpression("REPLACE(REPLACE(REPLACE(REPLACE(extra" . $delta . ", '&amp;', '&'), '&quot;', '\"'), '&lt;', '<'), '&gt;', '>')", $value_field);
}

/**
 * Import taxonomy terms.
 */
function pptodrupal_taxonomy_term_import(&$context) {
  $context['message'] = t('Importing categories (part one of four).');
  if ($context['sandbox']['progress'] == 0) {
    // The first category id, plus the number added to imported ids, is the
    // minimum insert id of imported categories from Photopost. This is saved so
    // the entries in taxonomy tables may be deleted later.
    $result = db_select('categories', 'c')
      ->addTag('vbimport');
    $result->addExpression('MIN(c.id)+:add_to_ids', 'min', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
    $result->addExpression('MAX(c.id)+:add_to_ids', 'max', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
    $category_bounds = $result->execute()->fetchAssoc();
    variable_set('pptodrupal_categories_id_min', $category_bounds['min']);
    variable_set('pptodrupal_categories_id_max', $category_bounds['max']);
  }

  $vocabulary = taxonomy_vocabulary_machine_name_load(PPTODRUPAL_CATEGORIES_VOCABULARY);

  $context['query_insert'] = db_insert('taxonomy_term_data')
    ->fields(array('name', 'description', 'weight', 'tid', 'vid'));

  $context['query_select'] = db_select('categories', 'c')
    ->fields('c', array('catname', 'description', 'catorder'));

  $context['query_select']->addExpression('c.id+:add_to_ids', 'tid', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS)); 
  $context['query_select']->addExpression(':vid', 'vid', array(':vid' => $vocabulary->vid));
}

/**
 * Attach child categories to parents.
 */
function pptodrupal_taxonomy_hierarchy_children_import(&$context) {
  $context['message'] = t('Importing categories (part two of four).');

  $result = db_select('categories', 'c')
    ->addTag('vbimport')
    ->fields('c', array('children'))
    ->where("c.children <> ''");
  $result->addField('c', 'id', 'parent');

  $context['query_select'] = clone $result;

  $result->range($context['sandbox']['progress'], $context['sandbox']['records_per_pass']);
  $categories = $result->execute();

  $child_insert = db_insert('taxonomy_term_hierarchy')
    ->fields(array('tid', 'parent'));

  foreach ($categories as $category) {
    $children = explode(',', $category->children);
    foreach ($children as $child) {
      $values = array(
        'tid' => $child + PPTODRUPAL_ADD_TO_IDS,
        'parent' => $category->parent + PPTODRUPAL_ADD_TO_IDS,
      );
      $child_insert->values($values);
    }
  }

  // It's possible the insert query will not have any values, not a problem.
  // @see: InsertQuery::preExecute()
  $child_insert->execute();
}

/**
 * Import categories with no parents.
 */
function pptodrupal_taxonomy_hierarchy_top_level_import(&$context) {
  $context['message'] = t('Importing categories (part three of four).');

  $context['query_insert'] = db_insert('taxonomy_term_hierarchy')
    ->fields(array('tid', 'parent'));

  $context['query_select'] = db_select('categories', 'c')
    ->addMetaData('import_into_tables', array('tth'))
    ->isNull('tth.tid');

  $context['query_select']->leftJoin('taxonomy_term_hierarchy', 'tth', 'c.id+:add_to_ids = tth.tid', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
  $context['query_select']->addExpression('c.id+:add_to_ids', 'tid', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS)); 
  $context['query_select']->addExpression(0, 'parent');
}

/**
 * Attach photos to taxonomy.
 */
function pptodrupal_taxonomy_index_import(&$context) {
  $context['message'] = t('Importing categories (part four of four).');

  // Get the node type's default settings.
  $node = new stdClass();
  $node->type = PPTODRUPAL_CONTENT_TYPE;
  node_object_prepare($node);

  $context['query_insert'] = db_insert('taxonomy_index')
    ->fields(array('nid', 'tid', 'sticky', 'created'));

  $context['query_select'] = db_select('photos', 'p');

  $context['query_select']->addExpression('p.id+:add_to_ids', 'nid', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS)); 
  $context['query_select']->addExpression('p.cat+:add_to_ids', 'tid', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS)); 
  $context['query_select']->addExpression($node->sticky, 'sticky');
  $context['query_select']->addExpression('p.date', 'created');
}

/**
 * Import keywords for each photo into a freetagging taxonomy.
 */
function pptodrupal_keywords_taxonomy_term_import(&$context) {
  $context['message'] = t('Importing keywords (part one of five).');

  $vocabulary = taxonomy_vocabulary_machine_name_load(PPTODRUPAL_KEYWORDS_TAXONOMY);
  $keywords_query = db_select('photos', 'p')
    ->addTag('vbimport')
    ->fields('p', array('keywords'));
  $keywords_query->addExpression('p.id+:add_to_ids', 'id', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));

  $context['query_select'] = clone $keywords_query;

  $keywords_query->range($context['sandbox']['progress'], $context['sandbox']['records_per_pass']);
  $keywords = $keywords_query->execute();

  $term_data_insert = db_insert('taxonomy_term_data')
    ->fields(array('name', 'tid', 'vid'));

  // This becomes a field.
  $tid_field = 'taxonomy_' . PPTODRUPAL_KEYWORDS_TAXONOMY . '_tid';
  $field_data_insert = db_insert('field_data_taxonomy_' . PPTODRUPAL_KEYWORDS_TAXONOMY)
    ->fields(array('entity_type', 'bundle', 'entity_id', 'revision_id', 'language', 'delta', $tid_field));

  $field_revision_insert = db_insert('field_revision_taxonomy_' . PPTODRUPAL_KEYWORDS_TAXONOMY)
    ->fields(array('entity_type', 'bundle', 'entity_id', 'revision_id', 'language', 'delta', $tid_field));

  // The imported keywords don't have tids, so we track our own.
  $result = db_select('taxonomy_term_data', 'td');
  $result->addExpression('MAX(td.tid)', 'max_tid');
  $current_tid = $result->execute()->fetchField();

  foreach ($keywords as $photo) {
    $children = explode(' ', $photo->keywords);
    $delta = 0;
    foreach ($children as $child) {
      $current_tid++;
      $child = trim(html_entity_decode($child));
      $term_data_insert->values(array(
        'name' => $child,
        'tid' => $current_tid,
        'vid' => $vocabulary->vid,
      ));

      $values = array(
        'entity_type' => 'node',
        'bundle' => PPTODRUPAL_CONTENT_TYPE,
        'entity_id' => $photo->id,
        'revision_id' => $photo->id,
        'language' => 'und',
        'delta' => $delta++,
        $tid_field => $current_tid,
      );
      $field_data_insert->values($values);
      $field_revision_insert->values($values);
    }
  }
  $term_data_insert->execute();
  $field_data_insert->execute();
  $field_revision_insert->execute();
}

/**
 * Delete previously imported junk taxonomy terms.
 */
function pptodrupal_keywords_taxonomy_junk_term_import(&$context) {
  $context['message'] = t('Importing keywords (part two of five).');

  // Get and cache array of query objects that will be run one per time this
  // function is called.
  $queries = &drupal_static(__FUNCTION__);
  if (!isset($queries)) {
    $queries = _pptodrupal_populate_junk_term_queries();
  }

  if ($context['sandbox']['progress'] == 0) {
    $context['sandbox']['max'] = count($queries) - 1;
  }

  // Execute the current query.
  $queries[$context['sandbox']['progress']]->execute();

  // Clean up after last query has been run.
  if ($context['sandbox']['progress'] == $context['sandbox']['max']) {
    unset($queries);
  }
}

/**
 * Populates array of queries for deleting junk keywords.
 */
function _pptodrupal_populate_junk_term_queries() {
  $queries = array();
  $vocabulary = taxonomy_vocabulary_machine_name_load(PPTODRUPAL_KEYWORDS_TAXONOMY);
  $ignore_words = array(
    'a',
    'an',
    'as',
    'at',
    'before',
    'but',
    'by',
    'for',
    'from',
    'is',
    'in',
    'into',
    'like',
    'of',
    'off',
    'on',
    'onto',
    'per',
    'since',
    'than',
    'the',
    'this',
    'that',
    'to',
    'up',
    'via',
    'with',
    '-',
    ' ',
    '!',
    '&',
    '.',
    ',',
    '/',
    '?',
    '@',
    '+',
    '--',
  );

  $t = 'taxonomy_term_data';

  $queries[] = db_update($t)
    ->expression('name', "REPLACE(name, '\"', '')");
  $queries[] = db_update($t)
    ->expression('name', "REPLACE(REPLACE(name, '(', ''), ')', '')");
  $queries[] = db_update($t)
    ->expression('name', "REPLACE(name, '\'', '')");
  $queries[] = db_update($t)
    ->expression('name', "REPLACE(name, ',', '')");
  $queries[] = db_update($t)
    ->expression('name', "REPLACE(name, '.', '')");

  // Every query has the same constraint on its vocabulary.
  foreach ($queries as &$query) {
    $query->condition('vid', $vocabulary->vid);
  }

  $subselect = db_select($t, 'td')
    ->fields('td', array('tid'))
    ->addTag('vbimport')
    ->addMetaData('import_into_tables', array('td'))
    ->condition(db_or()->condition('td.name', '')->condition('td.name', $ignore_words))
    ->condition('vid', $vocabulary->vid);

  // Hack due to hook_query_alter() not being called when query cast as string.
  vbimportapi_query_vbimport_alter($subselect);

  $queries[] = db_delete('taxonomy_index')
    ->condition('tid', $subselect, 'IN');

  $queries[] = db_delete('field_data_taxonomy_' . PPTODRUPAL_KEYWORDS_TAXONOMY)
    ->condition('taxonomy_' . PPTODRUPAL_KEYWORDS_TAXONOMY . '_tid', $subselect, 'IN');
  $queries[] = db_delete('field_revision_taxonomy_' . PPTODRUPAL_KEYWORDS_TAXONOMY)
    ->condition('taxonomy_' . PPTODRUPAL_KEYWORDS_TAXONOMY . '_tid', $subselect, 'IN');

  $queries[] = db_delete($t)
    ->condition('vid', $vocabulary->vid)
    ->condition(db_or()->condition('name', '')->condition('name', $ignore_words));

  return $queries;
}

/**
 * Merge duplicate, previously imported taxonomy terms (keywords).
 */
function pptodrupal_keywords_merge_import($function, $records_per_pass, $importer_module, $sub_module, &$context) {
  $context['message'] = t('Importing keywords (part four of five).');
  $keywords_vocabulary = taxonomy_vocabulary_machine_name_load(PPTODRUPAL_KEYWORDS_TAXONOMY);

  vbimportapi_taxonomy_merge_duplicates($keywords_vocabulary->vid, ceil(VBIMPORTAPI_RECORDS_PER_PASS / 100), PPTODRUPAL_KEYWORDS_TAXONOMY, 'pptodrupal', $context);
}

/**
 * Keyword hierarchy import.
 */
function pptodrupal_keywords_hierarchy_import(&$context) {
  $context['message'] = t('Importing keywords (part five of five).');
  $vocabulary = taxonomy_vocabulary_machine_name_load(PPTODRUPAL_KEYWORDS_TAXONOMY);

  $context['query_insert'] = db_insert('taxonomy_term_hierarchy')
    ->fields(array('tid', 'parent'));

  $context['query_select'] = db_select('taxonomy_term_data', 'td')
    ->addMetaData('import_into_tables', array('td'))
    ->condition('vid', $vocabulary->vid)
    ->fields('td', array('tid'));

  $context['query_select']->addExpression(0, 'parent');
  $context['query_select']->leftJoin('taxonomy_term_hierarchy', 'tth', 'td.tid = tth.tid');
  $context['query_select']->isNull('tth.tid');
}

/**
 * Import comments.
 */
function pptodrupal_comments_import(&$context) {
  $context['message'] = t('Importing comments.');
  if ($context['sandbox']['progress'] == 0) {
    // The first comment id, plus the number added to imported ids, is the
    // minimum insert id of imported comments from Photopost. This is saved so
    // the entries in {comments} may be deleted later.
    $result = db_select('comments', 'c')
      ->addTag('vbimport');
    $result->addExpression('MIN(c.id)+:add_to_ids', 'min', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
    $result->addExpression('MAX(c.id)+:add_to_ids', 'max', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
    $comments_bounds = $result->execute()->fetchAssoc();
    variable_set('pptodrupal_comments_id_min', $comments_bounds['min']);
    variable_set('pptodrupal_comments_id_max', $comments_bounds['max']);
  }

  $context['query_insert'] = db_insert('comment')
    ->fields(array('mail', 'hostname', 'changed', 'created', 'name', 'uid', 'cid', 'pid', 'nid', 'subject', 'status', 'thread', 'language'));

  $context['query_select'] = db_select('comments', 'c')
    ->fields('u', array('mail'))
    ->fields('c', array('ipaddress', 'date', 'date', 'username'));

  $context['query_select']->leftJoin('pptodrupal_users_linker', 'ul', 'c.userid = ul.photopost_userid');
  $context['query_select']->leftJoin('users', 'u', 'ul.drupal_uid = u.uid');
  $context['query_select']->addMetaData('import_into_tables', array('ul', 'u'));
  $context['query_select']->addExpression('COALESCE(ul.drupal_uid, 0)', 'uid');
  $context['query_select']->addExpression('c.id+:add_to_ids', 'cid', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS)); 
  $context['query_select']->addExpression(0, 'pid');
  $context['query_select']->addExpression('c.photo+:add_to_ids', 'nid', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS)); 
  $subject_length = vbimportapi_target_db_column_length('subject', 'comment');
  $context['query_select']->addExpression("REPLACE(REPLACE(REPLACE(REPLACE(SUBSTRING(c.comment FROM 1 FOR $subject_length), '&amp;', '&'), '&quot;', '\"'), '&lt;', '<'), '&gt;', '>')", 'subject');
  $context['query_select']->addExpression('IF(c.approved = 1, :comment_published, :comment_not_published)', 'status', array(':comment_published' => COMMENT_PUBLISHED, ':comment_not_published' => COMMENT_NOT_PUBLISHED));
  $context['query_select']->addExpression("''", 'thread');
  $context['query_select']->addExpression(':und', 'language', array(':und' => 'und'));
}


/**
 * Import comment body field.
 */
function pptodrupal_field_data_comment_body_import(&$context) {
  $context['message'] = t('Importing photo comment body fields.');

  _pptodrupal_comment_body_field_import_helper('field_data_comment_body', $context);
}

/**
 * Import comment body revisions.
 */
function pptodrupal_field_revision_comment_body_import(&$context) {
  $context['message'] = t('Importing photo comment body field revisions.');

  _pptodrupal_comment_body_field_import_helper('field_revision_comment_body', $context);
}

/**
 * Helper to construct comment body field data/revision import query.
 */
function _pptodrupal_comment_body_field_import_helper($table, &$context) {
  $context['query_insert'] = db_insert($table)
    ->fields(array('entity_type', 'bundle', 'entity_id', 'revision_id', 'language', 'delta', 'comment_body_value'));

  $context['query_select'] = db_select('comments', 'c');
  $context['query_select']->addExpression("'comment'", 'entity_type');
  $context['query_select']->addExpression("'comment_node_photopost'", 'bundle');
  $context['query_select']->addExpression('c.id+:add_to_ids', 'entity_id', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
  $context['query_select']->addExpression('c.id+:add_to_ids', 'revision_id', array(':add_to_ids' => PPTODRUPAL_ADD_TO_IDS));
  $context['query_select']->addExpression("'und'", 'language');
  $context['query_select']->addExpression(0, 'delta');
  $context['query_select']->addExpression("REPLACE(REPLACE(REPLACE(REPLACE(c.comment, '&amp;', '&'), '&quot;', '\"'), '&lt;', '<'), '&gt;', '>')", 'comment_body_value');
  // comment_body_format intentionally left out for now, could put the
  // the result of filter_fallback_format() in here, but forum posts
  // in plaintext are useless. Can't use the default format, either.
}

/**
 * Recreate a folder structure.
 */
function _pptodrupal_copy_dir_structure($source, $destination) {
  if (!is_dir($source)) {
    return;
  }

  @mkdir($destination);
  if (!is_writeable($destination)) {
    @chmod($directory, 0775);
  }
  $directory = dir($source);
  while (FALSE !== ($entry = $directory->read())) {
    if ($entry == '.' || $entry == '..') {
      continue;
    }

    $file = $source . '/' . $entry;
    if (is_dir($file)) {
      _pptodrupal_copy_dir_structure($file, $destination . '/' . $entry);
    }
  }
}

/**
 * Recursively delete a directory.
 */
function _pptodrupal_recursive_rm($path) {
  try {
    $path_iterator = new RecursiveDirectoryIterator($path);
  }
  catch (UnexpectedValueException $e) {
    watchdog('pptodrupal', 'Unable to delete directory imported Photopost photos were being stored in (when deleting a Photopost import).', array(), WATCHDOG_NOTICE);
    return;
  }

  foreach (new RecursiveIteratorIterator($path_iterator, RecursiveIteratorIterator::CHILD_FIRST) as $file) {
    if ($file->isDir()) {
      @rmdir($file->getPathname());
    }
    else {
      @unlink($file->getPathname());
    }
  }
  @rmdir($path);
}
