<?php

/**
 * Invokes an info type hook.
 *
 * @param string $hook
 *   The name of the hook to invoke.
 *
 * @return mixed
 */
function invoke_info_hook($hook) {
  return cache_function_result($hook, function () use ($hook) {
      $result = module_invoke_all($hook);
      drupal_alter($hook, $result);

      return $result;
    });
}

/**
 * Wraps a function with caching.
 *
 * @param string $name
 *   Name of the function.
 * @param closure|string $function
 *   The inner function which calculates the result of the cache.
 * @param mixed $default
 *   Default value for the cache.
 *
 * @return mixed
 */
function cache_function_result($name, $function, $default = NULL) {
  $cache = &drupal_static($name, $default);

  if ($cache === $default) {
    $cache = $function();
  }

  return $cache;
}

/**
 * Wraps a function with database and static caching.
 *
 * @param string $name
 *   Name of the caller function.
 * @param closure|string $function
 *   The inner function which calculates the result of the cache.
 * @param mixed $default
 *   The default value for the cache.
 * @param string $bin
 *   The name of the cache bin.
 *
 * @return mixed
 */
function pernament_cache_function_result($name, $function, $default = NULL, $bin = 'cache') {
  $cache = &drupal_static($name, $default);

  if ($cache === $default) {
    $dbcache = cache_get($name, $bin);

    if ($dbcache) {
      $cache = $dbcache->data;
    }
    else {
      $cache = $function();
      cache_set($name, $cache, $bin);
    }
  }

  return $cache;
}

/**
 * Wraps a function with array-type caching.
 *
 * @param string $name
 *   Name of the function.
 * @param string $key
 *   Key of the data. If the key does not exists in the internal array,
 *   then $function will run, and the return value will be stored.
 * @param closure|string $function
 *   The inner function which calculates the result of the cache for a given
 *   $key. The function gets only one parameter, the full cache.
 *
 * @return mixed
 */
function cache_function_array_result($name, $key, $function) {
  $cache = &drupal_static($name, array());

  if (empty($cache[$key])) {
    $cache[$key] = $function($cache);
  }

  return $cache[$key];
}

/**
 * Converts a list of object into a list of extracted object properties.
 *
 * @param string $property
 *   Name of the property to extract.
 * @param array $array
 *   List of objects.
 *
 * @return array
 *   A list of $property object properties in $array.
 */
function map_object_property($property, $array) {
  $args = func_get_args();
  $args[0] = extract_object_property($property);

  return call_user_func_array('array_map', $args);
}

/**
 * Helper function for array_map().
 *
 * @param string $property
 *   Name of the property to use.
 *
 * @return closure
 *   A generated function which returns a certain property of an object.
 */
function extract_object_property($property) {
  return function ($item) use ($property) {
    return $item->{$property};
  };
}

/**
 * Converts a list of associative arrays into a list of associative array
 * values.
 *
 * @param string $key
 *   Key of an associative array to extract.
 * @param array $array
 *   List of associative arrays.
 *
 * @return array
 *   A list of $key associative array values in $array.
 */
function map_array_key($key, $array) {
  $args = func_get_args();
  $args[0] = extract_array_key($key);

  return call_user_func_array('array_map', $args);
}

/**
 * Helper function for array_map().
 *
 * @param string $key
 *   Name of the key to use.
 *
 * @return closure
 *   A generated function which returns a certain value of an associative
 *   array.
 */
function extract_array_key($key) {
  return function ($item) use ($key) {
    return $item[$key];
  };
}

/**
 * Executes a function N times.
 *
 * @param int $n
 *   Times to execute the function.
 * @param closure $func
 *   Function to execute.
 *
 * @return void
 */
function times($n, $func) {
  for ($i = 0; $i < $n; ++$i) {
    $func($i);
  }
}

/**
 * Executes a function N times and collect the return values.
 *
 * @param $n
 *   Times to execute the function.
 * @param $func
 *   Function to execute.
 *
 * @return array
 *   Collected result.
 */
function times_map($n, $func) {
  $ret = array();

  for ($i = 0; $i < $n; ++$i) {
    $ret[] = $func($i);
  }

  return $ret;
}

/**
 * Applies a function on a value by changing it.
 *
 * @param mixed $value
 * @param callable $func
 *
 * @return
 */
function apply(&$value, $func) {
  $value = $func($value);
  return $value;
}

/**
 * Creates a function composition of two functions.
 *
 * Both functions' arity must be 1.
 *
 * @param callable $func0
 *   First function to apply.
 * @param callable $func1
 *   Second function to apply.
 *
 * @return callable
 */
function composite($func0, $func1) {
  return function ($arg) use ($func0, $func1) {
    return $func1($func0($arg));
  };
}

/**
 * Calls a function on each object.
 *
 * @param array $objects
 *   List of objects.
 * @param string $function
 *   Function name to call.
 *
 * Additional arguments will be passed to the called functions.
 *
 * @return array
 */
function call_func_on_multiple_objects($objects, $function) {
  $args = func_get_args();
  array_shift($args);
  array_shift($args);

  return array_map(function ($object) use ($function, $args) {
      return call_user_func_array(array($object, $function), $args);
    }, $objects);
}

/**
 * Calls a function on each class.
 *
 * @param array $classes
 *   List of classes.
 * @param string $function
 *   Function name to call.
 *
 * Additional arguments will be passed to the called functions.
 *
 * @return array
 */
function call_static_func_on_multiple_classes($classes, $function) {
  $args = func_get_args();
  array_shift($args);
  array_shift($args);

  return array_map(function ($class) use ($function, $args) {
      return call_user_func_array(array($class, $function), $args);
    }, $classes);
}

/**
 * Identity function.
 *
 * @param mixed $var
 *
 * @return mixed
 */
function id($var) {
  return $var;
}

/**
 * Returns the first non-null argument.
 *
 * This function works identically as the COALESCE() function in MySQL.
 *
 * @return null|mixed
 */
function coalesce() {
  $args = func_get_args();

  foreach ($args as $arg) {
    if ($arg !== NULL) {
      return $arg;
    }
  }

  return NULL;
}

/**
 * Returns the first item of an array.
 *
 * @param array $array
 *
 * @return mixed
 */
function head($array) {
  return reset($array);
}

/**
 * Returns everything but the first item of an array().
 *
 * @param array $array
 *
 * @return array
 */
function tail($array) {
  array_shift($array);
  return $array;
}

/**
 * A more usable replacement of array_map().
 *
 * @param string|closure $function
 *   A function with two arguments, the first is the array value, the second is
 *   the array key.
 * @param array $array
 *
 * @return
 */
function map($function, $array) {
  foreach ($array as $k => $v) {
    $array[$k] = $function($v, $k);
  }

  return $array;
}

/**
 * Takes a constant and creates a function which repeates it.
 *
 * @param mixed $constant
 *   Constant to repeat.
 *
 * @return closure
 *   A closure, which always returns $constant.
 */
function repeat($constant) {
  return function () use ($constant) {
    return $constant;
  };
}

/**
 * A function which always returns NULL.
 *
 * @return null
 */
function noop() {
  return NULL;
}

/**
 * Returns a dummy reference of a value.
 *
 * @param mixed $value
 *   Value to make a reference from.
 *
 * @return mixed
 *   Reference of the value.
 */
function &reference($value) {
  return $value;
}

/**
 * Calls $function if it is callable.
 *
 * @param callback $function
 *   Function to call.
 *
 * @return mixed|null
 *   Result of the function or NULL, if the function is not callable.
 */
function maybe_call($function) {
  $args = func_get_args();
  return maybe_call_array($function, tail($args));
}

/**
 * Calls $function if it is callable.
 *
 * @param callback $function
 *   Function to call.
 * @param array $arguments
 *   List of arguments.
 *
 * @return mixed|null
 *  Result of the function or NULL, if the function is not callable.
 */
function maybe_call_array($function, $arguments = array()) {
  return is_callable($function) ?
    call_user_func_array($function, $arguments) : NULL;
}

/**
 * Returns an array value for a specified key.
 *
 * @param $array
 *   Source array.
 * @param $key
 *   Key of the requested item.
 *
 * @return mixed|null
 *   Value of $array[$key] if exists, else NULL.
 */
function array_value($array, $key) {
  return isset($array[$key]) ? $array[$key] : NULL;
}

/**
 * Replacement function for uasort().
 *
 * @param array $array
 *   Array to sort.
 * @param callback $comparator
 *   Comparing function.
 *
 * @return array
 *   Sorted array.
 */
function array_sort($array, $comparator) {
  uasort($array, $comparator);
  return $array;
}

/**
 * Flips the arguments of a binary function.
 *
 * @param function $f
 *   Binary function.
 *
 * @return closure
 *   A new function with flipped arguments.
 */
function flip($f) {
  return function ($a, $b) use ($f) {
    return $f($b, $a);
  };
}

/**
 * Removes the first argument of a given function.
 *
 * @param $f
 *   Function which has at least one parameter.
 * @param $p
 *   The fixed first parameter.
 *
 * @return closure
 *   $f with one argument less.
 */
function curry($f, $p) {
  return function () use ($f, $p) {
    $args = func_get_args();
    array_unshift($args, $p);
    return call_user_func_array($f, $args);
  };
}

/**
 * Generates a requirement of a library for hook_requirements().
 *
 * @param string $lib
 *   Name of the library.
 * @param string $label
 *   Human readable name of the library.
 * @param int $severity
 *   Severity if the library is not found. Recommended values:
 *   - REQUIREMENT_ERROR
 *   - REQUIREMENT_WARNING
 *
 * @return array
 */
function generate_library_requirement($lib, $label, $severity = REQUIREMENT_ERROR) {
  $lib_exists = file_exists(module_exists('libraries') ?
      libraries_get_path($lib) :
      base_path() . 'sites/all/libraries/' . $lib);
  return _generate_requirement($lib_exists, $lib, $label, $severity);
}

/**
 * Generates a requirement of a PHP extension for hook_requirements().
 *
 * @param string $extension
 *   Name of the extension.
 * @param string $label
 *   Human readable name of the extension.
 * @param int $severity
 *   Severity if the extension is not found. Recommended values:
 *   - REQUIREMENT_ERROR
 *   - REQUIREMENT_WARNING
 *
 * @return array
 */
function generate_php_extension_requirement($extension, $label, $severity = REQUIREMENT_ERROR) {
  return _generate_requirement(extension_loaded($extension), $extension,
    $label, $severity);
}

/**
 * Universal requirement generator for hook_requirements().
 *
 * @param boolean $exists
 *   Status of the requirement.
 * @param string $name
 *   Name of the requirement.
 * @param string $label
 *   Human readable name of the requirement.
 * @param int $severity
 *   Severity if $exists is FALSE. Recommended values:
 *   - REQUIREMENT_ERROR
 *   - REQUIREMENT_WARNING
 *
 * @return array
 */
function _generate_requirement($exists, $name, $label, $severity = REQUIREMENT_ERROR) {
  $requirements = array();

  $requirements[$name] = array(
    'title' => t($label),
    'value' => $exists ? t('Installed') : t('Missing'),
    'severity' => $exists ? REQUIREMENT_OK : $severity,
  );

  return $requirements;
}
