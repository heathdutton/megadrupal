<?php
/**
 * @file
 * A module to calculate the dependencies for a project.
 */

/**
 * Implements hook_block_info().
 */
function project_dependency_block_info() {
  $blocks['components'] = array(
    'info' => t('Project components'),
    'cache' => DRUPAL_NO_CACHE,
  );
  $blocks['dependencies'] = array(
    'info' => t('Project release dependencies'),
    'cache' => DRUPAL_NO_CACHE,
  );
  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function project_dependency_block_view($delta = '') {
  switch ($delta) {
    case 'components':
      $node = menu_get_object();
      if ($node && $node->nid && $node->type == 'project_release') {
        // You have a valid Project Release node to work with.
        $path = explode('/', current_path());
        if (count($path) == 2) {
          // This is not the edit tab.
          $block['subject'] = t('Components');
          $block['content'] = project_dependency_components($node);
          return $block;
        }
      }
      break;

    case 'dependencies':
      $node = menu_get_object();
      if ($node && $node->nid && $node->type == 'project_release') {
        // You have a valid Project Release node to work with.
        $path = explode('/', current_path());
        if (count($path) == 2 || $path[2] == 'details') {
          // This is not the edit tab.
          $block['subject'] = t('Dependencies');
          $block['content'] = project_dependency_dependencies($node);
          return $block;
        }
      }
      break;
  }
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function project_dependency_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && !empty($plugin) && $plugin == 'content_types') {
    return "plugins/$plugin";
  }
}

/**
 * Return HTML with the project components.
 */
function project_dependency_components($node) {
  $content = '';
  $header = array(
    t('Title'),
    t('Name'),
  );
  /* Remove because do not want to initiate from webserver.
  $count = db_select('project_dependency_component', 'components')
    ->condition('components.release_nid', $node->nid)
    ->fields('components', array('name', 'title'))
    ->countQuery()
    ->execute()
    ->fetchField();
  if ($count == 0) {
    // Reprocess the release.
    module_load_include('inc', 'project_dependency',
      'project_dependency.drupal');
    $node_wrapper = entity_metadata_wrapper('node', $node);
    $pid = $node_wrapper->field_release_project->nid->value();
    $project_wrapper = entity_metadata_wrapper('node', $pid);
    $shortname = $project_wrapper->field_project_machine_name->value();
    $dependencies = project_dependency_process_release($shortname, $node);
    if ($dependencies === FALSE) {
      drupal_set_message(t('Dependency update failed.'), 'error');
    }
    else {
      drupal_set_message(t('Dependencies successfully updated.'));
    }
  }
  */
  $components = db_select('project_dependency_component', 'components')
    ->condition('components.release_nid', $node->nid)
    ->fields('components', array('name', 'title'))
    ->orderBy('components.title')
    ->execute();
  $rows = array();
  foreach ($components as $component) {
    $row = array(
      'data' => array(
        $component->title,
        $component->name,
      ),
    );
    $rows[] = $row;
  }
  $content['table'] = array(
    '#theme' => 'table',
    '#header' => $header,
    '#rows' => $rows,
    '#empty' => t('No entries in the Project Dependency component table for this release.'),
  );
  return $content;
}

/**
 * Return HTML with the project dependencies.
 */
function project_dependency_dependencies($node) {
  $content = '';
  $dependencies
    = project_dependency_get_external_release_dependencies($node->nid);
  $header = array(
    t('Project'),
    t('Selected release'),
  );
  $required_rows = array();
  $optional_rows = array();
  foreach ($dependencies as $dependency) {
    $row = array(
      'data' => array(
        l($dependency['uri'], 'project/' . $dependency['uri']),
        $dependency['version'],
      ),
    );
    if ($dependency['dependency_type'] == 0) {
      $required_rows[] = $row;
    }
    else {
      $optional_rows[] = $row;
    }
  }
  $content .= '<p>' . t('The selected release is the release that will be used for automated testing. Optional projects are used for testing.') . '</p>';
  $content .= '<h4>' . t('Required') . '</h4>';
  $content .= theme('table',
    array(
      'header' => $header,
      'rows' => $required_rows,
      'empty' => t('No required projects'),
    )
  );
  $content .= '<h4>' . t('Optional') . '</h4>';
  $content .= theme('table',
    array(
      'header' => $header,
      'rows' => $optional_rows,
      'empty' => 'No optional projects',
    )
  );
  return $content;
}

/*
 * Constants for the possible values of {project_release_dependency}.dependency_type.
 */
define('PROJECT_DEPENDENCY_DEPENDENCY_REQUIRED', 0);
define('PROJECT_DEPENDENCY_DEPENDENCY_RECOMMENDED', 1);

/**
 * Implements hook_project_release_create_package().
 *
 * When a release node is created, we build the dependencies.
 *
 * @param $project_node
 *   The fully-loaded project node of the related project.
 * @param $release_node
 *   The fully-loaded project release node that has been packaged.
 */
function project_dependency_project_release_create_package($project_node, $release_node) {
  module_load_include('inc', 'project_dependency', 'project_dependency.drupal');
  $wrapper = entity_metadata_wrapper('node', $project_node);
  $shortname = $wrapper->field_project_machine_name->value();
  project_dependency_process_release($shortname, $release_node);
}

/**
 * Loads a component.
 *
 * @param $component_id
 *   Component ID to load.
 *
 * @return
 *   Array of component information.
 */
function project_dependency_component_load($component_id) {
  return db_query('
    SELECT * FROM {project_dependency_component}
    WHERE component_id = :component_id',
    array(':component_id' => $component_id),
    array('fetch' => PDO::FETCH_ASSOC)
  );
}

/**
 * Loads the list of components contained by a project release.
 *
 * @param $release_nid
 *   Project release ID.
 *
 * @return
 *   Associative array of components keyed by component name and containing
 *   array keys: 'name', 'title', 'description'.
 */
function project_dependency_get_components($release_nid) {
  $result = db_query('
    SELECT * FROM {project_dependency_component}
    WHERE release_nid = :release_nid',
    array(':release_nid' => $release_nid),
    array('fetch' => PDO::FETCH_ASSOC)
  );
  $components = array();
  foreach ($result as $component) {
    $components[$component['name']] = $component;
  }
  return $components;
}

/**
 * Gets a list of dependency components for a component.
 *
 * @param $component_id
 *   Component ID to get dependencies for.
 * @param $dependency_type
 *   (Optional) Minimum dependency type, project_dependency_DEPENDENCY_*. All
 *   dependencies of equal or lesser stringency will be included.
 *
 * @return
 *   Associative array of dependencies keyed by component name.
 */
function project_dependency_component_dependencies_load_all($component_id, $dependency_type = PROJECT_DEPENDENCY_DEPENDENCY_REQUIRED) {
  $result = db_query('SELECT c.*
    FROM {project_dependency_dependency} d
    JOIN {project_dependency_component} c
      ON c.component_id = d.component_id
    WHERE c.component_id = :component_id
    AND dependency_type <= :dependency_type',
    array(':component_id' => $component_id, ':dependency_type' => $dependency_type),
    array('fetch' => PDO::FETCH_ASSOC));
  $dependencies = array();
  foreach ($result as $dependency) {
    $dependencies[$dependency['name']] = $dependency;
  }
  return $dependencies;
}

/**
 * Recursively determines the list of dependencies of a release.
 *
 * @param $release_nid
 *   Project release ID.
 * @param $dependency_type
 *   (Optional) Minimum dependency type, project_dependency_DEPENDENCY_*. All
 *   dependencies of equal or lesser stringency will be included.
 *
 * @return
 *   List of dependencies of the release.
 */
function project_dependency_get_dependencies($release_nid, $dependency_type = PROJECT_DEPENDENCY_DEPENDENCY_REQUIRED) {
  $components = project_dependency_get_components($release_nid);
  return _project_dependency_get_component_dependencies($components, $dependency_type);
}

/**
 * Recursively determines the list of dependencies for a list of components.
 *
 * @param array $components
 *   List of components to determine the dependencies for.
 * @param $dependency_type
 *   (Optional) Minimum dependency type, project_dependency_DEPENDENCY_*. All
 *   dependencies of equal or lesser stringency will be included.
 * @param $dependencies
 *   (Internal) Array of already determined dependencies.
 *
 * @return
 *   Associative array of dependencies keyed by component name and containing
 *   all component info keys: 'component_id', 'rid', 'name', 'title', and
 *   'description'.
 */
function _project_dependency_get_component_dependencies(array $components, $dependency_type, array $dependencies = array()) {
  foreach ($components as $component) {
    // Get all dependencies of the component.
    $dependencies_new = project_dependency_component_dependencies_load_all($component['component_id'], $dependency_type);

    // Add the new dependencies to the list of dependencies and remove the
    // dependencies that have already been added.
    foreach ($dependencies_new as $name => $dependency_new) {
      if (!isset($dependencies[$name])) {
        $dependencies[$name] = $dependency_new;
      }
      else {
        unset($dependencies_new[$name]);
      }
    }

    // Process the dependencies of all the new dependency components.
    $dependencies = _project_dependency_get_component_dependencies($dependencies_new, $dependency_type, $dependencies);
  }
  return $dependencies;
}

/**
 * Get an array of release dependencies of a given release nid and optional
 * components in that release nid.
 *
 * The variable project_dependency_excluded_dependencies is an array of
 * project shortnames (uri's) that must be excluded. This is used to
 * exclude the drupal project itself and simpletest contrib module, for
 * example.
 *
 * @param $depending_release_nid
 *   The release nid for which we're looking for dependencies.
 * @param $depending_components
 *   An (optional) array of component names (modules within the release nid).
 *
 * @return
 *   An array keyed by release nids of the dependencies. So:
 *   array($nid => array('version' => $version, 'tag' => $tag), ...)
 */
function project_dependency_get_external_release_dependencies($depending_release_nid, $depending_components = array()) {
  module_load_include('inc', 'project_dependency', 'project_dependency.drupal');
  $excluded_dependencies = variable_get('project_dependency_excluded_dependencies', array('drupal', 'simpletest', 'leftandright'));

  $release_dependencies = array();
  // Exclude the project shortname itself.
  $release_node = node_load($depending_release_nid);
  if (!$release_node) {
    return $release_dependencies;
  }
  $release_wrapper = entity_metadata_wrapper('node', $release_node);
  $pid = $release_wrapper->field_release_project->nid->value();
  $project_node = node_load($pid);
  $project_wrapper = entity_metadata_wrapper('node', $project_node);
  $shortname = $project_wrapper->field_project_machine_name->value();
  $excluded_dependencies[] = $shortname;

  $component_dependencies = array();
  project_dependency_get_external_component_dependencies($release_node,
    $project_node, $depending_components, $component_dependencies);
  foreach ($component_dependencies as $component => $component_info) {
    if (!in_array($component_info['uri'], $excluded_dependencies)) {
      $release_dependencies[$component_info['release_nid']] = array(
        'uri' => $component_info['uri'],
        'version' => $component_info['version'],
        'tag' => $component_info['tag'],
        'dependency_type' => $component_info['dependency_type'],
      );
    }
  }
  return $release_dependencies;
}
