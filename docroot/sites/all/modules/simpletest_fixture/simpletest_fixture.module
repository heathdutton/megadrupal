<?php

/**
 * @file
 * This module provides functionality to generate and employ fixtures
 * for SimpleTest tests.
 */

/**
 * Implements hook_menu().
 */
function simpletest_fixture_menu() {
  $items['admin/config/development/simpletest-fixture'] = array(
    'title' => 'Simpletest fixture settings',
    'description' => 'Settings for the simplest fixture module',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('simpletest_fixture_admin_settings'),
    'access callback' => 'user_access',
    'access arguments' => array('administer unit tests'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'simpletest_fixture.admin.inc',
  );

  return $items;
}

/**
 * Generate new fixture tables
 */
function simpletest_fixture_generate($mode = 'fixtures', $debug = FALSE) {
  /**
   * Write tests
   * - generating fixtures for an empty db
   * - generating fixtures for a populated db
   *   1) mode "fixtures"
   *   2) mode "full"
   */

  /**
   * TODO
   * - split into simpletest_fixtures_clear() + simpletest_fixtures_create()
   * - implement confirmation dialog: do you really want to.. ? y/n
   */


  // a limit of values in a db table
  // if values are > limit -> copying will be split up in several copy statements
  $value_limit = 1000000; // @todo maybe put in admin settings

  // the number of how many values should be copied at once
  $value_interval = 100000; // @todo maybe put in admin settings


  // Rebuild schema based on prefixed database
  $schemas = drupal_get_complete_schema($rebuild = FALSE);

  // Create a list of prefixed source table names
  $sources = array();
  foreach ($schemas as $name => $schema) {
    $sources[$name] = Database::getConnection()->prefixTables('{' . $name . '}');
  }

  // Retrieve the default database name
  $default_connection = Database::getConnectionInfo('default');
  $source_db_name = $default_connection['default']['database'];

  // Retrieve the static prefix parameter stored in the fixture db info in settings.php
  $fixturedb_connection = Database::getConnectionInfo('fixture');
  $fixturedb_prefix = $fixturedb_connection['default']['simpletest_prefix'];

  // Switch to fixture database
  Database::renameConnection('default', 'simpletest_original_default');
  Database::addConnectionInfo('default', 'default', $fixturedb_connection['default']);

  // sort the table schemas for a better overview during debugging
  ksort($schemas);

  // check the schema
  // if the Drupal schema is equal with the real db schema
  simpletest_fixture_check_db_schema($schemas, $source_db_name, $sources, $debug);


  // TODO Check if we're really connected to fixtures db

  // Remove old fixtures tables
  $res = db_query("SHOW TABLES");
  $dropped_tables_count = 0;
  foreach ($res as $table) {
    $table = array_shift(array_values((array)$table));

    // Only drop fixture tables
    if (strpos($table, $fixturedb_prefix) !== FALSE) {
      db_drop_table($table);
      $dropped_tables_count++;
    }
    // Also drop drupal tables in mode "full"
    else if ($mode == 'full') {
      // Keep table 'watchdog' so dblog_watchdog() doesn't complain
      if ($table == 'watchdog') {
        continue;
      }

      db_drop_table($table);
      $dropped_tables_count++;
    }
    // The drupal tables are already there
    else {
      $skip_drupal_db = TRUE;
    }
  }

  // Clone tables from source into fixtures database
  $cloned_tables_count = 0;

  $excludeTables = simpletest_fixture_excluded_tables();
  $excludeTables = array_flip($excludeTables);

  // Clone drupal tables
  if (!isset($skip_drupal_db)) {
    foreach ($schemas as $table => $schema) {
      // Create 'watchdog' only if the entire db gets populated from the first time
      if ($dropped_tables_count > 0 && $table == 'watchdog') {
        continue;
      }

      $target = Database::getConnection()->prefixTables('{' . $table . '}');

      if ($debug) {
        drush_print('----------');
        drush_print('Creating table');
        drush_print('TABLE: ' . $table);
        drush_print('TARGET: ' . $target);
        drush_print('SCHEMA: ' . key($schema));
      }

      db_create_table($target, $schema);

      if (!isset($excludeTables[$table])) {
        $source = $source_db_name .'.'. $sources[$table];

        $split = FALSE;
        $count_check = db_query('SELECT count(*) AS count FROM ' . $source);
        if (!empty($count_check)) {
          foreach ($count_check as $record) {
            if ($debug) {
              drush_print('COUNT: ' . $record->count);
            }
            if ($record->count > $value_limit) {
              if ($debug) {
                drush_print('COUNT is above limit');
              }
              $split = TRUE;
            }

          }
        }

        if ($split) {
          if ($debug) {
            drush_print('Copying will be splitted');
          }

          $i = 0;
          do {

            $from = $i; // start from current i
            $to = $value_interval; // get all values from i to the amount of the value interval, but -1 to avoid duplicate entry

            if ($debug) {
              drush_print('Copying from ' . $source . ' to ' . $target . ' values from '. $from .' to ' . $to);
              drush_print('INSERT INTO ' . $target . ' SELECT * FROM ' . $source . ' LIMIT ' . $from . ',' . $to);
            }
            db_query('INSERT INTO ' . $target . ' SELECT * FROM ' . $source . ' LIMIT ' . $from . ',' . $to);

            $i += $value_interval; // goto next interval

          } while ($i <= $record->count);

        }
        else {
          if ($debug) {
            drush_print('Copying from ' . $source . ' to ' . $target);
          }
          db_query('INSERT INTO ' . $target . ' SELECT * FROM ' . $source);
        }

      }
      else {
        if ($debug) {
          drush_print('Table is excluded. Content will not be copied.');
        }
      }
      $cloned_tables_count++;
    }
  }


  // Create fixture tables
  foreach ($schemas as $table => $schema) {
    $target_prefixed = Database::getConnection()->prefixTables('{' . $fixturedb_prefix . $table . '}');
    if ($debug) {
      drush_print('Creating table ' . $target_prefixed);
    }
    db_create_table($target_prefixed, $schema);
  }

  // Update the database schemas and schema alters
  if ($debug) {
    drush_print('Running updatedb');
  }
  drush_core_updatedb();

  // Copy content into fixture tables
  foreach ($schemas as $table => $schema) {
    $target_prefixed = Database::getConnection()->prefixTables('{' . $fixturedb_prefix . $table . '}');

    if (!isset($excludeTables[$table])) {
      $source = $source_db_name .'.'. $sources[$table];

      if ($debug) {
        drush_print('Copying from ' . $source . ' to ' . $target_prefixed);
      }

      $split = FALSE;
      $count_check = db_query('SELECT count(*) AS count FROM ' . $source);
      if (!empty($count_check)) {
        foreach ($count_check as $record) {
          if ($debug) {
            drush_print('COUNT: ' . $record->count);
          }
          if ($record->count > $value_limit) {
            if ($debug) {
              drush_print('COUNT is above limit');
            }
            $split = TRUE;
          }

        }
      }

      if ($split) {
        if ($debug) {
          drush_print('Copying will be splitted');
        }

        $i = 0;
        do {

          $from = $i; // start from current i
          $to = $value_interval; // get all values from i to the amount of the value interval, but -1 to avoid duplicate entry

          if ($debug) {
            drush_print('Copying from ' . $source . ' to ' . $target_prefixed . ' values from '. $from .' to ' . $to);
            drush_print('INSERT INTO ' . $target_prefixed . ' SELECT * FROM ' . $source . ' LIMIT ' . $from . ',' . $to);
          }

          db_insert($target_prefixed)
            ->from(db_select($source, 's')->fields('s', array_keys($schema['fields']))->range($from, $to))
            ->execute();

          $i += $value_interval; // goto next interval

        } while ($i <= $record->count);

      }
      else {
        if ($debug) {
          drush_print('Copying from ' . $source . ' to ' . $target_prefixed);
        }

        db_insert($target_prefixed)
          ->from(db_select($source, 's')->fields('s', array_keys($schema['fields'])))
          ->execute();
      }

    }
    $cloned_tables_count++;
  }

  // Get back to the original connection.
  Database::removeConnection('default');
  Database::renameConnection('simpletest_original_default', 'default');

  return array(
    'dropped_tables_count' => $dropped_tables_count,
    'cloned_tables_count' => $cloned_tables_count,
  );
}

/**
 * Tables that should be excluded
 * @return array $tables
 */
function simpletest_fixture_excluded_tables() {
  $tables = array();
  module_load_include('inc', 'simpletest_fixture', 'simpletest_fixture.admin');
  $excludeTables = simpletest_fixture_admin_exclude_tables();
  if (!empty($excludeTables)) {
    $tables = array_unique(array_values($excludeTables));
  }
  return $tables;
}

/**
 * Check the schemas
 * if the given Drupal schema is equal with the real db schema
 * and if the order of the columns in the tables are identical
 * @param $schemas
 * @param $source_db_name
 * @param $sources
 * @throws Exception
 */
function simpletest_fixture_check_db_schema(&$schemas, $source_db_name, $sources, $debug) {

  // schema can differ in db from Drupal schema
  if (!empty($schemas)) {
    foreach ($schemas as $table_name => $schema) {

      // check table schema
      $source = $source_db_name .'.'. $sources[$table_name];

      if ($debug) {
        drush_print('----------');
        drush_print('SCHEMA');
        drush_print_r($schema);
      }

      $fields = $schema['fields'];
      $db_schema_order = array();
      $rearrange_schema = FALSE;
      $fields_checked = array();

      $schema_check = db_query('DESC ' . $source);
      $column_cntr = 0;
      if (!empty($schema_check)) {
        foreach ($schema_check as $record) {
          // Try to sanitize what the DESC query has returned

          if (isset($record->field)) {
            $field = $record->field;
          }
          else if (isset($record->Field)) {
            $field = $record->Field;
          }
          else {
            throw new Exception("Missing 'field' property. Can't check table schema of " . $source);
          }

          if (isset($record->type)) {
            $db_type = $record->type;
          }
          else if (isset($record->Type)) {
            $db_type = $record->Type;
          }
          else {
            throw new Exception("Missing 'type' property. Can't check table schema of " . $source);
          }


          // the position of this column in the db table
          $column_cntr++;
          $db_schema_order[$field] = $field;

          if ($debug) {
            drush_print('SCHEMA CHECK RECORD');
            drush_print_r($record);
          }

          if (!empty($fields[$field])) {

            // check the column type
            $check = '';
            $schema_type = $fields[$field]['type'];
            if (!empty($fields[$field]['mysql_type'])) {
              $schema_type = $fields[$field]['mysql_type'];
            }

            // the length value
            $schema_type_length = '';
            if (!empty($fields[$field]['length'])) {
              $schema_type_length = $fields[$field]['length'];
            }
            if (empty($schema_type_length) && ('int' == $schema_type || 'serial' == $schema_type)) {
              // no length given
              // get the number out of the db column info
              preg_match('/(?P<digit>\d+)/', $db_type, $matches);
              if (!empty($matches['digit'])) {
                $schema_type_length = $matches['digit'];
              }
              else {
                throw new Exception('Cannot determine the length of the column type int.');
              }
            }

            switch ($schema_type) {

              case 'varchar':
                $check = 'varchar(' . $schema_type_length . ')';
                break;

              case 'text';
                $check = '';
                if (!empty($fields[$field]['size'])) {
                  switch ($fields[$field]['size']) {
                    case 'big':
                      $check .= 'long';
                      break;
                    case 'medium':
                      $check .= 'medium';
                      break;
                  }
                }
                $check .= 'text';
                break;

              case 'serial':
                $check = 'int(' . $schema_type_length . ')';
                if (!empty($fields[$field]['unsigned'])) {
                  $check .= ' unsigned';
                }
                break;

              case 'int':
                $check = '';
                if (!empty($fields[$field]['size'])) {
                  $check = $fields[$field]['size'];
                }

                $check .= 'int(' . $schema_type_length . ')';
                if (!empty($fields[$field]['unsigned'])) {
                  $check .= ' unsigned';
                }
                break;

              case 'float':
                $check = 'float';
                if (!empty($fields[$field]['size'])) {
                  switch ($fields[$field]['size']) {
                    case 'big':
                      $check = 'double';
                      break;
                  }
                }
                break;

              case 'blob':
                $check = '';
                switch ($fields[$field]['size']) {
                  case 'big':
                    $check = 'long';
                    break;
                }

                $check .= 'blob';
                break;

              case 'char':
                $check = 'char(' . $schema_type_length . ')';
                break;

              case 'datetime':
                $check = 'datetime';
                break;

              default:
                throw new Exception('Unknown schema column type. Has to be added in check');
                break;

            }

            if ($debug) {
              drush_print('CHECK COLUMN STRING: ' . $check);
            }

            if ($db_type != $check) {
              throw new Exception('The column type is different in the db than in the Drupal schema. Table: ' . $table_name . ' - column: ' . $field);
            }

            // check order of the columns
            $field_cntr = 0;
            // run through the schema fields
            foreach ($fields as $field_name => $field_data) {
              $field_cntr++;

              // if the schema field == the db field
              // the counters should be equal, else the order is different
              // if the order is different, the fields in the Drupal schema have to rearranged
              if ($field_name == $field) {
                // the counters should be equal
                if ($field_cntr == $column_cntr) {
                  // they are equal - same order
                }
                else {
                  // they are different, the order in the Drupal schema has to be rearranged
                  $rearrange_schema = TRUE;
                }

              }

            }

            $fields_checked[$field] = $field;

          }
          else {
            throw new Exception('Column ' . $field . ' of table ' . $table_name . ' is in the database but not in the Drupal schema.');
          }

        }
      }

      if ($debug) {
        drush_print('FIELDS CHECKED');
        drush_print_r($fields_checked);
      }

      // check if the amount of columns is equal
      if (count($fields_checked) != count($fields) ) {
        throw new Exception('Number of columns in table ' . $table_name . ' is different');
      }

      // if the order in the schema is different  and has to be rearranged
      $new_schema_fields = array();
      if (!empty($rearrange_schema)) {
        if (!empty($fields_checked)) {
          foreach ($fields_checked as $field_name) {
            $new_schema_fields[$field_name] = $fields[$field_name];
          }
        }
        if (!empty($new_schema_fields)) {
          $schemas[$table_name]['fields'] = $new_schema_fields;
        }

        $rearranged_schema_tables[$table_name] = $table_name;
      }
    }
  }

  if ($debug) {
    drush_print('REARRANGED SCHEMA TABLES');
    drush_print_r($rearranged_schema_tables);
  }
}
