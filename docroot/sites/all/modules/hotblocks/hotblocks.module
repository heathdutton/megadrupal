<?php

require_once('hotblocks.controls.php');
require_once('hotblocks.filter.php');

/***********Define Constants************************/

define('HOTBLOCKS_TITLE_HIDING_START', '(');
define('HOTBLOCKS_TITLE_HIDING_END', ')');
define('HOTBLOCKS_DEFAULT_TERMINOLOGY', 'hotblock item');
define('HOTBLOCKS_DEFAULT_TERMINOLOGY_PLURAL', 'hotblock items');


/***********Drupal Hooks****************************/

/**
 * Load javascript and CSS for admin controls, define some tabledrag settings.
 * Just return if user has no permissions.
 */
function hotblocks_load_files() {
  // Only run this function once per page, even if multiple blocks try to run it.
  static $hasrun = FALSE;
  if ($hasrun) {
    return;
  }

  $path_to_module = drupal_get_path('module', 'hotblocks');

  // Add our javascript and css
  drupal_add_js($path_to_module . '/js/jquery.quicksearch/jquery.quicksearch.js');
  drupal_add_js($path_to_module . '/js/hotblocks.js');
  drupal_add_css($path_to_module . '/css/hotblocks.css');
  drupal_add_js($path_to_module . '/js/hotblocks-controls.js');
  drupal_add_css($path_to_module . '/css/hotblocks-controls.css');
  drupal_add_css($path_to_module . '/css/hotblocks-modal.css');

  // Our table drag - needed here because js won't load when we get our reorder form from an ajax request
  // which does not reload the full page.
  $table_id = 'hotblocks-reorder-table';
  drupal_add_tabledrag($table_id, 'order', 'sibling', 'hotblocks_item-weight');

  // Load the jquery form plugin on every page
  drupal_add_library('system', 'jquery.form', TRUE);
  drupal_add_library('system', 'ui');
  drupal_add_library('system', 'ui.dialog');
  drupal_add_library('system', 'ui.tabs');

  // Set a static var flag that this function has run
  $hasrun = TRUE;
}

/**
 * Implements hook_menu().
 */
function hotblocks_menu() {
  $aItems = array();

  //////// Admin pages /////////////
  $aItems['admin/content/hotblocks'] = array(
    'title' => 'Hotblocks', //hotblocks_terminology(true,true),
    'page callback' => 'hotblocks_overview_by_block',
    'access callback' => 'hotblocks_access',
    'access arguments' => array('administer hotblocks'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'hotblocks.adminpages.inc',
  );
  
  $aItems['admin/content/hotblocks/overview_page'] = array(
    'title' => 'Overview by Page',
    'page callback' => 'hotblocks_overview_by_path',
    'access callback' => 'hotblocks_access',
    'access arguments' => array('administer hotblocks'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'hotblocks.adminpages.inc',
  );
  
  $aItems['admin/content/hotblocks/overview_block'] = array(
    'title' => 'Overview by Block',
    'page callback' => 'hotblocks_overview_by_block',
    'access callback' => 'hotblocks_access',
    'access arguments' => array('administer hotblocks'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'hotblocks.adminpages.inc',
  );

  $aItems['admin/content/hotblocks/overview_taxonomy'] = array(
    'title' => 'Overview by Taxonomy',
    'page callback' => 'hotblocks_taxonomy_page',
    'access callback' => 'hotblocks_access',
    'access arguments' => array('administer hotblocks'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'hotblocks.adminpages.inc',
  );
  
  $aItems['admin/content/hotblocks/create'] = array(
    'title' => 'Create new hotblock content', //  . hotblocks_terminology(),
    'page callback' => 'hotblocks_create_hotblocks_item_page',
    'access callback' => 'hotblocks_access',
    'access arguments' => array('create items in any hotblock'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'hotblocks.adminpages.inc',
  );

  $aItems['admin/config/user-interface/hotblocks'] = array(
    'title' => /*hotblocks_terminology(true,true).*/ 'Hotblocks',
    'description' => t("Add and remove hotblocks, rename hotblock blocks and configure hotblocks settings."),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hotblocks_settings'),
    'access callback' => 'hotblocks_access',
    'access arguments' => array('administer hotblocks'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'hotblocks.admin.inc',
  );
  
  $aItems['admin/config/user-interface/hotblocks/settings'] = $aItems['admin/config/user-interface/hotblocks'];
  $aItems['admin/config/user-interface/hotblocks/settings']['title'] = "Settings";
  $aItems['admin/config/user-interface/hotblocks/settings']['type'] = MENU_DEFAULT_LOCAL_TASK;
  $aItems['admin/config/user-interface/hotblocks/settings']['weight'] = 0;
  
  $aItems['admin/config/user-interface/hotblocks/view-modes'] = array(
    'title' => 'Node View Modes',
    'description' => t("Configure what node view modes to use for each node that can be used as a hotblock."),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hotblocks_settings_view_modes'),
    'access callback' => 'hotblocks_access',
    'access arguments' => array('administer hotblocks'),
    'weight' => 1,
    'type' => MENU_LOCAL_TASK,
    'file' => 'hotblocks.admin.inc',
  );
/*
  // Edit hotblock
  $aItems['admin/structure/hotblocks/%/edit'] = array(
    'title' => 'Edit Hotblock',
    'description' => t("Edit an individual hotblock"),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hotblocks_edit_form', 3),
    'access callback' => 'hotblocks_access',
    'access arguments' => array('administer hotblocks'),
    'type' => MENU_CALLBACK,
    'file' => 'hotblocks.admin.inc',
  );

  // Delete hotblock
  $aItems['admin/structure/hotblocks/%/delete'] = array(
    'title' => 'Edit Hotblock',
    'description' => t("Delete a hotblock"),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('hotblocks_delete_form', 3),
    'access callback' => 'hotblocks_access',
    'access arguments' => array('administer hotblocks'),
    'type' => MENU_CALLBACK,
    'file' => 'hotblocks.admin.inc',
  );*/

  //--//--// Callbacks: //--//--//

  //arg1 - block delta
  $aItems['hotblocks/assign/%'] = array(
    'title' => 'Assign Hotblocks_Item',
    'page callback' => 'hotblocks_assign_page',
    'page arguments' => array(2),
    'access callback' => 'hotblocks_access',
    'access arguments' => array('assign items to any hotblock', NULL, 2),
    'type' => MENU_CALLBACK,
  );

  //arg1 - block delta
  $aItems['hotblocks/reorder/%'] = array(
    'title' => 'reorder items in any hotblock',
    'page callback' => 'hotblocks_reorder',
    'page arguments' => array(2),
    'access callback' => 'hotblocks_access',
    'access arguments' => array('reorder items in any hotblock', NULL, 2),
    'type' => MENU_CALLBACK,
  );

  //arg1 - node id, arg2 - delta
  $aItems['hotblocks/assign/%/%'] = array(
    'page callback' => 'hotblocks_assign_to_block',
    'page arguments' => array(2, 3),
    'access callback' => 'hotblocks_access',
    'access arguments' => array('assign items to any hotblock', 2, 3),
    'type' => MENU_CALLBACK,
  );

  //arg1 - node id, arg2 - delta
  $aItems['hotblocks/remove/%/%'] = array(
    'page callback' => 'hotblocks_remove_from_block',
    'page arguments' => array(2, 3),
    'access callback' => 'hotblocks_access',
    'access arguments' => array('remove items from any hotblock', 2, 3),
    'type' => MENU_CALLBACK,
  );

  return $aItems;
}

/**
 * Implements hook_theme().
 */
function hotblocks_theme($existing, $type, $theme, $path) {
  return array(
    'hotblocks_reorder_form' => array(
      'render element' => 'form',
    ),
  );
}

/**
 * Implements hook_block_info().
 */
function hotblocks_block_info() {
  $blocks = array();

  // Query for hotblock machine names and labels and populate the blocks array
  foreach (hotblocks_get_blocks() as $machine_name => $label) {
    $blocks[$machine_name]['info'] = $label;
  }
  return $blocks;
}

/**
 * Implements hook_block_configure
 */
function hotblocks_block_configure($delta = '') {
  $form = array();

  $current_settings = hotblocks_block_get_settings($delta);

  // Allowed display methods (single page, global, etc)
  $hotblocks['allowed_display_methods'] = array(
    // Identify this is a hotblocks setting so hotblocks_block_save() will save it
    '#hotblocks'     => TRUE,
    '#type'          => 'checkboxes',
    '#title'         => 'Allowed content display methods',
    '#description'   => 'This option determines the choices a user has to display content when assigning it to this block. ' .
      'If no options are selected, all choices will be allowed.',
    // These options come from hotblocks_formstub_visibility_ops()
    '#options'       => array(
      'page'  => 'Allow: "Show on <em>this page</em> only"',
      'all'   => 'Allow: "Show on <em>all pages</em> (where this block is enabled)"',
      'group' => 'Allow: "Show on all pages of <em>this group</em>" (when Organic Groups is enabled)',
    ),
    '#default_value' => $current_settings['allowed_display_methods'],
  );

  // Minimum number of items
  $hotblocks['minimum_items'] = array(
    '#title' => 'Minimum number of items',
    '#type' => 'textfield',
    '#description' => 'Content editors will not be able to remove items from this block if it would cause the number' .
      ' of items to fall below the minimum. Changing this setting will not affect existing content. Set 0 or no value for no limit.',
    '#default_value' => $current_settings['minimum_items'],
  );

  // Maximum number of items
  $hotblocks['maximum_items'] = array(
    '#title' => 'Maximum number of items',
    '#type' => 'textfield',
    '#description' => 'The maximum number of items that can be placed in this block. Content editors will not be able' .
      ' to continue adding content past this maximum. Changing this setting will not affect existing content. Set 0 or no value for no limit.',
    '#default_value' => $current_settings['maximum_items'],
  );


  $mock_form = array();
  $mock_form_state = array();
  module_load_include('inc', 'hotblocks', 'hotblocks.admin');
  $hotblocks_global_settings = hotblocks_settings($mock_form, $mock_form_state, $delta);

  // Import title hiding option
  $hotblocks['hotblocks_title_hiding_hide_all'] = $hotblocks_global_settings['hotblocks_misc']['hotblocks_title_hiding']['hotblocks_title_hiding_hide_all'];

  // Import content filtering options
  $hotblocks['hotblocks_filtering'] = $hotblocks_global_settings['hotblocks_filtering'];


  // Put everything in a fieldset
  $form['hotblocks'] = array(
    '#title' => 'Hotblocks',
    '#type' => 'fieldset',
    'content' => $hotblocks,
  );

  return $form;
}

/**
 * Implements hook_block_save
 */
function hotblocks_block_save($delta = '', $edit = array()) {
  // Grab the submitted values from the form array that we're interested in
  $block_settings = array();
  $block_settings['allowed_display_methods'] = $edit['allowed_display_methods'];
  $block_settings['minimum_items'] = $edit['minimum_items'];
  $block_settings['maximum_items'] = $edit['maximum_items'];

  // From globals
  $block_settings['hotblocks_title_hiding_hide_all'] = $edit['hotblocks_title_hiding_hide_all'];

  $block_settings['hotblocks_allowed_types'] = $edit['hotblocks_allowed_types'];
  $block_settings['hotblocks_show_all_nodes_of_hotblocks_item_type'] = $edit['hotblocks_show_all_nodes_of_hotblocks_item_type'];
  $block_settings['hotblocks_allow_blocks'] = $edit['hotblocks_allow_blocks'];
  $block_settings['hotblocks_blocks_excluded_modules'] = $edit['hotblocks_blocks_excluded_modules'];
  $block_settings['hotblocks_block_only_whitelist'] = $edit['hotblocks_block_only_whitelist'];
  $block_settings['hotblocks_blocks_whitelist'] = $edit['hotblocks_blocks_whitelist'];

  // Store values for allowed bundles per entity type
  // @todo - This is a bad storage mechanism because we don't know all the variables that might exist.  All of these arrays
  // should go into an array
  $sorted_entity_info = entity_get_info();
  ksort($sorted_entity_info);
  foreach ($sorted_entity_info as $entity_type => $entity_info) {
    $block_settings['hotblocks_allowed_bundles_' . $entity_type] = $edit['hotblocks_allowed_bundles_' . $entity_type];
  }

  // Label can't be changed, but if we are editing the settings for a hotblock saved in code, we need to populate it in
  // the merge query otherwise it will become blank.
  $label = hotblocks_get_block_label($delta);

  // Save the settings
  db_merge('hotblocks_settings')
    ->key(array('machine_name' => $delta))
    ->fields(array(
      'data' => serialize($block_settings),
      'label' => $label,
    ))
    ->execute();
}

/**
 * Get stored settings for an individualblock
 * #@return array
 */
function hotblocks_block_get_settings($delta) {
  $result = ctools_export_load_object('hotblocks_settings', 'names', array($delta));

  // Return settings or an empty array
  return !empty($result[$delta]->data) ? $result[$delta]->data : array();
}

/**
 * Helper function to get a single setting value for a block
 *
 * @param $delta
 * - Block delta/machine name
 * If null, a global setting should be received, but this is not implemented yet.
 * @param $setting
 * - Machine name of the setting to retrieve
 */
function hotblocks_get_setting($setting, $delta = NULL) {
  // Setting for a specific hotblock
  if(!is_null($delta)) {
    $settings = hotblocks_block_get_settings($delta);

    // If we have the requested setting for this specific block, return that - otherwise try to get the global/default
    return isset($settings[$setting]) ? $settings[$setting] : hotblocks_get_setting($setting);
  }
  // Global / default / non-block-specific settings
  else {
    switch ($setting) {
      case 'hotblocks_show_all_nodes_of_hotblocks_item_type' :
        return variable_get('hotblocks_show_all_nodes_of_hotblocks_item_type', TRUE);
        break;
      case 'hotblocks_vocabulary' :
        return variable_get('hotblocks_vocabulary', 0);
        break;
      case 'hotblocks_use_icons' :
        return variable_get('hotblocks_use_icons', TRUE);
        break;
      case 'hotblocks_contextual_links' :
        return variable_get('hotblocks_contextual_links', FALSE);
        break;
      case 'hotblocks_extended_permissions' :
        return variable_get('hotblocks_extended_permissions', FALSE);
        break;
      case 'hotblocks_reorder_titles' :
        return variable_get('hotblocks_reorder_titles', TRUE);
        break;
      case 'hotblocks_title_hiding_hide_all' :
        return variable_get('hotblocks_title_hiding_hide_all', FALSE);
      break;
      case 'hotblocks_title_hiding_enable' :
        return variable_get('hotblocks_title_hiding_enable', TRUE);
      break;

      // Content filtering settings
      case 'hotblocks_allowed_types' :
        return variable_get('hotblocks_allowed_types', array('hotblocks_any'));
        break;
      case 'hotblocks_allow_blocks':
        return variable_get('hotblocks_allow_blocks', TRUE);
      break;
      case 'hotblocks_blocks_excluded_modules':
        return variable_get('hotblocks_blocks_excluded_modules', array());
       break;
      case 'hotblocks_block_only_whitelist':
        return variable_get('hotblocks_block_only_whitelist', FALSE);
      break;
      case 'hotblocks_blocks_whitelist':
        return variable_get('hotblocks_blocks_whitelist', array());
      break;

      default:
        // Default condition is intended to cover hotblocks_allowed_bundles_$entity_type
        return variable_get($setting);
        break;


    }
  }
}

/**
 * Implements hook_block_view().
 */
function hotblocks_block_view($delta) {
  // Add JS and CSS if the user has admin access to this block
  if (hotblocks_access('any block controls', NULL, $delta)) {
    hotblocks_load_files();
  }

  $block = array();

  // Build hotblocks content for the given delta
  $content = hotblocks_block_view_content($delta);
  if ($content) {
    // If we put the container at the top level $block['content'], it seems to get lost
    $block['content']['hotblock'] = array(
      '#type'       => 'container',
      '#attributes' => array(
        'class' => array('hotblock'),
      ),
      'hotblocks'   => $content,
    );
  }

  // If there are no items and the user does not have access to control the block, we don't want to display any markup
  if(empty($content['items']) && !hotblocks_access('any block controls', NULL, $delta)) {
    $block['content']['#access'] = FALSE;
  }

  // Add in contextual links placeholder
  if (user_access("access contextual links")) {
    $block['content']['#contextual_links'] = array(
      'hotblocks' => array(
        //TODO: better passing of data to hook_contextual_links_view_alter()
        'hotblocks/non-page/links-are-set-in-alter-hook',
        array($delta)
      )
    );
  }
  return $block;
}

/**
 * Implements hook_form_alter().
 *
 * @todo - Remove 'hotblocks_show_all_nodes_of_hotblocks_item_type' checks and functionality maybe..? This is the thing
 * that lets you make individual nodes assignable via hotblocks, rather than all nodes of a type.
 */
function hotblocks_form_alter(&$form, &$form_state, $form_id) {
  if (!empty($_GET['hotblocks_new']) && !empty($_GET['hotblocks_delta']) && !empty($_GET['hotblocks_delta']) && !empty($_GET['path'])) {
    // todo - check if this entity type is allowed to be assigned to hotblocks
    if (!empty($form['#entity']) && !empty($form['#entity_type'])) { // Make sure we're on an entity form
      // Add a custom submit handler - we need to be sure this is executed BEFORE entities own form handler so we can add
      // data to the entity before it's saved
      array_unshift($form['#submit'], 'hotblocks_entity_form_submit');

      // Give the user radio buttons to choose how to display this content - todo this would be better on the modal rather than the entity form
      $form['hotblocks'] = hotblocks_formstub_visibility_ops($_GET['path'], false, $_GET['hotblocks_delta']);

      // Signals to the form submit function that this item should be assigned to a hotblock after creation
      $form['hotblocks_data'] = array(
        '#type' => 'value',
        '#value' => array(
          'action' => 'assign',
          'delta' => $_GET['hotblocks_delta'],
          'path' => $_GET['path'],
          'entity_type' => $form['#entity_type'],
        ),
      );
    }
  }

  // If the 'hotblocks_delta' param is in the URL and it equals 'wysiwyg', we want to give the user some information about
  // the workflow.
  if(!empty($_GET['hotblocks_delta']) && $_GET['hotblocks_delta'] == 'wysiwyg') {
    drupal_set_message("When you're finished creating this new content, close this window to return to the original editing window. Your new content will be available to embed under the \"Choose existing content\" tab.");
  }
}

/**
 * Implements hook_node_insert().
 * Properties that have already been set on the node form will trigger these actions to occur.
 * @todo There is some more efficient namespacing that could be done with properties on the node object - at the least,
 * we should keep all of our information inside a 'hotblocks' key on the node.
 */
function hotblocks_entity_insert($entity, $type) {
  if (!empty($entity->hotblocks_data)) {
    $wrapper = entity_metadata_wrapper($type, $entity);

    // After the node has been created and given hotblocks_item status, potentially assign it to a block as a hotblocks_item as well
    if ($entity->hotblocks_data['action'] == 'assign') {
      $hotblock_item = new stdClass();
      $hotblock_item->entity_type = $entity->hotblocks_data['entity_type'];
      $hotblock_item->entity_id = $wrapper->getIdentifier();
      $hotblock_item->delta = $entity->hotblocks_data['delta'];
      $hotblock_item->path = $entity->hotblocks_data['path'];
      $hotblock_item->global = $entity->hotblocks_vis_type == 'all' ? 1 : 0;
      $hotblock_item->vis_type = $entity->hotblocks_vis_type;

      // Get the gid from the path
      $hotblock_item->vis_arg = hotblocks_og_context($hotblock_item->path, 'gid');
      
      drupal_write_record('hotblocks', $hotblock_item);

      // Let other modules react to the content change
      module_invoke_all('hotblocks_block_changed', 'added', $hotblock_item->delta);
    }
  }
}


/**
 * Implements hook_entity_update().
 */
function hotblocks_entity_update($entity, $type) {
  hotblocks_entity_insert($entity, $type);
}

/**
 * An added submit handler to the node add/edit form.  We inject some values into the form's node object here to
 * be processed by hotblocks_nodeapi where items like node id will be already populated in the event of new nodes.
 *
 * // todo - It'd probably be easier to make a single array of hotblocks info to pass on
 */
function hotblocks_entity_form_submit(&$form, &$form_state) {
  if (isset($form['hotblocks_data'])) {
    $form['#entity']->hotblocks_data = $form['hotblocks_data']['#value'];
  }
  $form['#entity']->hotblocks_vis_type = $form_state['values']['hotblocks_vis_type'];
}

/**
 * Implements hook_entity_delete().
 */
function hotblocks_entity_delete($entity, $type) {
  $entity_wrapper = entity_metadata_wrapper($type, $entity);
  $id = $entity_wrapper->getIdentifier();

  // If the node is deleted, we should remove all reference to it from the hotblocks table
  db_query("
    DELETE h, hw FROM {hotblocks} h
    LEFT JOIN {hotblocks_weight} hw ON h.hid = hw.hid
    WHERE h.entity_id = :id AND h.entity_type = :entity_type
  ", array(':id' => $id, ':entity_type' => $type));
}

/**
 * Implements hook_permission().
 */
function hotblocks_permission() {
  $aPerms = array(
    'administer hotblocks' => array(
      'title' => t('administer hotblocks'),
      'description' => t('TODO Add a description for \'administer hotblocks\''),
    ),
    'create items in any hotblock' => array(
      'title' => t('create items in any hotblock'),
      'description' => t('TODO Add a description for \'create items in any hotblock\''),
    ),
    'assign items to any hotblock' => array(
      'title' => t('assign items to any hotblock'),
      'description' => t('TODO Add a description for \'assign items to any hotblock\''),
    ),
    'remove items from any hotblock' => array(
      'title' => t('remove items from any hotblock'),
      'description' => t('TODO Add a description for \'remove items from any hotblock\''),
    ),
    'reorder items in any hotblock' => array(
      'title' => t('reorder items in any hotblock'),
      'description' => t('TODO Add a description for \'reorder items in any hotblock\''),
    ),
    'use all pages visibility' => array(
      'title' => t('use all pages visibility'),
      'description' => t('Place content with "all pages" visibility'),
    ),
    'use group pages visibility' => array(
      'title' => t('use group pages visibility'),
      'description' => t('Place content with "on group pages" visibility'),
    ),
    'use single pages visibility' => array(
      'title' => t('use single pages visibility'),
      'description' => t('Place content with "just this page" visibility'),
    ),
  );

  // Add permissions for controlling each node type in each hotblock
  if (hotblocks_get_setting('hotblocks_extended_permissions')) {
    $aOps = array('assign items to any hotblock', 'remove items from any hotblock', 'reorder items in any hotblock');
    foreach (hotblocks_get_allowed_node_types() as $sType) {
      foreach (hotblocks_get_blocks() as $iDelta => $block_label) {
        foreach ($aOps as $sOp) {
          $perm = hotblocks_get_perm($sOp, $sType, $iDelta);
          $aPerms[$perm] = array('title' => $perm);
        }
      }
    }
  }

  return $aPerms;
}

/** 
 *  Implements hook_contextual_links_view_alter().
 */
function hotblocks_contextual_links_view_alter(&$element, &$items) {
  // check this set of contextual links for the data set in hook_block_view
  if (isset($element['#contextual_links']['hotblocks-item'])) {
    $data = $element['#contextual_links']['hotblocks-item'][1];
    $oHotblocks_Item = new stdClass();
    $oHotblocks_Item->entity_id = $data['entity_id'];
    $oHotblocks_Item->delta = $data['delta'];
    $oHotblocks_Item->hid = $data['hid'];
    $removeLink = hotblocks_contextual_item_remove_link($oHotblocks_Item);
    $element['#links']['hotblocks-remove'] = $removeLink;
  }
  if (isset($element['#contextual_links']['hotblocks'])) {
  
    $delta = $element['#contextual_links']['hotblocks'][1][0];
    if (hotblocks_access('assign items to any hotblock', NULL, $delta)) {
      $element['#links']['hotblocks-assign'] = hotblocks_contextual_link('assign', $delta);
    }
    if (hotblocks_access('create items in any hotblock', NULL, $delta)) {
      $element['#links']['hotblocks-create'] = hotblocks_contextual_link('create', $delta);
    }
    if (hotblocks_access('reorder items in any hotblock', NULL, $delta)) {
      $element['#links']['hotblocks-reorder'] = hotblocks_contextual_link('reorder', $delta);
    }
    
  }
}

/*******************************[END] Drupal hooks****************/


/****************Pages**********************************************/
/**
 * Ajax page callback. Listing hotblocks grouped by node type as assignment links
 *
 * @param $iDelta
 * - Corresponds to the hotblocks_item block the user clicked in
 */
function hotblocks_assign_page($iDelta) {
  $sPath = isset($_GET['path']) ? $_GET['path'] : $_GET['q'];

  // Get a list of all content available to go in the hotblock
  // This list won't include nodes that the user isn't allowed to view, or blocks that are excluded from being hotblock assignable,
  // but it will need to be filtered additionally by hotblocks permissions (like which types can go into which groups)
  $hotblock_items = hotblocks_get_all_assignable_content($iDelta);

  // Remove items from our list that the user may not have permission to assign based on hotblocks permissions
  // Also, make an array of all item types in the process
  $itemTypes = array();
  foreach ($hotblock_items as $i => $oRow) {
    if (!hotblocks_access('assign items to any hotblock', $oRow->entity_type, $iDelta)) {
      unset($hotblock_items[$i]);
    }
    $itemTypes[drupal_html_class($oRow->friendlytype)] = $oRow->friendlytype;
  }
  asort($itemTypes);

  // If there are no items to display, let the user know and quit
  if (!sizeof($hotblock_items)) {
    print ('No ' . hotblocks_terminology(TRUE) . ' have been created yet.');
    drupal_exit();
  }

  // Build a table of links with no grouping, sorted alphabetically.
  // Alpha sorting is done by default in the hotblocks_get_all_assignable_content() function
  $rows = array();
  foreach ($hotblock_items as $hotblock_item) {
    $rows[] = array(
      'data'  => array(hotblocks_assign_to_block_link($iDelta, $hotblock_item), $hotblock_item->friendlytype),
      'class' => array(drupal_html_class($hotblock_item->friendlytype)),
    );
  }
  $hotblocks_table_alpha = array(
    '#theme'      => 'table',
    '#header'     => array('Name', 'Type'),
    '#rows'       => $rows,
    '#attributes' => array('class' => array('hotblocks-assign-table')),
  );

  // Build a table of links grouped by type
  foreach ($hotblock_items as $oRow) {
    $aHotblocksGrouped[$oRow->friendlytype][$oRow->entity_id] = $oRow;
  }
  ksort($aHotblocksGrouped);

  // Iterate through each group of items and render it as a table
  $hotblocks_grouped_tables = array();
  foreach ($aHotblocksGrouped as $sFriendlyType => $aRows) {
    $rows = array();
    foreach ($aRows as $oRow) {
      $rows[] = array(hotblocks_assign_to_block_link($iDelta, $oRow));
    }

    $hotblocks_grouped_tables[] = array(
      '#theme'      => 'table',
      '#header'     => array($sFriendlyType),
      '#rows'       => $rows,
      '#attributes' => array('class' => array('hotblocks-assign-table')),
    );
  }

  // Extra data that javascript will pass into the request when a user clicks an assign link
  $replacements = array(
    ':path' => $_GET['path'],
    ':token' => drupal_get_token("hotblocks-$iDelta"),
    ':replace' => isset($_GET['replace']) ? $_GET['replace'] : 0,
  );
  $extra_data = strtr('<input id="hb-extra-data" type="hidden" data-path=":path" data-token=":token" data-replace=":replace" />',$replacements);

  // Assimilate all of the content for our modal into a render array.
  $render = array(
    '#type'              => 'container',
    '#attributes' => array('id' => 'hb-assign-tab'),

    // Extra data that javascript will pass into the request when a user clicks an assign link
    'extra_data' => array('#markup' => $extra_data),

    // Get radios for choosing item visibility
    'visibility_options' => hotblocks_formstub_visibility_ops($sPath, TRUE, $iDelta),

    // Filtering/grouping/searching options
    'filters'            => array(
      '#type'            => 'container',
      '#attributes'      => array('id' => 'hotblocks-filters-container', 'class' => 'clearfix'),
      'filter_by_type'   => array(
        '#title'      => 'Filter by type',
        '#type'       => 'select',
        '#options'    => array('all' => 'None') + $itemTypes,
        '#attributes' => array('id' => 'hotblocks-filter-select'),
      ),
      'lightning_search' => array(
        '#title'      => 'Quick Search',
        '#type'       => 'textfield',
        '#attributes' => array('id' => 'quicksearch'),
        '#size'       => 32,
      ),
      'group_by_type'    => array(
        '#title'      => 'Group by',
        '#type'       => 'select',
        '#options'    => array('alpha' => 'None', 'type' => 'Type'),
        '#attributes' => array('id' => 'hotblocks-groupby-select'),
      ),
    ),

    // Content links (the potential hotblock items)
    'hotblock_item_list' => array(
      '#type'        => 'container',
      '#attributes'  => array('id' => 'hotblocks-item-list-wrapper'),
      // Help text at the top
      'instructions' => array('#markup' => '<b>Select an item to insert.</b>'),

      // Table containers
      'alpha'        => array(
        '#type'       => 'container',
        '#attributes' => array('id' => 'hotblocks-item-list-alpha'),
        'content'     => $hotblocks_table_alpha,
      ),
      'type'         => array(
        '#type'       => 'container',
        '#attributes' => array('id' => 'hotblocks-item-list-type', 'style' => 'display:none;'),
        'content'     => $hotblocks_grouped_tables,
      ),
    ),
  );

  $tabs = array(
    '#type'       => 'container',
    '#attributes' => array('id' => 'hbmodal-wrapper'),
    'tablinks'    => array('#markup' => '<ul><li><a href="#hb-assign-tab">Choose existing content</a></li><li><a href="#hb-create-tab">Create new content</a></li></ul>'),
    'tab1'        => $render,
    'tab2'        => array(
      '#type'       => 'container',
      '#attributes' => array('id' => 'hb-create-tab'),
      'content' => hotblocks_create_content_page($iDelta),
    ),
  );

  // Add a 'group by' option for taxonomy if this is configured by the user.
  if (module_exists('taxonomy') && hotblocks_get_setting('hotblocks_vocabulary', $iDelta)) {
    // todo - At the moment, the taxonomy grouping feature still has not been fully ported from D6
    /*$render['filters']['group_by_type']['#options']['taxonomy'] = 'Taxonomy';

    module_load_include('inc', 'hotblocks', 'hotblocks.adminpages');
    $hotblocks_table = array('#markup' => hotblocks_taxonomy_page($iDelta));*/
  }

  print render($tabs);
  drupal_exit();
}

/**
 * Generates a the radios element for choosing the visibility of a hotblocks item
 *
 * This generates a 'form stub' because the hotblocks assign modal does not use drupal's form processing system,
 * however this stub is also grabbed from hotblocks_form_alter when it's added to the node creation page.
 * 
 * @param $sPath
 * @return array
 * - renderable content
 */
function hotblocks_formstub_visibility_ops($sPath, $process = false, $delta) {
  // Build a little stub of a form which has a fieldset and some radio buttons
  // This is not hooked into the drupal form system for submit or validation, just makes some markup
  $form_stub = array (
    'fieldset' => array(
      '#type' => 'fieldset',
      'content' => array(
        'hotblocks_vis_type' => array(
          '#title' => t('Choose how you want this content to display'),
          '#type' => 'radios',
          '#options' => array(
            'page' => 'Show on <em>this page</em> only',
            'all' => 'Show on <em>all pages</em> (where this block is enabled)',
          ),
          '#default_value' => 'page',
          '#id' => 'hotblocks-vis-type',
        ),
      )
    )
  );
  
  // Add an option for the current page's group. We'll determine group id from this group or group content.
  // One of the limitations of our current implementation is that only the first group of a piece of group content
  // that belongs to more than one group will be stored.
  if(module_exists('og_context')) {
    // Find the gid for the content being viewed
    $gid = hotblocks_og_context($sPath, 'gid');

    // Get the groups of the current user
    $users_groups = og_get_groups_by_user();

    // If the user belongs to the group of this content, give them the option to assign
    // the block item with group visibility
    if(in_array($gid, $users_groups)) {
      $group_name = hotblocks_og_context($sPath, 'title');
      if(!empty($group_name)) {
        $form_stub['fieldset']['content']['hotblocks_vis_type']['#options']['group'] = 'Show on all pages of <em>this group</em> (' . $group_name . ')';
      }
    }
  }

  // Now that we have the default structure, potentially remove some options based on the users permissions
  if(!user_access('use all pages visibility')) {
    unset($form_stub['fieldset']['content']['hotblocks_vis_type']['#options']['all']);
  }
  if(!user_access('use group pages visibility')) {
    unset($form_stub['fieldset']['content']['hotblocks_vis_type']['#options']['group']);
  }
  if(!user_access('use single pages visibility')) {
    unset($form_stub['fieldset']['content']['hotblocks_vis_type']['#options']['page']);
  }

  // Remove options based on block settings
  $block_settings = hotblocks_block_get_settings($delta);
  $allowed_display_methods = array_filter($block_settings['allowed_display_methods']);

  // If there is nothing configured for allowed display methods, allow all and don't mess with it
  if(!empty($allowed_display_methods)) {
    foreach ($form_stub['fieldset']['content']['hotblocks_vis_type']['#options'] as $key => $option) {
      if(empty($allowed_display_methods[$key])) {
        // The block isn't configured to allow this option, remove it
        unset($form_stub['fieldset']['content']['hotblocks_vis_type']['#options'][$key]);
      }
    }
  }

  // Set the default value to the first option in case our original default has been removed due to settings or permissions
  if(!isset($form_stub['fieldset']['content']['hotblocks_vis_type']['#options'][$form_stub['fieldset']['content']['hotblocks_vis_type']['#default_value']])) {
    reset($form_stub['fieldset']['content']['hotblocks_vis_type']['#options']);
    $form_stub['fieldset']['content']['hotblocks_vis_type']['#default_value'] = key($form_stub['fieldset']['content']['hotblocks_vis_type']['#options']);
  }


  // When this form stub is being rendered outside of the drupal form system, we have to mimic some of drupal's
  // processing to get it to display right with ids, js, etc
  if($process) {
    // Ensure some defaults; if already set they will not be overridden.
    $form_state = array();
    $form_state += form_state_defaults();
    drupal_prepare_form('hotblocks-visibility', $form_stub, $form_state);
    drupal_process_form('hotblocks-visibility', $form_stub, $form_state);
  }


  return $form_stub;
}

/**
 * Menu callback for the reorder page
 * 
 * Here we just invoke the reorder form - we might have just put the call to 
 * drupal_get_form directly in the menu system, but it seems the forms theme
 * function doesn't get called until many other elements of the page get rendered by
 * Drupal, making the whole business much slower. Further, the output buffer has to be cleaned
 * in order to even get the output of just the block we want. Doubtless there are other methods of
 * doing a request like with the Drupal API, but so far this method seems the best for efficiency.
 *
 * @param $iDelta
 *  - Delta of the hotblock
 * @return null
 *  Prints a tabledrag form allowing you to reorder hotblocks assigned to a block
 */
function hotblocks_reorder($iDelta = NULL) {
  //path will be set if this is an ajax request, otherwise use the current path
  $sPath = isset($_GET['path']) ? $_GET['path'] : current_path();

  print render(drupal_get_form('hotblocks_reorder_form', $iDelta, $sPath));
  drupal_exit();
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function hotblocks_reorder_form($form, &$form_state, $iDelta, $sPath) {
  // Get a list of the hotblock_items in this block
  $hotblock_items = hotblocks_block_get_items($iDelta, $sPath);

  // Identify that the elements in 'items' are a collection, to
  // prevent Form API from flattening the array when submitted.
  $form['items']['#tree'] = TRUE;
  
  foreach ($hotblock_items as $hotblock_item) {
    $hid = $hotblock_item->hid;
    
    // Show the item title or its rendered content based on user defined setting
    if (hotblocks_get_setting('hotblocks_reorder_titles', $iDelta)) {
      $form['items'][$hid]['hotblocks_item_markup'] = array('#markup' => $hotblock_item->title);
    }
    else {
      $form['items'][$hid]['hotblocks_item_markup'] = hotblocks_item_view($hotblock_item, 0, 'reorder');
      $form['items'][$hid]['hotblocks_item_markup']['#attributes']['class'][] = 'hotblocks_item-reorder';
    }

    //Weight field used by tabledrag
    $form['items'][$hid]['weight'] = array(
      '#type' => 'weight',
      '#title' => t('Weight'),
      '#delta' => 25,
      '#title-display' => 'invisible',
      '#default_value' => $hotblock_item->weight,
    );
    
    //Store the whole rest of the hotblock item object in this row
    $form['items'][$hid]['hotblock_item'] = array(
      '#type' => 'value',
      '#default_value' => $hotblock_item,
    );
  }

  //A couple non-item-specific values to pass through
  $form['delta'] = array(
    '#type' => 'hidden',
    '#default_value' => $iDelta,
  );
  $form['path'] = array(
    '#type' => 'hidden',
    '#default_value' => $sPath,
  );
  
  //Submit buttons
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Save',
  );
  $form['cancel'] = array(
    '#type' => 'submit',
    '#value' => 'Cancel',
    '#submit' => array('hotblocks_reorder_form_submit_cancel'),
  );

  // When not reordering with titles only, add a class that tells CSS to constrain the item height so it's not too
  // difficult to reorder tall content.
  // @todo - We may want to make this a configurable setting, but you could override the CSS.
  if (!hotblocks_get_setting('hotblocks_reorder_titles', $iDelta)) {
    $form['#attributes']['class'] = array('constrain-size');
  }

  // Theme function to setup table dragging
  $form['#theme'] = 'hotblocks_reorder_form';
  
  return $form;
}

/**
 * Theme the reorder form table drag style
 */
function theme_hotblocks_reorder_form($variables) {
  $form = $variables['form'];
  
  // We need to pass the drupal_add_tabledrag() function an html id for the table
  $table_id = drupal_html_id('hotblocks-reorder-table');
  
  $weight_class = 'hotblocks_item-weight';

  // Initialize the variable which will store our table rows.
  $rows = array();

  // Iterate over each element in our $form['items'] array.
  foreach (element_children($form['items']) as $hid) {

    // Before we add our 'weight' column to the row, we need to give the
    // element a custom class so that it can be identified in the
    // drupal_add_tabledrag call.
    $form['items'][$hid]['weight']['#attributes']['class'] = array($weight_class);

    // We are now ready to add each element of our $form data to the $rows
    $rows[] = array(
      'data' => array(
        drupal_render($form['items'][$hid]['hotblocks_item_markup']),
        drupal_render($form['items'][$hid]['weight']),
      ),
      // To support the tabledrag behaviour, we need to assign each row a 'draggable' class
      'class' => array('draggable'),
    );
  }

  // We can render our tabledrag table for output.
  $output = theme('table', array(
    'rows' => $rows,
    'attributes' => array('id' => $table_id),
  ));

  // Render remaining form elements like submit buttons.
  $output .= drupal_render_children($form);

  // We now call the drupal_add_tabledrag() function in order to add the tabledrag.js goodness onto our page.
  // This call is essentially useless here since the output of this theme function does not include the full drupal page
  // with JS files and settings, etc.  We'll put the call in our hook_init function so it works when calling from the modal.
  drupal_add_tabledrag($table_id, 'order', 'sibling', 'hotblocks_item-weight');

  return $output;
}


/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function hotblocks_reorder_form_submit($form, $form_state) {
  $items = $form_state['values']['items'];
  $delta = $form_state['values']['delta'];
  $path = $form_state['values']['path'];
  
  //Delete all the currently stored weights for the items in this block on this path
  db_delete('hotblocks_weight')
    ->condition('path', $path)
    ->condition('delta', $delta)
    ->execute();
  
  //Resave each item in the weights table
  foreach ($items as $hid => $row) {
    $hotblock_item = $row['hotblock_item'];
    
    //We don't want the original path of this item - for weighting we want the page
    //that we did the weighting on
    $hotblock_item->path = $path;
    
    //Give this weight record the weight that tabledrag gave it
    $hotblock_item->weight = $row['weight'];
    
    //There will be more fields in the object we're saving than we need, but all
    //of the minimum ones required are present.
    drupal_write_record('hotblocks_weight', $hotblock_item);
  }

  print render(hotblocks_block_view_content($delta));

  // Let other modules react to the content change
  module_invoke_all('hotblocks_block_changed', 'reordered', $delta);

  drupal_exit();
}

/**
 * Submit handler for hotblocks_reorder_form when 'cancel' is pressed.
 * Just returns the content of the block again to get the display back
 * to normal.
 */
function hotblocks_reorder_form_submit_cancel($form, $form_state) {
  // Set the path that hotblocks_block_view_content will use to show blocks from
  $_GET['path'] = $form_state['values']['path'];

  print render(hotblocks_block_view_content($form_state['values']['delta']));
  drupal_exit();
}

/**
 * Gets an associative array of all types of content (bundles of nodes, drupal block, bundles of entities)
 * The array is keyed by entity type, with an additional array that has human readable label and a create URL for that
 * entity
 *
 *
 * Example structure:
 * ... (Array, 3 elements)
 *  node (Array, 4 elements)
 *    agenda (Array, 2 elements)
 *      label (String, 6 characters ) Agenda
 *      create_url (String, 15 characters ) node/add/agenda
 *    person (Array, 2 elements)
 *    person_collection (Array, 2 elements)
 *    widget_content (Array, 2 elements)
 *  block (Array, 1 element)
 *    block (Array, 2 elements)
 *      label (String, 5 characters ) Block
 *      create_url (String, 25 characters ) admin/structure/block/add
 *  embeddable (Array, 1 element)
 *    quote (Array, 2 elements)
 *      label (String, 5 characters ) Quote
 *      create_url (String, 48 characters ) admin/structure/entity-type/embeddable/quote/add
 *
 * @param $iDelta
 * @return array
 */
function hotblocks_get_all_allowed_types($iDelta = null) {
  $return_types = array();

  // Add node types to the list
  $allowed_nodetypes = hotblocks_get_setting('hotblocks_allowed_types', $iDelta);
  // If all nodes are allowed, get a complet list from the system
  if (in_array('hotblocks_any', $allowed_nodetypes)) {
    $allowed_nodetypes = array_keys(node_type_get_names());
  }
  foreach ($allowed_nodetypes as $type) {
    // Get info about the node type from the system
    $node_type_info = node_type_get_type($type);
    $return_types['node'][$type] = array(
      'label' => $node_type_info->name,
      // Construct the URL to create nodes of this bundle by replacing '_' with '-', that's how node.module does it
      'create_url' => 'node/add/' . str_replace('_', '-', $node_type_info->type),
    );
  }


  // Add Drupal Blocks to the mix, if they are configured
  if (hotblocks_get_setting('hotblocks_allow_blocks', $iDelta)) {
    $return_types['block']['block'] = array(
      'label' => 'Block',
      'create_url' => 'admin/structure/block/add',
    );
  }

  // Add in other entities
  $bundles = hotblocks_get_allowed_entity_bundles($iDelta);
  if(!empty($bundles)) {
    $entity_info = entity_get_info();
    foreach ($bundles as $entity_type => $bundles) {
      foreach ($bundles as $bundle) {
        $create_url = null;

        // Try to generate an 'add' link for ECK entities
        if(!empty($entity_info[$entity_type]['bundles'][$bundle]['crud']['add']['path'])) {
          $create_url = $entity_info[$entity_type]['bundles'][$bundle]['crud']['add']['path'];
        }

        // Add link for taxonomy_term
        if($entity_type == 'taxonomy_term') {
          $create_url = "admin/structure/taxonomy/$bundle/add";
        }

        // Add link for user
        if($entity_type == 'user') {
          $create_url = "admin/people/create";
        }

        $return_types[$entity_type][$bundle] = array(
          'label' => $entity_info[$entity_type]['bundles'][$bundle]['label'],
          'create_url' => $create_url,
        );
      }
    }
  }

  return $return_types;
}

/**
 * @return array
 * - A numeric array of node types (machine names)
 *
 * @return Array of node types which are configured to be hotblocks
 */
function hotblocks_get_allowed_node_types($iDelta = null) {
  $aNodeTypes = array();

  $all_types = hotblocks_get_all_allowed_types($iDelta);
  if(!empty($all_types['node'])) {
    $aNodeTypes = array_keys($all_types['node']);
  }

  return $aNodeTypes;
}

/**
 * Returns an associative array of one or more bundles keyed by entity type
 * @return array
 */
function hotblocks_get_allowed_entity_bundles($iDelta) {
  $return = array();

  // Get each entity type in the system and sort by key (key is the entity type machine name)
  $sorted_entity_info = entity_get_info();
  ksort($sorted_entity_info);

  // Iterate through each entity type
  foreach ($sorted_entity_info as $entity_type => $entity_info) {
    // Get all of the allowed bundles for this entity type
    $allowed_bundles = hotblocks_get_setting('hotblocks_allowed_bundles_' .$entity_type, $iDelta);

    // If there are allowed bundles for this entity type in the settings, add them to our return array
    if(!empty($allowed_bundles)) {
      $return[$entity_type] = $allowed_bundles;
    }
  }

  return $return;
}

/**
 * Ajax page callback for the new content modal.
 * Gives the user links to create new content and then automatically add that content to the already-chosen hotblock.
 *
 * @todo - Automatic assignment does not work with Drupal blocks after creation, but does work with nodes and entities
 * made by ECK. Have not tested other types of entities.
 */
function hotblocks_create_content_page($iDelta) {
  $sPath = $_GET['path'];
  $link_options = array(
    'query'      => drupal_get_destination() + array(
        'path'            => $sPath,
        'entity_type'     => 'node',
        'hotblocks_new'   => 1,
        'hotblocks_delta' => $iDelta,
      ),
    'attributes' => array('class' => array('hotblocks_item-create'))
  );

  // When we're creating content through the WYSIWYG window, we don't want the destination of the current page, which is
  // hotblocks/assign/wysiwyg, so clear it out.
  if($iDelta == 'wysiwyg') {
    unset($link_options['query']['destination']);
  }

  // Create a list of item types that the user can create. Determine first if the user has access to create this content.
  $items = array();
  foreach (hotblocks_get_all_allowed_types($iDelta) as $entity_type => $bundles) {
    foreach ($bundles as $bundle => $bundle_info) {
      // Drupal blocks relies on 'administer blocks' permissions
      if ($entity_type == 'block') {
        $create_access = user_access('administer blocks');
      }
      // Nodes/entities can use entity access
      else {
        $fake_entity = new stdClass();
        $fake_entity->bundle = $bundle;
        $fake_entity->type = $bundle;
        $fake_entity->entity_type = $entity_type;
        $create_access = entity_access('create', $entity_type, $fake_entity);
      }

      // If the user has access to create this entity, provide a link
      if ($create_access) {
        $items[] = array(l($bundle_info['label'], $bundle_info['create_url'], $link_options));
      }
    }
  }

  // Return a renderable array
  return array(
    '#theme' => 'item_list',
    '#items' => $items,
  );
}
/**********************[END] Pages *************************/

/**************************Helper functions*****************/

/**
 * Returns the user defined name of the specified hotblocks_item block as defined by the user in the hotblocks settings page.
 *
 * @param $iDelta
 * @return string
 */
function hotblocks_get_block_label($delta) {
  $result = ctools_export_load_object('hotblocks_settings', 'names', array($delta));
  return $result[$delta]->label;
}

/**
 * Get machine names and labels of all hotblocks
 *
 * @return array
 * - An associative array of blocks, keyed by machine_name where value is human-readable label.
 * return array([1] => 'name1',[2] => 'someothername',[3] => 'etc');
 *
 * @todo - Now that this function leverages ctools_export_load_object, refactor functions that use it to call this
 * function directly or accept the default return value that the function provides
 */
function hotblocks_get_blocks() {
  $blocks = array();

  $ctobjects = ctools_export_load_object('hotblocks_settings');

  foreach ($ctobjects as $row) {
    $blocks[$row->machine_name] = $row->label;
  }
  return $blocks;
}


/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function hotblocks_icon_path($set = NULL) {
  if (is_null($set)) {
    $set = variable_get('hotblocks_icons_set', '48x48');
  }
  return drupal_get_path('module', 'hotblocks') . '/images/' . $set;
}
/**********************[END]**Helper functions*****************/

/********************Hotblocks API/db functions*******************/


/**
 * Load a hotblocks_item record from the database based on
 * primary key hid.
 */
function hotblocks_item_load($hid) {
  $hotblock_item = db_query("SELECT * FROM {hotblocks} WHERE hid = :hid", array(':hid' => $hid))->fetchObject();
  if(!empty($hotblock_item)) {
    // Populate the 'title' property for blocks
    hotblocks_item_preload($hotblock_item);
  }

  return $hotblock_item;
}

/**
 * Remove a hotblocks_item instance from the database
 */
function hotblocks_item_remove($hid) {
  db_delete('hotblocks')
    ->condition('hid', $hid)
    ->execute();
    
  db_delete('hotblocks_weight')
    ->condition('hid', $hid)
    ->execute();
}

/**
 * Render a hotblocks_item node with administrative controls (if applicable)
 * The first parameter can either be a hotblocks_item id or an already loaded hotblocks_item object
 *
 * @return array
 * Returns a renderable array
 */
function hotblocks_item_view($hotblock_item, $iDelta = 0, $sContext = 'normal') {
  // Hotblock item is a Block
  if ($hotblock_item->entity_type == 'block') {
    // Load the basic block object from the database
    $block = _hotblocks_get_block_by_bid($hotblock_item->entity_id);

    // An explicit value of FALSE here means we couldn't get info from the block table and this probably isn't
    // a valid block.
    if($hotblock_item->title === FALSE) {
        drupal_set_message('Hotblocks tried to display an invalid block - this block has been removed from hotblocks.');
        hotblocks_item_remove($hotblock_item->hid);
        return '';
    }

    // Normal context - user is seeing this block inside a hotblock
    $blocks = array_values(_block_render_blocks(array($block)));
    if (!isset($blocks[0])) {
      // This block doesn't have any content.  If an admin is viewing, show them a placeholder
      // so that they can know at least that the block is assigned here.
      if (hotblocks_access('any block controls', NULL, $iDelta)) {
        $renderableItem = array('#markup' => '<div class="block">[Empty Block]<br />' . $hotblock_item->title . '</div>');
      }
      else {
        // If we're here, a regular non admin is viewing an empty block, no output should be generated
        return FALSE;
      }
    }
    else {
      // Show the block
      $block = $blocks[0];

      // Add in contextual links
      if (variable_get('hotblocks_contextual_links', FALSE)) {
        hotblocks_hotblocks_item_contextual_controls($hotblock_item, $block->content);
      }

      // Rebuild/render - @todo - This step seems redundant because it happens above, but appears necessary.  Refactor?
      $block_content = _block_render_blocks(array($block));
      $renderableItem = _block_get_renderable_array($block_content);
    }
  }
  // Hotblock item is a node
  elseif ($hotblock_item->entity_type == 'node') {
    // Look for a translated version of the node in the current language, use the base node if not found
    global $language;
    $lang = $language->language;
    $base_node = node_load($hotblock_item->entity_id);

    // If somehow the node is missing or can't be loaded, remove it from hotblocks
    if($base_node === FALSE) {
      drupal_set_message('Hotblocks tried to display a missing node - this node has been removed from hotblocks.');
      hotblocks_item_remove($hotblock_item->hid);
      return '';
    }

    if(function_exists('translation_node_get_translations')) {
      $translations = translation_node_get_translations($base_node->tnid);
      $node = (isset($translations[$lang]) ? node_load($translations[$lang]->nid): $base_node);
    }
    else {
      $node = $base_node;
    }

    // We will respect node access unless the option is turned off, in which case a user needs standard node access or 'administer hotblocks' to see the node
    if (!hotblocks_access('view node', $node, $iDelta)) {
      return FALSE;
    }

    // If configured, hide the node title.
    // @todo - This setting should probably go away on the grounds of not best practice. There are other ways to do this
    // outside of hotblocks
    if (hotblocks_get_setting('hotblocks_title_hiding_hide_all', $iDelta)) {
      $node->title = '';
    }
    // If configured, apply title filtering. @todo - This is another option that no longer feels like best practice.
    // The original intent was to have an 'admin title' when seeing blocks in the list.
    elseif (variable_get('hotblocks_title_hiding_enable', TRUE)) {
      $sDelimStart = variable_get('hotblocks_title_hiding_delim_start', HOTBLOCKS_TITLE_HIDING_START);
      $sDelimEnd = variable_get('hotblocks_title_hiding_delim_end', HOTBLOCKS_TITLE_HIDING_END);
      $sTitle = trim($node->title);
      $node->title = preg_replace('/\(.*\)/', '', $sTitle);
    }

    // Get renderable array for node
    $node = node_view($node,variable_get('hotblocks_view_mode_'.$node->type, variable_get('hotblocks_view_mode_default', NULL)));

    // If set, add contextual links into the node's renderable array
    if (variable_get('hotblocks_contextual_links', FALSE)) {
      hotblocks_hotblocks_item_contextual_controls($hotblock_item, $node);
    }

    $renderableItem = $node;
  }
  else {
    // Assume this is an entity of another variety
    $entity = entity_load($hotblock_item->entity_type, array($hotblock_item->entity_id));
    $renderableItem = entity_view($hotblock_item->entity_type, $entity); // todo - configurable viewmode would be nice
  }


  // Get item links markup for this hotblock item
  $aControls = array();
  if (!variable_get('hotblocks_contextual_links', FALSE)) {
    $aControls = hotblocks_item_controls($hotblock_item);
  }

  // Build render output for this item
  $renderOutput = array(
    '#type'       => 'container',
    '#attributes' => array(
      'id'    => drupal_html_id('hotblocks_item-' . $hotblock_item->hid),
      'class' => array(
        'hotblocks_item',
        'hid-' . $hotblock_item->hid,
        'hotblocks-entity-type-' . $hotblock_item->entity_type,
      ),
    ),
    'item'        => $renderableItem,
    'controls'    => $aControls,
  );

  // A little debugging helper
  if(!empty($_REQUEST['hbdebug'])) {
    $renderOutput['debug'] = array('#markup' => '<pre>' . print_r($hotblock_item, TRUE) . '</pre>');
  }

  return $renderOutput;
}

/**
 * Ajax menu callback.
 * Creates an instance of the given node as a hotblocks_item for the designated block.
 * Prints the block output when done.
 *
 * @param int
 * - node id $entity_id
 * @param int
 * block delta $iDelta
 */
function hotblocks_assign_to_block($entity_id = NULL, $iDelta = NULL) {
  if (!isset($_GET['token']) || $_GET['token'] != drupal_valid_token($_GET['token'], "hotblocks-$iDelta")) {
    drupal_access_denied();
    exit();
  }
  if (!$iDelta || !$entity_id) {
    print 'Error';
    drupal_exit();
  }

  //@todo - Maybe we should create a blank entry here so that even if all the hotblocks of this node are removed,
  //it still shows up in the list of allowable nodes to assign as a hotblocks_item.


  // If the 'replace' URL parameter is present, this new content is replacing some old content, so we can inherit
  // it's hid, path, vis_type, vis_arg, and global properties. Taking its hid will also cause entries in the hotblocks_weight
  // table to be inherited
  if(!empty($_GET['replace']) && is_numeric($_GET['replace'])) {
    $replaced_item = hotblocks_item_load($_GET['replace']);
    $path = $replaced_item->path;
    $vis_type = $replaced_item->vis_type;
    $vis_arg = $replaced_item->vis_arg;
    $global = $replaced_item->global;

    // Create the new hotblocks_item record and write to the database
    $hotblock_item = array(
      'hid' => $replaced_item->hid,
      'entity_id' => $entity_id,
      'delta' => $iDelta,
      'path' => $path,
      'vis_type' => $vis_type,
      'vis_arg' => $vis_arg,
      'entity_type' => $_GET['entity_type'],
      'global' => $global,
    );
    // Replace an existing record
    drupal_write_record('hotblocks', $hotblock_item, 'hid');
  }
  else {
    // This is not a replacement, read item parameters from the URL
    $path = $_GET['path'];
    $vis_type = $_GET['hotblocks_vis_type'];
    $global = $vis_type == 'all' ? 1 : 0;
    // Get the gid from the path
    $vis_arg = $vis_type == 'group' ? hotblocks_og_context($path, 'gid') : NULL;

    // Create the new hotblocks_item record and write to the database
    $hotblock_item = array(
      'entity_id' => $entity_id,
      'delta' => $iDelta,
      'path' => $path,
      'vis_type' => $vis_type,
      'vis_arg' => $vis_arg,
      'entity_type' => $_GET['entity_type'],
      'global' => $global,
    );
    // Write a new record
    drupal_write_record('hotblocks', $hotblock_item);
  }


  // Show the hotblocks block
  // @todo - Hotblocks utilizes Drupal.attachbehaviors on new content, but printing this content and exiting breaks
  // Drupal's built in ajax api for forms and such.  Maybe need a Drupal abstraction like ajax_deliver() ?
  print render(hotblocks_block_view_content($iDelta));

  // Let other modules react to the content change
  module_invoke_all('hotblocks_block_changed', 'added', $iDelta);

  drupal_exit();
}

/**
 * Menu callback - ajaxy except when used on the overview pages
 *
 * @param $hid
 *  - Unique ID for hotblock_item
 * @param $iDelta
 * - Delta for hotblock
 */
function hotblocks_remove_from_block($hid, $iDelta) {
  // Protect against XSRF attacks by validating a token
  if (!isset($_GET['token']) || $_GET['token'] != drupal_valid_token($_GET['token'], "hotblocks-$iDelta-$hid")) {
    drupal_access_denied();
    drupal_exit();
  }
  
  // Remove the item from our tables
  hotblocks_item_remove($hid);

  // Let other modules react to the content change
  module_invoke_all('hotblocks_block_changed', 'removed', $iDelta);
  
  // Either redirect or return block content for an ajax request
  if (!empty($_GET['destination']) && empty($_REQUEST['js'])) {
    drupal_set_message(hotblocks_terminology(FALSE, TRUE) . ' removed');
    drupal_goto();
  }
  else {
    print render(hotblocks_block_view_content($iDelta));
    drupal_exit();
  }
}


/**
 * @return
 * Returns an array of all valid hotblocks_item records from the hotblocks or node table (depending on configuration) with
 * their respective titles.
 * Each array item is an object with members entity_id and title
 * In the case of blocks, entity_id actually = bid...a legacy thing that should change one day
 */
function hotblocks_get_all_assignable_content($iDelta) {
  $aRows = array();

  // Add nodes that assignable into hotblocks
  $aRows = array_merge($aRows, hotblocks_get_assignable_nodes($iDelta));

  // Add in blocks if they are enabled as valid hotblocks_item types
  if (hotblocks_get_setting('hotblocks_allow_blocks', $iDelta)) {
    // Get an array of modified block objects and add it to our list of items
    $blocks = hotblocks_get_assignable_blocks(TRUE, $iDelta);
    $aRows = array_merge($aRows, $blocks);
  }

  // Add entities to our list if they can be assigned
  $allowed_bundles = hotblocks_get_allowed_entity_bundles($iDelta);
  if(!empty($allowed_bundles)) {
    $entities = hotblocks_get_assignable_entities($iDelta);
    $aRows = array_merge($aRows, $entities);
  }

  /**
   * usort function to sort alphabetically based on $obj->title
   */
  function hotblocks_list_sort($a, $b) {
    return strcasecmp(trim($a->title), trim($b->title));
  }
  usort($aRows, 'hotblocks_list_sort');

  // Allow other modules to alter the list of assignable content.
  // @todo - Create a hotblocks.api.php to document this hook
  drupal_alter('hotblocks_assignable_content', $aRows, $iDelta);

  return $aRows;
}

/**
 * Get a list of nodes that are are allowed to be assigned to hotblocks
 * @return array
 */
function hotblocks_get_assignable_nodes($iDelta) {
  $aRows = array();
  $aNodeTypes = array();

  $all_types = hotblocks_get_all_allowed_types($iDelta);
  if(!empty($all_types['node'])) {
    $aNodeTypes = array_keys($all_types['node']);
  }

  // If no types are configured, just return.
  if(empty($aNodeTypes)) {
    return array();
  }

  $query = db_select('node', 'n');
  $query->fields('n');
  $query->orderBy('n.title', 'ASC');
  $query->innerJoin('node_type','nt', 'n.type = nt.type');
  $query->addField('nt', 'name', 'friendlytype');

  //if our access control function isn't saying we can view all nodes with impunity, we want to respect drupals node access
  if (!hotblocks_access('view node', 'all')) {
    $query->addTag('node_access');
  }

  if (variable_get('hotblocks_show_all_nodes_of_hotblocks_item_type', TRUE)) {
    //Show all nodes of types that are allowed to be in hotblocks
    $query->condition('n.type', $aNodeTypes, 'IN');
  }
  else {
    //If all nodes of the allowed types aren't allowed to be in hotblocks, we need to rely on entries in the hotblocks table
    $query->join('hotblocks', 'h', 'h.entity_id = n.nid');
    $query->distinct();
  }
  $result = $query->execute();

  foreach ($result as $oRow) {
    //We still need to check access for cases like unpublished nodes that db_rewrite_sql didnt catch or grants like 'administer hotblocks'
    //@todo - does the above statement still hold true?
    if (!hotblocks_access('view node', $oRow)) {
      continue;
    }
    $oRow->entity_type = 'node';

    //In the future this object will be treated like a hotblock item object which reads entity_id and not nid
    $oRow->entity_id = $oRow->nid;

    $aRows[] = $oRow;
  }

  return $aRows;
}

/**
 * Return an array of block objects
 * Block objects are modified with some properties to make
 * utilizing the object more consistent with the way nodes are handled
 */
function hotblocks_get_assignable_blocks($respectFilters = TRUE, $iDelta = null) {
  //Get an array of block arrays from the block module
  $blocks = _block_rehash();

  //Whitelisting
  $use_whitelist = hotblocks_get_setting('hotblocks_block_only_whitelist', $iDelta);
  $whitelist = hotblocks_get_setting('hotblocks_blocks_whitelist', $iDelta);

  //Blacklisted modules
  $blacklist = hotblocks_get_setting('hotblocks_blocks_excluded_modules', $iDelta);

  $aRows = array();
  foreach ($blocks as $aBlock) {

    //Skip blocks from modules that the user has excluded in settings
    if (in_array($aBlock['module'], $blacklist)) {
      continue;
    }

    //Skip blocks that are not whitelisted if we have the whitelist option turned on
    //Only do the check if $respectFilters is true - settings page does not want these filtered
    if ($use_whitelist && $respectFilters) {
      $unique_id = $aBlock['module'] . '_' . $aBlock['delta'];
      //Don't show this block if it's not in our whitelist
      if (!in_array($unique_id, $whitelist)) {
        continue;
      }
    }

    //Make a pretend entity object from our block array that's in a similar format as node objects
    $oRow = new stdClass();
    $oRow->entity_id = $aBlock['bid'];
    $oRow->entity_type = 'block';
    $oRow->friendlytype = 'Block';
    $oRow->title = $aBlock['info'];
    $oRow->block = $aBlock;
    $aRows[] = $oRow;
  }

  return $aRows;
}

/**
 * Return an array of hotblock_items for the list of assignable entities
 */
function hotblocks_get_assignable_entities($iDelta) {
  $entity_all_info = entity_get_info();

  $items = array();

  // Add entities to our list if they can be assigned
  $allowed_bundles = hotblocks_get_allowed_entity_bundles($iDelta);
  if(!empty($allowed_bundles)) {
    foreach ($allowed_bundles as $entity_type => $bundles) {
      foreach ($bundles as $bundle) {
        // Query for all entities of this type and bundle
        $query = new EntityFieldQuery();
        $query->entityCondition('entity_type', $entity_type);

        // Note: The "comment" entity type does not support bundle conditions.
        // (https://api.drupal.org/api/drupal/includes!entity.inc/function/EntityFieldQuery%3A%3AentityCondition/7 )
        if($entity_type != 'comment') {
          $query->entityCondition('bundle', $bundle);
        }

        $result = $query->execute();

        if (isset($result[$entity_type])) {
          $ids = array_keys($result[$entity_type]);
          $entities = entity_load($entity_type, $ids);

          // Add these entity ids to our rows
          foreach ($entities as $id => $entity) {
            $wrapper = entity_metadata_wrapper($entity_type, $entity);
            $hotblock_item = new stdClass();
            $hotblock_item->entity_type = $entity_type;
            $hotblock_item->entity_id = $id;
            $hotblock_item->title = $wrapper->label();
            $hotblock_item->friendlytype = $entity_all_info[$entity_type]['bundles'][$bundle]['label'];

            $items[] = $hotblock_item;
          }
        }
      }
    }
  }
  return $items;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function hotblocks_get_perm($sOp, $sType = NULL, $iDelta) {
  switch ($sOp) {
    case 'assign items to any hotblock':
      return sprintf('assign items of type %s to %s', $sType, hotblocks_get_block_label($iDelta));
      break;

    case 'remove items from any hotblock':
      return sprintf('remove items of type %s from %s', $sType, hotblocks_get_block_label($iDelta));
      break;

    case 'reorder items in any hotblock':
      return sprintf('reorder items in %s', hotblocks_get_block_label($iDelta));
      break;

  }
}

/**
 * Access control for various hotblocks_item operations
 *
 * @param $sOp:
 * Can be:
 * create
 * assign hotblocks
 * remove hotblocks
 * reorder hotblocks
 * administer hotblocks
 * view node
 * any block controls
 *
 * @param $sType
 * Node type or node id which will be queried for type, or in the case of 'view node' can be a node object or entity_id
 *
 * @param $iDelta
 * Hotblocks_Item block delta
 *
 * @return boolean
 */
function hotblocks_access($sOp, $sType = NULL, $iDelta = NULL) {
  //Users with administer hotblocks can do whatever they want
  if (user_access('administer hotblocks')) {
    return TRUE;
  }
  
  //This check determines whether the user can do any operations to a given block 
  //(not an item in the block, but to the block): assign, create, or order
  if($sOp == 'any block controls') {
    if (hotblocks_access('assign items to any hotblock', NULL, $iDelta)) {
      return TRUE;
    }
    if (hotblocks_access('create items in any hotblock', NULL, $iDelta)) {
      return TRUE;
    }
    if (hotblocks_access('reorder items in any hotblock', NULL, $iDelta)) {
      return TRUE;
    }
    
    //If none of the above conditions were true, return false
    return FALSE;
  }

  if ($sOp == 'view node') {
    if ($sType == 'all') {
      //We're saying you cant view all nodes without a node access check first (if respect node access is on)
      return !variable_get('hotblocks_respect_node_access', TRUE);
    }

    if (is_numeric($sType)) {
      $oNode = node_load($sType);
    }
    else {
      $oNode = $sType;
    }

    //we will respect node access unless the option is turned off, in which case a user only need some permission to administer the hotblock to see the node
    return node_access('view', $oNode) || ( !variable_get('hotblocks_respect_node_access', TRUE) && hotblocks_access('any block controls', NULL, $iDelta) );
  }

  //if extended permissions is not on, we can just return the user_access equivilent of the op
  if (!variable_get('hotblocks_extended_permissions', FALSE)) {
    return user_access($sOp);
  }

  //The generic permission supercedes granular permissions, so if we have it return true (except with 'create items in any hotblock', see below)
  if ($sOp != 'create items in any hotblock' && user_access($sOp)) {
    return TRUE;
  }

  if (is_numeric($sType)) {
    $sType = db_query("SELECT type FROM {node} WHERE nid = :nid", array(':nid' => $sType))->fetchField();
  }

  switch ($sOp) {
    case 'assign items to any hotblock':
    case 'remove items from any hotblock':
      if (!$iDelta) {
        return user_access($sOp);
      }
      if (!$sType) {
        //If no type is specified we check if the user has at least 1 specific permission for that block
        foreach (hotblocks_get_allowed_node_types($iDelta) as $sCheckType) {
          if (hotblocks_access($sOp, $sCheckType, $iDelta)) {
            return TRUE;
          }
        }
        return FALSE;
      }
      //if we have a type and delta we can fall through to 'reorder items in any hotblock' case for its granular check
    case 'reorder items in any hotblock':
      return user_access(hotblocks_get_perm($sOp, $sType, $iDelta));
      break;

    case 'administer hotblocks':
      return user_access($sOp);
      break;

    case 'create items in any hotblock':
      //If a block is asking, verify that we can also assign the hotblocks_item there as well, otherwise the permission is meaningless (to a block)
      if ($iDelta) {
        if ($sType) {
          return node_access('create', $sType) && hotblocks_access('assign items to any hotblock', $sType, $iDelta);
        }
        else {
          return user_access('create items in any hotblock') && hotblocks_access('assign items to any hotblock', $sType, $iDelta);
        }
      }
      return user_access('create items in any hotblock');
      break;
  }
  return FALSE;
}

/**
 * Get an array of hotblock objects for a given block for a certain URL path.
 *
 * @param $iDelta
 * - Block delta
 * @param $path
 * - Drupal path to look for items in
 * @return array
 * - Return an array of hotblock objects straight from the database query.
 */
function hotblocks_block_get_items($iDelta, $path) {
  $hotblock_items = array();

  // Query for global items in this block
  $hotblock_items = array_merge($hotblock_items, db_query("
    SELECT h.*, hw.path hw_path, hw.weight hw_weight FROM {hotblocks h}
    LEFT JOIN {hotblocks_weight hw} ON h.hid = hw.hid AND hw.path = :path
    WHERE h.delta = :delta AND h.vis_type = 'all'",
    array(':delta' => $iDelta, ':path' => $path))->fetchAll());

  // Query for items based on group content
  if(module_exists('og_context')) {
    $gid = hotblocks_og_context($path, 'gid');
    if(!empty($gid)) {
      $hotblock_items = array_merge($hotblock_items, db_query("
        SELECT h.*, hw.path hw_path, hw.weight hw_weight FROM {hotblocks h}
        LEFT JOIN {hotblocks_weight hw} ON h.hid = hw.hid AND hw.path = :path
        WHERE h.delta = :delta AND h.vis_type = 'group' AND h.vis_arg = :gid",
        array(':delta' => $iDelta, ':path' => $path, ':gid' => $gid))->fetchAll());
    }
  }

  // Query for items specifically assigned to this path
  $hotblock_items = array_merge($hotblock_items, db_query("
    SELECT h.*, hw.path hw_path, hw.weight hw_weight FROM {hotblocks h}
    LEFT JOIN {hotblocks_weight hw} ON h.hid = hw.hid AND hw.path = :path
    WHERE h.delta = :delta AND h.vis_type = 'page' AND h.path = :path",
    array(':delta' => $iDelta, ':path' => $path))->fetchAll());

  // Sort all the items by their hw_weight
  usort($hotblock_items, 'hotblock_items_sort');

  // Populate the 'title' property for blocks
  foreach ($hotblock_items as $hotblock_item) {
    hotblocks_item_preload($hotblock_item);
  }

  return $hotblock_items;
}

/**
 * Add properties to the hotblock_item object while it's being loaded.
 * Currently this just adds in the $hotblock_item->title property.
 */
function hotblocks_item_preload($hotblock_item) {
  if ($hotblock_item->entity_type == 'block') {
    // Load the basic block object from the database
    $block = _hotblocks_get_block_by_bid($hotblock_item->entity_id);

    // Add the block info onto the hotblock_item
    $hotblock_item->block = $block;

    // Set the item title - used later if reordering or when the block is empty
    $hotblock_item->title = hotblocks_get_block_title_by_bid($block);

    // Set the item's edit URL
    $hotblock_item->edit_url = "admin/structure/block/manage/{$block->module}/{$block->delta}/configure";

    $hotblock_item->friendlyType = 'Block';

    // No URI exists for individual blocks, so the 'link' will just be a plain text label
    $hotblock_item->link = $hotblock_item->title;
  }
  elseif ($hotblock_item->entity_type == 'node') {
    // Grab the node title from the DB
    $hotblock_item->title = db_query("SELECT title FROM {node} WHERE nid = :nid", array(':nid' => $hotblock_item->entity_id))->fetchField();

    // Set the item's edit URL
    $hotblock_item->edit_url = "node/{$hotblock_item->entity_id}/edit";

    // Set the item's view URL
    $hotblock_item->view_url = "node/{$hotblock_item->entity_id}";

    // Query the human readable node type label directly from the DB
    $hotblock_item->friendlyType = db_query("SELECT nt.name FROM {node} n, {node_type} nt WHERE n.nid = :nid AND n.type = nt.type", array(':nid' => $hotblock_item->entity_id))->fetchField();

    // Link to this item
    $hotblock_item->link = l($hotblock_item->title, "node/{$hotblock_item->entity_id}");
  }
  else {
    // Load the entity object and an entity_metadata_wrapper
    $entity = entity_load_single($hotblock_item->entity_type, $hotblock_item->entity_id);
    $wrapper = entity_metadata_wrapper($hotblock_item->entity_type, $entity);

    // Attach the entity and wrapper to the $hotblock_item so other code that may want this info doesn't have to relaod
    $hotblock_item->entity = $entity;
    $hotblock_item->entity_wrapper = $wrapper;

    // Populate the $hotblock_item with the required title
    $hotblock_item->title = $wrapper->label();

    // Set the item's edit URL
    // We're just taking our best guess at this based on entity URI, which we just add '/edit' to.  This is correct
    // for all cases that I can think of - node, taxonomy, user, ECK
    // todo - There's probably a way to verify the validity of this link
    $uri = entity_uri($hotblock_item->entity_type, $entity);
    if(!empty($uri['path'])) {
      $hotblock_item->edit_url =  $uri['path'] . '/edit';

      // Set the item's view URL
      $hotblock_item->view_url = $uri['path'];

      $hotblock_item->link = l($hotblock_item->title, $hotblock_item->view_url);
    }

    // In order to determine the 'friendly' name of this entity type, we need to get all entity info, then extract the
    // bundle of this entity via entity_extract_ids which we can use to locate the label in the entity info
    $entity_all_info = entity_get_info();
    try {
      list($entity_id, $entity_vid, $entity_bundle) = entity_extract_ids($hotblock_item->entity_type, $hotblock_item);
      $hotblock_item->friendlyType = $entity_all_info[$hotblock_item->entity_type]['bundles'][$entity_bundle]['label'];
    }
    catch (Exception $e) {
    }
  }
}

/***********@todo - these should probably all be theme functions *********************/

function hotblocks_block_view_content($iDelta) {
  //path will be set if this is a reload request from an ajax action, otherwise use the current page
  if(isset($_GET['path'])) {
    $path = $_GET['path'];
    
    //Fudge the path that Drupal thinks it's loading - this way, blocks that depend on arguments in the 
    //url and such will load in that context.  This is only relevant when ajax is requesting to reload a
    //block outside of a full page refresh.
    $_GET['q'] = $path;

    // Fix form #actions going to hotblocks page:
    // drupal_prepare_form() invokes hook_element_info, which calls system_element_info() which sets the default
    // drupal form #action to request_uri() which looks at the $_SERVER['REQUEST_URI'].  In this case, we need to trick drupal into thinking the request
    // uri is different, otherwise the form action for a newly added hotblock item will point to the last ajax url
    // (/hotblocks/assign/344/2?destination=...etc).  We have to alter the request URI for this rendering only.
    // We can disregard SERVER['argv'] as hotblocks won't be added from the command line
    // When this function is called from hotblocks_reorder_form() it causes the 'cancel' button to break.
    $_SERVER['REQUEST_URI'] = base_path() . $path;
  }

  $path = isset($_GET['path']) ? $_GET['path'] : current_path();

  // Get hotblock items for this block and path
  $hotblock_items = hotblocks_block_get_items($iDelta, $path);

  $renderOutput = array(
    '#type'       => 'container',
    '#attributes' => array(
      'class' => array('hotblock-wrapper'),
    ),
  );
  // Add classes based on items
  if(sizeof($hotblock_items) > 0) {
    $renderOutput['#attributes']['class'][] = 'has-items';
    $renderOutput['#attributes']['class'][] = 'items-count-' . sizeof($hotblock_items);
  }
  else {
    $renderOutput['#attributes']['class'][] = 'empty';
  }
  // Add class based on 'floating controls' settings
  if (variable_get('hotblocks_floating_controls', TRUE)) {
    $renderOutput['#attributes']['class'][] = 'floating';
  }

  // Get the markup for the block controls of this hotblock and add to output
  if (hotblocks_access('any block controls', NULL, $iDelta)) {
    $bBlockHasItems = sizeof($hotblock_items) > 0 ? TRUE : FALSE;
    $renderOutput['block_controls'] = hotblocks_block_controls($iDelta, $bBlockHasItems);
    $maximum_items = hotblocks_get_setting('maximum_items', $iDelta);

    // Remove the 'add content' link if the block has more items than the allowed maximum
    if(!empty($maximum_items) && sizeof($hotblock_items) >= $maximum_items) {
      $renderOutput['block_controls']['assignlink']['#access'] = FALSE;
    }

    // Remove the 'reorder' link if the block does not have more than one item
    if(sizeof($hotblock_items) < 2) {
      $renderOutput['block_controls']['reorderlink']['#access'] = FALSE;
    }

    // Add an 'editable' class to indicate the block is editable by the user.
    $renderOutput['#attributes']['class'][] = 'editable';
  }

  // Assign a global variable to hotblock_items so we can access it in other functions
  $GLOBALS['hotblock_items'] = $hotblock_items;

  // Iterate through our items and add to the render array
  foreach ($hotblock_items as $hb_item) {
    $item_view = hotblocks_item_view($hb_item, $iDelta);
    if (!empty($item_view)) {
      $renderOutput['items'][] = $item_view;
    }
  }

  // Reset our global
  $GLOBALS['hotblock_items'] = NULL;

  return $renderOutput;
}

/**
 * usort callback to sort the hotblock_items retrieved in a block
 */
function hotblock_items_sort($hotblock_item_a, $hotblock_item_b) {
  $a = $hotblock_item_a->hw_weight;
  $b = $hotblock_item_b->hw_weight;
  if ($a == $b) {
    return 0;
  }
  return ($a < $b) ? -1 : 1;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function hotblocks_terminology($bPlural = FALSE, $bCapitalize = FALSE) {
  if ($bPlural) {
    $terminology = variable_get('hotblocks_terminology_plural', HOTBLOCKS_DEFAULT_TERMINOLOGY_PLURAL);
  }
  else {
    $terminology = variable_get('hotblocks_terminology', HOTBLOCKS_DEFAULT_TERMINOLOGY);
  }

  if ($bCapitalize) {
    $terminology = ucfirst($terminology);
  }

  return check_plain($terminology);
}

/**
 * Get og context info about a path
 * 
 * We're really only handling the case of organic groups as nodes.
 *
 * @param $path
 *  - A drupal path, like node/24
 * @param $return
 *  - The type of information to return - 'gid' or 'title'
 */
function hotblocks_og_context($path, $return = 'gid') {
  if(module_exists('og_context')) {
    //Get context (an array) from the og_context module to figure out which gid this group or group content is associated with
    $node = menu_get_object('node', 1, $path);


    $og_context = _group_context_handler_entity('node', $node);
    //This next line is commented because it seems the og_context functions don't do as they claim and accept variable input
    //to determine og context, instead they keep trying to look at the current menu path, which wont work because we're in a modal
    //$og_context = og_context_determine_context('node', $menu_item);

    if(is_array($og_context)) {
      if(!empty($og_context['node'])) {
        // This is a group node
        // Grab the first group ID.
        $gid = reset($og_context['node']);
      }
      else {
        //This is group content
        //Grab it's first gid (NOTE currently we do not support content in multiple groups)
        $gid = reset($og_context);
      }

      if($return == 'title') {
        //Return the label of the group
        $group = og_load($gid);
        return $group->label;
      }
      else {
        //return a gid
        return $gid;
      }
    }
  }
}

/**
 * Helper function to get a block title from its bid
 */
function hotblocks_get_block_title_by_bid($block) {
  if (is_numeric($block)) {
    $block = db_query("SELECT * FROM {block} WHERE bid = :bid", array(':bid' => $block))->fetchObject();
  }
  $aBlockInfo = module_invoke($block->module, 'block_info');

  if(isset($aBlockInfo[$block->delta]['info'])) {
    return $aBlockInfo[$block->delta]['info'];
  }
  else {
    return FALSE;
  }

}


/**
 * Offer some template suggestions for nodes being themed inside a hotblock
 */
function hotblocks_preprocess_node(&$vars) {
  //If we're viewing nodes in the context of a hotblock, offer some template suggestions by default
  if (isset($vars['node']->hotblocks_view) && $vars['node']->hotblocks_view == TRUE) {
    $vars['template_files'][] = 'hotblocks';
    $vars['template_files'][] = 'hotblocks-' . $vars['node']->type;
  }
}


/**
 * Return a block from a given block id
 * @todo - I'm sure there is a function provided by the block module that is more appropriate for this
 * @param $bid int
 *  -A n integer of the requested block id
 */
function _hotblocks_get_block_by_bid($bid) {
  //check custom block table
  $block = block_custom_block_get($bid);
  if($block) {
    return $block;
  }
  
  //then check block table
  $block = db_query('SELECT * FROM {block} WHERE bid = :bid', array(':bid' => $bid))->fetchObject();
  if($block) {
    return $block;
  }
  
  return FALSE;
}

/**
 * Implementation of hook_ctools_plugin_directory().
 */
function hotblocks_ctools_plugin_directory($module, $plugin) {
  if ($module == 'ctools' && $plugin == 'export_ui') {
    return 'ctools-plugins/export_ui';
  }
}

/**
 * Given a potential  machine_name/delta, return true if a hotblock already exists in the system with that machine_name
 */
function hotblocks_check_machine_name_if_exist($name) {
  return db_query("SELECT COUNT(*) FROM {hotblocks_settings} WHERE machine_name = :name", array(':name' => $name))->fetchField();
}
