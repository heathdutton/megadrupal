<?php

require_once('hotblocks_wysiwyg.filter.php');

/**
 * Implements hook_menu().
 */
function hotblocks_wysiwyg_menu() {
  $items = array();

  $items['admin/content/hotblocks/wysiwyg_usage'] = array(
    'title'            => 'WYSIWYG usage',
    'page callback'    => 'hotblocks_wysiwyg_page',
    'access callback'  => 'hotblocks_access',
    'access arguments' => array('administer hotblocks'),
    'type'             => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Implements hook_wysiwyg_include_directory().
 */
function hotblocks_wysiwyg_wysiwyg_include_directory($type) {
  switch ($type) {
    case 'plugins':
      return 'plugins';
      break;
  }
}

/**
 * Implements hook_field_attach_insert().
 *
 * Track file usage for media files included in formatted text. Note that this
 * is heavy-handed, and should be replaced when Drupal's filter system is
 * context-aware.
 */
function hotblocks_wysiwyg_field_attach_insert($entity_type, $entity) {
  _hotblocks_wysiwyg_filter_add_file_usage_from_fields($entity_type, $entity);
}

/**
 * Implements hook_field_attach_update().
 *
 * @see media_field_attach_insert().
 */
function hotblocks_wysiwyg_field_attach_update($entity_type, $entity) {
  _hotblocks_wysiwyg_filter_add_file_usage_from_fields($entity_type, $entity);
}

/**
 * Add file usage from file references in an entity's text fields.
 */
function _hotblocks_wysiwyg_filter_add_file_usage_from_fields($entity_type, $entity) {
  // Extract the entity id, vid, and bundle. We only need the id.
  list($entity_id, $entity_vid, $entity_bundle) = entity_extract_ids($entity_type, $entity);

  // Clear out all usages for this entity, we'll rebuild them next.
  // Unlike media_wysiwyg, this module does not consider usages in other revisions of a given entity - only the most
  // recent/published entity has usages tracked.  This is simpler and feels more in line with what a user would expect
  // to see when examining the usage list. When tested with workbench moderation, the usages in the draft were ignored
  // and only the published version was tracked - unless no published version existed (in which case draft usages count).
  db_query("DELETE FROM {hotblocks_wysiwyg_usage} WHERE entity_id_source = :id AND entity_type_source = :type", array(':id' => $entity_id, ':type' => $entity_type));

  // Track the total usage of entities from all fields combined.
  $hotblock_items = hotblocks_wysiwyg_get_hotblock_item_counts_in_all_fields($entity_type, $entity);

  // Iterate through all found entities and update the hotblocks_wysiwyg_usage table with usage counts, provided that
  // the entity is valid (in existance) and can be loaded.
  foreach ($hotblock_items as $referenced_entity_type => $referenced_entities) {
    foreach ($referenced_entities as $referenced_entity_id => $entity_count) {
      $hotblock_item = (object) array('entity_id' => $referenced_entity_id, 'entity_type' => $referenced_entity_type);

      // Attempt to partially load the entity
      try {
        hotblocks_item_preload($hotblock_item);
      }
      catch (Exception $e) {
        // If we encountered an error trying to load this item, don't add its usage.
        continue;
      }

      // Verify that the entity exists and can be loaded - if it was able to derive a title, we'll consider it a success.
      // the hotblocks_item_preload function may not be the most reliable way to determine entity existance, but it helps
      // us test the 'block' entity_type which is not truly an entity type, but just an ordinary Drupal block.  Otherwise,
      // entity_load_single() would be adequate.
      if (!empty($hotblock_item->title)) {
        $record = array(
          'entity_id' =>  $referenced_entity_id,
          'entity_type' => $referenced_entity_type,
          'entity_id_source' => $entity_id,
          'entity_type_source' => $entity_type,
          'count' => $entity_count,
        );
        drupal_write_record('hotblocks_wysiwyg_usage', $record);
      }
    }
  }

  // todo maybe? - If a file entity is embedded in the WYSIWYG, we should call file_usage_add and register hotblocks_wysiwyg
  // as the module using the file - but we don't really expect hotblocks to be used for embedding files when media.module
  // or modules like IMCE already handling this.do this much better - still, it's a legitimite possibility.
}


/**
 * Utility function to get the a count of usages for each hotblock_item embedded in any/all fields of the given entity
 *
 * @param $entity
 * @param $entity_type
 * @return array
 * - An array of arrays, first keyed by entity type, then keyed by entity id. Value is the count of usages.
 */
function hotblocks_wysiwyg_get_hotblock_item_counts_in_all_fields($entity_type, $entity) {
  $hotblock_items = array();
  foreach (hotblocks_wysiwyg_filter_parse_from_fields($entity_type, $entity) as $hotblock_item) {
    if (empty($hotblock_items[$hotblock_item->entity_type][$hotblock_item->entity_id])) {
      // Set usage to 1 - this is the first time we've seen this entity used
      $hotblock_items[$hotblock_item->entity_type][$hotblock_item->entity_id] = 1;
    }
    else {
      // We already found this entity used once, so increment the usage counter
      $hotblock_items[$hotblock_item->entity_type][$hotblock_item->entity_id]++;
    }
  }
  return $hotblock_items;
}

/**
 * Parse hotblock_items embedded in an entity's text fields and return them as an array.
 */
function hotblocks_wysiwyg_filter_parse_from_fields($entity_type, $entity) {
  $entity_references = array();

  foreach (hotblocks_wysiwyg_filter_fields_with_text_filtering($entity_type, $entity) as $field_name) {
    if ($field_items = field_get_items($entity_type, $entity, $field_name)) {
      foreach ($field_items as $field_item) {
        preg_match_all(HOTBLOCKS_WYSIWYG_REGEX, $field_item['value'], $matches);

        // Skip this field if we didn't find any matches
        if(sizeof($matches) < 2) {
          continue;
        }

        // Iterate through all the matches of the 'data-hotblocks' attribute found in our hotblocks img tokens
        foreach ($matches[1] as $attr) {
          $hotblocks_item = hotblocks_wysiwyg_filter_parse_wysiwyg_token($attr);
          // Add it to our list if we were able to parse entity information from it.
          if(!empty($hotblocks_item)) {
            $entity_references[] = $hotblocks_item;
          }
        }
      }
    }
  }

  return $entity_references;
}

/**
 * Implements hook_entity_delete().
 *
 * Delete all usages for this entity
 */
function hotblocks_wysiwyg_entity_delete($entity, $type) {
  list($entity_id) = entity_extract_ids($type, $entity);

  db_delete('hotblocks_wysiwyg_usage')
    ->condition('entity_type_source', $type)
    ->condition('entity_id_source', $entity_id)
    ->execute();
}

/**
 * Returns an array containing the names of all fields that perform text filtering.
 * (copied from media_wysiwyg.module)
 */
function hotblocks_wysiwyg_filter_fields_with_text_filtering($entity_type, $entity) {
  list($entity_id, $revision_id, $bundle) = entity_extract_ids($entity_type, $entity);
  $fields = field_info_instances($entity_type, $bundle);

  // Get all of the fields on this entity that allow text filtering.
  $fields_with_text_filtering = array();
  foreach ($fields as $field_name => $field) {
    if (!empty($field['settings']['text_processing'])) {
      $fields_with_text_filtering[] = $field_name;
    }
  }

  return $fields_with_text_filtering;
}

/**
 * Implements hook_entity_dependencies().
 * Hook from Entity Dependency API module - code adapted from media_wysiwyg but not tested, but it's pretty straightforward.
 */
function hotblocks_wysiwyg_entity_dependencies($entity, $entity_type) {
  // Go through all the entity's text fields and add a dependency on any files
  // that are referenced there.
  $dependencies = array();
  foreach (hotblocks_wysiwyg_filter_parse_from_fields($entity_type, $entity) as $hotblock_item) {
    $dependencies[] = array('type' => $hotblock_item->entity_type, 'id' => $hotblock_item->entity_id);
  }
  return $dependencies;
}

/**
 * Page callback for 'admin/content/hotblocks/wysiwyg_usage'
 * This displays an administrative overview of each entity that is embedded in a WYSIWYG field.
 */
function hotblocks_wysiwyg_page() {
  // Select all rows from the hotblocks_wysiwyg_usage table - todo: This is not a scalable approach if the table grows very large
  $result = db_query("SELECT * FROM {hotblocks_wysiwyg_usage}");

  // Group results by the entity being embedded, with each source listed individually per entity
  $entities_grouped = array();
  foreach ($result as $row) {
    $entities_grouped[$row->entity_type][$row->entity_id][] = array(
      'entity_type_source' => $row->entity_type_source,
      'entity_id_source' => $row->entity_id_source,
      'count' => $row->count,
    );
  }

  // Now build table rows
  $rows = array();
  foreach ($entities_grouped as $entity_type => $entity_source_array) {
    foreach ($entity_source_array as $entity_id => $source_info) {
      // Get info about the embedded entity - we just want a link to it and the human-readable label for its entity type.
      $entity_stub = (object) array(
        'entity_id' => $entity_id,
        'entity_type' => $entity_type,
      );
      hotblocks_item_preload($entity_stub);

      // Build a mini table for all of the sources that this entity is embedded in
      $source_table_header = array('Source', 'Usages');
      $source_table_rows = array();
      foreach ($source_info as $info_array) {
        // Preload this entity
        $entity_source_stub = (object) array(
          'entity_id' => $info_array['entity_id_source'],
          'entity_type' => $info_array['entity_type_source'],
        );
        hotblocks_item_preload($entity_source_stub);

        // Add the row to our mini-table
        $source_table_rows[] = array($entity_source_stub->link, array('data' => $info_array['count'], 'width' => '20%'));
      }
      $used_in = theme('table', array('header' => $source_table_header, 'rows' => $source_table_rows, 'sticky' => FALSE));

      // Add this complete row: Link, Entity type, Table of sources
      $rows[] = array(
        array('data' => $entity_stub->title, 'style' => 'display:none;'), // This hidden column is used only for sorting
        $entity_stub->link,
        $entity_stub->friendlyType,
        $used_in,
      );
    }
  }

  // Build the table header with sort fields specified
  $header = array(
    array('data' => 'Title', 'style' => 'display:none;', 'field' => 'title'),
    array('data' => 'Embedded entity', 'field' => 'title', 'sort' => 'asc'),
    array('data' => 'Entity type', 'field' => 'type'),
    'Used in'
  );

  // Sort the table rows based on tablesort configuration
  hotblocks_wysiwyg_sort_table($header, $rows);

  // Build the final render array and return
  $render = array(
    'usage_table' => array(
      '#theme'  => 'table',
      '#header' => $header,
      '#rows'   => $rows,
      '#empty'  => t('No WYSIWYG usages detected.'),
      '#sticky' => TRUE,
    ),
  );
  return $render;
}

function hotblocks_wysiwyg_sort_table($header, &$rows) {
  // Ascertain the sort field and sort order using tablesort functions
  $tablesort_get_order = tablesort_get_order($header);
  $sort_field = $tablesort_get_order['sql'];
  $sort_direction = tablesort_get_sort($header);

  // Lookup the index of the sort field in the header array
  $sort_column = 0; // Assume the first column as the sort by default if we can't find the sort field
  foreach ($header as $i => $header_array) {
    if(!empty($header_array['field']) && $header_array['field'] == $sort_field) {
      $sort_column = $i;
      break;
    }
  }

  // Sort the table rows based on specified sort column and direction
  usort($rows, function ($a, $b) use ($sort_column, $sort_direction, $header) {
    // Swap the order of $a and $b for a descending sort
    if ($sort_direction == 'desc') {
      list($a, $b) = array($b, $a);
    }

    // Use the 'data' portion of the row array if it exists, otherwise the data is directly in the column.
    $a = !empty($a[$sort_column]['data']) ? $a[$sort_column]['data'] : $a[$sort_column];
    $b = !empty($b[$sort_column]['data']) ? $b[$sort_column]['data'] : $b[$sort_column];

    // Case-insensitive string comparison with whitespace trimming.
    return strcasecmp(trim($a), trim($b));
  });
}