<?php

/**
 * @file
 * Defines core Space Launches module functionality.
 */

/**
 * Implements hook_entity_info()
 */
function space_launches_entity_info() {
  $entities = array();

  $entities['space_launches_launch'] = array(
    'label' => t('Launch'),
    'plural label' => t('Launches'),
    'controller class' => 'SpaceLaunchesLaunchEntityController',
    'rules controller class' => 'EntityDefaultRulesController',
    'entity class' => 'SpaceLaunchesLaunch',
    'base table' => 'space_launches_launch',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'launch_id',
      'label' => 'title',
    ),
    'uri callback' => 'entity_class_uri',
    'module' => 'space_launches',
    'label callback' => 'entity_class_label',
  );

  return $entities;
}

/**
 * Implements hook_hook_info()
 */
function space_launches_hook_info() {
  $hooks = array(
    'space_launches_import' => array(
      'group' => 'space_launches',
    ),
  );

  return $hooks;
}

/**
 * Implements hook_block_info()
 */
function space_launches_block_info() {
  $blocks['upcoming_launches'] = array(
    'info' => t('Upcoming space launches'),
    'cache' => DRUPAL_CACHE_PER_ROLE,
  );

  return $blocks;
}

/**
 * Implements hook_block_view()
 */
function space_launches_block_view($delta = '') {
  $block = array();

  switch ($delta) {
    case 'upcoming_launches':
      $block['subject'] = t('Upcoming launches');
      $block['content'] = array(
        '#theme' => 'upcoming_launches_list',
        '#launches' => space_launches_get_upcoming_launches(),
      );
      break;
  }

  return $block;
}

/**
 * Implements hook_theme()
 */
function space_launches_theme() {
  $items = array();

  $items['upcoming_launches_list'] = array(
    'path' => drupal_get_path('module', 'space_launches') . '/templates',
    'template' => 'upcoming_launches_list',
    'variables' => array(
      'launches' => array(),
      'full' => FALSE,
      'date_format' => 'd M Y',
      'time_format' => 'H:i:s T',
      'timezone' => date_default_timezone_get(),
    ),
  );

  return $items;
}

/**
 * Implements hook_cron_queue_info()
 */
function space_launches_cron_queue_info() {
  $queues['process_launches'] = array(
    'worker callback' => 'space_launches_process_launch',
    'time' => 120,
  );

  return $queues;
}

/**
 * Implements hook_cron()
 */
function space_launches_cron() {
  $queue = DrupalQueue::get('process_launches');

  foreach (module_implements('space_launches_import') as $module) {
    foreach (module_invoke($module, 'space_launches_import') as $launch) {
      $queue->createItem($launch);
    }
  }
}

/**
 * Converts an array of launch data into a new or updated launch entity.
 *
 * @param type $data
 *   Array of launch data.
 *   See hook_space_launches_import() for structure.
 */
function space_launches_process_launch($data) {
  /* @var $launch SpaceLaunchesLaunch */
  $launch = space_launches_get_launch_by_source_uid($data['source_uid']);

  if ($launch != NULL) {
    // Found an existing launch.
    if ($data['source_updated'] > $launch->source_updated) {
      // Update the launch if it has been updated since the last import.
      $launch->source_updated = $data['source_updated'];
      $launch->title = $data['title'];
      $launch->description = $data['description'];
      $launch->url = $data['url'];
      $launch->time = $data['time'];
      $launch->time_is_exact = $data['time_is_exact'];

      $launch->save();
    }
  }
  else {
    // Create and save a new launch.
    $launch = entity_create('space_launches_launch', $data);
    $launch->save();
  }
}

/**
 * Gets an existing launch entity by the source UID, if one exists.
 *
 * @param string $source_uid
 *   The unique ID assigned to the launch by the source.
 */
function space_launches_get_launch_by_source_uid($source_uid) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'space_launches_launch')
      ->propertyCondition('source_uid', $source_uid, '=');

  $result = $query->execute();

  if (!empty($result) && isset($result['space_launches_launch'])) {
    $launch_result = current($result['space_launches_launch']);
    $launch = entity_load_single('space_launches_launch', $launch_result->launch_id);

    return $launch;
  }

  return NULL;
}

/**
 * Gets an array of launch entities for future launches.
 *
 * @param string $source
 *   Optional: The source to filter launches by.
 * @param type $limit
 *   Optional: The maximum number of launches.
 */
function space_launches_get_upcoming_launches($source = NULL, $limit = NULL) {
  $launches = array();

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'space_launches_launch')
      ->propertyCondition('time', time(), '>');

  if ($source != NULL) {
    $query->propertyCondition('source', $source, '=');
  }

  if ($limit != NULL) {
    $query->range(0, $limit);
  }

  $result = $query->execute();

  if (!empty($result) && isset($result['space_launches_launch'])) {
    $launch_ids = array_keys($result['space_launches_launch']);

    foreach ($launch_ids as $launch_id) {
      $launches[] = entity_load_single('space_launches_launch', $launch_id);
    }
  }

  return $launches;
}
