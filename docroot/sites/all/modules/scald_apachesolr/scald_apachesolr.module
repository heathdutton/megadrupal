<?php
/**
 * @file
 * Code for Scald Apache Solr.
 */

/**
 * Implements hook_apachesolr_entity_info_alter().
 */
function scald_apachesolr_apachesolr_entity_info_alter(array &$entity_info) {
  $entity_info['scald_atom']['indexable'] = TRUE;
  $entity_info['scald_atom']['status callback'][] = '_scald_apachesolr_scald_atom_status_callback';
  $entity_info['scald_atom']['document callback'][] = '_scald_apachesolr_scald_atom_solr_document';
  $entity_info['scald_atom']['reindex callback'] = '_scald_apachesolr_scald_atom_solr_reindex';
  $entity_info['scald_atom']['index_table'] = 'apachesolr_index_entities_scald_atom';
}

/**
 * Implements hook_entity_info_alter().
 */
function scald_apachesolr_entity_info_alter(&$entity_info) {
  $entity_info['scald_atom']['view modes']['search_index'] = array(
    'label' => t('Search index'),
    'custom settings' => FALSE,
  );

  $entity_info['scald_atom']['view modes']['search_result'] = array(
    'label' => t('Search result highlighting input'),
    'custom settings' => FALSE,
  );
}

/**
 * Implements hook_scald_contexts().
 */
function scald_apachesolr_scald_contexts() {
  return array(
    'search_index' => array(
      'title' => t('Search index'),
      'description' => t('A context to provide customized rendering.'),
      'render_language' => 'XHTML',
      'parseable' => TRUE,
      'hidden' => FALSE,
      'formats' => array(),
    ),
    'search_result' => array(
      'title' => t('Search result highlighting input'),
      'description' => t('A context to provide customized rendering.'),
      'render_language' => 'XHTML',
      'parseable' => TRUE,
      'hidden' => FALSE,
      'formats' => array(),
    ),
  );
}

/**
 * Implements hook_scald_prerender().
 */
function scald_apachesolr_scald_prerender($atom, $context, $options, $mode) {
}

/**
 * Implements hook_scald_render().
 */
function scald_apachesolr_scald_render($atom, $context, $options = array()) {
  if ($context == 'search_index' || $context == 'search_result') {
    return scald_atom_view($atom, $context);
  }
}

/**
 * Status callback for atoms after indexing a certain amount of atoms.
 *
 * @param string $entity_id
 *   Entity id.
 *
 * @param string $entity_type
 *   Entity type.
 *
 * @param object $entity
 *   In the case where the status is being checked while the entity is being
 *   saved, this contains the full entity object. In other cases, it will be
 *   NULL.
 *
 * @return int
 *   The status of the scald_atom
 */
function _scald_apachesolr_scald_atom_status_callback($entity_id, $entity_type, $entity = NULL) {
  if ($entity === NULL) {
    $entity = entity_load($entity_type, array($entity_id));
    $entity = $entity ? reset($entity) : FALSE;
  }

  if (empty($entity)) {
    // If the object failed to load, just stop.
    return FALSE;
  }

  // 5 is view & fetch actions.
  return scald_action_permitted($entity, array('fetch', 'view', 'op' => 'AND'));
}

/**
 * Builds the scald_atom-specific information for a Solr document.
 *
 * @param ApacheSolrDocument $document
 *   The Solr document we are building up.
 * @param ScaldAtom $scald_atom
 *   The entity we are indexing.
 * @param string $entity_type
 *   The type of entity we're dealing with.
 * @param string $env_id
 *   The type of entity we're dealing with.
 *
 * @return array
 *   A set of ApacheSolrDocument documents.
 */
function _scald_apachesolr_scald_atom_solr_document(ApacheSolrDocument $document, ScaldAtom $scald_atom, $entity_type, $env_id) {
  // Add the title.
  $document->label = apachesolr_clean_text($scald_atom->title);

  // Add the content.
  $text = scald_render($scald_atom, 'search_index');
  $document->content = apachesolr_clean_text($text);

  // Adding the teaser.
  $document->teaser = truncate_utf8($document->content, 300, TRUE);

  // Add some data.
  $document->is_uid = $scald_atom->publisher;
  $document->ss_provider = $scald_atom->provider;
  $document->ss_base_id = $scald_atom->base_id;

  // Generic use case for future reference. Callbacks can
  // allow you to send back multiple documents.
  $documents[] = $document;

  return $documents;
}

/**
 * Reindexing callback for ApacheSolr, for scald_atom.
 *
 * @param string $env_id
 *   The machine name of the environment.
 * @param string|null $bundle
 *   (optional) The bundle type to reindex. If not used
 *   all bundles will be re-indexed.
 *
 * @return null
 *   returns NULL if the specified bundle is not in the indexable bundles list.
 *
 * @throws Exception
 */
function _scald_apachesolr_scald_atom_solr_reindex($env_id, $bundle = NULL) {
  $indexer_table = apachesolr_get_indexer_table('scald_atom');
  $transaction = db_transaction();

  try {
    $indexable_bundles = apachesolr_get_index_bundles($env_id, 'scald_atom');

    if ($bundle && !empty($indexable_bundles) && !in_array($bundle, $indexable_bundles)) {
      // The bundle specified is not in the indexable bundles list.
      return NULL;
    }

    $delete = db_delete($indexer_table);

    if (!empty($bundle)) {
      $delete->condition('bundle', $bundle);
    }
    elseif (!empty($indexable_bundles)) {
      $delete->condition('bundle', $indexable_bundles, 'IN');
    }

    $delete->execute();

    $select = db_select('scald_atoms', 's');
    $select->addExpression("'scald_atom'", 'entity_type');
    $select->addField('s', 'sid', 'entity_id');
    $select->addField('s', 'type', 'bundle');
    $select->addExpression(REQUEST_TIME, 'changed');

    if ($bundle) {
      // Mark all scald_atoms of the specified content type for reindexing.
      $select->condition('s.type', $bundle);
    }
    elseif (!empty($indexable_bundles)) {
      // Restrict reindex to content types in the indexable bundles list.
      $select->condition('s.type', $indexable_bundles, 'IN');
    }

    $insert = db_insert($indexer_table)
      ->fields(array('entity_id', 'bundle', 'entity_type', 'changed'))
      ->from($select)
      ->execute();
  }
  catch (Exception $exception) {
    $transaction->rollback();
    throw $exception;
  }
}
