<?php

require_once 'resource_share.parser.php';

// **************** Hooks Begin ***************************
 
/**
* Form generator for module settings.
*/
function resource_share_settings() {
  $form = array();

  $form['resource_share_limit'] = array(
    '#type' => 'textfield',
    '#title' => t('Default Number of Hits'),
    '#default_value' => variable_get('resource_share_limit', 10),
    '#size' => 5,
    '#maxlength' => 5,
    '#description' => t("The default maximum number of hits to return 
                         per query. Can be overidden in query and 
                         in Max number."),
    '#required' => TRUE,
  );

  $form['resource_share_cap'] = array(
    '#type' => 'textfield',
    '#title' => t('Max Number of Hits'),
    '#default_value' => variable_get('resource_share_cap', 200),
    '#size' => 5,
    '#maxlength' => 5,
    '#description' => t("Max number of hits to return in any single 
                         query. Overrides the default and user limits. 
                         Can be used to cap the server load."),
    '#required' => TRUE,
  );
  
  $form['resource_share_batch'] = array(
    '#type' => 'textfield',
    '#title' => t('Batch Size'),
    '#default_value' => variable_get('resource_share_batch', 200),
    '#size' => 5,
    '#maxlength' => 5,
    '#description' => t("The number of hits to return per batch. 
                         To use with the 'batch' query term."),
    '#required' => TRUE,
  );
  
  $form['resource_share_require_authentication'] = array(
    '#type' => 'checkbox',
    '#title' => t('<strong>Block Anonymous Users, Require Authentication</strong>'),
    '#default_value' => variable_get('resource_share_require_authentication', 0),
    '#description' => t("Block all anonymous usage and require Session 
                         Authentication from every user. Needs Session 
                         Authentication in Services Module Enabled"),
    '#required' => FALSE,
  );

// user roles
  $user_roles = user_roles($membersonly = TRUE, $permission = NULL);
  $form['resource_share_roles'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Allowed Roles'),
    '#options' => $user_roles,
    '#default_value' => variable_get('resource_share_roles', $user_roles),
    '#description' => t("Roles that can use resource Share when authentication is required."),
    '#required' => FALSE,
  );

// resource types
  $resource_types = node_type_get_names();
// use this array to default to some, not all resource types
  foreach ($resource_types as $key => $value) {
    $default_types[$key] = $key;
  }
  
  $stored_default_types_anon = variable_get('resource_share_resource_types_anon', $default_types);
  $form['types'] = array(
    '#type' => 'fieldset',
    '#title' => t('Access to Content Types'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $form['types']['resource_share_resource_types_anon'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Resource Types Exposed to Anonymous User'),
    '#options' => $resource_types,
    '#default_value' => $stored_default_types_anon,
    '#description' => t("Select resource types available via the 
                         resource Share API to an Anonymous User."),
    '#required' => FALSE,
 );
  
  $stored_default_types_auth = variable_get('resource_share_resource_types_auth', $default_types);
  $form['types']['resource_share_resource_types_auth'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Resource Types Exposed to Logged in User'),
    '#options' => $resource_types,
    '#default_value' => $stored_default_types_auth,
    '#description' => t("Select resource types available via the 
                         resource Share API to a Logged in User'),."),
    '#required' => FALSE,
  );


// resource fields
  $core_fields = array(
    'nid' => 'nid',
    'type' => 'type',
    'created' => 'created',
    'title' => 'title',
    'body' => 'body',
    'teaser' => 'teaser',
    'taxonomy' => 'taxonomy',  
    'language' => 'language',
    'uid' => 'uid',
    'url' => 'url',
    'uuid' => 'uuid',
    'status' => 'status',
    'changed' => 'changed',
    'comment' => 'comment',
    'promote' => 'promote',
    'moderate' => 'moderate',
    'sticky' => 'sticky',
    'tnid' => 'tnid',
    'translate' => 'translate',
    'vid' => 'vid',
    'revision_uid' => 'revision_uid',
    'log' => 'log',
    'revision_timestamp' => 'revision_timestamp',
    'format' => 'format',
    'name' => 'name',
    'picture' => 'picture',
    'data' => 'data',
    'last_comment_timestamp' => 'last_comment_timestamp',
    'last_comment_name' => 'last_comment_name',
    'comment_count' => 'comment_count',
  );
  
// Drupal 7 function to get an array of all fields. 
// Get their names from keys only.
  $cck_fields = array_keys(field_info_fields());
//combine into associative array with same keys and value 
  $flat_cck = array_combine($cck_fields, $cck_fields);  
  $field_options = array_merge($core_fields, $flat_cck);
  $resource_share_default_fields = array(
    'nid' => 'nid',
    'type' => 'type',
    'created' => 'created',
    'title' => 'title',
    'body' => 'body',
    'teaser' => 'teaser',
    'taxonomy' => 'taxonomy',
  );
  
  $stored_default_fields_anon = variable_get('resource_share_resource_fields_anon', $resource_share_default_fields);
  $form['fields'] = array(
    '#type' => 'fieldset',
    '#title' => t('Access to Fields'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $form['fields']['resource_share_resource_fields_anon'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Expose Fields to Anonymous User'),
    '#options' => $field_options,
    '#default_value' => $stored_default_fields_anon,
    '#description' => t("Select fields available via the resource Share 
                         API to an Anonymous User."),
    '#required' => TRUE,
  );

  $stored_default_fields_auth = variable_get('resource_share_resource_fields_auth', $resource_share_default_fields);
  $form['fields']['resource_share_resource_fields_auth'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Expose Fields to Logged in User'),
    '#options' => $field_options,
    '#default_value' => $stored_default_fields_auth,
    '#description' => t("Select fields available via the resource Share API to a Logged in User."),
    '#required' => TRUE,
  );


  $form['tables'] = array(
    '#type' => 'fieldset',
    '#title' => t('Access to DB Tables'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $form['tables']['resource_share_expose_tables'] = array(
    '#type' => 'checkbox',
    '#title' => t('<strong>Expose DB Tables to Authenticated Users</strong>'),
    '#default_value' => variable_get('resource_share_expose_tables', 0),
    '#description' => t("Expose Drupal DB tables to a Logged In User. 
                         Check boxes below to expose particular tables."),
    '#required' => FALSE,
  );

// get the table list from db
  $schema_result = db_query("SHOW TABLES");
  while ($row = $schema_result->fetchAssoc()) {
    $schema_array[reset($row)] = reset($row);
    }
  $form['tables']['resource_share_tables'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Expose Tables to a Logged In User'),
    '#options' => $schema_array,
    '#default_value' => variable_get('resource_share_tables', $schema_array),
    '#description' => t("Select tables available via the resource Share 
                         API to a Logged In User."),
    '#required' => FALSE,
  );

  $form = system_settings_form($form);

// this calls the theme_resource_share_settings function which rewrites most elements of the form 
// with custom style and converts multi checkboxes into tables

//  from D6
//  $form['#theme'] = 'resource_share_settings'; 

  return $form;
  }

/**
* Implements hook_menu().
*/
function resource_share_menu() {
  $items = array();
  $items['resource_share/test'] = array(
    'title' => 'resource_share API testing page.',
    'page callback' => '_resource_share_test',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK
  );
  $items['admin/config/services/resource_share'] = array(
    'title' => t('Resource Share settings'),
    'description' => t('Description of the resource Share settings page'),
    'page callback' => 'drupal_get_form',
    'access callback'  => 'user_access',
    'page arguments' => array('resource_share_settings'),
    'access arguments' => array('access administration pages'),
    'type' => MENU_NORMAL_ITEM,
  );
  return $items;
  }

/**  
*  Validate settings input 
*  @param array, array ref 
*  The current form and its state 
*  @return void 
*/  
function resource_share_settings_validate($form, &$form_state) {
  $limit = $form_state['values']['resource_share_limit'];
  $cap = $form_state['values']['resource_share_cap'];
  if (!is_numeric($limit) || $limit <= 0) {
    form_set_error('resource_share_limit', t('You must enter a positive integer 
                                              for the Default number of hits.'));
  }
  elseif ($limit > $cap) {
    form_set_error('resource_share_limit', t('Default number of hits cannot be 
                                              larger than Max Number of Hits.'));
  }
}


/**
 * Implementation of hook_services_resources()
 * @return array
 */
function resource_share_services_resources() {
     return array(
       'share' => array(
         'retrieve' => array(
           'help' => 'Retrieves a resource via Resource Share',
           'file' => array('file' => 'inc', 'module' => 'resource_share'),
           'callback' => '_resource_share_retrieve',
           'access callback' => '_resource_share_access',
           'access arguments' => array('view'),
           'access arguments append' => TRUE,
           'args' => array(
             array(
               'name' => 'id',
               'type' => 'int',
               'description' => 'The id of the note to get',
               'source' => array('path' => '0'),
               'optional' => FALSE,
            ),
           ),
          ),
         ),
        );
}

/** 
* Function for retrieving nodes. This function is called as a callback
* from the hook_services_resources() of Services 3.3 module. It is a
* controller function for this module with most of the worklflow.
* @param --
* @return array of objects
*/
function _resource_share_retrieve() {
// initiate an error array to be used through the module by ref  
  $error_array = array();
// 1. check if authentication is required and if the user has the correct role  
  $require_auth = variable_get('resource_share_require_authentication', 0);
// Return if the user is not authenticated, write stats.
  if ($require_auth == 1 && _resource_share_user_validate($error_array) ===  FALSE) {
      return $error_array;
  }

// 2. parse the query and get back an array keyed on query terms
  $query_array = _resource_share_parse_query($error_array);
  if (!empty($error_array)) {
    return $error_array;
  }

// 3. call the index function to get a list of nodes/resources
  $resource_index = _resource_share_index($query_array, $error_array);
  if (!empty($error_array)) {
    return $error_array;
  }  
  
// 4. check if the size query was run and return just the number, no nodes.
  if (isset($resource_index['size'])) {
    return $resource_index['size'];
  }
  
// 5. check if the table query is set and allowed.
  if (isset($query_array['table'])) {
    if (variable_get('resource_share_expose_tables', 0) === 0) {
      return "Table queries are not permitted";
    }
      
    return $resource_index;
  }
  
  
// 6. get a list of exposed fields
  $exposed_fields_array = _resource_share_exposed('fields');
// Check if the indexed node is of the type in exposed types.
  if (empty($exposed_fields_array)) {
    $error_array['access error'] = 'No fields are set to be exposed via Resource Share';
    return $error_array;
  }
// make a black list of fields to unset  
    foreach ($exposed_fields_array as $field_key => $field_value) {
      if ($field_key !== $field_value) {
        $black_field_list[] = $field_key;
  }
  }
// 7. loop through the nid list and load the nodes
   foreach ($resource_index as $nid) {
      $node = node_load($nid);
      foreach ($black_field_list as $black_field) {
        unset($node->{$black_field});
      }
      $nodes[] = $node;      
   }
  return $nodes;
}

/**
* Parses the incoming query
* @param obj by ref
* @return array of strings
*/
function _resource_share_parse_query(&$error_array) {
  $query_array = array();
  $path_array = explode('/', $_SERVER['REQUEST_URI']);
  $query_string = array_pop($path_array);
  $query_string = preg_replace('/\.\w+/', '', $query_string);
  parse_str($query_string, $query_array);
  if (empty($query_array)) {
    $error_array['parse error'] = 'empty query';
  }
  return $query_array;
}


// ***** Group of Functions for Access Control *****
/** 
* Callback function for access in hook_services_resources().
* Always returns true, access control is implemented from retrieve()
* function.
* @param string, array
* @return bool
*/
function _resource_share_access($op = 'view', $args = array()) {
  return TRUE;
  }

/** 
* Function for access control per content type.
* @param string
* @return bool
*/
function _resource_share_myaccess() {

}


/** Function for cheking authentication and roles
 * @params error object by reference
 * @return bool
 */
function _resource_share_user_validate(&$error_array) {
  global $user;
// Check if user is authenticated
  if  ($user->uid == 0) {
    $error_array['authentication error'] = 'You need to be log in to access this API service';
    return FALSE;
  }
// Check if the authenticated user has roles that approve api's use.
  $approved_roles = variable_get('resource_share_roles', FALSE);
  $intersect_array = array();
  if (is_array($approved_roles) && is_array($user->roles)) {
    $intersect_array = array_intersect(array_values($approved_roles), 
                                          array_keys($user->roles));
  }

  if (empty($intersect_array)) {
    $error_array['authentication error'] = 'Your roles are not approved '. 
                             'by the admin for using resource Share API';
    return FALSE;
  }
// If all test are passed return true
  return TRUE;
}
  
/** 
* This function checks if the type of the node is listed as accessible for 
* the user (logged or anon)
* @param string 
* @return array of strings
*/
function _resource_share_exposed($item) {
  $require_auth = variable_get('resource_share_require_authentication', 0);
  $item_array = array();
  switch ($require_auth) {
    case "1": 
      $item_array = variable_get('resource_share_resource_' . $item . '_auth', array());
      break;
    case "0":
      global $user;
      if ($user->uid == 0) {
        $item_array = variable_get('resource_share_resource_' . $item . '_anon', array());
      }
      else{
        $item_array = variable_get('resource_share_resource_' . $item . '_auth', array());
      }
      break;
    default:
      $item_array = array();
  }
  return $item_array;
  }
// ***** End of Group of Functions for Access Control *****


/** 
* Function for providing an index (list) of nodes to 
* convert to output format and return to user
* @param array of strings, array by ref
* @return array of objects
*/
function _resource_share_index($request_array, &$error_array) {
//return array with node object as values
  $index = array();
// Check if "help" is in the query and if it is, return only the help response.
  if (isset($request_array['help'])) {
    $helpParse = new ParseHelp($request_array['help']);
    if ($helpParse->isValid()) {
      return array($helpParse->getHelp());
    }
    else{
      $error_array['help error'] = $helpParse->errorMsg;
      return FALSE;
  }
  }
 
// Check if count is present in the query request and return just the number of nodes if it is.
  if (isset($request_array['size'])) {
    $sizeParse = new ParseSize($request_array['size']);
    if ($sizeParse->isValid()) {
      $hit_count  = sizeof($nids);
      return array('size' => $hit_count);
    }
  }
  
// Check if table is present in the query request and return just the custom table results.  
  if (isset($request_array['table'])) {
    $tableParser = new ParseTable($request_array);
    if ($tableParser->isValid()) {
      $custom_sql = $tableParser->getSQL();
  $db_result = db_query($custom_sql);
  $custom_result = array();
  foreach ($db_result->fetchAll() as $key => $fetched_object) {
    $custom_result[] = (array)$fetched_object;
  }
      return $custom_result;
    }
    else{
      $error_array['table error'] = $tableParser->errorMsg;
      return FALSE;
    }
  }

// Get the nodes from db and track errors.
  $nids = _resource_share_db_get($request_array, $error_array);
// check if any error came back and return if they did
  if (!empty($error_array)) {
    return FALSE;
  }  


  if (!empty($nids)) {
// If batch processing is set, limit the number of nodes to retrieve. 
    if (isset($request_array['batch'])) {
      $batchParse = new ParseBatch($request_array['batch']);
        if ($batchParse->isValid()) {
          $batch_offset = ($batchParse->getBatch() - 1) * variable_get('resource_share_batch', 200);
          $nids = array_slice($nids, $batch_offset, variable_get('resource_share_batch', 200), TRUE);   //NB: RESIZING $nids ARRAY TO ONLY THE CURRENT CHUNK
  }
        else {
          $error_array['batch error'] = 'invalid batch query';
          return FALSE;
          }
  }
// Nb: here $nids can be either the full list or the current chunk of nids.
  }
  return $nids;
 }
 
/**
* Function to construct a db query based on the user input
* and settings, to run the query over the db and return an array of
* matched nodes
* @param $request
* @return return an array of NIDs matching the query
*/ 
function _resource_share_db_get($request_array, &$error_array) {
  $nids = array();             //return array
  $where_clause = array();    //holds the SQL clauses
  $select_term_count = 0;
// Parse input and construct sql clauses.
  foreach ($request_array as $term => $value) {
    switch ($term) {
      case "after":
        $afterParser = new ParseAfter($value);
        if ($afterParser->isValid()) {
          $where_clause[] = $afterParser->getSQL();
          $select_term_count++;
          continue;
        }
        else{
          $error_array['after error'] = $afterParser->errorMsg;
          return FALSE;
        }
      
      case "before":
        $beforeParser = new ParseBefore($value);
        if ($beforeParser->isValid()) {
          $where_clause[] = $beforeParser->getSQL();
          $select_term_count++;
          continue;
        }
        else{
          $error_array['before error'] = $beforeParser->errorMsg;
          return FALSE;
        }
      
      case "type":
        $typeParser = new ParseType($value);
        if ($typeParser->isValid()) {
          $where_clause[] = $typeParser->getSQL();
          $select_term_count++;
          continue;
        }
        else{
          $error_array['type error'] = $typeParser->errorMsg;
          return FALSE;
        }
      
      case "limit":
        $limitParser = new ParseLimit($value);
        if ($limitParser->isValid()) {
          $user_limit = $limitParser->getLimit();
        }
        else{
          $error_array['limit error'] = $limitParser->errorMsg;
          return FALSE;
        }
        continue;
      
      case "search":
        $searchParser = new ParseSearch($value);
        if ($searchParser->isValid()) {
          $where_clause[] = $searchParser->getSQL();
          $select_term_count++;
          continue;}
        else{
          $error_array['search error'] = $searchParser->errorMsg;
          return FALSE;
        }
    
      case "sort":
      $sortParser = new ParseSort($value);
      if ($sortParser->isValid()) {
        $order_clause = $sortParser->getSQL();
        }
      else{
        $error_array['sort error'] = $sortParser->errorMsg;
        return FALSE;
      }
    }
  }

// Check if the query is empty or does not have any recognizable terms.
  if ($select_term_count == 0) {
    $error_array['empty query error'] = 'Query does not have any known selection terms';
    return FALSE;
  }

// Construct the query from parsed input and sql clauses.
    $sql = 'SELECT distinct nid, type FROM node WHERE ';
// Construct the limit clause for SQL.
  if (isset($user_limit)) {
    $limit = min($user_limit, variable_get('resource_share_cap', 200));
  }
  else{
    $limit = min(variable_get('resource_share_limit', 10), variable_get('resource_share_cap', 200));
  }
// check if "batch" term is set
  if (isset($request_array['batch'])) {
// if batch is set no limit is imposed on the QUERY
    $limit_clause = '';
  }
  else {
    $limit_clause = ' LIMIT 0, ' . $limit;
  }

// Check if the node is published. If not, do not return it.
  $where_clause[] = 'status = 1';
// Construct the "oder by" clause.
  $order_clause = isset($order_clause) ? $order_clause : ' ORDER BY created DESC ';
 
// Get an array with the list of exposed types.
  $exposed_types_array = _resource_share_exposed('types');
// Check if the indexed node is of the type in exposed types.
  if (empty($exposed_types_array)) {
    $error_array['access error'] = 'No resource types are set to be exposed via Resource Share';
    return FALSE;
  }
// Construct the "type in" where clause for types exposed in settings.
  else {
// pad resource types with " quotes for SQL
    foreach ($exposed_types_array as $type_key => $type_value) {
      if ($type_key === $type_value) {
        $padded_exposed_types_array[] = "'" .  $type_key . "'";
  }     
  }
    $where_clause[] = "type IN (" . implode( ', ', $padded_exposed_types_array) . ")";
  }

// Put the query together and run it.
  $whole_query = $sql . implode(' AND ', $where_clause) . $order_clause . $limit_clause;
  $db_result = db_query($whole_query);
  foreach ($db_result->fetchAll() as $key => $fetched_object) {
    $nids[] = $fetched_object->nid;
  }
  return $nids;
}

