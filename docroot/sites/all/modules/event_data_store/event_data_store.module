<?php
/**
 * @file
 * Main event_data_store file.
 */

define('EVENT_DATA_STORE_AGGREGATED_INTERVAL_HOURLY', 0);
define('EVENT_DATA_STORE_AGGREGATED_INTERVAL_DAILY', 1);
define('EVENT_DATA_STORE_AGGREGATED_INTERVAL_WEEKLY', 2);
define('EVENT_DATA_STORE_AGGREGATED_INTERVAL_MONTHLY', 3);
define('EVENT_DATA_STORE_AGGREGATED_INTERVAL_YEARLY', 4);

require_once 'event_data_store.hooks.inc';

/**
 * Implements hook_permission().
 */
function event_data_store_permission() {
  return array(
    'administer event_data_store' => array(
      'title' => 'Administer Event Data Store',
    ),
  );
}

/**
 * Implements of hook_ctools_plugin_directory().
 */
function event_data_store_ctools_plugin_directory($module, $type) {
  if ($type == 'export_ui') {
    return 'plugins/export_ui';
  }
}

/**
 * Implements of hook_ctools_plugin_api().
 */
function event_data_store_ctools_plugin_api($owner, $api) {
  if ($owner == 'event_data_store' && $api == 'default_event_data_store_events') {
    return array('version' => 1);
  }
}

/**
 * Implements hook_default_event_data_store_event().
 *
 * Provide a default event.
 */
/*function event_data_store_default_event_data_store_event() {
  $export = array();

  $event = new stdClass();
  $event->api_version = 1;
  $event->name = 'my_default_event';
  $event->description = 'Default event_data_store event';
  $event->mydata = 'x';
  $export['my_default_event'] = $event;

  return $export;
}*/

/**
 * Load a single event.
 *
 * @param string $pid
 *   The event identifier.
 */
function event_data_store_event_load($pid) {
  ctools_include('export');
  $result = ctools_export_load_object('event_data_store_event', 'names', array($pid));
  if (isset($result[$pid])) {
    return $result[$pid];
  }
}

/**
 * Load a all events.
 *
 * @param string $pid
 *   The event identifier.
 */
function event_data_store_event_load_all() {
  ctools_include('export');
  return ctools_export_load_object('event_data_store_event', 'all');
}

/**
 * Export a event_data_store_event.
 *
 * @param object $obj
 *   The event_data_store object.
 * @param string $indent
 *   An identifier.
 *
 * @return string
 *   The export definition.
 */
function event_data_store_event_export($obj, $indent = '') {
  ctools_include('export');
  $output = ctools_export_object('event_data_store_event', $obj, $indent);
  return $output;
}

/**
 * Grab a list of all the available event triggers.
 */
function event_data_store_get_trigger_events() {
  $trigger_events = array(
    'user_registrations' => t('User registrations'),
    'user_logins' => t('User logins'),
    'user_logouts' => t('User logouts'),
    'users_blocked' => t('Users blocked'),
    'users_activated' => t('Users activated'),
    'users_cancelled' => t('Users cancelled'),
    'user_password_resets' => t('User password resets'),
    'nodes_created' => t('Nodes created'),
    'nodes_updated' => t('Nodes updated'),
    'nodes_deleted' => t('Nodes deleted'),
  );

  // Add in node type events.
  foreach (node_type_get_types() as $type_name => $type) {
    $replacements = array('@name' => $type->name);
    $trigger_events += array(
      "nodes_created_{$type_name}" => t('@name nodes created', $replacements),
      "nodes_updated_{$type_name}" => t('@name nodes updated', $replacements),
      "nodes_deleted_{$type_name}" => t('@name nodes deleted', $replacements),
    );
  }

  // Add in comment events.
  if (module_exists('comment')) {
    $trigger_events += array(
      'comments_created' => t('Comments created'),
      'comments_deleted' => t('Comments deleted'),
    );
  }

  // Add in file events.
  if (module_exists('file')) {
    $trigger_events += array(
      'files_uploaded' => t('File uploaded'),
      'files_deleted' => t('Files deleted'),
    );
  }

  // Add in search events.
  if (module_exists('search')) {
    $trigger_events += array(
      'search_executed' => t('Search executed'),
    );
  }

  // Add in Harmony events.
  if (module_exists('harmony_core')) {
    $trigger_events += array(
      'harmony_threads_created' => t('Harmony Threads created'),
      'harmony_threads_updated' => t('Harmony Threads updated'),
      'harmony_threads_deleted' => t('Harmony Threads deleted'),
      'harmony_threads_created_category' => t('Harmony Threads created in category'),
    );

    foreach (harmony_core_get_thread_types() as $type => $info) {
      $label = $type === 'harmony_thread' ? t('Default') : $info->label;
      $replacements = array('@label' => $label);
      $trigger_events += array(
        'harmony_threads_created' => t('Harmony @label Threads created', $replacements),
        'harmony_threads_updated' => t('Harmony @label Threads updated', $replacements),
        'harmony_threads_deleted' => t('Harmony @label Threads deleted', $replacements),
      );
    }

    $trigger_events += array(
      'harmony_thread_view_tracked' => t('Harmony Thread view tracked'),
      'harmony_thread_view_tracked_auth' => t('Harmony Thread view tracked (authenticated)'),
      'harmony_thread_view_tracked_anon' => t('Harmony Thread view tracked (anonymous)'),
      'harmony_posts_created' => t('Harmony Posts created'),
      'harmony_posts_updated' => t('Harmony Posts updated'),
      'harmony_posts_deleted' => t('Harmony Posts deleted'),
    );
  }

  foreach (module_implements('event_data_store_trigger_events') as $module) {
    $trigger_events[] = module_invoke($module, 'event_data_store_trigger_events');
  }

  return $trigger_events;
}

/**
 * Log an event.
 */
function event_data_store_log($event, $entity_type = '', $entity_id = '', $data = array()) {
  ctools_include('export');
  $event_triggers = ctools_export_load_object('event_data_store_event', 'conditions', array('event' => $event));

  if ($event_triggers) {
    global $user;
    $data = serialize($data);

    foreach ($event_triggers as $name => $event_trigger) {
      db_insert('event_data_store')
        ->fields(array(
          'event_name' => $name,
          'uid' => $user->uid,
          'timestamp' => REQUEST_TIME,
          'user_agent' => !empty($_SERVER['HTTP_USER_AGENT']) ? $_SERVER['HTTP_USER_AGENT'] : '',
          'ip_address' => ip_address(),
          'entity_type' => $entity_type,
          'entity_id' => $entity_id,
          'data' => $data,
        ))
        ->execute();
    }
  }
}

/**
 * Implements hook_cron().
 */
function event_data_store_cron() {
  $stores = event_data_store_event_load_all();

  if (!empty($stores)) {
    foreach ($stores as $name => $store) {
      // Aggregate data.
      if ($store->aggregate && ($store->aggregate_hourly || $store->aggregate_daily || $store->aggregate_weekly || $store->aggregate_monthly)) {
        // Work out what's happened since we've last aggregated.
        $past_hour = db_query('SELECT COUNT(*) FROM {event_data_store} WHERE event_name = :event_name AND timestamp >= :timestamp', array(
          ':event_name' => $name,
          ':timestamp' => variable_get('event_data_store_last_aggregated', 0),
        ))->fetchField();

        // Hourly aggregation.
        if ($store->aggregate_hourly) {
          event_data_store_cron_aggregate_interval($store, EVENT_DATA_STORE_AGGREGATED_INTERVAL_HOURLY, $past_hour);
        }
        // Daily aggregation.
        if ($store->aggregate_daily) {
          event_data_store_cron_aggregate_interval($store, EVENT_DATA_STORE_AGGREGATED_INTERVAL_DAILY, $past_hour);
        }
        // Weekly aggregation.
        if ($store->aggregate_weekly) {
          event_data_store_cron_aggregate_interval($store, EVENT_DATA_STORE_AGGREGATED_INTERVAL_WEEKLY, $past_hour);
        }
        // Monthly aggregation.
        if ($store->aggregate_monthly) {
          event_data_store_cron_aggregate_interval($store, EVENT_DATA_STORE_AGGREGATED_INTERVAL_MONTHLY, $past_hour);
        }
        // Yearly aggregation.
        if ($store->aggregate_yearly) {
          event_data_store_cron_aggregate_interval($store, EVENT_DATA_STORE_AGGREGATED_INTERVAL_YEARLY, $past_hour);
        }
      }

      // Prune old data.
      if ($store->prune_interval > 0) {
        $prune_interval = REQUEST_TIME - $store->prune_interval;
        db_query('DELETE FROM {event_data_store_agg} WHERE event_name = :event_name AND timestamp < :prune_interval', array(
          ':event_name' => $name,
          ':prune_interval' => $prune_interval,
        ));
        db_query('DELETE FROM {event_data_store} WHERE event_name = :event_name AND timestamp < :prune_interval', array(
          ':event_name' => $name,
          ':prune_interval' => $prune_interval,
        ));
      }
    }

    variable_set('event_data_store_last_aggregated', REQUEST_TIME);
  }
}

/**
 * Helper function to create aggregate data for a specified interval.
 */
function event_data_store_cron_aggregate_interval($store, $interval, $past_hour, $update_previous = TRUE) {
  // Figure out the timestamp for the start of the day, week or month.
  switch ($interval) {
    case EVENT_DATA_STORE_AGGREGATED_INTERVAL_HOURLY:
      $date = mktime(date('H'), 0, 0);
      break;
    case EVENT_DATA_STORE_AGGREGATED_INTERVAL_DAILY:
      $date = mktime(0, 0, 0);
      break;
    case EVENT_DATA_STORE_AGGREGATED_INTERVAL_WEEKLY:
      // Gah, this gets complicated. Get first day of the week as set by admin.
      // Default to Monday. When using strtotime use the correct string for
      // last or this.
      $first_day_of_week = variable_get('date_first_day', 1);
      $php_date_week_format_char = variable_get('date_api_use_iso8601', 0) == 1 ? 'N' : 'w';
      if (variable_get('date_api_use_iso8601', 0) && $first_day_of_week === 0) {
        $first_day_of_week = 7;
      }
      $today_first_day_of_week = date($php_date_week_format_char) == $first_day_of_week;
      $use_this_or_last = $today_first_day_of_week ? 'this' : 'last';
      $days = array('Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday');
      $date = strtotime($use_this_or_last . ' ' . $days[$first_day_of_week]);
      break;
    case EVENT_DATA_STORE_AGGREGATED_INTERVAL_MONTHLY:
      $date = mktime(0, 0, 0, date('n'), 1);
      break;
    case EVENT_DATA_STORE_AGGREGATED_INTERVAL_YEARLY:
      $date = mktime(0, 0, 0, 1, 1);
      break;
  }

  // Grab the current day, week or month record if one exists.
  $current_interval_record = db_query_range('SELECT * FROM {event_data_store_agg} WHERE event_name = :event_name AND period = :interval AND timestamp = :timestamp ORDER BY timestamp DESC', 0, 1, array(
      ':event_name' => $store->name,
      ':interval' => $interval,
      ':timestamp' => $date,
    ))
    ->fetchObject();

  // If a record exists, then update the flip out of it.
  if ($current_interval_record) {
    db_query('UPDATE {event_data_store_agg} SET value = :new_value WHERE edsa_id = :edsa_id', array(
      ':new_value' => ($current_interval_record->value + $past_hour),
      ':edsa_id' => $current_interval_record->edsa_id,
    ));
  }
  // First time round, create a record.
  else {
    // Make sure the previous interval is correct.
    $previous_interval_value = 0;
    if ($update_previous) {
      $previous_interval_value = event_data_store_finalise_previous_agg_value($store, $interval, $date);
    }

    // Do sum if that's the aggregation behaviour, final sum is taken care of
    // by the previous "finalise" function call.
    if ($store->aggregate_behaviour === 'sum') {
      $past_hour = $past_hour + $previous_interval_value;
    }

    // Create a record for the new interval.
    db_insert('event_data_store_agg')
      ->fields(array(
        'event_name' => $store->name,
        'timestamp' => $date,
        'value' => $past_hour,
        'period' => $interval,
      ))
      ->execute();
  }
}

/**
 * Just before we create a new aggregated record for an interval correct the
 * previous periods one as cron can be run at times which aren't dead on the
 * hour.
 */
function event_data_store_finalise_previous_agg_value($store, $interval, $date) {
  $number_to_grab = $store->aggregate_behaviour === 'tally' ? 1 : 2;
  $previous_interval_records = db_query_range('SELECT * FROM {event_data_store_agg} WHERE event_name = :event_name AND period = :interval ORDER BY timestamp DESC', 0, $number_to_grab, array(
    ':event_name' => $store->name,
    ':interval' => $interval,
  ))
  ->fetchAll();
  // If we've got a record or two, redo the count for the entire record.
  if (!empty($previous_interval_records)) {
    // Set our initial number.
    $previous_interval_count = $store->aggregate_behaviour === 'sum' && !empty($previous_interval_records[1]) ? $previous_interval_records[1]->value : 0;
    // Determine the end timestamp we want data to run up to.
    // This is just going to be the current date timestamp.
    $end_timestamp = $date;
    // Figure out the value for this time period.
    $previous_interval_count_from_db = db_query('SELECT COUNT(*) FROM {event_data_store} WHERE event_name = :event_name AND timestamp >= :timestamp AND timestamp < :end_timestamp', array(
      ':event_name' => $store->name,
      ':timestamp' => $previous_interval_records[0]->timestamp,
      ':end_timestamp' => $end_timestamp,
    ))->fetchField();
    if (!$previous_interval_count_from_db) {
      $previous_interval_count_from_db = 0;
    }
    $previous_interval_count = $previous_interval_count + $previous_interval_count_from_db;
    // Update the record.
    db_query('UPDATE {event_data_store_agg} SET value = :value WHERE edsa_id = :edsa_id', array(
      ':value' => $previous_interval_count,
      ':edsa_id' => $previous_interval_records[0]->edsa_id,
    ));

    return $previous_interval_count;
  }

  return 0;
}

/**
* Implements hook_views_api().
*/
function event_data_store_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'event_data_store') . '/views',
  );
}
