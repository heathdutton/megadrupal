<?php

/**
 * @file
 * Merge synonyms module.
 */

/**
 * Implements hook_ctools_plugin_directory().
 */
function merge_synonyms_ctools_plugin_directory($module, $plugin) {
  if ($module == 'feeds_tamper') {
    return 'plugins';
  }
}

/**
 * Implements hook_taxonomy_vocabulary_insert().
 */
function merge_synonyms_taxonomy_vocabulary_insert($vocabulary) {
  // Create field instances on newly created vocabularies.
  _merge_synonyms_field_instance($vocabulary->machine_name);
}

/**
 * Create field instance.
 *
 * @param string $vname
 *   Vocabulary name.
 */
function _merge_synonyms_field_instance($vname) {

  // Field instance settings.
  $instance = array(
    'field_name' => 'field_term_merge_synonyms',
    'entity_type' => 'taxonomy_term',
    'label' => t('Synonyms'),
    'description' => t('Add synonyms. One per line.'),
    'bundle' => $vname,
    'widget' => array(
      'type' => 'text_textarea',
    ),
  );

  // Create the instance.
  field_create_instance($instance);
}

/**
 * Implements hook_form_form_id_alter().
 */
function merge_synonyms_form_taxonomy_form_term_alter(&$form, &$form_state, $form_id) {

  // Check that this term/vocabulary has synonyms field(it should).
  if (isset($form['field_term_merge_synonyms'])) {
    // Set the weight of the merge button below the field.
    $weight = $form['field_term_merge_synonyms']['#weight'] + 1;

    // Button.
    $form['merge_synonyms_submit'] = array(
      '#type' => 'submit',
      '#value' => t('Merge synonyms'),
      // We need to save term get updated synonyms data.
      '#submit' => array('taxonomy_form_term_submit',
        'merge_synonyms_merge_synonyms_submit'),
      '#weight' => $weight,
    );
  }
}

/**
 * Submit function of merge button.
 */
function merge_synonyms_merge_synonyms_submit(&$form, &$form_state) {
  if (isset($form['#term']['tid'])) {
    $tid = $form['#term']['tid'];
    $vid = $form['#vocabulary']->vid;

    // Actual merge function.
    merge_synonyms_merge($tid, $vid);
  }
}

/**
 * Actual merge function.
 *
 * @param int $tid
 *   Term id to keep.
 * @param int $vid
 *   Vocabulary id.
 */
function merge_synonyms_merge($tid, $vid) {
  // Load taxonomy entity metadata wrapper.
  $term_entity = entity_metadata_wrapper('taxonomy_term', $tid);

  // Load synonyms of the taxonomy.
  $synonyms = explode(PHP_EOL, $term_entity->field_term_merge_synonyms->value());

  // Find synonyms and merge them with the current one.
  foreach ($synonyms as $synonym) {
    // Trim new lines and spaces.
    $synonym = str_replace(PHP_EOL, '', $synonym);
    $synonym = trim($synonym);

    // Get terms that match this synonym.
    $query_taxonomy = new EntityFieldQuery();
    $result_taxonomy = $query_taxonomy
      ->entityCondition('entity_type', 'taxonomy_term')
      ->propertyCondition('name', $synonym)
      ->propertyCondition('vid', $vid)
      ->execute();

    if (count($result_taxonomy) > 0) {
      // Clean table.
      $result_taxonomy = array_values(array_shift($result_taxonomy));
      // Get the term to be replaced.
      $tid_to_replace = $result_taxonomy[0]->tid;
      // Get nodes with the term to be replaced.
      $limit = 100;
      $nodes = taxonomy_select_nodes($tid_to_replace, FALSE, $limit);

      // Loop for each node to change the tid.
      foreach ($nodes as $nid) {
        // Load node entity metadata wrapper.
        $node_entity = entity_metadata_wrapper('node', $nid);

        // Get field(based on vid).
        $field_names = _merge_synonyms_field_name($vid, $node_entity->getBundle());

        // In case no field name is found.
        if (count($field_names) == 0) {
          watchdog('WATCHDOG_CRITICAL', 'No field found for vocabulary: @vocabulary',
            array('@vocabulary' => $vid));
        }

        foreach ($field_names as $field_name) {

          $replaced_tid = 0;
          // Replace term.
          foreach ($node_entity->{$field_name}->getIterator() as $delta => $term) {
            if ($term->getIdentifier() == $tid_to_replace) {
              $node_entity->{$field_name}[$delta] = $tid;
              $replaced_tid = $tid;
            }
          }

          // Remove duplicates.
          $duplicate_counter = FALSE;
          foreach ($node_entity->{$field_name}->getIterator() as $delta => $term) {
            if ($term->getIdentifier() == $replaced_tid
              && $duplicate_counter
            ) {
              unset($node_entity->{$field_name}[$delta]);
            }
            elseif ($term->getIdentifier() == $replaced_tid && !$duplicate_counter) {
              $duplicate_counter = TRUE;
            }
          }

          $node_entity->save();
        }
      }

      // Invoke functions that implement hook_merge_synonyms_merge.
      // Essentially replacing in nodes $tid_to_replace with $tid.
      module_invoke_all('merge_synonyms_merge)', $vid, $tid, $tid_to_replace);

      // Delete the old taxonomy term.
      taxonomy_term_delete($tid_to_replace);

      // Show message.
      drupal_set_message(t('Synonyms have been found and replaced for @synonym.',
        array('@synonym' => $synonym)));
    }
    else {
      // Show message.
      drupal_set_message(t('No synonyms found for @synonym.',
        array('@synonym' => $synonym)));
    }
  }
}

/**
 * Get synonym tid.
 *
 * @param int $vid
 *   Vocabulary id.
 * @param string $term_name
 *   Term name.
 *
 * @return int
 *   Term id or FALSE.
 */
function merge_synonyms_get_synonym_tid($vid, $term_name) {
  $query_taxonomy = new EntityFieldQuery();

  // Get terms that may have the synonym.
  $result_taxonomy = $query_taxonomy
    ->entityCondition('entity_type', 'taxonomy_term')
    ->fieldCondition('field_term_merge_synonyms', 'value', '%' . $term_name . '%', 'like')
    ->propertyCondition('vid', $vid)
    ->execute();

  if (count($result_taxonomy) > 0) {
    // Clean table.
    $result_taxonomy = array_values(array_shift($result_taxonomy));

    // Search each term for the exact synonym.
    foreach ($result_taxonomy as $term) {
      // Load the term.
      $term_entity = entity_metadata_wrapper('taxonomy_term', $term->tid);

      // Get the synonyms.
      $synonyms = explode(PHP_EOL, $term_entity->field_term_merge_synonyms->value());

      // Find if any synonym is a match.
      foreach ($synonyms as $synonym) {
        // Trim new lines and spaces.
        $synonym = str_replace(PHP_EOL, '', $synonym);
        $synonym = trim($synonym);
        if ($synonym == $term_name) {
          // Return this term id.
          return $term_entity->getIdentifier();
        }
      }
    }
  }

  return FALSE;
}

/**
 * Get field name of job content type(based on vid).
 *
 * @param int $vid
 *   Vocabulary id.
 * @param string $node_type
 *   Node type.
 *
 * @return string
 *   Field name of node.
 */
function _merge_synonyms_field_name($vid, $node_type) {

  $fields = field_info_instances('node', $node_type);

  $field_names = array();

  foreach ($fields as $field_name => $value) {
    // Load field info.
    $field_info = field_info_field($field_name);

    // Check this field corresponds to term reference field.
    if (isset($field_info['settings']['allowed_values'][0]['vocabulary'])) {

      // Load vocabulary.
      $vocabulary_name
        = $field_info['settings']['allowed_values'][0]['vocabulary'];
      $vocabulary = taxonomy_vocabulary_machine_name_load($vocabulary_name);

      // Check vocabulary and return the field name of node.
      if (isset($vocabulary->vid) && $vocabulary->vid == $vid) {
        $field_names[] = $field_name;
      }
    }
  }

  // Return array.
  return $field_names;
}
