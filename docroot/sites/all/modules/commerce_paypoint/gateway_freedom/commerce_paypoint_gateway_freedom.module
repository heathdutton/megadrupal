<?php
/**
 * @file
 * Integrates PayPoint.net's Gateway Freedom payment method with Drupal Commerce.
 * See: https://www.paypoint.net/assets/guides/Gateway_Freedom.pdf
 */

/**
 * PayPoint.net's Gateway Freedom XML-RPC endpoint URL.
 */
define('PAYPOINT_GATEWAY_FREEDOM_ENDPOINT', 'https://www.secpay.com/secxmlrpc/make_call');

/**
 * Implements hook_commerce_payment_method_info().
 */
function commerce_paypoint_gateway_freedom_commerce_payment_method_info() {
  $payment_methods = array();

  $payment_methods['paypoint_gateway_freedom'] = array(
    'base' => 'commerce_paypoint_gateway_freedom',
    'title' => t('PayPoint.net Gateway Freedom'),
    'description' => t('Integrates PayPoint.net Gateway Freedom payment service.'),
    'short_title' => t('PayPoint.net'),
  );

  return $payment_methods;
}

/**
 * Returns the default settings for the payment method settings form.
 *
 * @see commerce_paypoint_gateway_freedom_settings_form()
 */
function commerce_paypoint_gateway_freedom_default_settings() {
  $default_currency = variable_get('commerce_default_currency', 'GBP');

  return array(
    'merchant' => array(
      'merchant_id' => 'secpay',
      'vpn_password' => 'secpay',
    ),
    'duplicate_checking' => 1,
    'deferred' => array(
      'transaction_mode' => 'false',
      'reuse_credit_card_days' => 7,
      'reuse_debit_card_days' => 1,
    ),
    'testing' => array(
      'test_status' => COMMERCE_PAYPOINT_TEST_MODE_TEST,
      'default_cv2avs' => 'ALL MATCH',
    ),
    'code' => TRUE,
    'card_types' => drupal_map_assoc(array('visa', 'mastercard', 'amex', 'discover')),
    'currency_code' => in_array($default_currency, array_keys(commerce_paypoint_gateway_freedom_currencies())) ? $default_currency : 'GBP',
    'allow_supported_currencies' => FALSE,
  );
}

/**
 * Generates a settings form for the payment method options.
 *
 * @param $settings
 *   An array of the current settings.
 *
 * @return
 *   The settings form array.
 *
 * @ingroup forms
 */
function commerce_paypoint_gateway_freedom_settings_form($settings = NULL) {
  module_load_include('inc', 'commerce_payment', 'includes/commerce_payment.credit_card');
  $form = array();

  // Merge default settings into the stored settings array.
  // This is only relevant before the form is saved for the first time.
  $settings += commerce_paypoint_gateway_freedom_default_settings();

  $form['card_types'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Limit accepted credit cards to the following types'),
    '#description' => t('American Express is not available in the UK. Only MasterCard and Visa are available in Canada. If you enable Maestro or Solo, you must use GBP as your currency code.'),
    '#options' => array_intersect_key(commerce_payment_credit_card_types(), drupal_map_assoc(array('visa', 'mastercard', 'amex', 'discover', 'maestro', 'solo'))),
    '#default_value' => $settings['card_types'],
    '#required' => TRUE,
  );
  $form['currency_code'] = array(
    '#type' => 'select',
    '#title' => t('Default currency'),
    '#description' => t('Transactions in other currencies will be converted to this currency, so multi-currency sites must be configured to use appropriate conversion rates.'),
    '#options' => commerce_paypoint_gateway_freedom_currencies(),
    '#default_value' => $settings['currency_code'],
  );
  $form['code'] = array(
    '#type' => 'checkbox',
    '#title' => t('Require the card security code (i.e. CVV) to process credit card transactions.'),
    '#default_value' => $settings['code'],
  );

  $form['merchant'] = array(
    '#type' => 'fieldset',
    '#title' => t('Merchant settings'),
  );
  $form['merchant']['merchant_id'] = array(
    '#type' => 'textfield',
    '#title' => t('Merchant ID'),
    '#description' => t('Enter your PayPoint.net username (usually six letters followed by two numbers).'),
    '#default_value' => $settings['merchant']['merchant_id'],
  );
  $form['merchant']['vpn_password'] = array(
    '#type' => 'textfield',
    '#title' => t('VPN password'),
    '#description' => t('Enter the VPN password that you entered into the merchant admin inferface on the PayPoint.net site. This should be between 8 and 30 characters long.'),
    '#maxlength' => 30,
    '#default_value' => $settings['merchant']['vpn_password'],
  );

  $form['deferred'] = array(
    '#type' => 'fieldset',
    '#title' => t('Deferred transactions'),
  );
  $form['deferred']['transaction_mode'] = array(
    '#type' => 'select',
    '#title' => t('Transaction mode'),
    '#description' => t('Deferred transactions are useful if you want to take orders for items that you cannot always guarantee will be in stock. Using deferred transactions, you can take an initial authorisation (at which point no money has actually been taken) and then, when your product arrives in stock, you can release the funds for the deferred transaction and ship the product out to your customer. It is illegal in some countries to take payment for something which you don\'t have in stock.
<ul>
  <li>"Defer" will authorise only one unit of currency. This is useful avoid tying up funds in your customer\'s account if all you want to do is get their details into the system.</li>
  <li>"Full" will authorise the full amount of the transaction and freeze the funds in the customer\'s account. A new authorisation takes place when funds are released so be careful not to ship goods before confirming release of funds.</li>
  <li>"Reuse" will authorise the full amount of the initial transaction but on release will use the original authorisation code (which was obtained by the initial deferred transaction - if it is still valid). If not still valid, releasing will cause a new authorisation to take place (as is the case with "Defer" and "Full").</li>
</ul>'),
    '#options' => array(
      COMMERCE_PAYMENT_DEFERRED_DISABLED => t('Disabled'),
      COMMERCE_PAYMENT_DEFERRED_TRUE => t('Defer'),
      COMMERCE_PAYMENT_DEFERRED_REUSE => t('Reuse'),
    ),
    '#default_value' => $settings['deferred']['transaction_mode'],
  );
  $form['deferred']['reuse_credit_card_days'] = array(
    '#type' => 'select',
    '#title' => t('Credit card reuse days'),
    '#multiple' => FALSE,
    '#description' => t('The number of days within which a credit card transaction should reuse the same authorisation code.'),
    '#options' => drupal_map_assoc(range(1, 14)),
    '#default_value' => $settings['deferred']['reuse_credit_card_days'],
  );
  $form['deferred']['reuse_debit_card_days'] = array(
    '#type' => 'select',
    '#title' => t('Debit card reuse days'),
    '#multiple' => FALSE,
    '#description' => t('The number of days within which a debit card transaction should reuse the same authorisation code.'),
    '#options' => drupal_map_assoc(range(1, 14)),
    '#default_value' => $settings['deferred']['reuse_debit_card_days'],
  );

  $form['duplicate_checking'] = array(
    '#type' => 'checkbox',
    '#title' => t('Duplicate transaction checking'),
    '#description' => t('Duplicate transaction checking will stop the same order ID from the same user being used twice in the same hour. PayPoint.net believe this feature reduces customer bills by approximately 10% and also reduces the administration overhead, it is a "best efforts" feature however and can never be 100%. You must accept that occasionally you will get duplicates. During the testing phase of your integration, it is sometimes useful to not have to bother creating a new order ID for each transaction you send to PayPoint.net. If you wish to send test transactions with the same order ID but want PayPoint.net to not perform duplicate checks i.e., you want PayPoint.net to allow these duplicate transactions into the system without blocking them as duplicates then you must disable this option.'),
    '#default_value' => $settings['duplicate_checking'],
  );

  $form['testing'] = array(
    '#type' => 'fieldset',
    '#title' => t('Testing settings'),
  );
  $form['testing']['test_status'] = array(
    '#type' => 'select',
    '#title' => t('Test status'),
    '#description' => t('"Test" mode will simulate an authorised callback without contacting the bank, "Auto-decline" will simulate a declined callback without contacting the bank, and "Live" will send the transaction to the bank for authorization.'),
    '#options' => array(
      COMMERCE_PAYPOINT_TEST_MODE_TEST => t('Test'),
      COMMERCE_PAYPOINT_TEST_MODE_DECLINE => t('Auto-decline'),
      COMMERCE_PAYPOINT_TEST_MODE_LIVE => t('Live'),
    ),
    '#default_value' => $settings['testing']['test_status'],
  );
  $form['testing']['default_cv2avs'] = array(
    '#type' => 'select',
    '#title' => t('Default CV2AVS response'),
    '#multiple' => FALSE,
    '#description' => t("This is the response value for the CV2CVS callback parameter returned by PayPoint.net's server when running in test mode. Especially useful if you have set the CV2AVS options in the merchant admin interface and donâ€™t want to have to remove them for testing specific CV2AVS results."),
    '#options' => drupal_map_assoc(array(
      'ALL MATCH',
      'SECURITY CODE MATCH ONLY',
      'ADDRESS MATCH ONLY',
      'NO DATA MATCHES',
      'DATA NOT CHECKED',
      'PARTIAL ADDRESS MATCH / POSTCODE',
      'PARTIAL ADDRESS MATCH / ADDRESS',
      'SECURITY CODE MATCH / POSTCODE',
      'SECURITY CODE MATCH / ADDRESS',
    )),
    '#default_value' => $settings['testing']['default_cv2avs'],
  );

  return $form;
}

/**
 * Collects the request data to be sent to PayPoint.net's XML-RPC endpoint.
 *
 * @param $order
 *   The order object.
 * @param $settings
 *   The current payment method's settings array.
 * @param $pane_values
 *   The form values array.
 *
 * @return $data
 *   The data to be sent in the request call to the XML-RPC endpoint.
 */
function commerce_paypoint_gateway_freedom_data_get($order, $settings, $pane_values) {
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  $total = commerce_line_items_total($order_wrapper->commerce_line_items);
  $credit_card = $pane_values['credit_card'];

  // Generate the options string.
  $options = array(
    'cv2' => $credit_card['code'],
    'currency' => $total['currency_code'],
    'dups' => $settings['duplicate_checking'] === 1 ? 'true' : 'false',
    'deferred' => commerce_paypoint_deferred_parameter_format($settings),
  );

  // Values of either 'true' or 'false' mean we're in testing mode.
  if ($settings['testing']['test_status'] != COMMERCE_PAYPOINT_TEST_MODE_LIVE) {
    // The Integration Guide suggests that we avoid adding the test_status
    // parameter when in live mode.
    $options['test_status'] = $settings['testing']['test_status'];
    // Simulate the CV2AVS response.
    $options['default_cv2avs'] = $settings['testing']['default_cv2avs'];
  }
  $options_string = commerce_paypoint_gateway_freedom_key_value_string($options);

  // Generate the billing details string.
  $billing = array();
  // Add the billing details if they exist.
  if (!empty($order_wrapper->commerce_customer_billing->commerce_customer_address)) {
    $billing_address = $order_wrapper->commerce_customer_billing->commerce_customer_address->value();

    $billing['company'] = $billing_address['organisation_name'];
    $billing['addr_1'] = $billing_address['thoroughfare'];
    $billing['addr_2'] = $billing_address['premise'];
    $billing['city'] = $billing_address['locality'];
    $billing['state'] = $billing_address['administrative_area'];
    $billing['post_code'] = $billing_address['postal_code'];

    if (!empty($billing_address['name_line'])) {
      $billing['name'] = $billing_address['name_line'];
    }
    else {
      $billing['name'] = $billing_address['first_name'] . ' ' . $billing_address['last_name'];
    }
  }
  // Always add the email address.
  $billing['email'] = $order->mail;
  $billing_string = commerce_paypoint_gateway_freedom_key_value_string($billing);

  // We must format the year and month to format the service expects (mmyy).
  $expiry_date = commerce_paypoint_gateway_freedom_card_date_format($credit_card['exp_month'], $credit_card['exp_year']);

  $start_date = '';
  if (!empty($credit_card['start_month']) && !empty($credit_card['start_year'])) {
    $start_date = commerce_paypoint_gateway_freedom_card_date_format($credit_card['start_month'], $credit_card['start_year']);
  }

  $data = array(
    'mid' => $settings['merchant']['merchant_id'], // Merchant id, mid.
    'vpn_pswd' => $settings['merchant']['vpn_password'], // VPN password.
    // Append the timestamp to the transaction ID to ensure that it is unique
    // for each payment attempt. Allows the customer to retry following failed
    // payment attempts.
    'trans_id' => $order->order_id . '-' . REQUEST_TIME, // Transaction id, trans_id .
    'ip' => ip_address(), // External IP address of the cardholder.
    'name' => $credit_card['owner'], // Cardholder name.
    'card_number' => $credit_card['number'],
    'amount' => (string) _commerce_paypoint_order_total_get($order),
    'expiry_date' => $expiry_date, // Expiration date, formatted as mm/yy or mmyy.
    // Issue number only applies to Maestro or Solo cards.
    'issue_number' => $credit_card['issue'],
    'start_date' => $start_date,
    'order' => '',
    'shipping' => '', // Shipping address.
    'billing' => $billing_string,
    'options' => $options_string, // Extra options.
  );

  if (variable_get('commerce_paypoint_debug', FALSE)) {
    debug($data);
  }

  return $data;
}

/**
 * Formats a credit card start or expiry date in mmyy format.
 */
function commerce_paypoint_gateway_freedom_card_date_format($month, $year) {
  return date('my', mktime(0, 0, 0, $month, 1, $year));
}

/**
 * Converts a data array to key=value pairs separated by commas.
 *
 * @param $data
 *   An array of keys and values to covert.
 *
 * @return
 *   A string of key-value pairs separated by commas.
 */
function commerce_paypoint_gateway_freedom_key_value_string($data) {
  $list = array();
  foreach ($data as $key => $value) {
    $trimmed = trim($value);
    if (!empty($trimmed)) {
      $list[] = "$key=$value";
    }
  }

  return implode(',', $list);
}

/**
 * Payment method callback: Displays the payment form.
 */
function commerce_paypoint_gateway_freedom_submit_form($payment_method, $pane_values, $checkout_pane, $order) {
  module_load_include('inc', 'commerce_payment', 'includes/commerce_payment.credit_card');

  // Merge default settings into the stored settings array.
  // This is only relevant before the form is saved for the first time.
  $payment_method['settings'] += commerce_paypoint_gateway_freedom_default_settings();

  // Prepare the fields to include on the credit card form.
  $fields = array(
    'owner' => '',
    'code' => '',
  );

  // Include the card security code field if specified.
  if ($payment_method['settings']['code']) {
    $fields['code'] = '';
  }

  // Add the credit card types array if necessary.
  $card_types = (array)array_keys(commerce_payment_credit_card_types());
  if (!empty($card_types)) {
    $fields['type'] = $card_types;
  }

  // Add the start date and issue number if processing a Maestro or Solo card.
  if (in_array('maestro', $card_types) || in_array('solo', $card_types)) {
    $fields += array(
      'start_date' => '',
      'issue' => '',
    );
  }

  // Default to a known test credit card number, see: Gateway_Freedom.pdf (Test Card Numbers).
  return commerce_payment_credit_card_form($fields, array('number' => '4111111111111111'));
}

/**
 * Payment method callback: checkout form validation.
 */
function commerce_paypoint_gateway_freedom_submit_form_validate($payment_method, $pane_form, $pane_values, $order, $form_parents = array()) {
  module_load_include('inc', 'commerce_payment', 'includes/commerce_payment.credit_card');

  $settings = array(
    'form_parents' => array_merge($form_parents, array('credit_card')),
  );

  if (!commerce_payment_credit_card_validate($pane_values['credit_card'], $settings)) {
    return FALSE;
  }
}

/**
 * Payment method callback: checkout form submission.
 */
function commerce_paypoint_gateway_freedom_submit_form_submit($payment_method, $pane_form, $pane_values, $order, $charge) {
  // Display an error and prevent the payment attempt if payment method has not been configured yet.
  if (empty($payment_method['settings'])) {
    drupal_set_message(t('This payment method must be configured by an administrator before it can be used.'), 'error');
    return FALSE;
  }

  // Ensure we can determine a valid IPv4 IP address.
  if ($payment_method['settings']['testing']['test_status'] == COMMERCE_PAYPOINT_TEST_MODE_LIVE) {
    $ip_address = ip_address();

    // Go ahead and convert localhost from IPv6 to IPv4.
    if ($ip_address == '::1') {
      $ip_address = '127.0.0.1';
      watchdog('PayPoint', 'PayPoint must be able to retrieve an IPv4 IP address from the ip_address() function when not testing payments from localhost. While testing from localhost, your IPv6 address ::1 was automatically converted to 127.0.0.1.', array(), WATCHDOG_WARNING);
    }

    if (!filter_var($ip_address, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) {
      drupal_set_message(t('This payment method is not supported by the current web server configuration.'), 'error');
      watchdog('PayPoint', 'PayPoint must be able to retrieve an IPv4 IP address from the ip_address() function when not testing payments from localhost.', array(), WATCHDOG_ERROR);
      return FALSE;
    }
  }

  // Determine the currency code to use to actually process the transaction,
  // which will either be the default currency code or the currency code of the
  // charge if it's supported by module if that option is enabled.
  $currency_code = $payment_method['settings']['currency_code'];

  if (!empty($payment_method['settings']['allow_supported_currencies']) && in_array($charge['currency_code'], array_keys(commerce_paypoint_gateway_freedom_currencies()))) {
    $currency_code = $charge['currency_code'];
  }

  // Convert the charge amount to the specified currency.
  $amount = commerce_currency_convert($charge['amount'], $charge['currency_code'], $currency_code);

  // PayPoint requires a billing address, so ensure one has been added to the
  // order before building the name-value pair array.
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

  /*
  $valid_billing_address = TRUE;

  if (empty($order->commerce_customer_billing) || empty($order_wrapper->commerce_customer_billing->value()->commerce_customer_address)) {
    $valid_billing_address = FALSE;
  }
  else {
    // Check the values in the billing address array required by the module.
    $address_value = $order_wrapper->commerce_customer_billing->commerce_customer_address->value();

    if (empty($address_value['name_line']) && empty($address_value['first_name'])) {
      $valid_billing_address = FALSE;
    }

    foreach (array('thoroughfare', 'locality', 'postal_code', 'country') as $address_key) {
      if (empty($address_value[$address_key])) {
        $valid_billing_address = FALSE;
      }
    }
  }

  // Without a valid villing address, display and log the error messages and
  // prevent the payment attempt.
  if (!$valid_billing_address) {
    // Display a general error to the customer if we can't find the address.
    drupal_set_message(t('We cannot process your credit card payment without a valid billing address.'), 'error');

    // Provide a more descriptive error message in the failed transaction and
    // the watchdog.
    $transaction = commerce_payment_transaction_new($payment_method['method_id'], $order->order_id);
    $transaction->instance_id = $payment_method['instance_id'];
    $transaction->amount = $amount;
    $transaction->currency_code = $currency_code;
    $transaction->payload[REQUEST_TIME] = array();
    $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
    $transaction->message = t('The customer must be able to supply a billing address through the default address field of the core billing information customer profile to pay via PayPoint.');

    // Save the transaction information.
    commerce_payment_transaction_save($transaction);

    watchdog('PayPoint', 'A PayPoint transaction failed because the order did not have a value for the default billing address field. Your order or checkout configuration may need to be adjusted to support credit card payment via PayPoint.', NULL, WATCHDOG_ERROR);

    return FALSE;
  }
  */

  $response = commerce_paypoint_gateway_freedom_realtime_transaction_request($order, $payment_method['settings'], $pane_values);

  // Every attempted transaction should result in a new transaction entity being
  // created for the order to log either the success or the failure.
  return commerce_paypoint_gateway_freedom_transaction($payment_method, $order, $response);
}

/**
 * Makes the call to the XML-RPC endpoint and returns the response array.
 */
function commerce_paypoint_gateway_freedom_realtime_transaction_request($order, $settings, $pane_values) {
  require_once DRUPAL_ROOT . '/includes/xmlrpc.inc';

  $url = PAYPOINT_GATEWAY_FREEDOM_ENDPOINT; // Get the API endpoint URL for the method's transaction mode.
  $method = 'SECVPN.validateCardFull';
  $data = commerce_paypoint_gateway_freedom_data_get($order, $settings, $pane_values);

  // Allow modules to alter parameters of the API request.
  drupal_alter('commerce_paypoint_gateway_freedom_realtime_transaction_request', $data, $order);

  $result = commerce_paypoint_gateway_freedom_xmlrpc_request($url, $method, $data);

  // If the call failed, log an error.
  if ($result === FALSE) {
    watchdog('PayPoint', 'XML-RPC error: @errno. Message: @message.', array('@errno' => xmlrpc_errno(), '@message' => xmlrpc_error_msg()), WATCHDOG_ERROR);
  }

  // Parse the resultant XML into an array of response parameters.
  _commerce_paypoint_gateway_freedom_response_parse($result, $response);
  return $response;
}

/**
 * Parses the response XML into an array of parameters.
 */
function _commerce_paypoint_gateway_freedom_response_parse($result, &$response = array()) {
  // Strip the XML tags, leaving only the content.
  $result = strip_tags($result);

  // Cut off the leading "?".
  $result = substr($result, 1);

  // Decode any HTML entities.
  $result = html_entity_decode($result);

  // Parse the remaining query string into an array.
  return parse_str($result, $response);
}

/**
 * Initiates the XML-RPC request and returns the XML response data.
 *
 * Unfortunately, xmlrpc() returns an unparsable representation of the response
 * data. Therefore, we need to work around the problem by calling
 * drupal_http_request directly and passing the XML data on for parsing.
 *
 * @param $url
 *   The XML-RPC endpoint URL to call.
 * @param $method
 *   The XML-RPC method to invoke.
 * @param $data
 *   An array containing the request paramaters.
 *
 * @return
 *   The result XML data on success, or FALSE on failure.
 */
function commerce_paypoint_gateway_freedom_xmlrpc_request($url, $method, $data) {
  $xmlrpc_request = xmlrpc_request($method, array_values($data));

  $options['method'] = 'POST';
  $options['headers']['Content-Type'] = 'text/xml';
  $options['data'] = $xmlrpc_request->xml;

  $result = drupal_http_request($url, $options);

  if ($result->code != 200) {
    xmlrpc_error($result->code, $result->error);
    return FALSE;
  }

  $message = xmlrpc_message($result->data);

  if (!xmlrpc_message_parse($message)) {
    xmlrpc_error(-32700, t('Parse error. Not well formed.'));
    return FALSE;
  }

  if ($message->messagetype == 'fault') {
    xmlrpc_error($message->fault_code, $message->fault_string);
    return FALSE;
  }

  // We now know that the message is well-formed and a non-fault result.
  return $result->data;
}

/**
 * Processes the transaction.
 */
function commerce_paypoint_gateway_freedom_transaction($payment_method, $order, $response) {
  // Sanitize the incoming data.
  $response = array_map('check_plain', $response);

  // Initialize the transaction.
  $transaction = commerce_payment_transaction_new($payment_method['method_id'], $order->order_id);
  $transaction->instance_id = $payment_method['instance_id'];
  $transaction->remote_id = $response['trans_id'];

  // The amount callback parameter is the amount actually authorised by the
  // bank. If the bank does not authorise the payment, the amount callback
  // parameter will be empty.
  $amount = empty($response['amount']) ? 0 : $response['amount'];

  // PayPoint.net only sends back the currency callback parameter if it is not
  // GBP. We can therefore assume that a transaction without currency set is in
  // GBP.
  $currency = empty($response['currency']) ? 'GBP' : $response['currency'];

  $transaction->amount = commerce_currency_decimal_to_amount($amount, $currency);
  $transaction->currency_code = $currency;
  $transaction->payload[REQUEST_TIME] = $response;
  $transaction->remote_status = _commerce_paypoint_response_remote_status_calculate($response);

  $messages = array();

  // Handle simple response codes. Complex response codes which contain multiple
  // failure reasons (such as P:NEC) are handled separately below.
  switch ($response['code']) {
    case 'A': // Transaction authorised by bank.
      // Deferred transactions don't take the payment at the time of sale so
      // mark the payment as pending until it can be manually released.
      if (!empty($response['deferred']) && $response['deferred'] === 'true') {
        $transaction->status = COMMERCE_PAYMENT_STATUS_PENDING;
      }
      else {
        $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
      }

      $messages[] = _commerce_paypoint_response_message_calculate($response);
      break;

    case 'N': // Transaction not authorised.
    case 'C': // Communication problem.
    case 'F': // Fraud condition detected.
      $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
      $messages[] = _commerce_paypoint_response_message_calculate($response);
      break;

    // Pre-bank checks failed.
    case 'P:A': case 'P:X': case 'P:P': case 'P:S': case 'P:E': case 'P:I':
    case 'P:C': case 'P:T': case 'P:N': case 'P:M': case 'P:B': case 'P:D':
    case 'P:V': case 'P:R': case 'P:#':
      $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
      $messages[] = t('Pre-bank checks failed: %message', array('%message' => $transaction->message));
      break;
  }

  // Handle complex response codes. When multiple pre-bank checks fail, we're
  // given a compound code parameter such as P:NEC (which means that the name,
  // expiry date, and card number fields are all invalid or have not been
  // supplied).
  if (strpos($response['code'], 'P:') === 0 && strlen($response['code']) > 3) {
    $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
    $messages[] = t('Multiple pre-bank checks failed with error code %error_code:', array('%error_code' => $response['code']));

    // Split any characters that appear after "P:" into an array.
    $error_codes = str_split(substr($response['code'], 2));

    // Add each of the pre-authorisation failure messages to the messages array.
    foreach ($error_codes as $error_character) {
      $messages[] = _commerce_paypoint_response_message_calculate('P:' . $error_character);
    }
  }

  // Add the result of the CV2 and AVS anti-fraud checks sent from the bank.
  if (isset($response['cv2avs'])) {
    $messages[] = t('CV2AVS message: %message', array('%message' => _commerce_paypoint_cv2avs_message_parse($response['cv2avs'])));
  }

  // Add all of the messages to the transaction.
  $transaction->message = implode(' ', $messages);

  // Save the transaction and redirect to the next step in the checkout
  // process.
  commerce_payment_transaction_save($transaction);

  // Display an error if the transaction failed.
  if ($transaction->status === COMMERCE_PAYMENT_STATUS_FAILURE) {
    drupal_set_message(t('There was a problem with your payment details. Please try again. If the problem persists, please contact us.'), 'error');
    return FALSE;
  }
}

/**
 * Returns an array of all possible Direct Payment currency codes.
 */
function commerce_paypoint_gateway_freedom_currencies() {
  return drupal_map_assoc(array('AUD', 'CAD', 'CHF', 'CZK', 'DKK', 'EUR', 'GBP', 'HKD', 'HUF', 'JPY', 'NOK', 'NZD', 'PLN', 'SEK', 'SGD', 'USD'));
}

