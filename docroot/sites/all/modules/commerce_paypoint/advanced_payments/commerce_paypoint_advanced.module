<?php
/**
 * @file
 * Integrates 3rd generation PayPoint.net's Advanced Payments with Drupal Commerce.
 * See: https://developer.paypoint.com/payments/docs/
 */

/**
 * PayPoint.net's Advanced Payments XML-RPC endpoint URL.
 */
define('PAYPOINT_ADV_MITE_HOSTED_ENDPOINT', 'https://hosted.mite.paypoint.net');
define('PAYPOINT_ADV_MITE_API_ENDPOINT', 'https://api.mite.paypoint.net:2443');
define('PAYPOINT_ADV_LIVE_HOSTED_ENDPOINT', 'https://hosted.paypoint.net');
define('PAYPOINT_ADV_LIVE_API_ENDPOINT', 'https://api.paypoint.net');
define('PAYPOINT_ADV_DEBUG', FALSE); // Override in the settings.

/**
 * Implements hook_menu().
 */
function commerce_paypoint_advanced_menu() {
  $items = array();

  // Define a path to receive VPS callback (Server only).
  // @fixme
  $items['commerce_paypoint/notify-callback/%/%'] = array(
    'page callback' => 'commerce_paypoint_advanced_notify_callback',
    'page arguments' => array(2, 3),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
    'file' => 'includes/commerce_paypoint_advanced_hosted.inc',
  );

  // Define a path for a waiting page displayed whilst the iframe is loading.
  $items['commerce_paypoint/paypoint_waiting_page'] = array(
    'page callback' => 'commerce_paypoint_advanced_waiting_page',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'includes/commerce_paypoint_advanced.pages.inc',
  );

  // Payment page result for iframe.
  $items['commerce_paypoint/payment_result'] = array(
    'page callback' => 'commerce_paypoint_advanced_payment_result_page',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'includes/commerce_paypoint_advanced.pages.inc',
  );

  // View help topic index.
  $items['admin/help/commerce_paypoint_advanced'] = array(
    'title' => "PayPoint.net's Advanced Payments",
    'description' => "Integration of 3rd generation PayPoint.net's Advanced Payments with Drupal Commerce",
    'page callback' => 'commerce_paypoint_advanced_index_page',
    'access arguments' => array('view advanced help index'),
    'weight' => 9,
  );

  return $items;
}

/**
 * Implements hook_commerce_payment_method_info().
 */
function commerce_paypoint_advanced_commerce_payment_method_info() {
  $payment_methods = array();

  $payment_methods['paypoint_advanced'] = array(
    'base' => 'commerce_paypoint_advanced',
    'title' => t('PayPoint.net Advanced Payments'),
    'description' => t('Integrates PayPoint.net Advanced Payments service.'),
    'short_title' => t('PayPoint.net'),
    'display_title' => t('Credit or Debit card (PayPoint)'),
    'active' => TRUE,
    'offsite' => TRUE,
    'terminal' => FALSE,
    'callbacks' => array(),
    'offsite_autoredirect' => FALSE,
    'file' => 'includes/commerce_paypoint_advanced_hosted.inc',
  );

  return $payment_methods;
}

/**
 * Implements hook_page_build().
 */
function commerce_paypoint_advanced_page_build($page) {
  $url = explode('/', current_path());
  if (count($url) > 2) {
    if ($url[0] == 'checkout') {
      drupal_add_js(drupal_get_path('module', 'commerce_paypoint_advanced') .
      '/js/commerce_paypoint_hosted_iframe.js', array('type' => 'file', 'scope' => 'header', 'weight' => -100));
    }
  }
}

/**
 * Returns the default settings for the payment method settings form.
 *
 * @see commerce_paypoint_advanced_settings_form()
 */
function commerce_paypoint_advanced_default_settings() {
  $default_currency = variable_get('commerce_default_currency', 'GBP');

  return array(
    'integration_type' => array(
      'use_iframe' => FALSE,
    ),
    'merchant' => array(
      'username' => '',
      'password' => '',
      'instId'   => '',
    ),
    'connectivity' => array(
      'server' => 'sandbox',
      'request_type' => 'hosted',
      'debug' => PAYPOINT_ADV_DEBUG ?: variable_get('commerce_paypoint_debug', FALSE),
    ),
    'duplicate_checking' => 1,
    'deferred' => array(
      'transaction_mode' => 'false',
      'reuse_credit_card_days' => 7,
      'reuse_debit_card_days' => 1,
    ),
    'testing' => array(
      'test_status' => COMMERCE_PAYPOINT_TEST_MODE_TEST,
    ),
    'code' => TRUE,
    'card_types' => drupal_map_assoc(array('visa', 'mastercard', 'amex', 'discover')),
    'currency_code' => in_array($default_currency, array_keys(commerce_paypoint_advanced_currencies())) ? $default_currency : 'GBP',
    'allow_supported_currencies' => FALSE,

  );
}

/**
 * Generates a settings form for the payment method options.
 *
 * @param $settings
 *   An array of the current settings.
 *
 * @return
 *   The settings form array.
 *
 * @ingroup forms
 */
function commerce_paypoint_advanced_settings_form($settings = NULL) {
  module_load_include('inc', 'commerce_payment', 'includes/commerce_payment.credit_card');
  $form = array();

  // Merge default settings into the stored settings array.
  // This is only relevant before the form is saved for the first time.
  $settings += commerce_paypoint_advanced_default_settings();

  // Items only relevant to PayPoint Server integration.
  $form['integration_type'] = array(
    '#type' => 'fieldset',
    '#title' => t('PayPoint Integration Options'),
  );

  $form['integration_type']['use_iframe'] = array(
    '#type'          => 'checkbox',
    '#title'         => t('Display payment form in an iFrame'),
    '#description'   => t('Disabled, due partial implementation.') . '<br>' .  t('Use an iFrame to make the payment page appear to be an integrated part of your site.'),
    '#default_value' => $settings['integration_type']['use_iframe'] ?: FALSE,
  );

  /*
  $form['integration_type']['server_enabled'] = array(
    '#type' => 'checkbox',
    '#title' => t('Server (Including InFrame)'),
    '#default_value' => $settings['integration_type']['server_enabled'],
  );
  */

  /*
  $form['integration_type']['use_low_profile'] = array(
    '#type'          => 'checkbox',
    '#title'         => t('Use low profile payment pages'),
    '#description'   => t('Use the less graphical, simpler set of payment pages which look better inside an iFrame.'),
    '#default_value' => $settings['integration_type']['use_low_profile'],
  );
  */

  /*
  $form['integration_type']['form_enabled'] = array(
    '#type' => 'checkbox',
    '#title' => t('Form (Completely outsourcing your online payments to PayPoint.'),
    '#default_value' => $settings['integration_type']['form_enabled'],

  );
  */

  /*
  $form['card_types'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Limit accepted credit cards to the following types'),
    '#description' => t('American Express is not available in the UK. Only MasterCard and Visa are available in Canada. If you enable Maestro or Solo, you must use GBP as your currency code.'),
    '#options' => array_intersect_key(commerce_payment_credit_card_types(), drupal_map_assoc(array('visa', 'mastercard', 'amex', 'discover', 'maestro', 'solo'))),
    '#default_value' => $settings['card_types'],
    '#required' => TRUE,
  );
  */

  $form['currency_code'] = array(
    '#type' => 'select',
    '#title' => t('Default currency'),
    '#description' => t('Transactions in other currencies will be converted to this currency, so multi-currency sites must be configured to use appropriate conversion rates.'),
    '#options' => commerce_paypoint_advanced_currencies(),
    '#default_value' => $settings['currency_code'],
  );
  $form['code'] = array(
    '#type' => 'checkbox',
    '#title' => t('Require the card security code (i.e. CVV) to process credit card transactions.'),
    '#default_value' => $settings['code'],
  );

  $form['merchant'] = array(
    '#type' => 'fieldset',
    '#title' => t('API credentials'),
  );
  $form['merchant']['username'] = array(
    '#type' => 'textfield',
    '#title' => t('Username'),
    '#description' => t('Enter your PayPoint API account username.'),
    '#maxlength' => 50,
    '#default_value' => $settings['merchant']['username'],
  );
  $form['merchant']['password'] = array(
    '#type' => 'textfield',
    '#title' => t('Password'),
    '#description' => t('Enter your PayPoint API account password.'),
    '#maxlength' => 50,
    '#default_value' => $settings['merchant']['password'],
  );
  /*
   * In order to handle your request securely and reliably, you will need to submit credentials specific to your organisation with each request.
   * You will also be issued with at least one installation identifier.
   * If your company has multiple websites you may have a separate installation for each.
   */
  $form['merchant']['instId'] = array(
    '#type' => 'textfield',
    '#title' => t('The installation id'),
    '#description' => t('Enter your PayPoint API account installation identifier.'),
    '#maxlength' => 50,
    '#default_value' => $settings['merchant']['instId'],
  );

  $form['connectivity'] = array(
    '#type' => 'fieldset',
    '#title' => t('Connectivity'),
  );
  $form['connectivity']['server'] = array(
    '#type' => 'radios',
    '#title' => t('PayPoint End points'),
    '#options' => array(
      'sandbox' => ('Sandbox - use for testing'),
      'live' => ('Live - use for processing real transactions'),
    ),
    '#description' => t('Use the following endpoints for MITE and for LIVE. Merchant Integration Test Environment (MITE) allows you to test your integration before you submit real customer transactions.'),
    '#default_value' => $settings['connectivity']['server'],
  );
  $form['connectivity']['request_type'] = array(
    '#type' => 'radios',
    '#title' => t('PayPoint request type'),
    '#options' => array(
      // 'API' => ('API Requests'), // @todo
      // 'SDK' => ('SDK'), // ?
      'hosted' => ('Hosted Cashier'),
    ),
    '#description' => t('There are three ways you can access payment services: as a Hosted solution, via an API or using an SDK. Currently only Hosted Cashier is supported.'),
    '#default_value' => $settings['connectivity']['request_type'],
  );
  $form['connectivity']['debug'] = array(
    '#type' => 'checkbox',
    '#title' => t('Debug PayPoint request/responses.'),
    '#description' => t('Log all data from requests/responses.'),
    '#default_value' => $settings['connectivity']['debug'] ?: variable_get('commerce_paypoint_debug', FALSE),
  );

  /* @todo: ?
  $form['deferred'] = array(
    '#type' => 'fieldset',
    '#title' => t('Deferred transactions'),
  );
  $form['deferred']['transaction_mode'] = array(
    '#type' => 'select',
    '#title' => t('Transaction mode'),
    '#description' => t('Not implemented. Deferred transactions are useful if you want to take orders for items that you cannot always guarantee will be in stock. Using deferred transactions, you can take an initial authorisation (at which point no money has actually been taken) and then, when your product arrives in stock, you can release the funds for the deferred transaction and ship the product out to your customer. It is illegal in some countries to take payment for something which you don\'t have in stock.
<ul>
  <li>"Defer" will authorise only one unit of currency. This is useful avoid tying up funds in your customer\'s account if all you want to do is get their details into the system.</li>
  <li>"Full" will authorise the full amount of the transaction and freeze the funds in the customer\'s account. A new authorisation takes place when funds are released so be careful not to ship goods before confirming release of funds.</li>
  <li>"Reuse" will authorise the full amount of the initial transaction but on release will use the original authorisation code (which was obtained by the initial deferred transaction - if it is still valid). If not still valid, releasing will cause a new authorisation to take place (as is the case with "Defer" and "Full").</li>
</ul>'),
    '#options' => array(
      COMMERCE_PAYMENT_DEFERRED_DISABLED => t('Disabled'),
      COMMERCE_PAYMENT_DEFERRED_TRUE => t('Defer'),
      COMMERCE_PAYMENT_DEFERRED_REUSE => t('Reuse'),
    ),
    '#default_value' => $settings['deferred']['transaction_mode'],
    '#disabled' => TRUE,
  );
  $form['deferred']['reuse_credit_card_days'] = array(
    '#type' => 'select',
    '#title' => t('Credit card reuse days'),
    '#multiple' => FALSE,
    '#description' => t('Not implemented. The number of days within which a credit card transaction should reuse the same authorisation code.'),
    '#options' => drupal_map_assoc(range(1, 14)),
    '#default_value' => $settings['deferred']['reuse_credit_card_days'],
    '#disabled' => TRUE,
  );
  $form['deferred']['reuse_debit_card_days'] = array(
    '#type' => 'select',
    '#title' => t('Debit card reuse days'),
    '#multiple' => FALSE,
    '#description' => t('Not implemented. The number of days within which a debit card transaction should reuse the same authorisation code.'),
    '#options' => drupal_map_assoc(range(1, 14)),
    '#default_value' => $settings['deferred']['reuse_debit_card_days'],
    '#disabled' => TRUE,
  );
  */

  $form['duplicate_checking'] = array(
    '#type' => 'checkbox',
    '#title' => t('Duplicate transaction checking'),
    '#description' => t('Not implemented.') . '<br>' . t('Duplicate transaction checking will stop the same order ID from the same user being used twice in the same hour. PayPoint.net believe this feature reduces customer bills by approximately 10% and also reduces the administration overhead, it is a "best efforts" feature however and can never be 100%. You must accept that occasionally you will get duplicates. During the testing phase of your integration, it is sometimes useful to not have to bother creating a new order ID for each transaction you send to PayPoint.net. If you wish to send test transactions with the same order ID but want PayPoint.net to not perform duplicate checks i.e., you want PayPoint.net to allow these duplicate transactions into the system without blocking them as duplicates then you must disable this option.'),
    '#default_value' => $settings['duplicate_checking'],
    '#disabled' => TRUE,
  );

  $form['testing'] = array(
    '#type' => 'fieldset',
    '#title' => t('Testing settings'),
  );

  $form['testing']['test_status'] = array(
    '#type' => 'select',
    '#title' => t('Test status'),
    '#description' => t('"Test" mode will simulate an authorised callback without contacting the bank, "Auto-decline" will simulate a declined callback without contacting the bank, and "Live" will send the transaction to the bank for authorization.'),
    '#options' => array(
      COMMERCE_PAYPOINT_TEST_MODE_TEST => t('Test'),
      COMMERCE_PAYPOINT_TEST_MODE_DECLINE => t('Auto-decline'),
      COMMERCE_PAYPOINT_TEST_MODE_LIVE => t('Live'),
    ),
    '#default_value' => $settings['testing']['test_status'],
  );

  return $form;
}

/**
 * Collects the request data to be sent to PayPoint.net's XML-RPC endpoint.
 *
 * @param $order
 *   The order object.
 * @param $settings
 *   The current payment method's settings array.
 * @param $pane_values
 *   The form values array.
 *
 * @return $data
 *   The data to be sent in the request call to the XML-RPC endpoint.
 */
function commerce_paypoint_advanced_data_get($order, $settings, $pane_values) {
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  $total = commerce_line_items_total($order_wrapper->commerce_line_items);
  $credit_card = $pane_values['credit_card'];

  // Generate the options string.
  $options = array(
    'cv2' => $credit_card['code'],
    'currency' => $total['currency_code'],
    'dups' => $settings['duplicate_checking'] === 1 ? 'true' : 'false',
    'deferred' => commerce_paypoint_deferred_parameter_format($settings),
  );

  // Values of either 'true' or 'false' mean we're in testing mode.
  if ($settings['testing']['test_status'] != COMMERCE_PAYPOINT_TEST_MODE_LIVE) {
    // The Integration Guide suggests that we avoid adding the test_status
    // parameter when in live mode.
    $options['test_status'] = $settings['testing']['test_status'];
    // Simulate the CV2AVS response.
  }
  $options_string = commerce_paypoint_advanced_key_value_string($options);

  // Generate the billing details string.
  $billing = array();
  // Add the billing details if they exist.
  if (!empty($order_wrapper->commerce_customer_billing->commerce_customer_address)) {
    $billing_address = $order_wrapper->commerce_customer_billing->commerce_customer_address->value();

    $billing['company'] = $billing_address['organisation_name'];
    $billing['addr_1'] = $billing_address['thoroughfare'];
    $billing['addr_2'] = $billing_address['premise'];
    $billing['city'] = $billing_address['locality'];
    $billing['state'] = $billing_address['administrative_area'];
    $billing['post_code'] = $billing_address['postal_code'];

    if (!empty($billing_address['name_line'])) {
      $billing['name'] = $billing_address['name_line'];
    }
    else {
      $billing['name'] = $billing_address['first_name'] . ' ' . $billing_address['last_name'];
    }
  }
  // Always add the email address.
  $billing['email'] = $order->mail;
  $billing_string = commerce_paypoint_advanced_key_value_string($billing);

  // We must format the year and month to format the service expects (mmyy).
  $expiry_date = commerce_paypoint_advanced_card_date_format($credit_card['exp_month'], $credit_card['exp_year']);

  $start_date = '';
  if (!empty($credit_card['start_month']) && !empty($credit_card['start_year'])) {
    $start_date = commerce_paypoint_advanced_card_date_format($credit_card['start_month'], $credit_card['start_year']);
  }

  $data = array(
    'mid' => $settings['merchant']['username'], // Merchant id, mid.
    'vpn_pswd' => $settings['merchant']['password'], // VPN password.
    // Append the timestamp to the transaction ID to ensure that it is unique
    // for each payment attempt. Allows the customer to retry following failed
    // payment attempts.
    'trans_id' => $order->order_id . '-' . REQUEST_TIME, // Transaction id, trans_id .
    'ip' => ip_address(), // External IP address of the cardholder.
    'name' => $credit_card['owner'], // Cardholder name.
    'card_number' => $credit_card['number'],
    'amount' => (string) _commerce_paypoint_order_total_get($order),
    'expiry_date' => $expiry_date, // Expiration date, formatted as mm/yy or mmyy.
    // Issue number only applies to Maestro or Solo cards.
    'issue_number' => $credit_card['issue'],
    'start_date' => $start_date,
    'order' => '',
    'shipping' => '', // Shipping address.
    'billing' => $billing_string,
    'options' => $options_string, // Extra options.
  );

  if (variable_get('commerce_paypoint_debug', FALSE)) {
    debug($data);
  }

  return $data;
}

/**
 * Formats a credit card start or expiry date in mmyy format.
 */
function commerce_paypoint_advanced_card_date_format($month, $year) {
  return date('my', mktime(0, 0, 0, $month, 1, $year));
}

/**
 * Converts a data array to key=value pairs separated by commas.
 *
 * @param $data
 *   An array of keys and values to covert.
 *
 * @return
 *   A string of key-value pairs separated by commas.
 */
function commerce_paypoint_advanced_key_value_string($data) {
  $list = array();
  foreach ($data as $key => $value) {
    $trimmed = trim($value);
    if (!empty($trimmed)) {
      $list[] = "$key=$value";
    }
  }

  return implode(',', $list);
}

/**
 * Payment method callback: Displays the payment form.
 */
function commerce_paypoint_advanced_submit_form($payment_method, $pane_values, $checkout_pane, $order) {
   // @todo: Anything here?
}

/**
 * Payment method callback: redirect form, a wrapper around the module's general
 *   use function for building a form.
 */
function _commerce_paypoint_advanced_redirect_form($form, &$form_state, $order, $payment_method) {

  // Return an error if the enabling action's settings haven't been configured.
  if (empty($payment_method['settings']['business'])) {
    drupal_set_message(t('PayPoint is not configured for use. No PayPoint e-mail address has been specified.'), 'error');
    return array();
  }

  $settings = array(
    // Return to the previous page when payment is canceled
    'cancel_return' => url('checkout/' . $order->order_id . '/payment/back/' . $order->data['payment_redirect_key'], array('absolute' => TRUE)),

    // Return to the payment redirect page for processing successful payments
    'return' => url('checkout/' . $order->order_id . '/payment/return/' . $order->data['payment_redirect_key'], array('absolute' => TRUE)),

    // Specify the current payment method instance ID in the notify_url
    'payment_method' => $payment_method['instance_id'],

    // Include the application indicator
    'bn' => $payment_method['buttonsource'],
  );

  return commerce_paypoint_advanced_order_form($form, $form_state, $order, $payment_method['settings'] + $settings);
}

/**
 * Payment method callback: redirect form return validation.
 */
function commerce_paypoint_advanced_redirect_form_validate($order, $payment_method) {

  // This may be an unnecessary step, but if for some reason the user does end
  // up returning at the success URL with a Failed payment, go back.
  if (!empty($_POST['payment_status']) && $_POST['payment_status'] == 'Failed') {
    return FALSE;
  }

  // If for some reason the payment redirect key in this return post does not
  // match that in the order, prevent processing.
  if (empty($order->data['payment_redirect_key'])) {
    watchdog('commerce_paypoint_advanced', 'Customer returned from PayPoint does not have a redirect key.', array(), WATCHDOG_WARNING);
    return FALSE;
  }
}

/**
 * Payment method callback: checkout form validation.
 */
function commerce_paypoint_advanced_submit_form_validate($payment_method, $pane_form, $pane_values, $order, $form_parents = array()) {

  $settings = $payment_method['settings'];
  if (!$settings['merchant']['username'] || !$settings['merchant']['password']) {
    drupal_set_message('PayPoint is not configured for use. Please contact an administrator to resolve this issue.', 'error');
    watchdog('PayPoint', 'PayPoint credentials needs to be configured.', array(), WATCHDOG_ERROR);
    return FALSE;
  }

  // Testing connectivity to PayPoint end point.
  module_load_include('inc', 'commerce_paypoint_advanced', 'commerce_paypoint_advanced.class');
  $hosted = $settings['connectivity']['request_type'] == 'hosted';
  $url = commerce_paypoint_advanced_server_url($settings['testing']['test_status']);
  $ppo = new PPOAdvancedPayment($url, $settings['merchant']['username'], $settings['merchant']['password'], $hosted);
  try {
    $response = $ppo->sendPing();
  }
  catch (Exception $e) {
    watchdog('PayPoint', 'PayPoint payment service is not available at the moment. If the problem persists, please contact an administrator to resolve this issue.', array(), WATCHDOG_ERROR);
    watchdog_exception('commerce_paypoint_advanced', $e);
    return FALSE;
  }

}

/**
 * Payment method callback: checkout form submission.
 */
function commerce_paypoint_advanced_submit_form_submit($payment_method, $pane_form, $pane_values, $order, $charge) {

  // Display an error and prevent the payment attempt if payment method has not been configured yet.
  if (empty($payment_method['settings'])) {
    drupal_set_message(t('This payment method must be configured by an administrator before it can be used.'), 'error');
    return FALSE;
  }

  // Ensure we can determine a valid IPv4 IP address.
  $ip_address = ip_address();

  // Go ahead and convert localhost from IPv6 to IPv4.
  if ($payment_method['settings']['testing']['test_status'] == COMMERCE_PAYPOINT_TEST_MODE_LIVE) {
    if ($ip_address == '::1') {
      $ip_address = '127.0.0.1';
      watchdog('PayPoint', 'PayPoint must be able to retrieve an IPv4 IP address from the ip_address() function when not testing payments from localhost. While testing from localhost, your IPv6 address ::1 was automatically converted to 127.0.0.1.', array(), WATCHDOG_WARNING);
    }

    if (!filter_var($ip_address, FILTER_VALIDATE_IP, FILTER_FLAG_IPV4)) {
      drupal_set_message(t('This payment method is not supported by the current web server configuration.'), 'error');
      watchdog('PayPoint', 'PayPoint must be able to retrieve an IPv4 IP address from the ip_address() function when not testing payments from localhost.', array(), WATCHDOG_ERROR);
      return FALSE;
    }
  }

  // Determine the currency code to use to actually process the transaction,
  // which will either be the default currency code or the currency code of the
  // charge if it's supported by module if that option is enabled.
  $currency_code = $payment_method['settings']['currency_code'];

  if (!empty($payment_method['settings']['allow_supported_currencies']) && in_array($charge['currency_code'], array_keys(commerce_paypoint_advanced_currencies()))) {
    $currency_code = $charge['currency_code'];
  }

  // Convert the charge amount to the specified currency.
  $amount = commerce_currency_convert($charge['amount'], $charge['currency_code'], $currency_code);

  // PayPoint requires a billing address, so ensure one has been added to the
  // order before building the name-value pair array.
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

  $valid_billing_address = TRUE;

  if (empty($order->commerce_customer_billing) || empty($order_wrapper->commerce_customer_billing->value()->commerce_customer_address)) {
    $valid_billing_address = FALSE;
  }
  else {
    // Check the values in the billing address array required by the module.
    $address_value = $order_wrapper->commerce_customer_billing->commerce_customer_address->value();

    if (empty($address_value['name_line']) && empty($address_value['first_name'])) {
      $valid_billing_address = FALSE;
    }

    foreach (array('thoroughfare', 'locality', 'postal_code', 'country') as $address_key) {
      if (empty($address_value[$address_key])) {
        $valid_billing_address = FALSE;
      }
    }
  }

  // Without a valid villing address, display and log the error messages and
  // prevent the payment attempt.
  if (!$valid_billing_address) {
    // Display a general error to the customer if we can't find the address.
    drupal_set_message(t('We cannot process your payment without a valid billing address.'), 'error');

    // Provide a more descriptive error message in the failed transaction and
    // the watchdog.
    $transaction = commerce_payment_transaction_new($payment_method['method_id'], $order->order_id);
    $transaction->instance_id = $payment_method['instance_id'];
    $transaction->amount = $amount;
    $transaction->currency_code = $currency_code;
    $transaction->payload[REQUEST_TIME] = array();
    $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
    $transaction->message = t('The customer must be able to supply a billing address through the default address field of the core billing information customer profile to pay via PayPoint.');

    // Save the transaction information.
    commerce_payment_transaction_save($transaction);

    watchdog('PayPoint', 'A PayPoint transaction failed because the order did not have a value for the default billing address field. Your order or checkout configuration may need to be adjusted to support payment via PayPoint.', NULL, WATCHDOG_ERROR);

    return FALSE;
  }

  // Every attempted transaction should result in a new transaction entity being
  // created for the order to log either the success or the failure.
  //return commerce_paypoint_advanced_transaction($payment_method, $order, $response);
  return TRUE;
}

/**
 * Processes the transaction.
 */
/*
function commerce_paypoint_advanced_transaction($payment_method, $order, $response) {
  // Sanitize the incoming data.
  $response = array_map('check_plain', $response);

  // Initialize the transaction.
  $transaction = commerce_payment_transaction_new($payment_method['method_id'], $order->order_id);
  $transaction->instance_id = $payment_method['instance_id'];
  $transaction->remote_id = $response['trans_id'];

  // The amount callback parameter is the amount actually authorised by the
  // bank. If the bank does not authorise the payment, the amount callback
  // parameter will be empty.
  $amount = empty($response['amount']) ? 0 : $response['amount'];

  // PayPoint.net only sends back the currency callback parameter if it is not
  // GBP. We can therefore assume that a transaction without currency set is in
  // GBP.
  $currency = empty($response['currency']) ? 'GBP' : $response['currency'];

  $transaction->amount = commerce_currency_decimal_to_amount($amount, $currency);
  $transaction->currency_code = $currency;
  $transaction->payload[REQUEST_TIME] = $response;
  $transaction->remote_status = _commerce_paypoint_response_remote_status_calculate($response);

  $messages = array();

  // Handle simple response codes. Complex response codes which contain multiple
  // failure reasons (such as P:NEC) are handled separately below.
  switch ($response['code']) {
    case 'A': // Transaction authorised by bank.
      // Deferred transactions don't take the payment at the time of sale so
      // mark the payment as pending until it can be manually released.
      if (!empty($response['deferred']) && $response['deferred'] === 'true') {
        $transaction->status = COMMERCE_PAYMENT_STATUS_PENDING;
      }
      else {
        $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
      }

      $messages[] = _commerce_paypoint_response_message_calculate($response);
      break;

    case 'N': // Transaction not authorised.
    case 'C': // Communication problem.
    case 'F': // Fraud condition detected.
      $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
      $messages[] = _commerce_paypoint_response_message_calculate($response);
      break;

    // Pre-bank checks failed.
    case 'P:A': case 'P:X': case 'P:P': case 'P:S': case 'P:E': case 'P:I':
    case 'P:C': case 'P:T': case 'P:N': case 'P:M': case 'P:B': case 'P:D':
    case 'P:V': case 'P:R': case 'P:#':
      $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
      $messages[] = t('Pre-bank checks failed: %message', array('%message' => $transaction->message));
      break;
  }

  // Handle complex response codes. When multiple pre-bank checks fail, we're
  // given a compound code parameter such as P:NEC (which means that the name,
  // expiry date, and card number fields are all invalid or have not been
  // supplied).
  if (strpos($response['code'], 'P:') === 0 && strlen($response['code']) > 3) {
    $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
    $messages[] = t('Multiple pre-bank checks failed with error code %error_code:', array('%error_code' => $response['code']));

    // Split any characters that appear after "P:" into an array.
    $error_codes = str_split(substr($response['code'], 2));

    // Add each of the pre-authorisation failure messages to the messages array.
    foreach ($error_codes as $error_character) {
      $messages[] = _commerce_paypoint_response_message_calculate('P:' . $error_character);
    }
  }

  // Add the result of the CV2 and AVS anti-fraud checks sent from the bank.
  if (isset($response['cv2avs'])) {
    $messages[] = t('CV2AVS message: %message', array('%message' => _commerce_paypoint_cv2avs_message_parse($response['cv2avs'])));
  }

  // Add all of the messages to the transaction.
  $transaction->message = implode(' ', $messages);

  // Save the transaction and redirect to the next step in the checkout
  // process.
  commerce_payment_transaction_save($transaction);

  // Display an error if the transaction failed.
  if ($transaction->status === COMMERCE_PAYMENT_STATUS_FAILURE) {
    drupal_set_message(t('There was a problem with your payment details. Please try again. If the problem persists, please contact us.'), 'error');
    return FALSE;
  }
}
*/

/**
 * Payment method callback: validate an PayCash based on receiver e-mail address,
 *   price, and other parameters as possible.
 */
function commerce_paypoint_advanced_paypoint_paycash_validate($order, $payment_method, $ipn) {
  // Prepare a trimmed list of receiver e-mail addresses.
  if (!empty($payment_method['settings']['receiver_emails'])) {
    $receiver_emails = explode(',', $payment_method['settings']['receiver_emails']);
  }
  else {
    $receiver_emails = array();
  }

  // Add the business e-mail address to the list of addresses.
  $receiver_emails[] = $payment_method['settings']['business'];

  foreach ($receiver_emails as $key => &$email) {
    $email = trim(strtolower($email));
  }

  // Return FALSE if the receiver e-mail does not match one specified by the
  // payment method instance.
  if (!in_array(trim(strtolower($ipn['receiver_email'])), $receiver_emails)) {
    commerce_payment_redirect_pane_previous_page($order);
    watchdog('commerce_paypoint_advanced', 'PayCash rejected: invalid receiver e-mail specified (@receiver_email); must match the primary e-mail address on the PayPoint account.', array('@receiver_email' => $ipn['receiver_email']), WATCHDOG_NOTICE);
    return FALSE;
  }

  // Prepare the PayCash data for inclusion in the watchdog message if enabled.
  $paycash_data = '';

  if (!empty($payment_method['settings']['paycash_logging']) &&
    $payment_method['settings']['paycash_logging'] == 'full_ipn') {
    $paycash_data = '<pre>' . check_plain(print_r($ipn, TRUE)) . '</pre>';
  }

  // Log a message including the PayPoint transaction ID if available.
  if (!empty($ipn['txn_id'])) {
    watchdog('commerce_paypoint_advanced', 'PayCash validated for Order @order_number with ID @txn_id.!paycash_data', array('@order_number' => $order->order_number, '@txn_id' => $ipn['txn_id'], '!paycash_data' => $paycash_data), WATCHDOG_NOTICE);
  }
  else {
    watchdog('commerce_paypoint_advanced', 'PayCash validated for Order @order_number.!paycash_data', array('@order_number' => $order->order_number, '!paycash_data' => $paycash_data), WATCHDOG_NOTICE);
  }
}

/**
 * Payment method callback: process an PayCash once it's been validated.
 */
/*
function commerce_paypoint_advanced_paypoint_paycash_process($order, $payment_method, &$ipn) {
  // Do not perform any processing on transactions here that do not have
  // transaction IDs, indicating they are non-payment PayCashs such as those used
  // for subscription signup requests.
  if (empty($ipn['txn_id'])) {
    return FALSE;
  }

  // Exit when we don't get a payment status we recognize.
  if (!in_array($ipn['payment_status'], array('Failed', 'Voided', 'Pending', 'Completed', 'Refunded'))) {
    commerce_payment_redirect_pane_previous_page($order);
    return FALSE;
  }

  // If this is a prior authorization capture PayCash for which we've already
  // created a transaction...
  if (in_array($ipn['payment_status'], array('Voided', 'Completed')) &&
    !empty($ipn['auth_id']) && $auth_ipn = commerce_paypoint_paycash_load($ipn['auth_id'])) {
    // Load the prior PayCash's transaction and update that with the capture values.
    $transaction = commerce_payment_transaction_load($auth_ipn['transaction_id']);
  }
  else {
    // Create a new payment transaction for the order.
    $transaction = commerce_payment_transaction_new('paypoint_advanced', $order->order_id);
    $transaction->instance_id = $payment_method['instance_id'];
  }

  $transaction->remote_id = $ipn['txn_id'];
  $transaction->amount = commerce_currency_decimal_to_amount($ipn['mc_gross'], $ipn['mc_currency']);
  $transaction->currency_code = $ipn['mc_currency'];
  $transaction->payload[REQUEST_TIME . '-ipn'] = $ipn;

  // Set the transaction's statuses based on the PayCash's payment_status.
  $transaction->remote_status = $ipn['payment_status'];

  // If we didn't get an approval response code...
  switch ($ipn['payment_status']) {
    case 'Failed':
      $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
      $transaction->message = t("The payment has failed. This happens only if the payment was made from your customer’s bank account.");
      break;

    case 'Voided':
      $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
      $transaction->message = t('The authorization was voided.');
      break;

    case 'Pending':
      $transaction->status = COMMERCE_PAYMENT_STATUS_PENDING;
      $transaction->message = commerce_paypoint_paycash_pending_reason($ipn['pending_reason']);
      break;

    case 'Completed':
      $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
      $transaction->message = t('The payment has completed.');
      break;

    case 'Refunded':
      $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
      $transaction->message = t('Refund for transaction @txn_id', array('@txn_id' => $ipn['parent_txn_id']));
      break;
  }

  // Save the transaction information.
  commerce_payment_transaction_save($transaction);
  $ipn['transaction_id'] = $transaction->transaction_id;

  // Create a billing profile based on the PayCash if enabled.
  if (!empty($payment_method['settings']['paycash_create_billing_profile']) && isset($order->commerce_customer_billing)) {
    $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

    // If this order does not have a billing profile yet...
    if ($order_wrapper->commerce_customer_billing->value() === NULL) {
      // Ensure we have the required data in the PayCash.
      if (empty($ipn['residence_country']) || empty($ipn['first_name']) || empty($ipn['last_name'])) {
        $data = array_intersect_key($ipn, drupal_map_assoc(array('residence_country', 'first_name', 'last_name')));
        watchdog('commerce_paypoint_advanced', 'A billing profile for Order @order_number could not be created due to insufficient data in the PayCash:!data', array('@order_number' => $order->order_number, '!data' => '<pre>'. check_plain(print_r($data, TRUE)) .'</pre>'), WATCHDOG_WARNING);
      }
      else {
        // Create the new profile now.
        $profile = commerce_customer_profile_new('billing', $order->uid);

        // Add the address value.
        $profile_wrapper = entity_metadata_wrapper('commerce_customer_profile', $profile);

        $profile_wrapper->commerce_customer_address = array_merge(addressfield_default_values(), array(
          'country' => $ipn['residence_country'],
          'name_line' => $ipn['first_name'] . ' ' . $ipn['last_name'],
          'first_name' => $ipn['first_name'],
          'last_name' => $ipn['last_name'],
        ));

        // Save the profile, reference it from the order, and save the order.
        $profile_wrapper->save();
        $order_wrapper->commerce_customer_billing = $profile_wrapper;
        $order_wrapper->save();

        watchdog('commerce_paypoint_advanced', 'Billing profile created for Order @order_number containing the first and last names and residence country of the customer based on PayCash data.', array('@order_number' => $order->order_number));
      }
    }
  }

  commerce_payment_redirect_pane_next_page($order);
  watchdog('commerce_paypoint_advanced', 'PayCash processed for Order @order_number with ID @txn_id.', array('@txn_id' => $ipn['txn_id'], '@order_number' => $order->order_number), WATCHDOG_INFO);
}
*/

/**
 * Builds a Website Payments Standard form from an order object.
 *
 * @param $order
 *   The fully loaded order being paid for.
 * @param $settings
 *   An array of settings used to build out the form, including:
 *   - server: which server to use, either sandbox or live
 *   - business: the PayPoint e-mail address the payment submits to
 *   - cancel_return: the URL PayPoint should send the user to on cancellation
 *   - return: the URL PayPoint should send the user to on successful payment
 *   - currency_code: the PayPoint currency code to use for this payment if the
 *     total for the order is in a non-PayPoint supported currency
 *   - language: the PayPoint language code to use on the payment form
 *   - payment_action: the PayPoint payment action to use: sale, authorization,
 *     or order
 *   - payment_method: optionally a payment method instance ID to include in the
 *     PayCash notify_url
 *
 * @return
 *   A renderable form array.
 */
/*
function commerce_paypoint_advanced_order_form($form, &$form_state, $order, $settings) {
  $wrapper = entity_metadata_wrapper('commerce_order', $order);

  // Determine the currency code to use to actually process the transaction,
  // which will either be the default currency code or the currency code of the
  // order if it's supported by PayPoint if that option is enabled.
  $currency_code = $settings['currency_code'];
  $order_currency_code = $wrapper->commerce_order_total->currency_code->value();

  if (!empty($settings['allow_supported_currencies']) && in_array($order_currency_code, array_keys(commerce_paypoint_currencies('paypoint_advanced')))) {
    $currency_code = $order_currency_code;
  }

  $amount = $wrapper->commerce_order_total->amount->value();

  // Ensure a default value for the payment_method setting.
  $settings += array('payment_method' => '');

  // Build the data array that will be translated into hidden form values.
  $data = array(
    // Specify the checkout experience to present to the user.
    'cmd' => '_cart',

    // Signify we're passing in a shopping cart from our system.
    'upload' => 1,

    // The store's PayPoint e-mail address
    'business' => $settings['business'],

    // The path PayPoint should send the PayCash to
    'notify_url' => commerce_paypoint_paycash_url($settings['payment_method']),

    // The application generating the API request
    'bn' => 'CommerceGuys_Cart_PPS',

    // Set the correct character set
    'charset' => 'utf-8',

    // Do not display a comments prompt at PayPoint
    'no_note' => 1,

    // Do not display a shipping address prompt at PayPoint
    'no_shipping' => 1,

    // Return to the review page when payment is canceled
    'cancel_return' => $settings['cancel_return'],

    // Return to the payment redirect page for processing successful payments
    'return' => $settings['return'],

    // Return to this site with payment data in the POST
    'rm' => 2,

    // The type of payment action PayPoint should take with this order
    'paymentaction' => $settings['payment_action'],

    // Set the currency and language codes
    'currency_code' => $currency_code,
    'lc' => $settings['language'],

    // Use the timestamp to generate a unique invoice number
    'invoice' => commerce_paypoint_paycash_invoice($order),

    // Define a single item in the cart representing the whole order
    'amount_1' => commerce_paypoint_price_amount(commerce_currency_convert($amount, $order_currency_code, $currency_code), $currency_code),
    'item_name_1' => t('Order @order_number at @store', array('@order_number' => $order->order_number, '@store' => variable_get('site_name', url('<front>', array('absolute' => TRUE))))),
    'on0_1' => t('Product count'),
    'os0_1' => commerce_line_items_quantity($wrapper->commerce_line_items, commerce_product_line_item_types()),
  );

  // Allow modules to alter parameters of the API request.
  drupal_alter('commerce_paypoint_advanced_order_form_data', $data, $order);

  $form['#action'] = commerce_paypoint_advanced_server_url($settings['server']);

  foreach ($data as $name => $value) {
    if (!empty($value)) {
      $form[$name] = array('#type' => 'hidden', '#value' => $value);
    }
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Proceed to PayPoint'),
  );

  return $form;
}
*/

/**
 * Returns the URL to the specified PayPoint server.
 *
 * @param $server
 *   Either Sandbox (MITE) or LIVE indicating which server to get the URL for.
 * @param $request_type
 *   Either as a Hosted solution, or via an API.
 *
 * @return
 *   The URL to use to submit requests to the PayPoint server.
 */
function commerce_paypoint_advanced_server_url($mode = COMMERCE_PAYPOINT_TEST_MODE_TEST, $hosted = TRUE) {
  switch ($mode) {
    case COMMERCE_PAYPOINT_TEST_MODE_TEST:
      return $hosted ? PAYPOINT_ADV_MITE_HOSTED_ENDPOINT : PAYPOINT_ADV_MITE_API_ENDPOINT;
    case COMMERCE_PAYPOINT_TEST_MODE_LIVE:
      return $hosted ? PAYPOINT_ADV_LIVE_HOSTED_ENDPOINT : PAYPOINT_ADV_LIVE_API_ENDPOINT;
  }
}

/**
 * Returns an array of all possible Direct Payment currency codes.
 */
function commerce_paypoint_advanced_currencies() {
  return drupal_map_assoc(array('GBP')); // Only GBP is supported today.
}

/**
 * Returns an array of all possible card schemes.
 */
function commerce_paypoint_advanced_card_schemes() {
  return drupal_map_assoc(array('VISA', 'MASTERCARD', 'AMEX', 'JCB', 'LASER', 'DISCOVER', 'DINERS'));
}

/**
 * Topic index callback.
 */
function commerce_paypoint_advanced_index_page() {
  $output = theme('advanced_help_topic', array(
    'module' => 'commerce_paypoint_advanced',
    'topic' => 'commerce-paypoint-advanced',
  ));
  $output .= '&nbsp;' . t("Click the help icon to view docs about the PayPoint.net's Advanced Payments.");
  return $output;
}

/**
 * Initialize the PayPoint payment based on the provided order.
 *
 * @param $order
 *   Existing order to based on. If not specified, use the existing user's cart order.
 * @param $settings
 *   Payment settings (same as: $payment_method['settings'])
 *
 * @return
 *   Return PayPoint payment class.
 */
function commerce_paypoint_advanced_init_payment($order = NULL, $settings = array(), $iframe = FALSE) {

  if (!$order) {
    global $user;
    if (!$order = commerce_cart_order_load($user->uid)) {
      return FALSE;
    }
  }

  if (!$settings) {
    // Load default settings of the payment method instance if present. See: /admin/commerce/config/payment-methods
    $payment_instance = commerce_payment_method_instance_load('paypoint_advanced|commerce_payment_paypoint_advanced');
    $settings = $payment_instance['settings'];
  }

  // Wrap the order for easier access to data.
  $wrapper = entity_metadata_wrapper('commerce_order', $order);

  $total = commerce_line_items_total($wrapper->commerce_line_items);
  $total['amount'] = sprintf('%.2f', $wrapper->commerce_order_total->amount->value() / 100);
  $total['currency_code'] = $total['currency_code'] ?: 'GBP';

  $telephone = '';
  $ip_address = ip_address();
  $email = user_load($order->uid)->mail;

  module_load_include('inc', 'commerce_paypoint_advanced', 'commerce_paypoint_advanced.class');

  $hosted = (@$settings['connectivity']['request_type'] == 'hosted') ?: TRUE;
  $url = commerce_paypoint_advanced_server_url($settings['testing']['test_status']);
  $auth = $settings['merchant'];

  $ppo = new PPOAdvancedPayment($url, $auth['username'], $auth['password'], $auth['instId'], $hosted);
  if (!$ppo->sendPing()) {
    return FALSE;
  }

  if (module_exists('commerce_customer')) {
    // Load customer profile.
    $profile = commerce_customer_profile_load($order->commerce_customer_billing[LANGUAGE_NONE][0]['profile_id']);

    // Get user billing address.
    $billing_address = $profile->commerce_customer_address[LANGUAGE_NONE][0];

    // Get user delivery address.
    $delivery_address = NULL;

    if (isset($order->commerce_customer_shipping)) {
      $delivery_profile = commerce_customer_profile_load($order->commerce_customer_shipping[LANGUAGE_NONE][0]['profile_id']);
      $delivery_address = $delivery_profile->commerce_customer_address[LANGUAGE_NONE][0];
    }

    $address = array(
      'line1'         => $billing_address['thoroughfare'],
      'line2'         => $billing_address['premise'],
      'line3'         => $billing_address['sub_premise'],
      'line4'         => $billing_address['organisation_name'],
      'city'          => $billing_address['locality'],
      'region'        => $billing_address['administrative_area'],
      'postcode'      => $billing_address['postal_code'],
      'countryCode'   => $billing_address['country'] ?: "GB",
    );
    $ppo->setCustomerDetails($billing_address['name_line'], $address, $telephone, $email, $ip_address);
  }

  // Initialize and send the PayPoint request.
  // @fixme: payment_redirect_key is empty.
  if ($iframe) {
    $returnUrl = $abortUrl = url("commerce_paypoint/payment_result", array('absolute' => TRUE));
  } else {
    $returnUrl = url('checkout/' . $order->order_id . '/payment/return/' . $order->data['payment_redirect_key'], array('absolute' => TRUE));
    $notifyUrl = url('commerce_paypoint/notify-callback', array('absolute' => TRUE));
  }
  !$abortUrl  ?: $ppo->setSessionRestoreUrl($abortUrl);
  !$returnUrl ?: $ppo->setSessionReturnUrl($returnUrl);
  !$notifyUrl ?: $ppo->setSessionNotificationUrl($notifyUrl);
  !$postAuthCallbackUrl ?: $ppo->setSessionPostAuthCallbackUrl($postAuthCallback); // @todo

  $ppo->setCustomerMerchantId($order->uid);
  $ppo->setTransactionMoneyFixed($total['amount'], $total['currency_code']);
  // $ppo->setTransactionMerchantReference('your_reference_here'); // @todo
  $response = array();
  try {
    // Call PayPoint to get payment form that can then be included in an iFrame.
    $response = $ppo->sendProcessPayment();
  }
  catch (Exception $e) {
    watchdog_exception('commerce_paypoint_advanced', $e);
    watchdog('commerce_paypoint_advanced', 'PayPoint error response:\n<br>%data', array('%data' => print_r($ppo->getLastResponse(), TRUE)), WATCHDOG_ERROR);
    return FALSE;
  }

  if ($settings['connectivity']['debug'] || variable_get('commerce_paypoint_debug', FALSE)) {
    watchdog('commerce_paypoint_advanced', 'PayPoint response:\n<br>%data', array('%data' => print_r($response, TRUE)), WATCHDOG_DEBUG);
    function_exists('dpm') && user_access('administer site configuration') && dpm($response);
  }

  return $ppo;
}

/**
 * Implements iFrame form.
 *
 * @param $form: Nested array of form elements that comprise the form.
 * @param $form_state: A keyed array containing the current state of the form.
 * @param $iframe_src string
 *   The default URL of the iframe. Can be used to set endpoint directly, bypassing the redirection.
 * @param $redirectUrl string
 *   The URL used in submit form to direct your customer to to start the hosted session. Leave empty to not perform any redirection.
 * @param $options array
 *   Not implemented yet. But may be used for some specific iframe options.
 *
 * @return
 *   A keyed array containing the generated iframe form.
 */
function commerce_paypoint_advanced_iframe_form($form, &$form_state, $iframe_src = 'commerce_paypoint/paypoint_waiting_page', $redirectUrl = '', $options = array()) {

  if ($redirectUrl) {
    // Generate submit form only if $redirectUrl is specified.
    $form['#action'] = $redirectUrl;
    $form['#method'] = 'GET';
    $form['#attributes']['target'] = 'iframe_paypoint';

    $form['submit'] = array(
      '#type'  => 'submit',
      '#value' => t('Proceed to PayPoint'),
    );
  }
  $iframe_src = !filter_var($iframe_src, FILTER_VALIDATE_URL) ? url($iframe_src) : $iframe_src;
  $form['iframe_paypoint'] = array(
    '#markup' => '<iframe style="width: 600px; height:500px" scrolling="no" frameborder="0" name="iframe_paypoint" id="iframe_paypoint" src="' . $iframe_src . '"></iframe>',
  );
  return $form;
}
