<?php

define('VIRTUAL_ROLES_NO_ROLES', 'EMPTY');
define('VIRTUAL_ROLES_SANITY_CHECK', "<?php\nglobal \$user;\nif (!empty(\$user->roles[DRUPAL_ANONYMOUS_RID])) {\n  return TRUE;\n}\n?>");
define('VIRTUAL_ROLES_DISABLE_DEFAULT', 1);
define('VIRTUAL_ROLES_REMOVE_DEFAULT', 0);
define('VIRTUAL_ROLES_ACTION_TYPE_DEFAULT', 'add');
define('VIRTUAL_ROLES_APPLICATION_DEFAULT', 'path');
define('VIRTUAL_ROLES_PAGES_DEFAULT', '');
define('VIRTUAL_ROLES_WEIGHT_DEFAULT', 0);
define('VIRTUAL_ROLES_CACHE', FALSE);

/**
 * Implements hook_menu().
 */
function virtual_roles_menu() {

  $items = array();

  $items['admin/people/virtual_roles_settings'] = array(
    'title' => 'Virtual Roles Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('virtual_roles_settings_form'),
    'access arguments' => array('administer virtual role'),
    'type' => MENU_LOCAL_TASK,
  );

  foreach (user_roles() as $rid => $rname) {
    $items['admin/people/virtual_roles_settings/' . $rid] = array(
      'title' => $rname,
      'page callback' => 'drupal_get_form',
      'page arguments' => array('virtual_roles_role_settings', 3),
      'access arguments' => array('administer virtual role'),
      'type' => MENU_LOCAL_TASK,
    );
  }

  return $items;
}

/**
 * Implements hook_permission().
 */
function virtual_roles_permission() {
  return array(
    'administer virtual role' => array(
      'title' => t('Administer Virtual Roles'),
      'description' => t('Change the settings for how Virtual Roles are applied'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Create the Virtual Role module settings form.
 */
function virtual_roles_settings_form($form_state) {
  $form = array();

  $form['#tree'] = TRUE;

  $form['settings'] = array(
    '#type' => 'fieldset',
    '#title' => t('Settings'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );

  $form['settings']['virtual_roles_cache_expire'] = array(
    '#type' => 'textfield',
    '#title' => t('Cache lifetime (in minutes)'),
    '#default_value' => variable_get('virtual_roles_cache_expire', '10'),
    '#description' => t('Use this option to control how long the cached variables are kept in the system. Time is entered in minutes. If left blank, then the a users cache will not automatically be cleared. The default value is 10.'),
  );

  $form['settings']['virtual_roles_cache_method'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Cache method'),
    '#default_value' => variable_get('virtual_roles_cache_method', array('session')),
    '#options' => array(
      'session' => t('Use session caching'),
      'database' => t('Use database caching'),
    ),
    '#description' => t('Choose which method of caching best suits your site. Session variables are fast and do not require additional database queries, but they could reduce performance if the session variable grows to be too large. Session variables are automatically discarded when the user logs out.  Database variables, on the other hand, can last across multiple sessions, but they require that additional queries be run on every page load. You may choose to use either caching method separately, or use both at the same time. If neither method is enabled, then caching will be disabled.'),
  );
  $form['settings']['virtual_roles_cache_length'] = array(
    '#type' => 'textfield',
    '#title' => t('Session cache variable length'),
    '#default_value' => variable_get('virtual_roles_cache_length', 50),
    '#description' => t('Enter the number of variables that should be stored in the user\'s Session variable.  The default value is 50.'),
  );
  $form['settings']['virtual_roles_skip_processing'] = array(
    '#type' => 'textarea',
    '#title' => t('Sanity Check (i.e., should we skip the processing?)'),
    '#default_value' => variable_get('virtual_roles_skip_processing', VIRTUAL_ROLES_SANITY_CHECK),
    '#description' => t("If the PHP code entered into this box returns <code>TRUE</code>, then no further processing will be done. This is intended to be used as a quick test to avoid potentially unnecessary database calls. If not used wisely, this module could cripple your site's performance. The default code will make it so that Anonymous Users are not processed.  Most modules have not yet been loaded, so you are basically limited to the functions in <code>bootstrap.inc</code>, <code>common.inc</code> and <code>path.inc</code>, as well as the user object. Generally speaking, you should not do any SQL queries in this code. Wrap your code in the correct PHP tags. Invalid code <em>will</em> break your site."),
  );

  $form['role'] = array(
    '#type' => 'fieldset',
    '#title' => t('Role processing order'),
    '#description' => t('You can control the order in which roles are processed by dragging the individual roles into the order in which you would like for them to be processed. If javascript is disabled, you can still adjust the order by changing the weight of the individual roles.'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );

  $form['role']['table'] = array(
    '#tree' => TRUE,
    '#theme' => 'virtual_roles_settings_table',
  );

  $roles = _virtual_roles_roles();
  $master_array = variable_get('virtual_roles_master_array', array());
  $weights = array();

  // figure out the weights
  foreach ($roles as $rid => $role) {
    if (empty($master_array[$rid])) {
      $master_array[$rid] = _virtual_roles_role_defaults();
    }
    $weights[$rid] = !empty($master_array[$rid]['weight']) ? $master_array[$rid]['weight'] : VIRTUAL_ROLES_WEIGHT_DEFAULT;
  }
  uasort($weights, '_virtual_roles_cmp');

  foreach ($weights as $rid => $weight) {
    $form['role']['table'][$rid]['role'] = array(
      '#markup' => $roles[$rid],
    );
    $form['role']['table'][$rid]['weight'] = array(
      '#type' => 'weight',
      '#default_value' => $weight,
      '#delta' => 50,
      '#attributes' => array(
        'class' => array('role-weight'),
      ),
    );
    $form['role']['table'][$rid]['disable'] = array(
      '#type' => 'checkbox',
      '#title' => t('Disable'),
      '#default_value' => $master_array[$rid]['disable'],
    );
    $form['role']['table'][$rid]['remove'] = array(
      '#type' => 'checkbox',
      '#title' => t('Remove'),
      '#default_value' => $master_array[$rid]['remove'],
    );
  }

  $form ['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save settings'),
    '#submit' => array('virtual_roles_settings_form_submit_save'),
  );

  $form ['reset'] = array(
    '#type' => 'submit',
    '#value' => t('Reset'),
    '#submit' => array('virtual_roles_settings_form_submit_reset'),
  );

  return $form;
}

function virtual_roles_settings_form_validate($form, &$form_state) {
  $expire = $form_state['values']['settings']['virtual_roles_cache_expire'];
  if ((!empty($expire) && !is_numeric($expire)) || $expire === '0') {
    form_set_error('settings][virtual_roles_cache_expire', t('Cache lifetime must either be left blank or set to a valid number of minutes.'));
  }
  $length = $form_state['values']['settings']['virtual_roles_cache_length'];
  if (!is_numeric($length)) {
    form_set_error('settings][virtual_roles_cache_length', t('Session cache variable length must be set to a valid number.'));
  }
}

function virtual_roles_default_weight() {
  $roles = _virutal_role_roles();
  foreach ($roles as $rid => $val) {
    $roles[$rid] = 0;
  }
  return $roles;
}

function virtual_roles_settings_form_submit_save($form, &$form_state) {
  $settings = $form_state['values']['settings'];
  variable_set('virtual_roles_skip_processing', $settings['virtual_roles_skip_processing']);
  variable_set('virtual_roles_cache_expire', $settings['virtual_roles_cache_expire']);
  variable_set('virtual_roles_cache_method', $settings['virtual_roles_cache_method']);
  variable_set('virtual_roles_cache_length', $settings['virtual_roles_cache_length']);
  $master_array = variable_get('virtual_roles_master_array', array());
  foreach ($form_state['values']['role']['table'] as $rid => $role) {
    if (empty($master_array[$rid])) {
      $master_array[$rid] = _virtual_roles_role_defaults();
    }
    $master_array[$rid]['weight'] = $role['weight'];
    $master_array[$rid]['disable'] = $role['disable'];
    $master_array[$rid]['remove'] = $role['remove'];
  }
  variable_set('virtual_roles_master_array', $master_array);
}

function virtual_roles_settings_form_submit_reset($form, &$form_state) {
  variable_del('virtual_roles_skip_processing');
  variable_del('virtual_roles_cache_expire');
  variable_del('virtual_roles_cache_method');
  variable_del('virtual_roles_cache_length');
  $master_array = variable_get('virtual_roles_master_array', array());
  if (!empty($master_array)) {
    foreach ($master_array as $rid => $role) {
      if (!empty($master_array[$rid])) {
        $master_array[$rid]['remove'] = VIRTUAL_ROLES_REMOVE_DEFAULT;
        $master_array[$rid]['disable'] = VIRTUAL_ROLES_DISABLE_DEFAULT;
        $master_array[$rid]['weight'] = VIRTUAL_ROLES_WEIGHT_DEFAULT;
      }
    }
    variable_set('virtual_roles_master_array', $master_array);
  }
}

function theme_virtual_roles_settings_table($variables) {
  $element = &$variables['element'];
  drupal_add_tabledrag('virtual_roles_roles', 'order', 'sibling', 'role-weight');
  $header = array(
    'role' => t('Role'),
    'weight' => t('Weight'),
    'disable' => t('Do not process'),
    'remove' => t('Remove from user edit form'),
  );
  $rows = array();
  foreach (element_children($element) as $key) {
    $row = array();
    $row['data'] = array();
    foreach($header as $fieldname => $title) {
      if (isset($element[$key][$fieldname]['#title'])) {
        unset ($element[$key][$fieldname]['#title']);
      }
    $row['data'][] = drupal_render($element[$key][$fieldname]);
    $row['class'] = array('draggable');    }
    $rows[] = $row;
  }
  return theme('table', array(
    'header' => $header,
    'rows' => $rows,
    'attributes' => array('id' => 'virtual_roles_roles'),
  ));
}

/**
 * Form creation for admin/people/virtual_roles_settings/%
 */
function virtual_roles_role_settings($form, &$form_state, $rid) {
  $form = array();

  $edit = virtual_roles_get($rid);

  $form['rid'] = array(
    '#type' => 'value',
    '#value' => $rid,
  );

  $form['disable'] = array(
    '#type' => 'checkbox',
    '#title' => t('Do not try to evaluate for this role'),
    '#default_value' => $edit['disable'],
    '#description' => t("This option will remove this role from the processing queue."),
  );

  $form['remove'] = array(
    '#type' => 'checkbox',
    '#title' => t('Remove from the user edit page'),
    '#default_value' => $edit['remove'],
    '#description' => t("Selecting this option will remove the role from the user edit page."),
  );

  $form['context'] = array(
    '#type' => 'fieldset',
    '#title' => t('Context'),
    '#description' => t('Choose which contexts you would like to check for in determining whether or not to apply this role.'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );

  $contexts = virtual_roles_get_contexts();

  if (!empty($contexts)) {
    $options = array();
    foreach ($contexts as $test => $data) {
      $options[$test] = $data['title'];
    }
    $form['context']['contexts'] = array(
      '#type' => 'checkboxes',
      '#title' => '',
      '#options' => $options,
      '#default_value' => $edit['contexts'],
    );
  }

  $options = array(
    'add' => t('Add the role.'),
    'remove' => t('Remove the role.'),
    'toggle' => t('Toggle the role.'),
  );
  $description = t('Choose how you would like the role to be applied to the user account.');
  $form['action_type'] = array(
    '#type' => 'radios',
    '#title' => t('Action to apply'),
    '#options' => $options,
    '#default_value' => $edit['action_type'],
  );

  $options = array(
    'path' => t('Evaluate as paths.'),
    'php' => t('Evaluate as PHP code. Must return <code>TRUE</code> to activate (PHP-mode, experts only).'),
  );
  $description = t("Enter one page per line as Drupal paths. The '*' character is a wildcard. Example paths are %blog for the blog page and %blog-wildcard for every personal blog. %front is the front page.", array('%blog' => 'blog', '%blog-wildcard' => 'blog/*', '%front' => '<front>'));
  $description .= ' ' . t('If the PHP-mode is chosen, enter PHP code between %php. Note that executing incorrect PHP-code can break your Drupal site.', array('%php' => '<?php ?>'));
  $form['application'] = array(
    '#type' => 'radios',
    '#title' => t('When to apply the role'),
    '#options' => $options,
    '#default_value' => $edit['application'],
  );
  $form['pages'] = array(
    '#type' => 'textarea',
    '#title' => t('Pages'),
    '#default_value' => $edit['pages'],
    '#description' => $description,
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save settings'),
  );
  
  return $form;
}

function virtual_roles_role_settings_validate($form, &$form_state) {
}

function virtual_roles_role_settings_submit($form, &$form_state) {
  $rid = $form_state['values']['rid'];
  if (isset($rid) && !form_get_errors()) {
    $settings = array();
    $parts = array('disable', 'remove', 'contexts', 'action_type', 'application', 'pages');
    foreach ($parts as $p) {
      $settings[$p] = $form_state['values'][$p];
    }
    virtual_roles_set($rid, $settings);
    drupal_set_message(t('Your settings have been saved. You may need to flush your cache in order for changes to take effect.'));
  }
}

/**
 * Helper function to load the settings for an array.
 */
function virtual_roles_get($rid = NULL) {
  $master_array = variable_get('virtual_roles_master_array', array());
  if ($rid === NULL) {
    return $master_array;
  }
  if (isset($master_array[$rid])) {
    return $master_array[$rid];
  }
  else {
    return _virtual_roles_role_defaults();
  }
}

/**
 * Helper function to save the settings for a particular rid.
 */
function virtual_roles_set($rid, $settings) {
  $master_array = virtual_roles_get();
  $master_array[$rid] = $settings;
  variable_set('virtual_roles_master_array', $master_array);
}

/**
 * Implements hook_boot().
 */
function virtual_roles_boot() {
  // This hook happens *early* in the bootstrap, before modules are loaded, etc.
  // Consequently, many of the needed functions haven't been loaded yet, either.
  // Including them here won't make a big difference in performance.
  require_once DRUPAL_ROOT . '/includes/path.inc';
  require_once DRUPAL_ROOT . '/includes/common.inc';
  drupal_language_initialize();
  drupal_path_initialize();

  // Sanity check: Should we abandon ship?
  if (virtual_roles_sanity_check()) {
    return;
  }

  global $user;

  $user->roles = virtual_roles_get_roles($user);
}

/**
 * Helper function to make sure we are analyzing the correct user.
 */
function virtual_role_test_user($user = NULL) {
  static $account = NULL;
  if (!is_null($user)) {
    $account = $user;
  }
  return $account;
}

/**
 * Helper function that stores the original state of the user's roles
 */
function virtual_roles_initial_user_roles($user) {
  static $original_state = array();
  if (isset($original_state[$user->uid])) {
    return $original_state[$user->uid];
  }
  $original_state[$user->uid] = $user->roles;
  return $original_state[$user->uid];
}

/**
 * Helper function to load a user's roles
 */
function virtual_roles_get_roles($user) {
  static $users = array();

  // make sure that the initial state of the user's roles has been saved
  virtual_roles_initial_user_roles($user);

  if (isset($users[$user->uid])) {
    return $users[$user->uid];
  }

  // clear the cache if necessary
  $last_cleared = virtual_roles_cache_get($user->uid, 'cache_cleared', 'cache');
  if (empty($last_cleared)) {
    $last_cleared = REQUEST_TIME;
    virtual_roles_cache_set($user->uid, 'cache_cleared', $last_cleared, 'cache');
  }
  $expire = variable_get('virtual_roles_cache_expire', 10);
  $global_cache_clear = variable_get('virtual_roles_cache_cleared', 0);
  if ((!empty($expire) && (REQUEST_TIME - $last_cleared) > ($expire * 60))
    || ($global_cache_clear > $last_cleared)) {
    virtual_roles_clear_cache($user->uid);
  }

  // try to pull the roles from cache
  $roles = virtual_roles_cache_get($user->uid, $_GET['q'], 'path');
  if (!is_null($roles)) {
    $users[$user->uid] = $roles;
    return $users[$user->uid];
  }

  $temp_roles = $user->roles;
  $master_array = variable_get('virtual_roles_master_array', array());
  $contexts = variable_get('virtual_roles_contexts', array());
  if (!empty($master_array)) {
    $role_list = _virtual_roles_roles();
    foreach ($master_array as $rid => $val) {
      if (!empty($val) && !$val['disable']) {
        $match = FALSE;
        if (!empty($val['contexts'])) {
          foreach ($val['contexts'] as $test) {
            if (!empty($contexts[$test])) {
              $match = virtual_roles_test($test, $user);
              if ($match) {
                break;
              }
            }
          }
        }
        if (!$match && $val['application'] == 0) {
          // Match to a path.
          // Code modeled after block_list().
          $path = drupal_get_path_alias($_GET['q']);
          // Compare with the internal and path alias (if any).
          $match = drupal_match_path($path, $val['pages']);
          if ($path != $_GET['q']) {
            $match = $match || drupal_match_path($_GET['q'], $val['pages']);
          }
        }
        elseif (!$match && $val['application'] == 'php') {
          // PHP code.
          virtual_role_test_user($user);
          $match = virtual_roles_php_eval($val['pages']);
        }
        // Now apply the action.
        if ($match) {
          switch ($val['action_type']) {
            case 'add':
              // Add the role.
              if (isset($role_list[$rid])) {
                $temp_roles[$rid] = $role_list[$rid];
              }
              break;
            case 'remove':
              // Remove the role.
              unset($temp_roles[$rid]);
              break;
            case 'toggle':
              // Toggle the role.
              if (isset($temp_roles[$rid])) {
                unset($temp_roles[$rid]);
              }
              else {
                if (isset($role_list[$rid])) {
                  $temp_roles[$rid] = $role_list[$rid];
                }
              }
              break;
          }
        }
      }
    }
  }
  virtual_roles_cache_set($user->uid, $_GET['q'], $temp_roles, 'path');
  $users[$user->uid] = $temp_roles;
  return $users[$user->uid];
}

/**
 * Implements hook_user_load().
 */
function virtual_roles_user_load($users) {
  global $user;
  foreach ($users as $uid => $account) {
    // Only attempt to process virtual roles for the logged-in user.
    if ($user->uid == $account->uid) {
      $users[$uid]->roles = virtual_roles_get_roles($account);
    }
  }
}

/**
 * Implements hook_user_presave().
 */
function virtual_roles_user_presave(&$edit, $account, $category) {
  if (!virtual_roles_sanity_check()) {
    // Reset the roles to the original state so that Virtual Roles aren't
    // accidentally saved to the user account.
    $account->roles = virtual_roles_initial_user_roles($account);
  }
}

/**
 * Implements hook_user_logout().
 */
function virtual_roles_user_logout($account) {
  virtual_roles_clear_cache($account->uid);
}

/**
 * Implements hook_theme().
 */
function virtual_roles_theme($existing, $type, $theme, $path) {
  return array(
    'virtual_roles_settings_table' => array(
      'render element' => 'element',
    ),
  );
}

/**
 * STOLEN FROM user_roles() in user.module
 * user.module is not loaded yet, so we need to create this function on our own.
 *
 * Retrieve an array of roles matching specified conditions.
 *
 * @param $membersonly
 *   Set this to TRUE to exclude the 'anonymous' role.
 * @param $permission
 *   A string containing a permission. If set, only roles containing that
 *   permission are returned.
 *
 * @return
 *   An associative array with the role id as the key and the role name as
 *   value.
 */
function _virtual_roles_roles($membersonly = FALSE, $permission = NULL) {
  $query = db_select('role', 'r');
  $query->addTag('translatable');
  $query->fields('r', array('rid', 'name'));
  $query->orderBy('weight');
  $query->orderBy('name');
  if (!empty($permission)) {
    $query->innerJoin('role_permission', 'p', 'r.rid = p.rid');
    $query->condition('p.permission', $permission);
  }
  $result = $query->execute();

  $roles = array();
  foreach ($result as $role) {
    switch ($role->rid) {
      // We only translate the built in role names
      case DRUPAL_ANONYMOUS_RID:
        if (!$membersonly) {
          $roles[$role->rid] = t($role->name);
        }
        break;
      case DRUPAL_AUTHENTICATED_RID:
        $roles[$role->rid] = t($role->name);
        break;
      default:
        $roles[$role->rid] = $role->name;
    }
  }

  return $roles;
}

/**
 * Implements hook_form_alter().
 */
function virtual_roles_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'user_profile_form') {
    $hidden = _virtual_roles_get_hidden_rids();
    if (!empty($form['account']['roles']['#options'])) {
      foreach ($form['account']['roles']['#options'] as $rid => $role) {
        if (in_array($rid, $hidden)) {
          unset($form['account']['roles']['#options'][$rid]);
        }
      }
    }
  }
  elseif ($form_id == 'user_admin_new_role' || $form_id == 'user_admin_role') {
    $form['#submit'][] = 'virtual_roles_clear_menu_cache';
  }
}

/**
 * Helper function to clear the menu cache.
 */
function virtual_roles_clear_menu_cache() {
  module_invoke('menu', 'rebuild');
}

/**
 * Helper function for virtual_roles_form_alter().
 */
function _virtual_roles_get_hidden_rids() {
  $master_array = variable_get('virtual_roles_master_array', array());
  $remove = array();
  if (!empty($master_array)) {
    foreach ($master_array as $rid => $data) {
      if (!empty($data['remove'])) {
        $remove[] = $rid;
      }
    }
  }
  return $remove;
}

/**
 * Helper function to return an array of default settings for a role.
 */
function _virtual_roles_role_defaults() {
  return array(
    'disable' => VIRTUAL_ROLES_DISABLE_DEFAULT,
    'remove' => VIRTUAL_ROLES_REMOVE_DEFAULT,
    'action_type' => VIRTUAL_ROLES_ACTION_TYPE_DEFAULT,
    'application' => VIRTUAL_ROLES_APPLICATION_DEFAULT,
    'pages' => VIRTUAL_ROLES_PAGES_DEFAULT,
    'contexts' => array(),
    'weight' => VIRTUAL_ROLES_WEIGHT_DEFAULT,
  );
}

/**
 * Helper function to sort an array by value ascending, key ascending.
 */
function _virtual_roles_cmp($var1, $var2) {
  return $var1 >= $var2 ? 1 : -1;
}

/**
 * Returns a keyed array of contexts that can be used for testing whether or not
 * to apply a user role. The variable virtual_roles_contexts is set fresh every
 * time in order to assure that the most recent information will be available
 * during the hook_boot() instance.
 */
function virtual_roles_get_contexts() {
  static $contexts = NULL;
  if (!is_null($contexts)) {
    return $contexts;
  }
  $contexts = array();
  require_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'virtual_roles') . '/includes/core.inc';
  foreach (module_implements('virtual_roles') as $module) {
    $function = $module . '_virtual_roles';
    $temp = $function();
    if (!empty($temp)) {
      foreach ($temp as $test_name => $data) {
        if (empty($data['path'])) {
          $temp[$test_name]['path'] = drupal_get_path('module', $module);
        }
      }
    }
    if (!empty($temp)) {
      $contexts = array_merge($contexts, $temp);
    }
  }
  variable_set('virtual_roles_contexts', $contexts);
  return $contexts;
}

/**
 * This is the function that does all the work of making sure the proper include
 * files are loaded and making sure that vaules are properly pulled and saved to
 * cache.
 * If the $user variable is not set, then it will load the $user object from a
 * helper function. This makes it easy to call virtual_roles_test() in evaluated
 * php code.
 */
function virtual_roles_test($test, $user = NULL) {
  static $tests = array();

  if (is_null($user)) {
    // set the $user object to the default $user if no user was specified
    $user = virtual_roles_test_user();
  }

  $contexts = variable_get('virtual_roles_contexts', array());
  if (!empty($contexts[$test])) {
    $context = $contexts[$test];
    if (file_exists(DRUPAL_ROOT . '/' . $context['path'] . '/' . $context['file'])) {
      require_once DRUPAL_ROOT . '/' . $context['path'] . '/' . $context['file'];
    }
    $function = $context['callback'];
    if (function_exists($function)) {
      $cache_id = $function('cache', $user);
      if (is_null($cache_id)) {
        // The test does not apply to this page.
        return FALSE;
      }
      if ($cache_id !== FALSE) {
        // We have been supplied with a cache_id.
        if (isset($tests[$cache_id])) {
          return $tests[$cache_id];
        }
        $result = virtual_roles_cache_get($user->uid, $cache_id, 'test');
        if (!is_null($result)) {
          $tests[$cache_id] = $result;
          return $tests[$cache_id];
        }
      }
      $result = $function('process', $user);
      if ($cache_id) {
        virtual_roles_cache_set($user->uid, $cache_id, $result, 'test');
      }
      $tests[$cache_id] = $result;
    }
    return $tests[$cache_id];
  }

  return FALSE;
}

/**
 * Helper function to return the logged in user.
 *
 * @global
 *   $user is the logged in user
 * @return
 *   returns the logged in user
 */
function virtual_roles_test_user() {
  global $user;
  return $user;
}

/**
 * Implements hook_flush_caches().
 */
function virtual_roles_flush_caches() {
  // signal that user's sessions should be erased
  variable_set('virtual_roles_cache_cleared', REQUEST_TIME);
  return array();
}

/**
 * Helper function for clearing the cache data.
 */
function virtual_roles_clear_cache($uid) {
  if ($uid == 'all') {
    variable_set('virtual_roles_cache_cleared', REQUEST_TIME);
    cache_clear_all('vr:', 'cache', TRUE);
  }
  elseif (is_numeric($uid)) {
    cache_clear_all("vr:$uid:", 'cache', TRUE);
    if (isset($_SESSION['virtual_roles'])) {
      unset($_SESSION['virtual_roles']);
    }
    virtual_roles_cache_set($uid, 'cache_cleared', REQUEST_TIME, 'cache');
  }
}

/**
 * Helper function for setting a variable using the chosen cache method
 */
function virtual_roles_cache_set($uid, $cache_id, $data, $type = 'variable') {
  static $use_session, $use_database;
  if (virtual_roles_sanity_check()) {
    // the sanity check is telling us not to process anything
    return NULL;
  }
  if (!isset($use_session)) {
    $cache_method = variable_get('virtual_roles_cache_method', array('session'));
    $use_session = !empty($cache_method['session']);
    $use_database = !empty($cache_method['database']);
  }
  if ($use_database) {
    cache_set("vr:$uid:$type:$cache_id", $data, 'cache', CACHE_TEMPORARY);
  }
  if ($use_session) {
    if (isset($_SESSION['virtual_roles'][$uid][$type]) && count($_SESSION['virtual_roles'][$uid][$type]) >= variable_get('virtual_roles_cache_length', 50)) {
      // Prune the least used (first) element from the array.
      // We do this to keep the array being stored in the $_SESSION variable from 
      // being too large.
      array_shift($_SESSION['virtual_roles'][$uid][$type]);
    }
    $_SESSION['virtual_roles'][$uid][$type][$cache_id] = $data;
  }
}

/**
 * Helper function for retrieving a variable using the chosen cache method
 */
function virtual_roles_cache_get($uid, $cache_id, $type = 'variable') {
  static $use_session, $use_database;
  if (virtual_roles_sanity_check()) {
    // the sanity check is telling us not to process anything
    return NULL;
  }
  if (!isset($use_session)) {
    $cache_method = variable_get('virtual_roles_cache_method', array('session'));
    $use_session = !empty($cache_method['session']);
    $use_database = !empty($cache_method['database']);
  }
  if ($use_session) {
    if (isset($_SESSION['virtual_roles'][$uid][$type][$cache_id])) {
      // Move this element to the end of the array since it is the most recently
      // used.  This way, we can keep the $_SESSION variable to a managable size.
      $temp = $_SESSION['virtual_roles'][$uid][$type][$cache_id];
      unset($_SESSION['virtual_roles'][$uid][$type][$cache_id]);
      $_SESSION['virtual_roles'][$uid][$type][$cache_id] = $temp;
      return $_SESSION['virtual_roles'][$uid][$type][$cache_id];
    }
  }
  if ($use_database) {
    if ($cache = cache_get("vr:$uid:$type:$cache_id")) {
      if ($use_session) {
        if (isset($_SESSION['virtual_roles'][$uid][$type]) && count($_SESSION['virtual_roles'][$uid][$type]) >= variable_get('virtual_roles_cache_length', 50)) {
          // See comments in virtual_roles_cache_set() for explanation.
          array_shift($_SESSION['virtual_roles'][$uid][$type]);
        }
        $_SESSION['virtual_roles'][$uid][$type][$cache_id] = $cache->data;
      }
      return $cache->data;
    }
  }

  // there is nothing in cache
  return NULL;
}

/**
 * Helper function that stores the sanity check of whether or not Virtual Roles
 * should process the users
 */
function virtual_roles_sanity_check() {
  static $sanity_check;
  if (isset($sanity_check)) {
    return $sanity_check;
  }
  $sanity_check = virtual_roles_php_eval(variable_get('virtual_roles_skip_processing', VIRTUAL_ROLES_SANITY_CHECK));
  return $sanity_check;
}

/**
 * Function to evaluate PHP code.
 * Drupal 7 suggests using the php_eval() function from the optional PHP
 * module, however this module may or may not be available to us at the time
 * that the PHP needs to be evaluated, so we will use our own function.
 */
function virtual_roles_php_eval($code) {
  ob_start();
  print eval('?>' . $code);
  $output = ob_get_contents();
  ob_end_clean();
  return $output;
}
