<?php
/**
 * @file
 *   Features to git module functions.
 *
 *   Loosely based on features_direct_save module.
 */

/**
 * Git command.
 */
define('FEATURES_GIT_CMD', escapeshellcmd(variable_get('features_git_git_cmd', '/usr/bin/git')));

/**
 * Permission Name.
 */
define('FEATURES_GIT_PERM', 'export features to git');

/**
 * Implements hook_permission().
 */
function features_git_permission() {
  $perms = array();
  $perms[FEATURES_GIT_PERM] = array(
    'title' => t('Export a feature to git'),
    'description' => t('Export a feature to disk, commit it to git and push it to a remote server'),
    'restrict access' => TRUE,
    'warning' => t('This module writes code directly to disk. This permission should only be granted to trusted users.'),
  );

  return $perms;
}

/**
 * Implements of hook_form_FORM_ID_alter().
 */
function features_git_form_features_export_form_alter(&$form, &$form_state) {

  // We only want permitted users accessing this functionality.
  if (!user_access(FEATURES_GIT_PERM)) {
    return;
  }

  $module = '';
  if (isset($form['#feature']) && !empty($form['#feature']->name)) {
    $module = $form['#feature']->name;
  }
  $path = _features_git_get_path($module);

  if (!is_writable($path)) {
    // if we can't write the feature then we can't continue;
    return;
  }

  $form['#validate'][] = 'features_git_export_build_form_validate';

  $form['info']['#weight'] = 1;
  $form['export']['#weight'] = 2;
  $form['buttons']['#weight'] = 4;

  $form['buttons']['export'] = array(
    '#type' => 'submit',
    '#value' => t('Export feature to git'),
    '#weight' => 10,
    '#submit' => array('features_git_export_build_form_submit'),
  );

  // Git specific fields.
  $form['git'] = array(
    '#type' => 'fieldset',
    '#title' => t('Git options'),
    '#weight' => 3,
  );

  $form['git']['passphrase'] = array(
    '#type' => 'password',
    '#title' => t('SSH key passphrase'),
    '#description' => t('Password to unlock your SSH private key. Unprotected keys are not supported.'),
    '#required' => TRUE,
  );

  $form['git']['message'] = array(
    '#type' => 'textfield',
    '#title' => 'Commit message',
    '#description' => t('Description of changes that have been made. This will be used as the git commit message.'),
    '#required' => TRUE,
  );

  $remotes = _features_git_get_remotes($path);
  if (count($remotes) > 1) {
    $form['git']['remotes'] = array(
      '#type' => 'select',
      '#title' => 'Remote repository',
      '#options' => $remotes,
      '#description' => 'URL of the remote repository to push changes to.',
    );
  }
  else {
    $keys = array_keys($remotes);
    $remote = $keys[0];
    $value = $remotes[$remote];

    $form['git']['remotes_markup'] = array(
      '#type' => 'markup',
      '#markup' => t('<strong>Remote repository</strong><br />@repo', array('@repo' => $value)),
    );

    $form['git']['remotes'] = array(
      '#type' => 'value',
      '#value' => $remote,
    );
  }
}

/**
 * Validation handler for features_export form.
 */
function features_git_export_build_form_validate($form, &$form_state) {

  // We only want permitted users accessing this functionality.
  if (!user_access(FEATURES_GIT_PERM)) {
    return;
  }

  // We only care if we're exporting to git.
  if ($form['buttons']['export']['#value'] !== $form_state['values']['op']) {
    return;
  }

  if (!$form_state['values']['passphrase']) {
    form_set_error('passphrase', 'Enter a passphrase for your SSH key.');
  }

  if (!$form_state['values']['message']) {
    form_set_error('message', 'Enter a commit message.');
  }

  if (!$form_state['values']['module_name']) {
    return;
  }

  $path = drupal_get_path('module', $form_state['values']['module_name']);
  if (!$path) {
    $path = _features_git_get_path_new_module($form_state['values']['module_name']);
  }

  if (!is_dir($path)) {
    if (!drupal_mkdir($path, 02775, TRUE)) {
      form_set_error('name', 'Unable to create directory to save feature.');
    }
  }
}

/**
 * Submit handler for features_export form.
 */
function features_git_export_build_form_submit($form, &$form_state) {

  // We only want permitted users accessing this functionality.
  if (!user_access(FEATURES_GIT_PERM)) {
    return;
  }

  // We only care if we're exporting to git.
  if ($form['buttons']['export']['#value'] !== $form_state['values']['op']) {
    return;
  }

  $path = drupal_get_path('module', $form_state['values']['module_name']);
  if (!$path) {
    $path = _features_git_get_path_new_module($form_state['values']['module_name']);
  }


  if (!features_git_generate($path, $form_state['values'])) {
    drupal_set_message(t('Unable to create_feature.'), 'error');
    return;
  }

  if (!features_git_commit($path, $form_state['values'])) {
    drupal_set_message(t('Unable to commit feature.'), 'error');
    return;
  }

  drupal_goto('admin/structure/features/' . $form_state['values']['module_name']);
}

/**
 * Generates a feature and writes it to disk.
 *
 * @param string
 *   $path The path to save the feature in.
 * @param Array
 *   $values The values from the submitted form.
 *
 * @return bool
 *   Was the feature successfully generated and saved to disk?
 */
function features_git_generate($path, $values) {
  module_load_include('inc', 'features', 'features.export');
  features_include();

  // Assemble the combined component list.
  $stub = array();
  $components = array_keys(features_get_components());
  foreach ($components as $component) {
    // User-selected components take precedence.
    if (!empty($values['sources'][$component])) {
      $stub[$component] = features_dom_decode_options(array_filter($values['sources'][$component]));
    }
    // Only fallback to an existing feature's values if there are no export options for the component.
    elseif (!empty($form['#feature']->info['features'][$component])) {
      $stub[$component] = $form['#feature']->info['features'][$component];
    }
  }

  // Generate populated feature.
  $module_name = $values['module_name'];
  $export = features_populate($stub, $values['sources']['dependencies'], $module_name);

  // Directly copy the following attributes.
  $attr = array('name', 'description');
  foreach ($attr as $key) {
    $export[$key] = isset($values[$key]) ? $values[$key] : NULL;
  }

  // If either update status-related keys are provided, add a project key
  // corresponding to the module name.
  if (!empty($values['version']) || !empty($values['project_status_url'])) {
    $export['project'] = $values['module_name'];
  }
  if (!empty($values['version'])) {
    $export['version'] = $values['version'];
  }
  if (!empty($values['project_status_url'])) {
    $export['project status url'] = $values['project_status_url'];
  }

  $files = features_export_render($export, $module_name, TRUE);
  if (!count($files)) {
    drupal_set_message(t('Feature has no files.'), 'error');
    return FALSE;
  }

  foreach ($files as $extension => $file_contents) {
    if (!in_array($extension, array('module', 'info'))) {
      $extension .= '.inc';
    }
    file_put_contents("$path/$module_name.$extension", $file_contents);
  }

  // Check that something was written to disk.
  if (!is_file("$path/$module_name.info")) {
    drupal_set_message(t('Files not written to disk.'), 'error');
    return FALSE;
  }

  return TRUE;
}

function features_git_commit($path, $values) {

  global $user;
  $path = escapeshellarg($path);
  $author = escapeshellarg($user->name);
  $email = escapeshellarg($user->mail);
  $remote = escapeshellarg($values['remotes']);
  $commit_message = escapeshellarg($values['message']);
  $git = FEATURES_GIT_CMD;

  $branch = trim(exec("cd $path && $git branch | grep \\* | cut -d\\* -f2"));
  if (!$branch) {
    $branch = 'master';
  }
  $branch = escapeshellarg($branch);

  $cmd = "cd $path && $git add * && GIT_AUTHOR_NAME=$author GIT_COMMITTER_NAME=$author GIT_AUTHOR_EMAIL=$email GIT_COMMITTER_EMAIL=$email $git commit -m $commit_message 2>&1";
  $out = '';
  $ret = 0;
  exec($cmd, $out, $ret);
  if ( 0 !== $ret ) {
    drupal_set_message(t('Failed to commit files.'), 'error');
    return FALSE;
  }
  
  $ssh_askpass = variable_get('features_git_ssh_askpass', _features_git_get_path('features_git') . '/ssh-echopass');
  $display = 'hack';
  $cmd = "$git push $remote $branch";
  // The environment variables are escaped internally by PHP.
  $env = array(
    'SSH_ASKPASS' => $ssh_askpass,
    'DISPLAY' => $display,
    'SSH_PASS' => $values['passphrase'],
  );
  $pipes = array();
  
  $descriptorspec = array(
     0 => array("pipe", "r"),  // stdin is a pipe that the child will read from
     1 => array("pipe", "w"),  // stdout is a pipe that the child will write to
     2 => array("pipe", "w"),  // stderr is a pipe that the child will write to
  );
  
  $proc = proc_open($cmd , $descriptorspec , $pipes, $path, $env);
  if (!is_resource($proc)) {
    drupal_set_message(t('Unable to push changes.'), 'error');
    return FALSE;
  }
  
  // Check for errors.
  // TODO: These really belong in watchdog.
  $errors = stream_get_contents($pipes[2]);
  
  // Get status and close.
  $status = proc_get_status($proc);
  fclose($pipes[2]);
  fclose($pipes[1]);
  fclose($pipes[0]);
  proc_close($proc);
  $exit = $status['exitcode'];
  
  if (0 !== $exit) {
    drupal_set_message(t('Unable to push changes.'), 'error');
    return FALSE;
  }
  return TRUE;
}

/**
 * Get the full path name for an existing feature module.
 *
 * @param string
 *   $module_name The name of the module to lookup.
 *
 * @return string
 *   The full path to the module.
 */
function _features_git_get_path($module_name) {
  $path = $_SERVER['DOCUMENT_ROOT'] . base_path() 
    . '/' . drupal_get_path('module', $module_name);

  return $path;
}

/**
 * Get the full path name for a new feature module.
 *
 * @param string
 *   $module_name The name of the new module.
 *
 * @return string
 *   The full path name for the new module.
 */
function _features_git_get_path_new_module($module_name) {
  $path = $_SERVER['DOCUMENT_ROOT'] . base_path()
    . '/' . variable_get('feature_git_default_path', 'sites/all/modules/features')
    . '/' . basename($module_name);

  return $path;
}

/**
 * Fetches a list of available git remotes.
 *
 * @param string
 *   $path Path to check for remotes.
 * @param bool
 *   $only_push Only return push remotes?
 *
 * @return
 *   List of available remotes with short name as the key and URL as the value.
 */
function _features_git_get_remotes($path, $only_push = TRUE) {

  $path = escapeshellarg($path);

  $remotes = array('origin' => 'origin');

  $out = array();
  $ret = 0;
  exec("cd $path && " . FEATURES_GIT_CMD . ' remote -v', $out, $ret);

  if (0 !== $ret) {
    return $remotes;
  }

  foreach ($out as $line) {
    $m = array();
    if (!preg_match('/^(.+)\s(.+) \((push|fetch)\)$/', $line, $m)) {
      continue;
    }
    if ($only_push) {
      if (count($m) != 4 || 'push' !== $m[3]) {
        continue;
      }
    }
    $remotes[$m[1]] = $m[2];
  }

  return $remotes;
}
