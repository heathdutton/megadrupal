<?php
/**
 * @file
 * XC Search module functions
 *
 * @copyright (c) 2010-2011 eXtensible Catalog Organization
 */

/**
 * @addtogroup global variables
 * @{
 */

/**
 * The Apache Solr server object XC use for searching.
 * @var Apache_Solr_ServiceXc
 */
global $_xc_search_server;

/**
 * Array used for collecting data about the dureation of specific procedures.
 * @var array
 */

global $_xc_search_timing;
/**
 * Flag indicates whether the current search has result.
 * @var boolean
 */

global $_xc_search_no_results;
/**
 * @} End of "addtogroup global variables".
 */

/**
 * How many records should be in the search result list by default
 * @var int
 */
define('XC_SEARCH_LIMIT', 10);

/**
 * The directory, where the template files exists
 * @var string
 */
define('XC_SEARCH_TEMPLATE_DIR', 'templates');

/**
 * Permission for administering XC Search module
 * @var String
 */
define('ADMINISTER_XC_SEARCH', 'administer xc search');

/**
 * Is the current page within the XC Search path
 *
 * @return boolean
 */
function is_xc_search_path() {
  // Probably easier to do with arg() -- now checking for word boundaries, etc.
  return (boolean) preg_match('/^(search\/xc_search|xc\/search)\b/', $_GET['q']);
}


/**
 * Implements hook_help().
 *
 * @param $path A Drupal menu router path the help is being requested.
 * @param $arg An array that corresponds to the return of the arg() function.
 * @return A localized string containing the help text.
 */
function xc_search_help($path, $arg) {
  $output = '';
  switch ($path) {
    // Help for another path in the block module
    case "admin/help#xc_search":
      $output = '';
      break;

      /*
       case 'admin/xc/search/facet':
       $output = '<p>' . t('Some help for facets.') . '</p>';
       break;
       */

    case 'admin/xc/search/facet/datefacetset/%/edit':
      $output = '<p>' . t('Use this form to create date facet behaviours. There are two type of facet: the main, and some additional date facets. The main gives the bulk of the facet block. You should set up the start and end dates, plus an initial interval. It will create an list of intervals, e.g. if the interval is 100 years, it will list the centuries between the two end dates. The other kind of date, the additional date is a "query" date: you should set up the two end points. You can decide what would happen if the user clicks on the interval: if you gives an interval value (same as the main\'s Gap field), Drupal Toolkit will automatically "zooms" the interval, e.g. you gives that it should display the number of documents created in the last five years, and if the user clicks on it the Toolkit will display each year. If you leave Gap empty, the Toolkit will not "zoom" the interval. With label you can decide how to display the term, you can give expressive phrases like "last five year". With position field you can display the additional date before or after the main dates.') . '</p>';
      $output .= '<p>' . t('Use Solr date math in the gap, and the query fields. You can use NOW, YEAR, MONTH, DAY, HOUR, MINUTE, SECOND, MILLISECOND contants. The format of exact dates: YYYY-MM-DDThh:mm:ssZ, where T and Z are the T and Z characters. You can use * as the first or last date in the database. Some examples: [* TO NOW] = all dates up to now. [1000-01-01T00:00:01Z TO 2010-12-31T23:59:59Z] = between 1000 and 2010. NOW-5YEARS = 5 years before now.')
        . '</p>';
      break;
  }
  return $output;
}

/**
 * Implements hook_permission().
 */
function xc_search_permission() {
  return array(
    ADMINISTER_XC_SEARCH => array(
      'title' => t(ADMINISTER_XC_SEARCH),
      'description' => t('TODO Add a description for ADMINISTER_XC_SEARCH'),
    ),
  );
}

/**
 * Implements hook_menu().
 *
 * This is a wrapper around _xc_search_menu() which takes place at includes/menu.inc
 */
function xc_search_menu() {
  module_load_include('inc', 'xc_search', 'includes/menu');
  return _xc_search_menu();
}

/**
 * Implements hook_simpletest().
 */
function xc_search_simpletest() {
  $dir = drupal_get_path('module', 'xc_search') . '/tests';
  $tests = file_scan_directory($dir, '/\.test$/');
  return array_keys($tests);
}

/**
 * Implements hook_search_info()
 */
function xc_search_search_info() {
  return array(
    'title' => 'XC search'
  );
}

function xc_search_search_access() {
  return user_access('access user profiles');
}

function xc_search_search_execute($keys = NULL) {
  $meta = (object)array();
  return xc_search_do_search($keys, 'xc_search', $meta);
}

/**
 * Implements hook_search().
 */
function xc_search_search($op = 'search', $keys = NULL, &$meta = FALSE) {
  timer_start('xc_search_data/hook_search/' . $op);
  switch ($op) {
    case 'name':
      $output = t('Search records');
      break;

    case 'search':
      $output = xc_search_do_search($keys, 'xc_search', $meta);
      break;

    case 'admin':
      // we add the possibility to disable instant search momentarily via the admin/settings/search screen
      $form = array();
      $form['xc_search_search'] = array(
        '#type' => 'fieldset',
        '#title' => t('Search results availability'),
      );
      $form['xc_search_search']['xc_search_enable'] = array(
        '#type' => 'checkbox',
        '#title' => t('Instantly index node content after inserting or updating nodes.'),
        '#description' => t('Checking this will make your content appear instantly in your search results after inserting or updating. Default behaviour makes your content appear as soon as cron runs.'),
        '#default_value' => variable_get('instant_search_enable', '0'),
      );
      $output = $form;
      break;

    default:
      $output = FALSE;
  }
  timer_stop('xc_search_data/hook_search/' . $op);
  return $output;
}

/**
 * A central searcher
 *
 * @param $query (String)
 *   The query to search for
 * @param $caller_module (String)
 *   Which module called the search function
 * @param $meta (Array)
 *   A refrence array for storing metadata of search (number of hits etc.)
 *   - rows: the number of rows to display
 *   - first: the first result in this page
 *   - last: the last result in this page
 *   - total: the total number of results
 *
 * @return (Array)
 *   The result list. Each element conform to Search API
 */
function xc_search_do_search($query, $caller_module = NULL, &$meta = NULL) {
  global $_xc_search_server, $_xc_search_timing, $user;
  static $use_solr_debug = TRUE;

  timer_start('xc_search_data/hook_search/search/xc_search_do_search');

  $xc_statistics_enabled = module_exists('xc_statistics');
  if ($xc_statistics_enabled) {
    $_xc_search_timing = array(
      'start' => microtime(TRUE),
      'solr_to_array' => 0.0,
      'create_node' => 0.0,
      'template_elements' => 0.0,
      'images_extract_fields' => 0.0,
      'images_identifiers' => 0.0,
      'theme' => 0.0,
    );
  }
  $xc_search_type = variable_get('xc_search_type', 'basic');

  $filters = !empty($_GET['filter']) ? $_GET['filter'] : array();
  $start   = !empty($_GET['start'])  ? $_GET['start']  : 0;
  $sort    = !empty($_GET['sort'])   ? $_GET['sort']   : '';
  $rows    = xc_search_get_rows();
  $page    = xc_search_get_page();
  $is_query_link = (!empty($_GET['ql']) && $_GET['ql'] == 1) ? TRUE : FALSE;

  $checkbox_options = xc_search_block_checkbox_options();
  $online_only = $checkbox_options['online_only'];
  $exclude_microform = $checkbox_options['exclude_microform'];
  if (is_string($filters)) {
    $filters = array($filters);
  }

  while (is_array($page)) {
    $page = $page[0];
  }
  $page = intval($page);
  $debug_mode  = !empty($_GET['debug']) && $_GET['debug'] == 1 ? TRUE : FALSE;
  $search_type = !empty($_GET['search_type']) ? $_GET['search_type'] : 'standard';
  // TODO: get properties
  $search_ui_id = !empty($_GET['search_ui']) ? intval($_GET['search_ui']) : NULL;
  $search_ui = xc_search_ui_get($search_ui_id);
  if (trim($query) == '*') {
    $query = '*:*';
  }

  xc_search_current_query($query);
  xc_search_variable('search_ui', $search_ui);
  if ($xc_statistics_enabled) {
    $_xc_search_timing += array(
      'ui_id' => $search_ui->sui_id,
      'ui_name' => $search_ui->name,
    );
  }

  if ($search_type == 'standard' && $online_only == 1) {
    $filters[] = 'format_fc:"Online"';
  }
  if ($search_type == 'standard' && $exclude_microform == 1) {
    $filters[] = 'format_fc:"Not microform"';
  }

  if ($search_type == 'standard' || $search_type == 'mlt') {
    /*
     $prohibited_types = array('work', 'expression', 'holdings', 'item');
     foreach ($prohibited_types as $type) {
     if (!in_array('-type:' . $type, $filters)) {
     $filters[] = '-type:' . $type;
     }
     }
     */
  }
  $start  = $page * $rows;
  $filters = array_unique($filters);
  $solr_params = array(
    'fq' => $filters,
    // 'fl' => 'id,node_id_i,metadata_id_s,metadata_tsn',
  );
  $solr_params['XCNAME'] = ($caller_module == 'xc_browse') ? 'xc_browse_do_search' : 'xc_search_do_search';

  // reuse_filter
  if (isset($_GET['reuse_filter']) && $_GET['reuse_filter'] == 1 && is_null($query)) {
    $query = '*.*';
  }

  // search type specific settings
  if ($search_type == 'standard') {
    $solr_params += xc_search_highlighting_params();
    // $solr_params += xc_search_spellcheck_params($query);
  }
  elseif ($search_type == 'mlt') {
    $solr_params = array(
      'fq' => $filters,
      'search_type' => 'mlt',
    );
    $solr_params += xc_search_mlt_params();
  }

  // TODO: put it into admin UI
  $sort = xc_search_get_sort_param($sort);
  if ($sort != '') {
    $solr_params['sort'] = $sort;
  }

  if ($use_solr_debug) {
    $solr_params['debugQuery'] = 'on';
  }

  $boosting_query = xc_search_field_boosting($query, $search_ui);

  if ($search_ui->use_distinct_search == 0 && $caller_module != 'xc_browse') {
    require_once 'searching/xc_search_block.inc';
    $destination = drupal_get_destination();
    $facet_data = xc_search_block_facet_prepare(str_replace('destination=', '', urldecode($destination['destination'])));

    if (!empty($facet_data->params)) {
      $facet_params = $facet_data->params;
      unset($facet_params['fq']);
      $solr_params += $facet_params;
      $solr_params['XCNAME'] = 'xc_search_do_search_and_facet';
    }
  }

  if ($xc_statistics_enabled) {
    $_xc_search_timing['query'] = $query . '?' . http_build_query($filters);
  }

  $found = array();
  if ($query != NULL) {
    if ($xc_statistics_enabled) {
      $t = microtime(TRUE);
    }
    timer_start('xc_search_data/hook_search/search/xc_search_do_search/solr');
    $solr_params['caller'] = 'xc_search_data/hook_search/search/xc_search_do_search/solr';
    xc_search_variable('solr_params', $solr_params);
    do {
      $run_again = FALSE;
      try {
        $solr_query = $query;
        if ($query != '*:*' && !empty($boosting_query)) {
          $solr_query = sprintf('%s OR (%s)^%.02f', $boosting_query, $solr_query, 0.10);
        }
        $response = $_xc_search_server->search($solr_query, $start, $rows, $solr_params, TRUE);
      }
      catch (Exception $e) {
        $message = str_replace('_', ' ', $e->getMessage());
        if (strpos($message, 'orgapachelucenequeryParserParseException') !== FALSE
             || strpos($message, 'org.apache.lucene.queryParser.ParseException') !== FALSE) { // Solr 3.3.
          if (preg_match('/Lexical error at line (\d+) column (\d+)/', $message, $matches)) {
            $message = t('Cannot parse query string. Lexical error at line !line column !column.',
              array('!line' => $matches[1], '!column' => $matches[2]));
          }
          elseif (preg_match('/Cannot parse \'(.*?)\'/', $message, $matches)) {
            $message = t('Cannot parse query string !query.', array('!query' => $matches[1]));
          }
        }
        elseif (strpos($message, 'undefined field ') === 0 && preg_match('/[^\\\\]:/', $query)) {
          $query = preg_replace('/([^\\\\]):/', '$1\:', $query);
          $run_again = TRUE;
        }

        if ($run_again === FALSE) {
          xc_search_error($message);
          return $found;
        }
      }
    } while ($run_again);
    timer_stop('xc_search_data/hook_search/search/xc_search_do_search/solr');

    // save response to later usage
    xc_search_variable('search_response', $response);

    $total    = $response->response->numFound;
    $meta->total = $total;
    $meta->first = $start + 1;
    $meta->last  = ($start + $rows < $total) ? $start + $rows : $total;
    $meta->rows  = $rows;
    $GLOBALS['timers']['xc_search_data/hook_search/search/xc_search_do_search/solr/pure'] = array(
      'counter' => 1,
      'time' => $response->responseHeader->QTime,
    );
    if ($xc_statistics_enabled) {
      $_xc_search_timing['solr_all'] = microtime(TRUE) - $t;
      $_xc_search_timing['hits'] = $total;
      $_xc_search_timing['solr'] = $response->responseHeader->QTime / 1000;
    }
    $start    = $response->responseHeader->params->start;
    $limit    = $response->responseHeader->params->rows;
    $_SESSION['xc_search_query'][$caller_module] = array(
      'query' => $query,
      'solr_params' => $solr_params,
      'rows_per_page' => $rows,
      'total_results' => $total,
      'search_page' => str_replace('destination=', '', drupal_get_destination()),
    );
    // TODO: fix it.
    // pager_query is a D6 function totally reformed in D7
    // pager_query("SELECT %d", $rows, 0, NULL, $total);
    pager_default_initialize($total, $rows);

    /*
     drupal_set_message(t('%num records found in %sec sec',
     array('%num' => $total, '%sec' => $_xc_search_timing['solr'])));
     */
    if ($total > 0) {
      timer_start('xc_search_data/hook_search/search/xc_search_do_search/xc_search_show_item_array');
      $has_highlighting = !is_null($response->highlighting);
      $i = 1;
      foreach ($response->response->docs as $doc) {
        $doc_id = $doc->id;
        if ($has_highlighting && isset($response->highlighting->$doc_id)) {
          $highlight = $response->highlighting->$doc_id;
        }
        else {
          $highlight = NULL;
        }
        // TODO: rename xc_search_show_item_array
        timer_start('xc_search_data/hook_search/search/xc_search_do_search/xc_search_show_item_array2');
        $found[] = xc_search_show_item_array($doc, $highlight, ($start + $i++), $search_ui, $debug_mode);
        timer_stop('xc_search_data/hook_search/search/xc_search_do_search/xc_search_show_item_array2');
      }
      if ($total == 1) {
        header('Location: ' . $found[0]['link'], TRUE, 302);
      }
      timer_stop('xc_search_data/hook_search/search/xc_search_do_search/xc_search_show_item_array');
    }

    if (isset($response->spellcheck->suggestions)) {
      timer_start('xc_search_data/hook_search/search/xc_search_do_search/spellcheck');

      $spellcheck = array();
      // $spellcheck['has_result'] = ($total > 0);
      foreach ($response->spellcheck->suggestions as $key => $suggestion) {
        if ($key == 'collation') {
          $spellcheck['best'] = $suggestion;
        }
        elseif ($key == 'correctlySpelled') {
          $spellcheck['correctlySpelled'] = $suggestion;
        }
        else { // terms
          $terms = array();
          foreach ($suggestion->suggestion as $term) {
            $terms[$term->word] = $term->freq;
          }
          // arsort($terms);
          $spellcheck['terms'][$key] = array(
            'start' => $suggestion->startOffset,
            'end' => $suggestion->endOffset,
            'freq' => $suggestion->origFreq,
            'terms' => $terms,
          );
        }
      }
      xc_search_spellcheck($spellcheck);
      timer_stop('xc_search_data/hook_search/search/xc_search_do_search/spellcheck');
    }

    if ($use_solr_debug) {
      $keys = array_keys(get_object_vars($response->debug->timing->prepare));
      $GLOBALS['timers'][$solr_params['caller'] . '/solr-stat/time'] = array(
        'counter' => 1,
        'time' => $response->debug->timing->time,
      );
      $types = array('prepare', 'process');
      foreach ($types as $type) {
        foreach ($keys as $key) {
          if ($key == 'time') {
            $value = $response->debug->timing->$type->$key;
          }
          else {
            $value = $response->debug->timing->$type->$key->time;
          }
          if ($value != 0) {
            $GLOBALS['timers'][$solr_params['caller'] . '/solr-stat/' . $type . '/' . $key] = array(
              'counter' => 1,
              'time' => $value,
            );
          }
        }
      }
    }
  }

  timer_stop('xc_search_data/hook_search/search/xc_search_do_search');
  return $found;
}

/**
 * Theming search results.
 *
 * @param $results (Array)
 *   The results list, as defined in Search API
 * @param $meta (Object)
 *   Reference object containing the following fields:
 *   - total (int): the total number or results
 *   - first (int): the first result to show
 *   - last (int): the last result to show
 *   - rows (int): the number of rows to display
 *
 * @return (String) The search result page
 */
function theme_xc_search_search_results($variables) {
  $results = $variables['results'];
  $meta = $variables['meta'];
  global $_xc_search_timing;
  timer_start('xc_search_data/xc_search_search_page/theme_xc_search_search_results');

  $xc_statistics_enabled = !empty($_xc_search_timing);

  $pager_id = 10;

  $header = array();
  $rows   = array();
  $image_info = array();
  $availability = array();

  if ($xc_statistics_enabled) {
    $t1 = microtime(TRUE);
  }

  /* ncip_id => array(array(node_id -> ncip_item_id) */

  // Fetch all NCIP item IDs into an array

  timer_start('xc_search_data/xc_search_search_page/theme_xc_search_search_results/ncip_count');
  $all_ncip_item_ids = array();
  $ncip_item_count = 0;
  foreach ($results as $result) {
    if (!isset($result['extra'])) {
      continue;
    }
    foreach ($result['extra']['ncip_item_ids'] as $id_int => $ncip_info) {
      $all_ncip_item_ids[] = array(
        'nid' => $result['extra']['node_id'],
        'id_int' => $id_int,
        'ncip_info' => $ncip_info,
      );
      $ncip_item_count++;
    }
  }
  timer_stop('xc_search_data/xc_search_search_page/theme_xc_search_search_results/ncip_count');

  // Loop through each result item

  timer_start('xc_search_data/xc_search_search_page/theme_xc_search_search_results/loop');
  $count = 1;
  foreach ($results as $result) {
    $node_id = $result['extra']['node_id'];
    $counter = $result['extra']['counter'];
    $xc_record = $result['extra']['xc_record'];

    // image info
    if ($result['extra']['image_url'] == '') {
      $image_info[$result['extra']['node_id']] = $result['extra']['syndetics_ids'];
    }

    // status
    $status = array();
    foreach ($result['extra']['ncip_item_ids'] as $ncip_provider_id => $ncip_item_id) {
      if (isset($availability[$ncip_provider_id][$ncip_item_id])) {
        $status[] = xc_ncip_provider_get_name($ncip_provider_id) . ': '
          . drupal_placeholder($availability[$ncip_provider_id][$ncip_item_id]);
      }
    }
    if (!empty($status)) {
      $xc_record['status'] = join(', ', $status);
    }

    if (isset($result['extra']['element']['title'])) {
      $title_clean = strip_tags(xc_util_conditional_join(' &mdash; ', $result['extra']['element']['title']));
      $result['extra']['cover_title'] = t('Cover image of !title', array('!title' => $title_clean));
    }

    // Add classes to row
    $classes = array();
    $classes[] = 'result-row';
    $classes[] = 'row-' . $count;
    $classes[] = 'counter-' . (int) $counter;
    $classes[] = $counter % 2 == 0 ? 'even' : 'odd';
    if ($count == 1) {
      $classes[] = 'first';
    }
    if ($count == count($results)) {
      $classes[] = 'last';
    }

    $rows[] = theme('xc_search_result_list_row', array(
      'counter' => $counter,
      'node_id' => $node_id,
      'result' => $result,
      'xc_record' => $xc_record,
      'attributes' => array('class' => $classes)
    ));

    // Increment count
    $count++;
  }

  if ($xc_statistics_enabled) {
    $t2 = microtime(TRUE);
    $_xc_search_timing['collect_table'] = ($t2 - $t1);
  }
  timer_stop('xc_search_data/xc_search_search_page/theme_xc_search_search_results/loop');

  timer_start('xc_search_data/xc_search_search_page/theme_xc_search_search_results/js');
  drupal_add_js(drupal_get_path('module', 'xc_search') . '/js/xc_search.js');
  drupal_add_js(array('xc_search' => array(
      'page' => 'xc_search',
      'image_info' => $image_info,
      'image_url' => url('xc_search/ajax/image_info', array('absolute' => TRUE)),
      'ncip_info' => $all_ncip_item_ids,
      'ncip_item_count' => $ncip_item_count,
      'ncip_url' => url('xc_search/ajax/ncip_info', array('absolute' => TRUE)),
      'bookmark_item_url' => url('xc_search/ajax/bookmark_item', array('absolute' => TRUE)),
      'msg_journal_availability' => '<span class="available">' . t('Multiple items available') . '</span>',
      'msg_journal_call_numbers' => t('multiple'),
      'msg_not_available' => t('Not Available'),
      'token' => drupal_get_token(__FUNCTION__),
    )), array('type' => 'setting', 'scope' => JS_DEFAULT));
  timer_stop('xc_search_data/xc_search_search_page/theme_xc_search_search_results/js');

  // spellsheck
  $spellcheck = ''; // theme('xc_search_spellcheck', xc_search_spellcheck());

  // Result list
  timer_start('xc_search_data/xc_search_search_page/theme_xc_search_search_results/theme_result_list');
  $result_list = theme('xc_search_result_list', array(
    'header' => $header,
    'rows' => $rows,
    'attributes' => array('class' => array('xc-search-results table-results'))
  ));
  timer_stop('xc_search_data/xc_search_search_page/theme_xc_search_search_results/theme_result_list');

  // Notification
  timer_start('xc_search_data/xc_search_search_page/theme_xc_search_search_results/xc_search_general_notification');
  $general_notification = theme('xc_search_general_notification', array());
  timer_stop('xc_search_data/xc_search_search_page/theme_xc_search_search_results/xc_search_general_notification');

  timer_start('xc_search_data/xc_search_search_page/theme_xc_search_search_results/xc_search_bookmark_notification');
  $bookmark_notification = theme('xc_search_bookmark_notification', array());
  timer_stop('xc_search_data/xc_search_search_page/theme_xc_search_search_results/xc_search_bookmark_notification');

  $ui = xc_search_variable('search_ui');
  $add_query = FALSE;
  $synonyms = '';
  if (!isset($ui->handle_synonyms) || $ui->handle_synonyms == 1) {
    timer_start('xc_search_data/xc_search_search_page/theme_xc_search_search_results/synonyms');
    $synonyms = module_invoke_all('xc_synonyms', 'normal', xc_search_current_query());
    timer_stop('xc_search_data/xc_search_search_page/theme_xc_search_search_results/synonyms');
    $synonyms = join('', $synonyms);
  }
  elseif ($ui->handle_synonyms == 2) {
    drupal_add_js(array('xc_search' => array(
        'synonyms' => 1,
        'synonyms_url' => url('xc_search/ajax/xc_synonyms', array('absolute' => TRUE)),
      )), array('type' => 'setting', 'scope' => JS_DEFAULT));
    $synonyms = '<div id="xc-synonyms-placeholder"></div>';
    module_invoke_all('xc_synonyms', 'css', xc_search_current_query());
    $add_query = TRUE;
  }

  $themed_suggestions = '';
  if (!isset($ui->handle_suggestions) || $ui->handle_suggestions == 1) {
    timer_start('xc_search_data/xc_search_search_page/theme_xc_search_search_results/suggestions');
    $suggestions = xc_search_suggestions();
    timer_stop('xc_search_data/xc_search_search_page/theme_xc_search_search_results/suggestions');

    timer_start('xc_search_data/xc_search_search_page/theme_xc_search_search_results/suggestions/theme');
    $themed_suggestions = theme('xc_search_suggestions_serp', array('terms' => $suggestions));
    timer_stop('xc_search_data/xc_search_search_page/theme_xc_search_search_results/suggestions/theme');
  }
  elseif ($ui->handle_suggestions == 2) {
    drupal_add_js(array('xc_search' => array(
        'suggestions' => 1,
        'suggestions_url' => url('xc_search/ajax/xc_suggestions', array('absolute' => TRUE)),
      )), array('type' => 'setting', 'scope' => JS_DEFAULT));
    $add_query = TRUE;
    $themed_suggestions = '<div id="xc-suggestions-placeholder"></div>';
  }

  if ($add_query) {
    drupal_add_js(array('xc_search' => array('query' => xc_search_current_query())), array('type' => 'setting', 'scope' => JS_DEFAULT));
  }

  // TODO: revitalize did you mean, when it is possible
  $did_you_mean = ''; // xc_search_did_you_mean($suggestions, $meta);

  // Statistics
  if ($xc_statistics_enabled) {
    $_xc_search_timing['total'] = (microtime(TRUE) - $_xc_search_timing['start']);
    unset($_xc_search_timing['start']);
    xc_statistics_save('search', $_xc_search_timing);
  }

  timer_start('xc_search_data/xc_search_search_page/theme_xc_search_search_results/correction');
  $correction = '';
  if (isset($meta->correction)) {
    $params = xc_search_get_params();
    unset($params['os']);
    $url_params = array('query' => $params);
    $params['no_corr'] = 1;
    $url_params_for_original = array('query' => $params);
    $correction = '<p id="xc-correction">'
      . t('Showing results for <strong>!suggested1</strong>. Search instead for <strong>!suggested2</strong> or <strong>!suggested3</strong> or <strong>!original</strong>',
          array(
      '!suggested1' => l($meta->correction->suggested[0], 'xc/search/' . $meta->correction->suggested[0], $url_params),
      '!suggested2' => l($meta->correction->suggested[1], 'xc/search/' . $meta->correction->suggested[1], $url_params),
      '!suggested3' => l($meta->correction->suggested[2], 'xc/search/' . $meta->correction->suggested[2], $url_params),
      '!original' => l($meta->correction->original, 'xc/search/' . $meta->correction->original, $url_params_for_original),
    ))
      . '</p>';
  }
  timer_stop('xc_search_data/xc_search_search_page/theme_xc_search_search_results/correction');

  // Return output -- note that the info bar is output twice
  $output = $spellcheck
          . $did_you_mean
          . '<div style="clear: both;">' . $bookmark_notification . '</div>'
          . ($ui->handle_synonyms == 1 ? $synonyms : '')
          . $correction
          . $result_list
          . ($ui->handle_synonyms == 2 ? $synonyms : '')
          . $themed_suggestions
          . $general_notification;

  timer_stop('xc_search_data/xc_search_search_page/theme_xc_search_search_results');

  return $output;
} // theme_xc_search_search_results

/**
 * Create a 'Did you mean' link
 *
 * @param array $suggestions
 *   List of suggestions
 * @param object $meta
 *   The basic attributes of the search
 *
 * @return string
 *   The link
 */
function xc_search_did_you_mean($suggestions, $meta) {
  $output = '';

  if (!empty($suggestions)) {
    $keys = arg(2);
    foreach ($suggestions as $suggestion) {
      if (empty($suggestion)) {
        continue;
      }

      if ($keys != $suggestion) {
        $suggestion_result = xc_search_do_solr_search($suggestion, TRUE, 0, 0);
        break;
      }
    }

    if ($suggestion_result['total'] > $meta->total) {
      $params = xc_search_get_params();
      unset($params['os']);
      $url_params = array('query' => $params);

      $output = t('Did you mean !link?', array(
        '!link' => l($suggestion, 'xc/search/' . $suggestion, $url_params),
      ));
    }
  }
  return $output;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_xc_search_spellcheck($variables) {
  $spellcheck = $variables['spellcheck'];
  if (empty($spellcheck['terms'])) {
    return '';
  }
  $is_first = TRUE;
  $params = xc_search_get_params();
  unset($params['os']);
  $url_params          = $params;
  $original_query      = xc_search_current_query();
  $has_multiple_terms  = (count($spellcheck['terms']) > 1);
  $multiple_term_query = (count(preg_split('\s+', $original_query)) > 1);
  $use_replacement     = FALSE;
  // $output = t('No results for %query.', array('%query' => $original_query));

  if ($spellcheck['has_result'] && ($multiple_term_query || $has_multiple_terms)) {
    if (empty($spellcheck['best'])) {
      return '';
    }
    $output .= t('Search instead for !link', array(
      '!link' => l($spellcheck['best'], 'xc/search/' . $spellcheck['best'], array('query' => $url_params)),
    ));
  }
  else {
    $output .= t(' Search ');
    foreach ($spellcheck['terms'] as $term => $properties) {
      if (!$is_first) {
        $output .= '; ';
      }
      else {
        $is_first = FALSE;
      }
      $output .= t('instead of %term: ', array('%term' => $term));
      $suggestions = array();
      foreach ($properties['terms'] as $suggestion => $freq) {
        if ($use_replacement) {
          $query = '';
          if ($properties['start'] > 0) {
            $query .= drupal_substr($original_query, 0, $properties['start']);
          }
          $query .= $suggestion;
          if (strlen($original_query) > $properties['end']) {
            $query .= drupal_substr($original_query, $properties['end']);
          }
        }
        else {
          $query = $suggestion;
        }
        $link = l($suggestion, 'xc/search/' . $query, array('query' => $url_params));
        if ($use_replacement && $has_multiple_terms) {
          $suggestions[] = $link;
        }
        else {
          $suggestions[] = "$link ($freq)";
        }
      }
      $output .= join(', ', $suggestions);
    }
  }

  return '<div id="spellcheck">' . $output . '</div>';
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_xc_search_no_results($variables) {
  $title = $variables['title'];
  $content = $variables['content'];
  return '<div id="xc-search-no-result">'
    . '<h2>' . $title . '</h2>'
    . '<div class="content">' . $content . '</div>'
    . theme('xc_search_suggestions', array('terms' => xc_search_suggestions()))
    // . theme('xc_search_spellcheck', xc_search_spellcheck())
    . '</div>';
}

/**
 * Theming the list of suggestions
 *
 * @param $suggestions (array)
 *   List of suggestions
 */
function theme_xc_search_suggestions($variables) {
  $suggestions = $variables['terms'];
  $links = array();
  $params = xc_search_get_params();
  unset($params['os']);
  // $url_params = drupal_query_string_encode($params);
  foreach ($suggestions as $suggestion) {
    $links[] = l($suggestion, 'xc/search/' . $suggestion, array('query' => $params));
  }

  return '<div id="spellcheck">' . join(', ', $links) . '</div>';
}

/**
 * Theming the list of suggestions
 *
 * @param $suggestions (array)
 *   List of suggestions
 */
function theme_xc_search_suggestions_serp($variables) {
  $suggestions = $variables['terms'];
  if (empty($suggestions)) {
    return '';
  }
  $links = array();
  $params = xc_search_get_params();
  unset($params['os']);
  $url_params = $params;
  $next = ceil(count($suggestions) / 2);
  $i = 0;
  foreach ($suggestions as $j => $suggestion) {
    if ($next == $j) {
      $i++;
    }
    $links[$i][] = l($suggestion, 'xc/search/' . $suggestion, array('query' => $url_params));
  }

  $text = '<div id="xc-suggestions">'
        .   '<div id="xc-suggestions-title">'
              . t('Searches related to <strong>!query</strong>:',
                array('!query' => xc_search_current_query()))
        .   '</div>';
  for ($k = 0; $k <= $i; $k++) {
    if ($links[$k] && !empty($links[$k])) {
      $text .= '<div class="xc-suggestions-list"><p>' . join('<p></p>', $links[$k]) . '</p></div>';
    }
  }
  $text .= '</div>';

  return $text;
}

/**
 * Theming the search's info bar (bumber of results, pager, selection actions,
 * and action buttons).
 *
 * @param $meta (Object)
 *   The container of meta elements
 * @param $show_numbers (Boolean)
 *   Whether to show the numbers in the info bar (numbers and pager)
 * @param $show_actions (Boolean)
 *   Whether to show the actions part of the info bar (actions)
 * @param $show_form (Boolean)
 *   Whether to show the form in the info bar (actions)
 * @param $location (String)
 *   The location of the info bar. Currently only top and bottom is utilized.
 *   An additional class suffix for 'xc-search-info-bar-'. If NULL the div has
 *   only the default class ('xc-search-info-bar'). Default is 'top'.
 * @param $screen (String)
 *   The screen which called the info bar. Default is 'xc_search'.
 *
 * @return (String)
 *   The info bar
 */
function theme_xc_search_info_bar($variables) {
  $meta = $variables['meta'];
  $components = $variables['components'];
  $type = $variables['type'];
  $number = $variables['number'];
  $location = $variables['location'];
  $screen = $variables['module'];
  global $user;
  static $cache = array();

  $action_links = $action_buttons = array();

  $content = array(
    'pager' => '',
    'numbers' => '',
    'actions' => '',
    'form' => '',
    'back_to_results' => '',
  );

  timer_start('theme_xc_search_info_bar/pager');
  if (in_array('pager', $components)) {
    if (!isset($cache['pager'])) {
      $cache['pager'] = theme('xc_search_info_bar_pager', array('meta' => $meta));
    }
    $content['pager'] = $cache['pager'];
  }
  timer_stop('theme_xc_search_info_bar/pager');

  timer_start('theme_xc_search_info_bar/numbers');
  if (in_array('numbers', $components) && $number != '001b') {
    if (!isset($cache['numbers'])) {
      $cache['numbers'] = theme('xc_search_info_bar_numbers', array('meta' => $meta));
    }
    $content['numbers'] = $cache['numbers'];
  }
  timer_stop('theme_xc_search_info_bar/numbers');

  timer_start('theme_xc_search_info_bar/actions');
  if (in_array('actions', $components)) {
    if (!isset($cache['actions'])) {
      $action_links = array(
        'select-all-action' => t('All'),
        'select-none-action' => t('None'),
      );

      $ui = xc_search_ui_get();
      $action_buttons = array(
        'bookmark-action' => array('title' => t('Bookmark')),
        'email-action' => array('title' => t('Email')),
        'text-action' => array('title' => t('Text')),
        'print-action' => array('title' => t('Print')),
      );

      if (!$ui->display_bookmark_action || $user->uid == 0) {
        $action_buttons['bookmark-action']['#disabled'] = TRUE;
      }

      if (!$ui->display_email_action) {
        $action_buttons['email-action']['#disabled'] = TRUE;
      }

      if (!$ui->display_text_action) {
        $action_buttons['text-action']['#disabled'] = TRUE;
      }

      if (!$ui->display_print_action) {
        $action_buttons['print-action']['#disabled'] = TRUE;
      }

      if ($screen == 'xc_account') {
        unset($action_buttons['bookmark-action']);
        $action_buttons['bookmark-action'] = array(
          'title' => t('Remove'),
          '#id' => 'remove-bookmark',
        );
      }

      $cache['actions'] =
          '<div class="xc-search-info-bar-actions">'
        .   theme('xc_search_info_bar_actions', array('links' => $action_links, 'buttons' => $action_buttons))
        . '</div>';
    }
    $content['actions'] = $cache['actions'];
  }
  timer_stop('theme_xc_search_info_bar/actions');

  timer_start('theme_xc_search_info_bar/form');
  if (in_array('form', $components)) {
    if (!isset($cache['form'])) {
      // per page links
      $row_options = xc_search_rows_options();
      $params = xc_search_get_params();
      $actual_rows = xc_search_get_rows();
      unset($params['rows']);
      $query = $params; // drupal_query_string_encode($params) . '&rows=';

      foreach ($row_options as $key => $value) {
        $query['rows'] = $key;
        if ($key == $actual_rows) {
          $links[] = '<span class="xc-search-rowsperpage-link-actual">' . $key . '</span>';
        }
        else {
          $links[] = '<span class="xc-search-rowsperpage-link">'
            . l($key, $_GET['q'], array('query' => $query))
            . '</span>';
        }
      }

      $sortform = drupal_get_form('xc_search_sortform', $location, $screen);
      $themed_form =
        '<div class="xc-search-action-form">'
        .   '<div class="xc-search-sort-form">'
        .     drupal_render($sortform)
        .   '</div>';

      if ($number != '001b') {
        $themed_form .=
            '<div class="xc-search-rowsperpage">'
        .     t('!links Per Page', array('!links' => join(' | ', $links)))
        .   '</div>';
      }

      if (in_array('numbers', $components) && $number == '001b') {
        $themed_form .= theme('xc_search_info_bar_numbers', array('meta' => $meta));
      }

      $themed_form .= '</div>';
      $cache['form'] = $themed_form;
    }
    $content['form'] = $cache['form'];
  }
  timer_stop('theme_xc_search_info_bar/form');

  timer_start('theme_xc_search_info_bar/back_to_results');
  if (in_array('back_to_results', $components)) {
    $content['back_to_results'] = theme('xc_search_info_bar_back_to_results', array('meta' => $meta));
  }
  timer_stop('theme_xc_search_info_bar/back_to_results');

  timer_start('theme_xc_search_info_bar/classes');
  $class_names = array('xc-search-info-bar');
  if ($type) {
    $class_names[] = "xc-search-info-bar-$type";
  }
  if ($type && $number) {
    $class_names[] = "xc-search-info-bar-$number-$type";
  }
  if ($location) {
    $class_names[] = 'xc-search-info-bar-' . preg_replace('/\W/', '', $location);
  }
  if (isset($class)) {
    $class_names[] = $class;
  }
  timer_stop('theme_xc_search_info_bar/classes');

  $output = '<div class="' . join(' ', $class_names) . '">';
  foreach ($components as $component) {
    $output .= $content[$component];
  }
  $output .= '</div>';

  return $output;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_xc_search_info_bar_back_to_results($variables) {
  $meta = $variables['meta'];
  $results_page = $meta->extra['list'];
  $output = '<div class="xc-search-back-to-results">'
    . l($results_page['label'], $results_page['url'])
    . '</div>';
  return $output;
}

/**
 * Theme the action bar part of info bar
 *
 * @param $links (Array)
 *   Links (default: select all/none)
 * @param $buttons (Array)
 *   Buttons to start some actions (bookmark, print etc.)
 *
 * @return (String)
 *   Themed bar
 */
function theme_xc_search_info_bar_actions($variables) {
  $links = $variables['links'];
  $buttons = $variables['buttons'];
  $action_links = array();
  $action_buttons = array();

  foreach ($links as $class => $title) {
    $action_links[] = array(
      'href' => '',
      'title' => $title,
      'attributes' => array('class' => array($class)),
      'fragment' => ' ',
      'external' => TRUE,
    );
  }

  foreach ($buttons as $class => $properties) {
    $attributes = array('class' => array($class));
    $id = $class;

    if (!is_array($properties)) {
      $title = $properties;
    }
    else {
      $title = $properties['title'];
      if (isset($properties['#disabled']) && $properties['#disabled']) {
        $attributes['class'][] = 'action-disabled';
        $attributes['disabled'] = 'disabled';
      }
      if (isset($properties['#id'])) {
        $id = $properties['#id'];
      }
    }

    $definition = array(
      '#value' => $title,
      '#button_type' => 'submit',
      '#attributes' => $attributes,
    );

    if (isset($id) && !is_null($id)) {
      $definition['#id'] = $id;
    }

    $data = theme('button', array('element' => $definition));
    $action_buttons[]['data'] = $data;
  }

  $distinct_bars = FALSE;
  $last_button = end($action_buttons);
  if (preg_match('/id="remove-bookmark"/', $last_button['data'])) {
    $distinct_bars = TRUE;
    array_pop($action_buttons); // remove last button
    $remove_bar = array($last_button);
  }

  $output = '<div class="xc-search-actions">'
    . '<span class="xc-search-action-links">' . t('Select: ') . theme('links', array('links' => $action_links)) . '</span>'
    . '<span class="xc-search-action-buttons">' . theme('item_list', array('items' => $action_buttons)) . '</span>';
  if ($distinct_bars) {
    $output .= '<span class="xc-search-action-buttons xc-remove-bar">' . theme('item_list', array('items' => $remove_bar)) . '</span>';
  }
  $output .= '</div>';

  return $output;
}

/**
 * Theming the numbers (1-10 of 254 results) in info bar.
 *
 * @param $meta (Object)
 *   Container of meta element. Possible fields:
 *   - rows: the number of rows to display
 *   - first: the first result in this page
 *   - last: the last result in this page
 *   - total: the total number of results
 * @param $full (Boolean)
 *   Whether or not to show the 'first-last' part
 *
 * @return (String)
 *   The themed numbers
 */
function theme_xc_search_info_bar_numbers($variables) {
  $meta = $variables['meta'];
  $full = $variables['full'];
  // Numbers
  $variables = array(
    '!first' => '<span class="first">' . $meta->first . '</span>',
    '!last' => '<span class="last">'  . $meta->last  . '</span>',
    '!total' => '<span class="total">' . $meta->total . '</span>',
  );

  if ($full) {
    $numbers = ($meta->first != $meta->last)
      ? t('!first &mdash; !last of !total results', $variables)
      : t('!first of !total results', $variables);
  }
  else {
    $numbers = t('!total results', $variables);
  }

  return '<div class="xc-search-numbers">' . $numbers . '</div>';
}

/**
 * Themeing pager in info bar
 *
 * @param $meta
 *   Container of meta element. Possible fields:
 *   - rows: the number of rows to display
 *   - first: the first result in this page
 *   - last: the last result in this page
 *   - total: the total number of results
 *
 * @return (String)
 *   The themed pager
 */
function theme_xc_search_info_bar_pager($variables) {
  $meta = $variables['meta'];
  static $cache;
  // Pager
  if (isset($meta)) {
    if (!isset($cache)) {
      $pager_form = drupal_get_form('xc_search_pager_form', $meta);
      $cache = '<div class="xc-search-pager">'
         . drupal_render($pager_form)
         . '</div>';
    }
    return $cache;
  }
}

/**
 * Draw a search result table. This is a copy of theme_table, but it use themed
 * HTML rows (list of <TR> elements), instead of the abstract rows array.
 *
 * @param Array $header
 * @param Array $rows
 * @param <type> $attributes
 * @param <type> $caption
 * @return <type>
 */
function theme_xc_search_result_list($variables) {
  $header = $variables['header'];
  $rows = $variables['rows'];
  $attributes = $variables['attributes'];
  $caption = $variables['caption'];

  // Add sticky headers, if applicable.
  if (count($header)) {
    drupal_add_js('misc/tableheader.js');
    // Add 'sticky-enabled' class to the table to identify it for JS.
    // This is needed to target tables constructed by this function.
    $attributes['class'][] = 'sticky-enabled';
  }

  $output = '<table' . drupal_attributes($attributes) . ">\n";

  if (isset($caption)) {
    $output .= '<caption>' . $caption . "</caption>\n";
  }

  // Format the table header:
  if (count($header)) {
    $ts = tablesort_init($header);
    // HTML requires that the thead tag has tr tags in it followed by tbody
    // tags. Using ternary operator to check and see if we have any rows.
    $output .= (count($rows) ? ' <thead><tr>' : ' <tr>');
    foreach ($header as $cell) {
      $cell = tablesort_header($cell, $header, $ts);
      $output .= _theme_table_cell($cell, TRUE);
    }
    // Using ternary operator to close the tags based on whether or not there are rows
    $output .= (count($rows) ? " </tr></thead>\n" : "</tr>\n");
  }
  else {
    $ts = array();
  }

  // Format the table rows:
  if (count($rows)) {
    $output .= "<tbody>\n" . join('', $rows) . "</tbody>\n";
  }

  $output .= "</table>\n";
  return $output;
}

/**
 * Theme XC notification for search and browse pages
 *
 * @return
 *  Output HTML
 */
function theme_xc_search_general_notification() {
  return '<div id="xc-general-notification"></div>';
}

/**
 * Theme XC notification for search and browse pages
 *
 * @return
 *  Output HTML
 */
function theme_xc_search_bookmark_notification() {
  // TODO: button to hide this place
  $alt_text = t('close');
  $path1 = drupal_get_path('module', 'xc_search') . '/images/alert-close.png';
  $path2 = drupal_get_path('module', 'xc_search') . '/images/hover-close-alert.png';
  drupal_add_js(array('xc_search' => array(
      'xc_bookmark_close_state1' => $path1,
      'xc_bookmark_close_state2' => $path2,
    )), array('type' => 'setting', 'scope' => JS_DEFAULT));
  $image = theme('image', array('path' => $path1, 'width' => '', 'height' => '', 'alt' => $alt_text, 'title' => $alt_text, 'attributes' => array(
      'id' => 'xc-bookmark-close',
      'height' => 15,
    )));

  return '<div id="xc-bookmark-notification"><span class="content"></span>' . $image . '</div>';
}

/**
 * Get highlighting parameters
 *
 * @param $highlighter_id (int)
 *   The identifier of the highlighter record (Drupal's xc_search_highlighter table)
 *
 * @return
 *   The array of Solr highlighting parameter
 */
function xc_search_highlighting_params($highlighter_id = 1) {
  $highlighter = xc_search_highlighter_load($highlighter_id);
  $params = array();
  if (!is_null($highlighter)) {
    $params['hl']             = 'true';
    $params['hl.fragsize']    = $highlighter->fragsize;
    $params['hl.simple.pre']  = $highlighter->pre;
    $params['hl.simple.post'] = $highlighter->post;
    $params['hl.snippets']    = $highlighter->snippets;
    $params['hl.fl']          = $highlighter->fieldlist;
  }
  return $params;
}

/**
 * Get the Solr 'MoreLikeThis' parameters
 * @param $mlt_id
 *   The more like this record's identifier (Drupal's xc_search_mlt table)
 * @return unknown_type
 */
function xc_search_mlt_params($mlt_id = 1) {
  $mlt = xc_search_mlt_load($mlt_id);
  $params = array();
  if (!is_null($mlt)) {
    $params['mlt.fl']     = $mlt->fl;
    if (isset($mlt->mintf) && $mlt->mintf > 0) {
      $params['mlt.mintf']  = $mlt->mintf;
    }
    if (isset($mlt->mindf) && $mlt->mindf > 0) {
      $params['mlt.mindf']  = $mlt->mindf;
    }
    if (isset($mlt->minwl) && $mlt->minwl > 0) {
      $params['mlt.minwl']  = $mlt->minwl;
    }
    if (isset($mlt->maxwl) && $mlt->maxwl > 0) {
      $params['mlt.maxwl']  = $mlt->maxwl;
    }
    if (isset($mlt->maxqt) && $mlt->maxqt > 0) {
      $params['mlt.maxqt']  = $mlt->maxqt;
    }
    if (isset($mlt->maxntp) && $mlt->maxntp > 0) {
      $params['mlt.maxntp'] = $mlt->maxntp;
    }
    if (isset($mlt->boost)) {
      $params['mlt.boost']  = $mlt->boost;
    }
    if (isset($mlt->qf)) {
      $params['mlt.qf']     = $mlt->qf;
    }
    if (isset($mlt->count)) {
      $params['mlt.count']  = $mlt->count;
    }
    if (isset($mlt->match_include)) {
      $params['mlt.match.include']    = $mlt->match_include;
    }
    if (isset($mlt->match_offset)) {
      $params['mlt.match.offset']     = $mlt->match_offset;
    }
    if (isset($mlt->interestingTerms)) {
      $params['mlt.interestingTerms'] = $mlt->interestingTerms;
    }
  }
  return $params;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_get_sort_param($sort) {
  $use_new_sort = variable_get('xc_search_use_new_sort', TRUE);
  if ($use_new_sort) {
    if ($sort == '' || $sort == 'relevancy') {
      $sort = 'score desc';
    }
  }
  else {
    switch ($sort) {
      case '':
        break;
      case 'date_asc':
        $sort = 'date_df asc';
        break;
      case 'date_desc':
        $sort = 'date_df desc';
        break;
      case 'title_asc':
        $sort = 'dcterms__title_s asc';
        break;
      case 'title_desc':
        $sort = 'dcterms__title_s desc';
        break;
      case 'author_asc':
        $sort = 'creator_author_fc asc';
        break;
      case 'author_desc':
        $sort = 'creator_author_fc desc';
        break;
      case 'relevancy':
      default:
        $sort = 'score desc';
        break;
    }
  }
  return $sort;
}

/**
 * Gets the boosting query
 *
 * It returns the part of the query, which can weight it fields to modify relevancy
 *
 * @param $query (string)
 *   The query string
 * @param $search_ui (Object)
 *   The Search UI object
 */
function xc_search_field_boosting($query, $search_ui) {

  $boost_factors = xc_search_get_boost_factors($search_ui);
  $boost_query = array();
  foreach ($boost_factors as $field => $factor) {
    $boost_query[] = sprintf("%s:(%s)^%.02f", $field, $query, $factor);
  }

  $boosted_query = join(' OR ', $boost_query);
  return $boosted_query;
}

/**
 * Get the boost factors
 *
 * @param $search_ui (object)
 *   The search UI object
 *
 * @return (array)
 *   The array of field names - boost factors (number) pairs
 */
function xc_search_get_boost_factors($search_ui) {
  if (isset($search_ui->boost_factors) && !empty($search_ui->boost_factors)) {
    $boost_factors = array();
    foreach ($search_ui->boost_factors as $id => $factor) {
      $boost_factors[$factor['solr_field']] = $factor['factor'];
    }
  }
  else {
    // default boost factors
    $boost_factors = array(
      'dcterms__title_t' => 1000.00,
      'authors_contributors_fc' => 50.00,
    );
  }

  return $boost_factors;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_form_alter(&$form, $form_state, $form_id) {

  // Advanced node search form
  if (($form_id == 'search_form' || $form_id == 'xc_search_form')
       && $form['module']['#value'] == 'xc_search'
      // && user_access('use advanced search')
      ) {
    $form['#action'] = preg_replace('/search\/(node|xc_search)$/', 'xc/search', $form['#action']);
    $form['#validate'] = array('xc_search_form_search_validate');
    $form['#submit'] = array('xc_search_form_search_submit');
    $form['basic']['xc_search']['#TREE'] = TRUE;

    if (is_xc_search_path() && isset($_GET['reuse_filter']) && $_GET['reuse_filter'] == 1) {
      $form['basic']['xc_search']['filter'] = array(
        '#type' => 'hidden',
        '#default_value' => serialize($_GET['filter']),
      );
      $form['basic']['xc_search']['reuse_filter'] = array(
        '#type' => 'hidden',
        '#default_value' => 1,
      );
    }
  }
  elseif ($form_id == 'xc_search_sortform' && $form['screen']['#value'] == 'xc_search') {
    $form['#validate'] = array('xc_search_sortform_validate');
    $form['#submit'] = array('xc_search_sortform_submit');
    $form['basic']['xc_search']['#TREE'] = TRUE;
    if (is_xc_search_path() && isset($_GET['reuse_filter']) && $_GET['reuse_filter'] == 1) {
      $form['basic']['xc_search']['filter'] = array(
        '#type' => 'hidden',
        '#default_value' => serialize($_GET['filter']),
      );
      $form['basic']['xc_search']['reuse_filter'] = array(
        '#type' => 'hidden',
        '#default_value' => 1,
      );
    }
  }
  elseif ($form_id == 'print_mail_form') {
    global $user;
    $form['fld_from_addr']['#disabled'] = FALSE;
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_form_search_validate($form, &$form_state) {
  $values = $form_state['values'];
  $original_state['keys'] = $values['keys'];
  if ((!isset($values['is_query_link']) || !$values['is_query_link']) && $values['keys'] == '') {
    $values['keys'] = '*';
  }
  $value = (isset($values['is_query_link']) && $values['is_query_link'])
    ? trim($form['basic']['#post']['hidden_keys'])
    : trim($values['keys']);

  form_set_value($form['basic']['processed_keys'], $value, $form_state);
  form_set_value($form['basic']['original_state'], $original_state, $form_state);
}

/**
 * Form API callback for the search form. Registered in node_form_alter().
 */
function xc_search_form_validate($form, &$form_state) {

  $values = $form_state['values'];
  xc_search_current_query($values);
  variable_set('xc_search_type', $values['xc_search_type']);

  // Initialise using any existing basic search keywords.
  $keys = $values['processed_keys'];

  // Insert extra restrictions into the search keywords string.
  if (isset($values['type']) && is_array($values['type'])) {
    // Retrieve selected types - Forms API sets the value of unselected checkboxes to 0.
    $values['type'] = array_filter($values['type']);
    if (count($values['type'])) {
      $keys = search_query_insert($keys, 'type', implode(',', array_keys($values['type'])));
    }
  }

  if (isset($values['category']) && is_array($values['category'])) {
    $keys = search_query_insert($keys, 'category', implode(',', $values['category']));
  }
  if ($values['or'] != '') {
    if (preg_match_all('/ ("[^"]+"|[^" ]+)/i', ' ' . $values['or'], $matches)) {
      $keys .= ' ' . implode(' OR ', $matches[1]);
    }
  }
  if ($values['negative'] != '') {
    if (preg_match_all('/ ("[^"]+"|[^" ]+)/i', ' ' . $values['negative'], $matches)) {
      $keys .= ' -' . implode(' -', $matches[1]);
    }
  }
  if ($values['phrase'] != '') {
    $keys .= ' "' . str_replace('"', ' ', $values['phrase']) . '"';
  }

  if (!empty($keys)) {
    form_set_value($form['basic']['processed_keys'], trim($keys), $form_state);
  }
}

/**
 * Returns a part of XC metadata record as themed string
 *
 * @param $xc_record (Array)
 *   The XC record array
 * @param $element (Array)
 *   The display template elements
 * @param $display_type (String)
 *   The display type ('title' or 'snippet')
 * @param $counter (int)
 *   A record counter
 *
 * @return (String)
 *   A themed record display
 */
function theme_xc_search_metadata($variables) {
  $xc_record = $variables['xc_record'];
  $element = $variables['element'];
  $display_type = $variables['display_type'];
  $counter = $variables['counter'];
  $params = $variables['params'];
  global $base_url, $_xc_search_timing;
  static $frbr = array();
  timer_start('theme_xc_search_metadata');

  $start = microtime(TRUE);
  timer_start('theme_xc_search_metadata/xc_search_get_template_name');
  $tpl_name = xc_search_get_template_name($xc_record, $display_type);
  timer_stop('theme_xc_search_metadata/xc_search_get_template_name');

  timer_start('theme_xc_search_metadata/' . $tpl_name);
  $output = theme($tpl_name, array(
    'base_url' => $base_url,
    'xc_record_id' => $xc_record['id'],
    'xc_record' => $xc_record,
    'element' => $element,
    'frbr' => $frbr,
    'params' => $params,
  ));
  timer_stop('theme_xc_search_metadata/' . $tpl_name);

  timer_start('theme_xc_search_metadata/_xc_search_timing');
  if (!empty($_xc_search_timing)) {
    $_xc_search_timing['theme'] += (microtime(TRUE) - $start);
  }
  timer_stop('theme_xc_search_metadata/_xc_search_timing');

  timer_stop('theme_xc_search_metadata');
 // print($output);
  return $output;
}

/**
 * Get the name of the template. A wrapper function of xc_util_template_get_name.
 *
 * @param $xc_record (Array)
 *   The XC record
 * @param $display_type (String)
 *   The type of display, like 'title', 'snippet', 'full'
 *
 * @return (String)
 *   The name of template
 */
function xc_search_get_template_name($xc_record, $display_type) {
  // TODO: just a workaround, should test why metadata_type is missing
  return xc_util_template_get_name($xc_record['metadata_type'], $xc_record['type'], $display_type);
}

/**
 * Get the cover image url by ISBN, UPC and OCLC number.
 *
 * @param $isbns
 *   ISBN number(s). The numbers should be saparated with a comma.
 * @param $upcs
 *   UPC number(s) (Syndetics internal idenfier)
 * @param $oclcs
 *   OCLC number(s)
 * @param $image_size
 *   Image size. One of SYNDETICS_LARGE, SYNDETICS_MEDIUM or SYNDETICS_SMALL
 * @param $only_cached_images
 *   Get only cached images, or all image
 *
 * @return image url or empty string.
 */
function xc_search_get_syndetics_image($isbns, $upcs, $oclcs, $image_size = SYNDETICS_SMALL, $only_cached_images = FALSE) {
  if (!function_exists('syndetics_image_url')) {
    return '';
  }

  $urls = array();
  if ($isbns != '') {
    $isbns = explode(',', $isbns);
    foreach ($isbns as $isbn) {
      $urls = syndetics_image_url(array('ISBN' => $isbn, 'UPC' => $upcs, 'OCLC' => $oclcs),
        SYNDETICS_TYPE_COMPLEX, $image_size, $only_cached_images);
      if (count($urls) > 0) {
        //$image_cache[$xc_record['id']] = $urls[0];
        break;
      }
    }
  }
  elseif ($upcs != '' || $oclcs != '') {
    $urls = syndetics_image_url(
      array('ISBN' => $isbns, 'UPC' => $upcs, 'OCLC' => $oclcs),
      SYNDETICS_TYPE_COMPLEX, $image_size, $only_cached_images
    );
  }

  return (!empty($urls) ? $urls[0] : '');
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_oclc_url($id) {
  return 'http://www.worldcat.org/oclc/' . $id;
}

function _xc_get_manifestations($xc_record, $retrieve_solr_doc = TRUE) {
  if ($xc_record['metadata_type'] == 'expression') {
    $query = 'xc__expressionManifested_t:"' . $xc_record['id'] . '"';
  }
  elseif ($xc_record['metadata_type'] == 'holdings') {
    $query = 'id:("' . join('" OR "', $xc_record['xc:manifestationHeld']) . '")';
  }
  $result = xc_search_do_solr_search($query, $retrieve_solr_doc);
  return $result['docs'];
}

/**
 * Get the Holdings record connected to a manifestation
 *
 * @param $xc_record (array)
 *   The manifestation record
 * @param $retrieve_solr_doc (boolean)
 *   If TRUE it returns Solr documents, if FALSE it returns arrays with XC fields
 *
 * @return (Array)
 */
function _xc_get_holdings($xc_record, $retrieve_solr_doc = TRUE, $do_id_hack = FALSE) {
  $from_solr = FALSE;

  if ($from_solr) {
    $id = $xc_record['id'];
    if ($do_id_hack) {
      $id = str_replace('_', ' ', $id);
    }
    $query = 'xc__manifestationHeld_t:"' . $id . '"';
    $result = xc_search_do_solr_search($query, $retrieve_solr_doc);
    return $result['docs'];
  }
  else {
    $holdings = array();
    // holdingsid
    $int = xc_util_get_identifier_int($xc_record['id']);
    $children = xc_entity_get_child_identifiers($int);
    //$children = xc_entity_get_child_identifiers(xc_util_get_identifier_int($xc_record['id']));
    if (!empty($children)) {
      foreach ($children as $identifier) {
        $entity = xc_metadata_ids_by_identifier_int($identifier);
        xc_sql_xc_retrieve($entity);
        $holdings[] = $entity->metadata;
      }
    }
    return $holdings;
  }
}

/**
 * Simple Solr search
 *
 * @param $query (String)
 *   The solr query
 * @param $retrieve_solr_doc (Boolean)
 *   If true (default) retieve Solr documents, else array of xc_records
 * @param $offset (int)
 *   Which is the first document to retrieve?
 * @param $limit (int)
 *   How much documents to retrieve?
 * @param $params (Array)
 *   Solr parameters
 *
 * @return (Array) An associative array, which has the following keys:
 *   'total' - the total number of records matching the query,
 *   'docs' - the array of documents (either as Solr docs, or as xc_records)
 */
function xc_search_do_solr_search($query, $retrieve_solr_doc = TRUE,
    $offset = 0, $limit = XC_SEARCH_LIMIT, $params = array()) {
  global $_xc_search_server;
  $try_counter = 1;
  $xc_records = array();
  timer_start('xc_search_do_solr_search/_xc_search_server->search');
  while ($try_counter < 5) {
    try {
      $response = $_xc_search_server->search($query, $offset, $limit, $params);
      $try_counter = 5;
    }
    catch (Exception $e) {
      xc_log_error('xc solr', var_export($e, TRUE) . ' try counter: ' . $try_counter);
      $try_counter++;
      usleep(500000); // sleep for 0.5 sec
    }
  }
  timer_stop('xc_search_do_solr_search/_xc_search_server->search');


  $total = $response->response->numFound;
  $time  = (int) $response->responseHeader->QTime / 1000;
  $GLOBALS['timers']['xc_search_do_solr_search/_xc_search_server->search/solr'] = array(
    'counter' => 1,
    'time' => $response->responseHeader->QTime,
  );

  if ($retrieve_solr_doc) {
    return array(
      'total' => $total,
      'docs' => $response->response->docs,
      'time' => $time,
    );
  }

  if ($total > 0) {
    timer_start('xc_search_do_solr_search/_xc_solr_to_array');
    foreach ($response->response->docs as $doc) {
      $xc_records[] = _xc_solr_to_array($doc);
    }
    timer_stop('xc_search_do_solr_search/_xc_solr_to_array');
  }

  return array(
    'total' => $total,
    'docs' => $xc_records,
    'time' => $time,
  );
}

/**
 * replace {element:creator} to ({xc:contributor} OR {xc:author})
 * @param $matches
 * @return unknown_type
 */
function xc_search_get_display_template_elements($entity, $xc_record) {
  static $functions = array(), $cache = array();
  if (!isset($functions) || !isset($functions[$entity])) {
    $functions[$entity] = array();
    $templates = xc_search_display_template_element_get($entity);
    foreach ($templates as $template_name => $template) {
      $template = preg_replace("/\{(\w+:[\w-]+)\}/", "\\\$xc['\\1']", $template);
      $functions[$entity][$template_name] = create_function('$xc', $template);
    }
  }

  if (!isset($cache[$xc_record['id']])) {
    $elements = array();
    // TODO: add elements for holdings data
    if (isset($functions[$entity])) {
      foreach ($functions[$entity] as $template_name => $newfunc) {
        $values = $newfunc($xc_record);
        if (is_array($values)) {
          $flat_values = array();
          foreach ($values as $v) {
            $flat_values = array_merge($flat_values, (array) $v);
          }
          $values = $flat_values;
        }
        $elements[$template_name] = $values;
      }
    }
    else {
      // The holdings data has no display templates
      //drupal_set_message('No functions for ' . $entity);
    }
    $cache[$xc_record['id']] = $elements;
  }
  return $cache[$xc_record['id']];
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_display_template_element_get($entity_type, $element_name = NULL) {
  static $template_element_cache, $sql_without_name, $sql_with_name;
  if (!isset($template_element_cache)) {
    $template_element_cache = array();
  }
  // TODO from Tom, convert to D7 query
  if (!isset($sql_without_name)) {
    $sql_without_name = "SELECT element_name, template
      FROM {xc_search_display_template_element}
      WHERE entity_type = :entity_type";

    $sql_with_name = $sql_without_name . " AND element_name = :element_name";
  }
  $key = isset($element_name) ? $element_name : 'ANY';

  if (!isset($template_element_cache[$entity_type])
       || !isset($template_element_cache[$entity_type][$key])) {
    $sql = 'SELECT element_name, template FROM {xc_search_display_template_element}
      WHERE entity_type = :entity_type';

    if ($element_name != NULL) {
      // TODO Please convert this statement to the D7 database API syntax.
      $result = db_query($sql_with_name,array(':entity_type'=> $entity_type, ':element_name'=>$element_name));
    }
    else {
      // TODO Please convert this statement to the D7 database API syntax.
      $result = db_query($sql_without_name, array(':entity_type'=>$entity_type));
    }

    $val = NULL;
    if ($element_name != NULL) {
      $data = $result->fetchObject();
      $val = $data->template;
    }
    else {
      $val = array();
      foreach ($result as $data) {
        $val[$data->element_name] = $data->template;
      }
    }
    $template_element_cache[$entity_type][$key] = $val;
  }

  return $template_element_cache[$entity_type][$key];
}


/**
 * Prepare the item data for showing later
 *
 * @param $doc (Object)
 *   The Solr Document
 * @param $highlight_obj (Object)
 *   The highlight document
 * @param $i (int)
 *   Counter
 * @param $search_ui (Object)
 *   The XC Search UI object
 * @param $debug_mode (Boolean)
 *   Whether we have to use a debug mode
 *
 * @return (Array)
 *   The result item
 */
function xc_search_show_item_array($doc, $highlight_obj = NULL, $i = -1, $search_ui, $debug_mode = FALSE) {
  global $_xc_search_timing, $_xc_search_server;
  static $field_map, $params, $highlight_tags, $non_highlightable_fields;

  if (!isset($params)) {
    $params = xc_search_variable('solr_params');
  }

  timer_start('xc_search_data/hook_search/search/xc_search_do_search/xc_search_show_item_array/highlight');
  $xc_statistics_enabled = !empty($_xc_search_timing);
  $highlight = array();
  $abstract_highlights = array();
  if (!is_null($highlight_obj)) {
    if (!isset($non_highlightable_fields)) {
      $non_highlightable_fields = array_flip(array(
        'metadata_tsn',
        'serialized_tsn',
        'xc__workExpressed_t',
        'xc__expressionManifested_t',
      ));
    }

    foreach ($highlight_obj as $key => $value) {
      if (!isset($non_highlightable_fields[$key])) {
        if ($key == 'dcterms__abstract_txt') {
          $abstract_highlights = array_merge($abstract_highlights, $value);
        }
        else {
          $highlight = array_merge($highlight, $value);
        }
      }
    }
  }
  $highlight = array_unique($highlight);
  $abstract_highlights = array_unique($abstract_highlights);
  timer_stop('xc_search_data/hook_search/search/xc_search_do_search/xc_search_show_item_array/highlight');

  if ($xc_statistics_enabled) {
    $t1 = microtime(TRUE);
  }
  // TODO: use $doc->serialized_tsn

  timer_start('xc_search_data/hook_search/search/xc_search_do_search/xc_search_show_item_array/xc_record');
  $xc_record = unserialize($doc->metadata_tsn);
  $xc_record['id'] = $doc->id;

  if (!isset($field_map)) {
    $field_map = array(
      'node_id_i' => 'node_id',
      'node_type_s' => 'node_type',
      'metadata_id_s' => 'metadata_id',
      'metadata_type_s' => 'metadata_type',
      'type' => 'type',
      'source_id_s' => 'source_id',
      'bibid_s' => 'bibid',
    );
  }
  foreach ($field_map as $solr_field => $key) {
    if (isset($doc->$solr_field)) {
      $xc_record[$key] = $doc->$solr_field;
    }
  }

  // adding facet values
  $fields = $doc->getFieldNames();
  foreach ($fields as $field_name) {
    if (preg_match('/(.*?)_(fc|df)$/', $field_name, $matches)) {
      $xc_record[$matches[1]] = $doc->$field_name;
    }
  }
  timer_stop('xc_search_data/hook_search/search/xc_search_do_search/xc_search_show_item_array/xc_record');

  if ($xc_statistics_enabled) {
    $t_node = microtime(TRUE);
    $_xc_search_timing['solr_to_array'] += ($t_node - $t1);
  }
  if (empty($xc_record['node_id']) || $xc_record['node_id'] == 0) {
    timer_start('xc_search_data/hook_search/search/xc_search_do_search/xc_search_show_item_array/node_id');
    if (variable_get('xc_metadata_node_creation_finished', 0) != 1) {
      require_once drupal_get_path('module', 'xc_metadata') . '/includes/xc_metadata.postharvest.inc';
      $node_id = xc_metadata_create_node_for_metadata($xc_record['metadata_id']);
      $xc_record['node_id'] = $node_id;
    }
    else {
      $xc_record['node_id'] = _metadata_id_to_node_id($xc_record['metadata_id']);
    }
    timer_stop('xc_search_data/hook_search/search/xc_search_do_search/xc_search_show_item_array/node_id');
  }
  if ($xc_statistics_enabled) {
    $t2 = microtime(TRUE);
    $_xc_search_timing['create_node'] += ($t2 - $t_node);
  }

  $xc_record['admin']['debug_mode'] = (boolean) $debug_mode;
  timer_start('xc_search_data/hook_search/search/xc_search_do_search/xc_search_show_item_array/elements');
  $element = xc_search_get_display_template_elements($xc_record['type'], $xc_record);
  timer_stop('xc_search_data/hook_search/search/xc_search_do_search/xc_search_show_item_array/elements');

  if ($xc_statistics_enabled) {
    $t3 = microtime(TRUE);
    $_xc_search_timing['template_elements'] += ($t3 - $t2);
    $t4 = microtime(TRUE);
  }

  timer_start('xc_search_data/hook_search/search/xc_search_do_search/xc_search_show_item_array/xc_search_get_full_display_url');
  $xc_record += array(
    'full_display_url' => xc_search_get_full_display_url($xc_record, $i),
    'full_display_link' => xc_search_get_full_display_link($xc_record),
    'syndetics_ids' => xc_search_get_syndetics_identifiers($xc_record),
  );
  timer_stop('xc_search_data/hook_search/search/xc_search_do_search/xc_search_show_item_array/xc_search_get_full_display_url');

  if (isset($xc_record['syndetics_ids'])) {
    timer_start('xc_search_data/hook_search/search/xc_search_do_search/xc_search_show_item_array/syndetics');
    $xc_record['image_url'] = xc_search_get_syndetics_image(
      $xc_record['syndetics_ids']['ISBN'],
      $xc_record['syndetics_ids']['UPC'],
      $xc_record['syndetics_ids']['OCLC'],
      SYNDETICS_SMALL, TRUE
    );
    timer_stop('xc_search_data/hook_search/search/xc_search_do_search/xc_search_show_item_array/syndetics');
  }

  // Highlighting the abstract
  if (!empty($abstract_highlights)) {
    timer_start('xc_search_data/hook_search/search/xc_search_do_search/xc_search_show_item_array/abstract_highlighted');
    $abstract_highlighted = $element['abstract'];
    if (!isset($highlight_tags)) {
      $highlight_tags = array($params['hl.simple.pre'], $params['hl.simple.post']);
    }
    for ($j = 0; $j < count($abstract_highlighted); $j++) {
      foreach ($abstract_highlights as $abstract_highlight) {
        $pure = str_replace($highlight_tags, '', $abstract_highlight);
        $abstract_highlighted[$j] = str_replace($pure, $abstract_highlight, $abstract_highlighted[$j]);
      }
    }
    $element['abstract'] = $abstract_highlighted;
    $is_abstract_highlighted = TRUE;
    timer_stop('xc_search_data/hook_search/search/xc_search_do_search/xc_search_show_item_array/abstract_highlighted');
  }
  else {
    $is_abstract_highlighted = FALSE;
  }

  // set do_display_abstract
  $element['do_display_abstract'] = FALSE;
  if (!empty($element['abstract'])) {
    if ($search_ui->display_abstract_strategy == 'always') {
      $element['do_display_abstract'] = TRUE;
    }
    elseif ($search_ui->display_abstract_strategy == 'if_highlighted') {
      $element['do_display_abstract'] = $is_abstract_highlighted;
    }
    elseif ($search_ui->display_abstract_strategy == 'if_film') {
      $element['do_display_abstract'] = in_array(t('Films, videos'), $xc_record['format']);
    }
    elseif ($search_ui->display_abstract_strategy == 'if_film_highlighted') {
      $element['do_display_abstract'] = in_array(t('Films, videos'), $xc_record['format']) && $is_abstract_highlighted;
    }
  }

  // show these URLs only in debug mode
  if ($debug_mode) {
    if ($xc_statistics_enabled) {
      $t5 = microtime(TRUE);
    }
    timer_start('xc_search_data/hook_search/search/xc_search_do_search/xc_search_show_item_array/holdings');
    $holdings = _xc_get_holdings($xc_record, FALSE);
    timer_stop('xc_search_data/hook_search/search/xc_search_do_search/xc_search_show_item_array/holdings');

    $oclc_urls = array();
    if (!empty($xc_record['xc:recordID'])) {
      $oclc_urls = array_map(
        'xc_search_oclc_url',
        xc_util_get_metadata_value($xc_record['xc:recordID'], array('@type' => 'OCoLC'))
      );
    }

    $xc_record += array(
      'count_holdings' => count($holdings),
      'oclc_urls' => $oclc_urls,
      'solr_link' => xc_search_get_solr_link($xc_record),
      'sibling_link' => xc_search_get_sibling_link($xc_record),
      'mlt_link' => xc_search_get_mlt_link($xc_record),
      'remote_xml_link' => xc_search_get_remote_xml_link($xc_record),
      'schema_record_link' => l(t('XC Schema Record'), 'node/' . $xc_record['node_id'] . '/xc/schemaview'),
    );

    if ($xc_statistics_enabled) {
      if (!isset($_xc_search_timing['xml_links'])) {
        $_xc_search_timing['xml_links'] = 0;
      }
      $_xc_search_timing['xml_links'] += microtime(TRUE) - $t5;
    }
  }

  timer_start('xc_search_data/hook_search/search/xc_search_do_search/xc_search_show_item_array/theme_title');
  $title = theme('xc_search_metadata', array('xc_record' => $xc_record, 'element' => $element, 'display_type' => 'title', 'counter' => $i));
  timer_stop('xc_search_data/hook_search/search/xc_search_do_search/xc_search_show_item_array/theme_title');

  return array(
    'link' => $xc_record['full_display_url'],
    'title' => $title,
    'type' => 'XC Manifestation',
    'snippet' => '',
    'extra' => array(
      'xc_record' => $xc_record,
      'element' => $element,
      'counter' => $i,
      'syndetics_ids' => $xc_record['syndetics_ids'],
      'image_url' => $xc_record['image_url'],
      'node_id' => $xc_record['node_id'],
      'highlight' => !empty($highlight)
                  ? '&hellip; ' . join(' &hellip; <br /> &hellip; ', $highlight) . ' &hellip;'
                  : '',
      'ncip_item_ids' => xc_search_get_ncip_mappings($xc_record),
      'bookpost' => '', /*((module_exists('bookpost') && isset($xc_record['dcterms:identifier_ISBN'])
 && $xc_record['dcterms:identifier_ISBN'] != '')
 ? retrieve_bookdata_api($xc_record['dcterms:identifier_ISBN'])
 : NULL),*/
    ),
  );
}

/**
 * Preprocess 'xc_search_result_list_row' template
 * @param $variables
 * arguments:
 * - 'counter': the record counter
 * - 'node_id': the node id
 * - 'result': the result (from Search API)
 * - 'xc_record': the full XC record
 */
function template_preprocess_xc_search_result_list_row(&$variables) {
  timer_start('template_preprocess_xc_search_result_list_row');
  $variables['result']['snippet'] = theme('xc_search_metadata', array(
      'xc_record' => $variables['xc_record'],
      'element' => $variables['result']['extra']['element'],
      'display_type' => 'snippet',
      'counter' => $variables['result']['extra']['counter'],
      'params' => array(),
    )
  );

  $variables['result']['extra']['id'] = $variables['xc_record']['id'];

  if ($variables['xc_record']['node_type'] == 'xc_manifestation') {
    $more_less_divider = 80 * 3;
    $abstract = xc_util_conditional_join(', ', $variables['result']['extra']['element']['abstract']);
    if (strlen($abstract) <= $more_less_divider) {
      $variables['result']['extra']['element']['abstract'] = $abstract;
    }
    else {
      $delimiter = '<delim>';
      $lines = explode($delimiter, wordwrap($abstract, 80, $delimiter));
      $variables['result']['extra']['element']['abstract'] = join(' ', array_slice($lines, 0, 3));
      $variables['result']['extra']['element']['abstract_more'] = join(' ', array_slice($lines, 3));
    }
  }

  // Attributes for row element
  $variables['attributes'] = drupal_attributes($variables['attributes']);
  timer_stop('template_preprocess_xc_search_result_list_row');
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_get_syndetics_identifiers($xc_record) {
  global $_xc_search_timing;
  static $image_cache;

  $xc_statistics_enabled = !empty($_xc_search_timing);
  if ($xc_statistics_enabled) {
    $t = microtime(TRUE);
  }

  if (!isset($image_cache[$xc_record['node_id']])) {
    $image_cache[$xc_record['id']] = '';
    $xc_syndetics_identifier_fields = xc_search_get_xc_syndetics_identifier_fields();
    foreach ($xc_syndetics_identifier_fields as $field => $type) {
      if ($xc_statistics_enabled) {
        $t8_1 = microtime(TRUE);
      }
      if (!isset($xc_record[$field])) {
        $image_cache[$xc_record['node_id']][$type['label']] = '';
        continue;
      }
      $IDs = xc_util_get_metadata_value($xc_record[$field], $type['filter']);
      if ($type['label'] == 'OCLC') {
        $IDs = array_map('xc_util_remove_spaces', $IDs);
      }
      if ($xc_statistics_enabled) {
        $t8_2 = microtime(TRUE);
        $_xc_search_timing['images_extract_fields'] += ($t8_2 - $t8_1);
      }
      $image_cache[$xc_record['node_id']][$type['label']] = join(',', $IDs);
    }
  }

  if ($xc_statistics_enabled) {
    $_xc_search_timing['images_identifiers'] += (microtime(TRUE) - $t);
  }

  $output = $image_cache[$xc_record['node_id']];
  return $output;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_get_remote_xml_link($xc_record) {
  if ($xc_record['source_id']) {
    $schedule_id = _source_id_to_schedule_id($xc_record['source_id']); // bridge
    $schedule    = _oaiharvester_schedule_get($schedule_id);
    $oai_url     = _oaiharvester_provider_get_url_by_id($schedule->provider_id);
  }
  else {
    $oai_url = _oaiharvester_provider_get_url_by_id(6);
  }
  $remote_xml_link = l(
    'remote xml',
    $oai_url,
    array(
    'query' => 'verb=GetRecord&identifier=' . $xc_record['id'] . '&metadataPrefix=xc',
    'absolute' => TRUE,
  )
  );
  return $remote_xml_link;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_get_solr_link($xc_record) {
  global $_xc_search_server;
  return l(
    'solr link',
    // $_xc_search_server->getUrl(),
    'http://' . $_SERVER['SERVER_NAME'] . ':' . $_xc_search_server->getPort()
      . $_xc_search_server->getPath() . 'select',
    array('query' => 'q=id:"' . $xc_record['id'] . '"')
  );
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_get_sibling_link($xc_record) {
  global $_xc_search_server;

  $link = FALSE;
  $workExpressed = $xc_record['xc:workExpressed'];
  if (isset($workExpressed) && !empty($workExpressed)) {
    if (!is_array($workExpressed)) {
      $workExpressed = array($workExpressed);
    }
    $ids = array();
    foreach ($workExpressed as $instance) {
      $ids[] = $instance['#value'];
    }
    $query = 'xc__workExpressed_t:("' . join('" OR "', $ids) . '")';
    $response = $_xc_search_server->search($query, 0, 0, array());
    $siblings_total = $response->response->numFound - 1;
    if ($siblings_total > 0) {
      $link = l($siblings_total . ' sibling items', '/xc/search/' . $query);
    }
  }
  return $link;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_get_mlt_link($xc_record) {
  return l(
    'more like this',
    'xc/search/id:"' . $xc_record['id'] . '"',
    array('query' => 'search_type=mlt')
  );
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_get_full_display_url($xc_record, $hit = -1) {
  static $allowed_callers = array(
    'xc-browse' => 1,
    'xc-search' => 1,
    'bookmark' => 1,
    'check-out' => 1,
    'request' => 1,
  );
  $debug = (isset($_GET['debug']) && $_GET['debug'] == 1);

  if (preg_match('{^xc_browse\b}', $_GET['q'])) {
    $caller = 'xc-browse';
  }
  elseif (preg_match('{^(search\/xc_search|xc\/search)\b}', $_GET['q'])
       && !preg_match('{^search\/xc_search\/full\b}', $_GET['q'])) {
    $caller = 'xc-search';
  }
  elseif (preg_match('{^user\b}', $_GET['q'])) {
    $caller = 'my-account';
  }
  elseif (isset($_GET['caller']) && isset($allowed_callers[$_GET['caller']])) {
    $caller = $_GET['caller'];
  }
  else {
    $caller = 'xc-search';
  }

  $query = array(
    'hit' => $hit,
    'caller' => $caller,
  );
  if ($debug) {
    $query['debug'] = 1;
  }

  // TODO The second parameter to this function call should be an array.
  return url(
    xc_search_get_full_display_path($xc_record),
    array(
    'absolute' => TRUE,
    'query' => $query,
  )
  );
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_get_full_display_link($xc_record) {
  return l(t('full display'), xc_search_get_full_display_path($xc_record));
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_get_full_display_path($xc_record) {
  static $check_node;

  if (!isset($check_node)) {
    $check_node = variable_get('xc_search_check_node', 0);
  }
  // this is needs when the MySQL and Solr in not in sync, so there is node
  // referenced from the record
  $use_node = TRUE;
  if ($use_node) {
    if ($check_node) {
      $node_exists = xc_util_node_exists($xc_record['node_id']);
      $link = ($node_exists)
        ? 'node/' . $xc_record['node_id']
        : 'admin/xc/search/full/' . base64_encode($xc_record['id']);
    }
    else {
      $link = 'node/' . $xc_record['node_id'];
    }
  }
  else {
    $link = 'admin/xc/search/full/' . base64_encode($xc_record['id']);
  }
  return $link;
}

/**
 * Populate the NCIP identifiers by NCIP servers, like serverID => bib identifier
 *
 * @param $xc_record (Array)
 *   The metadata record
 *
 * @return (Array)
 *   An associted array of NCIP provider IDs and bibliographical identifiers
 */
function xc_search_get_ncip_mappings($xc_record) {
  static $xc_search_xc_ils_mappings;

  $identifier_int = xc_util_get_identifier_int($xc_record['id']);
  $xc_search_xc_ils_mappings = xc_ils_get_all_mappings();

  $mapping = array();
  foreach ($xc_search_xc_ils_mappings as $field_name => $property_sets) {
    foreach ($property_sets as $properties) {
      // get the org code
      $org_code = FALSE;
      if ($field_name == 'xc:recordID' && isset($properties['filter']['@type'])) {
        $org_code = $properties['filter']['@type'];
      }

      // bibid is came from index
      if (isset($xc_record['bibid'])) {
        $bib_id = $xc_record['bibid'];
      }
      // bibid is came from settings
      elseif (isset($xc_record[$field_name])) {
        $filter = $properties['filter'] ? $properties['filter'] : array();
        $identifiers = xc_util_get_metadata_value($xc_record[$field_name], $filter);
        $bib_id = $identifiers[0];
      }

      $mapping[$identifier_int][] = array(
        'bib_id' => $bib_id,
        'ncip_provider_id' => $properties['ncip_provider_id'],
        'org_code' => $org_code,
      );
    }
  }
  return $mapping;
}

/**
 * Shows a) a histogram of the first 100 facet terms b) list of all
 * facet terms by 100 term per page.
 */
function xc_search_show_more_facets() {

  $query = $_GET['query'];
  $facet = $_GET['facet'];
  if (!preg_match('/^[a-z]\w+_fc$/', $facet)) {
    return t('Sorry, %this is not a valid facet name.', array('%this' => $facet));
  }
  $index_facet = xc_index_facet_load_by_name(preg_replace('/_fc/', '', $facet));
  drupal_set_title(t('Terms of %facet for filtered query %query', array('%facet' => $index_facet->label, '%query' => $query)), PASS_THROUGH);

  $filters = !empty($_GET['filter']) ? $_GET['filter'] : array();
  $offset = !empty($_GET['offset']) ? intval($_GET['offset']) : 0;

  $checkbox_options = xc_search_block_checkbox_options();
  $online_only = $checkbox_options['online_only'];
  $exclude_microform = $checkbox_options['exclude_microform'];
  if ($online_only == 1) {
    $filters[] = 'format_fc:"Online"';
  }
  if ($exclude_microform == 1) {
    $filters[] = 'format_fc:"Not microform"';
  }

  /*
   $prohibited_types = array('work', 'expression', 'holdings', 'item');
   foreach ($prohibited_types as $type) {
   if (!in_array('-type:' . $type, $filters)) {
   $filters[] = '-type:' . $type;
   }
   }
   */

  $params = array(
    'facet' => 'on',
    'facet.field' => $facet,
    'facet.mincount' => 1,
    'facet.offset' => $offset,
    'facet.limit' => 100,
    'facet.missing' => 'on',
    'fq' => array_unique($filters),
  );

  $url_params = xc_search_get_params();
  unset($url_params['facet']);
  unset($url_params['query']);
  unset($url_params['page']);
  unset($url_params['offset']);
  $url_queries = http_build_query($url_params);
  $response = $GLOBALS['_xc_search_server']->search($query, 0, 0, $params, FALSE);
  $terms = array();
  if (isset($response->facet_counts->facet_fields)
       && isset($response->facet_counts->facet_fields->$facet)) {
    foreach ($response->facet_counts->facet_fields->$facet as $term => $count) {
      if ($count == 0) {
        continue;
      }
      if ($term == '_empty_') {
        $items[] = t('no value') . ' (' . $count . ')';
      }
      else {
        $terms[] = array($term, $count);
        $query_params = $url_params;
        $query_params['filter[]'] = $facet . ':"' . $term . '"';
        $items[] = l($term, 'xc/search/' . $query, array('query' => $query_params))
          . ' (' . $count . ')';
      }
    }
    $output = '<div id="jschart_' . $facet . '"></div>';
    $output .= theme('item_list', array('items' => $items));
    $drupal_get_destination = drupal_get_destination();
    $navigation_link = $drupal_get_destination['destination'];
    list($path, $url_queries) = explode('?', $navigation_link);
    $url_queries = preg_replace('/(?:^|&)offset=[^&]*(&|$)/', '$1', $url_queries);
    $navigation_links = array();
    $query_params = $url_params;
    if ($offset > 0) {
      $query_params['offset'] = ($offset - $params['facet.limit']);
      $navigation_links[] = l(t('Previous terms') . '<', $path, array('query' => $query_params));
    }
    if (count($items) >= $params['facet.limit']) {
      $query_params['offset'] = ($offset + $params['facet.limit']);
      $navigation_links[] .= l('>' . t('Next terms'), $path, array('query' => $query_params));
    }
    if (!empty($navigation_links)) {
      $output .= join(' &mdash; ', $navigation_links);
    }
    if ($offset == 0) {
      drupal_add_js(drupal_get_path('module', 'xc_search') . '/js/jscharts.js');
      drupal_add_js(drupal_get_path('module', 'xc_search') . '/js/show_more_facets.js');
      drupal_add_js(array('xc_search' => array(
          'facet_array' => $terms,
          'facet_name' => $facet,
          'facet_label' => $index_facet->label,
          'facet_count' => min(count($terms), 100),
        )), array('type' => 'setting', 'scope' => JS_DEFAULT));
    }
  }
  else {
    $output = t('No terms in that facet');
  }

  return $output;
}

/**
 * Implements hook_block_info().
 */
function xc_search_block_info() {

  $search_and_browse_pages = $search_pages = array(
    'search/xc_search',
    'search/xc_search/*',
    'xc/search',
    'xc/search/*',
  );
  $search_and_browse_pages[] = 'xc_browse/*';
  $search_and_browse_pages[] = 'user/*/bookmarked-items';
  $search_and_browse_page_top = $search_and_browse_pages;
  $search_and_browse_page_top[] = 'node/*';
  
  $blocks['facet_checkboxes'] = array(
    'info' => t('XC facet checkboxes'),
    'region' => 'sidebar_first',
    'status' => TRUE,
    'visibility' => 1,
    'pages' => join("\n", $search_pages),
    'cache' => DRUPAL_NO_CACHE,
  );

  $blocks['facet_activefilters'] = array(
    'info' => t('XC facet active filters'),
    'region' => 'sidebar_first',
    'status' => TRUE,
    'visibility' => 1,
    'pages' => join("\n", $search_pages),
    'cache' => DRUPAL_NO_CACHE,
  );

  $blocks['facets'] = array(
    'info' => t('XC facets'),
    'region' => 'sidebar_first',
    'status' => TRUE,
    'visibility' => 1,
    'pages' => join("\n", $search_pages),
    'cache' => DRUPAL_NO_CACHE,
  );

  $blocks['xc_search_form'] = array(
    'info' => t('XC search form'),
    'region' => 'header',
    'status' => TRUE,
    'visibility' => 1,
    'pages' => join("\n", $search_pages),
    'cache' => DRUPAL_NO_CACHE,
  );

  $blocks['serp_info_bar_top'] = array(
    'info' => t('XC search result list command bar on top'),
    'region' => 'content',
    'weight' => -17,
    'status' => TRUE,
    'visibility' => 1,
    'pages' => join("\n", $search_and_browse_page_top),
    'cache' => DRUPAL_NO_CACHE,
  );

  $blocks['serp_info_bar_bottom'] = array(
    'info' => t('XC search result list command bar on bottom'),
    'region' => 'content',
    'weight' => 17,
    'status' => TRUE,
    'visibility' => 1,
    'pages' => join("\n", $search_and_browse_pages),
    'cache' => DRUPAL_NO_CACHE,
  );

  $blocks['result_navigation_top'] = array(
    'info' => t('XC search result navigation (top)'),
    'region' => -1,
    'status' => FALSE,
    'visibility' => 1,
    'pages' => "node/*",
    'cache' => DRUPAL_NO_CACHE,
  );

  $blocks['result_navigation_bottom'] = array(
    'info' => t('XC search result navigation (bottom)'),
    'region' => -1,
    'status' => FALSE,
    'visibility' => 1,
    'pages' => "node/*",
    'cache' => DRUPAL_NO_CACHE,
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function xc_search_block_view($delta) {
  include_once 'searching/xc_search_block.inc';
  $destination = drupal_get_destination();
  $path = $destination['destination'];

  switch ($delta) {
    case 'facets':
      if (empty($_POST)) {
        $result = xc_search_block_facets($path);
      }
      break;

    case 'facet_checkboxes':
      $result = xc_search_block_facet_checkboxes($path);
      break;

    case 'facet_activefilters':
      $result = xc_search_block_facet_activefilters($path);
      break;

    case 'xc_search_form':
      include_once drupal_get_path('module', 'xc_search') . '/xc_search.pages.inc';
      $query = '';

      if (arg(0) == 'node') {
        $xc_search_frd = xc_search_get_full_record_display_options();
        if (!drupal_is_front_page() && $xc_search_frd->show_search_form == 0) {
          break;
        }

        // get from session
        $caller = xc_get_caller();

        // do not apply in browse context
        if ($caller['module'] == 'xc_browse' || ($caller['use_default'] == TRUE && !drupal_is_front_page())) {
          break;
        }

        // get query only on given pages
        if ($caller['module'] == 'xc_search' && !$caller['use_default']) {
          $query = $_SESSION['xc_search_query'][$caller['module']]['query'];
        }
      }
      else {
        $query = search_get_keys();
      }

      if ($query == '*:*') {
        $query = '';
      }

      $result = array(
        'subject' => '',
        'content' => drupal_get_form('xc_search_form', NULL, $query, 'xc_search'),
      );
      break;

    case 'result_navigation_top':
      $result = xc_search_block_result_navigation(arg(1), 'top');
      break;

    case 'result_navigation_bottom':
      $result = xc_search_block_result_navigation(arg(1), 'bottom');
      break;

    case 'serp_info_bar_top':
      $xc_search_frd = xc_search_get_full_record_display_options();
      if ($xc_search_frd->show_navigation == 0) {
        break;
      }
      if (!(arg(0) == 'node' && arg(2) . '/' . arg(3) == 'xc/schemaview')) {
        $result = xc_search_block_info_bar('top');
      }
      break;

    case 'serp_info_bar_bottom':
      $xc_search_frd = xc_search_get_full_record_display_options();
      if ($xc_search_frd->show_navigation == 0) {
        break;
      }
      $result = xc_search_block_info_bar('bottom');
      break;

    default:
      break;
  } // view case

  return $result;
}

/**
 * Implements hook_block().
 *
 * We currently have two blocks: 'XC facets' (for facets) and 'XC search result
 * navigation' (for search result navigation).
 *
 * @param $op (String)
 *   Operation to run
 * @param $delta (int)
 *   Which block are we talking about
 * @param $edit
 */
function xc_search_block_OLD($op = 'list', $delta = 0, $edit = array()) {
  // TODO Remaining code in this function needs to be moved to the appropriate new hook function.
  timer_start('block/' . $op);
  timer_start('block/' . $op . '/' . $delta);
  $t = microtime(TRUE);
  $result = '';
  timer_stop('block/' . $op . '/' . $delta);
  timer_stop('block/' . $op);
  return $result;
}

/**
 * Transforms the raw query string into a human readable format.
 *
 * @param $query (string)
 *   The query in raw Lucene syntax
 *
 * @return (string)
 *   The human readable format.
 */
function xc_search_display_query($query) {
  $query = preg_replace('/\btype:manifestation(\b|$)/', ' ', $query);
  $query = preg_replace_callback(
    '/([a-zA-Z0-9]+)__?([a-zA-Z0-9]+)_([a-zA-Z0-9]{1,2}):(\()(.*?)\)/',
    'xc_search_translate_field', $query);
  $query = preg_replace_callback(
    '/([a-zA-Z0-9]+)__?([a-zA-Z0-9]+)_([a-zA-Z0-9]{1,2}):(")(.*?)"/',
    'xc_search_translate_field', $query);
  $query = preg_replace_callback('/\(([^\)]+ (OR|AND|NOT) [^\)]+)\)/',
    'xc_search_display_query_remove_booleans', $query);
  /*
   $query = preg_replace_callback('/^([a-zA-Z0-9]+_[a-zA-Z0-9]+)_(?:fc|df):"(.*?)"/',
   'xc_search_translate_facet', $query);
   */
  $query = preg_replace('/^\s*\(|\)\s*$/', '', $query);
  $query = preg_replace('/\\\/', '', $query);
  return $query;
}

/**
 * Translates an XC field query in Lucene syntax into a human readable format.
 *
 * A typucal XC field query: dcterms__title_s:"King Lear". It is parsed into an array:
 * ['dcterms__title_s:"King Lear"', 'dcterms', 'title', 's', '"King Lear"'].
 * It became title: "King Lear"
 *
 * @param $matches (array)
 *   The XC query in lucene syntax parsed into an array of 5 elements.
 *   The elements are: the full query, namespace, field name, field type, query term.
 *
 *  @return (string)
 *    A human readable, translatable string, such as 'title: "King Lear"'.
 */
function xc_search_translate_field($matches) {
  $field_type = $matches[3];

  if ($field_type == 'fc' || $field_type == 'df') {
    $field = xc_index_facet_load_by_name($matches[1] . '_' . $matches[2]);
  }
  else {
    $field = xc_metadata_field_get($matches[2], $matches[1]);
    if (!empty($field->title)) {
      $field->label = $field->title;
    }
    else {
      $field = xc_search_field_load_proxy($matches[1] . ':' . $matches[2]);
    }
  }
  $output = t($field->label) . ': ';

  if ($matches[4] == '"') {
    $output .= '"' . $matches[5] . '"';
  }
  else {
    $output .= $matches[5];
  }

  return $output;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_translate_facet($matches) {
  $index_facet = xc_index_facet_load_by_name($matches[1]);
  return t($index_facet->label) . ': ' . $matches[2];
}

// function xc_search_get_field($solr_field)

/*
 function xc_search_display_query_remove_booleans($matches) {
 $separator = ' ' . $matches[2] . ' ';
 return join($separator, array_unique(explode($separator, $matches[1])));
 }
 */

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_display_query_remove_booleans($matches) {
  $boolean_expression = $matches[1];
  $boolean_operator = $matches[2];
  $separator = ' ' . $boolean_operator . ' ';
  $queries = explode($separator, $boolean_expression);
  $map = array();
  foreach ($queries as $query) {
    list($field, $value) = explode(': ', $query, 2);
    $map[$value][] = $field;
  }
  $new_format_queries = array();
  foreach ($map as $value => $fields) {
    $new_format_queries[] = $value . ' as ' . join(', ', array_unique($fields));
  }
  return join(', ', $new_format_queries);
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_field_load_proxy($name) {
  switch ($name) {
    case 'rdarole:artist':
      return (object) array('label' => 'artist');
      break;
    case 'rdarole:author':
      return (object) array('label' => 'author');
      break;
    case 'rdarole:compiler':
      return (object) array('label' => 'compiler');
      break;
    case 'rdarole:composer':
      return (object) array('label' => 'composer');
      break;
    case 'rdarole:speaker':
      return (object) array('label' => 'speaker');
      break;
    case 'xc:creator':
      return (object) array('label' => 'creator');
      break;
    case 'dcterms:creator':
      return (object) array('label' => 'creator');
      break;
    case 'rdarole:editor':
      return (object) array('label' => 'editor');
      break;
    case 'rdarole:illustrator':
      return (object) array('label' => 'illustrator');
      break;
    case 'xc:creator':
      return (object) array('label' => 'creator');
      break;
    case 'rdarole:director':
      return (object) array('label' => 'director');
      break;
    case 'rdarole:performer':
      return (object) array('label' => 'performer');
      break;
    case 'rdarole:producer':
      return (object) array('label' => 'producer');
      break;
    case 'rdarole:translator':
      return (object) array('label' => 'translator');
      break;
    case 'xc:contributor':
      return (object) array('label' => 'contributor');
      break;
    case 'dcterms:contributor':
      return (object) array('label' => 'contributor');
      break;
    case 'dcterms:publisher':
      return (object) array('label' => 'publisher');
      break;
    case 'rdvocab:placeOfProduction':
      return (object) array('label' => 'place of production');
      break;

    default:
      xc_log_error('xc search', 'field without title: ' . $name);
      return (object) array('label' => $name);
      break;
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_remove_date_filter($filters, $facet_name) {
  $result = array();
  foreach ($filters as $filter) {
    if (!preg_match('/^' . $facet_name . ':/', $filter)) {
      $result[] = $filter;
    }
  }
  return $result;
}

/**
 * Static getter/setter for the current query
 * COPY OF apachesolr_current_query
 */
function xc_search_current_query($query = NULL) {
  static $saved_query = NULL;
  if (is_object($query)) {
    $saved_query = clone $query;
  }
  elseif (!empty($query)) {
    $saved_query = $query;
  }

  //return empty($saved_query) ? $saved_query : clone $saved_query;
  return $saved_query;
}

/**
 * Get all facets belongs to the same facet group
 * @param $facet_id (int)
 *   The id of facet group
 * @return (Array)
 *   Array of facet objects. Object properties: field_id, name, label, type
 *     ('field', 'date' or 'query'), facet_id (=facet group id),
 *     attribute_set_id, weight.
 */
function xc_search_facets_by_group($facet_id) {
  $sql = 'SELECT field.*, facet.label
    FROM {xc_search_facet_field} AS field
    INNER JOIN {xc_index_facet} AS facet ON (field.name = facet.name)
    WHERE field.facet_id = %d
    ORDER BY field.weight, field_id';
  $result = db_query('SELECT field.*, facet.label
    FROM {xc_search_facet_field} AS field
    INNER JOIN {xc_index_facet} AS facet ON (field.name = facet.name)
    WHERE field.facet_id = :facet_id
    ORDER BY field.weight, field_id', array(':facet_id' => $facet_id));
  $fields = array();
  //while ($data = db_fetch_object($result)) {
  foreach ($result as $data) {
    $fields[] = $data;
  }
  return $fields;
}

/**
 * Implements hook_form_[form_id]_alter().
 */
function xc_search_form_search_theme_form_alter(&$form, $form_state) {
  xc_search_form_search_block_form_alter($form, $form_state);
}

/**
 * Implements hook_form_[form_id]_alter().
 */
function xc_search_form_search_block_form_alter(&$form, $form_state) {
  //if (variable_get('xc_search_make_default', 0)) {
  if (!isset($form['#submit'])) {
    $form['#submit'] = array('xc_search_search_box_form_submit');
  }
  else {
    $key = array_search('search_box_form_submit', $form['#submit']);
    if ($key !== FALSE) {
      // Replace the search module's function.
      $form['#submit'][$key] = 'xc_search_search_box_form_submit';
    }
  }
}

/**
 * Process a block search form submission.
 */
function xc_search_search_box_form_submit($form, &$form_state) {
  $form_id = $form['form_id']['#value'];
  $keys = $form_state['values'][$form_id];
  // Handle Apache webserver clean URL quirks.
  if (variable_get('clean_url', '0')) {
    $keys = str_replace('+', '%2B', $keys);
  }
  $form_state['redirect'] = 'xc/search/' . trim($keys);
}

/**
 * Added form submit function to account for Apache mode_rewrite quirks.
 *
 * @see xc_search_form_search_form_alter()
 */
function xc_search_form_search_submit($form, &$form_state) {
  $base = 'xc/search/';
  $values = $form_state['values'];
  $submit_by_button = isset($form['basic']['#post']['op']);

  if (isset($form['basic']['#post']['op'])
       && $form['basic']['#post']['op'] == t('Start new search')) {
    $form_state['redirect'] = $base;
  }
  else {
    $posted_values = $form_state['clicked_button']['#post'];
    $keys = $values['processed_keys'];
    // TODO:
    /*
     $escaping_strategy = xc_search_get_escaping_strategy();
     if ($escaping_strategy == 'escape_everything') {
     $keys = xc_search_escape_query($keys);
     }
     // other cases
     ...
     */
    $original_state = $values['original_state'];
    $query = '';
    // $base = 'search/' . $values['module'] . '/';
    if (variable_get('clean_url', '0')) {
      $keys = str_replace('+', '%2B', $keys);
    }
    $params = array();
    if (!$submit_by_button) {
      if (!empty($_GET['filter'])) {
        foreach ($_GET['filter'] as $filter) {
          $params['filter'][] = $filter;
        }
      }
    }

    /*
     if (!empty($posted_values['reuse_filter']) && $posted_values['filter']) {
     $filters = unserialize($posted_values['filter']);
     foreach ($filters as $filter) {
     $params[] = 'filter[]=' . rawurlencode($filter);
     }
     // $params[] = 'reuse_filter=1';
     }
     */
    if (!empty($values['sort'])) {
      $params['sort'] = $values['sort'];
    }
    if (!empty($values['rows'])) {
      $params['rows'] = $values['rows'];
    }
    if (!empty($values['is_query_link']) && $values['is_query_link'] == 1) {
      $params['ql'] = 1;
    }
    if (!empty($original_state)) {
      foreach ($original_state as $key => $value) {
        $params['os'][$key] = $value;
      }
    }
    if (isset($values['online_only'])) {
      $params['online_only'] = intval($values['online_only']);
    }
    if (isset($values['exclude_microform'])) {
      $params['exclude_microform'] = intval($values['exclude_microform']);
    }
    if (isset($values['hidden_filters'])) {
      $hidden_filters = unserialize($values['hidden_filters']);
      if (!empty($hidden_filters)) {
        foreach ($hidden_filters as $filter) {
          $params['filter'][] = $filter;
        }
      }
    }
    $query = $params;

    $form_state['redirect'] = array($base . $keys, array('query' => $query));
    if ($keys == '' && empty($query)) {
      form_set_error('keys', t('Please enter some keywords.'));
    }
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_get_attribute_set($type, $attribute_set_id) {
  switch ($type) {
    case 'query':
      return xc_search_query_facet_properties_load($attribute_set_id);
      break;
    case 'date':
      return xc_search_date_facet_properties_load($attribute_set_id);
      break;
    case 'field':
    default:
      return xc_search_field_facet_properties_load($attribute_set_id);
      break;
  }
}

/**
 *
 * @param $type
 * @param $properties
 * @param $facet_name
 * @return unknown_type
 */
function xc_search_facet_properties2solr_params($type, $properties, $facet_name) {
  // TODO (from Tom): the error start to show up drupal_http_build_query()
  require_once 'searching/xc_search_properties2solr_params.inc';
  switch ($type) {
    case 'query':
      return xc_search_query_facet_properties2solr_params($properties, $facet_name);
      break;
    case 'date':
      return xc_search_date_facet_properties2solr_params($properties, $facet_name);
      break;
    case 'field':
    default:
      return xc_search_field_facet_properties2solr_params($properties, $facet_name);
      break;
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_solr_doc_load($id) {
  static $cache;

  if (!isset($cache[$id])) {
    $id = base64_decode($id);
    $result = xc_search_do_solr_search('id:"' . $id . '"');
    $cache[$id] = $result['docs'][0];
  }

  return $cache[$id];
}

/**
 * Get the teaser of a document
 *
 * @param $doc (Solr document)
 *   The Solr document as source
 * @param $get_availability (Boolean)
 *   Whether or not get the get availability line
 *
 * @return (String)
 *   The teaser (the title and snippet of the metadata record)
 */
function xc_search_teaser($doc, $get_availability = FALSE) {
  $xc_record = _xc_solr_to_array($doc);
  $xc_record['full_display_url'] = xc_search_get_full_display_url($xc_record, 1);
  $element   = xc_search_get_display_template_elements($xc_record['type'], $xc_record);
  $variables = array('xc_record' => $xc_record, 'element' => $element, 'display_type' => 'title', 'counter' => 1);

  $content  = theme('xc_search_metadata', $variables);
  $content .= theme('xc_search_metadata', array('xc_record' => $xc_record, 'element' => $element, 'display_type' => 'snippet', 'counter' => 1, 'params' => array('get_availability' => $get_availability)));

  return $content;
}

/**
 * Prepare full record display
 *
 * @param $xc_record
 * @param $doc (Object) -- for legacy and testing support
 *   A Solr Document
 */
function xc_search_full($xc_record, $doc = NULL) {
  global $user;
  timer_start('xc_search_full');

//  $xc_record = _xc_solr_to_array($doc);
  $element = xc_search_get_display_template_elements($xc_record['type'], $xc_record);
  drupal_set_title(xc_util_conditional_join(' &mdash; ', $element['title']));

  timer_start('xc_search_full/holdings');
  timer_start('xc_search_full/holdings/_xc_get_holdings');
  $holdings = _xc_get_holdings($xc_record, FALSE);
  timer_stop('xc_search_full/holdings/_xc_get_holdings');
  $xc_search_frd = xc_search_get_full_record_display_options();

  $xc_record['holdings_use_table'] = $xc_search_frd->holdings_use_table;
  if ($xc_search_frd->holdings_use_table) {
    timer_start('xc_search_full/holdings/holdings_use_table');
    $xc_record['holdings_summary'] = array();
    foreach ($holdings as $holding) {
      if (!empty($holding['xc:textualHoldings'])) {
        foreach ($holding['xc:textualHoldings'] as $textualHolding) {
          $xc_record['holdings_summary'][] = array(
            'location' => xc_search_get_location($holding['xc:location'][0]['#value']),
            'callNumber' => $holding['xc:callNumber'][0]['#value'],
            'textualHolding' => $textualHolding['#value'],
          );

          if (!$xc_search_frd->holdings_list_all) {
            break;
          }
        }
      }
      else {
        $xc_record['holdings_summary'][] = array(
          'location' => xc_search_get_location($holding['xc:location'][0]['#value']),
          'callNumber' => $holding['xc:callNumber'][0]['#value'],
          'textualHolding' => '',
        );
      }
    }
    timer_stop('xc_search_full/holdings/holdings_use_table');
  }
  else {
    timer_start('xc_search_full/holdings/holdings_list');
    $holdings_summary = array();
    foreach ($holdings as $holding) {
      if (!empty($holding['xc:textualHoldings'])) {
        $location = xc_search_get_location($holding['xc:location'][0]['#value']);
        if ($xc_search_frd->holdings_list_all == TRUE) {
          $textualHoldings = array();
          foreach ($holding['xc:textualHoldings'] as $textualHolding) {
            $textualHoldings[] = $textualHolding['#value'];
          }
          $value = join(', ', $textualHoldings);
        }
        else {
          $value = $holding['xc:textualHoldings'][0]['#value'];
        }
        $holdings_summary[] = sprintf('<em>%s</em>: %s', $location, $value);
      }
    }

    if (!empty($holdings_summary)) {
      $xc_record['holdings_summary'] = $holdings_summary;
    }
    timer_stop('xc_search_full/holdings/holdings_list');
  }
  timer_stop('xc_search_full/holdings');

  //$xc_record['remote_xml_link'] = xc_search_get_remote_xml_link($xc_record);
  timer_start('xc_search_full/syndetics');
  if (module_exists('syndetics')) {
    timer_start('xc_search_full/syndetics/xc_search_get_syndetics_identifiers');
    $syndetics_ids = xc_search_get_syndetics_identifiers($xc_record);
    timer_stop('xc_search_full/syndetics/xc_search_get_syndetics_identifiers');
    $xc_record += array(
      'syndetics_ids' => $syndetics_ids,
      'image_url_large' => xc_search_get_syndetics_image($syndetics_ids['ISBN'], $syndetics_ids['UPC'], $syndetics_ids['OCLC'], SYNDETICS_LARGE, FALSE),
      'image_url_medium' => xc_search_get_syndetics_image($syndetics_ids['ISBN'], $syndetics_ids['UPC'], $syndetics_ids['OCLC'], SYNDETICS_MEDIUM, FALSE),
    );

    if ($xc_record['image_url_medium'] == '') {
      $syndetics_ids['large'] = 1;
      $image_info[$xc_record['node_id']] = $syndetics_ids;
    }

    timer_start('xc_search_full/syndetics/syndetics_get_object');
    $xc_record['summary'] = syndetics_get_object($syndetics_ids, SYNDETICS_TYPE_COMPLEX, 'SUMMARY');
    timer_stop('xc_search_full/syndetics/syndetics_get_object');
  }
  timer_stop('xc_search_full/syndetics');

  timer_start('xc_search_full/enhancements');
  $xc_record['enhancements'] = module_invoke_all('xc_display_full', 'enhance', $xc_record);
  timer_stop('xc_search_full/enhancements');

  /*
   foreach (module_implements('xc_display_full') as $module) {
   $function = $module . '_' . $hook;
   $xc_record['enhancements'][] = $function('enhance', $xc_record);
   }
   */

  $is_online = FALSE;
  if (isset($xc_record['dcterms:identifier'])) {
    $is_online = xc_util_contains_url(xc_util_get_metadata_value($xc_record['dcterms:identifier']));
  }

  if (!$is_online) {
    // get status
    $ncip_ids = xc_search_get_ncip_mappings($xc_record);

    // here was the code of NCIP...
    $_SESSION['xc_full'] = $token = drupal_get_token(__FUNCTION__);
    drupal_add_js(array('xc_search' => array(
        'ncip_bibs' => $ncip_ids,
        'token' => $token,
      )), array('type' => 'setting', 'scope' => JS_DEFAULT));
  }

  // get more like this
  $filters = array();
  /*
   $prohibited_types = array('work', 'expression', 'holdings', 'item');
   foreach ($prohibited_types as $type) {
   if (!in_array('-type:' . $type, $filters)) {
   $filters[] = '-type:' . $type;
   }
   }
   */

  timer_start('xc_search_full/mlt');
  $params = array(
    'fq' => $filters,
    'search_type' => 'mlt',
    'XCNAME' => 'mlt',
  );
  $params += xc_search_mlt_params();
  $query = 'id:"' . $xc_record['id'] . '"';
  $rows = isset($params['mlt.count']) ? $params['mlt.count'] : 10;

  timer_start('xc_search_full/mlt/search');
  $params['caller'] = 'xc_search_full/mlt/search';
  $mlts = xc_search_do_solr_search($query, FALSE, 0, $rows, $params);
  timer_stop('xc_search_full/mlt/search');
  $GLOBALS['timers']['xc_search_full/mlt/solr'] = array(
    'counter' => 1,
    'time' => ($mlts['time'] * 1000),
  );

  foreach ($mlts['docs'] as $mlt) {
    $ids     = xc_search_get_syndetics_identifiers($mlt);
    $mlt_element = xc_search_get_display_template_elements($mlt['type'], $mlt);
    $path    = xc_search_get_full_display_path($mlt);
    $link    = xc_search_get_full_display_url($mlt);
    $image_url = xc_search_get_syndetics_image($ids['ISBN'], $ids['UPC'],
               $ids['OCLC'], SYNDETICS_SMALL, TRUE); // only cached
    $full_title = xc_util_conditional_join(' &mdash; ', $mlt_element['title']);
    $short_title = xc_wordwrap($full_title, 160, ' &hellip');
    $title_clean = strip_tags($full_title);
    $all_creators = xc_util_conditional_join(' &mdash; ', $mlt_element['creator']);
    $short_creators = xc_wordwrap($all_creators, 120, ' &hellip');
    $xc_record['mlts'][] = array(
      'node_id' => $mlt['node_id'],
      'link' => $link,
      'image_url' => $image_url,
      'title_link' => l('<em>' . $short_title . '</em>',
                         $link, array('html' => TRUE, 'attributes' => array('title' => $title_clean))),
      'creator' => $short_creators,
      'title_clean' => $title_clean,
      'creator' => $short_creators,
      'all_creators' => $all_creators,
    );

    if ($image_url == '') {
      $image_info[$mlt['node_id']] = $ids;
    }
  }
  timer_stop('xc_search_full/mlt');

  $action_form = drupal_get_form('xc_search_full_action_form', $xc_record);
  $xc_record['action_buttons'] = drupal_render($action_form); //$action_buttons;

  timer_start('xc_search_full/js');
  drupal_add_js('misc/drupal.js', array('type' => 'file', 'weight' => JS_LIBRARY));
  drupal_add_js('misc/collapse.js', array('type' => 'file', 'weight' => JS_LIBRARY));
  drupal_add_js(drupal_get_path('module', 'xc_search') . '/js/xc_search.js', 'file');
  // TODO The second parameter to this function call should be an array.
  drupal_add_js(
    array(
    'xc_search' => array(
      'page' => 'node',
      'node_id' => $xc_record['node_id'],
      'ncip_url' => url(
            'xc_search/ajax/ncip_info_full',
            array('absolute' => TRUE)),
      'open_worldcat_identity_url' => url(
            'xc_search/ajax/open_worldcat_identity_url',
            array('absolute' => TRUE)),
      'image_info' => $image_info,
      'image_url' => url(
            'xc_search/ajax/image_info',
            array('absolute' => TRUE)),
      'bookmark_item_url' => url(
            'xc_search/ajax/bookmark_item',
            array('absolute' => TRUE)),
      'remove_bookmark_item_url' => url(
            'xc_search/ajax/remove_bookmark_item',
            array('absolute' => TRUE)),
      'schemaview_url' => url(
            'node/' . $xc_record['node_id'] . '/xc/schemaview',
            array('absolute' => TRUE)),
    ),
  ), array('type' => 'setting'
  , 'scope' => JS_DEFAULT));
  timer_stop('xc_search_full/js');

  timer_start('xc_search_full/theme');
  $output = theme('xc_search_metadata', array('xc_record' => $xc_record, 'element' => $element, 'display_type' => 'full'));
  timer_stop('xc_search_full/theme');

  timer_stop('xc_search_full');
  return $output;
}

/**
 * Get the display name of a holdings' location
 *
 * @param $location_code (String)
 *   The code of the location
 *
 * @return (string)
 *   The display name of the location
 */
function xc_search_get_location($location_code) {
  static $cache;

  if (empty($location_code)) {
    return '';
  }

  if (!isset($cache[$location_code])) { 

    $label = db_query("SELECT label FROM {xc_search_location} WHERE code = :code", array(':code' => $location_code))->fetchField();
    if (!$label) {
      $label = $location_code;
    }

    $cache[$location_code] = $label;
  }

  return $cache[$location_code];
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_full_action_form($form, &$form_state, $xc_record) {
  global $user;

  $nid = $xc_record['node_id'];
  $sid = $xc_record['id'];
  $form = array(
    '#theme' => 'xc_search_full_action_form',
  );
  $bookmark_id = function_exists('xc_account_get_bookmark_id') ? xc_account_get_bookmark_id($user->uid, $nid) : 0;

  $form['uid'] = array(
    '#type' => 'hidden',
    '#value' => $user->uid,
  );

  $form['nid'] = array(
    '#type' => 'hidden',
    '#value' => $nid,
  );

  $form['bookmark_id'] = array(
    '#type' => 'hidden',
    '#value' => $bookmark_id,
  );

  $form['sid'] = array(
    '#type' => 'hidden',
    '#value' => $sid,
  );

  $ui = xc_search_ui_get();

  $buttons = array(
    'schema-action' => array('title' => t('View XC Schema')),
  );

  if ($ui->display_bookmark_action) {
    $buttons['bookmarked'] = t('Bookmarked');
    $buttons['bookmark-action'] = t('Bookmark');
    $buttons['remove-bookmark-action'] = t('Remove bookmark');

    if ($user->uid == 0) {
      $buttons['bookmark-action'] = array(
        'title' => $buttons['bookmark-action'],
        '#disabled' => TRUE,
      );
    }
  }

  $buttons += array(
    'email-action' => array('title' => t('Email')),
    'text-action' => array('title' => t('Text')),
    'share-action' => array('title' => t('Share')),
  );

  if (!$ui->display_email_action) {
    $buttons['email-action']['#disabled'] = TRUE;
  }

  if (!$ui->display_text_action) {
    $buttons['text-action']['#disabled'] = TRUE;
  }

  if (!$ui->display_share_action) {
    $buttons['share-action']['#disabled'] = TRUE;
  }

  $action_buttons = array();
  foreach ($buttons as $class => $properties) {
    if ($class == 'schema-action' && !user_access(ACCESS_METADATA_SCHEMA)) {
      continue;
    }

    if (is_array($properties)) {
      $title = $properties['title'];
      if (isset($properties['#disabled'])) {
        $disabled = $properties['#disabled'];
      }
    }
    else {
      $title = $properties;
      $disabled = FALSE;
    }

    $form[$class] = array(
      '#type' => 'submit',
      '#value' => $title,
      '#attributes' => array('class' => array($class)),
    );

    if (isset($disabled) && $disabled) {
      $form[$class]['#disabled'] = $disabled;
      $form[$class]['#attributes']['class'][] = 'action-disabled';
    }

    if ($class == 'bookmarked') {
      $form[$class]['#type'] = 'item';
      $form[$class]['#id'] = 'bookmarked';
      $form[$class]['#title'] = 'Bookmarked';
      $form[$class]['#prefix'] = '<div id="bookmarked">';
      $form[$class]['#suffix'] = '</div>';
    }

    if (is_null($bookmark_id) || $bookmark_id === FALSE) {
      if ($class == 'remove-bookmark-action') {
        $form[$class]['#attributes']['style'] = 'display: none;';
      }
      elseif ($class == 'bookmarked') {
        $form[$class]['#prefix'] = '<div id="bookmarked" style="display: none;">';
      }
    }
    else {
      if ($class == 'bookmark-action') {
        $form[$class]['#attributes']['style'] = 'display: none;';
      }
    }
  }

  return $form;
}

/**
 * Implements hook_init().
 */
function xc_search_init() {
  global $_xc_search_server;

  drupal_add_css(drupal_get_path('module', 'xc_search') . '/xc_search.css', array('preprocess' => FALSE));

  // register search server
  if (module_exists('xc_solr')) {
    $servers = xc_solr_get_servers();
    foreach ($servers as $solr) {
      $_xc_search_server = new Drupal_Apache_Solr_ServiceXc($solr->host, $solr->port, $solr->path);
      break; // use the first one
    }
  }

  if (preg_match('/^(xc\/search|node)\//', $_GET['q'])) {
    if (user_access(ADMINISTER_XC_SEARCH) || (isset($_GET['xc_timers']) && $_GET['xc_timers'] == 1)) {
      register_shutdown_function('xc_search_shutdown');
    }
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_shutdown() {
  if (!variable_get('xc_search_show_timing_results', 0)
       || !preg_match('/^(xc\/search|node)\//', $_GET['q'])
       || !user_access(ADMINISTER_XC_SEARCH)) {
    return;
  }
  global $timers;

  $output = array();

  foreach (array_keys($timers) as $timer) {
    $duration = timer_read($timer);
    if ((!isset($duration))) {
      $duration = $timers[$timer]['time'];
    }

    if ($timer == 'page') {
      $total = $duration;
    }
    $output[] = sprintf('%s: %s', $timer, $duration);
  }

  $solr = 0.0;
  $keys = array(
    'xc_search_data/hook_search/search/xc_search_do_search/solr/ApacheSolrService/search/_sendRawGet/communication with Solr',
    'xc_search_full/mlt/search/ApacheSolrService/search/_sendRawGet/communication with Solr',
    'xc_solr_xc_retrieve/ApacheSolrService/search/_sendRawGet/communication with Solr',
    'xc_metadata_view/ApacheSolrService/search/_sendRawGet/communication with Solr',
  );
  foreach ($keys as $key) {
    if (isset($timers[$key])) {
      $solr += $timers[$key]['time'];
    }
  }

  $drupal = $total - $solr;
  $solr_pt = ($solr * 100 / $total);
  $drupal_pt = 100 - $solr_pt;
  $summary = sprintf("Summary: Total: %s, Drupal: %.2f%% (%s), Solr: %.2f%% (%s)", $total, $drupal_pt, $drupal, $solr_pt, $solr);
  array_unshift($output, $summary);

  print theme('item_list', array('items' => $output, 'title' => t('Timing results'), 'type' => 'ol'));
}

/**
 * Implements hook_search_page().
 */
function xc_search_search_page($results, &$meta = FALSE) {
  return array(
    '#theme' => 'xc_search_search_results',
    '#results' => $results,
    '#module' => 'xc_search',
    '#meta' => $meta
  );
  //return theme('xc_search_search_results', array('results' => $results, 'meta' => $meta));
}

/**
 * Preprocess template variables for manifestation_snippet.
 *
 * Preserved variables: template_files, zebra, directory, is_admin, is_front,
 * logged_in, db_is_active, user
 * Parameters: base_url, id, xc_record, element, frbr
 *
 * @param $variables
 */
function template_preprocess_manifestation_snippet(&$variables) {
  static $link_options, $online_link_strategy;

  // TODO:
  // problems:
  // $variables['xc_record']['dcterms:extent'] always contains a ' :' at the end

  $variables['citation'] = xc_util_conditional_join(', ', $variables['element']['citation']);
  $variables['publisher'] = xc_util_conditional_join(', ', $variables['element']['publisher']);
  $variables['date'] = xc_util_conditional_join(', ', $variables['element']['date']);
  $map = array(
    'placeOfProduction' => 'rdvocab:placeOfProduction',
    'issued' => 'dcterms:issued',
    'extent' => 'dcterms:extent',
  );
  foreach ($map as $variable_name => $schema_field) {
    if (isset($variables['xc_record'][$schema_field])) {
      $variables[$variable_name] = xc_util_conditional_join(', ',
        xc_util_get_metadata_value($variables['xc_record'][$schema_field]));
    }
  }

  $variables['format'] = xc_search_get_manifestation_formats($variables['xc_record']['format']);
  $variables['is_journal'] = preg_match('/\b' . t('Journals') . '\b/', $variables['format']);

  // TODO:
  if (isset($variables['xc_record']['dcterms:identifier'])
       && xc_util_contains_url(xc_util_get_metadata_value($variables['xc_record']['dcterms:identifier']))) {
    $variables['get_availability'] = FALSE;
    $online_links = xc_util_get_metadata_value($variables['xc_record']['dcterms:identifier']);

    // get manifestation's links
    $manifestation = (object) array('metadata_id' => $variables['xc_record']['metadata_id']);
    xc_sql_xc_retrieve($manifestation);
    if (isset($manifestation->metadata['dcterms:identifier'])) {
      $manifestation_links = xc_util_get_metadata_value($manifestation->metadata['dcterms:identifier']);
    }
    else {
      $manifestation_links = array();
    }

    if (!isset($link_options)) {
      $link_options = array(
        'external' => 1,
        'shorten' => 1,
        'regex' => '{(https?|ftp)://[^ ]+}',
      );
    }

    if (!isset($online_link_strategy)) {
      $search_ui = xc_search_variable('search_ui');
      if (!empty($search_ui->online_link_strategy)) {
        $online_link_strategy = $search_ui->online_link_strategy;
      }
      else {
        $online_link_strategy = 'holdings_manifestation';
      }
    }

    foreach ($online_links as $identifier) {
      if (preg_match("{(https?|ftp)://[^ ]+}", $identifier)) {
        if (empty($manifestation_links)) {
          $online_links['holdings'][] = xc_util_make_link($identifier, '', $link_options);
        }
        else {
          if (in_array($identifier, $manifestation_links) && $online_link_strategy != 'holdings') {
            $online_links['manifestation'][] = xc_util_make_link($identifier, '', $link_options);
          }
          elseif (!in_array($identifier, $manifestation_links) && $online_link_strategy != 'manifestation') {
            $online_links['holdings'][] = xc_util_make_link($identifier, '', $link_options);
          }
        }
      }
    }

    switch ($online_link_strategy) {
      case 'holdings':
        if (!empty($online_links['holdings'])) {
          $variables['online_links'] = array_unique($online_links['holdings']);
        }
        break;

      case 'manifestation':
        if (!empty($online_links['manifestation'])) {
          $variables['online_links'] = array_unique($online_links['manifestation']);
        }
        break;

      case 'holdings_manifestation':
        if (!empty($online_links['holdings'])) {
          $variables['online_links'] = array_unique($online_links['holdings']);
        }
        elseif (!empty($online_links['manifestation'])) {
          $variables['online_links'] = array_unique($online_links['manifestation']);
        }
        break;

      case 'manifestation_holdings':
        if (!empty($online_links['manifestation'])) {
          $variables['online_links'] = array_unique($online_links['manifestation']);
        }
        elseif (!empty($online_links['holdings'])) {
          $variables['online_links'] = array_unique($online_links['holdings']);
        }
        break;
    }
  }
  else {
    $variables['get_availability'] = isset($variables['params']['get_availability'])
      ? $variables['params']['get_availability']
      : TRUE;
  }
} // template_preprocess_manifestation_snippet

function template_preprocess_manifestation_title(&$variables) {
  timer_start('theme_xc_search_metadata/manifestation_title/template_preprocess');

  $variables['title'] = xc_util_conditional_join(' &mdash; ', $variables['element']['title']);

  $creators = (array) $variables['element']['creator'];
  if (count($creators) > 1) {
    $ui = xc_search_variable('search_ui');
    if ($ui !== FALSE) {
      switch ($ui->authors_count) {
        // all creators
        case -1:
          break;

         // none of them
        case 0:
          $creators = array();
          break;

        default:
          $has_more = (count($creators) > $ui->authors_count);
          $creators = array_slice($creators, 0, $ui->authors_count);
          if ($has_more) {
            $creators[] = '&hellip;';
          }
          break;
      }
    }
  }

  $variables['creator'] = xc_util_conditional_join(' &mdash; ', $creators);

  if (!empty($variables['xc_record']['full_display_url'])) {
    $variables['title_link'] = l(
      $variables['title'],             // link text
      $variables['xc_record']['full_display_url'], // URL full_display_url
      array('html' => TRUE, 'absolute' => TRUE)
    );
    if (!empty($variables['creator'])) {
      $variables['creator_link'] = l(
        $variables['creator'],
        $variables['xc_record']['full_display_url'],
        array('html' => TRUE, 'absolute' => TRUE)
      );
    }
  }
  else {
    $variables['title_link'] = $variables['title'];
    if (!empty($variables['creator'])) {
      $variables['creator_link'] = $variables['creator'];
    }
  }

  timer_stop('theme_xc_search_metadata/manifestation_title/template_preprocess');
}

function template_preprocess_oai_dc_title(&$variables) {
  $variables['dc_title'] = array();
  foreach ($variables['xc_record']['dc:title'] as $title) {
    $variables['dc_title'][] = $title['#value'];
  }
}

function template_preprocess_oai_dc_snippet(&$variables) {
  static $dc_fields;
  if (!isset($dc_fields)) {
    $dc_fields = array(
      'dc:title' => 'title', 'dc:creator' => 'creator', 'dc:date' => 'date',
      'dc:subject' => 'subject', 'dc:description' => 'description',
      'dc:relation' => 'relation', 'dc:publisher' => 'publisher',
      'dc:rights' => 'rights', 'dc:coverage' => 'coverage', 'dc:type' => 'type',
      'dc:format' => 'format', 'dc:identifier' => 'identifier'
    );
  }

  foreach ($dc_fields as $dc_field => $field) {
    $variables['dc'][$field] = array();
    if (isset($variables['xc_record'][$dc_field])) {
      foreach ($variables['xc_record'][$dc_field] as $instance) {
        $variables['dc'][$field][] = $instance['#value'];
      }
    }
  }
}

/**
 * Preprocess full display template
 * @param $variables
 */
function xc_search_template_preprocess_page(&$variables) { }

function template_preprocess_manifestation_full(&$variables) {
  timer_start('template_preprocess_manifestation_full');

  $author_field_names = array(
    'rdarole:artist' => t('artist'),
    'rdarole:author' => t('author'),
    'rdarole:compiler' => t('compiler'),
    'rdarole:composer' => t('composer'),
    'rdarole:speaker' => t('speaker'),
    'xc:creator' => t('creator'),
    'dcterms:creator' => t('creator'),
  );
  $contributor_field_names = array(
    'rdarole:director' => t('director'),
    'rdarole:editor' => t('editor'),
    'rdarole:illustrator' => t('illustrator'),
    'rdarole:performer' => t('performer'),
    'rdarole:producer' => t('producer'),
    'rdarole:translator' => t('translator'),
    'xc:contributor' => t('contributor'),
    'dcterms:contributor' => t('contributor'),
    'rdarole:speaker' => t('speaker'),
  );

  $authors_contibutors = array();
  // foreach (array_merge($author_field_names, $contributor_field_names) as $field_name => $label) {
  foreach ($contributor_field_names as $field_name => $label) {
    if (isset($variables['xc_record'][$field_name])) {
      if (is_array($variables['xc_record'][$field_name])) {
        foreach (xc_util_get_metadata_value($variables['xc_record'][$field_name]) as $author) {
          $authors_contibutors[$author]['fields'][] = $field_name;
          $authors_contibutors[$author]['labels'][] = $label;
        }
      }
      else {
        $authors_contibutors[$variables['xc_record'][$field_name]]['fields'][] = $field_name;
        $authors_contibutors[$variables['xc_record'][$field_name]]['labels'][] = $label;
      }
    }
  }

  $creators = array();
  if (isset($variables['xc_record']['creator_author'])) {
    $creators = array_unique((array) $variables['xc_record']['creator_author']);
  }
  $links = array();
  $link_options = array(
    'phrase' => 1,
    'facet' => 1,
  );
  foreach ($creators as $creator) {
    $links[] = array(
      xc_util_make_link($creator, 'creator_author_fc', $link_options),
      l(
        t('(Search WorldCat Identities)'),
        'xc_search/ajax/open_worldcat_identity_url',
        array('query' => array('sURL' => $creator))
      ),
    );
  }
  if (!empty($links)) {
    if (count($links) == 1) {
      $variables['top_author_links'] = $links[0][0] . ' &nbsp; ' . $links[0][1];
    }
    elseif (count($links) <= 4) {
      $variables['top_author_links'] = theme('table', array('header' => array(), 'rows' => $links, 'attributes' => array('id' => 'xc-authors-list')));
    }
    else {
      $items = array();
      foreach ($links as $i => $link) {
        if ($i < 4) {
          $items[] = $link;
        }
        else {
          $items[] = array(
            'data' => $link,
            'class' => array('xc-hidden-author'),
          );
        }
      }
      $items[] = array(
        'data' => array(t('<a href="#">!count more</a>',
                  array('!count' => intval(count($links) -4)))),
        'id' => 'xc-show-hidden-authors',
      );
      $variables['top_author_links'] = theme('table', array('header' => array(), 'rows' => $items, 'attributes' => array('id' => 'xc-authors-list')));
      drupal_add_js(drupal_get_path('module', 'xc_search') . '/js/xc_manifestation.js');
    }
  }

  $links = array();
  foreach ($authors_contibutors as $contributor => $info) {
    // it retrieves always ONE link
    $raw_links = xc_util_conditional_joined_link(NULL, $contributor,
      'other_contributors_fc', array('phrase' => 1, 'facet' => 1, 'debug' => 1));
    foreach ($raw_links as $link) {
      $links[] = $link . ' (' . join(', ', $info['labels']) . ')';
    }
  }
  if (!empty($links)) {
    $variables['all_author_links'] = $links;
  }

  $variables['ajax_loader_img'] = drupal_get_path('module', 'xc_search') . '/images/ajax-loader.gif';

  /*
   $variables['publisher'] = xc_util_conditional_joined_link(', ',
   $variables['element']['publisher'], 'dcterms:publisher');
   */
  $variables['publisher'] = xc_util_conditional_join(', ', $variables['element']['publisher']);

  $variables['date'] = xc_util_conditional_join(', ', $variables['element']['date']);
  // $variables['format'] = xc_util_conditional_join(', ', $variables['element']['format']);
  $variables['format'] = xc_search_get_manifestation_formats($variables['xc_record']['format']);

  $variables['language'] = xc_util_conditional_join('&mdash;', $variables['element']['language']);
  $variables['abstract'] = xc_util_conditional_join('&mdash;', $variables['element']['abstract']);
  $variables['title'] = xc_util_conditional_join(', ', $variables['element']['title']);
  $variables['creator'] = xc_util_conditional_join(', ', $variables['element']['creator']);

  $variables['node_id'] = $variables['xc_record']['node_id'];
  $variables['image_url_large'] = $variables['xc_record']['image_url_large'];
  $variables['image_url_medium'] = $variables['xc_record']['image_url_medium'];

  /**
   $variables['placeOfProduction'] = xc_util_conditional_joined_link(', ',
   $variables['xc_record']['rdvocab:placeOfProduction'],
   'rdvocab:placeOfProduction');
   **/
  if (isset($variables['xc_record']['genre'])) {
    $variables['genre'] = is_array($variables['xc_record']['genre'])
      ? theme('item_list', array('items' => $variables['xc_record']['genre']))
      : xc_util_conditional_join(' &mdash; ', $variables['xc_record']['genre']);
  }

  // ISBN
  if (isset($variables['xc_record']['dcterms:identifier'])) {
    $variables['ISBN'] = xc_util_conditional_join(' &mdash; ', xc_util_get_metadata_value($variables['xc_record']['dcterms:identifier'], array('@type' => 'ISBN')));
  }

  // ISSN
  $variables['ISSN'] = xc_util_conditional_join(' &mdash; ',
    xc_util_get_metadata_values($variables['xc_record'], array(
    'dcterms:identifier' => array('@type' => 'ISSN'),
    'xc:identifier' => array('@type' => 'ISSN'),
  )
  ));

  if (!empty($variables['xc_record']['xc:recordID'])) {
    $oclcs = xc_util_get_metadata_value($variables['xc_record']['xc:recordID'], array('@type' => 'OCoLC'));
    for ($i = 0; $i < count($oclcs); $i++) {
      $oclcs[$i] = sprintf('%s (%s)',
        $oclcs[$i],
        l(t('Search WorldCat'),
          xc_search_oclc_url($oclcs[$i]),
          array('attributes' => array('title' => t('See this record at OCLC\'s WorldCat'))))
      );
    }
    $variables['OCLC'] = join(' &mdash; ', $oclcs);
  }
  $fields = array(
    'audience' => 'dcterms:audience',
    'extent' => 'dcterms:extent',
    'otherPhisicalDetails' => 'dcterms:otherPhisicalDetails',
    'dimensions' => 'rdvocab:dimensions',
    'requires' => 'dcterms:requires',
    'tableOfContents' => 'dcterms:tableOfContents',
    'titleOfWork' => 'rdvocab:titleOfWork',
    'responsibility' => 'rdvocab:statementOfResponsibilityRelatingToTitle',
    'dissertationOrTheses' => 'rdvocab:dissertationOrThesesInformation',
    'description' => 'dcterms:description',
    'placeOfProduction' => 'rdvocab:placeOfProduction',
    'editionStatement' => 'rdvocab:editionStatement',
    'natureOfContent' => 'rdvocab:natureOfContent',
    'thesisAdvisor' => 'xc:thesisAdvisor',
  );
  foreach ($fields as $variable => $schemafield) {
    if (isset($variables['xc_record'][$schemafield])) {
      $variables[$variable] = xc_util_conditional_join(
        ' &mdash; ',
        xc_util_get_metadata_value($variables['xc_record'][$schemafield])
      );
    }
  }
  $variables['summary'] = xc_util_conditional_join('<br />', $variables['xc_record']['summary']);
  // $variables['locations'] = $variables['xc_record']['all_locations'];

  $variables['isPartOf'] = '';
  if (isset($variables['xc_record']['xc:isPartOf'])) {
    $variables['isPartOf'] = xc_util_conditional_join(' &mdash; ',
      xc_util_get_metadata_value($variables['xc_record']['xc:isPartOf']));
    if (!empty($variables['isPartOf']) && !empty($variables['xc_record']['dcterms:isPartOf'])) {
      $variables['isPartOf'] .= ' &mdash; ';
    }
    $variables['isPartOf'] .= xc_util_conditional_join(' &mdash; ', xc_util_get_metadata_values($variables['xc_record'], 'dcterms:isPartOf'));
  }

  // applying subject_spatial, subject_topic, subject_temporal
  if (!empty($variables['xc_record']['subject_spatial']) || !empty($variables['xc_record']['region'])
        || !empty($variables['xc_record']['subject_topic']) || !empty($variables['xc_record']['topic'])) {
    $subjects = array(
      'subject_spatial' => 'region',
      'subject_topic' => 'topic',
    );
    foreach ($subjects as $subject => $old_name) {
      $key = $subject;
      if (empty($variables['xc_record'][$subject])) {
        if (!empty($variables['xc_record'][$old_name])) {
          $key = $old_name;
        }
        else {
          continue;
        }
      }
      if (!is_array($variables['xc_record'][$key])) {
        $variables['xc_record'][$key] = array($variables['xc_record'][$key]);
      }

      $solr_field = $key . '_fc';
      foreach ($variables['xc_record'][$key] as $term) {
        $solr_query = $solr_field . ':"' . $term . '"';
        $variables[$subject][] = l($term,
          'xc/search/*', // . urlencode($solr_query),
          array('query' => array(
            'filter' => array($solr_query),
            'reuse_filter' => 1,
            'ql' => 1,
          ))
        );
      }
    }
  }
  if (isset($variables['xc_record']['subject_temporal'])) {
    $variables['subject_temporal'] = (array) $variables['xc_record']['subject_temporal'];
  }
  else {
    $variables['subject_temporal'] = array();
  }

  $identifiers = array();
  if (isset($variables['xc_record']['dcterms:identifier'])) {
    $identifiers = xc_util_get_metadata_value($variables['xc_record']['dcterms:identifier']);
    if (!is_array($identifiers)) {
      $identifiers = array($identifiers);
    }
  }
  $variables['url_identifiers'] = array();
  $options = array(
    'external' => 1,
    'regex' => '{(https?|ftp)://[^ ]+}',
    'shorten' => 1,
  );
  foreach ($identifiers as $identifier) {
    if (preg_match("{(https?|ftp)://[^ ]+}", $identifier)) {
      $variables['url_identifiers'][] = xc_util_make_link($identifier, '', $options);
    }
  }

  // has version
  $variables['has_version'] = array();
  if (isset($variables['xc_record']['dcterms:hasVersion'])) {
    $has_version_items = xc_util_get_metadata_value($variables['xc_record']['dcterms:hasVersion']);
    if (!empty($has_version_items)) {
      $options = array(
        'external' => 1,
        'regex' => '{(https?|ftp)://[^ ]+}',
        'shorten' => 1,
      );
      foreach ($has_version_items as $identifier) {
        if (preg_match("{(https?|ftp)://[^ ]+}", $identifier)) {
          $variables['has_version'][] = xc_util_make_link($identifier, '', $options);
        }
      }
    }
  }

  $variables['has_admin_right'] = user_access(ADMINISTER_XC_SEARCH);

  // holdings summary
  if (!empty($variables['xc_record']['holdings_summary'])) {
    if ($variables['xc_record']['holdings_use_table'] == TRUE) {
      $rows = array();
      foreach ($variables['xc_record']['holdings_summary'] as $holdings) {
        $rows[] = array_values($holdings);
      }
      $variables['holdings_summary'] = $rows;
    }
    else {
      $variables['holdings_summary'] = $variables['xc_record']['holdings_summary'];
    }
  }

  $relations = array();
  if (!empty($variables['xc_record']['xc:relation'])) {
    $relations = xc_util_get_metadata_value($variables['xc_record']['xc:relation']);
  }
  if (!empty($variables['xc_record']['dcterms:relation'])) {
    $relations = array_merge($relations, xc_util_get_metadata_value($variables['xc_record']['dcterms:relation']));
  }

  if (!empty($relations)) {
    xc_util_link_walk($relations, '', array('external' => 1, 'regex' => '{(https?|ftp)://[^ ]+}'));
    $variables['relations'] = $relations;
  }
  $variables['mlts'] = &$variables['xc_record']['mlts'];
  $variables['enhancements'] = $variables['xc_record']['enhancements'];
  $variables['action_buttons'] = &$variables['xc_record']['action_buttons'];

  timer_stop('template_preprocess_manifestation_full');
}

/**
 * Theming other contributors
 *
 * @param $links (Array)
 *   List of other contributors
 * @param $colnum (int)
 *   The number of columns. Possible values: 2 to 6
 *
 * @return (String)
 *   The themed list of other contributors
 */
function theme_xc_multicolumn_list($variables) {
  $links = $variables['links'];
  $colnum = $variables['colnum'];
  if (empty($links) || intval($colnum) < 2 || intval($colnum) > 6) {
    return '';
  }

  if (count($links) == 1) {
    return $links[0];
  }

  $slices = xc_search_multicolumn_slices($links, $colnum);

  $output = '';
  foreach ($slices as $slice) {
    $output .= theme('item_list', array('items' => $slice['data'], 'title' => NULL, 'type' => 'ul', 'attributes' => array('class' => array($slice['class']))));
  }
  return $output;
}

/**
 * Theming other contributors
 *
 * @param $links (Array)
 *   List of other contributors
 *
 * @return (String)
 *   The themed list of other contributors
 */
function theme_xc_multicolumn_table($variables) {
  $items = $variables['links'];
  $colnum = $variables['colnum'];
  $attributes = $variables['attributes'];
  $caption = $variables['caption'];

  if (count($items) == 1) {
    return $items[0];
  }

  $slices = xc_search_multicolumn_slices($items, $colnum);
  $rows = array();
  for ($i = 0, $len = count($slices[0]['data']); $i < $len; $i++) {
    $cells = array();
    for ($j = 0; $j < $colnum; $j++) {
      //assign one dummy cell to the right column to prevent Undefined offset error
      if (!isset($slices[$j]['data'][$i])) {
       $slices[$j]['data'][$i] = '';
      }
      $cells[] = array(
        'data' => $slices[$j]['data'][$i],
        'class' => $slices[$j]['class'],
      );
    }
    $rows[] = $cells;
  }
  if (empty($attributes['class'])) {
    $attributes['class'] = array('xc-multicolumn-table',  'xc-column-' . $colnum);
  }
  else {
    $attributes['class'] += array('xc-multicolumn-table', 'xc-column-' . $colnum);
  }
  $output = theme('table', array('header' => array(), 'rows' => $rows, 'attributes' => $attributes, 'caption' => $caption));
  return $output;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_multicolumn_slices($items, $colnum = 2) {
  $slices = array();
  if (empty($items) || intval($colnum) < 2 || intval($colnum) > 6) {
    return $slices;
  }

  $classnames = array(
    1 => 'first',
    2 => 'second',
    3 => 'third',
    4 => 'fourth',
    5 => 'fifth',
    6 => 'sixth',
  );
  $remainder = count($items) % $colnum;
  if ($remainder == 0) {
    $size = count($items) / $colnum;
    for ($i = 0; $i < $colnum; $i++) {
      $slices[] = array(
        'data' => array_slice($items, ($i * $size), $size),
        'class' => $classnames[$i + 1],
      );
    }
  }
  else {
    $size = floor(count($items) / $colnum);
    $shift = 0;
    for ($i = 0; $i < $colnum; $i++) {
      // computing offset
      if ($i == 0) {
        $offset = 0;
      }
      else {
        $offset = ($i * $size) + $shift;
      }

      // computing the size
      if ($remainder > $shift) {
        $shift++;
        $current_size = $size + 1;
      }
      else {
        $current_size = $size;
      }

      // create the slices
      $slices[] = array(
        'data' => array_slice($items, $offset, $current_size),
        'class' => $classnames[$i + 1],
      );
    }
  }

  return $slices;
}

/**
 * Preprocess function for manifestation_full_mlt theme
 *
 * @param $variables (Array)
 *   The variables available to the theme
 */
function template_preprocess_manifestation_full_mlt(&$variables) {
  if (!empty($variables['mlt'])) {
    $variables = array_merge($variables, $variables['mlt']);
  }

  if ($variables['show'] == 'title') {
    $variables['show'] = ($variables['title_link']);
    unset($variables['image_url']);
  }
  elseif ($variables['show'] == 'image') {
    $variables['show'] = ($variables['image_url']);
    unset($variables['title_link']);
  }
  elseif ($variables['title_link'] || $variables['image_url']) {
    $variables['show'] = TRUE;
  }
  else {
    $variables['show'] = FALSE;
  }
}

/**
 * Implements hook_theme().
 */
function xc_search_theme() {
  global $base_url;

  $themes = array(
    'xc_search_form' => array(
      'render element' => 'form',
      'file' => 'xc_search.pages.inc',
    ),
    'xc_search_search_results' => array(
      'variables' => array(
        'results' => NULL,
        'meta' => NULL,
      ),
      /*
 'file' => 'search.pages.inc',
 'template' => 'search-results',
 */
    ),
    'xc_search_info_bar' => array(
      'variables' => array(
        'meta' => array(),
        'components' => array(),
        'type' => '',
        'number' => '',
        'location' => 'top',
        'module' => 'xc_search',
      ),
    ),
    'xc_search_info_bar_actions' => array(
      'variables' => array(
        'links' => array(),
        'buttons' => array(),
      ),
    ),
    'xc_search_info_bar_numbers' => array(
      'variables' => array(
        'meta' => array(),
        'full' => FALSE,
      ),
    ),
    'xc_search_info_bar_pager' => array(
      'variables' => array('meta' => array()),
    ),
    'xc_search_block_filter' => array(
      'variables' => array(
        'search_path' => NULL,
        'label' => NULL,
        'get_params' => NULL,
      ),
      'file' => 'searching/xc_search_block.inc',
    ),
    'xc_search_block_facet_link' => array(
      'variables' => array(
        'term' => NULL,
        'count' => NULL,
        'path' => NULL,
        'filter_by_label' => NULL,
        'query' => NULL,
      ),
      'file' => 'searching/xc_search_block.inc',
    ),
    'xc_search_block_label' => array(
      'variables' => array(
        'field_label' => NULL,
        'label' => NULL,
        'is_active' => FALSE,
      ),
      'file' => 'searching/xc_search_block.inc',
    ),
    'xc_search_block_result_navigation' => array(
      'variables' => array('links' => array()),
      'file' => 'searching/xc_search_block.inc',
    ),
    'xc_search_facet_group_reorder_form' => array(
      'render element' => 'form',
    ),
    'xc_search_sortoption_reorder_form' => array(
      'render element' => 'form',
      'file' => 'admin/xc_search_sortoption.inc',
    ),
    'xc_search_date_facet_properties_form' => array(
      'render element' => 'form',
    ),
    'xc_search_date_facet_properties_edit_form' => array(
      'render element' => 'form',
    ),
    'xc_search_result_list' => array(
      'variables' => array(
        'header' => NULL,
        'rows' => NULL,
        'attributes' => array(),
        'caption' => NULL,
      ),
    ),
    'xc_search_result_list_row' => array(
      'template' => 'templates/xc-search-result-list-row',
      'variables' => array(
        'counter' => NULL,
        'node_id' => NULL,
        'result' => array(),
        'xc_record' => NULL,
        'attributes' => array(),
      ),
    ),
    'xc_search_metadata' => array(
      'variables' => array(
        'xc_record' => NULL,
        'element' => NULL,
        'display_type' => 'title',
        'counter' => NULL,
        'params' => array(),
      ),
    ),
    'selection_bar' => array(
      'template' => 'templates/selection-bar',
      'variables' => array(),
    ),
    'manifestation_full_locations' => array(
      'template' => 'templates/manifestation-full-locations',
      'variables' => array('locations' => NULL),
    ),
    'manifestation_full_mlt' => array(
      'template' => 'templates/manifestation-full-mlt',
      'variables' => array(
        'mlt' => NULL,
        'count' => NULL,
        'show' => TRUE,
      ),
    ),
    'xc_search_no_results' => array(
      'variables' => array(
        'title' => NULL,
        'content' => NULL,
      ),
    ),
    'xc_search_pager_form' => array(
      'render element' => 'form',
    ),
    'xc_search_block_facet_checkboxes' => array(
      'variables' => array('checkboxes' => NULL),
    ),
    'xc_search_block_facet_activefilters' => array(
      'variables' => array('active_filters' => array()),
    ),
    'xc_search_general_notification' => array(
      'variables' => array(),
    ),
    'xc_search_bookmark_notification' => array(
      'variables' => array(),
    ),
    'xc_search_manifestation_format' => array(
      'variables' => array(
        'format' => NULL,
        'is_online' => FALSE,
        'is_microform' => FALSE,
      ),
    ),
    'xc_search_spellcheck' => array(
      'variables' => array('spellcheck' => array()),
    ),
    'xc_search_suggestions' => array(
      'variables' => array('terms' => array()),
    ),
    'xc_search_suggestions_serp' => array(
      'variables' => array('terms' => array()),
    ),
    'xc_multicolumn_list' => array(
      'variables' => array(
        'links' => array(),
        'colnum' => 2,
      ),
    ),
    'xc_multicolumn_table' => array(
      'variables' => array(
        'links' => array(),
        'colnum' => 2,
        'attributes' => array(),
        'caption' => NULL,
      ),
    ),
    'xc_search_info_bar_back_to_results' => array(
      'variables' => array('meta' => NULL),
    ),
    'xc_search_ui_form' => array(
      'render element' => 'form',
      'file' => 'admin/xc_search_ui.inc',
    ),
    'xc_search_ui_edit_form' => array(
      'render element' => 'form',
      'file' => 'admin/xc_search_ui.inc',
    ),
  );

  $entities = array('oai_dc', 'work', 'expression', 'manifestation');
  $tpl_types = array('title', 'snippet', 'full');
  foreach ($entities as $entity) {
    foreach ($tpl_types as $type) {
      $themes[$entity . '_' . $type] = array(
        'template' => XC_SEARCH_TEMPLATE_DIR . '/' . $entity . '-' . $type,
        'variables' => array(
          'base_url' => $base_url,
          'id' => NULL,
          'xc_record' => NULL,
          'element' => NULL,
          'frbr' => NULL,
          'params' => array(),
        ),
      );
    }
  }
  return $themes;
}

/**
 * Implements hook_theme_registry_alter().
 *
 * Adds the xc_search/templates directory to the directories, where Drupal will look for template
 * for print_node theme
 *
 * @param $theme_registry (Array)
 *   Drupal Theme registry
 */
function xc_search_theme_registry_alter(&$theme_registry) {
  /*
   $theme_registry['print_node']['theme paths'] = array_merge(
   $theme_registry['print_node']['theme paths'],
   array(drupal_get_path('module', 'xc_search') . '/templates'));
   */
}

/**
 * Implements hook_fieldset_helper_path_alter().
 *
 * This is a hook of fieldset_helper. It change the path which use in storing
 * the state of collapsible fieldsets. We would like to handle all search pages
 * equally.
 *
 * See its history at http://drupal.org/node/823318.
 *
 * @param $path (String)
 *   The current path. This is a key in fieldset_helper's registry
 */
function xc_search_fieldset_helper_path_alter(&$path) {
  if (strstr($path, 'xc/search') == $path || strstr($path, 'search/xc_search') == $path) {
    $path = 'xc/search';
  }
}

/**
 * Implements hook_fieldset_helper_rewite_path().
 *
 * This is a little bit outdated with the hook_fieldset_helper_path_alter().
 * See its history at http://drupal.org/node/823318.
 *
 * @param $path (Object)
 *   It's current_path field is a key in fieldset_helper's registry. This is a reference.
 */
function xc_search_fieldset_helper_rewite_path(&$param) {
  $param->current_path = preg_replace('/^(search\/xc_search)\/.*$/', "$1", $param->current_path);
  return TRUE;
}

/** COMMON functions
 *  ---------------- */

/**
 * Load the record from the DB according to its ID
 * @param $sui_id (int)
 *   The search UI identifier
 * @return (Object)
 *   The search UI object
 */
function xc_search_ui_load($sui_id) { 
  $result = db_query('SELECT * FROM {xc_search_ui} WHERE sui_id = :sui_id', array(':sui_id' => $sui_id));
  $data = $result->fetchObject();
  $data->boost_factors = xc_search_ui_get_boosting_by_ui($data->sui_id);

  return $data;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_ui_get_boosting_by_ui($ui_id) {
  $factors = array(); 
  $result = db_query('SELECT * FROM {xc_search_ui_boosting} WHERE sui_id = :sui_id', array(':sui_id' => $ui_id));
  foreach ($result as $data) {
    $factors[$data->id] = array(
      'solr_field' => $data->solr_field,
      'factor' => $data->factor,
    );
  }

  return $factors;
}

/**
 * Load the search ui with the given UI ID, or the first one.
 * @param $sui_id
 * @return unknown_type
 */
function xc_search_ui_get($sui_id = NULL) {
  $ui = NULL;
  if (is_null($sui_id)) {
    // TODO: later we should create a radio button based selector to select the
    // default one, and not use the first one
    $sui_id = variable_get('xc_search_ui_min', NULL);
    if (is_null($sui_id)) {
      $sql = 'SELECT min(sui_id) FROM {xc_search_ui}';
      $sui_id = db_query($sql)->fetchField();
      variable_set('xc_search_ui_min', $sui_id);
    }
  }

  return xc_search_ui_load($sui_id);
}

/**
 * Load MoreLikeThis record
 * @param $mlt_id
 * @return (Object)
 *   A MoreLikeThis record
 */
function xc_search_mlt_load($mlt_id) { 
  $result = db_query('SELECT * FROM {xc_search_mlt} WHERE mlt_id = :mlt_id', array(':mlt_id' => $mlt_id));
  $data = $result->fetchObject();
  return $data;
}

/**
 * Load a highlighter record
 * @param $highlighter_id (int)
 *   The identifier of the record
 * @return (Object)
 *   The highlighter object
 */
function xc_search_highlighter_load($highlighter_id) { 
  $result = db_query('SELECT * FROM {xc_search_highlighter} WHERE highlighter_id = :highlighter_id', array(':highlighter_id' => $highlighter_id));
  $data = $result->fetchObject();
  return $data;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_facet_group_load($facet_id) { 
  $result = db_query('SELECT * FROM {xc_search_facet_group} WHERE facet_id = :facet_id', array(':facet_id' => $facet_id));
  $data = $result->fetchObject();
  return $data;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_facet_group_title($facet) {
  return t('@name facet group', array('@name' => $facet->name));
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_display_template_load($xc_search_display_template) { 
  $result = db_query('SELECT * FROM {xc_search_display_template} WHERE template_id = :template_id', array(':template_id' => $xc_search_display_template));
  $data = $result->fetchObject();
  return $data;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_display_template_element_load($xc_search_display_template_element) { 
  $result = db_query('SELECT * FROM {xc_search_display_template_element} WHERE element_id = :element_id', array(':element_id' => $xc_search_display_template_element));
  $data = $result->fetchObject();
  return $data;
}

/**
 * Get title for sorting option
 *
 * @param $record (Object)
 *   The sorting option object
 *
 * @return (String)
 *   The label of sorting option as it will be the title
 */
function xc_search_sortoption_title($record) {
  return $record->label;
}

/**
 * Load the database record
 * @param $field_id (int)
 *   The identifier of a facet
 * @return (Object)
 *   The field database record as object. Its fields are: field_id, name (the
 *   name of the facet), type (could be: field, date, and query), facet_id
 *   (which refers to the facet group's identifier), and attribute_set_id
 *   (which refers to an attribute set)
 */
function xc_search_facet_field_load($field_id) { 
  $result = db_query('SELECT * FROM {xc_search_facet_field} WHERE field_id = :field_id', array(':field_id' => $field_id));
  $data = $result->fetchObject();
  return $data;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_field_facet_properties_load($set_id) {
  $result = db_query('SELECT * FROM {xc_search_field_facet_properties} WHERE set_id = :set_id', array(':set_id' => $set_id));
  $data = $result->fetchObject();
  return $data;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_query_facet_properties_load($set_id) {
  $result = db_query('SELECT * FROM {xc_search_query_facet_properties} WHERE set_id = :set_id', array(':set_id' => $set_id));
  $data = $result->fetchObject();
  return $data;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_date_facet_properties_load($set_id) {
  $result = db_query('SELECT * FROM {xc_search_date_facet_properties} WHERE set_id = :set_id', array(':set_id' => $set_id));
  $data = $result->fetchObject();
  return $data;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_sortoption_load($id) {
  return db_query('SELECT * FROM {xc_search_sortoption} WHERE id = :id', array(':id' => $id))->fetchObject();
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_restore_defaults_form($form, &$form_state) {
  $form['delete'] = array(
    '#type' => 'checkbox',
    '#title' => t('Do you want to delete existing values?'),
    '#options' => array(
      0 => t('No'),
      1 => t('Yes'),
    ),
  );
  return confirm_form(
    array($form),
    t('Are you sure, that you would like to restore default search settings?'),
    'admin/xc/search', // path to go if user click on 'cancel'
    t('This action cannot be undone.'),
    t('Start process'),
    t('Cancel')
  );
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_restore_defaults_form_submit($form, &$form_state) {
  drupal_set_time_limit(0);
  $delete = (boolean) $form_state['values']['delete'];

  $mpath = drupal_get_path('module', 'xc_search');
  $dpath = $mpath . '/admin';

  //include_once DRUPAL_ROOT . '/' . $dpath . '/xc_search_display_template.inc';
  include_once $dpath . '/xc_search_display_template.inc';
  xc_search_display_template_import_defaults($delete);

  include_once $dpath . '/xc_search_display_template_element.inc';
  xc_search_display_template_element_import_defaults($delete);

  include_once $dpath . '/xc_search_mlt.inc';
  xc_search_mlt_import_defaults($delete);

  include_once $dpath . '/xc_search_highlighter.inc';
  xc_search_highlighter_import_defaults($delete);

  include_once $dpath . '/xc_search_date_facet_properties.inc';
  xc_search_date_facet_properties_import_defaults($delete);

  include_once $dpath . '/xc_search_field_facet_properties.inc';
  xc_search_field_facet_properties_import_defaults($delete);

  include_once $dpath . '/xc_search_facet_group.inc';
  xc_search_facet_group_import_defaults($delete);

  include_once $dpath . '/xc_search_facet_field.inc';
  xc_search_facet_field_import_defaults($delete);

  include_once $dpath . '/xc_search_ui.inc';
  xc_search_ui_restore_defaults($delete);

  $form_state['redirect'] = 'admin/xc/search';
}

/**
 * Returns the number of rows to display.
 *
 * @return (int)
 *   The number of rows to display
 */
function xc_search_get_rows() {
  $rows = !empty($_GET['rows']) ? intval($_GET['rows']) : XC_SEARCH_LIMIT;
  return $rows;
}

/**
 * Returns the page number of a SERP.
 *
 * @return (int)
 *   The page number (first page is 0)
 */
function xc_search_get_page() {
  $page = !empty($_GET['page']) ? intval($_GET['page']) : 0;
  return $page;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_get_params($strict = FALSE) {
  $strict_keys = array(
    'search_type' => 1,
    'filter' => 1,
    'start' => 1,
    'rows' => 1,
    'image' => 1,
    'ql' => 1,
    'sort' => 1,
    'caller' => 1,
    'page' => 1,
  );

  $url_params = array();
  foreach ($_GET as $key => $value) {
    if ($key == 'q' || ($strict && !isset($strict_keys[$key]))) {
      continue;
    }
    $url_params[$key] = $value;
  }

  return $url_params;
}

/**
 * Form definition of sortform form
 *
 * @param $form_state (Array)
 *   The state of form
 * @param $id (String)
 *   The form id
 *
 * @return (Array)
 *   Form definition
 */
function xc_search_sortform($form, &$form_state, $id, $screen = NULL) {
  // preparing default query value
  if (!empty($form_state['input']['query'])) {
    $query = $form_state['input']['query'];
  }
  else {
    $params = xc_search_get_params();
    unset($params['sort']);
    $query = drupal_http_build_query($params);
  }

  // preparation of default sort value
  $use_new_sort = variable_get('xc_search_use_new_sort', TRUE);
  if ($use_new_sort) {
    $default_sort = 'score desc';
  }
  else {
    $default_sort = 'relevancy';
  }

  $sort = '';
  if (!empty($form_state['input']['sort'])) {
    $sort = $form_state['input']['sort'];
  }
  elseif (!empty($form_state['sort'])) {
    $sort = $form_state['sort'];
  }
  elseif (isset($_GET['sort'])) {
    $sort = $_GET['sort'];
  }

  if ($sort == '') {
    $sort = $default_sort;
  }

  if (is_null($screen) && !empty($form_state['input']['screen'])) {
    $screen = $form_state['input']['screen'];
  }

  if ($screen == 'xc_browse') {
    $action = 'xc/search';
    // $action = 'xc_browse';
    if (!empty($_REQUEST['keys'])) {
      $keys = $_REQUEST['keys'];
    }
    else {
      $keys = join('/', array(arg(1), arg(2), arg(3)));
    }
  }
  else {
    $action = 'xc/search';
    $keys   = search_get_keys();
  }

  $form = array(
    '#id' => 'xc_search_sortform_' . $id,
    '#action' => url($action),
  );

  $form['screen'] = array(
    '#type' => 'hidden',
    '#value' => $screen,
  );

  $form['keys'] = array(
    '#type' => 'hidden',
    '#value' => $keys,
  );

  $form['query'] = array(
    '#type' => 'hidden',
    '#value' => $query,
  );

  $form['sort'] = array(
    '#type' => 'select',
    '#default_value' => $sort,
    '#options' => xc_search_sort_options(),
    '#attributes' => array('onchange' => 'this.form.submit();'),
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Search'),
    '#attributes' => array('style' => 'display:none'),
  );

  return $form;
}

/**
 * Validates sortform form
 *
 * @param $form
 * @param $form_state
 */
function xc_search_sortform_validate($form, &$form_state) { }

/**
 * Submit function for sortform form
 *
 * @param $form (Array)
 *   The form object
 * @param $form_state (Array)
 *   The form state object reference
 */
function xc_search_sortform_submit($form, &$form_state) {
  if ($form_state['values']['screen'] == 'xc_browse') {
    $base = 'xc_browse/';
  }
  else {
    $base = 'xc/search/';
  }
  $keys  = $form_state['values']['keys'];
  $sort  = $form_state['values']['sort'];
  parse_str($form_state['values']['query'], $query);
  $query['sort'] = $sort;

  $form_state['redirect'] = array($base . $keys, array('query' => $query));
}

/**
 * Returns the sorting options
 *
 * @return (Array)
 *   List of pairs of keys and lables of sorting options.
 */
function xc_search_sort_options() {
  $use_new_sort = variable_get('xc_search_use_new_sort', TRUE);
  if ($use_new_sort) {
    $options = variable_get('xc_search_sortoption', array());
    if (empty($options)) {
      require_once drupal_get_path('module', 'xc_search') . '/admin/xc_search_sortoption.inc';
      $options = array_merge(
        array('' => t('Sort by')),
        xc_search_sortoption_get_options(TRUE)
      );
      variable_set('xc_search_sortoption', $options);
    }
  }
  else {
    $options = array(
      '' => t('Sort by'),
      'relevancy' => t('Relevancy'),
      'date_asc' => t('Oldest first'),
      'date_desc' => t('Newest first'),
      'title_asc' => t('Title (A-Z)'),
      'title_desc' => t('Title (Z-A)'),
      'author_asc' => t('Author (A-Z)'),
      'author_desc' => t('Author (Z-A)'),
    );
  }
  return $options;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_rows_options() {
  return drupal_map_assoc(array(10, 50, 100));
}

/**
 * The XC pager form definition.
 *
 * @param $form_state (Array)
 *   The state of the form (fulfilled with actual values)
 *
 * @return (Array)
 *   The form's definition
 */
function xc_search_pager_form($form, &$form_state, $meta = NULL) {
  global $pager_page_array, $pager_total;
  static $allowed_callers = array(
    'bookmark' => 1,
    'xc-search' => 1,
    'xc-browse' => 1,
  );

  if (is_null($meta) && !is_null($form_state['input']['meta'])) {
    $meta = unserialize($form_state['input']['meta']);
  }

  $element = 0;
  $query = array();
  if (!empty($form_state['input']['url'])) {
    $url = $form_state['input']['url'];
  }
  else {
    $params = xc_search_get_params();
    unset($params['page']);
    $query = $params; // drupal_query_string_encode($params);
    $url = $_GET['q'];
  }

  if (!isset($query) && !empty($form_state['input']['query'])) {
    parse_str($form_state['input']['query'], $query);
  }

  $caller = '';
  if (isset($form_state['input']['caller'])) {
    $caller = $form_state['input']['caller'];
  }
  elseif (isset($_GET['caller'])) {
    $caller = $_GET['caller'];
  }

  if (isset($_GET['caller']) && isset($allowed_callers[$_GET['caller']])) {
    $is_node = TRUE;
  }
  elseif (!empty($form_state['input']['is_node'])
       && $form_state['input']['is_node'] == 1) {
    $is_node = TRUE;
  }
  else {
    $is_node = FALSE;
  }

  // preparation of default sort value
  if (!empty($form_state['input']['page'])) {
    $page = $form_state['input']['page'];
  }
  elseif (!empty($form_state['page'])) {
    $page = $form_state['page'];
  }
  elseif ($is_node) {
    $page = $_GET['hit'];
  }
  elseif (isset($_GET['page'])) {
    $page = $_GET['page'];
  }
  else {
    $page = 0;
  }

  // set max
  if (isset($form_state['input']['max'])) {
    $max = $form_state['input']['max'];
  }
  else {
    if ($is_node) {
      $max = $meta->total;
    }
    else {
      $max = ceil($meta->total / $meta->rows);
    }
  }

  $is_first = $is_node ? ($page == 1) : ($pager_page_array[$element] == 0);
  $is_last  = $is_node ? ($page == $max) : ($pager_page_array[$element] >= $pager_total[$element] - 1);
  $current  = $is_node ? $page : $pager_page_array[$element] + 1;
  $next_url = !empty($form_state['input']['next_url'])
            ? $form_state['input']['next_url']
            : (($is_node && $meta->extra['next']) ? $meta->extra['next']['url'] : '');
  $prev_url = !empty($form_state['input']['prev_url'])
            ? $form_state['input']['prev_url']
            : (($is_node && $meta->extra['prev']) ? $meta->extra['prev']['url'] : '');
  $caller_module = !empty($form_state['input']['caller_module'])
            ? $form_state['input']['caller_module']
            : (($is_node && isset($meta->extra['caller_module'])) ? $meta->extra['caller_module'] : '');

  $form = array(
    '#action' => url('xc/search'),
    '#programmed' => TRUE,
    '#theme' => 'xc_search_pager_form',
  );

  $form['meta'] = array(
    '#type' => 'hidden',
    '#attributes' => array(
      'value' => serialize($meta),
      'id'=>"edit-meta",
    ),
  );

  $form['url'] = array(
    '#type' => 'hidden',
    '#attributes' => array(
      'value' => $url,
      'id'=>"edit-url",
    ),
  );

  $form['query'] = array(
    '#type' => 'hidden',
    '#attributes' => array(
      'value' => drupal_http_build_query($query),
      'id'=>"edit-query",
    ),
  );

  $form['page'] = array(
    '#type' => 'hidden',
    '#attributes' => array(
     'value' => $page,
     'id'=>"edit-page",
    ),
  );

   $form['max'] = array(
    '#type' => 'hidden',
    '#value' => $max,
  );

  $form['is_node'] = array(
    '#type' => 'hidden',
    '#attributes' => array(
      'value' => (int) $is_node,
      'id'=>"edit-node",
    ),
  );

  $form['caller'] = array(
    '#type' => 'hidden',
    '#attributes' => array(
      'value' => $caller,
      'id'=>"edit-caller",
     ),
  );

  $form['caller_module'] = array(
    '#type' => 'hidden',
    '#attributes' => array(
      'value' => $caller_module,
      'id'=>"edit-module",
    ),
  );

  $form['prev_url'] = array(
    '#type' => 'hidden',
    '#attributes' => array(
      'value' => $prev_url,
      'id'=>"edit-prev-url",
    ),
  );

  $form['next_url'] = array(
    '#type' => 'hidden',
    '#attributes' => array(
      'value' => $next_url,
      'id'=>"edit-next-url",
    ),
  );

  // trick: when on submit() the first submit will be triggered
  $form['jump'] = array(
    '#id' => 'xc-search-pager-form-go',
    '#type' => 'submit',
    '#value' => t('Go'),
    '#name' => 'jump',
    '#attributes' => array(
      'class' => array('xc-search-pager-go'),
      'style' => 'display: none',
    ),
  );

  $form['previous'] = array(
    '#type' => 'submit',
    '#value' => '', //t('Previous'),
    '#name' => 'previous',
    '#attributes' => array('class' => array('xc-search-pager-previous')),
  );

  if ($is_first) {
    $form['previous']['#disabled'] = TRUE;
    $form['previous']['#attributes']['class'][] = 'xc-search-pager-disabled';
  }

  $form['current'] = array(
    '#type' => 'textfield',
    '#size' => 3,
    '#default_value' => $current,
    '#attributes' => array(
      'onchange' => "this.form.submit()", //"document.location=this.form.url.value + (parseInt(this.value) - 1);",
      'class' => array('xc-search-pager-current'),
    ),
  );

  $form['next'] = array(
    '#type' => 'submit',
    '#value' => '', //t('Next'),
    '#name' => 'next',
    '#attributes' => array('class' => array('xc-search-pager-next')),
  );

  if ($is_last) {
    $form['next']['#disabled'] = TRUE;
    $form['next']['#attributes']['class'][] = 'xc-search-pager-disabled';
  }

  return $form;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_xc_search_pager_form($variables) {
  $form = $variables['form'];

  $textfield = preg_replace('/^<[^>]+>|<\/div>$/', '', drupal_render($form['current']));

  $total = '<span="xc-current-text-total">' . $form['max']['#value'] . '</total>';

  if ($form['is_node']['#value']) {
    $text = t('Result !counter of !total', array('!counter' => '<counter />', '!total' => '<total />'));
  }
  else {
    $text = t('Page !counter of !total', array('!counter' => '<counter />', '!total' => '<total />'));
  }

  list($before, $after) = explode('<counter />', $text);
  if (strstr($before, '<total />')) {
    $before = str_replace('<total />', $total, $before);
  }
  if (strstr($after, '<total />')) {
    $after = str_replace('<total />', $total, $after);
  }

  $items = array(
    drupal_render($form['previous']),
    '<span="xc-current-text">' . $before . '</span>',
    $textfield,
    '<span="xc-current-text">' . $after . '</span>',
    drupal_render($form['next']),
  );
  $output = theme('item_list', array('items' => $items, 'title' => NULL, 'type' => 'ul', 'attributes' => array('id' => 'xc-search-pager-controls')));

  $output .= drupal_render_children($form);
  return $output;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_pager_form_submit($form, &$form_state) {

  $value = $form_state['values'];
  $page = (int) $value['page'];

  $url = $value['url'];
  $min = $value['is_node'] == 1 ? 1 : 0;
  if ($form_state['clicked_button']['#name'] == 'next') {
    $page++;
    if ($value['next_url'] != '') {
      $url = $value['next_url'];
    }
  }
  elseif ($form_state['clicked_button']['#name'] == 'previous') {
    $page--;
    if ($value['prev_url'] != '') {
      $url = $value['prev_url'];
    }
  }
  else {
    if ($value['current'] > $value['max']) {
      $page = $value['max'];
    }
    else {
      $page = $value['current'];
    }

    if ($value['is_node'] != 1) {
      $page--;
    }
  }

  if ($page < $min) {
    $page = $min;
  }

  parse_str($value['query'], $query);

  if ($value['is_node'] == 1) {
    $query['hit'] = $page;
    if ($value['caller'] == 'bookmark') {
      $bookmark = xc_account_get_bookmarked_item($page);
      $form_state['redirect'] = array('node/' . $bookmark->nid, array('query' => $query));
    }
    else {
      $node_id = xc_solr_get_nth_result($value['caller_module'], $page - 1);
      $form_state['redirect'] = array('node/' . $node_id, array('query' => $query));
    }
  }
  else {
    $query['page'] = $page;
    $form_state['redirect'] = array($value['url'], array('query' => $query));
  }
}

/**
 * Get formats for a manifestation
 *
 * @param $xc_formats (Array)
 *   The format facet values of a manifestation
 */
function xc_search_get_manifestation_formats($xc_formats = array()) {
  static $removable_formats;

  if (empty($xc_formats)) {
    return '';
  }

  if (!isset($removable_formats)) {
    $removable_formats = array('Not Online', 'Not online', 'Not microform');
  }

  if (!is_array($xc_formats)) {
    $xc_formats = array($xc_formats);
  }
  $raw_formats = array_diff($xc_formats, array_intersect($removable_formats, $xc_formats));

  $formats = array();
  $is_online = in_array('Online', $xc_formats);
  $is_microform = in_array('Microform', $xc_formats);
  foreach ($raw_formats as $format) {
    $formats[] = theme('xc_search_manifestation_format', array('format' => $format, 'is_online' => $is_online, 'is_microform' => $is_microform));
  }
  if (empty($formats)) {
    if ($is_online) {
      $formats[] = theme('xc_search_manifestation_format', array('format' => 'Online', 'is_online' => $is_online, 'is_microform' => $is_microform));
    }
    elseif ($is_microform) {
      $formats[] = theme('xc_search_manifestation_format', array('format' => 'Microform', 'is_online' => $is_online, 'is_microform' => $is_microform));
    }
  }
  return join(', ', $formats);
}

/**
 * Theming a format
 *
 * @param $format (String)
 *   The name of the format
 * @param $is_online (Boolean)
 *   Whether the item is online
 * @param $is_microform (Boolean)
 *   Whether the item is microform
 */
function theme_xc_search_manifestation_format($variables) {
  $format = $variables['format'];
  $is_online = $variables['is_online'];
  $is_microform = $variables['is_microform'];
  if ($format == 'Books, texts' && $is_online) {
    $class = 'online_book';
  }
  elseif ($format == 'Journals' && $is_online) {
    $class = 'online_journal';
  }
  else {
    $class = str_replace('__', '_', str_replace(array(',', ' '), '_', strtolower($format)));
  }

  return '<span class="' . $class . '">' . $format . '</span>';
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_error($error_msg = NULL) {
  static $cache;
  if (!is_null($error_msg)) {
    $cache = $error_msg;
  }
  else {
    return $cache;
  }
}

/**
 * Get suggestions based on current query.
 *
 * The xc_search_suggestion_type Drupal variable may contain different suggestion types.
 * The current implementation supports only Google suggestion service, which is an unofficial
 * API, and in the future may be changed. Later we can suppoert Yahoo!'s Related Suggestios
 * Webservice (http://developer.yahoo.com/search/web/V1/relatedSuggestion.html)
 *
 * @param $query (String)
 *   The query term to get suggestions for. If the query is empty, the function makes use the
 *   actual search query
 * @param $is_autocomplete (boolean)
 *   The caller is an autocomplete function
 */
function xc_search_suggestions($query = '', $is_autocomplete = FALSE) {
  if ($query == '') {
    $query = xc_search_current_query();
  }
  $suggestions = array();
  if ($query != '' && !strstr($query, ' OR ')) {
    $suggestion_type = variable_get('xc_search_suggestion_type', 'google_complete');

    if ($suggestion_type == 'google_complete') {
      $url = 'http://www.google.com/complete/search?output=toolbar&q=' . rawurlencode($query);
      // we need to use XMLReader instead of SimpleXML, because the later can not handle non UTF-8 responses.
      // Google unfortunatelly notify character encoding in the HTTP header, not in XML
      try {
        $result = drupal_http_request($url);
        if ($result->code != 200 || $result->data == '') {
          xc_log_error('xc suggestion', 'Wrong response for: ' . $url);
          return $suggestions;
        }
        $content = $result->data;
        $content_type = '';
        if (isset($result->headers['Content-Type'])) {
          $content_type = $result->headers['Content-Type'];
        }
        elseif (isset($result->headers['content-type'])) {
          $content_type = $result->headers['content-type'];
        }
        // Content-Type: text/xml; charset=ISO-8859-1
        if (preg_match('/^text\/html/', $content_type)) {
          xc_log_error('xc suggestion', 'Wrong content type for: ' . $url);
          return $suggestions;
        }
        $charset = 'ISO-8859-1';
        if (preg_match('/^text\/xml; charset=(.*?)$/', $content_type, $matches)) {
          $charset = $matches[1];
          if ($charset != 'ISO-8859-1') {
            xc_log_error('xc suggestion', sprintf('charset: %s (%s)', $charset, $url));
          }
        }
        else {
          xc_log_error('xc suggestion', sprintf('Unhandled content type from Google suggestion: "%s" (%s)', $content_type, $url));
        }

        $xml = new XMLReader(); 
        $is_successful_xml = $xml->xml($content, $charset);
        if (!$is_successful_xml) {
          xc_log_error('xc suggestion', sprintf('Unable to read in xml source: "%s" (%s)', $content_type, $url));
        }
        else {
          $counter = -1;
          $collector = array();
          while (@$xml->read()) {
            if ($xml->nodeType == XMLReader::ELEMENT && $xml->name == 'suggestion') {
              $counter++;
              $term = $xml->getAttribute('data');
              if (!$is_autocomplete || $term != $query) {
                $collector[$counter] = array(
                  'term' => $term,
                  'num' => 1,
                );
              }
            }
            if ($xml->nodeType == XMLReader::ELEMENT && $xml->name == 'num_queries') {
              $num = (int) $xml->getAttribute('int');
              if (isset($collector[$counter])) {
                $collector[$counter]['num'] = $num;
              }
            }
          }
          // while
          usort($collector, 'xc_search_cmp_google_suggestions');
          foreach ($collector as $term) {
            $suggestions[] = $term['term'];
          }
        }
      }
      catch (Exception $e) {
        // TODO: handle error
      }
    }
  }
  return $suggestions;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_cmp_google_suggestions($a, $b) {
  if ($a["num"] > $b["num"]) {
    return -1;
  }
  elseif ($a["num"] < $b["num"]) {
    return 1;
  }
  else {
    if ($a["term"] > $b["term"]) {
      return -1;
    }
    elseif ($a["term"] < $b["term"]) {
      return 1;
    }
    else {
      return 0;
    }
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_spellcheck($spellcheck = NULL) {
  static $cache;
  if (!is_null($spellcheck)) {
    $cache = $spellcheck;
  }
  else {
    return $cache;
  }
}

/**
 * Creates URL parameters for Solr spellchecker
 *
 * @param $query (String)
 *   The Solr query
 *
 * @return (Array)
 *   The URL parameters
 */
function xc_search_spellcheck_params($query) {
  // TODO: all this should move to admin interface
  static $alloed_dicts = array(
    'default' => 1,
    'jarowinkler' => 1,
  );

  $param = 'spellcheck.dictionary';
  if (!empty($_GET[$param]) && isset($alloed_dicts[$_GET[$param]])) {
    $dictionary = $_GET[$param];
  }
  else {
    $dictionary = 'default';
  }
  return array(
    'spellcheck' => 'true',
    'spellcheck.q' => $query,
    'spellcheck.dictionary' => $dictionary,
    'spellcheck.count' => 5,
    'spellcheck.extendedResults' => 'true',
    'spellcheck.onlyMorePopular' => 'true',
    'spellcheck.collate' => 'true',
  );
}

/**
 * Return the current state of checkboxes.
 *
 * @return (Array)
 *   An associative array of checkbox ids, and the state of the checkbox according to current request.
 *   0 means non checked state, 1 means checked state. The current ckeckboxes are:
 *   online_only and exclude_microform
 */
function xc_search_block_checkbox_options() {
  return array(
    'online_only' => (isset($_GET['online_only'])
      ? (intval($_GET['online_only']) == 1 ? 1 : 0)
      : 0),
    'exclude_microform' => (isset($_GET['exclude_microform'])
      ? (intval($_GET['exclude_microform']) == 1 ? 1 : 0)
      : 1),
  );
}

/**
 * Save $meta object for later use or get saved meta. Meta object stores information
 * regarding to the current search page, like first result, last result, total number
 * or result, number of results per page.
 *
 * @param $meta (Object)
 *   The meta to cache.
 *   - total (int): the total number or results
 *   - first (int): the first result to show
 *   - last (int): the last result to show
 *   - rows (int): the number of rows to display
 *
 * @return (Object)
 *   The cached meta
 */
function xc_search_meta($meta = NULL) {
  static $cache;
  if (!is_null($meta)) {
    $cache = $meta;
  }
  else {
    return $cache;
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_variable($key, $value = NULL) {
  static $cache;

  if (empty($key)) {
    return NULL;
  }

  if (is_null($value)) {
    if (isset($cache[$key])) {
      return $cache[$key];
    }
    else {
      return NULL;
    }
  }
  else {
    $cache[$key] = $value;
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_get_full_record_display_options() {
  static $record;

  if (!isset($record)) {
    // yes, currently it is a singleton...
    $record = db_query('SELECT * FROM {xc_search_full_record_display} WHERE id = :id', array(':id' => 1))->fetchObject();
    if (!$record) {
      $record = (object) array(
        'id' => 0,
        'show_search_form' => 0,
        'show_browse_form' => 1,
        'show_navigation' => 1,
        'mlt_ajax' => 'normal',
        'holdings_use_table' => 0,
        'holdings_list_all' => 0,
      );
    }
  }

  return $record;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_search_get_xc_syndetics_identifier_fields() {
  static $xc_syndetics_identifier_fields;
  if (!isset($xc_syndetics_identifier_fields)) {
    $xc_syndetics_identifier_fields = array(
      // TODO: change the _ISBN
      'dcterms:identifier' => array(
        'label' => 'ISBN',
        'filter' => array('@type' => 'ISBN'),
      ),
      //'dcterms:identifier' => 'ISBN',
      'xc:identifier' => array(
        'label' => 'UPC',
        'filter' => array('@type' => 'UPC'),
      ),
      'xc:recordID' => array(
        'label' => 'OCLC',
        'filter' => array('@type' => 'OCoLC'),
      ),
    );
  }

  return $xc_syndetics_identifier_fields;
}
