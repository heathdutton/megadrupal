<?php
/**
 * @file
 * Syndetics Solution connection module
 *
 * @author Király Péter <kirunews@gmail.com>
 *
 * @copyright (c) 2010-2011 eXtensible Catalog Organization
 */

/**
 * @addtogroup global variables
 * @{
 */

/**
 * The types of document enhancements Syndetics Solution could provide. It is an
 * associative array of the keys Syndetics use as URL parameters for accessing the
 * desirable enhancement (eg. 'TOC'), and either its human readable name (eg.
 * 'Table of Contents') or an array with 'label', 'xpath' and 'nodeNames' keys,
 * where the label is a human readable name, xpath is an xpath string, which
 * points to the location inside the resulted XML document, where the object takes
 * place, and nodeNames are array of node names, where the actual information takes
 * place.
 * @var array
 */
global $_syndetics_object_types;

/**
 * An associative array, which maps the Syndetics metadata enhancement types to
 * XC enhancement types. Metadata enhancement are those which adds plus information
 * to existing bibliographic metadata, such as a table of content, a summary,
 * review etc.
 *
 * @see $_syndetics_object_types
 *
 * @var array
 */
global $_syndetics_external_map;
/**
 * @} End of "addtogroup global variables".
 */

/**
 * Syndetics notation for large images
 * @var unknown_type
 */
define('SYNDETICS_LARGE', 'LC');

/**
 * Syndetics notation for medium size images
 * @var unknown_type
 */
define('SYNDETICS_MEDIUM', 'MC');

/**
 * Syndetics notation for small size images
 * @var unknown_type
 */
define('SYNDETICS_SMALL', 'SC');

/**
 * Syndetics notation for ISBN identifier
 * @var unknown_type
 */
define('SYNDETICS_TYPE_ISBN', 'ISBN');

/**
 * Syndetics notation for OCLC identifier
 * @var unknown_type
 */
define('SYNDETICS_TYPE_OCLC', 'OCLC');

/**
 * Syndetics notation for UPC identifier
 * @var unknown_type
 */
define('SYNDETICS_TYPE_UPC',   'UPC');

/**
 * Notation for a complex identifier, which is an associative array may contain all kind of Syndetics identifiers
 * @var unknown_type
 */
define('SYNDETICS_TYPE_COMPLEX', 'COMPLEX'); // covers all info

/**
 * Implements hook_menu().
 */
function syndetics_menu() {
  $items['admin/xc/syndetics'] = array(
    'title' => 'Syndetics Solution Services settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('syndetics_settings'),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_NORMAL_ITEM,
  );
  return $items;
}

/**
 * Form to save settings for Syndetics module
 */
function syndetics_settings($form, &$form_state) {
  $form['syndetics_client_code'] = array(
    '#type' => 'textfield',
    '#title' => t('Syndetics Solution client code'),
    '#description' => t('Please input the institution\'s Syndetics Solution client code.'),
    '#default_value' => variable_get('syndetics_client_code', ''),
    '#size' => 20,
  );

  return system_settings_form($form);
}

/**
 * Get the cover images corresponding to one or more bibliographic identifiers
 *
 * @param $ids (Array)
 *   Associative array of Syndetics identifiers (ISBN, OCLC, UPC numbers), where
 *   the keys are: ISBN, OCLC, and UPC and the values are the actual identifiers
 *   of the corresponding type, or an array of identifier values.
 * @param $id_type (String)
 *   The type of the identifier. One of the following: 'ISBN' - the default value
 *   (constant: SYNDETICS_TYPE_ISBN), 'OCLC' (SYNDETICS_TYPE_OCLC), 'UPC'
 *   (SYNDETICS_TYPE_UPC), 'COMPLEX' (SYNDETICS_TYPE_COMPLEX). COMPLEX means
 *   that the $ids parameter is an associative array.
 * @param $image_size (String)
 *   The size of the image. Possible values: 'LC' - for large images (corresponding
 *   constant: SYNDETICS_LARGE), 'MC' - for medium size image (SYNDETICS_MEDIUM),
 *   and 'SC' - for small size image, the default value (SYNDETICS_SMALL)
 * @param $only_cached_images (Boolean)
 *   Flag whether to retrieve only the cached image URLs, or access the Syndetics
 *   service.
 *
 * @return (Array)
 *   The list of image URLs
 */
function syndetics_image_url($ids, $id_type = SYNDETICS_TYPE_ISBN, $image_size = SYNDETICS_SMALL, $only_cached_images = FALSE) {
  global $_syndetics_external_map;
  static $service_url;

  timer_start('syndetics_image_url');

  if (!isset($service_url)) {
    $service_url = 'http://syndetics.com/index.aspx?&client=' . syndetics_get_client_code() . '&type=xw10';
  }

  //$id = substr(md5(serialize($ids)), 0, 5);
  //$do_trace = (!$only_cached_images) ? TRUE : FALSE;
  $do_trace = FALSE;
  $urls = array();
  // has image?
  $images = syndetics_get_object_record($ids, $id_type, $_syndetics_external_map[$image_size], $do_trace);
  if (empty($images) && !$only_cached_images) {
    $indexes = syndetics_get_cached_index($ids, $id_type);

    $images = array();
    // has index?
    if ((empty($indexes) && !$only_cached_images)
         || (!empty($indexes)
            && $indexes[0]->service_url == $service_url)
        ) {
      $indexes = syndetics_index($ids, $id_type);
    }

    if (!empty($indexes)) {
      $investigated_ids = array();
      foreach ($indexes as $record) {
        $has_img_record = FALSE;
        // process every record only once
        if (isset($investigated_ids[$record->external_id])) {
          continue;
        }
        $investigated_ids[$record->external_id] = 1;

        if (is_null($record->error) || $record->error == '') {
          $index = unserialize($record->service_content);
          if (isset($index[$image_size])) {
            if (!$has_img_record) {
              $img_name = $index[$image_size];
              $url = syndetics_build_image_url($ids, $id_type, $img_name);
              $error = ($url == '') ? 'empty URL' : NULL;

              list($img_w, $img_h) = getimagesize($url);
              if (!(($img_w > 1) && ($img_h > 1))) {
                continue;
              }

              $img_record = xc_external_save_record('Syndetics', $_syndetics_external_map[$image_size], $error, $url, NULL);
              $has_img_record = TRUE;
              if ($url != '') {
                $images[] = $img_record;
              }
            } // first record
            syndetics_save_connections($ids, $id_type, $img_record->external_id);
          }
        }
      }
    }
  }

  $urls = array();
  foreach ($images as $image) {
    if (isset($image->service_url) && $image->service_url != '') {
      $urls[] = $image->service_url;
    }
  }

  timer_stop('syndetics_image_url');
  return $urls;
}

/**
 * Get the cached index.xml
 *
 * @param $ids (String or Array)
 *   The bibliographic identifiers
 * @param $id_type
 *   The type of bibliographic identifiers
 *
 * @return (Object)
 *   An xc_external record object. Properties: external_id, service_provider,
 *   service_type, updated_at, error, service_url, service_content
 */
function syndetics_get_cached_index($ids, $id_type) {
  if ($id_type == SYNDETICS_TYPE_COMPLEX) {
    $result = xc_external_get_object_by_ids($ids, 'index');
  }
  else {
    $result = xc_external_get_object_by_id($ids, $id_type, 'index');
  }
  return $result;
}

/**
 * Get the stored record belonging to the object
 *
 * @param $ids (String or Associative array)
 *   The external ID or IDs (like ISBN, OCLC, UPC numbers)
 * @param $type (String)
 *   The type of the external identifier
 * @param $service_type (String)
 *   The object we want to retrieve (like summary)
 * @param $do_trace (Boolean)
 *   Whether make log entry about the process or not (default: FALSE)
 *
 * @return (Array)
 *   Array of stdClass of a xc_external table (fields: external_id, service_provider,
 *   service_type, updated_at, error, service_url, service_content)
 */
function syndetics_get_object_record($ids, $type, $service_type, $do_trace = FALSE) {
  timer_start('syndetics_get_object_record');
  if ($type == SYNDETICS_TYPE_COMPLEX) {
    $result = xc_external_get_object_by_ids($ids, $service_type, $do_trace);
  }
  else {
    $result = xc_external_get_object_by_id($ids, $type, $service_type, $do_trace);
  }
  timer_stop('syndetics_get_object_record');
  return $result;
}

/**
 * Saves the Syndetics connections with the help of XC External module's API function.
 *
 * @param $ids (string or array)
 *   The identifiers used by Syndetics
 * @param $identifier_type (String)
 *   The type of identifier (can be SYNDETICS_TYPE_COMPLEX, SYNDETICS_TYPE_ISBN, SYNDETICS_TYPE_OCLC, SYNDETICS_TYPE_UPC)
 * @param $external_id (int)
 *   XC External API's record identifier (different Syndetics IDs may refer to the same XC record ID).
 */
function syndetics_save_connections($ids, $identifier_type, $external_record_id) {
  static $identifier_types;

  if ($identifier_type == SYNDETICS_TYPE_COMPLEX) {
    if (!isset($identifier_types)) {
      $identifier_types = array(SYNDETICS_TYPE_ISBN, SYNDETICS_TYPE_OCLC, SYNDETICS_TYPE_UPC);
    }

    foreach ($identifier_types as $_identifier_type) {
      if (!empty($ids[$_identifier_type])) {
        xc_external_save_connection($ids[$_identifier_type], $_identifier_type, $external_record_id);
      }
    }
  }
  else {
    xc_external_save_connection($ids, $identifier_type, $external_record_id);
  }
}

/**
 * Get the Syndetics' index.xml processed content.
 *
 * @param $ids (String or Array)
 *   The bibliographic identifier or identifiers
 * @param $id_type
 *   The bibliographic identifier type
 *
 * @return (Array of Object)
 *   One or more xc_external record object. Properties: external_id, service_provider,
 *   service_type, updated_at, error, service_url, service_content
 */
function syndetics_index($ids, $id_type) {
  $cached_index = syndetics_get_cached_index($ids, $id_type);
  if (!empty($cached_index)
       && $cached_index[0]->service_url != 'http://syndetics.com/index.aspx?&client=' . syndetics_get_client_code() . '&type=xw10') {
    return $cached_index;
  }
  $fields = array();
  $url = syndetics_get_index_url($ids, $id_type);
  $error = '';
  $content = '';
  if ($url != '') {
    //xc_log_info('syndetics', 'download index info for ' . var_export($ids, TRUE));
    if (FALSE !== ($XML = @file_get_contents($url))) {
      if (strpos($XML, '<?xml') !== FALSE) {
        $dom = new DOMDocument();
        $dom->loadXML($XML);
        $root = $dom->getElementsByTagName("INDEX-ROOT")->item(0);
        $children = $root->childNodes;
        $count = $children->length;
        for ($i = 0; $i < $count; $i++) {
          $field = $children->item($i);
          if ($field->nodeType == XML_ELEMENT_NODE) {
            $fields[$field->nodeName] = $field->nodeValue;
          }
        }
      }
      else {
        $error = 'invalid source';
      }
    }
    else {
      $error = 'inexistent source';
    }
  }
  else {
    return array();
  }
  if ($error == '') {
    $content = serialize($fields);
  }

  $record = xc_external_save_record('Syndetics', XC_EX_INDEX, $error, $url, $content);
  syndetics_save_connections($ids, $id_type, $record->external_id);
  return array($record);
}

/**
 * Get the content belongs to a Syndetics object type (like summary or table of contents).
 *
 * @param $ids (Array)
 *   Associative array of Syndetics identifiers (ISBN, OCLC, UPC numbers), where
 *   the keys are: ISBN, OCLC, and UPC and the values are the actual identifiers
 *   of the corresponding type, or an array of identifier values.
 * @param $id_type (String)
 *   The type of the identifier. One of the following: 'ISBN' - the default value
 *   (constant: SYNDETICS_TYPE_ISBN), 'OCLC' (SYNDETICS_TYPE_OCLC), 'UPC'
 *   (SYNDETICS_TYPE_UPC), 'COMPLEX' (SYNDETICS_TYPE_COMPLEX). COMPLEX means
 *   that the $ids parameter is an associative array.
 * @param $object_type (String)
 *   The type of object you would like to retrieve. Possible known values:
 *   'INDEX' - Index (or Menu) page, 'TOC' - Table of Contents, BNATOC - Table of Contents,
 *   'FICTION' - Fiction/Biography Profile, 'FFICTION' - Fiction Search (Find Similar
 *   Titles), 'SUMMARY' - Summary / Annotation, 'GMSUMMARY' - German-Language Summary,
 *   'SPSUMMARY' - Spanish-Language Summary, 'SPREVIEW' - Spanish Language Review,
 *   'SWEDSUMMARY' - Swedish-Language Summary, 'SWEDTOC' - Swedish Language TOC,
 *   'SWEDREVIEW' - Swedish Language Review, 'ITASUMMARY' - Italian Language Summary,
 *   'AVSUMMARY' - Music & Video Summary, 'DBCHAPTER' - First Chapter or Excerpt,
 *   'LJREVIEW' - Library Journal Review, 'PWREVIEW' - Publishers Weekly Review,
 *   'SLJREVIEW' - School Library Journal Review, 'CHREVIEW' - CHOICE Review,
 *   'BLREVIEW' - Booklist Review, 'HBREVIEW' - Horn Book Review, 'KIRKREVIEW' -
 *   Kirkus Book Review, 'ANOTES' - Author Notes. I have not find a good
 *   documentation of all possible values the Syndetics service support, so it is
 *   probable, that other values are possible as well.
 *
 * @return (Object)
 *   The content of the response. If it is the INDEX, it contains an array
 *   of possible objects, and theirs properties, otherwise it is usually a HTML
 *   string.
 */
function syndetics_get_object($ids, $id_type, $object_type) {
  global $_syndetics_object_types;
  $info = syndetics_get_object_record($ids, $id_type, $object_type);
  if (!empty($info)) {
    return unserialize($info[0]->service_content);
  }
  $records = syndetics_index($ids, $id_type);
  foreach ($records as $record) {
    if (!is_null($record->error) && $record->error != '') {
      continue;
    }
    $index = unserialize($record->service_content);
    if (isset($index[$object_type])) {
      $object_name = $index[$object_type];
    }
  }
  if (!isset($object_name)) {
    return '';
  }

  $fields = array();
  $url = syndetics_build_object_url($ids, $id_type, $object_name);
  $error = '';
  $content = '';
  if ($url == '') {
    return '';
  }
  else {
    if (FALSE === ($XML = @file_get_contents($url))) {
      $error = 'inexistent source';
    }

    else {
      if (strpos($XML, '<?xml') === FALSE) {
        $error = 'inexistent source';
      }
      else {
        $dom = new DOMDocument();
        // TODO: handling errors like this:
        // warning: DOMDocument::loadXML() [domdocument.loadxml]:
        // Space required after the Public Identifier in Entity, line: 1
        // in syndetics.module on line 175.
        try {
          $dom->loadXML($XML);
          $nodeNames = $_syndetics_object_types[$object_type]['nodeNames'];
          $nodes = array($dom);
          for ($i = 0, $size = count($nodeNames); $i < $size; $i++) {
            $is_last = (($size - 1) == $i);
            $nodeName = $nodeNames[$i];
            $new_nodes = array();
            foreach ($nodes as $node) {
              $children = $node->getElementsByTagName($nodeName);
              $count = $children->length;
              for ($j = 0; $j < $count; $j++) {
                $node = $children->item($j);
                if ($is_last) {
                  $fields[] = $node->nodeValue;
                }
                else {
                  $new_nodes[] = $node;
                }
              }
            }
            $nodes = $new_nodes;
          }
        }
        catch (Exception $e) {
          $message = preg_replace('/( in ).*?(syndetics.module)/', "$1$2", $e->message);
          drupal_set_message($url);
          drupal_set_message($XML);
          drupal_set_message(var_export($e, TRUE));
          drupal_set_message($message);
        }
      }
    }
  }
  if ($error == '') {
    $content = serialize($fields);
  }

  $record = xc_external_save_record('Syndetics', $object_type, $error, $url, $content);
  syndetics_save_connections($ids, $id_type, $record->external_id);
  return $fields;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function syndetics_build_object_url($ids, $id_type, $object_name) {
  $url = 'http://syndetics.com/index.aspx?';
  switch ($id_type) {
    case SYNDETICS_TYPE_ISBN:
      $url .= 'isbn=' . $ids . '/' . $object_name;
      break;
    case SYNDETICS_TYPE_OCLC:
      $url .= 'isbn=/' . $object_name . '&OCLC=' . $ids;
      break;
    case SYNDETICS_TYPE_UPC:
      $url .= 'isbn=/' . $object_name . '&UPC=' . $ids;
      break;
    case SYNDETICS_TYPE_COMPLEX:
      $url .= 'isbn=' . $ids['ISBN'] . '/' . $object_name . '&UPC=' . $ids['UPC']
          . '&OCLC=' . $ids['OCLC'];
      break;
  }
  $url .= '&client=' . syndetics_get_client_code() . '&type=xw10';
  return $url;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function syndetics_get_client_code() {
  return check_plain(variable_get('syndetics_client_code', ''));
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function syndetics_build_image_url($ids, $id_type, $img_name) {
  $url = 'http://syndetics.com/index.aspx?';
  switch ($id_type) {
    case SYNDETICS_TYPE_ISBN:
      $url .= 'isbn=' . $ids . '/' . $img_name;
      break;
    case SYNDETICS_TYPE_OCLC:
      $url .= 'isbn=/' . $img_name . '&OCLC=' . $ids;
      break;
    case SYNDETICS_TYPE_UPC:
      $url .= 'isbn=/' . $img_name . '&UPC=' . $ids;
      break;
    case SYNDETICS_TYPE_COMPLEX:
      $url .= 'isbn=' . $ids['ISBN'] . '/' . $img_name . '&UPC=' . $ids['UPC']
        . '&OCLC=' . $ids['OCLC'];
      break;
  }
  $url .= '&client=' . syndetics_get_client_code() . '&type=xw10';
  return $url;
}

/**
 * Get the URL of Syndetics' index.xml
 *
 * @param $ids (String or Array)
 *   Array or string of identifier(s)
 * @param $id_type (String)
 *   The type of identifier
 *
 * @return (String)
 *   The URL of Syndetics' index.xml
 */
function syndetics_get_index_url($ids, $id_type) {
  $url = 'http://syndetics.com/index.aspx?';
  switch ($id_type) {
    case SYNDETICS_TYPE_ISBN:
      $url .= 'isbn=' . $ids . '/index.xml';
      break;
    case SYNDETICS_TYPE_OCLC:
      $url .= 'isbn=/index.xml&OCLC=' . $ids;
      break;
    case SYNDETICS_TYPE_UPC:
      $url .= 'isbn=/index.xml&UPC=' . $ids;
      break;
    case SYNDETICS_TYPE_COMPLEX:
      $url .= 'isbn=' . $ids['ISBN'] . '/index.xml' . '&UPC=' . $ids['UPC']
        . '&OCLC=' . $ids['OCLC'];
      break;
  }
  $url .= '&client=' . syndetics_get_client_code() . '&type=xw10';
  return $url;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function syndetics_init() {
  global $_syndetics_object_types, $_syndetics_types, $_syndetics_external_map;

  $_syndetics_object_types = variable_get('syndetics_object_types', array());
  if (empty($_syndetics_object_types)) {
    $_syndetics_object_types = syndetics_get_object_types();
    variable_set('syndetics_object_types', $_syndetics_object_types);
  }

  $_syndetics_types = array(SYNDETICS_TYPE_ISBN, SYNDETICS_TYPE_OCLC, SYNDETICS_TYPE_UPC);

  if (module_exists('xc_external')) {
    $_syndetics_external_map = array(
      'INDEX' => XC_EX_INDEX,
      SYNDETICS_LARGE => XC_EX_COVER_LARGE,
      SYNDETICS_MEDIUM => XC_EX_COVER_MEDIUM,
      SYNDETICS_SMALL => XC_EX_COVER_SMALL,
      'TOC' => XC_EX_TOC,
      'BNATOC' => XC_EX_TOC,
      'SUMMARY' => XC_EX_SUMMARY,
      'GMSUMMARY' => XC_EX_SUMMARY,
      'SPSUMMARY' => XC_EX_SUMMARY,
      'SPREVIEW' => XC_EX_REVIEW,
      'SWEDSUMMARY' => XC_EX_SUMMARY,
      'SWEDTOC' => XC_EX_TOC,
      'SWEDREVIEW' => XC_EX_REVIEW,
      'ITASUMMARY' => XC_EX_SUMMARY,
      'AVSUMMARY' => XC_EX_SUMMARY,
      'DBCHAPTER' => XC_EX_SAMPLE_CHAPTER,
      'LJREVIEW' => XC_EX_REVIEW,
      'PWREVIEW' => XC_EX_REVIEW,
      'SLJREVIEW' => XC_EX_REVIEW,
      'CHREVIEW' => XC_EX_REVIEW,
      'BLREVIEW' => XC_EX_REVIEW,
      'HBREVIEW' => XC_EX_REVIEW,
      'KIRKREVIEW' => XC_EX_REVIEW,
    );
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function syndetics_exit() { }

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function syndetics_get_object_types() {
  $settings = array(
    'INDEX' => t('Index (or Menu) page'),
    'TOC' => t('Table of Contents'),
    'BNATOC' => t('Table of Contents'),
    'FICTION' => t('Fiction/Biography Profile'),
    'FFICTION' => t('Fiction Search (Find Similar Titles)'),
    'SUMMARY' => array(
      'label' => t('Summary / Annotation'),
      'xpath' => 'USMARC/VarFlds/VarDFlds/Notes/Fld520/a',
      'nodeNames' => array('Fld520', 'a'),
    ),
    'GMSUMMARY' => t('German-Language Summary'),
    'SPSUMMARY' => t('Spanish-Language Summary'),
    'SPREVIEW' => t('Spanish Language Review'),
    'SWEDSUMMARY' => t('Swedish-Language Summary'),
    'SWEDTOC' => t('Swedish Language TOC'),
    'SWEDREVIEW' => t('Swedish Language Review'),
    'ITASUMMARY' => t('Italian Language Summary'),
    'AVSUMMARY' => t('Music & Video Summary'),
    'DBCHAPTER' => t('First Chapter or Excerpt'),
    'LJREVIEW' => t('Library Journal Review'),
    'PWREVIEW' => t('Publishers Weekly Review'),
    'SLJREVIEW' => t('School Library Journal Review'),
    'CHREVIEW' => t('CHOICE Review'),
    'BLREVIEW' => t('Booklist Review'),
    'HBREVIEW' => t('Horn Book Review'),
    'KIRKREVIEW' => t('Kirkus Book Review'),
    'ANOTES' => t('Author Notes'),
    //Series  (Fiction only)  (See below)
    //Awards   (See below)
  );

  return $settings;
}
