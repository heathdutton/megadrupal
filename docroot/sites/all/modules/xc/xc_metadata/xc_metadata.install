<?php
/**
 * @file
 * Installation functions for XC Metadata module
 *
 * @copyright (c) 2010-2011 eXtensible Catalog Organization
 */

/**
 * Implements hook_instal().
 */
function xc_metadata_install() {
  drupal_set_time_limit(0);

  // Create default variables
  variable_set('xc_enabled_formats', array());
  variable_set('xc_metadata_entities', array());
  variable_set('xc_metadata_fields', array());
  variable_set('xc_metadata_attributes', array());
  variable_set('xc_metadata_namespaces', array());
  variable_set('xc_metadata_entity_groups', array());
  variable_set('xc_metadata_xc_location_defaults_installed', XC_INSTALLED);
}

/**
 * Implements hook_uninstall().
 */
function xc_metadata_uninstall() {
  drupal_set_time_limit(0);

  // Delete variables
  variable_del('xc_enabled_formats');
  variable_del('xc_metadata_entities');
  variable_del('xc_metadata_fields');
  variable_del('xc_metadata_attributes');
  variable_del('xc_metadata_namespaces');
  variable_del('xc_metadata_entity_groups');
  variable_del('xc_metadata_xc_location_defaults_installed');
}

/**
 * Implements hook_requirements().
 *
 * @param $phase
 */
function xc_metadata_requirements($phase) {
  $requirements = array();
  if ($phase == 'runtime') {
    // check formats
    //require_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'xc_metadata') . '/includes/xc_metadata.format.inc';
    require_once drupal_get_path('module', 'xc_metadata') . ('/includes/xc_metadata.format.inc');
    $formats = xc_format_get();
    if (empty($formats)) {
      $requirements['xc_metadata_formats'] = array(
        'title' => t('XC Metadata Formats'),
        'value' => t('There are no metadata schema available for XC Drupal Toolkit'),
        'description' => t('No formats are available on this system. You must first !install a schema module',
          array('!install' => l(t('install'), 'admin/modules'))),
        'severity' => REQUIREMENT_WARNING,
      );
    }
    else {
      $disabled_formats = array();
      foreach ($formats as $type => $format) {
        if (!xc_format_is_enabled($type)) {
          $disabled_formats[] = $format['name'];
        }
      }
      if (!empty($disabled_formats)) {
        $requirements['xc_metadata_formats'] = array(
          'title' => t('XC Metadata Fromats'),
          'value' => t('There are disabled metadata formats'),
          'description' => t('The following formats are disabled: %formats. You should enable these !here if you want to use them.',
            array(
            '%formats' => join(', ', $disabled_formats),
            '!here' => l(t('here'), 'admin/xc/metadata/format'),
          )),
          'severity' => REQUIREMENT_WARNING,
        );
      }
    } // check formats
    // TODO: check storage location
    $locations = xc_location_get_all();
    if (empty($locations)) {
      $requirements['xc_metadata_locations'] = array(
        'title' => t('XC Metadata Locations'),
        'value' => t('There is no any metadata location.'),
        'description' => t('You should set up a metadata storage location !here!',
          array('!here' => l(t('here'), 'admin/xc/metadata/location'))),
        'severity' => REQUIREMENT_WARNING,
      );
    }
    else {
      $problems = array();
      foreach ($locations as $location) {
        if (!is_array($location->types)) {
          $problems[] = t('%location location has only one storage type, the other is missing.',
            array('%location' => $location->name));
        }
        if (!$location->has_solr_type) {
          $problems[] = t('%location location does not store records into Solr.',
            array('%location' => $location->name));
        }
      }
      if (!empty($problems)) {
        $requirements['xc_metadata_locations'] = array(
          'title' => t('XC Metadata Locations'),
          'value' => t('There is problem with metadata location(s).'),
          'description' => t('!problems<br />Please revise your metadata storage location !here unless you intentionally setup Drupal Toolkit this way',
            array(
            '!problems' => join(' ', $problems),
            '!here' => l(t('here'), 'admin/xc/metadata/location'),
          )
            ),
          'severity' => REQUIREMENT_WARNING,
        );
      }
    }
  }

  return $requirements;
}

/**
 * Implements hook_enable().
 */
function xc_metadata_enable() {
  drupal_set_time_limit(0);
  xc_metadata_rebuild();

  // Add source for Drupal node form
  $node_form_source = new stdClass();
  $node_form_source->name = t('Drupal node form');
  $node_form_source->description = t('Metadata created from Drupal node form');
  $node_form_source->type = 'node_form';

  xc_source_set($node_form_source);

  // imports default values for xc_location table
  if (module_exists('xc_util')) {
    $path = drupal_get_path('module', 'xc_metadata') . '/import/';

    if (variable_get('xc_metadata_xc_location_defaults_installed', XC_UNINSTALLED) == XC_INSTALLED) {
      $filename = $path . 'xc_location.csv';
      xc_util_bulk_insert('xc_location', xc_util_csv2objects($filename, ';', array(), FAlSE));
      variable_set('xc_metadata_xc_location_defaults_installed', XC_LOADED);
    }
  }
}

/**
 * Implements hook_disable().
 */
function xc_metadata_disable() {
  xc_metadata_rebuild();
}

/**
 * Implements hook_schema().
 */
function xc_metadata_schema() {
  drupal_set_time_limit(0);

  $schema['xc_metadata_entity'] = array(
    'description' => 'Information and definitions for available metadata entity types',
    'fields' => array(
      'type' => array(
        'description' => 'Metadata entity machine type name',
        'type' => 'varchar',
        'length' => 28,
        'not null' => TRUE,
      ),
      'node_type' => array(
        'description' => 'Related Drupal node type',
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
      ),
      'title' => array(
        'description' => 'Human-readable metadata entity name',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
      ),
      'description' => array(
        'description' => 'Metadata entity description',
        'type' => 'text',
        'not null' => TRUE,
      ),
      'module' => array(
        'description' => 'Module used to create the entity',
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
      ),
    ),
    'indexes' => array('module' => array('module')),
    'unique keys' => array('node_type' => array('node_type')),
    'primary key' => array('type'),
  );

  $schema['xc_entity_properties'] = array(
    'description' => 'Information about stored metadata entity instances',
    'fields' => array(
      'metadata_id' => array(
        'description' => 'Primary identifier for metadata',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'metadata_type' => array(
        'description' => 'Metadata entity type',
        'type' => 'varchar',
        'length' => 28,
        'not null' => TRUE,
      ),
      'node_id' => array(
        'description' => T('Related node identifier'),
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => FALSE,
      ),
      'node_type' => array(
        'description' => 'Drupal node type',
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
      ),
      'identifier' => array(
        'description' => 'Entity identifier',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
      ),
      'format' => array(
        'description' => 'Metadata format type',
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
      ),
      'source_id' => array(
        'decription' => 'Metadata source identifier',
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
      ),
      'created' => array(
        'description' => 'Creation timestamp',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'updated' => array(
        'description' => 'Last modified or updated timestamp',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'locks' => array(
        'description' => 'Metadata locks',
        'type' => 'text',
        'not null' => TRUE,
      ),
      'locations' => array(
        'description' => 'Metadata locations if not associated with metadata source',
        'type' => 'text',
        'not null' => TRUE,
      ),
      'properties' => array(
        'description' => 'Additional entity properities',
        'type' => 'text',
        'not null' => TRUE,
      ),
      'built' => array(
        'descrpition' => 'Whether the entity has been built',
        'type' => 'int',
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0,
      ),
      'stored' => array(
        'descrpition' => 'Whether the entity has been stored',
        'type' => 'int',
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0,
      ),
      'deleted' => array(
        'descrpition' => 'Whether the entity has been deleted',
        'type' => 'int',
        'size' => 'tiny',
        'not null' => TRUE,
        'default' => 0,
      ),
      'identifier_int' => array(
        'descrpition' => 'Normalized entity identifier',
        'type' => 'int',
        'size' => 'normal',
        'unsigned' => TRUE,
        'not null' => FALSE,
        'default' => 0,
      ),
    ),
    'indexes' => array(
      'node_id' => array('node_id'),
      'node_type' => array('node_type'),
      'node_type_metadata_type' => array('node_type', 'metadata_type'),
      'metadata_type_node_type' => array('metadata_type', 'node_type'),
      'format' => array('format'),
      'source_id' => array('source_id'),
      'identifier_int' => array('identifier_int'),
    ),
    'unique keys' => array(
      'identifier' => array('identifier'),
      /*
 'node_id_metadata_id_identifier' => array('node_id', 'metadata_id', 'identifier'),
 'metadata_id_node_id_identifier' => array('metadata_id', 'node_id', 'identifier'),
 'metadata_id_identifier' => array('metadata_id', 'identifier'),
 'identifier_metadata_id' => array('identifier', 'metadata_id'),
 'node_id_identifier' => array('node_id', 'identifier'),
 'identifier_node_id' => array('identifier', 'node_id'),
 */
    ),
    'primary key' => array('metadata_id'),
  );

  $schema['xc_metadata_field'] = array(
    'description' => 'Information and definitions for available metadata field types',
    'fields' => array(
      'name' => array(
        'description' => 'Metadata field machine name',
        'type' => 'varchar',
        'length' => 64,
        'not null' => TRUE,
      ),
      'namespace' => array(
        'description' => 'Metadata field namespace identifier',
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
      ),
      'title' => array(
        'description' => 'Human-readable metadata field name',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
      ),
      'description' => array(
        'description' => 'Metadata field description',
        'type' => 'text',
        'not null' => TRUE,
      ),
      'module' => array(
        'description' => 'Module used to create the field',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
      ),
      'type' => array(
        'description' => 'Metadata field value data storage type',
        'type' => 'varchar',
        'length' => 16,
        'not null' => TRUE,
      ),
      'size' => array(
        'description' => 'Metadata field value required size',
        'type' => 'int',
        'size' => 'tiny',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'max_size' => array(
        'description' => 'Metadata field value maximum size',
        'type' => 'int',
        'size' => 'tiny',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'required' => array(
        'description' => 'If set to true, the metadata field will be required',
        'type' => 'int',
        'size' => 'tiny',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'default_value' => array(
        'description' => 'Default metadata field value',
        'type' => 'text',
        'size' => 'big',
        'not null' => TRUE,
      ),
      'possible_values' => array(
        'description' => 'Possible values for the metadata field',
        'type' => 'text',
        'size' => 'big',
        'not null' => TRUE,
      ),
    ),
    'indexes' => array('module' => array('module')),
    'primary key' => array('name', 'namespace'),
  );

  $schema['xc_metadata_attribute'] = array(
    'description' => 'Information and definitions for available metadata attribute types',
    'fields' => array(
      'name' => array(
        'description' => 'Metadata attribute machine name',
        'type' => 'varchar',
        'length' => 64,
        'not null' => TRUE,
      ),
      'namespace' => array(
        'description' => 'Metadata attribute namespace identifier',
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
      ),
      'field' => array(
        'description' => 'Qualified field name, to which the attribute belongs',
        'type' => 'varchar',
        'length' => 100,
        'not null' => TRUE,
        'default' => '',
      ),
      'title' => array(
        'description' => 'Human-readable metadata attribute name',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
      ),
      'description' => array(
        'description' => 'Metadata attribute description',
        'type' => 'text',
        'not null' => TRUE,
      ),
      'module' => array(
        'description' => 'Module used to create the attribute',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
      ),
      'type' => array(
        'description' => 'Metadata attribute value data storage type',
        'type' => 'varchar',
        'length' => 16,
        'not null' => TRUE,
      ),
      'size' => array(
        'description' => 'Metadata attribute value required size',
        'type' => 'int',
        'size' => 'tiny',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'max_size' => array(
        'description' => 'Metadata attribute value maximum size',
        'type' => 'int',
        'size' => 'tiny',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'required' => array(
        'description' => 'If set to true, the metadata attribute will be required',
        'type' => 'int',
        'size' => 'tiny',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'default_value' => array(
        'description' => 'Default metadata attribute value',
        'type' => 'text',
        'size' => 'big',
        'not null' => TRUE,
      ),
      'possible_values' => array(
        'description' => 'Possible values for the metadata attribute',
        'type' => 'text',
        'size' => 'big',
        'not null' => TRUE,
      ),
    ),
    'indexes' => array('module' => array('module')),
    'primary key' => array('name', 'namespace', 'field'),
  );

  $schema['xc_metadata_entity_entities'] = array(
    'description' => 'Link table for relationships between metadata entity types',
    'fields' => array(
      'parent' => array(
        'decription' => 'Parent entity type',
        'type' => 'varchar',
        'length' => 28,
        'not null' => TRUE,
      ),
      'child' => array(
        'decription' => 'Child entity type',
        'type' => 'varchar',
        'length' => 28,
        'not null' => TRUE,
      ),
    ),
    'unique keys' => array('child_parent' => array('child', 'parent')),
    'primary key' => array('parent', 'child'),
  );

  $schema['xc_metadata_field_entities'] = array(
    'description' => 'Link table for relationship between a metadata field types and their related metadata entity types',
    'fields' => array(
      'field' => array(
        'description' => 'Related metadata field namespace',
        'type' => 'varchar',
        'length' => 98,
        'not null' => TRUE,
      ),
      'entity' => array(
        'description' => 'Related metadata entity type',
        'type' => 'varchar',
        'length' => 28,
        'not null' => TRUE,
      ),
    ),
    'unique keys' => array('entity_field' => array('entity', 'field')),
    'primary key' => array('field', 'entity'),
  );

  $schema['xc_metadata_field_attributes'] = array(
    'description' => 'Link table for relationship between metadata a field and related metadata attributes',
    'fields' => array(
      'field' => array(
        'description' => 'Related metadata field name',
        'type' => 'varchar',
        'length' => 98,
        'not null' => TRUE,
      ),
      'attribute' => array(
        'description' => 'Related metadata field namespace',
        'type' => 'varchar',
        'length' => 98,
        'not null' => TRUE,
      ),
    ),
    'unique keys' => array('attribute_field' => array('attribute', 'field')),
    'primary key' => array('field', 'attribute'),
  );

  $schema['xc_metadata_namespace'] = array(
    'description' => 'XML namespaces used in entities',
    'fields' => array(
      'prefix' => array(
        'description' => 'URI prefix to display in the XML schema',
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
      ),
      'uri' => array(
        'description' => 'Uniform Resource Identifier for the namespace',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
      ),
      'title' => array(
        'description' => 'Human-readable namespace name',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
      ),
      'description' => array(
        'description' => 'Namespace description',
        'type' => 'text',
        'not null' => TRUE,
      ),
      'module' => array(
        'description' => 'Module used to create the attribute',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
      ),
    ),
    'unique keys' => array('uri_prefix' => array('uri', 'prefix')),
    'primary key' => array('prefix'),
  );

  $schema['xc_metadata_entity_group'] = array(
    'description' => 'Metadata entity group types',
    'fields' => array(
      'type' => array(
        'description' => 'Metadata entity group machine type name',
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
      ),
      'title' => array(
        'description' => 'Human-readable metadata entity group name',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
      ),
      'description' => array(
        'description' => 'Metadata entity group description',
        'type' => 'text',
        'not null' => TRUE,
      ),
      'module' => array(
        'description' => 'Module used to create the entity group type',
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
      ),
      'primary_entity' => array(
        'description' => 'Base entity type for entity group',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
      ),
      'entities' => array(
        'description' => 'Entity types for inclusion or exclusion',
        'type' => 'text',
        'size' => 'big',
        'not null' => TRUE,
      ),
      'fields' => array(
        'description' => 'Field types for inclusion or exclusion',
        'type' => 'text',
        'size' => 'big',
        'not null' => TRUE,
      ),
      'attributes' => array(
        'description' => 'Attribute types for inclusion or exclusion',
        'type' => 'text',
        'size' => 'big',
        'not null' => TRUE,
      ),
      'namespaces' => array(
        'description' => 'Namespaces for inclusion or exclusion',
        'type' => 'text',
        'size' => 'big',
        'not null' => TRUE,
      ),
    ),
    'indexes' => array('module' => array('module')),
    'primary key' => array('type'),
  );

  $schema['xc_path'] = array(
    'description' => 'Metadata paths that describe specific entity relations and are needed to form a complete metadata tree structure',
    'fields' => array(
      'path_id' => array(
        'description' => 'Primary identifier for a metadata path',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'path' => array(
        'description' => 'Entry specifying the path from a top-most entity to a bottom-most entity in a metadata tree',
        'type' => 'text',
        'not null' => TRUE,
      ),
      'timestamp' => array(
        'description' => 'The last time the path was built',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
    ),
    //    'unique keys' => array('path' => array('path')),
    'primary key' => array('path_id'),
  );

  $schema['xc_entity_relationships'] = array(
    'description' => 'Link table for relationships between metadata entity instances',
    'fields' => array(
      'parent' => array(
        'decription' => 'Parent entity instance',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'child' => array(
        'decription' => 'Child entity instance',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
    ),
    'indexes' => array(
      'parent' => array('parent'),
      'child' => array('child'),
    ),
    'unique keys' => array('child_parent' => array('child', 'parent')),
    'primary key' => array('parent', 'child'),
  );

  $schema['xc_source'] = array(
    'description' => 'Information about metadata sources',
    'fields' => array(
      'source_id' => array(
        'description' => 'Primary identifier for metadata source',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'name' => array(
        'description' => 'Metadata source name',
        'type' => 'text',
        'not null' => TRUE,
      ),
      'description' => array(
        'description' => 'Metadata source description',
        'type' => 'text',
        'not null' => TRUE,
      ),
      'type' => array(
        'description' => 'Metadata source type',
        'type' => 'varchar',
        'length' => 32,
        'not null' => TRUE,
      ),
    ),
    'indexes' => array(
      'type' => array('type'),
    ),
    'primary key' => array('source_id'),
  );

  $schema['xc_location'] = array(
    'description' => 'Information about metadata storage locations',
    'fields' => array(
      'location_id' => array(
        'description' => 'Primary identifier for metadata storage location',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'name' => array(
        'description' => 'Metadata storage location name',
        'type' => 'text',
        'not null' => TRUE,
      ),
      'description' => array(
        'description' => 'Metadata storage location description',
        'type' => 'text',
        'not null' => TRUE,
      ),
      'types' => array(
        'description' => 'Metadata storage types for this location',
        'type' => 'text',
        'not null' => TRUE,
      ),
    ),
    'primary key' => array('location_id'),
  );

  $schema['xc_source_locations'] = array(
    'description' => 'Lookup table for metadata source and locations',
    'fields' => array(
      'source_id' => array(
        'description' => 'Metadata source identifier',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'location_id' => array(
        'description' => 'Metadata storage location identifier',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'weight' => array(
        'description' => 'Weight for ordering location priority',
        'type' => 'int',
        'unsigned' => FALSE,
        'not null' => FALSE,
        'default value' => 0,
      ),
    ),
    'indexes' => array(
      'location_source_weight' => array('location_id', 'source_id', 'weight'),
      //      'source_location_weight' => array('source_id', 'location_id', 'weight')
    ),
    'primary key' => array('source_id', 'location_id', 'weight'),
  );

  return $schema;
}
