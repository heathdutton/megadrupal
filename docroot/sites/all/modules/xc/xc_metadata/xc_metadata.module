<?php
/**
 * @file
 * XC Metadata functions
 *
 * @copyright (c) 2010-2011 eXtensible Catalog Organization
 */

require_once('lib/XCMetadata.php');
require_once('lib/XCMetadataEntity.php');
require_once('lib/XCMetadataField.php');
require_once('lib/XCMetadataAttribute.php');
require_once('lib/XCMetadataNamespace.php');
require_once('lib/XCMetadataEntityGroup.php');
require_once('lib/XCEntity.php');

// require_once('includes/xml_to_array.inc');
// require_once('includes/dom_to_array.inc');

require_once('includes/xc_metadata.format.inc');
require_once('includes/xc_metadata.location.inc');
require_once('includes/xc_metadata.source.inc');
require_once('includes/xc_metadata.delete.inc');
require_once('includes/xc_metadata.lookup.inc');
/**
 * Permission for accessing metadata
 * @var string
 */
define('ACCESS_METADATA', 'access metadata');

/**
 * Permission for administering metadata
 * @var string
 */
define('ADMINISTER_METADATA', 'administer metadata');

/**
 * Permission for administering metadata locations
 * @var string
 */
define('ADMINISTER_METADATA_LOCATIONS', 'administer metadata locations');

/**
 * Permission for administering metadata formats
 * @var string
 */
define('ADMINISTER_METADATA_FORMATS', 'administer metadata formats');

/**
 * Permission for accessing metadata schema
 * @var string
 */
define('ACCESS_METADATA_SCHEMA', 'access metadata schema');

/**
 * Implements hook_permission().
 */
function xc_metadata_permission() {
  return array(
    ACCESS_METADATA => array(
      'title' => t(ACCESS_METADATA),
      'description' => t('ACCESS_METADATA'),
    ),
    ACCESS_METADATA_SCHEMA => array(
      'title' => t(ACCESS_METADATA_SCHEMA),
      'description' => t('ACCESS_METADATA_SCHEMA'),
    ),
    ADMINISTER_METADATA => array(
      'title' => t(ADMINISTER_METADATA),
      'description' => t('ADMINISTER_METADATA'),
    ),
    ADMINISTER_METADATA_LOCATIONS => array(
      'title' => t(ADMINISTER_METADATA_LOCATIONS),
      'description' => t('ADMINISTER_METADATA_LOCATIONS'),
    ),
    ADMINISTER_METADATA_FORMATS => array(
      'title' => t(ADMINISTER_METADATA_FORMATS),
      'description' => t('ADMINISTER_METADATA_FORMATS'),
    ),
  );
}

/**
 * Refresh the metadata cache and related Drupal cache to ensure that updates
 * to metadata definitions and instances are properly loaded
 */
function xc_metadata_rebuild($now = FALSE) {
  // Clear caches
  xc_metadata_cache_clear_all();
  xc_cache_clear_all();
  cache_clear_all();

  // Reset all metadata references
  xc_metadata_reset();

  // Refresh Metadata module's knowledge of schema node types
  xc_metadata_node_info(TRUE);
  node_types_rebuild();

  // Rebuild menu, although it usually doesnt work
  menu_rebuild();

  // Clear Drupal caches
  drupal_get_schema(NULL, TRUE);
  drupal_flush_all_caches();
}

/**
 * Reset only Metadata module related caches as well as entity, field, attribute,
 * and namespace related variables
 */
function xc_metadata_reset() {
  xc_metadata_get_entities(TRUE);
  xc_metadata_get_fields(TRUE);
  xc_metadata_get_attributes(TRUE);
  xc_metadata_get_namespaces(TRUE);
  xc_metadata_get_entity_groups(TRUE);

  require_once('includes/xc_metadata.format.inc');
  xc_format_get('all', TRUE);
}

/**
 * Get the metadata entity type for a particular node type, if possible.
 *
 * @see _metadata_type_to_node_type()
 * @param $node_type
 *    Node type
 * @return
 *    A metadata entity type
 */
function _node_type_to_metadata_type($node_type) {
  static $metadata_type_map;

  if (!isset($metadata_type_map[$node_type])) {
    $metadata_types = xc_metadata_get_entities();
    $metadata_type_map[$node_type] = FALSE;
    foreach ($metadata_types as $metadata_type) {
      if ($metadata_type['node_type'] == $node_type) {
        $metadata_type_map[$node_type] = $metadata_type['type'];
        break;
      }
    }
  }

  return $metadata_type_map[$node_type];
}

/**
 * Gets the node type for particular metadata entity type, if possible.
 *
 * @see _node_type_to_metadata_type()
 *
 * @param $type (string)
 *    Metadata entity type
 *
 * @return (string)
 *    A node type
 */
function _metadata_type_to_node_type($type) {
  static $cache;

  if (!isset($cache[$type])) {
    $entity_types = xc_metadata_get_entities();
    foreach ($entity_types as $key=>$entity_type) {
      if ($entity_type['type'] == $type) {
        $cache[$type] = $entity_type['node_type'];
        break;
      }
    }
    if (!isset($cache[$type])) {
      $cache[$type] = NULL;
    }
  }
  return $cache[$type];
}

/**
 * Get the node ID for a particular metadata ID, if possible.
 *
 * @see _node_id_to_metadata_id()
 * @param $metadata_id
 *    Metadata ID
 * @return
 *    A node ID
 */
function _metadata_id_to_node_id($metadata_id) {
  static $cache;

  if (is_array($cache)) {
    $cache = array();
  }

  if (empty($cache[$metadata_id])) {
    $cache[$metadata_id] = db_query('SELECT node_id FROM {xc_entity_properties} WHERE metadata_id = :metadata_id', array(':metadata_id' => $metadata_id))->fetchField();
  }
  return $cache[$metadata_id];
}

/**
 * Get the metadata ID for a particular node ID, if possible.
 *
 * @see _metadata_id_to_node_id()
 * @param $node_id
 *    node ID
 * @return
 *    A Metadata ID
 */
function _node_id_to_metadata_id($node_id) {
  static $cache;

  if (!is_array($cache)) {
    $cache = array();
  }

  if (empty($cache[$node_id])) {
    $cache[$node_id] = db_query('SELECT metadata_id FROM {xc_entity_properties} WHERE node_id = :node_id', array(':node_id' => $node_id))->fetchField();
  }
  return $cache[$node_id];
}

/**
 * Get the metadata ID for a particular identifier, if possible.
 *
 * @see _identifier_to_node_id()
 *
 * @param $node_id
 *    node ID
 *
 * @return
 *    A Metadata ID or FALSE if there is no appropriate metadata id.
 */
function _identifier_to_metadata_id($identifier) {
  static $cache;

  if (!is_array($cache)) {
    $cache = array();
  }

  if (empty($cache[$identifier])) {
    $cache[$identifier] = db_query('SELECT metadata_id FROM {xc_entity_properties} WHERE identifier = :identifier', array(':identifier' => $identifier))->fetchField();
  }
  return $cache[$identifier];
}

function _identifier_to_node_id($identifier) {
  static $cache;
  if (!is_array($cache)) {
    $cache = array();
  }
  if (empty($cache[$identifier])) {
    $cache[$identifier] = db_query("SELECT node_id FROM {xc_entity_properties} WHERE identifier = :identifier", array(':identifier' => $identifier))->fetchField();
  }
  return $cache[$identifier];
}

/**
 * Check if a metadata entity type is defined
 *
 * @param $type
 *    Metadata entity type
 * @return
 *    TRUE by returning the metadata entity type if exists, FALSE otherwise
 */
function xc_metadata_entity_exists($type) {
  static $types, $cache;
  if (!isset($types)) {
    $types = xc_metadata_get_entities();
  }

  if (!isset($cache[$type])) {
    $stored_type = FALSE;
    foreach ($types as $t) {
      if ($t['type'] == $type) {
        $stored_type = $t;
        break;
      }
    }
    $cache[$type] = $stored_type;
  }

  return $cache[$type];
}

/**
 * Load XCEntity from Drupal URL
 *
 * @param metadata_id
 *    Metadata ID
 */
function xc_entity_load($metadata_id) {
  return new XCEntity($metadata_id);
}

/**
 * Load XCEntity from Drupal URL
 *
 * @param metadata_id
 *    Metadata ID
 */
function xc_entity_from_node_id_load($node_id) {
  return new XCEntity(array('node_id' => $node_id));
}

/**
 * Check if a metadata field type is defined
 *
 * @param $name
 *    Metadata attribute name
 * @param $namespace
 *    Metadata attribute namespace
 * @return
 *    TRUE by returning the metadata field array if exists, FALSE otherwise
 */
function xc_metadata_field_exists($name, $namespace = '') {
  $fields = xc_metadata_get_fields();
  foreach ($fields as $field) {
    if ($field['name'] == $name && $field['namespace'] == $namespace) {
      return $field;
    }
  }
  return FALSE;
}

/**
 * Check if a metadata attribute type is defined
 *
 * @param $name
 *    Metadata attribute name
 * @param $namespace
 *    Metadata attribute namespace
 * @return
 *    TRUE by returning the metadata attribute array if exists, FALSE otherwise
 */
function xc_metadata_attribute_exists($name, $namespace = '', $field = '') {
  $attributes = xc_metadata_get_attributes();
  foreach ($attributes as $a) {
    if ($a['name'] == $name
         && $a['namespace'] == $namespace
         && ($field != '' && $a['field'] == $field)) {
      return $a;
      break;
    }
  }
}

/**
 * Check if a metadata namespace type is defined
 *
 * @param $prefix
 *    Metadata namespace prefix
 * @return
 *    TRUE by returning the metadata namespace prefix if exists, FALSE otherwise
 */
function xc_metadata_namespace_exists($prefix) {
  $namespaces = xc_metadata_get_namespaces();
  foreach ($namespaces as $n) {
    if ($n['prefix'] == $prefix) {
      return $n;
    }
  }
}

/**
 * Check if a metadata record type is defined
 *
 * @param $type
 *    Metadata record type
 * @return
 *    TRUE by returning the metadata record type if exists, FALSE otherwise
 */
function xc_metadata_entity_group_exists($type) {
  $groups = xc_metadata_get_entity_groups();
  foreach ($groups as $g) {
    if ($g['type'] == $type) {
      return $g;
    }
  }
}

/**
 * Get the qualified name for a metadata structure type. The qualified name is
 * used in the metadata entity instance array, in database tables, and in many
 * other areas.
 *
 * For 'field' and 'attribute' types, the qualified name is, if specified, the
 * 'namespace' followed by a colon and the 'name' from the array as in:
 *
 *    "ns:fieldname" or "fieldname"
 *    "ns:attributename" or "attributename"
 *
 * For 'entity' and 'record' types, the qualified name is the 'type' from the
 * array as in:
 *
 *    "entityname"
 *    "recordname"
 *
 * For 'namespace' types, the qualified name is the 'prefix' from the array as
 * in:
 *
 *    "prefixname"
 *
 * For 'entity instance', that is, entity objects that contain an actual
 * instance of metadata, the qualified name is the 'metadata_type' followed by a
 * colon and the 'metadata_id' as in:
 *
 *    "entityname:1234567890"
 *
 * If no qualified string can be parsed from the array, an empty string is
 * returned.
 *
 * @see _object_to_qualified_name()
 * @see _qualified_name_to_array()
 * @see _qualified_name_to_object()
 * @param $array
 *    Metadata structure array
 * @param $type
 *    Metadata structure type
 * @return
 *    A string representation of the qualified name, based on the type of
 *    metadata structure specified, or an empty string
 */
function _array_to_qualified_name($array, $type) {
  if (is_object($array)) {
    $array = get_object_vars($array);
  }
  if (!is_array($array)) {
    return '';
  }

  switch ($type) {
    case 'field':
    case 'attribute':
      $_name = $array['name'];
      $_namespace = isset($array['namespace']) ? $array['namespace'] : '';
      $qualified = (!empty($_namespace) ? trim($_namespace) . ':' : '') . trim($_name);
      break;
    case 'entity':
    case 'record':
    case 'group':
    case 'entity group':
      // $_type = $array['type'];
      $qualified = trim($array['type']);
      break;
    case 'namespace':
      // $_prefix = $array['prefix'];
      $qualified = trim($array['prefix']);
      break;
    case 'metadata':
    case 'properties':
    case 'relationships':
      // $_metadata_id = $array['metadata_id'];
      $qualified = trim($array['metadata_id']);
      break;
  }
  return (string) $qualified;
}

/**
 * Implementation of _array_to_qualified_name() for metadata objects
 *
 * @see _array_to_qualified_name()
 * @see _qualified_name_to_object()
 * @see _qualified_name_to_array()
 * @param $object
 *    Metadata object
 * @param $type
 *    Metadata structure type
 * @return
 *    A string representation of the qualified name, based on the type of
 *    metadata structure specified, or an empty string
 */
function _object_to_qualified_name($object, $type) {
  return _array_to_qualified_name($object, $type);
}

/**
 * Get the array structure for a metadata structure type. The array structure
 * name is used in metadata objects and many other areas.
 *
 * For 'field' and 'attribute' types, the array includes the 'namespace' and
 * 'name' from the qualified name.
 *
 * For 'entity' and 'record' types, the array includes the 'type', which is also
 * the qualified name.
 *
 * For 'namespace' types, the array includes the 'prefix', which is also the
 * qualified name.
 *
 * For 'entity instance', that is, entity objects that contain an actual
 * instance of metadata, the array includes the 'metadata_type' and 'metadata_id' from the
 * qualified name.
 *
 * If no array can be created from the qualified name, an empty array is
 * returned.
 *
 * @see _qualified_name_to_object()
 * @see _array_to_qualified_name()
 * @see _object_to_qualified_name()
 *
 * @param $qualified
 *    Metadata qualified name
 * @param $type
 *    Metadata structure type
 * @param $to_object
 *    FALSE to return an array; TRUE to return an object
 *
 * @return
 *    A metadata structure array
 */
function _qualified_name_to_array($qualified, $type, $to_object = FALSE) {
  switch ($type) {
    case 'field':
    case 'attribute':
      $a1 = explode(':', $qualified);
      switch (count($a1)) {
        case 1:
          $metadata = array(
            'name' => $a1[0],
            'namsepace' => '',
          );
          break;
        case 2:
          $metadata = array(
            'name' => $a1[1],
            'namespace' => $a1[0],
          );
          break;
        default:
          $metadata = array();
          break;
      }
      break;

    case 'entity':
    case 'record':
      $metadata = array('type' => trim($qualified));
      break;

    case 'namespace':
      $metadata = array('prefix' => trim($qualified));
      break;

    case 'metadata':
    case 'relationships':
      $metadata = array('metadata_id' => trim($qualified));
      break;
  }

  if ($to_object) {
    $metadata = (object) $metadata;
  }

  return $metadata;
}

/**
 * Implementation of _qualified_name_to_array() for metadata objects
 *
 * @see _qualified_name_to_array()
 * @see _object_to_qualified_name()
 * @see _array_to_qualified_name()
 * @param $qualified
 *    Metadata qualified name
 * @param $type
 *    Metadata structure type
 * @return
 *    A StdClass object for the metadata structure
 */
function _qualified_name_to_object($qualified, $type) {
  return (object) _qualified_name_to_array($qualified, $type, TRUE);
}

/**
 * Gets all metadata entities.
 *
 * @param $update (boolean)
 *    FALSE to load from cache if possible
 *
 * @return (array)
 *    An array of metadata entity type array with entity type name and node
 *    type name for all defined metadata entity types
 */
function xc_metadata_get_entities($update = FALSE) {
  static $types;

  if ($update || !is_array($types)) {
    $types = array();
    $temp_types = array();
    $sql = 'SELECT type, node_type, title FROM {xc_metadata_entity}';
    $result = db_query($sql)->fetchAllAssoc('type');
    $result = object_to_array($result);
    foreach ($result as $entity) {

      $qualified = _array_to_qualified_name($entity, 'entity');
      $temp_entity = (array) $entity;
      $temp_types[$qualified] = array_merge($temp_entity, array('qualified' => $qualified));
    }
    variable_set('xc_metadata_entities', $temp_types);
    $types = $temp_types;
  }
  else {
    $types = variable_get('xc_metadata_entities', array());
  }

  return $types;
}

/**
 * Get all metadata fields
 *
 * @param $update
 *    FALSE to load from cache if possible
 * @return
 *    An array of arrays with field name and namespace for all defined
 *    metadata field types
 */
function xc_metadata_get_fields($update = FALSE) {
  static $fields;

  if ($update || !is_array($fields)) {
    $fields = array();
    $sql = 'SELECT name, namespace, title FROM {xc_metadata_field}';
    $result = db_query($sql);
    foreach ($result as $field) {
      $qualified = _array_to_qualified_name($field, 'field');
      $temp_field = (array) $field;
      $fields[$qualified] = array_merge($temp_field, array('qualified' => $qualified));
    }
    variable_set('xc_metadata_fields', $fields);
  }
  else {
    $fields = variable_get('xc_metadata_fields', array());
  }

  return $fields;
}

/**
 * Get all metadata attributes
 *
 * @param $update
 *    FALSE to load from cache if possible
 * @return
 *    An array of arrays with attribute name and namespace for all defined
 *    metadata attribute types
 */
function xc_metadata_get_attributes($update = FALSE) {
  static $attributes;
  if ($update || !is_array($attributes)) {
    $attributes = array();
    $sql = 'SELECT name, namespace, field, title FROM {xc_metadata_attribute}';
    $result = db_query($sql)->fetchAllAssoc('name');
    $result = object_to_array($result);
    foreach ($result as $attribute) {
      $qualified = _array_to_qualified_name($attribute, 'attribute');
      $temp_attribute = (array)$attribute;
      $attributes[] = array_merge($attribute, array('qualified', $qualified));
    }
    variable_set('xc_metadata_attributes', $attributes);
  }
  else {
    $attributes = variable_get('xc_metadata_attributes', array());
  }
  return $attributes;
}

/**
 * Get all metadata namespaces
 *
 * @param $update
 *    FALSE to load from cache if possible
 * @return
 *    An array of arrays with namespace prefix and uri for all defined
 *    metadata namespace types
 */
function xc_metadata_get_namespaces($update = FALSE) {
  static $namespaces;
  if ($update || !is_array($namespaces)) {
    $namespaces = array();
    $temp_namespaces = array();
    $sql = 'SELECT prefix, uri, title FROM {xc_metadata_namespace}';
    $result = db_query($sql)->fetchAllAssoc('prefix');
    $result = object_to_array($result);
    foreach ($result as $namespace) {
      $qualified = _array_to_qualified_name($namespace, 'namespace');
      $temp_namespace = (array)$namespace;
      $namespaces[$qualified] = array_merge($temp_namespace, array('qualified', $qualified));
    }
    variable_set('xc_metadata_namespaces', $namespaces);
  }
  else {
    $namespaces = variable_get('xc_metadata_namespaces', array());
  }
  return $namespaces;
}

/**
 * Get all metadata records
 *
 * @param $update
 *    FALSE to load from cache if possible
 * @return
 *    An array of arrays with record type for all defined metadata record types
 */
function xc_metadata_get_entity_groups($update = FALSE) {
  static $groups;
  if ($update || !is_array($groups)) {
    $groups = array();
    $sql = 'SELECT type, title FROM {xc_metadata_entity_group}';
    $result = db_query($sql);
    foreach ($result as $group) {
      $qualified = _array_to_qualified_name($group, 'group');
      $groups[$qualified] = array_merge($group, array('qualified', $qualified));
    }
    variable_set('xc_metadata_entity_groups', $groups);
  }
  else {
    $groups = variable_get('xc_metadata_entity_groups', array());
  }
  return $groups;
}

/**
 * Super function for the memory-based caching of metadata definition, instance,
 * and other necessary information.
 *
 * The Metadata module creates two global variables when the page is loaded:
 *
 *    1) $_xc_metadata_cache - to handle caching of metadata definiton objects
 *    2) $_xc_cache - to handle caching of metadata instance objects
 *
 * These variables are multi-dimensional arrays that contain the most updated
 * and cached version of metadata definition or instance objects that are copied
 * be newly constructed object of the particular type.
 *
 * The first level of the $cache array is the $type. The $type specifies what
 * kind of object is being cached. The second level is the $qualified, which is
 * the qualified name of the specific object being cached.
 *
 * All together, this function manages the many cache get, set, clear, and
 * clear all commands for all objects.
 *
 * Future notes:
 *    It may be possible to have modules create their own cache for metadata
 *    and use the metadata cache factory for assistance in handling calls to
 *    run operations on their cache.
 *
 * Cache factory and Drupal:
 *    In addition, this caching factory could be integrated into Drupal's cache
 *    functions. The only reason not to as of now is to keep this cache as a
 *    page load cache, and prevent it from being stored into a more persistent
 *    location, such as a database, as Drupal currently does.
 *
 * @param $cache
 *    Type of cache, such as 'xc' or 'xc_metadata'
 * @param $type
 *    Type name of object being cached
 * @param $qname
 *    Qualified name of the specific object being cached
 * @param $op
 *    Cache operation being conducted, such as 'set', 'get', 'clear', and
 *    'clear all'; default is 'get'
 * @param $object
 *    Object to cache; only needed for 'set'; default is NULL
 * @return
 *    Cached object or NULL
 */
function &_xc_cache_factory($cache, $type, $qname, $op = 'get', $object = NULL, $trace = FALSE) {
  global $_xc_metadatada_cache;

  $cache_type = $cache . '_cache';

  if (is_array($qname) || is_object($qname)) {
    if ($trace) {
      $t_cached = microtime(TRUE);
    }
    $qname = _object_to_qualified_name($qname, $type);
    if ($trace) {
      $t_cached2 = microtime(TRUE);
      xc_oaiharvester_statistics_set('xc_entity_set_relation/new/_object_to_qualified_name2', abs($t_cached2 - $t_cached));
    }
  }

  switch ($op) {
    case 'set':
      if (!empty($object)) {
        $_xc_metadatada_cache[$cache_type][(string) $type][(string) $qname] = $object;
        return $_xc_metadatada_cache[$cache_type][(string) $type][(string) $qname];
      }
      else {
        $return = NULL;
        return $return;
      }
      break;

    case 'get':
      if ($trace) {
        $t_cached = microtime(TRUE);
      }
      if (isset($_xc_metadatada_cache[$cache_type][(string) $type])
          && isset($_xc_metadatada_cache[$cache_type][(string) $type][(string) $qname])) {
        $cached = $_xc_metadatada_cache[$cache_type][(string) $type][(string) $qname];
      }
      else {
        $cached = NULL;
      }
      if ($trace) {
        $t_cached2 = microtime(TRUE);
        xc_oaiharvester_statistics_set('xc_entity_set_relation/new/cache return', abs($t_cached2 - $t_cached));
      }
      return $cached;
      break;

    case 'clear':
      unset($_xc_metadatada_cache[$cache_type][(string) $type][(string) $qname]);
      return $_xc_metadatada_cache[$cache_type];
      break;

    case 'clear all':
      unset($_xc_metadatada_cache[$cache_type]);
      // $_xc_metadatada_cache[$cache_type] = NULL;
      return $_xc_metadatada_cache[$cache_type];
      break;
  }
}

/**
 * Get a metadata definition object from the memory-based cache, if possible
 *
 * @param $type
 *    Type of metadata definition object being cached, such as 'entity',
 *    'field', 'attribute', 'namespace', or 'record'
 * @param $qualified
 *    Qualified name of the specific object being cached
 *
 * @return
 *    Cached object or NULL
 */
function &xc_metadata_cache_get($type, $qualified) {
  return _xc_cache_factory('xc_metadata', $type, $qualified, 'get');
}

/**
 * Set a metadata definition object to the memory-based cache
 *
 * @param $type
 *    Type of metadata definition object being cached, such as 'entity',
 *    'field', 'attribute', 'namespace', or 'record'
 * @param $qname
 *    Qualified name of the specific object being cached
 * @param $object
 *    Object to cache
 * @return
 *    Cached object or NULL
 */
function &xc_metadata_cache_set($type, $qname, $object) {
  return _xc_cache_factory('xc_metadata', $type, $qname, 'set', $object);
}

/**
 * Clear a specific metadata definition object from the cache
 *
 * @param $type
 *    Type of metadata definition object being cached, such as 'entity',
 *    'field', 'attribute', 'namespace', or 'record'
 * @param $qualified
 *    Qualified name of the specific object being cached
 */
function xc_metadata_cache_clear($type, $qualified) {
  _xc_cache_factory('xc_metadata', $type, $qualified, 'clear');
}

/**
 * Clear all metadata definition objects from the cache
 */
function xc_metadata_cache_clear_all() {
  _xc_cache_factory('xc_metadata', NULL, NULL, 'clear all');
}

/**
 * Get a metadata instance object from the cache, if possible
 *
 * @param $type
 *    Type of metadata instance object being cached, such as 'metadata',
 *    'relationships', 'record instance', or 'node'
 * @param $qualified
 *    Qualified name of the specific object being cached
 * @return
 *    Cached object or NULL
 */
function &xc_cache_get($type, $qualified, $trace = FALSE) {
  return _xc_cache_factory('xc', $type, $qualified, 'get', NULL, $trace);
}

/**
 * Set a metadata instance object to the cache
 *
 * @param $type
 *    Type of metadata instance object being cached, such as 'metadata',
 *    'relationships', 'record instance', or 'node'
 * @param $qualified
 *    Qualified name of the specific object being cached
 * @param $object
 *    Object to cache
 * @return
 *    Cached object or NULL
 */
function &xc_cache_set($type, $qualified, $object) {
  return _xc_cache_factory('xc', $type, $qualified, 'set', $object);
}

/**
 * Clear a specific metadata instance object from the cache
 *
 * @param $type
 *    Type of metadata instance object being cached, such as 'metadata',
 *    'relationships', 'record instance', or 'node'
 * @param $qualified
 *    Qualified name of the specific object being cached
 */
function xc_cache_clear($type, $qualified) {
  _xc_cache_factory('xc', $type, $qualified, 'clear');
}

/**
 * Clear all metadata instance objects from the cache
 */
function xc_cache_clear_all() {
  _xc_cache_factory('xc', NULL, NULL, 'clear all');
}

/**
 * Load entity type definition object
 *
 * Uses many different methods to load an entity type definition object, such
 * as passing the entity type name, for example, "work" or "oai_dc" or if an
 * object or array is passed, the 'metadata_type' or 'type' property is used
 *
 * @param $arg
 *    Argumetn or parameter used to instantiate the definition object
 * @return
 *    XCMetadataEntity object -- entity type definition
 */
function xc_metadata_entity_get($arg) {
  if (is_string($arg)) {
    if (xc_metadata_entity_exists($arg)) {
      return new XCMetadataEntity($arg);
    }
    else {
      return FALSE;
    }
  }
  elseif (is_array($arg) || is_object($arg)) {
    $entities = array();

    if (is_object($arg)) {
      $arg = get_object_vars($arg);
    }

    foreach ($arg as $entity) {
      if (isset($entity['metadata_type'])
           && xc_metadata_entity_exists($entity['metadata_type'])) {
        $type = trim($entity['metadata_type']);
      }
      elseif (isset($entity['type'])
           && xc_metadata_entity_exists($entity['type'])) {
        $type = trim($entity['type']);
      }
      elseif (is_string($entity)) {
        $type = trim($entity);
      }

      if (isset($type) && !empty($type) && xc_metadata_entity_exists($type)) {
        $entities[] = new XCMetadataEntity($type);
      }
    }
    return $entities;
  }
  else {
    return array();
  }
}

/**
 * Get an array of possible parent and child entity type definitions for
 * an entity type definition
 *
 * @param $object
 *    XCMetadataEntity object
 * @param $relation
 *    Relationship to current metadata entity type, 'parent' or 'child' or left
 *    blank for both
 * @return
 *    Array of XCMetadataEntity objects -- entity type definitions
 */
function xc_metadata_entity_get_entities(&$object, $relation = NULL) {
  if ($relation) {
    $_entities = xc_metadata_entity_get($object->entities[$relation]);
  }
  else {
    foreach ($object->entities as $key => $entities) {
      $_entities[$key] = xc_metadata_entity_get($entities);
    }
    return $_entities;
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_metadata_entity_get_fields(&$object) {
  return xc_metadata_field_get($object->fields);
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_metadata_entity_get_attributes(&$object) {
  return xc_metadata_attribute_get($object->attributes);
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_metadata_entity_get_namespaces(&$object) {
  return xc_metadata_namespace_get($object->namespaces);
}

/**
 * Set an entity type definition to the database
 *
 * @param XCMetadataEntity $object
 *    Instantiated entity type definition
 * @param $reset
 *    TRUE to reset entity type defintions cache
 * @param $force
 *    TRUE to supress all potential errors and force entity to be set
 * @return
 *    TRUE if entity definition has been created
 */
function xc_metadata_entity_set(XCMetadataEntity &$object, $reset = TRUE, $force = FALSE) {
  if (empty($object->type)) {
    return FALSE;
  }

  if (!$force && empty($object->node_type)) {
    drupal_set_message(
      t("No node type specified for entity type !type Cannot create new or update.",
        array('type' => $object->type)),
      'error');
    return FALSE;
  }

  if ($object->set) {
    // TODO Please review the conversion of this statement to the D7 database API syntax.
    /* db_query($sql, $object->node_type, $object->title, $object->description, $object->type, $object->module) */
    $sql = 'SELECT type, node_type, title, description, module
      FROM {xc_metadata_entity}
      WHERE type = :type AND module = :module';
    $conditions = array(':type' => $object->type, ':module' => $object->module);
    $stored_object = db_query($sql, $conditions)->fetchObject();

    if ($stored_object->node_type != $object->node_type
      || $stored_object->title != $object->title
      || $stored_object->description != $object->description) {
      $update_query = db_update('xc_metadata_entity')
        ->fields(array(
          'node_type' => $object->node_type,
          'title' => $object->title,
          'description' => $object->description,
        ))
        ->condition('type', $object->type)
        ->condition('module', $object->module);
      $result = $update_query->execute();
      if (!$result) {
        $msg = t('Unexpected error. Failed to update existing entity type %type.',
          array('%type' => check_plain($object->type)));
        xc_log_warning('update', 'msg: ' . $msg);
        xc_set_message('XC Metadata', $msg);
        return FALSE;
      }
    }
  }
  else {
    $result = $id = db_insert('xc_metadata_entity')
      ->fields(array(
        'type' => $object->type,
        'node_type' => $object->node_type,
        'title' => $object->title,
        'description' => $object->description,
        'module' => $object->module,
      ))
      ->execute();
  }

  $object->entities = array_unique($object->entities);
  $object->fields = array_unique($object->fields);
  $object->attributes = array_unique($object->attributes);
  $object->namespaces = array_unique($object->namespaces);
  xc_metadata_cache_set('entity', check_plain($object->type), $object);

  if ($reset) {
    xc_metadata_reset();
  }

  return TRUE;
}

/**
 * Set entity type relationships to the database
 *
 * @param XCMetadataEntity $object
 *    Instantiated entity type definition
 * @param $entities
 *    Associated array of entity types to be related to the current entity type
 *    by their relationship, for example, $array['parents'] and $array['children']
 * @param $reset
 *    TRUE to reset entity type defintions cache
 * @param $force
 *    TRUE to supress all potential errors and force entity to be set
 * @return
 *    TRUE if entity relationships have been created
 */
function xc_metadata_entity_set_entities(&$object, $entities = NULL, $reset = TRUE, $force = FALSE) {

  if (!$force && !xc_metadata_entity_exists($object->type)) {
    xc_set_message('XC Metadata',
      t('Cannot relate entities to this entity type %type because the entity type does not exist. The entity type must have been previously set.',
      array('%type' => check_plain($object->type))));
    return FALSE;
  }

  if (!is_array($entities)) {
    $entities = $object->entities;
  }
  $object->entities = $entities;
  if (!is_array($object->entities)) {
    xc_set_message('XC Metadata',
      t('Unable to create relationships for entity type %type.',
      array('%type' => check_plain($object->type))));
    return FALSE;
  }
 
  db_delete('xc_metadata_entity_entities')
    ->condition('parent', $object->type)
    ->condition('child', $object->type)
    ->execute();

  foreach ($entities as $relation => $relationship_entities) {
    if (is_array($relationship_entities)) {
      foreach ($relationship_entities as $entity) {
        if (!$force && !xc_metadata_entity_exists(check_plain($entity['type']))) {
          xc_set_message('XC Metadata',
            t('Cannot create relationship between entity type %type1 and entity type %type2 because the second entity type does not exist.',
            array(
            '%type2' => $object->type,
            '%type2' => check_plain($entity['type']),
          )));
          continue;
        }
        $result = TRUE;
        if ($relation == 'parents') { 
          $select_sql = "SELECT parent FROM {xc_metadata_entity_entities} WHERE parent = '" . $entity['type'] . "' AND child = '" . $object->type . "'";
          $test = db_query($select_sql)->fetchField();
          if (!$test) { 
            $insert_sql = "INSERT INTO {xc_metadata_entity_entities} (parent, child) VALUES ('" . $entity['type'] . "', '" . $object->type . "')";
            $result = db_query($insert_sql);
          }
        }
        elseif ($relation == 'children') { 
          $select_sql = "SELECT parent FROM {xc_metadata_entity_entities} WHERE parent = '" . $object->type . "' AND child = '" . $entity['type'] . "'";

          $test = db_query($select_sql)->fetchField();
          if (!$test) { 
            $insert_sql = "INSERT INTO {xc_metadata_entity_entities} (parent, child) VALUES ('" . $object->type . "', '" . $entity['type'] . "')";
            $result = db_query($insert_sql);
          }
        }
        if (!$result) {
          xc_set_message('XC Metadata',
            t('Unexpected error. Cannot create relationship between entity type %type1 and entity type %type2',
            array(
            '%type1' => check_plain($object->type),
            '%type2' => check_plain($entity['type']),
          )));
          continue;
        }
      }
    }
  }
  $object->entities = array_unique($object->entities);
  xc_metadata_cache_set('entity', check_plain($object->type), $object);
  if ($reset) {
    xc_metadata_reset();
  }
  return $entities;
}

/**
 * Unset an entity type definition from the database
 *
 * @param XCMetadataEntity $object
 *    Instantiated entity type definition
 * @param $reset
 *    TRUE to reset entity type defintions cache
 * @param $force
 *    TRUE to supress all potential errors and force entity to be unset
 * @return
 *    TRUE if entity type definition has been deleted
 */
function xc_metadata_entity_unset(XCMetadataEntity &$object, $reset = TRUE, $force = FALSE) {
  if (!$force && !xc_metadata_entity_exists($object->type)) {
    xc_set_message('XC Metadata',
      t('Cannot remove entity type %type because the entity type does not exist. The entity type must have been previously set.',
      array('%type' => check_plain($object->type))));
    return FALSE;
  } 
  $result = db_delete('xc_metadata_entity')
              ->condition('type', $object->type)
              ->condition('module', $object->module)
              ->execute();
  if (!$result) {
    xc_set_message('XC Metadata',
      t('Unexpected error. Cannot unset entity type %type.',
      array('%type' => check_plain($object->type))));
    return FALSE;
  }
 
  $result = db_delete('xc_metadata_field_entities')
              ->condition('entity', $object->type)
              ->execute();
  if (!$result) {
    xc_set_message('XC Metadata',
      t('Unexpected error. Cannot unset field type associations for entity type %type.',
      array('%type' => check_plain($object->type))));
    return FALSE;
  }
 
  $result = db_delete('xc_metadata_entity_entities')
              ->condition('parent', $object->type)
              ->condition('child', $object->type)
              ->execute();
  if (!$result) {
    xc_set_message('XC Metadata',
      t('Unexpected error. Cannot unset entity type associaitons for entity type %type',
      array('%type' => check_plain($object->type))));
    return FALSE;
  }
  xc_metadata_cache_clear('entity', check_plain($object->type));
  if ($reset) {
    xc_metadata_reset();
  }
  return TRUE;
}

/**
 * Load field type definition object
 *
 * Uses many different methods to load an field type definition object, such
 * as passing the entity type name, for example, "xc:creator" or if an object
 * or array is passed, the 'name' and 'namespace' keys are used
 *
 * @param $arg
 *    Argument or parameter used to instantiate the definition object
 * @return
 *    XCMetadataField object -- field type definition
 */
function xc_metadata_field_get($arg1, $arg2 = NULL) {
  if (is_string($arg1)) {
    if (!is_string($arg2)) {
      $arg1 = _qualified_name_to_array($arg1, 'field');
      $_name = trim($arg1['name']);
      $_namespace = trim($arg1['namespace']);
    }
    else {
      if (!is_null($arg2)) {
        $_name = trim($arg1);
        $_namespace = trim($arg2);
      } else {
        list($_namespace, $_name) = explode(':', $arg1);
      }
    }
    $_field = xc_metadata_field_exists($_name, $_namespace)
      ? new XCMetadataField($_name, $_namespace)
      : FALSE;
    if ($_field) {
      return $_field;
    }
    else {
      return FALSE;
    }
  }
  elseif (is_array($arg1) || is_object($arg1)) {
    $_fields = array();
    if (is_object($arg1)) {
      $arg1 = get_object_vars($arg1);
    }
    foreach ($arg1 as $field) {
      if (is_string($field)) {
        $field = _qualified_name_to_array($field, 'field');
      }
      if (is_array($field)) {
        $_name = trim($field['name']);
        $_namespace = trim($field['namespace']);
        $_field = xc_metadata_field_exists($_name, $_namespace)
          ? new XCMetadataField($_name, $_namespace)
          : FALSE;
        if ($_field) {
          $_fields[] = $_field;
        }
      }
    }
    return $_fields;
  }
  else {
    return array();
  }
}

/**
 * Get an array of all related entity type definitions for a field type
 * definition
 *
 * @param $object
 *    XCMetadataField object
 * @return
 *    Array of XCMetadataEntity objects -- entity type definitions
 */
function xc_metadata_field_get_entities(&$object) {
  return xc_metadata_entity_get($object->entities);
}

/**
 * Get an array of all related attribute type definitions for a field type
 * definition
 *
 * @param $object
 *    XCMetadataField object
 * @return
 *    Array of XCMetadataAttribute objects -- attribute type definitions
 */
function xc_metadata_field_get_attributes(&$field) {
  return xc_metadata_attribute_get(
    $field->attributes,
    '',
    $field->get_qualified_name()
  );
}

/**
 * Set a field type definition to the database
 *
 * @param XCMetadataField $object
 *    Instantiated field type definition
 * @param $reset
 *    TRUE to reset field type defintions cache
 * @param $force
 *    TRUE to supress all potential errors
 *
 * @return
 *    TRUE if field definition has been created
 */
function xc_metadata_field_set(XCMetadataField &$object, $reset = TRUE,
    $force = FALSE) {
  $qualified = _object_to_qualified_name($object, 'field');
  if (empty($qualified)) {
    return FALSE;
  }
  if ($object->set) { 
    $object->size = ($object->size == '') ? '0' : $object->size;
    $object->max_size = ($object->max_size == '') ? '0' : $object->max_size;
    $object->required = ($object->required == '') ? '0' : $object->required;
    $object->default_value = ($object->default_value == '') ? '0' : $object->default_value;
    $object->description = ($object->description == '') ? '0' : $object->description;
    $result = db_update('xc_metadata_field')
                ->fields(array(
                    'title' => $object->title,
                    'description' => $object->description,
                    'type' => $object->type,
                    'size' => $object->size,
                    'max_size' => $object->max_size,
                    'required' => $object->required,
                    'default_value' => $object->default_value,
                    'possible_values' => $object->possible_values,
                  ))
                ->condition('name', $object->name)
                ->condition('namespace', $object->namespace)
                ->condition('module', $object->module)
                ->execute();
  }
  else {
    $object->size = ($object->size == '') ? '0' : $object->size;
    $object->max_size = ($object->max_size == '') ? '0' : $object->max_size;
    $object->required = ($object->required == '') ? '0' : $object->required;
    $object->type = ($object->type == '') ? '0' : $object->type;
    $object->title = ($object->title == '') ? '0' : $object->title;

    $sql = "INSERT INTO {xc_metadata_field} (name, namespace, title,
            description, module, type, size, max_size, required, default_value,
            possible_values) VALUES ('". $object->name . "', '". $object->namespace ."', '". $object->title ."',
              '".$object->description."', '".$object->module."', '".$object->type."', " . $object->size . ",
            '".$object->max_size."', '".$object->required."', '".$object->default_value."', '".$object->possible_values."')";
    $result = db_query($sql);

    $object->set = TRUE;
  }
  $object->entities = array_unique($object->entities);
  $object->attributes = array_unique($object->attributes);
  xc_metadata_cache_set('field', _object_to_qualified_name($object, 'field'), $object);
  if ($reset) {
    xc_metadata_reset();
  }
  return TRUE;
}

/**
 * Set relationships to entity type definitions to the database
 *
 * @param XCMetadataField $object
 *    Instantiated field type definition
 * @param $entities
 *    Array of entity types to be related to the current field type
 * @param $reset
 *    TRUE to reset field type defintions cache
 * @param $force
 *    TRUE to supress all potential errors
 * @return
 *    TRUE if relationships have been created or updated
 */
function xc_metadata_field_set_entities(&$object, $entities = NULL, $reset = TRUE, $force = FALSE) {
  $qualified = check_plain(_object_to_qualified_name($object, 'field'));
  if (!$force && !xc_metadata_field_exists($object->name, $object->namespace)) {
    xc_set_message('XC Metadata',
      t('Cannot associate field %field with any entity types because the field does not exist. The field must have been previously set.',
      array('%field' => $qualified)));
    return FALSE;
  }
  $entities = is_array($entities) ? $entities : $object->entities;
  $object->entities = $entities; 
  $result = db_delete('xc_metadata_field_entities')
              ->condition('field', $qualified)
              ->execute();

  foreach ($entities as $entity) {
    if (!$force && !xc_metadata_entity_exists(check_plain($entity['type']))) {
      xc_set_message('XC Metadata',
        t('Cannot associate field %field with entity type %type. The entity type does not exist.',
        array(
        '%field' => $qualified,
        '%type' => check_plain($entity['type']),
      )));
      continue;
    } 
    $result =   db_insert('xc_metadata_field_entities')
                  ->fields(array(
                      'field' => $qualified,
                      'entity' => $entity['type'],
                    ))
                  ->execute();

  }
  $object->entities = array_unique($object->entities);
  xc_metadata_cache_set('field', $qualified, $object);
  if ($reset) {
    xc_metadata_reset();
  }
  return TRUE;
}

/**
 * Set relationships to attribute type definitions to the database
 *
 * @param XCMetadataField $object
 *    Instantiated field type definition
 * @param $attributes
 *    Array of attribute types to be related to the current field type
 * @param $reset
 *    TRUE to reset field type defintions cache
 * @param $force
 *    TRUE to supress all potential errors
 * @return
 *    TRUE if relationships have been created or updated
 */
function xc_metadata_field_set_attributes(&$object, $attributes = NULL, $reset = TRUE, $force = FALSE) {
  $qualified = check_plain(_object_to_qualified_name($object, 'field'));
  if (!$force && !xc_metadata_field_exists($object->name, $object->namespace)) {
    xc_set_message('XC Metadata',
      t('Cannot associate field %field with any attribute types because the field does not exist. The field must have been previously set.',
      array('%field' => $qualified)));
    return FALSE;
  }

  if (!is_array($attributes)) {
    $attributes = $object->attributes;
  }
  $object->attributes = $attributes;
 
  $result = db_delete('xc_metadata_field_attributes')
              ->condition('field', $qualified)
              ->execute();
  if (!is_array($attributes)) {
    xc_set_message('XC Metadata',
      t('Unexpected error. Cannot associate field %field with attribute types.',
      array('%field' => $qualified)));
    return FALSE;
  }

  foreach ($attributes as $attribute) {
    $attribute_qualified = check_plain(_array_to_qualified_name($attribute,
      'attribute'));
    if (!$force
         && !xc_metadata_attribute_exists($attribute['name'],
          $attribute['namespace'])) {
      xc_set_message('XC Metadata',
        t('Cannot associate field %field with attribute type %attribute. The attribute type does not exist.',
        array(
        '%field' => $qualified,
        '%attribute' => $attribute_qualified,
      )));
      continue;
    }
    $sql2 = "INSERT INTO {xc_metadata_field_attributes} (field, attribute)
          VALUES ('" . $qualified . "', '" . $attribute_qualified . "')";
    // TODO Please convert this statement to the D7 database API syntax.
    $result = db_query($sql2);
  }
  $object->attributes = array_unique($object->attributes);
  xc_metadata_cache_set('field', $qualified, $object);
  if ($reset) {
    xc_metadata_reset();
  }
  return TRUE;
}

/**
 * Unset an field type definition from the database
 *
 * @param XCMetadataField $object
 *    Instantiated field type definition
 * @param $reset
 *    TRUE to reset field type defintions cache
 * @param $force
 *    TRUE to supress all potential errors and force entity to be unset
 * @return
 *    TRUE if field type definition has been deleted
 */
function xc_metadata_field_unset(XCMetadataField &$object, $reset = TRUE, $force = FALSE) {
  $qualified = _object_to_qualified_name($object, 'field');
  if (!$force && !xc_metadata_field_exists($object->name, $object->namespace)) {
    xc_set_message('XC Metadata',
      t('Cannot remove field type %type because the field type does not exist. The field type must have been previously set.',
      array('%type' => check_plain($object->type))));
    return FALSE;
  } 
  $result = db_delete('xc_metadata_field')
              ->condition('name', $object->name)
              ->condition('namespace', $object->namespace)
              ->condition('module', $object->module)
              ->execute();

  if (!$result) {
    xc_set_message('XC Metadata',
      t('Unexpected error. Cannot unset field type %type.',
      array('%type' => check_plain($qualified))));
    return FALSE;
  }
 
  $result = db_delete('xc_metadata_field_entities')
              ->condition('field', $qualified)
              ->execute();
  if (!$result) {
    xc_set_message('XC Metadata',
      t('Unexpected error. Cannot unset entity type associations for field type %type.',
      array('%type' => check_plain($qualified))));
    return FALSE;
  }
 
  $result = db_delete('xc_metadata_field_attributes')
              ->condition('field', $qualified)
              ->execute();
  if (!$result) {
    xc_set_message('XC Metadata',
      t('Unexpected error. Cannot unset attribute type associations for field type %type.',
      array('%type' => check_plain($qualified))));
    return FALSE;
  }
  xc_metadata_cache_clear('field', check_plain($qualified));
  if ($reset) {
    xc_metadata_reset();
  }
  return TRUE;
}

/**
 * Load attribute type definition object
 *
 * Uses many different methods to load an attribute type definition object, such
 * as passing the entity type name, for example, "xsi:type" or if an object
 * or array is passed, the 'name' and 'namespace' keys are used
 *
 * @param $arg
 *    Argument or parameter used to instantiate the definition object
 *
 * @return
 *    XCMetadataAttribute object -- attribute type definition
 */
function xc_metadata_attribute_get($arg1, $arg2 = NULL, $field = '') {
  if (is_string($arg1)) {
    if (!is_string($arg2)) {
      $arg1 = _qualified_name_to_array($arg1, 'attribute');
      $_name = trim($arg1['name']);
      $_namespace = isset($arg1['namespace']) ? trim($arg1['namespace']) : '';
    }
    else {
      $_name = trim($arg1);
      $_namespace = trim($arg2);
    }

    $exists = xc_metadata_attribute_exists($_name, $_namespace, $field);
    if ($exists) {
      $_attribute = new XCMetadataAttribute($_name, $_namespace, $field);
      return $_attribute;
    }
    else {
      return FALSE;
    }
  }
  elseif (is_array($arg1) || is_object($arg1)) {
    $_attributes = array();
    if (is_object($arg1)) {
      $arg1 = get_object_vars($arg1);
    }
    foreach ($arg1 as $attribute) {
      if (is_string($attribute)) {
        $attribute = _qualified_name_to_array($attribute, 'attribute');
        $attribute['field'] = $field;
      }
      elseif (is_array($attribute) && !isset($attribute['field'])) {
        $attribute['field'] = $field;
      }

      if (is_array($attribute)) {
        $_name = trim($attribute['name']);
        $_namespace = isset($attribute['namespace']) ? trim($attribute['namespace']) : '';
        $_field = trim($attribute['field']);

        if (xc_metadata_attribute_exists($_name, $_namespace, $_field)) {
          $_attribute = new XCMetadataAttribute($_name, $_namespace, $_field);
          if ($_attribute) {
            $_attributes[] = $_attribute;
          }
        }
      }
    }
    return $_attributes;
  }
  else {
    return array();
  }
}

/**
 * Get an array of all related field type definitions for an attribute type
 * definition
 *
 * @param $object
 *    XCMetadataAttribute object
 * @return
 *    Array of XCMetadataField objects -- field type definitions
 */
function xc_metadata_attribute_get_fields(&$object) {
  return xc_metadata_field_get($object->fields);
}

/**
 * Set an attribute type definition to the database
 *
 * @param XCMetadataAttribute $object
 *    Instantiated attribute type definition
 * @param $reset
 *    TRUE to reset attribute type defintions cache
 * @param $force
 *    TRUE to supress all potential errors
 * @return
 *    TRUE if attribute type definition has been created
 */
function xc_metadata_attribute_set(XCMetadataAttribute &$object, $reset = TRUE,
    $force = FALSE) {

  $qualified = _object_to_qualified_name($object, 'field');

  if (empty($qualified)) {
    return FALSE;
  }

  if ($object->set) {
    $result = db_update('xc_metadata_attribute')
                ->fields(array(
                    'title' => $object->title,
                    'description' => $object->description,
                    'type' => $object->type,
                    'size' => $object->size,
                    'max_size' => $object->max_size,
                    'required' => $object->required,
                    'default_value' => $object->default_value,
                    'possible_values' => serialize($object->possible_values),
                  ))
                ->condition('name', $object->name)
                ->condition('namespace', $object->namespace)
                ->condition('module', $object->module)
                ->condition('field', $object->field)
                ->execute();
  }
  else {
    $object->title = ($object->title == '') ? '0' : $object->title;
    $object->description = ($object->description == '') ? '0' : $object->description;
    $object->module = ($object->module == '') ? '0' : $object->module;
    $object->type = ($object->type == '') ? '0' : $object->type;
    $object->size = ($object->size == '') ? '0' : $object->size;
    $object->max_size = ($object->max_size == '') ? '0' : $object->max_size;
    $object->required = ($object->required == '') ? '0' : $object->required;
    $object->default_value = ($object->default_value == '') ? '0' : $object->default_value;
    $object->possible_values = ($object->possible_values == '') ? '0' : $object->possible_values;

    $result = db_insert('xc_metadata_attribute')
                      ->fields(array(
                          'name' => $object->name,
                          'namespace' => $object->namespace,
                          'field' => $object->field,
                          'title' => $object->title,
                          'description' => $object->description,
                          'module' => $object->module,
                          'type' => $object->type,
                          'size' => $object->size,
                          'max_size' => $object->max_size,
                          'required' => $object->required,
                          'default_value' => $object->default_value,
                          'possible_values' => serialize($object->possible_values),
                        ))
                      ->execute();

    $object->set = TRUE;
  }
  xc_metadata_cache_set('attribute', $object->field . '@' . $qualified, $object);
  if ($reset) {
    xc_metadata_reset();
  }
  return TRUE;
}

/**
 * Unset an attribute type definition from the database
 *
 * @param XCMetadataAttribute $object
 *    Instantiated attribute type definition
 * @param $reset
 *    TRUE to reset attribute type defintions cache
 * @param $force
 *    TRUE to supress all potential errors
 * @return
 *    TRUE if attribute type definition has been deleted
 */
function xc_metadata_attribute_unset(XCMetadataAttribute &$object, $reset = TRUE, $force = FALSE) {
  $qualified = _object_to_qualified_name($object, 'attribute');
  if (!$force && !xc_metadata_attribute_exists($object->name, $object->namespace)) {
    xc_set_message('XC Metadata',
      t('Cannot remove attribute type %type because the attribute type does not exist. The attribute type must have been previously set.',
      array('%type' => check_plain($object->type))));
    return FALSE;
  }

  $result = db_delete('xc_metadata_attribute')
              ->condition('name', $object->name)
              ->condition('namespace', $object->namespace)
              ->condition('module', $object->module)
              ->condition('field', $object->field)
              ->execute();
  if (!$result) {
    xc_set_message('XC Metadata',
      t('Unexpected error. Cannot unset attribute type %type.',
      array('%type' => check_plain($qualified))));
    return FALSE;
  }

  $result = db_delete('xc_metadata_field_attributes')
              ->condition('attribute', $qualified)
              ->execute();
  if (!$result) {
    xc_set_message('XC Metadata',
      t('Unexpected error. Cannot unset attribute type associaitons for field type %type.',
      array('%type' => check_plain($qualified))));
    return FALSE;
  }
  xc_metadata_cache_clear('attribute', check_plain($qualified));
  if ($reset) {
    xc_metadata_reset();
  }
  return TRUE;
}

/**
 * Load namespace type definition object
 *
 * Uses many different methods to load an entity type definition object, such
 * as passing the namespace name, for example, "xc"
 *
 * @param $arg
 *    Argument or parameter used to instantiate the definition object
 * @return
 *    XCMetadataNamespace object -- namespace type definition
 */
function xc_metadata_namespace_get($arg) {
  if (is_string($arg)) {
    $_namespace = xc_metadata_namespace_exists($arg)
      ? new XCMetadataNamespace($arg)
      : FALSE;
    if ($_namespace) {
      return $_namespace;
    }
    else {
      return FALSE;
    }
  }
  elseif (is_array($arg) || is_object($arg)) {
    $_namespaces = array();
    if (is_object($arg)) {
      $arg = get_object_vars($arg);
    }
    foreach ($arg as $namespace) {
      if (isset($namespace['prefix'])) {
        $_prefix = trim($namespace['prefix']);
      }
      elseif (is_string($namespace)) {
        $_prefix = trim($namespace);
      }
      if (!empty($_prefix)) {
        $_namespace = xc_metadata_namespace_exists($_prefix)
          ? new XCMetadataNamespace($_prefix)
          : FALSE;
        if ($_namespace) {
          $_namespaces[] = $_namespace;
        }
      }
    }
    return $_namespaces;
  }
  else {
    return array();
  }
}

/**
 * Get an array of all related field type definitions for a namespace type
 * definition
 *
 * @param $object
 *    XCMetadataNamespace object
 * @return
 *    Array of XCMetadataField objects -- field type definitions
 */
function xc_metadata_namespace_get_fields(&$object) {
  return xc_metadata_field_get($object->fields);
}

/**
 * Get an array of all related attribute type definitions for a namespace type
 * definition
 *
 * @param $object
 *    XCMetadataNamespace object
 * @return
 *    Array of XCMetadataAttribute objects -- attribute type definitions
 */
function xc_metadata_namespace_get_attributes(&$object) {
  return xc_metadata_attribute_get($object->attributes);
}

/**
 * Set a namespace type definition to the database
 *
 * @param XCMetadataNamespace $object
 *    Instantiated namespace type definition
 * @param $reset
 *    TRUE to reset entity type defintions cache
 * @param $force
 *    TRUE to supress all potential errors
 * @return
 *    TRUE if the namespace definition has been created
 */
function xc_metadata_namespace_set(XCMetadataNamespace &$object, $reset = TRUE,
    $force = FALSE) {
  if (empty($object->prefix)) {
    return FALSE;
  }
  if ($object->set) {
    $result = db_update('xc_metadata_namespace')
                ->fields(array(
                    'uri' => $object->uri,
                    'title' => $object->title,
                    'description' => $object->description,
                  ))
                ->condition('prefix', $object->prefix)
                ->condition('module', $object->module)
                ->execute();
  }
  else {
    $result = $id = db_insert('xc_metadata_namespace')
                      ->fields(array(
                          'prefix' => $object->prefix,
                          'uri' => $object->uri,
                          'title' => $object->title,
                          'description' => $object->description,
                          'module' => $object->module,
                        ))
                      ->execute();
    $object->set = TRUE;
  }
  $object->fields = array_unique($object->fields);
  $object->attributes = array_unique($object->attributes);
  xc_metadata_cache_set('namespace', _object_to_qualified_name($object, 'namespace'), $object);
  if ($reset) {
    xc_metadata_reset();
  }
  return TRUE;
}

/**
 * Unset a namespace type definition from the database
 *
 * @param XCMetadataNamespace $object
 *    Instantiated namespace type definition
 * @param $reset
 *    TRUE to reset the namespace type defintions cache
 * @param $force
 *    TRUE to supress all potential errors
 * @return
 *    TRUE if entity definition has been deleted
 */
function xc_metadata_namespace_unset(XCMetadataNamespace &$object,
    $reset = TRUE, $force = FALSE) {
  if (!$force && !xc_metadata_namespace_exists($object->prefix)) {
    xc_set_message('XC Metadata',
      t('Cannot remove namespace %ns because the namespace does not exist. The namespace must have been previously set.',
      array('%ns' => check_plain($object->prefix))));
    return FALSE;
  }
  $result = db_delete('xc_metadata_namespace')
              ->condition('prefix', $object->prefix)
              ->condition('module', $object->module)
              ->execute();
  if (!$result) {
    xc_set_message('XC Metadata',
      t('Unexpected error. Cannot unset namespace %ns.',
      array('%ns' => check_plain($object->prefix))));
    return FALSE;
  }
  xc_metadata_cache_clear('namespace', $object->prefix);
  if ($reset) {
    xc_metadata_reset();
  }
}

// TODO: METADATA ENTITY GROUPS HAVE NOT BEEN IMPLEMENTED
//       However they may not be necessary at all

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_metadata_entity_group_get($arg) {
  if (is_string($arg)) {
    $_record = xc_metadata_entity_group_exists($arg)
      ? new XCMetadatarecord($arg)
      : FALSE;
    if ($_record) {
      return $_record;
    }
    else {
      return FALSE;
    }
  }
  elseif (is_array($arg) || is_object($arg)) {
    $_records = array();
    if (is_object($arg)) {
      $arg = get_object_vars($arg);
    }

    foreach ($arg as $record) {
      if (isset($record['type'])) {
        $_type = trim($record['type']);
      }
      elseif (is_string($record)) {
        $_type = trim($record);
      }

      if (!empty($_type)) {
        $_record = FALSE;
        if (xc_metadata_entity_group_exists($_type)) {
          $_record = new XCMetadatarecord($_type);
        }
        if ($_record) {
          $_records[] = $_record;
        }
      }
    }
    return $_records;
  }
  else {
    return array();
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_metadata_entity_group_get_entities(&$object, $sort = NULL) {
  if ($sort) {
    $_entities = xc_metadata_entity_get($object->entities[$sort]);
  }
  else {
    foreach ($object->entities as $key => $entities) {
      $_entities[$key] = xc_metadata_entity_get($entities);
    }
    return $_entities;
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_metadata_entity_group_get_fields(&$object, $sort = NULL) {
  if ($sort) {
    $_fields = xc_metadata_field_get($object->fields[$sort]);
  }
  else {
    foreach ($object->fields as $key => $fields) {
      $_fields[$key] = xc_metadata_field_get($fields);
    }
    return $_fields;
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_metadata_entity_group_get_attributes(&$object, $sort = NULL) {
  if ($sort) {
    $_attributes = xc_metadata_attribute_get($object->attributes[$sort]);
  }
  else {
    foreach ($object->attributes as $key => $attributes) {
      $_attributes[$key] = xc_metadata_attribute_get($attributes);
    }
    return $_attributes;
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_metadata_entity_group_get_namespaces(&$object, $sort = NULL) {
  if ($sort) {
    $_namespaces = xc_metadata_namespace_get($object->namespaces[$sort]);
  }
  else {
    foreach ($object->namespaces as $key => $namespaces) {
      $_namespaces[$key] = xc_metadata_namespace_get($namespaces);
    }
    return $_namespaces;
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_metadata_entity_group_set(XCMetadataEntityGroup &$object,
    $reset = TRUE, $force = FALSE) {
  $qualified = check_plain(_object_to_qualified_name($object, 'record'));
  $primary_qualified = check_plain(
    _object_to_qualified_name($object->primary_entity, 'entity'));
  if (!$force
       && (empty($object->primary_entity)
        || !xc_metadata_entity_exists($primary_qualified))) {
    xc_set_message('XC Metadata',
      t('No primary entity type specified or primary entity type does not exist. Cannot create new record type.'));
    return FALSE;
  }
  elseif ($object->set) {
    $result = db_update('xc_metadata_entity_group')
                ->fields(array(
                    'title' => $object->title,
                    'description' => $object->description,
                    'primary_entity' => serialize($object->primary_entity),
                    'entities' => serialize($object->entities),
                    'fields' => serialize($object->fields),
                    'attributes' => serialize($object->attributes),
                    'namespaces' => serialize($object->namespaces),
                  ))
                ->condition('type', $object->type)
                ->condition('module', $object->module)
                ->execute();
    if (!$result) {
      xc_set_message('XC Metadata',
        t('Unexpected error. Failed to update existing record type %type.',
        array('%type' => $qualified)));
      return FALSE;
    }
  }
  else {
    $result = db_insert('xc_metadata_entity_group')
                      ->fields(array(
                          'type' => $object->type,
                          'title' => $object->title,
                          'description' => $object->description,
                          'module' => $object->module,
                          'primary_entity' => serialize($object->primary_entity),
                          'entities' => serialize($object->entities),
                          'fields' => serialize($object->fields),
                          'attributes' => serialize($object->attributes),
                          'namespaces' => serialize($object->namespaces),
                        ))
                      ->execute();
    $object->set = TRUE;
  }
  $object->primary_entity = array_unique($object->primary_entity);
  $object->entities = array_unique($object->entities);
  $object->fields = array_unique($object->fields);
  $object->attributes = array_unique($object->attributes);
  $object->namespaces = array_unique($object->namespaces);
  xc_metadata_cache_set('record', $qualified, $object);
  if ($reset) {
    xc_metadata_reset();
  }
  return TRUE;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_metadata_entity_group_set_entities(&$object, $entities, $sort = NULL) {
  if ($sort) {
    $object->entities[$sort] = $entities;
  }
  else {
    $object->entities = $entities;
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_metadata_entity_group_set_fields(&$object, $fields, $sort = NULL) {
  if ($sort) {
    $object->fields[$sort] = $fields;
  }
  else {
    $object->fields = $fields;
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_metadata_entity_group_set_attributes(&$object, $attributes, $sort = NULL) {
  if ($sort) {
    $object->attributes[$sort] = $attributes;
  }
  else {
    $object->attributes = $attributes;
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_metadata_entity_group_set_namespaces(&$object, $namespaces,
    $sort = NULL) {
  if ($sort) {
    $object->namespaces[$sort] = $namespaces;
  }
  else {
    $object->namespaces = $namespaces;
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_metadata_entity_group_unset(XCMetadataEntityGroup &$object,
    $reset = TRUE, $force = FALSE) {
  $qualified = check_plain(_object_to_qualified_name($object, 'record'));
  if (!$force && !xc_metadata_entity_group_exists($object->type)) {
    xc_set_message('XC Metadata',
      t('Cannot remove record type %type because the record type does not exist. The record type must have been previously set.',
      array('%type' => $qualified)));
    return FALSE;
  }
  $result = db_delete('xc_metadata_entity_group')
              ->condition('type', $object->type)
              ->condition('module', $object->module)
              ->execute();
  if (!$result) {
    xc_set_message('XC Metadata',
      t('Unexpected error. Cannot unset record type %type.',
      array('%type' => $qualified)));
    return FALSE;
  }
  xc_metadata_cache_clear('record', $qualified);
  if ($reset) {
    xc_metadata_reset();
  }
}

/**
 * Gets properties for an XCEntity object, a metadata object
 *
 * @param $object
 *    XCEntity object
 * @param $update
 *    TRUE to refresh the metadata cache
 * @return
 *    XCEntity object with its properties
 */
function xc_entity_get_properties($object, $update = FALSE, $use_cache = TRUE, $caller = FALSE) {
  global $_oaiharvester_statistics;

  $t = microtime(TRUE);
  if ($use_cache) {
    $qualified_name = _object_to_qualified_name($object, 'properties');
    $_cached = xc_cache_get('properties', $qualified_name);
  }
  if (!$use_cache || ((empty($_cached) || $update) && !empty($qualified_name))) {
    // it lists all fields!
    /*
     $sql = 'SELECT metadata_id, metadata_type, node_id, node_type, identifier,
     format, source_id, created, updated, locks, locations, properties,
     built, stored, deleted
     */
    // $sql = 'SELECT metadata_id FROM {xc_entity_properties} WHERE metadata_id = %d';
    $properties = db_query('SELECT * FROM {xc_entity_properties} WHERE metadata_id = :metadata_id', array(':metadata_id' => $object->metadata_id))->fetchObject();
    if ($use_cache && $properties) {
      xc_cache_set('properties', $qualified_name, $properties);
    }
    if ($caller) {
      $t2 = microtime(TRUE);
      xc_oaiharvester_statistics_set($caller . '/xc_entity_get_properties', ($t2 - $t));
    }
    return $properties;
  }
  elseif ($use_cache && !empty($qualified_name)) {
    return $_cached;
  }
  else {
    return FALSE;
  }
}

/**
 * Load XCEntity properties from the database
 *
 * @see xc_entity_get_properties()
 * @param $object
 *    XCEntity object
 */
function xc_entity_load_properties(&$object) {
  $_object = xc_entity_get_properties($object);
  if ($_object) {
    $object->metadata_type = $_object->metadata_type;
    $object->node_type     = $_object->node_type;
    $object->node_id       = $_object->node_id;
    $object->identifier    = $_object->identifier;
    $object->identifier_int = $_object->identifier_int;
    $object->raw           = isset($_object->raw) ? $_object->raw : NULL;
    $object->format        = $_object->format;
    $object->created       = $_object->created;
    $object->updated       = $_object->updated;
    $object->built         = $_object->built;
    $object->stored        = $_object->stored;
    $object->source_id     = $_object->source_id;
    $object->locks         = $_object->locks;
    $object->locations     = $_object->locations;
    $object->properties    = $_object->properties;
  }
}

/**
 * Set properties for an XCEntity object to the database, essentially making
 * the metadata object exist within the XC system
 *
 * @param $object
 *    XCEntity object
 * @param $properties (array)
 *    Additional properties
 * @param $params (array)
 *   Keys:
 *   - identifier_prefix: the OAI identifier prefix
 */
function xc_entity_set_properties(&$object, $properties = NULL, $params = array(), $caller = '_xc_store') {
  global $_oaiharvester_statistics, $_xc_entity_properties_csv;
  static $property_fields;
  $start = microtime(TRUE);

  if (!empty($properties->created)) {
    $object->created = $properties->created;
  }
  if (!empty($properties->updated)) {
    $object->updated = $properties->updated;
  }
  $t_timestamp = microtime(TRUE);
  xc_oaiharvester_statistics_set($caller . '/02 set udated', abs($t_timestamp - $start));

  if (!empty($properties->locks)) {
    $object->locks = $properties->locks;
  }
  $t_locks = microtime(TRUE);
  xc_oaiharvester_statistics_set($caller . '/03 set locks', abs($t_locks - $t_timestamp));

  if (!empty($properties->properties)) {
    $object->properties = $properties->properties;
  }
  $t_properties = microtime(TRUE);
  xc_oaiharvester_statistics_set($caller . '/04 set properties', abs($t_properties - $t_locks));

  if (empty($object->identifier)) {
    // Give a generic identifier, if none is found
    $object->identifier = 'drupal:' . $_SERVER['SERVER_NAME'] . ':node/' . $object->node_id;
  }

  $t_stdClass = microtime(TRUE);
  if (!isset($params['create_node']) || $params['create_node'] == TRUE) {
    if (empty($object->node_type) || empty($object->node_id)) {
      $node        = new stdClass();
      $node->type  = _metadata_type_to_node_type($object->metadata_type);
      $node->title = empty($object->identifier) ? t('Untitled') : $object->identifier;
      node_save($node);

      // Add node type and ID
      $object->node_type = $node->type;
      $object->node_id   = $node->nid;
    }
  }
  else {
    $object->node_id = 0;
  }
  $t_node_save = microtime(TRUE);
  xc_oaiharvester_statistics_set($caller . '/05 node_save', abs($t_node_save - $t_stdClass));
  $return = FALSE;
  //$sql = 'SELECT * FROM {xc_entity_properties} WHERE metadata_id = %d';
  if ((!isset($params['id_generated']) || !$params['id_generated'])
       && !empty($object->metadata_id)
       && ($saved_object = xc_entity_get_properties($object, FALSE, FALSE, $caller . '/05 save SQL'))) {
    $t_update = microtime(TRUE);
    $diffs = array();
    if (!isset($property_fields)) {
      $property_fields = array(
        'serialized' => array('locks', 'locations', 'properties'),
        'others' => array('built', 'stored', 'deleted'),
      );
    }

    foreach ($property_fields['serialized'] as $field) {
      if ((!is_string($object->$field) && $saved_object->$field != serialize($object->$field))
           || (is_string($object->$field) && $saved_object->$field != $object->$field)) {
        $diffs[] = $field;
      }
    }
    foreach ($property_fields['others'] as $field) {
      if ($saved_object->$field != $object->$field) {
        $diffs[] = $field;
      }
    }
    // TODO: check
    if (!empty($diffs)) {
      $sql = 'UPDATE {xc_entity_properties} SET updated = %d';
      $arguments = array(time());
      foreach ($diffs as $field) {
        $serialize = in_array($field, $property_fields['serialized']);
        $sql .= ', ' . $field;
        $sql .= $serialize ? " = '%s'" : ' = %d';
        $arguments[] = $serialize && !is_string($object->$field) ? serialize($object->$field) : $object->$field;
      }
      $sql .= ' WHERE metadata_id = %d';
      $arguments[] = $object->metadata_id;
      $return = db_query($sql, $arguments);
    }
    xc_oaiharvester_statistics_set($caller . '/05 save SQL/01 update SQL', abs(microtime(TRUE) - $t_update));
  }
  else {
    // Insert the properties
    $use_insert = isset($params['use_insert']) ? $params['use_insert'] : 0;
    $t_insert = microtime(TRUE);
    if (!isset($params['use_insert']) || $params['use_insert'] == TRUE) {
      $sql = 'INSERT INTO {xc_entity_properties} (';
      if (isset($object->metadata_id)) {
        $sql .= 'metadata_id, ';
      }
      $sql .= 'metadata_type, node_id, node_type, identifier, format, source_id,
               created, updated, locks, locations, properties, built, stored,
               deleted, identifier_int) VALUES (';
      if (isset($object->metadata_id)) {
        $sql .= '%d, ';
      }
      $sql .= "'%s', %d, '%s', '%s', '%s', '%s', %d, %d, '%s', '%s', '%s', %d, %d, %d, %d)";
      $args = array();
      if (isset($object->metadata_id)) {
        $args[] = $object->metadata_id;
      } //
      array_push($args, $object->metadata_type, $object->node_id, $object->node_type,
        $object->identifier, $object->format, $object->source_id, time(), time(),
        serialize($object->locks), serialize($object->locations), serialize($object->properties),
        $object->built, $object->stored, $object->deleted,
        xc_util_get_identifier_int($object->identifier, $params['identifier_prefix']));

      $return = db_query($sql, $args);
      if (!isset($object->metadata_id) && $return) {
        // TODO: do not use db_last_insert_id with MySQL!!!
        $object->metadata_id = db_last_insert_id('{xc_entity_properties}', 'metadata_id');
      }
    }
    else { // use CSV method
      // fputcsv
      $object->deleted = 0;
      $now = time();
      fwrite($_xc_entity_properties_csv, join(XC_CSV_TAB, array(
        $object->metadata_id,
        $object->metadata_type,
        $object->node_id,
        $object->node_type,
        $object->identifier,
        $object->format,
        $object->source_id,
        $now,
        $now,
        serialize($object->locks),
        serialize($object->locations),
        serialize($object->properties),
        $object->built,
        $object->stored,
        $object->deleted,
        // TODO: remove this line, uncomment next one
        xc_util_get_identifier_int($object->identifier, $params['identifier_prefix'])
        , //str_replace($params['identifier_prefix'], '', $object->identifier)
      )) . XC_CSV_CR);
    }
    xc_oaiharvester_statistics_set($caller . '/05 save SQL/02 insert SQL', abs(microtime(TRUE) - $t_insert));
  }
  $t_sql = microtime(TRUE);
  xc_oaiharvester_statistics_set($caller . '/05 save SQL', abs($t_sql - $t_node_save));

  if ($return) {
    $qualified = _object_to_qualified_name($object, 'properties');
    $t_qualified = microtime(TRUE);
    xc_oaiharvester_statistics_set($caller . '/01 to qualified', abs($t_qualified - $t_sql));
    xc_cache_set('properties', $qualified, $object);
  }
  $t_cache = microtime(TRUE);
  xc_oaiharvester_statistics_set($caller . '/06 xc_cache_set', abs($t_cache - $t_sql));
}

/**
 * Unset properties for an XCEntity object from the database, deleting all
 * necessary information for that object
 *
 * @param $object
 *    XCEntity object
 */
function xc_entity_unset_properties(&$object) {
  $qualified = _object_to_qualified_name($object, 'properties');
  if ($qualified) {
    $result = db_delete('xc_entity_properties')
                ->condition('metadata_id', $object->metadata_id)
                ->execute();
    if (!$result) {
      xc_set_message('XC Metadata',
        t('Unexpected error. Failed to remove metadata properties.'));
    }
    // node_delete($object->node_id);
  }
}

/**
 * Get parent and child relationship for an XCEntity object
 *
 * @param $object
 *    XCEntity object
 * @param $relation
 *    Relationship to return, either 'parents' or 'children' or NULL for both
 * @param $update
 *    TRUE to refresh the relationships cache
 * @return
 *    An associative array of parent and child relationships
 */
function xc_entity_get_relationships(&$object, $relation = FALSE, $update = FALSE, $do_cache = TRUE, $use_int = FALSE) {
  $metadata_id = _object_to_qualified_name($object, 'relationships');
  if (empty($metadata_id)) {
    return array();
  }

  $relationships = $do_cache ? xc_cache_get('relationships', $metadata_id) : array();
  if (empty($relationships) || $update) {
    $relationships = array();
    if ($object->identifier_int) {
      $identifier_int = $object->identifier_int;
    }
    elseif ($object['identifier_int']) {
      $identifier_int = $object['identifier_int'];
    }
    else {
      $identifier_int = xc_metadata_identifier_int_from_metadata_id($metadata_id);
    }

    if (!$do_cache && (!$relation || $relation == 'parents')) {
      $result = db_query('SELECT parent FROM {xc_entity_relationships} WHERE child = :child', array(':child' => $identifier_int));
      foreach ($result as $entity) {
        if ($use_int) {
          $relationships['parents'][] = $entity->parent;
        }
        else {
          $relationships['parents'][] = xc_metadata_metadata_id_from_identifier_int($entity->parent);
        }
      }
    }

    if (!$do_cache && (!$relation || $relation == 'children')) {
      $result = db_query('SELECT child FROM {xc_entity_relationships} WHERE parent = :parent', array(':parent' => $identifier_int));
      foreach ($result as $entity) {
        if ($use_int) {
          $relationships['children'][] = $entity->child;
        }
        else {
          $relationships['children'][] = xc_metadata_metadata_id_from_identifier_int($entity->child);
        }
      }
    }
    if ($do_cache) {
      xc_cache_set('relationships', $metadata_id, $relationships);
    }
  }

  if ($relation) {
    return $relationships[$relation];
  }
  else {
    return $relationships;
  }
}

/**
 * Loads parent and child relationship into an XCEntity object
 *
 * @see xc_entity_get_relationships()
 * @param $object
 *    XCEntity object
 */
function xc_entity_load_relationships(&$object) {
  $relationships = xc_entity_get_relationships($object);
  if ($relationships) {
    $object->relationships = $relationships;
  }
}

/**
 * Sets an XCEntity object's parent and child relationships
 *
 * @param $object
 *    XCEntity object
 * @param $relationships
 *    Associated array of relationships, containing 'parents' and 'children'
 *    keys
 *
 * @return
 *    Associated array of relationships or FALSE if relationships cannot be set
 */
function xc_entity_set_relationships(&$object, $relationships = NULL) {
  $qualified = _object_to_qualified_name($object, 'relationships');
  if (!is_array($relationships)) {
    $relationships = $object->relationships;
  }
  $return = new stdClass();

  // Clear existing relationships
  $or_condition = db_or()
      ->condition('parent', $qualified)
      ->condition('child', $qualified);
  $result = db_delete('xc_entity_relationships')
      ->condition($or_condition)
      ->execute();
  if (!$result || !is_array($relationships)) {
    xc_set_message('XC Metadata', t('Unexpected error. Cannot set relationships for entity.'));
    return FALSE;
  }

  // Create relationships
  foreach ($relationships as $relation => $relationship_entities) {
    foreach ($relationship_entities as $entity) {
      $qualified2 = _array_to_qualified_name($entity, 'metadata');
      if ($relation == 'parents') {
        $result = db_query("INSERT INTO {xc_entity_relationships} (parent, child) VALUES (" . $qualified2 . "," . $qualified . ")");
      }
      elseif ($relation == 'children') {
        $result = db_query("INSERT INTO {xc_entity_relationships} (parent, child) VALUES (" . $qualified . "," . $qualified2 . ")");
      }
    }
  }
  $return->relationships = $relationships;
  xc_cache_set('relationships', $qualified, $return);

  return $return;
}

function xc_entity_set_relation(&$object, $id, $type = 'metadata_id', $relation = 'parent', $update = TRUE) {
  // Make sure the entity exists
  global $_oaiharvester_statistics;
  $t_start = microtime(TRUE);

  $relative = new XCEntity(array($type => $id), TRUE, TRUE,
    array(
    'properties_only' => TRUE,
    'trace_time' => TRUE,
    'caller' => 'xc_entity_set_relation/new XCEntity',
  ));
  $t_new = microtime(TRUE);
  xc_oaiharvester_statistics_set('xc_entity_set_relation/new', abs($t_new - $t_start));

  // Get plural name of relationship
  switch ($relation) {
    case 'parent':
    case 'parents':
      $_relation = 'parents';
      break;
    case 'child':
    case 'children':
      $_relation = 'children';
      break;
  }

  // Qualified name
  $qname_of_relative = _object_to_qualified_name($relative, 'relationships');

  // If relation does not already exist than insert relationship
  if ($relative->metadata_id) {
    if (is_array($object->relationships[$_relation])) {
      foreach ($object->relationships[$_relation] as $rel) {
        if (_array_to_qualified_name($rel, 'relationships') == $qname_of_relative) {
          $relationship_exists = TRUE;
          break;
        }
      }
    }
    if (!$relationship_exists) {
      $object->relationships[$_relation][] = _qualified_name_to_array($qname_of_relative, 'relationships');
    }
  }

  // If update, then set the changes to the database
  if ($update) {
    xc_entity_set_relationships($object);
  }

  $t_stop = microtime(TRUE);
  xc_oaiharvester_statistics_set('xc_entity_set_relation', abs($t_stop - $t_start));
}

/**
 * Make the $id as a parent of an XCEntity object
 *
 * @param $object (XCEntity)
 *   The XCEntity object
 * @param $id (String)
 *   The ID of metadata
 * @param $type (String)
 *   The type of ID (default is 'metadata_id')
 * @param $update (Boolean)
 *   Whether to update object (default is TRUE).
 */
function xc_entity_set_parent(&$object, $id, $type = 'metadata_id', $update = TRUE) {
  xc_entity_set_relation($object, $id, $type, 'parent', $update);
}

/**
 * Make the $id as a child of an XCEntity object
 *
 * @param $xc_entity (XCEntity)
 *   The XCEntity object
 * @param $id (String)
 *   The ID of metadata
 * @param $type (String)
 *   The type of ID (default is 'metadata_id')
 * @param $update (Boolean)
 *   Whether to update object (default is TRUE).
 */
function xc_entity_set_child(&$xc_entity, $id, $type = 'metadata_id', $update = TRUE) {
  xc_entity_set_relation($xc_entity, $id, $type, 'child', $update);
}

/**
 * Saves parent-child relations into xc_entity_relationships.csv file.
 *
 * @param $parent (int)
 *   The parent identifier_int value
 * @param $children_identifiers (Array)
 *   The child identifiers
 * @param $identifier_prefix (String)
 *   The OAI identifier prefix
 * @param $use_insert (Boolean)
 *   If TRUE: use SQL INSERT syntax, otherwise write a CSV
 */
function xc_entity_set_parent_identifiers($parent_identifiers, $child, $identifier_prefix = NULL, $use_insert = 0, $metadata_type = NULL) {
  global $_oaiharvester_is_initial_harvest, $_xc_metadata_statistics;

  if (!$_oaiharvester_is_initial_harvest) { 
    db_delete('xc_entity_relationships')
      ->condition('child', $child)
      ->execute();
  }

  foreach ($parent_identifiers as $identifier) {
    if (!isset($_xc_metadata_statistics->relations['total'])) {
      $_xc_metadata_statistics->relations['total'] = 0;
    }
    $_xc_metadata_statistics->relations['total']++;

    if (!is_null($metadata_type)) {
      if (!isset($_xc_metadata_statistics->relations[$metadata_type])) {
        $_xc_metadata_statistics->relations[$metadata_type] = 0;
      }
      $_xc_metadata_statistics->relations[$metadata_type]++;
    }

    if (is_array($identifier) && $identifier['#value']) {
      $identifier = $identifier['#value'];
    }
    $identifier_int = xc_util_get_identifier_int($identifier, $identifier_prefix);
    xc_metadata_save_relationship($identifier_int, $child, $use_insert);
  }
}

/**
 * Saves parent-child relations into xc_entity_relationships.csv file.
 *
 * @param $parent (int)
 *   The parent identifier_int value
 * @param $children_identifiers (Array)
 *   The child identifiers
 * @param $identifier_prefix (String)
 *   The OAI identifier prefix
 * @param $use_insert (boolean)
 *   If TRUE: use SQL INSERT syntax, otherwise write a CSV
 */
function xc_entity_set_child_identifiers($parent, $children_identifiers, $identifier_prefix = NULL, $use_insert = 0, $metadata_type = NULL) {
  global $_oaiharvester_is_initial_harvest;

  if (!$_oaiharvester_is_initial_harvest) { 
    db_delete('xc_entity_relationships')
      ->condition('parent', $parent)
      ->execute();
  }
  foreach ($children_identifiers as $child_identifier) {
    if (is_array($child_identifier) && $child_identifier['#value']) {
      $child_identifier = $child_identifier['#value'];
    }
    $child = xc_util_get_identifier_int($child_identifier, $identifier_prefix);
    xc_metadata_save_relationship($parent, $child, $use_insert);
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_metadata_save_relationship($parent, $child, $use_insert) {
  global $_xc_entity_relationships_csv;
  if ($use_insert) {
    $record = (object) array(
      'parent' => $parent,
      'child' => $child,
    );
    drupal_write_record('xc_entity_relationships', $record);
  }
  else {
    fwrite($_xc_entity_relationships_csv, $parent . XC_CSV_TAB . $child . XC_CSV_CR);
  }
}

/**
 * Get the child of a parent
 *
 * @param $parent (int)
 *   The indentifier_int value of a parent entity
 *
 * @return (Array)
 *   The array of children entities' indentifier_int values
 */
function xc_entity_get_child_identifiers($parent) {
  static $sql;

  if (!isset($sql)) {
    $sql = 'SELECT child FROM {xc_entity_relationships} WHERE parent = :parent';
  }

  $result = db_query($sql, array(':parent' => $parent));
  $children = array();
  while ($child = $result->fetchField()) {
    $children[] = $child;
  }

  return $children;
}

/**
 * Get the parent of a child
 *
 * @param $child (int)
 *   The indentifier_int value of a parent entity
 *
 * @return (Array)
 *   The array of children entities' indentifier_int values
 */
function xc_entity_get_parent_identifiers($child, $clear_cache = FALSE) {
  static $sql, $cache;

  if ($clear_cache && !empty($cache)) {
    $cache = array();
  }

  if (!isset($cache[$child])) {
    if (!isset($sql)) {
      $sql = 'SELECT parent FROM {xc_entity_relationships} WHERE child = :child';
    }
    $result = db_query($sql, array(':child' => $child));
    $parents = array();
    while ($parent = $result->fetchField()) {
      $parents[] = $parent;
    }
    $cache[$child] = $parents;
  }

  return $cache[$child];
}

/**
 * Unsets an XCEntity object's parent and child relationships
 *
 * @param $object
 *    XCEntity object
 * @return
 *    TRUE if relationships were set
 */
function xc_entity_unset_relationships($object) {
  $q_name = _object_to_qualified_name($object, 'relationships');
  if ($q_name) { 
    $or_condition = db_or()
      ->condition('parent', $q_name)
      ->condition('child', $q_name);
    $result = db_delete('xc_entity_relationships')
      ->condition($or_condition)
      ->execute();
    if (!$result) {
      xc_set_message('XC Metadata', t('Unexpected error. Failed to remove relationships for entity.'));
      return FALSE;
    }
    return TRUE;
  }
}

/**
 * Invokes an XC metadata hook
 *
 * @param $hook
 *    Name of the hook
 * @param $data
 *    Data to pass to the hook, typically either an object (XCEntity or node),
 *    an array containing certain keys, or an array of either objects or arrays
 * @param $args
 *    An array of arguments to pass, such as a storage location objects for the
 *    storage and retrieval hooks
 * @param $params
 *    Additional parameters
 */
function xc_invoke($hook, &$data, $args = array(), $params = array()) {
  switch ($hook) {
    case 'build':
      return _xc_build($data, $args[0], $params);
      break;
    case 'transform':
      return _xc_transform($data, $args[0], $params);
      break;
    case 'store':
      return _xc_store($data, $args[0], $params);
      break;
    case 'remove':
      return _xc_remove($data, $args[0], $params);
      break;
    case 'retrieve':
      return _xc_retrieve($data, $args[0], $params);
      break;
    case 'alter':
      return _xc_alter($data, $params);
      break;
    case 'optimize':
      return _xc_optimize();
      break;
    case 'commit':
      return _xc_commit();
      break;
  }
}

/**
 * Calls hook_xc_build() to build (construct) entity instance objects
 * from its raw input data based on the raw import format.
 *
 * Known implementation in core DT modules:
 * - xc_oai_dc_xc_build
 * - xc_schema_xc_build
 * - xc_oaiharvester_bridge_xc_build
 *
 * @param $objects
 *   An array of XCEntity objects
 * @param $format
 *   Raw input format
 * @param $params
 *   Additional arguments
 *
 * @return unknown_type
 */
function _xc_build(&$objects, $format = '', $params = array()) {
  global $_oaiharvester_statistics;
  static $hooks;
  $return = array();
  $_objects = is_object($objects) ? array($objects) : $objects;
  if (is_array($_objects)) {
    foreach ($_objects as $object) {
      // assure that it is object
      if (!is_object($object)) {
        $object = (object) $object;
      }
      // XC Entity
      if (!($object instanceof XCEntity)) {
        $tnew = microtime(TRUE);
        $object = new XCEntity($object);
      }
      if (empty($format)) {
        $format = $object->format;
      }
      $object->format = $format;
      if (!is_array($object->metadata)) {
        $object->metadata = array();
      }

      $t_hook = microtime(TRUE);
      if (!isset($hooks)) {
        $hooks = array();
        foreach (module_implements('xc_build') as $module) {
          $hooks[] = $module . '_xc_build';
        }
      }
      foreach ($hooks as $function) {
        $metadata = $function($object, $format, $params);
        if (is_array($metadata)) {
          $object->metadata = array_merge($object->metadata, $metadata);
        }
      }
      if ($object->built) {
        $object->node_type   = _metadata_type_to_node_type($object->metadata_type);
        // get metadata_id
        $t_cache_set = microtime(TRUE);
        xc_cache_set('metadata', _object_to_qualified_name($object, 'metadata'), $object);
        $t_set_prop = microtime(TRUE);
        xc_entity_set_properties($object, NULL, $params, '02 bridge/02 _xc_build/04 xc_entity_set_properties');
        $return[] = $object;
      }
    }
  }
  return is_array($objects) ? $return : array_shift($return);
}

/**
 *
 * @param $objects (Array)
 *   The XCEntity object(s)
 * @param $format (String)
 *   Name of the format
 * @param $params (Array)
 *   Keys: id_generated (boolean): the id is already generated, no need to create a new one,
 *   node_create (boolean): the node should be created
 *   identifier_prefix (String): the OAI identifier prefix, which can be removed during normalization
 * @return unknown_type
 */
function _xc_build_store(&$objects, $format = '', $params = array()) {
  global $_oaiharvester_statistics;
  static $build_hooks, $store_hooks;
  $return = array();
  $_objects = is_object($objects) ? array($objects) : $objects;
  if (is_array($_objects)) {
    foreach ($_objects as $object) {
      // assure that it is object
      if (!is_object($object)) {
        $object = (object) $object;
      }
      // XC Entity
      if (!($object instanceof XCEntity)) {
        $tnew = microtime(TRUE);
        $object = new XCEntity($object);
        xc_oaiharvester_statistics_set('01 step1/02 bridge/03 _xc_build_store/01 new XCEntity', abs(microtime(TRUE) - $tnew));
      }
      if (empty($format)) {
        $format = $object->format;
      }
      elseif ($object->format != $format) {
        $object->format = $format;
      }

      if (!is_array($object->metadata)) {
        $object->metadata = array();
      }

      // Build adds metadata part to object
      $t_hook = microtime(TRUE);
      if (!isset($build_hooks)) {
        $build_hooks = array();
        foreach (module_implements('xc_build') as $module) {
          $build_hooks[] = $module . '_xc_build';
        }
      }
      $params['caller'] = '01 step1/02 bridge/03 _xc_build_store/02 hook_xc_build';
      $object->metadata = array();
      foreach ($build_hooks as $function) {
        $metadata = $function($object, $format, $params);
        if (is_array($metadata)) {
          if (empty($object->metadata)) {
            $object->metadata = $metadata;
          }
          else {
            $object->metadata = array_merge_recursive($object->metadata, $metadata);
          }
        }
      }
      xc_oaiharvester_statistics_set('01 step1/02 bridge/03 _xc_build_store/02 hook_xc_build', abs(microtime(TRUE) - $t_hook));

      if ($object->built) {

        $object->node_type   = _metadata_type_to_node_type($object->metadata_type);
        // get metadata_id
        $t_cache_set = microtime(TRUE);
        // xc_cache_set('metadata', _object_to_qualified_name($object, 'metadata'), $object);
        $t_set_prop = microtime(TRUE);
        xc_oaiharvester_statistics_set('01 step1/02 bridge/03 _xc_build_store/03 xc_cache_set', abs($t_set_prop - $t_cache_set));
        $object->stored = TRUE;
        xc_entity_set_properties($object, NULL, $params, '02 bridge/03 _xc_build_store/04 xc_entity_set_properties');
        xc_oaiharvester_statistics_set('01 step1/02 bridge/03 _xc_build_store/04 xc_entity_set_properties', abs(microtime(TRUE) - $t_set_prop));
        //$return[] = $object;
      }
      // old _XC_STORE starts here
      // If object has no metadata, don't even try to store it
      if (empty($object->metadata)) {
        continue;
      }

      $start = microtime(TRUE);
      if (empty($locations)) {
        $source_locations = xc_source_get_locations($object->source_id);
        if (!empty($object->locations) && is_string($object->locations)) {
          $object->locations = unserialize($object->locations);
        }
        if (!empty($object->locations)) {
          $locations = $object->locations;
        }
        elseif (!empty($source_locations)) {
          $locations = $source_locations;
        }
        elseif (!empty($params['locations'])) {
          $locations = $params['locations'];
        }
      }

      // Make sure locations is an array
      if (!is_array($locations) && !is_array(unserialize($locations))) {
        $locations = array();
      }

      $loc_time = microtime(TRUE);
      xc_oaiharvester_statistics_set('01 step1/02 bridge/03 _xc_build_store/01 set locations', abs($loc_time - $start));

      if (!is_object($object)) {
        $object = (object) $object;
      }
      if (!($object instanceof XCEntity)) {
        $object = new XCEntity($object);
      }
      $obj_time = microtime(TRUE);
      xc_oaiharvester_statistics_set('01 step1/02 bridge/03 _xc_build_store/02 set object', abs($obj_time - $loc_time));

      // Create properties or save them first, if necessary
      // xc_entity_set_properties($object, NULL, FALSE, '02 bridge/03 _xc_build_store/03 xc_entity_set_properties');

      $prop_time = microtime(TRUE);
      xc_oaiharvester_statistics_set('01 step1/02 bridge/03 _xc_build_store/03 xc_entity_set_properties', abs($prop_time - $obj_time));

      // xc_entity_set_relationships($object);
      $rel_time = microtime(TRUE);
      xc_oaiharvester_statistics_set('01 step1/02 bridge/03 _xc_build_store/04 xc_entity_set_relationships', abs($rel_time - $prop_time));

      // metadata_id
      //$params['qualified']     = _object_to_qualified_name($object, 'metadata');
      //$params['definition']    = xc_metadata_entity_get($object->metadata_type);
      //$params['relationships'] = $object->relationships;
      //$params['properties']    = $object->properties;
      $para_time = microtime(TRUE);
      xc_oaiharvester_statistics_set('01 step1/02 bridge/03 _xc_build_store/05 set params', abs($para_time - $rel_time));

      // xc_log_info('metadata', 'stored: ' . (int) $object->stored);
      // Store to requested locations
      if (!isset($store_hooks)) {
        $store_hooks = array();
        foreach (module_implements('xc_store') as $module) {
          if ($module != 'xc_solr') {
            $store_hooks[] = $module . '_xc_store';
          }
        }
      }
      foreach ($store_hooks as $function) {
        $function($object, $locations, $params);
      }
      // xc_log_info('metadata', 'stored: ' . (int) $object->stored);
      $store_time = microtime(TRUE);
      xc_oaiharvester_statistics_set('01 step1/02 bridge/03 _xc_build_store/06 hook_xc_store', abs($store_time - $para_time));

      if ($object->stored) {
        $cache_time = microtime(TRUE);
        xc_cache_set('complete', _object_to_qualified_name($object, 'metadata'), $object);
        $set_time = microtime(TRUE);
        xc_oaiharvester_statistics_set('01 step1/02 bridge/03 _xc_build_store/07 xc_cache_set', abs($cache_time - $set_time));
        // xc_entity_set_properties($object, NULL, FALSE, '02 bridge/03 _xc_build_store/08 xc_entity_set_properties');
        xc_oaiharvester_statistics_set('01 step1/02 bridge/03 _xc_build_store/08 xc_entity_set_properties', abs(microtime(TRUE) - $set_time));
        //$return[] = $object;
      }
    }
  }
  //return $return;

  //return is_array($objects) ? $return : array_shift($return);
}

/**
 * Calls hook_xc_transform() to transform (convert) entity instance
 * objects metadata into a desired output format. Returns an array
 * of strings in the output format on success or null on failure.
 *
 * @param $objects Array of XCEntity objects
 * @param $format Output format
 * @param $params Additional arguments
 * @return unknown_type Array of strings or null
 */
function _xc_transform(&$objects, $format = '', $params = array()) {
  $_objects = is_object($objects) ? array($objects) : $objects;
  if (is_array($_objects)) {
    foreach ($_objects as $object) {
      if (!is_object($object)) {
        $object = (object) $object;
      }

      if (!($object instanceof XCEntity)) {
        $object = new XCEntity($object);
      }

      if (empty($format)) {
        $format = $object->format;
      }

      // TODO: commented out, because no usage of qualified
      // $qualified = _object_to_qualified_name($object, 'metadata');
      $key = 0;
      foreach (module_implements('xc_transform') as $module) {
        $function = $module . '_xc_transform';
        $return = $function($object, $format, $params);
        if (!empty($return)) {
          return $return;
        }
      }
    }
  }
}

/**
 * Calls hook_xc_store() to store metadata instances.
 * Has no return value. If no location is specified, it defaults to all locations.
 *
 * @param $objects
 *    Array of XCEntity objects or a single XCEntity object
 * @param $locations
 *    Data storage location
 * @param $params
 *    Additional arguments
 *
 * @return
 *    An array of XCEntity objects if an array was passed or a single XCEntity
 *    object
 */
function _xc_store(&$objects, $locations = array(), $params = array()) {

  $return = array();
  $_objects = is_object($objects) ? array($objects) : $objects;
  if (is_array($_objects)) {
    foreach ($_objects as $object) {
      // If object has no metadata, don't even try to store it
      if (empty($object->metadata)) {
        continue;
      }

      if (empty($locations)) {
        $source_locations = xc_source_get_locations($object->source_id);
        if (!empty($object->locations) && is_string($object->locations)) {
          $object->locations = unserialize($object->locations);
        }
        if (!empty($object->locations)) {
          $locations = $object->locations;
        }
        elseif (!empty($source_locations)) {
          $locations = $source_locations;
        }
        elseif (!empty($params['locations'])) {
          $locations = $params['locations'];
        }
      }

      // Make sure locations is an array
      if (!is_array($locations) && !is_array(unserialize($locations))) {
        $locations = array();
      }

      if (!is_object($object)) {
        $object = (object) $object;
      }
      if (!($object instanceof XCEntity)) {
        $object = new XCEntity($object);
      }

      // Create properties or save them first, if necessary
      xc_entity_set_properties($object, NULL, $params, '02 bridge/03 _xc_store/03 xc_entity_set_properties');
      xc_entity_set_relationships($object);

      // metadata_id
      $params['qualified']     = _object_to_qualified_name($object, 'metadata');
      $params['definition']    = xc_metadata_entity_get($object->metadata_type);
      $params['relationships'] = $object->relationships;
      $params['properties']    = $object->properties;

      // Store to requested locations
      foreach (module_implements('xc_store') as $module) {
        $function = $module . '_xc_store';
        $function($object, $locations, $params);
      }

      if ($object->stored) {
        xc_cache_set('complete', _object_to_qualified_name($object, 'metadata'), $object);
        xc_entity_set_properties($object, NULL, $params, '02 bridge/03 _xc_store/08 xc_entity_set_properties');
        $return[] = $object;
      }
    }
  }
  return $return;
}

/**
 * Calls hook_xc_remove() to remove metadata instances
 *
 * @param $objects
 *    Array of arrays or objects containing metadata types, identifiers,
 *    or anything that can be used to load an XCEntity object
 * @param $locations
 *    Data retrieval locations
 * @param $params
 *    Additional arguments
 */
function _xc_remove(&$objects, $locations = array(), $params = array()) {
  static $removed_nodes, $xc_remove_hooks;

  $_objects = is_object($objects) ? array($objects) : $objects;
  if (!is_array($_objects)) {
    return;
  }
  foreach ($_objects as $entity) {
    if (!is_object($entity)) {
      $entity = (object) $entity;
    }
    if (!($entity instanceof XCEntity)) {
      $entity = new XCEntity($entity);
    }

    if (empty($locations)) {
      $source_locations = xc_source_get_locations($entity->source_id);
      if (!empty($entity->locations) && is_string($entity->locations)) {
        $entity->locations = unserialize($entity->locations);
      }
      if (!empty($entity->locations)) {
        $locations = $entity->locations;
      }
      elseif (!empty($source_locations)) {
        $locations = $source_locations;
      }
      elseif (!empty($params['locations'])) {
        $locations = $params['locations'];
      }
    }

    // Make sure locations is an array
    if (!is_array($locations)) {
      $locations = array();
    }


    if (!empty($entity->metadata_id)) {
      // get metadata_id
      $params['qualified']     = _object_to_qualified_name($entity, 'metadata');
      $params['definition']    = xc_metadata_entity_get($entity->metadata_type);
      $params['relationships'] = $entity->relationships;
      $params['properties']    = $entity->properties;

      if (!isset($xc_remove_hooks)) {
        $hook = 'xc_remove';
        $xc_remove_hooks = array();
        foreach (module_implements($hook) as $module) {
          $function = $module . '_' . $hook;
          $xc_remove_hooks[] = $function;
        }
      }

      foreach ($xc_remove_hooks as $function) {
        $function($entity, $locations, $params);
      }

      xc_cache_clear('metadata', _object_to_qualified_name($entity, 'metadata'));

      // Delete everything at the absolute end
      xc_entity_unset_relationships($entity);
      xc_entity_unset_properties($entity);
    }
  }
}

/**
 * Calls hook_xc_retrieve() to retrieve metadata instances. Returns an
 * array of XCEntity objects.
 *
 * @param $objects
 *    Array of arrays or objects containing metadata types, identifiers,
 *    or anything that can be used to load an XCEntity object
 * @param $locations
 *    Data retrieval locations
 * @param $params
 *    Additional arguments
 * @return
 *    Array of XCEntity objects if an array was passed or a single XCEntity
 *    object
 */
function _xc_retrieve(&$objects, $location = NULL, $params = array()) {
  static $xc_retrieve_hooks;

  $_objects = is_object($objects) ? array($objects) : $objects;

  if (!is_array($_objects)) {
    return;
  }

  $return = array();
  foreach ($_objects as $object) {
    // Fetch everything at the beginning
    xc_entity_load_properties($object);
    xc_entity_load_relationships($object);

    $properties_only = isset($params['properties_only']) ? $params['properties_only'] : FALSE;
    if ($object->built
         && $object->stored
         && !$properties_only) {
      if (isset($params['load_metadata']) && $params['load_metadata'] === FALSE) {
        continue;
      }
      if (empty($location)) {
        $default_source_location = xc_source_get_default_location($object->source_id);
        if (!empty($object->location)) {
          // TODO: Currently, it just takes the first location, should be
          // ordered by weights in future
          $location = current($object->location);
        }
        elseif (!empty($default_source_location)) {
          $location = $default_source_location;
        }
        elseif (!empty($params['location'])) {
          $location = $params['location'];
        }
        else {
          $location = $location;
        }
      }

      // Make sure locations is an array
      if (isset($locations) && !is_array($locations)) {
        $locations = array();
      }

      if (!is_object($object)) {
        $object = (object) $object;
      }

      if (!($object instanceof XCEntity)) {
        $object = new XCEntity($object);
      }
      if (!empty($object->metadata_id)) {

        $params['qualified']     = _object_to_qualified_name($object, 'metadata');
        $params['definition']    = xc_metadata_entity_get($object->metadata_type);
        $params['relationships'] = $object->relationships;
        $params['properties']    = $object->properties;

        if (!isset($xc_retrieve_hooks)) {
          foreach (module_implements('xc_retrieve') as $module) {
            $xc_retrieve_hooks[] = $module . '_xc_retrieve';
          }
        }
        foreach ($xc_retrieve_hooks as $function) {
          $function($object, $location, $params);
        }

        xc_cache_set('metadata', _object_to_qualified_name($object, 'metadata'), $object);
      }
    } // !properties_only
  }

  return is_object($objects) ? array_shift($_objects) : $_objects;
}

/**
 * Calls hook_xc_alter() to alter (make changes to) metadata
 * instances for the current page load. Used to insert or modify
 * field, attribute, and namespace values dynamically.
 *
 * @param $objects
 *    An array of XCEntity objects or a single XCEntity object
 * @param $params
 *    Additional arguments
 */
function _xc_alter(&$objects, $params = array()) {
  $_objects = is_object($objects) ? array($objects) : $objects;
  if (is_array($_objects)) {
    foreach ($_objects as $object) {
      if (!is_object($object)) {
        $object = (object) $object;
      }

      if (!($object instanceof XCEntity)) {
        $object = new XCEntity($object);
      }

      if (xc_metadata_entity_exists($object->metadata_type)
           && !empty($object->metadata_id)) {
        module_invoke_all('xc_alter', $object, $params);
        xc_cache_set('metadata', _object_to_qualified_name($object, 'metadata'), $object);
      }
    }
  }
}

/**
 * Calls hook_xc_commit() after all script processing has completed
 */
function _xc_commit($locations = array(), $params = array()) {
  // global $_xc_commit_enabled;
  // $_xc_commit_enabled = TRUE;
  if (!isset($params['implicit']) || !$params['implicit']) {
    xc_log_info('metadata', '_xc_commit');
    module_invoke_all('xc_commit', $locations, $params);
  }
}

/**
 * Calls hook_xc_optimize() after all script processing has completed
 *
 * @param $locations (array)
 *   List of Location objects
 * @param $params (array)
 *   Associative array of parameters. Possible keys are:
 *   - 'solr servers': the array of Solr servers
 *   - 'sql_optimize': the SQL command to optimize table(s)
 */
function _xc_optimize($locations = array(), $params = array()) {
  // global $_xc_optimize_enabled;
  // $_xc_optimize_enabled = TRUE;
  module_invoke_all('xc_optimize', $locations, $params);
}

/**
 * Alter and return a field within an XCEntity object
 *
 * @param $object
 *    XCEntity object
 * @param $field
 *    Qualified name of the field or field array
 * @param $delta
 *    Field index if multiple fields within the same XCEntity
 * @param $alter
 *    What to alter within the field, such as "value" to change the value or
 *    "NULL" to make no changes
 * @param $value
 *    New value for the field, if any
 * @return
 *    Field that was changed
 */
function xc_alter_field(&$object, $field, $delta = 0, $alter = NULL, $value = NULL) {
  $delta = (array) $delta;
  if (is_object($field)) {
    $field = (array) $field;
  }
  if (!is_array($field)) {
    $field = _qualified_name_to_array($field, 'field');
  }
  if (xc_metadata_field_exists($field['name'], $field['namespace'])) {
    $qualified = _array_to_qualified_name($field, 'field');
    if (!isset($object->metadata[$qualified]) && is_null($alter)) {
      return NULL;
    }
    if (in_array('all', $delta)) {
      $delta = array_keys($object->metadata[$qualified]);
    }
    switch ($alter) {
      case 'value':
        foreach ($delta as $int) {
          $return[] = $object->metadata[$qualified][$int]['#value'] = $value;
        }
        break;

      default:
        foreach ($delta as $int) {
          $return[] = $object->metadata[$qualified][$int]['#value'];
        }
        break;
    }
    return count($return) == 1 ? current($return) : $return;
  }
}

/**
 * Alter and return an attribute within a field within an XCEntity object
 *
 * @param $object
 *    XCEntity object
 * @param $field
 *    Qualified name of the field or field array for which the attribute is within
 * @param $attribute
 *    Qualified name of the attribute or an attribute array
 * @param $delta
 *    Field index if multiple fields within the same XCEntity
 * @param $alter
 *    What to alter within the attribute, such as "value" to change the value or
 *    "NULL" to make no changes
 * @param $value
 *    New value for the attribute, if any
 * @return
 *    Attribute that was changed
 */
function xc_alter_attribute(&$object, $field, $attribute, $delta = 0, $alter = NULL, $value = NULL) {
  $delta = (array) $delta;
  if (is_object($field)) {
    $field = (array) $field;
  }
  if (is_object($attribute)) {
    $attribute = (array) $attribute;
  }
  if (!is_array($field)) {
    $field = _qualified_name_to_array($field, 'field');
  }
  if (!is_array($attribute)) {
    $attribute = _qualified_name_to_array($attribute, 'attribute');
  }
  if (xc_metadata_field_exists($field['name'], $field['namespace']) &&
      xc_metadata_attribute_exists($attribute['name'], $attribute['namespace'])) {
    $field_qualified = _array_to_qualified_name($field, 'field');
    $attribute_qualified = _array_to_qualified_name($attribute, 'attribute');
    if (in_array('all', $delta)) {
      $delta = array_keys($object->metadata[$field_qualified]);
    }
    switch ($alter) {
      case 'value':
        foreach ($delta as $int) {
          $return[] = $object->metadata[$field_qualified][$delta]["@$attribute_qualified"] = $value;
        }
        break;

      default:
        foreach ($delta as $int) {
          $return[] = $object->metadata[$field_qualified][$delta]["@$attribute_qualified"];
        }
        break;
    }
    return count($return) == 1 ? current($return) : $return;
  }
}

/**
 * Fetch a field from within an XCEntity object
 * @see xc_alter_field()
 */
function xc_fetch_field(&$object, $field, $delta = 0) {
  return xc_alter_field($object, $field, $delta);
}

/**
 * Fetch an attribute from within an XCEntity object and field
 * @see xc_alter_attribute()
 */
function xc_fetch_attribute(&$object, $field, $attribute, $delta = 0) {
  return xc_alter_attribute($object, $field, $attribute, $delta);
}

/**
 * Load a metadata schema array for a specific module
 *
 * @see xc_load_schema()
 * @param $module
 *    Specific module to lookup
 * @param $entities
 *    Optionally, an array of specific entities within the schema to lookup
 * @return
 *    Metadata schema array
 */
function xc_load_schema_by_module($module, $entities = array()) {
  if (is_string($module)) {
    $module = array($module);
  }
  elseif (!is_array($module)) {
    $module = array();
  }

  return xc_load_schema($entities, $module);
}

/**
 * Load a metadata schema array for a specific metadata format
 *
 * @see xc_load_schema()
 * @param $format
 *    Metadata format machine name
 * @param $entities
 *    Optionally, an array of specific entities within the schema to lookup
 * @return
 *    Metadata schema array
 */
function xc_load_schema_by_format($format, $entities = array()) {
  require_once('includes/xc_metadata.format.inc');

  $format   = xc_format_get($format);
  $entities = array_intersect($format['entities'], $entities);

  return xc_load_schema($entities);
}

/**
 * Load a metadata schema array
 *
 * @param $entities
 *    Optionally, an array of specific entities within the schema to load
 * @param $modules
 *    Optionally, an array of modules to limit the schema lookup
 * @return
 *    Metadata schema array
 */
function xc_load_schema($entities = array(), $modules = array()) {
  $schema = array();
  foreach (module_implements('xc_schema') as $module) {
    $do_load = FALSE;

    // Make sure the module is in the modules array
    if (!empty($modules) && is_array($modules)) {
      if (in_array($module, $modules)) {
        $do_load = TRUE;
      }
    }
    else {
      $do_load = TRUE;
    }

    if ($do_load) {
      $function = $module . '_xc_schema';
      $module_schema = call_user_func($function);

      // Assign the right module to the entity, field, attribute, or
      // namespace definition
      if (is_array($module_schema)) {
        foreach ($module_schema as $entity) {
          if (empty($entity['module'])) {
            $entity['module'] = $module;
          }
          if (is_array($entity['fields'])) {
            foreach ($entity['fields'] as $field) {
              if (empty($field['module'])) {
                $field['module'] = $module;
              }
              if (isset($field['attributes']) && is_array($field['attributes'])) {
                foreach ($field['attributes'] as $attribute) {
                  if (empty($attribute['module'])) {
                    $attribute['module'] = $module;
                  }
                }
              }
            }
          } // fields
          if (is_array($entity['namespaces'])) {
            foreach ($entity['namespaces'] as $namespace) {
              if (empty($namespace['module'])) {
                $namespace['module'] = $module;
              }
            }
          }
        }
      }

      // If entities is empty, then don't have to return specific
      // schemas; otherwise return only subset of schemas
      if (!empty($entities) && is_array($entities)) {
        foreach ($entities as $entity) {
          if (isset($module_schema[$entity])) {
            $schema[$entity] = (isset($schema[$entity]) && is_array($schema[$entity]))
              ? array_merge_recursive($schema[$entity], $module_schema[$entity])
              : $module_schema[$entity];
          }
        }
      }
      else {
        $schema = array_merge_recursive($schema, $module_schema);
      }
    }
  }
  return $schema;
}

/**
 * Install all metadata components (entities, fields, attributes, and namespaces
 * of a metadata schema that are not already installed
 *
 * @see xc_load_schema()
 * @see xc_uninstall_schema()
 * @param $schema
 *    Metadata schema array to install
 */
function xc_install_schema($schema) {
  static $possible_parameters;

  // Prevent PHP from timing out
  drupal_set_time_limit(0);

  if (!isset($possible_parameters)) {
    $possible_parameters = array(
      // TODO: do the same for field
      'attribute' => array(
        'name',
        'namespace',
        'title',
        'description',
        'module',
        'required',
        'size',
        'max_size',
        'default value',
        'possible values',
      ),
    );
  }

  if (empty($schema) || !is_array($schema)) {
    return FALSE;
  }
  xc_metadata_rebuild();

  // Entities
  foreach ($schema as $type => $entity) {
    if (empty($type) || !is_array($entity)) {
      continue;
    }
    $entity = array_merge($entity, _qualified_name_to_array($type, 'entity'));
    $entity_definition = new XCMetadataEntity($type);
    // Prevents the modification of an entity's original properties
    if (!xc_metadata_entity_exists($entity['type'])) {
      $entity_definition->title       = $entity['title'];
      $entity_definition->description = $entity['description'];
      $entity_definition->module      = isset($entity['module']) ? $entity['module'] : '';
    }

    $entities = is_array($entity_definition->entities)
      ? $entity_definition->entities
      : array();

    if (isset($entity['parents']) && is_array($entity['parents'])) {
      foreach ($entity['parents'] as $parent) {
        if (empty($parent)) {
          continue;
        }
        $entities['parents'][] = _qualified_name_to_array($parent, 'entity');
      }
    }

    if (isset($entity['children']) && is_array($entity['children'])) {
      foreach ($entity['children'] as $child) {
        if (empty($child)) {
          continue;
        }
        $entities['children'][] = _qualified_name_to_array($child, 'entity');
      }
    }

    $entity_definition->entities = $entities;
    $entity_definition->set_definition(TRUE, TRUE);

    // Fields
    if (is_array($entity['fields'])) {
      foreach ($entity['fields'] as $field_qualified => $field) {
        if (empty($field_qualified)) {
          continue;
        }
        $field = array_merge($field, _qualified_name_to_array($field_qualified, 'field'));
        $field_definition = new XCMetadataField($field['name'], $field['namespace']);

        // Prevents the modification of a field's original properties
        if (!xc_metadata_field_exists($field['name'], $field['namespace'])) {
          $field_definition->title = isset($field['title']) ? $field['title'] : '';
          $field_definition->description = isset($field['description']) ? $field['description'] : '';
          $field_definition->module = isset($field['module']) ? $field['module'] : '';
          $field_definition->required = isset($field['required']) ? $field['required'] : '';
          $field_definition->size = isset($field['size']) ? $field['size'] : '';
          $field_definition->max_size = isset($field['max_size']) ? $field['max_size'] : '';
          $field_definition->default_value = isset($field['default value']) ? $field['default value'] : '';
          $field_definition->possible_values = isset($field['possible values']) ? $field['possible values'] : '';
        }
        $field_definition->entities[] = _qualified_name_to_array($type, 'entity');
        $field_definition->set_definition(TRUE, TRUE);

        // Attributes
        if (isset($field['attributes']) && is_array($field['attributes'])) {
          foreach ($field['attributes'] as $attribute_qualified => $attribute) {
            if (empty($attribute_qualified)) {
              continue;
            }
            $unallowed_keys = array_diff(array_keys($attribute),
              $possible_parameters['attribute']);
            if (!empty($unallowed_keys)) {
              $msg = t('Unallowed keys in schema attribute definition: %keys',
                array('%keys' => join(', ', $unallowed_keys)));
              drupal_set_message($msg, 'error');
              xc_log_error('xc metadata', $msg);
            }
            $attribute = array_merge(
              $attribute,
              _qualified_name_to_array($attribute_qualified, 'attribute')
            );
            $field_definition->attributes[] = _qualified_name_to_array(
              $attribute_qualified, 'attribute');

            if (!isset($attribute['namespace'])) {
              $attribute['namespace'] = '';
            }
            $attribute_definition = new XCMetadataAttribute(
              $attribute['name'], $attribute['namespace'], $field_qualified
            );
            // Prevents the modification of an attribute's original properties
            if (!xc_metadata_attribute_exists($attribute['name'], $attribute['namespace'], $field_qualified)) {
              $properties = array(
                'title',
                'description',
                'module',
                'required',
                'size',
                'max_size',
                'default_value',
                'possible_values',
              );
              foreach ($properties as $property) {
                if (isset($attribute[$property])) {
                  $attribute_definition->$property = $attribute[$property];
                }
                else {
                  $attribute_definition->$property = NULL;
                }
              }
              /*
               $attribute_definition->title           = $attribute['title'];
               $attribute_definition->description     = $attribute['description'];
               $attribute_definition->module          = $attribute['module'];
               $attribute_definition->required        = $attribute['required'];
               $attribute_definition->size            = $attribute['size'];
               $attribute_definition->max_size        = $attribute['max_size'];
               $attribute_definition->default_value   = $attribute['default value'];
               $attribute_definition->possible_values = $attribute['possible values'];
               */
            }
            $attribute_definition->set_definition(TRUE, TRUE);
          }
        }
        $field_definition->set_definition(TRUE, TRUE);
      }
    }

    // Namespaces
    if (isset($entity['namespaces']) && is_array($entity['namespaces'])) {
      foreach ($entity['namespaces'] as $prefix => $namespace) {
        if (empty($prefix)) {
          continue;
        }
        $namespace = array_merge($namespace, _qualified_name_to_array($prefix, 'namespace'));
        $namespace_definition = new XCMetadataNamespace($prefix);
        // Prevents the modification of a namespace's original properties
        if (!xc_metadata_namespace_exists($prefix)) {
          $namespace_definition->uri = $namespace['uri'];
          $namespace_definition->title = isset($namespace['title']) ? $namespace['title'] : '';
          $namespace_definition->description = isset($namespace['description']) ? $namespace['description'] : '';
          $namespace_definition->module = isset($namespace['module']) ? $namespace['module'] : '';
        }
        $namespace_definition->set_definition(TRUE, TRUE);
      }
    }
  }
  xc_metadata_rebuild();
}

/**
 * Uninstalls all metadata schema components (entities, fields, attributes, and
 * namespaces) of a given schema that are not currently in use by an enabled
 * formats
 *
 * @see xc_load_schema()
 * @see xc_install_schema()
 * @param $schema
 *    Metadata schema array to uninstall
 */
function xc_uninstall_schema($schema) {
  if (empty($schema) || !is_array($schema)) {
    return FALSE;
  }
  xc_metadata_rebuild();

  // Prevent uninstalling any schemas that an enabled format is using
  // Hence, preventing the destruction of data being used
  require_once('includes/xc_metadata.format.inc');
  foreach (xc_format_get() as $type => $format) {
    if (xc_format_is_enabled($type) && is_array($format['entities'])) {
      foreach ($format['entities'] as $entity) {
        if (array_key_exists($entity, $schema)) {
          unset($schema[$entity]);
        }
      }
    }
  }

  // Remove entities
  foreach ($schema as $type => $entity) {
    if (empty($type) || !is_array($entity)) {
      continue;
    }
    $entity = array_merge($entity, _qualified_name_to_array($type, 'entity'));
    $entity_definition = new XCMetadataEntity($type);
    $entity_definition->unset_definition(TRUE, TRUE);

    // Remove fields
    if (is_array($entity['fields'])) {
      foreach ($entity['fields'] as $field_qualified => $field) {
        // Deciding to remove a field depends on whether it exists and
        // whether it is currently being used by an existing entity or attribute
        if (empty($field_qualified)) {
          continue;
        }
        $field = array_merge($field, _qualified_name_to_array($field_qualified, 'field'));
        if ($field_definition = xc_metadata_field_get($field['name'], $field['namespace'])) {
          $delete_field = TRUE;
          if ($delete_field) {
            foreach ($field_definition->entities as $field_entity) {
              if ($field_entity['type'] != $entity['type']
                   && xc_metadata_entity_exists($field_entity['type'])) {
                $delete_field = FALSE;
              }
            }
          }
          if ($delete_field) {
            $field_definition->unset_definition(TRUE, TRUE);
          }
          if ($delete_field) {
            // Remove attributes
            if (isset($field['attributes']) && is_array($field['attributes'])) {
              foreach ($field['attributes'] as $attribute_qualified => $attribute) {
                if (empty($attribute_qualified)) {
                  continue;
                }
                $qname = $field_qualified . '@' . $attribute_qualified;
                $attribute = array_merge(
                  $attribute,
                  _qualified_name_to_array($attribute_qualified, 'attribute')
                );
                // Deciding to remove an attribute depends on whether it exists and
                // whether it is currently being used by an existing field
                if (!isset($attribute['namespace'])) {
                  $attribute['namespace'] = '';
                }

                if ($attribute_definition = xc_metadata_attribute_get($attribute['name'], $attribute['namespace'], $field_qualified)) {
                  $delete_attribute = TRUE;
                  if ($delete_attribute) {
                    foreach ($attribute_definition->fields as $attribute_field) {
                      if (isset($attribute_field['name'])
                           && !($attribute_field['name'] == $field['name']
                            && $attribute_field['namespace'] == $field['namespace'])
                           && xc_metadata_field_exists($attribute_field['name'],
                               $attribute_field['attribute'])) {
                        $delete_attribute = FALSE;
                      }
                    }
                  }
                  if ($delete_attribute) {
                    $attribute_definition->unset_definition(TRUE, TRUE);
                  }
                }
              }
            }
          }
        }
      }
    }

    // Remove namespaces
    if (is_array($entity['namespaces'])) {
      foreach ($entity['namespaces'] as $prefix => $namespace) {
        if (empty($prefix)) {
          continue;
        }
        // Deciding to remove a namespace depends on whether it exists and
        // whether it is currently being used by an existing field or attribute
        if ($namespace_definition = xc_metadata_namespace_get($prefix)) {
          $delete_namespace = TRUE;
          if ($delete_namespace) {
            foreach ($namespace_definition->fields as $namespace_field) {
              if (xc_metadata_field_exists($namespace_field['name'], $namespace_field['namespace'])) {
                $delete_namespace = FALSE;
              }
            }
          }
          if ($delete_namespace) {
            foreach ($namespace_definition->attributes as $namespace_attribute) {
              if (xc_metadata_attribute_exists($namespace_attribute['name'], $namespace_attribute['namespace'])) {
                $delete_namespace = FALSE;
              }
            }
          }
          if ($delete_namespace) {
            $namespace_definition->unset_definition(TRUE, TRUE);
          }
        }
      }
    }
  }
  xc_metadata_rebuild();
}

/**
 * Implements hook_xc_optimize().
 */
function xc_metadata_xc_optimize($locations = array(), $params = array()) {
  global $databases;
  static $optimized;

  if (!$optimized) {
    $sql = NULL;
    switch ($databases['default']['default']['driver']) {
      case 'mysql':
      case 'mysqli':
        $sql = 'OPTIMIZE TABLE {xc_entity_properties}, {xc_entity_relationships}, {node}, {node_revisions}, {node_comment_statistics}';
        break;
      case 'pgsql':
        $sql = 'VACUUM ANALYZE {xc_entity_properties}, {xc_entity_relationships}, {node}, {node_revisions}, {node_comment_statistics}';
        break;
      default:
        if (isset($params['sql_optimize'])) {
          $sql_optimize = check_plain($params['sql_optimize']);
          $sql = $sql_optimize;
        }
        break;
    }
    if (!is_null($sql)) {
      if (!$optimized = db_query($sql)) {
        drupal_set_message(t('Unexpected error. Cannot optimize metadata.'), 'error');
      }
    }
  }
}

/**
 * Implements hook_init().
 */
function xc_metadata_init() {
  global $_xc_metadata_cache, $_xc_cache;

  $_xc_metadata_cache = array();
  $_xc_cache = array();
}

/**
 * Implements hook_exit().
 */
function xc_metadata_exit($destination = NULL) {
//  global $_xc_commit_enabled, $_xc_optimize_enabled;
//  if ($_xc_commit_enabled) {
//    module_invoke_all('xc_commit');
//  }
//  if ($_xc_optimize_enabled) {
//    module_invoke_all('xc_optimize');
//  }
}

/**
 * Implements hook_node_info().
 */
function xc_metadata_node_info($update = FALSE) {
  $node_info = array();
  $types = xc_metadata_get_entities($update);
  $entities = xc_metadata_entity_get($types);
  foreach ($entities as $entity) {
    $node_info[$entity->node_type] = array(
      'name' => empty($entity->title) ? $entity->type : t($entity->title),
      'base' => 'xc_metadata',
      'description' => t($entity->description),
      'has_title' => TRUE,
      'has_body' => FALSE,
      'locked' => TRUE,
    );
  }
  return $node_info;
}

/**
 * Implements hook_node_presave().
 */
function xc_metadata_node_presave($node) {
  // Set the identifier as the title, if possible
  if (isset($node->entity) && empty($node->identifier)) {
    $node->identifier = $node->entity->identifier;
  }
  if (empty($node->title)) {
    $node->title = empty($node->identifier) ? t('Untitled') : $node->identifier;
  }
}

/**
 * Implements hook_nodeapi().
 */
function xc_metadata_nodeapi_OLD(&$node, $op, $a3 = NULL, $a4 = NULL) { }

/**
 * Implements hook_insert().
 */
function xc_metadata_insert($node) {
  global $_oaiharvester_statistics;

  if (!isset($node->entity)) {
    return;
  }

  $t = microtime(TRUE);
  $entity = &$node->entity;
  if ($entity instanceof XCEntity) {
    if (empty($entity->node_id)) {
      $entity->node_id = $node->nid;
    }

    if (empty($entity->node_type)) {
      $entity->node_type = $node->type;
    }

    $entity->store();
  }
  // TODO: locations!
  _xc_commit(array(), array('implicit' => TRUE));
  xc_oaiharvester_statistics_set('01 step1/02 bridge/03 _xc_build_store/04 xc_entity_set_properties/05 node_save/xc_metadata_insert', abs(microtime(TRUE) - $t));
}

/**
 * Implements hook_update().
 */
function xc_metadata_update($node) {
  global $_oaiharvester_statistics;

  $t = microtime(TRUE);
  $entity = &$node->entity;
  if ($entity instanceof XCEntity) {
    if (empty($entity->node_id)) {
      $entity->node_id = $node->nid;
    }
    if (empty($entity->node_type)) {
      $entity->node_type = $node->type;
    }
    $entity->store();
  }
  // TODO: locations!
  _xc_commit(array(), array('implicit' => TRUE));
  xc_oaiharvester_statistics_set('01 step1/02 bridge/03 _xc_build_store/04 xc_entity_set_properties/05 node_save/xc_metadata_update', abs(microtime(TRUE) - $t));
}

/**
 * Implements hook_delete().
 */
function xc_metadata_delete($node) {
  $entity = new XCEntity($node, FALSE, FALSE, array('properties_only' => TRUE));
  $entity->remove();
}

/**
 * Implements hook_load().
 */
function xc_metadata_load($nodes) {
  timer_start('xc_metadata_load');
  foreach($nodes as $node) {
    $metadata_id = _node_id_to_metadata_id($node->nid);
    $trace = debug_backtrace();
    // the load is called by node_delete
    if ($trace[1]['function'] == 'node_invoke'
         && $trace[2]['function'] == 'node_load'
         && $trace[3]['function'] == 'node_delete') {
      $entity = new XCEntity($metadata_id, FALSE, FALSE, array('properties_only' => TRUE));
    }
    else {
      $entity = new XCEntity($metadata_id);
    }

    foreach ($entity as $key => $value) {
      $node->$key = $value;
      if ($key == 'metadata') {
        $titles = array();
        // TODO: add $schema->get_title_field() or something
        $title_field = preg_match('/^xc_/', $node->type) ? 'dcterms:title' : 'dc:title';
        $titles = xc_alter_field($entity, $title_field, 'all');
        $node->title = is_array($titles) ? join(' &mdash; ', $titles) : $titles;
      }
    }
  }
  timer_stop('xc_metadata_load');
}

/**
 * Implements hook_view().
 */
function xc_metadata_view($node, $view_mode) {
  timer_start('xc_metadata_view');
  $entity = new XCEntity($node);
  _xc_alter($entity);
  if ($view_mode == 'teaser') {
    // do nothing
    // TODO: title, snippets
    $template_types = array('title', 'snippet');
    $templates_exist = TRUE;
    foreach ($template_types as $template_type) {
      $template_name = xc_util_template_get_name($entity->metadata_type, $entity->type, $template_type);
      if (!xc_util_template_exists($template_name)) {
        $templates_exist = FALSE;
        break;
      }
    }
    if ($templates_exist) {
      $result = xc_search_do_solr_search('id:"' . $entity->identifier . '"');
      $xc_record = _xc_solr_to_array($result['docs'][0]);
      $element   = xc_search_get_display_template_elements($xc_record['type'], $xc_record);
      if (isset($element['title'])) {
        $node->title = is_array($element['title'])
          ? join(' &mdash; ', $element['title'])
          : $element['title'];
      }
      $node->content['metadata']['#value'] = xc_search_teaser($result['docs'][0]);
    }
  }
  elseif ($view_mode == 'full') {
    // TODO: full display
    $template_name = xc_util_template_get_name($entity->metadata_type, $entity->type, 'full');
    if (xc_util_template_exists($template_name)) {
      $result = xc_search_do_solr_search('metadata_id_s:' . $entity->metadata_id, TRUE, 0, 1, array('XCNAME' => 'xc_metadata_view'));
      $xc_record = _xc_solr_to_array($result['docs'][0]);
      if (!$xc_record['node_id'] && $entity->node_id) {
        $xc_record['node_id'] = $entity->node_id;
      }

      $element   = xc_search_get_display_template_elements($xc_record['type'], $xc_record);
      if (isset($element['title'])) {
        $node->title = is_array($element['title'])
          ? join(' &mdash; ', $element['title'])
          : $element['title'];
      }

      $node->content['metadata']['#markup'] = xc_search_full($xc_record, $result['docs'][0]);
    }
    else {
      if (is_array($entity->metadata)) {
        foreach ($entity->metadata as $qualified => $field) {
          if (substr($qualified, 0, 1) == '@') {
            continue;
          }
          if (!isset($node->content[$qualified])) {
            $node->content[$qualified] = array('#markup' => '');
          }
          $node->content[$qualified]['#markup'] .=
            theme('xc_field', array('field' => $qualified, 'data' => $node->metadata[$qualified]));
        }
      }
    }
  }
  timer_stop('xc_metadata_view');
  return $node;
}

/**
 * Implements hook_node_access().
 */
function xc_metadata_node_access($node, $op, $account) {
  switch ($op) {
    case 'create':
      break;
    case 'delete':
      break;
    case 'update':
      break;
    case 'view':
      return user_access(ACCESS_METADATA);
      break;
  }
}

/**
 * Implements hook_theme().
 */
function xc_metadata_theme() {
  return array(
    'xc_field' => array(
      'variables' => array(
        'field' => NULL,
        'data' => NULL,
      ),
    ),
  );
}

/**
 * Implements hook_form().
 */
function xc_metadata_form($node, $form_state) {
  // Set the metadata entity type if not already set
  if (empty($node->metadata_type)) {
    $node->metadata_type = _node_type_to_metadata_type($node->type);
  }

  $definition = new XCMetadataEntity($node->metadata_type);
  $entity = new XCEntity($node);

  $options = array();
  require_once('includes/xc_metadata.format.inc');
  foreach (xc_format_get() as $type => $format) {
    if (in_array($definition->type, $format['entities'])) {
      $options[$type] = $format['name'];
    }
  }

  $form['raw'] = array(
    '#type' => 'textarea',
    '#title' => t('Metadata'),
    '#rows' => 20,
    '#default_value' => $entity->transform(),
    '#weight' => 1,
  );

  $form['format'] = array(
    '#type' => 'select',
    '#title' => t('Format'),
    '#options' => $options,
    '#multiple' => FALSE,
    '#default_value' => $entity->format,
    '#required' => TRUE,
    '#weight' => 0,
  );

  $form['metadata_type'] = array(
    '#type' => 'value',
    '#default_value' => empty($entity->metadata_type) ? $node->metadata_type : $entity->metadata_type,
    '#required' => TRUE,
  );

  $form['metadata_id'] = array(
    '#type' => 'value',
    '#default_value' => $entity->metadata_id,
  );

  $form['identifier'] = array(
    '#type' => 'textfield',
    '#title' => t('Identifier'),
    '#disabled' => empty($entity->identifier) ? FALSE : TRUE,
    '#default_value' => $entity->identifier,
  );

  // If entity does not have a source, it is new and created by the node form,
  // so the user should select locations
  if (empty($entity->source_id)) {
    $locations = xc_location_get_all();
    $location_options = array();
    foreach ($locations as $location) {
      $location_options[$location->location_id] = $location->name;
    }

    $form['locations'] = array(
      '#type' => 'select',
      '#title' => t('Choose location(s) to store metadata '),
      '#description' => t('Note that this option is <strong>only available</strong> when first inserting this metadata node'),
      '#multiple' => TRUE,
      '#options' => $location_options,
      '#required' => TRUE,
    );
  }

  $form['entity'] = array(
    '#type' => 'value',
    '#value' => $entity,
  );

  $form['#submit'] = array('xc_metadata_submit');

  // Fix annoying issue with default value not being passed to form
  // validation if element is disabled. These values need to be passed
  // to the $node object, but Drupal does not do this for some reason
  if ($form['identifier']['#disabled']) {
    $form['identifier']['#value'] = $form['identifier']['#default_value'];
  }
  return $form;
}

/**
 * Implements hook_validate().
 */
function xc_metadata_validate(&$node, &$form) {
  $entity = &$node->entity;
  if ($entity instanceof XCEntity) {
    $entity->raw    = $node->raw;
    $entity->format = $node->format;
    $entity->build();
  }
  else {
    form_set_error('raw', t('Unexpected error. Cannot build entity instance.'));
  }

  $_metadata_id   = check_plain($form['metadata_id']['#value']);
  $_metadata_type = check_plain($form['metadata_type']['#value']);
  $_identifer     = check_plain($form['identifer']['#value']);
  $_locations     = is_array($form['locations']['#value']) ? $form['locations']['#value'] : array();

  xc_entity_load_properties($entity);

  // If there is no source, then make the source be the 'node_form'
  if (empty($entity->source_id)) {
    $sql = "SELECT * FROM {xc_source} WHERE type = 'node_form'";
    $source = db_query("SELECT * FROM {xc_source} WHERE type = :type", array(':type' => 'node_form'))->fetchObject();
    $entity->source_id = $source->source_id;

    // Also add the locations
    $entity->locations = array();
    foreach ($_locations as $_location_id) {
      $entity->locations[$_location_id] = xc_location_get($_location_id);
    }
  }

  // If certain entity information is not built, such as type and identifier, it
  // should first be added from the $node object, and if not available,
  // then from the $form array. Also, unfortunately, PHP has a flaw in the
  // ternary operator logic as well.
  if (empty($entity->metadata_type)) {
    $entity->metadata_type = (!empty($node->metadata_type) ? $node->metadata_type : $_metadata_type);
  }

  if (empty($entity->metadata_id)) {
    $entity->metadata_id = (!empty($node->metadata_id) ? $node->metadata_id : $_metadata_id);
  }

  if (empty($entity->identifer)) {
    $entity->identifer = (!empty($node->identifer) ? $node->identifer : $_identifer);
  }

  // If certain node values are empty, update with entity values and node values
  if (empty($node->metadata_type)) {
    $node->metadata_type = $entity->metadata_type;
  }
  if (empty($node->metadata_id)) {
    $node->metadata_id = $entity->metadata_id;
  }
  if (empty($node->identifier)) {
    $node->identifier = $entity->identifier;
  }
  if (empty($node->nid)) {
    $node->nid = $entity->node_id;
  }
  if (empty($node->type)) {
    $node->type = $entity->node_type;
  }

  // Check to make sure metadata types match
  if (empty($entity->metadata_type)) {
    form_set_error('metadata_type', t('Entity type not specified and/or cannot be built from raw data.'));
  }
  if (_node_type_to_metadata_type($node->type) != $entity->metadata_type) {
    form_set_error(
      'metadata_type',
      t('Incorrect entity type. Attempting to create %specified entity, but found %found entity instead.',
        array(
      '%specified' => _node_type_to_metadata_type($node->type),
      '%found' => $entity->metadata_type,
    )));
  }
  if ($node->metadata_type != $entity->metadata_type) {
    form_set_error(
      'metadata_type',
      t('Incorrect entity type. Attempting to create %specified entity, but found %found entity instead.',
        array(
      '%specified' => $node->metadata_type,
      '%found' => $entity->metadata_type,
    )));
  }
  if (!empty($_metadata_type) && $_metadata_type != $entity->metadata_type) {
    form_set_error(
      'metadata_type',
      t('Incorrect entity type. %specified entity specified, but found %found entity instead.',
        array(
      '%specified' => $_metadata_type,
      '%found' => $entity->metadata_type,
    )));
  }

  // Check to make sure identifier match
  if ($node->identifier != $entity->identifier) {
    form_set_error('identifier', t('Incorrect unique identifier. Identifier within node does not match the identifier within the entity.'));
  }
  if (!empty($_identifier) && $_identifier != $entity->identifier) {
    form_set_error('identifier', t('Incorrect unique identifier . Specified identifier does not match the identifier within the entity.'));
  }

  // Check to make sure metadata ID match
  if ($node->metadata_id != $entity->metadata_id) {
    form_set_error('metadata_id', t('Incorrect entity ID. ID within node does not match the ID within the entity.'));
  }
  if (!empty($_metadata_id) && $_metadata_id != $entity->metadata_id) {
    form_set_error('metadata_id', t('Incorrect entity ID. Specified ID does not match the ID within the entity.'));
  }

  // Prevent conflicts and duplicate nodes for entity instances
  if (empty($entity->node_id) && !empty($entity->nid)) {
    form_set_error('raw', t('Entity already exists as a %link.', array('%link' => l(t('node'), 'node/' . $entity->nid))));
  }
  if ($entity->node_id != $entity->nid) {
    form_set_error('', t('Incorrect node ID. Node ID within the node does not match the node ID within the entity.'));
  }
}

/**
 * XC Metadata node form submission
 */
function xc_metadata_submit($form, &$form_state) {
  $entity = &$form_state['values']['entity'];

  // Set changes to the $node object because the entity is finally built
  $form_state['values']['metadata_type'] = $entity->metadata_type; // = empty($entity->metadata_type)? $form_state['values']['metadata_type'] : $entity->metadata_type;
  $form_state['values']['metadata_id'] = $entity->metadata_id; // = empty($entity->metadata_id) ? $form_state['values']['metadata_id'] : $entity->metadata_id;
  $form_state['values']['identifier'] = $entity->identifier; // = empty($entity->identifier) ? $form_state['values']['identifier'] : $entity->identifier;
  $form_state['values']['title'] = empty($entity->identifier) ? t('Unititled') : $entity->identifier;
}

/**
 * Implements hook_flush_caches().
 */
function xc_metadata_flush_caches() {
  xc_metadata_reset();
}

/**
 * Themes a metadata field
 *
 * @param $field
 *    Field qualified name
 * @param $data
 *    Content data array
 * @return
 *    Themed HTML output
 */
function theme_xc_field($variables) {
  $field = $variables['field'];
  $data = $variables['data'];
  $definition = xc_metadata_field_get($field);
  if (!empty($definition)) {
    $qualified = _object_to_qualified_name($definition, 'field');
    $title = empty($definition->title) ? $qualified : $definition->title;

    $output = '<div class="xc_field field_' . check_plain($qualified) . '">';
    $output .= '<p><strong>' . check_plain($title) . '</strong>';
    foreach ($data as $item) {
      if (isset($item['#value'])) {
        $output .= '<br />' . check_plain($item['#value']);
      }
    }
    $output .= '</p></div>';
  }
  return $output;
}

/**
 * Menu callback to print XML of XCEnity object to the page
 *
 * @param $object
 *    XCEntity object
 */
function xc_download($object) {
  if (xc_metadata_entity_exists($object->metadata_type)) {
    require_once('includes/xc_metadata.format.inc');
    $format = xc_format_get($object->format);
    if ($format['download']) {
      $output = _xc_transform($object, $object->format);
      header('Content-type: ' . $format['content type']);
      header('Content-length: ' . strlen((string) $output));
      print $output;
    }
  }
}

/**
 * Show FRBR structure of a manifestation node.
 *
 * @param $node (Object)
 *   The node to show
 * @param $result (Array)
 *   The collection to store the information
 *
 * @return (String)
 *   The table of the whole structure
 */
function xc_download_all($node, &$result = array()) {
  // TODO: transform this function to work with metadata objects, not just nodes

  $node_rows = array();

  // getting information from the metadata array
  $node_rows[] = array(
    'data' => array($node->metadata_type, 'node id', $node->nid),
    'style' => 'font-weight: bolder;',
  );
  $node_rows[] = array(
    'data' => array('', 'metadata id', $node->metadata_id),
    'style' => 'font-weight: bolder;',
  );

  if (is_array($node->metadata)) {
    foreach ($node->metadata as $field_name => $field) {
      if (is_string($field)) {
        $value = $field;
      }
      else {
        $value = array();
        foreach ($field as $item) {
          $attr_values = array();
          $item_value = '';

          foreach ($item as $attr_name => $attr_value) {
            if ($attr_name == '#value') {
              $item_value = $attr_value;
            }
            else {
              if (!empty($attr_value)) {
                $attr_values[] = $attr_name . '="' . $attr_value . '"';
              }
            }
          }

          $attr_values = !empty($attr_values) ? ' (' . join(' ', $attr_values) . ')' : '';
          $value[] = $item_value . $attr_values;
        }

        if (count($value) == 1) {
          $value = $value[0];
        }
        else {
          $value = theme('item_list', array('items' => $value));
        }
      }

      $style = 'vertical-align: top;';
      if ($field_name == '@type' || $field_name == '@id') {
        $style .= 'font-weight: bolder;';
      }
      $data = array('', $field_name, $value);
      $node_rows[] = array(
        'data' => $data,
        'style' => $style,
      );
    } // foreach fields
  }
  else {
    xc_log_error('metadata', $node->nid);
  }

  $result[] = array(
    'type' => $node->type,
    'rows' => $node_rows,
  );

  if ($node->type == 'xc_manifestation') {
    $children = xc_entity_get_child_identifiers($node->identifier_int);
    if (!empty($children)) {
      foreach ($children as $identifier) {
        $child = xc_metadata_ids_by_identifier_int($identifier);
        $child_node_id = $child->node_id;
        if ($child_node_id == 0) {
          require_once('includes/xc_metadata.postharvest.inc');
          $child_node_id = xc_metadata_create_node($child, TRUE);
        }
        $child_node = node_load($child_node_id);
        $content = xc_download_all($child_node, $result);
      }
    }
  }

  // set up parents
  if (empty($node->relationships['parents'])) {
    switch ($node->type) {
      case 'xc_manifestation':
      case 'xc_expression':
        $parents = xc_entity_get_parent_identifiers($node->identifier_int);
        break;
    }
    if (!empty($parents)) {
      foreach ($parents as $identifier) {
        $metadata_id = xc_metadata_metadata_id_from_identifier_int($identifier);
        $node->relationships['parents'][] = $metadata_id;
      }
    }
  }

  if (!empty($node->relationships['parents'])) {
    foreach ($node->relationships['parents'] as $parent) {
      $node_id = _metadata_id_to_node_id($parent);
      if ($node_id == 0) {
        require_once('includes/xc_metadata.postharvest.inc');
        $node_id = xc_metadata_create_node_for_metadata($parent);
      }
      $node = node_load($node_id);
      $content = xc_download_all($node, $result);
    }
  }
  elseif ($node->type != 'xc_holdings') {
    $result = array_reverse($result);
    $rows = array(
      'xc_work' => array(),
      'xc_expression' => array(),
      'xc_manifestation' => array(),
      'xc_holdings' => array(),
    );
    foreach ($result as $item) {
      if (isset($rows[$item['type']])) {
        $rows[$item['type']] = array_merge($rows[$item['type']], $item['rows']);
      }
      else {
        $rows[$item['type']] = $item['rows'];
      }
    }
    $headers = array(t('FRBR level'), t('field'), t('value'));
    return theme('table', array('header' => $headers, 'rows' => array_merge(
      $rows['xc_work'],
      $rows['xc_expression'],
      $rows['xc_manifestation'],
      $rows['xc_holdings']
    )));
  }
  if (isset($content)) {
    return $content;
  }
}

/**
 * Show FRBR structure of a manifestation entity.
 *
 * @param $entity (Object)
 *   The node to show
 * @param $result (Array)
 *   The collection to store the information
 *
 * @return (String)
 *   The table of the whole structure
 */
function xc_metadata_schemaview($entity, &$result = array()) {

  $node_rows = array();

  // getting information from the metadata array
  $node_rows[] = array(
    'data' => array($entity->metadata_type, 'node id', $entity->node_id),
    'style' => 'font-weight: bolder;',
  );
  $node_rows[] = array(
    'data' => array('', 'metadata id', $entity->metadata_id),
    'style' => 'font-weight: bolder;',
  );

  if (is_array($entity->metadata)) {
    foreach ($entity->metadata as $field_name => $field) {
      if (is_string($field)) {
        $value = $field;
      }
      else {
        $value = array();
        foreach ($field as $item) {
          $attr_values = array();
          $item_value = '';

          foreach ($item as $attr_name => $attr_value) {
            if ($attr_name == '#value') {
              $item_value = $attr_value;
            }
            else {
              if (!empty($attr_value)) {
                $attr_values[] = $attr_name . '="' . $attr_value . '"';
              }
            }
          }

          $attr_values = !empty($attr_values) ? ' (' . join(' ', $attr_values) . ')' : '';
          $value[] = $item_value . $attr_values;
        }

        if (count($value) == 1) {
          $value = $value[0];
        }
        else {
          $value = theme('item_list', array('items' => $value));
        }
      }

      $style = 'vertical-align: top;';
      if ($field_name == '@type' || $field_name == '@id') {
        $style .= 'font-weight: bolder;';
      }
      $data = array('', $field_name, $value);
      $node_rows[] = array(
        'data' => $data,
        'style' => $style,
      );
    } // foreach fields
  }
  else {
    xc_log_error('metadata', $entity->node_id);
  }

  $result[] = array(
    'type' => $entity->metadata_type,
    'rows' => $node_rows,
  );

  if ($entity->metadata_type == 'manifestation') {
    $children = xc_entity_get_child_identifiers($entity->identifier_int);
    if (!empty($children)) {
      foreach ($children as $identifier) {
        $child_ids = xc_metadata_ids_by_identifier_int($identifier);
        $child = new XCEntity($child_ids->metadata_id);

//        $child_node_id = $child->node_id;
//        if ($child_node_id == 0) {
        // require_once 'includes/xc_metadata.postharvest.inc';
        // $child_node_id = xc_metadata_create_node($child, TRUE);
//        }
        // $child_node = node_load($child_node_id);

        $content = xc_metadata_schemaview($child, $result);
      }
    }
  }

  // set up parents
  if (empty($entity->relationships['parents'])) {
    switch ($entity->metadata_type) {
      case 'manifestation':
      case 'expression':
        $parents = xc_entity_get_parent_identifiers($entity->identifier_int);
        break;
    }
    if (!empty($parents)) {
      foreach ($parents as $identifier) {
        $metadata_id = xc_metadata_metadata_id_from_identifier_int($identifier);
        $entity->relationships['parents'][] = $metadata_id;
      }
    }
  }

  if (!empty($entity->relationships['parents'])) {
    foreach ($entity->relationships['parents'] as $parent_metadata_id) {

//      $node_id = _metadata_id_to_node_id($parent);
//      if ($node_id == 0) {
//        require_once 'includes/xc_metadata.postharvest.inc';
//        $node_id = xc_metadata_create_node_for_metadata($parent);
//      }
//      $entity = node_load($node_id);

      $parent = new XCEntity($parent_metadata_id);
      $content = xc_metadata_schemaview($parent, $result);
    }
  }
  elseif ($entity->metadata_type != 'holdings') {
    $result = array_reverse($result);
    $rows = array(
      'work' => array(),
      'expression' => array(),
      'manifestation' => array(),
      'holdings' => array(),
    );
    foreach ($result as $item) {
      if (isset($rows[$item['type']])) {
        $rows[$item['type']] = array_merge($rows[$item['type']], $item['rows']);
      }
      else {
        $rows[$item['type']] = $item['rows'];
      }
    }
    $headers = array(t('FRBR level'), t('field'), t('value'));
    return theme('table', array('header' => $headers, 'rows' => array_merge(
      $rows['work'],
      $rows['expression'],
      $rows['manifestation'],
      $rows['holdings']
    )));
  }
  if (isset($content)) {
    return $content;
  }
}

/**
 * Reconstructs the Solr structure
 *
 * @param $node (Object)
 *   The node object
 *
 * @return (string)
 *   The field-value table which will be sent to Solr
 */
function xc_solr_structure($node) {
  include_once drupal_get_path('module', 'xc_solr') . '/xc_solr.index.inc';
  $doc = xc_solr_onestop_indexer($node->metadata_id);

  $rows = array();

  $field_names = $doc->getFieldNames();
  foreach ($field_names as $field_name) {
    $values = $doc->$field_name;
    if (is_array($values)) {
      if (count($values) > 1) {
        $values = theme('item_list', array('items' => $values));
      }
      else {
        $values = $values[0];
      }
    }
    $rows[] = array(array(
        'data' => $field_name,
        'valign' => 'top',
      ), $values);
  }

  $content = theme('table', array('header' => array(t('Field'), t('Value')), 'rows' => $rows));

  if (isset($content)) {
    return $content;
  }
}

function is_metadata_node($object) {
  $_object = (array) $object;
  if ((isset($_object['type'])
          && xc_metadata_entity_exists($_object['type']))
       ||
      (isset($_object['metadata_type'])
          && xc_metadata_entity_exists($_object['metadata_type']))
    ) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Check the right, and whether the node is a metadata node.
 *
 * @param $permission (String)
 *   The permission to check
 * @param $node (Object)
 *   The node to check whether it is XC metadata node
 *
 * @return (Boolean)
 *   TRUE if it is an XC node, and the user has access right, FALSE otherwise.
 */
function xc_metadata_check_rights($permission, $node) {
  if (user_access($permission) && is_metadata_node($node)) {
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Implements hook_menu().
 */
function xc_metadata_menu() {
  $items['node/%xc_entity_from_node_id/xc/schemaview'] = array(
    'title' => 'View XC Schema Record',
    'page callback' => 'xc_metadata_schemaview',
    'page arguments' => array(1),
    'access callback' => 'xc_metadata_check_rights',
    'access arguments' => array(ACCESS_METADATA_SCHEMA, 1),
    'type' => MENU_CALLBACK,
    'weight' => 10,
  );

  $items['node/%node/xc/solr'] = array(
    'title' => 'View Solr record structure',
    'page callback' => 'xc_solr_structure',
    'page arguments' => array(1),
    'access callback' => 'xc_metadata_check_rights',
    'access arguments' => array(ADMINISTER_METADATA, 1),
    'type' => MENU_CALLBACK,
    'weight' => 10,
  );

  $items['admin/xc/metadata'] = array(
    'title' => 'Metadata Storage Configuration and Utilities',
    'description' => 'Setup of storage locations in Drupal.  Also includes various utilities for import, export, delete of metadata stored in Drupal.  Also includes a record lookup by identifier, and a list of metadata formats supported (based on installed plug-ins).  Prerequisites: You must have Solr installed on the same machine as Drupal so that it can be used as storage location.  You must setup SOLR using the SOLR admin menu choice. MySQL is also required, but it is required to use Drupal in the first place.',
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array(ADMINISTER_METADATA),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 2,
  );

  $items['admin/xc/metadata/delete'] = array(
    'title' => 'Delete',
    'description' => 'Delete all metadata that match a certain criteria',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_metadata_delete_form'),
    'access arguments' => array(ADMINISTER_METADATA),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 4,
  );

  $items['admin/xc/metadata/delete_source/%/%/%'] = array(
    'title' => 'Delete',
    'description' => 'Delete all metadata that match a certain criteria',
    'page callback' => 'xc_metadata_delete_by_source',
    'page arguments' => array(4, 5, 6),
    'access arguments' => array(ADMINISTER_METADATA),
    'type' => MENU_CALLBACK,
    'weight' => -5,
  );

  $items['admin/xc/metadata/lookup'] = array(
    'title' => 'Lookup',
    'description' => 'Lookup metadata node by any identifier',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_metadata_lookup_form'),
    'access arguments' => array(ADMINISTER_METADATA),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 3,
  );

  $items['admin/xc/metadata/location'] = array(
    'title' => 'Storage locations',
    'description' => 'Configure metadata storage locations and their properties',
    'page callback' => 'xc_location_list',
    'page arguments' => array(),
    'access arguments' => array(ADMINISTER_METADATA_LOCATIONS),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 1,
  );

  $items['admin/xc/metadata/location/list'] = array(
    'title' => 'List',
    'access arguments' => array(ADMINISTER_METADATA_LOCATIONS),
    'page callback' => 'xc_location_list',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );

  $items['admin/xc/metadata/location/add'] = array(
    'title' => 'Add storage location',
    'access arguments' => array(ADMINISTER_METADATA_LOCATIONS),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_location_form', 3),
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
  );

  $items['admin/xc/metadata/location/%xc_location'] = array(
    'title callback' => 'xc_location_title',
    'title arguments' => array(4),
    'page callback' => 'xc_location_view',
    'page arguments' => array(4),
    'access arguments' => array(ADMINISTER_METADATA_LOCATIONS),
    'type' => MENU_NORMAL_ITEM,
  );

  $items['admin/xc/metadata/location/%xc_location/view'] = array(
    'title' => 'View',
    'page callback' => 'xc_location_view',
    'page arguments' => array(4),
    'access arguments' => array(ADMINISTER_METADATA_LOCATIONS),
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/xc/metadata/location/%xc_location/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_location_form', 4),
    'access arguments' => array(ADMINISTER_METADATA_LOCATIONS),
    'type' => MENU_LOCAL_TASK,
  );

  $items['admin/xc/metadata/location/%xc_location/purge'] = array(
    'title' => 'Purge location',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_location_purge_form', 4),
    'access arguments' => array(ADMINISTER_METADATA_LOCATIONS),
    'type' => MENU_CALLBACK,
  );

  $items['admin/xc/metadata/location/%xc_location/delete'] = array(
    'title' => 'Delete location',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_location_delete_form', 4),
    'access arguments' => array(ADMINISTER_METADATA_LOCATIONS),
    'type' => MENU_CALLBACK,
  );

  $items['admin/xc/metadata/format'] = array(
    'title' => 'Formats',
    'description' => 'Configure metadata formats and schemas and their properties',
    'page callback' => 'xc_format_list',
    'page arguments' => array(),
    'access arguments' => array(ADMINISTER_METADATA_FORMATS),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 2,
    //    'file' => 'includes/xc_metadata.format.inc',
  );

  $items['admin/xc/metadata/format/list'] = array(
    'title' => 'List',
    'access arguments' => array(ADMINISTER_METADATA_FORMATS),
    'page_callback' => 'xc_format_list',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    //    'file' => 'includes/xc_metadata.format.inc',
  );

  $items['admin/xc/metadata/format/%'] = array(
    'title callback' => 'xc_format_title',
    'title arguments' => array(4),
    'page callback' => 'xc_format_view',
    'page arguments' => array(4),
    'access arguments' => array(ADMINISTER_METADATA_FORMATS),
    'type' => MENU_CALLBACK,
    //    'file' => 'includes/xc_metadata.format.inc',
  );

  $items['admin/xc/metadata/format/%/enable'] = array(
    'title' => 'Enable format',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_format_enable_form', 4),
    'access arguments' => array(ADMINISTER_METADATA_FORMATS),
    'type' => MENU_CALLBACK,
    //    'file' => 'includes/xc_metadata.format.inc',
  );

  $items['admin/xc/metadata/format/%/disable'] = array(
    'title' => 'Disable format',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_format_disable_form', 4),
    'access arguments' => array(ADMINISTER_METADATA_FORMATS),
    'type' => MENU_CALLBACK,
    //    'file' => 'includes/xc_metadata.format.inc',
  );

  $items['admin/xc/metadata/postharvest'] = array(
    'title' => 'Batch node creation',
    'description' => 'Run post-harvest node creation batch process',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_metadata_postharvest_batch_launch_form'),
    'access arguments' => array(ADMINISTER_METADATA_FORMATS),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'includes/xc_metadata.postharvest.inc',
    'weight' => 2,
  );

  $items['admin/xc/metadata/create_relationship'] = array(
    'title' => 'Batch relationship creation',
    'description' => 'Run post-harvest relationship creation batch process',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_metadata_relationship_batch_launch_form'),
    'access arguments' => array(ADMINISTER_METADATA_FORMATS),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'includes/xc_metadata.postharvest.inc',
    'weight' => 3,
  );

  $items['admin/xc/metadata/statistics'] = array(
    'title' => 'Statistical data',
    'description' => 'Statistical data about the content in the database',
    'page callback' => 'xc_metadata_statistics_view',
    'access arguments' => array(ADMINISTER_METADATA),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'includes/xc_metadata.statistics.inc',
    'weight' => 3,
  );

  return $items;
}

/**
 * Implements hook_preprocess_page().
 */
function xc_metadata_preprocess_node(&$variables) {
  // Nasty brutish hack to remove $submitted section from node page
  if (is_metadata_node($variables['node'])) {
    unset($variables['submitted']);
  }
}

/**
 * The batch operation which iterates over all XCEntity records to create nodes
 * based on them. It calls xc_metadata_create_node() function to create nodes.
 *
 * @param $source_id (int)
 *   The source identifier
 * @param $saved_batch_id (int)
 *   The oaiharvester_batch record identifier
 * @param $operation_id (int)
 *   The operation identifier
 * @param $context (array)
 *   The Batch API $context object
 */
function xc_metadata_node_creation_batch_operation($source_id = NULL, $saved_batch_id = -1,
    $operation_id = -1, &$context = array()) {
  global $_oaiharvester_statistics, $_xc_meta_time, $_xc_metadata_statistics;
  static $sql;
  drupal_set_time_limit(0);
  $_oaiharvester_statistics = variable_get('oaiharvester_statistics', array('start' => microtime(TRUE)));
  if (!function_exists('xc_metadata_statistics_empty')) {
    include_once drupal_get_path('module', 'xc_metadata') . '/includes/xc_metadata.statistics.inc';
  }
  $_xc_metadata_statistics = variable_get('xc_metadata_stat_harvested', xc_metadata_statistics_empty());

  $limit = 200;
  // first run
  if (empty($context['sandbox'])) {
    $t1 = microtime(TRUE);
    drupal_set_message('xc_metadata_node_creation_batch_operation');
    $context['results']['start'] = $t1;
    $context['sandbox'] = array(
      'start_time' => $t1,
      'offset' => 0,
      'progress' => 0,
    );

    // get implemented schemas
    $metadata_types = array();
    $schemas = module_invoke_all('xc_schema');
    foreach ($schemas as $key => $schema) {
      if (!isset($schema['group']) || empty($schema['group'])) {
        $metadata_types[] = $key;
      }
      // handling xc schemas
      elseif ($schema['group'] == 'xc_schema') {
        if ($key == 'manifestation') {
          $metadata_types[] = $key;
        }
        // else do nothing, process only this type
      }
      else {
        // there is a group, but at time of writing this code there is no example for that.
      }
    }
    $metadata_types_conditions = array();
    foreach ($metadata_types as $metadata_type) {
      $metadata_types_conditions[] = "metadata_type = '" . $metadata_type . "'";
    }
    $metadata_types_condition = '(' . join(' OR ', $metadata_types_conditions) . ')';

    $context['sandbox']['count_sql'] = 'SELECT COUNT(metadata_id) FROM {xc_entity_properties} WHERE node_id = 0';
    if (!empty($metadata_types_condition)) {
      $context['sandbox']['count_sql'] .= ' AND ' . $metadata_types_condition;
    }

    // TODO Please convert this statement to the D7 database API syntax.
    $context['results']['total'] = db_query($context['sandbox']['count_sql'])->fetchField();
    //xc_log_info('xc metadata node', 'total: ' . $context['results']['total']);

    $min_sql = 'SELECT min(metadata_id) FROM {xc_entity_properties} WHERE node_id = 0';
    if (!empty($metadata_types_condition)) {
      $min_sql .= ' AND ' . $metadata_types_condition;
    }
    // TODO Please convert this statement to the D7 database API syntax.
    $offset_id = db_query($min_sql)->fetchField() - 1;
    //xc_log_info('xc metadata node', 'offset id: ' . $offset_id);
    $offset = 0;

    $context['sandbox']['metadata_types_condition'] = $metadata_types_condition;
    xc_oaiharvester_statistics_set('04 step4/01 preparation', abs(microtime('TRUE') - $t1));

    // init $_xc_meta_time
    variable_del('xc_metadata_time');
    $_xc_meta_time = array();
  }
  else { // subsequent runs
    $t1 = microtime(TRUE);
    $offset = $context['sandbox']['offset'];
    $offset_id = $context['sandbox']['offset_id'];
    $metadata_types_condition = $context['sandbox']['metadata_types_condition'];
    //xc_log_info('xc metadata node', 'offset: ' . $offset . ' of ' . $context['results']['total']);
    if (!isset($context['sandbox']['start_time'])) {
      $context['sandbox']['start_time'] = $t1;
    }
    xc_oaiharvester_statistics_set('04 step4/02 normal preparation', abs(microtime('TRUE') - $t1));

    // init $_xc_meta_time
    $_xc_meta_time = variable_get('xc_metadata_time', array());
  }

  if ($saved_batch_id != -1) {
    $saved_batch = oaiharvester_saved_batch_load($saved_batch_id);
  }

  if ($context['results']['total'] != 0 && $context['results']['total'] > $offset) {
    $t1 = microtime(TRUE);
    include_once drupal_get_path('module', 'xc_metadata') . '/includes/xc_metadata.postharvest.inc';
    if (!isset($sql)) {
      $sql = 'SELECT metadata_id, node_id, node_type, metadata_type, identifier FROM {xc_entity_properties} '
         . ' WHERE metadata_id > :min AND metadata_id < :max'
         . ' AND node_id = 0'
         . ' AND ' . $metadata_types_condition;
    }

    $t2 = microtime(TRUE);
    $max = $offset_id + ($limit * 4);
    xc_log_info('xc metadata node', 'Node creation SQL: ' . $offset_id . ' - ' . $max);
    $result = db_query($sql, array(':min' => $offset_id, ':max' => $max));
    xc_oaiharvester_statistics_set('04 step4/03 main task/01 sql select', abs(microtime('TRUE') - $t2));

    $t2 = microtime(TRUE);
    $processed = 0;
    foreach ($result as $metadata) {
      if (empty($metadata->node_id)) {
        // xc_log_info('xc metadata node', 'Creating node for ' . $metadata->metadata_id);
        $t3 = microtime(TRUE);
        xc_metadata_create_node($metadata, FALSE);
        xc_oaiharvester_statistics_set('04 step4/03 main task/02 iteration/01 xc_metadata_create_node', abs(microtime('TRUE') - $t3));
      }
      $offset_id = $metadata->metadata_id;
      $processed++;
    }
    $offset_id = $max - 1;

    xc_oaiharvester_statistics_set('04 step4/03 main task/02 iteration', abs(microtime('TRUE') - $t2));
    xc_oaiharvester_statistics_set('04 step4/03 main task', abs(microtime('TRUE') - $t1));
    $context['sandbox']['offset'] += $processed;
    $context['sandbox']['offset_id'] = $offset_id;
    if (!isset($context['sandbox']['progress'])) {
      $context['sandbox']['progress'] = 0;
    }
    $context['sandbox']['progress'] += $processed;
    variable_set('xc_metadata_time', $_xc_meta_time);

    // Sometime it happens, that other process runs paralelly, and the count changes over time.
    // Prevent endless loop by finishing the process.
    // TODO Please convert this statement to the D7 database API syntax.
    if ($processed == 0
         && db_query($context['sandbox']['count_sql'])->fetchField() == 0) {
      $context['finished'] = 1.0;
    }
  }

  if ($context['results']['total'] == 0) {
    $context['finished'] = 1.0;
  }
  else {
    $context['finished'] = ($context['sandbox']['offset'] / $context['results']['total']);
    if ($context['finished'] > 1.0) {
      $context['finished'] = 1.0;
    }
  }

  $elapsed = (microtime(TRUE) - $context['results']['start']);
  $estimated = $elapsed / $context['finished'];
  $current_batch = batch_get();
  $current_batch_id = isset($current_batch['id']) ? $current_batch['id'] : $saved_batch_id;
  $context['message'] = t('Now creating node %progress out of %max entities/nodes (%finished%). Elapsed time: %elapsed, estimated total: %estimated.<br />!stop_process',
    array(
    '%progress' => $context['sandbox']['progress'],
    '%max' => $context['results']['total'],
    '%finished' => sprintf("%02d", $context['finished'] * 100),
    '%elapsed' => oaiharvester_sec_to_time($elapsed),
    '%estimated' => oaiharvester_sec_to_time($estimated),
    '!stop_process' => l(
        t('Stop harvesting'),
        'batch',
        array('query' => array('op' => 'finished', 'id' => $current_batch_id))
      ),
  )
  );

  if (isset($saved_batch)) {
    $saved_batch_status = $context['finished'] < 1.0 ? 'NODE_CREATION_IN_PROGRESS' : 'NODE_CREATION_FINISHED';
    oaiharvester_saved_batch_update_status($saved_batch, $operation_id, 'xc_metadata_node_creation_batch_operation', $saved_batch_status, $context);
  }

  if ($context['finished'] == 1.0) {
    $_oaiharvester_statistics['04 step4/03 main task/02 iteration/01 xc_metadata_create_node/01 node'] = $_xc_meta_time['node'];
    $_oaiharvester_statistics['04 step4/03 main task/02 iteration/01 xc_metadata_create_node/02 update'] = $_xc_meta_time['update'];
    xc_oaiharvester_statistics_set('04 step4', microtime(TRUE) - $context['sandbox']['start_time']);

    if (isset($saved_batch) && count($saved_batch->sets) == 1) {
      if (count($saved_batch->sets) == $operation_id + 1) {
        xc_log_info('set passive', 'metadata: set passive schedule #' . $saved_batch->schedule_id);
        oaiharvester_schedule_set_passive($saved_batch->schedule_id);
      }

      // update metadata statistics
      $saved_report = empty($saved_batch->reports) ? array() : unserialize($saved_batch->reports);
      $saved_report['xc_oaiharvester_bridge']['metadata_statistics'] = $_xc_metadata_statistics;
      $saved_batch->reports = serialize($saved_report);
      $ret = drupal_write_record('oaiharvester_batch', $saved_batch, 'id');
    }
    xc_log_info('xc metadata node', 'Node creation has been finished successfully.');
  }
  variable_set('oaiharvester_statistics', $_oaiharvester_statistics);
  variable_set('xc_metadata_stat_harvested', $_xc_metadata_statistics);
}

/**
 * The batch operation which iterate over all XCEntity records to create relationship
 * based on them. It calls xc_metadata_create_node() function to create nodes.
 */
function xc_metadata_relationship_creation_batch_operation($source_id = NULL,
    $saved_batch_id = NULL, $operation_id = NULL, &$context = array()) {
  global $_xc_meta_time, $_xc_entity_relationships_csv;

  drupal_set_time_limit(0);
  if (empty($context['sandbox'])) {
    drupal_set_message('xc_metadata_relationship_creation_batch_operation');

    // get implemented schemas
    $metadata_types_conditions = array();
    $xc_schema = xc_schema_xc_schema();
    foreach ($xc_schema as $key => $entity_def) {
      // work has no uplink, so it is not necessary to receive
      if ($key != 'work') {
        // TODO: find out how to get node type from metadata type
        $metadata_types_conditions[] = "node_type = 'xc_" . $key . "'";
      }
    }
    $metadata_types_condition = '(' . join(' OR ', $metadata_types_conditions) . ')';

    $context['results']['start'] = microtime(TRUE);
    $_xc_meta_time = variable_get('xc_metadata_time', array());
    $count_sql  = 'SELECT COUNT(metadata_id) FROM {xc_entity_properties} WHERE ' . $metadata_types_condition;
    // TODO Please convert this statement to the D7 database API syntax.
    $context['results']['total'] = db_query($count_sql)->fetchField();

    xc_log_info('metadata', 'total: ' . $context['results']['total']);
    // TODO Please convert this statement to the D7 database API syntax.
    $offset_id = db_query('SELECT min(metadata_id) FROM {xc_entity_properties} WHERE ' . $metadata_types_condition)->fetchField() - 1;
    xc_log_info('metadata', 'offset id: ' . $offset_id);
    $context['sandbox']['start_time'] = microtime(TRUE);
    $context['sandbox']['metadata_types_condition'] = $metadata_types_condition;
    $offset = $context['sandbox']['offset'] = 0;
    db_query('TRUNCATE TABLE {xc_entity_relationships}');

    // prepare csv file
    $file_dir  = drupal_realpath(file_default_scheme() . '://');
    $cache_dir = $file_dir . '/oaiharvester_sql_cache/';
    $sql_cache_dir = $cache_dir . 'batch';
    $context['results']['csv_file_name'] = NULL;
    if (!file_prepare_directory($cache_dir, FILE_CREATE_DIRECTORY)) {
      drupal_set_message('!file_check_directory: ' . $cache_dir);
      xc_log_error('harvester', t('The Drupal default \'file\' directory is not writable. Check out your Drupal settings, or turn off the caching of harvested responses. Your current file directory is %file.',
        array('%file' => $file_dir))
      );
    }
    else {
      $file_check_success = file_prepare_directory($sql_cache_dir, FILE_CREATE_DIRECTORY);
      if (!$file_check_success) {
        drupal_set_message('!file_check_directory: ' . $sql_cache_dir);
      }
      else {
        $file = $sql_cache_dir . '/xc_entity_relationships.csv';
        if (file_exists($file)) {
          unlink($file);
        }
        $context['results']['csv_file_name'] = $file;
      }
    }
  }
  else {
    $offset = $context['sandbox']['offset'];
    $offset_id = $context['sandbox']['offset_id'];
    $metadata_types_condition = $context['sandbox']['metadata_types_condition'];
    // xc_log_info('reindex', 'offset: ' . $offset . ' of ' . $context['results']['total']);
    if (!isset($context['sandbox']['start_time'])) {
      $context['sandbox']['start_time'] = microtime(TRUE);
    }
  }

  if (is_null($context['results']['csv_file_name'])) {
    $use_insert = TRUE;
  }
  else {
    $use_insert = FALSE;
    $_xc_entity_relationships_csv = fopen($context['results']['csv_file_name'], 'a');
  }

  // iterating metadata

  if ($context['results']['total'] != 0 && $context['results']['total'] > $offset) {
    // include_once drupal_get_path('module', 'xc_metadata') . '/includes/xc_metadata.postharvest.inc';
    $limit = 100;
    $multiplicator = $default_multiplicator = 3;
    for ($i = 0; $i < 100; $i++) {
      if ($context['results']['total'] <= $offset) {
        continue;
      }
      $up_limit = ((int) $offset_id + ($limit * $multiplicator));
      $sql = 'SELECT ent.metadata_id, ent.metadata_type, ent.identifier, meta.metadata
               FROM {xc_entity_properties} AS ent'
           . ' INNER JOIN {xc_sql_metadata} AS meta USING (metadata_id)'
           . ' WHERE (ent.metadata_id BETWEEN ' . (int) $offset_id . ' AND ' . $up_limit . ')'
           . ' AND ' . $metadata_types_condition
           . ' ORDER BY ent.metadata_id LIMIT ' . (int) $limit; // source_id = %d
      // xc_log_info('metadata', 'Relationship SQL: ' . $sql);
      $t1 = microtime(TRUE);
      // TODO Please convert this statement to the D7 database API syntax.
      $result = db_query($sql);
      $t2 = microtime(TRUE);
      if (($t2 - $t1) > 0.5) {
        xc_log_info('metadata', 'execute SQL (' . ($t2 - $t1) . '): ' . $sql);
      }
      // $sql_metadata = 'SELECT metadata FROM {xc_sql_metadata} WHERE metadata_id = %d';
      $found = 0;
      foreach ($result as $data) {
        $found++;
        xc_schema_set_relationships($data->metadata_type, $data->identifier, unserialize($data->metadata), NULL, $use_insert);
        $offset_id = $data->metadata_id;
      }
      $offset += $found;
      if ($found < $limit) {
        $offset_id = $up_limit;
      }
      elseif ($multiplicator != $default_multiplicator) {
        $multiplicator = $default_multiplicator;
      }
    }
    if (is_resource($_xc_entity_relationships_csv)) {
      fclose($_xc_entity_relationships_csv);
    }

    $context['sandbox']['offset'] = $offset; //+= $limit;
    $context['finished'] = ($context['sandbox']['offset'] / $context['results']['total']);
    $context['sandbox']['offset_id'] = $offset_id;
    $elapsed = (microtime(TRUE) - $context['results']['start']);
    $estimated = $elapsed / $context['finished'];
    $context['message'] = t('Now creating relationship %progress out of %max entities. Elapsed time: %elapsed, estimated total: %estimated',
      array(
      '%progress' => $context['sandbox']['offset'],
      '%max' => $context['results']['total'],
      '%elapsed' => oaiharvester_sec_to_time($elapsed),
      '%estimated' => oaiharvester_sec_to_time($estimated),
    )
    );
    variable_set('xc_metadata_time', $_xc_meta_time);
  }
  else {
    $context['finished'] = 1;
  }
}

/**
 * Get the node_id associated with the identifier_int field
 *
 * @param $identifier_int (int)
 *   The identifier_int field
 *
 * @return (int)
 *   The node_id field
 */
function xc_metadata_node_id_from_identifier_int($identifier_int) {
  static $sql = 'SELECT node_id FROM {xc_entity_properties} WHERE identifier_int = :identifier_int';
  return db_query($sql, array(':identifier_int' => $identifier_int))->fetchField();
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_metadata_get_by_identifier_int($identifier_int) {
  static $sql = 'SELECT * FROM {xc_entity_properties} WHERE identifier_int = :identifier_int';
  return db_query($sql, array(':identifier_int' => $identifier_int))->fetchObject();
}

/**
 * Return a light-weight object with the main ettibutes of the metadata: metadata_id, node_id, identifier, metadata_type
 *
 * @param $identifier_int (int)
 *   The identifier_int
 *
 * @return (Object)
 *   The light-weight object representing the metadata
 */
function xc_metadata_ids_by_identifier_int($identifier_int) {
  static $sql = 'SELECT metadata_id, node_id, identifier, metadata_type FROM {xc_entity_properties} WHERE identifier_int = :identifier_int';
  return  db_query($sql, array(':identifier_int' => $identifier_int))->fetchObject();
}

function xc_metadata_ids_by_id($metadata_id) {
  static $sql = 'SELECT metadata_id, node_id, identifier, identifier_int, metadata_type FROM {xc_entity_properties} WHERE metadata_id = :metadata_id';
  return  db_query($sql, array(':metadata_id' => $metadata_id))->fetchObject();
}

/**
 * Get the metadata_id associated with the identifier_int field
 *
 * @param $identifier_int (int)
 *   The identifier_int field
 *
 * @return (int)
 *   The metadata_id field
 */
function xc_metadata_metadata_id_from_identifier_int($identifier_int) {
  static $sql = 'SELECT metadata_id FROM {xc_entity_properties} WHERE identifier_int = :identifier_int';
  return db_query($sql, array(':identifier_int' => $identifier_int))->fetchField();
}

/**
 * Get the identifier_int associated with the metadata_id field
 *
 * @param $identifier_int (int)
 *   The metadata_id field
 *
 * @return (int)
 *   The identifier_int field
 */
function xc_metadata_identifier_int_from_metadata_id($metadata_id) {
  static $sql = 'SELECT identifier_int FROM {xc_entity_properties} WHERE metadata_id = :metadata_id';
  return db_query($sql, array(':metadata_id' => $metadata_id))->fetchField();
}

function xc_metadata_delete_metadata($metadata_id, $identifier_int) { 
  db_delete('xc_entity_properties')
    ->condition('metadata_id', $metadata_id)
    ->execute();  
  db_delete('xc_sql_metadata')
    ->condition('metadata_id', $metadata_id)
    ->execute();
  $or_condition = db_or()
    ->condition('parent', $identifier_int)
    ->condition('child', $identifier_int);
  db_delete('xc_entity_relationships')
    ->condition($or_condition)
    ->execute();
}

function xc_metadata_get_manifestation_ids_for_work($metadata_id) {
  static $sql;
  if (!isset($sql)) {
    $sql = 'SELECT manifestation.metadata_id AS metadata_id
            FROM {xc_entity_properties} AS work
            RIGHT JOIN {xc_entity_relationships} AS r1 ON r1.parent = work.identifier_int
            RIGHT JOIN {xc_entity_relationships} AS r2 ON r2.parent = r1.child
            LEFT JOIN {xc_entity_properties} AS manifestation ON manifestation.identifier_int = r2.child
            WHERE work.metadata_id = :metadata_id';
  }
  return xc_metadata_get_manifestation_ids($sql, $metadata_id);
}

function xc_metadata_get_manifestation_ids_for_expression($metadata_id) {
  static $sql;
  if (!isset($sql)) {
    $sql = 'SELECT manifestation.metadata_id AS metadata_id
            FROM {xc_entity_properties} AS expression
            RIGHT JOIN {xc_entity_relationships} AS r1 ON r1.parent = expression.identifier_int
            LEFT JOIN {xc_entity_properties} AS manifestation ON manifestation.identifier_int = r1.child
            WHERE expression.metadata_id = :metadata_id';
  }
  return xc_metadata_get_manifestation_ids($sql, $metadata_id);
}

function xc_metadata_get_manifestation_ids_for_holdings($metadata_id) {
  static $sql;
  if (!isset($sql)) {
    $sql = 'SELECT manifestation.metadata_id AS metadata_id
            FROM {xc_entity_properties} AS holdings
            RIGHT JOIN {xc_entity_relationships} AS r1 ON r1.child = holdings.identifier_int
            LEFT JOIN {xc_entity_properties} AS manifestation ON manifestation.identifier_int = r1.parent
            WHERE holdings.metadata_id = :metadata_id';
  }
  return xc_metadata_get_manifestation_ids($sql, $metadata_id);
}

function xc_metadata_get_manifestation_ids($sql, $metadata_id) {
  $results = db_query($sql, array(':metadata_id' => $metadata_id));
  $manifestations = array();
  foreach ($results as $manifestation) {
    $manifestations[] = $manifestation->metadata_id;
  }
  return $manifestations;
}

function xc_metadata_get_manifestation_ids_for_frbr($metadata_id, $metadata_type) {
  $manifestation_ids = array();
  switch ($metadata_type) {
    case XC_WORK:
      $manifestation_ids = xc_metadata_get_manifestation_ids_for_work($metadata_id); break;
    case XC_EXPRESSION:
      $manifestation_ids = xc_metadata_get_manifestation_ids_for_expression($metadata_id); break;
    case XC_HOLDINGS:
      $manifestation_ids = xc_metadata_get_manifestation_ids_for_holdings($metadata_id); break;
  }
  return $manifestation_ids;
}

function object_to_array($data) {
  if (is_array($data) || is_object($data)) {
    $result = array();
    foreach ($data as $key => $value) {
      $result[$key] = object_to_array($value);
    }
    return $result;
  }
  return $data;
}