<?php
/**
 * @file
 * Regular expression based implementation of the OAI-PMH parser.
 *
 * The XML response is parsed with regular expressions.
 *
 * @author Király Péter <kirunews@gmail.com>
 *
 * @copyright (c) 2010-2011 eXtensible Catalog Organization
 */

class OAIRegexParser implements IOAIParser {

  private $rawContent;
  private $raw_records;
  private $raw_resumption;
  private $httpCode;

  /** The OAI-PMH error messages */
  private $errorMsgs        = array();
  /** The error messages generated by this parser */
  private $parserErrors     = array();

  private $statistics       = array();
  private $hasErrors        = FALSE;
  private $hasListRecords   = FALSE;
  private $hasRecords       = FALSE;
  private $recordCount      = 0;
  private $records          = NULL;
  private $recordCounter    = -1;
  private $resumptionToken;
  private $hasResumptionToken = FALSE;
  private $need_debug       = FALSE;

  function __construct($content, $httpCode = 200) {
    $this->httpCode = $httpCode;
    $this->rawContent = $content;
    $t0 = microtime(TRUE);
    $this->process();
    $this->statistics['response'] = microtime(TRUE) - $t0;
  }

  /* PUBLIC FUNCTIONS */
  function setHttpCode($httpCode) {
    $this->httpCode = $httpCode;
  }

  function getHttpCode() {
    return $this->httpCode;
  }

  function process() {
    if ($this->httpCode == 200) {
      $this->rawContent = preg_replace('/<!--.*?-->/', '', $this->rawContent);
      $this->_processContent();
    }
    else {
      $this->errorMsg[] = $this->rawContent;
    }
  }

  function processFile($fileName) {
    $this->rawContent = file_get_contents($fileName);
    $this->_processContent();
  }

  function hasErrors() {
    return $this->hasErrors || ((int) $this->httpCode != 200 || !empty($this->errorMsgs));
  }

  /**
   * @return (Array)
   *   The list of server provided error messages. Each error has an 'attributes' array, and a 'text'
   */
  function listErrors() {
    return $this->errorMsgs;
  }

  function hasErrorMsg() {
    return empty($this->errorMsg);
  }

  function getErrorMsg() {
    return $this->errorMsg;
  }

  function hasRecords() {
    return $this->hasRecords;
  }

  function getRecordCount() {
    return $this->recordCount;
  }

  function getNextRecord() {
    if (++$this->recordCounter < $this->recordCount) {
      $xml = $this->records[$this->recordCounter];
      $t0 = microtime(TRUE);
      try {
        $record = $this->parseRecord($xml);
      }
      catch (Exception $e) {
        xc_log_error("parser", $e->getMessage());
      }
      $this->statistics['records'] = isset($this->statistics['records']) ? $this->statistics['records'] + (microtime(TRUE) - $t0) : 0;
      return $record;
    }
    else {
      return FALSE;
    }
  }

  function hasResumptionToken() {
    return $this->hasResumptionToken;
  }

  function getResumptionToken() {
    return $this->resumptionToken;
  }

  function getStatistics($type = 'all') {
    switch ($type) {
      case 'all':
        return $this->statistics;
        break;
      case 'response':
        return $this->statistics['response'];
      case 'records':
        return $this->statistics['records'];
      default:
        return;
    }
  }

  /* PRIVATE FUNCTIONS */
  private function _processContent() {
    if (strstr($this->rawContent, '<error') && !strstr($this->rawContent, '<ListRecords>')) {
      $text = $this->rawContent;
    }
    else {
      $text = $this->rawContent;
      if (!$this->need_debug) {
        $this->rawContent = '';
      }
    }

    $count = 0;
    $text = preg_replace("/^<\?xml[^<>]+\?>/", "", $text, -1, $count);
    if ($count != 1) {
      xc_log_error('regex', 'Malformed XML: no sheabang &mdash; ' . htmlentities($text));
      $this->parserErrors[] = 'no sheabang';
    }

    $count = 0;
    $text = preg_replace("/^\s*<OAI-PMH\b[^<>]+>/s", "", $text, -1, $count);
    if ($count != 1) {
      xc_log_error('regex', 'Malformed XML: no &lt;OAI-PMH&gt; &mdash; ' . htmlentities($text));
      $this->parserErrors[] = 'no OAI-PMH';
      return;
    }

    $count = 1;
    $text = preg_replace("/^\s*<responseDate>(.*?)<\/responseDate>/s", "", $text, -1, $count);
    if ($count != 1) {
      xc_log_error('regex', 'Malformed XML: no &lt;responseDate&gt; &mdash; ' . htmlentities($text));
      $this->parserErrors[] = 'no responseDate';
      return;
    }

    $count = 0;
    $text = preg_replace("/^\s*<request(?: [^<>]+)?>(.*?)<\/request>/s", "", $text, -1, $count);
    if ($count != 1) {
      xc_log_error('regex', 'Malformed XML: no &lt;request&gt; element in XML response: ' . htmlentities(substr($text, 0, 50)) . '&hellip;');
      $this->parserErrors[] = 'no request element';
      return;
    }

    $this->hasListRecords = FALSE;
    $this->hasErrors = FALSE;
    $count = 0;
    $text = preg_replace("/^\s*<ListRecords>/", "", $text, -1, $count);
    if ($count != 1) {
      $errors = '';
      $size = drupal_strlen($text);
      $text = preg_replace_callback(
        "/^\s*<error(?: code=([\'\"])(.*)([\'\"]))?>(.*)<\/error>/",
        array($this, 'setErrors'),
        $text
      );
      if ($size == drupal_strlen($text)) {
        xc_log_error('regex', 'Malformed XML: no ListRecords and no error elements &mdash; ' . htmlentities($text));
        $this->parserErrors[] = 'no ListRecords and error elements';
      }
      else {
        $this->hasErrors = TRUE;
      }
    }
    else {
      $this->hasListRecords = TRUE;
    }

    if (!$this->hasErrors && !$this->need_debug) {
      $this->rawContent = '';
    }

    if ($this->hasListRecords) {
      $resumption = '';
      $records    = '';
      $is_changed_size = TRUE;
      while (!preg_match("/^\s*<\/ListRecords>/", $text) && $is_changed_size) {
        $count = 0;
        $text = preg_replace_callback("/^\s*(<record>.*<\/record>)/s", array($this, 'setRecords'), $text, -1, $count);

        if ($count > 0) {
          $this->hasRecords = TRUE;
          $is_changed_size = TRUE;
          // raw_records is initialized by setRecords
          $mod_records = str_replace('<record>', '<#######><record>', $this->raw_records);
          $this->records = preg_split("/<#######>/", $mod_records, -1, PREG_SPLIT_NO_EMPTY);
          $this->recordCount = count($this->records);
          $mod_records = '';

          $count = 0;
          $text = preg_replace_callback("/^\s*(<resumptionToken([^<>]*)>(.*?)<\/resumptionToken>|<resumptionToken([^<>]*)\s*\/\s*>)/",
            array($this, 'setResumption'), $text, -1, $count);
          if ($count > 0) {
            $is_changed_size = TRUE;
            // resumption comes from setResumption
            //echo 'recCount: ', $this->recordCount, ", resumption: ", $this->resumptionToken['text'], "\n";
          }
          else {
            $is_changed_size = FALSE;
            //$this->parserErrors[] = 'no resumptionToken';
          }
        }
        else {
          $is_changed_size = FALSE;
          $this->parserErrors[] = 'no record elements';
        }
      } // process inside ListRecords

      $count = 0;
      $text = preg_replace('/^\s*<\/ListRecords>/', '', $text, -1, $count);
      if ($count != 1) {
        xc_log_error('regex', 'Malformed XML: no /ListRecords &mdash; ' . htmlentities($text));
        $this->parserErrors[] = 'no ListRecords closer element';
      }
    } // has ListRecords
    else {
      $this->parserErrors[] = 'no ListRecords element';
    }

    if ($this->hasListRecords || $this->hasErrors) {
      $count = 0;
      $text = preg_replace("/^\s*<\/OAI-PMH>/", '', $text, -1, $count);
      if ($count != 1) {
        xc_log_error('regex', 'Malformed XML: no /OAI-PMH &mdash; ' . htmlentities($text));
        $this->parserErrors[] = 'no /OAI-PMH closer element';
      }
    } // has ListRecords or error
  }

  /**
   * Save the error message come from OAI-PMH data provider
   *
   * @param $matches (array)
   *   matches[2]: the error code (optional)
   *   matches[4]: the error message
   *
   * @return (string)
   *   An empty string to replace the error message
   */
  private function setErrors($matches) {
    $msg = array(
      'text' => t('OAI-PMH data provider sent an error message. %error', array('%error' => $matches[4])),
    );

    if (isset($matches[2])) {
      $msg['code'] = $matches[2];
    }

    $this->errorMsgs[] = $msg;

    return "";
  }

  public function getParserErrors() {
    return $this->parserErrors;
  }

  private function setRecords($matches) {
    $this->raw_records = $matches[1];
    return "";
  }

  private function setResumption($matches) {
    $xml = simplexml_load_string($matches[1]);
    $this->resumptionToken = array(
      'attributes' => array(
        'completeListSize' => (int) $xml['completeListSize'],
        'cursor' => (int) $xml['cursor'],
        'expirationDate' => (string) $xml['expirationDate'],
      ),
      'text' => (string) $xml,
    );
    $this->hasResumptionToken = !empty($this->resumptionToken['text']);
    return "";
  }

  public function setDebug($need_debug = FALSE) {
    $this->need_debug = $need_debug;
  }

  function parseRecord($record_str) {
    $record = new SimpleXMLElement($record_str);
    $specs = array();
    if (isset($record->header->setSpec)) {
      foreach ($record->header->setSpec as $spec) {
        $specs[] = (string) $spec;
      }
    }
    $metadata = array();
    if (isset($record->metadata)) {
      $dom = dom_import_simplexml($record->metadata);
      if ($dom) {
        foreach ($dom->childNodes as $childNode) {
          if ($childNode->nodeType == XML_ELEMENT_NODE) {
            $metadata = array(
              'namespaceURI' => preg_replace('/\/$/', '', $childNode->namespaceURI),
              'childNode' => $childNode,
            );
            break;
          }
        }
      }
    }

    return array(
      'header' => array(
        '@status' => isset($record->header->attributes()->status) ? $record->header->attributes()->status : FALSE,
        'identifier' => (string) $record->header->identifier[0],
        'datestamp' => (string) $record->header->datestamp[0],
        'setSpec' => $specs,
      ),
      'metadata' => $metadata,
      'about' => isset($record->abouts) ? $record->abouts : FALSE,
    );
  }
}
