<?php
/**
 * @file
 * The functions need to run harvester.
 *
 * @copyright (c) 2010-2011 eXtensible Catalog Organization
 */

class OaiHarvesterTestCase extends DrupalWebTestCase {
  public static function getInfo() {
    return array(
      'name' => 'Testing OAI Harvester module',
      'description' => 'OAI Harvester tests.',
      'group' => 'eXtensible Catalog Drupal Toolkit',
    );
  }

  function setUp() {
    parent::setUp('oaiharvester', 'xc_oaiharvester_bridge', 'xc_util', 'xc_solr', 'xc_metadata', 'xc_index', 'xc_sql', 'xc_schema');
    /*
     $web_user = $this->drupalCreateUser(array('access hello form'));

     debug($web_user);
     $this->drupalLogin($web_user);
     */

    $this->privileged_user = $this->drupalCreateUser(array(
      'harvest records',
      'administer harvester',
      'administer metadata locations',
    ));
    $this->drupalLogin($this->privileged_user);

    // change Solr to the test
    $location_id = 1;
    $this->drupalGet('admin/xc/metadata/location/' . $location_id . '/edit');
    $this->assertTitle('default | Drupal', 'Title is ' . join(' | ', $this->xpath('//title')));
    $form = current($this->xpath('//form[@id = "xc-location-form"]'));
    $this->assertNotEqual($form, NULL, t('The page contains the location form'));
    //$this->assertEqual($this->drupalGetContent(), 'Content is ', htmlentities($this->drupalGetContent()));
    // $this->assertEqual($form->asXML(), '', $form->asXML());
    $solr_edit = array(
      'name' => 'Default',
      'description' => 'default storage',
    );
    $this->drupalPost(NULL, $solr_edit, t('Continue'));
    $solr_edit = array(
      'solr_host' => 'localhost',
      'solr_port' => '8984',
      'solr_path' => 'solr/xctest',
    );
    $this->drupalPost(NULL, $solr_edit, t('Save'));
    $solr_server_record = xc_solr_server_load($location_id);
    $this->assertNotEqual($solr_server_record, NULL, var_export($solr_server_record, TRUE));
    $this->assertEqual($solr_server_record->host, $solr_edit['solr_host'], sprintf('host should be %v (now it is %s)', $solr_edit['solr_host'], $solr_server_record->host));
    $this->assertEqual($solr_server_record->port, $solr_edit['solr_port'], sprintf('port should be %v (now it is %s)', $solr_edit['solr_port'], $solr_server_record->port));
    $this->assertEqual($solr_server_record->path, $solr_edit['solr_path'], sprintf('path should be %v (now it is %s)', $solr_edit['solr_path'], $solr_server_record->path));
    // refresh cache
    xc_solr_get_servers(TRUE);
    xc_search_init();
    xc_solr_init();
    $this->assertEqual($GLOBALS['_xc_search_server']->getPort(), 8984,
      '_xc_search_server port: ' . $GLOBALS['_xc_search_server']->getPort());
    $this->assertEqual($GLOBALS['_xc_search_server']->getPath(), '/solr/xctest/',
      '_xc_search_server path: ' . $GLOBALS['_xc_search_server']->getPath());
    $this->assertEqual($GLOBALS['_xc_solr_obj'][1]->getPort(), 8984,
      '_xc_solr_obj port: ' . $GLOBALS['_xc_solr_obj'][1]->getPort());
    $this->assertEqual($GLOBALS['_xc_solr_obj'][1]->getPath(), '/solr/xctest/',
      '_xc_solr_obj path: ' . $GLOBALS['_xc_solr_obj'][1]->getPath());
  }

  function tearDown() {
    parent::tearDown();
  }

  /**
   * Test the oaiharvester_sec_to_time function
   * @return unknown_type
   */
  function xtestSecToTime() {
    $tests = array(
      array('00:00:01', oaiharvester_sec_to_time(1)),
      array('00:01:00', oaiharvester_sec_to_time(60)),
      array('00:01:01', oaiharvester_sec_to_time(61)),
      array('00:01:59', oaiharvester_sec_to_time(119)),
      array('00:02:00', oaiharvester_sec_to_time(120)),
      array('00:02:01', oaiharvester_sec_to_time(121)),
      array('00:02:01', oaiharvester_sec_to_time(121)),
      array('00:59:59', oaiharvester_sec_to_time(3599)),
      array('01:00:00', oaiharvester_sec_to_time(3600)),
      array('01:00:01', oaiharvester_sec_to_time(3601)),
    );
    foreach ($tests as $t) {
      $this->assertEqual($t[0], $t[1],
        t('Timestamp awaited: %w but get: %r',
          array('%w' => $t[0], '%r' => $t[1])));
    }
  }

  function xtestHarvesterLibURL() {
    $url = 'http://128.174.70.247:8080/MetadataServicesToolkit/st/marctoxctransformation/oaiRepository';
    $verb = 'ListRecords';
    $metadata_prefix = 'xc';
    $params = array('metadataPrefix' => $metadata_prefix);
    require_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'oaiharvester') . '/lib/OaiPmhXC.php';
    $cache = file_directory_path();
    $oai = new OaiPmhXC($verb, $url, $params, $cache);
    $this->assertEqual($oai->getBaseUrl(), $url, 'Same base url');
    $oai->fetchContent();
    $this->assertEqual(FALSE, $oai->isErrorResponse(), 'Has not error response.');
    $this->assertEqual(200, $oai->getHttpCode(), 'The server returns correctly (HTTP 200 code).');

    // tesing DOM-based parser
    $parser = $oai->processContent('DOM');
    $this->runParserTests($parser);

    // tesing regex-based parser
    $parser = $oai->processContent('regex');
    $this->runParserTests($parser);
  }

  /*
   function testHarvesterLibFile() {
   $url = 'http://128.174.70.247:8080/MetadataServicesToolkit/st/marctoxctransformation/oaiRepository';
   $verb = 'ListRecords';
   $metadata_prefix = 'xc';
   $params = array('metadataPrefix' => $metadata_prefix);
   require_once drupal_get_path('module', 'oaiharvester') . '/lib/OaiPmhXC.php';
   $cache = file_directory_path();
   $oai = new OaiPmhXC($verb, $url, $params, $cache);
   $file = drupal_get_path('module', 'oaiharvester') . '/lib/cache/test.xml';
   $this->assertEqual(1, 1, 'File path is: ' . $file);

   $this->assertEqual($oai->getBaseUrl(), $url, 'Same base url');

   $oai->fetchContent('file', $file);
   $this->assertEqual(FALSE, $oai->isErrorResponse(), 'Has not error response.');
   $this->assertEqual(200, $oai->getHttpCode(), 'The server returns correctly (HTTP 200 code).');

   // tesing DOM-based parser
   $parser = $oai->processContent('DOM');
   $this->runParserTests($parser);

   // tesing regex-based parser
   $parser = $oai->processContent('regex');
   $this->runParserTests($parser);
   }
   */


  function runParserTests($parser) {
    $this->assertEqual(TRUE, $parser->has_records(), 'The server returned records');
    $this->assertNotEqual(0, $parser->get_record_count(), 'The server returned ' . $parser->get_record_count() . ' records');
    $entity_types = array('work', 'expression', 'manifestation', 'holdings');
    require_once DRUPAL_ROOT . '/' . drupal_get_path('module', 'xc_metadata') . '/includes/dom_to_array.inc';
    while ($record = $parser->get_next_record()) {
      /*
       $this->assertNotEqual('', $record['header']['identifier'], 'Has identifier');
       $this->assertNotEqual('', $record['header']['datestamp'], 'Has datestamp');
       $this->assertTrue(count($record['header']['setSpec']), 'Has setSpec(s)');
       $this->assertEqual('', $record['about'], 'Has no about');
       $this->assertEqual('http://www.extensiblecatalog.info/Elements', $record['metadata']['namespaceURI'], 'Correct namespace');
       $child = dom_to_array($record['metadata']['childNode']);
       $this->assertTrue(in_array($child['xc:entity'][0]['@type'], $entity_types), 'Has correct entity');
       $this->assertTrue(!$record['header']['@status'], 'No deletions');
       */
    }
    $this->assertTrue($parser->has_resumptionToken(), 'Has resumption token');
    $token = $parser->get_resumptionToken();
    $this->assertNotEqual('', $token['text'], 'Has a not empty resumption token');
    $this->assertTrue(($token['attributes']['completeListSize'] > 0), 'Has a lots of records');
    $this->assertEqual(0, $token['attributes']['cursor'], 'The cursor is set to 0');
    $this->assertEqual('', $token['attributes']['expirationDate'], 'Has no expriration date');
  }

  /**
   * Tests a dummy OAI server
   */
  function testHarvesterLibFile() {
    global $_xc_search_server, $_xc_solr_obj;

    // xc_search_init();
    // xc_solr_init();
    $this->assertEqual($GLOBALS['_xc_search_server']->getPort(), 8984,
      '_xc_search_server port: ' . $GLOBALS['_xc_search_server']->getPort());
    $this->assertEqual($GLOBALS['_xc_search_server']->getPath(), '/solr/xctest/',
      '_xc_search_server path: ' . $GLOBALS['_xc_search_server']->getPath());
    $this->assertEqual($GLOBALS['_xc_solr_obj'][1]->getPort(), 8984,
      '_xc_solr_obj port: ' . $GLOBALS['_xc_solr_obj'][1]->getPort());
    $this->assertEqual($GLOBALS['_xc_solr_obj'][1]->getPath(), '/solr/xctest/',
      '_xc_solr_obj path: ' . $GLOBALS['_xc_solr_obj'][1]->getPath());

    $dummy = 'http://localhost/dummyoai/index.php';
    // set value
    $result = drupal_http_request($dummy . '?cmd=set&value=one');
    $this->assertEqual($result->code, 200, 'The HTTP response code: ' . $result->code);
    $this->assertEqual($result->data, '<success/>', 'The web content: ' . htmlentities($result->data));

    // get value
    $result = drupal_http_request($dummy . '?cmd=get');
    $this->assertEqual($result->code, 200, 'The HTTP response code: ' . $result->code);
    $this->assertEqual($result->data, 'one', 'The web content: ' . htmlentities($result->data));

    // setup repository
    $url = 'http://localhost/dummyoai/index.php';
    $edit = array(
      'name' => 'DummyOAI',
      'oai_provider_url' => $url,
    );
    $this->drupalPost('admin/xc/harvester/repository/add', $edit, t('Submit and validate'));

    $provider = _oaiharvester_provider_get_by_url($url);
    // $this->assertEqual($provider->oai_provider_url, $url, 'The repository URL is ' . $provider->oai_provider_url);
    // $this->assertEqual($provider->name, $edit['name'], 'The repository name is ' . $provider->name);
    // $this->assertEqual($provider->admin_email, 'tcorbett@cushing.org', $provider->admin_email);

    $formats = _oaiharvester_metadataformats_get_by_provider($provider->provider_id);
    $formats_options = array();
    foreach ($formats as $data) {
      $formats_options[$data->format_id] = $data->name;
    }
    $this->assertEqual($formats_options, array(1 => 'xc'), var_export($formats_options, TRUE));

    // setup schedule
    // get form
    $this->drupalGet('admin/xc/harvester/schedule/step1');
    $this->assertText('Select repository', t('Form is displayed in step 1.'));
    file_put_contents('/home/kiru/download/t/log/step1.html', $this->drupalGetContent());
    $edit = array(
      'provider_id' => '1',
      'recurrence' => 'Weekly',
    );
    $this->drupalPost(NULL, $edit, t('Next'));
    $this->assertText('Schedule name', t('Form is displayed in step 2.'));
    file_put_contents('/home/kiru/download/t/log/step2.html', $this->drupalGetContent());
    $this->assertTitle('Step 2: Name harvest schedule | Drupal', 'Title is ' . join(' | ', $this->xpath('//title')));

    $optionsXML = $this->getAllOptions(current($this->xpath("//select[@id='edit-format-id']")));
    $formats = array();
    foreach ($optionsXML as $option) {
      $value = (string) $option->attributes()->value;
      if (!empty($value)) {
        $formats[$value] = (string) $option;
      }
    }
    $this->assertEqual($formats, array(1 => 'xc'), 'Formats: ' . var_export($formats, TRUE));

    $edit = array(
      'schedule_name' => 'Dummy demo - Weekly',
      'notify_email_address' => 'admin@example.com',
      'format_id[]' => 1,
      'parsing_mode' => 'regex',
      'is_cacheable' => 0,
      'do_defrbrize' => 4,
    );
    $this->drupalPost(NULL, $edit, t('Submit'));
    $schedule = oaiharvester_schedule_load(1);
    $this->assertEqual($schedule->harvest_schedule_id, 1, 'Schedule id: ' . $schedule->harvest_schedule_id);
    $this->assertEqual($schedule->provider_id, 1, 'Provider id: ' . $schedule->provider_id);
    $this->assertEqual($schedule->schedule_name, 'Dummy demo - Weekly', 'Schedule name: ' . $schedule->schedule_name);
    $this->assertEqual($schedule->recurrence, 'Weekly', 'Recurrence: ' . $schedule->recurrence);
    $this->assertEqual($schedule->parsing_mode, 'regex', 'Parsing mode: ' . $schedule->parsing_mode);
    $this->assertEqual($schedule->is_cacheable, 0, 'Cacheable: ' . $schedule->is_cacheable);
    $this->assertEqual($schedule->max_request, 0, 'Max request: ' . $schedule->max_request);
    $this->assertEqual($schedule->skip_main_task, 0, 'Skip main: ' . $schedule->max_request);

    $do_defrbrize = xc_oaiharvester_bridge_get_frbization_value($schedule->harvest_schedule_id);
    $this->assertEqual($do_defrbrize, 4, 'Do FRBRize: ' . $do_defrbrize);

    $use_insert = xc_oaiharvester_bridge_get_use_insert_value($schedule->harvest_schedule_id);
    $this->assertEqual($use_insert, 0, 'Use insert: ' . $use_insert);

    // clean Solr index
    xc_solr_xc_delete_all();

    // harvesting
    $this->drupalGet('admin/xc/harvester/schedule/1/start');
    $this->assertTitle('Harvest Report | Drupal', 'Title is ' . join(' | ', $this->xpath('//title')));
    $messages = '';
    foreach ($this->xpath('//div[@class="messages error"]') as $message) {
      $messages .= $message->asXML();
    }
    $this->assertEqual($messages, '', t('Error messages: %messages', array('%messages' => $messages)));
    // $this->assertEqual($this->drupalGetContent(), 'Content is ', htmlentities($this->drupalGetContent()));
    $this->assertText(t('69 records were harvested'), t('False number of records were harvested'));

    // check metadata
    $count = db_query('SELECT COUNT(metadata_id) as count FROM {xc_entity_properties}')->fetchField();
    $this->assertNotEqual($count, 0, 'Number of entities: ' . $count);

    // 19 works
    $count = db_query("SELECT COUNT(metadata_id) as count FROM {xc_entity_properties} WHERE metadata_type = :metadata_type", array(':metadata_type' => 'work'))->fetchField();
    $this->assertEqual($count, 19, 'Number of works: ' . $count);

    // 19 expressions
    $count = db_query("SELECT COUNT(metadata_id) as count FROM {xc_entity_properties} WHERE metadata_type = :metadata_type", array(':metadata_type' => 'expression'))->fetchField();
    $this->assertEqual($count, 19, 'Number of expressions: ' . $count);

    // 11 manifestations
    $count = db_query("SELECT COUNT(metadata_id) as count FROM {xc_entity_properties} WHERE metadata_type = :metadata_type", array(':metadata_type' => 'manifestation'))->fetchField();
    $this->assertEqual($count, 11, 'Number of manifestations: ' . $count);

    // 20 holdings
    $count = db_query("SELECT COUNT(metadata_id) as count FROM {xc_entity_properties} WHERE metadata_type = :metadata_type", array(':metadata_type' => 'holdings'))->fetchField();
    $this->assertEqual($count, 20, 'Number of holdings: ' . $count);

    // 11 nodes
    $node_count = $count = db_query('SELECT COUNT(nid) as count FROM {node}')->fetchField();
    $this->assertEqual($count, 11, 'Number of nodes: ' . $count);

    // $solr_info = xc_sorl_info_get();
    $params = array(
      'search_type' => 'luke',
    );
    $response = $_xc_search_server->search(NULL, 0, 0, $params, TRUE);

    $index_features = array(
      'numDocs' => t('Number of documents'),
      'numTerms' => t('Number of terms'),
      'version' => t('Solr version release date'),
      'optimized' => t('Index is optimized?'),
      'current' => t('Index is current (all user data is commited)?'),
      'hasDeletions' => t('Index has deletions?'),
      'lastModified' => t('Last modified'),
    );

    $hasDeletions = $response->index->hasDeletions;
    $this->assertEqual($hasDeletions, 0, $index_features['hasDeletions'] . ': ' . (int) $hasDeletions);

    $optimized = $response->index->optimized;
    $this->assertEqual($optimized, 1, $index_features['optimized'] . ': ' . (int) $optimized);

    $current = $response->index->current;
    $this->assertEqual($current, 1, $index_features['current'] . ': ' . $current);

    $numDocs = $response->index->numDocs;
    $this->assertEqual($numDocs, $node_count,
      sprintf('%s (%d) whould be equal to the number of nodes (%d)', $index_features['numDocs'], $numDocs, $node_count));

    // run schedule
  }
}
