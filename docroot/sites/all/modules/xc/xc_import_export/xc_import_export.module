<?php
/**
 * @file
 * XC Import Export module functions
 *
 * @copyright (c) 2010-2011 eXtensible Catalog Organization
 */

/**
 * Permission for administering metadata import
 * @var String
 */
define('ADMINISTER_METADATA_IMPORT', 'administer metadata import');

/**
 * Permission for administering metadata export
 * @var String
 */
define('ADMINISTER_METADATA_EXPORT', 'administer metadata export');


/**
 * Implements hook_permission().
 */
function xc_import_export_permission() {
  return array(
    ADMINISTER_METADATA_IMPORT => array(
      'title' => t(ADMINISTER_METADATA_IMPORT),
      'description' => t('TODO Add a description for ADMINISTER_METADATA_IMPORT'),
    ),
    ADMINISTER_METADATA_EXPORT => array(
      'title' => t(ADMINISTER_METADATA_EXPORT),
      'description' => t('TODO Add a description for ADMINISTER_METADATA_EXPORT'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function xc_import_export_menu() {
  $items['admin/xc/metadata/import'] = array(
    'title' => 'Import',
    'description' => 'Import metadata records from directory as XML',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_import_form'),
    'access arguments' => array(ADMINISTER_METADATA_IMPORT),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 5,
  );

  $items['admin/xc/metadata/import/default'] = array(
    'title' => 'Default',
    'description' => 'Import metadata records from a local directory',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_import_form'),
    'access arguments' => array(ADMINISTER_METADATA_IMPORT),
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/xc/metadata/export'] = array(
    'title' => 'Export',
    'description' => 'Export metadata records as XML to directory',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_export_form'),
    'access arguments' => array(ADMINISTER_METADATA_EXPORT),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 6,
  );

  $items['admin/xc/metadata/export/default'] = array(
    'title' => 'Default',
    'description' => 'Export metadata records to a local directory',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_export_form'),
    'access arguments' => array(ADMINISTER_METADATA_EXPORT),
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  return $items;
}

/**
 * Metadata import form
 */
function xc_import_form(&$form_state) {
  require_once drupal_get_path('module', 'xc_metadata') . '/includes/xc_metadata.format.inc';

  $formats = xc_format_get();
  $format_options = array();
  foreach ($formats as $type => $format) {
    $format_options[$type] = $format['name'];
  }

  $form['format'] = array(
    '#type' => 'select',
    '#title' => t('Import format'),
    '#options' => $format_options,
    '#multiple' => FALSE,
    '#required' => TRUE,
  );

  $form['directory'] = array(
    '#type' => 'textfield',
    '#title' => t('Import directory'),
    '#description' => t('Relative path from the Drupal "files" directory'),
    '#default_value' => 'xc/import',
    '#required' => TRUE,
  );

  $locations = xc_location_get_all();
  $location_options = array();
  foreach ($locations as $location) {
    $location_options[$location->location_id] = $location->name;
  }

  $form['locations'] = array(
    '#type' => 'select',
    '#title' => t('Choose location(s) to store metadata '),
    '#multiple' => TRUE,
    '#options' => $location_options,
    '#required' => TRUE,
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Import'),
  );

  return $form;
}

/**
 * Metadata import form submission handler
 */
function xc_import_form_submit($form, &$form_state) {
  $directory = $form_state['values']['directory'];
  $format = $form_state['values']['format'];
  $locations = $form_state['values']['locations'];

  $batch = array(
    'operations' => array(
      array('xc_import_batch', array($format, $directory, $locations)),
    ),
    'finished' => 'xc_import_batch_finished',
    'title' => t('Importing metadata'),
    'init_message' => t('Metadata import is starting'),
    'progress_message' => t('Processed @current out of @total'),
    'error_message' => t('Metadata import has encountered an error.'),
  );
  batch_set($batch);
}

/**
 * Metadata export form
 */
function xc_export_form(&$form_state) {
  $form['directory'] = array(
    '#type' => 'textfield',
    '#title' => t('Export directory'),
    '#description' => t('Relative path from the Drupal "files" directory'),
    '#default_value' => 'xc/export',
    '#required' => TRUE,
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Export'),
  );

  return $form;
}

/**
 * Metadata export form submission handler
 */
function xc_export_form_submit($form, &$form_state) {
  $directory = $form_state['values']['directory'];
  $locations = is_array($form_state['values']['locations']) ? $form_state['values']['locations'] : array();

  $batch = array(
    'operations' => array(
      array('xc_export_batch', array($directory)),
    ),
    'finished' => 'xc_export_batch_finished',
    'title' => t('Exporting metadata'),
    'init_message' => t('Metadata export is starting'),
    'progress_message' => t('Processed @current out of @total'),
    'error_message' => t('Metadata export has encountered an error.'),
  );
  batch_set($batch);
}

/**
 * Metadata import Batch API
 */
function xc_import_batch($format, $directory, $locations, &$context) {
  require_once drupal_get_path('module', 'xc_metadata') . '/includes/xc_metadata.format.inc';

  $_format = xc_format_get($format);
  $path = drupal_realpath(file_default_scheme() . '://') . '/' . $directory;
  file_prepare_directory($path, TRUE);

  if (!isset($context['sandbox']['progress'])) {
    $context['sandbox']['files'] = array_values(file_scan_directory($path, $_format['file extension'] . '$'));
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['current'] = 0;
    $context['sandbox']['max'] = count($context['sandbox']['files']);
  }

  $limit = 200;
  $start = $context['sandbox']['current'];
  $end = min($context['sandbox']['current'] + $limit, $context['sandbox']['max']);
  for ($i = $start; $i < $end; $i++) {
    // Get the file's contents
    $file = $context['sandbox']['files'][$i];
    $filename = $file->filename;
    $raw = file_get_contents($filename);

    // Instantiate incomplete entity
    $entity = new XCEntity();
    $entity->raw = $raw;
    $entity->source_id =
    $entity->format = $format;

    // Add the source to the incomplete entity
    $sql = "SELECT * FROM {xc_source} WHERE type = 'import_export'";
    $source = db_query("SELECT * FROM {xc_source} WHERE type = :type", array(':type' => 'import_export'))->fetchObject();
    $entity->source_id = $source->source_id;

    // Also add the locations
    $entity->locations = array();
    foreach ($locations as $location_id) {
      $entity->locations[$location_id] = xc_location_get($location_id);
    }

    // Build into complete entity
    _xc_build($entity);

    // Store entity to its locations
    _xc_store($entity);

    // Store some result for post-processing in the finished callback.
    $context['results'][] = $entity->metadata_id;

    // Update our progress information.
    $context['sandbox']['progress']++;
    $context['sandbox']['current'] = $entity->metadata_id;
    $context['message'] = t('Now processing %identifier', array('%identifier' => $entity->identifier));
  }

  if ($context['sandbox']['progress'] != $context['sandbox']['max']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
}

/**
 * Metadata import Batch API finished callback
 */
function xc_import_batch_finished($success, $results, $operations) {
  if ($success) {
    $message = t('Successfully imported %count metadata records.', array('%count' => count($results)));
  }
  else {
    $error_operation = reset($operations);
    $message = t('An error occurred while processing %error_operation with arguments: @arguments', array('%error_operation' => $error_operation[0], '@arguments' => print_r($error_operation[1], TRUE)));
  }
  drupal_set_message($message);
}

/**
 * Metadata export Batch API
 */
function xc_export_batch($directory, &$context) {
  if (!isset($context['sandbox']['progress'])) {
    $sql = 'SELECT COUNT(DISTINCT metadata_id) FROM {xc_entity_properties}';

    $context['sandbox'] = array(
      'progress' => 0,
      'current' => 0,
      'max' => db_query($sql)->fetchField(),
    );
  }

  require_once drupal_get_path('module', 'xc_metadata') . '/includes/xc_metadata.format.inc';
  $formats = xc_format_get();

  $limit = 200;
  $sql = "SELECT metadata_id
          FROM {xc_entity_properties}
          WHERE metadata_id > %d
          ORDER BY metadata_id ASC";
  $result = db_query_range("SELECT metadata_id
          FROM {xc_entity_properties}
          WHERE metadata_id > :metadata_id
          ORDER BY metadata_id ASC", array(':metadata_id' => $context['sandbox']['current']));

  //while ($metadata_id = db_fetch_object($result)) {
  foreach ($result as $metadata_id) {
    $entity = new XCEntity($metadata_id);

    // Transformed output, usually XML, and save as file to directory
    $output = $entity->transform();
    //$path = file_directory_path() . '/' . $directory;
    $path = drupal_realpath(file_default_scheme() . '://')  . '/' . $directory;
    $filename = $entity->metadata_id . '.' . $formats[$entity->format]['file extension'];

    file_prepare_directory($path, TRUE);
    file_save_data($output, $path . '/' . $filename, FILE_EXISTS_REPLACE);

    // Store some result for post-processing in the finished callback.
    $context['results'][] = $entity->metadata_id;

    // Update our progress information.
    $context['sandbox']['progress']++;
    $context['sandbox']['current'] = $entity->metadata_id;
    $context['message'] = t('Now processing %identifier', array('%identifier' => $entity->identifier));
  }

  if ($context['sandbox']['progress'] != $context['sandbox']['max']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
}

/**
 * Metadata export Batch API finished callback
 */
function xc_export_batch_finished($success, $results, $operations) {
  if ($success) {
    $message = t('Successfully exported %count metadata records.', array('%count' => count($results)));
  }
  else {
    $error_operation = reset($operations);
    $message = t('An error occurred while processing %error_operation with arguments: @arguments', array('%error_operation' => $error_operation[0], '@arguments' => print_r($error_operation[1], TRUE)));
  }
  drupal_set_message($message);
}

