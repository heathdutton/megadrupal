<?php
/**
 * @file
 * The module used for being a connector between Apache Solr server and Drupal Toolkit.
 * We use a modified version of the SolrPhpClient to access Solr webservices.
 *
 * The information about Solr servers are stored in xc_solr_server table in MySQL.
 *
 * @copyright (c) 2010-2011 eXtensible Catalog Organization
 */

/**
 * @addtogroup global variables
 * @{
 */
global $_xc_solr_obj;
global $_xc_solr_indexing_statistics;
global $_xc_solr_batch_remove;
global $_xc_solr_batch_documents;
global $_xc_solr_processed_record_count;
/**
 * @} End of "addtogroup global variables".
 */

require_once 'SolrPhpClient/Apache/Solr/DocumentXc.php';
require_once 'SolrPhpClient/Apache/Solr/ResponseXc.php';
require_once 'SolrPhpClient/Apache/Solr/ServiceXc.php';
require_once 'SolrPhpClient/Apache/Solr/Drupal_Apache_Solr_ServiceXc.php';

require_once 'xc_solr_date.inc';

/**
 * Number of documents belongs to one Solr::addDocuments() operation
 * @var int
 */
define('XC_BATCH_SIZE', 200);

/**
 * The number of documents after a commit operation triggered
 * @var int
 */
define('XC_COMMIT_SIZE', 1000);

/**
 * The number of document used in batch when reindexing
 * @var int
 */
define('XC_BULK_REINDEX_LIMIT', 50);

/**
 * Permission for administering XC Solr
 * @var String
 */
define('ADMINISTER_XC_SOLR', 'administer xc solr');

define('XC_SOLR_PROCESS_ALL', 'all');
define('XC_SOLR_PROCESS_CHANGES_ONLY', 'changes only');

/**
 * Phases of batch process
 */
if (!defined('XC_PHASE_PREPARATION')) {
  define('XC_PHASE_PREPARATION', 1);
  define('XC_PHASE_LOAD', 2);
  define('XC_PHASE_NORMALIZATION', 3);
}

define('XC_SOLR_SERVICE_DEFAULT', 1);
define('XC_SOLR_SERVICE_DRUPAL', 2);

/**
 * Implementation of hook_help()
 * @param $path
 * @param $arg
 * @return unknown_type
 */
function xc_solr_help($path, $arg) {
  $output = '';
  switch ($path) {
    case "admin/help#xc_solr" :
      $output = '<p>'
        . t('Integrates !solr into XC modules. Solr installation:',
          array('!solr' => l(t('Apache Solr'), 'http://lucene.apache.org/solr')));
      $steps = array(
        t('download Apache Solr from Solr !download_page',
          array('!download_page' => l(t('download page'), 'http://www.apache.org/dyn/closer.cgi/lucene/solr/'))),
        t('unzip it to a convenient place'),
        t("copy drupal/sites/all/modules/xc/xc_solr/schema.xml to Solr's example/solr/conf"),
        t('run solr with java -jar example/start.jar'),
        t('test Solr accessibility at !url',
          array('!url' => l('localhost:8983', 'http://localhost:8983/solr')))
      );
      $output .= theme('item_list', array('items' => $steps));
      $output .= t('More information at !url', array('!url' => l(t('Solr homepage'),
        'http://lucene.apache.org/solr')));
      $output .= '</p>';
      break;

    case 'admin/xc/solr/facet_stat' :
      $output = t('This page gives you information about whats happens during the facet creation. This table collect information from each faceted search. The columns of the table: ');
      $output .= theme('item_list', array('items' => array(
        t('total - the total time taken'),
        t('UI - the user interface which was applied'),
        t('hits - the number of hits'),
        t('prepare - the time taken for the preparation of facet parameters'),
        t('all solr - the time taken from sending the parameters, to receiving all results'),
        t('solr - the time taken purely for Solr query - reported by Solr itself'),
        t('display - the time taken for displaying facets'),
      )));
      break;
  }
  return $output;
} // xc_solr_help

/**
 * Implementation of hook_perm()
 * Valid permissions for this module
 * @return (Array)
 *   An array of valid permissions for the XC Solr module
 */
function xc_solr_perm() {
  return array(
    ADMINISTER_XC_SOLR
  );
}

/**
 * Implementation of hook_menu().
 * @return array The menu array
 */
function xc_solr_menu() {
  $items['admin/xc/solr'] = array(
    'title' => 'Solr Setup and Indexing',
    'description' => 'Tell Drupal about your Apache Solr server. Prerequisite: Install Solr on the same computer as Drupal following the instructions included with XC and from the Apache Solr site.',
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array(ADMINISTER_XC_SOLR),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 0,
  );
  $items['admin/xc/solr/server'] = array(
    'title' => 'Solr servers',
    'description' => 'Create, modify, and view Solr servers used for metadata
      storage and search',
    'page callback' => 'xc_solr_server_list',
    'access arguments' => array(ADMINISTER_XC_SOLR),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 0,
  );

  $items['admin/xc/solr/proxy'] = array(
    'title' => 'Solr proxy',
    'description' => 'If you don\'t have direct access to your Solr server,use this form to check queries',
    'page callback' => 'xc_solr_proxy',
    'access arguments' => array(ADMINISTER_XC_SOLR),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 1,
  );

  $items['admin/xc/solr/info'] = array(
    'title' => 'Information about Solr index',
    'description' => 'Information about Solr index.',
    'page callback' => 'xc_solr_info',
    'file' => 'xc_solr.info.inc',
    'access arguments' => array(ADMINISTER_XC_SOLR),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 2,
  );

  $items['admin/xc/solr/optimize'] = array(
    'title' => 'Optimize Solr index',
    'description' => 'Optimize Solr index.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_solr_xc_optimize_all_form'),
    'access arguments' => array(ADMINISTER_XC_SOLR),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 4,
  );

  $items['admin/xc/solr/field_type'] = array(
    'title' => 'Solr field types',
    'description' => 'Registry of dynamic Solr fields.',
    'page callback' => 'xc_solr_field_type_list',
    'access arguments' => array(ADMINISTER_XC_SOLR),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'xc_solr_field_type.inc',
    'weight' => 5,
  );

  $items['admin/xc/solr/search_stat'] = array(
    'title' => 'Statistics about searches',
    'description' => 'Statistics about searches.',
    'page callback' => 'xc_solr_search_statistics',
    'access arguments' => array(ADMINISTER_XC_SOLR),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'xc_solr.info.inc',
    'weight' => 6,
  );

  $items['admin/xc/solr/facet_stat'] = array(
    'title' => 'Statistics about facets',
    'description' => 'Statistics about facets.',
    'page callback' => 'xc_solr_facet_statistics',
    'access arguments' => array(ADMINISTER_XC_SOLR),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'xc_solr.info.inc',
    'weight' => 7,
  );

  $items['admin/xc/solr/batch_stat'] = array(
    'title' => 'Statistics about harvest',
    'description' => 'Statistics about harvest.',
    'page callback' => 'xc_solr_onestop_indexer_batch_statistics',
    'access arguments' => array(ADMINISTER_XC_SOLR),
    'type' => MENU_NORMAL_ITEM,
    // 'file' => 'xc_solr.info.inc',
    'weight' => 7,
  );

  $items['admin/xc/solr/delete_content'] = array(
    'title' => 'Delete content',
    'description' => 'Delete all Solr content.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_solr_xc_delete_all_form'),
    'access arguments' => array(ADMINISTER_XC_SOLR),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 8,
  );

  $items['admin/xc/solr/server/list'] = array(
    'title' => 'List',
    'description' => 'Listing of Solr servers',
    'page callback' => 'xc_solr_server_list',
    'access arguments' => array(ADMINISTER_XC_SOLR),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );
  $items['admin/xc/solr/server/add'] = array(
    'title' => 'Add server',
    'description' => 'Register a new Solr server',
    'page callback' => 'xc_solr_server_add',
    'access arguments' => array(ADMINISTER_XC_SOLR),
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
  );
  $items['admin/xc/solr/server/%xc_solr_server'] = array(
    'title callback' => 'xc_solr_server_title',
    'title arguments' => array(4),
    'description' => 'View the properties of a Solr server',
    'page callback' => 'xc_solr_server_view',
    'page arguments' => array(4),
    'access arguments' => array(ADMINISTER_XC_SOLR),
    'type' => MENU_CALLBACK,
  );
  $items['admin/xc/solr/server/%xc_solr_server/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/xc/solr/server/%xc_solr_server/edit'] = array(
    'title' => 'Edit',
    'description' => 'Edit the properties of a Solr server',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_solr_server_edit_form', 4),
    'access arguments' => array(ADMINISTER_XC_SOLR),
    'type' => MENU_LOCAL_TASK,
    'weight' => -9,
  );

  $items['admin/xc/solr/field_type/list'] = array(
    'title' => 'List Solr field types',
    'description' => 'List of Solr field types',
    'page callback' => 'xc_solr_field_type_list',
    'access arguments' => array(ADMINISTER_XC_SOLR),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
    'file' => 'xc_solr_field_type.inc',
  );
  $items['admin/xc/solr/field_type/add'] = array(
    'title' => 'Add a new Solr field type',
    'description' => 'Add a new Solr field type',
    'page callback' => 'xc_solr_field_type_add',
    'access arguments' => array(ADMINISTER_XC_SOLR),
    'type' => MENU_LOCAL_TASK,
    'file' => 'xc_solr_field_type.inc',
  );
  $items['admin/xc/solr/field_type/reorder'] = array(
    'title' => 'Reorder',
    'description' => 'Reorder Solr field types table',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_solr_field_type_reorder_form'),
    'access arguments' => array(ADMINISTER_XC_SOLR),
    'type' => MENU_LOCAL_TASK,
    'file' => 'xc_solr_field_type.inc',
  );
  $items['admin/xc/solr/field_type/%xc_solr_field_type'] = array(
    'title' => 'Show Solr field type',
    'description' => 'Show Solr field type',
    'title callback'  => 'xc_solr_field_type_title',
    'title arguments' => array(4),
    'page callback'   => 'xc_solr_field_type_view',
    'page arguments'  => array(4),
    'access arguments' => array(ADMINISTER_XC_SOLR),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'xc_solr_field_type.inc',
  );
  $items['admin/xc/solr/field_type/%xc_solr_field_type/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/xc/solr/field_type/%xc_solr_field_type/edit'] = array(
    'title' => 'Edit',
    'description' => 'Edit Solr field type',
    'page callback' => 'drupal_get_form',
    'page arguments'  => array('xc_solr_field_type_edit_form', 4),
    'access arguments' => array(ADMINISTER_XC_SOLR),
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
    'file' => 'xc_solr_field_type.inc',
  );

  $items['admin/xc/solr/field_type/%xc_solr_field_type/add'] = array(
    'title' => 'Add new Solr field type',
    'description' => 'Add new Solr field type',
    'page callback' => 'xc_solr_field_type_add',
    'access arguments' => array(ADMINISTER_XC_SOLR),
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
    'file' => 'xc_solr_field_type.inc',
  );

  $items['admin/xc/solr/indexlist'] = array(
    'title' => 'List fields to index',
    'description' => 'List fields to index.',
    'page callback' => 'xc_solr_show_fields2index_list',
    'access arguments' => array(ADMINISTER_XC_SOLR),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'xc_solr.index.inc',
  );
  $items['admin/xc/solr/onestop'] = array(
    'title' => 'Run one-stop indexer',
    'description' => 'Run one-stop indexer.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_solr_onestop_indexer_batch_launcher_form', NULL),
    'access arguments' => array(ADMINISTER_XC_SOLR),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'xc_solr.index.inc',
  );

  $items['admin/xc/solr/onestop_stat'] = array(
    'title' => 'Get one-stop indexer stat',
    'description' => 'Get one-stop indexer stat.',
    'page callback' => 'xc_solr_onestop_indexer_batch_finished',
    'access arguments' => array(ADMINISTER_XC_SOLR),
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * Implementation of hook_theme().
 *
 * List of themes defined in xc_solr modules
 */
function xc_solr_theme() {

  $themes = array(
    'xc_solr_field_type_reorder_form' => array(
      'arguments' => array(
        'form' => array()
      ),
      'file' => 'xc_solr_field_type.inc',
    ),
  );

  return $themes;
}

/**
 * Get all Solr server database records.
 * The server's fields are: sid, location_id (id for metadata source), name,
 * host, port, path, description
 *
 * @return (Array)
 *   The array of Solr id (sid) - Solr DB record object pairs
 */
function xc_solr_get_servers($update = FALSE) {
  static $servers = array();

  if (empty($servers) || $update == TRUE) {
    $sql = 'SELECT * FROM {xc_solr_servers}';
    $result = db_query($sql);
    //while ($solr = db_fetch_object($result)) {
    foreach ($result as $solr) {
      $servers[$solr->sid] = $solr;
    }
  }

  return $servers;
}

function xc_solr_server_title($sid) {
  $solr = xc_solr_server_load($sid);
  return $solr->name;
}

function xc_solr_get_url($sid) {
  $solr = xc_solr_server_load($sid);
  $url = 'http://' . check_plain($solr->host) . ':'. check_plain($solr->port) . check_plain($solr->path);
  return $url;
}

function xc_solr_server_list() {
  $headers = array(t('Name'), t('URL'), array('data' => t('Operations'),
    'colspan' => 2));
  $rows = array();
  $servers = xc_solr_get_servers();

  drupal_set_title(t('Solr servers'));

  foreach ($servers as $solr) {
    $url = xc_solr_get_url($solr->sid);
    $rows[] = array(
      check_plain($solr->name),
      l($url, check_url($url)),
      l(t('view'), 'admin/xc/solr/server/' . $solr->sid),
      l(t('edit'), 'admin/xc/solr/server/' . $solr->sid . '/edit')
    );
  }
  return theme('table', array('header' => $headers, 'rows' => $rows));
}

function xc_solr_server_view($solr) {
  $headers = array(t('Property'), t('Value'));
  $rows = array();

  $rows[] = array(t('Name'), check_plain($solr->name));
  $rows[] = array(t('Host'), check_plain($solr->host));
  $rows[] = array(t('Port'), check_plain($solr->port));
  $rows[] = array(t('Path'), check_plain($solr->path));
  $rows[] = array(t('URL'), check_url(xc_solr_get_url($solr->sid)));
  $rows[] = array(t('Description'), check_plain($solr->description));

  drupal_set_title(check_plain($solr->name));
  return theme('table', array('header' => $headers, 'rows' => $rows));
}

// -- BEGINING of add repository functions

/**
 * Add a new server
 * @return string The add server page with a form
 */
function xc_solr_server_add() {
  drupal_set_title(t('Solr servers'));
  return drupal_get_form('xc_solr_server_add_form');
}

/**
 * The add repository form object
 * @return array
 */
function xc_solr_server_add_form() {
  $form['name'] = array(
    '#title' => t('Name'),
    '#type' => 'textfield',
    '#description' => 'The name of the Solr server',
  );

  $form['host'] = array(
    '#title' => t('Host'),
    '#type' => 'textfield',
    '#description' => 'The host of the Solr server',
    '#default_value' => 'localhost',
  );

  $form['port'] = array(
    '#title' => t('Port'),
    '#type' => 'textfield',
    '#description' => 'The port of the Solr server',
    '#default_value' => '8983',
  );

  $form['path'] = array(
    '#title' => t('Path'),
    '#type' => 'textfield',
    '#description' => 'The path of the Solr server',
    '#default_value' => '/solr',
  );

  $form['description'] = array(
    '#title' => t('Description'),
    '#type' => 'textarea',
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Add server'),
  );

  return $form;
}

/**
 * Validate the new repository form
 * @param $form
 * @param $form_state
 * @return unknown_type
 */
function xc_solr_server_add_form_validate($form, &$form_state) {
  if (empty($form_state['values']['name'])
    || $form_state['values']['name'] == '') {
    form_set_error('name', t('Name shouldn\'t be empty'));
  }
  if (empty($form_state['values']['host'])
    || $form_state['values']['host'] == '') {
    form_set_error('name', t('Host shouldn\t be empty'));
  }
  if (empty($form_state['values']['port'])
    || $form_state['values']['port'] == '') {
    form_set_error('name', t('Port shouldn\'t be empty'));
  }
  if (empty($form_state['values']['path'])
    || $form_state['values']['path'] == '') {
    form_set_error('name', t('Path shouldn\t be empty'));
  }
}

/**
 * Handle post-validation form submission of new repository form
 * @param $form
 * @param $form_state
 * @return unknown_type
 */
function xc_solr_server_add_form_submit($form, &$form_state) {

  $solr = new stdClass();
  $solr->location_id = '';
  $solr->name = check_plain($form_state['values']['name']);
  $solr->host = check_plain($form_state['values']['host']);
  $solr->port = check_plain($form_state['values']['port']);
  $solr->path = check_plain($form_state['values']['path']);
  $solr->description = check_plain($form_state['values']['description']);

  $ret_val = drupal_write_record('xc_solr_servers', $solr);
  if ($ret_val == SAVED_NEW) {
    drupal_set_message(t('Solr server "%name" added', array('%name' => $solr->name)));
    $form_state['redirect'] = 'admin/xc/solr/server/list';
  }
  else {
    drupal_set_message(t('Unexpected error. Failed to create new Solr server.'));
  }
}

// -- END of add server funtions

function xc_solr_server_edit_form($form,&$form_state,$solr) {
  $form = xc_solr_server_add_form();
  $form['sid'] = array(
    '#type'  => 'hidden',
    '#value' => $solr->sid
  );
  $form['name']['#default_value'] = $solr->name;
  $form['host']['#default_value'] = $solr->host;
  $form['port']['#default_value'] = $solr->port;
  $form['path']['#default_value'] = $solr->path;
  $form['description']['#default_value'] = $solr->description;

  $form['submit']['#value'] = t('Save');
  $form['delete'] = array(
    '#type' => 'submit',
    '#value' => t('Delete'),
  );
  return $form;
}

function xc_solr_server_edit_form_validate($form, &$form_state) {
  xc_solr_server_add_form_validate($form, $form_state);
}

function xc_solr_server_edit_form_submit($form, &$form_state) {
  $solr = new stdClass();
  //$solr = new stdClass();
  $solr->sid  = check_plain($form_state['values']['sid']);
  $solr->name = check_plain($form_state['values']['name']);
  $solr->host = check_plain($form_state['values']['host']);
  $solr->port = check_plain($form_state['values']['port']);
  $solr->path = check_plain($form_state['values']['path']);
  $solr->description = check_plain($form_state['values']['description']);

  if ($form_state['clicked_button']['#value'] == t('Delete')) {
    $result = db_delete('xc_solr_servers')
              ->condition('sid', $solr->sid)
              ->execute();
    if ($result == 1) {
      drupal_set_message(t('%name removed', array('%name' => $solr->name)));
      $form_state['redirect'] = 'admin/xc/solr/server/list';
    }
    else {
      drupal_set_message(t('Unexpected error. Deletion removed %count server.',
        array('%name' => $record->name)));
    }
  }
  elseif ($form_state['clicked_button']['#value'] == t('Save')) {
    $result = drupal_write_record('xc_solr_servers', $solr, 'sid');

    if ($result == SAVED_UPDATED) {
      drupal_set_message(t('%name modified', array('%name' => $solr->name)));
      $form_state['redirect'] = 'admin/xc/solr/server/list';
    }
    else {
      drupal_set_message(t('Unexpected error. Failed to modify server.'));
    }
  }
}

/**
 * Implementation of hook_xc_location()
 * @see _xc_location
 */
function xc_solr_xc_location($op, $location, $params = array()) {
  switch ($op) {
    case 'types':
      $sid  = (isset($location->location_id)) ? xc_solr_get_sid($location->location_id) : FALSE;

      $types['solr'] = array(
        'name'        => ($sid
           ? t('Apache Solr server at %path', array('%path' => xc_solr_get_url($sid)))
           : t('Apache Solr server')),
        'description' => t('Store and retrieve metadata elements to and from Apache Solr servers'),
        'module'      => 'xc_solr',
        'help'        => t('Store and retrieve metadata elements to and from Apache Solr servers'),
        'default'     => TRUE
      );
      return $types;
      break;
    case 'view':
    case 'load':
      break;
    case 'form':
      break;
    case 'create':
    case 'update':
      // no information to update
      break;
    case 'purge':
      // delete all metadata in Solr server
      $sid  = xc_solr_get_sid($location->location_id);
      $solr = xc_solr_server_load($sid);
      xc_solr_server_unset($solr);
      break;
    case 'delete':
      // delete everything AND unregister Solr server
      break;
  }
}

function xc_solr_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'devel_generate_content_form') {
    /*
    $form['add_upload']['#type'] = 'hidden';
    $form['add_terms']['#type'] = 'hidden';
    $form['add_alias']['#type'] = 'hidden';
    // $form['num_nodes']['#type'] = 'hidden';
    $form['num_nodes']['#default_value'] = 0;
    $form['max_comments']['#type'] = 'hidden';
    $form['kill_content']['#default_value'] = 1;
    $form['time_range']['#type'] = 'hidden';
    $form['title_length']['#type'] = 'hidden';
    // */
  }
  elseif ($form_id == 'xc_location_form') {
    $step     = &$form_state['storage']['step'];
    $location = &$form_state['storage']['location'];

    if ($step == 2 && $location->has_solr_type) {
      $sid = isset($location->location_id) ? xc_solr_get_sid($location->location_id) : FALSE;
      if ($sid) {
        $current_solr = xc_solr_server_load($sid);
      }
      if (!$sid || empty($current_solr)) {
        $current_solr = (object)array(
          'host' => 'localhost',
          'port' => 8983,
          'path' => '/solr'
        );
      }

      $form['solr']['solr_host'] = array(
        '#title' => t('Host'),
        '#type' => 'textfield',
        '#description' => 'The host of the Solr server',
        '#default_value' => $current_solr->host,
        '#required' => TRUE
      );

      $form['solr']['solr_port'] = array(
        '#title' => t('Port'),
        '#type' => 'textfield',
        '#description' => 'The port of the Solr server',
        '#default_value' => $current_solr->port,
        '#required' => TRUE
      );

      $form['solr']['solr_path'] = array(
        '#title' => t('Path'),
        '#type' => 'textfield',
        '#description' => 'The path of the Solr server',
        '#default_value' => $current_solr->path,
        '#required' => TRUE
      );

      $form['#validate'][] = 'xc_solr_location_validate';
      $form['#submit'][] = 'xc_solr_location_submit';
    }
  }
}

function xc_solr_location_validate($form, &$form_state) {
  $step     = &$form_state['storage']['step'];
  $location = &$form_state['storage']['location'];

  if ($step == 2 && $location->has_solr_type) {
    // Nothing needed
    $form_state['solr_storage'] = &$form_state['storage'];
  }
}

function xc_solr_location_submit($form, &$form_state) {
  $step     = &$form_state['solr_storage']['step'];
  $location = &$form_state['solr_storage']['location'];

  if ($step > 2 && $location->has_solr_type) {
    $solr = new stdClass();
    $solr->sid         = xc_solr_get_sid($location->location_id);
    $solr->location_id = $location->location_id;
    $solr->host        = $form_state['values']['solr_host'];
    $solr->port        = $form_state['values']['solr_port'];
    $solr->path        = $form_state['values']['solr_path'];
    xc_solr_server_set($solr);
    unset($form_state['solr_storage']);
  }
}

function xc_solr_server_set($solr) {
  //TODO from Tom, need to convert to D7
  $sql = 'SELECT sid FROM {xc_solr_servers} WHERE sid = :d';

  $update = empty($solr->sid)
    ? FALSE
    : db_query($sql, array(':d' =>$solr->sid))->fetchField();

  if ($update) {
    $result = drupal_write_record('xc_solr_servers', $solr, 'sid');
  }
  else {
    unset($solr->sid);
    $result = drupal_write_record('xc_solr_servers', $solr);
  }

  if (!$result) {
    drupal_set_message(t('Unexpected error. Unable to register Solr server'), 'error');
  }
}

function xc_solr_server_unset($solr) {
  $sql = 'DELETE FROM {xc_solr_servers} WHERE storage_id = :d';
  $result = db_query($sql, array(':d' => $solr->sid));
  if ($result) {
    drupal_set_message(t('Apache Solr server removed'));
  }
  else {
    drupal_set_message(t('Unexpected error. Failed to remove server.'), 'error');
  }
}

function xc_solr_get_location_id($sid) {
  static $cache;
  if (empty($cache[$sid])) {
    $sql = 'SELECT location_id FROM {xc_solr_servers} WHERE sid = :d';
    // TODO from Tom, need to check db_result for D7
    $cache[$sid] = db_result(db_query($sql, array(':d' => $sid)));
  }
  return $cache[$sid];
}

/**
 * Get the Solr record identifier attached to a location id
 * @param $location_id (int) The location record's identifier
 * @return (int) The Solr record identifier
 */
function xc_solr_get_sid($location_id) {
  static $cache;
  if (empty($cache[$location_id])) {
    $sql = 'SELECT sid FROM {xc_solr_servers} WHERE location_id = :d';
    $cache[$location_id] = db_query($sql, array(':d' => $location_id))->fetchField();
  }
  return $cache[$location_id];
}

/**
 * Implementation of hook_xc_remove().
 *
 * Remove an object from the storage (here from Solr).
 *
 * @param (Object) $object
 *   XCEntity object
 * @param (Array) $locations
 * @param (Array) $params
 */
function xc_solr_xc_remove(&$object, $locations, $params = array()) {
  global $_xc_solr_batch_remove;
  /**
   * Flags whether the locations array is saved into a Drupal variable
   */
  static $location_saved;

  if (!empty($object)) {
    $_xc_solr_batch_remove[] = $object->metadata_id;
    if (!empty($locations) && !isset($location_saved)) {
      variable_set('xc_solr_remove_lat_locations', $locations);
      $location_saved = TRUE;
    }
  }

  if (count($_xc_solr_batch_remove) == XC_BATCH_SIZE
      || (isset($params['do_check_size']) && $params['do_check_size'] === FALSE)) {

    if (empty($locations) && $params['do_check_size'] === FALSE) {
      $locations = variable_get('xc_solr_remove_lat_locations', array());
    }

    if (empty($locations) && !empty($params['solr servers'])) {
      $solr_servers = $params['solr servers'];
    }
    else {
      $solr_servers = xc_solr_locations2solrs($locations);
    }

    foreach ($solr_servers as $solr) {
      if (is_null($solr)) {
        xc_log_info('solr', '$solr is NULL');
        continue;
      }

      try {
        $query = 'metadata_id_s:("' . join('" OR "', $_xc_solr_batch_remove) . '")';
        xc_log_info('solr', 'delete ' . $query);
        $solr->deleteByQuery($query);
      }
      catch (Exception $e) {
        xc_log_error('xc_solr', t('Problems during deletion: %e',
          array('%e' => $e->getMessage())));
      }
    }
    $_xc_solr_batch_remove = array();

    if (!empty($locations)) {
      variable_set('xc_solr_remove_lat_locations', $locations);
    }
  }
}

/**
 * Checking whether the Solr instance is running or not.
 *
 * @param $locations (Array)
 *   Array of storage location objects
 * @return (Array) An array of state reports. The key of the array is the
 *   location id, the value is an associative array, having the following keys:
 *   'url' (String) the URL of Solr,
 *   'running' (Boolean) TRUE is Solr is running, FALSE if Solr is stopped
 *   'response_time' (float) The response time of Solr (in the case it is
 *   running).
 */
function xc_solr_ping($locations) {
  global $_xc_solr_obj;

  $results = array();
  foreach ($locations as $location) {
    if (!$location->has_solr_type) {
      continue;
    }
    $sid = xc_solr_get_sid($location->location_id);
    $current_solr = $_xc_solr_obj[$sid];
    if (is_null($current_solr)) {
      continue;
    }
    $results[$location->location_id]['url'] = $current_solr->getUrl();
    try {
      $result = $current_solr->ping();
      if ($result === FALSE) {
        $results[$location->location_id]['running'] = FALSE;
      }
      else {
        $results[$location->location_id]['response_time'] = $result;
        $results[$location->location_id]['running'] = TRUE;
      }
    }
    catch (Exception $e) {
      xc_log_error('xc_solr', t('Problems during deletion: %e', array('%e' => $e->getMessage())));
      $results[$location->location_id]['running'] = FALSE;
    }
  }
  return $results;
}

/**
 * Implementation of hook_xc_store
 * @param $object
 * @param $location
 * @param $params
 * @return unknown_type
 */
function xc_solr_xc_store(&$object, $locations, $params = array()) {
  global $_xc_solr_batch_documents, $times, $_oaiharvester_statistics;

  $t0 = microtime(TRUE);
  if (!isset($_xc_solr_batch_documents)) {
     $_xc_solr_batch_documents = array();
  }
  if (!isset($times)) {
    $times = array(
      'record_count' => 0,
      'total'    => 0.0,
      'solarize' => 0.0,
      'document' => 0.0,
      'batch'    => 0.0,
    );
  }

  $solrs = xc_solr_locations2solrs($locations);
  $t1 = microtime(TRUE);
  $times['solarize'] += $t1 - $t0;

  if (!empty($solrs)) {
    $t_to_document = microtime(TRUE);
    require_once('xc_solr.index.inc');
    $document = xc_solr_metadata_to_solr_factory($object, 'iterate over indexes');
    $t_to_document2 = microtime(TRUE);
    xc_oaiharvester_statistics_set('02 bridge/03 _xc_store/06 hook_xc_store/solr_xc_store/01 create Solr document', abs($t_to_document2 - $t_to_document));
    xc_oaiharvester_statistics_set('toSolr', abs($t_to_document2 - $t_to_document));
    $_xc_solr_batch_documents[] = $document;
  }
  $t2 = microtime(TRUE);
  $times['document'] += $t2 - $t1;

  $indexed = FALSE;
  if (XC_BATCH_SIZE == 0 || XC_BATCH_SIZE == count($_xc_solr_batch_documents)) {
    xc_log_info('solr', 'call batch index: ' . count($_xc_solr_batch_documents));
    $times['record_count'] += count($_xc_solr_batch_documents);
    _xc_solr_batch_index(TRUE, $solrs, '02 bridge/03 _xc_store/06 hook_xc_store/solr_xc_store');
    $indexed = TRUE;

    // cleanups
    foreach ($_xc_solr_batch_documents as $_document) {
      unset($_document);
    }

    $_xc_solr_batch_documents = array();
  }
  $t3 = microtime(TRUE);
  $times['batch'] += ($t3 - $t2);
  $times['total'] += ($t3 - $t0);

  if ($indexed) {
    xc_log_info('xc_solr',
      t('Number of documents: %count, total time: %total, prepare Solr servers: %solarize (%solarize-pc%), creating Solr documents: %document (%document-pc%), save Solr documents: %batch (%batch-pc)%',
        array(
          '%count'       => $times['record_count'],
          '%total'       => sprintf("%01.2f", $times['total']),
          '%solarize'    => sprintf("%01.2f", $times['solarize']),
          '%solarize-pc' => sprintf("%01.2f", ($times['solarize'] * 100 / $times['total'])),
          '%document'    => sprintf("%01.2f", $times['document']),
          '%document-pc' => sprintf("%01.2f", ($times['document'] * 100 / $times['total'])),
          '%batch'       => sprintf("%01.2f", $times['batch']),
          '%batch-pc'    => sprintf("%01.2f", ($times['batch'] * 100 / $times['total']))
        )
      )
    );
  }
  xc_oaiharvester_statistics_set('02 bridge/03 _xc_store/06 hook_xc_store/solr_xc_store', abs($t3 - $t0));
}


function xc_solr_get_solr_field_name($field, $suffix = -1) {
  static $cache;
  if (!isset($cache[$field][$suffix])) {
    $cache[$field][$suffix] = str_replace(':', '__', $field) . ($suffix != -1 ? $suffix : '');
  }
  return $cache[$field][$suffix];
}

/**
 * Add field to a Solr document
 *
 * @param $document (Object)
 *   The Solr document
 * @param $field (associative array)
 *   The field to add. It has a #name and a #type (~ 'facet', 'date_facet', 'text')
 * @param $value (String)
 *   The field value
 * @param $cleaned_value
 *   A cleaned field value
 */
function _xc_solr_add_field(&$document, &$field, &$value) {
  global $_oaiharvester_statistics;
  $_oaiharvester_statistics['toSolr/_xc_solr_add_field#']++;
  $t = microtime(TRUE);
  if ($value != '') {
    if (is_array($field)) {
      if ($field['#type'] == 'facet') {
        $_oaiharvester_statistics['toSolr/_xc_solr_add_field/->addField#']++;
        $document->addField($field['#name'], $value, FALSE, TRUE);
      }
      elseif ($field['#type'] == 'date_facet' || $field['#type'] == 'date_field') {
        $_oaiharvester_statistics['toSolr/_xc_solr_add_field/->addField#']++;
        $document->addField($field['#name'], xc_solr_to_date($value, $field['#name'], $document->id), FALSE, TRUE);
      }
    }
    else {
      $_oaiharvester_statistics['toSolr/_xc_solr_add_field/->addField#']++;
      $document->addField($field, $value, FALSE, TRUE);
    }
  }
  $t2 = microtime(TRUE);
  xc_oaiharvester_statistics_set('toSolr/_xc_solr_add_field', ($t2 - $t));
}

/**
 * Implementation of hook_xc_retrieve().
 *
 * @param $object (XCEntity)
 *   A reference to the actual XCEntity object, and so $object->metadata should
 *   be populated. $object->metadata_id will be set. $object->identifier should
 *   also contain the OAI identifier
 * @param $location (Object)
 *   The location object. it contains what is stored in a row of the xc_location
 *   DB table.
 * @param $params
 *
 * @return (Boolean)
 *   Flag of success (TRUE or FALSE)
 */
function xc_solr_xc_retrieve(&$object, $location, $params = array()) {
  /*
  $definition    = $params['definition'];
  $qualified     = $params['qualified'];
  $properties    = $params['properties'];
  $relationships = $params['relationships'];
  */

  $success = FALSE;
  $solr = xc_solr_location2solr($location);
  if (!is_null($solr) && $object->metadata_id && empty($object->metadata)) {
    $solr_params = array(
      'fl' => 'metadata_tsn',
      'XCNAME' => 'xc_solr_xc_retrieve'
    );

    try {
      $response = $solr->search('metadata_id_s:' . $object->metadata_id, 0, 1, $solr_params);
      if ($response->response->numFound == 1) {
        $object->metadata = unserialize($response->response->docs[0]->metadata_tsn);
        $success = TRUE;
      }
      /*
      else {
        xc_log_warning('Solr', t('Number of documents with metadata_id %id: %count',
          array('%id' => $object->metadata_id, '%count' => $response->response->numFound)));
      }*/
    }
    catch (Exception $e) {
      drupal_set_message($e->getMessage(), 'error');
    }
  }
  return $success;
}

/**
 * Build an array from the Solr document. The key of array will be the original
 * field names
 * @param $doc Solr document
 * @return Array of fields
 */
function _xc_solr_to_array($doc, $schema_fields = array(), $from_cache = TRUE) {
  static $cache, $multivalue_fields, $field_map;
  if (!is_a($doc, 'Apache_Solr_DocumentXc')) {
    return array();
  }

  $xc_record = unserialize($doc->metadata_tsn);
  $xc_record['id'] = $doc->id;

  if (!isset($field_map)) {
    $field_map = array(
      'node_id_i' => 'node_id',
      'node_type_s' => 'node_type',
      'metadata_id_s' => 'metadata_id',
      'metadata_type_s' => 'metadata_type',
      'type' => 'type',
      'source_id_s' => 'source_id',
      'bibid_s' => 'bibid',
      'holdingsid_i' => 'holdingsid'
    );
  }
  foreach ($field_map as $solr_field => $key) {
    if (isset($doc->$solr_field)) {
      $xc_record[$key] = $doc->$solr_field;
    }
  }

  $fields = $doc->getFieldNames();
  foreach ($fields as $field_name) {
    if (preg_match('/^(.*)_(fc|df)$/', $field_name, $matches)) {
      $xc_record[$matches[1]] = is_array($doc->$field_name) ? array_unique($doc->$field_name) : $doc->$field_name;
    }
  }

  if (!isset($xc_record['node_id'])) {
    $xc_record['node_id'] = _metadata_id_to_node_id($xc_record['metadata_id']);
  }
  return $xc_record;

  /*
  if (!isset($multivalue_fields)) {
    // these fields should always be an array
    $multivalue_fields = array('xc:workExpressed', 'xc:expressionManifested',
      'xc:manifestationHeld');
  }

  if (!isset($cache[$doc->id]) || !$from_cache) {
    // regex looks like /(_i|_s|_l|_t|_b|_f|_d|_dt|_fc|_df)$/
    $suffix_regex = xc_solr_field_type_get_regex();
    $xc_record = array();

    if (!empty($schema_fields)) {
      $fields = array();
      foreach ($schema_fields as $field) {
        $fields[] = xc_solr_schema2solr($field, TRUE, FALSE);
      }
    }
    else {
      $fields = $doc->getFieldNames();
    }

    foreach ($fields as $field) {
      $value = $doc->$field;
      $xc_field = preg_replace($suffix_regex, "", $field, 1, $count);
      if ($count > 0) {
        $xc_field = str_replace('__', ':', $xc_field);
      }
      if ((in_array($xc_field, $multivalue_fields))) {
        if (!is_array($value)) {
          $value = array($value);
        }
      }
      $xc_record[$xc_field] = $value;
    }
    $cache[$doc->id] = $xc_record;
  }
  return $cache[$doc->id];
  */
}

/**
 * Send Documents to Solr index. It use the global $_xc_solr_batch_documents as the
 * array of Solr Documents.
 *
 * @param $do_check_size (Boolean)
 *   If TRUE (default) index only when the number of documents equals XC_BATCH_SIZE
 * @param $solrs (Array)
 *   The array of Solr server objects
 * @param $caller (String)
 *   The name or program part which calls this function
 *
 * @return (Boolean)
 *   Whether or not the document addition was successfull
 */
function _xc_solr_batch_index($do_check_size = TRUE, $solrs = array(), $caller = NULL) {
  global $_xc_solr_batch_documents, $_xc_solr_processed_record_count,
    $_oaiharvester_statistics;

  if (!isset($_oaiharvester_statistics)) {
    $_oaiharvester_statistics = variable_get('oaiharvester_statistics', array());
  }

  $t_add = microtime(TRUE);

  if (count($_xc_solr_batch_documents) == 0
      || ($do_check_size && XC_BATCH_SIZE != 0
          && count($_xc_solr_batch_documents) != XC_BATCH_SIZE)) {
    return FALSE;
  }

  foreach ($solrs as $solr) {
    try {
      // Add document to the Solr server
      $t0 = microtime(TRUE);
      $response = $solr->addDocuments($_xc_solr_batch_documents);
      xc_log_info('xc_solr',
        t('Solr indexed %count (so far %total) document in %sec sec (from %caller).',
        array(
          '%count'  => count($_xc_solr_batch_documents),
          '%sec'    => sprintf("%01.2f", microtime(TRUE)-$t0),
          '%total'  => $_xc_solr_processed_record_count,
          '%caller' => $caller,
      )));
      xc_oaiharvester_statistics_set($caller . '/add document (total)/add document (Solr)', $response->responseHeader->QTime / 1000);

      // cleanups
      foreach ($_xc_solr_batch_documents as $document) {
        unset($document);
      }

      $_xc_solr_batch_documents = array();
    }
    catch (Exception $e) {
      xc_log_error('xc_solr', $e->getMessage() .' Failed doc to add: '
        . var_export($_xc_solr_batch_documents[0], TRUE));
    }
  }
  xc_oaiharvester_statistics_set($caller . '/add document (total)', abs(microtime(TRUE) - $t_add));
  return TRUE;
}

/**
 * Confirmation form checking the need og index optimization
 * @return unknown_type
 */
function xc_solr_xc_optimize_all_form() {
  return confirm_form(
    array(),
    t('Are you sure, that you would like to optimize Solr index?'),
    'admin/xc/solr', // path to go if user click on 'cancel'
    t('This action cannot be undone.'),
    t('Optimize index'),
    t('Cancel')
  );
}

/**
 * Confirmation form handler: confirmed, that user wants to optimize index
 * @param $form
 * @param $form_state
 * @return unknown_type
 */
function xc_solr_xc_optimize_all_form_submit($form, &$form_state) {
  xc_solr_xc_optimize_all();
}

/**
 * Optimize all index
 * @return unknown_type
 */
function xc_solr_xc_optimize_all() {
  xc_solr_xc_optimize();
  drupal_goto('admin/xc/solr');
}

/**
 * Confirmation form: whether the user really wants to delete everything from index?
 * @param $form_state
 * @return unknown_type
 */
function xc_solr_xc_delete_all_form($form,&$form_state) {

  return confirm_form(
    array(),
    t('Are you sure, that you would like to delete all Solr content?'),
    'admin/xc/solr', // path to go if user click on 'cancel'
    t('This action cannot be undone.'),
    t('Delete all content'),
    t('Cancel')
  );
}

/**
 * Confirmed, that user wants to delete everything from index

 * @param unknown_type $form
 * @param unknown_type $form_state
 * @return unknown_type
 */
function xc_solr_xc_delete_all_form_submit($form, &$form_state) {
  xc_solr_xc_delete_all();
  $form_state['redirect'] = 'admin/xc/solr';
}

/**
 * Delete all index
 */
function xc_solr_xc_delete_all() {
  global $_xc_solr_obj, $_xc_solr_batch_documents;

  if (empty($params['solr servers'])) {
    $servers = xc_solr_get_servers();
  }
  else {
    $servers = $params['solr servers'];
  }

  foreach ($servers as $solr) {
    $_xc_solr_obj[$solr->sid]->deleteByQuery('*:*');
    $msg = t('Solr index at %sid deleted', array('%sid' => $solr->host . ':'
      . $solr->port . $solr->path));
    drupal_set_message($msg);
    xc_log_info('xc_solr', $msg);
  }

  xc_solr_xc_commit();
  xc_solr_xc_optimize();
  // drupal_goto('admin/xc/solr');
} // xc_solr_xc_delete_all

/**
 * Copy the fields of one Solr document to another Solr document
 * @param $source
 * @param $target
 * @return void
 */
function xc_solr_copy_doc_fields($source, &$target) {
  static $_uncopyable_fields;

  if (!isset($_uncopyable_fields)) {
    $_uncopyable_fields = array(
      'common' => array('id', 'type', 'metadata_id_s', 'metadata_type_s',
        'node_id_i', 'node_type_s', 'timestamp', 'serialized_tsn'),
      'work' => array(),
      'expression' => array(),
    );
  }

  $fields = $source->getFieldNames();
  foreach ($fields as $field_name) {
    // skip uncopiable fields
    if (in_array($field_name, $_uncopyable_fields['common'])
      || in_array($field_name, $_uncopyable_fields[$source->type])) {
      continue;
    }
    $values = $source->$field_name;
    // ensure that it is an array
    if (!is_array($values)) {
      $values = array($values);
    }
    foreach ($values as $value) {
      // if there is no such value
      if ((!is_array($target->$field_name) && ($target->$field_name != $value))
         || (is_array($target->$field_name) && !in_array($value, $target->$field_name))) {
        if ($field_name == 'text2') {
          $field_name = 'text';
        }
        $target->addField($field_name, $value);
      }
    }
  }
}

/**
 * Implementation of hook_xc_commit()
 */
function xc_solr_xc_commit($locations = array(), $params = array()) {
  global $_xc_solr_obj, $_xc_solr_batch_documents, $_xc_solr_batch_remove,
    $_oaiharvester_statistics;

  if (!isset($params['caller'])) {
    $params['caller'] = '';
  }

  xc_log_info('solr', 'xc_solr_xc_commit: ' . count($_xc_solr_batch_remove));

  if (!isset($_oaiharvester_statistics)) {
    $_oaiharvester_statistics = variable_get('oaiharvester_statistics', array());
  }

  $t_commit = microtime(TRUE);

  // TODO: it is not clear. The only call of this function is without any parameter
  $solr_servers = array();
  if (!empty($locations)) {
    $solr_servers = xc_solr_locations2solrs($locations);
  }
  else {
    $solr_servers = empty($params['solr servers'])
      ? $_xc_solr_obj
      : $params['solr servers'];
  }

  foreach ($solr_servers as $i => $solr_record) {
    if ($solr_record instanceof stdClass && !empty($solr_record->sid)) {
      $solr_servers[$i] = $_xc_solr_obj[$solr_record->sid];
    }
  }

  // delete documents
  if (count($_xc_solr_batch_remove) > 0) {
    xc_log_info('xc_solr', 'commit->batch_remove for ' . count($_xc_solr_batch_remove) . ' docs');
    $obj = NULL;
    xc_solr_xc_remove($obj, $locations, array('do_check_size' => FALSE, 'solr servers' => $solr_servers));
  }

  // insert documents
  if (count($_xc_solr_batch_documents) > 0) {
    xc_log_info('xc_solr', 'commit->batch_index for ' . count($_xc_solr_batch_documents) . ' docs');
    _xc_solr_batch_index(FALSE, $solr_servers, $params['caller']);
  }

  foreach ($solr_servers as $solr) {
    $response = $solr->commit();
    xc_log_info('xc_solr', t('Index changes committed in %ms ms at %url.',
      array('%ms' => $response->responseHeader->QTime, '%url' => $solr->getUrl())));
    xc_oaiharvester_statistics_set($params['caller'] . '/commit (total)/commit (Solr)', ($response->responseHeader->QTime / 1000));

    // cleanups
    if ($response instanceof Apache_Solr_ResponseXc) {
      $response->__destruct();
      unset($response);
    }
  }
  xc_oaiharvester_statistics_set($params['caller'] . '/commit (total)', abs(microtime(TRUE) - $t_commit));

  // TODO: if hook_xc_commit() changes probably we should change it
  variable_set('oaiharvester_statistics', $_oaiharvester_statistics);
} // xc_solr_xc_commit

/**
 * Implementation of hook_xc_optimize()
 */
function xc_solr_xc_optimize($locations = array(), $params = array()) {
  global $_xc_solr_obj;
  set_time_limit(0);

  xc_log_info('solr', 'Start optimizing');

  if (!empty($locations)) {
    $solr_servers = xc_solr_locations2solrs($locations);
  }
  else {
    $solr_servers = empty($params['solr servers'])
      ? xc_solr_get_servers()
     : $params['solr servers'];
  }

  foreach ($solr_servers as $solr) {
    if ($solr instanceof Apache_Solr_ServiceXc) {
      $response = $solr->commit();
      $response = $solr->optimize();
    }
    else {
      $response = $_xc_solr_obj[$solr->sid]->commit();
      $response = $_xc_solr_obj[$solr->sid]->optimize();
    }

    // cleanups
    if ($response instanceof Apache_Solr_ResponseXc) {
      $response->__destruct();
      xc_log_info('xc_solr', t('Index optimized in %time',
        array('%time' => xc_util_millisec_to_time($response->responseHeader->QTime))));
      unset($response);
    }
  }
}

/**
 * Get the Solr suffixes for a schema field name.
 *
 * @param $field (String)
 *   The schema field name
 * @param $is_strict (Boolean)
 *   Set strict mode, meaning that only those fields will have suffix, which are
 *   registered in a schema.
 *
 * @return (Array)
 *   List of suffixes
 */
function xc_solr_get_type_suffixes($field, $is_strict = FALSE) {
  static $known_field_problems, $suffixes;

  if ($field == 'id') {
    return array();
  }

  if (!isset($known_field_problems)) {
    $known_field_problems = array('dcterms:HasFormat',
      'rdvocab:dissertationOrThesisInformation', 'rdvocab:illustrationContent',
      'rdvocab:natureOfContent', 'rdvocab:titleOfExpression', 'rdvocab:titleOfWork',
      'xc:spacial', 'xc:titleOfExpression');
  }

  if (!isset($suffixes)) {
    $suffixes = module_exists('xc_index')
      ? xc_index_field_type_get_field_types_noid()
      : array();
  }

  if (!isset($suffixes[$field])) {
    if (!in_array($field, $known_field_problems)) {
      $msg = t('%field is not mapped to any type', array('%field' => $field));
      xc_log_info('xc solr', $msg);
      $known_field_problems[] = $field;
    }
    $suffixes[$field] = array();
  }

  if ($suffixes[$field] == array('n/a')) {
    $suffixes[$field] = array();
  }

  return $suffixes[$field];
}

/**
 * Get the fieldnames to index
 *
 * @param $type (String)
 *   The type of list to retrieve. Possible values 'structured' (a complex structured array)
 *   or 'simple' (a simple list of Solr field names).
 *
 * @return (Array)
 *   List of field names to index
 */
function xc_solr_fields2index_list($type = 'structured') {
  static $known_field_problems, $list;

  if ($type != 'structured' && $type != 'simple') {
    return array();
  }

  if (!isset($known_field_problems)) {
    $known_field_problems = array('dcterms:HasFormat',
      'rdvocab:dissertationOrThesisInformation', 'rdvocab:illustrationContent',
      'rdvocab:natureOfContent', 'rdvocab:titleOfExpression', 'rdvocab:titleOfWork',
      'xc:spacial', 'xc:titleOfExpression');
  }

  if (!isset($list)) {
    $stored_list = variable_get('xc_solr_fields2index_list', NULL);
    if (!is_null($stored_list)) {
      $list = $stored_list;
    }
    else {
      $no_data = array('n/a');
      $all_solr_fields = array();
      $indexes = module_exists('xc_index') ? xc_index_field_type_get_field_types_noid() : array();

      foreach ($indexes as $solr_base_field => $suffixes) {

        if ($suffixes == $no_data) {
          continue;
        }

        $solr_fields = array();
        $solr_date_fields = array();
        foreach ($suffixes as $suffix) {
          if ($suffix != 'n/a') {
            $all_solr_fields[] = xc_solr_get_solr_field_name($solr_base_field, $suffix);
            if ($suffix == '_dt') {
              $solr_date_fields[] = xc_solr_get_solr_field_name($solr_base_field, $suffix);
            }
            else {
              $solr_fields[] = xc_solr_get_solr_field_name($solr_base_field, $suffix);
            }
          }
        }

        $parts = explode('_', $solr_base_field);
        $field = $parts[0];
        $attribute = (isset($parts[1])) ? $parts[1] : '';
        if (empty($attribute)) {
          if (!empty($solr_fields)) {
            $structured_fields[$field]['general_fields'] = $solr_fields;
          }
          if (!empty($solr_date_fields)) {
            $structured_fields[$field]['date_fields'] = $solr_date_fields;
          }
        }
        else {
          $sql = "SELECT * FROM {xc_index_attribute_to_field}
                  WHERE solr_field = '".$solr_base_field."'
                  OR solr_field = '" . $field . "_xxxxxx'";
          $result = db_query($sql);
          $values = array();
          //while ($data = db_fetch_object($result)) {
          foreach ($result as $data) {
            if (preg_match('/^xsi:(.*)$/', $data->attribute, $matches)) {
              $data->attribute = $matches[1];
            }
            // TODO: handle date fields
            switch ($data->type) {
              case 'value_as_key':
              case 'as_key_exclusively':
                $structured_fields[$field][$data->type][$data->attribute]['values'][$attribute] = $solr_fields;
                break;
              case 'value_as_value':
                $structured_fields[$field][$data->type]['@' . $data->attribute] = $solr_fields;
                break;
            }
          }
        } // attributes
      } // foreach

      // get non conditional facets
      $facet_map = !module_exists('xc_index') ? array() : xc_index_get_all_facets_group_by_field(-1);
      foreach ($facet_map as $field => $facets) {
        foreach ($facets as $facet) {
          $key = 'facets';
          if ($facet['type'] == '_df') {
            $key = 'date_' . $key;
          }
          if ($facet['is_conditional'] == 1) {
            $key = 'conditional_' . $key;
          }
          $solr_name = $facet['name'] . $facet['type'];
          $structured_fields[$field][$key][] = $solr_name;
          if (!in_array($solr_name, $all_solr_fields)) {
            $all_solr_fields[] = $solr_name;
          }
        }
      }
      $list = array(
        'simple' => $all_solr_fields,
        'structured' => $structured_fields,
      );
      variable_set('xc_solr_fields2index_list', $list);
    }
  }

  return $list[$type];
}

function xc_solr_process_field_attribute($field, $attribute, $value, $debug = FALSE) {
  global $_oaiharvester_statistics;
  static $attributes, $field_type_alias_cache;
  if (!isset($attributes)) {
    // TODO: remove this line if the attributes will contain the namespace
    $do_namespace_hack = TRUE;
    $attributes = module_exists('xc_index')
      ? xc_index_attribute_get_attributes($do_namespace_hack) : array();
  }

  if (strpos($attribute, '@') === 0) {
    $attribute = drupal_substr($attribute, 1);
  }

  if (!isset($field_type_alias_cache)) {
    $field_type_alias_cache = array();
  }

  if (!isset($field_type_alias_cache['#IGNORED'][$field])) {
    if (!isset($attributes[$field])) {
      $field_type_alias_cache['#IGNORED'][$field] = TRUE;
    }
  }

  if (isset($field_type_alias_cache['#IGNORED'][$field])) {
    return NULL;
  }

  $indexing_type = $attributes[$field][$attribute]['type'];
  switch ($indexing_type) {
    case 'value_as_value':
      if (!isset($field_type_alias_cache[$field])
          || !isset($field_type_alias_cache[$field][$attribute])) {
        $_oaiharvester_statistics['toSolr/xc_solr_process_field_attribute/' . $indexing_type . '#']++;
        $fields = array(
          'value_as_key' => array(),
          'value_as_value' => array(),
          'as_key_exclusively' => array()
        );
        if (isset($attributes[$field][$attribute])) {
          $alias = $attributes[$field][$attribute];
          foreach (xc_solr_get_type_suffixes($alias['field']) as $suffix) {
            $fields[$indexing_type][] = xc_solr_get_solr_field_name($alias['field'], $suffix);
          }
          $fields['value_as_key'] = array_merge_recursive(
            $fields['value_as_key'],
            xc_solr_get_facet_aliases($alias['field'])
          );
        }
        else {
          drupal_set_message(t('%field, %type', array('%field' => $field, '%type' => $attribute)));
        }
        $field_type_alias_cache[$field][$attribute] = $fields;
      }
      $return = $field_type_alias_cache[$field][$attribute];
      break;

    case 'value_as_key':
    case 'as_key_exclusively':
      if (!isset($field_type_alias_cache[$field]) ||
         !isset($field_type_alias_cache[$field][$attribute]) ||
         !isset($field_type_alias_cache[$field][$attribute][$value])) {
        $_oaiharvester_statistics['toSolr/xc_solr_process_field_attribute/' . $indexing_type . '#']++;

        $fields = array(
          'value_as_key' => array(),
          'value_as_value' => array(),
          'as_key_exclusively' => array(),
        );
        if (isset($attributes[$field][$attribute])) {
          // get xc_index_field_type.type where field = $new_field
          if (!empty($value)) {
            $raw_field = $field . '_' . xc_util_remove_ns($value);
            $new_field = xc_solr_get_solr_field_name($raw_field);
            foreach (xc_solr_get_type_suffixes($raw_field) as $suffix) {
              $fields[$indexing_type][] = $new_field . $suffix;
            }
            $fields[$indexing_type] = array_merge_recursive(
              $fields['value_as_key'],
              xc_solr_get_facet_aliases($alias['field'])
            );
          }
        }
        else {
          drupal_set_message(t('%field, %type', array('%field' => $field, '%type' => $attribute)));
        }
        $field_type_alias_cache[$field][$attribute][$value] = $fields;
      }
      $return = $field_type_alias_cache[$field][$attribute][$value];
      break;
  }

  if ($debug) {

  }
  return $return;
}

/**
 * Get the facets belonging to this field
 *
 * @param $field (string)
 *   The schema field name
 *
 * @return (Array of assoc array)
 *   The list of facets. Each facet is an associative array, where the '#name'
 *   contains the name of the facet, and '#type' contains the type ('facet' or
 *   'date_facet').
 */
function xc_solr_get_facet_aliases($field) {
  global $_oaiharvester_statistics;
  static $cache, $facet_map;
  $_oaiharvester_statistics['toSolr/xc_solr_get_facet_aliases#']++;
  if (!isset($cache)) {
    $cache = array();
  }

  if (!isset($facet_map)) {
    $_oaiharvester_statistics['toSolr/xc_solr_get_facet_aliases/get fields#']++;
    $t = microtime(TRUE);
    $facet_map = !module_exists('xc_index') ? array() : xc_index_get_all_facets_group_by_field(0);
    $t2 = microtime(TRUE);
    xc_oaiharvester_statistics_set('toSolr/xc_solr_get_facet_aliases/get fields', ($t2 - $t));
  }

  if (!isset($cache[$field])) {
    $t = microtime(TRUE);
    $fields = array();
    if (isset($facet_map[$field])) {
      foreach ($facet_map[$field] as $facet_alias) {
        $solr_field = xc_solr_get_solr_field_name($facet_alias['name']);
        if ($facet_alias['type'] == '_df') {
          $solr_field .= '_df'; // date facet
          $type = 'date_facet';
        }
        else {
          $solr_field .= '_fc';
          $type = 'facet';
        }
        $fields[] = array('#name' => $solr_field, '#type' => $type);
      }
    }
    $cache[$field] = $fields;
    $t2 = microtime(TRUE);
    xc_oaiharvester_statistics_set('toSolr/xc_solr_get_facet_aliases/set cache', ($t2 - $t));
    $_oaiharvester_statistics['toSolr/xc_solr_get_facet_aliases/set cache#']++;
  }
  return $cache[$field];
}

// TODO: revision this function. It is a little outdated, and used no more
function xc_solr_add_conditional_facets(&$document) {
  static $facets;
  if (!isset($facets)) {
    include_once drupal_get_path('module', 'xc_index') . '/xc_index_facet.inc';
    $facets = xc_index_facet_list_conditionals();
  }
  foreach ($facets as $facet) {
    // $name = $facet->name;
    $fn = $facet->fn;
    $values = $fn($document);
    if (!empty($values)) {
      $field = $facet->name . $facet->type;
      foreach ($values as $value) {
        if ($field == 'type_of_content') {
          xc_log_info('conditional', $field . ' -> ' . $value);
        }
        $document->addField($field, $value);
      }
    }
  }
}

/**
 * Translate Solr field name to schema field name. The schema name consist of
 * namespace + ':' + fieldname. The Solr name consist of namespace + '__' + field
 * name + suffix, where siffux is '_' + one or more characters.
 * @param $solr_fieldname
 * @return unknown_type
 */
function xc_solr_solr2schema($solr_fieldname) {
  $suffix_regex = xc_solr_field_type_get_regex();

  $schema_fieldname = preg_replace($suffix_regex, "", $solr_fieldname, 1, $count);
  if ($count > 0) {
    $schema_fieldname = str_replace('__', ':', $schema_fieldname);
  }
  return $schema_fieldname;
}

/**
 * Translate schema field name to Solr field names (there can be multiple,
 * if you choose to index as multiple types). The schema name consist of
 * namespace + ':' + fieldname. The Solr name consist of namespace + '__' + field
 * name + suffix, where siffux is '_' + one or more characters.
 *
 * @param $schema_fieldname (String)
 *   The Solr field name
 * @param $only_first (Boolean, default: FALSE)
 *   If TRUE return only the first schema field name
 * @param $field_label (String)
 *   The label of a Solr field type (like: sortable integer, phrase, text, boolean,
 *   date, string facet, date facet....)
 *
 * @return (Array/String)
 *   the list of schema field name, or the first one (if $only_first id TRUE)
 */
function xc_solr_schema2solr($schema_fieldname, $only_first = FALSE, $field_label = FALSE) {
  static $cache;
  if (!isset($cache)) {
    $cache = array();
  }

  if (!isset($cache[$schema_fieldname])) {
    if (preg_match('/^(.*)\|@(.*)=(.*)$/', $schema_fieldname, $matches)) {
      $schema_fieldname = $matches[1] . '_' . $matches[3];
    }

    $solr_fields = array();
    $suffixes = array_unique(xc_solr_get_type_suffixes($schema_fieldname));
    $has_suffix = FALSE;
    if (is_string($field_label)) {
      require_once 'xc_solr_field_type.inc';
      $solr_type = xc_solr_field_type_by_label($field_label);
      if (in_array($solr_type->suffix, $suffixes)) {
        $has_suffix = TRUE;
        $solr_fields[] = xc_solr_get_solr_field_name($schema_fieldname, $solr_type->suffix);
      }
    }
    if (!$has_suffix) {
      if ((empty($suffixes) || $suffixes[0] == 'n/a') && strstr($schema_fieldname, ':')) {
        array_unshift($suffixes, '_t');
      }
      foreach ($suffixes as $suffix) {
        if ($suffix != 'n/a') {
          $solr_fields[] = xc_solr_get_solr_field_name($schema_fieldname, $suffix);
        }
      }
    }
    $cache[$schema_fieldname] = $solr_fields;
  }
  $solr_fields = $cache[$schema_fieldname];

  if ($only_first == TRUE) {
    return $solr_fields[0];
  }
  return $solr_fields;
}

/**
 * Transform Solr formatted date from original date
 *
 * @param $orig_value (String)
 *   The original date value
 * @param $orig_field (String)
 *   The original name of the date field (used only for logging)
 *
 * @return (String)
 *   The correctly formatted date
 */
function xc_solr_to_date($orig_value, $orig_field, $doc_id) {
  global $_xc_util_months, $_oaiharvester_statistics;
  static $skippable_values = array(
    '[n.d.]', 'n.d.]', 'n.d.', 'nd.]', '[n. d.]', '[n. d.].', '[n.d.] .',
    '[n.d.].', '[n.d]', '[n.d].', 'n. d.', 'n. d.]', 'n.d.].', 'n.d]', '[N.d.]',
    's.n.,', 's.d.]', '1uuu-', '-'
  );

  /* other values:
   'MDCC.', 'In the yere of our Lorde God. M.CCCCC.XLIX. The .IX. daye of Marche.', 'M DC XCI.', 'M.ccccc.xlix.',
   'M. D. XCI.', 'MDCXCVIII.' 'MDCLXXXVII.', 'M.DC.XXI.]', 'M.DC.XXVIII.', 'M.DC.LXXII.', 'Anno M.DC.XVIII.', 'M.DCC.XCVII.',
   'M.D.XXXII.',
   'Decimo septimo Ka. Aprilis. M.D.XXVII. Nostre Salutis Anno.'
   */

  $t = microtime(TRUE);

  static $months_pn, $date_cache;
  if (!isset($months_pn)) {
    $months_pn = join('|', $_xc_util_months);
  }
  if (!isset($date_cache)) {
    $date_cache = array();
  }
  if (!isset($date_cache[$orig_value])) {
    $value = trim(strtolower($orig_value));
    if (in_array($orig_value, $skippable_values)) {
      $value = '';
    }
    elseif ($value != '') {
      $value = preg_replace('/sh..?.?wa \d\d? /', '', $value);
      $value = preg_replace_callback("/($months_pn) (\d\d?), (.*)$/", 'xc_solr_month_replacement', $value, -1, $count);
      if ($count == 0) {
        $value = preg_replace('/\D/', '', $value);
        $value = preg_replace('/^(\d{2})$/', '${1}00-01-01T00:00:00Z', $value);
        $value = preg_replace('/^(\d{3})$/', '${1}0-01-01T00:00:00Z', $value);
        $value = preg_replace('/^(\d{4})\d*$/', '$1-01-01T00:00:00Z', $value);
        $value = preg_replace('/^(\d{4}-\d{2}-\d{2})$/', '${1}T00:00:00Z', $value);
        if (drupal_strlen($value) != 20) {
          xc_log_info('xc_solr date', sprintf('[bibid %s] %d/%s: "%s" -> "%s"', join(', ', $doc_id), drupal_strlen($value), $orig_field, $orig_value, $value));
          $value = '';
        }
      }
    }
    // TODO: improve this
    //xc_log_info('xc_solr', 'date: ' . $orig_value . ' => ' . $value);
    $date_cache[$orig_value] = $value;
  }
  // $t2 = ;
  xc_oaiharvester_statistics_set('03 step3/02 iterator/01 xc_solr_onestop_indexer/toSolr/07 date_facet/xc_solr_to_date', (microtime(TRUE) - $t));
  return $date_cache[$orig_value];
}

function xc_solr_month_replacement($matches) {
  global $_xc_util_months;

  $month = sprintf("%02d", array_search($matches[1], $_xc_util_months)+1);
  $day   = sprintf("%02d", $matches[2]);
  $value = preg_replace('/\D/', '', $matches[3]);
  $value = preg_replace('/^(\d{4})\d*$/', "$1-$month-${day}T00:00:00Z", $value);
  return $value;
}

function xc_solr_make_query($field, $value, $query_type = 'keyword') {
  if ($query_type == 'keyword') {
    $value = '(' . $value . ')';
  }
  elseif ($query_type == 'phrase') {
    $value = '"' . $value . '"';
  }
  elseif ($query_type == 'proximity') {
    $value = '"' . $value . '"~0.75';
  }
  elseif ($query_type == 'truncated') {
    $value = $value . '*';
  }
  if ($field == '') {
    return $value;
  }
  return $field . ':' . $value;
}

/**
 * Create an array of Apache_Solr_ServiceXc objects from array of location records
 *
 * @param $locations (Array)
 *   List of location records
 *
 * @return (Array)
 *   List of Apache_Solr_ServiceXc objects
 */
function xc_solr_locations2solrs($locations = array()) {
  static $cache = array();

  $key = serialize($locations);
  if (!isset($cache[$key])) {
    $solr_servers = array();
    if (is_array($locations)) {
      foreach ($locations as $location) {
        $solr_server = xc_solr_location2solr($location);
        if (!is_null($solr_server)) {
          $solr_servers[] = $solr_server;
        }
      }
    }
    $cache[$key] = $solr_servers;
  }
  return $cache[$key];
}

function xc_solr_location2solr($location) {
  global $_xc_solr_obj;
  static $cache = array();

  $key = serialize($location);
  if (!isset($cache[$key])) {
    $solr_server = NULL;
    if ($location->has_solr_type) {
      $solr_server = $_xc_solr_obj[xc_solr_get_sid($location->location_id)];
    }
    $cache[$key] = $solr_server;
  }
  return $cache[$key];
}

function xc_solr_proxy() {
  global $_xc_solr_obj;
  $output = drupal_get_form('xc_solr_proxy_form');
  $xc_solr_proxy_query = variable_get('xc_solr_proxy_query', '');
  if ($xc_solr_proxy_query != '') {
    foreach ($_xc_solr_obj as $solr) {
      $response = NULL;
      try {
        $response = $solr->sendRawGet(str_replace(array('"', ' '), array('%22', '%20'),
          $xc_solr_proxy_query), FALSE, FALSE);
      }
      catch (Exception $e) {
        drupal_set_message($e->getMessage(), 'error');
        xc_log_error('xc solr', $e->getMessage());
        continue;
      }
      $start = isset($response->responseHeader->params->start)
        ? $response->responseHeader->params->start + 1
        : $response->response->start + 1;
      $limit = isset($response->responseHeader->params->rows)
        ? $response->responseHeader->params->rows
        : count($response->response->docs);
      $total = $response->response->numFound;
      $time = $response->responseHeader->QTime / 1000;
      $output .= '<strong>'
        . t('%num records found in %time sec. Showing %start-%to:',
            array(
              '%num' => $total,
              '%start' => $start,
              '%to' => min(($start + $limit - 1), $total),
              '%time' => $time))
        . '</strong>';
      if ($total > 0) {
        foreach ($response->response->docs as $doc) {
          $output .= '<p>' . var_export($doc, TRUE) . '</p>';
        }
      }

      // cleanups
      if ($response instanceof Apache_Solr_ResponseXc) {
        $response->__destruct();
        unset($response);
      }
    }
  }

  return $output;
}

function xc_solr_proxy_form(&$from_state) {
  $xc_solr_proxy_query = variable_get('xc_solr_proxy_query', '');
  $form['query'] = array(
    '#type' => 'textarea',
    '#description' => t('Write your solr query here'),
    '#default_value' => $xc_solr_proxy_query,
  );
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Submit'),
  );

  return $form;
}

function xc_solr_proxy_form_submit($form, &$form_state) {
  variable_set('xc_solr_proxy_query', $form_state['values']['query']);
  return $form_state['values']['query'];
}

/**
 * Remove unnecessary characters from the end of string
 *
 * @param $value (String)
 *   The value to clean up
 *
 * @return (String)
 *   The cleaned value
 */
function _xc_solr_clean($value) {
  return preg_replace('/[ \.,;\\\\\/]+$/', '', $value);
}

function xc_solr_onestop_indexer_batch_finished($success = TRUE, $results = array(), $operations = array()) {
  global $_oaiharvester_statistics;

  drupal_set_message('xc_solr_onestop_indexer_batch_finished');
  if (is_null($_oaiharvester_statistics)) {
    $_oaiharvester_statistics = variable_get('oaiharvester_statistics', array());
  }
  $items = array();
  $total = $_oaiharvester_statistics['03 step3/02 iterator'] + $_oaiharvester_statistics['03 step3/01 SELECT metadata_id'];
  // TODO: remove this
  $number_of_records = 11679000;
  foreach ($_oaiharvester_statistics as $key => $value) {
    // $items[] = $key . ': ' . $value;
    $items[] = t('%key: %value1 || %value (%per%) - %rec ms/record', array(
      '%key' => $key, //preg_replace('/^\d+ /', '', $parts[count($parts)-1]),
      '%value1' => $value,
      '%value' => ($value > 60) ? oaiharvester_sec_to_time($value, TRUE) : sprintf("%01.3f", $value),
      '%per' => ($total == 0) ? 0 : sprintf("%01.3f", ($value / $total) * 100),
      '%rec' => sprintf("%01.3f", ($value * 1000 / $number_of_records)),
    ));
  }
  $stat = theme('item_list', array('items' => $items));
  xc_log_info('solr stat', 'Final result: ' . $stat);
  //drupal_set_message(var_export($results, TRUE));
  return $stat;
}

function xc_solr_onestop_indexer_batch_statistics() {
  global $_oaiharvester_statistics;
  if (is_null($_oaiharvester_statistics)) {
    $_oaiharvester_statistics = variable_get('oaiharvester_statistics', array());
  }
  drupal_add_css(drupal_get_path('module', 'xc_solr') . '/xc_solr.statistics.css');

  $items = array();
  $_oaiharvester_statistics['total'] = $_oaiharvester_statistics['03 step3'];
  if (!empty($_oaiharvester_statistics)) {
    ksort($_oaiharvester_statistics);
    $statistics = array();
    $subtotal = 0;
    $number_of_records = 2500000;
    foreach ($_oaiharvester_statistics as $key => $value) {
      $parts = explode('/', $key);
      $text = '';
      $c = count($parts);
      for ($i = 1; $i < $c; $i++) {
        $text .= ' &nbsp; ';
      }
      if (count($parts) == 1) {
        $subtotal = $value;
      }
      if (preg_match('/#$/', $key)) {
        $statistics[] = array(
          '<tt>' . $text . '</tt>'
          . preg_replace('/^\d+ /', '', $parts[count($parts)-1]) . ': ' . $value,
        );
      }
      else {
        $statistics[] = array(
          array(
            'data' => '<tt>' . $text . '</tt><span title="' . $key . '">' . preg_replace('/^\d+ /', '', $parts[count($parts)-1]) . '</span>',
            'class' => array('xc-left'),
          ),
          (($value > 60) ? oaiharvester_sec_to_time($value, TRUE) : sprintf("%01.3f", $value)),
          (($_oaiharvester_statistics['total'] == 0) ? 0 : sprintf("%01.3f", ($value / $_oaiharvester_statistics['total']) * 100)),
          (($subtotal == 0) ? 0 : sprintf("%01.3f", ($value / $subtotal) * 100)),
          sprintf("%01.3f", ($value * 1000 / $number_of_records))
        );
      }
    }
    $header = array(t('process'), t('total sec'), t('% of total'), t('% of part'), t('ms/record'));
    $output = theme('table', array('header' => $header, 'rows' => $statistics, 'attributes' => array('id' => 'xc-statistics'),
      'caption' => t('Statistics of harvesting @n records', array('@n' => $number_of_records))));
  }

  return $output;
}

function xc_solr_oaiharvester_batch_started($parameters) {
  $iteration_strategies = variable_get('xc_solr_iteration_strategies', array());
  $iteration_strategies[$parameters['saved_batch_id']] = $parameters['is_initial_harvest']
    ? XC_SOLR_PROCESS_ALL
    : XC_SOLR_PROCESS_CHANGES_ONLY;
  variable_set('xc_solr_iteration_strategies', $iteration_strategies);
}

/**
 * Iterates over the entities, and calls xc_solr_onestop_indexer()
 *
 * @see xc_solr_onestop_indexer
 *
 * @param $source_id (int)
 *   The identifier of source (see the XC Metadata module's xc_source table)
 * @param $locations (array)
 *   List of location objects (see XC Metadata module's xc_location table,
 *   and Storage locations at admin/xc/metadata/location)
 * @param $saved_batch_id (int)
 *   The identifier of the saved batch object (see oaiharvester_batch table)
 * @param $operation_id (int)
 *   The identifier of current operation
 * @param $context (array)
 *   Batch API's internal use container
 */
function xc_solr_onestop_indexer_batch($source_id, $locations = array(), $saved_batch_id = -1, $operation_id = -1, &$context = array()) {
  global $_oaiharvester_statistics, $_xc_solr_indexing_statistics;
  static $limit, $document_limit, $solrs, $sql;

  set_time_limit(0);
  require_once('xc_solr.index.inc');

  if (!isset($context['sandbox']['do_next'])) {
    $context['sandbox']['do_next'] = TRUE;
  }
  if ($context['sandbox']['do_next']) {
    if (!isset($context['sandbox']['phase'])) {
      $context['sandbox']['phase'] = XC_PHASE_PREPARATION;
    }
    else if ($context['sandbox']['phase'] == XC_PHASE_PREPARATION) {
      $context['sandbox']['phase'] = XC_PHASE_LOAD;
    }
    else if ($context['sandbox']['phase'] == XC_PHASE_LOAD) {
      $context['sandbox']['phase'] = XC_PHASE_NORMALIZATION;
    }
    $context['sandbox']['do_next'] = FALSE;
  }

  $memory_start = memory_get_usage(true);

  if (!isset($solrs)) {
    $context['sandbox']['function'] = 'xc_solr_onestop_indexer_batch';
    $context['sandbox']['limit'] = 1000;
    $document_limit = 200;
    $solrs = xc_solr_locations2solrs($locations);
  }

  $t0 = microtime(TRUE);
  $_oaiharvester_statistics = variable_get('oaiharvester_statistics', array());

  if ($context['sandbox']['phase'] == XC_PHASE_PREPARATION) {
    $saved_batch_status = xc_solr_onestop_indexer_batch_prepare($locations, $saved_batch_id, $context);
  }

  else if ($context['sandbox']['phase'] == XC_PHASE_LOAD) {
    $t0 = microtime(TRUE);
    if (!isset($context['sandbox']['start_time'])) {
      $context['sandbox']['start_time'] = microtime(TRUE);
    }
    $_xc_solr_indexing_statistics = variable_get('xc_solr_indexing_statistics', array('empty' => 0, 'metadata' => 0, 'success' => 0, 'entity' => 0));
    xc_oaiharvester_statistics_set('03 step3/00 preparation', (microtime(TRUE) - $t0));

    $offset = $context['sandbox']['offset'];
    $offset_id = $context['sandbox']['offset_id'];
    xc_log_info('reindex', sprintf('offset: %s (offset_id: %s) of %s', $offset, $offset_id, $context['sandbox']['max']));

    // prepare SQL
    if (!isset($sql)) {
      if ($context['sandbox']['iteration_strategy'] == XC_SOLR_PROCESS_ALL) {
        $sql = 'SELECT metadata_id FROM {xc_entity_properties}'
             . ' WHERE (metadata_id BETWEEN :offset_id AND :max_id)'
             . ' AND ' . $context['sandbox']['metadata_types_condition']
             . ' ORDER BY metadata_id'; // LIMIT %d'; // source_id = %d
      }
      elseif ($context['sandbox']['iteration_strategy'] == XC_SOLR_PROCESS_CHANGES_ONLY) {
        $sql = 'SELECT metadata_id FROM {xc_oaiharvester_bridge_changes}'
             . ' WHERE (metadata_id BETWEEN :offset_id AND :max_id) AND type != ' . XC_DELETED
             . ' ORDER BY metadata_id'; // LIMIT %d'; // source_id = %d
      }
    }

    // create JSON solr dump on request
    $save_params = (object)array();
    if ($context['sandbox']['solr_target'] == 'create_dump') {
      $upload_file_limit = 5000;
      $save_params->hasFirst = FALSE;
      $save_params->hasLast = FALSE;
      $save_params->asJSON = $context['sandbox']['asJSON'];
      if (!isset($context['sandbox']['upload']['file_counter'])) {
        $save_params->hasFirst = TRUE;
        $context['sandbox']['upload']['file_counter'] = 1;
      }
      if ($offset > ($context['sandbox']['upload']['file_counter'] * $upload_file_limit)) {
        $save_params->hasLast = TRUE;
      }
    }

    // the main work
    $do_next = TRUE;
    $progress = 0;
    $documents_added = 0;
    while ($do_next) {
      $t_query = microtime(TRUE);
      $max_id = $offset_id + (3 * $context['sandbox']['limit']);
      // xc_log_info('onestop', xc_util_get_sql($sql, $offset_id, $max_id));
      $result = db_query($sql, array(':offset_id' => $offset_id, ':max_id' => $max_id)); // $limit, $source_id,
      $t_query1 = microtime(TRUE);
      xc_oaiharvester_statistics_set('03 step3/01 SELECT metadata_id', $t_query1 - $t_query);

      $documents = array();
      $doc_count = 0;
      foreach ($result as $data) {
        $progress++;
        $doc_count++;
        $t = microtime(TRUE);
        $documents[] = xc_solr_onestop_indexer($data->metadata_id, ($progress == 1)); // $locations
        $t2 = microtime(TRUE);
        xc_oaiharvester_statistics_set('03 step3/02 iterator/01 xc_solr_onestop_indexer', $t2 - $t);
        $current_id = $data->metadata_id;

        // send to Solr
        $t = microtime(TRUE);
        if ($doc_count == $document_limit) {
          // fire Solr
          $documents_added += xc_solr_onestop_indexer_batch_add_document($context, $solrs, $documents, $save_params);
          // reset values
          $doc_count = 0;
        }
        $t2 = microtime(TRUE);
        xc_oaiharvester_statistics_set('03 step3/02 iterator/02 send to solr', $t2 - $t);
      }

      // TODO: Is there leftovers?
      // check whether are there any more documents to index
      if (!empty($documents)) {
        $t = microtime(TRUE);
        $documents_added += xc_solr_onestop_indexer_batch_add_document($context, $solrs, $documents, $save_params);
        $doc_count = 0;
        $t2 = microtime(TRUE);
        xc_oaiharvester_statistics_set('03 step3/02 iterator/02 send to solr', $t2 - $t);
      }

      $t_iterator = microtime(TRUE);
      xc_oaiharvester_statistics_set('03 step3/02 iterator', $t_iterator - $t_query1);

      // run again?
      $do_next = (($progress + $context['sandbox']['offset']) < $context['sandbox']['max'] && $progress < $context['sandbox']['limit']);

      // Inclement offset. It grows without fail than the last value.
      $offset_id = $max_id + 1;
    } // end of while cycle

    // check whether are there any more documents to index
    if (!empty($documents)) {
      $documents_added += xc_solr_onestop_indexer_batch_add_document($context, $solrs, $documents, $save_params);
    }

    // save variables to sandbox
    $context['sandbox']['documents_added'] += $documents_added;
    $context['sandbox']['offset'] += $progress;
    $context['sandbox']['offset_id'] = $offset_id;
    xc_log_info('onestop', sprintf('Manifestation processed: %d, documents added: %d', $context['sandbox']['offset'], $context['sandbox']['documents_added']));

    // create message for the batch UI
    xc_solr_onestop_indexer_update_context_message($context, $_oaiharvester_statistics['03 step3/00 preparation']);

    // load saved batch and schedule objects
    if ($saved_batch_id != -1) {
      $saved_batch = oaiharvester_saved_batch_load($saved_batch_id);
      $schedule = oaiharvester_schedule_load($saved_batch->schedule_id, TRUE);
    }

    // check whether are there any more records to index
    if ($context['sandbox']['offset'] < $context['sandbox']['max']) {
      $context['finished'] = ($context['sandbox']['offset'] / ($context['sandbox']['max'] * 1.05));
      if (isset($saved_batch)) {
        $saved_batch_status = 'SOLR_INDEXING_IN_PROGRESS';
      }
    }
    else {
      $context['finished'] = (1 / 1.05);
      $context['sandbox']['do_next'] = TRUE;
      // close file
      if ($context['sandbox']['solr_target'] == 'create_dump') {
        $save_params->hasLast = TRUE;
        xc_solr_save_documents($solrs, $documents, $context, $save_params);
      }
    }

    // cleanups
    foreach ($documents as $document) {
      unset($document);
    }
  } // XC_PHASE_LOAD

  else if ($context['sandbox']['phase'] == XC_PHASE_NORMALIZATION) {
    $saved_batch_status = xc_solr_onestop_indexer_batch_normalize($saved_batch_id, $operation_id, $solrs, $context);
  } // XC_PHASE_NORMALIZATION

  else {
    xc_log_info('xc_solr', 'Undefined sandbox phase: ' . $context['sandbox']['phase']);
  }

  if (isset($saved_batch)) {
    oaiharvester_saved_batch_update_status($saved_batch, $operation_id, $context['sandbox']['function'], $saved_batch_status, $context);
  }

  // this way, the total time is always actualized
  $t_end = microtime(TRUE);
  $_oaiharvester_statistics['03 step3'] = ($t_end - $context['sandbox']['start_time']);

  // save variables
  variable_set('oaiharvester_statistics', $_oaiharvester_statistics);
  variable_set('xc_solr_indexing_statistics', $_xc_solr_indexing_statistics);
  xc_log_info('memorydiff', xc_util_byte_to_kilo(memory_get_usage(true) - $memory_start));
  xc_log_info('memorycons', xc_util_byte_to_kilo(memory_get_usage(true)));
}

function xc_solr_onestop_indexer_batch_normalize($saved_batch_id = -1, $operation_id, $solrs, &$context) {
  global $_xc_solr_indexing_statistics;

  $context['message'] = t('Optimizing Solr index...');

  if ($saved_batch_id != -1) {
    $saved_batch = oaiharvester_saved_batch_load($saved_batch_id);
    // update saved batch status
    if (isset($saved_batch) && $saved_batch !== FALSE) {
      oaiharvester_saved_batch_update_status($saved_batch, $operation_id, $context['sandbox']['function'], 'SOLR_INDEXING_FINISHED', $context);
    }
  }

  // update Solr
  foreach ($solrs as $solr) {
    try {
      // TODO: put this into a last round, that the message at batch process be refreshed
      xc_log_info('reindex', t('Solr: Committing changes'));
      $tc1 = microtime(TRUE);
      $solr->commit();
      $tc2 = microtime(TRUE);
      xc_log_info('reindex', t('Solr: Changes committed'));
      xc_oaiharvester_statistics_set('03 step3/03 commit', ($tc2 - $tc1));
      xc_log_info('reindex', t('Solr: Optimizing index'));
      $solr->optimize();
      $tc3 = microtime(TRUE);
      xc_log_info('reindex', t('Solr: Index optimized'));
      xc_oaiharvester_statistics_set('03 step3/04 optimize', ($tc3 - $tc2));
    }
    catch (Exception $e) {
      xc_log_error('xc_solr', $e->getMessage());
    }
  }
  $saved_batch_status = 'FINISHED';

  $context['finished'] = 1.0;
  if ($saved_batch_id != -1) {
    // save the _xc_solr_indexing_statistics
    if (isset($saved_batch)) {
      $saved_report = unserialize($saved_batch->reports);
      $saved_report['xc_solr']['indexing_statistics'] = $_xc_solr_indexing_statistics;
      $saved_batch->reports = serialize($saved_report);
      $ret = drupal_write_record('oaiharvester_batch', $saved_batch, 'id');
    }
    xc_solr_onestop_indexer_batch_finished();
    $context['results']['statistics'] = $_xc_solr_indexing_statistics;
    xc_log_info('solr', 'xc solr indexing statistics: ' . var_export($_xc_solr_indexing_statistics, TRUE));
  }

  return $saved_batch_status;
}

function xc_solr_onestop_indexer_batch_add_document(&$context, &$solrs, &$documents, $save_params) {
  if ($context['sandbox']['solr_target'] == 'index') {
    $documents_added = xc_solr_add_documents($solrs, $documents);
  }
  else if ($context['sandbox']['solr_target'] == 'create_dump') {
    xc_solr_save_documents($solrs, $documents, $context, $save_params);
  }
  else {
    xc_log_error('solr', 'Unhandled solr_target parameter: ' . $context['sandbox']['solr_target']);
  }

  // cleanups
  foreach ($documents as $document) {
    unset($document);
  }

  $documents = array();
  return $documents_added;
}

/**
 * Add documents to Solr index(es)
 *
 * @param $solrs (Array)
 *   List of Apache_Solr_ServiceXc objects
 * @param $documents (Array)
 *   List of Apache_Solr_DocumentXc objects
 *
 * @return (int)
 *   The number of documents added to Solr
 */
function xc_solr_add_documents(&$solrs, $documents) {
  static $asJSON;

  $documents_added = 0;
  if (empty($documents)) {
    xc_log_error('solr', 'There is no document to add with xc_solr_add_documents.');
    return $documents_added;
  }

  if (!isset($asJSON)) {
    $asJSON = variable_get('xc_solr_index_as_json', 1);
  }

  // There is a trick here. We use Drupal variable to store Solr version number.
  // This way we ask Solr only once to check the version number - otherwise it requires
  // lots of times, which is unnecessary, and each request takes more than one sec.
  // At the start of Solr index batch we remove
  // this variable, so we refresh it here (only once in an indexing session), to be sure,
  // that we use the right version. The Solr version is necessary, because different
  // Solr versions support or not support JSON update differently.
  $xc_solr_version_numbers = variable_get('xc_solr_version_numbers', array());
  $need_save_version_numbers = empty($xc_solr_version_numbers);
  $params = (object)array(
    'hasFirst' => TRUE,
    'hasLast' => TRUE,
    'asJSON' => $asJSON,
  );

  foreach ($solrs as $solr) {
    if (!isset($xc_solr_version_numbers[$solr->getUrl()])) {
      $version = $solr->getSolrVersionNumber();
      $xc_solr_version_numbers[$solr->getUrl()] = $version;
    }
    if (!$solr->hasSolrVersionNumber()) {
      $solr->setSolrVersionNumber($xc_solr_version_numbers[$solr->getUrl()]);
    }

    try {
      $response = $solr->addDocuments($documents, FALSE, TRUE, TRUE, $params);
      if ($response->getHttpStatus() != 200) {
        xc_log_error('solr json', 'addDocuments response: ' . var_export($response, TRUE));
      }
      else {
        $documents_added = count($documents);
      }
    }
    catch (Exception $e) {
      $document_count = count($documents);
      xc_log_warning('xc_solr', $e->getMessage() . ' Failed documents to add: '
        . $documents[0]->metadata_id_s[0] . '-' . $documents[$document_count - 1]->metadata_id_s[0]);
      for ($i = 0, $c = count($documents); $i < $c; $i++) {
        $document = $documents[$i];
        try {
          $response = $solr->addDocument($document);
          if ($response->getHttpStatus() != 200) {
            xc_log_error('solr', 'addDocuments response: ' . var_export($response, TRUE)
              . ' for document #' . $document->metadata_id_s);
          }
          else {
            $documents_added++;
          }
          unset($document);
        }
        catch (Exception $e) {
          unset($document);
          xc_log_error('xc_solr', $e->getMessage() .' Failed doc to add: ' . var_export($document, TRUE));
        }
      }
    }
  }
  // cleanups
  foreach ($documents as $document) {
    unset($document);
  }

  if ($need_save_version_numbers) {
    variable_set('xc_solr_version_numbers', $xc_solr_version_numbers);
  }

  return $documents_added;
}

/**
 * Add documents to Solr index(es)
 *
 * @param $solrs (Array)
 *   List of Apache_Solr_ServiceXc objects
 * @param $documents (Array)
 *   List of Apache_Solr_DocumentXc objects
 */
function xc_solr_save_documents(&$solrs, $documents, &$context, &$params) {
  static $asJSON;

  $file = xc_solr_create_input_cache_file_name($context);

  if (empty($documents)) {
    xc_log_error('solr', 'There is no document to add with xc_solr_add_documents.');
  }

  if (!isset($asJSON)) {
    $asJSON = variable_get('xc_solr_index_as_json', 1);
  }

  // There is a trick here. We use Drupal variable to store Solr version number.
  // This way we ask Solr only once to check the version number - otherwise it requires
  // lots of times, which is unnecessary, and each request takes more than one sec.
  // At the start of Solr index batch we remove
  // this variable, so we refresh it here (only once in an indexing session), to be sure,
  // that we use the right version. The Solr version is necessary, because different
  // Solr versions support or not support JSON update differently.
  $xc_solr_version_numbers = variable_get('xc_solr_version_numbers', array());
  $need_save_version_numbers = empty($xc_solr_version_numbers);

  $solr = $solrs[0];
  if (!isset($xc_solr_version_numbers[$solr->getUrl()])) {
    $version = $solr->getSolrVersionNumber();
    $xc_solr_version_numbers[$solr->getUrl()] = $version;
  }
  if (!$solr->hasSolrVersionNumber()) {
    $solr->setSolrVersionNumber($xc_solr_version_numbers[$solr->getUrl()]);
  }

  $content_to_save = $solr->createAddDocumentsContent($documents, FALSE, TRUE, TRUE, $params);
  if ($params->hasFirst) {
    xc_log_info('solr save', sprintf('Start writing to %s', $file));
    file_put_contents($file, $content_to_save);
  }
  else {
    file_put_contents($file, $content_to_save, FILE_APPEND);
  }

  if ($need_save_version_numbers) {
    variable_set('xc_solr_version_numbers', $xc_solr_version_numbers);
  }

  if ($params->hasLast) {
    $params->hasLast = FALSE;
    $params->hasFirst = TRUE;
    $context['sandbox']['upload']['file_counter']++;
  }
  elseif ($params->hasFirst) {
    $params->hasFirst = FALSE;
  }
}

/**
 * Implementation of hook_init()
 */
function xc_solr_init() {
  global $_xc_solr_obj;

  // Get the servers
  $_xc_solr_obj = array();
  $service_type = variable_get('xc_solr_service_type', XC_SOLR_SERVICE_DRUPAL);
  foreach (xc_solr_get_servers() as $solr) {
    switch ($service_type) {
      case XC_SOLR_SERVICE_DRUPAL:
        $_xc_solr_obj[$solr->sid] = new Drupal_Apache_Solr_ServiceXc($solr->host, $solr->port, $solr->path);
        break;
      case XC_SOLR_SERVICE_DEFAULT:
      default:
        $_xc_solr_obj[$solr->sid] = new Apache_Solr_ServiceXc($solr->host, $solr->port, $solr->path);
        break;
    }
  }
}

/**
 * Return the properties of a Solr server
 *
 * @param $id
 *   The sid of the server
 *
 * @return stdClass
 *   The server
 */
function xc_solr_server_load($sid, $update = FALSE) {
  $get_type = gettype($sid);
  $temp_sid = '';
  if ($get_type == 'string') {
    $temp_sid = $sid;
  }
  else {
    $temp_sid = $sid->sid;
  }

  $sql = 'SELECT * from {xc_solr_servers} WHERE sid = :d';
  $result = db_query($sql, array(':d' => $temp_sid));
  $solr = $result->fetchObject();
  return $solr;

//  static $cache;
//  if (empty($cache[$sid]) || $update) {
//    $sql = 'SELECT * from {xc_solr_servers} WHERE sid = %d';
//    $result = db_query($sql, $sid);
//    $cache[$sid] = db_fetch_object($result);
//  }
//  return $cache[$sid];

}

/** COMMON functions, called from outside
 *  ------------------------------------- */

/**
 * Return an associative array from the suffixes and the labels of fields
 * @return assoc array The field types list
 */
function xc_solr_field_type_get_types() {
  $sql = 'SELECT * FROM {xc_solr_field_type}';
  $result = db_query($sql);
  $ret_val = array();
  //while ($data = db_fetch_object($result)) {
  foreach ($result as $data) {
    $ret_val[$data->suffix] = $data->label;
  }
  return $ret_val;
}

function xc_solr_field_type_get_all() {
  $sql = 'SELECT * FROM {xc_solr_field_type} ORDER BY weight';
  $result = db_query($sql);
  $ret_val = array();
  //while ($data = db_fetch_object($result)) {
  foreach ($result as $data) {
    $ret_val[$data->suffix] = $data;
  }
  return $ret_val;
}

/**
 * Create a regular expression from the actual suffixes.
 * The regex looks like this: /(_i|_s|_l|_t|_b|_f|_d|_dt|_fc|_df)$/
 * @return string The regex matching all field suffixes
 */
function xc_solr_field_type_get_regex() {
  static $suffix_regex;
  if (!isset($suffix_regex)) {
    // get suffixes
    $suffixes = array_keys(xc_solr_field_type_get_types());
    // buld regex from suffixes
    $suffix_regex = '/(' . join('|', $suffixes) . ')$/';
  }
  return $suffix_regex;
}

/** Functions used by solr_menu
 *  --------------------------- */

function xc_solr_field_type_load($xc_solr_field_type) {
  $sql = 'SELECT * FROM {xc_solr_field_type} WHERE type_id = :d';
  $result = db_query($sql, array(':d' => $xc_solr_field_type));
  $data = $result->fetchObject();
  return $data;
}

function xc_solr_field_type_title($record) {
  return t('@type field type', array('@type' => $record->label));
}

function xc_solr_get_nth_result($caller_module, $count_number) {
  global $_xc_search_server;
  $query         = $_SESSION['xc_search_query'][$caller_module]['query'];
  $params        = $_SESSION['xc_search_query'][$caller_module]['solr_params'];
  $rows_per_page = $_SESSION['xc_search_query'][$caller_module]['rows_per_page'];
  $total_results = $_SESSION['xc_search_query'][$caller_module]['total_results'];
  $search_page   = $_SESSION['xc_search_query'][$caller_module]['search_page'];

  $first = $count_number;
  $rows  = 1;
  unset($params['hl']);
  unset($params['hl.fl']);
  unset($params['hl.fragsize']);
  unset($params['hl.simple.pre']);
  unset($params['hl.simple.post']);
  unset($params['hl.snippets']);
  $params += array(
    'fl' => 'dcterms__title_t,node_id_i',
    'XCNAME' => 'get_nth_result'
  );
  try {
    $response = $_xc_search_server->search($query, $first, $rows, $params, FALSE);
  }
  catch (Exception $e) {
    xc_log_error('navig_block', 'Query: ' . $query . ', params: ' . var_export($params, TRUE) . ', exception: ' . var_export($e, TRUE));
    return;
  }

  $doc = $response->response->docs[0];
  return $doc->node_id_i;
}

function xc_solr_list_fields() {
  global $_xc_search_server;

  $params = array(
    'search_type' => 'luke',
    'ft' => 'type',
    'numTerms' => 0,
  );

  $response = $_xc_search_server->search(NULL, 0, 0, $params, TRUE);
  return array_keys(get_object_vars($response->fields));
}

function xc_solr_last_modified() {
  global $_xc_search_server;

  $params = array(
    'search_type' => 'luke',
    'ft' => 'type',
    'numTerms' => 0,
  );

  $response = $_xc_search_server->search(NULL, 0, 0, $params, TRUE);
  return $response->index->lastModified;
}
