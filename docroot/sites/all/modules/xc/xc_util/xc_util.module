<?php
/**
 * @file
 * A utility module, which contains functions usable in other XC modules
 *
 * @copyright (c) 2010-2011 eXtensible Catalog Organization
 */

/**
 * The table is not installed
 */
define('XC_UNINSTALLED', -1);

/**
 * The table is installed
 */
define('XC_INSTALLED', 0);

/**
 * The table is loaded with default values
 */
define('XC_LOADED', 1);

/**
 * Convert milliseconds to H:i:s.ms format
 *
 * @param $millisec (int)
 *   The number of milliseconds
 *
 * @return (String)
 *   The string format of duration
 */
function xc_util_millisec_to_time($millisec) {
  $sec = 0;
  if ($millisec >= 1000) {
    $sec = (int)($millisec / 1000);
    $millisec = $millisec % 1000;
  }
  return oaiharvester_sec_to_time($sec) . '.' . $millisec;
}

/**
 * Log a message in info level. A wrapper for watchdog().
 * @param $type The type of message
 * @param $message The message
 * @param $variables Valiable to fill placeholders in message
 * @return unknown_type
 */
function xc_log_info($type, $message, $variables = array()) {
  watchdog($type, $message, $variables, WATCHDOG_INFO, _get_file_position(1));
  error_log($message, 4);
}

/**
 * Log an error level message. A wrapper for watchdog().
 * @param $type The type of message
 * @param $message The message
 * @param $variables Valiable to fill placeholders in message
 * @return unknown_type
 */
function xc_log_error($type, $message, $variables = array()) {
  watchdog($type, $message, $variables, WATCHDOG_ERROR, _get_file_position(1));
}

function xc_log_warning($type, $message, $variables = array()) {
  watchdog($type, $message, $variables, WATCHDOG_WARNING, _get_file_position(1));
}

/**
 * Get the filename, line, and function of the caller or of one of the caller’s ancestors
 *
 * @param $index (int)
 *   The index of caller. The 0 is the primary calles, 1 is the caller’s caller etc.
 * @param $skip_time (boolean)
 *   If you set this to TRUE the return value will not contain time information.
 *   Default is FALSE, and it display time.
 *
 * @return String
 *   Composed of filename, line, and function name
 */
function _get_file_position($index = 0, $skip_time = FALSE) {
  $trace = debug_backtrace();

  if (!$skip_time) {
    list($msec, $sec) = explode(' ', microtime());
    $text = format_date($sec, 'custom', 'H:i:s') . '.' . drupal_substr($msec, 2, 3) . ' ';
  }
  else {
    $text = ' (';
  }
  $text .= sprintf('%s:%d (%s())', basename($trace[$index]["file"]), $trace[$index]["line"], $trace[$index+1]["function"]);
  return $text;
}

function xc_ajax_bootstrap($token = NULL) {
  if (is_null($token)) {
    return;
  }
  while (!@stat('./includes/bootstrap.inc')) {
    chdir('..');
  }
  require_once './includes/bootstrap.inc';
  require_once './includes/file.inc';
  drupal_bootstrap(DRUPAL_BOOTSTRAP_FULL);

  $uid = 0;
  $sql = 'SELECT uid FROM {sessions} WHERE session LIKE \'%:token%\'';
  $result = db_query($sql, array(':token' => $token));
  if ($data = $result->fetchAssoc()) {
    $uid = $data['uid'];
  }

  // load user id any
  user_load($uid);
}

/**
 * Utility function to display variables var_exported way.
 * @param $variable (mixed)
 *   The variable to show
 * @param $label (String)
 *   A label, to display before the variable
 * @param $do_nl2br (Boolean)
 *   Flag to show line breaks or not (default: FALSE)
 * @return unknown_type
 */
function xc_util_dsm($variable, $label = NULL, $do_nl2br = FALSE) {
  if (is_null($label)) {
    $label = '';
  }
  else {
    $label .= ': ';
  }
  $value = var_export($variable, TRUE);
  if ($do_nl2br) {
    $value = nl2br($value);
  }
  drupal_set_message($label . $value);
}

function xc_util_remove_ns($q_name) {
  return preg_replace('/^[^:]+:/', '', $q_name);
}

function xc_util_remove_spaces($text) {
  return str_replace(' ', '', $text);
}

/**
 * Space to underscore
 * @param $text
 * @return unknown_type
 */
function xc_util_space2underscore($text) {
  return str_replace(' ', '_', $text);
}

/**
 * Create stdClass records from CVS-style string. The string contains lines,
 * the first one is the list of fieldnames, the rest lines contain the values.
 * The fields are separated by ';' sign.
 * @param $raw_data CSV-style list of data. Each row represents a record.
 * The first row is the list of fieldnames. The fields are separated by ';'.
 * @return array of stdClass
 */
function xc_util_create_bulk_records($raw_data, $table = NULL) {
  $records = array();
  $rows = preg_split("\n", $raw_data);
  $is_first = TRUE;
  foreach ($rows as $row) {
    $row = trim($row);
    $fields = explode(";", $row);
    if ($is_first == TRUE) {
      $field_names = $fields;
      $is_first = FALSE;
      continue;
    }
    $record = new stdClass;
    $count = count($fields);
    for ($i = 0; $i < $count; $i++) {
      $record->$field_names[$i] = $fields[$i];
    }
    $records[] = $record;
  }
  return $records;
}

/**
 * Create a list of records (array of objects) from a CSV file.
 *
 * @param $filename (String)
 *   The filename of the CSV file. (Relative to the Drupal’s index.php)
 * @param $separator (String)
 *   The field separator. Default is ';'.
 * @params $field_names (Array)
 *   The array of field names
 * @params $do_filter_xss (Boolean)
 *   Whether or not check the content of fields against XSS hacks. (Default is TRUE).
 *
 * @return (Array)
 *   The array of record objects.
 */
function xc_util_csv2objects($filename, $separator = ';', $field_names = array(), $do_filter_xss = TRUE) {
  $records = array();
  if (!file_exists($filename)) {
    drupal_set_message(t('The CSV file (%name) does not exist', array('%name' => $filename)), 'error');
    return $records;
  }
  $does_first_line_contain_field_names = FALSE;
  if (empty($field_names)) {
    $does_first_line_contain_field_names = TRUE;
  }
  $handle = fopen($filename, "r");
  $is_first = TRUE;
  // str_getcsv
  while (($fields = fgetcsv($handle, 1000, $separator)) !== FALSE) {
    if ($is_first == TRUE) {
      $is_first = FALSE;
      if ($does_first_line_contain_field_names) {
        $field_names = $fields;
        continue;
      }
    }
    $record = new stdClass;
    $count = count($fields);
    for ($i=0; $i < $count; $i++) {
      $record->$field_names[$i] = $do_filter_xss ? filter_xss($fields[$i]) : $fields[$i];
    }
    $records[] = $record;
  }
  fclose($handle);
  return $records;
}

/**
 * Bulk insert into a table.
 * @param $table The name of the table to insert records into
 * @param $raw_data CSV-style list of data. Each row represents a record.
 * The first row is the list of fieldnames. The fields are separated by ';'.
 * @return unknown_type
 */
function xc_util_bulk_insert($table, $records) {
  set_time_limit(0);
  $i = 0;
  xc_log_info('xc util', 'Populating ' . $table);
  $schema = drupal_get_schema($table, TRUE);
  while (empty($schema)) {
    $msg = t('The table %table is inexistent even after 10 sec', array('%table' => $table));
    drupal_set_message($msg, 'error');

    if ($i >= 10) {
      xc_log_error('util', $msg);
      return;
    }
    usleep(1000);
    xc_log_info('xc_util', 'waiting for a while (' . $table . ')');
    $schema = drupal_get_schema($table, TRUE);
    $i++;
  }

  if (is_string($records)) {
    // xc_log_info('xc_search', 'xc_util_bulk_insert string: ' . $table);
    $records = xc_util_create_bulk_records($records, $table);
  }
  foreach ($records as $record) {
    $ret_val = drupal_write_record($table, $record);
    if ($ret_val == SAVED_NEW) {
      /*
       xc_log_info('xc util', 'Successfully created a new record in %table.',
       array('%table' => $table));
       */
    }
    else {
      drupal_set_message(t('Unexpected error. Failed to insert a new record in %table.',
        array('%table' => $table, '%error' => db_get)));
    }
  }
}

/**
 * Creates array of stdClass objects from XML dump created with phpMyAdmin
 * @param $filename The filename of the dump
 * @return unknown_type
 */
function xc_util_xmldump_to_records($filename) {
  xc_log_info('xc_search', 'importing xml dump: ' . $filename);
  $records = array();

  $dom = new DOMDocument();
  $dom->load($filename);
  $table = $dom->firstChild;
  if ($table->nodeType != XML_ELEMENT_NODE) {
    do {
      $table = $table->nextSibling;
    } while ($table->nodeType != XML_ELEMENT_NODE);
  }

  //$table = $dom->getElementsByTagName('drupal_test_merge')->item(0);
  $xmlRecords = $table->childNodes;
  $len = $xmlRecords->length;

  for ($i = 0; $i < $len; $i++) {
    $xmlRecord = $xmlRecords->item($i);
    if ($xmlRecord->nodeType == XML_ELEMENT_NODE) {
      $fields = $xmlRecord->childNodes;
      if (isset($fields)) {
        $record = new stdClass;
        $nr_of_fields = $fields->length;
        for ($j = 0; $j < $nr_of_fields; $j++) {
          $field = $fields->item($j);
          if ($field->nodeType == XML_ELEMENT_NODE) {
            $parts = $field->childNodes;
            $content = array();
            for ($k = 0; $k < $parts->length; $k++) {
              $part = $parts->item($k);
              if ($part->nodeType == XML_ELEMENT_NODE) {
                $content[] = $dom->saveXML($part);
              }
              elseif ($part->nodeType == XML_TEXT_NODE) {
                $content[] = $part->data;
              }
            }
            $key = $field->nodeName;
            $record->$key = html_entity_decode(join('', $content));
          }
        }
        $records[] = $record;
      }
    }
  }
  return $records;
}

/**
 * Automatically create a form given the schema of a table and some additional
 * data.
 * Option is an array of settings, its possible keys are:
 * - fieldset - associative array for fieldset (fieldset name => array of field
 * names under that fieldset)
 * - label - associative array of labels of fields (field name => label)
 * - omit - array of field names to skip
 * - hidden - associative array of hidden fields (field name => default value)
 * - values - associative array for default values (field name => default value)
 * - select - associative array for possible values, used in selections
 * (field name => assoc array of values (value => label)
 * @param $schema
 * @param $options
 * @return (Array)
 *   A FAPI (Form API) compatible array
 */
function xc_util_build_autoform($schema, $options) {
  $fieldsetMap = array();
  if (isset($options['fieldset'])) {
    foreach ($options['fieldset'] as $fieldset_name => $fieldset) {
      foreach ($fieldset['fields'] as $field) {
        $fieldsetMap[$field] = $fieldset_name;
      }
    }
  }
  $labels = isset($options['label']) ? $options['label'] : array();

  foreach ($schema['fields'] as $field => $attributes) {
    if (isset($options['omit']) && in_array($field, $options['omit'])) {
      continue;
    }
    $form_field = array();
    $form_field['#title'] = (isset($labels[$field])) ? $labels[$field] : $field;
    $form_field['#description'] = $attributes['description'];
    if (isset($options['select'][$field])) {
      $form_field['#type'] = 'select';
      $form_field['#options'] = $options['select'][$field];
      if (isset($options['values']) && isset($options['values'][$field])) {
        $form_field['#default_value'] = $options['values'][$field];
      }
    }
    elseif (isset($options['hidden']) && in_array($field, array_keys($options['hidden']))) {
      $form_field['#type'] = 'hidden';
      $form_field['#value'] = $options['hidden'][$field];
    }
    elseif ($attributes['type'] == 'text') {
      $form_field['#type'] = 'textarea';
      if (isset($options['values']) && isset($options['values'][$field])) {
        $form_field['#default_value'] = $options['values'][$field];
      }
    }
    else {
      $form_field['#type'] = 'textfield';
      if (isset($options['values']) && isset($options['values'][$field])) {
        $form_field['#default_value'] = $options['values'][$field];
      }
    }

    if (isset($attributes['default'])) {
      $form_field['#default_value'] = $attributes['default'];
    }

    // add field to form
    if (!empty($fieldsetMap) && isset($fieldsetMap[$field])) {
      // creating fieldset if needed
      $fieldset_name = $fieldsetMap[$field];
      if (!isset($form[$fieldset_name])) {
        $form[$fieldset_name] = array(
          '#type' => 'fieldset',
        );
        foreach ($options['fieldset'][$fieldset_name] as $key => $value) {
          if ($key != 'fields') {
            $form[$fieldset_name][$key] = $value;
          }
        }
      }
      $form[$fieldset_name][$field] = $form_field;
    }
    else {
      $form[$field] = $form_field;
    }
  }
  // those fields, which available only in 'hidden' of option but not in schema
  if (isset($options['hidden'])) {
    $hidden_fields = array_keys($options['hidden']);
    foreach ($hidden_fields as $hidden_field) {
      if (!isset($schema['fields'][$hidden_field])) {
        $form_field['#type'] = 'hidden';
        $form_field['#value'] = $options['hidden'][$hidden_field];
        $form[$hidden_field] = $form_field;
      }
    }
  }

  return $form;
}

/**
 * A utility function to display properties of record in a table.
 *
 * It shows only those fields, which has an entry in the fieldset. If you want to
 * add more fields to display, add field value to <code>$record</code>
 * (eg. <code>$record->new_field = 'some value';</code>, and <code>array($new_field => 'display name')</code>
 * to <code>$fieldset</code>.
 *
 * @param $record (object)
 *   The record to show
 * @param $fieldset (array)
 *   An associaciteve array of fields to show (as field name => display name, field name => display name)
 * @param $options (array)
 *   Value options
 * @param $parameters (array)
 *   Additional parameters. Possible value: 'filters' is an associative
 *   array with the keys are field name and value is one (string) or more (array)
 *   of functions to run on the field.
 *
 * @return (String)
 *   A themed table
 */
function xc_util_view($record, $fieldset, $options = array(), $parameters = array()) {
  $headers = array(t('Property'), t('Value'));
  $rows = array();
  foreach ($fieldset as $name => $title) {
    if (isset($options[$name]) && isset($options[$name][$record->$name])) {
      $data = $options[$name][$record->$name];
    }
    else {
      $data = $record->$name;
    }

    if (isset($parameters['filters']) && isset($parameters['filters'][$name])) {
      foreach ($parameters['filters'][$name] as $filter) {
        if (is_array($filter)) {
          $func = array_shift($filter);
          array_unshift($filter, $data);
          $data = call_user_func_array($func, $filter);
        }
        else {
          $data = call_user_func($filter, $data);
        }
      }
    }
    $rows[] = array(
      'data' => array($title, $data),
      'valign' => 'top'
    );
  }
  $caption = isset($parameters['caption']) ? $parameters['caption'] : NULL;
  return theme('table', array('header' => $headers, 'rows' => $rows, 'attributes' => NULL, 'caption' => $caption));
}

/**
 * It returns a joined value is the value is an array, else the value as it is.
 * @param $separator The separator between values
 * @param $value The value to process
 * @return The joined array
 */
function xc_util_conditional_join($separator, $value) {
  if (is_array($value)) {
    return join($separator, $value);
  }
  else {
    return $value;
  }
}

/**
 * Create a search links from value (or values) of a field. If the field contains
 * multiple values it creates multiple links.
 * @param $separator (String) Separator between link (if there are more than one value)
 * @param $values (Array/String) The field value or values
 * @param $fields (Array/String) The name of the field or fields
 * @param $options (Array) Options. Possible values:
 *   'phrase' = the value should be handled as phrase query
 *   'external' = the value is an external (not Drupal) link
 *   'regex' = the value should be a regular expression, which the function use
 *     as a filter. If the value matches, it will be link, if it fails, it will
 *     remain as string.
 *   'is_facet' = the field is a facet
 *   'outlink' = An additional link should be created. This is as array with
 *     the following keys:
 *     'label' => the label of the link
 *     'link' = a link pattern. It should contain a placeholder: [value] to
 *       replace it with the field’s value
 *     'separator' = a string which separates the two links
 * @return (String) The resulted search links
 */
function xc_util_conditional_joined_link($separator, $values, $fields, $options = array()) {
  if (!is_array($values)) {
    $values = array($values);
  }
  $links = array();
  foreach ($values as $value) {
    $link = xc_util_make_link($value, $fields, $options);
    if ($link != '') {
      $links[] = $link;
    }
  }
  if (is_null($separator)) {
    return $links;
  }
  return join($separator, $links);
}

function xc_util_link_walk(&$items, $fields, $options = array()) {
  for ($i = 0; $i < count($items); $i++) {
    $link = xc_util_make_link($items[$i], $fields, $options);
    if (!is_null($link)) {
      $items[$i] = $link;
    }
    else {
      unset($items[$i]);
    }
  }
}

function xc_util_make_link($value, $fields, $options = array()) {
  $link = NULL;
  if ($value != '' && !is_null($value) && !empty($value)) {
    if (isset($options['external'])) {
      if (!isset($options['regex']) || preg_match($options['regex'], $value, $matches)) {
        if ($matches) {
          if (isset($options['shorten'])) {
            if (preg_match('{((?:https?|ftp)://[^/]+)$}', $value)) {
              $link = preg_replace('{((?:https?|ftp)://[^/]+)$}', "<a href=\"$1\">$1</a>", $value);
            }
            else {
              if (preg_match('{((?:https?|ftp)://)([^/]+)([^ ]*)}', $value, $matches)) {
                if (strlen($matches[2]) > 30) {
                  $host = join('.', array_slice(explode('.', $matches[2]), -2));
                  $link = sprintf('<a href="%s">%s&hellip;</a>', $matches[0], $matches[1] . '&hellip;' . $host);
                }
                else {
                  $link = preg_replace(
                    '{((?:https?|ftp)://[^/]+)([^ ]*)}e',
                    "'<a href=\"\\1\\2\">'. str_replace(array('.', '/'), array('.&shy;', '/&shy;'), '\\1'). '&hellip;</a>'",
                    $value
                  );
                }
              }
              else {
                $link = preg_replace('{((?:https?|ftp)://[^/]+)([^ ]*)}', "<a href=\"$1$2\">$1&hellip;</a>", $value);
              }
            }
          }
          else {
            $link = preg_replace('{((?:https?|ftp)://[^ ]+)}', "<a href=\"$1\">$1</a>", $value);
          }
        }
        else {
          $link = l($value, $value, array('absolute' => TRUE));
        }
      }
      else {
        $link = $value;
      }
    }
    else {
      $facet_link = isset($options['facet']) && $options['facet'] == 1;

      if (isset($options['phrase'])) {
        $query_term = '"' . ($facet_link ? _xc_solr_clean($value) : $value) . '"';
      }
      else {
        $query_term = '(' . preg_replace('/([\?:\(\)\[\]])/', '\\\\${1}',
          ($facet_link ? _xc_solr_clean($value) : $value)) . ')';
      }

      if ($fields == '') {
        if ($facet_link) {
          $link = l($value, 'xc/search/*', array(
            'query' => array('ql' => 1, 'filter[]' => $query_term),
            'HTML' => TRUE));
        }
        else {
          $link = l($value, 'xc/search/' . $query_term, array(
            'query' => array('ql' => 1),
            'HTML' => TRUE));
        }
      }
      else {
        if (!is_array($fields)) {
          $fields = array($fields);
        }
        $field_queries = array();
        foreach ($fields as $field) {
          if (!is_string($field)) {
            xc_util_dsm(debug_backtrace());
          }
          $solr_fields = $facet_link ? array($field) : xc_solr_schema2solr($field);
          foreach ($solr_fields as $solr_field) {
            $field_queries[] = $solr_field . ':' . $query_term;
          }
        }
        $query = count($field_queries) > 1
          ? '(' . join(' OR ', $field_queries) . ')'
          : $field_queries[0];
        if ($facet_link) {
          $link = l($value, 'xc/search/*', array(
            'query' => array('ql' => 1, 'filter[]' => $query),
            'HTML' => TRUE));
        }
        else {
          $link = l($value, 'xc/search/' . $query, array(
            'query' => array('ql' => 1),
            'HTML' => TRUE));
        }
      }

      // outer links
      if ($value != '' && isset($options['outlink'])) {
        $separator = empty($options['outlink']['separator'])
          ? ' '
          : $options['outlink']['separator'];
        if ($options['outlink']['inside'] === TRUE) {
          list($target, $query) = $options['outlink']['link'];
          $link .= $separator . l($options['outlink']['label'],
            $target,
            array(
              'absolute' => TRUE,
              'HTML' => TRUE,
              'query' => preg_replace('/\[value\]/', rawurlencode($value), $query),
            )
          );
        }
        else {
          $link .= $separator . l($options['outlink']['label'],
            preg_replace('/\[value\]/', urlencode($value), $options['outlink']['link']),
            array('absolute' => TRUE, 'HTML' => TRUE)
          );
        }
      } // outer links
    }
  }
  return $link;
}


/**
 * Check whether a node exists
 * @param $nid (int) The node id
 * @return (Boolean) TRUE if the node exists, and FALSE if it does not exist
 */
function xc_util_node_exists($nid) {
  $sql = 'SELECT COUNT(*) FROM {node} WHERE nid = :nid';
  // TODO Please convert this statement to the D7 database API syntax.
  $countrows = db_query($sql, array(':nid' => $nid))->fetchField();
  return ($countrows == 0) ? FALSE : TRUE;
}

/**
 * Return the value of an element. If there are multiple elements, it gives
 * the Nth element’s value, which should be nominated by the $delta parameter.
 *
 * @param $element (Array)
 *   The element whose value should be extracted.
 * @param $delta (int)
 *   The count of the element whose value should be extracted.
 *
 * @return (String)
 *   The value of the element
 */
function xc_util_xml_array_element_value($element, $delta = NULL) {
  if (isset($element['#value'])) {
    return $element['#value'];
  }
  else {
    return $delta ? $element[$delta]['#value'] : $element[0]['#value'];
  }
}

/**
 * Removes duplicate values from an array.
 *
 * A workaround for complex arrays, which are not handled correctly with PHP’s
 * array_unique function.
 *
 * @param $input (Array)
 *   An array with possible duplicated values
 * @return (Array)
 *   The array consisting of the unique items of the original
 */
function xc_util_array_unique($input) {
  $serialized = array();
  foreach ($input as $item) {
    $serialized[] = serialize($item);
  }
  $serialized = array_unique($serialized);

  $output = array();
  foreach ($serialized as $item) {
    $output[] = unserialize($item);
  }
  return $output;
}

function xc_util_remove_array_element(&$array, $elements) {
  foreach ($array as $key => $value) {
    if (in_array($value, $elements)) {
      unset($array[$key]);
    }
  }
}

/**
 * Shows the SQL query with actual parameters and table names.
 *
 * Usage:
 * <code>
 * xc_util_get_sql(db_rewrite_sql($sql, '{table}', 'primary id'), $param1));
 </code>
 * @param $query (String)
 *   The SQL query
 * @param $arg1, $arg2, $arg3
 *   The parameters of the query
 * @return (String) The SQL which will run against DB.
 */
function xc_util_get_sql($query) {
  $args = func_get_args();
  array_shift($args);
  $query = Database::getConnection()->prefixTables($query);
  //$query = db_prefix_tables($query);
  if (isset($args[0]) and is_array($args[0])) { // 'All arguments in one array' syntax
    $args = $args[0];
  }
 // TODO from Tom
 // _db_query_callback($args, TRUE);
 // $query = preg_replace_callback(DB_QUERY_REGEXP, '_db_query_callback', $query);
  return $query;
}

/**
 * Replaces all spaces with non-breaking space
 * @param $text
 * @return unknown_type
 */
function xc_util_spacer($text) {
  return str_replace(' ', '&nbsp;', $text);
}

/**
 * Checks whether a container (a string or an array) contains a value or at
 * least one of the values
 * @param $container (array or string)
 *   The container, which should contain a given value
 * @param $values (array or string)
 *   The value or the list of values which should be or in the case of list
 *   at least one of its elements should be in the container
 * @return (boolean)
 *   TRUE if the value is in the container, otherwise FALSE
 */
function xc_util_contains($container, $values) {
  if (is_string($values)) {
    if (is_string($container)) {
      return $container == $values;
    }
    elseif (is_array($container)) {
      return in_array($values, $container);
    }
  }
  elseif (is_array($values)) {
    if (is_string($container)) {
      return in_array($container, $values);
    }
    elseif (is_array($container)) {
      return (count(array_intersect($container, $values)) > 0);
    }
  }
}

/**
 * Merge non empty elements (arrays, and non arrays) into an array
 *
 * @return (Array)
 *   The new merged array
 */
function xc_util_array_merge() {
  $result = array();
  $arg_list = func_get_args();
  foreach ($arg_list as $arg) {
    if (is_array($arg) && !empty($arg)) {
      $result = array_merge($result, $arg);
    }
    else {
      if (!empty($arg)) {
        $result[] = $arg;
      }
    }
  }
  return $result;
}

/**
 * Checks whether a given string is a URL. If this is an array, checks whether
 * at least one of its element is a URL
 * @param $url (String or Array)
 *   A string or a list we should checks
 * @return (boolean)
 *   TRUE if the input or at least one of the inputs is URL. Otherwise FALSE
 */
function xc_util_contains_url($url) {
  if (is_string($url)) {
    return preg_match('{(^|\b)(https?|ftp)://}', $url);
  }
  elseif (is_array($url)) {
    foreach ($url as $uri) {
      if (preg_match('{(^|\b)(https?|ftp)://}', $uri)) {
        return TRUE;
      }
    }
    return FALSE;
  }
}

function xc_util_template_get_name($metadata_type, $type, $display_type) {
  static $cache;

  $key = $metadata_type . '|' . $type . '|' . $display_type;
  if (!isset($cache[$key])) {
    $type = !empty($metadata_type)
      ? (is_array($metadata_type) ? $metadata_type[0] : $metadata_type)
      : (!empty($type) ? $type : 'general');
    if ($type == 'xc_oai_dc') {
      $type = 'oai_dc';
    }
    $cache[$key] = $type . '_' . $display_type;
  }

  return $cache[$key];
}

function xc_util_template_exists($name) {
  static $registry = NULL;
  if (!isset($registry)) {
    drupal_theme_initialize();
    $registry = theme_get_registry();
  }
  $theme = $registry[$name];
  if (empty($theme)) {
    return FALSE;
  }

  // TODO: it is not examining the overriden templates
  if (!empty($theme['template'])) {
    return file_exists($theme['template'] . '.tpl.php');
  }
  return TRUE;
}

/**
 * Creates atomic value from arrays which has only one element.
 *
 * Sometimes the string parameters became arrays. This function creates atomic
 * value from arrays which has only one element. The function is recursive, so
 * if it is an array of one array of one array ... of one string, it becames a
 * string.
 *
 * @param $url_params (Array)
 *   The URL parameters array
 *
 * @return (Array)
 *   The cleaned URL parameter array
 */
function xc_clean_params($url_params) {
  foreach ($url_params as $key => $value) {
    if ($key != 'filter' && is_array($value)) {
      if (count($value) == 1) {
        while (is_array($value) && count($value) == 1 && isset($value[0])) {
          $value = $value[0];
        }
      }
      $url_params[$key] = $value;
    }
  }
  return $url_params;
}

function print_r_tree($data) {
  $out = print_r($data, TRUE);
  $out = preg_replace('/([ \t]*)(\[[^\]]+\][ \t]*\=\>[ \t]*[a-z0-9 \t_]+)\n[ \t]*\(/iUe', "'\\1<a href=\"javascript:toggleDisplay(\''.(\$id = substr(md5(rand().'\\0'), 0, 7)).'\');\">\\2</a><div id=\"'.\$id.'\" style=\"display: none;\">'", $out);
  $out = preg_replace('/^\s*\)\s*$/m', '</div>', $out);
  return '<script language="Javascript">function toggleDisplay(id) { document.getElementById(id).style.display = (document.getElementById(id).style.display == "block") ? "none" : "block"; }</script>' . "\n$out";
}

function xc_util_push(&$values, $elements) {
  foreach ($elements as $element) {
    $values[] = $element;
  }
}

/**
 * Gets the values of schema field
 *
 * @param $fields (Array)
 *   The field or fields the values should be extracted of
 * @param $filters (Array)
 *   Array of attributes and values, which should match in the field
 *
 * @return (Array)
 *   The values of the field
 */
function xc_util_get_metadata_value($fields, $filters = array(), $fieldname = NULL) {
  if (empty($fields)) {
    return;
  }

  $values = array();
  foreach ($fields as $metadata_field) {
    if (empty($filters)) {
      if (isset($metadata_field['#value'])) {
        $values[] = $metadata_field['#value'];
      }
    }
    else {
      foreach ($filters as $attr_name => $attr_value) {
        if ($attr_name === 0) {
          // TODO: Handle errors
        }
        if (isset($metadata_field[$attr_name])) {
          if (is_array($attr_value)) {
            if (in_array($metadata_field[$attr_name], $attr_value)) {
              $values[] = $metadata_field['#value'];
            }
          }
          else {
            if ($metadata_field[$attr_name] == $attr_value) {
              $values[] = $metadata_field['#value'];
            }
          }
        }
      }
    }
  }
  return array_unique($values);
}


function xc_util_get_metadata_values($record, $options) {
  if (!is_array($options)) {
    $options = array($options);
  }
  $values = array();
  foreach ($options as $field => $filters) {
    if (isset($record[$field])) {
      $values = xc_util_array_merge($values, xc_util_get_metadata_value($record[$field], $filters));
    }
  }
  return $values;
}

function xc_util_push_metadata_value($values, $fields, $fieldname = NULL) {
  return array_merge($values, xc_util_get_metadata_value($fields, array(), $fieldname));
}

/**
 * Delete the div around a form element.
 *
 * Usage:
 * @code
 *   $form['...'] = array(
 *     ...
 *     '#post_render' => array('oaiharvester_delete_div_around'),
 *     ...
 *   );
 * @endcode
 * @param $content
 * @param $elements
 * @return unknown_type
 */
function xc_util_delete_div_around($content, $elements) {
  $content = preg_replace('/(^\s*<div[^<>]+>\s*|\s*<\/div>\s*$)/', '', $content);
  return $content;
}

function xc_util_init() {
  global $_xc_util_months;

  $_xc_util_months = array(
    'january',
    'february',
    'march',
    'april',
    'may',
    'june',
    'july',
    'august',
    'september',
    'october',
    'november',
    'december'
  );
}

/**
 * Gets the numeric part of an OAI identifier harvested from MST
 *
 * @param $identifier (String)
 *   The full OAI identifier
 * @param $identifier_prefix (String)
 *   The OAI identifier prefix
 *
 * @return (int)
 *   The numeric part of the OAI idenfitier
 */
function xc_util_get_identifier_int($identifier, $identifier_prefix = NULL) {
  // TODO: remove this line, uncomment next one.
  // Now there is a bug in MST, and the OAI identifiers do not match the <oai prefix><number> pattern.
  // Workaround: remove the non-numbers from the beginning of the string.
  // When the MST will fix this problem, we can go back to the str_replace version
  return preg_replace('/^.*?(\d+)$/', "$1", $identifier);
  // return str_replace($identifier_prefix, $identifier);
}

/**
 * Checks whether a given index is existing for a database table.
 * Warning: this is a MySQL-specific function, it doesn't work for other DB types
 *
 * @param $table (String)
 *   The name of database table
 * @param $index_name (String)
 *   The name of index, what we are looking for
 *
 * @return (Boolean)
 *   TRUE if the index exists, FALSE if it doesn't exist
 */
function xc_util_index_exists($table, $index_name) {
  static $cache;
  if (!isset($cache[$table])) {
    $results = db_query('SHOW INDEX FROM {' .  db_escape_table($table) . '}');
    $cache[$table] = array();
    foreach ($results as $data) {
      $cache[$table][$data->Key_name] = 1;
    }
  }
  return isset($cache[$table][$index_name]);
}

/**
 * Get maximum n char from a text, splitting intelliently
 *
 * @param $text (String)
 *   The text to shorten
 * @param $length (int)
 *   The maximum number of characters to retrieve
 *
 * @return (String)
 *   The shorted text
 */
function xc_wordwrap($text, $length = 80, $suffix = '') {
  if (drupal_strlen($text) <= $length) {
    return $text;
  }
  $delimiter = '<delim>';
  $lines = explode($delimiter, wordwrap($text, $length, $delimiter));
  return $lines[0] . $suffix;
}

function xc_oaiharvester_statistics_set($key, $value) {
  global $_oaiharvester_statistics;

  if (!isset($_oaiharvester_statistics)) {
    $_oaiharvester_statistics = variable_get('oaiharvester_statistics', array());
  }

  if (!isset($_oaiharvester_statistics[$key])) {
    $_oaiharvester_statistics[$key] = $value;
  }
  else {
    $_oaiharvester_statistics[$key] += $value;
  }
}



function xc_log_memory_consumption($label) {
  $full = xc_util_byte_to_kilo(memory_get_usage(true));
  $used = xc_util_byte_to_kilo(memory_get_usage());
  xc_log_info('memory', sprintf("memory usage at %s: full: %s, used: %s (%s)", str_pad($label, 20), $full, $used, _get_file_position(1)));
}


function xc_util_byte_to_kilo($size) {
  static $unit = array('B', 'KB', 'MB', 'GB', 'TB', 'PB');

  if ($size == 0) {
    return $size;
  }

  $i = floor(log($size, 1024));
  return sprintf('%7.3f %s', ($size / pow(1024, $i)), $unit[$i]);
}

function xc_log_globals() {
  static $exclude;

  if (!isset($exclude)) {
    $exclude = array_flip(array(
      '_POST',
      '_GET',
      '_COOKIE',
      '_FILES',
      '_SERVER',
      '_SESSION',
      '_REQUEST',
      'GLOBALS',
      'base_url',
      'base_path',
      'base_root',
      'db_url',
      'db_prefix',
      'db_collation',
      'cookie_domain',
      'installed_profile',
      'update_free_access',
      'db_type',
      'active_db',
      'user',
      'language',
      'multibyte',
      'theme_key',
      'theme',
      'custom_theme',
      'theme_info',
      'base_theme_info',
      'theme_engine',
      'theme_path',
      // resources:
      '_xc_oaiharvester_bridge_set_csv',
      '_xc_entity_relationships_csv',
      '_xc_entity_properties_csv',
      '_xc_oaiharvester_bridge_header_csv',
      '_xc_sql_metadata_csv',
      // 'conf'
    ));
  }

  $keys = array_keys($GLOBALS);
  $filtered = array();
  foreach ($keys as $key) {
    if (isset($exclude[$key]) || count($GLOBALS[$key]) == 0 || is_bool($GLOBALS[$key]) || is_numeric($GLOBALS[$key])) {
      continue;
    }
    $typedkey = sprintf('%s (%s) %d', $key, gettype($GLOBALS[$key]), count($GLOBALS[$key]));
    $filtered[$typedkey] = strlen(serialize($GLOBALS[$key]));
  }
  arsort($filtered);
  $info = array('total: ' . strlen(serialize($GLOBALS)));
  foreach ($filtered as $key => $value) {
    $info[] = $key . ': ' . $value;
  }
  xc_log_info('globals', join('; ', $info));
}

function xc_util_list_directory($dir) {

  $file_list = array();
  $total = 0;
  if (file_prepare_directory($dir, FALSE)) {
    $files = scandir($dir);
    $cached_file_count = count($files);
    if ($cached_file_count > 2) {
      for ($i = 0; $i < $cached_file_count; $i++) {
        if ($files[$i] == '.' || $files[$i] == '..') {
          continue;
        }
        $stat = stat($dir . '/' . $files[$i]);
        $file_list[] = array(
          $files[$i],
          xc_util_byte_to_kilo($stat['size']),
          format_date($stat['mtime'], 'custom', 'Y-m-d H:i:s'),
        );
        $total += $stat['size'];
      }
    }
  }
  $file_list[] = array(
    '<strong>' . t('total') . '</strong>',
    xc_util_byte_to_kilo($total),
    '',
  );

  return theme('table', array('header' => array(t('name'), t('size'), t('last modification')), 'rows' => $file_list));
}


/**
 * Get data from cache. If there is no stored values, it returns the default data.
 *
 * @param String $cid
 * @param mixed $default_value
 */
function xc_cache_get_data($cid, $default_value) {
  $cache = cache_get($cid);
  $data = ($cache !== FALSE) ? $cache->data : $default_value;
  return $data;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_util_get_global_options($name = NULL) {
  static $options;

  if (isset($options)) {
    $options = array(
      'true_false' => array(
        1 => t('true'),
        0 => t('false'),
      ),
      'true_false_solr' => array(
        'true' => t('true'),
        'false' => t('false'),
      ),
      'enable_disable' => array(
        1 => t('enable'),
        0 => t('disable'),
      ),
    );
  }

  if (is_null($name)) {
    return $options;
  }
  elseif (isset($options[$name])) {
    return $options[$name];
  }

  return FALSE;
}

function xc_util_simple_trace($debug_backtrace) {
  $simple_trace = array();
  foreach ($debug_backtrace as $item) {
    if (isset($item['file']) && strstr($item['file'], '/modules/xc/')) {
      $file = preg_replace('/^.*\/modules\/xc\//', '', $item['file']);
      $simple_trace[] = $file . ':' . $item['line'] . ' ' . $item['function'] . '()';
    }
    else if (preg_match('/^xc_/', $item['function'])) {
      $simple_trace[] = $item['function'] . '()';
    }
    else {
      $simple_trace[] = $item['function'] . '()';
    }
  }
  return join(' -- ', $simple_trace);
}

function xc_util_get_sql7($query, $args) {
  foreach ($args as $key => $data) {
    $query = preg_replace('#' . $key . '\b#', "'". $data . "'", $query);
  }

  return $query;
}
