<?php
/**
 * @file
 * XC Authentication module
 *
 * @copyright (c) 2010-2011 eXtensible Catalog Organization
 */

/**
 * @addtogroup global variables
 * @{
 */

/**
 * Flag indicates whether the current user is authenticated.
 *
 * @var boolean
 */
global $_xc_auth_authenticated;
/**
 * @} End of "addtogroup global variables".
 */

/**
 * Signals that the login process was unsuccessfull.
 */
define('XC_AUTH_LOGIN_FAILURE', 0x000);

/**
 * Signals that the login process was successfull.
 */
define('XC_AUTH_LOGIN_SUCCESS', 0x001);

/**
 * Signals that the login credentials were invalid.
 */
define('XC_AUTH_LOGIN_INCORRECT', 0x002);

/**
 * Signals that the logout process was unsuccessfull.
 */
define('XC_AUTH_LOGOUT_FAILURE', 0x000);

/**
 * Signals that the logout process was successfull.
 */
define('XC_AUTH_LOGOUT_SUCCESSFUL', 0x001);

require_once 'includes/xc_auth.credentials.inc';
require_once 'includes/xc_auth.methods.inc';
require_once 'includes/xc_auth.account.inc';

//  LDAP INTEGRATION EXPERIMENTAL!!!
//  require_once('includes/xc_auth.ldap.inc'));


/**
 * Implements hook_permission().
 */
function xc_auth_permission() {
  $perm = array(
    'administer xc authentication' => array(
      'title' => t('administer xc authentication'),
      'description' => t('administer xc authentication'),
    ),
    'edit own xc authenticated users' => array(
      'title' => t('edit own xc authenticated users'),
      'description' => t('edit own xc authenticated users'),
    ),
    'edit all xc authenticated users' => array(
      'title' => t('edit all xc authenticated users'),
      'description' => t('edit all xc authenticated users'),
    ),
  );
  if (variable_get('xc_auth_authenticate_by_auth_type_perm', 0)) {
    foreach (xc_auth_type_get_all() as $type) {
      $perm[] = t('authenticate by %type type', array('%type' => strtolower($type->name)));
    }
  }

  if (variable_get('xc_auth_authenticate_by_method_perm', 0)) {
    foreach (xc_auth_method_get_all() as $method) {
      $perm[] = t('authenticate by %method method', array('%method' => strtolower($method->name)));
    }
  }

  return $perm;
}

/**
 * Implements hook_theme().
 */
function xc_auth_theme() {
  return array(
    'xc_auth_auto_auth_types_form' => array(
      'render element' => 'elements',
    ),
    'xc_auth_auto_login_form' => array(
      'variables' => array(),
    ),
    'xc_auth_type_list_form' => array(
      'render element' => 'form',
    ),
    'xc_auth_type_reorder_form' => array(
      'render element' => 'form',
    ),
  );
}

/**
 * Implements hook_theme_registry_alter().
 */
function xc_auth_theme_registry_alter(&$theme_registry) {
  // Override username theme if settings is enabled
  if (variable_get('xc_auth_override_usernames', 1)) {
    $theme_registry['username']['function'] = 'xc_auth_username';
  }
}

/**
 * Get authmaps with caching
 */
function xc_auth_get_authmap($authname, $update = FALSE) {
  static $cache;
  if (empty($cache[$authname]) || $update) {
    $sql = "SELECT authname FROM {authmap}
            WHERE authname = '%s' AND module = 'xc_auth'";
    $cache[$authname] = $authname = db_query("SELECT authname FROM {authmap}
            WHERE authname = :authname AND module = :module", array(':authname' => $authname, ':module' => 'xc_auth'))->fetchField();
  }
  return $cache[$authname];
}

/**
 * Theme function to rewrite displayed username as the default authentication
 * type's identity (typically the username)
 *
 * @see theme_username()
 */
function xc_auth_username($object) {
  if (isset($object->uid) && isset($object->name)) {
    // Check if authenticated by XC Authentication
    $_name = variable_get('xc_auth_override_usernames', 1)
       && xc_auth_get_authmap($object->name)
       ? _drupal_to_xc_auth($object->name, 'identity')
       : $object->name;

    // Shorten the name when it is too long or it will break many tables.
    if (variable_get('xc_auth_truncate_long_usernames', 0)
         && drupal_strlen($_name) > 20) {
      $name = drupal_substr($_name, 0, 15) . '&hellip;';
    }
    else {
      $name = $_name;
    }

    if (user_access('access user profiles')) {
      $output = l($name, 'user/' . $object->uid,
        array('attributes' => array('title' => t('View user profile.'))));
    }
    else {
      $output = check_plain($name);
    }
  }
  elseif (isset($object->name)) {
    if (!empty($object->homepage)) {
      $output = l($object->name, $object->homepage,
        array('attributes' => array('rel' => 'nofollow')));
    }
    else {
      $output = check_plain($object->name);
    }

    $output .= ' (' . t('not verified') . ')';
  }
  else {
    $output = check_plain(variable_get('anonymous', t('Anonymous')));
  }

  return $output;
}

/**
 * Generate identity for users on authentication types, using authentication
 * methods that do not provide a custom identify function
 *
 * @param $credentials
 *    Credentials definition object
 * @param $values
 *    Array of values passed into login form
 */
function xc_auth_identify($credentials, $values) {
  $credentials = (object) $credentials;
  $identity = array();
  if (is_array($credentials->credentials)) {
    foreach ($credentials->credentials as $k => $v) {
      if ($v['stored'] && isset($values[$k])) {
        $identity[] = $values[$k];
      }
    }
  }
  $identity = implode('_', $identity);
}

/**
 * Inverse of identity generation for users on authentication types, using
 * authentication methods that do not provide a custom reverse identify function
 *
 * @param $credentials
 *    Credentials definition object
 * @param $identity
 *    Identity of the user
 */
function xc_auth_reverse_identify($credentials, $identity) {
  $credentials = (object) $credentials;
  $keys = array();
  $values = explode('_', $identity);
  if (is_array($credentials->credentials)) {
    foreach ($credentials->credentials as $k => $v) {
      if ($v['stored']) {
        $keys[] = $k;
      }
    }
  }
  $values = array_combine($keys, $values);
}

/**
 * Get a Drupal username for an user on an external authentication system
 *
 * @param $identity
 *    Identity of the user on an authentication type
 * @param $auth
 *    Authentication type
 * @return
 *    Drupal username
 */
function _xc_auth_to_drupal($identity, $auth) {
  return $identity . '_' . $auth->tid;
}

/**
 * Get the identity for a Drupal user on an external authentication system
 *
 * @param $name
 *    Drupal username
 * @param $return
 *    What to return, either 'identity' for the identity, 'tid' for the
 *    authentication type identifier, or NULL for an array containing both
 * @return
 *    Either the identity of the user, the authentication type identifier, or
 *    an array of both
 */
function _drupal_to_xc_auth($name, $return = NULL) {
  $pos = strrpos($name, '_');
  $identity = array(
    'identity' => drupal_substr($name, 0, $pos),
    'tid' => drupal_substr($name, $pos + 1),
  );
  return empty($return) ? $identity : $identity[$return];
}

/**
 * Authentication settings form
 */
function xc_auth_settings_form($form, &$form_state) {
  $form['instructions'] = array(
    '#value' => t('Make sure to set up !permissions for roles given to users upon account creation or initial registration from login and !configure the login block',
                  array(
      '!permissions' => l(t('permissions'), 'admin/user/permissions'),
      '!configure' => l(t('configure'), 'admin/structure/block/configure/xc_auth/xc_login'),
    )),
  );

  $form['xc_auth_override_usernames'] = array(
    '#type' => 'checkbox',
    '#title' => t('Override username theme'),
    '#description' => t('Enable to only display only the identity of a user (based on their default authentication type) instead of full Drupal username, which includes the numeric authenitcation type identifier. Disable if using Drupal, a custom theme or template, or another module to theme the Drupal username.'),
    '#default_value' => variable_get('xc_auth_override_usernames', 1),
  );

//  $form['xc_auth_truncate_long_usernames'] = array(
//    '#type' => 'checkbox',
//    '#title' => t('Truncate long usernames'),
//    '#description' => t('By default, Drupal will truncate usernames that are over 20 characters. This is disabled if overriding the username theme. Enable this setting to return to the default Drupal behavior.'),
//    '#default_value' => variable_get('xc_auth_truncate_long_usernames', 0)
//  );
  //
//  $form['xc_auth_prevent_conflicting_usernames'] = array(
//    '#type' => 'checkbox',
//    '#title' => t('Prevent conflicting usernames'),
//    '#description' => t('Keep checked to prevent conflicting usernames in Drupal that could arise if more than one authentication types have users with the same identity. The ONLY time this could be safe to disable is if you use one authentication type and/or are confident that there would be no potential identity or username conflicts over the lifetime of your site. Even if that is true, keep in mind that it is ALWAYS recommended to leave this feature enabled.'),
//    '#default_value' => variable_get('xc_auth_prevent_conflicting_usernames', 1)
//  );
  //
//  $form['xc_auth_authenticate_by_auth_type_perm'] = array(
//    '#type' => 'checkbox',
//    '#title' => t('Enable permissions to authenticate user by authentication type'),
//    '#description' => t('Enables permission settings to limit which users can authenticate to a certain authentication type by role. If selected, make sure to edit permission settings or users may not be able to authenticate.'),
//    '#default_value' => variable_get('xc_auth_authenticate_by_auth_type_perm', 0)
//  );
  //
//  $form['xc_auth_authenticate_by_method_perm'] = array(
//    '#type' => 'checkbox',
//    '#title' => t('Enable permissions to authenticate user by method'),
//    '#description' => t('Enables permission settings to limit which users can authenticate using certain authentication methods by role. If selected, make sure to edit permission settings or users may not be able to authenticate. Since each authentication type uses a certain authenication method, pay careful attention to permissions if using this setting.'),
//    '#default_value' => variable_get('xc_auth_authenticate_by_method_perm', 0)
//  );
  //
//  $form['xc_auth_show_login_tabs'] = array(
//    '#type' => 'checkbox',
//    '#title' => t('Show remote authentication login options as tabs on login page'),
//    '#description' => t('Displays login pages options as tabs. May be useful for login web forms with "multiple" remote authentiction severs.'),
//    '#default_value' => variable_get('xc_auth_show_login_tabs', 0)
//  );

  $form['#submit'][] = 'xc_auth_settings_form_submit';

  return system_settings_form($form);
}

/**
 * Authentication settings form submit handler
 */
function xc_auth_settings_form_submit($form, &$form_state) {
  menu_rebuild();
}

/**
 * Get an authetication type's name for page title
 */
function xc_auth_type_title($auth_type) {
  return $auth_type->name;
}

/**
 * Get authentication type
 *
 * @param $tid
 *    Authentication type identifier
 * @param $update
 *    TRUE to update authentication type cache
 * @return
 *    Authentication type object
 */
function xc_auth_type_load($tid, $update = FALSE) {
  $auth_types = xc_auth_type_get_all($update);
  return $auth_types[$tid];
}

/**
 * Get authentication type
 *
 * @see xc_auth_type_load()
 * @param $tid
 *    Authentication type identifier
 * @return
 *    Authentication type object
 */
function xc_auth_type_get($tid) {
  return xc_auth_type_load($tid);
}

/**
 * Get all authentication types
 *
 * @see xc_auth_type_load()
 * @param $update
 *    TRUE to update authentication type cache
 * @return
 *    Array of authentication type objects
 */
function xc_auth_type_get_all($update = FALSE) {
  static $auth_types;

  if (empty($auth_types) || $update) {
    $sql = 'SELECT tid, method, data, name, description, reset_password_text,
              help_text, login_success_text, login_failure_text, login_incorrect_text,
              roles, credentials, login_text, logout_text, auto_load_values,
              auto_create_account, weight
            FROM {xc_auth_type}
            ORDER BY weight';
    $result = db_query($sql);

    $auth_types = array();
    foreach ($result as $auth_type) {
      $auth_type->data = unserialize($auth_type->data);
      $auth_type->roles = unserialize($auth_type->roles);
      $auth_type->credentials = unserialize($auth_type->credentials);
      $auth_types[$auth_type->tid] = $auth_type;
    }
  }

  return $auth_types;
}

/**
 * Get an authentication method. Note that this does NOT return an
 * object, unlike xc_auth_method_load(), which does
 *
 * @see xc_auth_method_load()
 * @param $method
 *    Authentcation method name
 * @return
 *    Authentication method array
 */
function xc_auth_method_get($method) {
  $methods = xc_auth_method_get_all();
  return $methods[$method];
}

/**
 * Get an authentication method
 *
 * @see xc_auth_method_get()
 * @param $method
 *    Authentcation method name
 * @return
 *    Authentication method object
 */
function xc_auth_method_load($method) {
  return (object) xc_auth_method_get($method);
}

/**
 * Get all authentication methods
 *
 * @see xc_auth_method_load()
 * @param $update
 *    TRUE to update authentication method cache
 * @return
 *    Array of authentication method objects
 */
function xc_auth_method_get_all($update = FALSE) {
  static $cache;
  if (empty($cache) || $update) {
    $cache = array();
    foreach (module_invoke_all('xc_auth_methods') as $k => $v) {
      $cache[$k] = (object) $v;
    }
  }
  return $cache;
}

/**
 * Get all authentication method names
 *
 * @return
 *    An array of all authentication method names, with their machine names
 *    as keys
 */
function xc_auth_method_get_all_names() {
  $names = array();
  foreach (xc_auth_method_get_all() as $key => $value) {
    $names[$key] = $value->name;
  }
  return $names;
}

/**
 * Get an authentication credential definition. Note that this does NOT return
 * an object, unlike xc_auth_credentials_load(), which does
 *
 * @see xc_auth_credentials_load()
 * @param $type
 *    Authentcation credentials type
 * @return
 *    Authentication credentials definition array
 */
function xc_auth_credentials_get($type) {
  $credentials = xc_auth_credentials_get_all();
  return $credentials[$type];
}

/**
 * Get an authentication credential definition
 *
 * @see xc_auth_credentials_get()
 * @param $type
 *    Authentcation credentials type
 * @return
 *    Authentication credentials definition object
 */
function xc_auth_credentials_load($type) {
  return (object) xc_auth_credentials_get($type);
}

/**
 * Get all authentication credentials definitions
 *
 * @return
 *    An array of all authentication credential definitions
 */
function xc_auth_credentials_get_all($update = FALSE) {
  static $cache;

  if (!isset($cache) || $update) {
    $cache = array();
    foreach (module_invoke_all('xc_auth_credentials') as $k => $v) {
      $cache[$k] = (object) $v;
    }
  }

  return $cache;
}

/**
 * Get all authentication credentials names
 *
 * @return
 *    An array of all authentication credential names with their machine names
 *    as keys
 */
function xc_auth_credentials_get_all_names() {
  $names = array();
  foreach (xc_auth_credentials_get_all() as $key => $value) {
    $names[$key] = $value['name'];
  }
  return $names;
}

/**
 * Authentication type form
 */
function xc_auth_type_form($form, &$form_state, $auth_type = NULL) {

  if (is_object($auth_type) && !empty($auth_type->method)) {
    $form_state['storage']['step'] = 1;
  }

  $auth_type = empty($form_state['values']['auth_type'])
    ? (empty($auth_type) ? new stdClass() : $auth_type)
    : $form_state['values']['auth_type'];

  $form['auth_type'] = array(
    '#type' => 'value',
    '#value' => $auth_type,
  );

  if (empty($form_state['storage']['step'])
       || $form_state['storage']['step'] == 0) {
    $form_state['storage']['step'] = 0;

    $form['method'] = array(
      '#type' => 'select',
      '#title' => t('Authentication method'),
      '#description' => t('Select authentication method to use for this authentication type'),
      '#options' => xc_auth_method_get_all_names(),
      '#required' => TRUE,
    );

    $submit_text = t('Continue');
  }
  elseif ($form_state['storage']['step'] == 1) {
    $method_name = !empty($auth_type->method)
      ? $auth_type->method
      : $form_state['values']['method'];
    $method = xc_auth_method_load($method_name);
    $credentials = xc_auth_credentials_load($method->credentials);

    $form['name'] = array(
      '#type' => 'textfield',
      '#title' => t('Name'),
      '#default_value' => isset($auth_type->name) ? $auth_type->name : '',
      '#required' => TRUE,
    );

    $form['description'] = array(
      '#type' => 'textarea',
      '#title' => t('Description'),
      '#default_value' => isset($auth_type->description) ? $auth_type->description : '',
    );

//    $form = array(
//      '#title' => t('Login form customization'),
//      '#collapsible' => TRUE,
//      '#collapsed' => TRUE
//    );
    //

    // Labels and descriptions for credentials
    $form['credentials'] = array(
      '#tree' => TRUE,
    );

    if (is_array($credentials->credentials)) {
      foreach ($credentials->credentials as $key => $value) {
        $form['credentials'][$key]['label'] = array(
          '#type' => 'textfield',
          '#title' => t('Label for @title', array('@title' => $value['title'])),
          '#default_value' =>
              isset($auth_type->credentials)
                && is_array($auth_type->credentials[$key])
                && !empty($auth_type->credentials[$key]['label'])
            ? $auth_type->credentials[$key]['label']
            : $value['label'],
          '#required' => TRUE,
        );
        $form['credentials'][$key]['description'] = array(
          '#type' => 'textarea',
          '#title' => t('Help text for @title', array('@title' => $value['title'])),
          '#default_value' =>
              isset($auth_type->credentials)
              && is_array($auth_type->credentials[$key])
              && !empty($auth_type->credentials[$key]['description'])
            ? $auth_type->credentials[$key]['description']
            : (isset($value['description']) ? $value['description'] : ''),
          '#rows' => 2,
          '#required' => FALSE,
        );
      }
    }
    else {
      $form['credentials']['info'] = array(
        '#type' => 'item',
        '#markup' => t('No login form credentials to edit'),
      );
    }

    $form['reset_password_text'] = array(
      '#type' => 'textarea',
      '#rows' => 2,
      '#title' => t('Lost or forgotten password reset text (HTML allowed)'),
      '#default_value' => isset($auth_type->reset_password_text) ? $auth_type->reset_password_text : '',
    );

    $form['help_text'] = array(
      '#type' => 'textarea',
      '#rows' => 2,
      '#title' => t('Help text/html'),
      '#default_value' => isset($auth_type->help_text) ? $auth_type->help_text : ''
    );

    $form['login_text'] = array(
      '#type' => 'textfield',
      '#title' => t('Login form submit button text'),
      '#default_value' => empty($auth_type->login_text)
        ? t('Login')
        : $auth_type->login_text,
      '#size' => 30,
    );

    $form['logout_text'] = array(
      '#type' => 'textfield',
      '#title' => t('Logout form submit button text'),
      '#default_value' => empty($auth_type->logout_text)
        ? t('Log out')
        : $auth_type->logout_text,
      '#size' => 30,
    );

    // Other form elements
    $form['data'] = array(
      //      '#type' => 'fieldset', //      '#title' => t('!name settings', array('!name' => $method->name)),
      '#tree' => TRUE,
      //      '#collapsible' => TRUE, //      '#collapsed' => TRUE
    );

    $method_form     = 'xc_auth_method_' . $method_name . '_form';
    $method_validate = 'xc_auth_method_' . $method_name . '_validate';
    $method_submit   = 'xc_auth_method_' . $method_name . '_submit';
    if (function_exists($method_form)) {
      $form['data'][$method_name] = array(
        '#tree' => TRUE,
      );
      $elements = call_user_func_array($method_form, array($form_state));
      foreach ($elements as $element => $element_value) {
        // get default value
        if (isset($auth_type->data)
            && is_array($auth_type->data)
            && !empty($auth_type->data[$method_name][$element])) {
          $default_value = $auth_type->data[$method_name][$element];
        }
        else {
          $default_value = isset($form['data'][$method_name][$element]['#default_value'])
            ? $form['data'][$method_name][$element]['#default_value']
            : '';
        }

        $form['data'][$method_name][$element] = $element_value;
        $form['data'][$method_name][$element]['#default_value'] = $default_value;
      }
    }

    $form['permissions'] = array(
      '#type' => 'fieldset',
      '#title' => t('Permissions automatically applied to new users'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );

    $roles = array();
    $result = db_query('SELECT rid, name FROM {role}');
    foreach ($result as $role) {
      $roles[$role->rid] = t($role->name);
    }

    $form['permissions']['roles'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Roles to assign to user upon registration or first login'),
      '#options' => $roles,
      '#default_value' => isset($auth_type->roles) && is_array($auth_type->roles)
        ? $auth_type->roles
        : array(DRUPAL_AUTHENTICATED_RID => DRUPAL_AUTHENTICATED_RID),
    );

    $form['permissions']['auto_create_account'] = array(
      '#type' => 'checkbox',
      '#title' => t('Automatically create accounts for users on first login'),
      '#description' => t('Creates an account for authenticated users after their first login. If this option is not set, a user with valid credentials may still receive an "incorrect login" error.'),
      '#default_value' => !isset($auth_type->auto_create_account)
        ? 1
        : $auth_type->auto_create_account
    );

    $form['permissions']['auto_load_values'] = array(
      '#type' => 'checkbox',
      '#title' => t('Automatically load safe to store values of credentials'),
      '#description' => t('Some values for credentials, such as the username, are stored by default. Disabling this feature is not recommended because it would require that a user type in both username and password instead of just a password on certain forms.'),
      '#default_value' => !isset($auth_type->auto_load_values)
        ? 1
        : $auth_type->auto_load_values
    );

    $form['response'] = array(
      '#type' => 'fieldset',
      '#title' => t('Response messages'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );

    $form['response']['login_incorrect_text'] = array(
      '#type' => 'textfield',
      '#title' => t('Incorrect or unmatched login credentials error text'),
      '#default_value' => isset($auth_type->login_incorrect_text)
        ? $auth_type->login_incorrect_text
        : t('Incorrect or unmatched login credentials'),
      '#size' => 100,
    );

    $form['response']['login_success_text'] = array(
      '#type' => 'textfield',
      '#title' => t('Successful login text'),
      '#default_value' => isset($auth_type->login_success_text)
        ? $auth_type->login_success_text
        : t('Login successful'),
      '#size' => 100,
    );

    $form['response']['login_failure_text'] = array(
      '#type' => 'textfield',
      '#title' => t('Failed or invalid login text'),
      '#default_value' => isset($auth_type->login_failure_text)
        ? $auth_type->login_failure_text
        : t('Failed or invalid login'),
      '#size' => 100,
    );

    // Set validate function, so that method-specific function does not change it
    $form['#validate'][] = 'xc_auth_type_form_validate';

    // Set method-specific validate function
    if (function_exists($method_validate)) {
      $form['#validate'][] = $method_validate;
    }

    // Set submit function, so that method-specific function does not change it
    $form['#submit'][] = 'xc_auth_type_form_submit';

    // Set method-specific submit function
    if (function_exists($method_submit)) {
      $form['#submit'][] = $method_submit;
    }

    $submit_text = !empty($auth_type->tid)
      ? t('Save')
      : t('Add authentication type');
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => $submit_text,
  );

  return $form;
}

/**
 * Authentication type form validation handler
 */
function xc_auth_type_form_validate($form, &$form_state) {
  if ($form_state['storage']['step'] == 0) {
    $auth_type = &$form_state['values']['auth_type'];
    $auth_type->method = check_plain($form_state['values']['method']);

    $form_state['storage']['step'] = 1;
  }
  elseif ($form_state['storage']['step'] == 1) {
    $form_state['storage']['step'] = 2;
  }
}

/**
 * Authentication type form submission handler
 */
function xc_auth_type_form_submit($form, &$form_state) {
  if ($form_state['storage']['step'] != 2) {
    $form_state['rebuild'] = TRUE;
    return;
  }

  if ($form_state['storage']['step'] == 2) {
    $values = $form_state['values'];
    // Ready to save the authentication type
    $auth_type = &$form_state['values']['auth_type'];
    $auth_type->name = check_plain($values['name']);
    $auth_type->description = check_plain($values['description']);
    $auth_type->data = serialize($values['data']);
    $auth_type->roles = array();
    foreach ($values['roles'] as $role => $active) {
      if ($active) {
        $auth_type->roles[$role] = $role;
      }
    }
    $auth_type->roles = serialize($auth_type->roles);
    $auth_type->credentials = serialize($values['credentials']);
    $auth_type->login_text = $values['login_text'];
    $auth_type->logout_text = $values['logout_text'];
    if (isset($values['auto_load_values'])) {
      $auth_type->auto_load_values = $values['auto_load_values'];
    }
    if (isset($values['auto_create_account'])) {
      $auth_type->auto_create_account = $values['auto_create_account'];
    }
    $auth_type->reset_password_text = $values['reset_password_text'];
    $auth_type->login_incorrect_text = $values['login_incorrect_text'];
    $auth_type->login_failure_text = $values['login_failure_text'];
    $auth_type->login_success_text = $values['login_success_text'];
    $auth_type->help_text = $values['help_text'];

    $word = empty($auth_type->tid) ? 'create' : 'update';
    if (empty($auth_type->tid)) {
      $result = drupal_write_record('xc_auth_type', $auth_type);
    }
    else {
      $result = drupal_write_record('xc_auth_type', $auth_type, 'tid');
    }

    if ($result) {
      if ($word == 'create') {
        drupal_set_message(
          t('%name login form created, make sure to configure !blocks for user login',
          array('%name' => $auth_type->name, '!blocks' => l('login blocks and pages', 'admin/xc/auth/block')))
        );
      }
      elseif ($word == 'update') {
        drupal_set_message(
          t('%name login form updated, make sure to update !blocks for users login',
          array('%name' => $auth_type->name, '!blocks' => l('login blocks and pages', 'admin/xc/auth/block')))
        );
      }
    }
    else {
      if ($word == 'create') {
        drupal_set_message(t("Unexpected error. Unable to create login form ."));
      }
      elseif ($word == 'update') {
        drupal_set_message(t("Unexpected error. Unable to update login form ."));
      }
    }

    // Clear storage to end the multi-form
    unset($form_state['storage']);

    // Rebuild menus
    menu_rebuild();

    // Return to listing of authentication types
    $form_state['redirect'] = 'admin/xc/auth/type';
  }
}

/**
 * List all authentication types
 */
function xc_auth_type_list() {
  $header = array(
    t('Name'),
    t('Method'),
    t('Credential Prompts'),
    t('NCIP Server'),
    t('Type'),
    array(
      'data' => t('Operations'),
      'colspan' => 3,
    ),
  );
  $rows = array();
  $auth_types = xc_auth_type_get_all();

  if (empty($auth_types)) {
    drupal_set_message(t('No authentication types are on this system. You must first !create an authentication type.',
      array('!create' => l(t('create'), 'admin/xc/auth/type/add'))),
      'warning');
  }

  foreach ($auth_types as $auth_type_name => $auth_type) {
    $method = xc_auth_method_load($auth_type->method);
    $credentials = xc_auth_credentials_load($method->credentials);
    $credentials_name = $credentials->name;
    $labels = array();
    foreach ($auth_type->credentials as $crd) {
      $labels[] = $crd['label'];
    }
    if ($labels) {
      $credentials_name .=  ' (' . implode('/', $labels) . ')';
    }
    if ($auth_type->method == 'ncip_provider') {
      $ncip_provider = xc_ncip_provider_load($auth_type->data['ncip_provider']['ncip_provider_id']);
      $ncip_server = $ncip_provider->name;
      if ($auth_type->data['ncip_provider']['ncip_provider_auth_type'] == 'ldap') {
        $ncip_auth_type = 'LDAP';
      }
      elseif ($auth_type->data['ncip_provider']['ncip_provider_auth_type'] == 'default') {
        $ncip_auth_type = 'Default';
      }
      else {
        $ncip_auth_type = t('Unknown');
      }
    }
    else {
      $ncip_server = '';
      $ncip_auth_type = '';
    }
    $rows[] = array(
      $auth_type->name,
      $method->name,
      $credentials_name,
      $ncip_server,
      $ncip_auth_type,
      l(t('view'), 'admin/xc/auth/type/' . $auth_type_name),
      l(t('edit'), 'admin/xc/auth/type/' . $auth_type_name . '/edit'),
      l(t('delete'), 'admin/xc/auth/type/' . $auth_type_name . '/delete'),
    );
  }

  return theme('table', array('header' => $header, 'rows' => $rows));
}

/**
 * List and reorder all authentication types
 */
function xc_auth_type_list_form($form, &$form_state) {
  $form = array(
    //    '#theme' => 'xc_auth_type_list_form',
    '#tree' => TRUE,
  );

  $auth_types = xc_auth_type_get_all();
  $weight_delta = count($auth_types);
  foreach ($auth_types as $auth_type_id => $auth_type) {
    $method = xc_auth_method_load($auth_type->method);
    $credentials = xc_auth_credentials_load($method->credentials);
    $credentials_name = $credentials->name;
    $labels = array();
    foreach ($auth_type->credentials as $crd) {
      $labels[] = $crd['label'];
    }
    if ($labels) {
      $credentials_name .=  ' (' . implode('/', $labels) . ')';
    }
    if ($auth_type->method == 'ncip_provider') {
      $ncip_provider = xc_ncip_provider_load($auth_type->data['ncip_provider']['ncip_provider_id']);
      $ncip_server = $ncip_provider->name;
      if ($auth_type->data['ncip_provider']['ncip_provider_auth_type'] == 'ldap') {
        $ncip_auth_type = 'LDAP';
      }
      elseif ($auth_type->data['ncip_provider']['ncip_provider_auth_type'] == 'default') {
        $ncip_auth_type = 'Default';
      }
      else {
        $ncip_auth_type = t('Unknown');
      }
    }
    else {
      $ncip_server = '';
      $ncip_auth_type = '';
    }

    $form['types'][$auth_type_id] = array(
      'name' => array('#markup' => $auth_type->name),
      'method' => array('#markup' => $method->name),
      'credentials' => array('#markup' => $credentials_name),
      'ncip_server' => array('#markup' => $ncip_server),
      'ncip_auth_type' => array('#markup' => $ncip_auth_type),
      'view' => array('#markup' => l(t('view'), 'admin/xc/auth/type/' . $auth_type_id)),
      'edit' => array('#markup' => l(t('edit'), 'admin/xc/auth/type/' . $auth_type_id . '/edit')),
      'delete' => array('#markup' => l(t('delete'), 'admin/xc/auth/type/' . $auth_type_id . '/delete')),
      'weight' => array(
        '#type' => 'weight',
        '#default_value' => $auth_type->weight,
        '#delta' => $weight_delta,
      ),
    );
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save order'),
  );

  return $form;
}

/**
 * Submit new order for list
 */
function xc_auth_type_list_form_submit($form, &$form_state) {
  $types = $form_state['values']['types'];
  foreach ($types as $tid => $type) {
    // TODO Please review the conversion of this statement to the D7 database API syntax.
    /* db_query('UPDATE {xc_auth_type} SET weight = %d WHERE tid = %d', $type['weight'], $tid) */
    db_update('xc_auth_type')
      ->fields(array(
          'weight' => $type['weight'],
        ))
      ->condition('tid', $tid)
      ->execute();
  }
  drupal_set_message(t('Order of login forms has been successfully updated.'));
}

/**
 * Theme authentication type list with ordering
 */
function theme_xc_auth_type_list_form($variables) {
  $form = $variables['form'];
  drupal_add_tabledrag('authtype-sort', 'order', 'sibling', 'sort');

  $rows = array();
  $header = array(t('Name'), t('Method'), t('Credential Prompts'), t('NCIP Server'), t('Type'), array(
      'data' => t('Operations'),
      'colspan' => 4,
  ));

  $auth_types = xc_auth_type_get_all();
  if (empty($auth_types)) {
    drupal_set_message(t('No authentication types are on this system. You must first !create an authentication type.',
      array('!create' => l(t('create'), 'admin/xc/auth/type/add'))),
      'warning');
  }

  if (isset($form['types'])) {
    foreach (element_children($form['types']) as $key) {
      $type = &$form['types'][$key];
      $type['weight']['#attributes']['class'] = array('sort');

      $cells = array(
        drupal_render($type['name']),
        drupal_render($type['method']),
        drupal_render($type['credentials']),
        drupal_render($type['ncip_server']),
        drupal_render($type['ncip_auth_type']),
        drupal_render($type['view']),
        drupal_render($type['edit']),
        drupal_render($type['delete']),
        drupal_render($type['weight']),
      );

      $rows[] = array(
        'data' => $cells,
        'class' => array('draggable'),
      );
    }
  }

  $output = theme('table', array(
    'header' => $header,
    'rows' => $rows,
    'attributes' => array('id' => 'authtype-sort')
  ));

  $output .= drupal_render_children($form);
  return $output;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_auth_type_reorder_form(&$form_state) {
  $form = array(
    '#theme' => 'xc_auth_type_reorder_form',
    '#tree' => TRUE,
  );

  $auth_types = xc_auth_type_get_all();
  $weight_delta = count($auth_types);
  foreach ($auth_types as $auth_type_id => $auth_type) {
    $method = xc_auth_method_load($auth_type->method);
    $form['types'][$auth_type_id] = array(
      'type' => array('#value' => $auth_type->name),
      'method' => array('#value' => $method->name),
      'desc' => array('#value' => $auth_type->description),
      'view' => array('#value' => l(t('view'), 'admin/xc/auth/type/' . $auth_type_id)),
      'edit' => array('#value' => l(t('edit'), 'admin/xc/auth/type/' . $auth_type_id . '/edit')),
      'delete' => array('#value' => l(t('delete'), 'admin/xc/auth/type/' . $auth_type_id . '/delete')),
      'weight' => array(
        '#type' => 'weight',
        '#default_value' => $auth_type->weight,
        '#delta' => $weight_delta,
      ),
    );
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save order'),
  );

  return $form;
}

/**
 * Save the order of types
 *
 * @param $form
 * @param $form_state
 */
function xc_auth_type_reorder_form_submit($form, &$form_state) {
  $id = $form_state['values']['facet_id'];
  $types = $form_state['values']['types'];
  foreach ($types as $tid => $type) {
    // TODO Please review the conversion of this statement to the D7 database API syntax.
    /* db_query('UPDATE {xc_auth_type} SET weight = %d WHERE tid = %d', $type['weight'], $tid) */
    db_update('xc_auth_type')
      ->fields(array(
          'weight' => $type['weight'],
        ))
      ->condition('tid', $tid)
      ->execute();
  }
  drupal_set_message(t('Order of remote authentication types has been successfully updated.'));
}

/**
 * Themeing xc_auth_type_reorder_form form
 *
 * @param $form (array)
 *   The FAPI form array
 */
function theme_xc_auth_type_reorder_form($variables) {
  $form = $variables['form'];
  drupal_add_tabledrag('authtype-sort', 'order', 'sibling', 'sort');

  $rows = array();
  $auth_types = xc_auth_type_get_all();

  if (empty($auth_types)) {
    drupal_set_message(t('No authentication types are on this system. You must first !create an authentication type.',
      array('!create' => l(t('create'), 'admin/xc/auth/type/add'))),
      'warning');
  }

  foreach (element_children($form['types']) as $key) {
    $type = &$form['types'][$key];
    $type['weight']['#attributes']['class'] = 'sort';

    $cells = array(
      drupal_render($type['type']),
      drupal_render($type['method']),
      drupal_render($type['desc']),
      drupal_render($type['view']),
      drupal_render($type['edit']),
      drupal_render($type['delete']),
      drupal_render($type['weight']),
    );

    $rows[] = array(
      'data' => $cells,
      'class' => array('draggable'),
    );
  }

  $output = theme('table', array('header' => array(t('Name'), t('Method'), t('Description'), array(
        'data' => t('Operations'),
        'colspan' => 4,
        'style' => 'text-align: center;',
      )),
      'rows' => $rows,
      'attributes' => array('id' => 'authtype-sort')
    )
  );

  $output .= drupal_render_children($form);
  return $output;
}

/**
 * View an authentication type
 *
 * @param $auth_type
 *    Authentiction type object
 */
function xc_auth_type_view($auth_type) {
  $header = array(t('Property'), t('Value'));
  $rows = array();
  $output = '';

  $method = xc_auth_method_load($auth_type->method);
  $credentials = xc_auth_credentials_load($method->credentials);

  $rows[] = array(t('Name'), $auth_type->name);
  if (!empty($auth_type->description)) {
    $rows[] = array(t('Description'), $auth_type->description);
  }

  if (!empty($credentials)) {
    $rows[] = array(array('data' => t('Credentials:'), 'colspan' => 2));
    $rows[] = array(t('name'), $credentials->name);
    $rows[] = array(t('description'), $credentials->description);
    foreach ($auth_type->credentials as $credential => $attributes) {
      $rows[] = array(array(
            'data' => sprintf('<em>%s</em>', $credential), 
            'colspan' => 2,
            'style' => 'text-indent: 10px;'));
      foreach ($attributes as $name => $value) {
        $rows[] = array(array('data' => $name, 'style' => 'text-indent: 20px;'), $value);
      }
    }
  }

  $rows[] = array(
    t('Lost or forgotten password reset text (HTML allowed)'),
    $auth_type->reset_password_text,
  );

  $rows[] = array(
    t('Login form submit button text'),
    $auth_type->login_text,
  );

  $rows[] = array(
    t('Logout form submit button text'),
    $auth_type->logout_text,
  );

  $method_form = 'xc_auth_method_' . $auth_type->method . '_form';
  $form_state = array();
  if (function_exists($method_form)) {
    $elements = call_user_func_array($method_form, array(&$form_state));
    foreach ($elements as $element => $element_value) {
      $ncip_auth_type = NULL;
      $ncip_server = NULL;
      if ($auth_type->method == 'ncip_provider' && $element == 'ncip_provider_auth_type') {
        if (isset($auth_type->data['ncip_provider']['ncip_provider_auth_type'])) {
          if ($auth_type->data['ncip_provider']['ncip_provider_auth_type'] == 'ldap') {
            $ncip_auth_type = 'LDAP';
          }
          elseif ($auth_type->data['ncip_provider']['ncip_provider_auth_type'] == 'default') {
            $ncip_auth_type = t('Default');
          }
        }
      }

      if ($auth_type->method == 'ncip_provider' && $element == 'ncip_provider_id') {
        if (isset($auth_type->data['ncip_provider']['ncip_provider_id'])) {
          $ncip_provider = xc_ncip_provider_load($auth_type->data['ncip_provider']['ncip_provider_id']);
          $ncip_server = $ncip_provider->name;
        }
      }

      if ($ncip_auth_type) {
        $element_actual_value = $ncip_auth_type;
      }
      elseif ($ncip_server) {
        $element_actual_value = $ncip_server;
      }
      elseif (isset($auth_type->data[$auth_type->method][$element])) {
        $element_actual_value = $auth_type->data[$auth_type->method][$element];
      }
      else {
        $element_actual_value = '';
      }

      $rows[] = array(
        $element_value['#title'],
        $element_actual_value,
      );
    }
  }

  $roles = array();
  if (is_array($auth_type->roles)) {
    // TODO Please convert this statement to the D7 database API syntax.
    $result = db_query('SELECT rid, name FROM {role}');
    foreach ($result as $role) {
      if (in_array($role->rid, $auth_type->roles)) {
        $roles[] = $role->name;
      }
    }
  }

  $rows[] = array(
    t('Roles to assign to user upon registration or first login'),
    theme('item_list', array('items' => $roles)),
  );

  $rows[] = array(
    t('Incorrect or unmatched login credentials error text'),
    $auth_type->login_incorrect_text,
  );

  $rows[] = array(
    t('Successful login text'),
    $auth_type->login_success_text,
  );

  $rows[] = array(
    t('Failed or invalid login text'),
    $auth_type->login_failure_text,
  );

  $rows[] = array(t('Method'), $method->name);
  $rows[] = array(t('Help text'), $auth_type->help_text);
  $rows[] = array(t('Auto load values?'), ($auth_type->auto_load_values ? t('yes') : t('no')));
  $rows[] = array(t('Auto create account?'), ($auth_type->auto_create_account ? t('yes') : t('no')));

  if (isset($auth_type->data['ncip_provider'])) {
    $ncip_provider = xc_ncip_provider_load($auth_type->data['ncip_provider']['ncip_provider_id']);
    $url = $ncip_provider->host . ':' . $ncip_provider->port . $ncip_provider->path;
    $rows[] = array(
      t('NCIP provider'),
      l($ncip_provider->name, 'admin/xc/ncip/provider/' . $ncip_provider->ncip_provider_id)
        . ' (' . $url . ')'
    );
    $rows[] = array(
      t('NCIP server authentication type (default or LDAP)'),
      $auth_type->data['ncip_provider']['ncip_provider_auth_type']
    );
  }

  $output = theme('table', array('header' => $header, 'rows' => $rows));
  return $output;
}

/**
 * Authentication type deletion form
 */
function xc_auth_type_delete_form($form, &$form_state, $auth_type) {
  $form['xc_auth_type'] = array(
    '#type' => 'value',
    '#value' => $auth_type,
  );
  return confirm_form($form,
    t('Are you sure you want to delete the %name authentication type?',
      array('%name' => $auth_type->name)),
    'admin/xc/auth/type', '', t('Delete'), t('Cancel'));
}

/**
 * Authentication type deletion form submission
 */
function xc_auth_type_delete_form_submit($form, &$form_state) {
  $auth_type = $form_state['values']['xc_auth_type'];

  // Delete authentication type
  $sql = 'DELETE FROM {xc_auth_type} WHERE tid = %d';
  // TODO Please review the conversion of this statement to the D7 database API syntax.
  /* db_query($sql, $auth_type->tid) */
  db_delete('xc_auth_type')
    ->condition('tid', $auth_type->tid)
    ->execute();

  // Delete all authentication users associated with the authentication type
  $sql = 'DELETE FROM {xc_auth_user} WHERE tid = %d';
  // TODO Please review the conversion of this statement to the D7 database API syntax.
  /* db_query($sql, $auth_type->tid) */
  db_delete('xc_auth_user')
    ->condition('tid', $auth_type->tid)
    ->execute();

  // Rebuild menus
  menu_rebuild();

  $form_state['redirect'] = 'admin/xc/auth/type';
  drupal_set_message(t('%name authentication type deleted.',
    array('%name' => $auth_type->name)));
}

/**
 * Implements hook_menu().
 */
function xc_auth_menu() {
  $auth_types = xc_auth_type_get_all();
  $login_blocks = xc_auth_login_block_get_all();

  $items['admin/xc/auth'] = array(
    'title' => 'Authentication',
    'description' => 'Configure the “Login to your ILS” page.  Prerequisite: The NCIP functionality is configured (see NCIP admin menu choice)',
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('administer xc authentication'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 9,
  );

  $items['admin/xc/auth/settings'] = array(
    'title' => 'Settings',
    'description' => 'Manage and configure authentication settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_auth_settings_form'),
    'access arguments' => array('administer xc authentication'),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 0,
  );

  $items['admin/xc/auth/type'] = array(
    'title' => 'Login forms',
    'description' => 'Setup and configure login forms for remote authentication systems',
    'access arguments' => array('administer xc authentication'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_auth_type_list_form'),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 2,
  );

  $items['admin/xc/auth/type/list'] = array(
    'title' => 'List',
    'access arguments' => array('administer xc authentication'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_auth_type_list_form'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );

  $items['admin/xc/auth/type/add'] = array(
    'title' => 'Add login form',
    'access arguments' => array('administer xc authentication'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_auth_type_form'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
  );

//  $items['admin/xc/auth/type/reorder'] = array(
//    'title' => 'Reorder',
//    'access arguments' => array('administer xc authentication'),
//    'page callback' => 'drupal_get_form',
//    'page arguments' => array('xc_auth_type_reorder_form'),
//    'type' => MENU_LOCAL_TASK,
//    'weight' => 2
//  );

  $items['admin/xc/auth/type/%xc_auth_type'] = array(
    'title callback' => 'xc_auth_type_title',
    'title arguments' => array(4),
    'page callback' => 'xc_auth_type_view',
    'page arguments' => array(4),
    'access arguments' => array('administer xc authentication'),
    'type' => MENU_CALLBACK,
  );

  $items['admin/xc/auth/type/%xc_auth_type/view'] = array(
    'title' => 'View',
    'page callback' => 'xc_auth_type_view',
    'page arguments' => array(4),
    'access arguments' => array('administer xc authentication'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 1,
  );

  $items['admin/xc/auth/type/%xc_auth_type/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_auth_type_form', 4),
    'access arguments' => array('administer xc authentication'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
  );

  $items['admin/xc/auth/type/%xc_auth_type/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_auth_type_delete_form', 4),
    'access arguments' => array('administer xc authentication'),
    'type' => MENU_CALLBACK,
  );

  if (variable_get('xc_auth_show_login_tabs', 0)) {
    $auth_type = reset($auth_types);
    $items['xc/login'] = array(
      'title' => 'Login',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('xc_auth_login_form', $auth_type),
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
    );
  }
  else {
    $items['xc/login'] = array(
      'title' => 'Login',
      'description' => 'External authentication login',
      'page callback' => 'xc_auth_login_page',
      'type' => MENU_CALLBACK,
      'access callback' => TRUE,
      'weight' => -100,
    );
  }

  $items['xc/logout'] = array(
    'title' => 'Logout',
    'description' => 'External authentication logout',
    'page callback' => 'xc_auth_logout_page',
    'type' => MENU_CALLBACK,
    'access callback' => TRUE,
    'weight' => 100,
  );

  $items['xc/authlink/%'] = array(
    'title' => 'Login',
    'description' => 'A link based login',
    'page callback' => 'xc_auth_authenticate_by_link',
    'page arguments' => array(2),
    'type' => MENU_CALLBACK,
    'access callback' => TRUE,
    'weight' => -100,
  );

  // Links for authentication types
  $i = 0;
  foreach ($auth_types as $auth_type) {
    $task_type = $i == 0 ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK;
    $items['xc/login/' . $auth_type->tid] = array(
      'title' => $auth_type->name,
      'page callback' => 'drupal_get_form',
      'page arguments' => array('xc_auth_login_form', $auth_type, 'login'),
      'access callback' => TRUE,
      'type' => variable_get('xc_auth_show_login_tabs', 0) ? $task_type : MENU_CALLBACK,
      'weight' => $i,
    );
    $items['xc/login/' . $auth_type->tid . '/refresh'] = array(
      'title' => $auth_type->name,
      'page callback' => 'drupal_get_form',
      'page arguments' => array('xc_auth_login_form', $auth_type, 'refresh'),
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
    );

    $items['xc/logout/' . $auth_type->tid] = array(
      'title' => $auth_type->name,
      'page callback' => 'xc_auth_logout_page',
      'page arguments' => array($auth_type),
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
    );
    $i++;
  }

  // Links for login web pages
  foreach ($login_blocks as $login_block) {
    if (is_string($login_block->url)) {
      $items[$login_block->url] = array(
        'title' => $login_block->name,
        'page callback' => 'xc_auth_login_block_render',
        'page arguments' => array($login_block),
        'access callback' => TRUE,
        'type' => MENU_CALLBACK,
      );
    }
  }

  $items['admin/xc/auth/block'] = array(
    'title' => 'Login blocks and pages',
    'description' => 'Create and manage login form and pages for remote authentication systems',
    'page callback' => 'xc_auth_login_block_list',
    'type' => MENU_NORMAL_ITEM,
    'access arguments' => array('administer xc authentication'),
    'weight' => 3,
  );

  $items['admin/xc/auth/block/list'] = array(
    'title' => 'List',
    'page callback' => 'xc_auth_login_block_list',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'access arguments' => array('administer xc authentication'),
    'weight' => 0,
  );

  $items['admin/xc/auth/block/add'] = array(
    'title' => 'Add login block',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_auth_login_block_form'),
    'type' => MENU_LOCAL_TASK,
    'access arguments' => array('administer xc authentication'),
    'weight' => 1,
  );

  $items['admin/xc/auth/block/%xc_auth_login_block/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_auth_login_block_form', 4),
    'access arguments' => array('administer xc authentication'),
    'type' => MENU_CALLBACK,
    'weight' => 2,
  );

  $items['admin/xc/auth/block/%xc_auth_login_block/make-default'] = array(
    'title' => 'Make default',
    'page callback' => 'xc_auth_login_block_make_default',
    'page arguments' => array(4, TRUE),
    'access arguments' => array('administer xc authentication'),
    'type' => MENU_CALLBACK,
  );

  $items['admin/xc/auth/block/%xc_auth_login_block/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_auth_login_block_delete_form', 4),
    'access arguments' => array('administer xc authentication'),
    'type' => MENU_CALLBACK,
  );

  $items['admin/xc/auth/authlink'] = array(
    'title' => 'Login by link settings',
    'description' => 'Settings of authentication through xc/authlink',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xc_auth_authlink_settings'),
    'type' => MENU_LOCAL_TASK,
    'access arguments' => array('administer xc authentication'),
    'weight' => 100,
  );

  return $items;
}

/**
 * Get all authentication users for a Drupal user
 *
 * @param $uid
 *    Drupal user id
 * @return
 *    Array of authentication user objects
 */
function xc_auth_user_get_all($uid, $tid = NULL) {
  $sql = 'SELECT uid, tid, identity, stored_values FROM {xc_auth_user} WHERE uid = :uid';
  $result = null;
  if ($tid) {
    $sql .= ' AND tid = :tid';
    $result = db_query($sql, array(':uid'=>$uid,':tid'=> $tid));
  }
  else {
    $result = db_query($sql, array(':uid'=>$uid));
  }

  $auth_users = array();
  foreach ($result as $auth_user) {
    $auth_user->stored_values = unserialize($auth_user->stored_values);
    $auth_users[$auth_user->tid] = $auth_user;
  }
  return $auth_users;
}

/**
 * Authentication a user
 *
 * @param $auth (object)
 *    Authentication type for login (see xc_auth_type table)
 * @param $values
 *    Array of values for login credentials. Keys: attempt_drupal_login,
 *    user, pass, op, xc_auth_types (array of objects), submit (the label of submit button),
 *    original, destination, form_build_id, form_id.
 * @param $data
 *    Array of additional data or information to pass to login functions
 *
 * @return
 *    Authentication status, either XC_AUTH_LOGIN_SUCCESS, XC_AUTH_LOGIN_INCORRECT,
 *    or XC_AUTH_LOGIN_FAILURE
 */
function xc_auth_authenticate($auth, $values, $data = array()) {
  global $user, $_xc_auth_authenticated;

  // in XC modules only xc_ncip_provider implements it, see xc_ncip_provider_xc_login
  $modules = module_implements('xc_login');
  foreach ($modules as $module) {
    $function = $module . '_xc_login';
    $xc_login_response = $function($auth, $values, $data);

    // Any successful result means it is authenticated
    switch ($xc_login_response) {
      case XC_AUTH_LOGIN_SUCCESS:
        $result = $xc_login_response;
        break;

      case XC_AUTH_LOGIN_INCORRECT:
        $result = (isset($result) && $result == XC_AUTH_LOGIN_SUCCESS) ? $result : $xc_login_response;
        break;

      case XC_AUTH_LOGIN_FAILURE:
      default:
        $result = (isset($result) && ($result == XC_AUTH_LOGIN_INCORRECT || $result == XC_AUTH_LOGIN_SUCCESS))
          ? $result
          : $xc_login_response;
        break;
    }
  }

  // If authentication was unsuccessful, return correct error
  if ($result != XC_AUTH_LOGIN_SUCCESS) {
    return $result;
  }

  $method = xc_auth_method_load($auth->method);

  $credentials = xc_auth_credentials_load($method->credentials);
  // Build array of values that are safe to store
  $safe_to_store_values = array();
  if (is_array($credentials->credentials)) {
    foreach ($credentials->credentials as $k => $v) {
      if ($v['stored']) {
        $safe_to_store_values[$k] = $values[$k];
      }
    }
  }

  // Store data from login hook into session
  $_SESSION['xc_auth_types'][$auth->tid]['data'] = $data;

  // Find the identity of a user, what a user is called in the system, based
  // on their credentials
  $function = 'xc_auth_identify_' . $method->credentials;
  $identity = function_exists($function)
    ? call_user_func($function, $values)
    : xc_auth_identify($credentials, $values);

  // Lookup a Drupal user for the identity, if possible
  $sql = "SELECT uid FROM {xc_auth_user} WHERE identity = :identity AND tid = :tid";
  $uid = db_query($sql, array(':identity' => $identity, ':tid' => $auth->tid))->fetchField();

  if (empty($uid)) {
    // Since there is no Drupal user for this valid login, so associate it with
    // a new user if one is not already logged in, update the authentication
    // lookup table for users, and authenticate the user
    if (empty($user->uid)) {
      $username = _xc_auth_to_drupal($identity, $auth);
      $userinfo = array(
        'name' => $username,
        'pass' => user_password(),
        'init' => $username,
        'status' => 1,
        'roles' => $auth->roles,
        'authname_xc_auth' => $username,
        'access' => time(),
      );

      if (!$auth->auto_create_account) {
        return XC_AUTH_LOGIN_INCORRECT;
      }

      if (!$account = user_save('', $userinfo)) {
        return XC_AUTH_LOGIN_FAILURE;
      }
      $user = $account;
    }

    // Authorize the Drupal account to use the externally authenticated user
    xc_auth_authorize($auth, $identity, $user->uid, $safe_to_store_values);

    // Finish the Drupal authentication process
    user_login_finalize($values);
  }
  elseif ($user->uid == $uid) {
    // If logged in user is the same as requested user, then authenticate user
    // without any other Drupal necessities
  }
  elseif ($account = user_load($uid)) {
    // If there is another Drupal user to be logged in, authenticate that user,
    // if possible, and proceed to logging them in
    if (user_is_blocked($account->name)) {
      return XC_AUTH_LOGIN_FAILURE;
    }
    $user = $account;

    // Finish the Drupal authentication process
    user_login_finalize($values);
  }
  else {
    // No other situations to consider... or so far
  }

  // Get user information, from XC account module, if applicable
  if (module_exists('xc_account') && function_exists('xc_account_get_all')) {
    xc_account_get_all($user, $values, TRUE);
  }

  // Add identity to session, signifying that the user is currently logged in
  $_SESSION['xc_auth_types'][$auth->tid]['identity'] = $identity;

  // Insert safe to store values into session
  $_SESSION['xc_auth_types'][$auth->tid]['values'] = $safe_to_store_values;

  // Finally, authenticate the user
  $_xc_auth_authenticated = TRUE;

  // Authentication was successful
  return XC_AUTH_LOGIN_SUCCESS;
}

/**
 * Authentication a Drupal user
 *
 * @param $values
 *    Array of values for login credentials
 * @param $data
 *    Array of additional data or information to pass to login functions
 *
 * @return
 *    Authentication status, either XC_AUTH_LOGIN_SUCCESS, XC_AUTH_LOGIN_INCORRECT,
 *    or XC_AUTH_LOGIN_FAILURE
 */
function xc_auth_user_authenticate($values, $data = array()) {
  global $user;

  // If there is no username or password as expected by Drupal in the values
  // array return a failed login
  if (empty($values['user']) || empty($values['pass'])) {
    return XC_AUTH_LOGIN_FAILURE;
  }

  $uid = user_authenticate($values['user'], $values['pass']);
  if ($uid === FALSE) {
    return XC_AUTH_LOGIN_FAILURE;
  }
  $user = user_load($uid);

  // If an account is found with the matching username and password it
  // is successful, otherwise the credentials are wrong
  if ($user) {
    // Finalize the Drupal authentication process
    $edit = array();
    user_login_finalize($edit);

    // Authentication was successful
    return XC_AUTH_LOGIN_SUCCESS;
  }
  else {
    return XC_AUTH_LOGIN_INCORRECT;
  }
}

/**
 * De-authenticate a user
 *
 * @param $auth
 *    Authentication type for logout
 * @param $data
 *    Additional data to pass to logout functions
 */
function xc_auth_deauthenticate($auth = NULL, $data = array(), $account = NULL) {
  global $user;
  $account = empty($account) ? $user : $account;
  $auth = is_numeric($auth) ? xc_auth_type_load($auth) : $auth;
  $tid  = $auth ? $auth->tid : NULL;
  $auth_users = xc_auth_user_get_all($account->uid, $tid);

  $auth_types = array();
  foreach ($auth_users as $auth_user) {
    // If only one authentication type is being checked and this is not it,
    // then continue
    if ($auth && $auth_user->tid != $auth->tid) {
      continue;
    }

    // Load the authentication type
    $auth_type = xc_auth_type_load($auth_user->tid);

    // Log each authentication type user out
    // the current implementation is: xc_ncip_provider_xc_logout()
    module_invoke_all('xc_logout', $auth_type, $data);

    // Remove the authentication type identity and data from the session
    unset($_SESSION['xc_auth_types'][$auth_user->tid]['identity']);
    unset($_SESSION['xc_auth_types'][$auth_user->tid]['data']);
  }
}

/**
 * Authorize an authentication type, attaching it from a Drupal account
 *
 * @param $auth
 *    Authentication type
 * @param $identity
 *    Identity for user within Drupal
 * @param $safe_to_store_values
 *    Values for credentials (such as username) that are *safe* for Drupal
 *    to remember
 * @param $user_id
 *    Drupal user id
 */
function xc_auth_authorize($auth, $identity, $user_id, $safe_to_store_values = array()) {
  // Update the lookup table for authentication for users
  $sql = "DELETE FROM {xc_auth_user} WHERE tid = %d AND identity = '%s'";
  // TODO Please review the conversion of this statement to the D7 database API syntax.
  /* db_query($sql, $auth->tid, $identity) */
  db_delete('xc_auth_user')
    ->condition('tid', $auth->tid)
    ->condition('identity', $identity)
    ->execute();

  $record = new stdClass();
  $record->uid           = $user_id;
  $record->tid           = $auth->tid;
  $record->identity      = $identity;
  $record->stored_values = serialize($safe_to_store_values);
  drupal_write_record('xc_auth_user', $record);
}

/**
 * De-authorize an authentication type, detaching it from a Drupal account
 *
 * @param $auth
 *    Authentication type
 * @param $user_id
 *    Drupal user id
 */
function xc_auth_deauthorize($auth, $user_id) {
  // Remove from the lookup table for authentication for users
  $sql = 'DELETE FROM {xc_auth_user} WHERE tid = %d AND uid = %d';
  // TODO Please review the conversion of this statement to the D7 database API syntax.
  /* db_query($sql, $auth->tid, $user_id) */
  db_delete('xc_auth_user')
    ->condition('tid', $auth->tid)
    ->condition('uid', $user_id)
    ->execute();

  // Deauthenticate
  xc_auth_deauthenticate($auth);

  // Destroy all user/session knowledge of the external account
  unset($_SESSION['xc_auth_types'][$auth->tid]);
}

/**
 * Implements hook_block_info().
 */
function xc_auth_block_info() {
  $login_blocks = xc_auth_login_block_get_all();
  $blocks = array();
  foreach ($login_blocks as $login_block_id => $login_block) {
    $blocks['xc_login_' . $login_block->type . '_' . $login_block_id] = array(
      'info' => $login_block->name,
    );
  }
  return $blocks;
}

/**
 * Implements hook_block_configure().
 */
function xc_auth_block_configure($delta) {
  $form = array();
  if (substr($delta, 0, 9) == 'xc_login_') {
    $parts = explode('_', $delta);
    $type = $parts[2];
    $login_block_id = $parts[3];
    if (in_array($type, array('single', 'multiple', 'auto'))) {
      $form['xc_login_info'] = array(
        '#type' => 'info',
        '#title' => t('Configure login blocks and pages'),
        '#value' => t('More options available by !configuring the login web form.',
              array('!configuring' => l(t('configuring'), 'admin/xc/auth/block/' . $login_block_id . '/edit'))),
      );
    }
  }
  return $form;
}

/**
 * Implements hook_block_view().
 */
function xc_auth_block_view($delta) {
  if (substr($delta, 0, 9) == 'xc_login_') {
    $parts = explode('_', $delta);
    $type = $parts[2];
    $login_block_id = $parts[3];
    $login_block = xc_auth_login_block_get($login_block_id);
    if ($login_block) {
      return array(
        'subject' => $login_block->name,
        'content' => xc_auth_login_block_render($login_block),
      );
    }
  }
}

/**
 * Implements hook_block().
 */
function xc_auth_block_OLD($op = 'list', $delta = 0, $edit = array()) { }

/**
 * Implements hook_user_insert().
 */
function xc_auth_user_insert(&$edit, $account, $category) { }

/**
 * Implements hook_user_presave().
 */
function xc_auth_user_presave(&$edit, $account, $category) {
  $sql = 'DELETE FROM {xc_auth_user} WHERE uid = %d';
  // TODO Please review the conversion of this statement to the D7 database API syntax.
  /* db_query($sql, $account->uid) */
  db_delete('xc_auth_user')
    ->condition('uid', $account->uid)
    ->execute();
}

/**
 * Implements hook_user_cancel().
 */
function xc_auth_user_cancel($edit, $account, $method) {
  $sql = 'DELETE FROM {xc_auth_user} WHERE uid = %d';
  // TODO Please review the conversion of this statement to the D7 database API syntax.
  /* db_query($sql, $account->uid) */
  db_delete('xc_auth_user')
    ->condition('uid', $account->uid)
    ->execute();
}

/**
 * Implements hook_user_XXX().
 */
function xc_auth_user_XXX($edit, $account) {
  $form = array();
  drupal_set_title(strip_tags(theme('username', array('account' => $account))));

  // Deauthorizing accounts
  if (($user->uid && ($user->uid == $account->uid) &&
           user_access('edit own xc authenticated users')) ||
           user_access('edit all xc authenticated users')) {
    $auth_users = xc_auth_user_get_all($account->uid);
    foreach ($auth_users as $auth_user) {
      $auth_type = xc_auth_type_load($auth_user->tid);
      $form['auth_types']['tid_' . $auth_type->tid] = array(
        '#type' => 'fieldset',
        '#title' => $auth_type->name,
        '#collapsible' => TRUE,
        '#collapsed' => FALSE,
      );
      $form['auth_types']['tid_' . $auth_type->tid]['info'] = array(
        '#type' => 'item',
        '#markup' => t('Currently authorized to log in as <strong>!identity</strong>.  Deauthorizing prevent logging into this account and could also destroy all account settings!',
              array('!identity' => $auth_user->identity)),
      );
      $form_key = 'deauthorize_' . $auth_type->tid . '_' . $account->uid;
      $form['auth_types']['tid_' . $auth_type->tid][$form_key] = array(
        '#type' => 'submit',
        '#value' => t('Deauthorize') . ' ' . $auth_type->name,
        '#auth_user' => $auth_user,
      );
    }
  }
  return $form;
}

/**
 * Implements hook_user_login().
 */
function xc_auth_user_login(&$edit, $account) {
  // Insert "safe to store" values of remote accounts into user session
  $auth_users = xc_auth_user_get_all($account->uid);
  foreach ($auth_users as $auth_user) {
    $_SESSION['xc_auth_types'][$auth_user->tid]['values'] = $auth_user->stored_values;
  }
}

/**
 * Implements hook_user_logout().
 */
function xc_auth_user_logout($account) {
  // Log out of every authentication type
  xc_auth_logout();

  // Remove all user information from the session
  unset($_SESSION['xc_auth_types']);
}

/**
 * Implements hook_user_categories().
 */
function xc_auth_user_categories() {
  return array();
}

/**
 * Implements hook_user_load().
 */
function xc_auth_user_load($users) { }

/**
 * Implements hook_user_view().
 */
function xc_auth_user_view($account, $view_mode) {
  drupal_set_title(strip_tags(theme('username', array('account' => $account))));
}

/**
 * Implements hook_user().
 */
function xc_auth_user_OLD($op, &$edit, &$account, $category = NULL) {
  // TODO Remaining code in this function needs to be moved to the appropriate new hook function.
  global $user;
}

/**
 * Implements hook_form_alter().
 */
function xc_auth_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'user_profile_form' && $form['auth_types']) {
    $form['#submit'][] = 'xc_auth_deauthorize_from_user_profile_form';
  }
}

/**
 * Deauthorizes an authentication type from the user profile form
 */
function xc_auth_deauthorize_from_user_profile_form($form, &$form_state) {
  // Because of a bug in Drupal, this may not work if the administrator decides
  // to name two authentication types the *same* -- better to not name two
  // authentication types the same
  $parts = explode('_', $form_state['clicked_button']['#parents'][0]);
  if ($parts[0] == 'deauthorize') {
    $auth_user = $form_state['clicked_button']['#auth_user'];
    $auth_type = xc_auth_type_load($auth_user->tid); //_auth_type_load($parts[1]);
    $user_id   = $auth_user->uid; // $parts[2];
    xc_auth_deauthorize($auth_type, $user_id);
  }
}

/**
 * Log a user into a remote authentication system or Drupal
 *
 * @param $auth_types (array)
 * @param $values (array)
 * @param $attempt_drupal_login (boolean)
 *   Flag, if it should try log in to Drupal
 *
 * @return (boolean)
 *   TRUE if the authentication were successful, otherwise FALSE
 */
function xc_auth_login($auth_types = NULL, $form_values = array(), $type = 'login', $attempt_drupal_login = FALSE,
  $default_login_incorrect_text = NULL, $default_login_failure_text = NULL) {
  // Ensure array of authentication types
  if (is_object($auth_types)) {
    $auth_types = array($auth_types);
  }

  // Remvoe any empty elements from array
  $auth_types = array_filter($auth_types);

  $login_success_text = '';
  $login_errors = array();
  $login_incorrect_text = array();
  $login_failure_text = array();

  foreach ($auth_types as $auth_type) {
    $result = xc_auth_authenticate($auth_type, $form_values);

    switch ($result) {
      case XC_AUTH_LOGIN_SUCCESS:
        // Get message from auth type
        if ($auth_type->login_success_text) {
          $login_success_text = $auth_type->login_success_text;
        }

        // Login was successful
        if ($type == 'refresh') {
          drupal_set_message(t('Account refresh successful'));
        }
        else {
          drupal_set_message($login_success_text);
        }
        return TRUE;
        break;

      case XC_AUTH_LOGIN_INCORRECT:
        $login_errors[] = XC_AUTH_LOGIN_INCORRECT;
        // Get message from auth type
        if ($auth_type->login_incorrect_text) {
          $login_incorrect_text[] = $auth_type->name . ': ' . $auth_type->login_incorrect_text;
        }
        break;

      case XC_AUTH_LOGIN_FAILURE:
      default:
        $login_errors[] = XC_AUTH_LOGIN_FAILURE;
        // Get message from auth type
        if ($auth_type->login_failure_text) {
          $login_failure_text[] = $auth_type->name . ': ' . $auth_type->login_failure_text;
        }
        break;
    }
  }

  // Attempt to login to Drupal account using credentials
  if ($attempt_drupal_login) {
    $result = xc_auth_user_authenticate(array(
      'user' => $form_values['user'],
      'pass' => $form_values['pass'],
    ));

    switch ($result) {
      case XC_AUTH_LOGIN_SUCCESS:
        drupal_set_message(t('Drupal login successful.'));
        return TRUE;
        break;

      case XC_AUTH_LOGIN_INCORRECT:
        $login_errors[] = XC_AUTH_LOGIN_INCORRECT;
        $login_incorrect_text[] = t('Sorry, unrecognized Drupal username or password. <a href="@password">Have you forgotten your password?</a>',
          array('@password' => url('user/password')));
        break;

      case XC_AUTH_LOGIN_FAILURE:
        $login_errors[] = XC_AUTH_LOGIN_FAILURE;
        $login_failure_text[] = t('Sorry, Drupal login failed. Please try again.');
      default:
        break;
    }
  }

  $login_errors_text = array_merge($login_incorrect_text, $login_failure_text);
  if (!$login_errors_text && $type == 'refresh') {
    drupal_set_message(t('Account refresh unsuccessful'));
  }
  else {
    if ($default_login_incorrect_text && in_array(XC_AUTH_LOGIN_INCORRECT, $login_errors)) {
      drupal_set_message($default_login_incorrect_text, 'error');
    }
    else if ($default_login_failure_text && in_array(XC_AUTH_LOGIN_FAILURE, $login_errors)) {
      drupal_set_message($default_login_failure_text, 'error');
    }
    else {
      drupal_set_message(theme('item_list', array('items' => $login_errors_text)), 'error');
    }
  }

  return FALSE;
}

/**
 * Logout
 */
function xc_auth_logout($auth_type = NULL) {
  xc_auth_deauthenticate($auth_type);
}

/**
 * Implements hook_forms().
 */
function xc_auth_forms() {
  $forms = array();
  foreach (xc_auth_type_get_all() as $auth_type) {
    $forms['xc_auth_login_' . $auth_type->tid . '_form']['callback'] = 'xc_auth_login_form';
  }
  return $forms;
}

/**
 * Display all login forms on one page
 */
function xc_auth_login_forms($tid = NULL, $multiple = FALSE, $theme = 'fieldset', $collapsed = TRUE) {

  $output = '';

  // Authentication types
  $auth_types = xc_auth_type_get_all();
  if (empty($auth_types)) {
    if (user_access('administer xc authentication')) {
      drupal_set_message(
        t('No remote authentication systems or none configured for this form or page eiether !add a remote authentication system or !configure login web forms and page',
          array(
        '!add' => l(t('add an authentication type'), 'admin/xc/auth/type/add'),
        '!configure' => l(t('configure'), 'admin/xc/auth/block'),
      )
          ), 'warning');
    }
  }
  else {
    if ($tid !== NULL) {
      $tid = (array) $tid;
    }

    if (!$multiple && count($tid) == 1) {
      $auth_type = $auth_types[reset($tid)];
      $form_id = 'xc_auth_login_' . reset($tid) . '_form';
      $output = drupal_get_form($form_id, $auth_type);
    }
    else {
      foreach ($auth_types as $auth_type) {
        if (is_array($tid) && !in_array($auth_type->tid, $tid)) {
          continue;
        }
        $form_id = 'xc_auth_login_' . $auth_type->tid . '_form';
        $output .= $theme
          ? theme($theme,
            array('element' => array(
              '#title' => t($auth_type->name),
              '#value' => drupal_get_form($form_id, $auth_type),
              '#collapsible' => TRUE,
              '#collapsed' => $collapsed,
            )))
          : drupal_get_form($form_id, $auth_type);
      }
    }
  }

  return $output;
}

/**
 * Login form
 */
function xc_auth_login_form($form, &$form_state, $auth_type = NULL, $type = 'login', $hide_safe_to_store_values = TRUE) {
  if (!$auth_type) {
    $form['info'] = array(
      '#type' => 'item',
      '#description' => t('No authentication type specified.'),
    );
    return $form;
  }

  $form['#attributes']['class'] = 'xc-auth-login-form';

  $method = xc_auth_method_load($auth_type->method);
  $credentials = xc_auth_credentials_load($method->credentials);
  $keys = array('roles', 'data', 'credentials');
  foreach ($keys as $key) {
    if (is_string($auth_type->$key)) {
      $auth_type->$key = unserialize($auth_type->$key);
    }
  }

  // If a user has already been authenticated with this type
  if ($type == 'login' && isset($_SESSION['xc_auth_types'][$auth_type->tid]['identity'])) {
    $form['info'] = array(
      '#type' => 'item',
      '#markup' => t('Currently logged into %name as <strong>!identity</strong>',
        array(
        '%name' => $auth_type->name,
        '!identity' => $_SESSION['xc_auth_types'][$auth_type->tid]['identity'],
      )),
    );

    $form['#submit'][] = 'xc_auth_logout_submit';

    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => empty($auth_type->logout_text)
        ? t('Log out')
        : t($auth_type->logout_text),
      '#weight' => 90,
    );
  }
  else {
    // Find the values of of a user, what a user is called in the system, based
    // on their credentials
    $function = 'xc_auth_identify_' . $method->credentials;
    if (function_exists($function)) {
      $values = call_user_func($function, $values);
    }
    else {
      $values = xc_auth_identify($credentials, $values);
    }

    // elements = user, pass
    foreach ($credentials->credentials as $element => $attributes) {
      if (empty($auth_type->credentials[$element]['label'])) {
        $_label = $attributes['label'];
      }
      else {
        $_label = $auth_type->credentials[$element]['label'];
      }

      if ($hide_safe_to_store_values
           && $attributes['stored']
           && !empty($_SESSION['xc_auth_types'][$auth_type->tid]['values'][$element])
           && $auth_type->auto_load_values) {

        // the ID of user
        $form[$element] = array(
          '#type' => 'hidden',
          '#value' => $_SESSION['xc_auth_types'][$auth_type->tid]['values'][$element],
        );

        $form[$element . '-info'] = array(
          '#type' => 'item',
          '#markup' => t('%name has been automatically remembered as <strong>!username</strong>',
            array(
              '%name' => $_label, // the label of use = NetID or Username or Barcode
              '!username' => $_SESSION['xc_auth_types'][$auth_type->tid]['values'][$element],
            )
          ),
        );
      }
      else {
        $form[$element] = array(
          '#type' => $attributes['type'],
          '#title' => $_label,
          '#description' => !empty($auth_type->credentials[$element]['description'])
            ? $auth_type->credentials[$element]['description']
            : $attributes['description'],
          '#required' => $attributes['required'],
          '#weight' => $attributes['weight'],
        );
      }
    }

    $form['reset_password_text'] = array(
      '#type' => 'item',
      '#markup' => isset($auth_type->reset_password_text) ? $auth_type->reset_password_text : '',
      '#weight' => 99,
    );

    $form['help_text'] = array(
      '#type' => 'item',
      '#markup' => isset($auth_type->help_text) ? $auth_type->help_text : '',
      '#weight' => 100,
    );

    $form['submit'] = array(
      '#type' => 'submit',
      '#weight' => 90,
    );

    if ($type == 'refresh') {
      $form['submit']['#value'] = t('Refresh account');
      $form['refresh'] = array(
        '#type' => 'value',
        '#value' => TRUE,
      );
    }
    else {
      $form['submit']['#value'] = empty($auth_type->login_text) ? t('Login') : t($auth_type->login_text);
    }

    // Set validate function, so that method-specific function does not change it
    $form['#validate'][] = 'xc_auth_login_validate';

    // Set submit function, so that method-specific function does not change it
    $form['#submit'][] = 'xc_auth_login_submit';
  }

  $form['xc_auth_type'] = array(
    '#type' => 'value',
    '#value' => $auth_type,
  );

  // Original page
  $form['original'] = array(
    '#type' => 'value',
    '#value' => $_GET['q'],
  );

  return $form;
}

/**
 * Login form validation handler
 */
function xc_auth_login_validate($form, &$form_state) {
  $auth_type = $form_state['values']['xc_auth_type'];

  $method_name = $auth_type->method;
  $method_validate = 'xc_auth_method_login_' . $method_name . '_validate';

  // Call method-specific validation function
  if (function_exists($method_validate)) {
    $method_validate($form, $form_state);
  }
}

/**
 * Login form submission handler
 */
function xc_auth_login_submit($form, &$form_state) {
  $auth_type = $form_state['values']['xc_auth_type'];
  $values = $form_state['values'];

  $method_name = $auth_type->method;
  $method_submit = 'xc_auth_method_login_' . $method_name . '_submit';

  // Set method-specific validate function
  if (function_exists($method_submit)) {
    $method_submit($form, $form_state);
  }

  // Login
  if (xc_auth_login($auth_type, $values, $values['refresh'] ? 'refresh' : 'login')) {
    // Set redirection
    $original_url = $form_state['values']['original'];
    $redirect_url = isset($_GET['destination'])
      ? $_GET['destination']
      : 'user';

    $form_state['redirect'] = $redirect_url;
  }
}

/**
 * Login page
 */
function xc_auth_login_page() {
  if (($login_blocks = xc_auth_login_block_get_all()) && count($login_blocks) == 1) {
    $login_block = reset($login_blocks);
    if ($login_block->url) {
      variable_set('xc_auth_login_page_url', $login_block->url);
      if (user_access('administer xc authentication')) {
        drupal_set_message(t('%name set to default login', array('%name' => $login_block->name)));
      }
    }
  }

  if ($goto = variable_get('xc_auth_login_page_url', NULL)) {
    if (isset($_GET['x-destination'])) {
      // TODO array('destination' => $_GET['x-destination']) needs to be an array of keys and values instead of a string.
      drupal_goto($goto, array('query' => array('destination' => $_GET['x-destination'])));
    }
    else {
      drupal_goto($goto);
    }
  }
  else {
    if (user_access('administer xc authentication')) {
      drupal_set_message(t('No default login page !configured', array(
        '!configured' => l(t('configured'), 'admin/xc/auth/block'),
      )));
    }
    drupal_goto('user');
  }
}

/**
 * Logout page
 */
function xc_auth_logout_page($auth_type = NULL) {
  include_once drupal_get_path('module', 'user') . '/user.pages.inc';

  // Log out
  user_logout();

  // Redirect
  isset($_GET['destination'])
    ? drupal_goto($_GET['destination'])
    : drupal_goto();
}

/**
 * Logout form submission handler
 */
function xc_auth_logout_submit($form, &$form_state) {
  $auth_type = $form_state['values']['xc_auth_type'];
  xc_auth_logout($auth_type);
}

/**
 * Automatic login form
 */
function xc_auth_auto_login_form($form, &$form_state, $data = array()) {

  $form = array();
  $auth_types = array();

  // Assign the correct weight key for Drupal's element_sort()
  foreach ($data['auth_types'] as $_tid => $_auth_type) {
    $data['auth_types'][$_tid]['#weight'] = $_auth_type['weight'];
  }

  // Get authentication types from data
  uasort($data['auth_types'], 'element_sort');
  foreach (xc_auth_type_get_all() as $_tid => $_auth_type) {
    if (in_array($_tid, array_keys($data['auth_types']))) {
      $auth_types[$_tid] = $_auth_type;
    }
  }

  $form['attempt_drupal_login'] = array(
    '#type' => 'hidden',
    '#value' => $data['attempt_drupal_login'],
  );

  // Get credentials to use for form
  $method = xc_auth_method_load($_auth_type->method);
  $credentials = xc_auth_credentials_load($method->credentials);

  // Return if no authentication types or credentials are specified
  if ((empty($auth_types) || empty($credentials)) && user_access('xc administer authentication')) {
    if (empty($auth_types)) {
      $form['info'] = array(
        '#type' => 'item',
        '#description' => t('No authentication types specified.'),
      );
    }

    if (empty($credentials)) {
      $form['info'] = array(
        '#type' => 'item',
        '#description' => t('No credentials specified.'),
      );
    }

    return $form;
  }

  // If a user has already been authenticated with any of the authentication
  // types, return an option to logout
  foreach ($auth_types as $auth_type) {
    if (isset($_SESSION['xc_auth_types'][$auth_type->tid]['identity'])) {
      $form['info'] = array(
        '#type' => 'item',
        '#markup' => t('Currently logged into %name as <strong>!identity</strong>',
          array(
          '%name' => $auth_type->name,
          '!identity' => $_SESSION['xc_auth_types'][$auth_type->tid]['identity'],
        )
        ),
      );

      $form['#submit'][] = 'xc_auth_logout_submit';

      $form['submit'] = array(
        '#type' => 'submit',
        '#value' => empty($data['logout_text'])
          ? t('Log out')
          : t($data['logout_text']),
        '#weight' => 90,
      );

      return $form;
    }
  }

  // Find the values of of a user, what a user is called in the system, based
  // on their credentials
  $function = NULL;
  if (isset($data['credentials'])) {
    $function = 'xc_auth_identify_' . $data['credentials'];
  }
  $values = $form_state['input'];
  if ($function !== NULL && function_exists($function)) {
    $values = call_user_func($function, $values);
  }
  else {
    $values = xc_auth_identify($credentials, $values);
  }

  // $element_keys are 'user', 'pass'
  // $element_definitions are form element definition arrays (label, description, type, required, weight)
  foreach ($credentials->credentials as $element_key => $element_definition) {
    if (empty($data['form'][$element_key]['label'])) {
      $_label = $element_definition['label'];
    }
    else {
      $_label = $data['form'][$element_key]['label'];
    }

    if (!isset($data['form'][$element_key]['description'])) {
      $description = $element_definition['description'];
    }
    else {
      $description = $data['form'][$element_key]['description'];
    }

    $form[$element_key] = array(
      '#type' => $element_definition['type'],
      '#title' => $_label,
      '#description' => $description,
      '#required' => $element_definition['required'],
      '#weight' => $element_definition['weight'],
    );
  }

  $form['reset_password_text'] = array(
    '#type' => 'item',
    '#markup' => $data['reset_password_text'],
    '#weight' => 99,
  );

  $form['help_text'] = array(
    '#type' => 'item',
    '#markup' => $data['help_text'],
    '#weight' => 100,
  );

  $form['login_incorrect_text'] = array(
    '#type' => 'value',
    '#value' => $data['login_incorrect_text'],
  );

  $form['login_failure_text'] = array(
    '#type' => 'value',
    '#value' => $data['login_failure_text'],
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => empty($data['login_text'])
      ? t('Login')
      : t($data['login_text']),
    '#weight' => 90,
  );

  // Set validate function, so that method-specific function does not change it
  $form['#validate'][] = 'xc_auth_auto_login_validate';

  // Set submit function, so that method-specific function does not change it
  $form['#submit'][] = 'xc_auth_auto_login_submit';

  $form['xc_auth_types'] = array(
    '#type' => 'value',
    '#value' => $auth_types,
  );

  // Original page
  $form['original'] = array(
    '#type' => 'value',
    '#value' => $_GET['q'],
  );

  $form['destination'] = array(
    '#type' => 'hidden',
    '#value' => (isset($_GET['destination']) ? $_GET['destination'] : ''),
  );

  return $form;
}

/**
 * Automatic login form validation handler
 */
function xc_auth_auto_login_validate($form, &$form_state) {
  $auth_types = $form_state['values']['xc_auth_types'];

  foreach ($auth_types as $auth_type) {
    $method_name = $auth_type->method;
    $method_validate = 'xc_auth_method_login_' . $method_name . '_validate';

    // Call method-specific validation function
    if (function_exists($method_validate)) {
      $method_validate($form, $form_state);
    }
  }
}

/**
 * Automatic login form submission handler
 */
function xc_auth_auto_login_submit($form, &$form_state) {

  $values = $form_state['values'];
  $auth_types = $values['xc_auth_types'];

  foreach ($auth_types as $auth_type) {
    $method_submit = 'xc_auth_method_login_' . $auth_type->method . '_submit';

    // Set method-specific validate function
    if (function_exists($method_submit)) {
      $method_submit($form, $form_state);
    }
  }

  $redirect_url = isset($_GET['destination']) ? $_GET['destination'] : 'user';

  // Login
  if (xc_auth_login($auth_types, $values, 'login', $values['attempt_drupal_login'], $values['login_incorrect_text'], $values['login_failure_text'])) {
    // Set redirection
    $form_state['redirect'] = $redirect_url;
  }
  else {
    unset($_GET['destination']);
    $original_url = $form_state['values']['original'];
    $form_state['redirect'] = array($original_url, array('query' => array('destination' => $redirect_url)));
  }
}

/**
 * Get login block
 *
 * @param $login_block_id
 *    Login block identifier
 * @param $update
 *    TRUE to update login block cache
 * @return
 *    Login block object
 */
function xc_auth_login_block_load($login_block_id, $update = FALSE) {
  $login_blocks = xc_auth_login_block_get_all($update);
  return $login_blocks[$login_block_id];
}

/**
 * Get login block
 *
 * @see xc_auth_login_block_load()
 * @param $tid
 *    Login block identifier
 * @return
 *    Login block object
 */
function xc_auth_login_block_get($login_block_id) {
  return xc_auth_login_block_load($login_block_id);
}

/**
 * Get all login blocks
 *
 * @see xc_auth_login_block_load()
 * @param $update
 *    TRUE to update login block cache
 * @return
 *    Array of login block objects
 */
function xc_auth_login_block_get_all($update = FALSE) {
  static $login_blocks;
  if (empty($login_blocks) || $update) {
    $sql = 'SELECT login_block_id, name, description, type, url, data
            FROM {xc_auth_login_block}';
    $result = db_query($sql);

    $login_blocks = array();
    foreach ($result as $login_block) {
      $login_block->data = unserialize($login_block->data);
      $login_blocks[$login_block->login_block_id] = $login_block;
    }
  }
  return $login_blocks;
}

/**
 * List all login blocks
 */
function xc_auth_login_block_list() {
  $header = array(
    t('Name'),
    t('Description'),
    array(
      'data' => t('Operations'),
      'colspan' => 2,
    ),
    t('Default Login URL'),
  );
  $rows = array();
  $login_blocks = xc_auth_login_block_get_all();

  if (empty($login_blocks)) {
    drupal_set_message(t('No login web forms exist on this system. You must first !add a login web form.',
      array('!add' => l(t('add'), 'admin/xc/auth/block/add'))),
      'warning');
  }

  foreach ($login_blocks as $login_block_id => $login_block) {
    if (!$login_block->url) {
      $make_default_text = t('<em>No URL provided</em>');
    }
    elseif (variable_get('xc_auth_login_page_url', NULL) == $login_block->url) {
      $make_default_text = t('<em>Already default login</em>');
    }
    else {
      $make_default_text = l(t('Make default'), 'admin/xc/auth/block/' . $login_block_id . '/make-default');
    }

    $rows[] = array(
      $login_block->name,
      $login_block->description,
      l(t('edit'), 'admin/xc/auth/block/' . $login_block_id . '/edit'),
      l(t('delete'), 'admin/xc/auth/block/' . $login_block_id . '/delete'),
      $make_default_text,
    );

  }
  return theme('table', array('header' => $header, 'rows' => $rows));
}

/**
 * Render login block HTML
 */
function xc_auth_login_block_render($login_block) {
  switch ($login_block->type) {
    case 'single':
      return drupal_get_form(
        'xc_auth_login_form',
        xc_auth_type_get($login_block->data['auth_type'])
      );
      break;

    case 'multiple':
      return xc_auth_login_forms(
        $login_block->data['auth_types'],
        TRUE,
        $login_block->data['theme'],
        $login_block->data['theme-collapsed']
      );
      break;

    case 'auto':
      return drupal_get_form(
        'xc_auth_auto_login_form',
        $login_block->data
      );
      break;
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_auth_login_block_make_default($login_block, $goto = FALSE) {
  if ($login_block->url) {
    variable_set('xc_auth_login_page_url', $login_block->url);
  }
  if ($goto) {
    drupal_goto('admin/xc/auth/block');
  }
}

/**
 * Login block form
 */
function xc_auth_login_block_form($form, &$form_state, $login_block = NULL) {
  $auth_types = xc_auth_type_get_all();

  if (empty($auth_types)) {
    drupal_set_message(
      t('No remote authentication systems configured for this site. Please !add a remote authentication system before creating any web forms',
        array('!add' => l(t('add'), 'admin/xc/auth/type/add'))),
        'warning');
  }

  $form_state['storage']['login_block'] = $login_block;

  if (is_object($login_block)
      && in_array($login_block->type, array('single', 'multiple', 'auto'))) {
    $type = $login_block->type;

    $form['type'] = array(
      '#type' => 'hidden',
      '#value' => $login_block->type,
    );

    if (empty($form_state['storage']['step'])) {
      $form_state['storage']['step'] = 1;
    }
  }
  elseif (empty($form_state['storage']['step'])) {
    $form_state['storage']['step'] = 0;

    $login_block_options = array(
      'auto' => t('Automatic'),
      'single' => t('Single'),
      'multiple' => t('Multiple'),
    );

    $form['type'] = array(
      '#type' => 'select',
      '#title' => t('Login block type'),
      '#description' => t('Select type of login web form to create. Once the web form has been saved, this setting cannot be changed unless a new web form is created.')
        . t('The types available are') . ':'
        . '<ul><li><strong>' . t('Automatic (Default)') . ': </strong>' . t('This is the default option and provides one form to automatically log into one out of many remote systems. It is the most intuitive option for users on sites with more than one remote authentication system. Most institutions will prefer this option.')
        . '</li><li><strong>' . t('Single (Simple)') . ': </strong>' . t('Provides one form to log into a single remote system. A simple way to set up a login form for one remote authentication system.')
        . '</li><li><strong>' . t('Multiple (Advanced)') . ': </strong>' . t('Provides many forms to log into multiple remote systems on the same page. Uses the interface to clearly separate login options, unlike the default automatic login form. Good for debugging.') . '</li></ul>',
      '#options' => $login_block_options,
      '#default_value' => 'auto',
      '#required' => TRUE,
    );

    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Continue'),
    );
  }
  else {
    $type = $form_state['values']['type'];
  }

  if ($form_state['storage']['step'] == 1) {
    $form['name'] = array(
      '#type' => 'textfield',
      '#title' => t('Name'),
      '#default_value' => isset($login_block->name) ? $login_block->name : '',
      '#required' => TRUE,
    );

    $form['description'] = array(
      '#type' => 'textarea',
      '#title' => t('Description'),
      '#default_value' => isset($login_block->description) ? $login_block->description : '',
    );

    $form['data'] = array(
      '#tree' => TRUE,
    );

    $form['type'] = array(
      '#type' => 'hidden',
      '#value' => isset($type) ? $type : $form_state['values']['type'],
    );

    $auth_types_options = array();
    foreach ($auth_types as $tid => $auth_type) {
      $auth_types_options[$tid] = $auth_type->name;
    }

    switch ($type) {
      case 'single':
        $form['data']['auth_type'] = array(
          '#type' => 'select',
          '#title' => t('Select authentication type'),
          '#required' => TRUE,
          '#description' => t('Choose one remote authentication system for users to authenticate with this form. The appearance of the form is !configured with the login form for this remote system.',
            array('!configured' => l(t('configured'), "admin/xc/auth/type"))),
          '#options' => $auth_types_options,
          '#default_value' => is_array($login_block->data['auth_types'])
            ? reset($login_block->data['auth_types'])
            : reset($auth_types_options),
        );
        break;

      case 'multiple':
        $form['data']['auth_types'] = array(
          '#type' => 'checkboxes',
          '#title' => t('Select authentication types'),
          '#required' => TRUE,
          '#description' => t('Choose remote authentication system(s) for users to authenticate with this form. The appearance of the forms is !configured from the login form for this remote system.',
            array('!configured' => l(t('configured'), "admin/xc/auth/type"))),
          '#options' => $auth_types_options,
          '#default_value' => is_array($login_block->data['auth_types']) ? $login_block->data['auth_types'] : array(),
        );

        $form['data']['theme'] = array(
          '#type' => 'select',
          '#title' => t('Display'),
          '#description' => t('Select how the multiple login options should be separated and arranged within the web form or page. This setting is particularly useful for designing custom themes.'),
          '#options' => array(
            'fieldset' => t('Separated into fieldsets'),
            'fieldset-collapsed' => t('Separated into collapsed fieldsets'),
            '' => t('No separation'),
          ),
          '#default_value' => isset($login_block->data['theme']) ? $login_block->data['theme'] : 'fieldset',
        );
        break;
      case 'auto':
        $form['data']['auth_types'] = array(
          '#tree' => TRUE,
          '#theme' => 'xc_auth_auto_auth_types_form',
        );

        foreach ($auth_types as $tid => $auth_type) {
          $form['data']['auth_types'][$tid] = array(
            '#tree' => TRUE,
          );

          $form['data']['auth_types'][$tid]['selected'] = array(
            '#type' => 'checkbox',
            '#default_value' => isset($login_block->data['auth_types'][$tid]['selected']) ? $login_block->data['auth_types'][$tid]['selected'] : '',
          );

          $form['data']['auth_types'][$tid]['name'] = array(
            '#type' => 'value',
            '#value' => $auth_type->name,
          );

          $method = xc_auth_method_get($auth_type->method);
          $credentials = xc_auth_credentials_get($method->credentials);
          $form['data']['auth_types'][$tid]['credentials'] = array(
            '#type' => 'value',
            '#value' => $credentials->name,
          );

          $range = range(-20, 20);
          $form['data']['auth_types'][$tid]['weight'] = array(
            '#type' => 'select',
            '#options' => array_combine($range, $range),
            '#default_value' => isset($login_block->data['auth_types'][$tid]['weight'])
              ? $login_block->data['auth_types'][$tid]['weight']
              : 0,
          );
        }
        break;
    }

    $form['url'] = array(
      '#type' => 'textfield',
      '#title' => t('URL alias'),
      '#description' => t('Provide a URL alias to create a login page. For example, <em>"xc/login/myauth"</em> will make this login form accessible from <em>www.mysite.com/xc/login/myauth</em> or <em>www.myside.com?q=xc/login/myauth</em>.'),
      '#default_value' => isset($login_block->url) ? $login_block->url : '',
    );

    if (in_array($type, array('single', 'multiple'))) {
      $submit_text = $login_block ? t('Save') : t('Add login block');
    }
    elseif ($type == 'auto') {
      $submit_text = t('Continue');
    }

    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => $submit_text,
    );
  }

  if ($form_state['storage']['step'] == 2) {

    // Labels and descriptions for credentials
    $form['data']['form'] = array(
      '#tree' => TRUE,
    );

    $first = xc_auth_type_get(reset(array_keys($form_state['values']['data']['auth_types'])));
    $method = xc_auth_method_get($first->method);
    $credentials = xc_auth_credentials_get($method->credentials);

    if (is_array($credentials->credentials)) {
      foreach ($credentials->credentials as $key => $value) {
        $default_value = $value['label'];
        if (isset($login_block->data['form'][$key])
            && is_array($login_block->data['form'][$key])
            && !empty($login_block->data['form'][$key]['label'])) {
          $default_value = $login_block->data['form'][$key]['label'];
        }
        $form['data']['form'][$key]['label'] = array(
          '#type' => 'textfield',
          '#title' => t('Label for @title', array('@title' => $value['title'])),
          '#default_value' => $default_value,
          '#required' => TRUE,
        );

        $default_value = isset($value['description']) ? $value['description'] : '';
        if (isset($login_block->data)
            && is_array($login_block->data['form'][$key])
            && !empty($login_block->data['form'][$key]['description'])) {
          $default_value = $login_block->data['form'][$key]['description'];
        }
        $form['data']['form'][$key]['description'] = array(
          '#type' => 'textarea',
          '#title' => t('Help text for @title', array('@title' => $value['title'])),
          '#default_value' => $default_value,
          '#rows' => 2,
          '#required' => FALSE,
        );
      }
    }
    else {
      $form['data']['form']['info'] = array(
        '#type' => 'item',
        '#markup' => t('No login form credentials to edit'),
      );
    }

    $form['data']['help_text'] = array(
      '#type' => 'textarea',
      '#rows' => 2,
      '#title' => t('Help text (HTML allowed)'),
      '#default_value' => isset($login_block->data) ? $login_block->data['help_text'] : '',
    );

    $form['data']['reset_password_text'] = array(
      '#type' => 'textarea',
      '#rows' => 2,
      '#title' => t('Lost or forgotten password reset text (HTML allowed)'),
      '#default_value' => isset($login_block->data) ? $login_block->data['reset_password_text'] : '',
    );

    $form['data']['login_text'] = array(
      '#type' => 'textfield',
      '#title' => t('Login button text'),
      '#default_value' => empty($login_block->data['login_text'])
        ? t('Login')
        : $login_block->data['login_text'],
      '#size' => 30,
    );

    $form['data']['logout_text'] = array(
      '#type' => 'textfield',
      '#title' => t('Logout button text'),
      '#default_value' => empty($login_block->data['logout_text'])
        ? t('Log out')
        : $login_block->data['logout_text'],
      '#size' => 30,
    );

    $form['data']['responses'] = array(
      '#type' => 'fieldset',
      '#title' => t('Response messages'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );

    $form['data']['responses']['login_incorrect_text'] = array(
      '#type' => 'textfield',
      '#title' => t('Incorrect or unmatched login credentials error text'),
      '#default_value' => isset($login_block->data['login_incorrect_text'])
        ? $login_block->data['login_incorrect_text']
        : 'Incorrect or unmatched login credentials',
      '#size' => 100,
    );

    $form['data']['responses']['login_success_text'] = array(
      '#type' => 'textfield',
      '#title' => t('Successful login text'),
      '#default_value' => isset($login_block->data['login_success_text'])
        ? $login_block->data['login_success_text']
        : 'Login successful',
      '#size' => 100,
    );

    $form['data']['responses']['login_failure_text'] = array(
      '#type' => 'textfield',
      '#title' => t('Failed or invalid login text'),
      '#default_value' => isset($login_block->data['login_failure_text'])
        ? $login_block->data['login_failure_text']
        : 'Failed or invalid login',
      '#size' => 100,
    );

    $form['advanced'] = array(
      '#type' => 'fieldset',
      '#title' => t('Advanced settings'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );

    $default = (isset($login_block->data['attempt_drupal_login'])) ? $login_block->data['attempt_drupal_login'] : TRUE;
    $form['advanced']['attempt_drupal_login'] = array(
      '#type' => 'checkbox',
      '#title' => t('Attempt Drupal login as last resort'),
      '#description' => t('Make final attempt to authenticate with Drupal no match is made for other remote systems'),
      '#default_value' => $default,
    );

    $form['submit'] = array(
      '#type' => 'submit',
      '#value' => $login_block ? t('Save') : t('Add login block'),
    );
  }

  return $form;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function theme_xc_auth_auto_auth_types_form($variables) {
  $elements = $variables['elements'];
  $rows = array();
  $header = array(t('Selected'), t('Name'), t('Login credentials'), t('Weight'));

  foreach (element_children($elements) as $tid) {
    $rows[] = array(
      drupal_render($elements[$tid]['selected']),
      $elements[$tid]['name']['#value'],
      $elements[$tid]['credentials']['#value'],
      drupal_render_children($elements[$tid]['weight']),
    );
  }

  return theme('fieldset', array('element' => array(
    '#title' => t('Remote authentication systems'),
    '#description' => t('Select login options from the rows in the table and order the priority for login by the weight column'),
    '#value' => theme('table', array('header' => $header, 'rows' => $rows)),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  )));
}

/**
 * Login block form validation handler
 */
function xc_auth_login_block_form_validate($form, &$form_state) {
  $step = $form_state['storage']['step'];
  $login_block = $form_state['storage']['login_block'];
  if (!is_null($login_block)) {
    $type = $login_block->type;
  }
  elseif (isset($form_state['values']['type'])) {
    $type = $form_state['values']['type'];
  }
  elseif (isset($form_state['storage']['values'][$step]['type'])) {
    $type = $form_state['storage']['values'][$step]['type'];
  }
  else {
    $type = 'auto';
  }

  if ($form_state['storage']['step'] == 0) {
    $form_state['storage']['step'] = 1;
  }
  elseif ($form_state['storage']['step'] == 1) {
    switch ($type) {
      case 'single':
        if (empty($form_state['values']['data']['auth_type'])) {
          form_set_error('data', t('No remote authentication system selected'));
        }
        break;
      case 'multiple':
        $arr = array_filter($form_state['values']['data']['auth_types']);
        if (empty($arr)) {
          form_set_error('data', t('No remote authentication system(s) selected'));
        }
        break;
      case 'auto':
        $first = reset($form_state['values']['data']['auth_types']);
        $credentials = $first['credentials'];
        $selected = 0;
        foreach ($form_state['values']['data']['auth_types'] as $tid => $auth_type) {
          if ($auth_type['selected']) {
            $selected++;
          }
          if ($auth_type['credentials'] != $credentials) {
            form_set_error('data', t('Automatic forms require identical login credentials for all selected remote authentication systems'));
          }
        }
        if ($selected < 1) {
          form_set_error('data', t('No remote authentication system(s) selected'));
        }

        break;
    }
    $form_state['storage']['step'] = 2;
  }
  elseif ($form_state['storage']['step'] == 2) {
    $form_state['storage']['step'] = 3;
  }
}

/**
 * Login block form submission handler
 */
function xc_auth_login_block_form_submit($form, &$form_state) {
  $form_state['storage']['values'][$form_state['storage']['step']] = $form_state['values'];

  $form_state['values'] = array();
  foreach ($form_state['storage']['values'] as $step => $values) {
    $form_state['values'] += $values;
  }

  $type = $form_state['values']['type'];

  if ((in_array($type, array('single', 'multiple')) && $form_state['storage']['step'] == 2) ||
      ($type == 'auto' && $form_state['storage']['step'] == 3)) {

    $login_block = &$form_state['storage']['login_block'];
    $data = $form_state['values']['data'];

    if ($type == 'multiple') {
      $data['auth_types'] =
        array_filter($data['auth_types']);

      $theme = explode('-', $data['theme']);
      $data['theme'] = array_shift($theme);
      foreach ($theme as $setting) {
        $data["theme-$setting"] = TRUE;
      }
    }

    if ($type == 'auto') {
      foreach ($data['auth_types'] as $_tid => $_auth_type) {
        if (!$_auth_type['selected']) {
          unset($data['auth_types'][$_tid]);
        }
      }

      $data['attempt_drupal_login'] = $form_state['values']['attempt_drupal_login'];
      $data['reset_password_text'] = $form_state['values']['reset_password_text'];
      $data['help_text'] = $form_state['values']['help_text'];
      $data['login_incorrect_text'] = $form_state['values']['login_incorrect_text'];
      $data['login_success_text'] = $form_state['values']['login_success_text'];
      $data['login_failure_text'] = $form_state['values']['login_failure_text'];
      $data['login_text'] = $form_state['values']['login_text'];
      $data['logout_text'] = $form_state['values']['logout_text'];
      $data['form'] = $form_state['values']['form'];
    }

    $login_block->name = check_plain($form_state['values']['name']);
    $login_block->type = check_plain($form_state['values']['type']);
    $login_block->description = check_plain($form_state['values']['description']);
    $login_block->url = check_url($form_state['values']['url']);
    $login_block->data = serialize($data);

    $word = empty($login_block->login_block_id) ? 'create' : 'update';
    if (empty($login_block->login_block_id)) {
      $result = drupal_write_record('xc_auth_login_block', $login_block);
    }
    else {
      $result = drupal_write_record('xc_auth_login_block', $login_block, 'login_block_id');
    }

    if ($result) {
      $params = array(
        '%name' => $login_block->name,
        '!admin' => l(t('block administration'), 'admin/structure/block'),
      );
      if ($word == 'create') {
        drupal_set_message(t('%name login web form created. Configure the region for its block on the !admin page.', $params));
      }
      elseif ($word == 'update') {
        drupal_set_message(t('%name login web form updated. Configure the region for its block on the !admin page.', $params));
      }
    }
    else {
      drupal_set_message(t("Unexpected error. Unable to $word authentication type."));
    }

    // Clear storage to end the multi-form
    unset($form_state['storage']);

    // Return to listing of authentication types
    $form_state['redirect'] = 'admin/xc/auth/block';
  }
  else {
    $form_state['rebuild'] = TRUE;
  }

  // Rebuild menus
  menu_rebuild();
}

/**
 * Login block deletion form
 */
function xc_auth_login_block_delete_form($form, &$form_state, $login_block) {
  $form['login_block'] = array(
    '#type' => 'value',
    '#value' => $login_block,
  );

  return confirm_form($form,
    t('Are you sure you want to delete the %name login web form?',
      array('%name' => $login_block->name)),
    'admin/xc/auth/block', '', t('Delete'), t('Cancel'));
}

/**
 * Login block deletion form submission
 */
function xc_auth_login_block_delete_form_submit($form, &$form_state) {
  $login_block = $form_state['values']['login_block'];

  // Delete authentication type
  $sql = 'DELETE FROM {xc_auth_login_block} WHERE login_block_id = %d';
  // TODO Please review the conversion of this statement to the D7 database API syntax.
  /* db_query($sql, $login_block->login_block_id) */
  db_delete('xc_auth_login_block')
    ->condition('login_block_id', $login_block->login_block_id)
    ->execute();

  $form_state['redirect'] = 'admin/xc/auth/block';
  drupal_set_message(t('%name login web form deleted.',
    array('%name' => $login_block->name)));

  // Rebuild menus
  menu_rebuild();
}

/**
 * Form to save settings for xc/authlink/%
 */
function xc_auth_authlink_settings($form, &$form_state) {
  drupal_add_js(drupal_get_path('module', 'xc_auth') . '/xc_auth.js');

  $mode = variable_get('xc_auth_linkmode', 'demouser');

  // xc_auth_linkable_sites
  $form['xc_auth_linkable_sites'] = array(
    '#type' => 'textarea',
    '#title' => t('Link login is allowed from these sites'),
    '#description' => t('The sites which are able to use the xc/authlink/% menu to try to log in. An asteriks means from anywhere'),
    '#default_value' => variable_get('xc_auth_linkable_sites', ''),
  );

  $form['xc_auth_linkmode'] = array(
    '#type' => 'radios',
    '#title' => t('Select mode'),
    '#description' => t('With Multiuser mode you can allow login for multiple users, in Demo user mode everybody will be automatically logged in as the user you specified.'),
    '#options' => array(
      'multiuser' => t('Multiple users can log in'),
      'demouser' => t('Everybody who use this link will be logged as a specific "demo user"'),
    ),
    '#default_value' => $mode,
  );

  $form['multiuser'] = array(
    '#type' => 'fieldset',
    '#title' => t('Multiple users can log in'),
    '#description' => t('Use this part of the form, if you want anybody anybody, to log in with its own password.'),
    '#collapsible' => TRUE,
    '#collapsed' => ($mode == 'multiuser' ? FALSE : TRUE),
    '#attributes' => array('id' => 'multiuser'),
  );

  // xc_auth_linkable_users
  $form['multiuser']['xc_auth_linkable_users'] = array(
    '#type' => 'textarea',
    '#title' => t('Link login is allowed for these users'),
    '#description' => t('List the users one by one, each in a distinct line. An asteriks means no limitation.'),
    '#default_value' => variable_get('xc_auth_linkable_users', ''),
  );

  // xc_auth_3deskey
  $form['multiuser']['xc_auth_3deskey'] = array(
    '#type' => 'textfield',
    '#title' => t('Secret key for restore encrypted data'),
    '#description' => t('Please provide a maximum 24 character log key. The link use 3DES algorithm, which require the same key on encryption and decription side.'),
    '#default_value' => variable_get('xc_auth_3deskey', ''),
    '#size' => 20,
  );

  // timesout
  $form['multiuser']['xc_auth_timeout'] = array(
    '#type' => 'textfield',
    '#title' => t('Timeout of the timestamp in the link'),
    '#description' => t('The link contains a timestamp, and the site might use this timestamp when decide to allow log in or not. 0 means no timeout, any link can be used forever. A positive number means the number of minutes the site allows to login from the creation of the link.'),
    '#default_value' => variable_get('xc_auth_timeout', '0'),
    '#size' => 20,
  );

  $form['demouser'] = array(
    '#type' => 'fieldset',
    '#title' => t('Everybody who use this link will be logged as a specific "demo user"'),
    '#description' => t('Use this part of the form, if you do not want anybody, only one special user to log in. Please use an existing, real user. It can be created for this special purpose as well.'),
    '#collapsible' => TRUE,
    '#collapsed' => ($mode == 'demouser' ? FALSE : TRUE),
    '#attributes' => array('id' => 'demouser'),
  );

  // xc_auth_demouser
  $form['demouser']['xc_auth_demouser'] = array(
    '#type' => 'textfield',
    '#title' => t('Name of demo user'),
    '#description' => t('Please provide username for the demo user.'),
    '#default_value' => variable_get('xc_auth_demouser', ''),
    '#size' => 20,
  );

  // xc_auth_demopass
  $form['demouser']['xc_auth_demopass'] = array(
    '#type' => 'textfield',
    '#title' => t('Password of demo user'),
    '#description' => t('Please provide a password for the demo user.'),
    '#default_value' => variable_get('xc_auth_demopass', ''),
    '#size' => 20,
  );

  return system_settings_form($form);
}

/**
 * Authenticates a user folliwing a special link (xc/authlink/%)
 *
 * @param $auth (object)
 *    Authentication type for login (see xc_auth_type table)
 * @param $values
 *    Array of values for login credentials. Keys: attempt_drupal_login,
 *    user, pass, op, xc_auth_types (array of objects), submit (the label of submit button),
 *    original, destination, form_build_id, form_id.
 * @param $data
 *    Array of additional data or information to pass to login functions
 *
 * @return
 *    Authentication status, either XC_AUTH_LOGIN_SUCCESS, XC_AUTH_LOGIN_INCORRECT,
 *    or XC_AUTH_LOGIN_FAILURE
 */
function xc_auth_authenticate_by_link($encrypted_data) {

  $mode = variable_get('xc_auth_linkmode', 'multiuser');
  if ($mode == 'demouser') {
    $user      = variable_get('xc_auth_demouser', '');
    $pass      = variable_get('xc_auth_demopass', '');
  }
  elseif ($mode == 'multiuser') {
    $params = xc_auth_decrypt_link($encrypted_data);
    if (!is_array($params) || !isset($params['t']) || !isset($params['u']) || !isset($params['p'])) {
      xc_log_error('xc_auth_link', 'No timestamp or user or pass in authentication link: %params',
        array('%params' => var_export($params, TRUE)));
      drupal_goto('');
    }

    $timestamp = $params['t'];
    $user      = $params['u'];
    $pass      = $params['p'];

    // check if the link is not outdated
    $timeout = (int) variable_get('xc_auth_timeout', 0);
    if ($timeout > 0) {
      if ((time() - $timestamp) > ($timeout * 60)) {
        xc_log_error('xc_auth_link', t('The authentication link is outdated.'));
        drupal_goto('');
      }
    }

    // check if the user is on the list of allowable users
    $linkable_users = variable_get('xc_auth_linkable_users', '*');
    if ($linkable_users != '*') {
      $linkable_users = explode("\n", $linkable_users);
      if (empty($linkable_users) || !in_array($user, $linkable_users)) {
        xc_log_error('xc_auth_link', t('%user is not allowed to login this way.', array('%user' => $user)));
        drupal_goto('');
      }
    }
  }

  // TODO: add additional defence: registering HTTP_REFERER dpm($_SERVER);
  /*
   $linkable_sites = variable_get('xc_auth_linkable_sites', '*');
   if ($linkable_sites != '*') {
   $linkable_sites = explode("\n", $linkable_sites);
   $referer = $_SERVER['HTTP_REFERER'];
   if (!empty($linkable_sites) && !in_array($referer, $linkable_sites)) {
   xc_log_error('xc_auth_link', t('%site is not allowed to login from.', array('%site' => $referer)));
   drupal_goto('');
   }
   }
   */

  $xc_auth_types = xc_auth_type_get_all();

  $values = array(
    'user' => check_plain($user),
    'pass' => check_plain($pass),
    'op' => 'Login',
    'xc_auth_types' => $xc_auth_types,
    'original' => 'default-login',
  );
  $result = xc_auth_login($xc_auth_types, $values, 'login', TRUE);

  $destination = ($result) ? '' : $values['original'];
  drupal_goto($destination);
}

/**
 * Decrypt link.
 *
 * The link contains URL parameters for username and password in decrypted form.
 * It decrypts the string, and create an array of parameters.
 *
 * @param $encrypted_data (string)
 *   The encrypted parameters as a string
 *
 * @return (array)
 *   The parameters need for authentication
 */
function xc_auth_decrypt_link($encrypted_data) {

  // key should be set in xc_auth_3deskey variable.
  $key = variable_get('xc_auth_3deskey', '');

  // the base64 encoding contains / and + which used specially in Drupal, so they should be changed
  $base64 = str_replace(array('_', '-'), array('/', '+'), $encrypted_data);

  $encrypted = base64_decode($base64);

  // base64 should be used to maintain binary-safe strings
  $iv = 'iviviviv';
  $decrypted_data = mcrypt_ecb(MCRYPT_3DES, $key, $encrypted, MCRYPT_DECRYPT, $iv);

  // additional security measure
  $output = '';
  for ($i = 0; $i < strlen($decrypted_data); $i++) {
    if ($i % 2 == 1) {
      $output .= substr($decrypted_data, $i, 1);
    }
  }

  // create array from string
  parse_str(str_replace('&amp;', '&', $output), $params);

  return $params;
}
