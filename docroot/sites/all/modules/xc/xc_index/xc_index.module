<?php
/**
 * @file
 * XC Index module functions
 *
 * @copyright (c) 2010-2011 eXtensible Catalog Organization
 */

/**
 * Permission for administering XC Search module
 * @var String
 */
define('ADMINISTER_XC_INDEX', 'administer xc index');

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_index_help($path, $arg) {
  switch ($path) {
    // Help for another path in the block module
    case 'admin/xc/index':
      $text = '<p>'
            . t('Indexing settings. Alert! These are advanced settings, do not modify before consulting the manual.')
            . '</p>';
      $text .= theme('xc_index_consistency', array('consistency' => xc_index_check_consistency()));
      return $text;
      break;

    case 'admin/xc/index/facets':
    case 'admin/xc/index/field_type':
    case 'admin/xc/index/field_type/%':
    case 'admin/xc/index/sortables':
    case 'admin/xc/search/facet/group/%':
    case 'admin/xc/search/facet':
      return theme('xc_index_consistency', array('consistency' => xc_index_check_consistency()));
      break;
  }
}

/**
 * Implements hook_permission().
 */
function xc_index_permission() {
  return array(
    ADMINISTER_XC_INDEX => array(
      'title' => t(ADMINISTER_XC_INDEX),
      'description' => t('TODO Add a description for ADMINISTER_XC_INDEX'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function xc_index_menu() {
  module_load_include('inc', 'xc_index', 'includes/menu');
  return _xc_index_menu();
}

/**
 * Implements hook_simpletest().
 */
function xc_index_simpletest() {
  $dir = drupal_get_path('module', 'xc_index') . '/tests';
  $tests = file_scan_directory($dir, '/\.test$/');
  return array_keys($tests);
}

/**
 * Implements hook_theme().
 */
function xc_index_theme() {
  global $base_url;

  $themes = array(
    'xc_index_field_type_form' => array(
      'render element' => 'form',
    ),
    'xc_index_attribute_form' => array(
      'render element' => 'form',
    ),
    'xc_index_facet_mapping_form' => array(
      'render element' => 'form',
    ),
    'xc_index_facet_mapping_edit_form' => array(
      'render element' => 'form',
    ),
    'xc_index_facet_form' => array(
      'render element' => 'form',
    ),
    'xc_index_facet_edit_form' => array(
      'render element' => 'form',
    ),
    'xc_index_consistency' => array(
      'variables' => array('consistency' => NULL),
    ),
  );
  return $themes;
}

/** COMMON FUNCTIONS called from ooutside
 *  ------------------------------------ */

/**
 * Returns a list of all fileds, and all types of the field as an array like
 * array('dcterms:available' => array('_s', '_t', ...), 'dc:type' => ...)
 *
 * @return (array)
 *   The map of all metadata fields, and theirs suffixes
 */
function xc_index_field_type_get_field_types_noid() {
  $sql = 'SELECT * FROM {xc_index_field_type}';
  $result = db_query($sql);
  $values = array();
  //while ($data = db_fetch_object($result)) {
  foreach($result as $data) {
    $values[$data->field][] = $data->type;
  }
  return $values;
}

/**
 * Return the array of array of the attributes and its properties.
 *
 * The first key of the array is the field name, the second key is the attribute
 * name (without the namespace part if $do_namespace_hack argument is TRUE).
 * The value of the key is an associative array with 3 fields: id, type (ignore,
 * value_as_key, as_key_exclusively, value_as_value) and solr field name.
 *
 * @param $do_namespace_hack (boolean)
 *   If true we remove the namespace part from attribute name.
 *
 * @return (array)
 *   The array of attributes. Its keys are: id, type and field (Solr field)
 */
function xc_index_attribute_get_attributes($do_namespace_hack = FALSE) {
  $sql = 'SELECT * FROM {xc_index_attribute_to_field}';
  $result = db_query($sql);
  $values = array();
  //while ($data = db_fetch_object($result)) {
  foreach ($result as $data) {
    if ($do_namespace_hack == TRUE && module_exists('xc_util')) {
      $data->attribute = xc_util_remove_ns($data->attribute);
    }
    $values[$data->schema_field][$data->attribute] = array(
      'id' => $data->atof_id,
      'type' => $data->type,
      'field' => $data->solr_field,
    );
  }
  return $values;
}

/**
 * Get the list of facets grouped by fields
 *
 * @param $is_conditional (int)
 *   Whether or not the facet value is based on a condition (expressed as PHP code)
 *
 * @return (Array)
 *   like array(field_name1 => array(facet1, facet2....), field_name2 => array(...))
 */
function xc_index_get_all_facets_group_by_field($is_conditional = 0) {
  if (!in_array($is_conditional, array(-1, 0, 1))) {
    $is_conditional = -1;
  }

  $facets = array();
  // xc_index_field_to_facet: list of schema field (field) and facet name (facet) pairs
  // xc_index_facet: properties of a facet (name, label, type, is_conditional, conditions (PHP code), enabled)
  $sql = 'SELECT ftf.*, facet.type, facet.is_conditional FROM {xc_index_field_to_facet} AS ftf
      LEFT JOIN {xc_index_facet} as facet ON ftf.facet = facet.name
      WHERE facet.enabled = 1';
  if ($is_conditional == 0 || $is_conditional == 1) {
    $sql .= ' AND facet.is_conditional = :d';
  }

  $result = db_query($sql, array(':d' =>$is_conditional));
  foreach($result as $data) {
    $facets[$data->field][] = array(
      'name' => $data->facet,
      'type' => $data->type,
      'is_conditional' => (int) $data->is_conditional,
    );
  }
  return $facets;
}

/**
 * Decide whether a given facet exists or not
 *
 * @param $facet (String)
 *   The name of the facet
 *
 * @return (boolean)
 *   TRUE if the facet exists, otherwise FALSE
 */
function xc_index_facet_exists($facet) { 
  $count = db_query('SELECT COUNT(*) FROM {xc_index_facet} WHERE name = :name', array(':name' => $facet))->fetchField();
  return ($count == 0 ? FALSE : TRUE);
}

/**
 * Gets all facet aliases belonging to a given metadata schema
 *
 * @param string $schema
 *   The name of metadata schema
 * @param boolean $include_contidionals
 *   Whether include conditional facets
 *
 * @return unknown_type
 */
function xc_index_facet_mapping_get_facets($schema = NULL, $include_contidionals = FALSE) {
  static $cache;

  if (!isset($cache[$schema][(int) $include_contidionals])) {
    $aliases = array();

    $sql = 'SELECT DISTINCT (name) FROM {xc_index_facet}';
    if (!$include_contidionals) {
      $sql .= ' WHERE is_conditional = 0';
    }

    require_once drupal_get_path('module', 'xc_metadata') . '/includes/xc_metadata.format.inc';
    $schemas = xc_format_get_schemas();
    if (!is_null($schema) && in_array($schema, $schemas)) {
      $sql .= ($include_contidionals) ? ' WHERE ' : ' AND ';
      $sql .= ' metadata_schema = \'%s\'';
    }

    $result = db_query($sql, $schema);
    //while ($data = db_fetch_object($result)) {
    foreach($result as $data) {
      $aliases[$data->name] = 'facet: ' . $data->name;
    }
    $cache[$schema][(int) $include_contidionals] = $aliases;
  }
  return $cache[$schema][(int) $include_contidionals];
}

/** LOADER functions
 *  ---------------- */

/**
 * Loads the information about a metadata entity
 *
 * @param $entity_name (string)
 *   The name of entity
 *
 * @return (array)
 *   An associative array of metadata schema. The keys are
 *   - title: title of the entity
 *   - description: description of the entity
 *   - group: the group in which this entity exists
 *   - fields: list of fields
 *   - parents: the list of names of parent entities
 *   - children: the list of names of children entities
 *   - namespaces: list of namespaces used in the entity
 *   - entity_name: the name of entity (like 'manifestation')
 *   - metadata_schema: the name of metadata schema (like 'xc')
 */
function xc_index_attribute_metadata_load($entity_name) {
  static $cache;
  if (!isset($entity_name) || trim($entity_name) == '') {
    return NULL;
  }

  if (!isset($cache[$entity_name])) {
    require_once drupal_get_path('module', 'xc_metadata') . '/includes/xc_metadata.format.inc';

    $schemas = module_invoke_all('xc_schema');
    $schema = $schemas[$entity_name];
    $schema['entity_name'] = $entity_name;
    $schema['metadata_schema'] = xc_format_get_schema_by_entity($entity_name);
    $cache[$entity_name] = $schema;
  }

  return $cache[$entity_name];
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_index_facet_load($facet_id) {
  static $xc_index_facet_load_cache;
  if (!isset($xc_index_facet_load_cache[$facet_id])) {
    $result = db_query('SELECT * FROM {xc_index_facet} WHERE facet_id = :facet_id', array(':facet_id' => $facet_id));
    $xc_index_facet_load_cache[$facet_id] = db_fetch_object($result);
  }
  return $xc_index_facet_load_cache[$facet_id];
}

/**
 * Get the index facet properties.
 *
 * @param $facet_name (string)
 *   The name properties of the stored index facet
 *
 * @return (Object)
 *   The stored index facet with the following properties:
 *   - facet_id (int),
 *   - name (machine name),
 *   - label (human readable),
 *   - type ('_fc' or '_df'),
 *   - is_conditional (0 or 1),
 *   - conditions (PHP code used during indexing)
 */
function xc_index_facet_load_by_name($facet_name) {
  static $cache;

  if (!isset($cache[$facet_name])) {
    $record = db_query('SELECT * FROM {xc_index_facet} WHERE name = :name', array(':name' => $facet_name))->fetchObject();
    $cache[$facet_name] = $record;
  }
  return $cache[$facet_name];
}

/**
 * Loads the list of fields for a metadata schema
 *
 * @param $metadata_schema (string)
 *   The name of metadata schema like 'xc'
 *
 * @return (array)
 *   An associative array with the following keys:
 *   - metadata_schema: the metadata schema name
 *   - fields: the list of fields used in this metadata schema
 */
function xc_index_field_type_metadata_load($metadata_schema) {
  if (!isset($metadata_schema) || trim($metadata_schema) == '') {
    return NULL;
  }

  require_once drupal_get_path('module', 'xc_metadata') . '/includes/xc_metadata.format.inc';
  $fields = xc_format_get_fields($metadata_schema);

  return array(
    'metadata_schema' => $metadata_schema,
    'fields' => $fields,
  );
}

/**
 * @param unknown_type $document
 * @param unknown_type $metadata
 */
function xc_index_format_facet(&$document, &$metadata) {
  static $cache, $all_fields, $smallcase_fields, $common, $default_values;
  global $_oaiharvester_statistics;

  $ft1 = microtime(TRUE);
  if (!isset($all_fields)) {
    $all_fields = array(
      'xc:type007',
      'dcterms:type',
      'xc:typeLeader06',
      'rdvocab:modeOfIssuance',
      'rdvocab:dimensions',
      'xc:typeSMD',
      'dcterms:identifier',
      'dcterms:hasVersion',
    );
  }

  if (!isset($common->smallcase_fields)) {
    $common->smallcase_fields = array('xc:type007', 'dcterms:type', 'xc:typeLeader06', 'dcterms:identifier');
    $common->non_smallcase_fields = array_diff($all_fields, $common->smallcase_fields);
  }

  if (!isset($cache)) {
    $cache = array(
      'maps/xc:type007' => array('map', 'globe'),
      'maps/xc:typeLeader06' => array('cartographic material', 'manuscript cartographic material'),
      'other/dcterms:type' => array('physicalObject', 'tactile material', 'kit', 'multiple'),
      'other/xc:type007' => array('tactile material', 'kit', 'multiple'),
      'film/xc:type007' => array('motion picture', 'videorecording', 'video recording'),
    );
  }

  if (!isset($default_values)) {
    $default_values = array(t('Not Online'), t('Not microform'));
  }

  $xc_record = array();
  foreach ($common->smallcase_fields as $field) {
    if (!isset($metadata[$field])) {
      continue;
    }
    $instances = (array) $metadata[$field];
    foreach ($instances as $instance) {
      $xc_record[$field][] = strtolower($instance['#value']);
    }
  }

  foreach ($common->non_smallcase_fields as $field) {
    if (isset($metadata[$field]) && count($metadata[$field]) > 1
         && $field != 'dcterms:hasVersion'
         && $field != 'rdvocab:dimensions' // [0]['#value'] => '32 cm. +', [1]['#value'] => '34 cm.'
        ) {
      xc_log_error('solr', 'multiple instances of ' . $field . ' in ' . join(', ', $document->metadata_id_s)
          . ': ' . var_export($metadata[$field], TRUE));
    }

    if (isset($metadata[$field])) {
      $xc_record[$field] = strtolower($metadata[$field][0]['#value']);
    }
  }

  // create a type007 proxy as assoc array, to use to check existence of values
  $type007 = array();
  if (isset($xc_record['xc:type007'])) {
    foreach ($xc_record['xc:type007'] as $type) {
      $type007[$type] = 1;
    }
  }

  $dcterms_type = array();
  if (isset($xc_record['dcterms:type'])) {
    foreach ($xc_record['dcterms:type'] as $type) {
      $dcterms_type[$type] = 1;
    }
  }

  $ft2 = microtime(TRUE);
  xc_oaiharvester_statistics_set('03 step3/02 iterator/01 xc_solr_onestop_indexer/02 format facet/01 prepare', $ft2 - $ft1);

  $facets = array();
  if (   (!empty($xc_record['dcterms:hasVersion'])
          && xc_util_contains_url($xc_record['dcterms:hasVersion']))
       ||
         (isset($xc_record['xc:type007'])
          && isset($type007['electronic resource'])
          && isset($xc_record['dcterms:identifier'])
          && xc_util_contains_url($xc_record['dcterms:identifier']))) {
    $facets[] = t('Online');
  }
  else {
    $facets[] = t('Not online');
  }
  $ft3 = microtime(TRUE);
  xc_oaiharvester_statistics_set('03 step3/02 iterator/01 xc_solr_onestop_indexer/02 format facet/02 Online', $ft3 - $ft2);

  if (!empty($type007) && isset($type007['microform'])) {
    $facets[] = t('Microform');
  }
  else {
    $facets[] = t('Not microform');
  }
  $ft4 = microtime(TRUE);
  xc_oaiharvester_statistics_set('03 step3/02 iterator/01 xc_solr_onestop_indexer/02 format facet/03 Microform', $ft4 - $ft3);

  if (isset($xc_record['rdvocab:modeOfIssuance'])
      && $xc_record['rdvocab:modeOfIssuance'] == 'serial') {
    $facets[] = t('Journals');
  }
  $ft5 = microtime(TRUE);
  xc_oaiharvester_statistics_set('03 step3/02 iterator/01 xc_solr_onestop_indexer/02 format facet/04 Journals', $ft5 - $ft4);

  if ((!empty($type007) && xc_util_contains($xc_record['xc:type007'], $cache['maps/xc:type007']))
       || (  isset($xc_record['xc:typeLeader06'])
         && !empty($xc_record['xc:typeLeader06'])
         && xc_util_contains($xc_record['xc:typeLeader06'], $cache['maps/xc:typeLeader06']))) {
    $facets[] = t('Maps');
  }
  $ft6 = microtime(TRUE);
  xc_oaiharvester_statistics_set('03 step3/02 iterator/01 xc_solr_onestop_indexer/02 format facet/05 Maps', $ft6 - $ft5);

  if (!empty($type007) && isset($type007['notated music'])) {
    $facets[] = t('Musical scores');
  }
  $ft7 = microtime(TRUE);
  xc_oaiharvester_statistics_set('03 step3/02 iterator/01 xc_solr_onestop_indexer/02 format facet/06 Musical scores', $ft7 - $ft6);

  if (!empty($dcterms_type)) {
    if (isset($dcterms_type['text'])
        && isset($xc_record['rdvocab:modeOfIssuance'])
        && $xc_record['rdvocab:modeOfIssuance'] != 'serial') {
      $facets[] = t('Books, texts');
    }

    if (isset($dcterms_type['sound'])) {
      $facets[] = t('Sound recordings');
    }

    if (isset($dcterms_type['sound'])
         && isset($xc_record['rdvocab:dimensions'])
         && $xc_record['rdvocab:dimensions'] == '4 3/4 in.') {
      $facets[] = t('Audio CDs');
    }

    if (isset($dcterms_type['stillimage'])) {
      $facets[] = t('Still images');
    }

    if (xc_util_contains($xc_record['dcterms:type'], $cache['other/dcterms:type'])
         && $xc_record['rdvocab:modeOfIssuance'] != 'serial'
         && xc_util_contains($xc_record['xc:type007'], $cache['other/xc:type007'])) {
      $facets[] = t('Other');
    }
  }
  $ft8 = microtime(TRUE);
  xc_oaiharvester_statistics_set('03 step3/02 iterator/01 xc_solr_onestop_indexer/02 format facet/07 dcterms:type', $ft8 - $ft7);

  if (!empty($type007) && xc_util_contains($xc_record['xc:type007'], $cache['film/xc:type007'])) {
    $facets[] = t('Films, videos');
  }
  $ft9 = microtime(TRUE);
  xc_oaiharvester_statistics_set('03 step3/02 iterator/01 xc_solr_onestop_indexer/02 format facet/08 Films, videos', $ft9 - $ft8);

  if (isset($xc_record['xc:typeSMD']) && $xc_record['xc:typeSMD'] == 'videodisc') {
    $facets[] = t('DVDs');
  }
  $ft10 = microtime(TRUE);
  xc_oaiharvester_statistics_set('03 step3/02 iterator/01 xc_solr_onestop_indexer/02 format facet/09 DVDs', $ft10 - $ft9);

  if ($facets == $default_values) {
    $msg = 'xc:type007: ' . var_export($xc_record['xc:type007'], TRUE)
      . ', dcterms:identifier: ' .  var_export($xc_record['dcterms:identifier'], TRUE)
      . ', is_url(dcterms:identifier): ' .  xc_util_contains_url($xc_record['dcterms:identifier'])
      . ', dcterms:type: ' .  var_export($xc_record['dcterms:type'], TRUE)
      . ', rdvocab:modeOfIssuance: ' .  $xc_record['rdvocab:modeOfIssuance']
      . ', rdvocab:dimensions: ' .  $xc_record['rdvocab:dimensions']
      . ', xc:typeSMD: ' .  $xc_record['xc:typeSMD'];
    xc_log_error('format facet', 'Unresolved format facet <a href="node/' . $doc->node_id
    . '">in this node</a>. Relevant fields are: ' . $msg);
  }
  $ft11 = microtime(TRUE);
  xc_oaiharvester_statistics_set('03 step3/02 iterator/01 xc_solr_onestop_indexer/02 format facet/10 errors', $ft10 - $ft9);

  xc_solr_add_fields($document, 'format_fc', $facets);
}

/**
 * Implements hook_xc_process_facet_<facetname>().
 *
 * @param $document (Object)
 *   The Solr document
 * @param $metadata (array)
 *   The metadata array
 * @param $fields (array)
 *   The fields to index
 */
function xc_index_xc_process_facet_type_of_content_fc(&$document, &$metadata, &$fields) {
  static $facet = 'type_of_content_fc', $all_fields, $direct_fields;

  if (!isset($all_fields)) {
    $all_fields = array(
      'dcterms:audience',
      'rdvocab:natureOfTheContent',
      'rdvocab:natureOfContent',
      'rdvocab:dissertationOrThesesInformation',
      'rdvocab:dissertationOrThesisInformation',
    );
  }
  if (!isset($direct_fields)) {
    $direct_fields = array('dcterms:audience', 'rdvocab:natureOfTheContent', 'rdvocab:natureOfContent');
  }

  $values = array();
  foreach ($direct_fields as $field) {
    if (!empty($metadata[$field])) {
      foreach ($metadata[$field] as $instance) {
        $values[] = $instance['#value'];
      }
    }
  }

  if (!empty($metadata['rdvocab:dissertationOrThesesInformation'])
       || !empty($metadata['rdvocab:dissertationOrThesisInformation'])) {
    $values[] = t('Thesis/dissertation');
  }

  if (!empty($values)) {
    // remove duplicates
    if (count($values) > 1) {
      $values = array_values(array_unique($values));
    }

    xc_solr_add_fields($document, $facet, $values);
  }
}

/**
 * Implements hook_xc_process_facet_FACET().
 */
function xc_index_xc_process_facet_subject_fc(&$document, &$metadata, &$fields) {
  xc_index_clear_subject($document, $metadata, $fields, 'subject_fc');
}

/**
 * Implements hook_xc_process_facet_FACET().
 */
function xc_index_xc_process_facet_subject_spatial_fc(&$document, &$metadata, &$fields) {
  xc_index_clear_subject($document, $metadata, $fields, 'subject_spatial_fc');
}

/**
 * Implements hook_xc_process_facet_FACET().
 */
function xc_index_xc_process_facet_subject_topic_fc(&$document, &$metadata, &$fields) {
  xc_index_clear_subject($document, $metadata, $fields, 'subject_topic_fc');
}

/**
 * Implements hook_xc_process_facet_FACET().
 */
function xc_index_xc_process_facet_subject_temporal_fc(&$document, &$metadata, &$fields) {
  xc_index_clear_subject($document, $metadata, $fields, 'subject_temporal_fc');
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_index_clear_subject(&$document, &$metadata, &$fields, $facet) {
  static $excludable_types = array(
    'dcterms:LCC' => 1,
    'dcterms:DDC' => 1,
    'dcterms:NLM' => 1,
    'dcterms:NDC8' => 1,
    'xc:LCC' => 1,
    'xc:DDC' => 1,
    'xc:NLM' => 1,
    'xc:NDC8' => 1,
  );

  $values = array();
  foreach ($fields as $field) {
    foreach ($metadata[$field] as $instance) {
      if (!isset($instance['@type']) || !isset($excludable_types[$instance['@type']])) {
        $values[] = _xc_solr_clean($instance['#value']);
      }
    }
  }

  if (!empty($values)) {
    // remove duplicates
    if (count($values) > 1) {
      $values = array_values(array_unique($values));
    }

    xc_solr_add_fields($document, $facet, $values);
  }
}

/**
 * Implements hook_xc_process_facet_FACET().
 *
 * Add facet values for superlocation_fc facet at indexing time.
 *
 * @param $document (Object)
 *   The Solr Document object
 * @param $metadata (array)
 *   The metadata array
 * @param $fields (array)
 *   List of field names
 */
function xc_index_xc_process_facet_superlocation_fc(&$document, &$metadata, &$fields) {
  if (isset($metadata['xc:location'])) {
    $values = array();
    foreach ($metadata['xc:location'] as $instance) {
      $values = array_merge($values, xc_index_get_super_location($instance['#value']));
    }

    if (!empty($values)) {
      // remove duplicates
      if (count($values) > 1) {
        $values = array_values(array_unique($values));
      }

      xc_solr_add_fields($document, 'superlocation_fc', $values);
    }
  }
}

/**
 * Get super location display name
 *
 * @param $location_code (String)
 *   The code of location
 *
 * @return (String)
 *   The display name of location
 */
function xc_index_get_super_location($location_code) {
  static $cache;

  if (!isset($cache[$location_code])) {
    $result = db_query("SELECT label FROM {xc_index_super_location} WHERE code = :code", array(':code' => $location_code));
    $labels = array();
    //while ($data = db_fetch_object($result)) {
    foreach($result as $data) {
      $labels[] = $data->label;
    }

    if (empty($labels)) {
      $labels[] = $location_code;
    }

    $cache[$location_code] = $labels;
  }

  return $cache[$location_code];
}

/**
 * Check the consystency of the indexable and the actually indexed fields.
 *
 * @return (Object)
 *   A consistency report object has two fields:
 *   - status: an integer reflecting the status of consistency. Possible values are:
 *             WATCHDOG_CRITICAL, WATCHDOG_WARNING, WATCHDOG_INFO
 *   - description: an array or error messages
 */
function xc_index_check_consistency() {
  $consistency = (object) array(
    'status' => WATCHDOG_INFO,
    'description' => array(),
  );

  // compare times
  // DATE_ISO8601 = 2005-08-14T16:13:03+0000
  // $solr_date = DateTime::createFromFormat(DATE_ISO8601, xc_solr_last_modified());
  $xc_solr_last_modified = xc_solr_last_modified();
  $definition_time = variable_get('xc_index_definition_modification_time', time());
  if ($definition_time > $xc_solr_last_modified) {
    $consistency->status = WATCHDOG_CRITICAL;
    $consistency->description = array(t(
      'The index definitions was changed (!definition_time) since the last Solr index modification (!solr_time).',
      array(
        '!definition_time' => format_date($definition_time, 'custom', 'Y-m-d H:i:s'),
        '!solr_time' => format_date(strtotime($xc_solr_last_modified), 'custom', 'Y-m-d H:i:s'),
      )
    ));
  }

  // compare fields
  $common_fields = array(
    'source_id_s',
    'type',
    'timestamp',
    'id',
    'metadata_id_s',
    'node_type_s',
    'text',
    'text_icu',
    'node_id_i',
    'metadata_type_s',
    'metadata_tsn',
  );
  $solr_fields = array_diff(xc_solr_list_fields(), $common_fields); // get solr fields
  $defined_fields = xc_solr_fields2index_list('simple');
  $applied_fields = variable_get('xc_solr_fields2index_list_applied', array());

  require_once 'xc_index_facet.inc';
  $conditional_facets = xc_index_facet_list_conditionals();
  $conditionals = array();
  foreach ($conditional_facets as $facet) {
    $conditionals[] = $facet->name . $facet->type;
  }

  $indexed_but_not_defined = array_diff($solr_fields, $defined_fields);
  if (!empty($applied_fields)) {
    $not_indexed_new = array_diff($defined_fields, $applied_fields);
    $applied_but_not_indexed = array_diff($applied_fields, $solr_fields);
    $not_indexed_conditionals = array_intersect($applied_but_not_indexed, $conditionals);
    $not_indexed_missing_data = array_diff($applied_but_not_indexed, $not_indexed_conditionals);
  }
  else {
    $not_indexed_new = array_diff($defined_fields, $solr_fields);
    $not_indexed_conditionals = array_intersect($not_indexed_new, $conditionals);
    $not_indexed_missing_data = array();
  }

  $problems = array();
  if (!empty($indexed_but_not_defined)) {
    $min_max = array();
    foreach ($indexed_but_not_defined as $field) {
      if (preg_match('/_(min|max)_(sdt|ss)$/', $field)) {
        $min_max[] = $field;
      }
    }
    $indexed_but_not_defined = array_diff($indexed_but_not_defined, $min_max);
    if (!empty($indexed_but_not_defined)) {
      $problems[] = t('The following fields are still in index, though they are not already defined: %fields.',
        array('%fields' => join(', ', $indexed_but_not_defined)));
    }
  }

  // TODO: need revision!!
  if (isset($not_indexed_new) && !empty($not_indexed_new)) {
    $problems[] = t('The following fields are defined to index, though they are still not indexed: %fields.',
      array('%fields' => join(', ', $not_indexed_new))); // $defined_but_not_indexed
  }

  if (!empty($not_indexed_conditionals)) {
    $problems[] = t('The following conditional facet(s) are defined but not indexed: %fields. It may worth revisiting the PHP codes which create the content of those fields, it is possible, that the missing inside index can be originated to a coding problem.',
       array('%fields' => join(', ', $not_indexed_conditionals)));
  }

  if (!empty($not_indexed_missing_data)) {
    $warnings[] = t('The following fields were not indexed possibly due to missing data: %fields.',
      array('%fields' => join(', ', $not_indexed_missing_data)));
  }

  if (!empty($problems) || !empty($warnings)) {
    if (!empty($problems)) {
      $consistency->status = WATCHDOG_CRITICAL;
      if ($consistency->status == WATCHDOG_INFO) {
        $consistency->description = $problems;
      }
      else {
        $consistency->description = array_merge($consistency->description, $problems);
      }
      if (!empty($warnings)) {
        $consistency->description = array_merge($consistency->description, $warnings);
      }
    }
    else {
      $consistency->status = WATCHDOG_WARNING;
      $consistency->description = array_merge($consistency->description, $warnings);
    }
  }
  else {
    if ($consistency->status != WATCHDOG_INFO) {
      $consistency->description[] = t('We do not have enough information about the nature of your changes. Please consider reindexing.');
    }
    else {
      $consistency->description[] = t('The index definitions are in consistent state with Solr index.');
    }
  }

  return $consistency;
}

/**
 * Theming index consistency report (differences between index definition and current state of index).
 *
 * @param $consistency (Object)
 *   Fields:
 *   'status': the status of consistency (WATCHDOG_INFO, WATCHDOG_WARNING or WATCHDOG_CRITICAL)
 *   'description' (array): the description of consistency, and the cause of possible problems
 *
 * @return (String)
 *   A formatted report
 */
function theme_xc_index_consistency($variables) {
  $consistency = $variables['consistency'];
  $text = '';
  // $class = $consistency->status != WATCHDOG_CRITICAL ? ' class="critical"' : '';
  $text .= theme('item_list', array('items' => $consistency->description));
  if ($consistency->status != WATCHDOG_INFO) {
    $text .= '<p>'
          . t('To apply your changes, you have to reindex your Solr server. !click_here',
            array('!click_here' => l(t('Click here'), 'admin/xc/solr/onestop')))
          . '</p>';
  }

  return $text;
}
