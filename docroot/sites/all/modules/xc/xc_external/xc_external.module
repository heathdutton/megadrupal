<?php
/**
 * @file
 * XC External Searvices Framework module functions
 *
 * Integrates external web services into the search result list or into the bibliographical description
 *
 * @copyright (c) 2010-2011 eXtensible Catalog Organization
 */

/**
 * Type for small cover image.
 * @var string
 */
define('XC_EX_COVER_SMALL', 'cover_small');

/**
 * Type for medium size cover image.
 * @var string
 */
define('XC_EX_COVER_MEDIUM', 'cover_medium');

/**
 * Type for large cover image.
 * @var string
 */
define('XC_EX_COVER_LARGE', 'cover_large');

/**
 * Type for index page.
 * @var string
 */
define('XC_EX_INDEX', 'index');

/**
 * Type for document summary.
 * @var string
 */
define('XC_EX_SUMMARY', 'summary');

/**
 * Type for sample chapter.
 * @var string
 */
define('XC_EX_SAMPLE_CHAPTER', 'sample_chapter');

/**
 * Type for table of contents.
 * @var string
 */
define('XC_EX_TOC', 'toc');

/**
 * Type for review.
 * @var string
 */
define('XC_EX_REVIEW', 'review');

/**
 * Type for comment.
 * @var string
 */
define('XC_EX_COMMENT', 'comment');

/**
 * Cache timeout.
 * @var int
 */
define('XC_EX_TIMEOUT', 60 * 60 * 24);

/**
 * Implements hook_init().
 */
function xc_external_init() {
  /*
   // This lines are commented out, because they are not used at this time. Planned to use them later.
   global $_xc_external_service_types;
   $_xc_external_service_types = array(
   'XC_EX_COVER_SMALL', 'XC_EX_COVER_MEDIUM', 'XC_EX_COVER_LARGE', 'XC_EX_INDEX',
   'XC_EX_SUMMARY', 'XC_EX_SAMPLE_CHAPTER', 'XC_EX_TOC', 'XC_EX_REVIEW',
   'XC_EX_COMMENT',
   );
   */
}

/**
 * Get all stored object belongs to a given identifier and identifier type pair.
 *
 * @param $id (string)
 *   An external identifier
 * @param $id_type (string)
 *   An external identifier type, such as ISBN, OCLC.
 *
 * @return array
 *   The list of stored objects.
 */
function xc_external_get_all_by_id($id, $id_type) {
  static $sql;
  if (!isset($sql)) {
    $sql = "SELECT info.* FROM {xc_external_connection} AS conn,
            LEFT JOIN {xc_external} AS info ON conn.external_id = info.external_id
              WHERE conn.identifier_type = '%s'
                AND conn.identifier = '%s'";
  }

  xc_external_clear_old_entries();
  $result = db_query("SELECT info.* FROM {xc_external_connection} AS conn,
            LEFT JOIN {xc_external} AS info ON conn.external_id = info.external_id
              WHERE conn.identifier_type = :conn.identifier_type
                AND conn.identifier = :conn.identifier", array(':conn.identifier_type' => $id, ':conn.identifier' => $id_type));

  $objects = array();
  //while ($data = db_fetch_object($result)) {
  foreach ($result as $data) {
    $objects[] = $data;
  }

  return $objects;
}

/**
 * Get the stored object by an identifier
 *
 * @param $id (String)
 *   An identifier
 * @param $id_type (String)
 *   An identifier type
 * @param $service_type (String)
 *   A service type
 * @param $do_trace (Boolean)
 *   Flag whether or not to log the SQL query (default: FALSE)
 *
 * @return (Object)
 *   An xc_external record object. Properties: external_id, service_provider,
 *   service_type, updated_at, error, service_url, service_content
 */
function xc_external_get_object_by_id($id, $id_type, $service_type, $do_trace = FALSE) {
  static $cache, $sql, $do_clear;

  if (!isset($do_clear)) {
    xc_external_clear_old_entries();
    $do_clear = FALSE;
  }

  if (!isset($cache[$id][$id_type][$service_type])) {
    if (!isset($sql)) {
      $sql = 'SELECT info.* FROM {xc_external_connection} AS conn
              LEFT JOIN {xc_external} AS info ON conn.external_id = info.external_id
              WHERE conn.identifier_type = :conn.identifier_type
                AND conn.identifier = :conn.identifier
                AND info.service_type = :info.service_type
                AND info.updated_at >= :info.updated_at';
    }
    $timeframe = format_date(time() - XC_EX_TIMEOUT, 'custom', 'Y-m-d H:i:s');
    //TODO from Tom
    $final_sql = xc_util_get_sql($sql, $id_type, $id, $service_type, $timeframe);
    $result = db_query($sql, array(':conn.identifier_type' => $id_type, ':conn.identifier' => $id, ':info.service_type' => $service_type, ':info.updated_at' => $timeframe));
    $connections = array();
    $i = 0;
    foreach ($result as $data) {
      $i++;
      $connections[] = $data;
    }
    if ($do_trace) {
      xc_log_info('xc_external', $service_type . ' => ' . $i . ' ' . $final_sql);
    }
    $cache[$id][$id_type][$service_type] = $connections;
  }
  return $cache[$id][$id_type][$service_type];
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function xc_external_get_object_by_ids($ids, $service_type, $do_trace = FALSE) {
  static $cache, $sql, $do_clear;

  if (!isset($do_clear)) {
    xc_external_clear_old_entries();
    $do_clear = FALSE;
  }
  //TODO from Tom, need to check on this query
  if (!isset($sql)) {
    $sql = <<< END
SELECT info.* FROM {xc_external_connection} AS conn
  LEFT JOIN {xc_external} AS info ON conn.external_id = info.external_id
  WHERE info.service_type = :service_type
    AND info.updated_at >= :updated_at
END;
  }

  $types = array();
  foreach ($ids as $type => $values) {
    if (empty($values)) {
      continue;
    }
    $criteria = "(conn.identifier_type = '$type' AND conn.identifier = ";
    if (is_array($values)) {
      $criteria .= "('" . join("' OR '", $values) . "')";
    }
    else {
      $criteria .= "'$values'";
    }
    $types[] = $criteria . ')';
  }
  $sql_full = $sql . "\n" . ' AND (' . join("\n OR ", $types) . ')';

  $timeframe = format_date(time() - XC_EX_TIMEOUT, 'custom', 'Y-m-d H:i:s');
  // xc_log_info('external', xc_util_get_sql($sql_full, $service_type, $timeframe));
  // TODO Please convert this statement to the D7 database API syntax.
  $result = db_query($sql_full, array(
    ':service_type' => $service_type,
    ':updated_at' => $timeframe)
  );

  $connections = array();
  $i = 0;
  $found_keys = array();
  foreach ($result as $data) {
    $i++;
    if (!isset($found_keys[$data->external_id])) {
      $connections[] = $data;
      $found_keys[$data->external_id] = 1;
    }
  }

  if ($do_trace) {
    $final_sql = xc_util_get_sql($sql_full, $service_type, $timeframe);
    xc_log_info('xc_external', $service_type . ' => ' . $i . ' ' . $final_sql);
  }

  return $connections;
}

/**
 * Clears old cahced values
 *
 * @param $service_provider (String)
 *   The service provider, like Syndetics.
 */
function xc_external_clear_old_entries($service_provider = 'Syndetics') {
  static $checked;

  if ($checked === TRUE) {
    return;
  }
  $checked = TRUE;

  $today = format_date(time(), 'custom', 'Y-m-d');
  if (variable_get('xc_external_last_checked', '') != $today) {
    $timeframe = format_date(time() - XC_EX_TIMEOUT, 'custom', 'Y-m-d H:i:s');
    $sql = "DELETE e, c FROM {xc_external_connection} AS c
            INNER JOIN {xc_external} AS e
            WHERE e.external_id = c.external_id
            AND e.updated_at <= :updated_at
            AND e.service_provider = :service_provider";
    db_query($sql, array(':updated_at'=>$timeframe,':service_provider'=> $service_provider));
    NULL;
    variable_set('xc_external_last_checked', $today);
  }
}


/**
 * Save a record into xc_external table.
 *
 * @param $service_provider (String)
 *   The service provider (like Syndetics)
 * @param $service_type (String)
 *   Service type
 * @param $error (String)
 *   Error message (if there is any)
 * @param $service_url (String)
 *   The URL of the service
 * @param $service_content (String)
 *   The content of the service - typically an XML
 *
 * @return (Object)
 *   An xc_external record object. Properties: external_id, service_provider,
 *   service_type, updated_at, error, service_url, service_content
 */
function xc_external_save_record($service_provider, $service_type, $error = '',
    $service_url, $service_content = '') {
  $record = new stdClass();
  $record->service_provider = $service_provider;
  $record->service_type     = $service_type;
  $record->updated_at       = format_date(time(), 'custom', 'Y-m-d H:i:s');
  $record->error            = $error;
  $record->service_url      = $service_url;
  $record->service_content  = $service_content;
  $result = drupal_write_record('xc_external', $record);
  return $record;
}

/**
 * Saves a connection between enhancements from external sources (xc_external table),
 * and its external identifiers. Such a content might have multiple identifiers,
 * and identifier types (e.g. ISBN, OCLC, UPC etc.).
 *
 * @param $identifier (string)
 *   The external identifier
 * @param $identifier_type (string)
 *   The type of the external identifier
 * @param $external_id (int)
 *   The internal record identifier of the enhancement (xc_external table's external_id field).
 */
function xc_external_save_connection($identifier, $identifier_type, $external_id) {
  $record = new stdClass();
  $record->identifier = $identifier;
  $record->identifier_type = $identifier_type;
  $record->external_id = $external_id;
  $result = drupal_write_record('xc_external_connection', $record);
}
