<?php

/**
 * @file
 * Hooks and classes for implement MongoDB-backed entities
 *
 * This module provides a custom EntityFieldQuery for MongoEntity
 * that uses db.collection.find. It also provides an EntityController
 * class that handles CRUD operations for the MongoEntity
 *
 * mongo_entity.module is a work in progress, and there is a lot to be done:
 * @todo implement caching when loading MongoEntities
 *
 * When defining Mongo Entities with hook_entity_info, a few extra parameters
 * are required:
 * - 'collection name': The Mongo Collection. It defaults to
 *   the entity type name
 *
 * Note that Mongo Entities do not use MongoDB's ObjectID; Drupal requires
 * entities to have a unique numeric ID, so the _id is generated from a
 * sequential Drupal variable stored in the SQL database, keyed by
 * entity type name.
 */

/**
 * Implements hook_menu().
 *
 * Allow custom MongoEntityController classes to implement a static
 * hook_menu function that will be added to the menu system.
 *
 * @todo Make sure hook_menu fires after hook_entity_info. It must, right?
 */
function mongo_entity_menu() {

  $items = array();
  $items['mongo-entity/embedded-entity-widget/callback'] = array(
    'page callback' => '_mongo_entity_embedded_entity_widget_callback',
    'access callback' => TRUE,
    'delivery callback' => 'ajax_deliver',
    'theme callback' => 'ajax_base_page_theme',
    'type' => MENU_CALLBACK,
  );
  $items['admin/structure/mongo-entities'] = array(
    'title' => 'Mongo Entity types',
    'description' => 'Manage Mongo Entity types, including fields and display settings.',
    'page callback' => 'mongo_entity_overview_types',
    'access arguments' => array('administer site configuration'),
  );

  foreach (entity_get_info() as $entity_type => $entity_info) {
    if (is_a($entity_info['controller class'], 'MongoEntityController', TRUE)) {
      $temp = $entity_info['controller class']::hook_menu();
      foreach ($temp as &$item) {
        if (empty($item['file path']) && !empty($entity_info['module'])) {
          $item['file path'] = drupal_get_path('module', $entity_info['module']);
        }
      }
      $items += $temp;
    }
  }

  return $items;

}

/**
 * Returns a page of Mongo Entity entity types, with links to manage fields and display
 */
function mongo_entity_overview_types() {

  $field_ui = module_exists('field_ui');

  $header = array(t('Name'), array('data' => t('Operations'), 'colspan' => $field_ui ? '4' : '2'));
  $rows = array();

  foreach (entity_get_info() as $entity_type => $entity_info) {
    if (is_a($entity_info['controller class'], 'MongoEntityController', TRUE)) {

      if ($field_ui && $entity_info['fieldable']) {

        foreach ($entity_info['bundles'] as $bundle) {

          $row = array();
          // @todo Add an edit function?
          $row[] = $bundle['label'];

          // Manage fields.
          $row[] = array('data' => l(t('manage fields'), (isset($bundle['admin']['real path']) ? $bundle['admin']['real path'] : $bundle['admin']['path']) . '/fields'));
          // Display fields.
          $row[] = array('data' => l(t('manage display'), (isset($bundle['admin']['real path']) ? $bundle['admin']['real path'] : $bundle['admin']['path']) . '/display'));
          $rows[] = $row;

        }

      }

    }

  }

  $build['table'] = array(
    '#theme' => 'table',
    '#header' => $header,
    '#rows' => $rows,
    '#empty' => t('No entity types available.'),
  );
  return $build;

}

/**
 * Implements hook_entity_property_info_alter().
 */
function mongo_entity_entity_property_info_alter(&$info) {

  foreach (entity_get_info() as $entity_type => $entity_info) {
    if (is_a($entity_info['controller class'], 'MongoEntityController', TRUE)) {
      if (!isset($info[$entity_type]['properties']['_id'])) {
        $info[$entity_type]['properties']['_id'] = array(
          'label' => 'ID',
          'type' => 'integer',
        );
        $info[$entity_type]['properties']['_bundle'] = array(
          'label' => 'Type',
          'type' => 'text',
        );
      }
    }
  }

}

/**
 * Implements hook_field_info().
 */
function mongo_entity_field_info() {

  $items = array();
  $items['embedded_entity'] = array(
    'label' => 'Embedded entity',
    'description' => t('An entity stored as a sub-document in a MongoDB collection.'),
    'settings' => array('entity_type' => NULL,),
    'instance_settings' => array(),
    'default_widget' => 'embedded_entity_widget',
    'default_formatter' => 'embedded_entity_view',
    'property_type' => 'entity',
    'property_callbacks' => array('mongo_entity_embedded_entity_property_callback'),
  );
  return $items;

}

function mongo_entity_embedded_entity_property_callback(&$info, $entity_type, $field, $instance, $field_type) {

  // Define a data structure for dealing with text that is formatted or has
  // a summary.
  $property = &$info[$entity_type]['bundles'][$instance['bundle']]['properties'][$field['field_name']];

  // Set the `type` of this property to the entity type in the field settings
  $embedded_entity_type = $field['settings']['entity_type'];
  $property['type'] = ($field['cardinality'] != 1) ? "list<{$embedded_entity_type}>" : $embedded_entity_type;

  // @todo add getter callback and (irish) setter callback

}


/**
 * Implements hook_field_settings_form().
 */
function mongo_entity_field_settings_form($field, $instance, $has_data) {

  $form = array();
  $form['entity_type'] = array(
    '#type' => 'select',
    '#title' => t('Entity type'),
    '#options' => array(),
    '#default_value' => $field['settings']['entity_type'],
  );

  $items = module_invoke_all('entity_info');
  foreach ($items as $entity_type => $entity_info) {
    if (isset($entity_info['controller class']) && is_a($entity_info['controller class'], 'MongoEmbeddedEntityController', TRUE)) {
      $form['entity_type']['#options'][$entity_type] = $entity_info['label'];
    }
  }

  return $form;

}

/**
 * Implements hook_field_instance_settings_form().
 */
function mongo_entity_field_instance_settings_form($field, $instance) {

  $form = array();
  return $form;

}

/**
 * Implements hook_field_widget_info().
 */
function mongo_entity_field_widget_info() {

  $items = array();
  $items['embedded_entity_widget'] = array(
    'label' => 'Embedded entity widget',
    'description' => t('An inline form for creating and editing embedded entities.'),
    'field types' => array('embedded_entity'),
    'settings' => array(),
  );
  $items['embedded_entity_none'] = array(
    'label' => 'None',
    'description' => t('Do not display a widget for this embedded entity.'),
    'field types' => array('embedded_entity'),
    'settings' => array(),
  );
  return $items;

}

/**
 * Implements hook_field_widget_form().
 */
function mongo_entity_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {

  if ($instance['widget']['type'] == 'embedded_entity_widget') {

    // Hide 'Default value' on settings form
    if (empty($element['#entity'])) {
      $form['#access'] = FALSE;
      return;
    }

    // Build a parents array for this element's values in the form.
    $parents = array_merge($element['#field_parents'], array($element['#field_name'], $element['#language'], $delta));

    // Cardinality
    $cardinality = $field['cardinality'];

    if ($cardinality == 1) {
      $element += array(
        '#type' => 'fieldset',
        '#title' => $instance['label'],
      );
    }

  /*
    // @todo don't create a new item on edit page
    if ($cardinality == -1 && $delta > 0 && mongo_entity_field_is_empty($items[$delta], $field)) {
      return NULL;
    }
  */

    $entity_type = $field['settings']['entity_type'];
    if (isset($items[$delta]['entity'])) {
      $entity = $items[$delta]['entity'];
    }
    else {
      $entity_info = entity_get_info($entity_type);

      if (count($entity_info['bundles']) > 1) {

        // Provide a dropdown for the user to select between bundles for this entity
        if (!empty($form_state['values'])) {
          $values = drupal_array_get_nested_value($form_state['values'], $parents);
          if (!empty($values['bundle'])) {
            $bundle = $values['bundle'];
          }
        }

        if (empty($bundle)) {
          $bundle = key($entity_info['bundles']);
        }

        $wrapper = "mongo-entity-embedded-entity-widget-{$field['field_name']}-{$delta}";
        $element['bundle'] = array(
          '#type' => 'select',
          '#title' => 'Bundle',
          '#default_value' => $bundle,
          '#options' => array(),
          '#ajax' => array(
            'path' => 'mongo-entity/embedded-entity-widget/callback',
            'wrapper' => $wrapper,
          ),
        );
        foreach ($entity_info['bundles'] as $key => $bundle_info) {
          $element['bundle']['#options'][$key] = $bundle_info['label'];
        }
        $element['#prefix'] = '<div id="' . $wrapper . '">';
        $element['#suffix'] = '</div>';

        $form_state['cache'] = TRUE;

        $entity = entity_create($entity_type, array('_bundle' => $bundle));

      }
      else {
        $bundle = key($entity_info['bundles']);
        $entity = entity_create($entity_type, array('_bundle' => $bundle));
      }
    }

    $element['#field'] = $field;
    $element['#instance'] = $instance;

    $element['#element_validate'][] = 'mongo_entity_field_widget_element_validate';

    // Allow empty values (even if some fields are required) if the embedded entity is not required
    // and if the item is the last one.
    if (!$element['#required'] && $delta == count($items)) {
      $element['#after_build'][] = 'mongo_entity_field_widget_after_build_not_required';
    }
    $element['#tree'] = TRUE;
    $element['#parents'] = $parents;
    $element['#entity_type'] = $entity_type;
    if (isset($entity->_id)) {
      $element['_id'] = array(
        '#type' => 'value',
        '#value' => $entity->_id,
      );
    }

    // @todo use the entity_ui_get_form function here
    field_attach_form($entity_type, $entity, $element, $form_state);
    $element['#entity'] = $entity;
  }

  return $element;

}

/**
 * AJAX callback to rebuild the embedded entity widget form element
 * when the bundle type is changed.
 */
function _mongo_entity_embedded_entity_widget_callback() {

  list($form, $form_state, $form_id) = ajax_get_form();

  $form_state['values'] = array();
  $form = form_builder($form_id, $form, $form_state);

  $form_state['rebuild'] = TRUE;
  $form = drupal_rebuild_form($form_id, $form_state, $form);

  $parents = $form_state['triggering_element']['#parents'];
  array_pop($parents);

  $element = drupal_array_get_nested_value($form, $parents);

  // Remove the _weight form element, since it is rendered outside of the wrapper
  unset($element['_weight']);

  return $element;

}

function _mongo_entity_element_validated(&$element) {

  // Remove the error for this element, and the associated error message
  $form = &drupal_static('form_set_error');
  $name = implode('][', $element['#parents']);
  if (isset($form[$name])) {
    $message = $form[$name];
    $message_index = array_search($message, $_SESSION['messages']['error']);
    unset($_SESSION['messages']['error'][$message_index]);
    unset($form[$name]);
  }

  $element['#validated'] = TRUE;
  foreach (element_children($element) as $key) {
    _mongo_entity_element_validated($element[$key]);
  }

}

/**
 * Gets the submitted values for this widget, and disables validation if
 * they are all empty
 */
function mongo_entity_field_widget_after_build_not_required($element, $form_state) {

  // Validate all the fields

  // Use a clone of the element and the form_state to do some validation
  // _form_validate changes the structure of the fields, especially select fields
  $element_copy = $element;
  $form_state_copy = $form_state;

  // Field is empty depends on validation functions to run first...
  _form_validate($element_copy, $form_state_copy);

  $entity_type = $element_copy['#entity_type'];
  $entity = $element_copy['#entity'];
  $field = $element_copy['#field'];
  $field_name = $field['field_name'];
  $langcode = LANGUAGE_NONE;
  $instance = $element_copy['#instance'];
  $delta = $element_copy['#delta'];

  $form = array();
  $form['#parents'] = array();

  $items = array();

  field_default_extract_form_values($entity_type, $entity, $field, $instance, $langcode, $items, $form, $form_state_copy);

  if (isset($items[$delta])) {
    $items = $items[$delta];
  }
  else {
    $items = NULL;
  }

  if ($items) {
    if (mongo_entity_field_is_empty($items, $field)) {
      // Reset validation errors
      _mongo_entity_element_validated($element);
    }
  }

  return $element;

}

/**
 * element_validate callback for embedded_entity fields
 */
function mongo_entity_field_widget_element_validate($element, &$form_state, $form) {

  field_attach_form_validate($element['#entity_type'], $element['#entity'], $element, $form_state);

}

/**
 * Implements hook_field_attach_submit().
 */
function mongo_entity_field_attach_submit($entity_type, $entity, $form, &$form_state) {

  list(,,$bundle) = entity_extract_ids($entity_type, $entity);

  foreach (field_info_instances($entity_type, $bundle) as $field_name => $instance) {

    // Loop through all the fields for this embedded entity
    if ($instance['widget']['module'] == 'mongo_entity' && $instance['widget']['type'] == 'embedded_entity_widget') {
      $field = field_info_field($field_name);

      $embedded_entity_type = $field['settings']['entity_type'];
      $embedded_entity_info = entity_get_info($embedded_entity_type);
      $embedded_entity_class = $embedded_entity_info['entity class'];

      $elements = $form[$field_name][LANGUAGE_NONE];

      // Get the values from this embedded entity form
      $items = array();
      field_default_extract_form_values($entity_type, $entity, $field, $instance, LANGUAGE_NONE, $items, $form, $form_state);

      foreach ($items as $delta => $item) {
        // If there are values for this element, attach them to the entity.
        if (!mongo_entity_field_is_empty($item, $field)) {
          $embedded_entity = $elements[$delta]['#entity'];
          field_attach_submit($embedded_entity_type, $embedded_entity, $elements[$delta], $form_state);
          $entity->{$field_name}[LANGUAGE_NONE][$delta] = array(
            'entity' => $embedded_entity,
          );
        }
        // Otherwise, delete this item
        else {
          unset($entity->{$field_name}[LANGUAGE_NONE][$delta]);
        }
      }

    }
  }

}

function mongo_entity_field_widget_settings_form($field, $instance) {

  $form = array();
  return $form;

}

/**
 * Implements hook_field_presave().
 */
function mongo_entity_field_presave($entity_type, $entity, $field, $instance, $langcode, &$items) {
  if ($field['type'] == 'embedded_entity') {
    // @todo Make sure that we don't need to do anything to programatically created embedded entities.
  }
}

function mongo_entity_field_formatter_info() {
  return array(
    'embedded_entity_view' => array(
      'label' => t('Rendered entity'),
      'description' => t('Display the embedded entities rendered by entity_view().'),
      'field types' => array('embedded_entity'),
    ),
  );
}

function mongo_entity_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $result = array();
  switch ($display['type']) {
    case 'embedded_entity_view':
      foreach ($items as $delta => $item) {
        $result[$delta] = entity_view($field['settings']['entity_type'], $item, 'default', $langcode, FALSE);
      }
      break;
  }
  return $result;
}

function mongo_entity_field_is_empty($item, $field) {

  $embedded_entity_type = $field['settings']['entity_type'];

  // Gah, iterate through every property for this field, and check if it is empty
  foreach (element_children($item) as $key) {

    // Ignore fields that start with an underscore, like _weight
    if (strpos($key, '_') === 0) {
      continue;
    }
    // If this looks like a field, test it like a field
    // @todo compare field names against the embedded entity type's fields
    if ($embedded_field = field_info_field($key)) {
      $function = $embedded_field['module'] . '_field_is_empty';
      // field_get_items doesn't work, because it doesn't know what bundle this item is
      $embedded_items = $item[$key][LANGUAGE_NONE];
      // @todo if this is called by mongo_entity_field_widget_after_build_not_required,
      // options_field_widget_validate hasn't run yet, so some values could still be _none
      // Bad options.module. Bad.
      if ($embedded_items && is_array($embedded_items)) {
        foreach ($embedded_items as $embedded_item) {
          if (!$function($embedded_item, $embedded_field)) {
            return FALSE;
          }
        }
      }
    }
    // Other wise, just check if its empty
    else {
      if (!empty($item)) {
        return FALSE;
      }
    }

  }

  return TRUE;

}

/**
 * Implements hook_ctools_plugin_directory().
 */
function mongo_entity_ctools_plugin_directory($module, $plugin) {
  if ($module == 'entityreference') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Implements hook_entity_info_alter().
 */
function mongo_entity_entity_info_alter(&$items) {

  // Force MongoEntities to use _id as their key.
  foreach ($items as $entity_type => &$entity_info) {

    if (isset($entity_info['controller class']) && is_a($entity_info['controller class'], 'MongoEntityController', TRUE)) {

      // Set a value for 'revisionable'
      if (!isset($entity_info['revisionable'])) {
        $entity_info['revisionable'] = FALSE;
      }

      // Set the id, revision and name key.
      $entity_info['entity keys']['id'] = '_id';
      if (!empty($entity_info['bundleable'])) {
        $entity_info['entity keys']['bundle'] = '_bundle';
      }
      if (!empty($entity_info['revisionable'])) {
        $entity_info['entity keys']['revision'] = '_revision_id';
      }

      // Set a default collection name.
      if (empty($entity_info['collection'])) {
        $entity_info['collection'] = $entity_type;
      }

      // Define collection indexes.
      // @todo Auto define embedded indexes.
      $collection = mongodb_collection($entity_info['collection']);
      // Add an index on the bundle
      if (!empty($entity_info['bundleable'])) {
        $collection->ensureIndex(array('_bundle' => 1));
      }
      // Add an index on the revision ID
      if (!empty($entity_info['revisionable'])) {
        $collection->ensureIndex(array('_revision_id' => 1));
      }
      if (!empty($entity_info['indexes'])) {
        foreach ($entity_info['indexes'] as $index) {
          if (is_array($index)) {

            // Support options for indexes.
            if (isset($index[0]) && is_array($index[0])) {
              // If the array is multidimensional, pass the first item as the keys, and the second as the options
              list($keys, $options) = $index;
              $collection->ensureIndex($keys, $options);
            }
            else {
              // Otherwise, just pass the argument as the keys
              $collection->ensureIndex($index);
            }
          }
          else {
            // @todo throw an exception, because $index must be an array
          }
        }
      }

      // Get Views to shut up about "undefined index".
      $entity_info['base table'] = '';

      // Get EFQ Views Backed to stop whining "in_array() expects parameter 2 to be array, null given in _efq_views_get_property_handlers()"
      $entity_info['schema_fields_sql']['base table'] = array();

      // Using the internal field cache is redundant. Disable it for all entities.
      $entity_info['field cache'] = FALSE;
    }

  }

  if (isset($items['node'])) {
//    $items['node']['controller class'] = 'MongoEntityNodeController';
  }

}

/**
 * Setting the type of field value.
 *
 * @param string $type
 *   Type of field
 * @param string $value
 *   Vaule of field
 *
 * @return string
 *   Returns the value
 */
function _mongo_entity_value($type, $value) {

  if (is_null($value)) {
    return NULL;
  }

  if (is_array($value)) {

    // allow NULL values in arrays
    foreach ($value as &$item) {
      $item = _mongo_entity_value($type, $item);
    }
    return $value;

  }
  else {

    switch ($type) {
      case 'int':
      case 'integer':
      case 'serial':
        return intval($value);

      case 'float':
        return floatval($value);

      case 'date':
        // Convert a timestamp to MongoDate
        return new MongoDate($value);

      case 'datetime':
        // Convert a datetime to MongoDate
        return new MongoDate(strtotime($value));

      case 'blob':
        return new MongoBinData($value, 2);

      default:
        return $value;

    }
  }

}

/**
 * Converts SQL-style field conditions into MongoDB conditions.
 *
 * Borrowed from mongodb_field_storage.module.
 */
function _mongo_entity_query_value($value, $operator, $type) {
  if (!isset($operator)) {
    $operator = is_array($value) ? 'IN' : '=';
  }

  // Convert values
  $value = _mongo_entity_value($type, $value);
  switch ($operator) {
    case '=':
      return $value;

    case 'IN':
      return array('$in' => $value);

    case 'NOT IN':
      return array('$nin' => $value);

    case 'ALL':
      return array('$all' => $value);

    case '<':
      return array('$lt' => $value);

    case '>':
      return array('$gt' => $value);

    case '<=':
      return array('$lte' => $value);

    case '>=':
      return array('$gte' => $value);

    case '!=':
    case '<>':
      return array('$ne' => $value);

    case 'STARTS_WITH':
      return new MongoRegex('/^' . $value . '/');

    case 'CONTAINS':
      return new MongoRegex('/' . $value . '/i');

    case 'BETWEEN':
      return array('$gte' => $value[0], '$lte' => $value[1]);

    default:
      throw new EntityFieldQueryException("$operator not implemented");

  }
}

/**
 * Implements hook_entity_query_alter().
 */
function mongo_entity_entity_query_alter($query) {

  if (isset($query->entityConditions['entity_type'])) {
    $entity_type = $query->entityConditions['entity_type']['value'];
    $entity_info = entity_get_info($entity_type);

    if (is_a($entity_info['controller class'], 'MongoEntityController', TRUE)) {
      $query->executeCallback = 'mongo_entity_query';
    }
  }
}

function _mongo_entity_get_controller($entity_type) {

  if ($entity_type && ($entity_info = entity_get_info($entity_type))) {
    return entity_get_controller($entity_type);
  }

}

function _mongo_entity_get_embedded_entity_controller($entity_type) {

  if (($controller = _mongo_entity_get_controller($entity_type)) && is_a($controller, 'MongoEmbeddedEntityController')) {
    return $controller;
  }

}

/**
 * Executes an EntityFieldQuery on a MongoDB collection.
 */
function mongo_entity_query($query) {

  $find = array();
  $entity_type = $query->entityConditions['entity_type']['value'];
  unset($query->entityConditions['entity_type']);

  // I borrowed a lot of this from mongodb_field_storage.
  if (isset($entity_type)) {

    // @todo handle revisions
    $entity_info = entity_get_info($entity_type);

    $entity_map = array(
      'entity_id' => '_id',
      'revision_id' => '_revision_id',
      'bundle' => '_bundle',
    );
    $type_map = array(
      'entity_id' => 'int',
      'revision_id' => 'int',
      'bundle' => 'text',
    );
    // @todo if not bundleable, don't use the bundle entity condition
    foreach ($query->entityConditions as $field => $data) {
      $value = $data['value'];
      $find[$entity_map[$field]][] = _mongo_entity_query_value($value, $data['operator'], $type_map[$field]);
    }
    foreach ($query->fieldConditions as $index => $data) {

      // If EFQ has already read the field info, use that.
      if (isset($data['field']['field_name'])) {

        $field_name = $data['field']['field_name'] . '.' . $data['column'];
        $type = $data['field']['columns'][$data['column']]['type'];

      // If this is an embedded field, the field data will be an array of field names.
      } else if (is_array($data['field'])){

        // Join the field names together to build the query
        $field_name = implode('.', $data['field']) . '.' . $data['column'];

        // Get the last field definition, and use that to get the column type
        $field_definition = field_info_field(end($data['field']));
        $type = $field_definition['columns'][$data['column']]['type'];

      }

      $find[$field_name][] = _mongo_entity_query_value($data['value'], $data['operator'], $type);
      unset($query->fields[$index]);

    }

    if ($query->propertyConditions) {

      foreach ($query->propertyConditions as $data) {
        $property_info = entity_get_property_info($entity_type);

        $props = explode('.', $data['column']);
        foreach ($props as $prop) {

          $type = isset($property_info['properties'][$prop]['type']) ? $property_info['properties'][$prop]['type'] : 'int';

          // structs don't have embedded entities. please continue
          if ($type == 'struct') {
            break;
          }

          // @todo Handle bundle entity conditions

          // If this is an embedded entity...
          if (_mongo_entity_get_embedded_entity_controller($type)) {
            $property_info = entity_get_property_info($type);
          }
        }

        // Treat each $find key as an array, just in case there are multiple conditions
        $find[$data['column']][] = _mongo_entity_query_value($data['value'], $data['operator'], $type);

      }
    }

    foreach ($find as $key => $value) {

      // Reduce the conditions for each key to a single value if there is only one condition for that key
      if (count($value) == 1) {
        $find[$key] = $value[0];
      }
      // Otherwise, combine each condition into an array, keyed by the operator.
      else {

        // Check to see if any of the values are scalar or have duplicate operators
        if (!array_filter($value, 'is_scalar') && !call_user_func_array('array_intersect_key', $value)) {
          // Use the implicit AND operation
          $find[$key] = array();
          for ($i = 0; $i < count($value); $i++) {
            $find[$key] += $value[$i];
          }

        }
        else {
          // Use the AND operation on all the properties
          unset($find[$key]);
          for ($i = 0; $i < count($value); $i++) {
            $find['$and'][] = array($key => $value[$i]);
          }
        }

      }

    }

    if ($controller = _mongo_entity_get_embedded_entity_controller($entity_type)) {

      $stubs = array();
      $count = 0;

      // Map the embedded entities by their field and property names
      $properties = $controller->getEmbeddedProperties();
      foreach ($properties as $property_name => $collection_names) {
        $order = (!empty($query->order))? $query->order : NULL;
        $range = (!empty($query->range))? $query->range : NULL;
        $parent_find = array();

        // If this is a MongoEmbeddedEntityFieldQuery, we need to add in the parent conditions as well.
        if (get_class($query) == 'MongoEmbeddedEntityFieldQuery') {
          foreach ($query->parentPropertyConditions as $data) {
            $props = explode('.', $data['column']);
            foreach ($props as $prop) {

              $type = isset($property_info['properties'][$prop]['type']) ? $property_info['properties'][$prop]['type'] : 'int';
              // @todo Handle bundle entity conditions

              // If this is an embedded entity...
              if (_mongo_entity_get_embedded_entity_controller($type)) {
                $property_info = entity_get_property_info($type);
              }
            }

            $parent_find[$data['column']] = _mongo_entity_query_value($data['value'], $data['operator'], $type);
          }
          foreach ($query->parentFieldConditions as $data) {
            // If EFQ has already read the field info, use that.
            if (isset($data['field']['field_name'])) {

              $field_name = $data['field']['field_name'] . '.' . $data['column'];
              $type = $data['field']['columns'][$data['column']]['type'];

            // If this is an embedded field, the field data will be an array of field names.
            }
            else if (is_array($data['field'])){

              // Join the field names together to build the query
              $field_name = implode('.', $data['field']) . '.' . $data['column'];

              // Get the last field definition, and use that to get the column type
              $field_definition = field_info_field(end($data['field']));
              $type = $field_definition['columns'][$data['column']]['type'];

            }

            if (isset($parent_find[$field_name])) {
              $parent_find[$field_name] = array_merge($parent_find[$field_name], _mongo_entity_query_value($data['value'], $data['operator'], $type));
            }
            else {
              $parent_find[$field_name] = _mongo_entity_query_value($data['value'], $data['operator'], $type);
            }
          }
        }

        foreach ($collection_names as $collection_name) {
          $result = _mongo_entity_embedded_entity_query($collection_name, $property_name, $find, $parent_find, $order, $range);

          if ($query->count) {
            $count += count($result['result']);
          }
          else {
            foreach ($result['result'] as $doc) {
              $values = $doc[$property_name];
              $id = $values['_id'];
              $stub = entity_create_stub_entity($entity_type, array($id));
              $stub->_parent = $doc['_id'];
              $stub->_collection = $collection_name;
              // @todo Each one of these may be a different entity type, I guess
              $stubs[$entity_type][$id] = $stub;
            }
          }

        }

      }

      if ($query->count) {
        return $count;
      }
      else {
        return $stubs;
      }

    }

    else {
      $collection = mongodb_collection($entity_info['collection']);

      // @todo prefix embedded collections with the parent field name
      if ($query->count && !$query->range) {
        return $collection->count($find);
      }
      if (empty($find)) {
        $cursor = $collection->find();
      }
      else {
        // Useful for debugging queries
        $query->addMetaData('mongo_entity_query', $find);
        $cursor = $collection->find($find);
      }
      if (isset($query->hint)) {
        $cursor->hint($query->hint);
      }
      if ($query->range) {
        $cursor->skip($query->range['start'])->limit($query->range['length']);
      }
      if ($query->count) {
        return $cursor->count(TRUE);
      }
      else {
        $sort = array();
        foreach ($query->order as $order) {
          switch ($order['type']) {
            case 'field':
              if (isset($order['specifier']['field']['field_name'])) {
                $field_name = $order['specifier']['field']['field_name'];
              }
              else {
                $field_name = implode('.', $order['specifier']['field']);
              }
              $key = $field_name . '.' . $order['specifier']['column'];
              break;

            case 'property':
              $key = $order['specifier'];
              break;

            case 'entity':
              $key = $entity_map[$order['specifier']];
              break;

          }
          $sort[$key] = $order['direction'] == 'ASC' ? 1 : -1;
        }
        if ($sort) {
          $cursor->sort($sort);
        }
      }
    }
    $return = array();
    if (isset($cursor)) {
      foreach ($cursor as $row) {
        $id = (string) $row['_id'];
        $row += array('_revision_id' => NULL);
        $entity = entity_create_stub_entity($entity_type, array(
          $id,
          $row['_revision_id'],
          isset($row['_bundle']) ? $row['_bundle'] : NULL,
        ));
        $return[$entity_type][$id] = $entity;
      }
    }
    return $return;
  }

}

/**
 * Query an embedded entity based on its fields and properties
 */
function _mongo_entity_embedded_entity_query($collection_name, $property_name, $conditions, $parent_conditions = array(), $order = NULL, $range = NULL) {

  global $test_case;

  $pipeline = array();

  if (empty($conditions) && empty($parent_conditions)) {

    $pipeline[] = array('$project' => array($property_name => 1));
    $pipeline[] = array('$unwind' => '$' . $property_name);

    /*
    db.met_entity.aggregate(
      {$project: {field_multi_embedded_entity: 1}},
      {$unwind: '$field_multi_embedded_entity'},
    );
    */

  }
  else {

    $match = array();
    foreach ($conditions as $key => $value) {
      $match["{$property_name}.{$key}"] = $value;
    }

    /*
    db.met_entity.aggregate(
      {$match: {'field_multi_embedded_entity.field_embedded_entity_name.value': 'Find me'}},
      {$project: {field_multi_embedded_entity: 1}},
      {$unwind: '$field_multi_embedded_entity'},
      {$match: {'field_multi_embedded_entity.field_embedded_entity_name.value': 'Find me'}}
    );
    */

    $pipeline[] = array('$match' => $match + $parent_conditions);
    $pipeline[] = array('$project' => array($property_name => 1));
    $pipeline[] = array('$unwind' => '$' . $property_name);
    if (!empty($match)) {
      $pipeline[] = array('$match' => $match);
    }

  }

  if (!is_null($order)) {
    $match = array();
    foreach ($order as $key => $value) {
      switch ($value['type']) {
      case 'field':
        $match[$property_name . '.' . $value['specifier']['field']['field_name'] . '.' . $value['specifier']['column']] = ($value['direction'] == 'ASC')? 1:-1;
        break;
      case 'property':
      case 'entity': // TODO: Not sure this is correct, but i think it can be handled the same.
        $match[$property_name . '.' . $value['specifier']] = ($value['direction'] == 'ASC')? 1:-1;
        break;
      }
    }

    $pipeline[] = array('$sort' => $match);
  }

  if (!is_null($range) && !is_null($range['start'])) {
    $pipeline[] = array('$skip' => $range['start']);
    $pipeline[] = array('$limit' => $range['length']);
  }

  $collection = mongodb_collection($collection_name);
  $result = $collection->aggregate($pipeline);

  return $result;

}

/**
 * Instructs Field API to skip over MongoEntity fields when writing.
 */
function _mongo_entity_skip_fields($entity_type, $entity, &$skip_fields) {
  $entity_info = entity_get_info($entity_type);
  if (is_a($entity_info['controller class'], 'MongoEntityController', TRUE)) {
    $fields = field_info_instances($entity_type);
    foreach ($fields as $bundle => $bundle_fields) {
      foreach ($bundle_fields as $field) {
        $field_id = $field['field_id'];
        $skip_fields[$field_id] = $field_id;
      }
    }
  }
}

/**
 * Implements hook_field_storage_pre_load().
 */
function mongo_entity_field_storage_pre_load($entity_type, $entity, $age, &$skip_fields) {
  _mongo_entity_skip_fields($entity_type, $entity, $skip_fields);
}

/**
 * Implements hook_field_storage_pre_insert().
 */
function mongo_entity_field_storage_pre_insert($entity_type, $entity, &$skip_fields) {
  _mongo_entity_skip_fields($entity_type, $entity, $skip_fields);
}

/**
 * Implements hook_field_storage_pre_update().
 */
function mongo_entity_field_storage_pre_update($entity_type, $entity, &$skip_fields) {
  _mongo_entity_skip_fields($entity_type, $entity, $skip_fields);
}

/**
 * Displays a table of embedded entity fields for a given entity type.
 */
function mongo_entity_embedded_entity_types($entity_type, $bundle = NULL) {

  $header = array(
    'Type',
    array(
      'data' => 'Operations',
      'colspan' => 2,
    ),
  );
  $rows = array();

  $instances = field_info_instances($entity_type);
  $instances = $instances[$entity_type];
  foreach ($instances as $field_name => $instance) {
    $field = field_info_field($field_name);
    if ($field['type'] == 'embedded_entity') {

      $embedded_entity_type = $field['settings']['entity_type'];
      $embedded_entity_info = entity_get_info($embedded_entity_type);

      // If there is only one bundle, and it has the same name as the entity, use that.
      if (isset($embedded_entity_info['bundles'][$embedded_entity_type]) && count($embedded_entity_info['bundles']) == 1) {
        $path = $embedded_entity_info['bundles'][$embedded_entity_type]['admin']['path'];
        $rows[] = array(
          $instance['label'],
          l('Manage fields', "$path/fields"),
          l('Manage display', "$path/display"),
        );
      }
      else {
        foreach ($embedded_entity_info['bundles'] as $bundle => $bundle_info) {
          $path = $bundle_info['admin']['path'];
          $rows[] = array(
            t('!field_name - !bundle', array('!field_name' => $instance['label'], '!bundle' => $bundle_info['label'])),
            l('Manage fields', "$path/fields"),
            l('Manage display', "$path/display"),
          );
        }
      }

    }
  }
  return theme('table', array('header' => $header, 'rows' => $rows, 'empty' => 'No embedded entity types'));

}
