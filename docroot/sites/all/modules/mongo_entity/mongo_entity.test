<?php

class MongoEntitySaveTest extends DrupalWebTestCase {

  public static function getInfo() {
    return array(
      'name' => 'Mongo Entity unit tests',
      'description' => 'Tests CRUD operations for Mongo Entities',
      'group' => 'Mongo Entity',
    );
  }

  function dsm($message) {
    $this->assert('debug', $message);
  }

  function dvm($input) {
    include_once DRUPAL_ROOT . '/includes/utility.inc';
    $output = '<pre>' . drupal_var_export($input) . '</pre>';
    $this->assert('debug', $output);
  }

  function setUp() {

    global $conf;

    // Save the mongo connection for later, so it doesn't get whacked by setUp()
    // @todo this isn't working
    if (isset($conf['mongodb_connections'])) {
      $this->mongodb_connections = $conf['mongodb_connections'];
    }
    else {
      $this->mongodb_connections = NULL;
    }

    parent::setUp('node', 'entity', 'entity_test', 'features', 'mongodb', 'mongo_entity', 'mongo_entity_test', 'devel', 'devel_generate', 'text');

    // Save this, so that it persist
    $conf['mongodb_connections'] = $this->mongodb_connections;
    variable_set('mongodb_connections', $this->mongodb_connections);

  }

  function testMongoEntity() {

    $entity_info = entity_get_info('met_entity');

    // Create two entities with the same _id, and try to save both of them
    // They should be assigned unique IDs when saved (inserted).
    $entity1 = entity_create('met_entity', array('_id' => 17));
    entity_save('met_entity', $entity1);
    try {
      $entity2 = entity_create('met_entity', array('_id' => 17));
      entity_save('met_entity', $entity2);
      $unique_id = TRUE;
    }
    catch (Exception $e) {
      $unique_id = FALSE;
    }
    $this->assertTrue($unique_id, 'Generate unique IDs for new entities');

    // Wreck the mongo_entity_info counter, and try to force an error
    // Empty the collection
    $collection = mongodb_collection('met_entity');
    $collection->remove();

    // Remove the counter
    $info = mongodb_collection('mongo_entity_info');
    $info->remove(array('entity_type' => 'met_entity'));
    // Insert one entity
    $entity1 = entity_create('met_entity', array());
    entity_save('met_entity', $entity1);

    // Remove the counter, again
    $info->remove(array('entity_type' => 'met_entity'));

    try {
      // Insert another entity
      $entity2 = entity_create('met_entity', array());
      entity_save('met_entity', $entity2);
      $unique_id_conflict = FALSE;
    } catch (Exception $e) {
      $unique_id_conflict = TRUE;
    }
    $this->assertTrue($unique_id_conflict, 'Throw an exception when inserting entities with duplicate IDs');

  }

  function testMongoEntityBundle() {

    $e1 = entity_create('met_bundle_test', array('_bundle' => 'met_bundle_test_1'));
    $e2 = entity_create('met_bundle_test', array('_bundle' => 'met_bundle_test_2'));

    entity_save('met_bundle_test', $e1);
    entity_save('met_bundle_test', $e2);

    $query = new EntityFieldQuery;
    $query->entityCondition('entity_type', 'met_bundle_test');
    $query->entityCondition('bundle', 'met_bundle_test_2');
    $result = $query->execute();

    $this->assertTrue(count($result['met_bundle_test']) == 1 && isset($result['met_bundle_test'][$e2->_id]), 'Query matched one and only one entity by bundle name.');

  }

  function testEmbeddedEntityField() {

    module_load_include('inc', 'devel_generate', 'devel_generate');
    module_load_include('inc', 'devel_generate', 'devel_generate.fields');

    // Generate some embedded entities.
    $e1 = entity_create('met_entity', array());

    $e2 = entity_create('met_embedded_entity', array());
    $e3 = entity_create('met_embedded_entity', array());
    $e4 = entity_create('met_embedded_entity', array());

    $e1->field_embedded_entity[LANGUAGE_NONE][0]['entity'] = $e2;

    $e1->field_multi_embedded_entity[LANGUAGE_NONE][]['entity'] = $e3;
    $e1->field_multi_embedded_entity[LANGUAGE_NONE][]['entity'] = $e4;

    entity_save('met_entity', $e1);

    // Test that IDs are created for all entities
    $this->assertTrue(!empty($e1->_id), 'ID set for base entity.');
    $this->assertTrue(!empty($e2->_id), 'ID set for single cardinality embedded entity field.');
    $this->assertTrue(!empty($e3->_id) && !empty($e4->_id), 'IDs set for multiple cardinality embedded entity field.');

    // Generate sample data for the embedded entities
    devel_generate_fields($e2, 'met_embedded_entity', 'met_embedded_entity');
    devel_generate_fields($e3, 'met_embedded_entity', 'met_embedded_entity');
    devel_generate_fields($e4, 'met_embedded_entity', 'met_embedded_entity');
    entity_save('met_embedded_entity', $e2);
    entity_save('met_embedded_entity', $e3);
    entity_save('met_embedded_entity', $e4);

    // Load embedded entity, and compare it.
    $loaded_entities = entity_load('met_embedded_entity', array($e2->_id));
    $this->assertTrue(count($loaded_entities) == 1, 'Loaded one embedded entity.');
    $el2 = current($loaded_entities);

    // @todo check _parent, _collection, and _field values
    $this->assertTrue(!empty($el2) && $el2->_id == $e2->_id, 'Loaded entity from single cardinality embedded entity field.');
    $this->assertTrue(!empty($el2->field_embedded_entity_name[LANGUAGE_NONE][0]['value']), 'Embedded entity text field is not empty.');
    $el4 = entity_load_single('met_embedded_entity', $e4->_id);
    $this->assertTrue(!empty($el4) && $el4->_id == $e4->_id, 'Loaded entity from multiple cardinality embedded entity field.');

    // Delete an embedded entity without deleting the parent entity.
    entity_delete('met_embedded_entity', $e2->_id);
    $this->assertTrue(entity_load_single('met_embedded_entity', $e2->_id) == NULL, 'Embedded entity deleted.');
    $this->assertTrue(entity_load_single('met_entity', $e1->_id) != NULL, 'Parent of deleted embedded entity still exists.');

    entity_delete('met_entity', $e1->_id);
    $this->assertTrue(entity_load_single('met_entity', $e1->_id) == NULL, 'Entity deleted.');

  }

  function testEmbeddedEntityFieldQuery() {

    // Generate some embedded entities.
    $e1 = entity_create('met_entity', array());

    $e2 = entity_create('met_embedded_entity', array());
    $e3 = entity_create('met_embedded_entity', array());
    $e4 = entity_create('met_embedded_entity', array());

    $e1->field_embedded_entity[LANGUAGE_NONE][0]['entity'] = $e2;

    $e1->field_multi_embedded_entity[LANGUAGE_NONE][]['entity'] = $e3;
    $e1->field_multi_embedded_entity[LANGUAGE_NONE][]['entity'] = $e4;

    entity_save('met_entity', $e1);

    $e2->field_embedded_entity_name[LANGUAGE_NONE][0]['value'] = 'Try again';
    $e3->field_embedded_entity_name[LANGUAGE_NONE][0]['value'] = 'Not it';
    $e4->field_embedded_entity_name[LANGUAGE_NONE][0]['value'] = 'Find me';

    entity_save('met_embedded_entity', $e2);
    entity_save('met_embedded_entity', $e3);
    entity_save('met_embedded_entity', $e4);

    $query = new EntityFieldQuery;
    $query->entityCondition('entity_type', 'met_embedded_entity');
    $query->fieldCondition('field_embedded_entity_name', 'value', 'Find me');
    $result = $query->execute();

    $this->assertTrue(count($result['met_embedded_entity']) == 1 && isset($result['met_embedded_entity'][$e4->_id]), 'Query matched one and only one embedded entity by field value.');

  }

  function testEmbeddedEntityProperty() {

    $e1 = entity_create('met_entity', array());

    $e2 = entity_create('met_embedded_entity', array());
    $e3 = entity_create('met_embedded_entity', array());
    $e4 = entity_create('met_embedded_entity', array());

    // Apple is just a
    $e1->apple = $e2;
    $e1->bananas[] = $e3;
    $e1->bananas[] = $e4;

    entity_save('met_entity', $e1);

    $this->assertTrue(!empty($e2->_id) && $e1->apple->_id == $e2->_id, 'Saved property containing a single embedded entity.');
    $this->assertTrue(!empty($e3->_id) && !empty($e4->_id) && $e1->bananas[0]->_id == $e3->_id && $e1->bananas[1]->_id == $e4->_id, 'Saved property containing an array of embedded entities.');

    $test = entity_load_single('met_entity', $e1->_id);
    $this->assertTrue($test->apple->_id == $e2->_id, 'Loaded entity with property containing a single embedded entity.');
    $this->assertTrue(count($test->bananas) == 2 && $test->bananas[0]->_id == $e3->_id && $test->bananas[1]->_id == $e4->_id, 'Loaded entity with property containing an array of embedded entities.');

    // @todo load embedded entities
    $el2 = entity_load_single('met_embedded_entity', $e2->_id);
    $this->assertTrue($e2->_id == $el2->_id, 'Loaded embedded entity from a property containing a single embedded entity.');
    $el4 = entity_load_single('met_embedded_entity', $e4->_id);
    $this->assertTrue($e4->_id == $el4->_id, 'Loaded embedded entity from a property containing an array of embedded entities.');

    // @todo save embedded entity properties

    // @todo delete embedded entity properties
/*
    entity_delete('met_embedded_entity', $e2->_id);
    entity_delete('met_embedded_entity', $e4->_id);
*/

  }

  function testEntityIndexes() {

    $e1 = entity_create('met_index_test', array('var1' => 3, 'var2' => 5));
    $e2 = entity_create('met_index_test', array('var1' => 5, 'var2' => 5));
    $e3 = entity_create('met_index_test', array('var1' => 3, 'var2' => 5));

    try {
      entity_save('met_index_test', $e1);
      $success = TRUE;
    } catch (Exception $e) {
      $success = FALSE;
    }
    $this->assertTrue($success, 'Insert a new entity with unique index.');

    try {
      entity_save('met_index_test', $e2);
      $success = TRUE;
    } catch (Exception $e) {
      $success = FALSE;
    }
    $this->assertTrue($success, 'Insert a new entity with a unique index with different values.');

    try {
      entity_save('met_index_test', $e3);
      $success = FALSE;
    } catch (Exception $e) {
      $success = TRUE;
    }
    $this->assertTrue($success, 'Throw an exception when inserting an entity with duplicate values for a unique index.');

  }

  function testLogicalOperators() {

    $e1 = entity_create('met_entity', array('date' => time(), 'value' => 7));
    entity_save('met_entity', $e1);

    $query = new EntityFieldQuery;
    $query->entityCondition('entity_type', 'met_entity');
    $query->propertyCondition("date", strtotime('-1 day'), ">=");
    $query->propertyCondition("date", strtotime('+1 day'), "<=");
    $result = $query->execute();

    $this->assertTrue(isset($result['met_entity'][$e1->_id]), 'Query multiple true conditions on the same property, and return a result.');

    $query = new EntityFieldQuery;
    $query->entityCondition('entity_type', 'met_entity');
    $query->propertyCondition("date", strtotime('-1 day'), ">=");
    $query->propertyCondition("date", strtotime('+1 day'), ">=");
    $result = $query->execute();

    $this->assertTrue(empty($result['met_entity']), 'Query mixed true and false conditions on the same property, and return null.');

    $query = new EntityFieldQuery;
    $query->entityCondition('entity_type', 'met_entity');
    $query->propertyCondition('value', 4, '>');
    $query->propertyCondition('value', 7);
    $result = $query->execute();

    $this->assertTrue(isset($result['met_entity'][$e1->_id]), 'Query multiple true conditions on the same property, and return a result.');

  }

}