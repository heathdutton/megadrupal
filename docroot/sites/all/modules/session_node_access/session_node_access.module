<?php

/**
 * @file
 * Module implementing per-session node permissions for users.
 */

/**
 * Implements hook_permission().
 */
function session_node_access_permission() {
  return array(
    'administer session node access' => array(
      'title' => t('Administer Session node access'),
      'description' => t('Grant per-session permissions for users to access nodes they created.'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_menu().
 */
function session_node_access_menu() {
  $items = array();

  // Admin configuration - Settings.
  $items['admin/config/content/session_node_access'] = array(
    'title' => 'Session based access',
    'description' => 'Grant per-session permissions for users to access nodes they created.',
    'access arguments' => array('administer session node access'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('session_node_access_form'),
    'weight' => 1,
  );
  return $items;
}

/**
 * Form constructor for the module configuration page.
 *
 * @see session_node_access_form_submit()
 */
function session_node_access_form($form, &$form_state) {
  $form = array();
  $form['moduletitle'] = array(
    '#markup' => t('Session node access'),
    '#prefix' => '<h2>',
    '#suffix' => '</h2>',
  );

  // Fieldsets.
  $form['moduleinfo'] = array(
    '#markup' => t('On this page you can grant additional permissions to users after they create a node.
      Consider this use case: Content created by anonymous users is set to be not published until a mod reviews it.
      With this module the user gets to view/edit/delete their freshly created content without it to be publicly
      accessible.'),
    '#prefix' => '<p>',
    '#suffix' => '</p>',
  );
  $form['content_types_fieldset'] = array(
    '#type' => 'fieldset',
    '#title' => t('Restrict by content type'),
    '#description' => t('Grant per-session node permissions to certain users who create nodes of the following content types.
      If a user creates a node of the checked content type, they will get access to it until their session expires.
      Check at least one element.'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
  );
  $form['user_roles_fieldset'] = array(
    '#type' => 'fieldset',
    '#title' => t('Restrict by user roles'),
    '#description' => t('Grant per-session node permissions to all users assigned to the following roles.
      <strong>Note:</strong> In most cases checking roles other than \'anonymous\' won\'t be necessary because of the available \'View own unpublished\'
      options in the permissions tab. Check at least one element.'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
  );
  $form['permissions_fieldset'] = array(
    '#type' => 'fieldset',
    '#title' => t('Grant these permissions'),
    '#description' => t('Said users will be granted the following permissions to nodes they create.
      These permissions will expire along with the user\'s session. Check at least one element.'),
    '#collapsible' => FALSE,
    '#collapsed' => FALSE,
  );

  $settings = variable_get('session_node_access_settings');

  // Prepare content type settings for display.
  $content_types = node_type_get_names();
  $default_value = array();
  foreach ($content_types as $machine_name => $human_name) {
    if (isset($settings['content_types'][$machine_name]) && $settings['content_types'][$machine_name] == 1) {
      $default_value[] = $machine_name;
    }
  }

  // Display content type settings.
  $form['content_types_fieldset']['content_types'] = array(
    '#type' => 'checkboxes',
    '#options' => $content_types,
    '#default_value' => $default_value,
  );

  // Prepare user role settings for display.
  $user_roles = user_roles();
  $default_value = array();
  foreach ($user_roles as $role_id => $role_name) {
    if (isset($settings['user_roles'][$role_id]) && $settings['user_roles'][$role_id] == 1) {
      $default_value[] = $role_id;
    }
  }

  // Display user role settings.
  $form['user_roles_fieldset']['user_roles'] = array(
    '#type' => 'checkboxes',
    '#options' => $user_roles,
    '#default_value' => $default_value,
  );

  // Prepare permissions settings for display.
  $permissions = array(
    'view' => t('View'),
    'update' => t('Update'),
    'delete' => t('Delete'),
  );
  $default_value = array();
  foreach ($permissions as $permission => $human_permission) {
    if (isset($settings['permissions'][$permission]) && $settings['permissions'][$permission] == 1) {
      $default_value[] = $permission;
    }
  }

  // Display permission settings.
  $form['permissions_fieldset']['permissions'] = array(
    '#type' => 'checkboxes',
    '#options' => $permissions,
    '#default_value' => $default_value,
  );

  // Prepare publishing settings for display.
  $published = isset($settings['published']) ? $settings['published'] : 0;

  // Display publishing settings.
  $form['published_fieldset']['published'] = array(
    '#title' => t('Take effect only on published nodes'),
    '#description' => t('Usually this is unchecked, as most use cases for this module require it to give temporary
      permissions to users to nodes they create but which are still unpublished by the moderator.'),
    '#type' => 'checkbox',
    '#default_value' => $published,
  );

  $form['options']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save configuration'),
  );
  return $form;
}

/**
 * Form submission handler for the module configuration page.
 *
 * Submits settings to database and displays a confirmation message.
 */
function session_node_access_form_submit($form, &$form_state) {

  // Prepare content type settings for submission.
  $content_types = node_type_get_names();
  foreach ($content_types as $machine_name => $human_name) {
    $settings['content_types'][$machine_name] = is_string($form_state['values']['content_types'][$machine_name]) ? 1 : 0;
  }

  // Prepare user role settings for submission.
  $user_roles = user_roles();
  foreach ($user_roles as $role_id => $role_name) {
    $settings['user_roles'][$role_id] = $form_state['values']['user_roles'][$role_id] != 0 ? 1 : 0;
  }

  // Prepare permission settings for submission.
  foreach (array('view', 'update', 'delete') as $permission) {
    $settings['permissions'][$permission] = is_string($form_state['values']['permissions'][$permission]) ? 1 : 0;
  }

  // Prepare permission settings for submission.
  $settings['published'] = $form_state['values']['published'];

  // Submit settings into the database.
  variable_set('session_node_access_settings', $settings);

  $message = t('Your settings have been saved.');
  drupal_set_message($message, 'status', FALSE);
}

/**
 * Checks if currently logged in user has access to a node.
 *
 * @param object $node
 *   The node to be checked if accessible by currently logged in user.
 * @param string $op
 *   The user operation for which to check access (view/update/delete).
 * @param object $account
 *   The user to be checked for access to the node.
 *   If not provided, current user is taken.
 *
 * @return bool
 *   True if user has access, false if they do not.
 */
function session_node_access_user_node_access($node, $op, $account = NULL) {
  if (!isset($_SESSION['session_node_access']['nodes_created'])) {
    return FALSE;
  }

  $settings = variable_get('session_node_access_settings');

  // Check if settings allow granting permissions to this node.
  if (isset($settings['permissions'][$op]) && $settings['permissions'][$op] == 1) {
    if (isset($settings['content_types'][$node->type]) && $settings['content_types'][$node->type] == 1) {
      if (is_array($settings['user_roles']) && in_array(1, array_intersect_key($settings['user_roles'],
          is_null($account) ? $GLOBALS['user']->roles : $account->roles))) {
        if ($settings['published'] == 0 || $node->status == 1) {
          if (in_array($node->nid, $_SESSION['session_node_access']['nodes_created'])) {
            return TRUE;
          }
        }
      }
    }
  }
  return FALSE;
}

/**
 * Implements hook_node_insert().
 *
 * Makes sure that content created by users gets referenced in their
 * session variable to be checked for in hook_nde_access.
 */
function session_node_access_node_insert($node) {
  $settings = variable_get('session_node_access_settings');
  if (isset($settings['content_types'][$node->type]) && $settings['content_types'][$node->type] == 1) {
    global $user;
    if (is_array($settings['user_roles']) && in_array(1, array_intersect_key($settings['user_roles'],
        $user->roles))) {
      $_SESSION['session_node_access']['nodes_created'][] = $node->nid;
    }
  }
}

/**
 * Implements hook_node_access().
 *
 * Grants access to users to view/edit/delete a node (depending
 * on settings) in case they created it in their current session.
 */
function session_node_access_node_access($node, $op, $account) {

  if (session_node_access_user_node_access($node, $op, $account)) {

    // Grant access for this user to this node user.
    return NODE_ACCESS_ALLOW;
  }
  return NODE_ACCESS_IGNORE;
}
