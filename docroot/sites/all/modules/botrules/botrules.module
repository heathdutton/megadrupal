<?php

/**
 * @file
 * Bot Rules (botrules) module main file.
 *
 * @see bot_rules.rules.inc
 */

/**
 * Implements hook_help().
 */
function botrules_help($path, $arg) {
  switch ($path) {
    case 'irc:features':
      return array(t('Botrules'));
    case 'irc:features#botrules':
      return variable_get('botrules_help', 'Sorry, no help available yet.');
  }
}

/**
 * Implements hook_permission().
 */
function botrules_permission() {
  return array(
    'configure botrules' => array(
      'title' => t('Configure Bot Rules module'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function botrules_menu() {
  $items['admin/config/bot/botrules'] = array(
    'title'            => 'Bot Rules',
    'description'      => 'Configure Bot Rules',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('botrules_configure'),
    'access arguments' => array('configure botrules'),
    'type'             => MENU_NORMAL_ITEM,
  );
  return $items;
}

/**
 * Implements hook_form().
 *
 * Module configuration form.
 *
 * @ingroup forms
 */
function botrules_configure() {
  $form['botrules_help'] = array(
    '#type'  => 'textarea',
    '#title' => t('Online help text'),
    '#default_value' => variable_get('botrules_help', 'Sorry, no help available yet.'),
  );
  $form['messages'] = array(
    '#type'  => 'fieldset',
    '#title' => t('Messages'),
  );
  $form['messages']['botrules_message_chunk'] = array(
    '#type'          => 'textfield',
    '#title'         => t('Split long messages into chunks of'),
    '#prefix'        => '<div class="container-inline">',
    '#suffix'        => t('characters (16 to 255)') . '</div>',
    '#size'          => 5,
    '#default_value' => variable_get('botrules_message_chunk', 255),
    '#required'      => TRUE,
    '#element_validate' => array('botrules_validate_chunk'),
  );
  $form['messages']['botrules_queue_portion'] = array(
    '#type'          => 'textfield',
    '#title'         => t('Number of queued messages to release in one go'),
    '#size'          => 10,
    '#default_value' => variable_get('botrules_queue_portion', 3),
    '#required'      => TRUE,
    '#element_validate' => array('element_validate_integer_positive'),
    '#description'   => t('Note: when a rule is fired by a bot event, any responses are not queued but sent instantly.'),
  );
  $form['messages']['botrules_log_invalid'] = array(
    '#type'          => 'checkbox',
    '#title'         => t('Log attempts to send invalid messages'),
    '#default_value' => variable_get('botrules_log_invalid', TRUE),
    '#description'   => t('Messages/actions with empty target or body are not sent, and a notice is logged. You can turn logging off if you know what you are doing.'),
  );
  $form['messages']['botrules_timestamp_format'] = array(
    '#type'          => 'select',
    '#title'         => t('Timestamp format for messages queued until target shows signs of activity'),
    '#options'       => botrules_date_format_choices(),
    '#default_value' => variable_get('botrules_timestamp_format', 'none'),
    '#description'   => t('Note: changing this setting has no retroactive effect on messages already queued.'),
  );
  $form['prefix'] = array(
    '#type'  => 'fieldset',
    '#title' => t('Command prefix/identifier'),
  );
  $form['prefix']['botrules_prefix'] = array(
    '#type'          => 'textfield',
    '#size'          => 15,
    '#default_value' => variable_get('botrules_prefix', '&'),
    '#description'   => t("Empty for none (i.e., listen to all messages), &lt;botname&gt; for bot's nickname."),
  );
  $form['prefix']['botrules_prefix_anywhere'] = array(
    '#type'          => 'checkbox',
    '#title'         => t('Allow at any position'),
    '#default_value' => variable_get('botrules_prefix_anywhere', FALSE),
  );
  $form['prefix']['botrules_prefix_private'] = array(
    '#type'          => 'checkbox',
    '#title'         => t('Require in private messages'),
    '#default_value' => variable_get('botrules_prefix_private', TRUE),
    '#description'   => t('If unchecked, any private message received by the bot will be sent for Rules evaluation.'),
  );
  if (module_exists('bot_log')) {
    $all_categories = db_query('SELECT DISTINCT(channel) FROM {bot_log}')
      ->fetchCol();
    $real_channels = variable_get('bot_log_channels', array());
    $pseudologs = array_diff($all_categories, $real_channels);
    if (count($pseudologs) > 0) {
      array_walk($pseudologs, create_function('&$val', '$val = drupal_substr($val, 1);'));
      $pseudologs = array_combine($pseudologs, $pseudologs);
      $form['botrules_pseudologs_displayed'] = array(
        '#type'          => 'checkboxes',
        '#title'         => t('Highlights pseudochannels to show on the log page'),
        '#options'       => $pseudologs,
        '#default_value' => variable_get('botrules_pseudologs_displayed', array()),
        '#description'   => t('Previously logged and discontinued channels show here as well.'),
      );
    }
  }
  $form['note'] = array(
    '#type'  => 'item',
    '#markup' => t('Note: due to the way Bot module handles variables, configuration changes may take up to 5 minutes to be picked up.'),
  );
  return system_settings_form($form);
}

/**
 * Helper function - validates chunk size for long messages.
 *
 * Technically, it is possible to break a message into one-character long
 * chunks, which would however make little sense. 16 is just a voluntarily
 * chosen 'sane' lower limit.
 */
function botrules_validate_chunk($element, &$form_state) {
  $value = $element['#value'];
  if (!is_numeric($value) || intval($value) != $value || $value < 16 || $value > 255) {
    form_error($element, t('Chunk size must be a positive integer between 16 and 255.'));
  }
}

/**
 * Helper function - prepare date format choices for queued message timestamp.
 */
function botrules_date_format_choices() {
  $choices['none'] = t('None');
  $formats = system_get_date_types();
  foreach ($formats as $format) {
    $choices[$format['type']] = $format['title'] . ': [' . format_date(REQUEST_TIME, $format['type']) . ']';
  }
  return $choices;
}

/**
 * Listen for conversation directed at, or about, the bot.
 *
 * @param object $data
 *   The regular $data object prepared by the IRC library.
 * @param bool $from_query
 *   Whether this was a queried request.
 */
function botrules_irc_msg_channel($data, $from_query = FALSE) {
  // Retrieve configured prefix/identifier.
  $prefix = variable_get('botrules_prefix', '&');
  // Trim it. Do not let trailing spaces spoil the fun.
  if (trim($prefix) === '<botname>') {
    // Get bot's current nickname.
    global $irc;
    $prefix = $irc->_nick;
  }
  if ($prefix === ''
    // Identifier allowed everywhere in the message.
    || (variable_get('botrules_prefix_anywhere', FALSE) == TRUE && stripos($data->message, $prefix) !== FALSE)
    // Prefix allowed only at position 0.
    || (variable_get('botrules_prefix_anywhere', FALSE) == FALSE && stripos($data->message, $prefix) === 0)) {
    // Invoke rules event.
    rules_invoke_event('botrules_event_got_channel_message', $data->channel, $data->nick, $data->message);
  }
  // Look whether there are any queued messages for this nick.
  botrules_queue_discharge_queued($data->nick);
}

/**
 * Listen for private messages directed at the bot.
 *
 * @param object $data
 *   The regular $data object prepared by the IRC library.
 */
function botrules_irc_msg_query($data) {
  // Retrieve configured prefix/identifier.
  $prefix = variable_get('botrules_prefix', '&');
  // Trim it. Do not let trailing spaces spoil the fun.
  if (trim($prefix) === '<botname>') {
    // Get bot's current nickname.
    global $irc;
    $prefix = $irc->_nick;
  }
  if ($prefix === ''
    // Prefix not required in private messages.
    || variable_get('botrules_prefix_private', TRUE) == FALSE
    // Identifier allowed everywhere in the message.
    || (variable_get('botrules_prefix_anywhere', FALSE) == TRUE && stripos($data->message, $prefix) !== FALSE)
    // Prefix allowed only at position 0.
    || (variable_get('botrules_prefix_anywhere', FALSE) == FALSE && stripos($data->message, $prefix) === 0)) {
    // Invoke rules event.
    rules_invoke_event('botrules_event_got_private_message', $data->nick, $data->message);
  }
  // Look whether there are any queued messages for this nick.
  botrules_queue_discharge_queued($data->nick);
}

/**
 * Implements hook_irc_bot_cron_fastest().
 */
function botrules_irc_bot_cron_fastest() {
  global $irc;
  botrules_refresh_vars();
  botrules_queue_discharge_immediate();
  // Make bot check its own nickname a bit more often, so that 'Make bot change
  // its nickname' action could complete in reasonable time.
  if ($irc->_nick !== variable_get('bot_nickname', 'bot_module')) {
    $irc->changeNick(variable_get('bot_nickname', 'bot_module'));
  }
  // Check if the bot has been instructed to part any channels.
  botrules_part_channels();
}

/**
 * Implements hook_irc_bot_cron().
 */
function botrules_irc_bot_cron() {
  // Refresh user lists for known channels.
  global $irc;
  global $_botrules_user_data;
  foreach ($_botrules_user_data as $channel => $users) {
    $irc->who($channel);
  }
}

/**
 * Implements hook_irc_msg_who().
 */
function botrules_irc_msg_who($data) {
  if ($data->rawmessageex[6] != '/WHO') {
    global $_botrules_user_data;
    $_botrules_user_data[$data->rawmessageex[3]][$data->rawmessageex[7]] = 1;
    botrules_cache_user_data();
  }
}

/**
 * Implements hook_irc_msg_join().
 */
function botrules_irc_msg_join($data) {
  global $irc;
  global $_botrules_user_data;
  if ($data->nick == $irc->_nick) {
    // Hey, the user joining is me, the bot itself. Clean cached user data and
    // prepare to consume /WHO responses.
    $_botrules_user_data[$data->channel] = array();
  }
  else {
    $_botrules_user_data[$data->channel][$data->nick] = 1;
  }
  botrules_cache_user_data();
  rules_invoke_event('botrules_event_user_joined_channel', $data->nick, $data->channel);
}

/**
 * Implements hook_irc_msg_part().
 */
function botrules_irc_msg_part($data) {
  global $_botrules_user_data;
  unset($_botrules_user_data[$data->channel][$data->nick]);
  botrules_cache_user_data();
}

/**
 * Implements hook_irc_msg_nickchange().
 */
function botrules_irc_msg_nickchange($data) {
  global $irc;
  global $_botrules_user_data;
  // Update user data.
  foreach ($_botrules_user_data as &$channel) {
    if (isset($channel[$data->nick])) {
      $channel[$data->message] = 1;
      unset($channel[$data->nick]);
    }
  }
  // Cache user data.
  botrules_cache_user_data();
  // Limit our own nick flood if we are attempting to assume a nickname which
  // is already taken. This can happen e.g. on freenode, where instead of
  // simply returning an error the server would give us a nickname like
  // 'NickN123'.
  if ($data->message == $irc->_nick) {
    $desired_nick = variable_get('bot_nickname', 'bot_module');
    if ($desired_nick != $irc->_nick) {
      // If we changed our nickname to something different from desired
      // nickname, stop trying and pretend we wanted it all along.
      variable_set('bot_nickname', $irc->_nick);
    }
  }
}

/**
 * Implements hook_irc_msg_quit().
 */
function botrules_irc_msg_quit($data) {
  global $_botrules_user_data;
  foreach ($_botrules_user_data as &$channel) {
    if (isset($channel[$data->nick])) {
      unset($channel[$data->nick]);
    }
  }
  botrules_cache_user_data();
}

/**
 * Helper function - churn out queued 'immediate' actions.
 */
function botrules_queue_discharge_immediate() {
  $portion = variable_get('botrules_queue_portion', 3);
  // Get no more than n actions at once to avoid flood.
  $actions = db_query_range('SELECT aid, type, target, content FROM {botrules_queue} WHERE queued = 0', 0, $portion);
  foreach ($actions as $action) {
    if ($action->type === 'message') {
      bot_message($action->target, $action->content);
      // Delete action from queue.
      db_delete('botrules_queue')
        ->condition('aid', $action->aid)
        ->execute();
    }
    elseif ($action->type === 'action') {
      bot_action($action->target, $action->content);
      // Delete action from queue.
      db_delete('botrules_queue')
        ->condition('aid', $action->aid)
        ->execute();
    }
    else {
      // Other action types not yet implemented.
    }
  }
}

/**
 * Helper function - churn out queued 'queued' messages.
 *
 * @param string $nick
 *   Target of the message (nickname).
 */
function botrules_queue_discharge_queued($nick) {
  $portion = variable_get('botrules_queue_portion', 3);
  // Get no more than n actions at once to avoid flood.
  // Do not fetch type (as this handles messages only) and target (as we
  // already know it).
  $actions = db_query_range('SELECT aid, content FROM {botrules_queue} WHERE queued = 1 AND target = :target', 0, $portion, array(':target' => $nick));
  foreach ($actions as $action) {
    bot_message($nick, $action->content);
    // Delete action from queue.
    db_delete('botrules_queue')
      ->condition('aid', $action->aid)
      ->execute();
  }
  $more = db_query('SELECT COUNT(1) FROM {botrules_queue} WHERE queued = 1 AND target = :target', array(':target' => $nick))->fetchField();
  if ($more > 0) {
    bot_message(
      $nick,
      format_plural(
        $more,
        'There is 1 more message for you.',
        'There are @count more messages for you.'
      )
    );
  }
}

/**
 * Helper function - inserts a new item into bot queue.
 *
 * @param string $target
 *   Target of the action (nickname or channel).
 * @param string $content
 *   Body of the message (if applicable).
 * @param string $type
 *   Type of the action (message/action/etc. (etc. not implemented yet)).
 * @param int $queued
 *   Timing of the message (0 = send ASAP, 1 = queue until the target shows
 *   signs of activity).
 */
function botrules_queue($target, $content = NULL, $type = 'message', $queued = 0) {
  $chunk = variable_get('botrules_message_chunk', 255);
  if (drupal_strlen($content) <= $chunk) {
    db_insert('botrules_queue')
      ->fields(array(
        'type' => $type,
        'queued' => $queued,
        'target' => $target,
        'content' => $content,
      ))
      ->execute();
  }
  else {
    $messages = botrules_split($content, $chunk);
    foreach ($messages as $message) {
      db_insert('botrules_queue')
        ->fields(array(
          'type' => $type,
          'queued' => $queued,
          'target' => $target,
          'content' => $message,
        ))
        ->execute();
    }
  }
}

/**
 * Helper function - split long message into chunks.
 */
function botrules_split($message, $chunk = 255) {
  // Ellipse symbol and its length + 1. Could be made configurable.
  list($ellipse, $ellipse_length) = array('[...]', 6);
  $lines = explode("\n", wordwrap($message, $chunk - $ellipse_length, "\n", TRUE));
  $linecount = count($lines);
  foreach ($lines as $number => $line) {
    // Line numbers go from 0 to actual line count - 1.
    if ($number < $linecount - 1) {
      $messages[] = $line . ' ' . $ellipse;
    }
    else {
      // No ellipse on the last line.
      $messages[] = $line;
    }
  }
  return $messages;
}

/**
 * Helper function - update cached channel/user data.
 */
function botrules_cache_user_data() {
  global $_botrules_user_data;
  cache_set('botrules_user_data', $_botrules_user_data);
}

/**
 * Helper function - update bot nickname and channels variables.
 *
 * Bot runs in an infinite loop, making persistent variables indeed persistent.
 * The whole variable cache is refreshed during five-minute cron runs by
 * bot.module; however, to complete 'change nickname' and 'join/part channel'
 * actions in reasonable time, we need to update the relevant variables more
 * often.
 */
function botrules_refresh_vars() {
  global $conf;
  $data = db_select('variable')
    ->fields('variable', array('name', 'value'))
    ->condition('name', array('bot_nickname', 'bot_channels'), 'IN')
    ->execute()
    ->fetchAllKeyed();
  foreach ($data as $name => $value) {
    $conf[$name] = unserialize($value);
  }
}

/**
 * Helper function - check if bot has been instructed to part a channel.
 */
function botrules_part_channels() {
  global $irc;
  $channels = explode(',', variable_get('bot_channels', '#botwar'));
  $channels_to_part = array_diff(array_keys($irc->_channels), $channels);
  if (count($channels_to_part) > 0) {
    foreach ($channels_to_part as $channel) {
      $irc->part($channel, NULL);
    }
  }
}

/**
 * Implements hook_page_alter().
 *
 * Add highlight pseudochannels to the channels overview page generated by
 * bot_log.module; alter page titles for individual pseudochannels.
 */
function botrules_page_alter(&$page) {
  // Channels overview page.
  if (isset($page['content']['system_main']['bot_log_channels'])) {
    $pseudologs = array_filter(variable_get('botrules_pseudologs_displayed', array()));
    if (count($pseudologs) > 0) {
      foreach ($pseudologs as $key => $category) {
        $categories[] = '<li>' . l($category, 'bot/log/' . $category) . '</li>';
      }
      $page['content']['system_main']['botrules_pseudologs'] = array(
        '#prefix' => '<p>' . t('See also highlights:') . '</p><ul>',
        '#markup' => implode("\n", $categories),
        '#suffix' => '</ul>',
      );
    }
  }
  // Individual channel page - alter the title if it is not a real channel.
  elseif (isset($page['content']['system_main']['bot_log_filter_form'])) {
    $real_channels = variable_get('bot_log_channels', array());
    $category = arg(2);
    if (!in_array('#' . $category, $real_channels)) {
      $date = arg(3) ? arg(3) : gmdate('Y-m-d');
      $title = t('Highlights: @category, @date (GMT)', array('@category' => $category, '@date' => $date));
      drupal_set_title($title, PASS_THROUGH);
    }
  }
}

/**
 * Helper function - create an array of available log entry types.
 */
function botrules_log_entry_types() {
  return array(
    '2'      => t('Channel message'),
    '256'    => t('User performed an action'),
    '64'     => t('User joined channel'),
    '524288' => t('User left channel'),
    '4096'   => t('User quit'),
    '1024'   => t('User changed nickname'),
    '512'    => t('Channel topic was changed'),
  );
}
