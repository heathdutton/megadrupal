<?php

/*
 * Include the importexportapi hooks.
 */
module_load_include('php', 'proteus', 'proteus_importexportapi');
//include_once DRUPAL_ROOT . '/' . 'proteus_importexportapi.php';
/**
 * User-right for creating proteus quiz nodes.
 */
define('PROTEUS_CREATE', 'create proteus content');
/**
 * User-right for editing a user's own proteus quiz nodes.
 */
define('PROTEUS_EDITOWN', 'edit own proteus content');
/**
 * User-right for editing other user's proteus quiz nodes.
 */
define('PROTEUS_EDITALL', 'edit all proteus content');
/**
 * User-right for deleting a user's own proteus quiz nodes.
 */
define('PROTEUS_DELETETOWN', 'delete own proteus content');
/**
 * User-right for deleting other user's proteus quiz nodes.
 */
define('PROTEUS_DELETEALL', 'delete all proteus content');
/**
 * User-right for rating questions.
 */
define('PROTEUS_RATE', 'rate questions');
/**
 * Flag indicating that the student must choose the step size.
 */
define('PROTEUS_CHOOSE', 0);
/**
 * Flag indicating the last selected question should be used.
 */
define('PROTEUS_USEOLD', 1);
/**
 * Flag indicating a new question should be selected using a small step.
 */
define('PROTEUS_SMALL', 2);
/**
 * Flag indicating a new question should be selected using a medium step.
 */
define('PROTEUS_MEDIUM', 3);
/**
 * Flag indicating a new question should be selected using a large step.
 */
define('PROTEUS_LARGE', 4);

/**
 * Implements hook_help().
 */
function proteus_help($path, $arg) {
  $output = ''; //declare your output variable
  switch ($path) {
    case "admin/help#proteus":
      $output = '<p>' . t("A module for adaptive question ordering.") . '</p>';
      break;
  }
  return $output;
}

/**
 * Implements hook_menu().
 */
function proteus_menu() {
  $items = array();

  $items['node/%node/proteus_questions'] = array(
    'title' => 'Questions',
    'page callback' => 'proteus_questions',
    'page arguments' => array(1),
    'access callback' => 'proteus_question_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
  );
  $items['node/%node/proteus_users'] = array(
    'title' => 'Quiz Users',
    'page callback' => 'proteus_users',
    'page arguments' => array(1),
    'access callback' => 'proteus_question_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 3,
  );

  $items['admin/config/content/proteus'] = array(
      'title' => 'Proteus settings',
      'description' => 'Configure the Proteus module.',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('proteus_config'),
      //'access arguments' => array('configure closed question'),
      'access arguments' => array('access administration pages'),
      'position' => 'left',
      'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * Form builder for our admin settings page.
 */
function proteus_config() {
  $form = array();

  $form['proteus_use_default_step'] = array(
    '#type' => 'select',
    '#title' => t('Default quiz step'),
    '#options' => array(
      PROTEUS_CHOOSE => t('Student must choose'),
      PROTEUS_SMALL => t('Small steps'),
      PROTEUS_MEDIUM => t('Medium steps'),
      PROTEUS_LARGE => t('Large steps'),
    ),
    '#default_value' => variable_get('proteus_use_default_step', 0),
    '#description' => t('Here a default step size can be selected. If <em>Student must choose</em> is selected (default), the student must select the desired step size. Otherwise the specified step size will be used.'),
  );

  $form['proteus_show_progress'] = array(
   '#type' => 'checkbox',
    '#title' => t('Show progress'),
    '#default_value' => variable_get('proteus_show_progress', FALSE),
    '#description' => t('Shows the progress and current question score information to the student during the quiz when checked.'),
  );

  return system_settings_form($form);
}

/**
 * Menu item access callback - determine if the questions tab on proteus nodes
 * is accessible.
 */
function proteus_question_access($node) {
  return $node->type == "proteus" && user_access(PROTEUS_CREATE) && node_access('view', $node);
}

/**
 * Implements hook_user_cancel().
 */
function proteus_user_cancel($edit, $account, $method) {
  switch ($method) {
    case 'user_cancel_reassign':
    case 'user_cancel_delete':      // This will not be called here. Added to be complete, also for the future
      db_delete('proteus_user_objective_level')     // Delete the user objective (topic) bookkeeping
        ->condition('uid', $account->uid)
        ->execute();
      db_delete('proteus_user_objective_log')       // Delete the user quiz log
        ->condition('uid', $account->uid)
        ->execute();
      break;
  }
}


/**
 * Implements hook_user_delete().
 */
function proteus_user_delete($account) {
  db_delete('proteus_user_objective_level')     // Delete the user objective (topic) bookkeeping
    ->condition('uid', $account->uid)
    ->execute();
  db_delete('proteus_user_objective_log')       // Delete the user quiz log
    ->condition('uid', $account->uid)
    ->execute();
}

/**
 * Menu callback - show view with all the users that started this proteus quiz.
 */
function proteus_users($node) {
  // add view html to page contents
  $retval = '<h2>' . t('Users that started this Proteus quiz') . ':</h2>';
  $retval .= views_embed_view('ClosedQuestionUsers', 'default', $node->nid);
  return $retval;
}

/**
 * Implements hook_theme().
 */
function proteus_theme() {
  $themes = array(
    'proteus_form_questionobjectives' => array(
      'render element' => 'form',
    ),
    'proteus_form_quiztargets' => array(
      'render element' => 'form',
    ),
    'proteus_objectivesoverview' => array(
      'variables' => array('overview' => NULL),
    ),
    'proteus_progressbar' => array(
      'variables' => array('progress' => 0),
    ),
    'proteus_stepchoices' => array(
      'variables' => array('links' => array()),
    ),
  );
  return $themes;
}

/**
 * Implements hook_node_info().
 */
function proteus_node_info() {
  $retval = array(
    'proteus' => array(
      'name' => t('Proteus Quiz'),
      'base' => 'proteus',
      'description' => t('Create a Proteus quiz.'),
    ),
  );
  return $retval;
}
 
/**
 * Implements hook_permission().
 */
function proteus_permission() {
  $retval = array(
    PROTEUS_RATE => array(
      'title' => t('Rate Proteus contained questions'),
      'description' => t('Users with this right can add, change or delete learning objectives for a Proteus quiz or question ratings for a Closed Question.'),
    ),
  );

  return $retval;
}

/**
 * Implements hook_insert().
 */
function proteus_insert($node) {
  // SQL: "INSERT INTO {proteus_quiz} (vid, nid, exit_text) VALUES (%d, %d, '%s')", $node->vid, $node->nid, $node->exit_text
  db_insert('proteus_quiz')->fields(array(
    'vid' => $node->vid,
    'nid' => $node->nid,
    'exit_text' => $node->exit_text,
  ))->execute();

  proteus_quiz_save($node);
}

/**
 *
 * Implements hook_update().
 */
function proteus_update($node) {
  if (!empty($node->revision)) { // if this is a new revision of the node,
    proteus_insert($node);
  }
  else {
    // SQL: "UPDATE {proteus_quiz} SET exit_text='%s' WHERE vid = %d", $node->exit_text, $node->vid
    db_update('proteus_quiz')->fields(array(
      'exit_text' => $node->exit_text,
    ))->condition('vid', $node->vid)->execute();

    proteus_quiz_save($node);
  }
}

/**
 * Implements hook_delete().
 */
function proteus_delete($node) {
  // SQL: 'DELETE FROM {proteus_quiz_objective_target} WHERE nid=%d', $node->nid
  db_delete('proteus_quiz_objective_target')->condition('nid', $node->nid)->execute();
}

/**
 * Implements hook_load().
 */
function proteus_load($nodes) {
  global $user;
  
  foreach ($nodes as $nid => &$node) {

    // SQL: 'SELECT exit_text FROM {proteus_quiz} WHERE vid = %d', $node->vid
    $node->exit_text = db_select('proteus_quiz', 'pq')->fields('pq', array('exit_text'))->condition('vid', $node->vid)->execute()->fetchField();

    $node->proteus = array();

    // SQL: 'SELECT termid,targetlevel FROM {proteus_quiz_objective_target} WHERE nid=%d;'
    $query = db_select('proteus_quiz_objective_target', 'pqot')->fields('pqot', array('termid', 'targetlevel'))->condition('nid', $nid);
    foreach ($query->execute() as $row) {
      $node->proteus[$row->termid] = array(
        'targetlevel' => $row->targetlevel,
      );
    }

    module_load_include('php', 'proteus', 'ProteusQuiz.class');
    $node->proteusQuiz = new ProteusQuiz($node, $user);
    $node->question = & $node->proteusQuiz; // ProteusQuiz implements CqQuestionInterface, so put it where questions are expected to be.

    $resetName = 'CqQS_' . $nid . '_ResetLevels';
    if (isset($_REQUEST[$resetName]) && (user_access(PROTEUS_CREATE) || $node->proteusQuiz->onceCorrect())) {
      $node->proteusQuiz->resetUserLevels();
    }
    $resetName = 'CqQS_' . $nid . '_ResetQuestions';
    if (isset($_REQUEST[$resetName]) && (user_access(PROTEUS_CREATE) || $node->proteusQuiz->onceCorrect())) {
      $node->proteusQuiz->resetUserQuestions();
      unset( $_REQUEST[$resetName] );
    }
  }
}

/**
 * Implements hook_view().
 */
function proteus_view(&$node, $view_mode) {
  // Only shown the quiz content when viewing the node
  if ( strpos($view_mode,'full') !== false ) {
    $question_node = NULL;

    drupal_add_css(drupal_get_path('module', 'proteus') . '/proteus.css');

    if (isset($node->proteus)) {
      $next_link_name = 'CqQS_' . $node->nid . '_Next';         // This one is set in ProteusQuiz.class constructor and is returned when an question is correctly answered
      $small_link_name = 'CqQS_' . $node->nid . '_Small';
      $medium_link_name = 'CqQS_' . $node->nid . '_Medium';
      $large_link_name = 'CqQS_' . $node->nid . '_Large';
      $config_step_size = variable_get('proteus_use_default_step', 0);

      $given_step_size_found = isset($_REQUEST[$small_link_name]) || isset($_REQUEST[$medium_link_name]) || isset($_REQUEST[$large_link_name]);
      $has_prev_question = $node->proteusQuiz->hasOldQuestion();
      $give_next_question = isset($_REQUEST[$next_link_name] );
      $quiz_is_correct = false;

      if ( isset($_REQUEST[$next_link_name] ) ) {
        // A question has been answered. clear this question so a new question can be searched or the quiz can be finished
        $node->proteusQuiz->clearOldQuestion();
        
        $quiz_is_correct = $node->proteusQuiz->isCorrect();
      }
      
      $return_question = ($give_next_question && ($config_step_size > 0) && !$quiz_is_correct) || $given_step_size_found;
      
      if ( !$return_question ) {
        // A question is finished, or the user just started.
        // Either display the "finished" screen, or the "select next step" screen.

        if ($quiz_is_correct) {
          // The user completed the quiz, show the "finished screen"
          $node->content['question'] = array(
            '#markup' => check_markup($node->exit_text, filter_default_format()),
            '#weight' => 1,
          );
        }
        else if ( $config_step_size == PROTEUS_CHOOSE ) {
          // The student must select the next step in the quiz to go to the first of next question
          // Display the "Select next question" screen

          $path = isset($_GET['q']) ? $_GET['q'] : '';

          $links['small']['path'] = $path;
          $links['small']['options'] = array('query' => array($small_link_name => 1));
          $links['medium']['path'] = $path;
          $links['medium']['options'] = array('query' => array($medium_link_name => 1));
          $links['large']['path'] = $path;
          $links['large']['options'] = array('query' => array($large_link_name => 1));
          $node->content['question'] = array(
            '#markup' => theme('proteus_stepchoices', array('links' => $links)),
            '#weight' => 1,
          );
        }
        else {
          // This the start of the quiz with configured step size.
          // shown the "Start the quiz" link
          $links['path'] = isset($_GET['q']) ? $_GET['q'] : '';
          switch ( $config_step_size ) {
          case PROTEUS_SMALL:
            $links['options'] = array('query' => array($small_link_name => 1));
            break;
          case PROTEUS_MEDIUM:
            $links['options'] = array('query' => array($medium_link_name => 1));
            break;
          case PROTEUS_LARGE:
            $links['options'] = array('query' => array($large_link_name => 1));
            break;
          default:
            drupal_set_message(t('An unknown step size is configured for Proteus quizzes.'), 'error');
            break;
          }
          $node->content['question'] = array(
            '#markup' => theme('proteus_stepchoices', array('links' => $links)),
            '#weight' => 1,
          );
        }
      }
      else {
        /**
         * We either have an old question, or the student selected a step-size.
         * Find the (next) question and display it
         */
        $search_rule = PROTEUS_USEOLD;
        if (!$node->proteusQuiz->hasOldQuestion()) {
          if (($config_step_size == PROTEUS_SMALL) || isset($_REQUEST[$small_link_name])) {
            $search_rule = PROTEUS_SMALL;
          }
          elseif (($config_step_size == PROTEUS_MEDIUM) || isset($_REQUEST[$medium_link_name])) {
            $search_rule = PROTEUS_MEDIUM;
          }
          elseif (($config_step_size == PROTEUS_LARGE) || isset($_REQUEST[$large_link_name])) {
            $search_rule = PROTEUS_LARGE;
          }
        }

        // Fetch the question node of the selected question.
        $node->proteusQuiz->selectQuestion($search_rule);
        $question_node = $node->proteusQuiz->getQuestionNode();

        if (isset($question_node->question)) {
          $question_levels = $question_node->proteus;

          // Figure out what the current levels are and how this question can
          // affect those.
          $overview = array();
          $overview_completion = 0;
          foreach ($node->proteus as $tid => $term) {
            $user_objective = $node->proteusQuiz->getUserLevelsFor($tid);
            $target_level = empty($term['targetlevel']) ? 0 : $term['targetlevel'];
            $cur_level = empty($user_objective['curlevel']) ? 0 : $user_objective['curlevel'];
            $max_level = empty($user_objective['maxlevel']) ? 0 : $user_objective['maxlevel'];
            $enter_level = isset($question_levels[$tid]['enterlevel']) ? $question_levels[$tid]['enterlevel'] : '-';
            $exit_level = isset($question_levels[$tid]['exitlevel']) ? $question_levels[$tid]['exitlevel'] : '-';
            $taxterm = taxonomy_term_load($tid);
            $overview[$tid]['title'] = array('#markup' => $taxterm->name);
            $overview[$tid]['enterlevel'] = array('#markup' => $enter_level);
            $overview[$tid]['exitlevel'] = array('#markup' => $exit_level);
            $overview[$tid]['curlevel'] = array('#markup' => $cur_level);
            $overview[$tid]['maxlevel'] = array('#markup' => $max_level);
            $overview[$tid]['targetlevel'] = array('#markup' => $target_level);
            $overview_completion += min(1, $cur_level / $target_level);
          }
          $overview_completion *= 100;
          $overview_completion /= count($node->proteus);

          // For teachers or when enabled through the configuration: print the complete level overview.
          if (user_access(PROTEUS_CREATE) || variable_get('proteus_show_progress', FALSE) ) {
            $node->content['proteus_objectivesoverview'] = array(
              '#markup' => '' . theme('proteus_objectivesoverview', array('overview' => $overview)),
              '#weight' => -10,
            );
          }
          
          // For students, print a simple progress-bar.
          $node->content['proteus_objectivesprogress'] = array(
            '#markup' => theme('proteus_progressbar', array('progress' => $overview_completion)),
            '#weight' => -9,
          );

          /**
           * Display the question.
           * We don't want to use node_view, as that also adds stuff like
           * book-navigation, so we directly use question->getOutput().
           */
          if (isset($question_node->question)) {
            $node->content['question'] = $question_node->question->getOutput();
            $node->content['question']['#weight'] = 0;

            // This is a trick to place the link to the next question next to the submit button of the question. The
            // link is submitted to the user as a feedback text. This span with the specified class is used to identify
            // the position to replace with the link text. See ProteusQuiz.class.php in function getExtraFeedbackItems(...)
            $node->content['question']['proteus_next_question'] = array(
              '#markup' => '<span class="cqFbBlock cqFb-next" ></span>',
            );
          }
        }
        else {
          // There is no question node. Either the module is already finished,
          // or there is a problem.
          if ($node->proteusQuiz->onceCorrect() && $node->proteusQuiz->isCorrect()) {
            $node->content['question'] = array(
              '#markup' => '<p>' . t('You have already finished the module.') . '</p>',
              '#weight' => 0,
            );
          }
          else {
            $node->content['question'] = array(
              '#markup' => '<p>' . t('No (more) suitable questions found! Please contact your teacher.') . '</p>',
              '#weight' => 0,
            );
          }
        }
      }
      
      /**
       * Teachers and students that have finished the module are allowed to reset
       * their levels and questions so they can re-take the quiz to practice some
       * more.
       *
       * Teachers also get a link to directly edit the question.
       */
      if (user_access(PROTEUS_CREATE) || $node->proteusQuiz->onceCorrect()) {
        $path = isset($_GET['q']) ? $_GET['q'] : '';
        $resetLvlLink = l(t('Reset all levels.'), $path, array('query' => array('CqQS_' . $node->nid . '_ResetLevels' => 1)));
        $resetQnsLink = l(t('Reset all questions.'), $path, array('query' => array('CqQS_' . $node->nid . '_ResetQuestions' => 1)));
        $editQuestionLink = '';
        if (user_access(PROTEUS_CREATE) && isset($question_node->nid)) {
          $editQuestionLink = l(t('Edit current question.'), 'node/' . $question_node->nid . '/edit');
        }
        $node->content['reset'] = array(
          '#markup' => '<br/>' . $resetLvlLink . ' ' . $resetQnsLink . ' ' . $editQuestionLink,
          '#weight' => 2,
        );
      }
    }
    else {
      $node->content['question'] = array(
        '#markup' => t('No target levels found!'),
        '#weight' => 0,
      );
    }
  }

  return $node;
}

/**
 * Saves the proteus objectives data of a proteus node.
 *
 * @param Object $node
 *   Drupal node object of the proteus node to save the objectives data for.
 */
function proteus_quiz_save(&$node) {
  if ( isset($node->proteusObjectives) ) {
    $objectives_correct = TRUE;
    
    if (!isset($node->proteus)) {
      $nodes = array( $node->nid => $node );
      proteus_load( $nodes );
    }
    
    // First check if there are objectives in the node Proteus object that are not in the received
    // objectives list. These must be deleted.
    if ( !empty($node->proteus) ) {
      foreach ($node->proteus as $tid => $level) {
        if ( !array_key_exists( $tid, $node->proteusObjectives ) )
        {
            // The objective is removed by the user.
            // SQL: 'DELETE FROM {proteus_quiz_objective_target} WHERE nid=%d AND termid=%d;'
            db_delete('proteus_quiz_objective_target')->condition('nid', $node->nid)->condition('termid', $tid)->execute();
            //dpm($tid, 'proteus_quiz_save delete objective');
        }
      }
    }

    foreach ($node->proteusObjectives as $tid => $objective) {
      $tid = (int) $tid;
      if ($tid > 0) {
        $targetlevel = $objective['targetlevel'];
        if (!isset($node->proteus[$tid])) { // New objective
          //dpm($tid, 'proteus_quiz_save add new objective');
          
          // SQL: 'INSERT INTO {proteus_quiz_objective_target} SET nid=%d, termid=%d, targetlevel=%d;'
          db_insert('proteus_quiz_objective_target')->fields(array(
            'nid' => $node->nid,
            'termid' => $tid,
            'targetlevel' => $targetlevel,
          ))->execute();
        }
        else { // Existing objective
          //dpm($tid, 'proteus_quiz_save changing objective');
          
          // SQL: 'UPDATE {proteus_quiz_objective_target} SET targetlevel=%d WHERE nid=%d AND termid=%d;'
          db_update('proteus_quiz_objective_target')->fields(array(
            'targetlevel' => $targetlevel,
          ))->condition('nid', $node->nid)->condition('termid', $tid)->execute();
        }
        
        if ($targetlevel == 0) {
          $objectives_correct = FALSE;
        }
      }
    }
    
    if ($objectives_correct == 0) {
      drupal_set_message(t('At least one objective has no correct target level. Correct this before using this quiz.'), 'warning');
    }
  }
  else {
    drupal_set_message(t('No objectives have been assigned to this Proteus quiz. Before using this quiz, assign objectives to this quiz and questions to use with it.'), 'warning');
  }
}

/**
 * Implements hook_form().
 */
function proteus_form($node, &$form_state) {

  // Handle any asynchronous event that may be the cause of this call. Check which and handle it
  handle_proteus_events( $node, $form_state );

  $type = node_type_get_type( $node );

  // Add title if required
  if ( !empty($type->has_title) ) {
    $form['title'] = array(
      '#type' => 'textfield',
      '#title' => check_plain($type->title_label),
      '#required' => TRUE,
      '#default_value' => $node->title,
      '#weight' => -5,
    );
  }

  $form['exit_text'] = array(
    '#type' => 'textarea',
    '#title' => t('Text when finished'),
    '#default_value' => (array_key_exists( 'exit_text', $node ) ? $node->exit_text : ''),
    '#required' => FALSE,
  );

  // Objectives fieldset
  $form['proteus'] = array(
    '#type' => 'fieldset',
    '#access' => user_access(PROTEUS_RATE),
    '#title' => t('Proteus Learning Objectives'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#description' => t('Changes made to the learning objectives are not permanent until you save this Proteus quiz.'),
    '#prefix' => '<div class="proteus">',
    '#suffix' => '</div>',
    '#weight' => 1,
  );

  // Wrapper for fieldset contents (used by ajax).
  $form['proteus']['proteus-wrapper'] = array(
    '#prefix' => '<div id="proteus-wrapper">',
    '#suffix' => '</div>',
    'proteusObjectives' => proteus_quiz_form_objectives($node, $form_state),
  );

  // Add-button for adding new objectives.
  $form['proteus']['add'] = proteus_form_addbutton($node);

  return $form;
}

/**
 * Checks if any asynchronous event has occurred. If so, it will try to handle it. Checking
 * is done by testing for presence of the 'triggering_element' field. This indicates that a
 * user has triggered an event action (ajax mostly).
 *
 * @param array $form_state
 *   The form state of the form to generate the form-part for.
 *
 * @return array
 *   The form-state will be altered according the user input.
 */
 function handle_proteus_events($node, &$form_state) {
  if (user_access(PROTEUS_RATE) && isset($form_state['triggering_element']) && isset($form_state['triggering_element']['#type'])) {
    // Always add the present Proteus objectives to the list to return, otherwise they will not be correctly updated
    $form_state['proteus_new']['proteus'] = array();
    if (isset($form_state['values']['proteusObjectives'])) {
      foreach ($form_state['values']['proteusObjectives'] as $tid_prev => $objective) {
        $form_state['proteus_new']['proteus'][$tid_prev] = $objective;
      }
    }

    if ($form_state['triggering_element']['#type'] == 'select' ) {
      // It is the add term trigger event that must be handled
      if ( strstr($form_state['triggering_element']['#name'], 'proteus_term' ) ) {
        // A new term must be added to the list
        if (!empty($form_state['triggering_element']['#value'])) {
          // There is a 'new' term selected. Add it to the terms list if not already present
          $tid = $form_state['triggering_element']['#value'];

          if ((int) $tid > 0 && !isset($form_state['values']['proteusObjectives'][$tid])) {
            //dpm($tid, 'Adding new proteus term to proteusObjectives:');
            
            $form_state['values']['proteusObjectives'][$tid] = array();
            $form_state['proteus_new']['proteus'][$tid] = array();
          }
        }
      }
    }
    else if ($form_state['triggering_element']['#type'] == 'submit' ) {
      if (isset($form_state['triggering_element']['#parents']) && count($form_state['triggering_element']['#parents']) >= 3 && $form_state['triggering_element']['#parents'][0] == 'proteusObjectives' ) {
        // A term must be removed
        $tid_remove = $form_state['triggering_element']['#parents'][1];
        
        //dpm($tid_remove, 'Removing proteus term:');
        
        if ( isset($form_state['values']['proteusObjectives'][$tid_remove]) ) {
          // Unset these state values to indicate that these objectives must be removed during save action
          unset($form_state['values']['proteusObjectives'][$tid_remove]);
          unset($form_state['proteus_new']['proteus'][$tid_remove]);
        }

        $form_state['rebuild'] = TRUE;
      }
    }
    //else {
    //  drupal_set_message('handle_proteus_events: no event found');
    //}
  }
}


/**
 * Generate the form-part that edits objectives for a question.
 * This bit of form gets put in
 * $form['proteus']['proteus-wrapper']['objectives']
 *
 * @param object $node
 *   The drupal node object of the proteus quiz.
 *
 * @param array $form_state
 *   The form state of the form to generate the form-part for.
 *
 * @return array
 *   A drupal form-api compatibel form-array.
 */
function proteus_quiz_form_objectives($node, $form_state) {
  // We want the objectives to be listed under a common parent in
  // form_state['values'] so $form['#tree'] = TRUE;
  $form = array(
    '#tree' => TRUE,
    '#theme' => 'proteus_form_quiztargets',
  );
  
  if (isset($form_state['proteus_new']['proteus'])) {
    $proteus = $form_state['proteus_new']['proteus'];
  }
  elseif (isset($node->proteus)) {
    $proteus = $node->proteus;
  }
  
  if (!empty($proteus)) {
    foreach ($proteus as $tid => $term) {
      $targetlevel = empty($term['targetlevel']) ? 0 : $term['targetlevel'];
      $taxterm = taxonomy_term_load($tid);
      $form[$tid]['title'] = array('#markup' => $taxterm->name);
      $form[$tid]['targetlevel'] = array(
        '#type' => 'textfield',
        '#default_value' => $targetlevel,
        '#maxlength' => 5,
        '#size' => 5,
      );
      $form[$tid]['remove'] = array(
        '#type' => 'submit',
        '#value' => t('Remove'),
        '#name' => 'remove' . $tid,
        '#executes_submit_callback' => FALSE,
        '#ajax' => array(
          'callback' => 'proteus_edit_term_callback',
          'wrapper' => 'proteus-wrapper',
          'progress' => array(
            'type' => 'throbber',
            'message' => t('Term is being removed ...'),
          ),
          'effect' => 'fade',
        ),
      );
    }
  }
  
  return $form;
}

/**
 * Menu callback - show the question overview for a single Proteus quiz.
 */
function proteus_questions( $node ) {
  drupal_add_css(drupal_get_path('module', 'proteus') . '/proteus.css');
  drupal_set_title('Questions for: ' . $node->title);

  return $node->proteusQuiz->generateQuestionOverview();
}


/**
 * Implements hook_node_load().
 */
function proteus_node_load( $nodes, $types ) {
  foreach ( $nodes as $nid => &$node ) {
    // We are using the revision id instead of node id.
    if ($node->type == "closedquestion") {
      proteus_question_load($node);
    }
  }
}


/**
 * Implements hook_node_view().
 */
/*function proteus_node_view($node, $view_mode = 'full') {
}*/


/**
 * Implements hook_node_insert().
 */
function proteus_node_insert($node) {
  if ($node->type == "closedquestion" && user_access(PROTEUS_RATE)) {
    
    if (!isset($node->proteus)) {
      proteus_question_load($node);
    }

    if (isset($node->proteusObjectives)) {
      foreach ($node->proteusObjectives as $tid => $objective) {
        $tid = (int) $tid;
        if ($tid > 0) {
          $enterLevel = $objective['enterlevel'];
          $exitLevel = $objective['exitlevel'];

          // SQL: 'INSERT INTO {proteus_question_objective} SET nid=%d, termid=%d, enterlevel=%d, exitlevel=%d;'
          db_insert('proteus_question_objective')->fields(array(
            'nid' => $node->nid,
            'termid' => $tid,
            'enterlevel' => $enterLevel,
            'exitlevel' => $exitLevel,
          ))->execute();
        }
      }
    }
  }
}


/**
 * Implements hook_node_update().
 */
function proteus_node_update($node) {
  if ($node->type == "closedquestion" && user_access(PROTEUS_RATE)) {
    
    if (!isset($node->proteus)) {
      proteus_question_load($node);
    }
    
    // First check if there are objectives in the node Proteus object that are not in the recieved
    // objectives list. These must be deleted.
    if ( !empty($node->proteus) ) {
      foreach ($node->proteus as $tid => $level) {
        if ( !array_key_exists( $tid, $node->proteusObjectives ) )
        {
            // The objective is removed by the user.
            // SQL: 'DELETE FROM {proteus_question_objective} WHERE nid=%d AND termid=%d;'
            db_delete('proteus_question_objective')->condition('nid', $node->nid)->condition('termid', $tid)->execute();
            //dpm($tid, 'proteus_node_update delete objective');
        }
      }
    }

    if ( isset($node->proteusObjectives) ) {
      foreach ($node->proteusObjectives as $tid => $objective) {
        $tid = (int) $tid;
        if ($tid > 0) {
          $enterLevel = $objective['enterlevel'];
          $exitLevel = $objective['exitlevel'];

          if (isset($node->proteus[$tid])) {
            // SQL: 'UPDATE {proteus_question_objective} SET enterlevel=%d, exitlevel=%d WHERE nid=%d AND termid=%d;'
            db_update('proteus_question_objective')->fields(array(
              'enterlevel' => $enterLevel,
              'exitlevel' => $exitLevel,
            ))->condition('nid', $node->nid)->condition('termid', $tid)->execute();
            //dpm($tid, 'proteus_node_update updated objective');
          }
          else {
            // A new objective is added
            // SQL: 'INSERT INTO {proteus_question_objective} SET nid=%d, termid=%d, enterlevel=%d, exitlevel=%d;'
            db_insert('proteus_question_objective')->fields(array(
              'nid' => $node->nid,
              'termid' => $tid,
              'enterlevel' => $enterLevel,
              'exitlevel' => $exitLevel,
            ))->execute();
            //dpm($tid, 'proteus_node_update added new objective');
          }
        }
      }
    }
  }
}


/**
 * Implements hook_node_delete().
 */
function proteus_node_delete($node) {
  if ($node->type == "closedquestion") {
    $node->proteus = array();   // Clear the QlosedQuestion related information in the Proteus quiz

    // SQL: 'DELETE FROM {proteus_question_objective} WHERE nid=%d;'
    db_delete('proteus_question_objective')->condition('nid', $node->nid)->execute();
  }
}


/**
 * Implements load question.
 */
function proteus_question_load(&$node) {
  if ($node->type == "closedquestion") {
    $node->proteus = array();

    // SQL: 'SELECT termid,enterlevel,exitlevel FROM {proteus_question_objective} WHERE nid=%d;'
    $query = db_select('proteus_question_objective', 'pqo')->fields('pqo', array('termid', 'enterlevel', 'exitlevel'))->condition('nid', $node->nid);
    foreach ($query->execute() as $row) {
      $node->proteus[$row->termid] = array(
        'enterlevel' => $row->enterlevel,
        'exitlevel' => $row->exitlevel,
      );
    }
  }
}


/**
 * Implements hook_form_alter().
 * Used to add a proteus section to closed questions.
 */
function proteus_form_alter(&$form, &$form_state, $form_id) {
  if (isset($form['type']) && isset($form['#node'])) {
    $node = $form['#node'];
    if ($form['type']['#value'] . '_node_form' == $form_id && $node->type == "closedquestion") {
      // Handle any asynchronous event that may be the cause of this call. Check which and handle it
      handle_proteus_events( $node, $form_state );

      // Objectives fieldset
      $form['proteus'] = array(
        '#type' => 'fieldset',
        '#access' => user_access(PROTEUS_RATE),
        '#title' => t('Proteus Question Rating'),
        '#collapsible' => TRUE,
        '#collapsed' => empty($node->proteus),
        '#description' => t('Changes made to the question rating(s) are not permanent until you save this question.'),
        '#prefix' => '<div class="proteus">',
        '#suffix' => '</div>',
        '#weight' => 30,
      );

      // Objectives added, in a wrapper for #ajax.
      $form['proteus']['proteus-wrapper'] = array(
        '#prefix' => '<div id="proteus-wrapper">',
        '#suffix' => '</div>',
        'proteusObjectives' => proteus_question_form_objectives($node, $form_state),
      );

      // Add-button for adding new objectives.
      $form['proteus']['add'] = proteus_form_addbutton($node);
    }
  }
}


/**
 * Generate the form-part that edits objectives for a question.
 * This bit of form gets put in $form['proteus']['proteus-wrapper']['objectives']
 *
 * @param object $node
 *   The drupal node object of the question.
 *
 * @param array $form_state
 *   The form state of the form to generate the form-part for.
 *
 * @return array
 *   A drupal form-api compatibel form-array.
 */
function proteus_question_form_objectives($node, $form_state) {
  $form = array();
  // We want the objectives to be listed under a common parent in
  // form_state['values'] so $form['#tree'] = TRUE;
  $form['#tree'] = TRUE; // group them in form_state['values']
  $form['#theme'] = 'proteus_form_questionobjectives';

  if (isset($form_state['proteus_new']['proteus'])) {
    $proteus = $form_state['proteus_new']['proteus'];
  }
  elseif (isset($node->proteus)) {
    $proteus = $node->proteus;
  }
  
  if (!empty($proteus)) {
    foreach ($proteus as $tid => $term) {
      $enterlevel = empty($term['enterlevel']) ? 0 : $term['enterlevel'];
      $exitlevel = empty($term['exitlevel']) ? 10 : $term['exitlevel'];
      $taxterm = taxonomy_term_load($tid);
      $form[$tid]['title'] = array('#markup' => $taxterm->name);
      $form[$tid]['enterlevel'] = array(
        '#type' => 'textfield',
        '#default_value' => $enterlevel,
        '#maxlength' => 5,
        '#size' => 5,
      );
      
      $form[$tid]['exitlevel'] = array(
        '#type' => 'textfield',
        '#default_value' => $exitlevel,
        '#maxlength' => 5,
        '#size' => 5,
      );

      $form[$tid]['remove'] = array(
        '#type' => 'submit',
        '#value' => t('Remove'),
        '#name' => 'remove' . $tid,
        '#executes_submit_callback' => FALSE,
        '#ajax' => array(
          'callback' => 'proteus_edit_term_callback',
          'wrapper' => 'proteus-wrapper',
          'progress' => array(
            'type' => 'throbber',
            'message' => t('Term is being removed ...'),
          ),
          'effect' => 'fade',
        ),
      );
    }
  }
  return $form;
}

/**
 * Generate the form-part with the add-objective button and select
 * boxes for all the vocabularies for a question or a quiz.
 * This bit of form gets put in $form['proteus']['add']
 *
 * @param object $node
 *   Drupal node object that the form belongs to.
 *
 * @return array
 *   A drupal form-api compatibel form-array.
 */
function proteus_form_addbutton($node) {
  $form = array();
  $count = 0;
  $form['proteus_term']['#tree'] = TRUE; // group them in form_state['values']
  $fields = field_info_fields();

  foreach ( $fields as $field_name => $field ) {
    if (!empty($field['bundles']['node']) &&
      $field['type'] == 'taxonomy_term_reference' &&
      in_array($node->type, $field['bundles']['node']) &&
      !empty($field['settings']['allowed_values']) ) {
      // Get the vocabulary information that is related to this field found
      $vocabulary = taxonomy_vocabulary_machine_name_load( $field['settings']['allowed_values'][0]['vocabulary'] );
      // Get all terms that are related to this vocabulary
      $tree = taxonomy_get_tree($vocabulary->vid);
      $options = array();

      $options[''] = t('- Please choose -');    // Add the initial choice indicating the action to perform

      // Put all terms in the tree for the drop-down combobox
      foreach ($tree as $term) {
        $options[$term->tid] = str_repeat('-', $term->depth) . $term->name;
      }
      
      // Add the ajax event submitting term selection field. When a user selects a new term from the list, an ajax
      // event is sent to the server to handle the user action. This is done by performing the whole from build and then
      // filter the returned information within the specified callback function
      $form['proteus_term'][$vocabulary->vid] = array(
        '#type' => 'select',
        '#title' => t('Add a topic from: ') . check_plain($vocabulary->name),
        '#options' => $options,
        '#default_value' => '',
        '#description' => filter_xss_admin($vocabulary->description), // Used to be the help text given with the vocabulary
        '#multiple' => FALSE,
        '#ajax' => array(
          'callback' => 'proteus_edit_term_callback',
          'wrapper' => 'proteus-wrapper',
          'progress' => array(
            'type' => 'throbber',
            'message' => t('Term is being added ...'),
          ),
          'effect' => 'fade',
        ),
      );
      $form['proteus_term'][$vocabulary->vid]['#weight'] = $vocabulary->weight;

      $count++;
    }
  }

  if ($count == 0) {
    if ( $node->type == "proteus" ) {
      drupal_set_message( t('No taxonomy term field for choosing the topics is associated with the Proteus content type. Go to Proteus <a href="@link">manage fields</a>, add a taxonomy term reference field and associate it with the vocabulary that will be used for both "Closed Question" and "Proteus Quiz" terms.', array('@link' => url('admin/structure/types/manage/proteus/fields'))), 'error' );
    }
    elseif ( $node->type == "closedquestion" )
    {
      drupal_set_message( t('No taxonomy term field for choosing the topics is associated with the Closed Question content type. Go to Closed Question <a href="@link">manage fields</a>, add a taxonomy term reference field and associate it with the vocabulary that will be used for both "Closed Question" and "Proteus Quiz" terms.', array('@link' => url('admin/structure/types/manage/closedquestion/fields'))), 'error' );
    }
  }
  
  return $form;
}


/**
 * Ajax-callback for JavaScript-based actions used in the question and quiz edit
 * page.
 */
function proteus_edit_term_callback($form, $form_state) {
  return $form['proteus']['proteus-wrapper'];
}


/**
 * Theme the objectives list of a question.
 *
 * @param array $form
 *   The form element to theme.
 *
 * @return string
 *   The rendered form element.
 *
 * @ingroup themeable
 */
function theme_proteus_form_questionobjectives($variables) {
  $form = $variables['form'];
  $header = array(t('Topic'), t('Entry level'), t('Exit level'), t('Remove'));

  $count = 0;
  foreach (element_children($form) as $key) {
    $count++;
    $row = array();
    $row[] = drupal_render($form[$key]['title']);
    $row[] = drupal_render($form[$key]['enterlevel']);
    $row[] = drupal_render($form[$key]['exitlevel']);
    $row[] = drupal_render($form[$key]['remove']);
    $rows[] = array(
      'data' => $row,
//      'class' => array('draggable'),  // Not completely implemented, so not used
    );
  }
  if ($count > 0) {
    // The next function can also be replaced by theme_table(...)
    $output = theme('table', array('header' => $header, 'rows' => $rows, 'attributes' => array('id' => 'proteus-objectives')));
    $output .= drupal_render_children($form);
  }
  else {
    $message = array('#markup' => t('No objectives defined yet.'));
    $output = drupal_render($message);
  }
  return $output;
}

/**
 * Theme the target objectives list of a quiz.
 *
 * @param array $form
 *   The form element to theme.
 *
 * @return string
 *   The rendered form element.
 *
 * @ingroup themeable
 */
function theme_proteus_form_quiztargets($variables) {
  $form = $variables['form'];
  $header = array(t('Topic'), t('Target level'), t('Remove'));
  $rows = array();
  foreach (element_children($form) as $key) {
    $row = array();
    $row[] = drupal_render($form[$key]['title']);
    $row[] = drupal_render($form[$key]['targetlevel']);
    $row[] = drupal_render($form[$key]['remove']);
    $rows[] = array(
      'data' => $row,
//      'class' => array('draggable'),      // Not completely implemented, so not used
    );
  }
  $output = theme('table', array('header' => $header, 'rows' => $rows, 'attributes' => array('id' => 'proteus-objectives', 'class' => array())));
  $output .= drupal_render_children($form);
  return $output;
}

/**
 * Theme the overview of objectives for the current question.
 *
 * @param array $overview
 *   The objective data to theme. Array of arrays with fields:
 *   - title: string - The title of the objective.
 *   - enterlevel: int - The enter level of the question for this objective.
 *   - exitlevel: int - The exit level of the question for this objective.
 *   - curlevel: int - The current level of the student for this objective.
 *   - maxlevel: int - The maximum level of the student for this objective.
 *   - targetlevel: int - The target level of this objective for this quiz.
 *
 * @return string
 *   The rendered overview.
 *
 * @ingroup themeable
 */
function theme_proteus_objectivesoverview($variables) {
  $overview = $variables['overview'];
  $header = array(
    t('Topic'),
    t('Enter Level'),
    t('Exit Level'),
    t('Current Level'),
    t('Max Level'),
    t('Target level'),
  );
  foreach (element_children($overview) as $key) {
    $row = array();
    $row[] = drupal_render($overview[$key]['title']);
    $row[] = drupal_render($overview[$key]['enterlevel']);
    $row[] = drupal_render($overview[$key]['exitlevel']);
    $row[] = drupal_render($overview[$key]['curlevel']);
    $row[] = drupal_render($overview[$key]['maxlevel']);
    $row[] = drupal_render($overview[$key]['targetlevel']);
    $rows[] = array(
      'data' => $row,
//      'class' => array('draggable'),      // Not completely implemented, so not used
    );
  }
  $output = theme('table', array('header' => $header, 'rows' => $rows, 'attributes' => array('id' => 'proteus-objectives')));
  $output .= drupal_render($overview);
  return $output;
}

/**
 * Theme a progressbar showing how far the user has progressed through this
 * quiz.
 *
 * @param int $progress
 *   The progress of the user, in %.
 *
 * @return string
 *   The rendered progress bar.
 *
 * @ingroup themeable
 */
function theme_proteus_progressbar($variables) {
  $progress = $variables['progress'];
  return '<div class="baroutline"><div class="bar" style="margin-left:0% ;width: ' . $progress . '%;"> </div></div>';
}

/**
 * Theme the choices the student has for choosing the next question.
 *
 * @param array $links
 *   associative array with keys small, medium and large, each containing an
 *   associative array with keys:
 *   - path: string - The url to use for this link.
 *   - options: string - The l() compatible url-options to use for this link.
 *
 * @return string
 *   The rendered choices.
 *
 * @ingroup themeable
 */
function theme_proteus_stepchoices($variables) {
  $links = $variables['links'];
  $html = '';
  
  if ( isset( $links['path'] ) ) {
    // The user cannot choose the next step (see proteus_view(...)). Here the link to the start of the quiz must be shown
    $html = '<p class="startquiz"> [' . l(t('Start the quiz ...'), $links['path'], $links['options']) . ' ] </p>';
  }
  else {
    // The user must specify the next step
    $html = '<h2 class="stepchoice">' . t('Choose a step:') . '</h2>';
    $html .= ' <p class="stepchoice">';
    if (isset($links['small'])) {
      $html .= '[ ' . l(t('Small'), $links['small']['path'], $links['small']['options']) . ' ]';
    }
    if (isset($links['medium'])) {
      $html .= '[ ' . l(t('Medium'), $links['medium']['path'], $links['medium']['options']) . ' ]';
    }
    if (isset($links['large'])) {
      $html .= '[ ' . l(t('Large'), $links['large']['path'], $links['large']['options']) . ' ]';
    }
    $html .= ' </p>';
  }
  
  return $html;
}
