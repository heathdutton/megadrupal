<?php

namespace Drupal\soauth\Provider;

use Drupal\soauth\Router;
use Drupal\soauth\Service;

use Drupal\soauth\Common\Url;
use Drupal\soauth\Common\Storage;
use Drupal\soauth\Common\Session;

use Drupal\soauth\Common\Entity\User;
use Drupal\soauth\Common\Hydrator\ObjectMap;


/**
 * Class AbstractBaseProvider
 * @author Raman Liubimau <raman@cmstuning.net>
 */
abstract class AbstractBaseProvider {
  
  /**
   * Database storage
   * @var Storage
   */
  private $storage;
  
  /**
   * Session storage
   * @var Session
   */
  private $session;
  
  /**
   * Construct provider
   * @param $service Service
   */
  public function __construct() {
    $this->storage = new Storage($this->getName());
    $this->session = new Session($this->getName());
  }
  
  /**
   * Get name.
   * @return string
   */
  public function __toString() {
    return $this->getName();
  }
  
  /**
   * Get database storage
   * @return Storage
   */
  public function getStorage() {
    return $this->storage;
  }

  /**
   * Get session storage
   * @return Session
   */
  public function getSession() {
    return $this->session;
  }  
  
  /**
   * Get permissions
   * @param string glue
   * @return array|string
   */
  public function getScope($glue=NULL) {
    // Provider scope is stored as array of strings. By default, this function
    // returns scope as is. But provider must redefine this function and
    // set default glue of strings array according to provider documentation.
    $scope = $this->getStorage()->get('scope', array());
    
    return (is_null($glue) ? $scope : implode($glue, $scope));
  }
  
  /**
   * Get weight.
   * @return integer
   */
  public function getWeight() {
    return $this->getStorage()->get('weight', 0);
  }
  
  /**
   * Build action url.
   * @param string $action
   * @param string $destination
   * @return Url
   */
  public function buildActionUrl($action, $destination='') {
    if (!empty($destination)) {
      return Router::buildActionUrl($this, $action, array(
        'to' => $destination,
      ));
    }
    return Router::buildActionUrl($this, $action);
  }
  
  /**
   * Get redirect URL.
   * This URL must match redirect URL in app settings.
   * @return Url
   */
  public function getRedirectUrl() {
    return $this->buildActionUrl('connect');
  }
  
  /**
   * Get destination url
   * @return string
   */
  public function getDestinationUrl() {
    return $this->getSession()->get('to');
  }
  
  /**
   * Get user data in uniform form.
   * @return array
   */
  public function getUniformUserData($token) {
    // Get raw user data from provider
    $rawData = $this->getRawUserData($token);
    $userData = array(
      'raw' => $rawData,
    );
    
    // Get uniform field map from provider
    $fieldMap = $this->getUniformFieldMap();
    
    // Transform raw user data to uniform form
    foreach ($fieldMap as $key => $field) {
      $userData[$key] = $field->get($rawData);
    }
    
    return $userData;
  }
  
  
  /**
   * Set destination
   * This function sets destination url that will be used as url of redirect
   * after executing action. Default value of destination url is url of the
   * front page.
   * @param array $query
   */
  protected function setDestinationUrl($query) {
    $this->getSession()->set('to', (
      isset($query['to']) ? $query['to'] : '<front>'
    ));
  }
  
  /**
   * Find or create new user
   * @param array $data
   * @return array
   */
  protected function findOrCreateUser($data) {    
    if (user_is_logged_in()) {
      return array(
        'action' => 'connect',
        'user' => User::getCurrent(),
      );
    } elseif (($user = User::find($this, $data['id'], $data['mail']))) {
      return array(
        'action' => 'login',
        'user' => $user,
      );
    } else {
      return array(
        'action' => 'registration',
        'user' => $this->createUser($data),
      );
    }
  }
  
  /**
   * Create new Drupal's user
   * @param array $data
   */
  protected function createUser($data) {
    // Construct new user from uniform data passed as argument. At least,
    // unform user data must contain external user id and user email. If
    // advanced mapping is enabled, other fields will be mapped using ObjectMap.
    $user = new User();
    
    // Drupal's user name must be unique and we will generate them using
    // authentication providers machine name and external user id.
    $user->name = $this.'-'.$data['id'];
    
    // Because user password is autogenerated by this function, we need to
    // notify user about it. Out of box Drupal support only one email address
    // per user.
    $user->mail = $data['mail'];
    
    // Generate user password, set user active and give default role
    $user->pass = user_password(8);
    $user->status = 1;
    $user->init = 'email_address';
    $user->roles = array(DRUPAL_AUTHENTICATED_RID => 'authenticated user',);
    
    // To tell Drupal's function user_save() that user is new, we must set 
    // is_new flag.
    // @see https://api.drupal.org/api/drupal/modules%21user%21user.module/function/user_save/7
    $user->is_new = TRUE;
    
    // At this point basic mapping is finished. Get SoAuth service settings if
    // we must make advanced mapping.
    $settings = Service::getInstance()->getSettings();
    
    // Check if advanced mapping is enabled.
    if ($settings->get('mapping', FALSE)) {
      // Get field mapping map from settings and transform them to use with
      // ObjectMap
      $map = array_flip($settings->get('mapping_map', array()));
      
      // Create ObjectMap and hydrate new user
      $hydrator = new ObjectMap($map);
      $hydrator->hydrate($user, $data);
    }
    
    // Copy user password and save user. User password will be unset in
    // user_save() function, but we must send it to user.
    $pass = $user->pass;
    $user->save();
    $user->pass = $pass;
    
    // Get site primary email address and send email with credentials to user
    $site_mail = variable_get('site_mail', '');
    
    drupal_mail('user', 'register_no_approval_required', $user->mail, NULL,
      array('account' => $user->getObject()), $site_mail);
    
    return $user;
  }
  
  /**
   * Install hook.
   * By default do nothing, but you can redefine it in your provider.
   * For example, you can set presets for application permissions.
   */
  public function setDefaults() {
    // Do nothing
  }

  /**
   * Get a short name of provider.
   * This function must return a short machine-readable name of provider.
   * @return string
   */
  abstract public function getName();
  
  /**
   * Get a full name of provider.
   * This function must return a full name of provider.
   * @return string
   */
  abstract public function getFullName();
  
  /**
   * Get authorize page URL
   * @return Url 
   */
  abstract public function getAuthorizeUrl();
  
  /**
   * Get request token URL
   * @return Url
   */
  abstract public function getRequestTokenUrl();
  
  
  /**
   * Get uniform fields
   * @return array
   */
  abstract public function getUniformFieldMap();

  /**
   * Get current user identity from provider by token
   * @param string $token
   * @return User
   */
  abstract public function getRawUserData($token);
  
  /**
   * Build API endpoint URL
   * @param string path
   * @return Url
   */
  abstract public function buildApiEndpointUrl($path);

  /**
   * Make settings form.
   * @return array
   */
  abstract public function makeSettingsForm();
  
  /**
   * Submit settings.
   * @param array $values
   */
  abstract public function submitSettings($values);
  
  /**
   * Callback for login or association.
   * Each provider must implement this action.
   * @param array $query
   */
  abstract public function actionConnect($query);
  
  /**
   * Callback for deauthorization.
   * Each provider must implement this action.
   * @param array $query
   */
  abstract public function actionDeauthorize($query);
}
