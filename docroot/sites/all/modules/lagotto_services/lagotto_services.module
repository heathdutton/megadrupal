<?php
/**
 * @file
 * Drupal interface to the Lagotto service.
 */

// Prefixes that could appear on a DOI.
define('LAGOTTO_SERVICES_DOI_SCHEME', 'doi:');
define('LAGOTTO_SERVICES_DOI_URL', 'http://dx.doi.org/');
define('LAGOTTO_SERVICES_DOI_SSLURL', 'https://dx.doi.org/');

/*
 * Constants defining the structure of the api URI, and the
 * API version numbers used for fetching an article and
 * for modifying article data.
 *
 * Lagotto API v4 is currently the only API option to create,
 * change or delete an article on a remote server (though there
 * are other methods available from the server).
 *
 * Lagotto API v5 provides options for reading information from
 * the server.
 */
define('LAGOTTO_SERVICES_SERVICE_URI', '/api/v%version%/articles');
define('LAGOTTO_SERVICES_API_FETCH', 5);
define('LAGOTTO_SERVICES_API_POST', 4);

define('LAGOTTO_SERVICES_DEFAULT_DOMAIN', 'http://alm.plos.org');
define('LAGOTTO_SERVICES_DEFAULT_KEY', '');

define('LAGOTTO_SERVICES_PERM_CONFIG', 'administer lagotto services');
define('LAGOTTO_SERVICES_PERM_REQUEST', 'make doi requests');

/**
 * API: Return True if current session has permission to add works to server.
 *
 * @return bool
 *   True if current session has permission to add works to server, False
 *   otherwise.
 *
 * @see lagotto_services_fetch_work
 * @see lagotto_services_submit_add_enabled
 * @see lagotto_services_submit_remove_enabled
 */
function lagotto_services_fetch_enabled() {
  return user_access(LAGOTTO_SERVICES_PERM_REQUEST);
}

/**
 * Semi-private function to get the README file for use in module Help.
 *
 * It is intended this function can be used by submodules.
 *
 * Call with:
 *   $output = lagotto_services_admin_get_readme(__FILE__);
 *
 * This code was lifted directly from:
 *   Provide help text in the Drupal UI
 *   <https://www.drupal.org/node/161085#hook_help>
 *
 * @param string $modulefile
 *   The pathname for a file in the same directory as the desired README.
 *
 * @return string
 *   The returned README text, processed using Markdown if available.
 */
function lagotto_services_admin_get_readme($modulefile) {
  $path = dirname($modulefile) . '/README.md';
  $readme = file_get_contents($path);
  if (!isset($readme)) {
    return NULL;
  }
  if (module_exists('markdown')) {
    $filters = module_invoke('markdown', 'filter_info');
    $info = $filters['filter_markdown'];

    if (function_exists($info['process callback'])) {
      $function = $info['process callback'];
      $output = $function($readme, NULL);
    }
    else {
      $output = '<pre>' . $readme . '</pre>';
    }
  }
  else {
    $output = '<pre>' . $readme . '</pre>';
  }

  return $output;
}

/**
 * Implements hook_help().
 */
function lagotto_services_help($path, $arg) {
  switch ($path) {
    case 'admin/help#lagotto_services':
      $output = lagotto_services_admin_get_readme(__FILE__);
      return $output;

    case 'admin/config/services/lagotto_services':
      return '<p>' . t('The Drupal interface to the Lagotto service.') . '</p>';
  }
}

/**
 * Implements hook_permission().
 */
function lagotto_services_permission() {
  return array(
    LAGOTTO_SERVICES_PERM_CONFIG => array(
      'title' => t('Administer Lagotto services'),
      'description' => t('Administer the Lagotto server configuration.'),
    ),
    LAGOTTO_SERVICES_PERM_REQUEST => array(
      'title' => t('Make work requests'),
      'description' => t('Request information about individual works from the Lagotto server.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function lagotto_services_menu() {
  $items = array();
  $items['admin/config/services/lagotto_services'] = array(
    'title' => 'Lagotto Services',
    'description' => 'Provides configuration options for Lagotto services.',
    'access arguments' => array(LAGOTTO_SERVICES_PERM_CONFIG),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('lagotto_services_admin_settings'),
    'file' => 'lagotto_services.admin.inc',
  );
  return $items;
}

/**
 * API: Return the configured Lagotto service host (base URL).
 *
 * @return string
 *   The server base URL as configured by the user, or the default.
 *
 * @see lagotto_services_service_key
 * @see lagotto_services_submit_service_creds
 */
function lagotto_services_service_host() {
  $url = variable_get('lagotto_services_url', LAGOTTO_SERVICES_DEFAULT_DOMAIN);
  return $url;
}

/**
 * API: Return the configured Lagotto service URL.
 *
 * @param int $version
 *   API version number.
 *
 * @return string
 *   The server URL as configured by the user, or the default.
 *
 * @see lagotto_services_service_host
 */
function lagotto_services_service_url($version = LAGOTTO_SERVICES_API_FETCH) {
  // We currently only understand API versions 3,4 and 5.
  $possible_versions = array(3, 4, 5);
  if (!in_array($version, $possible_versions)) {
    $version = LAGOTTO_SERVICES_API_FETCH;
  }

  // Embed the selected API version number in the URI.
  $service_uri = preg_replace('/\%version\%/', $version, LAGOTTO_SERVICES_SERVICE_URI);

  // Fetch the base URL (of the form http://example.org/) for the server.
  $url = variable_get('lagotto_services_url', LAGOTTO_SERVICES_DEFAULT_DOMAIN);

  return $url . $service_uri;
}

/**
 * API: Return the configured Lagotto service API key.
 *
 * @return string
 *   The server key as configured by the user, or the default.
 *
 * @see lagotto_services_service_host
 * @see lagotto_services_service_url
 */
function lagotto_services_service_key() {
  $key = variable_get('lagotto_services_apikey', LAGOTTO_SERVICES_DEFAULT_KEY);
  return $key;
}

/**
 * Make a metrics retrieval URL for a work.
 *
 * Globals: defines define the default base URL and the API key.
 *
 * @param mixed $work_list
 *   The ID that is being enquired about. This can be either a string or an
 *   array of strings. Invalid IDs are ignored, and prefixes (e.g. doi:) are
 *   removed.
 * @param array $options
 *   'include_detail' - TRUE to include timeline info in the metrics.
 *   'service_key' - override the key from lagotto_services_service_key.
 *   'service_url' - override the url from lagotto_services_service_url.
 *                   This should be the full api link, not just the base.
 *   'fetch_api_version' - override the normal api version number (e.g. '5').
 *   'sources' - if present must be an array of names of data sources.
 *   'order_by' - The order of results:
 *                   'date' - use descending date,
 *                   'event' - by descending event count.
 *
 * @return string|null
 *   A URL to be retrieved, or NULL if:
 *   - zero or more than 50 IDs are present after cleaning,
 *   - if the server URL is invalid.
 */
function lagotto_services_make_fetch_url($work_list, $options = array()) {
  $default_options = array(
    'include_detail' => FALSE,
    'service_key' => NULL,
    'service_url' => NULL,
    'sources' => NULL,
    'order_by' => NULL,
    'id_type' => 'doi',
    'fetch_api_version' => LAGOTTO_SERVICES_API_FETCH,
  );
  $options = array_merge($default_options, $options);

  $sources = array();
  $works = array();

  $id_type = $options['id_type'];
  $server_types = array(
    'doi' => 'doi',
    'pmcid' => 'pmcid',
    'pmid' => 'pmid',
  );
  if (array_key_exists($id_type, $server_types)) {
    $query_type = $server_types[$id_type];
  }
  else {
    // Default to DOI because it's easiest to sanity-check.
    $id_type = 'doi';
    $query_type = 'doi';
  }

  // Wrap single ID with array to make remaining logic simpler.
  if (is_string($work_list)) {
    $work_list = array($work_list);
  }

  // Validate the work list.
  if (is_array($work_list)) {
    foreach ($work_list as $id) {
      switch ($id_type) {
        case 'doi':
          $id = lagotto_services_validate_doi($id);
          break;

        case 'pmcid':
          $id = lagotto_services_validate_pmcid($id);
          break;

        case 'pmid':
          $id = lagotto_services_validate_pmid($id);
          break;
      }
      // Calls above return null if the ID is not a valid one.
      if (!empty($id)) {
        $works[] = $id;
      }
    }
  }

  // If none of the IDs was valid, there are more than the server will process,
  // or the original $work_list was neither a string nor an array, return null.
  if (empty($works) || count($works) > 50) {
    return NULL;
  }

  if (!empty($options['sources']) && is_array($options['sources'])) {
    $source_list = array();
    foreach ($source_list as $src) {
      if (is_string($src) && !empty($src)) {
        $sources[] = $src;
      }
    }
  }

  // We allow the url to be overridden, but if so it should be the whole thing.
  if (!empty($options['service_url'])) {
    $url = $options['service_url'];
  }
  else {
    $url = lagotto_services_service_url($options['fetch_api_version']);
  }
  if (!valid_url($url, TRUE)) {
    return NULL;
  }

  $key = lagotto_services_service_key();

  // Translate the flags.
  $info = ($options['include_detail']) ? 'detail' : 'summary';

  // Finally, construct the url.
  $query = array(
    'api_key' => $key,
    'type' => $query_type,
    'ids' => implode(',', $works),
    'info' => $info,
  );

  // Optional 'order' flag.
  if ($options['order_by'] == 'event' && !empty($sources)) {
    $query['order'] = NULL;
  }

  // Optional sources list.
  if (!empty($sources)) {
    $query['sources'] = implode(',', $sources);
  }

  return url($url, array('absolute' => TRUE, 'query' => $query));
}

/**
 * Convert a DOI into the minimal form '10\.\d+/.+'.
 *
 * Check that a DOI is not a URL or URI and appears valid, returning the
 * minimal form if possible or NULL.
 *
 * @param string $doi
 *   The DOI that is being checked.
 *
 * @return bool|mixed
 *   A trimmed $doi if it validates OK, FALSE if not.
 */
function lagotto_services_validate_doi($doi) {
  $doi_cache = lagotto_services_validate_doi_cache($doi);

  return $doi_cache[$doi];
}

/**
 * Check that the supplied PubMedCentral ID looks like one.
 *
 * In particular, it can start with 'PMC' (either case) and must
 * have an integer number following between 3 and 12 digits.
 * 10 digits was chosen because at the time of writing there were
 * no 8 digit IDs.
 *
 * @param string $pmc
 *   The ID to check. e.g. 'Pmc2947', '92743', 'PMC1000246'.
 *
 * @return mixed
 *   FALSE if the value doesn't look like a PMCID, or the ID if it does.
 */
function lagotto_services_validate_pmcid($pmc) {
  if (preg_match('/^(pmc)?[1-9][0-9]{2,9}$/i', $pmc)) {
    return $pmc;
  }
  return FALSE;
}

/**
 * Check that the supplied PubMed ID looks like one.
 *
 * In particular, it must be an integer number with between 3 and 12 digits.
 * 12 digits was chosen because at the time of writing there were no 9 digit
 * IDs.
 *
 * @param string $pm
 *   The ID to check. e.g. 'Pmc2947', '92743', 'PMC29019387'.
 *
 * @return mixed
 *   FALSE if the value doesn't look like a PMCID, or the ID if it does.
 */
function lagotto_services_validate_pmid($pm) {
  if (preg_match('/^[1-9][0-9]{2,11}$/', $pm)) {
    return $pm;
  }
  return FALSE;
}

/**
 * Build a cache of DOI requests.
 *
 * @param string $doi
 *   The DOI that is being checked.
 *
 * @return mixed
 *   An array of DOIs - the request as the key and the validated DOI as the
 *   value.
 */
function lagotto_services_validate_doi_cache($doi) {
  $doi_cache = &drupal_static(__FUNCTION__, array());

  if (!isset($doi_cache[$doi])) {

    /*
     * These regexes match the two forms DOIs are normally encountered in
     * that are not minimal:
     *  - http://dx.doi.org/10.NNNN/AAAAA...
     *  - https://dx.doi.org/10.NNNN/AAAAA...
     *  - doi:10.NNNN/AAAAA
     * where N is a 4 digit number and AAAA is a character string.
     *
     * The replacement pattern renders both down to the minimal form.
     */
    $patterns = array(
      '/^https?:\/\/dx\.doi\.org\/(10\.\d+\/.+)$/',
      '/^doi:(10\.\d+\/.+)$/',
    );

    $clean_doi = preg_replace($patterns, '$1', $doi);

    if (!preg_match('/^10\.\d+\/.+$/', $clean_doi)) {
      $doi_cache[$doi] = FALSE; /* negative cache */
    }
    else {
      $doi_cache[$doi] = $clean_doi;
    }
  }

  return $doi_cache;
}

/**
 * API: Check for existence of a single work.
 *
 * A wrapper function that makes it easier to call than the 'full' fetch.
 * NB: the return value differs from the fetch call.
 *
 * @param string $id
 *   The ID for the article.
 * @param array $options
 *   Keys:
 *   'service_key' - override the key from lagotto_services_service_key
 *   'service_url' - override the url from lagotto_services_service_url
 *   'fetch_api_version' - override the normal api (e.g. '5').
 *   'sources' - if present, an array of source names to filter the results.
 *   Note that include_detail and quiet keys are overriden.
 *
 * @return array|null
 *   The decoded JSON data for the work if the if exists, NULL otherwise.
 */
function lagotto_services_work_exists($id, $options = array()) {
  $override_options = array(
    'include_detail' => FALSE,
    'quiet' => TRUE,
  );
  $options = array_merge($options, $override_options);

  $lookup = lagotto_services_fetch_work($id, $options);
  $record = lagotto_services_record($lookup, 0);
  if (!empty($record['error'])) {
    return NULL;
  }
  else {
    return $record;
  }
}

/**
 * API: Do an article lookup request using the Lagotto v5 api.
 *
 * To find a record on the Lagotto server using the ID, returning the details
 *
 * @param mixed $work_list
 *   The ID for the article, or an array of them. ID are validated and
 *   invalid entries are ignored.
 * @param array $options
 *   Keys:
 *   'include_detail' - TRUE to include timeline info in the metrics.
 *   'service_key' - override the key from lagotto_services_service_key
 *   'service_url' - override the url from lagotto_services_service_url
 *   'fetch_api_version' - override the normal api (e.g. '5').
 *   'quiet' -  Don't log failed lookups.
 *   'sources' - if present, an array of source names to filter the results.
 *   'order_by' - The order of results:
 *     'date' - use descending date,
 *     'event' - by descending event count.
 *
 * @return object|NULL
 *   The response object from drupal_http_request()
 *   NULL if access denied or there were no valid IDs passed in.
 *   A constructed object with 'code' 500 if the service URL is invalid.
 *
 * @see lagotto_services_make_fetch_url
 * @see lagotto_services_submit_add
 */
function lagotto_services_fetch_work($work_list, $options = array()) {
  $default_options = array(
    'include_detail' => FALSE,
    'quiet' => FALSE,
    'service_key' => NULL,
    'service_url' => NULL,
    'sources' => NULL,
    'order_by' => NULL,
    'id_type' => 'doi',
  );
  $options = array_merge($default_options, $options);

  // Unlike the add & delete options, fetch doesn't change server state so
  // there's no need for a dediacated disable option.
  $enabled = lagotto_services_fetch_enabled();
  if (!$enabled) {
    watchdog('lagotto_services',
      'Fetch request failed: permission denied',
      WATCHDOG_WARNING);
    return NULL;
  }

  $http_request = array(
    'headers' => array(
      'Accept' => 'application/json',
    ),
    'method' => 'GET',
  );

  // Make a request URL and do it.
  $url = lagotto_services_make_fetch_url($work_list, $options);
  if (!empty($url)) {
    $response = drupal_http_request($url, $http_request);
  }
  else {
    watchdog('lagotto_services',
      'Fetch request failed: URL could not be constructed.',
      WATCHDOG_ERROR);
    $response = new stdClass();
    $response->code = 500;
    $response->options = $options;
    $response->status_message = 'Invalid service URL supplied';
  }

  // Evaluate request response.
  if (!$options['quiet'] && (empty($response) || $response->code != 200)) {
    watchdog('lagotto_services',
      'Fetch request [%req] failed code [%code] with message [%msg]',
      array(
        '%req' => $url,
        '%code' => $response->code,
        '%msg' => $response->status_message,
      ),
      WATCHDOG_WARNING);
  }

  return $response;
}

/**
 * API: Return an array of records from a server response.
 *
 * Use this to easily access the server response data from the return value
 * of fetch or add work calls. You either get an empty array or an array of
 * the returned articles.
 *
 * @param object $reply
 *   The response object as returned from lagotto_services_fetch() et al.
 * @param int $success
 *   The expected successful return code; set to 0 to disable checking for
 *   return codes, or to e.g. 201 or 202 for alternate codes.
 *
 * @return array
 *   The returned data as an indexed array of arrays.
 *     'result' is the returned 'data' record from the server.
 *     'error' values:
 *       0 = success
 *       1000..1000+JSON_ERROR_UNSUPPORTED_TYPE = json decode error
 *       2000 = No result from HTTP request, e.g. timeout
 *       3000 = HTTP request returned empty JSON.
 *     'message' is a string describing the error.
 */
function lagotto_services_records($reply, $success = 200) {
  // Reset json_last_error so caller can rely on it.
  $records = array();
  if (empty($reply)) {
    $records['error'] = 2000;
    $records['message'] = t('API Request returned NULL');
  }
  elseif (empty($reply->data)) {
    $records['error'] = 2000;
    if (empty($reply->error)) {
      $records['message'] = t('API Request returned no data: unknown error');
    }
    else {
      $records['message'] = t('API Request returned no data: @info',
        array('@info' => $reply->error));
    }
  }
  elseif ($success != 0 && $success != $reply->code) {
    $records['error'] = 1000 + $reply->code;
    $records['message'] = t('HTTP request was not successful: @info',
      array('@info' => $reply->error));
  }
  else {
    $json = drupal_json_decode($reply->data);
    $err = json_last_error();
    if ($err === JSON_ERROR_NONE) {
      if (!empty($json) && !empty($json['data'])) {
        $records['result'] = $json['data'];
        $records['error'] = 0;
        $records['message'] = t('OK');
      }
      else {
        $records['error'] = 3000;
        $records['message'] = t('API Request returned empty result');
      }
    }
    else {
      $records['error'] = json_last_error();
      $records['message'] = json_last_error_msg();
    }
  }
  return $records;
}

/**
 * API: Return a record from a server response.
 *
 * Use this to easily access the server response data from the return value
 * of fetch or add calls. You either get an empty array or an array of
 * the returned articles.
 *
 * @param object $reply
 *   The response object as returned from lagotto_services_fetch_work() et al.
 * @param int $recno
 *   The record number of the required record.
 * @param int $success
 *   The expected successful return code; set to 0 to disable checking for
 *   return codes, or to e.g. 201 or 202 for alternate codes.
 *
 * @return array|null
 *   The returned record as an array, if all well, else an array describing
 *   the error. Use:
 *     (!empty($record['error']) && ($record['error'] > 0))
 *   as the error condition.
 *
 * @see lagotto_services_records()
 */
function lagotto_services_record($reply, $recno = 0, $success = 200) {
  $records = lagotto_services_records($reply, $success);
  if (!empty($records['result'])) {
    return $records['result'][$recno];
  }
  return $records;
}

/**
 * API: Return a php date value from the issue date in a return record.
 *
 * @param array $record
 *   The record for one entry.
 *
 * @return int
 *   The result of strtotime() on the first 'issued' date entry in the record.
 */
function lagotto_services_issue_date(array $record) {
  if (empty($record['issued'])) {
    return NULL;
  }

  // Compatibility fix for old ALM software: date-parts not date_parts[0].
  if (!empty($record['issued']['date_parts'])) {
    $d = $record['issued']['date_parts'];
  }
  elseif (!empty($record['issued']['date-parts'])) {
    $d = $record['issued']['date-parts'][0];
  }
  else {
    return NULL;
  }

  if (!empty($d) && count($d) == 3) {
    return strtotime($d[0] . '-' . $d[1] . '-' . $d[2]);
  }
  else {
    return NULL;
  }
}
