<?php

// REPLACE THESE HARD CODED VARIABLES
define("MNN_59TH_FACILITIES_INVENTORY_TID", 804);
define("MNN_FIREHOUSE_FACILITIES_INVENTORY_TID", 1043);
define("MNN_CM_INVENTORY_TID", 800);

define("MNN_FIREHOUSE_2ND_FLOOR_EXPRESS_STUDIO_NID", 306113);
define("MNN_FIREHOUSE_2ND_FLOOR_MINI_EXPRESS_STUDIO_NID", 306114);
define("MNN_FIREHOUSE_GEORGE_STONEY_NID", 306112);
define("MNN_FIREHOUSE_JULIA_DE_BURGOS_SMALL_STUDIO_NID", 306114);
define("MNN_FIREHOUSE_ZAPATA_EXPRESS_NID", 306113);
define("MNN_59TH_STU001_OPEN_STUDIO_NID", 374849);
define("MNN_59TH_STU002_CLOSED_STUDIO_NID", 374850);
define("MNN_59TH_STU003_STUDIO_EXPRESS_NID", 374871);
define("MNN_59TH_STU004_STUDIO_MINI_EXPRESS_NID", 374872);
define("MNN_CM_DCTV_STUDIO_NID", 374848);
// END REPLACE

define("RESERVATIONS_DAILY_CHART_PATH","admin/reservations/manage/chart");
define("RESERVATIONS_DAILY_CHART_VIEW", "reservations_daily_chart");
define("RESERVATIONS_DAILY_CHART_VIEW_DISPLAY", "chart_page");
define("RESERVATIONS_DAILY_CHART_START", 9);
define("RESERVATIONS_DAILY_CHART_END", 24);
define("RESERVATIONS_DAILY_CHART_RAW", "admin/reservations/manage/chart/raw");

/**
 * Implements hook_init().
 */
function reservations_daily_chart_init() {
  drupal_add_css(drupal_get_path('module', 'reservations_daily_chart') . 
		 '/reservations_daily_chart.css');
}

/**
 * Implements hook_menu().
 */
function reservations_daily_chart_menu() {
  $items = array();
  
  //THE MAIN MENU ITEM FOR THE CHART THAT HAS A CALL BACK FUNCTION THAT 
  //BUILDS THE CHART ITSELF
  $items[RESERVATIONS_DAILY_CHART_PATH] = 
    array(
	  'title' => t("Daily Resource Chart"),
	  'page callback'    => 'reservations_daily_chart_display',    
	  'access arguments' => array('manage reservations'),
  );

  //ADD MENU ITEMS THAT WILL SHOW UP IN THE RESERVATONS OVERLAY
  $vid = variable_get('reservations_inventory_vid', 0);
  $terms = taxonomy_get_tree($vid);
  $inventories = array();
  foreach ($terms as $term) {
    $items['admin/reservations/' . $term->tid . '/daily-reservation-chart'] = 
      array(
	    'title' => t('Daily Resource Chart for @term_name', 
			 array('@term_name'=>$term->name)),
	    'page callback' => 'reservations_daily_chart_page_redirect',
	    'page arguments' => array(2),
	    'access arguments' => array('manage reservations'),
	    'type' => MENU_NORMAL_ITEM,
	    'weight' => 1000,
	    );
  }
  
  return $items;
}

/**
 * Implements hook_node_info().
 */
function reservations_daily_chart_node_info() {
  return array(
    // Project nodes.
    'cm_project' => array(
      'name' => t('Daily Chart'),
      'base' => 'reservations_daily_chart',
      'description' => t('<b>Reservations</b> - This content type is used to group Reservations in a Chart display.'),
      'has_title' => TRUE,
      'title_label' => 'Title',
      'has_body' => TRUE,
    ),
  );
}

/**
 * Implement hook_form() with the standard default form.
 */
function reservations_daily_chart_form($node, $form_state) {
  return node_content_form($node, $form_state);
}

/**
 * Called by reservations_daily_chart_menu()
 *  This function will use the reservations_daily_chart view to offer an
 * exposed date filter and then display the results in a custom chart where
 * each column is a 30 minute time block and each row is a particular
 * researvable item. 
 * @returns $ret - html for the hook_menu page we are describing
 */
function reservations_daily_chart_display($arg_string = NULL, 
  $is_pdf = FALSE ) {

  //fetch our view
  $view = views_get_view(RESERVATIONS_DAILY_CHART_VIEW);
  
  //DEAL WITH INVENTORY ARGUMENT
  $args = reservations_daily_chart_special_args($arg_string);
  if (count($args['inventories']) > 0) {
    $view->set_arguments($args['inventories']);
    if (count($args['inventories']) == 1) {
      $multiple_inventories = FALSE;
      $inventory_tid = $args['inventories'][0];
    }
    else {
      $multiple_inventories = TRUE;
      $inventory_tid = NULL;
    }
  }

  //build our veiw query then execute it.
  $view->build(RESERVATIONS_DAILY_CHART_VIEW_DISPLAY);  

  //fetch the inventory if its the default
  if (!$inventory_tid && !$multiple_inventories) {
    $args['inventories'] = array($view->args[0]);
    $inventory_tid  = $view->args[0];
  }

  //execute the query and grab the results
  $view->execute(RESERVATIONS_DAILY_CHART_VIEW_DISPLAY);
  $results = $view->result;

  //TIMES, THIS WILL SET ALL THE RELEVANT TIME VARIABLES
  reservations_daily_chart_fill_times($view, 
					 $start_date, 
					 $start_timestamp,
					 $end_timestamp, 
					 $pdf_title_date);

  
  //ITEM RESERVATIONS
  $reservation_items =
    reservations_daily_chart_get_item_reservations($results);
  
  //BUCKET CATEGORIES
  $vid = variable_get('reservations_grouping_vid', 0);
  $terms = taxonomy_get_tree($vid);
  $bucket_categories = array();
  foreach ($terms as $term) {
    $bucket_categories[$term->tid] = array(); 
  }

  //RESERVABLE CONTENT TYPES
  // Loop through each reserable type, placing it into the bucket categories
  // array along with any reservations attached to it.
  $reservable_types = reservations_content_types();
  $reservable_types = array_reverse($reservable_types);

  $has_items_to_display = FALSE;
  foreach ($reservable_types as $bucket_content_type=>$reservable_type) {
    if (reservations_daily_chart_inventory_check($reservable_type
						    ['inventory_tids'],
						    $args['inventories'])){

      $grouping_tid = $reservable_type['reservations_grouping'];
      $items = reservations_daily_chart_get_items_for_type
        ($reservation_items, $bucket_content_type, $args['item_ids']);
      if (count($items)) {
	$has_items_to_display = TRUE;
      }

      $bucket_categories[$grouping_tid][$bucket_content_type] = $items;
      
    }
  }

  if (!$has_items_to_display) {
    return reservations_daily_chart_get_no_resources_msg($inventory_tid,
							    $args['title']);
  }


  //HTML TABLE DISPLAYING THE CART
  $chart = reservations_daily_chart_get_chart_html($bucket_categories, 
     						      $start_date,
    						      $start_timestamp, 
    						      $end_timestamp,
						      $is_pdf);

  //get header html for page
  $header = reservations_daily_chart_get_page_header($inventory_tid,
							$start_timestamp,
							$args['title']);

  //our return variable
  $ret = "";
  $ret .= $header;
  $ret .= reservations_daily_chart_widgets($view, $args,$exposed_widgets);
  $ret .= $chart;

  return $ret;
  
}

function reservations_daily_chart_inventory_check($type_inventory_tids,
						     $arg_inventory_tids){
  foreach($type_inventory_tids as $tid) {
    if(in_array($tid, $arg_inventory_tids)){
      return TRUE;
    }
  }
  return FALSE;
}

function reservations_daily_chart_get_chart_html($bucket_categories, 
						    $start_date,
						    $start_timestamp, 
						    $end_timestamp,
						    $is_pdf) {
  $header_start = RESERVATIONS_DAILY_CHART_START;
  $header_end = RESERVATIONS_DAILY_CHART_END;
  
  $row_end_timestamp = 
    reservations_daily_chart_get_timestamp($start_date,
					      $header_end);
  $row_start_timestamp = 
    reservations_daily_chart_get_timestamp($start_date,
					      $header_start);

  foreach($bucket_categories as $bucket_tid => $buckets) {
    foreach ($buckets as $bucket_name => $bucket_items) {
      foreach ($bucket_items as $bucket_item) {
	$block_start_timestamp = $row_start_timestamp;	
	
	$item_nid = $bucket_item->nid;
	$item_title = isset($bucket_item->code) ? 
	  $bucket_item->code : $bucket_item->title;
  $item_title = l($item_title, 'node/' . $item_nid);
  
	$reservations = (isset($bucket_item->reservations) && 
			 is_array($bucket_item->reservations)) ? 
			 $bucket_item->reservations : array();

	$has_reservations = false;
        $reservation_start_blocks = array();
	foreach ($reservations as $item_reservation) {
	  if ($item_reservation->check_out_time) {
            $check_out_time = strtotime($item_reservation->check_out_time);
          }
          else {
            $check_out_time = null;
          }
          if ($item_reservation->check_in_time) {
            $check_in_time = strtotime($item_reservation->check_in_time);
          }
          else {
            $check_in_time = null;
          }

	  //dsm(date('m/d h:ia',$check_out_time), "checkout");
	  //dsm(date('m/d h:ia',$check_in_time), "checkin");
	  //dsm(date('m/d h:ia',$block_start_timestamp), "block start");
	  //dsm(date('m/d h:ia',$row_end_timestamp), "row end");

	  //IF THE CHECKOUT TIME IS LATER THAN THE RESERVE END TIME WE HAVE
	  //ISSUES
	  if($check_out_time &&
	     $check_out_time >=strtotime($item_reservation->reserve_end_time)){

            $item = node_load($item_reservation->item_id);
            $future_checkout_time_error = 
	          "The reservation ".
              l($item_reservation->reservation_id.
	      	" ($item_reservation->name) ",
	      		'node/'.
	      	$item_reservation->reservation_id).
              " for ".l($item->title, "node/$item->nid").
                " cannot be displayed because its check out time,  " .
	      $item_reservation->check_out_time.
                " is later than its intended check in time, ".
	      $item_reservation->reserve_end_time.
	      ".<br/>";
	    continue;
          }
	  
	  //PUT RESERVATIONS INTO THEIR TIME BLOCKS
	  $has_reservations = true;

          //figure out what time to use for the start of the res block
          //it will either be the reserve_start_time or the check_in_time
          if ($check_out_time &&
              (!$check_in_time ||
	       $check_out_time < $check_in_time )) {
            $index = $check_out_time;
            $minutes = date('i', $index);
            if ($minutes != 0 AND $minutes != 30 ) {
              if ($minutes < 30) {
                $index = mktime(date('H', $index), 0, 0,
				date('m', $index),date('d', $index),
				date('Y', $index));
              }
              else  {
                $index = mktime(date('H', $index), 30, 0,
				date('m', $index),date('d', $index),
				date('Y', $index));
              }
            }
            else {
              $index = mktime(date('H', $index), date('i', $index), 0,
			      date('m', $index),date('d', $index),
			      date('Y', $index));
            }
          }
	  else {
            $index = strtotime($item_reservation->reserve_start_time);
          }

	  $item_reservation->res_block_start_time = $index;
          if ( $index < $block_start_timestamp ) {
            $index = $block_start_timestamp;
          }
	  //dsm(date('r', $item_reservation->res_block_start_time));
          //figure out what time to use for the end of the res block
          //it will either be the reserve_start_time or the check_in_time
          if ($check_in_time &&
              $check_out_time < $check_in_time ) {
            $minutes = date('i', $check_in_time);
            if ($minutes != 0 AND $minutes != 30 ) {
              if ($minutes < 30) {
                $check_in_time = mktime(date('H', $check_in_time), 30, 0,
					date('m', $check_in_time),
					date('d', $check_in_time),
					date('Y', $check_in_time));
              }
	      else  {
		$check_in_time = mktime(date('H', $check_in_time), 0, 0,
					date('m', $check_in_time),
					date('d', $check_in_time),
					date('Y', $check_in_time)) + 60*60;
	      }
	    }
	    else {
		$check_in_time = mktime(date('H', $check_in_time), 
					date('i', $check_in_time), 0,
					date('m', $check_in_time),
					date('d', $check_in_time),
					date('Y', $check_in_time));
	    }
	    if ( $check_in_time > $row_end_timestamp ) {
	      $check_in_time = $row_end_timestamp;
	    }
	    $item_reservation->res_block_end_time = $check_in_time;
	  }
	  else {
            $item_reservation->res_block_end_time = 
	      strtotime($item_reservation->reserve_end_time);

            if ( $item_reservation->res_block_end_time > $row_end_timestamp ) {
              $item_reservation->res_block_end_time = $row_end_timestamp;
            }
          }
	  //Put the reservations in the arrays, one for checking on reservation
          //overlaps, one for displaying on the grid
          $reservation_start_blocks[$index][$item_reservation->reservation_id]
	    = $item_reservation;
          $tmp_time = strtotime($item_reservation->reserve_start_time);
          $original_reserve_times[$tmp_time][$item_reservation->reservation_id]
            = $item_reservation;
	  //dsm($item_reservation, "reservation");

	}//end of loop processing reservations for an item
	//all reservations should be in $reservation_start_blocks and 
	//$original_reserve_times
	if ($has_reservations) {
	  //dsm($original_reserve_times, 'reserve times');
	  //dsm($reservation_start_blocks, 'start blocks');
	}
	
	$overlap_errors =
	  reservations_daily_chart_overlap_check($original_reserve_times,
						    $reservation_start_blocks);
	if ($has_reservations) {
	  //dsm($reservation_start_blocks, 'possibly modified start blocks');
	}
	if ($wrong_day_error) {
	  $errors .= $wrong_day_error;
          $wrong_day_error = null;
	}
        if ($future_checkout_time_error) {
          $errors .= $future_checkout_time_error;
          $future_checkout_time_error = null;
	}
        if ($overlap_errors) {
          $errors .= $overlap_errors;
          $overlap_errors = null;
        }
        if ($reversed_check_in_error) {
          $errors .= $reversed_check_in_error;
	  $reversed_check_in_error = null;
        }
	//dsm($errors);
	$label = $is_pdf ? "            " : $label = "-*-"; 
	$row_values = array();
	$row_values[] = array('data' => $item_title,);

	if (!$has_reservations) {
          for ($block_end_timestamp = $block_start_timestamp + 60*30;
	       $block_end_timestamp <= $row_end_timestamp;
	       $block_end_timestamp += 60*30) {
	    // fix for #3679 - removed timezone so we aren't double shifting that in the link title
            //$url_timestamp = $block_end_timestamp-60*30 - date('Z', $block_end_timestamp);
	          $url_timestamp = $block_end_timestamp-60*30;
            if ( !$is_pdf ) { 
              $title = date('g:ia', $url_timestamp) . " ".$bucket_item->title;
	      $url = 
		"node/add/reservations-reservation";
	      $url .= '?start_time='.$url_timestamp.'&item_nid='.$item_nid; 
              $data  = 
		"<a title=\"$title\" class=\"facilities-grid\" href='/".
		$url."'>";
              $data .= "$label</a> ";
            }
            else {
              $data  = $label;
            }
            $row_values[] = array('data'=>$data);
          }
	  
        }
	
	//THIS ROW HAS RESERVATIONS SO WE WILL PLACE THE RESERVATIONS 
	if ($has_reservations) {
	  //dsm($reservation_start_blocks, 'start blocks');
	  $counter_test = 0;
          for ($block_end_timestamp = $block_start_timestamp + 60*30;
	       ($block_end_timestamp <= $row_end_timestamp);
	       $block_end_timestamp += 60*30) {
	    
	    if ($counter_test == 50) {
	      drupal_set_message("Infinite Loop Error #787438");
	      break;
	    }
	    $counter_test++;
	    //dsm(date("m/d g:ia",$block_start_timestamp), 'block start');
	    //dsm(date("m/d g:ia",$block_end_timestamp), 'block end');
            if (array_key_exists($block_start_timestamp,
				 $reservation_start_blocks)) {
	      //dsm("i am in");
              $data='';

              $item_reservation=
		$reservation_start_blocks[$block_start_timestamp];

              $reservation_id = $item_reservation->reservation_id;
	      $reserve_end_timestamp = $item_reservation->res_block_end_time;

              $col_span=($reserve_end_timestamp-$block_start_timestamp)/
		(30*60);

              $reservation_name=$item_reservation->name;
              if ( $is_pdf ) {
                $reservation_name = strtolower($reservation_name);
              }

              $text = "<span class = 'reservations_internal_grid'>";

              $display_class = NULL;
              if ($item_reservation->check_in_time) {
                $display_class = 'reservations_checked_in';
              }
              else if ($item_reservation->check_out_time) {
                $display_class = 'reservations_checked_out';
              }
              else {
                $display_class = 'reservations_ready';
              }

              $user_suspensions = 
		reservations_daily_chart_check_user_for_suspension
		($item_reservation->uid);

	      if ( count($user_suspensions) ) {
                $title = "SUSPENDED: $reservation_name $bucket_item->title";
                $text .= "<span class='$display_class'>".
                  "<a title=\"$title\"class=\"facility-chart-username\" href=\"".
                  '/node/'.$reservation_id.
		  '/edit"><span class="suspended-user">'.$reservation_name.
		  " (s)</span></a></span>";
                $text .= "</span>";
                if ( $is_pdf ) {
                  $text = "<strong>$reservation_name</strong>";
                }
              }
              else {
                $title = date('g:ia',$block_start_timestamp).
		  " $reservation_name $bucket_item->title";

                $text .= "<span class='$display_class'>".
                  "<a title=\"$title\" class=\"facility-chart-username\" href=\"".
                  '/node/'.$reservation_id.'/edit">'.$reservation_name.
		  '</a></span>';
                $text .= "</span>";
                if ( $is_pdf ) {
                  $text = "<strong>$reservation_name</strong>";
                }
              }
	      $cell_classes = array('facility-chart-username');
              if ( $display_class ) {
                $cell_classes[] = $display_class;
              }
              $row_values[]  = array('data'=>$text,
                                     'colspan'=>$col_span,
                                     'align'=>'center',
                                     'class' => 'facility-chart-username '.
				     $display_class,
                                     );
	      $block_start_timestamp = $reserve_end_timestamp;	      
              $block_end_timestamp=$reserve_end_timestamp;
	      //dsm("setting next start=".
	      //  date('m/d g:ia',$block_start_timestamp));
	      //dsm("setting next end=".
	      //  date('m/d g:ia',$block_end_timestamp));


	    }
	    else {
	      //$url_timestamp=$block_start_timestamp - 
	      //  date('Z', $block_end_timestamp);
	      $url_timestamp=$block_start_timestamp;
	      //dsm(date('g:ia', $url_timestamp));
              if ( !$is_pdf ) {
                $title = date('g:ia', $url_timestamp) . " " . 
		  $bucket_item->title;
		$url = 
		 "/node/add/reservations-reservation";
		$url .= '?start_time='.$url_timestamp.'&item_nid='.$item_nid; 
                $data  = 
		  "<a title='$title' href='$url'".
		  ' class="facilities-grid" '.">";
                $data .= "$label</a> ";
              }
              else {
                $data  = $label;
              }
	      //dsm("setting here2=".date('h/m g:ia',$block_end_timestamp));
	      $block_start_timestamp = $block_end_timestamp;
	      $row_values[] = array('data'=>$data);
	      //dsm($row_values);
	    }


	  }
	}//finshed building row 
	$rows[] = $row_values;	    
      }//end of bucket items
    }//end of buckets
  }// end of bucket terms

  //dsm($rows, "rows");
  

  $headers = reservations_daily_chart_get_headers();
  $attributes = array(
		      'border'      => 1,
		      'cellspacing' => 0,
		      'cellpadding' => 0,
		      'class'       => array('facility-daily-chart')
		      );
  // including 'class'       => 'facility-daily-chart' and sticky 
  // causes error
  $table = theme_table(array('header'=>$headers,
			     'rows'=>$rows,
			     'attributes'=>$attributes, 'sticky' => TRUE));


  if ( $is_pdf ) {
    $output2 = '<h4>Facilities Chart  '.$pdf_title_date.'</h4>';
    $output2 .= $table;
    //TODO IMPLEMENT THIS
    //reservations_chart_pdfbuild($output2, $pdf_title_date);
  }


  return $table;
}

function reservations_daily_chart_check_user_for_suspension($uid){
  //TODO IMPLEMENT ME!
  return array();
}


function reservations_daily_chart_get_timestamp($date_string,
						   $hour = 0,
						   $minute = 0,
						   $second = 0) {
  $timestamp = strtotime($date_string);
  $ret_stamp = mktime($hour, $minute, $second,
		      date('n', $timestamp),
		      date('j', $timestamp),
		      date('Y', $timestamp));
 
  return $ret_stamp;
}

function reservations_daily_chart_get_headers() {
  $headers = array();

  $header_start = RESERVATIONS_DAILY_CHART_START;
  $header_end = RESERVATIONS_DAILY_CHART_END;

  $column_count = (($header_end - $header_start) * 2) + 1;

  $data = t("ITEM");
  $headers[] = array('data' => $data);

  for ($i = $header_start; $i < $header_end; $i++) {
    $hour = ($i<=12) ? $i : $i-12;
     
    $data = $hour.":00";
    $headers[] = array('data' => $data);

    $data = $hour.":30";
    $headers[] = array('data' => $data);
  }

  return $headers;
}

function reservations_daily_chart_fill_times(&$view, 
						 &$start_date, 
						 &$start_timestamp,
						 &$end_timestamp, 
						 &$pdf_title_date){
  if(isset($view->exposed_raw_input) && 
     isset($view->exposed_raw_input['field_reservations_date_value']) &&
    isset($view->exposed_raw_input['field_reservations_date_value']['value'])){
    $start_date = 
      $view->exposed_raw_input['field_reservations_date_value']['value'];
    $start_timestamp = strtotime($start_date);
  }
  else {
    $start_date = date('Y-m-d'); 
    $start_timestamp = strtotime($start_date);
  }
  //this is a daily view so end time is always 24 hours from starttime
  $end_timestamp = $start_timestamp + 24*60*60;
  // We need this to throw at the top of the pdf
  $pdf_title_date = $start_date;
}

function reservations_daily_chart_get_item_reservations(&$results) {
  //iterate over results, store in array
  foreach($results as $k=>$result) {
    $data = $result->_field_data['nid']['entity'];

    $status = $data->reservations_reservation_status;      
    //THESE SHOULD BE FILTERED OUT BY THE VIEW, BUT KEEPING HERE JUST IN CASE
    if ($status == RESERVATIONS_STATUS_UNCONFIRMED ||
	$status == RESERVATIONS_STATUS_CANCELLED ||
	$status == RESERVATIONS_STATUS_DENIED ||
	$status == RESERVATIONS_STATUS_NO_SHOW) {
      continue;
    }

    foreach ($data->reservations_reservation_items as $did=>$item_result) {
      $item_reservation = new stdClass();

      $reserve_start_time = $data->field_reservations_date['und'][0]['value'];

      $reserve_end_time = $data->field_reservations_date['und'][0]['value2'];
      $reserve_end_time = 
	reservations_daily_chart_end_time_shift($reserve_end_time);

      $timestamp = strtotime($reserve_start_time);
      $offset = date('Z', $timestamp);

      $reserve_start_time = date('Y-m-d H:i:s', 
				 (strtotime($reserve_start_time) + $offset));
      
      $timestamp = strtotime($reserve_end_time);
      $reserve_end_time = date('Y-m-d H:i:s',
                                 (strtotime($reserve_end_time) + $offset));

      if ($status == RESERVATIONS_STATUS_PENDING) {
	$check_out_time = $check_in_time = NULL;
      }
      else if ($status == RESERVATIONS_STATUS_CHECKED_OUT) {
	$check_out_time = $reserve_start_time;
	$check_in_time = NULL;
      }
      else  if ($status == RESERVATIONS_STATUS_CHECKED_IN) {
	$check_out_time = $reserve_start_time;
	$check_in_time = $reserve_end_time;
      }
           
      $item_reservation->check_out_time = $check_out_time;
      $item_reservation->check_in_time = $check_in_time;
      $item_reservation->item_id = $item_result['reservations_item_nid'];
      $item_reservation->name = $data->name;
      $item_reservation->reservation_id = $data->nid;
      $item_reservation->reserve_start_time = $reserve_start_time;
      $item_reservation->reserve_end_time = $reserve_end_time;

      $reservation_items[$item_result['reservations_item_nid']][] = 
	$item_reservation;
      
    }
  }
  return $reservation_items;
}

function reservations_daily_chart_get_no_resources_msg($inventory_tid,
							  $title) {
  $ret = "";
  if (!isset($title) || !$title) {
    $term = taxonomy_term_load($inventory_tid);
    $title = $term->name;
  }
  $ret .= "<h2>".t("No resources to display for @title",
		   array('@title' =>$title))."</h2>";
  $ret .= t("A resource is a type of reservable item that is reserved 
            specifically, generally something like a studio or a facility.");

  return $ret;
}

function reservations_daily_chart_get_page_header($inventory_tid,
						     $time,
						     $title) {
  $ret = "";
  if (!isset($title) || !$title) {
    $term = taxonomy_term_load($inventory_tid);
    $title = $term->name;
  }
  
  $ret .= "<h2>".t("Daily Resource Chart for @title", array('@title'=>$title)).
    "</h2>";
  $ret .= "<h2>".date("Y-m-d", $time)."</h2>";

  
  return $ret;

}

function reservations_daily_chart_get_items_for_type(&$reservation_items,
							$bucket_content_type,
							$item_ids) {
  $ret = array();
  $sql = "
    SELECT n.nid, n.type, n.title , c.field_facility_code_value as code,
      i.reservations_default_availability
    FROM  node n
    LEFT JOIN reservations_reservation_detail d
      ON n.nid = d.reservations_item_nid 
    INNER JOIN reservations_node_type nt
      ON n.type = nt.type 
    LEFT JOIN reservations_reservation_item_node i    
      ON n.vid = i.vid 
    LEFT JOIN field_revision_field_facility_code c
      ON c.revision_id=i.vid
    WHERE    (( (nt.reservations_type_setting IN  ('resource')) 
    AND       (i.reservations_sub_type IN  ('1'))     )
    AND (n.type='$bucket_content_type') 
    AND i.reservations_default_availability=1 ";

  if (isset($item_ids) && is_array($item_ids) && count($item_ids)) {
    $is_first = TRUE;
    $sql .= "AND (";
    foreach($item_ids as $id) {
      if ($is_first) {
	$is_first = FALSE;
      }
      else {
	$sql .= " OR ";
      }
      $sql .= " n.nid=$id ";
    }
    $sql .= " ) ";
  }

  $sql .= 
    ") GROUP BY n.nid, n.type, n.title
      ORDER BY n.title desc
    ";
  $results = db_query($sql);

  while ($result = $results->fetchObject()) {
    $item = new stdClass();
    $item->title = $result->title;
    $item->nid = $result->nid;
    $item->type = $bucket_content_type;
    $item->code = $result->code;
    if (isset($reservation_items[$result->nid])) {
      $item->reservations = $reservation_items[$result->nid];
    }
    $item->status = $result->reservations_default_availability;
    $ret[] = $item;
  } 
  return $ret;

}

function reservations_daily_chart_overlap_check(&$original_reserve_times,
						   &$reservation_start_blocks  ) {

  $overlaps = array();
  $error_message = NULL;
  if ( is_array($reservation_start_blocks) &&
       ! empty($reservation_start_blocks) )
    {
      $prev_reservation = null;
      foreach ( $original_reserve_times as $index => $reservations) {
	foreach ($reservations as $reservation_id => $reservation) {
	  if ( $prev_reservation && ($reservation->reserve_start_time <
				     $prev_reservation->reserve_end_time) &&
	       !$prev_reservation->check_in_time ) {
	    $overlaps[] = array($prev_reservation, $reservation);
	  }
	}
	$prev_reservation = $reservation;
      }
      $original_reserve_times = null;
      reset($reservation_start_blocks);
      $prev_reservation = null;
      $nudged_reservations = null;
      $altered_reservation_start_blocks = array();
      $counter = 0;
      $block_keys = array_keys($reservation_start_blocks);
      asort($block_keys);
      $first_time = true;

      while ($first_time ||
	     ($nudged_reservations && (count($nudged_reservations) > 0)) ||
	     ($reservations && (count($reservations) > 0))) {
	$first_time = false;
	$start_time = array_shift($block_keys);
	$reservations = $reservation_start_blocks[$start_time];


	/***************************************
$counter++; var_dump("Main for loop counter ".$counter);
var_dump("altered block");
foreach($altered_reservation_start_blocks as $k1 => $v1) {
    var_dump("res id: ".$v1->reservation_id." start: ".date('r', $k1).
    "end: ".date('r', $v1->res_block_end_time));
}
//***************************************/
	$res_keys = array();
	if ($reservations) {
	  $res_keys = array_keys($reservations);
	}

	//nudged reservations are ones that we will try to put into the next
	//timeblock
	if ($nudged_reservations) {
	  if ($res_keys) {
	    $res_keys = array_merge(array_keys($nudged_reservations), $res_keys);
	  }
	  else {
	    $res_keys = array_keys($nudged_reservations);
	  }
	  foreach($nudged_reservations as $reservation_id => $reservation) {
	    $reservations[$reservation_id] = $reservation;
	  }
	}

	/***************************************
var_dump("res keys");
var_dump($res_keys);
var_dump("nudge keys");
var_dump(array_keys($nudged_reservations));
var_dump("start time: ".date('r', $start_time ));
//***************************************/

	$nudged_reservations = array();
	$nudge_remaining_reservations = false;
	foreach ($res_keys as $k=> $reservation_id) {
	  $reservation = $reservations[$reservation_id];
	  /***************************************
var_dump("**************Reservation ID: ".$reservation_id." Start Time: ".date('r', $reservation->res_block_start_time)
  ." End Time: ".date('r', $reservation->res_block_end_time). " Item Res ID $reservation->item_reservation_id");
  //**************************************/

	  //if this boolean has been set to true, it means we need to move
	  //all of the rest of the reservations that were entered into the
	  //$reservation_start_blocks array at $start_time to the next
	  //$start_time
	  if ( $nudge_remaining_reservations) {
	    if ( $reservation->res_block_start_time ==
		 $prev_reservation->res_block_start_time) {
	      $reservation->res_block_start_time  += 30*60;
	    }
	    /***************************************
var_dump("Putting into nudged reservations 6");
var_dump("sTART TIME ".date('r', $reservation->res_block_start_time) .
  "Nudged Res ID $reservation->reservation_id");
  //**************************************/

	    $nudged_reservations[$reservation->reservation_id] = $reservation;
	    continue;
	  }
	  //if $reservation->res_block_start_time equals res_block_end_time
	  //we will not be able to display this reservation
	  if ($reservation->res_block_start_time ==
              $reservation->res_block_end_time) {
	    $item = node_load($reservation->item_id);
          $error_message .= "Cannot display ".
            l($reservation->reservation_id." ($reservation->name) ",
            'reservations/mnn_facilities/facility/detail/'.
	      $reservation->reservation_id).
                " reservation for " .
	    l($item->title, "node/$item->nid").
                " because there are too many overlaps (of check out/in times) at " .
	    date('g:ia', $prev_reservation->res_block_start_time)."<br/>";
	  continue;
	  }

	  //if two or more reservations have teh same res_block_start_time
	  //then we will store the one with the earliest res_block_end_time
	  //in the $altered_reservation_start_blocks array
	  if ( $prev_reservation && ($reservation->res_block_start_time ==
				     $prev_reservation->res_block_start_time) ) {
	    //go into this if if we are replacing teh $prev_reservation
	    //with $reservation in the $altered_reservation_start_blocks array
	    if ($reservation->res_block_end_time <
		$prev_reservation->res_block_end_time) {

	      /***************************************
var_dump("Putting into altered and  nudged reservations 1");
var_dump("sTART TIME ".date('r', $reservation->res_block_start_time) .
  "END TIME ".date('r', $reservation->res_block_end_time) .
  "Res ID $reservation->reservation_id");

var_dump("sTART TIME ".date('r', $prev_reservation->res_block_start_time) .
  "Nudged Res ID $prev_reservation->reservation_id");
  //**************************************/

	      $altered_reservation_start_blocks[$reservation->res_block_start_time] = $reservation;
	      $prev_reservation->res_block_start_time  += 30*60;
	      $nudged_reservations[$prev_reservation->reservation_id] = $prev_reservation;
	      $prev_reservation = $reservation;
	    }
	    //go into the else if we will push $reservation to the next
	    //time block
	    else {
	      $reservation->res_block_start_time  += 30*60;
	      $nudged_reservations[$reservation->reservation_id] = $reservation;

	      /**************************************
var_dump("Putting into nudged reservations 3");
var_dump("sTART TIME ".date('r', $reservation->res_block_start_time) .
  "END TIME ".date('r', $reservation->res_block_end_time) .
  "Nudged Res ID $reservation->reservation_id");
  //**************************************/

	      $nudge_remaining_reservations = true;
	    }
	    continue;
	  }
	  //will go into this block if the $prev_reservation overlaps
	  //$reservation
	  else if ( $prev_reservation && ($reservation->res_block_start_time <
					  $prev_reservation->res_block_end_time) ) {

	    $new_cur_start = $reservation->res_block_start_time;
	    $new_prev_end = $prev_reservation->res_block_end_time;
	    //first see if you can move the prev_reservations end time without
	    //making it a zero length block
	    while ($new_cur_start < $new_prev_end) {
	      $new_prev_end -= 30*60;

	      /***************************************
var_dump("Prev End ".date('r', $new_prev_end) . " Cur Start ".date('r', $new_cur_start) );
//***************************************/

	      //see if backing the end time a half hour still allows reservation
	      //to show up
	      if ($new_cur_start >= $new_prev_end &&
		  $new_prev_end > $prev_reservation->res_block_start_time) {
		$prev_reservation->res_block_end_time = $new_prev_end;

		/***************************************
var_dump("Putting both into altered reservations");
var_dump("sTART TIME ".date('r', $prev_reservation->res_block_start_time) .
  " END TIME ".date('r', $prev_reservation->res_block_end_time) .
  " Res ID $prev_reservation->reservation_id");

var_dump("sTART TIME ".date('r', $reservation->res_block_start_time) .
  " END TIME ".date('r', $reservation->res_block_end_time) .
  " Res ID $reservation->reservation_id");
  //**************************************/

              $altered_reservation_start_blocks
                [$prev_reservation->res_block_start_time] = $prev_reservation;
              $altered_reservation_start_blocks[$reservation->res_block_start_time]
                = $reservation;
              $prev_reservation = $reservation;
	      }
	      //we've backed up too far
	      else if ($new_cur_start >= $new_prev_end) {
		$new_cur_start += 30*60;
		$reservation->res_block_start_time = $new_cur_start;
		$nudge_remaining_reservations = true;
		$nudged_reservations[$reservation->reservation_id] = $reservation;

		/***************************************
var_dump("Putting into nudged reservations 4");
var_dump("sTART TIME ".date('r', $reservation->res_block_start_time) .
  "Nudged Res ID $reservation->reservation_id");
  //**************************************/
	      }
	    }
	  }
	  else {
	    /***************************************
var_dump("Putting into altered reservations 0");
var_dump("sTART TIME ".date('r', $reservation->res_block_start_time) .
  "END TIME ".date('r', $reservation->res_block_end_time) .
  "Res ID $reservation->reservation_id");
            }
          }
        }
        else {
/***************************************
var_dump("Putting into altered reservations 0");
var_dump("sTART TIME ".date('r', $reservation->res_block_start_time) .
  "END TIME ".date('r', $reservation->res_block_end_time) .
  "Res ID $reservation->reservation_id");
  //**************************************/
          $altered_reservation_start_blocks[$reservation->res_block_start_time]
            = $reservation;
	  }
	  $prev_reservation = $reservation;
	}//END OF FOR LOOP
      }//end of while loop
      $reservation_start_blocks = $altered_reservation_start_blocks;
    }


  if ( $overlaps ) {
    $error_message .= "There are overlaps on reservation times! The " .
      "following pairs of reservations overlap: <br/> ";
    foreach ( $overlaps as $overlap ) {
      $res1 = $overlap[0];
      $res2 = $overlap[1];
      $item = node_load($res1->item_id);
      $error_message .= l($item->title.":", "node/$item->nid").
        l($res1->reservation_id." ($res1->name)",
          'reservations/mnn_facilities/facility/detail/'.
          $res1->reservation_id) ." overlaps ".
	l($res2->reservation_id." ($res2->name)",
          'reservations/mnn_facilities/facility/detail/'.
          $res2->reservation_id)."<br/>";
    }
  }

/*****************************************************
var_dump("final altered block");
foreach($reservation_start_blocks as $k1 => $v1) {
 var_dump("res id: ".$v1->reservation_id." start: ".date('r', $k1).
 "end: ".date('r', $v1->res_block_end_time));
}
var_dump($error_message);
}exit();
//***************************************/
  return $error_message;
}

//this function bumps reserve end time one second when it was set to H:59:59
//to prevent validation errors on back to back reservations
function reservations_daily_chart_end_time_shift($reserve_end_time) {
  $timestamp = strtotime($reserve_end_time);
  if (date('s', $timestamp) == 59) {
    $timestamp ++;
  }

  return date('Y-m-d H:i:s', $timestamp);
}

function reservations_daily_chart_form_alter(
&$form, &$form_state, $form_id) {

  if ($form_id== 'reservations_reservation_node_form') {
    //dsm($form);
    //fetch timestamp from query string
    $start_time = filter_input(INPUT_GET, 'start_time');

    $lang = $form['language']['#value'];
    
    $item_nid = filter_input(INPUT_GET, 'item_nid');
    //set item_nid from query string
    if (isset($item_nid) && is_numeric($item_nid)) {
      if (!arg(3)) {
	$item = node_load($item_nid);
	$inventory_tid = $item->field_reservations_inventory[$lang][0]['tid'];
	drupal_goto("node/add/reservations-reservation/inventory/".
		    $inventory_tid,
		    array('query'=>array('item_nid'=>$item_nid,
					 'start_time'=>$start_time
					 )
			  )
		    );
	return;
      }
      $form['choice_wrapper']['reservations_reservation_items']['choice_1']
	['reservations_item_nid']['#default_value']  = $item_nid;
    }

    if (isset($start_time) && is_numeric($start_time)) {
      $start_time = $start_time - date('Z', $start_time);
      $end_time = $start_time + 60*60;

      //set start date/end date and time
      $form['field_reservations_date'][$lang][0]['#default_value'] = 
	array('value'=>	date('Y-m-d H:i:s', $start_time),
	      'value2'=>date('Y-m-d H:i:s', $end_time));
    }
  }
}

/**
 *
 */

function reservations_daily_chart_special_args($arg_string) {
  $ret = array();
  $ret['inventories'] = array();
  $ret['item_ids'] = array();

  if ($arg_string ==  "studio-chart") {
    $ret['title'] = "MNN Studios";
    $ret['url_special_arg'] = $arg_string;
    $ret['inventories'][] = MNN_59TH_FACILITIES_INVENTORY_TID; 
    $ret['inventories'][] = MNN_FIREHOUSE_FACILITIES_INVENTORY_TID;
    $ret['inventories'][] = MNN_CM_INVENTORY_TID;
    $ret['item_ids'][] = MNN_FIREHOUSE_2ND_FLOOR_EXPRESS_STUDIO_NID;
    $ret['item_ids'][] = MNN_FIREHOUSE_2ND_FLOOR_MINI_EXPRESS_STUDIO_NID;
    $ret['item_ids'][] = MNN_FIREHOUSE_GEORGE_STONEY_NID;
    $ret['item_ids'][] = MNN_FIREHOUSE_JULIA_DE_BURGOS_SMALL_STUDIO_NID;
    $ret['item_ids'][] = MNN_FIREHOUSE_ZAPATA_EXPRESS_NID;
    $ret['item_ids'][] = MNN_59TH_STU001_OPEN_STUDIO_NID;
    $ret['item_ids'][] = MNN_59TH_STU002_CLOSED_STUDIO_NID;
    $ret['item_ids'][] = MNN_59TH_STU003_STUDIO_EXPRESS_NID;
    $ret['item_ids'][] = MNN_59TH_STU004_STUDIO_MINI_EXPRESS_NID;
    $ret['item_ids'][] = MNN_CM_DCTV_STUDIO_NID;
    $ret['url_arg_section'] = implode('/',$ret['inventories']);
  }
  else if (isset($arg_string) && $arg_string && is_numeric($arg_string)) {
    $ret['title'] = "";
    $ret['inventories'][] = $arg_string;
  }

  return $ret;
}

function reservations_daily_chart_widgets(&$view, &$args,$exposed_widgets) {
  //changed the form action so we point to the chart, rather than the raw view
  $exposed_widgets = $view->exposed_widgets;

  $old_action = 'action="/'.RESERVATIONS_DAILY_CHART_RAW;
  if (isset($args['url_arg_section'])) {
    $old_action .= "/".$args['url_arg_section'];
  }
  $new_action = 'action="/'.RESERVATIONS_DAILY_CHART_PATH;
  if (isset($args['url_special_arg'])) {
    $new_action .= "/".$args['url_special_arg'];
  }

  $exposed_widgets = str_replace($old_action, $new_action, $exposed_widgets);
  return $exposed_widgets;
}

/**
  * Implements hook_views_api().
  */
function reservations_daily_chart_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'reservations_daily_chart'),
  );
}


// CAN LIKELY BE REMOVED
function reservations_daily_chart_page_redirect($tid) {
  drupal_goto(RESERVATIONS_DAILY_CHART_PATH."/".$tid);
}
