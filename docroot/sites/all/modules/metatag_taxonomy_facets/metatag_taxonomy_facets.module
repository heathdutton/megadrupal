<?php

/**
 * @file
 * Primary hook implementations for Metatag Taxonomy Facets.
 */

/**
 * Implements hook_permission().
 */
function metatag_taxonomy_facets_permission() {
  $permissions = array();

  $permissions['metatag taxonomy facets edit page'] = array(
    'title' => t('Edit metatags for filtered faceted pages'),
  );

  return $permissions;
}

/**
 * Implements hook_menu().
 */
function metatag_taxonomy_facets_menu() {
  $items = array();

  $items['admin/config/search/metatags/taxonomy_facets'] = array(
    'title' => 'Taxonomy facets',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('metatag_taxonomy_facets_configure_facets_form'),
    'file' => 'metatag_taxonomy_facets.admin.inc',
    'access arguments' => array('administer meta tags'),
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/config/search/metatags/taxonomy_facets_item/%metatag_taxonomy_facets/edit'] = array(
    'title' => 'Edit Taxonomy facets metatags',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('metatag_taxonomy_facets_instance_edit_form', 5),
    'file' => 'metatag_taxonomy_facets.admin.inc',
    'access arguments' => array('administer meta tags'),
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/search/metatags/taxonomy_facets_item/%/%/add'] = array(
    'title' => 'Add taxonomy facets metatags',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('metatag_taxonomy_facets_instance_add_form', 5, 6),
    'file' => 'metatag_taxonomy_facets.admin.inc',
    'access arguments' => array('administer meta tags'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_entity_info().
 */
function metatag_taxonomy_facets_entity_info() {
  $entities = array();

  $entities['taxonomy_facets_combinations'] = array(
    'label' => t('Taxonomy facets combinations'),
    'controller class' => 'EntityAPIController',
    'base table' => 'taxonomy_facets_combinations',
    'load hook' => 'metatag_taxonomy_facets_combinations_load',
    'save callback' => 'metatag_taxonomy_facets_combinations_save',
    'entity keys' => array(
      'id' => 'cid',
    ),
    'bundles' => array(),
  );
  $entities['taxonomy_facets'] = array(
    'label' => t('Taxonomy facets'),
    'controller class' => 'EntityAPIController',
    'base table' => 'taxonomy_facets_items',
    'fieldable' => TRUE,
    'metatags' => TRUE,
    'uri callback' => 'metatag_taxonomy_facets_uri_callback',
    'load hook' => 'metatag_taxonomy_facets_load',
    'save callback' => 'metatag_taxonomy_facets_save',
    'entity keys' => array(
      'id' => 'tfid',
    ),
    'view modes' => array(
      'display' => array(
        'label' => t('Fake display'),
        'custom settings' => FALSE,
      ),
    ),
    'bundles' => array(),
  );

  return $entities;
}

/**
 * Implements hook_ctools_plugin_api().
 */
function metatag_taxonomy_facets_ctools_plugin_api($owner, $api) {
  if ($owner == 'metatag' && $api == 'metatag') {
    return array('version' => 1);
  }
}

/**
 * Creates a list of all possible combinations of given facets.
 *
 * @param array $searcher_info
 *   Searcher info.
 * @param array $selected_facets
 *   Selected facets info.
 * @param bool $enabled_single
 *   If single facets should be accepted as combinations.
 *
 * @return array
 *   Labeled combinations array.
 */
function metatag_taxonomy_facets_get_combinations_info(array $searcher_info, array $selected_facets, $enabled_single = FALSE) {
  $combinations = _metatag_taxonomy_facets_get_combinations($selected_facets, $enabled_single);

  $result = array();
  foreach ($combinations as $facets) {
    $id = "taxonomy_facets:{$searcher_info['name']}";
    $facet_labels = array();
    foreach ($facets as $facet_info) {
      $id .= '+' . str_replace(':', '-', $facet_info['field']);
      $facet_labels[] = $facet_info['label'];
    }
    $label = "{$searcher_info['label']}: " . implode(' - ', $facet_labels);
    $result[$id] = array('label' => $label);
  }

  return $result;
}

/**
 * Helper function for recursive creation of combintaions.
 *
 * @param array $facet_items
 *   Items to make combinations of.
 * @param bool $enabled_single
 *   If single facets should be accepted as combinations.
 *
 * @return array
 *   Combinations generated.
 */
function _metatag_taxonomy_facets_get_combinations(array $facet_items, $enabled_single) {
  if (empty($facet_items)) {
    return array();
  }
  if (count($facet_items) == 1) {
    return $enabled_single ? array($facet_items) : array();
  }

  usort($facet_items, function ($a, $b) {
    return $a['field'] > $b['field'];
  });
  $result[] = $facet_items;

  $num_sub_calls = count($facet_items);
  for ($i = 0; $i < $num_sub_calls; $i++) {
    $cur_item = array_shift($facet_items);
    $result = array_merge($result, _metatag_taxonomy_facets_get_combinations($facet_items, $enabled_single));
    $facet_items[] = $cur_item;
  }

  return $result;
}

/**
 * Implements hook_page_alter().
 *
 * Iterates through all searchers and sets page metatag information if required.
 */
function metatag_taxonomy_facets_page_alter(&$page) {
  if (!metatag_config_is_enabled('taxonomy_facets')) {
    return;
  }

  $langcode = $GLOBALS['language_content']->language;

  $searchers = facetapi_get_active_searchers();
  foreach ($searchers as $searcher) {
    $info = metatag_taxonomy_facets_set_searcher_page_metatags_data($page, $searcher);
    if (!empty($info) && isset($info['entity'])) {
      module_invoke_all('entity_view', $info['entity'], 'taxonomy_facets', 'full', $langcode);
    }
  }
}

/**
 * Sets page metatags for given searcher.
 *
 * If searcher's facets are active on given page and facets' combination
 * metatags are configured.
 *
 * @param array $page
 *   Page array to set matatags data into.
 * @param string $searcher
 *   Searcher in whose active facets are used.
 *
 * @return mixed
 *   Full info array or NULL if inavailable.
 */
function metatag_taxonomy_facets_set_searcher_page_metatags_data(array &$page, $searcher) {
  $info = metatag_taxonomy_facets_get_searcher_metatags_data($searcher);
  if (empty($info)) {
    return NULL;
  }

  $taxonomy_facets_entity = (object) array(
    'tokens' => $info['tokens'],
  );
  $options = array();
  $options['token data']['taxonomy_facets'] = $taxonomy_facets_entity;

  $metatags = array();
  $metatags[$info['config']->instance] = metatag_metatags_view($info['config']->instance, $info['entity_metatags'], $options);

  drupal_alter('metatag_taxonomy_facets_rendered_metatags', $metatags);

  if (!empty($metatags)) {
    $page['content']['metatags'] = $metatags;
  }

  return $info;
}

/**
 * Gets all metatags information for current page and searcher.
 *
 * @param string $searcher
 *   Name of the searcher.
 *
 * @return array
 *   'config', 'tokens', 'entity' and 'entity_metatags' in associative array.
 */
function metatag_taxonomy_facets_get_searcher_metatags_data($searcher) {
  $searchers_data = &drupal_static(__FUNCTION__, array());
  if (isset($searchers_data[$searcher])) {
    return $searchers_data[$searcher];
  }

  $result = array();

  $config = metatag_taxonomy_facets_taxonomy_facets_get_config($searcher);
  if (empty($config)) {
    return $result;
  }

  $result['config'] = $config;

  $active_facets = facetapi_adapter_load($searcher)->getAllActiveItems();
  drupal_alter('metatag_taxonomy_facets_active_facets', $active_facets);
  asort($active_facets);

  $tokens = array();
  foreach ($active_facets as $facet) {
    $tokens[$facet['field alias']] = taxonomy_term_load($facet['value']);
  }
  $result['tokens'] = $tokens;

  $tids = array_map(function ($item) {
    return $item['value'];
  }, $active_facets);
  $entity = metatag_taxonomy_facets_find_entity($searcher, $config->instance, $tids);
  $result['entity'] = $entity;
  $result['entity_metatags'] = $entity ? $entity->metatags : array(LANGUAGE_NONE => metatag_config_load($config->instance)->config);

  $searchers_data[$searcher] = $result;

  return $result;
}

/**
 * Loads metatags config for given searcher's current active facets.
 *
 * @param string $searcher
 *   Searcher whose facets metatags data we are interested in.
 *
 * @return bool|array
 *   Metatags config data or FALSE if none is found.
 */
function metatag_taxonomy_facets_taxonomy_facets_get_config($searcher) {
  $adapter = facetapi_adapter_load($searcher);
  if (!$adapter) {
    return NULL;
  }
  $active_facets = $adapter->getAllActiveItems();
  if (empty($active_facets)) {
    return NULL;
  }

  drupal_alter('metatag_taxonomy_facets_active_facets', $active_facets);

  $facets_selected = variable_get('metatag_taxonomy_facets_selected');
  $facets_unselected = variable_get('metatag_taxonomy_facets_unselected');
  $ignore_unsupported_facets = variable_get('metatag_taxonomy_facets_ignore_unsupported_facets');
  $searcher_selected_facets = isset($facets_selected[$searcher]) ? $facets_selected[$searcher] : array();
  $searcher_unselected_facets = isset($facets_unselected[$searcher]) ? $facets_unselected[$searcher] : array();

  $instance = "taxonomy_facets:{$searcher}";
  asort($active_facets);
  foreach ($active_facets as $facet) {
    if (!isset($searcher_selected_facets[$facet['field alias']])) {
      if (!isset($searcher_unselected_facets[$facet['field alias']]) && isset($ignore_unsupported_facets[$searcher])) {
        continue;
      }
      return NULL;
    }
    $facet_name = str_replace(':', '-', $facet['field alias']);
    $instance .= "+{$facet_name}";
  }

  return metatag_config_load($instance);
}

/**
 * Implements hook_menu_local_tasks_alter().
 *
 * If all active facets on the given page are configured to have taxonomy facets
 * metatags enabled, link is provided to add or edit metatags info for this page
 */
function metatag_taxonomy_facets_menu_local_tasks_alter(&$data, &$router_item, &$root_path) {
  if (!user_access('metatag taxonomy facets edit page')) {
    return;
  }

  $searchers = facetapi_get_active_searchers();
  if (empty($searchers)) {
    return;
  }

  $is_tab_enabled = FALSE;
  foreach ($searchers as $searcher) {
    $facets_config = metatag_taxonomy_facets_taxonomy_facets_get_config($searcher);

    if (!$facets_config) {
      continue;
    }

    $active_facets = facetapi_adapter_load($searcher)->getAllActiveItems();
    asort($active_facets);

    $tids = array_map(function ($item) {
      return $item['value'];
    }, $active_facets);
    $facets_part = metatag_taxonomy_facets_get_facets_part($facets_config->instance, $searcher);
    $tfid = metatag_taxonomy_facets_taxonomy_facets_find($searcher, $facets_part, $tids);
    if ($tfid) {
      $url = "admin/config/search/metatags/taxonomy_facets_item/{$tfid}/edit";
    }
    else {
      $coimbination_id = metatag_taxonomy_facets_combinations_find($searcher, $facets_part);
      if (!$coimbination_id) {
        continue;
      }
      $tids_part = implode(',', $tids);
      $url = "admin/config/search/metatags/taxonomy_facets_item/{$coimbination_id}/{$tids_part}/add";
    }
    $data['tabs'][0]['output'][] = array(
      '#theme' => 'menu_local_action',
      '#link' => array(
        'title' => t('Metatags'),
        'href' => $url,
      ),
    );

    $is_tab_enabled = TRUE;
  }

  if (!$is_tab_enabled) {
    return;
  }
  if (!isset($data['tabs'][0]['count']) || $data['tabs'][0]['count'] < 2) {
    // If there are less then two tabs, menu system won't render 'em
    // so we pretend to have at least two.
    $data['tabs'][0]['count'] = 2;
  }
}

/**
 * Concatenates searcher name and facets string with prefix into instance name.
 *
 * @param int $combinatin_id
 *   Combination Id.
 *
 * @return string
 *   Combination instance name.
 */
function metatag_taxonomy_facets_get_combination_instance($combinatin_id) {
  $combination = metatag_taxonomy_facets_combinations_load($combinatin_id);
  return "taxonomy_facets:{$combination->searcher}+{$combination->facets}";
}

/**
 * Extracts facets part of instance string.
 *
 * @param string $instance
 *   Combination instance name string.
 * @param string $searcher
 *   Searcher name.
 *
 * @return string
 *   Facets instance name part.
 */
function metatag_taxonomy_facets_get_facets_part($instance, $searcher) {
  $parts = explode("{$searcher}+", $instance);
  return $parts[1];
}

/**
 * Saves combination to database.
 *
 * @param object $entity
 *   Entity being saved.
 *
 * @return mixed
 *   Saving results.
 *
 * @see entity_save()
 */
function metatag_taxonomy_facets_combinations_save($entity) {
  $entity->combination_hash = _metatag_taxonomy_facets_get_combination_hash($entity->searcher, $entity->facets);
  return entity_get_controller('taxonomy_facets_combinations')->save($entity);
}

/**
 * Returns combination hash.
 *
 * @param string $searcher
 *   Searcher name.
 * @param string $facets
 *   Facets string.
 *
 * @return string
 *   Hashed string.
 */
function _metatag_taxonomy_facets_get_combination_hash($searcher, $facets) {
  return md5("{$searcher}:{$facets}");
}

/**
 * Loads taxonomy_facets entity.
 *
 * @param int $tfid
 *   Taxonomy facets instance Id.
 *
 * @return bool|object
 *   Loaded entity or FALSE if load failed.
 */
function metatag_taxonomy_facets_load($tfid) {
  $list = entity_load('taxonomy_facets', array($tfid));
  return $list ? reset($list) : FALSE;
}

/**
 * Saves taxonomy_facets entity.
 *
 * @param object $entity
 *   Entity being saved.
 *
 * @return mixed
 *   Saving results.
 *
 * @see entity_save()
 */
function metatag_taxonomy_facets_save($entity) {
  $entity->tids_hash = md5($entity->tids);
  return entity_get_controller('taxonomy_facets')->save($entity);
}

/**
 * Gets taxonomy_facets entity uri.
 *
 * @param object $entity
 *   Entity being enquired.
 *
 * @return string
 *   Entity uri.
 */
function metatag_taxonomy_facets_uri_callback($entity) {
  // Now we suppose that entity only use on the page it represents.
  return array(
    'path' => current_path(),
    'options' => array(),
  );
}

/**
 * Loads taxonomy_facets entity by searcher name, unstance string and terms ids.
 *
 * @param string $searcher
 *   Searcher name.
 * @param string $instance
 *   Taxonomy facets combination instance string.
 * @param array $tids
 *   Taxonomy terms ids.
 *
 * @return object|null
 *    Loaded entity or null if none was found.
 */
function metatag_taxonomy_facets_find_entity($searcher, $instance, array $tids) {
  $facets_part = metatag_taxonomy_facets_get_facets_part($instance, $searcher);
  $tfid = metatag_taxonomy_facets_taxonomy_facets_find($searcher, $facets_part, $tids);

  return $tfid ? entity_load_single('taxonomy_facets', $tfid) : NULL;
}

/**
 * Finds facets combination entity id.
 *
 * @param string $searcher
 *   Searcher name.
 * @param string $facets
 *   Facets string.
 * @param array $tids
 *   Taxonomy terms ids.
 *
 * @return int
 *   Taxonomy facets entity id.
 */
function metatag_taxonomy_facets_taxonomy_facets_find($searcher, $facets, array $tids) {
  $hash = _metatag_taxonomy_facets_get_combination_hash($searcher, $facets);
  $query = db_select('taxonomy_facets_items', 'f');
  $query->join('taxonomy_facets_combinations', 'c', 'c.cid = f.combination_id');
  return $query->fields('f', array('tfid'))
    ->condition('combination_hash', $hash)
    ->condition('tids', implode(',', $tids))
    ->execute()
    ->fetchColumn();
}

/**
 * Loads facet combination entity.
 *
 * @param int $cid
 *   Combination Id.
 *
 * @return object|bool
 *   Loaded entity or FALSE if none was found.
 */
function metatag_taxonomy_facets_combinations_load($cid) {
  $list = entity_load('taxonomy_facets_combinations', array($cid));
  return $list ? reset($list) : FALSE;
}

/**
 * Checks if facet is taxonomy term facet.
 *
 * @param array $facet_info
 *   Facet info received from facetapi
 * @return boolean
 *   Check result
 */
function metatag_taxonomy_facets_is_taxonomy_facet(array $facet_info) {
  if (isset($facet_info['field api name']) && !empty($facet_info['field api name'])) {
    $field_info = field_info_field($facet_info['field api name']);
    return $field_info['type'] == 'taxonomy_term_reference';
  }
  if (isset($facet_info['field type']) && !empty($facet_info['field type'])) {
    return $facet_info['field type'] == 'taxonomy_term';
  }
  
  return false;
}

/**
 * Finds facet combination id by searcher name and facets string.
 *
 * @param string $searcher
 *   Searcher name.
 * @param string $facets
 *   Facets string.
 *
 * @return int
 *   Combination Id.
 */
function metatag_taxonomy_facets_combinations_find($searcher, $facets) {
  $hash = _metatag_taxonomy_facets_get_combination_hash($searcher, $facets);
  $query = db_select('taxonomy_facets_combinations', 'c');
  return $query->fields('c', array('cid'))
    ->condition('combination_hash', $hash)
    ->execute()
    ->fetchColumn();
}

/**
 * Saves combinations: creates new, deletes stale.
 *
 * @param array $combinations
 *   Combinations being saved.
 */
function _metatag_taxonomy_facets_save_combinations(array $combinations) {
  foreach ($combinations as $searcher_name => $searcher_combinations) {
    $prev_combinations = db_select('taxonomy_facets_combinations', 'c')
      ->fields('c', array('cid', 'facets'))
      ->condition('searcher', $searcher_name)
      ->execute()
      ->fetchAllKeyed();

    // Adding any new combinations.
    foreach ($searcher_combinations as $combination) {
      $prev_index = array_search($combination['facets'], $prev_combinations);
      if ($prev_index !== FALSE) {
        unset($prev_combinations[$prev_index]);
      }
      else {
        $entity = entity_create('taxonomy_facets_combinations', $combination);
        entity_save('taxonomy_facets_combinations', $entity);
      }
    }
    // Removing any stale combinations and corresponding entities.
    foreach ($prev_combinations as $cid => $facets) {
      metatag_taxonomy_facets_delete_combination($cid);
    }
  }
}

/**
 * Delete combination and corresponding instances records.
 *
 * @param int $cid
 *   Combintaion id to be deleted.
 */
function metatag_taxonomy_facets_delete_combination($cid) {
  $tfids = db_select('taxonomy_facets_items', 'f')
    ->fields('f', array('tfid'))
    ->condition('combination_id', $cid)
    ->execute()->fetchColumn();
  if (!empty($tfids)) {
    entity_delete_multiple('taxonomy_facets', $tfids);
  }

  db_delete('taxonomy_facets_combinations')
    ->condition('cid', $cid)
    ->execute();
}
