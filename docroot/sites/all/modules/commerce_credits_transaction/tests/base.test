<?php
/**
 * @file
 * Commerce Credits Transaction Base Test Class
 */


/**
 * Contains public methods and assertions useful for classes that extend it.
 */
class CommerceCreditsTransactionTestCase extends CommerceBaseTestCase {

  /**
   * Implements setUp().
   */
  public function setUp() {
    // @todo get it so modules provided by sub classes work again. DrupalWTF.

    // @todo CommerceBaseTestCase::setUpHelper has a parameter option "all"
    // that does not provide all modules to enable. CommerceWTF.
    $modules = parent::setUpHelper('dependencies');
    $modules += parent::setUpHelper('api');
    $modules += parent::setUpHelper('ui');
    $modules += parent::setUpHelper('all', array('commerce_credits', 'commerce_credits_ui', 'commerce_credits_transaction'));
    parent::setUp($modules);

    // Create commerce_credits product.
    $this->product = $this->createCommerceCreditsProduct('credit');

    // Create a product node type with product reference field.
    $this->productNodeType = $this->drupalCreateContentType(array('type' => 'product', 'label' => 'Product'));
    $this->createFieldInstance('node', 'product', 'field_productref', 'commerce_product_reference', 'options_select', array('required' => 1));

    // Create a product node.
    $settings = array(
      'type' => 'product',
      'field_productref' => array(
        'und' => array(array(
          'product_id' => $this->product->product_id,
        )),
      ),
    );
    $this->productNode = $this->drupalCreateNode($settings);

    // Create a random node type.
    $this->transferNodeType = $this->drupalCreateContentType();
    $this->transferNode = $this->drupalCreateNode(array('type' => $this->transferNodeType->type));

    // Add the Manage credits role to the administrator user setup by commerce.
    $permissions = $this->permissionBuilder('site_admin');
    $permissions[] = 'manage commerce credits transaction';
    $this->site_admin = $this->drupalCreateUser($permissions);
    $this->assertTrue(user_access('manage commerce credits transaction', $this->site_admin), t('Site administrator role granted Manage Commerce Credits Transaction permission.'));

    // Create a user to buy credits.
    $this->web_user = $this->drupalCreateUser(array('access content'));
  }

  /**
   * Create a commerce credits product.
   *
   * @param $credit_type
   *   The Commerce Credits group.
   * @param $sku
   *   An optional SKU to set.
   * @param $title
   *   An optional product title to set.
   * @param $number
   *   An optional number of credits to assign when this product is purchased.
   * @return object
   *   The Commerce Product entity.
   */
  public function createCommerceCreditsProduct($credit_type, $sku = '', $title = '', $number = 10) {
    try {
      $product = commerce_product_new('commerce_credits');

      $product->sku = empty($sku) ? $this->randomName(10) : $sku;
      $product->title = empty($title) ? $this->randomName(10) : $title;
      $product->status = 1;
      $product->language = LANGUAGE_NONE;

      $product->commerce_credits_type = array(
        'und' => array(array(
          'value' => $credit_type,
        )),
      );
      $product->commerce_credits_number = array(
        'und' => array(array(
          'value' => $number,
        )),
      );

      commerce_product_save($product);
      $this->assertNotNull($product->product_id, t('Successfully created new product %title with product_id %id', array('%title' => $product->title, '%id' => $product->product_id)));

      return $product;
    }
    catch (Exception $e) {
      debug($e->getMessage());
      $this->assert(FALSE, t('Failed to create new product %title', array('%title' => $product->title)));
      return FALSE;
    }
  }

  /**
   * Create field and/or field instance.
   *
   * @param $entity_type
   *   The entity type.
   * @param $bundle
   *   The bundle.
   * @param $name
   *   The field name.
   * @param $field_type
   *   An optional field type. If not defined, text will be used.
   * @param $widget
   *   An optional widget type. If not defined, text_textfield will be used.
   * @param $options
   *   An optional array of options to set various field properties such as
   *   cardinality or settings. This may be required depending on the field!
   * @param $wiget_settings
   *   An optional array of widget settings to apply to the field instance.
   * @return boolean
   *   TRUE if the operation was successful. This will be asserted within this
   *   function as well.
   */
  public function createFieldInstance($entity_type, $bundle, $name, $field_type = 'text', $widget = 'text_textfield', $options = array(), $widget_settings = array()) {

    $field = field_read_field($name);
    if (!$field) {
      // Create the field.
      $field_info = array(
        'field_name' => $name,
        'type' => $field_type,
        'cardinality' => isset($options['cardinality']) ? $options['cardinality'] : 1,
        'required' => isset($options['required']) ? $options['required'] : 0,
        'settings' => isset($options['settings']) ? $options['settings'] : array(),
      );

      $field = field_create_field($field_info);
    }

    $this->assertNotNull($field['id'], t('Successfully found or created %type field, %name', array('%name' => $name, '%type' => $field_type)));

    $instance = field_read_instance($entity_type, $name, $bundle);

    if (!$instance) {
      $instance_info = array(
        'entity_type' => $entity_type,
        'bundle' => $bundle,
        'field_name' => $name,
        'widget' => array(
          'type' => $widget,
          'settings' => $widget_settings,
        ),
      );

      $instance = field_create_instance($instance_info);
    }

    $this->assertNotNull($instance['field_id'], t('Successfully found or created field instance, %name, on %type:%bundle as %widget', array('%name' => $name, '%type' => $entity_type, '%bundle' => $bundle, '%widget' => $widget)));

    return isset($instance['field_id']);
  }

  /**
   * Assert that an entity has a defined number of credits.
   *
   * @param $entity_type
   *   The entity type.
   * @param $entity
   *   The entity.
   * @param $credit_type
   *   The commerce credits group.
   * @param $number
   *   The number of credits the entity should have.
   * @param $message
   *   An optional message to set.
   * @param $group
   *   An optional group.
   */
  public function assertEntityHasCredits($entity_type, $entity, $credit_type, $number, $message = '', $group = 'Commerce Credits') {
    try {
      $wrapper = entity_metadata_wrapper($entity_type, $entity);
      $credits = entity_get_controller('commerce_credits')->loadByEntity($wrapper->getIdentifier(), $wrapper->type(), $credit_type, TRUE);
      $credits = is_array($credits) ? array_pop($credits) : FALSE;

      $num_credits = $credits ? $credits->credits : 0;

      $plural = format_plural($num_credits, '1 credit', '@count credits');
      $message = !empty($message) ? $message : t('%label has !plural', array('%label' => entity_label($entity_type, $entity), '!plural' => $plural));

      if ($credits && $credits->credits == $number) {
        // Credit entity exists and credits are equal.
        return $this->assert(TRUE, $message, $group);
      }
      elseif (!$credits && $number == 0) {
        // Credit entity does not exist and should not exist.
        return $this->assert(TRUE, $message, $group);
      }
      else {
        // Credit entity does not exist and should exist, OR credit entity does
        // not have credits equal to credits passed in.
        return $this->assert(FALSE, $message, $group);
      }
    }
    catch (Exception $e) {
      debug($e->getMessage());
      return $this->assert(FALSE, $message, $group);
    }
  }

  /**
   * Assert that the latest transaction for an entity exists, and has the
   * correct number of credits and transactional direction.
   *
   * @param $entity_type
   *   The entity type.
   * @param $entity
   *   The entity.
   * @param $number
   *   The number of credits in the transaction.
   * @param $transaction
   *   The transaction direction - in or out
   * @param $message
   *   An optional message.
   * @param $group
   *  An optional group.
   */
  public function assertCreditTransaction($entity_type, $entity, $number, $transaction, $message = '', $group = 'Commerce Credits') {
    $plural = format_plural($number, '1 credit', '@count credits');
    $message = !empty($message) ? $message : t('Found a %dir credit transaction of !plural to %label.', array('!plural' => $plural, '%dir' => $transaction, '%label' => entity_label($entity_type, $entity)));

    try {
      $wrapper = entity_metadata_wrapper($entity_type, $entity);

      $query = db_select('commerce_credits_transaction');
      $transaction_id = $query
        ->fields('commerce_credits_transaction', array('transaction_id', 'credits'))
        ->condition('transaction', $transaction)
        ->orderBy('transaction_date', 'DESC')
        ->orderBy('transaction_id', 'DESC')
        ->range(0, 1);
      $result = $query->execute();
      $transaction = $result->fetchObject();

      return $this->assert((isset($transaction->credits) ? $transaction->credits == $number : FALSE), $message, $group);
    }
    catch (Exception $e) {
      debug($e->getMessage());
      return $this->assert(FALSE, $message, $group);
    }
  }

  /**
   * Assert that an entity's commerce credits matches the sum of its transactions.
   *
   * @param $entity_type
   *   The entity type.
   * @param $entity
   *   The entity.
   * @param $credit_type
   *   The Commerce Credits group.
   * @param $message
   *   An optional message to set.
   * @param $group
   *   An optional group.
   */
  public function assertEntityHasCreditTransaction($entity_type, $entity, $credit_type, $message = '', $group = 'Commerce Credits') {
    $transaction_sum = 0;

    try {
      $wrapper = entity_metadata_wrapper($entity_type, $entity);
      $credits = entity_get_controller('commerce_credits')->loadByEntity($wrapper->getIdentifier(), $wrapper->type(), $credit_type, TRUE);
      $credits = is_array($credits) ? array_pop($credits) : FALSE;

      if (!isset($credits)) {
        // Query the transactions that are related to this entity.
        $query = db_select('commerce_credits_transaction', 'cct');
        $or = db_or()->condition('from_cid', $credits->cid)->condition('to_cid', $credits->cid);
        $query
          ->fields('cct')
          ->condition($or)
          ->condition('credit_type', $credit_type)
          ->condition('status', 'canceled');
        $result = $query->execute();

        foreach ($result as $record) {
          if ($record->to_entity_type == $entity_type && $record->to_entity_id == $wrapper->getIdentifier()) {
            $transaction_sum += $record->credits;
          }
          else {
            $transaction_sum -= $record->credits;
          }
        }

        $credits_plural = format_plural((isset($credits) ? $credits->credits : 0), '1 credit', '@count credits');
        $sum_plural = format_plural($transaction_sum, '1 total credit', '@count total credits');
        $message = !empty($message) ? $message : t('%label has !plural credits, and matching !sum from transactions', array('%label' => entity_label($entity_type, $entity), '!plural' => $plural, '!sum' => $sum_plural));

        return $this->assert($transaction_sum == $credits->credits, $message, $group);
      }
      else {
        // Fail if the credits entity doesn't exist... Don't have a good way to
        // handle this yet.
        return $this->assert(FALSE, $message, $group);
      }
    }
    catch (Exception $e) {
      debug($e->getMessage());
      return $this->assert(FALSE, ($message ? $message : $e->getMessasge()), $group);
    }
  }

}
