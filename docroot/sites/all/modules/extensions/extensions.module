<?php
/**
 * @file
 * An API for reusable objects.
 *
 * @copyright Copyright(c) 2012 Previous Next Pty Ltd
 * @license GPL v2 http://www.fsf.org/licensing/licenses/gpl.html
 * @author Chris Skene chris at previousnext dot com dot au
 */

/**
 * Register a new extension Collection.
 *
 * Collections are lazily instantiated with Extension registration, however you
 * can explicitly register a Collection using this function.
 *
 * @param string $collection_name
 *   Name of the collection to create.
 */
function extension_register_extension_collection($collection_name) {

  $registry = extensions_get_registry();

  $registry->setCollection($collection_name);
}

/**
 * Register an Extension.
 *
 * @param string $collection_name
 *   Name of the set the extension belongs in.
 * @param string $extension_name
 *   Name of the extension to register.
 * @param string|null $human_name
 *   A human readable name.
 *
 * @return \Drupal\extensions\Registry\RegistrationController
 *   A registration controller.
 */
function extensions_register_extension($collection_name, $extension_name, $human_name = NULL) {

  $registry = extensions_get_registry();

  $extension = new \Drupal\extensions\Registry\RegistrationController($registry);

  return $extension->register($collection_name, $extension_name, $human_name);
}

/**
 * Load the Registry.
 *
 * @return Drupal\extensions\Registry\Registry
 *   A registry object.
 */
function extensions_get_registry() {

  $register = &drupal_static('extensions');

  if (empty($register)) {
    $register = new \Drupal\extensions\Registry\Registry();

    return $register;
  }

  return $register;
}

/**
 * API function to manually declare extension information.
 *
 * @todo caching
 *
 * @param string|null $collection
 *   A collection name.
 */
function extensions_parse_extensions($collection = NULL) {

  if (!empty($collection)) {
    $collection = str_replace('-', '_', $collection);
    // Invokes hook_extensions_declare_collection_name()
    module_invoke_all('extensions_declare_' . $collection);
  }
  else {
    // Invokes hook_extensions_declare()
    module_invoke_all('extensions_declare');
  }
}

/**
 * Return configuration for a collection's extensions.
 *
 * @param string $collection
 *   The collection name.
 *
 * @return array
 *   An array of extension configuration information
 */
function extensions_get_extensions_list($collection) {
  $registry = extensions_get_registry();

  if ($registry->hasCollections() == TRUE) {
    return $registry->getCollection($collection)->getExtensionsSettings();
  }
}

/**
 * Return a set of loaded extensions for a collection.
 *
 * @param string $collection
 *   The collection name.
 *
 * @return array
 *   An array of extension configuration information
 */
function extensions_get_extensions($collection) {
  $registry = extensions_get_registry();

  $collection = $registry->getCollection($collection);
  if (!empty($collection)) {
    return $collection->getExtensions();
  }
}

/**
 * Return a single loaded extension.
 *
 * @param string $collection
 *   The collection name.
 * @param string $extension_name
 *   Name of the extension to register.
 *
 * @return \Drupal\extensions\Extension\ExtensionInterface
 *   An extension.
 */
function extensions_get_extension($collection, $extension_name) {
  $registry = extensions_get_registry();

  return $registry->getCollection($collection)->getExtension($extension_name);
}

/**
 * Scan modules for extension declarations, and return loaded extensions.
 *
 * @param string $collection
 *   The collection name.
 *
 * @return array
 *   An array of loaded extension objects.
 */
function extensions_load_extensions($collection) {

  // Parse all hooks to build the list of extensions.
  extensions_parse_extensions($collection);

  // Return the extension list.
  return extensions_get_extensions($collection);
}