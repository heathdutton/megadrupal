<?php
/**
 * @file
 * Containts date endpoint hook functions and form builder functions.
 */

/**
 * Implements hook_field_widget_info().
 */
function date_endpoint_field_widget_info() {
  $widgets = array(
    'date_endpoint' => array(
      'label' => t('Date Endpoint Select'),
      'description' => t('Gets date endpoints based on a recurring period relative to a repeating interval, and formats them into a select list.'),
      'field types' => array('datetime'),
      'settings' => array(),
    ),
  );
  return $widgets;
}

/**
 * Implements hook_field_widget_form().
 */
function date_endpoint_field_widget_settings_form($field, $instance) {
  $widget = $instance['widget'];
  $settings = $widget['settings'];
  $form = array();

  if ($widget['type'] == 'date_endpoint') {
    $form = array();
    $form['date_endpoint_reverse'] = array(
      '#type' => 'checkbox',
      '#title' => t('Reverse the date endpoint values'),
      '#description' => t('Reverses the order of the date endpoint values saved to the database.  This is intended for single-value date fields, to allow you to save the later endpoint to the database instead of the (default) earlier one.'),
    );
    if (isset($settings['date_endpoint_reverse'])) {
      $form['date_endpoint_reverse']['#default_value']
        = $settings['date_endpoint_reverse'];
    }

    foreach (array('day', 'week', 'month', 'year') as $component) {
      $form['date_endpoint_' . $component] = array(
        '#type' => 'textfield',
        '#title' => t('Number of @component intervals', array('@component' => $component)),
        '#default_value' => isset($settings['date_endpoint_' . $component]) ? $settings['date_endpoint_' . $component] : 5,
        '#size' => 10,
        '#maxlength' => PHP_INT_MAX,
        '#element_validate' => array('_date_endpoint_settings_validate'),
      );
    }
  }
  return $form;
}

/**
 * AJAX callback to rebuild the form.
 */
function date_endpoint_ajax($form, $form_state) {
  return $form;
}

/**
 * This is a modified copy of element_validate_integer_positive().
 */
function _date_endpoint_settings_validate($element, &$form_state) {
  $value = $element['#value'];
  if ($value !== '' && (!is_numeric($value)
    || intval($value) != $value
    || $value < 0)) {
    form_error($element, t('%name must be empty, or an integer between 0 and 400, inclusive.', array('%name' => $element['#title'])));
  }
}

/**
 * Implements hook_field_widget_form().
 */
function date_endpoint_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $settings = $instance['widget']['settings'];
  $element['#element_validate'] = array('_date_endpoint_widget_validate');

  $element['value'] = array(
    '#type' => 'select',
    '#empty_option' => t('Select a date'),
    '#title' => $element['#title'],
  );

  $endpoints = new DateEndpointGenerator(array(
    'intervals' => array(
      'D' => empty($settings['date_endpoint_day']) ? 0 : $settings['date_endpoint_day'],
      'W' => empty($settings['date_endpoint_week']) ? 0 : $settings['date_endpoint_week'],
      'M' => empty($settings['date_endpoint_month']) ? 0 : $settings['date_endpoint_month'],
      'Y' => empty($settings['date_endpoint_year']) ? 0 : $settings['date_endpoint_year'],
    ),
  ));

  // Deduce the default value.
  if (!empty($items[$delta]['value'])) {
    // If we have two endpoints, we can deduce the date component.
    if (!empty($items[$delta]['value2'])) {
      $date1 = new DateTime($items[$delta]['value']);
      $date2 = new DateTime($items[$delta]['value2']);
      $interval = $date1->diff($date2);
      $seconds = ($interval->y * 365 * 24 * 60 * 60) +
        ($interval->m * 30 * 24 * 60 * 60) +
        ($interval->d * 24 * 60 * 60) +
        ($interval->h * 60 * 60) +
        ($interval->i * 60) +
        $interval->s;
      // Account for anti-overlap logic.
      $seconds++;
      if ($seconds <= 86400) {
        $component = 'D';
      }
      elseif ($seconds <= 604800) {
        $component = 'W';
      }
      elseif ($seconds <= 2678400) {
        $component = 'M';
      }
      else {
        $component = 'Y';
      }
    }
    else {
      // If we only have one endpoint, pretend it's a day endpoint.
      $component = 'D';
    }
    $identifier = $endpoints->addEndpoint($component, new DateTime($items[$delta]['value']));
    $element['value']['#default_value'] = $identifier;
  }

  $element['value']['#options'] = $endpoints->getOptions();

  // serialize() cannot serialize a closure, so attach only needed properties.
  $form_state['storage']['date_endpoint_direction'][$field['field_name']][$delta] = $endpoints->direction;
  $form_state['storage']['date_endpoint_objects'][$field['field_name']][$delta] = $endpoints->getObjects();

  return $element;
}

/**
 * Combines selected option with endpoint objects to set/validate form values.
 */
function _date_endpoint_widget_validate($element, &$form_state) {
  $field = $form_state['field'][$element['#field_name']][$element['#language']]['field'];
  $widget = $form_state['field'][$element['#field_name']][$element['#language']]['instance']['widget'];
  $todate = $field['settings']['todate'];
  $delta = $element['#delta'];
  $widget_values = $form_state['values'][$field['field_name']][$element['#language']][$delta]['value'];

  $objects = $form_state['storage']['date_endpoint_objects'][$element['#field_name']][$delta];
  $direction = $form_state['storage']['date_endpoint_direction'][$element['#field_name']][$delta];

  // Only set the form value when there is actually a value present.
  $value = NULL;
  $value2 = NULL;
  if (!empty($widget_values)) {
    $widget_values = (array) $widget_values;
    foreach ($widget_values as $widget_key => $widget_value) {
      if ($widget_key === '_weight') {
        continue;
      }

      $endpoint_pair = $objects[$widget_value];
      if (!$endpoint_pair) {
        continue;
      }

      // Arrange the date values from earliest to latest.
      $reverse = isset($widget['settings']['date_endpoint_reverse']) ? $widget['settings']['date_endpoint_reverse'] : 0;
      if ($direction > 0) {
        $value = $endpoint_pair[$reverse]->format(DATE_FORMAT_DATETIME);
        $value2 = $endpoint_pair[!$reverse]->format(DATE_FORMAT_DATETIME);
      }
      elseif ($direction < 0) {
        $value = $endpoint_pair[!$reverse]->format(DATE_FORMAT_DATETIME);
        $value2 = $endpoint_pair[$reverse]->format(DATE_FORMAT_DATETIME);
      }
    }
  }

  form_set_value($element, array(
    'value' => $value,
    'value2' => $todate ? $value2 : NULL,
    'timezone' => date_default_timezone_get(),
    'offset' => NULL,
    'offset2' => NULL,
    'rrule' => NULL,
  ),
  $form_state);
}
