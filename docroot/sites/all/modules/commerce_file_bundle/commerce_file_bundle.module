<?php
/**
 * @file
 * commerce_file_bundle.module
 * Provides integration of commerce_file with commerce_product_bundle.
 */

/**
 * Implements hook_commerce_line_item_type_info_alter().
 *
 * Sets product=>true on the bundle line item type.
 */
function commerce_file_bundle_commerce_line_item_type_info_alter(&$line_item_types) {
  $line_item_types['bundle']['product'] = TRUE;
}


/**
 * Implements hook_entity_load().
 *
 * Adds commerce_product entity files onto 'bundle' type
 * line item file fields. Commerce does not take care of this
 * so we have to do it.
 */
function commerce_file_bundle_entity_load($entities, $type) {
  if ($type != 'commerce_line_item') {
    return;
  }

  foreach ($entities as $line_item) {
    $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
    if (isset($line_item_wrapper->commerce_product)) {
      $product_id = $line_item_wrapper->commerce_product->product_id->value();
      $product = commerce_product_load($product_id);
      // If this line item is a bundle type then go through and
      // refresh sub items.
      if (in_array($product->type, commerce_file_bundle_product_types())) {
        $query = new EntityFieldQuery();
        $entities = $query->entityCondition('entity_type', 'commerce_line_item')
          ->entityCondition('bundle', 'bundle')
          ->fieldCondition('commerce_parent_line_item', 'line_item_id', $line_item->line_item_id, '=')
          ->execute();
        if (!isset($entities['commerce_line_item'])) {
          return array();
        }
        foreach ($entities['commerce_line_item'] as $item) {
          $sub_line_item = commerce_line_item_load($item->line_item_id);
          $sub_line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $sub_line_item);
          commerce_file_refresh_line_item($sub_line_item_wrapper);
        }
      }
    }
  }
}

/**
 * Retrieve product types that reference other products.
 */
function commerce_file_bundle_product_types() {
  $product_types = array();
  foreach (field_info_instances('commerce_product') as $instances) {
    foreach ($instances as $instance) {
      $field = field_info_field($instance['field_name']);
      if ($field['type'] == 'commerce_product_reference' && !in_array($instance['bundle'], $product_types)) {
        $product_types[] = $instance['bundle'];
      }
    }
  }
  return $product_types;
}

/**
 * Update the status of licenses for files in an order.
 *
 * @param obj $order
 *   The order for which to update file license statuses.
 * @param string $updated_status
 *   The status to set on file licenses.
 */
function commerce_file_bundle_license_order_update_status($order, $updated_status = 'pending') {
  $line_items = field_get_items('commerce_order', $order, 'commerce_line_items');
  if (empty($line_items)) {
    return;
  }

  // Revoke line items for the order.
  foreach ($line_items as $delta => $field_item) {
    // Try to avoid any locking issues.
    try {
      $line_item = commerce_line_item_load($field_item['line_item_id']);
      if (!empty($line_item)) {
        // First look for sub line items (bundle line items will have them).
        $sub_items = array();
        $sub_items = commerce_product_bundle_get_sub_line_items($line_item);
        if (!empty($sub_items)) {
          foreach ($sub_items as $_delta => $sub_item) {
            commerce_file_license_line_item_update_status($sub_item, $order, $updated_status);
          }
        }
        else {
          commerce_file_license_line_item_update_status($line_item, $order, $updated_status);
        }
      }
    }
    catch (Exception $e) {
    }
  }
}
