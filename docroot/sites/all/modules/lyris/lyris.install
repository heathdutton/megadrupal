<?php
/**
 * @file
 * Installation and update instructions for the Lyris API integration module.
 */
/**
 * Implements hook_install().
 */
function lyris_install() {
  // Add fields for the content.  Instances will be created as lists (bundles)
  // are created.
  lyris_create_field('lyris_content_docparts');
}

/**
 * Implements hook_uninstall().
 */
function lyris_uninstall() {
  // Remove the fields we created.  We can't call lyris_fields() here because it
  // lives in the .module file, which is not loaded in the uninstall process.
  module_load_include('inc', 'lyris', 'includes/lyris.fields');
  $fields = lyris_lyris_fields();
  foreach (array_keys($fields) as $fieldname) {
    field_delete_field($fieldname);
  }

  // Clear out our variables.
  db_delete('variable')->condition('name', db_like('mollom_') . '%', 'LIKE')->execute();
}

/**
 * Implements hook_schema().
 */
function lyris_schema() {
  /**
   * Maintain a standard set of default struct values that can be used to
   * compile a complete struct to send to Lyris, ensuring no data is lost.
   */
  $schema['lyris_struct_defaults'] = array(
    'description' => 'Store the default values for a complete struct.',
    'fields' => array(
      'sfid' => array(
        'description' => 'Unique struct-field id.',
        'type' => 'serial',
        'not null' => TRUE,
      ),
      'struct' => array(
        'description' => 'The struct this field belongs to.',
        'type' => 'varchar',
        'length' => '64',
        'not null' => FALSE,
      ),
      'name' => array(
        'description' => 'Struct field name.',
        'type' => 'varchar',
        'length' => '128',
        'not null' => FALSE,
      ),
      'parent_eid' => array(
        'description' => 'Parent Entity ID (i.e. List ID to a Content.)',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'default_value' => array(
        'description' => 'The default value for this struct field.',
        'type' => 'blob',
        'not null' => FALSE,
      ),
    ),
    'primary key' => array('sfid'),
    'unique keys' => array(
      'struct_2' => array('struct', 'name', 'parent_eid')
    ),
    'indexes' => array(
      'name' => array('name'),
      'parent_eid' => array('parent_eid'),
      'struct' => array('struct'),
      'struct_name' => array('struct', 'name'),
    ),
  );

  /**
   * Permissions settings for each field.  Maintains a Role ID (rid) to
   * Struct-Field ID (sfid) relationship for viewing and editing values.
   */
  $schema['lyris_struct_permissions'] = array(
    'description' => 'Manage view and edit permissions for each field.',
    'fields' => array(
      'struct' => array(
        'description' => 'The struct this field belongs to.',
        'type' => 'varchar',
        'length' => '64',
        'not null' => TRUE,
        'default' => '',
      ),
      'name' => array(
        'description' => 'The struct field.',
        'type' => 'varchar',
        'length' => '128',
        'not null' => TRUE,
        'default' => '',
      ),
      'parent_eid' => array(
        'description' => 'The Entity ID of the parent entity (i.e. List ID to a Content.)',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'rid' => array(
        'description' => 'A Drupal role ID.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'status' => array(
        'description' => 'Numeric permission value: 0 = Hidden, 1 = Read Only, 2 = Writable.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
    ),
    'primary key' => array('struct', 'name', 'parent_eid', 'rid'),
    'indexes' => array(
      'name' => array('name'),
      'parent_eid' => array('parent_eid'),
      'rid' => array('rid'),
      'status' => array('status'),
      'struct' => array('struct'),
      'struct_role' => array('struct', 'rid'),
    ),
  );

  /**
   * Manage standard entity data and lyris sync info.
   */
  $schema['lyris_entities'] = array(
    'description' => 'Standard entity metadata and lyris sync info.',
    'fields' => array(
      'eid' => array(
        'description' => 'Entity ID.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'entity_type' => array(
        'description' => 'Entity type.',
        'type' => 'varchar',
        'length' => '255',
        'not null' => TRUE,
      ),
      'creator' => array(
        'description' => 'UID of the entity creator.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => FALSE,
      ),
      'created' => array(
        'description' => 'Timestamp when the entity was created.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => FALSE,
      ),
      'changer' => array(
        'description' => 'UID of the last user to change the entity.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => FALSE,
      ),
      'changed' => array(
        'description' => 'Timestamp of the last time the entity was changed.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => FALSE,
      ),
      'synced' => array(
        'description' => 'Timestamp of the last time this entity was synced with Lyris.',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => FALSE,
      ),
      'old_values' => array(
        'description' => 'If specific fields need to by synced, store the old values here for reference until they are synced with Lyris.',
        'type' => 'text',
        'not null' => FALSE,
      ),
    ),
    'primary key' => array('eid', 'entity_type'),
    'indexes' => array(
      'synced' => array('synced'),
    ),
  );

  /**
   * Lyris lists to be used as bundles for Lyris content.
   */
  $schema['lyris_list'] = array(
    'struct' => 'ListStruct',
    'description' => 'Lyris list data.',
    'fields' => array(
      'eid' => array(
        'description' => 'The primary identifier for this list.',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'title' => array(
        'description' => 'The human-readable title of the list.',
        'type' => 'varchar',
        'length' => '255',
        'not null' => FALSE,
      ),
      'template' => array(
        'description' => 'A template used to prepopulate content.',
        'type' => 'text',
        'size' => 'big',
      ),
      'template_format' => array(
        'description' => 'The text format to use with the template.',
        'type' => 'varchar',
        'length' => '255',
        'not null' => TRUE,
        'default' => 'plain_text',
      ),
      'origin' => array(
        'description' => 'Whether this list was created or imported.',
        'type' => 'varchar',
        'length' => '16',
        'not null' => FALSE,
      ),
      'server' => array(
        'description' => 'The Lyris server where this list lives.',
        'type' => 'varchar',
        'length' => '64',
        'not null' => FALSE,
      ),
    ),
    'primary key' => array('eid'),
    'unique keys' => array(
      'ListName' => array(LYRIS_DB_FIELD_PREFIX . 'ListName')
    ),
    'indexes' => array(
      'server' => array('server'),
    ),
  );

  /**
   * Lyris content represented as entities.
   */
  $schema['lyris_content'] = array(
    'struct' => 'ContentStruct',
    'description' => 'Contains Lyris content to generate mailings for a list.',
    'fields' => array(
      'eid' => array(
        'description' => 'The primary identifier for this content. Cannot use ContentID in case we cannot push to Lyris.',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
    ),
    'primary key' => array('eid'),
    'indexes' => array(
      'DateCreated' => array(LYRIS_DB_FIELD_PREFIX . 'DateCreated'),
      'ListName' => array(LYRIS_DB_FIELD_PREFIX . 'ListName'),
    ),
  );

  /**
   * Mailings
   */
  $schema['lyris_mailings'] = array(
    'struct' => 'MailingStruct',
    'description' => 'Manage an association of Lyris mailings to content and users',
    'fields' => array(
      'eid' => array(
        'description' => 'The primary identifier for this mailing.',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'ContentID' => array(
        'description' => 'The ContentID of the content that created the mailing.',
        'type' => 'int',
        'not null' => FALSE,
      ),
      'InMailID' => array(
        'description' => 'The Lyris InMailID returned when the mailing is accepted my Lyris.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      ),
      'OutMailID' => array(
        'description' => 'The OutMailID that Lyris creates when the mailing is delivered.',
        'type' => 'int',
        'not null' => FALSE,
      ),
      'send_date' => array(
        'description' => 'The datestamp when the mailing was sent to Lyris.',
        'type' => 'int',
        'not null' => FALSE,
      ),
      'uid' => array(
        'description' => 'The UID of the user who send the mailing.',
        'type' => 'int',
        'not null' => FALSE,
      ),
    ),
    'primary key' => array('eid'),
    'indexes' => array(
    ),
  );

  lyris_append_struct_to_schema($schema);

  return $schema;
}

/**
 * Append the Lyris fields as defined in includes/lyris.structs.inc.  Having
 * those fields available here allows us to more easily integrate Views and
 * other 3rd party modules. Any struct fields with the #schema parameter
 * will be added to the database table.
 */
function lyris_append_struct_to_schema(&$schema) {
  module_load_include('module', 'lyris');

  foreach ($schema as $table => &$def) {
    if (isset($def['struct'])) {
      //$fields = lyris_struct_form($def['struct'], NULL, NULL, FALSE);
      $fields = lyris_struct($def['struct'], 'schema');

      // Add each struct field with a schema array to the $schema definition.
      foreach ($fields as $name => $field) {
        // Ignore vertical tabs and grouping fieldsets
        if ($field['#type'] == 'vertical_tabs' || ($field['#type'] == 'fieldset' && $field['#tab'])) {
          continue;
        }
        // Break apart fieldset children into unique fields
        elseif ($field['#type'] == 'fieldset' && !$field['#tab']) {
          foreach (element_children($field) as $child) {
            $field_name = $name . "__" . $child;
            if (isset($field[$child]['#schema'])) {
              _lyris_schema_append($def, $field[$child], $field_name);
            }
          }
        }
        // Add standard fields
        elseif (isset($field['#schema'])) {
          _lyris_schema_append($def, $field, $name);
        }
      }
    }
  }
}

/**
 * Helper function to append struct fields to the database schema.
 */
function _lyris_schema_append(&$schema, $field, $name) {
  // Set the NOT NULL value if it is missing.
  if (!isset($field['#schema']['not null'])) {
    $field['#schema']['not null'] = !is_null($field['#default_value']);
  }

  // If NOT NULL is TRUE but no default is set, use the field #default_value
  if ($field['#schema']['not null'] == TRUE &&
      !isset($field['#schema']['default']) &&
      !in_array($field['#schema']['type'], array('text', 'blob'))) {
    $field['#schema']['default'] = (!is_null($field['#default_value']) ? $field['#default_value'] : '');
  }

  // If the schema type requires a length and one is not set, try #maxlnegth or
  // assign a standard default.
  if ($field['#schema']['type'] == 'int' && !isset($field['#schema']['length'])) {
    $field['#schema']['length'] = (isset($field['#maxlength']) ? $field['#maxlength'] : 10);
  }
  if ($field['#schema']['type'] == 'varchar' && !isset($field['#schema']['length'])) {
    $field['#schema']['length'] = (isset($field['#maxlength']) ? $field['#maxlength'] : 255);
  }

  // If the field data schema does not contain a specific description, use
  // the form field description or title if available.
  if (!isset($field['#schema']['description'])) {
    $field['#schema']['description'] = (isset($field['#description']) ? check_plain($field['#description']) : (isset($field['#title']) ? check_plain($field['#title']) : 'TODO: Set a description.'));
  }

  // Add the fields data to the table schema.
  $schema['fields'][LYRIS_DB_FIELD_PREFIX . $name] = $field['#schema'];
}

/**
 * Implements hook_update_N().
 * Add a field to lyris_entities to record changed fields.
 */
function lyris_update_7200(&$sandbox) {
  $spec = array(
    'description' => 'If specific fields need to by synced, store the old values here for reference until they are synced with Lyris.',
    'type' => 'text',
    'not null' => FALSE,
  );

  db_add_field('lyris_entities', 'old_values', $spec);

  // Provide a success messgage.
  return t('Update 7200 successful: Add a field to lyris_entities to record changed fields.');

  // If the update fails, provide a failure message.
  throw new DrupalUpdateException('Updated 7200 failed: Add a field to lyris_entities to record changed fields.');
}

/**
 * Implements hook_update_N().
 * Add fields for list templates.
 */
function lyris_update_7201(&$sandbox) {
  $fields = array(
    'template' => array(
      'description' => 'A template used to prepopulate content.',
      'type' => 'text',
      'size' => 'big',
    ),
    'template_format' => array(
      'description' => 'The text format to use with the template.',
      'type' => 'varchar',
      'length' => '255',
      'not null' => TRUE,
      'default' => 'plain_text',
    ),
  );

  foreach ($fields as $field_name => $field_data) {
    db_add_field('lyris_list', $field_name, $field_data);
  }

  // Provide a success messgage.
  return t('Update 7201 successful: Add fields for list templates.');

  // If the update fails, provide a failure message.
  throw new DrupalUpdateException('Updated 7201 failed: Add fields for list templates.');
}

/**
 * Unlock old credential fields so they can be removed.
 */
function lyris_update_7202(&$sandbox) {
  db_update('field_config')->fields(array('locked' => 0))->condition('field_name', array('lyris_username', 'lyris_userpass'), 'IN')->execute();

  // Provide a success messgage.
  return t('Update 7202 successful: Unlock old credential fields so they can be removed.');

  // If the update fails, provide a failure message.
  throw new DrupalUpdateException('Updated 7202 failed: Unlock old credential fields so they can be removed.');
}
