<?php
/**
 * @file
 * Lyris API integration module.
 */

// Path to this module
define('LYRIS_MOD_PATH', drupal_get_path('module', 'lyris'));

// Database tables
define('LYRIS_LIST_TABLE',     'lyris_list');
define('LYRIS_CONTENT_TABLE',  'lyris_content');
define('LYRIS_DEFAULTS_TABLE', 'lyris_struct_defaults');
define('LYRIS_PERM_TABLE',     'lyris_struct_permissions');
define('LYRIS_ENTITY_TABLE',   'lyris_entities');
define('LYRIS_MAILINGS_TABLE', 'lyris_mailings');

// List delete statuses
define('LYRIS_LIST_DELETE_FAILURE', 0);
define('LYRIS_LIST_DELETE_LOCAL',   1);
define('LYRIS_LIST_DELETE_REMOTE',  2);
define('LYRIS_LIST_DELETE_BOTH',    3);

// The origin of the list in the Drupal system: Created or Imported
define('LYRIS_LIST_NEW',    'new');
define('LYRIS_LIST_IMPORT', 'import');

// The default mode for Lyris to run.
define('LYRIS_MODE_OFFLINE',    'offline');
define('LYRIS_MODE_SANDBOX',    'sandbox');
define('LYRIS_MODE_PRODUCTION', 'production');
define('LYRIS_MODE_DEFAULT',    'production');

define('LYRIS_MODE_DISPLAY_DEFAULT', 0);

// Struct Field Permissions
define('LYRIS_FIELD_PERM_HIDDEN',  0);
define('LYRIS_FIELD_PERM_VIEW',    1);
define('LYRIS_FIELD_PERM_EDIT',    2);
define('LYRIS_FIELD_PERM_DEFAULT', 0);

// A Prefix to add to table columns to prevent Lyris names from conflicting
// with MySQL reserved words.
define('LYRIS_DB_FIELD_PREFIX', 'lyris_');

// Variable defaults
define('LYRIS_SYNC_THRESHOLD_DEFAULT', 10);

// Load the separate entity functionality.
include LYRIS_MOD_PATH . '/includes/lyris.controllers.inc';
include LYRIS_MOD_PATH . '/entities/lyris_list.inc';
include LYRIS_MOD_PATH . '/entities/lyris_content.inc';
include LYRIS_MOD_PATH . '/entities/lyris_mailing.inc';

/**
 * Implements hook_admin_paths().
 */
function lyris_admin_paths() {
  $paths = array(
    'lyris/*/edit'     => TRUE,
    'lyris/*/mailings' => TRUE,
    'lyris/*/delete'   => TRUE,
    'lyris/add'        => TRUE,
    'lyris/add/*'      => TRUE,
    'lyris/mailing/*'  => TRUE,
    'user/*/lyris'     => TRUE,
  );
  return $paths;
}

/**
 * Implements hook_block_info().
 */
function lyris_block_info() {
  $blocks['lyris_admin_links'] = array(
    'info' => t('Mailing List Admin Links'),
    'cache' => DRUPAL_CACHE_PER_PAGE | DRUPAL_CACHE_PER_ROLE,
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function lyris_block_view($delta = '') {
  $block = array();

  switch ($delta) {
    case 'lyris_admin_links':
      $lc = $list = NULL;

      // Determine the current context and load a list and content if applicable.
      if (arg(0) == 'lyris' && arg(1) == 'content' && is_numeric(arg(2))) {
        $lc = lyris_content_load(arg(2));
        $list = lyris_list_load($lc->localVal('ListName'));
      }
      elseif (arg(2) == 'lyris' && arg(3) == 'lists' && is_numeric(arg(4))) {
        $list = lyris_list_load(arg(4));
      }

      $block['subject'] = t('Lyris Admin');
      $block['content'] = theme('lyris_admin_links_block', array('content' => $lc, 'list' => $list));
      break;
  }

  return $block;
}

/**
 * Implements hook_cron().
 */
function lyris_cron() {
  lyris_include('cron');

  // Run a sync with Lyris
  $cron = new BatchSync();
  if ($cron->shouldRun()) {
    $cron->startTimer();
    $cron->run();
    $cron->stopTimer();
    $cron->writeLogSummary();
  }
}

/**
 * Implements hook_element_info().
 */
function lyris_element_info() {
  $types['lyris_token_fieldset'] = array(
    '#title' => t('Substitution Patterns'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#value' => NULL,
    '#process' => array('form_process_fieldset', 'ajax_process_form'),
    '#pre_render' => array('form_pre_render_fieldset'),
    '#theme_wrappers' => array('fieldset'),
  );

  return $types;
}

/**
 * Implements hook_entity_info().
 */
function lyris_entity_info() {
  $entities['lyris_list'] = array(
    'label' => t('Mailing List'),
    'base table' => LYRIS_LIST_TABLE,
    'module' => 'lyris',
    'entity class' => 'LyrisList',
    'controller class' => 'LyrisListEntityAPIController',
    'views controller class' => 'EntityDefaultViewsController',
    'uri callback' => 'lyris_list_uri',
    'fieldable' => FALSE,
    'entity keys' => array(
      'id' => 'eid',
      'label' => 'title',
      'lyris_id' => 'ListID',
    ),
    'bundles' => array(
      'lyris_list' => array(
        'label' => t('Lyris List'),
        'admin' => array(
          'path' => 'admin/structure/lyris',
          'access arguments' => array('administer lyris lists'),
        ),
      ),
    ),
  );

  $entities['lyris_content'] = array(
    'label' => t('Mailing List Content'),
    'base table' => LYRIS_CONTENT_TABLE,
    'module' => 'lyris',
    'entity class' => 'LyrisContent',
    'controller class' => 'LyrisEntityAPIController',
    'views controller class' => 'EntityDefaultViewsController',
    'uri callback' => 'lyris_content_uri',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'eid',
      'bundle' => llf('ListName'),
      'label' => llf('Title'),
      'lyris_id' => 'ContentID',
    ),
    'bundles' => array(),
    'bundle keys' => array(
      'bundle' => llf('ListName'),
    ),
    'view modes' => array(
      'default' => array(
        'label' => t('Default'),
        'custom settings' => FALSE,
      ),
    ),
  );

  $entities['lyris_mailing'] = array(
    'label' => t('Lyris Mailing'),
    'base table' => LYRIS_MAILINGS_TABLE,
    'module' => 'lyris',
    'entity class' => 'LyrisMailing',
    'controller class' => 'LyrisMailingEntityAPIController',
    'views controller class' => 'EntityDefaultViewsController',
    'uri callback' => 'lyris_mailing_uri',
    'fieldable' => FALSE,
    'entity keys' => array(
      'id' => 'eid',
      'label' => llf('Title'),
      'lyris_id' => 'InMailID',
    ),
    'bundles' => array(
      'lyris_mailing' => array(
        'label' => t('Lyris Mailing'),
        'admin' => array(
          'path' => 'admin/structure/lyris/lists/%lyris_list/mailings/%lyris_mailing',
          'bundle argument' => 6,
          'access callback' => 'lyris_mailing_access',
          'access arguments' => array('update', 4),
        ),
      ),
    ),
  );

  foreach (lyris_get_lists() as $list) {
    $entities['lyris_content']['bundles'][$list[llf('ListName')]] = array(
      'label' => $list['title'],
      'admin' => array(
        'path' => 'admin/structure/lyris/lists/%lyris_list',
        'real path' => 'admin/structure/lyris/lists/' . $list['eid'],
        'bundle argument' => 4,
        'access callback' => 'lyris_list_access',
        'access arguments' => array('update', $list),
      ),
    );
  }

  return $entities;
}

/**
 * Implements hook_field_access().
 */
function lyris_field_access($op, $field, $entity_type, $entity, $account) {
  // Access controls are added to the field definitions in
  // includes/lyris.fields.inc
  lyris_include('fields');
  $fields = lyris_fields();

  if (isset($fields[$field['field_name']]['instance'][$entity_type]['access'])) {
    $access = $fields[$field['field_name']]['instance'][$entity_type]['access'];

    if (is_array($access)) {
      return user_access($access[$op], $account);
    }
    else {
      return user_access($access, $account);
    }
  }
}

/**
 * Implements hook_forms().
 * Define a base form for lyris content entry.
 */
function lyris_forms() {
  lyris_include('forms');

  $forms = array();
  if ($lists = lyris_get_lists()) {
    foreach (array_keys($lists) as $list) {
      $forms[$list . '_lyris_content_form']['callback'] = 'lyris_content_form';
      $forms[$list . '_lyris_content_form']['file'] = 'includes/lyris.forms.inc';
    }
  }
  return $forms;
}

/**
 * Implements hook_help().
 */
function lyris_help($path, $arg) {
  $out = '';

  // Set messages for missing creds on structure pages.
  if (drupal_match_path($path, "admin/structure/lyris*\nadmin/content/lyris*")) {
    $account = lyris_global_user();
    $lyris_creds = lyris_creds_provided($account);
    if (!$lyris_creds['user']) {
      drupal_set_message(t('You have not !lp yet. If you do not have a Lyris password, contact your Lyris admin to have them setup your account.', array('!lp' => l(t('set your Lyris password'), "user/$account->uid/edit/lyris", array('query' => drupal_get_destination())))), 'warning');
    }
  }

  // Help text for all the Defaults pages
  if (drupal_match_path($path, "admin/structure/lyris/defaults*")) {
    $out .= t('The default settings allow you to choose which fields certain users have access to when creating and updating lists and content.  You can also set blanket default values for all lists and content.');
  }
  switch ($path) {
    case 'admin/config/services/lyris':
      $out .= '<h3>' . t('Lyris Administrator Account') . '</h3>';
      $out .= '<p>'  . t('Credentials must be set in your settings.php file for a server level lyris administrator.  This admin account is used for general querying and administrative tasks.') . '</p>';

      $out .= '<h3>' . t('Drupal User Accounts') . '</h3>';
      $out .= '<p>'  . t('Any user who wishes to send information to Lyris, such as updating a list or sending a mailing, must have thier own lyris account, whose email matches their Drupal account email, and they must set their lyris password in their user settings.') . '</p>';
      break;

    case 'admin/structure/lyris/defaults':
      $out .= '<p><strong>' . t('All new lists will inherit these initial values.') . '</strong></p>';
      break;

    case 'admin/structure/lyris/defaults/content':
      $out .= '<p><strong>' . t('All new content will inherit these initial values.  Content defaults can then be overridden per list in the list settings.') . '</strong></p>';
      break;

    case 'admin/structure/lyris/defaults/mailings':
      $out .= '<p><strong>' . t('All new mailings will inherit these initial values.  Mailing defaults can then be overridden per list in the list settings.') . '</strong></p>';
      break;
  }

  // Entity form Manage Fields pages
  if (drupal_match_path($path, 'admin/structure/lyris/lists/*/fields')) {
    $out .= t('Not all of these fields will be visible to every user.') . '<br />' .
            t('Check the !global and !content to determine who will see which fields.', array('!global' => l(t('global defaults'), 'admin/structure/lyris/defaults/content'), '!content' => l(t('content defaults for this list'), 'admin/structure/lyris/lists/' . $arg[4] . '/defaults')));
  }

  // User Lyris Settings
  if (drupal_match_path($path, 'user/*/edit/lyris')) {
    $out .= t('To manage Lyris lists, content and members, you will need a Lyris account with at least List Admin privileges to one list.  If you are not sure if you have an account, check with your Lyris Administrator to set one up.');
  }

  // List and Content edit forms
  if (drupal_match_path($path, "admin/structure/lyris/lists/*/edit\nlyris/content/*/edit")) {
    $out .= t('Substition patterns are available for all fields.  Many are provided by default, represented by a value in [square:brackets].');
  }

  return $out;
}

/**
 * Implements hook_menu().
 */
function lyris_menu() {
  // Lyris API configuration
  $items['admin/config/services/lyris'] = array(
    'title' => 'Lyris',
    'description' => 'Lyris Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('lyris_connection_settings_form'),
    'access arguments' => array('access lyris api'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'includes/lyris.admin.inc',
  );
  $items['admin/config/services/lyris/settings'] = array(
    'title' => 'Lyris Connection Settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );
  $items['admin/config/services/lyris/basic'] = array(
    'title' => 'Basic Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('lyris_basic_settings_form'),
    'access arguments' => array('administer lyris'),
    'file' => 'includes/lyris.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
  );
  $items['admin/config/services/lyris/cron'] = array(
    'title' => 'Cron Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('lyris_cron_settings_form'),
    'access arguments' => array('administer lyris'),
    'file' => 'includes/lyris.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
  );

  // Lyris List (Bundle) Management
  $items['admin/structure/lyris'] = array(
    'title' => 'Mailing Lists',
    'description' => 'Manage Lyris mailing lists.',
    'page callback' => 'lyris_page_lists',
    'access arguments' => array('edit any lyris lists'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'includes/lyris.pages.inc',
  );
  $items['admin/structure/lyris/list'] = array(
    'title' => 'Lists',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/structure/lyris/add'] = array(
    'title' => 'Create a New List',
    'description' => 'Create a new Lyris mailing list.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('lyris_form_list'),
    'access arguments' => array('create lyris lists'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'includes/lyris.forms.inc',
    'weight' => -10,
  );
  $items['admin/structure/lyris/import'] = array(
    'title' => 'Import an Existing List',
    'description' => 'Link to an existing Lyris list.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('lyris_form_list_import'),
    'access arguments' => array('import lyris lists'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'includes/lyris.forms.inc',
    'weight' => -9,
  );

  // Default Settings
  $items['admin/structure/lyris/defaults'] = array(
    'title' => 'Global Defaults',
    'description' => 'Set global default values for lists.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('lyris_form_defaults', 'ListStruct', 'list'),
    'access arguments' => array('edit any lyris lists'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'includes/lyris.forms.inc',
    'weight' => 0,
  );
  $items['admin/structure/lyris/defaults/lists'] = array(
    'title' => 'List Defaults',
    'description' => 'Manage List default settings.',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );
  $items['admin/structure/lyris/defaults/content'] = array(
    'title' => 'Content Defaults',
    'description' => 'Manage Content default settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('lyris_form_defaults', 'ContentStruct', 'content'),
    'access arguments' => array('administer lyris content'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'includes/lyris.forms.inc',
    'weight' => 1,
  );
  $items['admin/structure/lyris/defaults/mailings'] = array(
    'title' => 'Mailing Defaults',
    'description' => 'Manage Mailing default settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('lyris_form_defaults', 'MailingStruct', 'mailing'),
    'access arguments' => array('administer lyris content'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'includes/lyris.forms.inc',
    'weight' => 1,
  );

  /**
   * List Management
   */
  $items['admin/structure/lyris/lists/%lyris_list'] = array(
    'title' => 'Overview',
    'page callback' => 'lyris_list_view',
    'page arguments' => array(4),
    'access callback' => 'lyris_list_access',
    'access arguments' => array('view', 4),
    'file' => 'includes/lyris.pages.inc',
    'type' => MENU_CALLBACK,
    'weight' => -10,
  );
  $items['admin/structure/lyris/lists/%lyris_list/view'] = array(
    'title' => 'Overview',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/structure/lyris/lists/%lyris_list/edit'] = array(
    'title' => 'List Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('lyris_form_list', 4),
    'access arguments' => array('edit any lyris lists'),
    'file' => 'includes/lyris.forms.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => -9,
  );
  $items['admin/structure/lyris/lists/%lyris_list/defaults'] = array(
    'title' => 'Default Content Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('lyris_form_defaults', 'ContentStruct', 'content', 4),
    'access arguments' => array('administer lyris content'),
    'file' => 'includes/lyris.forms.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => -8,
  );
  $items['admin/structure/lyris/lists/%lyris_list/defaults/content'] = array(
    'title' => 'Content',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/structure/lyris/lists/%lyris_list/defaults/mailings'] = array(
    'title' => 'Mailings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('lyris_form_defaults', 'MailingStruct', 'mailing', 4),
    'access arguments' => array('administer lyris content'),
    'file' => 'includes/lyris.forms.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => -9,
  );
  $items['admin/structure/lyris/lists/%lyris_list/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('lyris_list_delete_confirm', 4),
    'access arguments' => array('delete any lyris lists'),
    'file' => 'includes/lyris.forms.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,
  );

  /**
   * Content Management
   */
  $items['lyris/add'] = array(
    'title' => 'Add Mailing List Content',
    'page callback' => 'lyris_content_add_page',
    'access callback' => 'lyris_content_access',
    'access arguments' => array('create'),
    'file' => 'includes/lyris.pages.inc',
  );
  $items['admin/content/lyris'] = array(
    'title' => 'Mailing List Content',
    'page callback' => 'lyris_content_listing',
    'access arguments' => array('view lyris content listing'),
    'file' => 'includes/lyris.pages.inc',
    'type' => MENU_LOCAL_TASK | MENU_NORMAL_ITEM,
  );
  $items['admin/content/lyris/%lyris_list'] = array(
    'title' => 'Mailing Lists',
    'page callback' => 'lyris_content_listing',
    'page arguments' => array(3),
    'access arguments' => array('view lyris content listing'),
    'file' => 'includes/lyris.pages.inc',
  );

  foreach (lyris_get_lists() as $list) {
    $items['lyris/add/' . $list['eid']] = array(
      'title' => 'Add Content for List: ' . $list['title'],
      'title callback' => 'check_plain',
      'description' => $list[llf('ShortDescription')],
      'page callback' => 'lyris_content_add',
      'page arguments' => array($list['eid']),
      'access callback' => 'lyris_list_access',
      'access arguments' => array('create', $list),
      'file' => 'includes/lyris.pages.inc',
    );
  }
  $items['lyris/content/%lyris_content'] = array(
    'title callback' => 'lyris_content_title',
    'title arguments' => array(2),
    // The page callback also invokes drupal_set_title() in case
    // the menu router's title is overridden by a menu link.
    'page callback' => 'lyris_content_page',
    'page arguments' => array(2),
    'access callback' => 'lyris_content_access',
    'access arguments' => array('view', 2),
    'file' => 'includes/lyris.pages.inc',
  );
  $items['lyris/content/%lyris_content/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['lyris/content/%lyris_content/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'lyris_content_edit',
    'page arguments' => array(2),
    'access callback' => 'lyris_content_access',
    'access arguments' => array('update', 2),
    'weight' => 0,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'file' => 'includes/lyris.pages.inc',
  );
  $items['lyris/content/%lyris_content/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('lyris_content_delete_confirm', 2),
    'access callback' => 'lyris_content_access',
    'access arguments' => array('delete', 2),
    'weight' => 1,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'file' => 'includes/lyris.forms.inc',
  );
  $items['lyris/content/%lyris_content/mailings'] = array(
    'title' => 'Preview/Send Mail',
    'page callback' => 'lyris_mailing_page',
    'page arguments' => array(2),
    'access callback' => 'lyris_content_access',
    'access arguments' => array('deliver', 2),
    'weight' => 2,
    'type' => MENU_LOCAL_TASK,
    'file' => 'includes/lyris.pages.inc',
  );
  $items['lyris/content/%lyris_content/mailings/preview'] = array(
    'title' => 'Mailings',
    'page callback' => 'lyris_content_render',
    'page arguments' => array(2),
    'access callback' => 'lyris_content_access',
    'access arguments' => array('deliver', 2),
    'weight' => 2,
    'type' => MENU_LOCAL_TASK,
    'file' => 'includes/lyris.pages.inc',
  );

  // Content View Callbacks
  $items['lyris/content/%lyris_content/view/embedded'] = array(
    'title callback' => 'lyris_content_title',
    'title arguments' => array(2),
    // The page callback also invokes drupal_set_title() in case
    // the menu router's title is overridden by a menu link.
    'page callback' => 'lyris_content_page_view',
    'page arguments' => array('embedded', 2),
    'access callback' => 'lyris_content_access',
    'access arguments' => array('view', 2),
    'file' => 'includes/lyris.pages.inc',
  );

  // Mailing delivery callbacks
  $items['lyris/mailing/%lyris_mailing/test'] = array(
    'title' => 'Mailing Test',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('lyris_mailing_form_test_confirm', 2),
    'access callback' => 'lyris_mailing_access',
    'access arguments' => array('deliver', 2),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'includes/lyris.forms.inc',
  );
  $items['lyris/mailing/%lyris_mailing/send'] = array(
    'title' => 'Mailing Send',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('lyris_mailing_form_send_confirm', 2),
    'access callback' => 'lyris_mailing_access',
    'access arguments' => array('deliver', 2),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'includes/lyris.forms.inc',
  );

  // AJAX Callbacks
  $items['lyris/ajax/list/name-validate/%'] = array(
    'title' => 'Lyris List Name Validation',
    'page callback' => 'lyris_ajax_name_validate',
    'page arguments' => array(4),
    'access arguments' => array('create lyris lists'),
    'type' => MENU_CALLBACK,
    'file' => 'includes/lyris.ajax.inc',
  );
  $items['lyris/ajax/list/name-autocomplete'] = array(
    'title' => 'Lyris List Name Autocomplete',
    'page callback' => 'lyris_ajax_name_autocomplete',
    'access arguments' => array('import lyris lists'),
    'type' => MENU_CALLBACK,
    'file' => 'includes/lyris.ajax.inc',
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function lyris_menu_alter(&$items) {
  // Send the Lyris user category to our own form instead of throwing a
  // conditional info the user_profile_form via an alter.
  $items['user/%user_category/edit/lyris']['page arguments'] = array('lyris_admin_credentials_form', 1);
  $items['user/%user_category/edit/lyris']['module'] = 'lyris';
  $items['user/%user_category/edit/lyris']['file'] = 'includes/lyris.admin.inc';
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function lyris_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  // Add action link to 'lyris/add' on 'admin/content/lyris' page.
  if ($root_path == 'admin/content/lyris') {
    $item = menu_get_item('lyris/add');
    if ($item['access']) {
      $data['actions']['output'][] = array(
        '#theme' => 'menu_local_action',
        '#link' => $item,
      );
    }
  }

  // Add action link to 'lyris/add/{listname}' on 'admin/content/lyris' page.
  if ($router_item['path'] == 'admin/content/lyris/%') {
    $item = menu_get_item('lyris/add');
    $item['path'] = $item['href'] = 'lyris/add/' . $router_item['page_arguments'][0]->localVal('ListName');
    if ($item['access']) {
      $data['actions']['output'][] = array(
        '#theme' => 'menu_local_action',
        '#link' => $item,
      );
    }
  }
}

/**
 * Implements hook_permission().
 */
function lyris_permission() {
  $perms = array(
    'administer lyris' => array(
      'title' => t('Administer Lyris'),
      'description' => t('Users may access Lyris administration areas.'),
      'restrict access' => TRUE,
    ),
    'access lyris api' => array(
      'title' => t('Access Lyris'),
      'description' => t('Users may enter a password for their Lyris account in order to use the Lyris API to administer lists and send mailings.  This is a global switch for all Lyris settings.  More granular permissions need to be enabled for specific functionality.'),
    ),
    'show lyris exceptions' => array(
      'title' => t('View Lyris Error Messages'),
      'description' => t('If an exception occurs while interacting with Lyris, the exception will be set as a status message for these users.  Otherwise users will be shown a generic message.'),
    ),
    'create lyris lists' => array(
      'title' => t('Create Lyris Lists'),
      'description' => t('Users may create new lists.')
    ),
    'import lyris lists' => array(
      'title' => t('Import Lyris Lists'),
      'description' => t('Users may import lists from Lyris.')
    ),
    'view any lyris list' => array(
      'title' => t('View Any List Overview Page'),
      'description' => t('View the list settings pages.')
    ),
    'edit any lyris lists' => array(
      'title' => t('Edit/Update Any Lyris Lists'),
      'description' => t('Manage all list settings.')
    ),
    'delete any lyris lists' => array(
      'title' => t('Delete Any Lyris Lists'),
      'description' => t('Delete any lyris lists locally and from Lyris.'),
    ),
    'deliver any lyris mailings' => array(
      'title' => t('Send Mailings for Any List'),
      'description' => t('Users may deliver mailings to any Lyris List.')
    ),
    'view lyris content listing' => array(
      'title' => t('View List Content Overview'),
      'description' => t('Allow users to view the Mailing List Content list.')
    ),
    'administer lyris content' => array(
      'title' => t('Administer All Lyris Content'),
      'description' => t('Overrides all administrative control for Lyris content.'),
      'restrict access' => TRUE,
    ),
  );

  // Create granular permissions for each list.
  /*$lists = lyris_get_lists();
  foreach ($lists as $list) {
    $listname = llf('ListName');
    $perms['view overview page for ' . $list[$listname]] = array(
      'title' => t('%name: View overview page', array('%name' => $list['title'])),
    );
    $perms['manage lyris settings for ' . $list[$listname]] = array(
      'title' => t('%name: Manage settings', array('%name' => $list['title'])),
    );
    $perms['create lyris content for ' . $list[$listname]] = array(
      'title' => t('%name: Create new content', array('%name' => $list['title'])),
    );
    $perms['deliver lyris mailings for ' . $list[$listname]] = array(
      'title' => t('%name: Create new content', array('%name' => $list['title'])),
    );
    $perms['edit own lyris content for ' . $list[$listname]] = array(
      'title' => t('%name: Edit own content', array('%name' => $list['title'])),
    );
    $perms['edit any lyris content for ' . $list[$listname]] = array(
      'title' => t('%name: Edit any content', array('%name' => $list['title'])),
    );
    $perms['delete own lyris content for ' . $list[$listname]] = array(
      'title' => t('%name: Delete own content', array('%name' => $list['title'])),
    );
    $perms['delete any lyris content for ' . $list[$listname]] = array(
      'title' => t('%name: Delete any content', array('%name' => $list['title'])),
    );
  }*/

  return $perms;
}

/**
 * Implements hook_preprocess().
 */
function lyris_preprocess(&$vars, $hook) {
  switch ($hook) {
    case 'lyris_entity_sync_status':
      $entity = $vars['entity'];
      $vars['status']  = (!$entity->hasChanges() ? t('No changes have been made since the last sync.') : t('Changes have been made since the last sync.'));
      $vars['changed'] = format_date($entity->changed, 'small') . ' (' . format_interval(time() - $entity->changed, 2) . ' ' . t('ago') . ')';
      $vars['synced']  = format_date($entity->synced, 'small')  . ' (' . format_interval(time() - $entity->synced, 2)  . ' ' . t('ago') . ')';
      $vars['classes_array'] += array('lyris-sync-status-block', 'lyris-sync-status-' . ($entity->synced >= $entity->changed ? 'yes' : 'no'));
      break;

    case 'lyris_helper_tools':
      lyris_include('css');

      $list = $vars['list'];
      $content = $vars['content'];

      // Get the list from the content if one wasn't provided.
      if ($content && !$list) {
        $list = lyris_object_parent($content);
      }

      $vars['list_title'] = ($list ? $list->getDisplayName() : '');
      $vars['list_name'] = ($list ? $list->localVal('ListName') : '');
      $vars['content_title'] = ($content ? $content->getDisplayName() : '');

      $list_links = $content_links = array();
      if (lyris_list_access('update', $list)) {
        $list_links[] = (l(t('Edit List'), "admin/structure/lyris/lists/{$list->eid}/edit", array('query' => drupal_get_destination())));
        $list_links[] = (l(t('View Subscribers'), "admin/structure/lyris/lists/{$list->eid}/members/overview"));
        $list_links[] = (l(t('Content List'), "admin/content/lyris/{$list->eid}"));
      }
      if ($content) {
        $content_links[] = (l(t('Edit Content'), "lyris/content/{$content->eid}/edit", array('query' => drupal_get_destination())));
        $content_links[] = (l(t('Edit Content Settings'), "admin/structure/lyris/lists/{$list->eid}/defaults", array('query' => drupal_get_destination())));
        $content_links[] = (l(t('Preview/Send Mail'), "lyris/content/{$content->eid}/mailings"));
        $content_links[] = (l(t('Edit Mailing Settings'), "admin/structure/lyris/lists/{$list->eid}/defaults/mailings", array('query' => drupal_get_destination())));
      }
      $vars['list_links'] = theme('item_list__lyris_helper_links', array('items' => $list_links, 'attributes' => array('class' => array('inline', 'links', 'menu'))));
      $vars['content_links'] = theme('item_list__lyris_helper_links', array('items' => $content_links, 'attributes' => array('class' => array('inline', 'links', 'menu'))));
      break;

    case 'lyris_mailing_preview':
      lyris_include('css');
      $mailing = $vars['mailing'];

      $content_link = l('[' . t('edit') . ']', "lyris/content/{$mailing->content_eid}/edit", array('query' => drupal_get_destination()));
      $list_link = l('[' . t('edit') . ']', "admin/structure/lyris/lists/{$mailing->list_eid}/edit", array('query' => drupal_get_destination()));

      $vars['to']       = htmlentities($mailing->localVal('To')) . " $content_link";
      $vars['reply_to'] = htmlentities($mailing->localVal('ReplyTo')) . " $list_link";
      $vars['from']     = htmlentities($mailing->localVal('From')) . " $content_link";
      $vars['subject']  = htmlentities($mailing->localVal('Subject')) . " $content_link";

      $vars['edit_content_link'] = $content_link;

      $vars['preview_path'] = base_path() . "lyris/content/{$mailing->content_eid}/mailings/preview";
      break;

    case 'lyris_content_embedded':
      lyris_include('css');
      $vars['content_path'] = base_path() . "lyris/content/" . $vars['content']->eid . "/view/embedded";
      break;
  }
}

/**
 * Implements hook_theme().
 */
function lyris_theme($existing, $type, $theme, $path) {
  return array(
    'item_list__lyris_helper_links' => array(
      'variables' => array('items' => array(), 'title' => NULL, 'type' => 'ul', 'attributes' => array()),
      'file' => 'includes/lyris.themes.inc',
    ),
    'lyris_add_page' => array(
      'variables' => array('content' => NULL),
      'file' => 'includes/lyris.themes.inc',
    ),
    'lyris_admin_links_block' => array(
      'variables' => array('list' => NULL, 'content' => NULL),
      'file' => 'includes/lyris.themes.inc',
    ),
    'lyris_content' => array(
      'variables' => array('content' => NULL, 'is_html' => TRUE),
      'path' => "$path/templates",
      'template' => 'lyris-content',
    ),
    'lyris_content_embedded' => array(
      'variables' => array('content' => NULL),
      'path' => "$path/templates",
      'template' => 'lyris-content-embedded',
    ),
    'lyris_form_default_perms_table' => array(
      'render element' => 'form',
      'file' => 'includes/lyris.forms.inc',
    ),
    'lyris_list_admin_overview' => array(
      'variables' => array('list' => NULL),
      'file' => 'includes/lyris.themes.inc',
    ),
    'lyris_list_admin_created' => array(
      'variables' => array('origin' => NULL, 'created' => NULL, 'creator' => NULL),
      'file' => 'includes/lyris.themes.inc',
    ),
    'lyris_list_admin_changed' => array(
      'variables' => array('changed' => NULL, 'changer' => NULL),
      'file' => 'includes/lyris.themes.inc',
    ),
    'lyris_mailing_preview' => array(
      'variables' => array('mailing' => NULL),
      'path' => "$path/templates",
      'template' => 'lyris-mailing-preview',
    ),
    'lyris_mode_indicator' => array(
      'variables' => array('attributes' => array('class' => array())),
      'file' => 'includes/lyris.themes.inc',
    ),
    'lyris_entity_sync_status' => array(
      'variables' => array('entity' => NULL, 'remote' => NULL),
      'path' => "$path/templates",
      'template' => 'lyris-entity-sync-status',
    ),
    /*'lyris_token_fieldset' => array(
      'render element' => 'element',
      'file' => 'includes/lyris.themes.inc',
    ),*/
  );
}

/**
 * Implements hook_token_info().
 */
function lyris_token_info() {
  $types = array(
    'lyris' => array(
      'name' => t('Lyris'),
      'description' => t('General Lyris tokens.'),
      'needs-data' => 'lyris_list',
    ),
    'lyris_list' => array(
      'name' => t('Lyris List'),
      'description' => t('Substitute values from Lyris lists.'),
      'needs-data' => 'lyris_list',
    ),
    'lyris_content' => array(
      'name' => t('Lyris Content'),
      'description' => t('Substitute values from Lyris content.'),
      'needs-data' => 'lyris_content',
    ),
    'lyris_mailing' => array(
      'name' => t('Lyris Mailing'),
      'description' => t('Substitute values for Lyris members.  IMPORTANT: Information is substituted from Lyris\'s records, not Drupal\'s.  Make sure you have set the proper values for your members or you may end up with e-mail addresses for every field.'),
      'needs-data' => 'lyris_content',
    ),
  );

  /**
   * List Tokens
   */
  $list['entityid'] = array(
    'name' => t('Entity ID'),
    'description' => t('The Drupal entity ID for this list.'),
  );
  $list['listid'] = array(
    'name' => t('List ID'),
    'description' => t('The Lyris ListID.'),
  );
  $list['name'] = array(
    'name' => t('List Name'),
    'description' => t('The human readable list name.'),
  );
  $list['description'] = array(
    'name' => t('Short Description'),
    'description' => t('From the Lyris short description field.'),
  );
  $list['comment'] = array(
    'name' => t('List Comment'),
    'description' => t('From the Lyris comment field.'),
  );

  /**
   * Content Tokens
   */
  $content['entityid'] = array(
    'name' => t('Entity ID'),
    'description' => t('The Drupal entity ID for this content.'),
  );
  $content['contentid'] = array(
    'name' => t('Content ID'),
    'description' => t('The Lyris ContentID.'),
  );
  $content['title'] = array(
    'name' => t('Content Title'),
    'description' => t('The title of the content.'),
  );
  $content['description'] = array(
    'name' => t('Description'),
    'description' => t('The description for this content.'),
  );

  /**
   * Lyris Member Mailing Tokens
   */
  $member['email'] = array(
    'name' => t('Member\'s E-mail'),
    'description' => t('The member\'s e-mail address.'),
  );
  $member['firstname'] = array(
    'name' => t('Member\'s First Name'),
    'description' => t('The member\'s first name (the first component of their full name). If the member does not have a full name, their email address is used instead. If a member only has a single component to their name, that component is used.'),
  );
  $member['fullname'] = array(
    'name' => t('Member\'s Full Name'),
    'description' => t('The member\'s full name. If the member does not have a full name, their email address is used instead.'),
  );
  $member['memberid'] = array(
    'name' => t('Member\'s Lyris ID'),
    'description' => t('The member\'s unique Member ID. This is useful for exactly identifying the user.'),
  );

  return array(
    'types' => $types,
    'tokens' => array('lyris_list' => $list, 'lyris_content' => $content, 'lyris_mailing' => $member),
  );
}

/**
 * Implements hook_token_info_alter().
 */
function lyris_token_info_alter(&$data) {
  // Remove Lyris Username and Password fields from tokens.
  unset($data['tokens']['user']['lyris-username'], $data['tokens']['user']['lyris_username'], $data['tokens']['user']['lyris_userpass']);

  // Remove any tokens generated from entity_token
  foreach (array('lyris_list', 'lyris_content', 'lyris_member', 'lyris_mailing') as $type) {
    foreach ($data['tokens'][$type] as $key => $token) {
      if (isset($token['entity-token']) && $token['entity-token'] === TRUE) {
        unset($data['tokens'][$type][$key]);
      }
    }
  }
}

/**
 * Implements hook_tokens().
 */
function lyris_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();

  switch ($type) {
    case 'lyris_list':
      if (isset($data['lyris_list'])) {
        $list = $data['lyris_list'];
        foreach ($tokens as $name => $original) {
          switch ($name) {
            case 'entityid':
              $replacements[$original] = $list->eid;
              break;
            case 'listid':
              $replacements[$original] = $list->localVal('ListID');
              break;
            case 'name':
              $replacements[$original] = $list->getDisplayName();
              break;
            case 'description':
              $replacements[$original] = $list->localVal('ShortDescription');
              break;
            case 'comment':
              $replacements[$original] = $list->localVal('Comment');
              break;
          }
        }
      }
      break;

    case 'lyris_content':
      if (isset($data['lyris_content'])) {
        $content = $data['lyris_content'];
        foreach ($tokens as $name => $original) {
          switch ($name) {
            case 'entityid':
              $replacements[$original] = $content->eid;
              break;
            case 'contentid':
              $replacements[$original] = $content->localVal('ContentID');
              break;
            case 'title':
              $replacements[$original] = $content->getDisplayName();
              break;
            case 'description':
              $replacements[$original] = $content->localVal('Description');
              break;

          }
        }
      }
      break;

    case 'lyris_mailing':
      foreach ($tokens as $name => $original) {
        switch ($name) {
          case 'email':
            $replacements[$original] = '%%merge recip.emailaddr%%';
            break;
          case 'firstname':
            $replacements[$original] = '%%merge recip.firstname%%';
            break;
          case 'fullname':
            $replacements[$original] = '%%merge recip.fullname%%';
            break;
          case 'memberid':
            $replacements[$original] = '%%merge recip.memberid%%';
            break;
        }
      }
      break;
  }

  return $replacements;
}

/**
 * Implements hook_user_categories().
 */
function lyris_user_categories() {
  $data[] = array(
    'name' => 'lyris',
    'title' => t('Lyris'),
    'access arguments' => array(1, 'access lyris api'),
    'weight' => 2,
  );

  return $data;
}

/**
 * Get a lyris API connection object from the static cache to prevent loading
 * multiple instances per request.
 *
 * @param $lyris_user
 *   'admin' or user entity to connect to Lyris.
 */
function lyris($lyris_user = NULL, $server = NULL) {
  // Kick out if the user is not valid.
  if ($lyris_user != 'admin' && (!$lyris_user && user_is_anonymous())) {
    return;
  }

  // Determine the Lyris server to call.
  if (!$server) {
    $server = variable_get('lyris_mode', LYRIS_MODE_DEFAULT);
  }

  $user = lyris_global_user();
  $lyris = &drupal_static(__FUNCTION__);
  $uid = ($lyris_user == 'admin' ? 'admin' : (is_object($lyris_user) ? $lyris_user->uid : $user->uid));

  // Generate a unique key for this user/mode connection
  $key = $uid . $server;

  if (!isset($lyris[$key])) {
    lyris_include('lyris');
    $lyris[$key] = ($lyris_user == 'admin' ? new LyrisApi('admin', $server) : (is_object($lyris_user) ? new LyrisApi($lyris_user, $server) : new LyrisApi($user, $server)));
    $lyris[$key]->object_key = $key;
    $lyris[$key]->uid = $uid;
  }

  return $lyris[$key];
}

/**
 * Get the current Lyris API version.
 *
 * @param $server
 *   The Lyris server to check the API version.
 * @param $full
 *   Boolean whether to return the full API version or just the major version.
 *   The major version is used to determine which API functions to use.
 */
function lyris_api_version($server = NULL, $type = 'major') {
  $data = &drupal_static(__FUNCTION__);

  // If a server is not specified, use the selection from the settings form.
  $server = ($server ? $server : variable_get('lyris_mode', LYRIS_MODE_DEFAULT));

  // Try to get the version form server cache.
  if (!isset($data[$server][$type])) {
    // First let's check for a system variable.
    $api = variable_get('lyris_api_' . $type . '_' . $server);

    // No system var set? Get it from Lyris.
    if (!$api) {
      return FALSE;
      //$lyris = lyris('admin', $server, TRUE);
      //$api = ($type == 'full' ? $lyris->api_version : $lyris->api_major_version);
    }

    // Reset the cache.
    $data[$server][$type] = $api;
  }

  return $data[$server][$type];
}

/**
 * Create a field.
 *
 * @param $field_name
 *   The name of a field defined in includes/lyris.fields.inc.
 *
 * @return $field
 *   The full field array.
 */
function lyris_create_field($field_name, $quiet = FALSE) {
  $fields = lyris_fields();
  $field = NULL;

  // Ensure we have a definition for this field.
  if (isset($fields[$field_name])) {
    $field = $fields[$field_name]['field'];
    $field['field_name'] = $field_name;
    _lyris_create_field($field, $quiet);
  }
  else {
    drupal_set_message(t('Unable to create field %f.', array('%f' => $field_name)), 'error');
    watchdog('lyris', 'Error creating field %f. No field definition provided.', array('%f' => $field_name), WATCHDOG_ERROR);
  }

  return $field;
}

/**
 * Helper function to create the field.
 *
 * @param $field
 *   The field definition array from includes/lyris.fields.inc.
 */
function _lyris_create_field(&$field, $quiet) {
  // First try to load the field to make sure it doesn't already exist.
  $existing_field = field_info_field($field['field_name']);
  if (empty($existing_field)) {
    $field = field_create_field($field);
  }
  elseif (!$quiet) {
    $field = $existing_field;
    drupal_set_message(t('Field %f already exists.', array('%f' => $field['field_name'])), 'error');
    watchdog('lyris', 'Error creating field %f. Field with that name already exists.', array('%f' => $field['field_name']), WATCHDOG_ERROR);
  }
}

/**
 * Attach an instance of a field to a bundle.
 *
 * @param $field_name
 *   The name of a field defined in includes/lyris.fields.inc.
 * @param $entity_type
 *   The type of entity in which to create the field instance.
 * @param $bundle
 *   The bundle of the entity type in which to create the field instance.
 *
 * @return $instance
 *   The full instance array.
 */
function lyris_create_field_instance($field_name, $entity_type, $bundle) {
  $fields = lyris_fields();
  $instance = NULL;

  $bundles = $fields[$field_name]['instance'][$entity_type];

  // Ensure we have a definition for this instance.
  if (isset($bundles[$bundle])) {
    $instance = $bundles[$bundle];
  }
  elseif (isset($bundles['all'])) {
    $instance = $bundles['all'];
  }

  if ($instance) {
    $instance['field_name']  = (isset($instance['field_name']) ? $instance['field_name'] : $field_name);
    $instance['entity_type'] = $entity_type;
    $instance['bundle']      = $bundle;
    _lyris_create_field_instance($instance);
  }
  else {
    $args = array('%f' => $field_name, '%b' => $bundle, '%e' => $entity_type);
    drupal_set_message(t('Unable to attach field %f to %b.', $args), 'error');
    watchdog('lyris', 'Error creating field instance %f on bundle %b of entity %e. No definition provided.', $args, WATCHDOG_ERROR);
  }

  return $instance;
}

/**
 * Helper function to create the instance.
 *
 * @param $instance
 *   An instance definition array from includes/lyris.fields.inc.
 */
function _lyris_create_field_instance(&$instance) {
  // First try to load the instance to make sure it doesn't already exist.
  $existing_instance = field_info_instance($instance['entity_type'], $instance['field_name'], $instance['bundle']);
  if (empty($existing_field)) {
    $instance = field_create_instance($instance);
  }
  else {
    $instance = $existing_instance;
    $args = array('%f' => $instance['field_name'], '%b' => $instance['bundle'], '%e' => $instance['entity_type']);
    drupal_set_message(t('Field %f already exists on %b.', $args), 'error');
    watchdog('lyris', 'Error creating field instance %f on bundle %b of entity %e. Instance already exists.', $args, WATCHDOG_ERROR);
  }
}

/**
 * Check for lyris sandbox, production and user creds.  Useful for restricting
 * access to certain forms and pages.
 *
 * @return Array
 *   Keyed on sandbox, production and user with boolean values indicating whether
 *   credentials have been provided.
 */
function lyris_creds_provided($account = NULL) {
  $sandbox    = variable_get('lyris_wsdl_sandbox', '');
  $production = variable_get('lyris_wsdl_production', '');

  $account = (is_object($account) ? $account : lyris_global_user());
  $name = (isset($account->data['lyris_username']) ? $account->data['lyris_username'] : NULL);
  $pass = (isset($account->data['lyris_userpass']) ? $account->data['lyris_userpass'] : NULL);

  return array(
    'sandbox' => !empty($sandbox),
    'production' => !empty($production),
    'user' => (!empty($name) && !empty($pass)),
  );
}

/**
 * Instantiate a new lyris entity.
 */
function lyris_entity_create($entity_type, $parent_eid = 0) {
  $entity = entity_create($entity_type, array('parent_eid' => $parent_eid));
  $entity->prepareObject($parent_eid);
  return $entity;
}

/**
 * Load a Lyris entity.
 *
 * Not to be confused with hook_entity_load().
 */
function lyris_entity_load_entity($entity_type, $eid, $reset = FALSE) {
  $eids = array($eid);
  $conditions = array();
  $entities = lyris_entity_load_multiple($entity_type, $eids, $conditions, $reset);
  return ($entities ? reset($entities) : FALSE);
}

/**
 * Load multiple Lyris entites from the DB.
 */
function lyris_entity_load_multiple($entity_type, $eids = array(), $conditions = array(), $reset = FALSE) {
  $entities = array();
  foreach (entity_load($entity_type, $eids, $conditions, $reset) as $entity) {
    $entities[] = $entity;
  }

  return $entities;
}

/**
 * Return the definition of a single Lyris field.
 */
function lyris_field($field_name) {
  $fields = lyris_fields();
  return (isset($fields[$field_name]) ? $fields[$field_name] : array());
}

/**
 * Data store for Lyris field definitions.
 *
 * Note: hook_field_info defines new field types, such as 'text' and 'numeric.'
 *   We just need to create fields of existing types and add them to bundles.
 *   This function defines those fields.
 *
 * When the module is installed, we create the fields via the .install file.
 * When a new bundle is created, we add fields to the bundle via
 * hook_field_attach_create_bundle().
 *
 * array(
 *   'field_name' => array(
 *     'field' => array(
 *       [FIELD DEFINITION],
 *     ),
 *     'instance' => array(
 *       [ENTITY TYPE] => array(
 *         'access' => array(
 *           'view' => [PERMISSION],
 *           'edit' => [PERMISSION],
 *         ),
 *         [BUNDLE NAME] => array(
 *           [BUNDLE INSTANCE DEFINITION],
 *         ),
 *       ),
 *     ),
 *   ),
 * );
 *
 * Note: If access is defined as a string it will apply to both view and edit
 * operations.
 */
function lyris_fields($module = NULL) {
  lyris_include('fields');

  if ($module) {
    $fields = module_invoke($module, 'lyris_fields');
  }
  else {
    $fields = module_invoke_all('lyris_fields');
  }

  return $fields;
}

/**
 * Implements hook_field_extra_fields().
 */
function lyris_field_extra_fields() {
  $extra = array();

  $struct = lyris_struct('ContentStruct', 'extra_fields', lyris_api_version());

  foreach (lyris_get_lists() as $list) {
    $extra['lyris_content'][$list[llf('ListName')]]['form'] = array();

    foreach ($struct as $name => $field) {
      $extra['lyris_content'][$list[llf('ListName')]]['form'][$name] = array(
        'label' => $field['#title'],
        'description' => $field['#description'],
        'weight' => $field['#weight'],
      );
    }

    // Add the token fieldset
    $extra['lyris_content'][$list[llf('ListName')]]['form']['lyris_token_ref'] = array(
      'label' => t('Token Substitution Patterns'),
      'description' => t('The token substitution patterns fieldset.  Tokens may be used in any Lyris field.'),
      'weight' => 99,
    );
  }

  return $extra;
}

/**
 * Returns a list of available lists.
 *
 * @param $server
 *   The server/mode to fetch lists from.  (Sandbox or Production)
 *
 * @return
 *   An array of node type names, keyed by the type.
 */
function lyris_get_lists($server = NULL) {
  if (!$server) {
    $server = variable_get('lyris_mode', LYRIS_MODE_DEFAULT);
  }

  $sel = db_select(LYRIS_LIST_TABLE, 'll');
  $sel->leftJoin(LYRIS_ENTITY_TABLE, 'le', "le.eid = ll.eid AND le.entity_type = 'lyris_list'");

  $sel->condition('ll.server', $server)
      ->fields('ll')
      ->fields('le')
      ->orderBy('ll.title');
  $res = $sel->execute();

  $ret = array();
  while ($list = $res->fetchAssoc()) {
    $ret[$list[llf('ListName')]] = $list;
  }

  return $ret;
}

/**
 * Return a list of unsynced records.
 *
 * @param $filter
 *   An array of criteria to filter the unsynced results.
 * @param $limit
 *   The maximum number of records to return.
 */
function lyris_get_unsynced($filter = array(), $limit = 0) {
  $select = db_select(LYRIS_ENTITY_TABLE, 'le')
              ->fields('le')
              ->condition(db_or()->where('le.changed > le.synced')->isNull('le.synced'))
              ->orderBy('le.changed');

  // Apply the limit
  if ($limit > 0) {
    $select->range(0, (int) $limit);
  }

  // Apply the filters
  foreach ($filter as $field => $value) {
    if ($field == 'entity_type') {
      switch ($value) {
        case 'lyris_member':
          $select->leftJoin(LYRIS_MEMBER_TABLE, 'lm', 'lm.eid = le.eid');
          $select->fields('lm');
          break;
      }
    }

    $select->condition($field, $value);
  }

  // Ignore mailings as they are not synced.
  $select->condition('le.entity_type', 'lyris_mailing', '<>');

  $res = $select->execute();

  // Preview the query with devel
  //dpq($select);

  $return = array();
  while ($record = $res->fetchAssoc()) {
    $return[] = $record;
  }

  return $return;
}

/**
 * Get a fully loaded user object for the active user.
 */
function lyris_global_user() {
  global $user;
  return user_load($user->uid);
}

/**
 * Manage external includes and assets.
 */
function lyris_include($hook, $module = NULL) {
  $module = (module_exists($module) ? $module : 'lyris');

  // Attempt to detect path by a pattern
  if (file_exists(drupal_get_path('module', $module) . "/includes/{$module}.{$hook}.inc")) {
    module_load_include('inc', $module, "includes/{$module}.{$hook}");
  }

  switch ($hook) {
    case 'lyris':
      module_load_include('class.inc', 'lyris', 'classes/exceptions');
      module_load_include('class.inc', 'lyris', 'classes/base');
      module_load_include('class.inc', 'lyris', 'classes/lyrisconn');
      module_load_include('class.inc', 'lyris', 'classes/lyrisapi');
      //module_load_include('class', 'lyris', 'classes/lyrisobject');
      //module_load_include('class', 'lyris', 'classes/lyrislist');
      //module_load_include('class', 'lyris', 'classes/lyriscontent');
      //module_load_include('class', 'lyris', 'classes/lyrismailing');
      break;

    case 'soap':
      switch (PHP_MINOR_VERSION) {
        case 3:
        case 4:
          module_load_include('php', 'lyris', 'soap/nusoap-5.3/lib/nusoap');
          break;

        default:
          module_load_include('php', 'lyris', 'soap/nusoap-5.2/lib/nusoap');
          break;
      }
      break;

    case 'cron':
      module_load_include('class.inc', 'lyris', 'classes/cron');
      break;

    case 'css':
      drupal_add_css(LYRIS_MOD_PATH . '/lyris.css');
      break;

    case 'js':
      drupal_add_js(LYRIS_MOD_PATH . '/js/lyris.js');
      break;
  }

  // Allow other modules to include external files.
  module_invoke_all('lyris_include', $hook);
}

/**
 * Given a Lyris Object, find the parent to that object that may govern specifc
 * behavior for that object, such as a bundle to an entity.
 *
 * I.E. Given a Lyris Content object, return the List.
 */
function lyris_object_parent($child_object) {
  switch ($child_object->struct_type) {
    case 'ListStruct':
      return NULL;
      break;

    case 'ContentStruct':
    case 'MailingStruct':
      $listname = $child_object->localVal('ListName');
      return ($listname ? lyris_list_load($listname) : NULL);
      break;
  }
}

/**
 * Encrypt a password string.
 */
function lyris_password_encrypt($str) {
  $key   = md5(drupal_get_hash_salt());
  $iv    = mcrypt_create_iv(mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB), MCRYPT_RAND);
  return trim(base64_encode(mcrypt_encrypt(MCRYPT_RIJNDAEL_256, $key, $str, MCRYPT_MODE_ECB, $iv)));
}

/**
 * Decrypt a password string.
 */
function lyris_password_decrypt($str) {
  $ivsize = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_256, MCRYPT_MODE_ECB);
  $iv     = mcrypt_create_iv($ivsize, MCRYPT_RAND);
  $key    = md5(drupal_get_hash_salt());
  return trim(mcrypt_decrypt(MCRYPT_RIJNDAEL_256, $key, base64_decode($str), MCRYPT_MODE_ECB, $iv));
}

/**
 * Check a user's Lyris privileges for a given API function on a given server.
 *
 * @param $func
 *   The Lyris API function.
 * @param $account
 *   The user account to validate.
 * @param $mode
 *   The production or sandbox server to check against.
 *
 * @return
 *   Boolean value whether the provided user has access to the provided API
 *     function.
 */
function lyris_remote_access($func, $account = NULL, $mode = NULL, $list = NULL) {
  if (!$mode) {
    $mode = variable_get('lyris_mode', LYRIS_MODE_DEFAULT);
  }

  // Validate parameters
  $account = (is_object($account) ? $account : lyris_global_user());
  //$mode = ($mode == LYRIS_MODE_OFFLINE ? LYRIS_MODE_PRODUCTION : $mode);

  $lyris = lyris($account, $mode);

  if ($lyris->isConnected()) {
    // If the user is a server admin, they can do anything.
    if ($lyris->isServerAdmin()) {
      return TRUE;
    }

    // @TODO Add check per API call.

  }
  else {
    return FALSE;
  }

  return TRUE;
}

/**
 * Helper function to determine whether or not to show lyris devel info.
 */
function lyris_show_devel($var = NULL, $val = NULL) {
  $pass = ($var ? variable_get($var) == $val : TRUE);
  return (module_exists('lyris_devel') && user_access('view lyris devel info') && $pass);
}

/**
 * Get a single struct definition for the current API.
 *
 * @param $struct_name
 *   The name of the struct type tyo get. (I.E. ContentStruct, ListStruct)
 * @param $api
 *   The API version of the struct to get.  Default setting if NULL.
 * @param $format
 *   Determines the formatters used to prepare the struct data.
 *
 * FORMATS:
 *   - local: Prepares the struct data to populate a flat, local object with
 *      default values.
 *   - lyris: Prepares the struct data in a Struct array for transport to Lyris.
 *   - defaults_form: Prepare values for the Struct Defaults form.
 *   - entity_form: Prepare values for the Entity data collection form.
 *   - schema: Prepare data to be appended to a db table schema.
 *
 * @return
 *   A default struct array from the includes/lyris.structs.inc file.
 */
function lyris_struct($struct_name, $format = NULL, $api = NULL, $entity = NULL) {
  $structs = lyris_structs();
  $struct = $structs[$struct_name];
  $defaults = (array) $entity;
  $api = ($api ? $api : lyris_api_version());

  _lyris_struct_format_apply_default_params($struct);

  switch ($format) {
    // LOCAL OBJECT FORMAT
    case 'local':
      unset($struct['vertical_tabs']);
      _lyris_struct_format_localize($struct);

      foreach ($struct as $field_name => &$field_data) {
        _lyris_struct_format_api_filter($field_name, $field_data, $struct, $api);
        _lyris_struct_format_filter($field_name, $field_data, $struct, $format);
        _lyris_struct_format_reduce_to_values($field_data);
      }
      break;

    // LYRIS STRUCT ARRAY
    case 'lyris':
      unset($struct['vertical_tabs']);
      foreach ($struct as $field_name => &$field_data) {
        _lyris_struct_format_api_filter($field_name, $field_data, $struct, $api);
        _lyris_struct_format_filter($field_name, $field_data, $struct, $format);
        _lyris_struct_format_reduce_to_values($field_data);
      }
      break;

    // FORM ELEMENTS FOR THE DEFAULT/PERMISSIONS SETTINGS FORM
    case 'defaults_form':
      _lyris_struct_format_localize($struct);

      foreach ($struct as $field_name => &$field_data) {
        _lyris_struct_format_api_filter($field_name, $field_data, $struct, $api);
        _lyris_struct_format_filter($field_name, $field_data, $struct, $format);

        if ($defaults) {
          _lyris_struct_format_form_overrides($field_name, $field_data, 'defaults_form', $defaults);
        }
      }

      // Group fields into their fieldsets
      _lyris_struct_format_field_groups($struct, $struct_name, 'defaults_form');
      break;

    // FORM ELEMENTS FOR THE ENTITY ADD/EDIT FORM
    case 'entity_form':
      _lyris_struct_format_localize($struct);

      foreach ($struct as $field_name => &$field_data) {
        _lyris_struct_format_api_filter($field_name, $field_data, $struct, $api);
        _lyris_struct_format_filter($field_name, $field_data, $struct, $format);

        if ($defaults) {
          _lyris_struct_format_form_overrides($field_name, $field_data, 'entity_form', $defaults);
        }

        if ($entity) {
          _lyris_struct_format_access_check($field_name, $field_data, $struct, $entity);
        }
      }

      // Group fields into their fieldsets
      //_lyris_struct_format_field_groups($struct, $struct_name, 'entity_form');
      break;

    // STRUCT SUITED TO GENERATE THE EXTRA FIELDS FOR ENTITIES
    case 'extra_fields':
      unset($struct['vertical_tabs']);
      _lyris_struct_format_localize($struct);

      foreach ($struct as $field_name => &$field_data) {
        _lyris_struct_format_api_filter($field_name, $field_data, $struct, $api);
        _lyris_struct_format_filter($field_name, $field_data, $struct, $format);
      }
      break;

    case 'schema':
      break;
  }

  return $struct;
}

/**
 * Struct Filter: Apply Defaults
 * Ensure all fields have the default parameters that we may be checking for
 * in later processing.
 *
 * NOTE: Limited to 2 levels.
 */
function _lyris_struct_format_apply_default_params(&$struct) {
  $defaults = array(
    '#description' => NULL,
    '#weight' => 0,
    '#required' => FALSE,
    '#defaultable' => TRUE,
    '#tab' => FALSE,
    '#permanent' => FALSE,
    '#hidden' => FALSE,
    '#permission' => array(),
  );
  $perms = array('hide' => TRUE, 'read' => TRUE, 'write' => TRUE);

  foreach ($struct as $field_name => &$field_data) {
    // Skip the vertical tabs grouping.
    if ($field_data['#type'] == 'vertical_tabs') {
      $field_data['#hidden'] = FALSE;
      continue;
    }

    $field_data += $defaults;
    $field_data['#permission'] += $perms;

    foreach (element_children($field_data) as $child_name) {
      $field_data[$child_name] += $defaults;
      $field_data[$child_name]['#permission'] += $perms;
    }
  }
}

/**
 * Struct Filter: API Filter
 * Filter the fields to the appropriate API verison.
 *
 * NOTE: Applies to all array depths.
 */
function _lyris_struct_format_api_filter($field_name, &$field_data, &$struct, $api) {
  // Remove fields that are not in the current API version.
  if (isset($field_data['#api']) && !in_array($api, $field_data['#api'])) {
    unset($struct[$field_name]);
  }
  else {
    foreach (element_children($field_data) as $child_name) {
      _lyris_struct_format_api_filter($child_name, $field_data[$child_name], $field_data, $api);
    }
  }
}

/**
 * Struct Filter: Format Filter
 * Remove fields that specify not to be included in certain formats.
 *
 * NOTE: Applies to all array depths.
 */
function _lyris_struct_format_filter($field_name, &$field_data, &$struct, $format) {
  if (isset($field_data['#filter'][$format]) && $field_data['#filter'][$format] == FALSE) {
    unset($struct[$field_name]);
  }
  else {
    foreach (element_children($field_data) as $child_name) {
      _lyris_struct_format_filter($child_name, $field_data[$child_name], $field_data, $format);
    }
  }
}

/**
 * Struct Filter: Localize
 * Rename the fields to our local, MySQL-safe names and flatten arrays.
 *
 * NOTE: Limited to 2 levels.
 */
function _lyris_struct_format_localize(&$struct) {
  $new_struct = array();

  foreach ($struct as $field_name => $field_data) {
    // Skip the vertical tabs grouping.
    if ($field_data['#type'] == 'vertical_tabs') {
      $new_struct[$field_name] = $field_data;
      continue;
    }

    if (isset($field_data['#struct'])) {
      foreach (element_children($field_data) as $child_name) {
        $field_data[$child_name]['#title'] = $field_data['#title'] . ' ' . $field_data[$child_name]['#title'];
        $new_struct[LYRIS_DB_FIELD_PREFIX . "{$field_name}__{$child_name}"] = $field_data[$child_name];
      }
    }
    else {
      $new_struct[LYRIS_DB_FIELD_PREFIX . $field_name] = $field_data;
    }
  }

  $struct = $new_struct;
}

/**
 * Struct Filter: Reduce to Values
 * Trim the struct values down to just their name and default value.
 *
 * NOTE: Limited to 1 level.
 */
function _lyris_struct_format_reduce_to_values(&$field_data) {
  $field_data = (isset($field_data['#default_value']) ? $field_data['#default_value'] : NULL);
}

/**
 * Struct Filter: Override form parameters for specific forms.
 *
 * NOTE: Limited to 1 level.
 */
function _lyris_struct_format_form_overrides($field_name, &$field_data, $key, $defaults = array()) {
  // Override parameters
  if (isset($field_data['#overrides'][$key])) {
    foreach ($field_data['#overrides'][$key] as $param => $val) {
      $field_data[$param] = $val;
    }
  }

  // Override default values
  if (isset($defaults[$field_name])) {
    $field_data['#default_value'] = $defaults[$field_name];
  }

  // Check devel settings for weight appendage
  if (lyris_show_devel('lyris_devel_show_form_weights', TRUE)) {
    $field_data['#title'] = "(" . (isset($field['#weight']) ? $field['#weight'] : 0) . ") " . $field['#title'];
  }
}

/**
 * Struct Filter: Group Fields
 * Apply the Vertical Tabs grouping element.
 */
function _lyris_struct_format_field_groups(&$struct, $struct_name, $form_type) {
  $form = array();

  if (!isset($struct['vertical_tabs'])) {
    return;
  }
  else {
    $form['vertical_tabs'] = $struct['vertical_tabs'];
    unset($struct['vertical_tabs']);
  }

  foreach ($struct as $field_name => $field_data) {
    if (isset($field_data['#group'])) {
      // Create the initial fieldset
      if (!isset($form['vertical_tabs']['fs_' . $field_data['#group']])) {
        // Reset the required indicator for this group
        $title  = (isset($form['vertical_tabs']['#groups'][$field_data['#group']]['#title'])  ? $form['vertical_tabs']['#groups'][$field_data['#group']]['#title']  : $field_data['#group']);
        $weight = (isset($form['vertical_tabs']['#groups'][$field_data['#group']]['#weight']) ? $form['vertical_tabs']['#groups'][$field_data['#group']]['#weight'] : 99);
        $desc   = (isset($form['vertical_tabs']['#groups'][$field_data['#group']]['#description']) ? $form['vertical_tabs']['#groups'][$field_data['#group']]['#description'] : '');

        $form['vertical_tabs']['fs_' . $field_data['#group']] = array(
          '#type'   => 'fieldset',
          '#title'  => $title,
          '#description' => '<p class="description">' . $desc . '</p>',
          '#weight' => $weight,
          '#group'  => $field_data['#group'],
          '#tab'    => TRUE,
        );
      }

      // Append the field to the fieldset
      $form['vertical_tabs']['fs_' . $field_data['#group']][$field_name] = $field_data;
      $form['vertical_tabs']['fs_' . $field_data['#group']]['#attached']['js'] = array(
        LYRIS_MOD_PATH . '/js/lyris.forms.js' => array('type' => 'file', 'weight' => -10),
        LYRIS_MOD_PATH . "/js/forms.{$struct_name}_{$form_type}.js" => array('type' => 'file', 'weight' => -9),
      );

      // If there is a required field, add a marker to the group tab.
      if ($field_data['#required']) {
        $form['vertical_tabs']['fs_' . $field_data['#group']]['#attributes']['class'][] = 'required-fields';
      }
    }
    // Put any ungrouped fields into a separate fieldset.
    else {
      if (!isset($form['fs_ungrouped'])) {
        $form['fs_ungrouped'] = array(
          '#type'   => 'group',
          '#weight' => -99,
          '#tab'    => TRUE,
        );
      }

      // Append the field to the fieldset
      $form['fs_ungrouped'][$field_name] = $field_data;
    }
  }

  $struct = $form;
}

/**
 * Struct Filter: Access Check
 * Restrict access to certain struct fields based on the defaults permissions
 * settings.
 */
function _lyris_struct_format_access_check($field_name, &$field_data, &$struct, $entity, $parent_eid = 0) {
  $view = lyris_struct_access('view', $entity, $field_name, $parent_eid);
  $edit = lyris_struct_access('edit', $entity, $field_name, $parent_eid);

  // Set the overall access level.  Apparently access levels of children
  // override their parents.  Fieldsets are not being rendered if there are
  // any children with FALSE access.  Instead, we'll simply skip the field
  // and not add it to the form array.
  if (!($view || $edit || $field_data['#permanent']) || $field_data['#hidden']) {
    unset($struct[$field_name]);
    return;
  }

  // If the field is read-only, change the type to 'item'
  if ($view && !$edit) {
    // Parse the markup
    if (isset($field_data['#options'])) {
      $markup = $field_data['#options'][$field_data['#default_value']];
    }
    elseif (in_array($field_data['#type'], array('textfield', 'textarea')) && !$field_data['#default_value']) {
      $markup = '[none]';
    }
    elseif ($field_data['#type'] == 'checkbox') {
      $markup = ($field_data['#default_value'] == 1 ? t('True') : t('False'));
    }
    else {
      $markup = $field_data['#default_value'];
    }

    $field_data['#type']   = 'item';
    $field_data['#markup'] = '<em class="default-value">' . htmlentities($markup) . '</em>';
    $field_data['#value']  = $field_data['#default_value'];
    //unset($field_data['#description']);
  }
}

/**
 * These are complete structs with default values to populate the struct form
 * fields and ensure complete structs are sent to Lyris.
 *
 * This function simply collects ALL available struct data.  Filtering is done
 * in lyris_struct().
 */
function lyris_structs() {
  lyris_include('structs');
  $structs = module_invoke_all('struct_data');

  // Iterate through the structs to fill out any nesting.
  foreach ($structs as $struct => &$struct_fields) {
    foreach ($struct_fields as $field_name => &$field_def) {
      if (isset($field_def['#struct'])) {
        $field_def += $structs[$field_def['#struct']['#name']];
      }
    }
  }

  // Allow structs to be altered by other modules.
  drupal_alter('lyris_struct', $structs);

  return $structs;
}

/**
 * Access callback for struct fields.
 */
function lyris_struct_access($op, &$object, $field) {
  $field_perms = &drupal_static(__FUNCTION__, array());
  $field = llf($field);
  $account = lyris_global_user();
  $parent = lyris_object_parent($object);
  $parent_eid = ($parent ? $parent->eid : 0);

  // Make sure we have loaded the fieldperms for this object.
  if (empty($field_perms)) {
    $object->populatePerms(array_keys($account->roles), $parent_eid);
    $field_perms = $object->field_perms;
  }

  $perms = array();
  if (array_key_exists($field, $field_perms)) {
    foreach ($field_perms[$field] as $rid => $data) {
      $perms[$field][] = $data['status'];
    }
  }

  switch ($op) {
    case 'view':
      if (array_key_exists($field, $perms)) {
        return (in_array(LYRIS_FIELD_PERM_VIEW, $perms[$field]) || in_array(LYRIS_FIELD_PERM_EDIT, $perms[$field]));
      }
      break;

    case 'edit':
      if (array_key_exists($field, $perms)) {
        return (in_array(LYRIS_FIELD_PERM_EDIT, $perms[$field]));
      }
      break;
  }
}

/**
 * Prepare a docpart array from a Drupal textfield value.
 */
function lyris_docparts_from_textfield($entity, $field_name) {
  $docparts = array();
  $field = field_get_items('lyris_content', $entity, $field_name);

  if (is_array($field) && !empty($field)) {
    foreach ($field as $instance) {
      // Detect whether this field is rendering or escaping HTML.
      $docpart['Body'] = $instance['value'];
      $docpart['MimePartName'] = lyris_textfield_mimetype($instance);
      $docpart['CharSetID'] = 1;
      $docpart['Encoding'] = 'quoted-printable';

      $docparts[] = $docpart;
    }
  }

  return $docparts;
}

/**
 * Given a textfield determine whether it is text or html from the filters set.
 */
function lyris_textfield_mimetype($instance) {
  $filters = filter_list_format($instance['format']);
  return ($filters ? ($filters['filter_html_escape']->status ? 'text' : 'html') : 'text');
}

/**
 * Log a request to lyris and compare it against the threshold limit to
 * determine whether we should start queuing requests for cron runs.
 *
 * @todo Convert to use Batch API
 */
function lyris_threshold_allow() {
  static $threshold_limit;
  static $threshold_count = 0;

  // If the data hasn't been set, load it.
  if (!is_numeric($threshold_limit)) {
    $threshold_limit = variable_get('lyris_sync_threshold', LYRIS_SYNC_THRESHOLD_DEFAULT);
  }

  // Increment the threshold counter.
  $threshold_count++;

  return ($threshold_count <= $threshold_limit);
}

/**
 * Translate a string to a valid path argument.
 */
function lyris_url_str($str) {
  // Substitute any non-alphanumeric characters for hyphens.
  return preg_replace('/[^a-z0-9]$/i', '-', $str);
}

/**
 * Validate the a string as a machine name.
 */
function lyris_validate_machine_name($element, &$form_state, $form) {
  if (!preg_match('/^[a-z0-9\-\_]+$/', $element['#value'])) {
    form_error($element, t('!title may contain only lowercase alphanumerics, underscores and hyphens.', array('!title' => $element['#title'])));
  }
}

/**
 * Compare two values using the lyris data translator to determine whether they
 * are equal values or not.  This is used mostly for date conversions.
 */
function lyris_values_are_equal($local_value, $lyris_value, $field_name) {
  // Localize fields
  LyrisEntity::translateField($field_name, $lyris_value, 'local');

  return (bool) ($local_value == $lyris_value);
}

/**
 * Form field validator for integer values.
 */
function _lyris_element_validate_integer(&$element) {
  $intval = (int) $element['#value'];

  // Some elements must be an integer if set, but may also be NULL, such as
  // Doc ID references.  If the default is null and they do not have a value,
  // allow validation to pass.
  if (is_null($element['#default_value']) && empty($element['#value'])) {
    return;
  }

  if (!is_numeric($element['#value']) || $intval != $element['#value']) {
    form_error($element, t('!title must be an integer.', array('!title' => $element['#title'])));
  }
}

/**
 * Form field validators for email addresses.
 */
function _lyris_element_validate_email(&$element) {
  if (!empty($element['#value']) && !valid_email_address($element['#value'])) {
    form_error($element, t('The e-mail address %mail is not valid.', array('%mail' => $element['#value'])));
  }
}

/**
 * Lyris options.
 *
 * @param $list
 *   The name of the options list to return.
 * @param $key
 *   Optionally specify a list key to return just the value of that key.
 *
 * @return
 *   Either an array of list options or the value of a specific key of the list
 *   if $key is specified.
 */
function _lyris_options($list, $key = NULL) {
  $ops['lyris_mode'] = array(
    LYRIS_MODE_OFFLINE    => t('Offline'),
    LYRIS_MODE_SANDBOX    => t('Sandbox'),
    LYRIS_MODE_PRODUCTION => t('Production'),
  );
  return ($key && isset($ops[$list][$key]) ? $ops[$list][$key] : $ops[$list]);
}

/**
 * Lyris Local Field
 *
 * Shorthand function to convert Lyris Struct field names to local field names.
 */
function llf($field) {
  return LyrisEntity::fieldConvertLocal($field);
}

/**
 * Lyris Remote Field
 *
 * Shorthand function to convert Lyris Struct field names to the proper remote
 * label.
 */
function lrf($field) {
  return LyrisEntity::fieldConvertRemote($field);
}
