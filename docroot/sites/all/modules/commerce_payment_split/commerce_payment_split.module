<?php
/**
 * @file
 * Allow pay multiple time for an order
 */

/**
 * Implements hook_commerce_checkout_pane_info().
 */
function commerce_payment_split_commerce_checkout_pane_info() {
  $checkout_panes = array();

  $checkout_panes['commerce_payment_split'] = array(
    'title' => t('Prepaid'),
    'page' => 'checkout',
    'file' => 'includes/commerce_payment_split.checkout_pane.inc',
    'weight' => 10,
  );

  return $checkout_panes;
}

/**
 * Implements hook_commerce_price_component_type_info().
 */
function commerce_payment_split_commerce_price_component_type_info() {
  return array(
    'pay_later' => array(
      'title' => t('Pay Later'),
      'weight' => -20,
    ),
  );
}

/**
 * Implements hook_commerce_line_item_type_info().
 */
function commerce_payment_split_commerce_line_item_type_info() {
  $line_item['prepaid'] = array(
    'name' => t('Prepaid'),
    'description' => 'A prepaid line item, apply for order have prepaid',
    'product' => FALSE,
    'add_form_submit_value' => t('Add Prepaid'),
    'base' => 'commerce_payment_split_prepaid',
  );
  return $line_item;
}

/**
 * Configure the line item with additional fields or whatever.
 *
 * This function is called by the line item module when it is enabled or this
 * module is enabled. It invokes this function using the configuration_callback
 * as specified above. Other modules defining product line item types should
 * use this function to ensure their types have the required fields.
 *
 * @param $line_item_type
 *   The info array of the line item type being configured.
 *
 * @see commerce_product_line_item_configuration()
 */
function commerce_payment_split_prepaid_configuration($line_item_type) {
  $type = $line_item_type['type'];
  // Here we could add fields or other configuration.
}

/**
 * Returns a title for this line item.
 */
function commerce_payment_split_prepaid_title($line_item) {
  return t('Prepaid');
}

/**
 * Returns the elements necessary to add a product line item through a line item
 * manager widget (on the order form).
 */
function commerce_payment_split_prepaid_add_form($element, &$form_state) {
  $form = array();
  return $form;
}

/**
 * Adds the selected product information to a line item added via a line item
 *   manager widget (on the admin order page).
 *
 * @param $line_item
 *   The newly created line item object.
 * @param $element
 *   The array representing the widget form element.
 * @param $form_state
 *   The present state of the form upon the latest submission.
 * @param $form
 *   The actual form array.
 *
 * @return
 *   NULL if all is well or an error message if something goes wrong.
 */
function commerce_payment_split_add_form_submit(&$line_item, $element, &$form_state, $form) {
  $line_item->line_item_label = t('Prepaid');

  // Wrap the line item and product to easily set field information.
  $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);

  // Provide a default price.
  $amount = 50000;
  $currency_code = 'USD';

  $line_item->commerce_unit_price = array('und' => array(
    '0' => array('amount' => $amount, 'currency_code' => $currency_code)
  ));

  if (!is_null($line_item_wrapper->commerce_unit_price->value())) {
    // Add the base price to the components array.
    if (!commerce_price_component_load($line_item_wrapper->commerce_unit_price->value(), 'base_price')) {
      $line_item_wrapper->commerce_unit_price->data = commerce_price_component_add(
        $line_item_wrapper->commerce_unit_price->value(),
        'pay_later',
        $line_item_wrapper->commerce_unit_price->value(),
        TRUE,
        FALSE
      );
    }
  }
}

/**
 * Utility function which creates a new example_2 line item populated with the
 * a price of $0.00, etc..
 *
 * @param $order_id
 *   The ID of the order the line item belongs to (if available).
 *
 * @return
 *   The fully loaded line item..
 */
function commerce_payment_split_prepaid_new($order_id = 0, $currency_code = 'USD') {
  $type = 'prepaid';

  // Create the new line item.
  $line_item = entity_create('commerce_line_item', array(
    'type' => $type,
    'order_id' => $order_id,
    'quantity' => 1,
  ));

  // For this example, we'll use a price of USD $0.00 for the "prepaid".
  $amount = 0;

  $line_item->commerce_unit_price = array('und' => array(
    '0' => array('amount' => $amount, 'currency_code' => $currency_code)
  ));

  $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);

  if (!is_null($line_item_wrapper->commerce_unit_price->value())) {
    // Add the base price to the components array.
    if (!commerce_price_component_load($line_item_wrapper->commerce_unit_price->value(), 'base_price')) {
      $line_item_wrapper->commerce_unit_price->data = commerce_price_component_add(
        $line_item_wrapper->commerce_unit_price->value(),
        'pay_later',
        $line_item_wrapper->commerce_unit_price->value(),
        TRUE,
        FALSE
      );
    }
  }
  // Return the line item.
  return $line_item;
}

// There should be one of our example line items on every order, so make sure
// it's there or add it.
function commerce_payment_split_commerce_order_presave($order) {
  // Find out if our order already has an example_2 line item.
  $type_exists = FALSE;
  if (!empty($order->commerce_line_items['und'])) {
    foreach($order->commerce_line_items['und'] as $delta => $line_item_entry) {
      if ($line_item = commerce_line_item_load($line_item_entry['line_item_id'])) {
        if ($line_item->type == 'prepaid') {
          $type_exists = TRUE;
          break;
        }
      }
    }
  }

  // If our line item is not yet in the order and the order has an ID,
  // create a line item to add to the order.
  if (!$type_exists && $order->order_id > 0) {
    $balance = commerce_payment_order_balance($order);
    $line_item = commerce_payment_split_prepaid_new($order->order_id, $balance['currency_code']);
    commerce_line_item_save($line_item);
    $order->commerce_line_items['und'][] = array('line_item_id' => $line_item->line_item_id);
  }
}

/**
 * This function get the raw total of an order
 */
function commerce_payment_split_get_order_base_price_total($order) {
  $wrapper = entity_metadata_wrapper('commerce_order', $order);
  $order_total = $wrapper->commerce_order_total->value();
  $totals = array(
    'amount' => 0,
    'currency_code' => $order_total['currency_code'],
  );
  foreach ($order->commerce_order_total[LANGUAGE_NONE] as $delta => $price) {
    foreach ($price['data']['components'] as $key => $component) {
      if (!empty($component['included']) && $component['name'] == 'base_price') {
        $totals['amount'] += $component['price']['amount'];
      }
    }
  }
  return $totals;
}

function commerce_payment_split_order_balance($order, $totals = array()) {
  $wrapper = entity_metadata_wrapper('commerce_order', $order);
  $order_total = commerce_payment_split_get_order_base_price_total($order);

  // Calculate the transaction totals if not supplied.
  if (empty($totals)) {
    $totals[$order_total['currency_code']] = 0;
    $transaction_statuses = commerce_payment_transaction_statuses();

    foreach (commerce_payment_transaction_load_multiple(array(), array('order_id' => $order->order_id)) as $transaction) {
      // If the payment transaction status indicates it should include the
      // current transaction in the total...
      if ($transaction_statuses[$transaction->status]['total']) {
        // Add the transaction to its currency's running total if it exists...
        if (isset($totals[$transaction->currency_code])) {
          $totals[$transaction->currency_code] += $transaction->amount;
        }
        else {
          // Or begin a new running total for the currency.
          $totals[$transaction->currency_code] = $transaction->amount;
        }
      }
    }
  }

  // Only return a balance if the totals array contains a single matching currency.
  if (count($totals) == 1 && isset($totals[$order_total['currency_code']])) {
    return array('amount' => $order_total['amount'] - $totals[$order_total['currency_code']], 'currency_code' => $order_total['currency_code']);
  }
  else {
    return FALSE;
  }
}

function commerce_payment_split_apply($prepaid, $order) {
  $type_exists = FALSE;
  if (!empty($order->commerce_line_items['und'])) {
    foreach($order->commerce_line_items['und'] as $delta => $line_item_entry) {
      if ($line_item = commerce_line_item_load($line_item_entry['line_item_id'])) {
        if ($line_item->type == 'prepaid') {
          $type_exists = TRUE;
          break;
        }
      }
    }
  }
  // Change price
  if ($type_exists) {
    //$total = commerce_payment_split_get_order_base_price_total($order);
    $balance  = commerce_payment_split_order_balance($order);
    $line_item->commerce_unit_price[LANGUAGE_NONE][0]['amount'] = $prepaid['amount'] - $balance['amount'];
    $line_item->commerce_unit_price[LANGUAGE_NONE][0]['data']['components'][0]['price']['amount'] = $prepaid['amount'] - $balance['amount'];
    commerce_line_item_save($line_item);
  }
}

/**
 * Implements hook_commerce_price_formatted_components_alter().
 */
function commerce_payment_split_commerce_price_formatted_components_alter(&$components, $price, $entity) {
  // If we have pay_later
  if (isset($components['pay_later'])) {
    $balance = commerce_payment_split_order_balance($entity);
    $components['pay_to_day'] = array(
      'title' => t('Pay to date'),
      'price' => array(
        'amount' => $components['base_price']['price']['amount'] - $balance['amount'],
        'currency_code' => $balance['currency_code'],
      ),
      'weight' => $components['pay_later']['weight'] - 10,
    );
    // Change title
    $order_balance = commerce_payment_order_balance($entity);
    $components['commerce_price_formatted_amount']['price']['amount'] = $order_balance['amount'];
    $components['commerce_price_formatted_amount']['title'] = t('Pay now');
  }
}
