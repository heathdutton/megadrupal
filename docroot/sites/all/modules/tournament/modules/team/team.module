<?php

/**
 * @file
 * Implements Teams for Tournaments.
 */

 /**
 * Team join privacy settings.
 */
define('TEAM_JOIN_OFF', 0); // Joining not allowed
define('TEAM_JOIN_AUTO', 1); // Members can join without confirmation
define('TEAM_JOIN_PASS', 2); // Password required to join
define('TEAM_JOIN_CONFIRM', 3); // Team administrator confirmation required

/**
 * Team member roles.
 */
define('TEAM_MEMBER_ROLE_INVITED', 0); // The user has been invited but has not yet accepted
define('TEAM_MEMBER_ROLE_PENDING', 1); // The user applied to join but has not yet been accepted
define('TEAM_MEMBER_ROLE_MEMBER', 2); // The user is a normal member
define('TEAM_MEMBER_ROLE_ADMIN', 6); // The user is a team administrator

/**
 * Implements hook_permission().
 */
function team_permission() {
  return array(
    'administer teams' => array(
      'title' => t('Administer teams'),
      'restrict access' => TRUE,
    ),
    'create team' => array(
      'title' => t('Create new teams'),
    ),
    'access team contents' => array(
      'title' => t('View team contents'),
    ),
  );
}

/**
 * Implements hook_entity_info().
 */
function team_entity_info() {
  $return = array(
    'team' => array(
      'label' => t('Team'),
      'controller class' => 'TeamController',
      'base table' => 'teams',
      'uri callback' => 'team_uri',
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'tid',
        'label' => 'name',
      ),
      'bundles' => array(
        'team' => array(
          'label' => t('Team'),
          'admin' => array(
            'path' => 'admin/config/competition/team',
          ),
        ),
      ),
      'view modes' => array(
        'full' => array(
          'label' => t('Team account'),
          'custom settings' => FALSE,
        ),
        'teaser' => array(
          'label' => t('Teaser'),
          'custom settings' => TRUE,
        ),
      ),
    ),
  );

  return $return;
}

/**
 * Controller class for teams.
 *
 * This extends the DrupalDefaultEntityController class, adding required
 * special handling for team objects.
 */
class TeamController extends DrupalDefaultEntityController {

  protected function attachLoad(&$teams, $revision_id = FALSE) {
    // Set the default value for team members
    foreach ($teams as $tid => $team) {
      $teams[$tid]->members = array();
    }
    // Retrieve team members from the database and add it as an associative
    // array (member uid => member role) to each team.
    $result = db_select('teams_members', 'tm')
      ->condition('tm.tid', array_keys($teams))
      ->fields('tm', array('tid', 'uid', 'role'))
      ->orderBy('role', 'DESC')
      ->execute();

    foreach ($result as $record) {
      $teams[$record->tid]->members[$record->uid] = $record->role;
    }

    // Call the default attachLoad() method. This will add fields and call
    // hook_team_load().
    parent::attachLoad($teams, $revision_id);
  }
}

/**
 * Entity uri callback.
 */
function team_uri($team) {
  return array(
    'path' => 'team/' . $team->tid,
  );
}

/**
 * Loads a team object.
 *
 * @param $tid
 *   Integer specifying the team ID to load.
 * @param $reset
 *   TRUE to reset the internal cache and load from the database; FALSE
 *   (default) to load from the internal cache, if set.
 *
 * @return
 *   A fully-loaded team object upon successful team load, or FALSE if the team
 *   cannot be loaded.
 *
 * @see team_load_multiple()
 */
function team_load($tid, $reset = FALSE) {
  $teams = team_load_multiple(array($tid), array(), $reset);
  return reset($teams);
}

/**
 * Load multiple teams based on certain conditions.
 *
 * This function should be used whenever you need to load more than one team
 * from the database. Teams are loaded into memory and will not require
 * database access if loaded again during the same page request.
 *
 * @param $tids
 *   An array of team IDs.
 * @param $conditions
 *   (deprecated) An associative array of conditions on the {teams}
 *   table, where the keys are the database fields and the values are the
 *   values those fields must have. Instead, it is preferable to use
 *   EntityFieldQuery to retrieve a list of entity IDs loadable by
 *   this function.
 * @param $reset
 *   A boolean indicating that the internal cache should be reset. Use this if
 *   loading a team object which has been altered during the page request.
 *
 * @return
 *   An array of team objects, indexed by tid.
 *
 * @see entity_load()
 * @see team_load()
 * @see team_load_by_name()
 * @see EntityFieldQuery
 *
 * @todo Remove $conditions in Drupal 8.
 */
function team_load_multiple($tids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('team', $tids, $conditions, $reset);
}

/**
 * Fetch a team object by team name.
 *
 * @param $name
 *   String of the team name.
 * @return
 *   A fully-loaded $team object upon successful team load or FALSE if team
 *   cannot be loaded.
 *
 * @see team_load_multiple()
 */
function team_load_by_name($name) {
  $teams = team_load_multiple(array(), array('name' => $name, 'status' => 1));
  return reset($teams);
}

/**
 * Implements hook_field_extra_fields().
 */
function team_field_extra_fields() {
  $extra = array();
  $extra['team']['team'] = array(
    'form' => array(
      'name' => array(
        'label' => t('Name'),
        'description' => t('Team name'),
        'weight' => -5,
      ),
    ),
    'display' => array(
      'members' => array(
        'label' => t('Members'),
        'description' => t('Team member list'),
        'weight' => 1,
      ),
    ),
  );

  return $extra;
}

/**
 * Implements hook_theme().
 */
function team_theme() {
  return array(
    'team' => array(
      'render element' => 'elements',
      'template' => 'team',
    ),
    'team_members_form_members' => array(
      'render element' => 'element',
      'file' => 'team.pages.inc',
    ),
    'team_member_select_show_icon' => array(
    ),
    'team_member_select_hide_icon' => array(
    ),
  );
}

/**
 * Implements hook_menu().
 */
function team_menu() {
  $items['admin/config/competition/team'] = array(
    'title' => 'Teams',
    'description' => 'Configure tournament team settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('team_admin_settings'),
    'access arguments' => array('access administration pages'),
    'file' => 'team.admin.inc',
  );
  $items['admin/config/competition/team/settings'] = array(
    'title' => 'Settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['team/autocomplete'] = array(
    'title' => 'Team autocomplete',
    'page callback' => 'team_autocomplete',
    'access arguments' => array('access team contents'),
    'type' => MENU_CALLBACK,
    'file' => 'team.pages.inc',
  );

  $items['team/add'] = array(
    'title' => 'Create team',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('team_create_form'),
    'access arguments' => array('create team'),
    'file' => 'team.pages.inc',
    'type' => MENU_CALLBACK,
  );
  $items['team/%team'] = array(
    'title callback' => 'team_page_title',
    'title arguments' => array(1),
    'page callback' => 'team_page_view',
    'page arguments' => array(1),
    'access callback' => 'team_view_access',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK,
    'file' => 'team.pages.inc',
  );
  $items['team/%team/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['team/%team/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('team_form', 1),
    'access callback' => 'team_access',
    'access arguments' => array('update', 1),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'file' => 'team.pages.inc',
  );
  $items['team/%team/edit/profile'] = array(
    'title' => 'Profile',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );
  $items['team/%team/edit/members'] = array(
    'title' => 'Manage members',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('team_members_form', 1),
    'access callback' => 'team_access',
    'access arguments' => array('update', 1),
    'type' => MENU_LOCAL_TASK,
    'file' => 'team.pages.inc',
    'weight' => 5,
  );
  $items['team/%team/edit/settings'] = array(
    'title' => 'Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('team_settings_form', 1),
    'access callback' => 'team_access',
    'access arguments' => array('update', 1),
    'type' => MENU_LOCAL_TASK,
    'file' => 'team.pages.inc',
    'weight' => 10,
  );
  $items['team/%team/edit/members/invite'] = array(
    'title' => 'Invite new member',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('team_member_invite_form', 1),
    'access callback' => 'team_access',
    'access arguments' => array('update', 1),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'team.pages.inc',
  );
  $items['team/%team/edit/members/add'] = array(
    'title' => 'Add new member',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('team_member_add_form', 1),
    'access arguments' => array('administer teams'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'team.pages.inc',
    'weight' => 5,
  );
  $items['team/%team/edit/members/%/remove'] = array(
    'title' => 'Remove member',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('team_member_remove_confirm', 1, 4),
    'access callback' => '_team_member_remove_access',
    'access arguments' => array(1, 4),
    'type' => MENU_CALLBACK,
    'file' => 'team.pages.inc',
  );
  $items['team/%team/join'] = array(
    'title' => 'Join team',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('team_member_join_form', 1),
    'access callback' => '_team_member_join_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'team.pages.inc',
  );
  $items['team/%team/invite/respond'] = array(
    'title' => 'Respond to invite',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('team_member_invite_respond_form', 1),
    'access callback' => '_team_member_invite_respond_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'team.pages.inc',
  );
  $items['team/%team/leave'] = array(
    'title' => 'Leave Team',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('team_member_leave_confirm', 1),
    'access callback' => 'team_is_member',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'team.pages.inc',
    'weight' => 10,
  );
  $items['team/%team/cancel'] = array(
    'title' => 'Cancel',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('team_cancel_confirm', 1),
    'access callback' => 'team_access',
    'access arguments' => array('cancel', 1),
    'type' => MENU_CALLBACK,
    'file' => 'team.pages.inc',
  );
  $items['team/%team/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('team_delete_confirm', 1),
    'access callback' => 'team_access',
    'access arguments' => array('delete', 1),
    'type' => MENU_CALLBACK,
    'file' => 'team.pages.inc',
  );

  if (module_exists('match')) {
    $items['team/%team/challenge'] = array(
      'title' => 'Challenge Team',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('match_challenge_form', 'team', 1),
      'access callback' => 'match_challenge_access',
      'access arguments' => array('team', 1),
      'type' => MENU_LOCAL_ACTION,
      'file' => 'match.pages.inc',
      'file path' => drupal_get_path('module', 'match'),
    );
  }

  $items['node/%node/team_member_select/%/%/%'] = array(
    'title' => 'Show team members',
    'page callback' => 'team_member_select_expand',
    'page arguments' => array(1, 3, 4, 5),
    'access callback' => 'tournament_participants_exist',
    'access arguments' => array(1, 3),
    'file' => 'team.pages.inc',
    'type' => MENU_CALLBACK,
  );
  $items['node/%node/team_member_update/%/%'] = array(
    'title' => 'Team member update request',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('team_member_select_update_form', 1, 3, 4),
    'access callback' => '_team_member_select_update_access',
    'access arguments' => array(1, 3, 4),
    'file' => 'team.pages.inc',
    'type' => MENU_CALLBACK,
  );
  $items['node/%node/edit/participants/%/members'] = array(
    'title' => 'Edit members',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('team_tournament_participant_members_form', 1, 4),
    'access callback' => '_team_tournament_participant_members_access',
    'access arguments' => array(1, 4),
    'type' => MENU_CALLBACK,
    'file' => 'team.pages.inc',
  );

  return $items;
}

/**
 * Access callback for updating selected team tournament members
 */
function _team_member_select_update_access($node, $id, $uid) {
  if (tournament_update_access($node)) {
    return TRUE;
  }

  if (!tournament_participants_exist($node, $id)) {
    return FALSE;
  }

  $result = db_select('teams_tournaments_members', 'ttm')
    ->condition('nid', $node->nid)
    ->condition('tid', $id)
    ->condition('uid', $uid)
    ->countQuery()
    ->execute()
    ->fetchField();

  if (empty($result)) {
    // No team tournament member found
    return FALSE;
  }
}

/**
 * Team view access callback.
 *
 * @param $team
 *   Can either be a full team object or a $tid.
 */
function team_view_access($team) {
  if (user_access('access team contents')) {
    // At this point, load the complete team object.
    if (!is_object($team)) {
      $team = team_load($team);
    }

    return (is_object($team) && $team->status);
  }

  return FALSE;
}

/**
 * Menu access callback for the removal of team members
 */
function _team_member_remove_access($team, $uid) {
  return array_key_exists($uid, $team->members) && team_access('update', $team);
}

/**
 * Menu access callback for the responding of team invitations
 */
function _team_member_invite_respond_access($team) {
  global $user;

  // Check user is in the team and has been invited
  return array_key_exists($user->uid, $team->members) && $team->members[$user->uid] == TEAM_MEMBER_ROLE_INVITED;
}

/**
 * Menu access callback for the joining of team members
 */
function _team_member_join_access($team) {
  global $user;

  // Team account has been canceled
  if (!$team->status) {
    return FALSE;
  }

  // Users must not be part of the team already
  if (array_key_exists($user->uid, $team->members)) {
    return FALSE;
  }

  // Joining is disabled by the team admin
  if ($team->joining == TEAM_JOIN_OFF) {
    return FALSE;
  }

  // Joining is disabled globally
  if (!variable_get('team_joining', 1)) {
    return FALSE;
  }

  return user_access('access team contents');
}

/**
 * Access callback to ensure a given user is an active member
 * of a given team.
 */
function team_is_member($team, $account = NULL) {
  if (empty($account)) {
    $account = $GLOBALS['user'];
  }

  // Team account has been canceled
  if (!$team->status) {
    return FALSE;
  }

  $members = _team_members_active($team);
  return array_key_exists($account->uid, $members) && user_access('access team contents');
}

/**
 * Access callback for tournament participant members callback
 */
function _team_tournament_participant_members_access($node, $id) {
  if (!tournament_supported_type($node->type) || $node->entity_type != 'team') {
    return FALSE;
  }

  if (empty($node->member_select) || !tournament_participants_exist($node, $id)) {
    return FALSE;
  }

  if (tournament_update_access($node)) {
    // Tournament admins can edit anybodys members
    return TRUE;
  }

  // Ensure the user has access over the given team
  $team = team_load($id);
  return team_access('update', $team);
}

/**
 * Determine whether the current user may perform the given operation on the
 * specified team.
 *
 * @param $op
 *   The operation to be performed on the team. Possible values are:
 *   - "update"
 *   - "delete"
 * @param $team
 *   The team object on which the operation is to be performed
 * @param $account
 *   Optional, a user object representing the user for whom the operation is to
 *   be performed. Determines access for a user other than the current user.
 * @return
 *   TRUE if the operation may be performed, FALSE otherwise.
 */
function team_access($op, $team, $account = NULL) {
  $team_access = &drupal_static(__FUNCTION__, array());

  if (!$team || !in_array($op, array('update', 'delete', 'cancel'), TRUE)) {
    // If there was no team to check against, or the $op was not one of the
    // supported ones, we return access denied.
    return FALSE;
  }
  // If no user object is supplied, the access check is for the current user.
  if (empty($account)) {
    $account = $GLOBALS['user'];
  }

  if (!$account->uid) {
    return FALSE;
  }

  // $team may be either an object or a team tid. Team tid will become the static cache cid.
  $cid = $team->tid;

  // If we've already checked access for this team, user and op, return from cache.
  if (isset($team_access[$account->uid][$cid][$op])) {
    return $team_access[$account->uid][$cid][$op];
  }

  // If the user holds the privileged permission, return true
  if (user_access('administer teams', $account)) {
    $team_access[$account->uid][$cid][$op] = TRUE;
    return TRUE;
  }

  switch ($op) {
    case 'update':
    case 'cancel':
      if (isset($team->members[$account->uid])) {
        // Only available to team admins
        $team_access[$account->uid][$cid][$op] = $team->members[$account->uid] == TEAM_MEMBER_ROLE_ADMIN;
      }
      else {
        $team_access[$account->uid][$cid][$op] = FALSE;
      }
      break;
    default:
      // Only users with 'administer teams' access should be able to perform other
      // ops not listed here. (i.e. 'delete')
      $team_access[$account->uid][$cid][$op] = FALSE;
  }

  return $team_access[$account->uid][$cid][$op] && $team->status;
}

/**
 * Implements hook_match_participants_access_list().
 */
function team_match_participants_access_list($entity_type, $account, $admin = TRUE) {
  if ($entity_type == 'team') {
    $role = $admin ? TEAM_MEMBER_ROLE_ADMIN : NULL;
    $users = team_load_user_teams(array($account->uid), $role);
    if (!empty($users)) {
      return $users[$account->uid];
    }
  }
}

/**
 * Implements hook_match_challenge_access().
 */
function team_match_challenge_access($entity_type, $entity) {
  if ($entity_type == 'team') {
    global $user;

    // Team account has been canceled
    if (!$entity->status) {
      return MATCH_CHALLENGE_ACCESS_DENIED;
    }

    // Team challenging is globally disabled
    if (!variable_get('team_challenging', 1)) {
      return MATCH_CHALLENGE_ACCESS_DENIED;
    }

    // Current user is a member of the opponent
    if (isset($entity->members[$user->uid])) {
      return MATCH_CHALLENGE_ACCESS_DENIED;
    }
  }
}

/**
 * Implements hook_match_participants_extract().
 */
function team_match_participants_extract($entity_type, $entity, $access = FALSE) {
  if ($entity_type == 'team') {
    $members = array();

    if (!$access) {
      $required = array(TEAM_MEMBER_ROLE_MEMBER, TEAM_MEMBER_ROLE_ADMIN);
    }
    else {
      $required = array(TEAM_MEMBER_ROLE_ADMIN);
    }

    foreach ($entity->members as $uid => $role) {
      if (in_array($role, $required)) {
        $members[] = $uid;
      }
    }

    return $members;
  }
}

/**
 * Implements hook_tournament_participants_count().
 */
function team_tournament_participants_count($entity_type, $ids) {
  if ($entity_type == 'team') {
    $count = db_select('teams_members', 'tm')
      ->condition('tid', $ids)
      ->condition('role', TEAM_MEMBER_ROLE_MEMBER, '>=')
      ->countQuery()
      ->execute()
      ->fetchField();

    return $count;
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 *
 * @see tournament_form()
 */
function team_form_node_form_alter(&$form, &$form_state, $form_id) {
  $node = $form_state['node'];

  if (tournament_supported_type($node->type)) {
    $entity_types = match_entity_types_list();
    if (isset($entity_types['team'])) {
      if (!empty($node->entity_type) && $node->entity_type == 'team') {
        $form['general']['structure']['#options'] = _team_tournament_sizes();
        $form['general']['structure']['#default_value'] = $node->min_team_size;
        // We cannot switch back to a 1v1 tournament
        unset($form['general']['structure']['#options'][1]);
      }
      elseif (empty($node->nid)) {
        $form['general']['structure']['#options'] += _team_tournament_sizes();
      }

      $form['signup']['settings']['multiple_signup'] = array(
        '#type' => 'checkbox',
        '#title' => t('Users can participate in multiple teams in this tournament at the same time'),
        '#default_value' => isset($node->multiple_signup) ? $node->multiple_signup : 0,
        '#states' => array(
          // Show this field only when the participant type is team
          'invisible' => array(
            ':input[name="structure"]' => array('value' => '1'),
          ),
        ),
        '#weight' => 10,
        '#access' => variable_get('team_multiple_signup', 1),
      );
      $form['signup']['settings']['member_select'] = array(
        '#type' => 'checkbox',
        '#title' => t('Require selection of team members'),
        '#default_value' => isset($node->member_select) ? $node->member_select : 0,
        '#weight' => 15,
        '#states' => array(
          // Show this field only when the participant type is team
          'invisible' => array(
            ':input[name="structure"]' => array('value' => '1'),
          ),
        ),
      );

      // Force hide team elements when the tournament is already a user type.
      if (!empty($node->entity_type) && $node->entity_type == 'user') {
        $form['signup']['settings']['multiple_signup']['#access'] = FALSE;
        $form['signup']['settings']['member_select']['#access'] = FALSE;
      }
    }
  }
}

/**
 * Implements hook_node_load().
 */
function team_node_load($nodes, $types) {
  $tournament_type = FALSE;

  // We use $types to check for this to keep the function as
  // light as we can.
  foreach ($types as $type) {
    if (tournament_supported_type($type)) {
      $tournament_type = TRUE;
    }
  }
  // There is no node types that we care about here so return.
  if (!$tournament_type) {
    return;
  }

  $nids = array();
  foreach ($nodes as $node) {
    if (isset($node->entity_type) && tournament_supported_type($node->type) && $node->entity_type == 'team') {
      // Add nid to list and add min_team_size?
      $nids[] = $node->nid;
    }
  }

  if (!empty($nids)) {
    $result = db_select('teams_tournaments', 'tt')
      ->fields('tt')
      ->condition('nid', $nids, 'IN')
      ->execute();

    foreach ($result as $field) {
      $nodes[$field->nid]->min_team_size = $field->min_team_size;
      $nodes[$field->nid]->multiple_signup = $field->multiple_signup;
      $nodes[$field->nid]->member_select = $field->member_select;
    }
  }
}

/**
 * Implements hook_node_presave().
 */
function team_node_presave($node) {
  if (tournament_supported_type($node->type) && !empty($node->structure) && $node->structure > 1) {
    $node->entity_type = 'team';
    $node->min_team_size = $node->structure;
  }
}

/**
 * Implements hook_node_insert().
 */
function team_node_insert($node) {
  if (tournament_supported_type($node->type) && $node->entity_type == 'team') {
    team_tournment_save($node);
  }
}

/**
 * Implements hook_node_update().
 */
function team_node_update($node) {
  if (tournament_supported_type($node->type) && $node->entity_type == 'team') {
    team_tournment_save($node, TRUE);
  }
}

/**
 * Save team tournament details.
 */
function team_tournment_save($node, $update = FALSE) {
  $primary_keys = $update ? 'nid' : array();
  drupal_write_record('teams_tournaments', $node, $primary_keys);
}

/**
 * Implements hook_node_delete().
 */
function team_node_delete($node) {
  if (tournament_supported_type($node->type)) {
    db_delete('teams_tournaments')->condition('nid', $node->nid)->execute();
  }
}

/**
 * Implements hook_tournament_list_participants_alter().
 */
function team_tournament_list_participants_alter(&$data, $node) {
  if (!empty($node->entity_type) && $node->entity_type == 'team' && !empty($node->member_select)) {
    if (!empty($data['participants']['#items'])) {
      $icon = theme('team_member_select_show_icon');

      foreach ($data['participants']['#items'] as $id => &$item) {
        $link = l($icon, 'node/' . $node->nid . '/team_member_select/' . $id . '/show/nojs', array('html' => TRUE, 'attributes' => array('class' => array('use-ajax', 'team-member-select-show-icon'))));
        $item['data'] .= ' ' . $link;
      }
    }
  }
}

/**
 * Implements hook_node_view().
 */
function team_node_view($node, $view_mode, $langcode) {
  if ($view_mode == 'full' && !empty($node->entity_type) && $node->entity_type == 'team') {
    if ($node->type == 'match') {
      // Match module provides us with a match page view mode
      if (count($node->participants) == 2) {
        $ids = array_keys($node->participants);

        // Ensure only existent entites are shown
        if (!empty($node->participants[$ids[0]]['entity'])) {
          $a = team_view($node->participants[$ids[0]]['entity'], 'match');
        }
        if (!empty($node->participants[$ids[1]]['entity'])) {
          $b = team_view($node->participants[$ids[1]]['entity'], 'match');
        }

        $node->content['match']['#rows']['score']['a']['data'] .= drupal_render($a);
        $node->content['match']['#rows']['score']['b']['data'] .= drupal_render($b);
      }
    }
    elseif (tournament_supported_type($node->type) && !empty($node->member_select)) {
      if (tournament_update_access($node)) {
        $result = db_select('teams_tournaments_members', 'ttm')
          ->fields('ttm', array('tid', 'uid', 'created'))
          ->condition('nid', $node->nid)
          ->condition('status', 0)
          ->execute();

        foreach ($result as $record) {
          $team = team_load($record->tid);
          $account = user_load($record->uid);

          $string = t('!team requested to add member !account to their member list at: @time.',
            array('!team' => l($team->name, 'team/' . $team->tid),
                  '!account' => theme('username', array('account' => $account)),
                  '@time' => format_date($record->created)));
          $string .= ' - ' . l(t('Respond'), 'node/' . $node->nid . '/team_member_update/' . $team->tid . '/' . $account->uid);
          drupal_set_message($string, 'warning');
        }
      }
    }
  }
}

/**
 * An array of team tournament members
 *
 * @param $node
 *   A tournament node object.
 * @param $id
 *   A team tid
 */
function team_tournaments_members($node, $id, $status = 1) {
  $result = db_select('teams_tournaments_members', 'ttm')
    ->fields('ttm', array('uid', 'status'))
    ->condition('nid', $node->nid)
    ->condition('tid', $id)
    ->condition('status', $status, '>=')
    ->execute()
    ->fetchAllKeyed(0,1);

  return $result;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function team_form_match_challenge_form_alter(&$form, &$form_state, $form_id) {
  $entity = $form_state['entity'];
  if (!empty($entity->challenge_info)) {
    $form['challenge_info'] =	array(
      '#type' => 'item',
      '#title' => t('Challenge message from @name', array('@name' => $entity->name)),
      '#markup' => filter_xss($entity->challenge_info),
      '#weight' => -5,
    );
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function team_form_tournament_signup_form_alter(&$form, &$form_state, $form_id) {
  if (isset($form_state['node'])) {
    $node = $form_state['node'];
    if ($node->entity_type == 'team') {
      $form['#validate'][] = 'team_tournament_signup_form_validate';

      // Member selection form
      if (!empty($node->member_select)) {
        $form['#submit'][] = 'team_tournament_signup_form_submit';

        if ($form['id']['#type'] == 'value') {
          // There is only 1 team available
          $team = team_load($form['id']['#value']);
        }
        elseif ($form['id']['#type'] == 'select') {
          // Multiple teams available, add our ajax
          $form['id']['#ajax'] = array(
            'callback' => 'team_member_select_callback',
            'wrapper' => 'team-members-wrapper',
            'method' => 'replace',
            'effect' => 'fade',
          );

          if (!empty($form_state['values']['id'])) {
            // A team has been selected
            $team = team_load($form_state['values']['id']);
          }
          else {
            $team = team_load($form['id']['#default_value']);
          }
        }

        if (!empty($team)) {
          $form['members'] = array(
            '#type' => 'checkboxes',
            '#title' => t('Members'),
            '#prefix' => '<div id="team-members-wrapper">',
            '#suffix' => '</div>',
            '#options' => team_member_select_options($team),
          );
        }
      }
    }
  }
}

/**
 * Ajax callback to update the team id
 */
function team_member_select_callback($form, $form_state) {
  return $form['members'];
}

/**
 * Build an array of team members for use in form selects
 */
function team_member_select_options($team) {
  // Load all members
  $members = _team_members_active($team);
  $accounts = user_load_multiple(array_keys($members));

  $options = array();
  foreach ($accounts as $uid => $account) {
    $options[$uid] = format_username($account);
  }

  return $options;
}

/**
 * Validate handler for the tournament sign up form.
 *
 * @see tournament_signup_form()
 */
function team_tournament_signup_form_validate($form, &$form_state) {
  $node = $form_state['node'];
  $team = team_load($form_state['values']['id']);

  // Set members to validate
  if (!empty($node->member_select)) {
    $members = $form_state['values']['members'];
    foreach ($members as $uid => $status) {
      if (!$status) {
        unset($members[$uid]);
        unset($form_state['values']['members'][$uid]); // Used in submit handler
      }
    }
  }
  else {
    $members = _team_members_active($team);
  }

  if (empty($members)) {
    form_set_error('members', t('No team members selected.'));
  }
  // Do not allow team members to participate in multiple teams
  elseif (empty($node->multiple_signup)) {
    $uids = array_keys($members);

    $query = db_select('tournament_participants', 'p');
    $query->join('teams', 't', 'p.id = t.tid');
    $query->join('teams_members', 'tm', 't.tid = tm.tid');

    $result = $query->fields('tm', array('uid'))
      ->condition('p.nid', $node->nid)
      ->condition('p.status', 1)
      ->condition('t.status', 1)
      ->condition('tm.uid', $uids)
      ->execute();

    foreach ($result as $record) {
      $account = user_load($record->uid);
      form_set_error('id', t('Team member %name is already present in another team participating in this tournament. Users are not allowed to be in multiple teams that participate in the same tournament.', array('%name' => $account->name)));
    }
  }

  // Minimum member count validation
  if (!empty($node->min_team_size)) {
    if (count($members) < $node->min_team_size) {
      form_set_error('id', t('Your team requires at least @team_size members to sign up for this tournament.', array('@team_size' => $node->min_team_size)));
    }
  }

  if (!empty($node->signup_role)) {
    $uids = array_keys($members);
    $accounts = user_load_multiple($uids);

    $role = user_role_load($node->signup_role);

    foreach ($accounts as $account) {
      if (!in_array($role->name, $account->roles)) {
        form_set_error('id', t('Member @account must have user role %name to sign up to this tournament.', array('@account' => $account->name, '%name' => $role->name)));
      }
    }
  }
}

/**
 * Submit handler for the tournament sign up form.
 * Add custom team member select data.
 *
 * @see tournament_signup_form()
 */
function team_tournament_signup_form_submit($form, &$form_state) {
  $node = $form_state['node'];
  $members = $form_state['values']['members'];
  $tid = $form_state['values']['id'];

  $query = db_insert('teams_tournaments_members')
    ->fields(array('nid', 'tid', 'uid', 'status', 'created'));

  foreach ($members as $uid => $status) {
    $query->values(array('nid' => $node->nid, 'tid' => $tid, 'uid' => $uid, 'status' => 1, 'created' => REQUEST_TIME));
  }

  $query->execute();
}

/**
 * Invokes hook_tournament_participant_delete().
 */
function team_tournament_participant_delete($id, $node, $old_state) {
  if ($node->entity_type == 'team') {
    db_delete('teams_tournaments_members')
      ->condition('tid', $id)
      ->condition('nid', $node->nid)
      ->execute();
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function team_form_tournament_participant_add_form_alter(&$form, &$form_state, $form_id) {
  if (isset($form_state['node'])) {
    $node = $form_state['node'];
    if ($node->entity_type == 'team') {
      $form['participant']['#element_validate'][] = 'team_tournament_participant_add_team_validate';
      $form['participant']['#autocomplete_path'] = 'team/autocomplete';
    }
  }
}

/**
 * Element validation handler for user participants
 */
function team_tournament_participant_add_team_validate($element, &$form_state, $form) {
  if (!$entity = team_load_by_name($form_state['values']['participant'])) {
    form_set_error('participant', t('Team not found'));
  }
  else {
    // Store for use in submit handler
    $form_state['entity'] = $entity;
  }
}

/**
 * Title callback for team_page_view().
 */
function team_page_title($team) {
  return $team->name;
}

/**
 * Gather team IDs and the respective roles that the given
 * users are members of.
 *
 * @param $users
 *   An array of user objects.
 * @param $role
 *   Optional, use this to only return users of a specific member
 *   role.
 *
 * @return array
 *   An associative array of team ids keyed by user id
 */
function team_load_user_teams($uids, $role = NULL) {
  // Set the default value for user teams
  foreach ($uids as $uid) {
    $teams[$uid] = array();
  }

  $query = db_select('teams_members', 'tm');
  $query->join('teams', 't', 'tm.tid = t.tid');

  $result = $query->fields('tm', array('tid', 'uid', 'role'))
    ->condition('tm.uid', $uids)
    ->condition('t.status', 1)
    ->execute();

  $teams = array();
  foreach ($result as $record) {
    if (!isset($role)) {
      $teams[$record->uid][] = $record->tid;
    }
    elseif ($role == $record->role) {
      $teams[$record->uid][] = $record->tid;
    }
  }

  return $teams;
}

/**
 * Implements hook_user_view()
 */
function team_user_view($account, $view_mode, $langcode) {
  if ($view_mode == 'full' && variable_get('team_user_list', 1)) {
    $tids = team_load_user_teams(array($account->uid));

    if (!empty($tids[$account->uid])) {
      $teams = team_load_multiple($tids[$account->uid]);

      $items = array();
      foreach ($teams as $team) {
        if (!empty($team->status) && $team->members[$account->uid] >= TEAM_MEMBER_ROLE_MEMBER) {
          $items[$team->tid] = l($team->name, 'team/' . $team->tid);
        }
      }

      // Show a list of active teams on the user profile
      $account->content['teams'] = array(
        '#prefix' => '<div class="teams">',
        '#suffix' => '</div>',
        '#theme' => 'item_list',
        '#items' => $items,
        '#title' => t('Teams'),
      );
    }
  }
}

/**
 * Implements hook_user_delete().
 */
function team_user_delete($account) {
  team_member_delete_user($account);
}

/**
 * Implements hook_user_cancel().
 */
function team_user_cancel($edit, $account, $method) {
  team_member_delete_user($account);
}

function team_member_delete_user($account) {
  db_delete('teams_members')
    ->condition('uid', $account->uid)
    ->execute();

  db_delete('teams_tournaments_members')
    ->condition('uid', $account->uid)
    ->execute();
}

/**
 * Implements hook_block_info().
 */
function team_block_info() {
  $blocks['my_teams'] = array(
    'info' => t('My teams'),
    'cache' => DRUPAL_CACHE_PER_USER,
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function team_block_view($delta = '') {
  $block = array();

  switch ($delta) {
    case 'my_teams':
      $block['subject'] = t('My teams');
      $block['content'] = team_build_my_teams();
      break;
  }

  return $block;
}

/**
 * Builds a renderable array of links to teams that
 * the given user is an active member of.
 *
 * @param $account
 *   Optional, A user object for who to return teams for.
 *
 * @return
 *   A renderable array of links.
 */
function team_build_my_teams($account = NULL) {
  $build = array();

  if (empty($account)) {
    $account = $GLOBALS['user'];
  }

  $tids = team_load_user_teams(array($account->uid));

  if (!empty($tids[$account->uid])) {
    $teams = team_load_multiple($tids[$account->uid]);

    $links = array();
    foreach ($teams as $team) {
      if (!empty($team->status) && $team->members[$account->uid] >= TEAM_MEMBER_ROLE_MEMBER) {
        $links['team-' . $team->tid] = array(
          'title' => $team->name,
          'href' => 'team/' . $team->tid,
          'team' => $team,
        );
      }
    }

    $build = array(
      '#theme' => 'links',
      '#links' => $links,
    );
  }

  return $build;
}

/**
 * Implements hook_search_info().
 */
function team_search_info() {
  return array(
    'title' => 'Teams',
    'path' => 'team',
  );
}

/**
 * Implements hook_search_access().
 */
function team_search_access() {
  return user_access('access team contents');
}

/**
 * Implements hook_search_execute().
 */
function team_search_execute($keys = NULL, $conditions = NULL) {
  // Replace wildcards with MySQL/PostgreSQL wildcards.
  $keys = preg_replace('!\*+!', '%', $keys);
  $query = db_select('teams')->extend('PagerDefault');
  $query->fields('teams', array('tid'));

  // Search on team name
  $query->condition('name', '%' . db_like($keys) . '%', 'LIKE');

  $tids = $query
    ->condition('status', 1)
    ->limit(variable_get('team_list_limit', 10))
    ->execute()
    ->fetchCol();

  $teams = team_load_multiple($tids);
  $builds = team_view_multiple($teams, 'teaser');

  $results = array();

  foreach ($teams as $team) {
    $build = $builds['teams'][$team->tid];
    unset($build['#theme']);
    $team->rendered = drupal_render($build);

    $extra = module_invoke_all('team_search_result', $team);

    $result = array(
      'title' => $team->name,
      'link' => url('team/' . $team->tid, array('absolute' => TRUE)),
      'snippet' => search_excerpt($keys, $team->rendered),
    );

    $results[] = $result;
  }

  return $results;
}

/**
 * Save changes to a team or add a new team.
 *
 * @param $team
 *   The $team object to be saved. If $team->tid is
 *   omitted (or $team->is_new is TRUE), a new team will be added.
 */
function team_save($team) {
  $transaction = db_transaction();

  try {
    // Load the stored entity, if any.
    if (!empty($team->tid) && !isset($team->original)) {
      $team->original = entity_load_unchanged('team', $team->tid);
    }

    // Avoid the storing of an empty field
    if (empty($team->join_pass)) {
      unset($team->join_pass);
    }
    else {
      // Hash the join team password
      require_once DRUPAL_ROOT . '/' . variable_get('password_inc', 'includes/password.inc');
      $team->join_pass = user_hash_password(trim($team->join_pass));
      // Abort if the hashing failed and returned FALSE.
      if (!$team->join_pass) {
        return FALSE;
      }
    }

    field_attach_presave('team', $team);

    // Determine if we will be inserting a new team.
    if (!isset($team->is_new)) {
      $team->is_new = empty($team->tid);
    }

    // Set the timestamp fields.
    if (empty($team->created)) {
      $team->created = REQUEST_TIME;
    }
    // The changed timestamp is always updated for bookkeeping purposes,
    // for example: revisions, searching, etc.
    $team->changed = REQUEST_TIME;

    // Let modules modify the team before it is saved to the database.
    module_invoke_all('team_presave', $team);
    module_invoke_all('entity_presave', $team, 'team');

    // Save the team
    if ($team->is_new) {
      // For new teams, save new records for the team
      drupal_write_record('teams', $team);
      $op = 'insert';

      // Add the author as the first member
      global $user;
      team_member_insert($team, $user, TEAM_MEMBER_ROLE_ADMIN);
    }
    else {
      // For existing teams, update the team record
      drupal_write_record('teams', $team, 'tid');
      $op = 'update';
    }

    // Save fields.
    $function = "field_attach_$op";
    $function('team', $team);

    module_invoke_all('team_' . $op, $team);
    module_invoke_all('entity_' . $op, $team, 'team');

    // Clear internal properties.
    unset($team->is_new);
    unset($team->original);
    // Clear the static loading cache.
    entity_get_controller('team')->resetCache(array($team->tid));

    // Ignore slave server temporarily to give time for the
    // saved team to be propagated to the slave.
    db_ignore_slave();
  }
  catch (Exception $e) {
    $transaction->rollback();
    watchdog_exception('team', $e);
    throw $e;
  }
}


/**
 * Generate an array for rendering the given team.
 *
 * @param $team
 *   A team object.
 * @param $view_mode
 *   View mode, e.g. 'full', 'teaser'...
 * @param $langcode
 *   (optional) A language code to use for rendering. Defaults to the global
 *   content language of the current request.
 *
 * @return
 *   An array as expected by drupal_render().
 */
function team_view($team, $view_mode = 'teaser', $langcode = NULL) {
  if (!isset($langcode)) {
    $langcode = $GLOBALS['language_content']->language;
  }

  // Populate $team->content with a render() array.
  team_build_content($team, $view_mode, $langcode);

  $build = $team->content;
  // We don't need duplicate rendering info in team->content.
  unset($team->content);

  $build += array(
    '#theme' => 'team',
    '#team' => $team,
    '#view_mode' => $view_mode,
    '#language' => $langcode,
  );

  // Allow modules to modify the structured team.
  $type = 'team';
  drupal_alter(array('team_view', 'entity_view'), $build, $type);

  return $build;
}

/**
 * Returns whether the current page is the full page view of the passed-in team.
 *
 * @param $team
 *   A team object.
 */
function team_is_page($team) {
  $page_team = menu_get_object('team');
  return (!empty($page_team) ? $page_team->tid == $team->tid : FALSE);
}

/**
 * Process variables for team.tpl.php
 *
 * Themes can utilize their own copy of team.tpl.php. The default is located
 * inside "modules/team/team.tpl.php". Look in there for the full list of
 * variables.
 *
 * The $variables array contains the following arguments:
 * - $team
 * - $view_mode
 * - $page
 *
 * @see team.tpl.php
 */
function template_preprocess_team(&$variables) {
  $team = $variables['team'] = $variables['elements']['#team'];

  $variables['view_mode'] = $variables['elements']['#view_mode'];
  // Provide a distinct $teaser boolean.
  $variables['teaser'] = $variables['view_mode'] == 'teaser';
  $variables['page'] = $variables['view_mode'] == 'full' && team_is_page($team);

  $variables['date'] = format_date($team->created);
  $variables['name'] = theme('username', array('account' => $team));

  $uri = entity_uri('team', $team);
  $variables['team_url'] = url($uri['path'], $uri['options']);
  $variables['name'] = check_plain($team->name);

  // Flatten the team object's member fields.
  $variables = array_merge((array) $team, $variables);

  // Helpful $content variable for templates.
  $variables += array('content' => array());
  foreach (element_children($variables['elements']) as $key) {
    $variables['content'][$key] = $variables['elements'][$key];
  }

  // Make the field variables available with the appropriate language.
  field_attach_preprocess('team', $team, $variables['elements'], $variables);

  // Gather team classes.
  $variables['classes_array'][] = drupal_html_class('team-' . $team->tid);
  if ($variables['teaser']) {
    $variables['classes_array'][] = 'team-teaser';
  }

  // Clean up name so there are no underscores.
  $variables['theme_hook_suggestions'][] = 'team__' . $team->tid;
}

/**
 * Construct a drupal_render() style array from an array of loaded teams.
 *
 * @param $teams
 *   An array of teams as returned by team_load_multiple().
 * @param $view_mode
 *   View mode, e.g. 'full', 'teaser'...
 * @param $weight
 *   An integer representing the weight of the first team in the list.
 *
 * @return
 *   An array in the format expected by drupal_render().
 */
function team_view_multiple($teams, $view_mode = 'teaser', $weight = 0, $langcode = NULL) {
  field_attach_prepare_view('team', $teams, $view_mode, $langcode);
  entity_prepare_view('team', $teams, $langcode);
  $build = array();
  foreach ($teams as $team) {
    $build['teams'][$team->tid] = team_view($team, $view_mode, $langcode);
    $build['teams'][$team->tid]['#weight'] = $weight;
    $weight++;
  }
  $build['teams']['#sorted'] = TRUE;
  return $build;
}

/**
 * Builds a structured array representing the teams's content.
 *
 * The content built for the team (field values, comments, file attachments or
 * other team components) will vary depending on the $view_mode parameter.
 *
 * @param $team
 *   A team object.
 * @param $view_mode
 *   View mode, e.g. 'full', 'teaser'...
 * @param $langcode
 *   (optional) A language code to use for rendering. Defaults to the global
 *   content language of the current request.
 */
function team_build_content($team, $view_mode = 'full', $langcode = NULL) {
  if (!isset($langcode)) {
    $langcode = $GLOBALS['language_content']->language;
  }

  // Remove previously built content, if exists.
  $team->content = array();

  // Build fields content.
  // In case of a multiple view, team_view_multiple() already ran the
  // 'prepare_view' step. An internal flag prevents the operation from running
  // twice.
  field_attach_prepare_view('team', array($team->tid => $team), $view_mode, $langcode);
  entity_prepare_view('team', array($team->tid => $team), $langcode);
  $team->content += field_attach_view('team', $team, $view_mode, $langcode);

  if (!empty($team->members)) {
    $members = _team_members_active($team);
    $users = entity_load('user', array_keys($members));

    $items = array();
    foreach ($members as $uid => $role) {
      if (isset($users[$uid])) {
        $member = '';
        if (variable_get('team_user_picture', 0)) {
          $member = theme('user_picture', array('account' => $users[$uid]));
        }
        $member .= theme('username', array('account' => $users[$uid]));

        if ($role == TEAM_MEMBER_ROLE_ADMIN) {
          $member .= ' (' . t('Admin') . ')';
        }

        $items[] = $member;
      }
    }

    // Show count for regular members, and provide link to edit membership for admins
    $title = t('Members (@count)', array('@count' => count($members)));
    $title = team_access('update', $team) ? l($title, "team/" .  $team->tid . "/edit/members") : $title;

    $team->content['members'] = array(
      '#prefix' => '<div id="team-members">',
      '#suffix' => '</div>',
      'members' => array(
        '#theme' => 'item_list',
        '#items' => $items,
        '#title' => $title,
      )
    );
  }

  // Allow modules to make their own additions to the team.
  module_invoke_all('team_view', $team, $view_mode, $langcode);
  module_invoke_all('entity_view', $team, 'team', $view_mode, $langcode);
}

/**
 * Extracts active members from a team
 */
function _team_members_active($team) {
  if (empty($team->members)) {
    return array();
  }

  $members = $team->members;

  foreach ($members as $uid => $role) {
    if ($role < TEAM_MEMBER_ROLE_MEMBER) {
      unset($members[$uid]);
    }
  }

  return $members;
}

/**
 * Creates an array of acceptable tournament signup team sizes.
 */
function _team_tournament_sizes() {
  $max = variable_get('team_tournament_size_max', 8);

  $options = array();
  for ($i=2;$i<=$max;$i++) {
    $options[$i] = $i . 'v' . $i;
  }

  return $options;
}

/**
 * Cancel a team. This is the preferred method for removing team entities.
 * By deleting a team using team_delete(), the team name can not be used in
 * previous content where they exists. For example, Tournament participant list
 * or match results page.
 *
 * @param $tid
 *   A team ID.
 */
function team_cancel($team) {
  $team->status = 0;
  team_save($team);

  module_invoke_all('team_cancel', $team);
  module_invoke_all('entity_cancel', $team, 'team');
}

/**
 * Delete a team.
 *
 * @param $tid
 *   A team ID.
 */
function team_delete($tid) {
  team_delete_multiple(array($tid));
}

/**
 * Delete multiple teams.
 *
 * @param $tids
 *   An array of team IDs.
 */
function team_delete_multiple($tids) {
  if (!empty($tids)) {
    $transaction = db_transaction();

    $teams = team_load_multiple($tids, array());

    try {
      foreach ($teams as $tid => $team) {
        module_invoke_all('team_delete', $team);
        module_invoke_all('entity_delete', $team, 'team');
        field_attach_delete('team', $team);

        // Removes any associated paths
        path_delete(array('source' => 'team/' . $team->tid));
      }

      // Delete after calling hooks so that they can query team tables as needed.
      db_delete('teams_members')
        ->condition('tid', $tids, 'IN')
        ->execute();
      db_delete('teams_tournaments_members')
        ->condition('tid', $tids, 'IN')
        ->execute();
      db_delete('teams')
        ->condition('tid', $tids, 'IN')
        ->execute();

    }
    catch (Exception $e) {
      $transaction->rollback();
      watchdog_exception('team', $e);
      throw $e;
    }

    // Clear the page and block and team_load_multiple caches.
    entity_get_controller('team')->resetCache();
  }
}

/**
 * Prepares a team $team object for editing.
 * Fills in a few default values, and then invokes hook_team_prepare().
 */
function team_object_prepare(&$team) {
  global $user;

  $team = new stdClass();
  $team->name = '';
  $team->joining = TEAM_JOIN_CONFIRM;
  $team->uid = $user->uid;
  $team->created = REQUEST_TIME;

  module_invoke_all('team_prepare', $team);
}

/**
 * Inserts a new team member
 */
function team_member_insert($team, $account, $role) {
  db_insert('teams_members')
    ->fields(array(
      'tid' => $team->tid,
      'uid' => $account->uid,
      'role' => $role,
      'timestamp' => REQUEST_TIME,
    ))
    ->execute();
}

/**
 * Deletes a team member
 */
function team_member_delete($team, $account) {
  db_delete('teams_members')
    ->condition('tid', $team->tid)
    ->condition('uid', $account->uid)
    ->execute();

  db_delete('teams_tournaments_members')
    ->condition('tid', $team->tid)
    ->condition('uid', $account->uid)
    ->execute();
}

/**
 * Themes team member select icon pulldown image
 */
function theme_team_member_select_show_icon() {
  $variables = array(
    'path' => drupal_get_path('module', 'team') . '/images/show.png',
    'alt' => t('Show team members'),
    'title' => t('Show team members'),
    'height' => 16,
    'width' => 16,
  );

  $image = theme('image', $variables);

  return '<span class="team-member-select-icon">' . $image . '</span>';
}

/**
 * Themes team member select icon hide image
 */
function theme_team_member_select_hide_icon() {
  $variables = array(
    'path' => drupal_get_path('module', 'team') . '/images/hide.png',
    'alt' => t('Hide team members'),
    'title' => t('Hide team members'),
    'height' => 16,
    'width' => 16,
  );

  $image = theme('image', $variables);

  return '<span class="team-member-select-icon">' . $image . '</span>';
}

/**
 * Sends mail notifications to team members
 *
 * @param $team
 *   A team object
 * @param $key
 *   Mail type delta
 * @param $role
 *   At least this member role is required to recieve the email.
 * @param $params
 *   Optional, an array of parameters for drupal_mail()
 * @param $module
 *   The module which will handle the rendering of the mail in hook_mail().
 */
function team_mail_members($team, $key, $role = TEAM_MEMBER_ROLE_ADMIN, $params = array(), $module = 'team') {
  global $user;

  // Only email members with the required role, exclude the triggering user
  foreach ($team->members as $uid => $member_role) {
    if ($member_role >= $role && $user->uid != $uid) {
      $uids[] = $uid;
    }
  }

  // No related user accounts
  if (empty($uids)) {
    return;
  }

  // Load user account objects
  $accounts = user_load_multiple($uids);

  if (!empty($accounts)) {
    $params['team'] = $team;
    foreach ($accounts as $account) {
      $params['account'] = $account;
      drupal_mail($module, $key, $account->mail, user_preferred_language($account), $params);
    }
  }
}

/**
 * Implementation of hook_views_api().
 */
function team_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'team') . '/views'
  );
}

/**
 * Implements hook_mail().
 */
function team_mail($key, &$message, $params) {
  global $user;

  $options = array(
    'langcode' => $message['language']->language,
  );

  $team = $params['team'];

  switch ($key) {
    // Team member invitation
    case 'invite':
      $message['subject'] = t('Team invite at @site_name', array('@site_name' => variable_get('site_name', 'Drupal')), $options);
      $message['body'][] = t('!name sent you an invite to join team !team.', array('!team' => $team->name, '!name' => $user->name), $options);
      $message['body'][] = t('Respond to the invite here: @url', array('@url' => url('team/' . $team->tid . '/invite/respond', array('absolute' => TRUE))), $options);
      $message['body'][] = t('Team !team profile: @url', array('!team' => $team->name, '@url' => url('team/' . $team->tid, array('absolute' => TRUE))), $options);
      break;

    // Team member join request
    case 'join':
      $message['subject'] = t('Team join request at @site_name', array('@site_name' => variable_get('site_name', 'Drupal')), $options);
      $message['body'][] = t('!name has requested to join team !team.', array('!team' => $team->name, '!name' => $user->name), $options);
      $message['body'][] = t('Manage your team members: @url', array('@url' => url('team/' . $team->tid . '/edit/members', array('absolute' => TRUE))), $options);
      break;

    // New team member
    case 'member':
      $message['subject'] = t('New team member at @site_name', array('@site_name' => variable_get('site_name', 'Drupal')), $options);
      $message['body'][] = t('!name has joined team !team.', array('!team' => $team->name, '!name' => $user->name), $options);
      $message['body'][] = t('Team !team profile: @url', array('!team' => $team->name, '@url' => url('team/' . $team->tid, array('absolute' => TRUE))), $options);
      break;

    // Tournament member change request
    case 'tournament_member_select_admin':
      $node = $params['node'];
      $team = $params['team'];
      $uid = $params['uid'];

      $account = user_load($uid);

      $message['subject'] = t('Member list change request at @site_name', array('@site_name' => variable_get('site_name', 'Drupal')), $options);
      $message['body'][] = t('!team requested to add member !name to their member list for tournament !tournament.', array('!team' => $team->name, '!name' => $account->name, '!tournament' => $node->title), $options);
      $message['body'][] = t('Follow this link to view your tournament: @url', array('@url' => url('node/' . $node->nid, array('absolute' => TRUE))), $options);
      break;
  }
}

/**
 * Check whether a plain text password matches a stored hashed password.
 *
 * @param $password
 *   A plain-text password
 * @param $team
 *   A team object.
 *
 * @return
 *   TRUE or FALSE.
 */
function _team_check_password($team, $password) {
  require_once DRUPAL_ROOT . '/' . variable_get('password_inc', 'includes/password.inc');
  $hash = _password_crypt('sha512', $password, $team->join_pass);

  return $hash && $team->join_pass == $hash;
}

/**
 * Returns the correct string description for the given
 * team joining setting.
 */
function team_join_description($team_join) {
  switch ($team_join) {
    case TEAM_JOIN_OFF:
      return t('Team Joining is set to <strong>Disabled</strong>. The Join button will not be visible on your team profile page.');
      break;
    case TEAM_JOIN_AUTO:
      return t('Team Joining is set to <strong>Public</strong>. Any user who requests to join this team will automatically become a team member.');
      break;
    case TEAM_JOIN_PASS:
      return t('Team Joining is set to <strong>Password required</strong>. Any user may join this team if they enter the correct password set by the team administrator.');
      break;
    case TEAM_JOIN_CONFIRM:
      return t('Team Joining is set to <strong>Admin confirmation</strong>. Team administrators must confirm the membership of any user who requests to join this team.');
      break;
  }
}

/**
 * Returns an array of team joining options keyed
 * by the join setting value.
 */
function team_join_options() {
  return array(
    TEAM_JOIN_OFF => t('Disable'),
    TEAM_JOIN_AUTO => t('Public'),
    TEAM_JOIN_PASS => t('Password required'),
    TEAM_JOIN_CONFIRM => t('Admin confirmation'),
  );
}

/**
 * Returns an array of team member roles keyed
 * by the role value.
 */
function team_get_member_roles() {
  return array(
    TEAM_MEMBER_ROLE_INVITED => t('Invited'),
    TEAM_MEMBER_ROLE_PENDING => t('Pending'),
    TEAM_MEMBER_ROLE_MEMBER => t('Member'),
    TEAM_MEMBER_ROLE_ADMIN => t('Admin'),
  );
}
