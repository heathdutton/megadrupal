<?php

/**
 * @file
 * Implements Matches for entity competition.
 */

/**
 * Match statues
 */
define('MATCH_STATUS_NONE', 0);
define('MATCH_STATUS_AWAITING_CHALLENGE_ACCEPT', 1);
define('MATCH_STATUS_AWAITING_DATE_ACCEPT', 4);
define('MATCH_STATUS_AWAITING_RESULT', 8);
define('MATCH_STATUS_AWAITING_RESULT_ACCEPT', 12);
define('MATCH_STATUS_FINISHED', 16);


/**
 * Match challenge access denied
 */
define('MATCH_CHALLENGE_ACCESS_DENIED', 'deny');

/**
 * Implements hook_permission().
 */
function match_permission() {
  return array(
    'create challenges' => array(
      'title' => t('Create match challenges'),
    ),
  );
}

/**
* Implements hook_entity_info_alter().
*/
function match_entity_info_alter(&$info) {
  $entity_types = match_entity_types_list();

  foreach ($entity_types as $type => $value) {
    $info[$type]['view modes']['match'] = array(
      'label' => t('Match page'),
      'custom settings' => FALSE,
    );
  }
}

/**
 * Implements hook_menu().
 */
function match_menu() {
  $items['admin/config/competition'] = array(
    'title' => 'Competition',
    'position' => 'right',
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('access administration pages'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
  );
  $items['admin/config/competition/match'] = array(
    'title' => 'Matches',
    'description' => 'Configure match settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('match_settings_form'),
    'access arguments' => array('access administration pages'),
    'file' => 'match.admin.inc',
  );

  $items['node/%node/action/%'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('match_action_form', 3, 1),
    'access callback' => 'match_access',
    'access arguments' => array(3, 1),
    'type' => MENU_CALLBACK,
    'file' => 'match.pages.inc'
  );

  $items['node/%node/edit/participants/remove/%'] = array(
    'title' => 'Remove participant',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('match_remove_participant_confirm', 1, 5),
    'access callback' => '_match_remove_participant_access',
    'access arguments' => array(1, 5),
    'file' => 'match.pages.inc',
    'type' => MENU_CALLBACK,
  );
  $items['user/%user/challenge'] = array(
    'title' => 'Challenge User',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('match_challenge_form', 'user', 1),
    'access callback' => 'match_challenge_access',
    'access arguments' => array('user', 1),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'match.pages.inc',
  );

  return $items;
}

/**
 * Menu access callback for the removal of match participants
 */
function _match_remove_participant_access($node, $id) {
  return array_key_exists($id, $node->participants) && $node->type == 'match' && node_access('update', $node);
}

/**
 * Menu access callback for match challenging
 */
function match_challenge_access($entity_type, $entity) {
  // Check if the entity type is supported
  $entity_types = match_entity_types_list();
  if (!array_key_exists($entity_type, $entity_types)) {
    return FALSE;
  }

  $access = module_invoke_all('match_challenge_access', $entity_type, $entity);
  if (in_array(MATCH_CHALLENGE_ACCESS_DENIED, $access, TRUE)) {
    return FALSE;
  }

  return user_access('create challenges');
}


/**
 * Implements hook_match_participants_access_list().
 */
function match_match_participants_access_list($entity_type, $account, $admin = TRUE) {
  // We handle access checks for user entities in this module.
  if ($entity_type == 'user') {
    return array($account->uid);
  }
}

/**
 * Implements hook_match_challenge_access().
 */
function match_match_challenge_access($entity_type, $entity) {
  // We handle access checks for user entities in this module.
  if ($entity_type == 'user') {
    global $user;
    if ($entity->uid == $user->uid) {
      return MATCH_CHALLENGE_ACCESS_DENIED;
    }

    if (!variable_get('match_user_challenging', 1)) {
      return MATCH_CHALLENGE_ACCESS_DENIED;
    }
  }
}

/**
 * Menu access callback for match operations.
 *
 * @param $op
 *   The operation to be performed on the match. Possible values are:
 *   - "result_enter"
 *   - "result_respond"
 *   - "result_cancel"
 *   - "date_enter"
 *   - "date_respond"
 *   - "date_cancel"
 *   - "challenge_enter"
 *   - "challenge_respond"
 *   - "challenge_cancel"
 * @param $node
 *   The match node that the action is being made upon.
 * @param $id
 *   Optional, a participant ID for whom the current operation is to be performed on.
 * @param $account
 *   Optional, a user object representing the user for whom the operation is to
 *   be performed. Determines access for a user other than the current user.
 *
 * @return
 *   TRUE if the operation may be performed, FALSE otherwise.
 */
function match_access($op, $node, $account = NULL) {
  // These are all of the allowed operations and the match status
  // that is required for their access.
  $ops = array(
    'result_enter' => MATCH_STATUS_AWAITING_RESULT,
    'result_respond' => MATCH_STATUS_AWAITING_RESULT_ACCEPT,
    'result_cancel' => MATCH_STATUS_AWAITING_RESULT_ACCEPT,
    'date_enter' => MATCH_STATUS_AWAITING_RESULT,
    'date_respond' => MATCH_STATUS_AWAITING_DATE_ACCEPT,
    'date_cancel' => MATCH_STATUS_AWAITING_DATE_ACCEPT,
    'challenge_respond' => MATCH_STATUS_AWAITING_CHALLENGE_ACCEPT,
    'challenge_reverse' => MATCH_STATUS_AWAITING_CHALLENGE_ACCEPT,
    'challenge_cancel' => MATCH_STATUS_AWAITING_CHALLENGE_ACCEPT,
  );

  // Return false on incorrect ops
  if (!array_key_exists($op, $ops)) {
    return FALSE;
  }

  // We only care about match nodes
  if ($node->type != 'match') {
    return FALSE;
  }

  // No operations can be made on matches without participants
  if (!isset($node->participants) || count($node->participants) < 2) {
    return FALSE;
  }

  // If no user object is supplied, the access check is for the current user
  if (empty($account)) {
    $account = $GLOBALS['user'];
  }

  // Tournament admins can enter results for related matches
  if ($op == 'result_enter' && !empty($node->tid)) {
    $tournament = node_load($node->tid);
    if (node_access('update', $tournament, $account)) {
      return in_array($node->match_status, array(MATCH_STATUS_AWAITING_RESULT, MATCH_STATUS_AWAITING_RESULT_ACCEPT));
    }
  }

  // Create a list of participants to check access for
  $ids = array_keys($node->participants);
  $ids = match_participants_access_list($node->entity_type, $ids, $account);

  // If ids is empty, the user has access over none of the participants
  if (empty($ids)) {
    return FALSE;
  }

  switch ($op) {
    case 'result_enter':
      return $node->match_status == $ops[$op] && $node->score_access;

    case 'date_enter':
      if (!empty($node->tid)) {
        $tournament = node_load($node->tid);
        return ($node->match_status == $ops[$op] && $tournament->new_match_dates);
      }

      return $node->match_status == $ops[$op];

    case 'result_respond':
    case 'date_respond':
    case 'challenge_respond':
    case 'challenge_reverse':
      // True if the user has access over at least 1 non-confirmed participant
      foreach ($node->participants as $id => $participant) {
        if (in_array($id, $ids) && !$participant['confirm']) {
          return $node->match_status == $ops[$op];
        }
      }
      break;

    case 'result_cancel':
    case 'date_cancel':
    case 'challenge_cancel':
      // True if the participant has access over the sender.
      return $node->match_status == $ops[$op] && in_array($node->request_id, $ids);
  }
}

/**
 * Retrieves a list of participants that the given user
 * has access over.
 *
 * @param $entity_type
 *   The participant entity type.
 * @param $ids
 *   Optional, an array of specific participant IDs to check access for.
 * @param $account
 *   Optional, the user account to check access with.
 *
 * @return $ids
 *   An array of participant ids that passed the access checks
 */
function match_participants_access_list($entity_type, $ids = array(), $account = NULL) {
  // We can expect this function to be called several times per page load
  $access = &drupal_static(__FUNCTION__);

  // If no user object is supplied, the access check is for the current user
  if (empty($account)) {
    $account = $GLOBALS['user'];
  }

  // If available, work from cached access initially
  if (isset($access[$account->uid][$entity_type])) {
    // When no participants are specified, return the entire cache
    if (empty($ids)) {
      return $access[$account->uid][$entity_type];
    }

    // For a specific list of participants, check each individually
    foreach ($ids as $key => $id) {
      if (!in_array($id, $access[$account->uid][$entity_type])) {
        unset($ids[$key]);
      }
    }

    return $ids;
  }

  $list = module_invoke_all('match_participants_access_list', $entity_type, $account);

  // Cache the full access list
  $access[$account->uid][$entity_type] = $list;

  if (!empty($list)) {
    if (empty($ids)) {
      // The full list was requested, return the list un-touched
      return $list;
    }

    // Specific participants were requested so check each individually
    foreach ($ids as $key => $id) {
      if (!in_array($id, $list)) {
        unset($ids[$key]);
      }
    }

    return $ids;
  }

  // If we get this far, the user has access over no participants.
  // We should return an empty array.
  return array();
}

/**
 * Retrieves a list of entities (e.g. teams) that a give account is
 * a member of. match_participants_access_list() only returns entities the
 * user has -admin access- over whereas this function returns regardless.
 *
 * @param $entity_type
 *   The participant entity type.
 * @param $account
 *   Optional, a user account object.
 *
 * @return An array of entity IDs.
 */
function match_participants_full_list($entity_type, $account = NULL) {
  // If no user object is supplied, the check is for the current user
  if (empty($account)) {
    $account = $GLOBALS['user'];
  }

  if ($entity_type == 'user') {
    return array($account->uid);
  }

  // We can expect this function to be called several times per page load
  $list = &drupal_static(__FUNCTION__);

  // If available, return the cached list
  if (isset($list[$account->uid][$entity_type])) {
    return $list[$account->uid][$entity_type];
  }

  $list[$account->uid][$entity_type] = module_invoke_all('match_participants_access_list', $entity_type, $account, FALSE);
  return $list[$account->uid][$entity_type];
}

/**
 * Check if user belongs to one of the match participants.
 *
 * @param $node
 *   A tournament node object.
 */
function match_user_is_participant($node, $account = NULL) {
  // If no user object is supplied, the access check is for the current user
  if (empty($account)) {
    $account = $GLOBALS['user'];
  }

  if ($node->type != 'match') {
    return FALSE;
  }

  $participants = array_keys($node->participants);

  if ($node->entity_type == 'user') {
    return in_array($account->uid, $participants);
  }

  $list = match_participants_full_list('team', $account);

  if (!empty($list)) {
    foreach ($participants as $id) {
      if (in_array($id, $list)) {
        return TRUE;
      }
    }
  }

  return FALSE;
}

/**
 * Check if match participants have confirmed.
 *
 * @param $node
 *   A match node object
 * @param $ignore
 *   An array of participants ids to ignore
 *
 * @return
 *   TRUE if all participants in the match have confirmed the result.
 */
function _match_confirmed($node, $ignore = array()) {
  foreach ($node->participants as $id => $participant) {
    // If any participant didn't confirm the result, do not finish the match
    if (!in_array($id, $ignore) && !$participant['confirm']) {
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Implementation of hook_views_api().
 */
function match_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'match') . '/views'
  );
}

/**
 * Implements hook_node_info().
 */
function match_node_info() {
  return array(
    'match' => array(
      'name' => t('Match'),
      'base' => 'match',
      'description' => t('Matches held between two entities (e.g. user/team).'),
      'has_title' => FALSE,
    ),
  );
}

/**
 * Implements hook_load().
 */
function match_load($nodes) {
  $result = db_select('matches', 'm')
    ->condition('m.nid', array_keys($nodes))
    ->fields('m')
    ->execute();

  foreach ($result as $fields) {
    $nid = $fields->nid;
    foreach ($fields as $key => $value) {
      if (!isset($nodes[$nid]->$key)) {
        $nodes[$nid]->$key = $value;
      }
    }
  }

  $result = db_select('matches_participants', 'mp')
    ->condition('mp.nid', array_keys($nodes))
    ->fields('mp')
    ->orderBy('weight')
    ->execute();

  $participants = array();
  foreach ($result as $record) {
    // Populate match participants
    $nid = $record->nid;
    $type = $nodes[$nid]->entity_type;
    $id = $record->id;

    $nodes[$nid]->participants[$id]['id'] = $id;
    $nodes[$nid]->participants[$id]['name'] = '???'; // Default
    $nodes[$nid]->participants[$id]['entity'] = array(); // Default
    $nodes[$nid]->participants[$id]['score'] = $record->score;
    $nodes[$nid]->participants[$id]['confirm'] = $record->confirm;
    $nodes[$nid]->participants[$id]['weight'] = $record->weight;

    // Group ids of entities of the same type before loading
    $participants[$type][$id][] = $nid;
  }

  foreach ($participants as $type => $ids) {
    $entities = entity_load($type, array_keys($ids));
    foreach ($entities as $id => $entity) {
      $nids = $participants[$type][$id];
      foreach ($nids as $nid) {
        $nodes[$nid]->participants[$id]['entity'] = $entity;
        $nodes[$nid]->participants[$id]['name'] = entity_label($type, $entity);
      }
    }
  }
}

/**
 * Implements hook_insert().
 */
function match_insert($node) {
  if (isset($node->participants)) {
    $default_weight = 0;
    foreach ($node->participants as $id => $participant) {
      $values[] = array(
        'nid' => $node->nid,
        'id' => $id,
        'score' => isset($participant['score']) ? $participant['score'] : 0,
        'confirm' => isset($participant['confirm']) ? $participant['confirm'] : 0,
        'weight' => isset($participant['weight']) ? $participant['weight'] : $default_weight,
      );

      $default_weight++;
    }

    if (isset($values)) {
      // Multi-insert new participants
      $query = db_insert('matches_participants')->fields(array('nid', 'id', 'score', 'confirm', 'weight'));
      foreach ($values as $record) {
        $query->values($record);
      }
      $query->execute();
    }
  }

  if (is_array($node->match_date)) {
    $node->match_date = match_date_convert($node->match_date);
  }
  if (is_array($node->request)) {
    $node->request = match_date_convert($node->request);
  }

  drupal_write_record('matches', $node);

  if ($node->match_status == MATCH_STATUS_AWAITING_CHALLENGE_ACCEPT) {
    if (isset($node->challenge_comment)) {
      $challenge = array(
        'nid' => $node->nid,
        'comment' => $node->challenge_comment,
      );

      drupal_write_record('matches_challenges', $challenge);

      $delta = 'challenge_enter';
    }
  }
  else {
    $delta = 'create';
  }

  // Log the match creation
  match_log($node, $delta);
}

/**
 * Implements hook_update().
 */
function match_update($node) {
  if (!empty($node->participants)) {
    $default_weight = 0;
    foreach ($node->participants as $id => $participant) {
      db_merge('matches_participants')
        ->key(array(
          'nid' => $node->nid,
          'id' => $id,
        ))
        ->fields(array(
          'score' => !empty($participant['score']) ? $participant['score'] : 0,
          'confirm' => !empty($participant['confirm']) ? $participant['confirm'] : 0,
          'weight' => isset($participant['weight']) ? $participant['weight'] : $default_weight,
        ))
        ->execute();

      $default_weight++;
    }
  }

  if (is_array($node->match_date)) {
    $node->match_date = match_date_convert($node->match_date);
  }
  if (is_array($node->request)) {
    $node->request = match_date_convert($node->request);
  }

  if ($node->match_status != $node->original->match_status && $node->match_status == MATCH_STATUS_FINISHED) {
    // If match belongs to a tournament, add the tournament
    // node to the match node for reference in hooks.
    if (!empty($node->tid)) {
      $node->tournament_node = node_load($node->tid);
    }

    $scores = array();
    foreach ($node->participants as $id => $participant) {
      $scores[$id] = $participant['score'];
    }

    // Set the winner of the match to the participant with
    // the highest score. For draws, we set no winner.
    if (count(array_unique($scores)) === 1) {
      $node->winner = 0;
    }
    else {
      $score = max($scores);
      $node->winner = array_search($score, $scores);
    }

    // Notify all modules of a finished match.
    module_invoke_all('match_finish', $node);
  }

  // Update the match record
  drupal_write_record('matches', $node, 'nid');
}

/**
 * Implements hook_delete().
 */
function match_delete($node) {
  db_delete('matches_challenges')->condition('nid', $node->nid)->execute();
  db_delete('matches_log')->condition('nid', $node->nid)->execute();
  db_delete('matches_participants')->condition('nid', $node->nid)->execute();
  db_delete('matches')->condition('nid', $node->nid)->execute();
}

/**
 * Implements hook_tournament_participant_replace().
 */
function match_tournament_participant_replace($node, $new, $old) {
  $query = db_select('matches', 'm');
  $query->join('matches_participants', 'mp', 'm.nid = mp.nid');

  $matches = $query->fields('m', array('nid'))
    ->condition('m.tid', $node->nid)
    ->condition('mp.id', $old)
    ->execute();

  foreach ($matches as $match) {
    db_update('matches_participants')
      ->fields(array(
        'id' => $new,
      ))
      ->condition('id', $old)
      ->condition('nid', $match->nid)
      ->execute();
  }
}

/**
 * Implements hook_element_info().
 */
function match_element_info() {
  $types['match_date'] = array(
    '#input' => TRUE,
    '#element_validate' => array('match_date_validate'),
    '#process' => array('match_date_process'),
    '#theme' => 'date',
    '#theme_wrappers' => array('form_element'),
  );
  return $types;
}

function match_date_process($element) {
  $element['#tree'] = TRUE;
  drupal_add_library('system','ui.datepicker');

  // Determine the order of day, month, year in the site's chosen date format.
  $format = variable_get('date_format_short', 'm/d/Y - H:i');
  $sort = array();
  $sort['day'] = max(strpos($format, 'd'), strpos($format, 'j'));
  $sort['month'] = max(strpos($format, 'm'), strpos($format, 'M'));
  $sort['year'] = strpos($format, 'Y');
  asort($sort);
  $popup_order = $date_order = array();
  foreach (array_keys($sort) as $order) {
    switch ($order) {
      case 'month':
        $popup_order[] = 'mm';
        $date_order[] = 'm';
        break;

      case 'day':
        $popup_order[] = 'dd';
        $date_order[] = 'd';
        break;

      case 'year':
        $popup_order[] = 'yy';
        $date_order[] = 'Y';
        break;
    }
  }

  // Determine date delimiter. American style date s(m/d/Y) use a forward slash delimiter
  // while European dates use hyphens or dots (d-m-Y)
  $delimiter = $date_order[0] == 'm' ? '/' : '-';

  // Minute increment
  $increment = !empty($element['#time_increment']) ? $element['#time_increment'] : 30;

  // Default values
  if (is_array($element['#value'])) {
    $time = strtotime($element['#value']['date'] . ' ' . $element['#value']['time']);
  }
  elseif (is_numeric($element['#value'])) {
    $time = match_date_round($element['#value'], $increment);
    $element['#value'] = array(
      'date' => format_date($time, 'custom', implode($delimiter, $date_order)),
      'time' => format_date($time, 'custom', 'H:i'),
    );
  }
  else {
    $time = match_date_round(REQUEST_TIME, $increment);
    $element['#value'] = array(
      'date' => '',
      'time' => format_date($time, 'custom', 'H:i'),
    );
  }

  // Date field
  $js_setting = array('match' => array('dateFormat' => implode($popup_order, $delimiter)));
  $element['date'] = array(
    '#type' => 'textfield',
    '#title' => t('Date'),
    '#title_display' => 'invisible',
    '#size' => 10,
    '#maxlength' => 10,
    '#attributes' => array('class' => array('match-date')),
    '#default_value' => $element['#value']['date'],
    '#required' => $element['#required'],
    '#ajax' => isset($element['#ajax']) ? $element['#ajax'] : array(),
    '#attached' => array(
      'js' => array(
        array('data' => drupal_get_path('module', 'match') . '/match.js'),
        array('data' => $js_setting, 'type' => 'setting'),
      ),
    ),
  );

  // Time field
  $options = array();
  for ($hour = 0; $hour < 24; $hour++) {
    for ($minute = 0; $minute < 60; $minute += $increment) {
      $options[] = sprintf('%02d:%02d', $hour, $minute);
    }
  }

  $element['time'] = array(
    '#type' => 'select',
    '#title' => t('Time'),
    '#title_display' => 'invisible',
    '#options' => drupal_map_assoc($options),
    '#required' => $element['#required'],
    '#attributes' => $element['#attributes'],
    '#default_value' => $element['#value']['time'],
    '#ajax' => isset($element['#ajax']) ? $element['#ajax'] : array(),
  );

  return $element;
}

/**
 * Rounds a given time up to the next increment
 *
 * @param $timestamp
 *   A unix timestamp
 * @param $increment
 *   Time increment in minutes, e.g. 15 for quaterly
 *
 * @return
 *   The rounded time as a unix timestamp
 */
function match_date_round($timestamp, $increment) {
  $minute = format_date($timestamp, 'custom', 'i');

  if ($diff = $minute % $increment) {
    $timestamp += ($increment - $diff) * 60; // increase in seconds
  }

  return $timestamp;
}

function match_date_validate($element) {
  if (!empty($element['#value']['date']) && strtotime(implode(' ', $element['#value'])) === FALSE) {
    form_set_error($element['#name'], t('Invalid input format'));
  }
}

/**
 * Converts an inputed date into a db-friendly timestamp.
 *
 * @param $date
 *   A complete match_date form element.
 * @return
 *   A unix timestamp.
 */
function match_date_convert($date) {
  return strtotime(implode($date, ' '));
}

/**
 * Forms a match title based on the amount of participants present in the match.
 */
function match_title($node, $score = FALSE) {
  if (empty($node->participants)) {
    return t('Empty match');
  }
  else {
    $count = count($node->participants);

    if ($count > 2) {
      // Keep titles with more than 2 participants short
      return t('Match with @count participants', array('@count' => $count));
    }
    elseif ($count == 2) {
      foreach($node->participants as $participant) {
        $names[] = $participant['name'];
        $scores[] = $participant['score'];
      }

      if ($score) {
        return t('@name_a @score_a - @score_b @name_b', array('@score_a' => $scores[0], '@score_b' => $scores[1], '@name_a' => $names[0], '@name_b' => $names[1]));
      }
      else {
        return t('@name_a v @name_b', array('@name_a' => $names[0], '@name_b' => $names[1]));
      }
    }
    else {
      $participant = reset($node->participants);
      if ($participant['weight'] == 1) {
        return t('??? vs @name', array('@name' => $participant['name']));
      }
      else {
        return t('@name vs ???', array('@name' => $participant['name']));
      }
    }
  }
}

/**
 * Implements hook_form().
 */
function match_form($node, &$form_state) {
  $info = entity_get_info();

  $form['entity_type'] = array(
    '#type' => 'select',
    '#title' => t('Participant type'),
    '#options' => match_entity_types_list(),
    '#default_value' => isset($node->entity_type) ? $node->entity_type : 0,
    '#disabled' => isset($node->entity_type),
    '#description' => empty($node->nid) ? t('Only participants of this type can take part in this match.') : t('You cannot edit this option after a match has been created.'),
  );
  $form['match_date'] = array(
    '#type' => 'match_date',
    '#title' => t('Match date'),
    '#size' => 10,
    '#time_increment' => 10,
    '#default_value' => isset($node->match_date) ? $node->match_date : REQUEST_TIME,
  );

  $form['advanced'] = array(
    '#type' => 'fieldset',
    '#title' => t('Advanced'),
    '#collapsed' => TRUE,
    '#collapsible' => TRUE,
    '#description' => t('Advanced settings are for experienced administrators only. Most of the settings here will be set automatically and are used to reflect the current match status.'),
  );
  $form['advanced']['match_status'] = array(
    '#type' => 'select',
    '#title' => t('Match Status'),
    '#options' => match_status_list(),
    '#default_value' => isset($node->match_status) ? $node->match_status : MATCH_STATUS_AWAITING_RESULT,
    '#description' => t('The Match Actions available on the match page are based on this match status setting.'),
  );
  if (isset($node->request_id)) {
    $options = _match_participant_options($node);
    $form['advanced']['request_id'] = array(
      '#type' => 'select',
      '#title' => t('Requester'),
      '#options' => $options,
      '#default_value' => isset($node->request_id) ? $node->request_id : '',
      '#access' => !empty($options),
      '#description' => t('The participant that made the latest request. This is used, for example, to determined who requested a date change or challenge.'),
      '#empty_value' => 0,
    );
  }
  else {
    $form['advanced']['request_id'] = array(
      '#type' => 'textfield',
      '#title' => t('Requester'),
      '#size' => 15,
      '#description' => t('The participant that made the latest request. This is used, for example, to determined who requested a date change or challenge.'),
    );
  }
  $form['advanced']['request'] = array(
    '#type' => 'match_date',
    '#title' => t('Request date'),
    '#size' => 10,
    '#time_increment' => 10,
    '#default_value' => isset($node->request) ? $node->request : REQUEST_TIME,
    '#description' => t('The date that the latest request was made.'),
  );
  $form['advanced']['score_access'] = array(
    '#type' => 'checkbox',
    '#title' => t('Participants can enter scores for their own matches.'),
    '#default_value' => isset($node->score_access) ? $node->score_access : 1,
  );
  $form['advanced']['tid'] = array(
    '#type' => 'textfield',
    '#title' => t('Tournament node ID'),
    '#size' => 5,
    '#default_value' => isset($node->tid) ? $node->tid : '',
  );

  $form['participants_wrapper'] = array(
    '#type' => 'fieldset',
    '#title' => t('Participants'),
    '#prefix' => '<div id="match-participants-wrapper">',
    '#suffix' => '</div>',
    '#description' => t('In almost all situations exactly two participants should be added here. Theoretically, any number of participants may be added to matches.'),
    '#element_validate' => array('match_participant_weight_validate'),
  );
  $form['participants_wrapper']['participants'] = array(
    '#tree' => TRUE,
    '#theme' => 'match_form_participants',
  );

  // Lists current match participants
  if (isset($node->participants)) {
    $weight_options = range(0, count($node->participants) - 1);
    foreach ($node->participants as $id => $participant) {
      $form['participants_wrapper']['participants'][$id]['id'] = array(
        '#markup' => $id,
      );
      $form['participants_wrapper']['participants'][$id]['name'] = array(
        '#markup' => match_participant_label($node->entity_type, $participant['entity']),
      );
      $form['participants_wrapper']['participants'][$id]['score'] = array(
        '#type' => 'textfield',
        '#title' => t('Score'),
        '#title_display' => 'invisible',
        '#default_value' => isset($participant['score']) ? $participant['score'] : 0,
        '#element_validate' => array('element_validate_integer'),
        '#size' => 15,
        '#disabled' => $node->match_status == MATCH_STATUS_FINISHED ? TRUE : FALSE,
      );
      $form['participants_wrapper']['participants'][$id]['weight'] = array(
        '#type' => 'select',
        '#options' => $weight_options,
        '#default_value' => isset($participant['weight']) ? $participant['weight'] : 0,
      );
      $form['participants_wrapper']['participants'][$id]['action'] = array(
        '#markup' => l(t('Remove'), 'node/' . $node->nid . '/edit/participants/remove/' . $id),
      );
      // Store these as values so that they can be used by hook_update() and hook_insert().
      $form['participants_wrapper']['participants'][$id]['entity'] = array(
        '#type' => 'value',
        '#value' => $participant['entity'],
      );
      $form['participants_wrapper']['participants'][$id]['confirm'] = array(
        '#type' => 'value',
        '#value' => !empty($participant['confirm']) ? $participant['confirm'] : 0,
      );
    }
  }

  // Add new match particiapnts
  if (empty($form_state['num_participants'])) {
    $form_state['num_participants'] = 1;
  }
  for ($i = 0; $i < $form_state['num_participants']; $i++) {
    $form['participants_wrapper']['participants']['add'][$i] = array(
      'id' => array(
        '#type' => 'textfield',
        '#title' => t('Participant ID'),
        '#title_display' => 'invisible',
        '#size' => 15,
        '#description' => isset($node->entity_type) ? $info[$node->entity_type]['label'] . ' ID' : t('Participant ID'),
        '#element_validate' => array('element_validate_integer', '_match_form_validate_id'),
      ),
      'score' => array(
        '#type' => 'textfield',
        '#title' => t('Participant Score'),
        '#title_display' => 'invisible',
        '#size' => 15,
        '#description' => t('Score'),
        '#element_validate' => array('element_validate_integer'),
      ),
    );
  }
  $form['participants_wrapper']['add_more'] = array(
    '#type' => 'submit',
    '#value' => t('Add one more'),
    '#submit' => array('match_form_participants_add'),
    '#ajax' => array(
      'callback' => 'match_form_participants_add_callback',
      'wrapper' => 'match-participants-wrapper',
    ),
    '#limit_validation_errors' => array(),
  );
  if ($form_state['num_participants'] > 1) {
    $form['participants_wrapper']['remove_more'] = array(
      '#type' => 'submit',
      '#value' => t('Remove one'),
      '#submit' => array('match_form_participants_remove'),
      '#ajax' => array(
        'callback' => 'match_form_participants_add_callback',
        'wrapper' => 'match-participants-wrapper',
      ),
      '#limit_validation_errors' => array(),
    );
  }

  return $form;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * @see match_form()
 */
function match_form_match_node_form_alter(&$form, &$form_state, $form_id) {
  $form['#submit'][] = 'match_form_add_participants';
}

/**
 * Form validation handler for new participant id element.
 */
function _match_form_validate_id($element, &$form_state, $form) {
  $info = entity_get_info();

  if (!empty($element['#value'])) {
    $id = $element['#value'];
    $type = $form_state['values']['entity_type'];
    $name = implode('][', $element['#parents']);

    if (isset($form_state['values']['participants'][$id])) {
      form_set_error($name, t('@name @id is already a participant of this match.', array('@name' => $element['#title'], '@id' => $id)));
    }
    elseif (!form_get_error($element)) {
      // Load the entity if there is no previous validation errors
      $entity = entity_load($type, array($id));
      if (empty($entity)) {
        form_set_error($name, t('@name @id does not exist.', array('@name' => $element['#title'], '@id' => $id)));
      }
    }
  }
}

/**
 * Submit handler for the match add/edit form.
 *
 * @see match_form()
 */
function match_form_add_participants($form, &$form_state) {
  // Adds new participants into the correct node structure
  if (isset($form_state['values']['participants']['add'])) {
    foreach ($form_state['values']['participants']['add'] as $participant) {
      if (!empty($participant['id'])) {
        $score = !empty($participant['score']) ? $participant['score'] : 0;
        $form_state['values']['participants'][$participant['id']]['score'] = $score;
      }
    }
  }

  // No longer needed
  unset($form_state['values']['participants']['add']);
}

/**
 * Callback for both ajax-enabled buttons.
 *
 * Selects and returns the fieldset with the names in it.
 */
function match_form_participants_add_callback($form, $form_state) {
  return $form['participants_wrapper'];
}

/**
 * Submit handler for the "Add one more" button.
 *
 * Increments the max counter and causes a rebuild.
 */
function match_form_participants_add($form, &$form_state) {
  $form_state['num_participants']++;
  $form_state['rebuild'] = TRUE;
}

/**
 * Submit handler for the "Remove one" button.
 *
 * Decrements the max counter and causes a form rebuild.
 */
function match_form_participants_remove($form, &$form_state) {
  if ($form_state['num_participants'] > 1) {
    $form_state['num_participants']--;
  }
  $form_state['rebuild'] = TRUE;
}

/**
 * Return a participant entity label as a link.
 *
 * @param $entity_type
 * @param $entity
 *   A participant entity.
 *
 * @return Static html returned from l()
 */
function match_participant_label($entity_type, $entity) {
  if (!empty($entity)) {
    $label = entity_label($entity_type, $entity);
    $uri = entity_uri($entity_type, $entity);
    return l($label, $uri['path'], $uri);
  }

  return '???';
}

/**
 * Implements hook_view().
 */
function match_view($node, $view_mode) {
  if ($view_mode == 'full' && node_is_page($node)) {
    $title = match_title($node);
    drupal_set_title($title);

    // Display a breadcrumb for matches that belong to a tournament
    if (!empty($node->tid)) {
      $tournament = node_load($node->tid);
      $breadcrumb = array(
        l(t('Home'), '<front>'),
        l($tournament->title, 'node/' . $tournament->nid),
      );

      drupal_set_breadcrumb($breadcrumb);
    }

    // Match actions
    $actions = _match_actions($node);
    if (!empty($actions)) {
      $node->content['actions'] = array(
        '#theme' => 'links',
        '#prefix' => '<div id="match-actions">',
        '#suffix' => '</div>',
        '#links' => $actions,
        '#attributes' => array(
          'class' => array('links', 'match-actions'),
        ),
        '#heading' => t('Match actions'),
        '#weight' => -10,
      );
    }

    // Display a list of participants
    if (isset($node->participants)) {
      if (count($node->participants) > 2) {
        $header = $node->match_status == MATCH_STATUS_FINISHED ? array(t('Name'), t('Score')) : array(t('Participants'));

        foreach ($node->participants as $participant) {
          $row = array(
            match_participant_label($node->entity_type, $participant['entity']),
          );

          if ($node->match_status == MATCH_STATUS_FINISHED) {
            $row[] = $participant['score'];
          }

          $rows[] = $row;
        }
      }
      else {
        $header = array();

        // Manageable participant references
        foreach ($node->participants as $participant) {
          $participant['weight'] == 0 ? $a = $participant : $b = $participant;
        }

        // Fake empty participants if not available
        if (!isset($a)) {
          $a = array('score' => 0, 'entity' => array());
        }
        if (!isset($b)) {
          $b = array('score' => 0, 'entity' => array());
        }

        // Only show scores when match is finished
        $score = $node->match_status == MATCH_STATUS_FINISHED ? $a['score'] . ' - ' . $b['score'] : 'vs';

        $rows = array(
          'date' => array(
            array(
              'data' => format_date($node->match_date, 'long'),
              'colspan' => 3, 'align' => 'center'
            )
          ),
          'score' => array(
            'a' => array(
              'data' => '<div class="participant-label clearfix">' . match_participant_label($node->entity_type, $a['entity']) . '</div>',
              'class' => 'participant participant-a',
              'width' => '25%',
              'align' => 'center'
            ),
            'score' => array(
              'data' => '<h2>' . $score . '</h2>',
              'class' => 'score',
              'align' => 'center'
            ),
            'b' => array(
              'data' => '<div class="participant-label clearfix">' . match_participant_label($node->entity_type, $b['entity']) . '</div>',
              'class' => 'participant participant-b',
              'width' => '25%',
              'align' => 'center'
            ),
          ),
        );
      }

      // We handle user participant pictures in this module
      if ($node->entity_type == 'user' && variable_get('match_user_picture', 0)) {
        if (!empty($a['entity'])) {
          $rows['score']['a']['data'] .= theme('user_picture', array('account' => $a['entity']));
        }
        if (!empty($b['entity'])) {
          $rows['score']['b']['data'] .= theme('user_picture', array('account' => $b['entity']));
        }
      }

      $node->content['match'] = array(
        '#theme' => 'table',
        '#header' => $header,
        '#rows' => $rows,
        '#attributes' => array(
          'id' => 'match-score',
        ),
      );
    }

    // Match log
    $header = array(t('Date'), t('Details'), t('User'));

    $result = db_select('matches_log', 'ml')
      ->fields('ml')
      ->condition('nid', $node->nid)
      ->orderBy('created', 'DESC')
      ->execute();

    $rows = array();
    foreach ($result as $record) {
      // Group the user IDs to be loaded in one go later
      if (!isset($uids[$record->uid])) {
        $uids[$record->uid] = $record->uid;
      }

      $rows[] = array(
        'date' => format_date($record->created),
        'description' => _match_log_description($node, $record),
        'author' => $record->uid,
      );
    }

    // Add author user names
    if (!empty($rows) && !empty($uids)) {
      $accounts = user_load_multiple(array_keys($uids));
      foreach ($rows as &$row) {
        $row['author'] = theme('username', array('account' => $accounts[$row['author']]));
      }
    }

    $node->content['log'] = array(
      '#theme' => 'table',
      '#rows' => $rows,
      '#header' => $header,
      '#weight' => 10,
    );
  }

  return $node;
}

/**
 * Creates a match node.
 *
 * @param $match
 *   A match object with at least the following elements:
 *   match_date - a unix timestamp
 *   participants - a linear array of participant IDs
 * @param $node
 *   Optional, a tournament node object that this match is a
 *   part of.
 */
function match_create_match($match, $node = NULL) {
  $match->title = '';
  $match->type = 'match';
  $match->uid = 0;
  $match->status = 1;
  $match->language = 'und';

  if (!empty($node)) {
    $match->tid = $node->nid;
    $match->entity_type = $node->entity_type;
    $match->score_access = $node->score_access;
  }

  if (!isset($match->match_status)) {
    $match->match_status = MATCH_STATUS_AWAITING_RESULT;
  }
  if (!isset($match->request)) {
    $match->request = REQUEST_TIME;
  }

  node_save($match);
}

/**
 * Returns the correct log description.
 *
 * @param $node
 *   A match node object.
 * @param $record
 *   A database record object from {matches_log}
 *
 * @return string
 *   A translated description of a log record.
 *
 * see match_view()
 */
function _match_log_description($node, $record) {
  $variables = unserialize($record->variables);

  switch ($record->delta) {
    case 'create':
      $output = t('Match created');
      break;
    case 'challenge_enter':
      $output = t('Challenge created');
      break;
    case 'challenge_respond_accept':
      $output = t('Challenge accepted');
      break;
    case 'challenge_reverse':
      $output = t('Challenge date change request: <em>@date</em>', array('@date' => format_date($variables['date'])));
      break;
    case 'date_enter':
      $output = t('Date change request: <em>@date</em>', array('@date' => format_date($variables['date'])));
      break;
    case 'date_respond_accept':
      $output = t('Date request accepted');
      break;
    case 'date_respond_reject':
      $output = t('Date request rejected');
      break;
    case 'date_cancel':
      $output = t('Date request cancelled');
      break;
    case 'result_enter':
    case 'result_enter_admin':
      $scores = array();
      foreach ($variables['scores'] as $id => $score) {
        $scores[] = $node->participants[$id]['name'] . ': ' . $score;
      }
      $output = t('Result entered: <em>@scores</em>', array('@scores' => implode(', ', $scores)));
      if ($record->delta == 'result_enter_admin') {
        $output .= ' (' . t('Forced') . ')';
      }
      break;
    case 'result_respond_accept':
    case 'result_respond_accept_admin':
      $output = t('Result accepted');
      break;
    case 'result_respond_reject':
      $output = t('Result rejected');
      break;
    case 'result_cancel':
      $output = t('Result cancelled');
      break;
  }

  return $output;
}

/**
 * Implements hook_theme().
 */
function match_theme() {
  return array(
    'match_form_participants' => array(
      'render element' => 'element',
    ),
  );
}

/**
 * Returns HTML for the match form participants form element.
 *
 * @param $variables
 *   An associative array containing:
 *   - element: An array representing the form element.
 *
 */
function theme_match_form_participants($variables) {
  $participants = $variables['element'];

  $header = array(t('Participant ID'), t('Name'), t('Score'), t('Weight'), t('Action'));

  $rows = array();
  foreach (element_children($participants) as $id) {
    if ($id == 'add') {
      foreach (element_children($participants['add']) as $i) {
        $rows[] = array(
          array('data' => drupal_render($participants['add'][$i]['id']), 'colspan' => 2),
          array('data' => drupal_render($participants['add'][$i]['score']), 'colspan' => 3),
        );
      }
    }
    else {
      $rows[] = array(
        array('data' => drupal_render($participants[$id]['id']), 'width' => '22%'),
        drupal_render($participants[$id]['name']),
        array('data' => drupal_render($participants[$id]['score']), 'width' => '22%'),
        array('data' => drupal_render($participants[$id]['weight']), 'width' => '20%'),
        array('data' => drupal_render($participants[$id]['action']), 'width' => '15%'),
      );
    }
   }

  $output = theme('table', array('header' => $header, 'rows' => $rows));

  return $output;
}

/**
 * Implements hook_node_delete().
 */
function match_node_delete($node) {
  if (tournament_supported_type($node->type)) {
    $nids = db_select('matches')
      ->fields('matches', array('nid'))
      ->condition('tid', $node->nid)
      ->execute()
      ->fetchCol();

    node_delete_multiple($nids);
  }
}

/**
 * Forms a list of actions that the current user can
 * perform on the current match.
 *
 * @return
 *   An array of links usable by theme_links()
 */
function _match_actions($node, $destination = NULL) {
  $actions = array();

  if (empty($destination)) {
    $destination = drupal_get_destination();
  }

  if (isset($destination['destination']) && $destination['destination'] == 'system/ajax' && !empty($node->tid)) {
    // When adding action links in an ajax callback (e.g. match list after More button click), the destination
    // bcomes the ajax query. Looks like a D8 fix is on the way: http://drupal.org/node/1181370
    $path = 'node/' . $node->tid;
    $destination = array('destination' => $path);
  }

  switch ($node->match_status) {
    case MATCH_STATUS_AWAITING_CHALLENGE_ACCEPT:
      if (match_access('challenge_respond', $node)) {
        $actions['challenge-respond'] = array(
          'title' => t('Respond to challenge'),
          'href' => 'node/' . $node->nid . '/action/challenge_respond',
          'query' => $destination,
        );
      }
      if (match_access('challenge_cancel', $node)) {
        $actions['challenge-cancel'] = array(
          'title' => t('Cancel challenge'),
          'href' => 'node/' . $node->nid . '/action/challenge_cancel',
          'query' => $destination,
        );
      }
      break;

    case MATCH_STATUS_AWAITING_RESULT:
      if (match_access('result_enter', $node)) {
        $actions['result-enter'] = array(
          'title' => t('Enter result'),
          'href' => 'node/' . $node->nid . '/action/result_enter',
          'query' => $destination,
        );
      }
      if (match_access('date_enter', $node)) {
        $actions['date-enter'] = array(
          'title' => t('Request a new date'),
          'href' => 'node/' . $node->nid . '/action/date_enter',
          'query' => $destination,
        );
      }
      break;

    case MATCH_STATUS_AWAITING_RESULT_ACCEPT:
      if (match_access('result_enter', $node)) {
        $actions['result-enter'] = array(
          'title' => t('Enter result'),
          'href' => 'node/' . $node->nid . '/action/result_enter',
          'query' => $destination,
        );
      }
      if (match_access('result_respond', $node)) {
        $actions['result-respond'] = array(
          'title' => t('Respond to result'),
          'href' => 'node/' . $node->nid . '/action/result_respond',
          'query' => $destination,
        );
      }
      if (match_access('result_cancel', $node)) {
        $actions['result-cancel'] = array(
          'title' => t('Cancel result'),
          'href' => 'node/' . $node->nid . '/action/result_cancel',
          'query' => $destination,
        );
      }
      break;

    case MATCH_STATUS_AWAITING_DATE_ACCEPT:
      if (match_access('date_respond', $node)) {
        $actions['date-respond'] = array(
          'title' => t('Respond to date request'),
          'href' => 'node/' . $node->nid . '/action/date_respond',
          'query' => $destination,
        );
      }
      if (match_access('date_cancel', $node)) {
        $actions['date-cancel'] = array(
          'title' => t('Cancel date request'),
          'href' => 'node/' . $node->nid . '/action/date_cancel',
          'query' => $destination,
        );
      }
      break;

    case MATCH_STATUS_FINISHED:
      break;
  }

  // Allow other modules to add actions
  drupal_alter('match_actions', $actions, $node);

  return $actions;
}

/**
 * Calculate the percentage of matches won by the given
 * participant entity ID.
 *
 * @param $entity_type
 * @param $id
 *   Participant entity ID
 *
 * @return
 *   The win percent ratio as a 1 point decimal
 */
function match_win_ratio($entity_type, $id) {
  $query = db_select('matches', 'm');
  $query->join('matches_participants', 'mp', 'm.nid = mp.nid');
  $result = $query->fields('m', array('winner'))
    ->condition('m.entity_type', $entity_type)
    ->condition('mp.id', $id)
    ->condition('m.match_status', MATCH_STATUS_FINISHED)
    ->execute();

  $win = 0;
  $count = 0;
  foreach ($result as $record) {
    if ($record->winner == $id) {
      $win++;
    }
    $count++;
  }

  $percent = ($win / $count) * 100;
  return number_format($percent, 1);
}

/**
 * Returns the correct action description.
 *
 * @param $node
 *   The match node object.
 * @param $delta
 *   The action being performed.
 *
 * @return string
 *   Returns a translated string of the action description.
 */
function _match_action_description($node, $delta) {
  switch ($delta) {
    case 'result_enter':
      $description = t('Enter a result for this match. Scores entered must be numeric.');
      break;

    case 'result_respond':
      if (!empty($node->request_id)) {
        $name = $node->participants[$node->request_id]['name'];
        $description = t('A match result was submitted by %name. Review the score below before responding.', array('%name' => $name));
      }
      else {
        $description = t('A match result was submitted by an administrator. Review the score below before responding.');
      }

      break;

    case 'result_cancel':
      $description = t('Are you sure you want to cancel the submitted result?');
      break;

    case 'date_enter':
    case 'challenge_reverse':
      $description = t('Enter a new match date below. The match opponents must accept this request before it becomes final.');
      break;

    case 'date_respond':
      $name = $node->participants[$node->request_id]['name'];
      $description = t('A match date change was requested by %name. Review the date below before responding.', array('%name' => $name));
      break;

    case 'date_cancel':
      $description = t('Are you sure you want to cancel the date requested?');
      break;

    case 'challenge_respond':
      $name = $node->participants[$node->request_id]['name'];
      $description = t('Review the challenge below before responding.');
      break;

    case 'challenge_cancel':
      $description = t('Are you sure you want to cancel this challenge?');
      break;
  }

  return $description;
}

/**
 * If found, returns a comment for a given match node.
 *
 * @param $node
 *   A match node object.
 */
function match_challenge_comment($node) {
  $comment = db_select('matches_challenges')
    ->fields('matches_challenges', array('comment'))
    ->condition('nid', $node->nid)
    ->execute()
    ->fetchField();

  return !empty($comment) ? $comment : NULL;
}

/**
 * Send mail notifications to match participants
 *
 * @param $node
 *   A match node object
 * @param $key
 *   Mail type delta
 * @param $params
 *   Optional, an array of parameters for drupal_mail()
 * @param $module
 *   Optional, allows for custom modules to use this function.
 */
function match_send_mail($node, $key, $params, $module = 'match') {
  global $user;

  $params['node'] = $node;
  if ($node->entity_type == 'user') {
    $accounts = array($params['entity']);
  }
  else {
    $uids = module_invoke_all('match_participants_extract', $node->entity_type, $params['entity'], TRUE);
    $accounts = user_load_multiple($uids);
  }

  foreach ($accounts as $account) {
    if (!isset($account->data['match']) || $account->data['match'] || !variable_get('match_mail_user', 1)) {
      // Do not email the triggering user
      if ($account->uid != $user->uid) {
        $params['account'] = $account;
        drupal_mail($module, $key, $account->mail, user_preferred_language($account), $params);
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function match_form_user_profile_form_alter(&$form, &$form_state) {
  if ($form['#user_category'] == 'account') {
    $account = $form['#user'];
    $form['match'] = array(
      '#type' => 'checkbox',
      '#title' => t('Send me important match updates via e-mail (recommended)'),
      '#default_value' => isset($account->data['match']) ? $account->data['match'] : 1,
    );
  }
}

/**
 * Implements hook_user_presave().
 */
function match_user_presave(&$edit, $account, $category) {
  if (isset($edit['match'])) {
    $edit['data']['match'] = $edit['match'];
  }
}

/**
 * Implements hook_mail().
 */
function match_mail($key, &$message, $params) {
  global $user;

  $options = array(
    'langcode' => $message['language']->language,
  );

  $node = $params['node'];
  $title = match_title($node);

  switch ($key) {
    case 'result_enter':
    case 'result_enter_admin':
      $scores = array();
      foreach ($params['scores'] as $id => $score) {
        $scores[] = $node->participants[$id]['name'] . ': ' . $score;
      }

      $message['subject'] = t('Match result entered at @site_name', array('@site_name' => variable_get('site_name', 'Drupal')), $options);
      $message['body'][] = t('!name entered a result for your match. See below for details.', array('!name' => $user->name), $options);
      $message['body'][] = t('Match: !title', array('!title' => $title), $options);
      $message['body'][] = t('Result entered: @scores', array('@scores' => implode(', ', $scores)), $options);

      if ($key == 'result_enter') {
        $message['body'][] = t('Respond to the request here: @url', array('@url' => url('node/' . $node->nid . '/action/result_respond', array('absolute' => TRUE))), $options);
      }

      $message['body'][] = t('Match details page: @url', array('@url' => url('node/' . $node->nid, array('absolute' => TRUE))), $options);
      break;

    case 'result_respond_accept':
    case 'result_respond_accept_admin':
      $message['subject'] = t('Match result accepted at @site_name', array('@site_name' => variable_get('site_name', 'Drupal')), $options);
      $message['body'][] = t('Your match result was accepted by @name.', array('@name' => $user->name), $options);
      $message['body'][] = t('Match: !title', array('!title' => $title), $options);
      $message['body'][] = t('Match details page: @url', array('@url' => url('node/' . $node->nid, array('absolute' => TRUE))), $options);
      break;

    case 'result_respond_reject':
      $message['subject'] = t('Match result rejected at @site_name', array('@site_name' => variable_get('site_name', 'Drupal')), $options);
      $message['body'][] = t('Your match result was rejected by @name.', array('@name' => $user->name), $options);
      $message['body'][] = t('Match: !title', array('!title' => $title), $options);
      $message['body'][] = t('Match details page: @url', array('@url' => url('node/' . $node->nid, array('absolute' => TRUE))), $options);
      break;

    case 'date_enter':
      $message['subject'] = t('Match date change request at @site_name', array('@site_name' => variable_get('site_name', 'Drupal')), $options);
      $message['body'][] = t('@name requested to change the date for your match. See below for details.', array('@name' => $user->name), $options);
      $message['body'][] = t('Match: !title', array('!title' => $title), $options);
      $message['body'][] = t('New date: @date', array('@date' => format_date($params['date'], 'medium', '', NULL, $options['langcode'])), $options);
      $message['body'][] = t('Respond to the request here: @url', array('@url' => url('node/' . $node->nid . '/action/date_respond', array('absolute' => TRUE))), $options);
      $message['body'][] = t('Match details page: @url', array('@url' => url('node/' . $node->nid, array('absolute' => TRUE))), $options);
      break;

    case 'date_respond_accept':
      $message['subject'] = t('Match date change request accepted at @site_name', array('@site_name' => variable_get('site_name', 'Drupal')), $options);
      $message['body'][] = t('Your date change request was accepted by !name.', array('!name' => $user->name), $options);
      $message['body'][] = t('Match: !title', array('!title' => $title), $options);
      $message['body'][] = t('New date: @date', array('@date' => format_date($node->match_date, 'medium', '', NULL, $options['langcode'])), $options);
      $message['body'][] = t('Match details page: @url', array('@url' => url('node/' . $node->nid, array('absolute' => TRUE))), $options);
      break;

    case 'date_respond_reject':
      $message['subject'] = t('Match date change request rejected at @site_name', array('@site_name' => variable_get('site_name', 'Drupal')), $options);
      $message['body'][] = t('Your date change request was rejected by !name.', array('!name' => $user->name), $options);
      $message['body'][] = t('Match: !title', array('!title' => $title), $options);
      $message['body'][] = t('Match details page: @url', array('@url' => url('node/' . $node->nid, array('absolute' => TRUE))), $options);
      break;

    case 'challenge_enter':
      $message['subject'] = t('Match challenge at @site_name', array('@site_name' => variable_get('site_name', 'Drupal')), $options);
      $message['body'][] = t('!name challenged you to a match. See below for details.', array('!name' => $user->name), $options);
      $message['body'][] = t('Match: !title', array('!title' => $title), $options);
      $message['body'][] = t('Date: @date', array('@date' => format_date($node->match_date, 'medium', '', NULL, $options['langcode'])), $options);

      if (!empty($node->tid)) {
        $tournament = node_load($node->tid);
        $message['body'][] = t('Tournament: !title', array('!title' => $tournament->title), $options);
      }

      $message['body'][] = t('Respond to the request here: @url', array('@url' => url('node/' . $node->nid . '/action/challenge_respond', array('absolute' => TRUE))), $options);
      break;

    case 'challenge_reverse':
      $message['subject'] = t('Challenge date change request at @site_name', array('@site_name' => variable_get('site_name', 'Drupal')), $options);
      $message['body'][] = t('@name requested to change the date for your match challenge. See below for details.', array('@name' => $user->name), $options);
      $message['body'][] = t('Match: !title', array('!title' => $title), $options);
      $message['body'][] = t('New date: @date', array('@date' => format_date($params['date'], 'medium', '', NULL, $options['langcode'])), $options);
      $message['body'][] = t('Respond to the request here: @url', array('@url' => url('node/' . $node->nid . '/action/challenge_respond', array('absolute' => TRUE))), $options);
      break;

    case 'challenge_respond_accept':
      $message['subject'] = t('Challenge accepted at @site_name', array('@site_name' => variable_get('site_name', 'Drupal')), $options);
      $message['body'][] = t('Your match challenge was accepted by !name. See below for details.', array('!name' => $user->name), $options);
      $message['body'][] = t('Match: !title', array('!title' => $title), $options);
      $message['body'][] = t('Date: @date', array('@date' => format_date($node->match_date, 'medium', '', NULL, $options['langcode'])), $options);
      $message['body'][] = t('Match details page: @url', array('@url' => url('node/' . $node->nid, array('absolute' => TRUE))), $options);
      break;
  }
}

/**
 * Returns an associative array of match participants
 * names keyed by entity ID.
 */
function _match_participant_options($node) {
  if (!isset($node->participants)) {
    return array();
  }

  $options = array();
  foreach ($node->participants as $id => $participant) {
    $options[$id] = $participant['name'];
  }

  return $options;
}


/**
 * Returns an associative array of match statuses.
 *
 * @param $status
 *   Optional, a match status to return
 */
function match_status_list($status = NULL) {
  $statuses = array(
    MATCH_STATUS_NONE                       => t('None'),
    MATCH_STATUS_AWAITING_CHALLENGE_ACCEPT  => t('Awaiting challenge accept'),
    MATCH_STATUS_AWAITING_DATE_ACCEPT       => t('Awaiting date change accept'),
    MATCH_STATUS_AWAITING_RESULT            => t('Awaiting result'),
    MATCH_STATUS_AWAITING_RESULT_ACCEPT     => t('Awaiting result accept'),
    MATCH_STATUS_FINISHED                   => t('Finished'),
  );

  if (isset($status)) {
    return $statuses[$status];
  }

  return $statuses;
}

/**
 * Performs updates for match participant records
 *
 * @param $node
 *   A match node.
 * @param $values
 *   Associative array of new values keyed by field name
 * @param $id
 *   Optional, a specific participant id to apply updates to
 */
function match_update_participants($node, $values, $id = NULL) {
  $query = db_update('matches_participants')
    ->fields($values)
    ->condition('nid', $node->nid);

  if (isset($id)) {
    $query->condition('id', $id);

    $node->participants[$id] = array_merge($node->participants[$id], $values);
  }
  else {
    // Update referenced $node to the latest values
    foreach ($node->participants as $id => $participant) {
      $node->participants[$id] = array_merge($participant, $values);
    }
  }

  $query->execute();
}

/**
 * Deletes participant from a match node.
 */
function match_remove_participant($node, $id) {
  db_delete('matches_participants')
    ->condition('nid', $node->nid)
    ->condition('id', $id)
    ->execute();
}

/**
 * @param $node
 *   A match node object.
 *
 * @param $delta
 *   The action being carried out on the match.
 *
 * @param $variables
 *   Custom data to be stored in the log.
 */
function match_log($node, $delta, $variables = NULL) {
  global $user;

  $match = array(
    'nid' => $node->nid,
    'match_status' => $node->match_status,
    'request_id' => $node->request_id,
    'uid' => $user->uid,
    'hostname' =>ip_address(),
    'created' => REQUEST_TIME,
    'delta' => $delta
  );

  if (isset($variables)) {
    $match['variables'] = $variables;
  }

  drupal_write_record('matches_log', $match);

  // If the same hostname both makes a request and accepts the request,
  // flag this is a potential cheating issue.
  if ($delta == 'result_respond_accept' || $delta == 'date_respond_accept' || $delta == 'challenge_respond_accept') {

    switch ($delta) {
      case 'result_respond_accept':
        $request_delta = 'result_enter';
        break;
      case 'date_respond_accept':
        $request_delta = 'date_enter';
        break;
      case 'challenge_respond_accept':
        $request_delta = 'challenge_enter';
        break;
    }

    $query = db_select('matches_log')
      ->condition('nid', $match['nid'])
      ->condition('delta', 'result_enter')
      ->condition('hostname', $match['hostname'])
      ->countQuery()
      ->execute()
      ->fetchField();

    if (!empty($query)) {
      watchdog('match', 'Match IP conflict', NULL, WATCHDOG_WARNING, l(t('Go to match page'), 'node/' . $match['nid']));
    }
  }
}

/**
 * Converts the checkbox administrator variable into a
 * select field element style options array.
 *
 * @see match_form().
 */
function match_entity_types_list() {
  $info = entity_get_info();
  $entity_types = variable_get('match_entity_types', array('user'));

  $options = array();
  foreach ($entity_types as $type) {
    if ($type && isset($info[$type])) {
      $options[$type] = $info[$type]['label'];
    }
  }

  return $options;
}

/**
 * Load all matches for a given tournament
 *
 * @param $node
 *  Tournament node object
 * @return
 *  Array of match nodes
 */
function match_load_tournament_matches($node) {
  $nids = db_select('matches', 'm')
    ->fields('m', array('nid'))
    ->condition('m.tid', $node->nid)
    ->execute()
    ->fetchCol();

  if (!empty($nids)) {
    return node_load_multiple($nids);
  }
}

/*
 * Validation function to ensure participant weights are unique when editing
 */
function match_participant_weight_validate($element, $form_state,  $complete_form) {
  $weights = array();
  foreach($form_state['values']['participants'] as $id => $participant) {
    if (is_numeric($id)) {
      if (isset($weights[$participant['weight']])) {
        form_error($element['participants'][$id]['weight'], t('Participant weight must be unique.'));
      }
      else {
        $weights[$participant['weight']] = TRUE;
      }
    }
  }
}