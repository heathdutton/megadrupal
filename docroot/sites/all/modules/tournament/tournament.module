<?php

/**
 * Tournament statuses
 */
define('TOURNAMENT_STATUS_ACTIVE', 1);
define('TOURNAMENT_STATUS_STARTED', 4);
define('TOURNAMENT_STATUS_FINISHED', 8);

/**
 * Tournament signup access denied
 */
define('TOURNAMENT_ACCESS_DENIED', 'deny');

/**
 * Implements hook_help().
 */
function tournament_help($path, $arg) {
  if (substr($path, 0, 9) == 'node/add/') {
    // Prepare the content type name
    $node_type = substr($path, 9);
    $node_type = node_type_load($node_type);

    if (tournament_supported_type($node_type->type)) {
      $output = '<p>' . t('Tournaments take place over a total of 3 steps.') . '</p>'; // TODO
      $output .= '<ol>';
      $output .= '<li>' . t('<strong>Create a tournament</strong>. You are able to edit settings after the tournament is created.') . '</li>';
      $output .= '<li>' . t('<strong>Gather participants</strong>. Before you can start your tournament, participants must sign up to play.') . '</li>';
      $output .= '<li>' . t('<strong>Start</strong>. When you are ready for participants to play matches, hit the <em>Start tournament</em> button on the tournament page. Remember, you cannot delete a tournament after it has been started!') . '</li>';
      $output .= '</ol>';
      return $output;
    }
  }
}

/**
 * Implements hook_permission().
 */
function tournament_permission() {
  return array(
    'add tournament participant' => array(
      'title' => t('Add participants to tournaments'),
    ),
    'join tournaments' => array(
      'title' => t('Sign up to tournaments'),
    ),
    'import participants' => array(
      'title' => t('Import participants into tournaments'),
    ),
  );
}

/**
 * Implements hook_node_info().
 */
function tournament_node_info() {
  return array(
    'tournament' => array(
      'name' => t('Tournament'),
      'base' => 'tournament',
      'description' => t('A tournament that has no special match functions. This could be used for an event that just needs basically functionality, (e.g. participant management).'),
      'title_label' => t('Tournament title'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function tournament_menu() {
  $items['tournament/autocomplete'] = array(
    'title' => 'Tournament autocomplete',
    'page callback' => 'tournament_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
    'file' => 'tournament.pages.inc',
  );

  $items['admin/config/competition/tournament'] = array(
    'title' => 'Tournaments',
    'description' => 'Configure general tournament settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tournament_admin_settings'),
    'access arguments' => array('access administration pages'),
    'file' => 'tournament.admin.inc',
  );

  $items['node/%node/edit/settings'] = array(
    'title' => 'Settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['node/%node/edit/participants'] = array(
    'title' => 'Manage participants',
    'page callback' => 'tournament_edit_participants',
    'page arguments' => array(1),
    'access callback' => 'tournament_update_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'file' => 'tournament.pages.inc',
    'weight' => 5,
  );
  $items['node/%node/edit/participants/add'] = array(
    'title callback' => '_tournament_participant_add_title',
    'title arguments' => array(1),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tournament_participant_add_form', 1),
    'access callback' => 'tournament_participant_add_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'tournament.pages.inc',
  );
  $items['node/%node/edit/participants/%/remove'] = array(
    'title' => 'Remove participant',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tournament_participant_remove_confirm', 1, 4),
    'access callback' => 'tournament_participant_remove_access',
    'access arguments' => array(1, 4),
    'type' => MENU_CALLBACK,
    'file' => 'tournament.pages.inc',
  );
  $items['node/%node/edit/participants/%/replace'] = array(
    'title' => 'Replace participant',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tournament_participant_replace_form', 1, 4),
    'access callback' => 'tournament_participant_replace_access',
    'access arguments' => array(1, 4),
    'type' => MENU_CALLBACK,
    'file' => 'tournament.pages.inc',
  );
  $items['node/%node/edit/participants/import'] = array(
    'title' => 'Import',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tournament_participant_import_form', 1),
    'access callback' => 'tournament_participant_import_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'tournament.pages.inc',
  );
  $items['node/%node/edit/admins'] = array(
    'title' => 'Manage admins',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tournament_admins_form', 1),
    'access callback' => 'tournament_admins_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'file' => 'tournament.pages.inc',
    'weight' => 10,
  );
  $items['node/%node/signup'] = array(
    'title' => 'Sign up',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tournament_signup_form', 1),
    'access callback' => '_tournament_signup_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'tournament.pages.inc',
  );
  $items['node/%node/leave'] = array(
    'title' => 'Leave',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tournament_leave_form', 1),
    'access callback' => '_tournament_leave_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'tournament.pages.inc',
  );
  $items['node/%node/start'] = array(
    'title' => 'Start tournament',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('tournament_start_form', 1),
    'access callback' => '_tournament_start_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'tournament.pages.inc',
  );

  return $items;
}

/**
 * Title callback; Add a participant to a tournament
 */
function _tournament_participant_add_title($node) {
  $info = entity_get_info();
  $label = strtolower($info[$node->entity_type]['label']);
  return t('Add a @label', array('@label' => t($label)));
}

/**
 * Invoke tournament access checks to a specific tournament type.
 *
 * @param $op
 *   Access type.
 * @param $node
 *   A tournament node object.
 *
 * @return FALSE if access is denied by the tournament type.
 */
function tournament_access_invoke($op, $node) {
  if ($node->type != 'tournament') {
    $access = module_invoke($node->type, 'tournament_access_' . $op, $node);

    // We must explicitly check if a boolean value was returned
    if (is_bool($access)) {
      return $access;
    }
  }

  return TRUE;
}

/**
 * Access callback for tournament signup form
 */
function _tournament_signup_access($node) {
  if (tournament_supported_type($node->type)) {
    if (!$node->signup_access || !$node->status) {
      return FALSE;
    }

    // Global access check
    if (!user_access('join tournaments')) {
      return FALSE;
    }

    // Full list of participants the user has access over
    $ids = match_participants_access_list($node->entity_type);

    if (!empty($ids)) {
      // Return participants that are already signed up from $ids
      $ids_exist = tournament_participants_exist($node, $ids);

      if (count($ids) == $ids_exist) {
        // All of the participants the user has access over
        // are already signed up.
        return FALSE;
      }
    }

    return TRUE;
  }
}

/**
 * Access callback for tournament leave form
 */
function _tournament_leave_access($node) {
  if (tournament_supported_type($node->type)) {
    // Full list of participant the user has access over
    $ids = match_participants_access_list($node->entity_type);

    if (!empty($ids)) {
      // Return participants that are already signed up from $ids
      $ids_exist = tournament_participants_exist($node, $ids);

      if (!empty($ids_exist)) {
        // Allow tournament types to alter leave access
        return tournament_access_invoke('leave', $node);
      }
    }
  }
}

/**
 * Access callback for managing tournaments
 */
function tournament_update_access($node) {
  return tournament_supported_type($node->type) && node_access('update', $node);
}

/**
 * Access callback for starting tournaments
 */
function _tournament_start_access($node) {
  return tournament_update_access($node) && $node->tournament_status == TOURNAMENT_STATUS_ACTIVE;
}

/**
 * Access callback for tournament participant add callback
 */
function tournament_participant_add_access($node) {
  return tournament_update_access($node) && user_access('add tournament participant');
}

/**
 * Access callback for importing tournament participants
 */
function tournament_participant_import_access($node) {
  return tournament_update_access($node) && user_access('import participants');
}

/**
 * Access callback for editing tournament admins
 */
function tournament_admins_access($node) {
  global $user;
  if (!tournament_update_access($node)) {
    return FALSE;
  }

  return $user->uid == $node->uid || user_access('bypass node access');
}

/**
 * Access callback for tournament participant removal callback
 */
function tournament_participant_remove_access($node, $id) {
  if (!tournament_update_access($node) || !tournament_participants_exist($node, $id)) {
    return FALSE;
  }

  // Participants can always be removed
  return TRUE;
}

/**
 * Access callback for tournament participant replace callback
 */
function tournament_participant_replace_access($node, $id = NULL) {
  if (isset($id) && !tournament_participants_exist($node, $id, 1)) {
    return FALSE;
  }

  // Participants can always be replaced
  return TRUE;
}

/**
 * Sends mail notifications to tournament admins
 *
 * @param $node
 *   A tournament node object
 * @param $key
 *   Mail type delta
 * @param $params
 *   Optional, an array of parameters for drupal_mail()
 * @param $module
 *   The module which will handle the rendering of the mail in hook_mail().
 */
function tournament_mail_admins($node, $key, $params = array(), $module = 'tournament') {
  global $user;

  $uids = db_select('tournament_admins', 'ta')
    ->fields('ta', array('uid'))
    ->condition('nid', $node->nid)
    ->condition('uid', $user->uid, '<>') // Don't mail current user
    ->execute()
    ->fetchCol();

  if (empty($uids)) {
    return;
  }

  // Load user account objects
  $accounts = user_load_multiple($uids);

  if (!empty($accounts)) {
    $params['node'] = $node;
    foreach ($accounts as $account) {
      $params['account'] = $account;
      drupal_mail($module, $key . '_admin', $account->mail, user_preferred_language($account), $params);
    }
  }
}

/**
 * Implements hook_mail().
 */
function tournament_mail($key, &$message, $params) {
  global $user;

  $options = array(
    'langcode' => $message['language']->language,
  );

  switch ($key) {
    case 'participant_add_admin':
      $id = $params['participant_id'];
      $node = $params['node'];
      $entity = entity_load($node->entity_type, array($id));
      $label = entity_label($node->entity_type, $entity[$id]);

      $message['subject'] = t('A new participant joined your tournament at @site_name', array('@site_name' => variable_get('site_name', 'Drupal')), $options);
      $message['body'][] = t('!name joined your tournament !tournament.', array('!name' => $label, '!tournament' => $node->title), $options);
      $message['body'][] = t('Follow this link to view your tournament: @url', array('@url' => url('node/' . $node->nid, array('absolute' => TRUE))), $options);
      break;
  }
}

/**
 * Implements hook_theme().
 */
function tournament_theme() {
  return array(
    'tournament_admins_form_admins' => array(
      'render element' => 'element',
      'file' => 'tournament.pages.inc',
    ),
  );
}

/**
 * Determines if a given user account is a participant in a tournament
 * regardless of it's entity type.
 */
function tournament_user_exist($node, $account = NULL) {
  if (!user_is_logged_in()) {
    return FALSE;
  }

  // If no user object is supplied, the access check is for the current user
  if (empty($account)) {
    $account = $GLOBALS['user'];
  }

  // Full list of participants the user has access over
  $ids = match_participants_access_list($node->entity_type, array(), $account);

  if (!empty($ids)) {
    // Return participants that exist from $ids
    $ids_exist = tournament_participants_exist($node, $ids);

    return !empty($ids_exist);
  }

  return FALSE;
}

/**
 * Determines if a given list of participants exist in a given
 * tournament. Returns count.
 *
 * @param $node
 *   A tournament supported node.
 * @param $ids
 *   A single or array of participant entity IDs.
 * @param $status
 *   Optional, a participant status to match checks on.
 *
 * @return
 *   The count of participants from $ids that exist in
 *   the tournament.
 */
function tournament_participants_exist($node, $ids, $status = NULL) {
  $ids = !is_array($ids) ? array($ids) : $ids;

  $nodes = &drupal_static(__FUNCTION__);
  if (!empty($nodes[$node->nid])) {
    foreach ($nodes[$node->nid] as $cache) {
      if ($cache['ids'] == $ids) {
        return $cache['count'];
      }
    }
  }

  $query = db_select('tournament_participants')
    ->fields('tournament_participants', array('id'))
    ->condition('nid', $node->nid)
    ->condition('id', $ids);

  if (!empty($status)) {
    $query->condition('status', $status);
  }
  else {
    $query->condition('status', 0, '>');
  }

  $count = $query->countQuery()
    ->execute()
    ->fetchField();

  // Set cache
  $nodes[$node->nid][] = array(
    'ids' => $ids,
    'count' => $count,
  );
  
  return $count;
}

/**
 * Determines if a given list of participants exist in a given
 * tournament. Returns an array.
 *
 * @param $node
 *   A tournament supported node.
 * @param $ids
 *   A single or array of participant entity IDs.
 *
 * @return
 *   An array of participant ids, from the given $ids, that exist
 *   in the tournament.
 */
function tournament_participants_exist_list($node, $ids) {
  $ids = !is_array($ids) ? array($ids) : $ids;

  $ids_exist = db_select('tournament_participants')
    ->fields('tournament_participants', array('id'))
    ->condition('nid', $node->nid)
    ->condition('id', $ids)
    ->condition('status', 0, '>')
    ->execute()
    ->fetchCol();

  foreach ($ids as $key => $id) {
    if (!in_array($id, $ids_exist)) {
      unset($ids[$key]);
    }
  }

  return $ids;
}

/**
 * Returns a tournament participant status.
 *
 * @param node
 *   A tournament node object.
 * @param $id
 *   A participant entity ID.
 *
 * @return
 *   The participant status as an integer.
 */
function tournament_participant_status($node, $id) {
  $status = db_select('tournament_participants')
    ->fields('tournament_participants', array('status'))
    ->condition('nid', $node->nid)
    ->condition('id', $id)
    ->execute()
    ->fetchField();

  return $status;
}

/**
 * Implements hook_block_info().
 */
function tournament_block_info() {
  $blocks['active_participants'] = array(
    'info' => t('Tournament participants (Active)'),
    'cache' => DRUPAL_NO_CACHE,
  );
  $blocks['waiting_participants'] = array(
    'info' => t('Tournament participants (Waiting list)'),
    'cache' => DRUPAL_NO_CACHE,
  );  

  return $blocks;
}

/**
 * Implements hook_block_view().
 */
function tournament_block_view($delta = '') {
  $block = array();
  
  if ($node = menu_get_object()) {
    if (tournament_supported_type($node->type) && _tournament_list_participants_access($node)) {
      $limit = variable_get('tournament_participants_max', 0);
      
      switch ($delta) {
        case 'active_participants':
          if ($node->type == 'instant_team') {
            $limit = 0;
          }
          $participants = tournament_list_participants($node, 1, $limit);
          $status = 1;
          $count = tournament_participant_count($node, $status);
          $title = t('Participants (@count)', array('@count' => $count));
          break;
          
        case 'waiting_participants':
          $participants = tournament_list_participants($node, 2, $limit);
          $status = 2;
          $count = tournament_participant_count($node, $status);
          $title = t('Waiting list (@count)', array('@count' => $count));
          break;
      }
      
      if (isset($participants) && isset($title)) {
        if (tournament_update_access($node)) {
          $title = l($title, 'node/' . $node->nid . '/edit/participants');
        }
        
        // Add a more link
        if ($limit > 0 && $count > 0) {
          $participants['more'] = drupal_get_form('tournament_list_participants_form', $node, $status);
        }
        
        $participants['#prefix'] = '<div class="participants-wrapper">';
        $participants['#suffix'] = '</div>';
        
        $block['subject'] = $title;
        $block['content'] = $participants;
      }
    }
  }
  
  return $block;
}

function tournament_participant_count($node, $status) {
  return db_select('tournament_participants', 'tp')
    ->fields('tp')
    ->condition('nid', $node->nid)
    ->condition('status', $status)
    ->countQuery()
    ->execute()
    ->fetchField();  
}

/**
 * Implements hook_form().
 */
function tournament_form($node, &$form_state) {
  // Implements vertical tab css fix for a core d7 issue: http://drupal.org/node/1143712
  drupal_add_css(drupal_get_path('module', 'tournament') . '/css/tournament-form.css');

  $type = node_type_get_type($node);

  // General tournament settings
  $form['settings'] = array(
    '#type' => 'vertical_tabs',
  );

  $form['general'] = array(
    '#title' => t('General settings'),
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#group' => 'settings',
    '#weight' => 0,
  );
  $form['general']['title'] = array(
    '#type' => 'textfield',
    '#title' => check_plain(t($type->title_label)),
    '#default_value' => !empty($node->title) ? $node->title : '',
    '#required' => TRUE,
    '#description' => variable_get('tournament_title_lock', 0) ? t('You are unable to change the title after starting a tournament.') : '',
  );
  $form['general']['start'] = array(
    '#title' => t('Start date'),
    '#type' => 'match_date',
    '#size' => 10,
    '#time_increment' => 10,
    '#default_value' => !empty($node->start) ? $node->start : REQUEST_TIME,
    '#required' => TRUE,
    '#description' => t('This date is only a guideline for participants. The tournament will not start until you hit the <em>Start tournament</em> button on the tournament page.'),
  );
  
  if (!empty($node->entity_type) && $node->entity_type == 'user') {
    $form['general']['structure'] = array(
      '#type' => 'item',
      '#title' => t('Format'),
      '#markup' => '1v1',
    );
  }
  else {
    $form['general']['structure'] = array(
      '#type' => 'select',
      '#title' => t('Format'),
      '#options' => array(1 => '1v1'),
    );    
  }
  $form['general']['size'] = array(
    '#type' => 'textfield',
    '#title' => t('Size'),
    '#default_value' => !empty($node->size) ? $node->size : '',
    '#element_validate' => array('element_validate_integer'),
    '#size' => 3,
    '#description' => t('The number of participants in this tournament. Once this limit has been reached, new sign ups will be automatically added to a waiting list. <strong>Leave blank for no limit.</strong>'),
  );

  // Hide these settings after a tournament has started as they loose their meaning
  if (!empty($node->tournament_status) && $node->tournament_status != TOURNAMENT_STATUS_ACTIVE) {
    $form['general']['size']['#disabled'] = TRUE;

    if (variable_get('tournament_title_lock', 0)) {
      $form['general']['title']['#disabled'] = TRUE;
    }
  }

  // Sign up settings
  $form['signup'] = array(
    '#title' => t('Sign up settings'),
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#group' => 'settings',
    '#weight' => 10,
  );
  $form['signup']['signup_access'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow participants to sign up for your tournament'),
    '#default_value' => isset($node->signup_access) ? $node->signup_access : 1,
  );
  $form['signup']['settings'] = array(
    '#type' => 'container',
    '#states' => array(
      'visible' => array(
        ':input[name="signup_access"]' => array('checked' => TRUE),
      ),
    ),
  );
  $form['signup']['settings']['signup_pass_status'] = array(
    '#type' => 'checkbox',
    '#title' => t('Password protect the tournament sign up'),
    '#default_value' => !empty($node->signup_pass) ? 1 : 0,
  );
  $form['signup']['settings']['signup_pass'] = array(
    '#type' => 'password_confirm',
    '#size' => 15,
    '#process' => array('form_process_password_confirm'),
    '#description' => !empty($node->signup_pass) ? t('To change the current password, enter the new password in both fields.') : '',
  );
  $form['signup']['settings']['signup_deadline_status'] = array(
    '#type' => 'checkbox',
    '#title' => t('Set a deadline for participants to sign up by'),
    '#default_value' => !empty($node->signup_deadline) ? 1 : 0,
  );
  $form['signup']['settings']['signup_deadline_date'] = array(
    '#title' => t('Deadline'),
    '#type' => 'match_date',
    '#size' => 10,
    '#time_increment' => 10,
    '#default_value' => !empty($node->signup_deadline) ? $node->signup_deadline : REQUEST_TIME,
    '#description' => t('After this date has passed, participants will not be able to sign up to this tournament.'),
    '#states' => array(
      'visible' => array(
        ':input[name="signup_deadline_status"]' => array('checked' => TRUE),
      ),
    ),
  );
  $form['signup']['settings']['signup_role_status'] = array(
    '#type' => 'checkbox',
    '#title' => t('Users must have a specific role'),
    '#default_value' => !empty($node->signup_role) ? 1 : 0,
  );
  $form['signup']['settings']['signup_role'] = array(
    '#type' => 'select',
    '#title' => t('User role'),
    '#options' => user_roles(TRUE, 'join tournaments'),
    '#default_value' => !empty($node->signup_role) ? $node->signup_role : 0,
    '#states' => array(
      'visible' => array(
        ':input[name="signup_role_status"]' => array('checked' => TRUE),
      ),
    ),
  );

  $form['advanced'] = array(
    '#title' => t('Advanced settings'),
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#group' => 'settings',
    '#weight' => 15,
  );
  $form['advanced']['score_access'] = array(
    '#type' => 'checkbox',
    '#title' => t('Participants can enter scores for their own matches.'),
    '#default_value' => isset($node->score_access) ? $node->score_access : 1,
  );
  $form['advanced']['list_participants'] = array(
    '#type' => 'checkbox',
    '#title' => t('Show the participant list on the tournament page'),
    '#default_value' => isset($node->list_participants) ? $node->list_participants : 1,
  );
 $form['advanced']['new_match_dates'] = array(
    '#type' => 'checkbox',
    '#title' => t('Allow users to request new match dates'),
    '#default_value' => isset($node->new_match_dates) ? $node->new_match_dates : 1,
  );

  if (!empty($node->nid) && $alias = drupal_lookup_path('alias', 'node/' . $node->nid)) {
    $form['advanced']['alias'] = array(
      '#type' => 'item',
      '#title' => t('Alias'),
      '#markup' => t('This tournament is now accessible at <a href="@url">@url</a>.', array('@url' => url($alias, array('absolute' => TRUE)))),
      '#weight' => 4,
    );
  }
  else {
    $form['advanced']['alias'] = array(
      '#type' => 'textfield',
      '#title' => t('Alias'),
      '#field_prefix' => 't/',
      '#description' => t('An alias allows you to promote your presence on @site-name with a short URL. For example, an alias of "flowers" would appear as the URL <em>!domain/flowers</em>.<br />WARNING: You are unable to change your alias after it is decided.', array('!domain' => $_SERVER['HTTP_HOST'] . '/t', '@site-name' => variable_get('site_name', 'Drupal'))),
      '#weight' => 4,
      '#size' => 20,
      '#element_validate' => array('tournament_alias_validate'),
    );
  }

  return $form;
}

/**
 * Validate a given user alias.
 */
function tournament_alias_validate($element, &$form_state, $form) {
  if (!empty($element['#value'])) {
    $alias = trim($element['#value']);
    $path = 't/' . $alias;

    // Check for bogus characters
    if (preg_match("/[^a-zA-Z0-9_\-]+/", $alias) > 0) {
      form_set_error('alias', t('You can only use letters, numbers, hyphens and underscores for aliases.'));
    }
    elseif (preg_match("/[a-zA-Z]+/", $alias) == 0) {
      form_set_error('alias', t('You must use one or more alphabetical characters for aliases.'));
    }
    elseif (drupal_get_normal_path($path) != $path) {
      form_set_error('alias', t('Alias not available. The alias entered is already in use.'));
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function tournament_form_node_form_alter(&$form, &$form_state, $form_id) {
  $node = $form['#node'];

  if (tournament_supported_type($node->type)) {
    // Form for new nodes
    if (empty($node->nid)) {
      $form['actions']['submit']['#value'] = t('Create tournament');
    }
    else {
      $form['actions']['submit']['#value'] = t('Save tournament');
    }

    // D7 core does not pass down #states or #attributes with password_confirm
    // elements so we must add them ourselves.
    $form['signup']['settings']['signup_pass']['#pre_render'] = array('tournament_form_process_password_confirm');

    $form['body']['#weight'] = 10;
  }
}

/**
 * pre_render callback function for signup_password password_confirm element.
 *
 * @see tournament_form().
 */
function tournament_form_process_password_confirm($elements) {
  foreach (element_children($elements) as $element) {
    $elements[$element]['#attributes']['autocomplete'] = 'off';
    $elements[$element]['#states'] = array(
      'visible' => array(
        ':input[name="signup_pass_status"]' => array('checked' => TRUE),
      ),
    );
  }

  return $elements;
}

/**
 * Fetch a node object by title.
 *
 * @param $name
 *   String with the tournament's title.
 * @return
 *   A fully-loaded $node object upon successful node load or FALSE if node
 *   cannot be loaded.
 *
 * @see node_load_multiple()
 */
function tournament_load_by_name($title) {
  $nodes = node_load_multiple(array(), array('title' => $title));
  return reset($nodes);
}

/**
 * Implements hook_load().
 */
function tournament_load($nodes) {
  $result = db_query('SELECT * FROM {tournament} WHERE nid IN (:nids)', array(':nids' => array_keys($nodes)));
  foreach ($result as $fields) {
    $nid = $fields->nid;
    foreach ($fields as $key => $value) {
      if (!isset($nodes[$nid]->$key)) {
        $nodes[$nid]->$key = $value;
      }
    }
  }
}

/**
 * Restructures active participants and those in the waiting
 * list. This usually needs calling when the tournament size has
 * been increased or decreased before it starts.
 *
 * @param $node
 *   A tournament node object.
 *
 * @see tournament_update()
 */
function _tournament_participants_restructure($node) {
  $count = db_select('tournament_participants', 'tp')
    ->fields('tp', array('id'))
    ->condition('nid', $node->nid)
    ->condition('status', 1)
    ->countQuery()
    ->execute()
    ->fetchField();

  // When the size changes, ensure participants are restructured correctly
  if (empty($node->size)) {
    // There is no limit to tournament size, make sure everyone is promoted
    $old_status = 2;
    $new_status = 1;
  }
  elseif ($node->size > $count) {
    // Size increased, lets try to promote some participants
    $diff = $node->size - $count;
    $old_status = 2;
    $new_status = 1;
    $sort = 'ASC';
  }
  elseif ($node->size < $count) {
    // Size decreased, we need to delete some participants
    $diff = $count - $node->size;
    $old_status = 1;
    $new_status = 2;
    $sort = 'DESC';
  }
  else {
    // Everything is as it should be.
    return;
  }

  $query = db_select('tournament_participants', 'tp')
    ->fields('tp', array('id'))
    ->condition('nid', $node->nid)
    ->condition('status', $old_status)
    ->orderBy('registered', $sort);

  if (isset($diff)) {
    $query->range(0, $diff);
  }

  $ids = $query->execute()->fetchCol();

  foreach ($ids as $id) {
    db_update('tournament_participants')
      ->fields(array(
        'status' => $new_status,
      ))
      ->condition('id', $id)
      ->condition('nid', $node->nid)
      ->execute();
  }
}

/**
 * Implements hook_insert().
 */
function tournament_insert($node) {
  if (!empty($node->structure) && $node->structure == '1') {
    $node->entity_type = 'user';
  }
  
  tournament_save($node);
}

/**
 * Implements hook_update().
 */
function tournament_update($node) {
  // When changing the size for pre-start tournaments, restructure participants
  if ($node->size != $node->original->size && !(empty($node->size) && empty($node->original->size))) {
    _tournament_participants_restructure($node);
  }

  tournament_save($node, TRUE);
}

function tournament_save($node, $update = FALSE) {
  $primary_keys = $update ? 'nid' : array();

  // Tournament start date
  if (is_array($node->start)) {
    $node->start = match_date_convert($node->start);
  }

  // Sign up deadline date
  if (isset($node->signup_deadline_status) && empty($node->signup_deadline_status)) {
    $node->signup_deadline = 0;
  }
  elseif (empty($node->signup_deadline_date['date'])) {
    $node->signup_deadline = 0;
  }
  else {
    $node->signup_deadline = match_date_convert($node->signup_deadline_date);
  }

  // Sign up role
  if (isset($node->signup_role_status) && empty($node->signup_role_status)) {
    $node->signup_role = 0;
  }

  // Sign up password
  if (isset($node->signup_pass_status) && empty($node->signup_pass_status)) {
    // Always clear the password when the status is unchecked
    $node->signup_pass = '';
  }
  elseif (empty($node->signup_pass)) {
    // No new password was entered, keep the original
    unset($node->signup_pass);
  }
  else {
    // Hash the join team password
    require_once DRUPAL_ROOT . '/' . variable_get('password_inc', 'includes/password.inc');
    $node->signup_pass = user_hash_password(trim($node->signup_pass));
    // Abort if the hashing failed and returned FALSE.
    if (!$node->signup_pass) {
      return FALSE;
    }
  }

  drupal_write_record('tournament', $node, $primary_keys);

  // Alias
  if (!empty($node->alias)) {
    // Add new drupal path for the team alias
    $path['source'] = 'node/' . $node->nid;
    $path['alias'] = 't/' . trim($node->alias);
    path_save($path);
  }

  if (empty($update)) {
    // Add node author as the first tournament admin
    db_insert('tournament_admins')
      ->fields(array(
        'nid' => $node->nid,
        'uid' => $node->uid,
        'created' => REQUEST_TIME,
      ))
      ->execute();
  }
}

/**
 * Implements hook_delete().
 */
function tournament_delete($node) {
  db_delete('tournament')
    ->condition('nid', $node->nid)
    ->execute();

  db_delete('tournament_participants')
    ->condition('nid', $node->nid)
    ->execute();

  db_delete('tournament_admins')
    ->condition('nid', $node->nid)
    ->execute();

  // Removes any associated paths
  path_delete(array('source' => 'node/' . $node->nid));
}

/**
 * Deletes a participant from a tournament.
 *
 * @param $id
 *   A participant entity ID
 * @param $entity_type
 *   The participant entity type
 * @param $node
 *   Optional, tournament supported node object
 */
function tournament_participant_delete($id, $entity_type, $node = NULL) {
  // When deleting an active participant, we retain their entry
  // in the database. This is to prevent issues with tournament
  // rankings and matches having blank participants.
  $query = db_update('tournament_participants')
    ->fields(array(
      'status' => 0,
    ))
    ->condition('id', $id);

  if (!empty($node)) {
    $nids = array($node->nid);
  }
  else {
    // Return a list of all tournaments the given participant has played in
    $tournaments = db_select('tournament', 't');
    $tournaments->join('tournament_participants', 'tp', 't.nid = tp.nid');

    $nids = $tournaments->fields('t', array('nid'))
    ->condition('t.entity_type', $entity_type)
    ->condition('tp.id', $id)
    ->condition('tp.status', 0, '>')
    ->execute()
    ->fetchCol();
  }

  if (!empty($nids)) {
    // Store the previous status
    $old_status = tournament_participant_status($node, $id);

    // Set the participant to status 0
    $query->condition('nid', $nids)->execute();

    // Load tournaments
    $nodes = node_load_multiple($nids);

    // If there is a waiting list, move someone up from the queue
    foreach ($nodes as $node) {
      if ($node->tournament_status == TOURNAMENT_STATUS_ACTIVE && $old_status == 1) {
        tournament_participant_promote($node);
      }

      // Alert other modules
      module_invoke_all('tournament_participant_delete', $id, $node, $old_status);
    }
  }
}

/**
 * Populate tournament participant names
 */
function tournament_participants_populate_names($node, &$participants) {
  $info = entity_get_info($node->entity_type);
  $entities = entity_load($node->entity_type, array_keys($participants));

  foreach ($participants as $id => $participant) {
    if (isset($entities[$id])) {
      if ($participants[$id]->status) {
        $participants[$id]->name = match_participant_label($node->entity_type, $entities[$id]);
      }
      else {
        $participants[$id]->name = entity_label($node->entity_type, $entities[$id]);
      }

      $participants[$id]->uri = entity_uri($node->entity_type, $entities[$id]);
    }
    else {
      $participants[$id]->name = $info['label'] . ' ' . $id;
    }
  }
}

/**
 * Implements hook_node_access().
 */
function tournament_node_access($node, $op, $account) {
  if ($op == 'update' && is_object($node) && tournament_supported_type($node->type)) {
    $count = db_select('tournament_admins')
      ->condition('nid', $node->nid)
      ->condition('uid', $account->uid)
      ->countQuery()
      ->execute()
      ->fetchField();

    if (!empty($count)) {
      return NODE_ACCESS_ALLOW;
    }
  }
}

/**
 * Add a single participant to a tournament
 *
 * @param $node
 *   A tournament node object.
 * @param $id
 *   A new participant entity id
 */
function tournament_participant_add($node, $id) {
  global $user;

  $participant = array(
    'registered' => REQUEST_TIME,
    'uid' => $user->uid,
  );

  if ($node->tournament_status == TOURNAMENT_STATUS_STARTED) {
    $participant['status'] = 2;
  }
  else {
    $participant['status'] = tournament_is_full($node) ? 2 : 1;
  }

  // There may be previously deleted participants so we should use merge.
  db_merge('tournament_participants')
    ->key(array(
      'nid' => $node->nid,
      'id' => $id,
    ))
    ->fields($participant)
    ->execute();

  // Mail admins
  $params['participant_id'] = $id;
  tournament_mail_admins($node, 'participant_add', $params);

  // Notify other modules
  module_invoke_all('tournament_participant_add', $node, $id);
}

/**
 * Determine whether sign up is full (waiting list).
 *
 * @param $node
 *   A tournament node object.
 */
function tournament_is_full($node) {
  $nodes = &drupal_static(__FUNCTION__);

  if (!isset($nodes[$node->nid])) {
    $count = db_select('tournament_participants')
      ->condition('nid', $node->nid)
      ->condition('status', 1)
      ->countQuery()
      ->execute()
      ->fetchField();

    if (!empty($node->size) && $node->size <= $count) {
      $nodes[$node->nid] = TRUE;
    }
    else {
      $nodes[$node->nid] = FALSE;
    }
  }

  return $nodes[$node->nid];
}

/**
 * Promote a single participant from the waiting list (if exists)
 *
 * @param $node
 *   A tournament node object.
 */
function tournament_participant_promote($node) {
  $participant = db_select('tournament_participants')
    ->fields('tournament_participants')
    ->condition('nid', $node->nid)
    ->condition('status', 2)
    ->orderBy('registered')
    ->range(0, 1)
    ->execute()
    ->fetchObject();

  if (!empty($participant)) {
    db_update('tournament_participants')
      ->fields(array(
        'status' => 1,
      ))
      ->condition('id', $participant->id)
      ->condition('nid', $node->nid)
      ->execute();
  }
}

/**
 * Implements hook_user_cancel().
 *
 * @see tournament_entity_cancel()
 */
function tournament_user_cancel($edit, $account, $method) {
  // Depending on some site setups, user deletion may be disabled.
  module_invoke_all('entity_cancel', $account, 'user');
}

/**
 * Implements hook_entity_delete().
 */
function tournament_entity_delete($entity, $type) {
  $types = match_entity_types_list();

  if (array_key_exists($type, $types)) {
    list($id) = entity_extract_ids($type, $entity);
    tournament_participant_delete($id, $type);
  }
}

/**
 * Return the number of times a given participant has played in any tournament.
 */
function tournament_tournament_count($entity_type, $id) {
  $query = db_select('tournament', 't');
  $query->join('tournament_participants', 'tp', 't.nid = tp.nid');
  $tournaments = $query->fields('t', array('nid'))
    ->condition('t.entity_type', $entity_type)
    ->condition('tp.status', 1)
    ->condition('tp.id', $id)
    ->countQuery()
    ->execute()
    ->fetchField();
  
  return $tournaments;  
}

/**
 * Return the number of times a given participant has played a match.
 */
function tournament_match_count($entity_type, $id) {
  $query = db_select('matches', 'm');
  $query->join('matches_participants', 'mp', 'm.nid = mp.nid');
  $matches = $query->fields('m', array('nid'))
    ->condition('m.entity_type', $entity_type)
    ->condition('m.match_status', MATCH_STATUS_FINISHED)
    ->condition('mp.id', $id)
    ->countQuery()
    ->execute()
    ->fetchField();
  
  return $matches; 
}

/**
 * Implements hook_entity_view().
 */
function tournament_entity_view($entity, $type, $view_mode, $langcode) {
  $types = match_entity_types_list();
  if (!isset($types[$type]) || $view_mode != 'full') {
    return;
  }

  $info = entity_get_info();
  list($id) = entity_extract_ids($type, $entity);

  // Match count
  $matches = tournament_match_count($type, $id);

  // Tournament count
  $tournaments = tournament_tournament_count($type, $id);

  // Match count link
  $links['matches'] = array(
    'title' => t('@count matches', array('@count' => $matches)),
  );

  if (!empty($matches)) {
    $ratio = match_win_ratio($type, $id);
    $links['matches']['title'] .= ' (' . t('@ratio% win', array('@ratio' => $ratio)) . ')';
  }

  // Tournament count link
  $links['tournaments'] = array(
    'title' => t('@count tournaments', array('@count' => $tournaments)),
  );

  $entity->content['tournament_stats'] = array(
    '#theme' => 'links',
    '#links' => $links,
    '#heading' => t('Tournament statistics'),
  );
}

/**
 * Implements hook_entity_cancel().
 * @todo This hook is not part of core. Yet. :)
 */
function tournament_entity_cancel($entity, $type) {
  $types = match_entity_types_list();

  if (array_key_exists($type, $types)) {
    list($id) = entity_extract_ids($type, $entity);
    tournament_participant_delete($id, $type);
  }
}

/**
 * Implementation of hook_views_api().
 */
function tournament_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'tournament') . '/views'
  );
}

/**
 * Determines if a node is a supported tournament node type.
 *
 * @param $type
 *   Optional, A node type as a string.
 * @param $full
 *   Optional, Return the entire type object
 *
 * @return
 *   TRUE if the given node type is a tournament node type.
 *   If no type is provided, returns the full list of supported
 *   tournament types.
 */
function tournament_supported_type($type = NULL, $full = FALSE) {
  $tournament_types = &drupal_static(__FUNCTION__);

  if (empty($tournament_types)) {
    $tournament_types = array();
    foreach (node_type_get_types() as $node_type) {
      if ($node_type->base == 'tournament') {
        $tournament_types[$node_type->type] = $full ? $node_type : $node_type->name;
      }
    }
  }

  if (!empty($type)) {
    return isset($tournament_types[$type]);
  }

  return $tournament_types;
}

function _tournament_get_status($tournament_status = NULL) {
  $statuses = array(
    TOURNAMENT_STATUS_ACTIVE => t('Awaiting start'),
    TOURNAMENT_STATUS_STARTED => t('In progress'),
    TOURNAMENT_STATUS_FINISHED => t('Finished'),
  );

  if (!empty($tournament_status)) {
    return $statuses[$tournament_status];
  }

  return $statuses;
}

/**
 * Implements hook_view().
 */
function tournament_view($node, $view_mode) {
  if ($view_mode == 'full') {
    // Nothing to do here but left it for reference.
  }

  return $node;
}

/**
 * Implements hook_match_finish().
 */
function tournament_match_finish($node) {
  if (isset($node->tournament_node)) {
    if (!tournament_access_invoke('finish', $node->tournament_node)) {
      // In some cases, such as ladders, tournament types may not want to finish
      // the tournament here. Therefore we should invoke this access check.
      return;
    }

    $query = db_select('matches')
      ->condition('tid', $node->tid)
      ->condition('match_status', MATCH_STATUS_FINISHED, '<>')
      ->condition('nid', $node->nid, '<>')
      ->countQuery()
      ->execute()
      ->fetchField();

    if (empty($query)) {
      // All matches in the tournament are finished so finish the
      // entire tournament.
      tournament_finish($node->tournament_node);
    }
  }
}

/**
 * Finish a tournament.
 *
 * @param $node
 *   A tournament node object.
 */
function tournament_finish($node) {
  module_invoke_all('tournament_finish', $node);

  $node->tournament_status = TOURNAMENT_STATUS_FINISHED;
  node_save($node);

  // TODO Notify participants
}

/**
 * Returns participants data for a given tournament.
 *
 * @param $node
 *   A tournament node object.
 * @param $status
 *   Filter participants based on a specific status.
 * @param $limit
 *   Limit the number of returned participant records.
 * @param $offset
 *   The offset for the record limit.
 * 
 * @return
 *   Associative array of tournament participants keyed by
 *   participant ID. Each participant is an object with the
 *   following properties:
 *   - id
 *   - name
 *   - score
 *   - link
 *   - status
 *   - registered
 *   - rank
 */
function tournament_participants_data($node, $status = NULL, $limit = 0, $offset = 0) {
  $query = db_select('tournament_participants', 'tp')
    ->fields('tp', array('id', 'status', 'registered', 'rank'))
    ->condition('nid', $node->nid)
    ->orderBy('registered', 'DESC');
  
  if (isset($status)) {
    $query->condition('status', $status);
  }
  else {
    $query->condition('status', 0, '>');
  }

  if (!empty($limit)) {
    $query->range(0, $limit);
  }
  elseif (!empty($offset)) {
    $query->range($offset, 9999);
  }
  
  $participants = $query->execute()->fetchAllAssoc('id');

  if (!empty($participants)) {
    $entities = entity_load($node->entity_type, array_keys($participants));

    foreach ($participants as $id => $participant) {
      $label = entity_label($node->entity_type, $entities[$id]);
      $uri = entity_uri($node->entity_type, $entities[$id]);
      $participant->name = $label;
      $participant->link = l($label, $uri['path'], $uri);

      // We might need to use this entity later
      $participant->entity = $entities[$id];
    }

    // Allow other modules to alter participant data
    drupal_alter('tournament_participants_data', $participants, $node);
  }

  return $participants;
}

/**
 * Returns an array of participant entity IDs for a given tournament.
 *
 * @param $node
 *   A tournament node object.
 */
function tournament_participants_load($node, $limit = NULL, $offset = NULL) {
  $query = db_select('tournament_participants', 'tp')
    ->fields('tp', array('id'))
    ->condition('nid', $node->nid)
    ->condition('status', 0, '>');

  if (isset($limit) && isset($offset)) {
    $query->range($offset, $limit);
  }

  $ids = $query->execute()->fetchCol();

  return $ids;
}

/**
 * Lists participants for a given tournament.
 *
 * @param $node
 *   A tournament node object.
 * @param $status
 *   Filter participants based on a specific status.
 * @param $limit
 *   Limit the number of returned participant records.
 * @param $offset
 *   The offset for the record limit.
 *
 * @return
 *   A render array for a list of participants.
 *
 * see tournament_view()
 */
function tournament_list_participants($node, $status = NULL, $limit = 0, $offset = 0) {
  // Load participants data
  $participants = tournament_participants_data($node, $status, $limit, $offset);

  $items = array();
  foreach ($participants as $id => $participant) {
    $data = isset($participant->data) ? $participant->data : '';

    // Handle user pictures in this module
    if ($node->entity_type == 'user' && variable_get('tournament_user_picture', 0)) {
      $data .= theme('user_picture', array('account' => $participant->entity));
    }
    
    // Add the participants linked entity label
    $data .= $participant->link;
    
    $items[$id] = array(
      'data' => $data,
      'class' => array('participant-' . $id),
    );
  }

  $build = array(
    'participants' => array(
      '#theme' => 'item_list',
      '#items' => $items,
      '#attributes' => array(
        'class' => array('participants-list'),
      ),
    ),
  );
  
  drupal_alter('tournament_list_participants', $build, $node);

  return $build;
}

/**
 * Access callback for listing participants.
 *
 * @param $node
 *   A tournament node object.
 */
function _tournament_list_participants_access($node) {
  return !empty($node->list_participants);
}


/**
 * Form builder; Extends a participants list via Ajax.
 */
function tournament_list_participants_form($form, &$form_state, $node, $status) {
  $form_state['node'] = $node;
  $form_state['participant_status'] = $status;
  
  $form['#prefix'] = '<div id="tournament-list-participants-form-' . $status . '">';
  $form['#suffix'] = '</div>';
  $form['actions'] = array('#type' => 'actions');
  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('See all'),
    '#attributes' => array(
      'class' => array('tournament-list-participants-submit'),
    ),
    '#ajax' => array(
      'method' => 'replace',
      'callback' => 'tournament_list_participants_form_callback',
      'wrapper' => 'tournament-list-participants-form-' . $status,
     ),
  );
  
  return $form;
}

/**
 * AJAX submit handler for tournament list participants form.
 */
function tournament_list_participants_form_callback($form, $form_state) {
  $node = $form_state['node'];
  $status = $form_state['participant_status'];
  $offset = variable_get('tournament_participants_max', 0);
  $build = tournament_list_participants($node, $status, 0, $offset);
  return $build['participants'];
}

/**
 * Check whether a plain text password matches a stored hashed password.
 *
 * @param $password
 *   A plain-text password
 * @param $node
 *   A tournament node object.
 *
 * @return
 *   TRUE or FALSE.
 */
function _tournament_check_password($node, $password) {
  require_once DRUPAL_ROOT . '/' . variable_get('password_inc', 'includes/password.inc');
  $hash = _password_crypt('sha512', $password, $node->signup_pass);

  return $hash && $node->signup_pass == $hash;
}

/**
 * Adds the correct ordinal suffix to numbers (e.g. 1st, 2nd etc)
 *
 * @param $num
 *   An integer.
 *
 * @return
 *   A string of the given integer with suffix applied.
 */
function tournament_ordinal_suffix($num) {
  if (!in_array(($num % 100),array(11,12,13))){
    switch ($num % 10) {
      // Handle 1st, 2nd, 3rd
      case 1:  return $num.'st';
      case 2:  return $num.'nd';
      case 3:  return $num.'rd';
    }
  }
  return $num.'th';
}
