<?php

/**
 * @file
 * Defines all the necessary functions for the module.
 */

/**
 * Implements hook_field_formatter_info().
 */
function relative_timestamps_field_formatter_info() {
  return array(
    'relative_timestamps' => array(
      'label' => t('Relative time'),
      'field types' => array('date', 'datestamp', 'datetime'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function relative_timestamps_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  $settings = $display['settings'];
  $formatter = $display['type'];
  $variables = array(
    'entity' => $entity,
    'entity_type' => $entity_type,
    'field' => $field,
    'instance' => $instance,
    'langcode' => $langcode,
    'items' => $items,
    'display' => $display,
    'dates' => array(),
    'attributes' => array(),
    'rdf_mapping' => array(),
    'add_rdf' => module_exists('rdf'),
  );

  // If there is an RDf mapping for this date field, pass it down to the theme.
  $rdf_mapping = array();
  if (!empty($entity->rdf_mapping) && function_exists('rdf_rdfa_attributes')) {
    if (!empty($entity->rdf_mapping[$field['field_name']])) {
      $variables['rdf_mapping'] = $rdf_mapping = $entity->rdf_mapping[$field['field_name']];
    }
  }

  // Give other modules a chance to prepare the entity before formatting it.
  drupal_alter('date_formatter_pre_view', $entity, $variables);

  // See if we are only supposed to display a selected
  // item from multiple value date fields.
  $selected_deltas = array();
  if (!empty($entity->date_id)) {
    foreach ((array) $entity->date_id as $key => $id) {
      list($module, $nid, $field_name, $selected_delta, $other) = explode('.', $id . '.');
      if ($field_name == $field['field_name']) {
        $selected_deltas[] = $selected_delta;
      }
    }
  }

  switch ($display['type']) {
    case 'relative_timestamps':
      foreach ($items as $delta => $item) {
        if (!empty($entity->date_id) && !in_array($delta, $selected_deltas)) {
          continue;
        }
        else {
          if (empty($item['value2']) || $item['value'] == $item['value2']) {
            $element[$delta] = array('#markup' => relative_timestamps_generate($item['value']));
          }
          else {
            $element[$delta] = array('#markup' => relative_timestamps_generate($item['value'], $item['value2']));
          }
        }
      }
      break;
  }
  return $element;
}


/**
 * Returns the constructed string for output.
 *
 * @param string $start
 *   The start date value from the DB
 *
 * @param string $end
 *   The end date value from the DB (if applicable)
 *
 * @return string
 *   A string meant for direct output
 */
function relative_timestamps_generate($start, $end = NULL) {

  // Only a start date is supplied.
  if (!$end) {
    $delta = REQUEST_TIME - relative_timestamps_convert($start);
    $timestr = relative_timestamps_format($delta);
    // Different output if yesterday or tomorrow!
    if ($timestr == t('yesterday') || $timestr == t('tomorrow')) {
      return $timestr;
    }
    else {
      return $delta >= 0 ? t('@string ago', array('@string' => $timestr)) : t('in @string', array('@string' => $timestr));
    }
  }

  // A start and end date are supplied.
  else {
    $delta1 = REQUEST_TIME - relative_timestamps_convert($start);
    $timestr1 = relative_timestamps_format($delta1);
    $delta2 = REQUEST_TIME - relative_timestamps_convert($end);
    $timestr2 = relative_timestamps_format($delta2);

    // This part could possibly get some love,
    // but for now it's the right way to construct the date range.
    // Prepend 'from' if the start date is yesterday or tomorrow.
    if ($timestr1 == t('yesterday') || $timestr1 == t('tomorrow')) {
      $timestr1 = t('from @string', array('@string' => $timestr1));
    }
    // Prepend 'from' and append 'ago' if the start date is
    // in the past and is not yesterday.
    elseif ($delta1 >= 0) {
      $timestr1 = t('from @string ago', array('@string' => $timestr1));
    }
    // Prepend 'in' if the start date is in the future.
    else {
      $timestr1 = t('in @string', array('@string' => $timestr1));
    }
    // Do not prepend anything if the end date is yesterday or tomorrow.
    // Only append 'ago' or 'from now', depending on the situation.
    if ($timestr2 != t('yesterday') || $timestr2 != t('tomorrow')) {
      if ($delta2 >= 0) {
        $timestr2 = t('@string ago', array('@string' => $timestr2));
      }
      else {
        $timestr2 = t('@string from now', array('@string' => $timestr2));
      }
    }

    // Construct the string.
    return t('@start until @end', array('@start' => $timestr1, '@end' => $timestr2));
  }
}

/**
 * Convert dates to UNIX timestamps and preserve their UTC state.
 *
 * @param string $timestamp
 *   A timestamp in without a predefined format
 *
 * @return string
 *   Returns the equivalent UNIX timestamp
 */
function relative_timestamps_convert($timestamp) {
  if ($timestamp_converted = strtotime($timestamp . ' UTC')) {
    return $timestamp_converted;
  }
  else {
    return $timestamp;
  }
}

/**
 * An improved equivalent of Drupal's format_interval.
 *
 * @param string $delta
 *   The interval amount in seconds
 *
 * @return string
 *   A string containing the relative time
 */
function relative_timestamps_format($delta) {
  static $second;
  if (!isset($second)) {
    $second = 1;
  }
  static $minute;
  if (!isset($minute)) {
    $minute = 60 * $second;
  }
  static $hour;
  if (!isset($hour)) {
    $hour = 60 * $minute;
  }
  static $day;
  if (!isset($day)) {
    $day = 24 * $hour;
  }
  static $month;
  if (!isset($month)) {
    $month = 30 * $day;
  }

  if ($delta >= 0) {
    $future = 0;
  }
  else {
    $future = 1;
    $delta = -$delta;
  }

  if ($delta < 1 * $minute) {
    return $delta == 1 ? t('1 second') : t('@seconds seconds', array('@seconds' => $delta));
  }
  if ($delta < 2 * $minute || floor($delta / $minute) == 1) {
    return t('1 minute');
  }
  if ($delta < 45 * $minute) {
    return t('@minutes minutes', array('@minutes' => floor($delta / $minute)));
  }
  if ($delta < 90 * $minute || floor($delta / $hour) == 1) {
    return t('1 hour');
  }
  if ($delta < 24 * $hour) {
    return t('@hours hours', array('@hours' => floor($delta / $hour)));
  }
  if ($delta < 48 * $hour) {
    return $future ? t('tomorrow') : t('yesterday');
  }
  if ($delta < 30 * $day) {
    return t('@days days', array('@days' => floor($delta / $day)));
  }
  if ($delta < 12 * $month) {
    $months = floor($delta / $day / 30);
    return $months <= 1 ? t('1 month') : t('@months months', array('@months' => $months));
  }
  else {
    $years = floor($delta / $day / 365);
    return $years <= 1 ? t('1 year') : t('@years years', array('@years' => $years));
  }
}
