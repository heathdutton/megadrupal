<?php


/**
 * Payment method callback: settings form.
 */
function commerce_nets_settings_form($settings = array()) {
  $form = array();

  $settings = $settings + array(
    'merchantid' => '',
    'netstoken' => '',
    'language' => 'en_GB',
    'environment' => 'test',
    'payment_action' => 'AUTH',
    'order_description' => '',
    'advanced' => array(
      'transaction_id' => '',
      'use_redirect' => FALSE,
    ),
    'recurring' => FALSE,
  );

  $form['merchantid'] = array(
    '#type' => 'textfield',
    '#title' => t('Merchant ID'),
    '#description' => t('Merchant ID issued by Nets.'),
    '#default_value' => $settings['merchantid'],
    '#required' => TRUE,
  );

  $form['netstoken'] = array(
    '#type' => 'textfield',
    '#title' => t('Token'),
    '#description' => t('Nets token issued by Nets.'),
    '#default_value' => $settings['netstoken'],
    '#required' => TRUE,
  );

  $form['language'] = array(
    '#type' => 'select',
    '#title' => t('Terminal language'),
    '#description' => t('Language to present the user at the Nets Terminal.'),
    '#options' => commerce_nets_languages(),
    '#default_value' => $settings['language'],
  );

  $form['environment'] = array(
    '#type' => 'radios',
    '#title' => t('Environment'),
    '#description' => t('Environment to use.'),
    '#options' => array(
      'test' => ('Test, use for testing, requires a test account.'),
      'live' => ('Live, use for production, required real card data.'),
    ),
    '#default_value' => $settings['environment'],
  );

  $form['payment_action'] = array(
    '#type' => 'radios',
    '#title' => t('Payment action'),
    '#description' => t('If we should charge or authorize the charge as our first action. Note: There might be local rules about this.'),
    '#options' => array(
      'SALE' => t('Sale, authorize and capture the funds at the time the payment is processed.'),
      'AUTH' => t('Authorization, authorize (reserve) funds for the payment to be captured later.'),
    ),
    '#default_value' => $settings['payment_action'],
  );

  $form['recurring'] = array(
    '#type' => 'checkbox',
    '#title' => t('Enable recurring payment'),
    '#description' => t('Enable this to give people the option to let Nets remember card details.'),
    '#default_value' => $settings['recurring'],
  );

  $form['order_description'] = array(
    '#type' => 'textfield',
    '#title' => t('Order description'),
    '#description'  => t('Custom description to show on the Nets terminal. Can contain HTML.'),
    '#default_value' => $settings['order_description'],
  );

  $form['advanced'] = array(
    '#type' => 'fieldset',
    '#title' => t('Advanced'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );

  $form['advanced']['transaction_id'] = array(
    '#type' => 'textfield',
    '#title' => t('Transaction ID'),
    '#description' => t('Custom Transaction ID to use. Note: Must be unique and can NOT be more than 32 characters long after evaluation. Leave empty for autogenerated ID at Nets.'),
    '#default_value' => $settings['advanced']['transaction_id'],
  );

  $form['advanced']['use_redirect'] = array(
    '#type' => 'checkbox',
    '#title' => t('Skip redirect forms'),
    '#description' => t('Enable this to skip redirect forms during checkout.'),
    '#default_value' => $settings['advanced']['use_redirect'],
  );

  if (module_exists('token')) {
    $form['token'] = array(
      '#type' => 'fieldset',
      '#title' => t('Replacement patterns'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );
    $form['token']['tree'] = array(
      '#theme' => 'token_tree',
      '#token_types' => array('commerce-order'),
    );
  }

  return $form;
}

/**
 * Payment method callback: submit form.
 */
function commerce_nets_submit_form($payment_method, $pane_values, $checkout_pane, $order) {
  drupal_add_css(drupal_get_path('module', 'commerce_nets') . '/css/commerce_nets.css');

  $form = array();

  // Merge in values from the order.
  if (!empty($order->data['commerce_nets'])) {
    $pane_values += $order->data['commerce_nets'];
  }

  if (isset($payment_method['settings']['recurring']) && $payment_method['settings']['recurring']) {
    $form['recurring'] = array(
      '#type' => 'checkbox',
      '#title' => t('Store new card.'),
      '#description' => t('Check this to let Nets remember card details.'),
      '#default_value' => empty($recurring_payment) ? FALSE : TRUE,
    );

    if (user_is_logged_in()) {
      $pan_hashes = commerce_nets_recurring_get_payment_hashes($GLOBALS['user']->uid);
      if (count($pan_hashes)) {
        $hash_radio = array();
        foreach ($pan_hashes as $pan_hash) {
          if (commerce_nets_is_valid_pan_hash($pan_hash)) {
            $hash_radio[$pan_hash->id] = '<span class="panhash valid">'.$pan_hash->issuer.', #'.substr($pan_hash->masked_pan, 12, 4).' YYMM:'.$pan_hash->expiry_date.'</span>';
          }
          else {
            $hash_radio[$pan_hash->id] = '<span class="panhash not-valid">'.$pan_hash->issuer.', #'.substr($pan_hash->masked_pan, 12, 4).' YYMM:'.$pan_hash->expiry_date.'</span>';
          }
        }

        $form['pan_hashes'] = array(
          '#type' => 'radios',
          '#title' => t('Stored cards'),
          '#description' => t('Choose a previously saved card to use.'),
          '#options' => $hash_radio,
        );
      }
    }
  }

  // Show information about the payment method.
  $form['instructions'] = array(
    '#markup' => t('Continue with checkout to complete payment via Nets.'),
    '#prefix' => '<div class="commerce_nets_instructions"><p>',
    '#suffix' => '</p></div>',
  );

  return $form;
}

/**
 * Payment method callback: submit form validate.
 *
 * Checks length of merchantid and netstoken.
 */
function commerce_nets_submit_form_validate($payment_method, $pane_form, $pane_values, $order, $form_parents = array()) {

  if ((!isset($payment_method['settings']['merchantid']) || empty($payment_method['settings']['merchantid'])) ||
      (!isset($payment_method['settings']['netstoken']) || empty($payment_method['settings']['netstoken']))) {
    drupal_set_message(t('Nets Terminal is not configured correctly. Please try another payment method.'), 'error');
    return FALSE;
  }

  if (!empty($pane_values['pan_hashes'])) {
    if (!$pan_hash = commerce_nets_recurring_get_payment_hash($pane_values['pan_hashes'])) {
      drupal_set_message(t('There was a problem with the chosen card option.'), 'warning');
      drupal_set_message(t('Please try again to choose another option.'), 'warning');
      return FALSE;
    }
    if (!commerce_nets_is_valid_pan_hash($pan_hash)) {
      drupal_set_message(t('Chosen card is no longer valid.'), 'warning');
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Payment method callback: submit form submit.
 */
function commerce_nets_submit_form_submit($payment_method, $pane_form, $pane_values, $order, $charge) {
  // if pan_hashes is set, force recurring to be true.
  if (isset($pane_values['pan_hashes']) && !empty($pane_values['pan_hashes'])) {
    $pane_values['recurring'] = 1;
  }

  $order->data[$payment_method['method_id']] = array(
    'pane_values' => $pane_values,
  );

  // Move forward for redirect.
  return TRUE;
}

/**
 * Payment method callback: redirect form.
 */
function commerce_nets_redirect_form($form, &$form_state, $order, $payment_method) {

  // if set we redirect automagically to next step. If not user has to click "forward" / "Cancel".
  $use_redirect = $payment_method['settings']['advanced']['use_redirect'];

  // Set some URLS for Nets to return to.
  $urls = array(
    'cancel_return' => url('checkout/' . $order->order_id . '/payment/back/' . $order->data['payment_redirect_key'], array('absolute' => TRUE)),
    'return'        => url('checkout/' . $order->order_id . '/payment/return/' . $order->data['payment_redirect_key'], array('absolute' => TRUE)),
  );

  $charge = commerce_payment_order_balance($order);

  // Create a local transaction for the register event.
  $transaction = commerce_nets_register_transaction($order, $payment_method, $charge, $urls);

  if (!$transaction) {
    watchdog('commerce_nets', 'Could not register new transaction for order @order_id.', array('@order_id' => $order->order_id), WATCHDOG_ERROR);
    if ($use_redirect) {
      return drupal_goto($urls['cancel_return']);
    }
    return commerce_nets_simple_form('Go back', $urls['cancel_return']);
  }

  $terminal_url = commerce_nets_terminal_url($payment_method['settings']['environment']);
  $merchant_id  = $payment_method['settings']['merchantid'];
  $remote_id    = $transaction->remote_id;
  $url          = strtr('%terminal?merchantId=%merchantid&transactionId=%remoteid', array(
                   '%terminal' => $terminal_url,
                   '%merchantid' => $merchant_id,
                   '%remoteid' => $remote_id));

  watchdog('commerce_nets', 'Sending user to Nets. Order: @order_id.', array('@order_id' => $order->order_id), WATCHDOG_NOTICE);
  if ($use_redirect) {
    return drupal_goto($url);
  }
  return commerce_nets_simple_form('Proceed to Nets', $url);
}

/**
 * Payment method callback: redirect form return validation.
 *
 * We trust Nets to be the only ones that know about this.
 */
function commerce_nets_redirect_form_validate($order, $payment_method) {

  $remote_id     = isset($_GET['transactionId']) ? $_GET['transactionId'] : '';
  $response_code = isset($_GET['responseCode'])  ? $_GET['responseCode']  : '';

  $message_variables = array(
                             '%oid' => $order->order_id,
                             '%tid' => $remote_id,
                             '%rc'  => $response_code
                             );

  if (empty($remote_id) || empty($response_code)) {
    watchdog('commerce_nets', 'Return from Nets has wrong values for order: %oid, transactionId: %tid and responseCode: %rc.', $message_variables, WATCHDOG_ERROR);
    return FALSE;
  }

  $transaction = commerce_nets_get_transaction_by_remote_id($remote_id);

  if (!$transaction) {
    watchdog('commerce_nets', 'Transaction can not be loaded for order: %oid from $remote_id: %tid.', $message_variables, WATCHDOG_ERROR);
    return FALSE;
  }

  $nets_transaction = commerce_nets_query_transaction($payment_method, $remote_id);

  if ($response_code !== 'OK') {
    $message_variables['%reason'] = '';
    if (isset($nets_transaction->ErrorLog)
      && isset($nets_transaction->ErrorLog->PaymentError)
      && isset($nets_transaction->ErrorLog->PaymentError->ResponseText)) {

      $message_variables['%reason'] = $nets_transaction->ErrorLog->PaymentError->ResponseText;

      drupal_set_message(t('Status from Nets').' : '.t($message_variables['%reason']), 'error');
    }

    watchdog('commerce_nets', 'There was a problem with payment for order %oid, reason "%reason"', $message_variables, WATCHDOG_INFO);

    // Update transaction to indicate current status.
    $transaction->remote_status = $response_code;
    $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
    commerce_payment_transaction_save($transaction);

    return FALSE;
  }

  // store pan_hash if recurring payment was set by user
  if (isset($nets_transaction->CardInformation->PanHash) && !empty($nets_transaction->CardInformation->PanHash)) {
    commerce_nets_recurring_save_payment_hash($order->uid, $nets_transaction->CardInformation);
  }

  return commerce_nets_process_transaction($order, $payment_method, $transaction, $payment_method['settings']['payment_action']);
}

/**
 * Performs a transaction Register at Nets.
 *
 * @param object $order
 *   Commerce order object that we will create transaction for.
 *
 * @param object $payment_method
 *   Payment method instance for the order.
 *
 * @param array $charge
 *   Charge array with amount and currency_code.
 *
 * @return bool
 *   TRUE if success at creating the transaction at Nets, FALSE otherwise.
 */
function commerce_nets_register_transaction($order, $payment_method, $charge, $urls) {
  #module_load_include('inc', 'commerce_nets', 'commerce_nets.classes');

  #$payment_settings = $payment_method['settings'];

  $wsdl = commerce_nets_wsdl_url($payment_method['settings']['environment']);
  $client = commerce_nets_init_client($wsdl);

  // Parameters in Order.
  $order_amount = $charge['amount'];
  $order_currency_code = $charge['currency_code'];
  $order_force_3dsecure = NULL;
  $order_goods = NULL;
  $order_number = $order->order_id;
  $order_update_stored_payment_info = NULL;

  // Order object.
  $nets_order = new Order(
    $order_amount,
    $order_currency_code,
    $order_force_3dsecure,
    $order_goods,
    $order_number,
    $order_update_stored_payment_info
  );

  // Paramenters in Environment.
  $environment_language = NULL;
  $environment_os = NULL;
  $environment_webserviceplatform = 'PHP5';

  // Environment object.
  $nets_environment = new Environment(
    $environment_language,
    $environment_os,
    $environment_webserviceplatform
  );

  // Parameters in Terminal.
  $terminal_auto_auth = NULL;
  $terminal_payment_methodlist = NULL;
  $terminal_language = $payment_method['settings']['language'];

  // By default, we use no description for the terminal.
  $terminal_order_description = NULL;

  // Custom string provided for order_description. Replace it.
  if (!empty($payment_method['settings']['order_description'])) {
    $order_description_replaced = token_replace($payment_method['settings']['order_description'], array('commerce-order' => $order));
    if ($payment_method['settings']['order_description'] !== $order_description_replaced) {
      $terminal_order_description = $order_description_replaced;
    }
  }

  $terminal_redirect_on_error = $urls['cancel_return'];
  $terminal_redirect_url = $urls['return'];

  // Terminal object.
  $nets_terminal = new Terminal(
    $terminal_auto_auth,
    $terminal_payment_methodlist,
    $terminal_language,
    $terminal_order_description,
    $terminal_redirect_on_error,
    $terminal_redirect_url
  );

  // Parameters in Customer.
  $customer_address1 = NULL;
  $customer_address2 = NULL;
  $customer_company_name = NULL;
  $customer_company_registration_number = NULL;
  $customer_country = NULL;
  $customer_first_name = NULL;
  $customer_last_name = NULL;
  $customer_number = $order->uid;
  $customer_email = $order->mail;
  $customer_phone_number = NULL;
  $customer_postcode = NULL;
  $customer_social_security_number = NULL;
  $customer_town = NULL;

  // Customer object.
  $nets_customer = new Customer(
    $customer_address1,
    $customer_address2,
    $customer_company_name,
    $customer_company_registration_number,
    $customer_country,
    $customer_number,
    $customer_email,
    $customer_first_name,
    $customer_last_name,
    $customer_phone_number,
    $customer_postcode,
    $customer_social_security_number,
    $customer_town
  );

  $pane_values = $order->data[$payment_method['method_id']]['pane_values'];
  $recurring_value = empty($pane_values['recurring'])  ? NULL : $pane_values['recurring'];
  $pan_hash_id     = empty($pane_values['pan_hashes']) ? NULL : $pane_values['pan_hashes'];


  $recurring = NULL;
  // check if we should tell Nets to store card details
  if ($recurring_value) {
    $expiry_date = NULL;
    $frequency   = NULL;
    $type        = 'S'; // to-do - find out why 'S'
    $pan_hash    = NULL;
    // see if payment should be done with stored card details
    if (!empty($pan_hash_id)) {

      if ($pan_hash_record = commerce_nets_recurring_get_payment_hash($pan_hash_id)) {
        $pan_hash = $pan_hash_record->pan_hash;
      }
    }

    $recurring = new Recurring(
      $expiry_date,
      $frequency,
      $type,
      $pan_hash
    );
  }

  // Parameters in Register Request.
  $nets_avtale_giro   = NULL;
  $nets_card_info     = NULL;
  $nets_description   = NULL;
  $nets_dnbnor_direct_payment = NULL;
  $nets_micro_payment = NULL;
  $nets_recurring     = $recurring;
  $nets_service_type  = NULL;

  // By default, let nets create a Transaction ID for us.
  $nets_transaction_id = NULL;

  $transaction_id_replaced = token_replace($payment_method['settings']['advanced']['transaction_id'], array('commerce-order' => $order));
  if (!empty($transaction_id_replaced)) {
    $nets_transaction_id = $transaction_id_replaced;
  }

  $nets_transaction_recon_ref = NULL;

  // Register Request object.
  $nets_register_request = new RegisterRequest(
    $nets_avtale_giro,
    $nets_card_info,
    $nets_customer,
    $nets_description,
    $nets_dnbnor_direct_payment,
    $nets_environment,
    $nets_micro_payment,
    $nets_order,
    $nets_recurring,
    $nets_service_type,
    $nets_terminal,
    $nets_transaction_id,
    $nets_transaction_recon_ref
  );

  // Soap parameters.
  $merchant_id = $payment_method['settings']['merchantid'];
  $token       = $payment_method['settings']['netstoken'];

  // Soap parameters.
  $soap_parameters = array(
    "token"      => $token,
    "merchantId" => $merchant_id,
    "request"    => $nets_register_request
  );

  $soap_success = FALSE;

  try {
    $soap_result = $client->__call('Register', array("parameters" => $soap_parameters));
  } catch (Exception $e) {
    commerce_nets_log_exception($e, 'register');

    return FALSE;
  }

  // RegisterResult.
  $register_result       = $soap_result->RegisterResult;
  $remote_transaction_id = $register_result->TransactionId;

  $transaction = commerce_payment_transaction_new($payment_method['method_id'], $order->order_id);
  $transaction->instance_id   = $payment_method['instance_id'];
  $transaction->amount        = $charge['amount'];
  $transaction->currency_code = $charge['currency_code'];
  $transaction->status        = 'registered';
  $transaction->remote_status = 'OK';
  $transaction->remote_id     = $remote_transaction_id;

  // Save transaction.
  commerce_payment_transaction_save($transaction);
  return $transaction;
}


function commerce_nets_query_transaction($payment_method, $remote_id) {

  $wsdl = commerce_nets_wsdl_url($payment_method['settings']['environment']);
  $client = commerce_nets_init_client($wsdl);

  $query_request = new QueryRequest(
    $remote_id
  );

  // Soap parameters.
  $merchant_id = $payment_method['settings']['merchantid'];
  $token       = $payment_method['settings']['netstoken'];

  // Soap parameters.
  $soap_parameters = array(
    "token"      => $token,
    "merchantId" => $merchant_id,
    "request"    => $query_request
  );

  $soap_success = FALSE;

  try {
    $soap_result = $client->__call('Query', array("parameters" => $soap_parameters));
    return $soap_result->QueryResult;
  } catch (Exception $e) {
    commerce_nets_log_exception($e, 'Query');
    return FALSE;
  }

}


/**
 * Performs a transaction Process at Nets.
 *
 * @param object $order
 *   Commerce order object that we will create transaction for.
 *
 * @param object $payment_method
 *   Payment method instance for the order.
 *
 * @param object $transaction
 *   Transaction object for this operation.
 *
 * @return bool
 *   TRUE if success at processing the transaction at Nets, FALSE otherwise.
 */
function commerce_nets_process_transaction($order, $payment_method, $transaction, $operation = 'AUTH') {

  // invoke hook so modules can add/change params. ex. recon_ref
  module_invoke_all('commerce_nets_transaction', $order, $payment_method, $transaction, $operation);

  $wsdl = commerce_nets_wsdl_url($payment_method['settings']['environment']);
  $client = commerce_nets_init_client($wsdl);

  // Process paramters.
  $description           = NULL;
  $transaction_amount    = $transaction->amount;
  $transaction_id        = $transaction->remote_id;
  $transaction_recon_ref = isset($transaction->recon_ref) ? $transaction->recon_ref : NULL;

  // Process object.
  $nets_process_request = new ProcessRequest(
          $description,
          $operation,
          $transaction_amount,
          $transaction_id,
          $transaction_recon_ref
  );

  // Soap setup.
  $merchantid = $payment_method['settings']['merchantid'];
  $token = $payment_method['settings']['netstoken'];

  // Soap parameters.
  $soap_parameters = array(
    "token" => $token,
    "merchantId" => $merchantid,
    "request" => $nets_process_request,
  );

  // Placeholder for setting inside try/catch.
  $remote_response_code = '';


  try {
    $soap_result = $client->__call('Process', array("parameters" => $soap_parameters));
  } catch (Exception $e) {
    commerce_nets_log_exception($e, 'process');

    // Save the return exception as a payload.
    $transaction->payload = commerce_nets_extract_exception_details($e);
    commerce_payment_transaction_save($transaction);

    return FALSE;
  }

  $process_result = $soap_result->ProcessResult;
  if ($process_result->ResponseCode == "OK") {
    // Save transaction.
    $transaction->remote_status = $process_result->ResponseCode;
    // Set transaction status to what Nets told us it did.
    $transaction->status = commerce_nets_transaction_status_from_nets_operation($process_result->Operation);
    commerce_payment_transaction_save($transaction);
    return TRUE;
  }
  else {
    // Keep response code for initial AUTH/SALE calls.
    $remote_response_code = $process_result->ResponseCode;
  }


  // Save transaction.
  // Only if is initial transaction, others (CAPTURE, CREDIT, ANNUL) we don't change status (to retry).
  if (in_array($operation, array('AUTH', 'SALE'))) {
    $transaction->remote_status = $remote_response_code;
    $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
    commerce_payment_transaction_save($transaction);
  }

  return FALSE;
}

/**
 * Helper function to set local status based on what operation Nets have done on a transaction.
 *
 * @param string $operation
 *   Operation to check local status for.
 *
 * @return string
 *   Local status to set on transaction.
 */
function commerce_nets_transaction_status_from_nets_operation($operation) {
  $statuses = array(
    'AUTH' => 'authorize',
    'SALE' => 'success',
    'CAPTURE' => 'success',
    'CREDIT' => 'credit',
    'ANNUL' => 'annull',
  );

  if (!isset($statuses[$operation])) {
    watchdog('commerce_nets', 'No transaction status for %operation.', array('%operation' => $operation), WATCHDOG_ERROR);
    return FALSE;
  }

  return $statuses[$operation];
}

/**
 * Helper function to get readable name based on operation performed at Nets.
 *
 * @param string $operation
 *   Operation to get a human readable name for.
 *
 * @return string
 *   A translatabe human readable operation name.
 */
function commerce_nets_readable_operation_name($operation) {
  $operation_names = array(
    'AUTH' => 'Authorize',
    'SALE' => 'Sale',
    'CAPTURE' => 'Capture',
    'CREDIT' => 'Credit',
    'ANNUL' => 'Annull',
  );

  if (!isset($operation_names[$operation])) {
    watchdog('commerce_nets', 'No readable operation name for %operation.', array('%operation' => $operation), WATCHDOG_ERROR);
    return t('Unknown');
  }

  return t($operation_names[$operation]);
}

/**
 * Callback for Operations performs in the Commerce Order UI.
 *
 * @param string $operation
 *   Operation to perform: CAPTURE/CREDIT/ANNUL.
 * @param object $order
 *   Commerce Order (loaded) the transaction belongs to.
 * @param object $transaction
 *   Commerce Payment Transaction (loaded) to perform operation for.
 *
 * @return NULL
 *   Returns NULL and performs a drupal_goto back to the payment overview for this order.
 */
function commerce_nets_transaction_operation($operation, $order, $transaction) {

  $payment_method = commerce_payment_method_instance_load($transaction->instance_id);

  if (!$payment_method) {
    drupal_set_message(t('Failure to load Payment method (@instance_id) for transaction.', array('@instance_id' => $transaction->instance_id)), 'error');
  }
  else {
    $readable_operation_name = commerce_nets_readable_operation_name($operation);

    $api_call_success = commerce_nets_process_transaction($order, $payment_method, $transaction, $operation);

    if (!$api_call_success) {
      drupal_set_message(t('Trying to perform @operation failed at Nets. Please check your error logs.', array('@operation' => $readable_operation_name)), 'error');
    }
    else {
      drupal_set_message(t('@operation performed at Nets.', array('@operation' => $readable_operation_name)));
    }
  }

  $payment_url = strtr('admin/commerce/orders/%order_id/payment', array('%order_id' => $order->order_id));

  drupal_goto($payment_url);
}

/**
 * Helper function to log Exceptions from Nets.
 *
 * @param object $exception
 *   Exception object.
 * @param string $operation
 *   Operation we tried to perform at Nets (AUTH, SALE, ...).
 */
function commerce_nets_log_exception(&$exception, $operation = '') {
  $message_vars = array('%operation' => $operation);

  if (isset($exception->detail)) {
    // We cycle to make it easy to find $type without knowing the real exception.
    foreach ($exception->detail as $type => $e) {
      $message_vars += array(
        '%type' => $type,
        '%message' => isset($e->Message) ? $e->Message : '',
        '%response_code' => isset($e->Result) && isset($e->Result->ResponseCode) ? $e->Result->ResponseCode : '',
        '%response_source' => isset($e->Result) && isset($e->Result->ResponseSource) ? $e->Result->ResponseSource : '',
        '%response_text' => isset($e->Result) && isset($e->Result->ResponseText) ? $e->Result->ResponseText : '',
      );

      watchdog('commerce_nets', 'Nets failed, tried %operation. Type: %type, Message: %message, ResponseCode: %response_code, ResponseSource: %response_source and ResponseText: %response_text.', $message_vars, WATCHDOG_ERROR);
    }
  }
  else {
    watchdog('commerce_nets', 'Nets failed, tried %operation. Exception: <pre>@exception</pre>', array(
                                                                                                       '@exception' => print_r($exception, TRUE),
                                                                                                       '%operation' => $operation,
                                                                                                       ), WATCHDOG_ERROR);
  }
}

/**
 * Extracts exception details without knowing type.
 *
 * @param Exception $exception
 *   SOAP/Nets exception to extract details from.
 *
 * @return array
 *   An assosiative array, formatted for use in t()/format_string().
 */
function commerce_nets_extract_exception_details($exception) {
  $details = array();

  if (isset($exception->detail)) {
    // We cycle to make it easy to find $type without knowing the real exception.
    foreach ($exception->detail as $type => $e) {
      $details += array(
        '%type' => $type,
        '%message' => isset($e->Message) ? $e->Message : '',
        '%response_code' => isset($e->Result) && isset($e->Result->ResponseCode) ? $e->Result->ResponseCode : '',
        '%response_source' => isset($e->Result) && isset($e->Result->ResponseSource) ? $e->Result->ResponseSource : '',
        '%response_text' => isset($e->Result) && isset($e->Result->ResponseText) ? $e->Result->ResponseText : '',
      );
    }
  }

  return $details;
}


/**
 * Gets a transaction by it's remote ID.
 *
 * @param int $order_id
 *   Order ID to fetch transaction for.
 * @param int $remote_id
 *   Remote ID of the transaction.
 * @param string $transaction_status
 *   Current transaction status.
 *
 * @return mixed
 *   Transaction ID if successful, FALSE otherwise.
 */
function commerce_nets_get_transaction_by_remote_id($remote_id) {
  $sql = "SELECT transaction_id FROM {commerce_payment_transaction}
          WHERE remote_id = :remote_id
          AND payment_method = 'commerce_nets'
          LIMIT 1;";
  $transaction_id = db_query($sql, array(
                                         ':remote_id' => $remote_id,
                                         ))->fetchField();
  if ($transaction_id) {
    return commerce_payment_transaction_load($transaction_id);
  }

  return FALSE;
}


/**
 * Initialize NETS webservice client and include class file
 *
 * @param int $wsdl
 *   WSDL path
 *
 * @return mixed
 *   soap client if succesfull. False / exeption if not
 */
function commerce_nets_init_client($wsdl) {

  module_load_include('inc', 'commerce_nets', 'commerce_nets.classes');

  if (strpos($_SERVER["HTTP_HOST"], 'uapp') > 0) {
    // Creating new client having proxy.
    $client = new SoapClient($wsdl, array(
                                          'proxy_host' => "isa4",
                                          'proxy_port' => 8080,
                                          'trace'      => TRUE,
                                          'exceptions' => TRUE
                                          ));
  }
  else {
    // Creating new client without proxy.
    $client = new SoapClient($wsdl, array(
                                          'trace'      => TRUE,
                                          'exceptions' => TRUE
                                          ));
  }
  if ($client) {
    return $client;
  }

  return FALSE;
}


/**
 * Returns the URL to the Nets Terminal.
 *
 * @param string $environment
 *   Environment to get url for.
 *
 * @return string
 *   URL to the Nets Terminal to use.
 */
function commerce_nets_terminal_url($environment) {
  switch ($environment) {
    case 'test':
      return 'https://epayment-test.bbs.no/terminal/default.aspx';
    case 'live':
      return 'https://epayment.bbs.no/terminal/default.aspx';
  }
}

/**
 * Returns the URL to the specified Nets WSDL server.
 *
 * @param string $environment
 *   Either test or live indicating which environment to get the URL for.
 *
 * @return string
 *   The URL to use to submit requests to the Nets server.
 */
function commerce_nets_wsdl_url($environment) {
  switch ($environment) {
    case 'test':
      return 'https://epayment-test.bbs.no/netaxept.svc?wsdl';
    case 'live':
      return 'https://epayment.bbs.no/netaxept.svc?wsdl';
  }
}

/**
 * Returns an array of all possible language codes.
 *
 * @return array
 *   The language code to set on Nets terminal.
 */
function commerce_nets_languages() {
  return array(
               'no_NO' => t('Norwegian'),
               'sv_SE' => t('Swedish'),
               'da_DK' => t('Danish'),
               'de_DE' => t('German'),
               'fi_FI' => t('Finnish'),
               'en_GB' => t('English')
               );
}

/**
 * Creates a small form with action and a submit button.
 *
 * @param string $title
 *   Title to put on the submit button.
 * @param string $url
 *   URL to set form action to.
 *
 * @return array
 *   FORM to be processed by Drupal.
 */
function commerce_nets_simple_form($title = '', $url = '/') {
  $form = array();

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t($title),
  );

  $form['#action'] = $url;

  return $form;
}

/**
 * Loads recurring payment string/hash records for user
 *
 * @param int $uid
 *   User id
 *
 * @return string
 *   Hash to be used in payment request
 */
function commerce_nets_recurring_get_payment_hashes($uid) {
  if (intval($uid) > 0) {
    $hashes = array();
    $result = db_query("SELECT * FROM {commerce_nets_cc_detail} WHERE uid = :uid ",
      array(':uid' => $uid))->fetchAll();
    return $result;
  }

  return array();
}

/**
 * Loads recurring payment string/hash record
 *
 * @param int $id
 *   id
 *
 * @return string
 *   Hash to be used in payment request
 */
function commerce_nets_recurring_get_payment_hash($id) {
  if (intval($id) > 0) {
    $result = db_query("SELECT * FROM {commerce_nets_cc_detail} WHERE id = :id",
      array(':id' => $id))->fetch();
    return $result;
  }

  return FALSE;
}

/**
 * Loads recurring payment id for hash
 *
 * @param int $pan_hash
 *   pan_hash to get id for
 *
 * @return int
 *   id for pan_hash
 */
function commerce_nets_recurring_get_payment_id($pan_hash) {
  if (!empty($pan_hash)) {
    return db_query("SELECT id FROM {commerce_nets_cc_detail} WHERE pan_hash = :pan_hash",
      array(':pan_hash' => $pan_hash))->fetchField();
  }

  return FALSE;
}

/**
 * Loads recurring payment string/hash
 *
 * @param int $uid
 *   Uid of user for whom to store card details
 * @param object $card_information
 *   Card details to be stored
 *
 * @return int
 *   ID of inserted record if successful, FALSE otherwise
 */
function commerce_nets_recurring_save_payment_hash($uid, $card_information) {

  if (intval($uid) > 0 && !empty($card_information)) {

    // check to see if we already have this pan_hash stored
    if ($id = commerce_nets_recurring_get_payment_id($card_information->PanHash)) {
      return $id;
    }
    // else store card details
    $id = db_insert('commerce_nets_cc_detail')
    ->fields(array(
      'uid'            => $uid,
      'payment_method' => $card_information->PaymentMethod,
      'issuer'         => $card_information->Issuer,
      'issuer_country' => $card_information->IssuerCountry,
      'masked_pan'     => $card_information->MaskedPAN,
      'pan_hash'       => $card_information->PanHash,
      'expiry_date'    => $card_information->ExpiryDate,
      'created'        => time(),
    ))
    ->execute();
    if ($id) {
      return $id;
    }
  }

  return FALSE;
}


function commerce_nets_is_valid_pan_hash($pan_hash) {
  $current_yearmonth = (int) date('ym');
  $valid_yearmonth   = (int) $pan_hash->expiry_date;
  if ($current_yearmonth <= $valid_yearmonth) {
    return TRUE;
  }

  return FALSE;
}
