<?php
/**
 * @file
 * Module to allow terms to be positioned as they are added or edited.
 */

/**
 * Implements hook_theme().
 */
function term_sibling_reorder_theme($existing, $type, $theme, $path) {
  return array(
    'term_sibling_reorder_taxonomy_form_term_add_reorder' => array(
      'render element' => 'form',
    ),
  );
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Add a preprocess submit and a postprocess submit callback.
 */
function term_sibling_reorder_form_taxonomy_form_term_alter(&$form, &$form_state, $form_id) {
  // First override the weight field with the new weight for the term.
  array_unshift($form['#submit'], 'term_sibling_reorder_taxonomy_form_term_pre_submit');

  // Then the rest of the submit functions fire.
  // Then save the other childrens' new weights.
  $form['#submit'][] = 'term_sibling_reorder_taxonomy_form_term_post_submit';

  // Hide the weight and replace with the draggable table.
  _term_sibling_reorder_taxonomy_form_term_add_reorder($form, $form_state);
}

/**
 * Replaces the weight field with the table for reordering children.
 */
function _term_sibling_reorder_taxonomy_form_term_add_reorder(&$form, &$form_state) {
  $relations = &$form['relations'];

  $vocab = $form['#vocabulary'];
  $allow_siblings_reorder = FALSE;

  $form['relations']['parent']['#ajax'] = array(
    'callback' => '_term_sibling_reorder_ajax_callback',
    'wrapper' => 'term-ajax-wrapper',
    'method' => 'replace',
    'effect' => 'fade',
  );

  if (isset($relations['parent']['#default_value']) && count($relations['parent']['#default_value']) == 1) {
    $relations['weight']['#type'] = 'value';
    $relations['weight']['#value'] = $relations['weight']['#default_value'];

    // Get the parent value from the form or form_state, whatever is relevant.
    $parent = (isset($form_state['values'])) ? reset($form_state['values']['parent']) : FALSE;
    if (!$parent) {
      $parent = reset($relations['parent']['#default_value']);
    }

    $siblings = _term_sibling_reorder_taxonomy_get_children($parent, $vocab->vid);

    $relations['siblings'] = array(
      '#type' => 'container',
      '#tree' => TRUE,
      '#weight' => -10,
      '#theme' => 'term_sibling_reorder_taxonomy_form_term_add_reorder',
      '#prefix' => '<div id="term-ajax-wrapper"><div id="draggable-container">',
      '#suffix' => '</div></div>',
    );


    // Build the actual form.
    foreach ($siblings as $key => $term) {
      // Save the term for the current page so we don't have to load it a
      // second time.
      $relations['siblings'][$key]['#term'] = (array) $term;

      // Make current term a bit more recognizable by appending "This Term".
      if ($term->tid == $form['tid']['#value']) {
        $term_link = l($term->name, "taxonomy/term/$term->tid");
        $relations['siblings'][$key]['view'] = array(
          '#type' => 'markup',
          '#markup' => $term_link . ' ' . t('(This Term)'),
        );
      }
      else {
        $relations['siblings'][$key]['view'] = array(
          '#type' => 'link',
          '#title' => $term->name,
          '#href' => "taxonomy/term/$term->tid",
        );
      }

      $relations['siblings'][$key]['tid'] = array(
        '#type' => 'value',
        '#value' => $term->tid,
      );
      $relations['siblings'][$key]['weight'] = array(
        '#type' => 'weight',
        '#title_display' => 'invisible',
        '#title' => t('Weight for added term'),
        '#default_value' => $term->weight,
      );
    }

    if (count($siblings) && !$form['#term']['tid']) {
      $key = 'current';

      $relations['siblings'][$key]['view'] = array(
        '#type' => 'markup',
        '#markup' => t('This Term'),
      );
      $relations['siblings'][$key]['tid'] = array(
        '#type' => 'value',
        '#value' => $key,
      );
      $relations['siblings'][$key]['weight'] = array(
        '#type' => 'weight',
        '#title_display' => 'invisible',
        '#title' => t('Weight for added term'),
        '#default_value' => 10,
      );
    }

    if (!count($siblings)) {
      unset($relations['siblings']);
    }
  }
}

/**
 * AJAX callback for replacing siblings table based on parent.
 */
function _term_sibling_reorder_ajax_callback($form, $form_state) {
  if (isset($form['relations']['siblings'])) {
    return $form['relations']['siblings'];
  }
  // Return empty text if there are no siblings.
  else {
    return '<div id="term-ajax-wrapper">' . t('There are no other children in this parent.') . '</div>';
  }
}

/**
 * Adds tabledrag for reordering terms.
 */
function theme_term_sibling_reorder_taxonomy_form_term_add_reorder($variables) {
  $form = $variables['form'];

  drupal_add_tabledrag('taxonomy-siblings', 'order', 'sibling', 'term-weight');

  $errors = form_get_errors() != FALSE ? form_get_errors() : array();
  $rows = array();
  foreach (element_children($form) as $key) {
    $term = $form[$key];

    $row = array();
    $row[] = drupal_render($term['view']);

    $term['weight']['#attributes']['class'] = array('term-weight');
    $row[] = drupal_render($term['weight']);
    $row = array('data' => $row);
    $rows[$key] = $row;
  }

  // Add necessary classes to rows.
  $row_position = 0;
  foreach ($rows as $key => $row) {
    $rows[$key]['class'] = array();
    $rows[$key]['class'][] = 'draggable';

    // Add an error class if this row contains a form error.
    foreach ($errors as $error_key => $error) {
      if (strpos($error_key, $key) === 0) {
        $rows[$key]['class'][] = 'error';
      }
    }
    $row_position++;
  }

  if (empty($rows)) {
    $rows[] = array(array('data' => $form['#empty_text'], 'colspan' => '3'));
  }

  $header = array(t('Sibling Name'), t('Weight'));
  $output = theme('table', array(
      'header' => $header,
      'rows' => $rows,
      'attributes' => array('id' => 'taxonomy-siblings'),
    ));

  return $output;
}

/**
 * Form submit callback that resets the weight before the term save operation.
 */
function term_sibling_reorder_taxonomy_form_term_pre_submit($form, &$form_state) {
  if (isset($form_state['values']['siblings'])) {
    $siblings = $form_state['values']['siblings'];
    $siblings_orig = $form_state['complete form']['relations']['siblings'];

    uasort($siblings, 'drupal_sort_weight');

    $changed = $new_term_weights = array();
    $count = 0;

    $current = ($form_state['values']['tid']) ? $form_state['values']['tid'] : 'current';

    // Start a new count from 0.
    foreach ($siblings as $tid => $term) {
      $new_term_weights[$tid] = $count;

      if ($tid != $current && $count != $siblings_orig[$tid]['#term']['weight']) {
        $changed[$tid] = $count;
      }

      $count++;
    }

    // Use this to set the weight of this term.
    $form_state['values']['weight'] = $new_term_weights[$current];

    if (!empty($changed)) {
      $form_state['storage']['changed_sibling_weights'] = $changed;
    }
  }
}

/**
 * Form submit callback after term has been saved.
 *
 * Saves sibling order and pushes changes to taxonomy_menu (if enabled).
 */
function term_sibling_reorder_taxonomy_form_term_post_submit($form, &$form_state) {
  if (isset($form_state['storage']['changed_sibling_weights'])) {
    $changed = $form_state['storage']['changed_sibling_weights'];

    foreach ($changed as $tid => $weight) {
      $term = taxonomy_term_load($tid);
      $term->weight = $weight;
      taxonomy_term_save($term);
    }

    // If taxonomy_menu is enabled with sync selected, push these changes to
    // the menu for this vocab.
    if (module_exists('taxonomy_menu')) {
      $vid = $form['#vocabulary']->vid;

      $menu_name = variable_get(_taxonomy_menu_build_variable('vocab_menu', $vid), 0);
      $sync = variable_get(_taxonomy_menu_build_variable('sync', $vid), 0);
      if ($menu_name && $sync) {
        // Update all menu items (do not rebuild the menu).
        _taxonomy_menu_update_link_items($vid);

        // Rebuild the menu.
        menu_cache_clear($menu_name);
      }
    }
  }
}

/**
 * Get a term's children, or top level of a vocab if $tid=0 and $vid<>0.
 *
 * This is a wrapper around core's taxonomy_get_children(), with support for
 * getting the top level terms of a vocab.
 */
function _term_sibling_reorder_taxonomy_get_children($tid, $vid = 0) {
  if ($tid === 0 && $vid > 0) {
    $query = db_select('taxonomy_term_data', 't');
    $query->join('taxonomy_term_hierarchy', 'h', 'h.tid = t.tid');
    $query->addField('t', 'tid');
    $query->condition('h.parent', $tid);
    if ($vid) {
      $query->condition('t.vid', $vid);
    }
    $query->addTag('term_access');
    $query->orderBy('t.weight');
    $query->orderBy('t.name');
    $tids = $query->execute()->fetchCol();
    $children = taxonomy_term_load_multiple($tids);
  }

  return isset($children) ? $children : taxonomy_get_children($tid, $vid);
}
