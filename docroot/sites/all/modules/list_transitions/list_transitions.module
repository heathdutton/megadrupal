<?php

/**
 * @file
 * Allows for customized transitions between list values.
 */

/**
 * Implements hook_facetapi_hook_info().
 */
function list_transitions_hook_info() {
  return array(
    'list_transitions_criterion' => array(
      'group' => 'list_transitions',
    ),
  );
}

/**
 * Implements hook_menu().
 */
function list_transitions_menu() {
  $items = array();

  // Bails if Field UI isn't installed.
  if (!module_exists('field_ui')) {
    return $items;
  }

  $items['admin/structure/list-transitions/transition/%list_transitions_transition/delete'] = array(
    'title' => 'Remove list transition',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('list_transition_delete_form', 4),
    'access arguments' => array('administer site configuration'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'list_transitions.admin.inc',
  );

  // Create tabs for all possible bundles.
  foreach (entity_get_info() as $entity_type => $entity_info) {
    if ($entity_info['fieldable']) {
      foreach ($entity_info['bundles'] as $bundle_name => $bundle_info) {
        if (isset($bundle_info['admin'])) {
          // Extract path information from the bundle.
          $path = $bundle_info['admin']['path'];
          // Different bundles can appear on the same path (e.g. %node_type and
          // %comment_node_type). To allow field_ui_menu_load() to extract the
          // actual bundle object from the translated menu router path
          // arguments, we need to identify the argument position of the bundle
          // name string ('bundle argument') and pass that position to the menu
          // loader. The position needs to be casted into a string; otherwise it
          // would be replaced with the bundle name string.
          if (isset($bundle_info['admin']['bundle argument'])) {
            $bundle_arg = $bundle_info['admin']['bundle argument'];
            $bundle_pos = (string) $bundle_arg;
          }
          else {
            $bundle_arg = $bundle_name;
            $bundle_pos = '0';
          }
          // This is the position of the %field_ui_menu placeholder in the
          // items below.
          $field_position = count(explode('/', $path)) + 1;

          // Extract access information, providing defaults.
          $access = array_intersect_key($bundle_info['admin'], drupal_map_assoc(array('access callback', 'access arguments')));
          $access += array(
            'access callback' => 'list_transitions_access_callback',
            'access arguments' => array('administer site configuration'),
          );
          $access['access arguments'][] = (string) $field_position;
          $access['access arguments'][] = (string) $entity_type;
          $access['access arguments'][] = (string) $bundle_pos;

          // Adds the "List Transitions" menu item.
          $items["$path/fields/%field_ui_menu/list-transitions"] = array(
            'load arguments' => array($entity_type, $bundle_arg, $bundle_pos, '%map'),
            'title' => 'List transitions',
            'page callback' => 'drupal_get_form',
            'page arguments' => array('list_transitions_criterion_form', $field_position, $entity_type),
            'type' => MENU_LOCAL_TASK,
            'file' => 'list_transitions.admin.inc',
            'weight' => 5,
          ) + $access;
        }
      }
    }
  }

  return $items;
}

/**
 * Access callback for the list transitions form.
 *
 * @param string $string
 *   The permission string.
 * @param int $field_position
 *   The position of the field name in the path.
 * @param string $entity_type
 *   The machine readable name of the entity.
 * @param int $bundle_pos
 *   The position of the bundle name in the path.
 *
 * @return
 *   A boolean flagging whether the user has access to the resource.
 */
function list_transitions_access_callback($string, $field_position, $entity_type, $bundle_pos) {
  if (user_access($string)) {
    // Gets the field and bundle from the path.
    $field_name = arg($field_position);
    $bundle_name = arg($bundle_pos);

    // Gets the field instance, checks whether we are using out widget.
    $field = field_info_field($field_name);
    $instances = field_info_instances($entity_type, $bundle_name);
    $multiple = $field['cardinality'] > 1 || $field['cardinality'] == FIELD_CARDINALITY_UNLIMITED;
    if (isset($instances[$field_name])) {
      return ('list_transitions_select' == $instances[$field_name]['widget']['type'] && !$multiple);
    }
  }

  // Defaults to FALSE.
  return FALSE;
}

/**
 * Implements hook_theme().
 */
function list_transitions_theme() {
  return array(
    'list_transitions_table' => array(
      'render element' => 'element',
      'file' => 'list_transitions.admin.inc',
    ),
  );
}

/**
 * Implements hook_list_transitions_load_entity().
 */
function list_transitions_list_transitions_load_entity() {
  if ('node' == arg(0) && is_numeric(arg(1))) {
    return node_load(arg(1));
  }
}

/**
 * Implements hook_field_widget_info().
 */
function list_transitions_field_widget_info() {
  return array(
    'list_transitions_select' => array(
      'label' => t('Select list with transitions'),
      'field types' => array('list_integer', 'list_float', 'list_text'),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
      ),
    ),
  );
}

/**
 * Gets list criterion.
 *
 * @param array $instance
 *   The field instance criterion is being collected for.
 *
 * @return array
 *   The criterion that applies to the entity.
 */
function list_transitions_get_criterion($instance) {
  $criterion = array();
  foreach (module_implements('list_transitions_criterion') as $module) {
    $function = $module . '_list_transitions_criterion';
    foreach ((array) $function($instance) as $criteria_name => $criteria) {
      $criterion[$criteria_name] = $criteria += array(
        'label' => $criteria_name,
        'group' => t('Other'),
        'criteria arguments' => array(),
        'settings callback' => FALSE,
        'settings arguments' => array(),
      );
    }
  }
  return $criterion;
}

/**
 * Implements hook_field_widget_form().
 *
 * @see options_field_widget_form()
 */
function list_transitions_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  global $user;

  // Abstract over the actual field columns, to allow different field types to
  // reuse those widgets.
  $value_key = key($field['columns']);

  $type = str_replace('list_transitions_', '', $instance['widget']['type']);
  $multiple = $field['cardinality'] > 1 || $field['cardinality'] == FIELD_CARDINALITY_UNLIMITED;
  $required = $element['#required'];
  $has_value = isset($items[0][$value_key]);
  $properties = _options_properties($type, $multiple, $required, $has_value);

  $entity_type = $element['#entity_type'];
  $entity = $element['#entity'];

  // Prepare the list of options, get the default value.
  $options = _options_get_options($field, $instance, $properties, $entity_type, $entity);
  $default_value = _options_storage_to_form($items, $options, $value_key, $properties);

  // Hacky way to check whether we are on the Field UI form. Invokes option
  // stripping method using our criterion. Fall back to normal list widget if
  // multiple values are allowed.
  if ((!isset($form['#type']) || 'fieldset' != $form['#type']) && !$multiple /*&& 1 != $user->uid*/) {
    $entity = isset($element['#entity']) ? $element['#entity'] : FALSE;
    list_transitions_filter_options($options, $instance, $default_value[0], $entity);
  }

  // Put current field values in shape.
  switch ($type) {
    case 'select':
      $element += array(
        '#type' => 'select',
        '#default_value' => $default_value,
        // Do not display a 'multiple' select box if there is only one option.
        '#multiple' => $multiple && count($options) > 1,
        '#options' => $options,
      );
      break;
  }

  $element += array(
    '#value_key' => $value_key,
    '#element_validate' => array('options_field_widget_validate'),
    '#properties' => $properties,
  );

  return $element;
}

/**
 * Implements hook_field_widget_settings_form().
 */
function list_transitions_field_widget_settings_form($field, $instance) {
  return options_field_widget_settings_form($field, $instance);
}

/**
 * Filters the list options based on the selected criteria.
 *
 * Invokes each selected criteria's callbacks for each option in the list. If
 * at least one criteria passes, the item will remain in the options. Otherwise
 * it is filtered out.
 *
 * @param array &$options
 *   The options being filtered.
 * @param array $instance
 *   The field instance.
 * @param string $default_value
 *   The default value.
 * @param stdClass|FALSE $entity
 *   The entity containing the field data, FALSE if the entity is no present
 *   which will default to the standard list display.
 */
function list_transitions_filter_options(array &$options, array $instance, $default_value, $entity) {
  if ($entity) {

    // Load the instance settings, sets the base name.
    $settings = list_transitions_get_instance_settings($instance['field_name'], $instance['entity_type'], $instance['bundle']);
    $base_name = "{$instance['entity_type']}:{$instance['bundle']}:{$instance['field_name']}";
    $criterion = list_transitions_get_criterion($instance);

    // If we have no criterion, treat this as a normal list.
    if (!$criterion) {
      return;
    }

    // Iterate over options and strips applicable ones.
    foreach ($options as $option_name => $option) {

      // If the option is the current value, display it.
      if ($option_name == $default_value) {
        continue;
      }

      // Iterate over criteria, makes sure at least one passed.
      $name = "$base_name:$default_value:$option_name";
      if (isset($settings[$name])) {
        $active_criterion = array_filter($settings[$name]->criterion, 'list_transitions_filter_inactive_criterion');
        foreach ($active_criterion as $criteria_name => $active) {
          $criteria = $criterion[$criteria_name];
          $criteria_settings = $settings[$name]->criterion[$criteria_name];
          $arguments = array_merge(array($entity, $instance, $criteria_settings), $criteria['criteria arguments']);
          if (call_user_func_array($criteria['criteria callback'], $arguments)) {
            // Coninue to next option.
            continue 2;
          }
        }
      }

      // If we get here, no criteria matched to unset the value.
      unset($options[$option_name]);
    }
  }
}

/**
 * Filters inactive criterion.
 */
function list_transitions_filter_inactive_criterion($criteria_settings) {
  return !empty($criteria_settings['active']);
}

/**
 * Loads all transitions associated with the field.
 *
 * @param string $field_name
 *   The machine name of the field.
 * @param string $entity_type
 *   The machine name of the entity.
 * @param string $bundle_name
 *   The machine name of the bundle.
 *
 * @return array
 *   An array of settings keyed by name.
 */
function list_transitions_get_instance_settings($field_name, $entity_type, $bundle_name) {
  $settings = &drupal_static(__FUNCTION__, array());
  if (!isset($settings[$field_name][$entity_type][$bundle_name])) {
    ctools_include('export');
    $args = array(
      'field_name' => $field_name,
      'entity_type' => $entity_type,
      'bundle' => $bundle_name
    );
    $transitions = ctools_export_load_object('list_transitions', 'conditions', $args);
    $settings[$field_name][$entity_type][$bundle_name] = $transitions;
  }
  return $settings[$field_name][$entity_type][$bundle_name];
}

/**
 * Loads a transition setting.
 *
 * @param $name
 *   The machine name of the setting.
 *
 * @return stdClass|NULL
 *   The configuration settings, NULL if the settings do not exist.
 */
function list_transitions_transition_load($name) {
  ctools_include('export');
  return ctools_export_crud_load('list_transitions', $name);
}
