<?php

/**
 * Implements hook_menu().
 * Set the mapping process available after the module has be enabled in the
 * admin/config/user-interface
 *
 * It will be a form that can be accessed only if the user is an administrator.
 */
function good_relations_menu() {
  $items = array();
  // Content type mapping menu item.
  $items['admin/config/user-interface/map_your_products'] = array(
    'title' => 'Available plugins to be mapped',
    'description' => 'Add RDF to products',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('good_relations_computation'),
    'access arguments' => array('user_is_admin'),
    'type' => MENU_NORMAL_ITEM,
  );
  // Autocomplete menu item.
  $items['tags/autocomplete'] = array(
    'title' => 'Autocomplete for tags',
    'page callback' => '_tags_autocomplete',
    'access arguments' => array('access tags autocomplete'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implements hook_ctools_plugin_type().
 *
 * The 'product' contains everything you need.
 * (product contains the content_types + product_variations -> commerce_prduct
 * references or any field of -> field_collection_item and also the
 * entity_references as separate items)
 *
 */
function good_relations_ctools_plugin_type() {
  return array(
    'product' => array(
      'use hooks' => TRUE,
    ),
  );
}

/**
 * Computation will be done using the following steps:
 * 1. include and load plugins.
 * 2. set the plugins in the $content_types (array) which includes separate
 *  commerce_product references and content types (and their entity references).
 * There are 3 types of plugins:
 * - content types
 *  + entity_reference (mapped separately)
 * - commerce_product
 * These are all included in the _options and _info.
 * 3. create our form accordingly (complex form).
 */
function good_relations_computation($form, &$form_state) {
  // Include all available plugins.
  ctools_include('plugins');
  // Load all plugins type 'product'.
  $content_types = ctools_get_plugins('good_relations', 'product');

  // Create our options.
  $all_options = array();
  $all_options_info = array();
  // All_options will contain the keys and values found.
  // All_options_info will contains the entity type.
  foreach ($content_types as $key => $value) {
    $fieldset_options = array();
    foreach ($value as $id => $product) {
      if (is_array($product)) {
        $fieldset_options[$id] = $product['label'];
      }
    }

    $all_options = array_merge($all_options, array($key => $fieldset_options));
    $all_options_info[$key] = array('entity' => $value['entity'], 'label' => $value['label']);
  }

  // Start building the form.
  // According to the options build the plugin_name => plugin_elements
  // Ex. variation_types => bags_cases...; regular_content_types => blog...
  foreach ($all_options as $plugin_name => $plugin_elements) {
    // The plugin_name will be a fieldset.
    $form[$plugin_name] = array(
      '#type' => 'fieldset',
      '#title' => 'Available: ' . $all_options_info[$plugin_name]['label'] . '',
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );
    // All the variation types and regular content types depending on the key.
    foreach ($plugin_elements as $machine_name => $label) {
      $form[$plugin_name][$plugin_name . '-' . $machine_name] = array(
        '#type' => 'checkbox',
        '#title' => $label,
        '#ajax' => array(
          'callback' => '_good_relations_ajax_callback',
          'wrapper' => $plugin_name . '-' . $machine_name . '_container',
          'method' => 'replace',
          'effect' => 'slide',
          'progress' => array('type' => 'none'),
        ),
      );
      // In order to generate the form correctly after the ajax call use a container.
      $form[$plugin_name][$plugin_name . '-' . $machine_name . '_container'] = array(
        '#id' => $plugin_name . '-' . $machine_name . '_container',
        '#type' => 'container',
      );

      // Ajax trigger.
      // If there is a triggering elements (checked) the fields will appear.
      if ((isset($form_state['triggering_element'])) &&
          ($form_state['triggering_element']['#value'])) {
        // If checked, the fields will appear, in a fieldset manner.
        $form[$plugin_name][$plugin_name . '-' . $machine_name . '_container'][$plugin_name . '-' . $machine_name . '_fieldset'] = array(
          '#type' => 'fieldset',
          '#tree' => TRUE,
          '#states' => array(
            'visible' => array(
              ':input[name="' . $plugin_name . '-' . $machine_name . '"]' => array('checked' => TRUE),
            ),
          ),
        );

        // Get the product_field_name.
        // Which can be commerce_product (included in entity reference).
        // Or field_collection_item (include in field collection).
        // Or none if no such fields exist.
        $product_field_name = _good_relations_get_product_field_name($machine_name, $all_options_info[$plugin_name]['entity']);
        $instances = array();
        if (isset($product_field_name[1]['type']) && $product_field_name[1]['type'] == 'commerce_product_reference') {
          $instances = field_info_instances('commerce_product', $machine_name);
          $product_field_name['entity'] = 'commerce_product';
          $product_field_name['bundle'] = $instances[key($instances)]['bundle'];
        }
        if (isset($product_field_name[1]['type']) && $product_field_name[1]['type'] == 'field_collection') {
          $instances = field_info_instances('field_collection_item', $product_field_name[0]);
          $product_field_name['entity'] = 'field_collection_item';
          $product_field_name['bundle'] = $instances[key($instances)]['bundle'];
        }

        // Load current mapping of the content type (if any).
        $machine_name_map = rdf_mapping_load($all_options_info[$plugin_name]['entity'], $machine_name);

        // Get all of the fields for the checked elements.
        $fields = field_info_instances($all_options_info[$plugin_name]['entity'], $machine_name);
        foreach ($fields as $field) {
          $field_map = $machine_name_map[$field['field_name']];

          $form[$plugin_name][$plugin_name . '-' . $machine_name . '_container'][$plugin_name . '-' . $machine_name . '_fieldset'][$field['field_name']] = array(
            '#type' => 'checkbox',
            '#title' => $field['label'],
          );
          // If checked => textfield with mapping information will appear.
          $form[$plugin_name][$plugin_name . '-' . $machine_name . '_container'][$plugin_name . '-' . $machine_name . '_fieldset'][$field['field_name'] . '_textfield'] = array(
            '#type' => 'textfield',
            '#size' => 30,
            '#maxlength' => 128,
            '#states' => array(
              'visible' => array(
                ':input[name="' . $plugin_name . '-' . $machine_name . '_fieldset[' . $field['field_name'] . ']"]' => array('checked' => TRUE),
              ),
            ),
            // Autocomplete for helping the user with information using the database table.
            '#autocomplete_path' => 'tags/autocomplete',
          );
          // If the mapping is already saved in the database.
          // The information will appear as completed accordingly.
          $form_values = array();
          if (isset($field_map)) {
            foreach ($field_map['predicates'] as $key => $value) {
              $form_values = array_merge($form_values, array($value));
            }
            $form[$plugin_name][$plugin_name . '-' . $machine_name . '_container'][$plugin_name . '-' . $machine_name . '_fieldset'][$field['field_name']]['#default_value'] = 1;
            $form[$plugin_name][$plugin_name . '-' . $machine_name . '_container'][$plugin_name . '-' . $machine_name . '_fieldset'][$field['field_name'] . '_textfield']['#default_value'] = $form_values;
          }
          if (!empty($instances) && $field['field_name'] === $product_field_name[0]) {
            $form[$plugin_name][$plugin_name . '-' . $machine_name . '_container'][$plugin_name . '-' . $machine_name . '_fieldset'][$field['field_name'] . '_fieldset'] = array(
              '#type' => 'fieldset',
              '#title' => $field['label'] . ' fields:',
              '#tree' => TRUE,
              '#states' => array(
                'visible' => array(
                  ':input[name="' . $plugin_name . '-' . $machine_name . '_fieldset[' . $field['field_name'] . ']"]' => array('checked' => TRUE),
                ),
              ),
            );
            // Now check if there is any mapping done on the entity.
            // Field collection or Entity reference.
            $entity_map = rdf_mapping_load($product_field_name['entity'], $product_field_name['bundle']);
            foreach ($instances as $field_name => $field_info) {
              // Load current mapping (if any).
              $entity_field_map = $entity_map[$field_name];
              if (isset($entity_field_map)) {
                $entity_field_map = implode(', ', $entity_field_map['predicates']);
              }
              $form[$plugin_name][$plugin_name . '-' . $machine_name . '_container'][$plugin_name . '-' . $machine_name . '_fieldset'][$field['field_name'] . '_fieldset'][$field_name] = array(
                '#type' => 'textfield',
                '#title' => $field_info['label'],
                '#size' => 30,
                '#maxlength' => 128,
                '#default_value' => $entity_field_map,
                // Autocomplete for helping the user with information using the database table.
                '#autocomplete_path' => 'tags/autocomplete',
              );
            }
            if (isset($product_field_name['entity'])) {
              $form_state[$machine_name][$machine_name . '_fieldset']['entity_field_type'] = $product_field_name['entity'];
              $form_state[$machine_name][$machine_name . '_fieldset']['entity_field_bundle'] = $product_field_name['bundle'];
            }
          }
        }
      }
    }
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Map'),
  );
  return $form;
}

/**
 * @param $form
 * @param $form_state
 * @return mixed
 */
function _good_relations_ajax_callback($form, &$form_state) {
  $primary_parent = $form_state['triggering_element']['#array_parents'][0];
  $secondary_parent = $form_state['triggering_element']['#array_parents'][1];
  return $form[$primary_parent][$secondary_parent . '_container'];
}

/**
 * @param $form
 * @param $form_state
 * @return bool
 *
 * Validate handler for the previously created form.
 *
 * This can be improved for more a more complex functionality.
 */
function good_relations_computation_validate($form, &$form_state) {
//  $fv = $form_state['values'];
//  $products = array_filter($fv, "is_numeric");
//  foreach ($products as $bundle => $value) {
//    // If checked.
//    if ($value) {
//      if (array_key_exists($bundle, $form['variation_types'])) {
//        $type = 'variation_types';
//      }
//      elseif (array_key_exists($bundle, $form['regular_content_types'])) {
//        $type = 'regular_content_types';
//      }
//      $mapping = array();
//      if (isset($fv[$bundle . '_fieldset'])) {
//        $fieldset = $fv[$bundle . '_fieldset'];
//        $fields = array_filter($fieldset, "is_numeric");
//        foreach ($fields as $id => $field) {
//          if (($field) && (isset($fieldset[$id . '_textfield']))) {
//            $mapping[$id] = $fieldset[$id . '_textfield'];
//          }
//          $entity_map = array();
//          $entity_type = NULL;
//          $entity_bundle = NULL;
//          // Map the entity reference if there is any.
//          if (($field) && (isset($fieldset[$id . '_fieldset']))) {
//            $entity_map = array();
//            foreach ($fieldset[$id . '_fieldset'] as $entity_field_name => $entity_field_map) {
//              $entity_map[$entity_field_name] = $entity_field_map;
//            }
//            if (isset($form_state[$bundle][$bundle . '_fieldset']['entity_field_type'])) {
//              $entity_type = $form_state[$bundle][$bundle . '_fieldset']['entity_field_type'];
//              $entity_bundle = $form_state[$bundle][$bundle . '_fieldset']['entity_field_bundle'];
//            }
//            // Instance for each entity (field collection or commerce product reference).
//            if (!empty($entity_type)) {
//              $instance = _good_relations_get_instance_entity($entity_type, $entity_bundle, $entity_map);
//// CANNOT VALIDATE BECAUSE ENCODED DATA
////              $emf = $instance->getEntityMappedFields();
////              foreach($emf as $id => $value) {
////                // GR specifics.
////                if((strpos($value, 'gr:') === FALSE) && (strpos($value, 'content:') === FALSE)) {
////                  form_set_error('', t('The tag must contain and start with gr: (good relations)'));
////                }
////              }
//            }
//          }
//        }
//        // Instance for the big picture (the node)
//        if (($instance = _good_relations_get_instance($bundle, $type, $mapping)) && (!empty($mapping))) {
////          $mf = $instance->getMappingFields();
////          foreach($mf as $id => $value) {
////            // GR specifics.
////            if((strpos($value, 'gr:') === FALSE) && (strpos($value, 'content:') === FALSE)) {
////              form_set_error('', t('The tag must contain and start with gr: (good relations)'));
////            }
////          }
//        }
//      }
//    }
//  }
}

/**
 * @param $form
 * @param $form_state
 *
 * the _submit() method for the previously created form.
 */
function good_relations_computation_submit($form, &$form_state) {
  $fv = $form_state['values'];
  $products = array_filter($fv, "is_numeric");
  foreach ($products as $name => $value) {
    // If checked.
    if ($value) {
      $info = explode('-', $name);
      $type = $info[0];
      $bundle = $info[1];
      $mapping = array();
      if (isset($fv[$name . '_fieldset'])) {
        $fieldset = $fv[$name . '_fieldset'];
        $fields = array_filter($fieldset, "is_numeric");
        foreach ($fields as $id => $field) {
          if (($field) && (isset($fieldset[$id . '_textfield']))) {
            $mapping[$id] = $fieldset[$id . '_textfield'];
          }
          $entity_map = array();
          $entity_type = NULL;
          $entity_bundle = NULL;
          // Map the entity reference if there is any.
          if (($field) && (isset($fieldset[$id . '_fieldset']))) {
            $entity_map = array();
            foreach ($fieldset[$id . '_fieldset'] as $entity_field_name => $entity_field_map) {
              $entity_map[$entity_field_name] = $entity_field_map;
            }
            if (isset($form_state[$bundle][$bundle . '_fieldset']['entity_field_type'])) {
              $entity_type = $form_state[$bundle][$bundle . '_fieldset']['entity_field_type'];
              $entity_bundle = $form_state[$bundle][$bundle . '_fieldset']['entity_field_bundle'];
            }
            // Instance for each entity (field collection or entity reference).
            if (!empty($entity_type)) {
              $instance = _good_relations_get_instance_entity($entity_type, $entity_bundle, $entity_map);
              rdf_mapping_save($instance->map());
            }
          }
        }
        // Instance for the big picture (the node)
        if (($instance = _good_relations_get_instance($bundle, $type, $mapping)) && (!empty($mapping))) {
          rdf_mapping_save($instance->map());
          drupal_set_message($instance->resultMessage());
        }
      }
    }
  }
}

/**
 * Implements hook_rdf_namespace().
 *
 * @return array
 */
function good_relations_rdf_namespaces() {
  return array(
    'gr' => 'http://purl.org/goodrelations/v1#',
  );
}

/**
 * @param $bundle
 * @param $type
 * @param $mapping
 * @return mixed
 */
function _good_relations_get_instance($bundle, $type, $mapping) {
  // Get all instances.
  $instances = &drupal_static(__FUNCTION__);
    ctools_include('plugins');
    // Get the plugin.
    $plugin = ctools_get_plugins('good_relations', 'product', $type);
    // Get the class.
    $class = ctools_plugin_get_class($plugin[$bundle], 'handler');
    // Create a new instance of that class.
    $instances[$bundle] = new $class($type, $bundle, $mapping);
    if (!is_subclass_of($instances[$bundle], 'good_relations_interface')) {
      $instances[$bundle] = null;
    }
  return $instances[$bundle];
}

function _good_relations_get_instance_entity($entity_type, $entity_bundle, $entity_map) {
  // Get all instances.
  $instances = &drupal_static(__FUNCTION__);
  // Create a new instance of that class.
  $instances[$entity_bundle] = new good_relations_entity_reference($entity_type, $entity_bundle, $entity_map);
  if (!is_subclass_of($instances[$entity_bundle], 'good_relations_interface')) {
    $instances[$entity_bundle] = null;
  }
  return $instances[$entity_bundle];
}

/**
 * Autocomplete helper
 *
 * $string = string for search
 *
 */
function _tags_autocomplete($string = '') {
  $matches = array();
  $result = db_select('good_relations_tags', 'grt')
      ->fields('grt', array('grt_tag'))
      ->condition('grt_tag', '%' . db_like($string) . '%', 'LIKE')
      ->execute();
  // Save the query to matches.
  foreach ($result as $row) {
    $matches[$row->grt_tag] = check_plain($row->grt_tag);
  }
  // Return the result to the form in json.
  drupal_json_output($matches);
}

/**
 * @param $content_type
 * @param $entity
 * @return array
 */
function _good_relations_get_product_field_name($content_type, $entity) {
  $product_reference_fields = array();
  $field_info_map = field_info_field_map();
  foreach (field_info_instances($entity, $content_type) as $field_name => $field_info) {
    if (!empty($field_info_map[$field_name]['type']) && $field_info_map[$field_name]['type'] == 'commerce_product_reference') {
      $product_reference_fields = array($field_name, $field_info_map[$field_name]);
    }
    if (!empty($field_info_map[$field_name]['type']) && $field_info_map[$field_name]['type'] == 'field_collection') {
      $product_reference_fields = array($field_name, $field_info_map[$field_name]);
    }
  }
  return $product_reference_fields;
}
