<?php
/**
 * @file
 * Code for Subdomain Field module.
 */

/**
 * Implements hook_field_info().
 */
function subdomain_field_field_info() {
  return array(
    'subdomain' => array(
      'label' => t('Subdomain Field'),
      'description' => t('Allows users to specify a subdomain for which the entity is accessible.'),
      'default_widget' => 'text_textfield',
      'default_formatter' => 'subdomain_formatter',
      'settings' => array('max_length' => 255),
      'instance_settings' => array('text_processing' => NULL),
      'property_type' => 'text',
    ),
  );
}

/**
 * Implements hook_field_formatter_info().
 */
function subdomain_field_field_formatter_info() {
  return array(
    'subdomain_formatter' => array(
      'label' => t('Subdomain field formatter'),
      'field types' => array('subdomain'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function subdomain_field_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  switch ($display['type']) {
    case 'subdomain_formatter':
      foreach ($items as $delta => $item) {
        $url = subdomain_field_get_url($item['value']);
        $element[$delta] = array(
          '#theme' => 'link',
          '#text' => $url,
          '#path' => $url,
          '#options' => array('attributes' => array('class' => array('subdomain_field')), 'html' => FALSE),
        );
        break;
      }
  }
  return $element;
}
/**
 * Generate an URL based on the found subdomain.
 *
 * @param string $subdomain
 *   The subdomain.
 *
 * @return string
 *   The entire URL using that subdomain.
 */
function subdomain_field_get_url($subdomain) {
  global $base_url, $cookie_domain;
  // FIXME: handle subdomains with only numbers properly.
  return preg_replace('/(https?:\/\/)(.*)/', '$1' . $subdomain . $cookie_domain, $base_url);
}
/**
 * Implements hook_field_widget_form().
 */
function subdomain_field_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $element += array(
    '#type' => $instance['widget']['type'],
    '#default_value' => isset($items[$delta]) ? $items[$delta] : '',
  );
  return $element;
}

/**
 * Implements hook_field_widget_error().
 */
function subdomain_field_field_widget_error($element, $error, $form, &$form_state) {
  form_error($element, $error['message']);
}

/**
 * Implements hook_field_is_empty().
 */
function subdomain_field_field_is_empty($item, $field) {
  if (empty($item['value'])) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implements hook_field_validate().
 */
function subdomain_field_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  // TODO: CHECK FOR EXISTING SUBDOMAIN.
  foreach ($items as $delta => $item) {
    if (!empty($item['value'])) {
      // Subdomain is already in database.
      if (!preg_match('/^[a-z0-9-\.]*$/', $item['value'])) {
        $errors[$field['field_name']][$langcode][$delta][] = array(
          'error' => 'text_max_length',
          'message' => t('%name: the subdomain must only contain characters 0-9, a-z, . and -.', array('%name' => $instance['label'])),
        );
      }
      if ($path = subdomain_field_get_by_subdomain($item['value'])) {
        $uri = entity_uri($entity_type, $entity);
        // And it's not pointing at this entity.
        if ($uri['path'] != $path) {
          $errors[$field['field_name']][$langcode][$delta][] = array(
            'error' => 'already_used',
            'message' => t('%name: the subdomain %subdomain is already in use.', array('%name' => $instance['label'], '%subdomain' => $item['value'])),
          );
        }
      }
      if (!empty($field['settings']['max_length']) && drupal_strlen($item['value']) > $field['settings']['max_length']) {
        $errors[$field['field_name']][$langcode][$delta][] = array(
          'error' => 'text_max_length',
          'message' => t('%name: the value may not be longer than %max characters.', array('%name' => $instance['label'], '%max' => $field['settings']['max_length'])),
        );
      }
    }
  }
}

/**
 * Implements hook_field_widget_info_alter().
 */
function subdomain_field_field_widget_info_alter(&$info) {
  $info['text_textfield']['field types'][] = 'subdomain';
}

/**
 * Implements hook_url_inbound_alter().
 */
function subdomain_field_url_inbound_alter(&$path, $original_path, $path_language) {
  // Does nothing if a non-existing autogenerated image is requested.
  $router_item = menu_get_item($path);
  if ($router_item['page_callback'] == 'image_style_deliver') {
    return;
  }
  // Looks up the correct path and changes the effective path.
  if ($subdomain = subdomain_field_subdomain()) {
    if ($newpath = subdomain_field_get_path($subdomain)) {
      $path = $newpath;
    }
  }
}

/**
 * Implements hook_url_outbound_alter().
 */
function subdomain_field_url_outbound_alter(&$path, &$options, $original_path) {
  $data = _subdomain_field_get_cache();
  // Path has been cached.
  if (isset($data['paths'][$path])) {
    // A subdomain exists for the path.
    if ($data['paths'][$path] !== FALSE) {
      $path = subdomain_field_get_url($data['paths'][$path]);
      $options['external'] = TRUE;
      return;
    }
  }
  // Path has not been cached.
  else {
    // But an entry exists.
    if ($subdomain = subdomain_field_get_by_path($path)) {
      $data['subdomains'][$subdomain] = $path;
      $data['paths'][$path] = $subdomain;
      $path = subdomain_field_get_url($data['paths'][$path]);
      $options['external'] = TRUE;
      return;
    }
    // And an entry does not exist.
    else {
      $data['paths'][$path] = NULL;
    }
    _subdomain_field_set_cache($data);
  }

  // If URL has not been changed, check whether we are on a subdomain which
  // should be stripped from links.
  static $real_base_url = '';
  if (($real_base_url != '' || $subdomain = subdomain_field_subdomain()) && empty($options['external']) && empty($options['absolute'])) {
    if ($real_base_url == '') {
      global $base_url;
      $real_base_url = str_replace($subdomain . '.', '', $base_url);
    }
    if ($path == '<front>') {
      $path = '';
    }
    $path = $real_base_url . '/' . $path;
    $options['external'] = TRUE;
  }
}

/**
 * Implements hook_entity_update().
 */
function subdomain_field_entity_update($entity, $type) {
  _subdomain_field_change_action($entity, $type, 'update');
}

/**
 * Implements hook_entity_delete().
 */
function subdomain_field_entity_delete($entity, $type) {
  _subdomain_field_change_action($entity, $type, 'delete');
}

/**
 * Implements hook_entity_insert().
 */
function subdomain_field_entity_insert($entity, $type) {
  _subdomain_field_change_action($entity, $type, 'insert');
}

/**
 * Get the current subdomain.
 *
 * @return string
 *   The current subdomain.
 */
function subdomain_field_subdomain() {
  global $cookie_domain;
  if ($_SERVER['SERVER_NAME'] != ltrim($cookie_domain, '.') && $_SERVER['SERVER_NAME'] != 'www' . $cookie_domain) {
    return str_replace($cookie_domain, '', $_SERVER['SERVER_NAME']);
  }
  return '';
}

/**
 * Get the real path based on a subdomain (cached).
 *
 * @param string $subdomain
 *   The subdomain.
 *
 * @return string
 *   The path.
 */
function subdomain_field_get_path($subdomain) {
  $data = _subdomain_field_get_cache();
  if (!empty($data['subdomains'][$subdomain])) {
    return $data['subdomains'][$subdomain];
  }
  if ($path = subdomain_field_get_by_subdomain($subdomain)) {
    $data['subdomains'][$subdomain] = $path;
    $data['paths'][$path] = $subdomain;
    _subdomain_field_set_cache($data);
    return $path;
  }
}

/**
 * Perform actions when entities are inserted, updated or deleted.
 *
 * @param object $entity
 *   The entity object.
 * @param string $type
 *   The entity type.
 * @param string $action
 *   The performed action.
 */
function _subdomain_field_change_action($entity, $type, $action) {
  $uri = entity_uri($type, $entity);
  // Removing items from cache.
  $data = _subdomain_field_get_cache();
  $subdomain = array_search($uri['path'], $data['subdomains']);
  unset($data['subdomains'][$subdomain]);
  unset($data['paths'][$uri['path']]);
  _subdomain_field_set_cache($data);

  // Updating database with info from any subdomain fields.
  $fields_info = _field_info_collate_fields();
  foreach ($fields_info['fields'] as $field) {
    if ($field['type'] == 'subdomain') {
      if (property_exists($entity, $field['field_name'])) {
        $wrapper = entity_metadata_wrapper($type, $entity);
        $subdomain_value = $wrapper->$field['field_name']->value();
        switch ($action) {
          case 'update':
            $query = db_merge('subdomain_field_path')
              ->fields(array('subdomain' => $subdomain_value))
              ->key(array('path' => $uri['path']))
              ->execute();
            break;

          case 'insert':
            $query = db_insert('subdomain_field_path')
              ->fields(array('subdomain' => $subdomain_value, 'path' => $uri['path']))
              ->execute();
            break;

          case 'delete':
            $query = db_delete('subdomain_field_path')
              ->condition('path', $uri['path'])
              ->execute();
            break;
        }
      }
    }
  }
}

/**
 * Get the cached data or create new structure if empty.
 * @return array
 *   Cached data.
 */
function _subdomain_field_get_cache() {
  if ($cache = cache_get('subdomain_field_mapping')) {
    $data = $cache->data;
  }
  else {
    $data = array('subdomains' => array(), 'paths' => array());
  }
  return $data;
}

/**
 * Save data to cache.
 *
 * @param array $data
 *   The data to save.
 */
function _subdomain_field_set_cache($data) {
  cache_set('subdomain_field_mapping', $data, 'cache', CACHE_TEMPORARY);
}

/**
 * Look up a subdomain name based on path.
 *
 * @param string $path
 *   The system path.
 *
 * @return string
 *   The subdomain.
 */
function subdomain_field_get_by_path($path) {
  $result = db_select('subdomain_field_path')
    ->condition('path', $path)
    ->fields('subdomain_field_path', array('subdomain'))
    ->execute()
    ->fetchAssoc();
  return $result ? $result['subdomain'] : NULL;
}

/**
 * Look up a path on subdomain name.
 *
 * @param string $subdomain
 *   The subdomain.
 *
 * @return string
 *   The system path.
 */
function subdomain_field_get_by_subdomain($subdomain) {
  $result = db_select('subdomain_field_path')
    ->condition('subdomain', $subdomain)
    ->fields('subdomain_field_path', array('path'))
    ->execute()
    ->fetchAssoc();
  return $result ? $result['path'] : NULL;
}
