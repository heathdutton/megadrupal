<?php

/**
 * @file
 * Implementation of a the xapian search library as a drupal module.
 */

module_load_include('inc', 'xapian', 'xapian.lib');

/**
 * Implementation of hook_search_info().
 */
function xapian_search_info() {
  return array(
    'title' => t('Xapian Search'),
    'path' => 'xapian',
  );
}

/**
 * Implementation of hook_search_access().
 */
function xapian_search_access() {
  return user_access('access content');
}

/**
 * Implementation of hook_search_admin().
 */
function xapian_search_admin() {
  return xapian_admin_form();
}

/**
 * Implementation of hook_search_execute().
 */
function xapian_search_execute($keys = NULL, $conditions = NULL) {
  return xapian_do_search($keys, $conditions);
}

/**
 * Implementation of hook_search_reset().
 */
function xapian_search_reset() {
  xapian_clear_index();
}

/**
 * Implementation of hook_search_status().
 */
function xapian_search_status() {
  return xapian_index_status();
}

/**
 * Retrieve information about the actual index status.
 */
function xapian_index_status() {
  $remaining = db_query('SELECT COUNT(xid) FROM {xapian_index_queue}')
    ->fetchField();
  $total = db_query('SELECT COUNT(nid) FROM {node} WHERE status = :status', array(':status' => 1))
    ->fetchField();

  return array('remaining' => $remaining, 'total' => $total);
}


/**
 * Generate the xapian admin form.
 */
function xapian_admin_form() {
  $form = array();
  $form['#cache'] = FALSE;

  $database_type = variable_get('xapian_database_type', XAPIAN_LOCAL);

  // Create an all-encompassing Xapian fieldset
  $form['xapian'] = array(
    '#type' => 'fieldset',
    '#collapsed' => FALSE,
    '#collapsible' => TRUE,
    '#weight' => 0,
    '#title' => t('Xapian search settings')
  );

  // Create a database fieldset
  $form['xapian']['database'] = array(
    '#type' => 'fieldset',
    '#collapsed' => ($database_type ? FALSE : TRUE),
    '#collapsible' => TRUE,
    '#title' => t('Database')
  );

  // Database type
  $form['xapian']['database']['xapian_database_type'] = array(
    '#type' => 'radios',
    '#title' => t('Type'),
    '#default_value' => $database_type ? $database_type : XAPIAN_LOCAL,
    '#options' => array(
      XAPIAN_LOCAL => t('Local'),
      XAPIAN_REMOTE => t('Remote')),
  );

  // local database settings
  $form['xapian']['database']['local_database'] = array(
    '#type' => 'fieldset',
    '#title' => t('Local database options'),
    '#collapsible' => TRUE,
    '#collapsed' => ($database_type != XAPIAN_LOCAL)
  );
  $form['xapian']['database']['local_database']['xapian_database_path'] = array(
    '#type' => 'textfield',
    '#title' => t('Path to database'),
    '#default_value' => variable_get('xapian_database_path', file_default_scheme() . '://xapian_database'),
    '#required' => ($database_type == XAPIAN_LOCAL),
    '#description' => t('Directory where your local Xapian database will be created.  Specify a directory writable by your web server process.'),
  );

  // Remote database settings
  $form['xapian']['database']['remote_database'] = array(
    '#type' => 'fieldset',
    '#title' => t('Remote database options'),
    '#collapsible' => TRUE,
    '#collapsed' => ($database_type != XAPIAN_REMOTE),
  );
  $form['xapian']['database']['remote_database']['xapian_database_hostname'] = array(
    '#type' => 'textfield',
    '#title' => t('Database server'),
    '#default_value' => variable_get('xapian_database_hostname', ''),
    '#required' => ($database_type == XAPIAN_REMOTE),
    '#description' => t('IP address or host name of remote server running xapian-tcpsrv.'),
  );
  $form['xapian']['database']['remote_database']['xapian_database_port'] = array(
    '#type' => 'textfield',
    '#title' => t('Database port'),
    '#default_value' => variable_get('xapian_database_port', '6431'),
    '#required' => ($database_type == XAPIAN_REMOTE),
    '#validate' => array('_xapian_validate_port' => array('xapian_database_port')),
    '#description' => t('Remote port that xapian-tcpsrv is listening on.'),
  );

  // Optional write-only database (see http://drupal.org/node/282855)
  $form['xapian']['database']['writeonly'] = array(
    '#type' => 'fieldset',
    '#title' => t('Optional write-only database settings'),
    '#collapsible' => TRUE,
    '#collapsed' => variable_get('xapian_write_database_hostname', '') && variable_get('xapian_write_database_port', '') ? FALSE : TRUE,
    '#description' => t('Leave these optional settings blank to use the above settings for both read and write database access.  If you would like to send write queries to a different database than read queries, configure the remote write-only database settings below.  Using a separate remote write-only server allows you to efficiently scale your search solution across multiple web servers, and avoids potential issues with lock contention.'),
  );

  $form['xapian']['database']['writeonly']['xapian_write_database_hostname'] = array(
    '#type' => 'textfield',
    '#title' => t('Write-only database server'),
    '#default_value' => variable_get('xapian_write_database_hostname', ''),
    '#description' => t('IP address or host name of remote server running %writable.', array('%writable' => t('xapian-tcpsrv --writable'))),
  );
  $form['xapian']['database']['writeonly']['xapian_write_database_port'] = array(
    '#type' => 'textfield',
    '#title' => t('Write-only database port'),
    '#default_value' => variable_get('xapian_write_database_port', ''),
    '#validate' => array('_xapian_validate_port' => array('xapian_write_database_port')),
    '#description' => t('Remote port that %writable is listening on.', array('%writable' => t('xapian-tcpsrv --writable'))),
  );

  // indexing settings
  $form['xapian']['performance'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('Performance')
  );
  $form['xapian']['performance']['xapian_index_immediately'] = array(
    '#type' => 'checkbox',
    '#title' => t('Index immediately'),
    '#default_value' => variable_get('xapian_index_immediately', TRUE),
    '#description' => t('Enable this option to index content immediately as it is created and updated.  Disable this option to delay indexing until cron runs.  Your should disable this option on larger websites.'),
  );

  // Display settings
  $form['xapian']['display'] = array(
    '#type'  => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('Display')
  );
  $form['xapian']['display']['xapian_node_count_type'] = array(
    '#type' => 'radios',
    '#title' => t('Result count'),
    '#description' => t('This setting determines the value that xapian returns for the result count returned from queries (used for number of pages in pagers, etc.)'),
    '#default_value' => variable_get('xapian_node_count_type', 0),
    '#options' => array(
      XAPIAN_MATCHES_BEST_ESTIMATE => t('Best estimate'),
      XAPIAN_MATCHES_LOWER_BOUND => t('Lower bound'),
      XAPIAN_MATCHES_UPPER_BOUND => t('Upper bound'),
    ),
  );

  // Logging options
  $form['xapian']['diagnostic'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('Logging')
  );
  $form['xapian']['diagnostic']['xapian_log_queries'] = array(
    '#type' => 'checkbox',
    '#title' => t('Log searches'),
    '#description' => t('Log search queries and time taken for search to the watchdog log.'),
    '#default_value' => variable_get('xapian_log_queries', FALSE),
  );

  // Node Type Settings
  $form['xapian']['node_types'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('Excluded node types')
  );
  $form['xapian']['node_types']['markup'] = array(
    '#value' => t("<p>Select the node types to <strong>EXCLUDE</strong> from Xapian's indexing</p>"),
  );
  $types = node_type_get_types();
  foreach ($types as $key => $type) {
    $options[$key] = $type->name;
  }
  $form['xapian']['node_types']['xapian_excluded_nodes'] = array(
    '#type' => 'select',
    '#title' => t('Exclude indexing on'),
    '#options' => $options,
    '#default_value' => variable_get('xapian_excluded_nodes', array()),
    '#multiple' => TRUE,
  );

  // Algorithms
  $form['xapian']['algorithms'] = array(
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#title' => t('Algorithms')
  );
  $languages = _xapian_languages();
  // See http://xapian.org/docs/stemming.html
  $form['xapian']['algorithms']['xapian_stem_language'] = array(
    '#type' => 'select',
    '#title' => t('Stemming language'),
    '#options' => $languages,
    '#default_value' => variable_get('xapian_stem_language', 'english'),
    '#description' => t('Select the language that Xapian should use when deriving the stem of each word when building an index.'),
  );

  $form['#submit'][] = 'xapian_admin_form_submit';

  return $form;
}

/**
 * Process xapian_admin_form form submissions.
 */
function xapian_admin_form_submit($form, &$form_state) {
  if ($form_state['values']['xapian_excluded_nodes'] != variable_get('xapian_excluded_nodes', array())) {
    drupal_set_message(t('You should reindex your entire site after changing the types'));
  }
}

/**
 * Special port validation routing
 *
 * @param array $field
 * @param string $field_name
 */
function _xapian_validate_port($field, $field_name) {
  if (!is_numeric($field['#value']) || (int)$field['#value'] < 1 || (int)$field['#value'] > 65535) {
    form_set_error($field_name, t('%value is not a valid port.', array('%value' => $field['#value'])));
  }
}

/**
 * Perform the xapian search.
 *
 * @param unknown_type $keys
 * @return array
 */
function xapian_do_search($keys, $conditions) {
  global $pager_total;
  global $pager_page_array;

  if (!empty($_REQUEST['page'])) {
    $page = $_REQUEST['page'];
  }
  else {
    $page = 0;
  }

  if (empty($keys)) {
    $keywords = search_get_keys();
  }
  else {
    $keywords = $keys;
  }

  $start = variable_get('xapian_search_results_per_page', 10) * $page;
  $length = variable_get('xapian_search_results_per_page', 10);

  $terms = array();
  $types = array();
  $extra = array();
  if (is_array($conditions)) {
    foreach ($conditions as $condition) {
      // If its a number, its a taxonomy term
      if (is_numeric($condition)) {
        $term = taxonomy_get_term($condition);
        if ($term) {
          $terms[] = XAPIAN_TERM_PREFIX_TAXTERM . drupal_strtolower($term->name);
        }
      }
      else {
        // Otherwise its a node type.
        $types[] = XAPIAN_TERM_PREFIX_NODETYPE . $condition;
      }
    }
    $extra = array($terms, $types);
  }

  list($count, $results) = xapian_query($keywords, $start, $length, $extra);

  $pager_total[0] = ceil($count / $length);
  $pager_page_array[0] = $page;

  return $results;
}

/**
 * Implementation of hook_node_revision_delete().
 */
function xapian_node_revision_delete($node) {
  xapian_index_node($node);
}

/**
 * Implementation of hook_node_insert().
 */
function xapian_node_insert($node) {
  xapian_index_node($node);
}

/**
 * Implementation of hook_node_update().
 */
function xapian_node_update($node) {
  xapian_index_node($node);
}

/**
 * Implementation of hook_node_delete().
 */
function xapian_node_delete($node) {
  xapian_remove_node_from_index($node);
}

/**
 * Implementation of hook_comment_insert().
 */
function xapian_comment_insert($comment) {
  $node = node_load($comment->nid);
  xapian_index_node($node);
}

/**
 * Implementation of hook_comment_update().
 */
function xapian_comment_update($comment) {
  $node = node_load($comment->nid);
  xapian_index_node($node);
}

/**
 * Implementation of hook_comment_delete().
 */
function xapian_comment_delete($comment) {
  $node = node_load($comment->nid);
  xapian_index_node($node);
}

/**
 * Implementation of hook_comment_publish().
 */
function xapian_comment_publish($comment) {
  $node = node_load($comment->nid);
  xapian_index_node($node);
}

/**
 * Implementation of hook_comment_unpublish().
 */
function xapian_comment_unpublish($comment) {
  $node = node_load($comment->nid);
  xapian_index_node($node);
}

/**
 * Queue a node for indexing
 *
 * @param object $node
 */
function _xapian_queue_index($node) {
  $xid = db_query('SELECT xid FROM {xapian_index_queue} WHERE nid = :nid', array(':nid' => $node->nid))
    ->fetchField();
  // Only queue a node if it's not already queued.
  if ($xid === FALSE) {
    db_insert('xapian_index_queue')
      ->fields(array(
        'nid' => $node->nid,
        'added' => REQUEST_TIME,
      ))
      ->execute();
  }
}

/**
 * Depending on whether queuing is enabled, either immediately index a node, or
 * queue it for later indexing.
 *
 * @param object $node
 */
function xapian_index_node(&$node) {
  $exclusions = array_values(variable_get('xapian_excluded_nodes', array()));
  if (in_array($node->type, $exclusions)) {
    xapian_remove_node_from_index($node);
    return;
  }
  if (variable_get('xapian_index_immediately', TRUE)) {
    if (_xapian_index_node($node)) {
      // Flush the changes to disk.
      _xapian_init_database(XAPIAN_WRITABLE, XAPIAN_FLUSH);
      db_delete('xapian_index_queue')
        ->condition('nid', $node->nid)
        ->execute();
    }
    else {
      watchdog('xapian', 'Failed to immediately index node with nid %nid, queueing to try again later.', array('%nid' => $node->nid));
      // Failed to update Xapian database, queue item to index later.
      _xapian_queue_index($node);
    }
  }
  else {
    _xapian_queue_index($node);
  }
}

/**
 * Process queued nodes for indexing
 */
function xapian_index_queued_nodes() {
  $indexed = 0;
  $failed = 0;
  $delete = FALSE;
  $start_time = microtime(TRUE);

  // Check to see if some indexed nodes failed to be flushed to disk last time
  // we tried indexing nodes.
  $not_flushed = db_query('SELECT COUNT(xid) FROM {xapian_index_queue} WHERE status > :status', array(':status' => 0))
    ->fetchField();
  $query = db_select('xapian_index_queue', 'x');
  $query->addField('x', 'nid');
  if ($not_flushed > 1) {
    // Re-index content that wasn't flushed to disk last time, minus the node
    // which failed last time.
    $limit = variable_get('search_cron_limit', 100);
    // FIXME Make these lines more readable.
    $error = $not_flushed - 1;
    $limit = $limit > $error ? $error : $limit;
    $query->condition('x.status', 0, '>')
      ->orderBy('x.indexed', 'ASC')
      ->range(0, $limit);
    $result = $query->execute();
  }
  elseif ($not_flushed == 1) {
    // Re-index a node that previously failed to index, removing it from the
    // queue now as it may not be indexable, such as a php node calling
    // drupal_goto()...
    $delete = db_query_range('SELECT nid FROM {xapian_index_queue} WHERE status > :status', 0, 1, array(':status' => 0))
      ->fetchField();
    $limit = 1;
    $query->condition('x.nid', $delete)
      ->range(0, $limit);
    $result = $query->execute();
  }
  else {
    $limit = (int)variable_get('search_cron_limit', 100);
    // TODO Convert this query to dbtng if possible.
    $result = db_query_range('SELECT nid FROM {xapian_index_queue} ORDER BY COALESCE(priority, 0) DESC, added ASC', 0, $limit);
  }

  if (!$result) {
    watchdog('xapian', 'Unable to read index queue.');
    return;
  }
  elseif ($delete) {
    db_delete('xapian_index_queue')
      ->condition('nid', $delete)
      ->execute();
  }

  $exclusions = array_values(variable_get('xapian_excluded_nodes', array()));
  foreach ($result as $node) {
    $new_node = node_load($node->nid, NULL, TRUE);
    if ($new_node) {
      if (in_array($new_node->type, $exclusions)) {
        // None indexable a node, log and clear it from the queue
        xapian_remove_node_from_index($new_node);
        db_delete('xapian_index_queue')
          ->condition('nid', $node->nid)
          ->execute();
        $failed++;
      }
      else {
        // Found a node, index it
        if (_xapian_index_node($new_node)) {
          $indexed++;
        }
        else {
          $failed++;
        }
      }
    }
    else {
      // Not a node, log an error, but may as well clear it from the queue
      watchdog('xapian', 'Could not load node with id %node for indexing', array('%node' => $node->nid));
      db_delete('xapian_index_queue')
        ->condition('nid', $node->nid)
        ->execute();
      $failed++;
    }
  }
  // Flush the changes to disk.
  _xapian_init_database(XAPIAN_WRITABLE, XAPIAN_FLUSH);
  $status = db_query('SELECT MAX(status) FROM {xapian_index_queue}')->fetchField();
  if ($status) {
    db_delete('xapian_index_queue')
      ->condition('status', $status)
      ->execute();
  }

  if (variable_get('xapian_log_queries', FALSE)) {
    $time_taken = (microtime(TRUE) - $start_time) * 1000;
    watchdog('xapian', '<p>Indexed %indexed nodes successfully, %failed failed in: %time ms</p>',
      array('%indexed' => $indexed, '%failed' => $failed, '%time' => $time_taken));
  }
}

/**
 * Implementation of hook_update_index().
 *
 * Index all queued content.
 */
function xapian_update_index() {
  // If one or more ids exist in the index queue, index them.
  $xid = db_query_range('SELECT xid FROM {xapian_index_queue}', 0, 1)->fetchField();
  if ($xid) {
    xapian_index_queued_nodes();
  }
}

/**
 * Confirm recreation of search index.
 */
function xapian_clear_index() {
  db_truncate('xapian_index_queue')->execute();
  $sel_query = db_select('node', 'n');
  $sel_query->addField('n', 'nid');
  $sel_query->addExpression(':time', 'added', array(':time' => REQUEST_TIME));
  db_insert('xapian_index_queue')
    ->fields(array('nid', 'added'))
    ->from($sel_query)
    ->execute();
}

/**
 * Default node index function
 * Indexes title, body, terms in the node (as text), and the taxonomy terms
 * as well.
 *
 * @param object $node
 * @return array
 */
function node_xapian_index($node) {
  $terms = array();

  // Load and render the node.
  $node = node_load($node->nid);
  $build = node_view($node, 'search_index');
  unset($build['#theme']);
  $node->rendered = drupal_render($build);

  $terms[] = array('type' => 'text', 'data' => strip_tags($node->title), 'weight' => 5);
  if (drupal_strlen($node->rendered)) {
    // avoid joining words separated only by html tags
    $text = str_replace(array('<', '>'), array(' <', '> '), $node->rendered);
    // filter the text to index
    $text = strip_tags($text);
    $text = trim($text);
    $terms[] = array('type' => 'text', 'data' => $text, 'weight' => 1);
  }

  // Fetch extra data normally not visible
  $extra = module_invoke_all('node_update_index', $node);
  foreach ($extra as $t) {
    $terms[] = array('type' => 'text', 'data' => $t, 'weight' => 1);
  }

  return $terms;
}
