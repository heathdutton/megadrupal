<?php

module_load_include('inc', 'giantbomb', 'includes/giantbomb.entity');
module_load_include('inc', 'giantbomb', 'includes/giantbomb.mapping');

/** 
 * Requests name of field which stores Giant Bomb endpoint.
 *
 * @see giantbomb_field_name()
 */
const GIANTBOMB_FIELD_ENDPOINT = 'GIANTBOMB_ENDPOINT';

/** 
 * Requests name of field which stores Giant Bomb object type.
 *
 * @see giantbomb_field_name()
 */
const GIANTBOMB_FIELD_TYPE = 'GIANTBOMB_TYPE';

/** 
 * Requests name of field which stores Giant Bomb object ID.
 *
 * @see giantbomb_field_name()
 */
const GIANTBOMB_FIELD_ID = 'GIANTBOMB_ID';

/** 
 * Requests name of field which stores a date which allows the module to update
 * the entity. This prevents excessive updates to an object.
 *
 * @see giantbomb_field_name()
 */
const GIANTBOMB_FIELD_NEXT_UPDATE = 'GIANTBOMB_NEXT_UPDATE';

const GIANTBOMB_FIELD_AUTO_NAME_ENDPOINT = 'giantbomb_endpoint';

const GIANTBOMB_FIELD_AUTO_NAME_TYPE = 'giantbomb_type';

const GIANTBOMB_FIELD_AUTO_NAME_ID = 'giantbomb_object_id';

const GIANTBOMB_FIELD_AUTO_NAME_NEXT_UPDATE = 'giantbomb_object_id';

/**
 * Implements hook_menu().
 */
function giantbomb_menu() {
  $items = array();

  $items['admin/config/services/giantbomb/search'] = array(
    'title' => 'Search',
    'description' => 'Giant Bomb',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('giantbomb_search_form'),
    'access arguments' => array('administer giantbomb'),
    'file' => 'giantbomb.forms.inc',
    'file path' => drupal_get_path('module', 'giantbomb') . '/includes',
    'type' => MENU_LOCAL_TASK,
    'weight' => -75,
  );

  $items['admin/config/services/giantbomb/scheduler'] = array(
    'title' => 'Scheduler',
    'description' => 'Lists all scheduled jobs.',
    'page callback' => 'giantbomb_job_list_page',
    'access arguments' => array('administer giantbomb'),
    'file' => 'giantbomb.pages.inc',
    'file path' => drupal_get_path('module', 'giantbomb') . '/includes',
    'type' => MENU_LOCAL_TASK,
    'weight' => -50,
  );

  $items['admin/config/services/giantbomb/scheduler/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );

  $items['admin/config/services/giantbomb/scheduler/add'] = array(
    'title' => 'Add job',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('giantbomb_job_add_form'),
    'access arguments' => array('administer giantbomb'),
    'file' => 'giantbomb.forms.inc',
    'file path' => drupal_get_path('module', 'giantbomb') . '/includes',
    'type' => MENU_LOCAL_ACTION,
    'weight' => 25,
  );

  $items['admin/config/services/giantbomb/scheduler/job/%giantbomb_job/edit'] = array(
    'title' => 'Edit job',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('giantbomb_job_edit_form', 6),
    'access arguments' => array('administer giantbomb'),
    'file' => 'giantbomb.forms.inc',
    'file path' => drupal_get_path('module', 'giantbomb') . '/includes',
    'type' => MENU_NORMAL_ITEM,
    'weight' => 25,
  );


  $items['admin/config/services/giantbomb/scheduler/job/%giantbomb_job/delete'] = array(
    'title' => 'Delete job',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('giantbomb_job_delete_form', 6),
    'access arguments' => array('administer giantbomb'),
    'file' => 'giantbomb.forms.inc',
    'file path' => drupal_get_path('module', 'giantbomb') . '/includes',
    'type' => MENU_NORMAL_ITEM,
    'weight' => 25,
  );

  $items['admin/config/services/giantbomb/types'] = array(
    'title' => 'Types',
    'description' => 'Lists all Giant Bomb object types, with option to edit mapping.',
    'page callback' => 'giantbomb_types_list_page',
    'access arguments' => array('administer giantbomb'),
    'file' => 'giantbomb.pages.inc',
    'file path' => drupal_get_path('module', 'giantbomb') . '/includes',
    'type' => MENU_LOCAL_TASK,
    'weight' => -25,
  );

  $items['admin/config/services/giantbomb/types/reload'] = array(
    'title' => 'Reload types',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('giantbomb_type_reload_form'),
    'access arguments' => array('administer giantbomb'),
    'file' => 'giantbomb.forms.inc',
    'file path' => drupal_get_path('module', 'giantbomb') . '/includes',
    'type' => MENU_LOCAL_ACTION,
    'weight' => 25,
  );

  $items['admin/config/services/giantbomb/types/manage/%giantbomb_api_endpoint/%_giantbomb_type_menu'] = array(
    'title' => 'Object',
    'title callback' => 'giantbomb_type_title',
    'title arguments' => array(6, 7),
    'description' => 'Show information about a Giant Bomb object.',
    'load arguments' => array(6),
    'page callback' => 'giantbomb_type_page',
    'page arguments' => array(6, 7),
    'access arguments' => array('administer giantbomb'),
    'file' => 'giantbomb.pages.inc',
    'file path' => drupal_get_path('module', 'giantbomb') . '/includes',
    'type' => MENU_NORMAL_ITEM,
  );

  $items['admin/config/services/giantbomb/types/manage/%giantbomb_api_endpoint/%_giantbomb_type_menu/object'] = array(
    'title' => 'Object',
    'description' => 'Show information about a Giant Bomb object.',
    'load arguments' => array(6),
    'page callback' => 'giantbomb_type_page',
    'page arguments' => array(6, 7),
    'access arguments' => array('administer giantbomb'),
    'file' => 'giantbomb.pages.inc',
    'file path' => drupal_get_path('module', 'giantbomb') . '/includes',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items['admin/config/services/giantbomb/types/manage/%giantbomb_api_endpoint/%_giantbomb_type_menu/entity'] = array(
    'title' => 'Entity Mapping',
    'description' => 'Edit entity mapping for a Giant Bomb type.',
    'load arguments' => array(6),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('giantbomb_type_edit_entity_form', 6, 7),
    'access arguments' => array('administer giantbomb'),
    'file' => 'giantbomb.forms.inc',
    'file path' => drupal_get_path('module', 'giantbomb') . '/includes',
    'type' => MENU_LOCAL_TASK,
    'weight' => 30,
  );

  $items['admin/config/services/giantbomb/types/manage/%giantbomb_api_endpoint/%_giantbomb_type_menu/fields'] = array(
    'title' => 'Field Mapping',
    'description' => 'Edit field mapping for a Giant Bomb type.',
    'load arguments' => array(6),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('giantbomb_type_edit_fields_form', 6, 7),
    'access callback' => 'giantbomb_type_edit_fields_access',
    'access arguments' => array(6, 7),
    'file' => 'giantbomb.forms.inc',
    'file path' => drupal_get_path('module', 'giantbomb') . '/includes',
    'type' => MENU_LOCAL_TASK,
    'weight' => 40,
  );

  $items['admin/config/services/giantbomb/types/manage/%giantbomb_api_endpoint/%_giantbomb_type_menu/relationships'] = array(
    'title' => 'Relationships',
    'description' => 'Manage how relationships are created between types.',
    'load arguments' => array(6),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('giantbomb_type_edit_relationships_form', 6, 7),
    'access callback' => 'giantbomb_type_edit_fields_access',
    'access arguments' => array(6, 7),
    'file' => 'giantbomb.forms.inc',
    'file path' => drupal_get_path('module', 'giantbomb') . '/includes',
    'type' => MENU_LOCAL_TASK,
    'weight' => 40,
  );

  $items['admin/config/services/giantbomb/types/manage/%giantbomb_api_endpoint/%_giantbomb_type_menu/delete'] = array(
    'title' => 'Delete',
    'description' => 'Delete a Giant Bomb type.',
    'load arguments' => array(6),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('giantbomb_type_delete_form', 6, 7),
    'access arguments' => array('administer giantbomb'),
    'file' => 'giantbomb.forms.inc',
    'file path' => drupal_get_path('module', 'giantbomb') . '/includes',
    'type' => MENU_NORMAL_ITEM,
    'weight' => 50,
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function giantbomb_permission() {
  return array(
    'administer giantbomb' => array(
      'title' => t('Administer Giant Bomb'), 
      'description' => t('Grant permission to change Giant Bomb configuration.'),
    ),
  );
}

/**
 * Implements hook_cron().
 */
function giantbomb_cron() {
  $time = $_SERVER['REQUEST_TIME'];
  $queue_list = DrupalQueue::get('giantbomb_list');
  $queue_object = DrupalQueue::get('giantbomb_object');

  $endpoints = giantbomb_api_endpoints();
  foreach ($endpoints as $endpoint => $endpoint_info) {
    $types = giantbomb_types_all($endpoint, 'id');
    $jobs = giantbomb_jobs_all($endpoint);

    foreach ($jobs as $job) {
      if ($job->active && (empty($job->next_update) || $time > $job->next_update)) {
        if (isset($types[$job->type])) {
          $object_info = $types[$job->type];
          $request_object = array(
            'endpoint' => $endpoint,
            'object' => $object_info->object,
            'settings' => isset($job->settings['request']) ? $job->settings['request'] : array(),
          );
          $request_object['settings']['job_settings'] = (array)$job->settings;

          if ($job->resource == 'object') {
            $request_object['settings']['next_update_ignore'] = TRUE;
            $request_object['id'] = $job->object_id;
            $queue_object->createItem($request_object);
          }
          elseif ($job->resource == 'list') {
            $queue_list->createItem($request_object);
          }
        }

        $result = db_update('giantbomb_jobs')
          ->fields(array(
            'updated' => ($time),
            'next_update' => ($time + $job->update_frequency),
          ))
          ->condition('id', $job->id)
          ->execute();
      }
    }
  }
}

/**
 * Implements hook_cron_queue_info().
 */
function giantbomb_cron_queue_info() {
  $queues['giantbomb_list'] = array(
    'worker callback' => 'giantbomb_queue_list', 
    'time' => 60,
  );

  $queues['giantbomb_object'] = array(
    'worker callback' => 'giantbomb_queue_object', 
    'time' => 60,
  );

  return $queues;
}

/**
 * Implements hook_ctools_plugin_type().
 */
function giantbomb_ctools_plugin_type() {
  $plugins['giantbomb_endpoint'] = array(
  );

  return $plugins;
}

/**
 * Queue callback.
 * 
 * @param $value
 *   The custom value written to createItem($value)
 *   
 * @see hook_cron_queue_info()
 */
function giantbomb_queue_list($value) {
  giantbomb_process_job_list($value['endpoint'], $value['object'], $value['settings']);
}


/**
 * Queue callback.
 * 
 * An object will only update if the associated entity 'next update' date
 * has passed.
 * 
 * @param $value
 *   The custom value written to createItem($value)
 *   
 * @see hook_cron_queue_info()
 */
function giantbomb_queue_object($value) {
  $endpoint = $value['endpoint'];
  $object = $value['object'];
  $id = $value['id'];
  $settings = isset($value['settings']) ? $value['settings']: array();

  if (empty($value['settings']['next_update_ignore'])) {
    list($entity_type, $entity) = giantbomb_local_entity_load($endpoint, $object, $id);
  
    if ($entity) {
      $wrapper = entity_metadata_wrapper($entity_type, $entity);
  
      $field_next_update =  giantbomb_field_name($endpoint, $object, GIANTBOMB_FIELD_NEXT_UPDATE);
      if (!$field_next_update) {
        // Do not process if there is no next update field.
        return;
      }
  
      $next_update = _giantbomb_entity_metadata_property_single($wrapper->{$field_next_update[0]})->value();
      if ($next_update > time()) {
        return; 
      }
    }
  }

  giantbomb_process_job_object($endpoint, $object, $id, $settings);
}

/**
 * Get where a Giant Bomb object is stored locally.
 *
 * @param string $endpoint
 *   A Giant Bomb endpoint name.
 * @param string $object
 *   A Giant Bomb object type.
 * @param int $id
 *   A Giant Bomb object ID.
 *
 * @return array|bool
 *   array(entity_type, entity_id) or FALSE if does not exist.
 */
function giantbomb_local_entity($endpoint, $object, $id) {
  $fast = &drupal_static(__FUNCTION__, FALSE);

  // Check static cache
  if (isset($fast[$endpoint][$object][$id])) {
    return $fast[$endpoint][$object][$id];
  }
  else {
    $fast[$endpoint][$object][$id] = FALSE;
    $fast_entity = &$fast[$endpoint][$object][$id];
  }

  // Begin new lookup
  $object_info = giantbomb_type_load($endpoint, $object);

  if (empty($object_info->entity_type) || empty($object_info->bundle)) {
    return FALSE;
  }

  $entity_type = $object_info->entity_type;
  $bundle = $object_info->bundle;

  $field_endpoint = giantbomb_field_name($endpoint, $object, GIANTBOMB_FIELD_ENDPOINT);
  $field_type = giantbomb_field_name($endpoint, $object, GIANTBOMB_FIELD_TYPE);
  $field_id = giantbomb_field_name($endpoint, $object, GIANTBOMB_FIELD_ID);

  if (!$field_endpoint || !$field_type || !$field_id) {
    return FALSE;
  }

  $query = new EntityFieldQuery;
  $result = $query
    ->entityCondition('entity_type', $entity_type)
    ->entityCondition('bundle', $bundle)
    ->fieldCondition($field_endpoint[0], $field_endpoint[1], $endpoint, '=')
    ->fieldCondition($field_type[0], $field_type[1], $object, '=')
    ->fieldCondition($field_id[0], $field_id[1], $id, '=')
    ->range(0, 1)
    ->execute();

  foreach ($result as $entity_type => $entities) {
    foreach ($entities as $entity_id => $entity) {
      $fast_entity = array($entity_type, $entity_id);
      break 2;
    }
  }

  return $fast_entity;
}

/**
 * Load local Drupal entity for a Giant Bomb object.
 *
 * @param string $endpoint
 *   A Giant Bomb endpoint name.
 * @param string $object
 *   A Giant Bomb object type.
 * @param int $id
 *   A Giant Bomb object ID.
 *
 * @return object|false
 */
function giantbomb_local_entity_load($endpoint, $object, $id) {
  list($entity_type, $entity_id) = giantbomb_local_entity($endpoint, $object, $id);
  if ($entity_type && $entity_id) {
    $entity = entity_load_single($entity_type, $entity_id);
    return array($entity_type, ($entity ? $entity : FALSE));
  }
  return FALSE;
}

/**
 * Count Giant Bomb local entities.
 *
 * @param string $endpoint
 *   A Giant Bomb endpoint name.
 * @param string $object
 *   A Giant Bomb object type.
 * @param int $id
 *   A Giant Bomb object ID.
 * @param string $entity_type
 *   (optional) Refine count with entity type.
 * @param string $bundle
 *   (optional) Refine count with bundle.
 *
 * @return int|bool
 *   Number of entities of this object type, or FALSE if the value is
 *   indeterminate. In the case where endpoint or type fields have not been 
 *   mapped for a type.
 */
function giantbomb_local_entity_count($endpoint, $object, $entity_type = NULL, $bundle = NULL) {
  $field_endpoint = giantbomb_field_name($endpoint, $object, GIANTBOMB_FIELD_ENDPOINT);
  $field_type = giantbomb_field_name($endpoint, $object, GIANTBOMB_FIELD_TYPE);

  if ($field_endpoint && $field_type) {
    $query = new EntityFieldQuery;
  
    if ($entity_type) {
      $query->entityCondition('entity_type', $entity_type);
      if ($bundle) {
        $query->entityCondition('bundle', $bundle);
      }
    }

    return $query
      ->fieldCondition($field_endpoint[0], $field_endpoint[1], $endpoint, '=')
      ->fieldCondition($field_type[0], $field_type[1], $object, '=')
      ->count()
      ->execute();
  }

  return FALSE;
}

/**
 * Update {giantbomb_types} with types from endpoint.
 *
 * Return the query used against the API.
 *
 * @param string $endpoint
 *   A Giant Bomb endpoint name.
 */
function giantbomb_types_update($endpoint) {
  $query = giantbomb_api_query_types($endpoint);

  foreach ($query->results as $type) {
    $title = ucwords(str_replace('_', ' ', $type->detail_resource_name));

    $merge = db_merge('giantbomb_types')
      ->key(array('id' => $type->id))
      ->fields(array(
        'endpoint' => $endpoint,
        'title' => $title,
        'object' => $type->detail_resource_name,
        'list' => $type->list_resource_name,
      ))
      ->execute();
  }

  return $query;
}

/**
 * Loads a single type from the database, and optionally checks to ensure
 * the type is configured.
 *
 * Use only with hook_menu.
 *
 * @param string $type
 *   Source type.
 * @param string $endpoint
 *   A Giant Bomb endpoint name.
 *
 * @return object|bool
 *   A type object, or FALSE.
 */
function _giantbomb_type_menu_load($type, $endpoint) {
  $types = giantbomb_types_all($endpoint, 'object');
  return isset($types[$type]) ? $types[$type] : FALSE;
}

function _giantbomb_static_void($endpoint, $object, $id) {
  $fast = &drupal_static('giantbomb_local_entity', FALSE);
  if (isset($fast[$endpoint][$object][$id])) {
    unset($fast[$endpoint][$object][$id]);
  }
}

/**
 * hook_menu() access callback.
 */
function giantbomb_type_edit_fields_access($endpoint_definition, $type_definition) {
  if (($type_definition->entity_type || $type_definition->bundle) && user_access('administer giantbomb')) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Helper for Entity Metadata Wrappers where single valued field are 
 * structured differently to multi-valued fields.
 * 
 * If value contains multiple values, then return value of $values['column']
 *
 * @param unknown_type $value
 * @param unknown_type $column
 * 
 * $wrapper->field_next_update->value() // no end date
 * $wrapper->field_date_test->value->value() // with end date
 * $wrapper->field_date_test->value() // with end date
 */
function _giantbomb_entity_metadata_property_single(&$value, $column = 'value') {
  return is_array($value->value()) ? $value->{$column} : $value;
}