<?php

/**
 * @file instantclick.module
 */

/**
 * Implements hook_menu().
 */
function instantclick_menu() {
  $items = array();
  $items['admin/config/development/instantclick'] = array(
    'title' => 'InstantClick',
    'description' => 'Configuration for InstantClick module',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('instantclick_form'),
    'access arguments' => array('access administration pages'),
    'type' => MENU_NORMAL_ITEM,
  );
  return $items;
}

/**
 * Page callback: Instantclick settings
 *
 * @see instantclick_menu()
 */
function instantclick_form($form, &$form_state) {
  $form['instantclick_enabled'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Enable InstantClick on:'),
    '#default_value' => variable_get('instantclick_enabled', array('Administrative Pages' => 0, 'Front end pages' => 0)),
    '#options' => drupal_map_assoc(array(t('Administrative Pages'), t('Front end pages'))),
  );

  $mode_options = array('blacklist' => t('Blacklist'), 'whitelist' => t('Whitelist'));
  $form['instantclick_mode'] = array(
    '#type' => 'radios',
    '#title' => t('InstantClick Mode:'),
    '#default_value' => variable_get('instantclick_mode', 'blacklist'),
    '#options' => $mode_options,
    '#description' => t('Configure instantclick\'s mode of operation. Blacklist is the default, and means that links must be manually excluded. (The logout link is automatically excluded by this module.) In whitelist mode, links must be manually enabled.'),
  );

   $form['instantclick_blacklist'] = array(
     '#type' => 'textarea',
     '#title' => t('Blacklisted paths'),
     '#default_value' => variable_get('instantclick_blacklist', ''),
     '#description' => t("Specify pages by using their paths. Enter one path per line. The '*' character is a wildcard. Example paths are <i>blog</i> for the blog page and <i>blog/*</i>, &lt;front&gt;"),
     '#states' => array(
       'visible' => array(
         ':input[name="instantclick_mode"]' => array('value' => 'blacklist'),
       ),
     ),
  );

  $form['instantclick_whitelist'] = array(
     '#type' => 'textarea',
     '#title' => t('Whitelisted paths'),
     '#default_value' => variable_get('instantclick_whitelist', ''),
     '#description' => t("Specify pages by using their paths. Enter one path per line. The '*' character is a wildcard. Example paths are <i>blog</i> for the blog page and <i>blog/*</i>, &lt;front&gt;"),
     '#states' => array(
       'visible' => array(
         ':input[name=instantclick_mode]' => array('value' => 'whitelist'),
       ),
     ),
  );

  return system_settings_form($form);
}

/**
 * Implements hook_libraries_info().
 */
function instantclick_libraries_info() {
  $libraries['instantclick'] = array(
    'name' => 'InstantClick',
    'vendor url' => 'http://instantclick.io',
    'download url' => 'http://instantclick.io/instantclick.min.js?2.1',
    'version arguments' => array(
      'file' => 'instantclick.js',
      // Get version with regex pattern e.g. 2.8.2.
      'pattern' => '#\sInstantClick\s(\d.+){1}#',
      'lines' => 1,
      'cols' => 200,
    ),
    'files' => array(
      'js' => array(
        'instantclick.js',
      ),
    ),
    'variants' => array(
      'minified' => array(
        'files' => array(
          'js' => array(
            'instantclick.min.js',
          ),
        ),
      ),
    ),
  );
  return $libraries;
}

/**
 * Check if the InstantClick library has been loaded, and warn if missing.
 *
 * @return bool
 *   A boolean indicating the InstantClick loaded status.
 */
function instantclick_loaded() {
  if (($library = libraries_load('instantclick')) && !empty($library['loaded'])) {
    return TRUE;
  }
  else {

    // Alert the authorized user/administrator to the abscence of the library.
    drupal_set_message(t('The InstantClick Library could not be found.
                          Please check the installation instructions and the <a href="@status">Status Report</a>.',
                          array('@status' => url('admin/reports/status'))), 'warning');
  }
}

/**
 * Implements hook_page_alter().
 */
function instantclick_page_alter(&$page) {
  $current_path = current_path();
  // Load the primary library as defined with hook_libraries_info above.
  // if (instantclick_loaded() && path_is_admin($current_path)) {
  $instantclick_enabled = variable_get('instantclick_enabled', array('Administrative Pages' => 0, 'Front end pages' => 0));
  if (path_is_admin($current_path)) {
    if (!$instantclick_enabled['Administrative Pages']) {
      return;
    }
  }
  else {
    if (!$instantclick_enabled['Front end pages']) {
      return;
    }
  }

  // We're still enabled, load up the js.
  if (instantclick_loaded()) {
    $settings = array(
      'instantClickMode' => variable_get('instantclick_mode', 'blacklist'),
    );
    drupal_add_js(array('instantClickConfig' => $settings), 'setting');
    drupal_add_js(drupal_get_path('module', 'instantclick') . '/instantclick.js');
  }

}

/**
 * Implements hook_theme_registry_alter()
 *   Override the theme_link function.
 *
 * @param $theme_registry
 */
function instantclick_theme_registry_alter(&$theme_registry) {
  if (!empty($theme_registry['link'])) {
    $theme_registry['link']['function'] = 'instantclick_theme_link';
  }
}

/**
 * Override of the theme_link() function.
 *   Override theme_link to blacklist links as needed.
 *
 * @param $variables
 *
 * @returnÂ·
 */
function instantclick_theme_link($variables) {
  $instantclick_mode = variable_get('instantclick_mode', 'blacklist');

  switch ($instantclick_mode) {
    case 'blacklist':

      // Load blacklisted link configuration.
      $blacklist = variable_get('instantclick_blacklist', '');

      // Add the logout link to the list.
      $blacklist .= "\r\nuser/logout";

      // Blacklist configured paths.
      if (drupal_match_path($variables['path'], $blacklist)) {
        $variables['options']['attributes']['data-no-instant'] = '';
      }

      if (path_is_admin(current_path())) {
        if (!path_is_admin($variables['path'])) {
          $variables['options']['attributes']['data-no-instant'] = '';
        }
      } else {
        if (path_is_admin($variables['path'])) {
          $variables['options']['attributes']['data-no-instant'] = '';
        }
      }
      break;
    case 'whitelist':

      // Load whitelisted link configuration.
      $whitelist = variable_get('instantclick_whitelist', '');

      // Whitelist configured paths.
      if (drupal_match_path($variables['path'], $whitelist)) {
        $variables['options']['attributes']['data-instant'] = '';
      }
      break;
  }

  return '<a href="' . check_plain(url($variables['path'], $variables['options'])) . '"' . drupal_attributes($variables['options']['attributes']) . '>' . ($variables['options']['html'] ? $variables['text'] : check_plain($variables['text'])) . '</a>';
}

/**
 * Implements hook_process().
 *
 * Store information about the CSS files needed on the current page as a Drupal
 * setting so we have access to it in JS.
 */
function instantclick_process(&$variables, $hook) {
  global $instantclick_css_info;

  if ($hook == 'html') {

    // If CSS is not aggregated, use the data we have in the variables array.
    if (!variable_get('preprocess_css', FALSE)) {
      $instantclick_css_info = $variables['css'];
      foreach ($instantclick_css_info as $key => $info) {
        $instantclick_css_info[$key]['data'] = '/' . $info['data'];
      }
    }

    // Get information about javascript files needed for the current page.
    // We re-use some of the code in drupal_get_js() to re-create the
    // proper file URLs since that information is not available to us
    // in a structured format.
    $default_query_string = variable_get('css_js_query_string', '0');
    $js_version_string = variable_get('drupal_js_version_query_string', 'v=');
    $js = drupal_add_js();
    foreach ($js as $idx => $item) {
      switch ($item['type']) {
        case 'file':
          $query_string = empty($item['version']) ? $default_query_string : $js_version_string . $item['version'];
          $query_string_separator = (strpos($item['data'], '?') !== FALSE) ? '&' : '?';
          $js[$idx]['src'] = file_create_url($item['data']) . $query_string_separator . ($item['cache'] ? $query_string : REQUEST_TIME);
          break;
        case 'inline':
          $js[$idx]['script'] = $item['data'];
          break;
        case 'setting':
          $js[$idx]['script'] = 'jQuery.extend(Drupal.settings, ' . drupal_json_encode(drupal_array_merge_deep_array($item['data'])) . ');';
          break;
      }
    }

    // Delete the previous setting.
    $variables['page_bottom'] .= '<script type="text/javascript">' .
      'delete Drupal.settings.instantClick;'
      . '</script>';

    // Add our information as a Drupal setting variable.
    $variables['page_bottom'] .= '<script type="text/javascript">' .
      'jQuery.extend(Drupal.settings, ' . drupal_json_encode(array('instantClickInfo' => array('css' => $instantclick_css_info, 'js' => $js))) . ');'
      . '</script>';
  }
}

/**
 * Implements hook_element_info_alter.
 *
 * Override drupal_pre_render_styles to get data about aggregated CSS files.
 */
function instantclick_element_info_alter(&$type) {
  if (variable_get('preprocess_css', FALSE)) {
    $type['styles']['#pre_render'] = array('instantclick_pre_render_styles');
  }
}

/**
 * Overridden version of drupal_pre_render_styles().
 */
function instantclick_pre_render_styles($elements) {
  global $instantclick_css_info;

  // Render styles using the default function.
  $elements = drupal_pre_render_styles($elements);

  // Gather information about which aggregated css files are required on this page.
  $instantclick_css_info = array();
  foreach ($elements as $key => $element) {
    if (is_numeric($key)) {
      $instantclick_css_info[$element['#attributes']['href']] = array(
        'data' => $element['#attributes']['href'],
        'media' => $element['#attributes']['media'],
        'browsers' => $element['#browsers'],
        'type' => 'file',
      );
    }
  }

  return $elements;
}
