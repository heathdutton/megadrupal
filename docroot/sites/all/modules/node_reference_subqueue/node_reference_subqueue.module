<?php
/**
 * @file
 * Node Reference Subqueue.
 */

/**
 * Define our own queue type, using hook_nodequeue_info().
 */
function node_reference_subqueue_nodequeue_info() {
  return array(
    'node_reference_subqueue' => array(
      'title' => t('Node Reference Subqueue'),
      'description' => t('Each particular grouping of Node Reference from the selected content types have their own unique subqueue. You can place nodes into any of these subqueues based on which node reference that node has been tagged with.'),
    ),
  );
}

/**
 * Implements hook_help().
 */
function node_reference_subqueue_help($path, $arg = array()) {
  $output = '';
  switch ($path) {
    case 'admin/help#node_reference_subqueue':
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('This module is an add-on of the Nodequeue module so this is mandatory to install Nodequeue module before running this module. By using this module, you can create a node reference sub-queue from the selected content types to have a unique sub-queue. You can place nodes into any of these sub-queues based on which node reference that node has been tagged with.') . '</p>';
      $output .= '<h3>' . t('Uses') . '</h3>';
      $output .= '<dl>';
      $output .= '<dt>' . t('Creating individual subqueues') . '</dt>';
      $output .= '<dd>' . t('From the Nodequeue interface (admin/structure/nodequeue/add/node_reference_subqueue), select a node reference field, define queue size and other values then select respective content type(s )to create a node reference queue.') . '</dd>';
      $output .= '<dd>' . t('On node create/update, it creates a sub queue for each selected node reference item under respective node reference queue created above.') . '</dd>';
      $output .= '<dt>' . t('Sorting the nodes') . '</dt>';
      $output .= '<dd>' . t('You can sort all nodes tagged by a node reference item in their respective sub queue which is managed through Nodequeue default interface.') . '</dd>';
      $output .= '</dl>';
      return $output;

  }
}

/**
 * Define hook_nodequeue_form() to add/edit node_reference_subqueue.
 */
function node_reference_subqueue_nodequeue_form($queue, &$form) {
  // Load data about node_reference fields.
  $options = array();
  $fields = field_info_fields();
  foreach ($fields as $field_name => $field) {
    if ($field['type'] == 'node_reference') {
      $options[$field_name] = t('Field %field-name', array('%field-name' => $field_name));
    }
  }

  if (empty($options)) {
    drupal_set_message(t('Please create atleast one Node Reference Field.'), 'error');
  }

  $form['placeholder']['node_ref_fields'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Node Reference fields'),
    '#description' => t('Please select which Node Reference Subqueue to use; each unique combination of terms from all of these fields will have a subqueue.'),
    '#options' => $options,
  );

  // Fields can be selected just when creating new node reference smartqueue.
  // Disable it after that.
  if (!empty($queue->qid)) {
    $form['placeholder']['node_ref_fields']['#disabled'] = TRUE;
    $form['placeholder']['node_ref_fields']['#default_value'] = explode('-', $queue->reference);
  }
}

/**
 * Implements hook_form_validate().
 */
function node_reference_subqueue_nodequeue_form_validate($queue, &$form_state, &$form) {
  if (!isset($queue->qid)) {
    $field_names = array_keys(array_filter($form_state['values']['node_ref_fields']));
    if (empty($field_names)) {
      form_error($form['placeholder']['node_ref_fields'], t('You must select at least one Node Reference field.'));
    }

    // Convert this to our reference.
    form_set_value($form['reference'], implode('-', $field_names), $form_state);
  }
}

/**
 * Implements hook_nodequeue_subqueues().
 *
 * @see node_reference_subqueue_build_string()
 * @see nodequeue_load_subqueues_by_queue()
 * @see node_reference_subqueue_nodequeue_subqueue_title()
 *
 * Returns list of references for subqueues that can host a given node.
 */
function node_reference_subqueue_nodequeue_subqueues(&$queue, $node) {

  $field_names = array();
  // Check if at least one supported field exists in node and load
  // selected nids.
  foreach (explode('-', $queue->reference) as $field_name) {
    // Save nids.
    if ($field_values = field_get_items('node', $node, $field_name)) {
      $field_names[$field_name] = array();
      foreach ($field_values as $field_value) {
        $field_names[$field_name][] = $field_value['nid'];
      }
    }
  }

  // Build reference strings for all subqueues.
  $references = node_reference_subqueue_build_string(array_filter($field_names));

  // We're returning an array of references for efficiency, but we also have
  // to check to see if the references we've generated exist. If they don't,
  // we have to create them.
  $exists = array();
  $subqueues = nodequeue_load_subqueues_by_reference(array($queue->qid => $references));

  foreach ($subqueues as $subqueue) {
    $exists[$subqueue->reference] = TRUE;
  }

  // Original subqueues.
  $pre_subqueue_reference = array();
  $pre_subqueues = nodequeue_load_subqueues_by_queue($queue->qid);
  if (!empty($pre_subqueues)) {
    foreach ($pre_subqueues as $pre_subqueue) {
      $pre_subqueue_reference[$pre_subqueue->reference] = $pre_subqueue->sqid;
    }
  }

  // Create subqueues if needed.
  if ($references) {
    foreach ($references as $reference) {
      if (empty($exists[$reference])) {
        nodequeue_add_subqueue($queue, node_reference_subqueue_nodequeue_subqueue_title($reference), $reference);
      }

      if (isset($pre_subqueue_reference[$reference])) {
        unset($pre_subqueue_reference[$reference]);
      }
    }
  }

  // Delete unreferenced subqueues from list.
  if (!empty($pre_subqueue_reference)) {
    foreach ($pre_subqueue_reference as $pre_sqid) {
      // nodequeue_remove_subqueue($pre_sqid);
      db_delete('nodequeue_nodes')->condition('nid', $node->nid)->condition('sqid', $pre_sqid)->execute();
    }
  }
  return $references;
}

/**
 * Form title for a new node reference subqueue.
 *
 * @param string $reference
 *   Subqueue reference string(nids imploded with '-').
 */
function node_reference_subqueue_nodequeue_subqueue_title($reference) {
  $nids = explode('-', $reference);
  if (count($nids) > 0) {
    foreach ($nids as $nid) {
      // If node exists.
      if ($nid) {
        $ref_node = db_query("SELECT node.title FROM {node} WHERE nid = :nid AND node.status = :status", array(":nid" => $nid, ":status" => 1))->fetchField();
        $titles[$nid] = $ref_node;
      }
    }

    // Create name using names of all node names. This could be
    // done better, but is OK for now.
    return implode('-', $titles);
  }
}

/**
 * Implements hook_node_update().
 *
 * Updates subqueue title if node title changes.
 */
function node_reference_subqueue_node_update($node) {
  // Find subqueues that contain this node.
  $result = db_query("SELECT nq.reference AS reference, sq.reference AS sqref, sq.sqid FROM {nodequeue_queue} nq INNER JOIN {nodequeue_subqueue} sq ON nq.qid = sq.qid WHERE nq.owner = 'node_reference_subqueue' AND (sq.reference = :nid)", array(':nid' => $node->nid))->fetchAll();

  foreach ($result as $row) {
    // Note that $row already contains the needed $row->reference.
    $title = node_reference_subqueue_nodequeue_subqueue_title($row->sqref);
    nodequeue_subqueue_update_title($row->sqid, $title);
  }
}

/**
 * Implements hook_node_delete().
 *
 * Deletes subqueue if node is removed
 *
 * @see nodequeue_remove_subqueue()
 */
function node_reference_subqueue_node_delete($node) {
  // Find subqueues that contain this node.
  $args = array(
    ':reference1' => $node->nid,
    ':reference2' => '%-' . $node->nid,
    ':reference3' => $node->nid . '-%',
    ':reference4' => '%-' . $node->nid . '-%',
  );
  $result = db_query("SELECT sq.sqid FROM {nodequeue_subqueue} sq INNER JOIN {nodequeue_queue} nq ON sq.qid = nq.qid WHERE nq.owner = 'node_reference_subqueue' AND (sq.reference = :reference1 OR sq.reference LIKE :reference2 OR sq.reference LIKE :reference3 OR sq.reference LIKE :reference4)", $args)->fetchAll();

  foreach ($result as $row) {
    nodequeue_remove_subqueue($row->sqid);
  }
}

/**
 * Build an array of strings representing all possible term combinations.
 *
 * @return array
 *   Shift an element off the beginning of array
 */
function node_reference_subqueue_build_string($arrays) {
  $array = array_shift($arrays);
  if (empty($arrays)) {
    return $array;
  }
}

/**
 * Autocomplete callback.
 *
 * @param string $queue
 *   The queue object that is the parent of this subqueue.
 * @param object $subqueue
 *   Subqueue object.
 * @param string $string
 *     A string that matches.
 *
 * @see nodequeue_get_content_id()
 *
 * @return array
 *   An array or string will return.
 */
function node_reference_subqueue_nodequeue_autocomplete($queue, $subqueue, $string, $where, $where_args) {
  global $user;

  $matches = array();
  if (empty($string)) {
    return $matches;
  }
  $queue_reference = $queue->reference;
  // Collect reference field name.This can be a term reference
  // or node reference field.
  foreach (explode('-', $queue_reference) as $field_name) {
    // Crete table name.
    $join_table = 'field_data_' . $field_name;

    // Check reference field is node/term type,
    // then set its table field name accordingly.
    $ref_field_name = $field_name . '_nid';

    $query = db_select('node', 'n');
    // Added left join for the reference field so that only related
    // node will populate in auto select.
    if (!empty($field_name)) {
      $query->leftjoin($join_table, 'ref_table', 'n.nid = ref_table.entity_id');
    }
    // For duplicate records.
    $query->leftjoin('nodequeue_nodes', 'nqn', 'n.nid = nqn.nid');

    $query->addTag('node_access')
            ->fields('n', array('nid', 'tnid', 'title'))
            ->range(0, variable_get('nodequeue_autocomplete_limit', 10));

    if (!empty($queue->types)) {
      $query->condition('n.type', $queue->types, 'IN');
    }
    // If reference id i.e term id or node id exists then
    // add this in where clause.
    $reference_id = $subqueue->reference;
    if (!empty($subqueue->reference) && !empty($ref_field_name)) {
      $query->condition('ref_table.' . $ref_field_name, $reference_id);
    }

    $where_args = array();
    if (!user_access('administer nodes', $user)) {
      $query->condition(db_or()->condition('n.status', 1)->condition('n.uid', $user->uid));
    }

    // Run a match to see if they're specifying by nid.
    $preg_matches = array();
    $match = preg_match('/\[nid: (\d+)\]/', $string, $preg_matches);
    if (!$match) {
      $match = preg_match('/^nid: (\d+)/', $string, $preg_matches);
    }

    if ($match) {
      // If it found a nid via specification,
      // reduce our resultset to just that nid.
      $query->condition('n.nid', $preg_matches[1]);
    }
    else {
      // Build the constant parts of the query.
      $query->where('LOWER(n.title) LIKE LOWER(:string)', array(':string' => '%' . db_like($string) . '%'));
    }

    $query->isNull('nqn.sqid');
    $query->addTag('i18n_select');
    $result = $query->execute();

    foreach ($result as $node) {
      $id = nodequeue_get_content_id($queue, $node);
      $matches[$node->nid] = check_plain($node->title) . " [nid: $id]";
    }
  }

  return $matches;
}
