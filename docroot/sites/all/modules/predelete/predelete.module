<?php
/**
 * @file
 * This module hooks into the drupal system (menu and form) to register a custom
 * callback to check if the node that is about to be deleted deletable.
 */

/**
 * Implements hook_theme().
 */
function predelete_theme() {
  return array(
    'predelete_reasons' => array(
      'variables' => array('reasons' => NULL),
    ),
  );
}

/**
 * Implements hook_permission().
 */
function predelete_permission() {
  return array(
    'bypass predeletion check' => array(
      'title' => t('Bypass predeletion check'),
      'description' => t('User with this permission are allowed to delete nodes without validation of the delete process.'),
    ),
  );
}

/**
 * Implements hook_menu_alter().
 */
function predelete_menu_alter(&$items) {
  // register the existing callback as a new one to redirect after checking
  $items['node/%node/predelete_checked'] = array(
    'type' => MENU_CALLBACK,
  ) + $items['node/%node/delete'];

  // Hook into the node deletion callback and rereoute to custom callback
  $items['node/%node/delete']['page callback'] = 'predelete_menu_callback';
  $items['node/%node/delete']['page arguments'] = array(1);
  $items['node/%node/delete']['type'] = MENU_LOCAL_TASK;
}

/**
 * Implements hook_form_alter().
 */
function predelete_form_alter(&$form, &$form_state, $form_id) {
  // Only hook into the confirmation form for multiple node deletion
  if ($form_id == 'node_admin_content' && $form['#submit'][0] == 'node_multiple_delete_confirm_submit') {
    // nullify the counter variables to check for the form contents
    $total = 0;
    $unset = 0;

    // Get the node that should be deleted
    $nodes = $form['nodes'];
    foreach ($nodes as $nid => $info) {
      if (is_array($info) && $info['#value'] == $nid) {
        // This is a nid, raise the counter
        $total++;

        // We have to do a node_load here because the functions needs a node object
        $node = node_load($nid);

        // Check if the node in $nid has the deleteable field.
        $result = _predelete_node_deletable($node);
        if (!$result['result']) {
          // The node may not be delete. We unset it from the form array.
          unset($form['nodes'][$nid]);
          // raise the counter for unset nodes.
          $unset++;
        }
      }
    }

    // The form is rectified. It could be possible that no deletable nodes
    // are left. Displaying the form would not really be usefull then.
    if ($unset == $total) {
      drupal_set_message(t('There are no deletable nodes in the selection.'));
      drupal_goto('admin/content');
    }
  }
}

/**
 * Menu callback to confirm the deletion of a node.
 * @param int $node the node to be deleted
 */
function predelete_menu_callback($node) {
  // Check if the node id is deleteable
  $result = _predelete_node_deletable($node);
  if ($result['result']) {
    drupal_goto('node/'.$node->nid.'/predelete_checked');
  }
  else {
    drupal_set_message(t('The node #title could not be deleted because of the following reason: !reason', array('#title' => $node->title, '!reason' => $result['reason'])), 'error');
    drupal_goto('node/'.$node->nid);
  }
}

/**
 * Helper function to let other modules react on the deletion
 * @param object $node the node object.
 * @return bool true if the is deletable
 */
function _predelete_node_deletable($node) {
  $return = array(
    'result' => TRUE,
    'reason' => t('default'),
  );

  // Is the user allowed to bypass the check?
  if (user_access('bypass predeletion check')) {
    $return['result'] = TRUE;
    return $return;
  }

  // Call the hook_predelete_node().
  $return = module_invoke_all('predelete_node', $node) + $return;

  // The return will be merged recursively if more than one module implements
  // the hook. If at least one module disables the deletion, we stop here.
  if (is_array($return['result'])) {
    $reasons = array();

    // iterate through all results (one row for each module implementing the
    // hook) and store the ids in an array to concenate the reasons.
    foreach ($return['result'] as $id => $result) {
      if ($result === FALSE) {
        $reasons[] = $return['reason'][$id];
      }
    }

    // If there is at least
    if (count($reasons) > 0) {
      $return = array('result' => FALSE, 'reason' => theme('predelete_reasons', $reasons));
    }
    else {
      $return = array('result' => TRUE, 'reason' => t('All modules implementing the hook want to have the node be deleted. Poor node.'));
    }
  }

  return $return;
}

/**
 * Theme the output of more than one reason
 * @param array $reasons an array of reason strings.
 * @return string the html output
 */
function theme_predelete_reasons($reasons) {
  $output = '<ul>';
  foreach ($reasons as $reason) {
    $output .= '<li>'.$reason.'</li>';
  }
  $output .= '</ul>';
  return $output;
}
