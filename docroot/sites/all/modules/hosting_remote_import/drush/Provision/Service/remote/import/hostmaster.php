<?php

 /**
  * @file
  *   A 'hostmaster' implementation of the 'remote_import' service type.
  */

/**
 * A class containing the 'hostmaster' implementation of the 'remote_import' service.
 *
 * This class is conditionally loaded when the "--remote_import_service_type=hostmaster"
 * option is passed to provision-save commands run on servers.
 *
 * The above flag is generated by the hosting counterpart of this class, which
 * provides the front end to configure all these fields.
 *
 * The responsibilities of this class include responding and saving any
 * values that are passed to it, and also to override the portions of
 * the public API for this service that are necessary.
 */
class Provision_Service_remote_import_hostmaster extends Provision_Service_remote_import {
 /**
  * Some common options handled upstream by the base service classes.
  */

  /**
   * Initialize this class, including option handling.
   */
  function init() {
    // REMEMBER TO CALL THE PARENT!
    parent::init();
    /**
     * Setting and storing a value.
     *
     * You will most commonly use :
     *    $this->server->setProperty('remote_import_field', 'default');
     *
     * This helper will check for an existing saved value, overridden
     * by a command line option falling back to the default.
     *
     * This is the format used by everything you want configurable from
     * the front end or command line.
     *
     * These values will be saved in ~/.drush/server_name.drush.alias.inc.
     */
    $this->server->setProperty('remote_import_field', 'default');
  }

  function list_sites() {
    $sites = array();

    $result = $this->remote_execute('@hostmaster status', array());
    drush_print_r($result);

    // We talk to the remote Aegir, and get it to list the sites it has.
    // We need to bootstrap the remote hostmaster.
    $lines[] = 'drush_bootstrap(DRUSH_BOOTSTRAP_DRUPAL_FULL)';
    $lines[] = '$sites = array()';
    $lines[] = '$results = db_query("SELECT sn.title as site, pn.title as platform
                                      FROM {hosting_site} hs
                                INNER JOIN {node} sn
                                        ON hs.nid = sn.nid
                                INNER JOIN {hosting_platform} hp
                                        ON hs.platform = hp.nid
                                INNER JOIN {node} pn
                                        ON hp.nid = pn.nid
                                     WHERE hs.status = :status", array(":status" => HOSTING_SITE_ENABLED))';
    $lines[] = 'foreach ($results as $result) {';
    $lines[] = '  $sites[$result->site] = $result->platform';
    $lines[] = '}';
    // Set the $sites array into the backend result, so we can extract it easily
    // later.
    $lines[] = 'drush_backend_set_result($sites)';

    // Execute the PHP we wrote in $lines on the remote server.
    $result = $this->remote_execute('@hostmaster php-eval', array(implode(';', $lines) . ';'));

    // If the PHP suceeeds, the result will be in the 'object' key.
    if (isset($result['object']) && is_array($result['object'])) {
      return $result['object'];
    }

    return FALSE;
  }

  function remote_execute($command, $data = array()) {
    $data += array(
      'root' => NULL,
      'uri' => NULL,
    );
    return drush_invoke_process(array('remote-host' => $this->server->remote_host, 'remote-user' => $this->server->script_user), $command, $data, array(), array('method' => 'POST', 'integrate' => TRUE));
  }

  function fetch_site($site) {
    // Do a backup on the remote server.
    $remote_backup_file = $this->remote_backup($site);

    // And now fetch that backup.
    $local_file = d('@hostmaster')->platform->server->backup_path . '/' . basename($remote_backup_file);
    $this->fetch($remote_backup_file, $local_file);

    // And now delete the backup just fetched.
    $this->remote_execute('provision-backup-delete', array($remote_backup_file));

    return $local_file;
  }

  function fetch($path, $dest) {
    $options = array(
      'omit-dir-times' => TRUE,
    );
    if (drush_core_call_rsync(escapeshellarg($this->server->script_user . '@' . $this->server->remote_host . ':/') . $path, $dest, $options, TRUE, FALSE)) {
      drush_log(dt('@path has been fetched from remote server @remote_host.', array(
        '@path' => $path,
        '@remote_host' => $this->server->remote_host))
      );
    }
    else {
      drush_set_error('PROVISION_FILE_SYNC_FAILED', dt('@path could not be fetched from remote server @remote_host.' .
        ' Changes might not be available until this has been done. (error: %msg)', array(
          '@path' => $path,
          '@remote_host' => $this->server->remote_host,
          '%msg' => join("\n", drush_shell_exec_output())))
      );
    }
  }

  function remote_backup($site) {
    $result = $this->remote_execute('@' . $site . ' provision-backup');

    if (isset($result['context']['backup_file'])) {
      return $result['context']['backup_file'];
    }

    return FALSE;
  }

  function fetch_settings($old_url) {
    $settings = array();

    $lines = array();
    $lines[] = 'drush_backend_set_result(d()->options)';

    // Execute the PHP we wrote in $lines on the remote server.
    $result = $this->remote_execute('@' . $old_url . ' php-eval', array(implode(';', $lines) . ';'));

    // If the PHP suceeeds, the result will be in the 'object' key.
    if (isset($result['object']) && is_array($result['object'])) {
      $remote_settings = $result['object'];
      // Now copy the settings we need:
      foreach ($this->remote_settings_to_copy() as $setting) {
        if (isset($remote_settings[$setting])) {
          $settings[$setting] = $remote_settings[$setting];
        }
      }
    }

    return $settings;
  }

  function remote_settings_to_copy() {
    $settings = array(
      'profile',
      'language',
    );
    // Allow other commands to alter the settings to copy.
    $modules = drush_command_implements('remote_import_hostmaster_remote_setings_to_copy_alter');
    foreach ($modules as $name) {
      $func = "{$name}_remote_import_hostmaster_remote_setings_to_copy_alter";
      $func($settings);
    }
    return $settings;
  }

  /**
   * Implementation of service verify.
   */
  function verify_server_cmd() {
    parent::verify_server_cmd();
    // We should try to connect to the remote hostmaster server.
    $result = $this->remote_execute('@hostmaster status');
    if (
      (!isset($result['object']['Drupal bootstrap']) || ($result['object']['Drupal bootstrap'] != 'Successful')) &&
      (!isset($result['object']['bootstrap']) || ($result['object']['bootstrap'] != 'Successful'))
    ) {
      return drush_set_error('REMOTE_SERVER_IS_NOT_MASTER', dt('The specified server is not an Aegir master server.'));
    }
  }
}
