<?php

/**
 * @file
 * Coordinates all generic process about products, such as price, transforming
 * nodes in products, product features and product types.
 */

define('EC_PRODUCT_CONVERT_NEVER', 0);
define('EC_PRODUCT_CONVERT_ALWAYS', 1);
define('EC_PRODUCT_CONVERT_OPTIONAL', 2);

/**
 * Implements hook_menu().
 */
function ec_product_menu() {
  $items = array();
  $access = array('administer products');

  $items['node/add/%/listing'] = array(
    'title' => 'Product type listing',
    'page callback' => '_ec_product_types_listing',
    'page arguments' => array(2),
    'access arguments' => array('administer products'),
    'type' => MENU_CALLBACK,
  );
  $items['product/autocomplete'] = array(
    'page callback' => 'ec_product_autocomplete',
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/store/products'] = array(
    'title' => 'Products',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ec_product_admin_ptypes_settings'),
    'access arguments' => $access,
    'file' => 'ec_product.admin.inc',
    'description' => t('Configure products related settings and types of products.'),
  );
  $items['admin/config/store/products/settings'] = array(
    'title' => 'Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ec_product_admin_ptypes_settings'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'access arguments' => $access,
    'file' => 'ec_product.admin.inc',
    'weight' => -10,
  );
  $items['admin/config/store/products/types'] = array(
    'title' => 'Types',
    'page callback' => 'ec_product_admin_ptypes',
    'type' => MENU_LOCAL_TASK,
    'access arguments' => $access,
    'file' => 'ec_product.admin.inc',
  );
  $items['admin/config/store/products/types/add'] = array(
    'title' => 'Add product type',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('ec_product_admin_ptypes_form'),
    'type' => MENU_LOCAL_ACTION,
    'access arguments' => $access,
    'file' => 'ec_product.admin.inc',
    'weight' => 1,
  );

  $ptypes = ec_product_get_types('names');
  foreach ($ptypes as $type => $description) {
    $items['admin/config/store/products/types/' . $type] = array(
      'title' => 'Product Type',
      'title callback' => 'ec_product_admin_ptypes_title',
      'title arguments' => array(5),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('ec_product_admin_ptypes_form', 5),
      'type' => MENU_CALLBACK,
      'access arguments' => $access,
      'file' => 'ec_product.admin.inc',
    );
    $items['admin/config/store/products/types/' . $type . '/edit'] = array(
      'title' => 'Edit',
      'type' => MENU_DEFAULT_LOCAL_TASK,
      'weight' => -10,
      'access arguments' => $access,
      'file' => 'ec_product.admin.inc',
    );
    $items['admin/config/store/products/types/' . $type . '/delete'] = array(
      'title' => 'Delete product type',
      'title callback' => 'ec_product_admin_ptypes_title',
      'title arguments' => array(5),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('ec_product_admin_ptypes_delete', 5),
      'type' => MENU_CALLBACK,
      'access arguments' => $access,
      'file' => 'ec_product.admin.inc',
    );
    $items['admin/config/store/products/types/' . $type . '/features'] = array(
      'title' => 'Features',
      'page callback' => 'ec_product_admin_features_overview',
      'page arguments' => array(5),
      'type' => MENU_LOCAL_TASK,
      'file' => 'ec_product.admin.inc',
      'access arguments' => $access,
    );
    $items['admin/config/store/products/types/' . $type . '/%/add'] = array(
      'title' => 'Edit feature',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('ec_product_admin_ptypes_feature_edit', 7, 5, 6),
      'type' => MENU_CALLBACK,
      'access arguments' => $access,
    );
    $items['admin/ecsettings/products/types/'. $type .'/%/add'] = array(
      'title' => 'Edit feature',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('ec_product_admin_ptypes_feature_edit', 6, 4, 5),
      'type' => MENU_CALLBACK,
      'access arguments' => $access,
      'file' => 'ec_product.admin.inc',
    );
    $items['admin/config/store/products/types/' . $type . '/%/edit'] = array(
      'title' => 'Edit feature',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('ec_product_admin_ptypes_feature_edit', 7, 5, 6),
      'type' => MENU_CALLBACK,
      'access arguments' => $access,
      'file' => 'ec_product.admin.inc',
    );
    $items['admin/config/store/products/types/' . $type . '/%/delete'] = array(
      'title' => 'Delete feature',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('ec_product_admin_ptypes_feature_delete', 5, 6),
      'type' => MENU_CALLBACK,
      'access arguments' => $access,
      'file' => 'ec_product.admin.inc',
    );
  }
  $items['ec_store/convertnode/js'] = array(
    'page callback' => 'ec_project_convert_node_js',
    'access arguments' => $access,
    'type' => MENU_CALLBACK,
    'file' => 'ec_product.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function ec_product_theme() {
  $template_path = drupal_get_path('module', 'ec_product') . '/templates';

  return array(
    'price' => array(
      'render element' => 'element',
      'file' => 'ec_product.theme.inc',
    ),
    'ec_product_price' => array(
      'variables' => array('node' => NULL),
      'template' => 'ec-product-price',
      'pattern' => 'ec-product-product__',
      'path' => $template_path,
      'file' => 'theme.inc',
    ),
    'ec_product_autocomplete' => array(
      'variables' => array('product' => NULL),
      'file' => 'ec_product.theme.inc',
    ),
    'ec_product_admin_ptypes_feature_list' => array(
      'render element' => 'form',
      'template' => 'ec-product-admin-ptypes-feature-list',
      'path' => $template_path,
      'file' => 'theme.inc',
    ),
    'ec_product_edit_form' => array(
      'render element' => 'form',
      'file' => 'ec_product.theme.inc',
    ),
    'ec_product_edit_form_product' => array(
      'render element' => 'form',
      'file' => 'ec_product.theme.inc',
    ),
    'ec_product_admin_features_overview' => array(
      'variables' => array('ptype' => NULL),
      'template' => 'ec-product-admin-features-overview',
      'path' => $template_path,
      'file' => 'theme.inc',
    ),
  );
}

/**
 * Implements hook_ec_perm().
 */
function ec_product_ec_perm() {
  $perms = array();
  if ($ptypes = ec_product_get_types('names')) {
    foreach ($ptypes as $ptype) {
      $perms['create ' . drupal_strtolower($ptype)] = array(
        'title' => 'Create ' . $ptype,
        'description' => t('Create %ptype product types', array('%ptype' => $ptype)),
      );
    }
  }
  return $perms;
}

/**
 * Implements hook_node_access().
 *
 * For 'create', 'update' and 'delete'. Each product type
 * module can implement its own hook_node_access() function
 * for access control.
 */
function ec_product_node_access($node, $op, $account = NULL) {

  // Get available product types.
  $ptypes = ec_product_get_types('names');

  // If there are no product types then there is nothing to administer
  // this prevents a useless link under 'create content'.
  if (empty($ptypes)) {
    return FALSE;
  }

  // Users with administer permissions have full access.
  if (user_access('administer products', $account)) {
    return TRUE;
  }

  // The first argument is 'product' if there is no current node,
  // e.g., when node module is determining which node types can be created.
  if ($node == 'product') {
    // Iterate through each product type to see if any returns TRUE.
    if (ec_product_ptypes_access()) {
      return TRUE;
    }

    // If no product type module has allowed create, update, or delete access, return FALSE.
    if ($op == 'create' || $op == 'update' || $op == 'delete') {
      return FALSE;
    }
  }
  // If there is a node object, invoke its product type's permissions.
  else {
    if (!empty($node->ptype)) {
      return ec_product_ptypes_access($ptypes[$node->ptype], $op);
    }
    return ec_product_ptypes_access(NULL, $op);
  }
}

/**
 * Check if the user can create/edit any kind of product type.
 *
 * @param $ptype
 *   Optional name of product type.
 * @param $op
 *   Optional string defining the operation to check.
 *
 * @return
 *   Boolean, TRUE if user can edit at least one of the product types.
 */
function ec_product_ptypes_access($ptype = NULL, $op = NULL) {
  if (empty($ptype)) {
    $ptypes = ec_product_get_types('names');
    while (list(, $ptype) = each($ptypes)) {
      if ($access = user_access('create ' . drupal_strtolower($ptype))) {
        return TRUE;
      }
    }
    return FALSE;
  }
  else {
    if (empty($op) or $op != 'view') {
      return user_access('create ' . drupal_strtolower($ptype));
    }
    return TRUE;
  }
}

/**
 *  Helper function to list available product types.
 *  In normal use this should not be empty, so the watchdog warning is added.
 *  This warning will occur when someone enables the product module but there are no
 *  modules that implement the ec_product_api.
 *
 * @return
 *   The returned array of enabled product types
 *   (e.g. [file] => 'file download', [tangible] => 'shippable product').
 */
function ec_product_get_types($op = 'types', $node = NULL, $reset = FALSE) {
  $_product_ptypes = & drupal_static(__FUNCTION__ . '__product_ptypes');
  $_product_names = & drupal_static(__FUNCTION__ . '__product_names');
  if ($reset or !isset($_product_ptypes)) {
    $_product_ptypes = ec_product_ptypes_build();

    drupal_alter('ec_ptypes', $_product_ptypes);

    foreach ($_product_ptypes as $type => $ptypes) {
      uasort($_product_ptypes[$type]->features, 'ec_sort');
    }

    $_product_names = array_map('_ec_product_ptype_map_names', $_product_ptypes);
    asort($_product_names);
  }

  if (!empty($node)) {
    if (is_array($node)) {
      $ptype = $node['ptype'];
    }
    elseif (is_object($node)) {
      $ptype = $node->ptype;
    }
    elseif (is_string($node)) {
      $ptype = $node;
    }
    if (!isset($_product_ptypes[$ptype])) {
      return FALSE;
    }
  }
  switch ($op) {
    case 'types':
      return $_product_ptypes;
    case 'type':
      return isset($ptype) && !empty($_product_ptypes[$ptype]) ? $_product_ptypes[$ptype] : NULL;
    case 'module':
      if (isset($ptype) && isset($_product_ptypes[$ptype]->fileinc)) {
        require_once DRUPAL_ROOT . '/' . $_product_ptypes[$ptype]->fileinc;
        return $_product_ptypes[$ptype]->module;
      }
      else {
        return FALSE;
      }
    case 'features':
      return isset($_product_ptypes[$ptype]->features) ? $_product_ptypes[$ptype]->features : FALSE;
    case 'names':
      return $_product_names;
    case 'name':
      return isset($ptype) ? $_product_names[$ptype] : FALSE;
  }
}

function _ec_product_ptype_map_names($a) {
  return $a->name;
}

/**
 * Return all the ptypes that are available on a node.
 */
function ec_product_get_node_ptypes($type) {
  $ptypes = ec_product_get_types();

  ec_product_filter_node_types($type, TRUE);
  return array_filter($ptypes, 'ec_product_filter_node_types');
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function ec_product_filter_node_types($a, $init = FALSE) {
  $type = & drupal_static(__FUNCTION__ . '_type');

  if ($init) {
    $type = $a;
    return;
  }

  return in_array($type, $a->node_types);
}

/**
 * Builds a list of available node types, by quering hook_product_info() in
 * all modules.
 *
 * Note: this is called by product_ptypes_get(), which caches the values
 * and hence this is kept in the admin file.
 */
function ec_product_ptypes_build() {
  $ptypes = array();

  foreach (module_implements('product_info') as $module) {
    $filepath = drupal_get_path('module', $module);
    $info_array = module_invoke($module, 'product_info');
    foreach ($info_array as $type => $info) {
      $info = (object) $info;
      if (isset($info->file) && !isset($info->filepath)) {
        $info->filepath = $filepath;
      }
      if (!isset($info->fileinc) && isset($info->file) && isset($info->filepath)) {
        $fileinc = './' . $info->filepath . '/' . $info->file;
        $info->fileinc = $fileinc;
      }
      $ptypes[$type] = $info;
      $ptypes[$type]->ptype = $type;
      $ptypes[$type]->internal = TRUE;
      $ptypes[$type]->features = array();
      $ptypes[$type]->node_types = array();
    }
  }

  $result = db_query('select * FROM {ec_product_ptypes}')
    ->fetchAll();
  foreach ($result as $type) {
    if (!empty($ptypes[$type->ptype])) {
      if ($type->name) {
        $ptypes[$type->ptype]->name = $type->name;
      }
      if ($type->description) {
        $ptypes[$type->ptype]->description = $type->description;
      }
      $ptypes[$type->ptype]->internal = FALSE;
    }
    else {
      $type->module = 'product_generic';
      $type->features = array();
      $type->node_types = array();
      $ptypes[$type->ptype] = $type;
    }
  }

  $features = ec_product_feature_get();
  $result = db_query('SELECT * FROM {ec_product_features} ORDER BY weight ASC')
    ->fetchAll();
  foreach ($result as $data) {
    if (isset($ptypes[$data->ptype])) {
      if (isset($features[$data->ftype])) {
        $feature = $features[$data->ftype];
        $feature->weight = $data->weight;
        $feature->ptype = $data->ptype;
        if ($data->data && ($settings = unserialize($data->data))) {
          if (is_array($settings)) {
            $feature = (object) ((array) $feature + $settings);
          }
        }
        
        ec_product_invoke_feature($feature->ftype, $feature, 'ptype_load');

        $ptypes[$data->ptype]->features[$feature->ftype] = clone $feature;
      }
    }
  }

  foreach (node_type_get_names() as $type => $description) {
    $types = variable_get('ec_product_ptypes_' . $type, array());

    foreach ($types as $ptype) {
      if (isset($ptypes[$ptype])) {
        $ptypes[$ptype]->node_types[] = $type;
      }
    }
  }

  return $ptypes;
}

/**
 * List all product types when user tries to create a product.
 */
function _ec_product_types_listing($form_state, $type = NULL) {
  $type = str_replace('-', '_', (isset($type) ? $type : arg(2)));
  $ptypes = variable_get('ec_product_ptypes_' . $type, array());
  if (empty($ptypes) && ec_product_can_be_converted($type) == EC_PRODUCT_CONVERT_OPTIONAL) {
    $ptypes = array_keys(ec_product_get_types('names'));
  }
  // If no (valid) product type has been provided, display a product type overview.
  $node = new stdClass();
  foreach ($ptypes as $ptype) {
    $name = ec_product_get_types('name', $ptype);
    $node->ptype = $ptype;
    if (ec_product_node_access('create', $node)) {
      $info = ec_product_get_types('type', $ptype);
      $type_url_str = str_replace('_', '-', $type);
      $ptype_url_str = str_replace('_', '-', $ptype);
      $out = '<dt>' . l($name, "node/add/$type_url_str/$ptype_url_str", array('title' => t('Add a !s.', array('!s' => $name)))) . '</dt>';
      $out .= '<dd>' . $info->description . '</dd>';
      $item[$name] = $out;
    }
  }

  if (isset($item)) {
    ksort($item);
    $output = t('Choose from the following available product types:') . '<dl>' .
      implode('', $item) . '</dl>';
  }
  else {
    $output = t('You are not allowed to create products.');
  }
  return $output;
}

/**
 * Implements hook_ec_transaction_load().
 */
function ec_product_ec_transaction_load(&$txn) {
  // When loading a transaction, gather the products and then let product and
  // product feature modules act on each item.
  $items = array();
  $result = db_query('SELECT stp.*, p.ptype
    FROM {ec_transaction_product} stp
    LEFT JOIN {ec_product} p ON stp.vid = p.vid
    WHERE stp.txnid = :txnid', array(':txnid' => $txn->txnid));

  foreach ($result as $item) {
    $item->data = unserialize($item->data);

    if ($extra = ec_product_invoke_productapi($item, 'transaction_load')) {
      foreach ($extra as $key => $value) {
        $item->$key = $value;
      }
    }
    if ($extra = ec_product_invoke_feature_all($item, 'transaction_load')) {
      foreach ($extra as $key => $value) {
        $item->$key = $value;
      }
    }

    $items[$item->nid] = $item;
  }

  $txn->items = $items;
}

/**
 * Implements hook_ec_transaction_insert().
 */
function ec_product_ec_transaction_insert(&$txn) {
  _ec_product_ec_transaction_save($txn);
}

/**
 * Implements hook_ec_transaction_update().
 */
function ec_product_ec_transaction_update(&$txn) {
  _ec_product_ec_transaction_save($txn);
}

/**
 * Helper function with common logic for inserting/updating products in a
 * transaction.
 */
function _ec_product_ec_transaction_save(&$txn) {
  // Hand control to ec_product_transaction_save_product to save each product,
  // where hook_productapi() is also invoked.
  if (is_array($txn->items)) {
    $orig_txn = ec_store_transaction_cache($txn->txnid);
    foreach ($txn->items as $item) {
      $item = clone $item;
      $item->txnid = $txn->txnid;
      ec_product_transaction_save_product($item);
    }
  }
}

/**
 * Implements hook_ec_transaction_delete().
 */
function ec_product_ec_transaction_delete(&$txn) {
  // Allow product/features to react to a deletion, the delete a product.
  if ($txn->items) {
    foreach ($txn->items as $item) {
      ec_product_invoke_productapi($item, 'transaction_delete');
      ec_product_invoke_feature_all($item, 'transaction_delete');
    }
  }

  db_delete('ec_transaction_product')
    ->condition('txnid', $txn->txnid)
    ->execute();
}

/**
 * Save transaction products.
 */
function ec_product_transaction_save_product($item) {
	try {
    drupal_write_record('ec_transaction_product', $item);

    ec_product_invoke_productapi($item, 'transaction_insert');
    ec_product_invoke_feature_all($item, 'transaction_insert');
  }
  catch (Exception $e) {
    drupal_write_record('ec_transaction_product', $item, array('txnid', 'nid'));
    
    ec_product_invoke_productapi($item, 'transaction_update');
    ec_product_invoke_feature_all($item, 'transaction_update');
  }
}

/**
 * Implements hook_ec_txn_allocation().
 */
function ec_product_ec_txn_allocation($txn, $orig_txn) {
  $items = !empty($txn->items) ? array_combine(array_map(create_function('$a', 'return $a->nid;'), $txn->items), $txn->items) : array();
  if (!empty($orig_txn->items)) {
    $items += array_combine(array_map(create_function('$a', 'return $a->nid;'), $orig_txn->items), array_map(create_function('$a', '$a->removed = TRUE; return $a;'), $orig_txn->items));
  }

  foreach ($items as $item) {
    ec_product_invoke_productapi($item, 'txn_allocation', $txn, $orig_txn);
    ec_product_invoke_feature_all($item, 'txn_allocation', $txn, $orig_txn);
  }
}

/**
 * Implements hook_ec_txn_workflow().
 */
function ec_product_ec_txn_workflow($txn, $orig_txn) {
  $items = !empty($txn->items) ? array_combine(array_map(create_function('$a', 'return $a->nid;'), $txn->items), $txn->items) : array();
  if (!empty($orig_txn->items)) {
    $items += array_combine(array_map(create_function('$a', 'return $a->nid;'), $orig_txn->items), array_map(create_function('$a', '$a->removed = TRUE; return $a;'), $orig_txn->items));
  }

  foreach ($items as $item) {
    ec_product_invoke_productapi($item, 'txn_workflow', $txn, $orig_txn);
    ec_product_invoke_feature_all($item, 'txn_workflow', $txn, $orig_txn);
  }
}

/**
 * Implements hook_invoiceapi().
 */
function ec_product_invoiceapi(&$invoice, $op) {
  if (is_string($invoice) && $op == 'form') {
    return t('Products');
  }
  switch ($op) {
    case 'form':
      $form['products'] = ec_product_edit_form($invoice);

      $form['seen']['#tree'] = TRUE;
      $form['seen']['product'] = array(
        '#type' => 'value',
        '#value' => TRUE,
      );
      return $form;
      break;

    case 'validate':
      if (!empty($invoice->new_products)) {
        foreach (explode(',', $invoice->new_products) as $nid) {
          if ($nid && (!($node = node_load($nid)) || empty($node->ptype))) {
            form_set_error('', empty($node) ? t('Cannot Locate Product %nid',
              array('%nid' => $nid)) : t('Node "%title" is not a valid product',
              array('%title' => $node->title)));
          }
        }
      }
      foreach ((array) $invoice->products as $nid => $item) {
        if (empty($item['qty']) || !is_numeric($item['qty']) || $item['qty'] < 1) {
          form_set_error("products][$nid][qty", t('The quantity must be a positive integer'));
        }
      }
    case 'submit':
      $change_products = FALSE;
      if (!empty($invoice->new_products)) {
        foreach (explode(',', $invoice->new_products) as $nid) {
          if (empty($invoice->items[$nid])) {
            ec_product_invoice_add($invoice, $nid);
            $change_products = TRUE;
          }
        }
        unset($invoice->new_products);
      }
      if (!empty($invoice->products)) {
        foreach ($invoice->products as $nid => $item) {
          if (!empty($item['delete'])) {
            unset($invoice->items[$nid]);
            $change_products = TRUE;
          }
          else {
            if (empty($invoice->items[$nid])) {
              ec_product_invoice_add($invoice, $nid);
              $change_products = TRUE;
            }
            foreach ($item as $key => $value) {
              if (!in_array($key, array('delete'))) {
                $invoice->items[$nid]->$key = $value;
              }
            }
          }
        }
        unset($invoice->products);
      }
      ec_store_recalc_transaction($invoice);

      // Reset the shippable flag
      if (!empty($change_products)) {
        $invoice->shippable = FALSE;
        foreach ($invoice->items as $item) {
          if (ec_product_is_shippable($item->vid)) {
            $invoice->shippable = TRUE;
            break;
          }
        }
      }
      if ($_POST['op'] == t('Update Products')) {
        return "admin/store/invoice/{$invoice->invoice_id}/edit/product";
      }
      break;

    case 'post_update':
      if (!empty($invoice->items)) {
        foreach ($invoice->items as $nid => $item) {
          if ($item->nid != $nid) {
            if (!isset($invoice->items[$nid])) {
              $invoice->items[$item->nid] = $item;
            }
            unset($invoice->items[$nid]);
            $goto_products = TRUE;
          }
        }
        if (!empty($goto_products)) {
          invoice_save($invoice->invoice_id, $invoice);
          drupal_set_message(t('There has been a problem with the products entered. This has now been corrected. Please check your products and continue.'), 'error');
          drupal_goto("admin/store/invoice/{$invoice->invoice_id}/edit/product");
        }
      }
      break;

    case 'review':
      if (empty($invoice->seen['product']) && !$invoice->txnid) {
        drupal_goto('admin/store/invoice/' . arg(3) . '/edit/product');
      }
      break;
  }
}

/**
 * @param &$invoice
 * @ingroup form
 */
function ec_product_edit_form(&$invoice) {
  module_load_include('inc', 'ec_product', 'product.admin');
  return _ec_product_edit_form($invoice);
}

/**
 * Add a product into an invoice.
 *
 * @param &$invoice
 *   Object, the invoice.
 * @param $nid
 *   Number, the node ID.
 * @param $data
 */
function ec_product_invoice_add(&$invoice, $nid, $data = NULL) {
  if ($node = node_load($nid)) {
    $invoice->items[$node->nid] = $node;
    $invoice->items[$node->nid]->qty = 1;
    $invoice->items[$node->nid]->data = $data;
    $invoice->items[$node->nid]->price = ec_product_price_adjust($invoice->items[$nid], $invoice);

    if (ec_product_is_shippable($invoice->items[$node->nid]->vid)) {
      $invoice->shippable = TRUE;
    }
  }
}

/**
 * Enable a feature.
 *
 * @param $info
 * @param $ftype
 *   String, the feature type.
 */
function ec_product_feature_disable($info, $ftype) {
  if (isset($info->features[$ftype])) {
    db_delete('ec_product_features')
      ->condition('ptype', $info->ptype)
      ->condition('ftype', $ftype)
      ->execute();
    ec_product_get_types('', NULL, TRUE); // reset product type cache
    ec_product_invoke_feature($ftype, $info, 'feature_disable', $ftype);
    drupal_set_message(t('Product feature %name has been disabled for %ptype_name',
      array('%name' => ec_product_feature_get('name', $ftype), '%ptype_name' => $info->name)));
  }
}

/**
 * Implements hook_feature_info().
 * List all feature information.
 */
function ec_product_feature_info() {
  return array(
    'no_discount' => array(
      'name' => t('No Discount'),
      'description' => t('Make this product type exempt from discount'),
      'module' => 'ec_product_feature_no_discount',
      'file' => 'ec_product.features.inc',
    ),
    'shippable' => array(
      'name' => t('Shippable'),
      'description' => t('Make a product type shippable'),
      'module' => 'ec_product_feature_shippable',
      'file' => 'ec_product.features.inc',
    ),
    'no_quantity' => array(
      'name' => t('No Quantity'),
      'description' => t('Make a product not have a quantity.'),
      'module' => 'ec_product_feature_no_quantity',
      'file' => 'ec_product.features.inc',
    ),
    'purchase_permission' => array(
      'name' => t('Purchase permission'),
      'description' => t('Allow the restriction of purchase by users based upon the permissions that the role has.'),
      'module' => 'ec_product_feature_permission',
      'file' => 'ec_product.features.inc',
      'hidden' => TRUE,
    ),
  );
}

/**
 * Enable a feature.
 *
 * @param $info
 * @param $ftype
 *   String, the feature type
 * @param $data
 *   Array or additional pameters to add the the products feature
 */
function ec_product_feature_enable($info, $ftype, $data = array()) {

  if (!isset($info->features[$ftype]) && ($feature = ec_product_feature_get('type', $ftype, TRUE))) {
    $fdata = array(
      'ptype' => $info->ptype,
      'ftype' => $ftype,
      'weight' => isset($feature->weight) ? $feature->weight : 0,
    );

    $fdata += $data;

    ec_product_feature_save($info->ptype, $fdata);

    drupal_set_message(t('Product feature %name has been enabled for %ptype_name',
      array('%name' => ec_product_feature_get('name', $ftype), '%ptype_name' => $info->name)));
  }
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function ec_product_feature_save($ptype, $info) {
  $info['ptype'] = $ptype;
  $ftype = $info['ftype'];

  if ($function = ec_product_feature_get_function($info['ftype'], 'settings')) {
    foreach ($function() as $field) {
      if (isset($info[$field])) {
        $info['data'][$field] = $info[$field];
        unset($info[$field]);
      }
    }
  }

  $existing = db_select('ec_product_features', 'epf')
    ->fields('epf')
    ->condition('ptype', $info['ptype'])
    ->condition('ftype', $info['ftype'])
    ->execute()
    ->fetchAssoc();

  if ($existing) {
    drupal_write_record('ec_product_features', $info, array('ptype', 'ftype'));
  }
  else {
    drupal_write_record('ec_product_features', $info);
    ec_product_invoke_feature($ftype, $info, 'feature_enable', $ftype);
  }
  ec_product_invoke_feature($ftype, $info, 'ptype_save');
  ec_product_get_types('', NULL, TRUE); // reset product type cache
}
/**
 * Check a ptype to see if a product feature has been enabled to this product.
 */
function ec_product_feature_exists($node, $feature) {
  if ($info = ec_product_get_types('type', $node)) {
    return isset($info->features[$feature]);
  }
  else {
    return FALSE;
  }
}

/**
 * List all features using some filter parameters.
 */
function ec_product_feature_get($op = 'types', $ftype = NULL, $reset = FALSE) {
  $types = & drupal_static(__FUNCTION__ . '_types');
  $names = & drupal_static(__FUNCTION__ . '_names');

  if (!empty($reset) || empty($types)) {
    foreach (module_implements('feature_info') as $module) {
      $filepath = drupal_get_path('module', $module);
      $info = module_invoke($module, 'feature_info');
      if (!empty($info)) {
        foreach ($info as $key => $value) {
          $value = (object) $value;
          $value->ftype = $key;

          if (isset($value->file) && !isset($value->filepath)) {
            $value->filepath = $filepath;
          }
          if (!isset($value->fileinc) && isset($value->file) && isset($value->filepath)) {
            $fileinc = './' . $value->filepath . '/' . $value->file;
            $value->fileinc = $fileinc;
          }

          $names[$key] = $value->name;
          $types[$key] = $value;
        }
        asort($names);
      }
    }
  }

  if (!empty($types) && !empty($ftype) && !isset($types[$ftype])) {
    return FALSE;
  }

  switch ($op) {
    case 'types':
      return $types;
    case 'type':
      return !empty($types[$ftype]) ? $types[$ftype] : NULL;
    case 'module':
      return $types[$ftype]->module;
    case 'names':
      return $names;
    case 'name':
      return $names[$ftype];
  }
}

/**
 * Get the function that is called.
 *
 * @param $ftype
 *   Feature type to be called.
 * @param $node
 *   Product node that is being called.
 * @param $hook
 *   Hook to called.
 *
 * @return
 *   Return the function that is to be called or NULL if no function exists.
 */
function ec_product_feature_get_function($ftype, $hook) {
  if ($info = ec_product_feature_get('type', $ftype)) {
    if (isset($info->fileinc)) {
      require_once DRUPAL_ROOT . '/' . $info->fileinc;
    }

    $function = "{$info->module}_{$hook}";
    if (function_exists($function)) {
      return $function;
    }
  }
}

/**
 * Get all the functions that are called a node.
 *
 * @param $node
 *   Object. product node that is being used.
 * @param $hook
 *   String. Hook that is to be called.
 *
 * @return
 *   Array. Hooks that are the functions of all the features.
 */
function ec_product_feature_get_all_functions(&$node, $hook) {
  $funcs = array();
  if ($features = ec_product_get_types('features', $node)) {
    foreach ($features as $ftype => $feature) {
      if ($function = ec_product_feature_get_function($ftype, $hook)) {
        $funcs[] = $function;
      }
    }
  }
  return $funcs;
}

/**
 * Update a feature.
 *
 * @param $features
 */
function ec_product_feature_update($feature) {
  db_update('ec_product_features')
    ->fields(array(
      'weight' => $feature->weight,
    ))
    ->condition('ptype', $feature->ptype)
    ->condition('ftype', $feature->ftype)
    ->execute();
}

/**
 * Get a list of all the product attributes, or check that one exists.
 *
 * Calling this function will return a list of all attributes that are
 * connected to the product type.
 *
 * @param $node
 *   Object. The product node which has all the product details.
 * @param $attribute
 *   String (Optional). An attribute by name, simply to determine
 *   if this attribute  exists.
 * @return
 *   If an $attribute is passed then just TRUE or FALSE is returned.
 *   Otherwise, all attributes are passed back.
 *
 * @TODO: the $node parameter is supplied from ec_buynow as a ptype- so
 * perhaps $node here should be relabeled as $ptype?
 */
function ec_product_attributes_get($node, $attribute = NULL) {
  $attr = $attribute; // Readability.

  $attributes = ec_product_invoke_productapi($node, 'attributes', $attr);
  $attributes = empty($attributes) ? array() : $attributes;
  $attributes = array_merge($attributes, ec_product_invoke_feature_all($node, 'attributes', $attr));

  if (!is_array($attributes) && empty($attributes)) {
    $attributes = array();
  }
  elseif (!is_array($attributes)) {
    $attributes = (array) $attributes;
  }

  if (!empty($attr)) {
    return isset($attributes[$attr]) ? $attributes[$attr] : FALSE;
  }
  else {
    return $attributes;
  }
}

/**
 * Determine if the product has a quantity.
 * @param $node
 *   Object, the node
 */
function ec_product_has_quantity($node) {
  $items = & drupal_static(__FUNCTION__ . '_items', array());
  if (empty($node->vid)) {
    $node = ec_product_load($node);
  }
  if (!isset($items[$node->vid])) {
    $items[$node->vid] = ec_product_attributes_get($node, 'no_quantity');
  }
  return empty($items[$node->vid]);
}

/**
 * Correct the quantity of an item, that it doesn't exceed the maximum.
 */
function ec_product_check_qty($item, $qty) {
  return (ec_product_has_quantity($item) || !$qty) ? $qty : 1;
}

/**
 * Execute a given feature hooks
 */
function ec_product_invoke_feature($ftype, &$node, $hook, $a4 = NULL, $a5 = NULL, $a6 = NULL, $a7 = NULL) {
  if ($function = ec_product_feature_get_function($ftype, $hook)) {
    return $function($node, $a4, $a5, $a6, $a7);
  }
}

/**
 * Execute all feature hooks
 *
 * @TODO: is $node here really an object? or a $ptype?- invoked twice- via productapi and ?
 */
function ec_product_invoke_feature_all(&$node, $hook, $a3 = NULL, $a4 = NULL, $a5 = NULL, $a6 = NULL) {
  $return = array();
  if ($features = ec_product_get_types('features', $node)) {
    foreach ($features as $feature) {
      if (isset($feature->ftype)) {
        $result = ec_product_invoke_feature($feature->ftype, $node, $hook, $a3, $a4, $a5, $a6);
        if (isset($result) && is_array($result)) {
          $return = array_merge($return, $result);
        }
        elseif (isset($result)) {
          $return[] = $result;
        }
      }
    }
  }
  return $return;
}

/**
 * The controller for the plugin API hooks. It iterates through the enabled
 * plugins and calls their *_productapi hook if one exists, passing it the
 * action (via $op) to execute.
 *
 * @param &$node
 *   Either a node object, node array, or a string containing the node type.
 * @param $op
 *   A string containing the name of the productapi operation.
 *   operations include:
 *      ec_checkout_validate_item
 *      ec_checkout_add_complete
 *      checkout_post_submit
 *      transaction_load
 *      transaction_delete
 *      transaction_insert
 *      txn_allocation
 *      txn_workflow
 *      attributes
 *      load (node)
 *      validate (node)
 *      delete (node)
 *      update (node)
 *      insert (node)
 *      adjust_price (node)
 *      form (node_form?)
 *      cart_form
 *      cart_remove_item
 *
 * @param $a3, $a4, $a5
 *   Arguments to pass on to the hook, after the $node and $op arguments.
 * @return
 *   The returned value of the invoked hooks.
 */
function ec_product_invoke_productapi(&$node, $op, $a3 = NULL, $a4 = NULL, $a5 = NULL) {
  if ($func = ec_product_productapi_get_function($node, $op)) {
    return $func($node, $a3, $a4, $a5);
  }
}

/**
 * Determine if a product or a product type is shippable.
 *
 * If a vid is given, the test is for a particular product,
 * whereas if a ptype is given it's for the ptype.
 *
 * @param $vid
 *   Version id of product.
 * @param $ptype
 *   Product type.
 * @return
 *    Boolean.
 */
function ec_product_is_shippable($vid = NULL, $ptype = NULL) {

  $product = isset($vid) ? db_query('SELECT ptype FROM {ec_product} WHERE vid = :vid', array(':vid' => $vid))->fetchObject() : (object) array('ptype' => $ptype);

  return ec_product_attributes_get($product, 'is_shippable');
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * - Node creation/editing (node/add/type and node/edit/#)
 *   A fieldset is added to allow the new node to be tranformed into one
 *   of the available product types. If the node has already been transformed,
 *   the some options may be presented for configuration.
 *
 * - Node type configuration (admin/content/types):
 *   When configuring each content type, you can select the product transformations
 *   that will be allowed when that type of node is created.
 *
 *   Note: The form alterations occur in _ec_product_form_*_alter() in product.admin.inc
 */
function ec_product_form_node_form_alter(&$form, &$form_state) {
  // Ensure that product form functions are available.
  $form_state['rebuild'] = FALSE;

  // Generic check for a node form.
  module_load_include('inc', 'ec_product', 'ec_product.admin');

  // If node is already a product.
  if (isset($form['#node']->ptype) && $form['#node']->ptype) {
    // Product is already a product (been added to store, for example).
    if (empty($form['product'])) {
      $form['product'] = array();
    }
    $form['product'] += _ec_product_alter_product_form($form_id, $form);
    if (!isset($form['product']['special_options'])) {
      $form['product']['special_options'] = array();
    }
    $form['product']['#process'] = array('form_process_fieldset', 'ajax_process_form' ,'ec_product_form_special_options');
  }
  // If node is not yet a product (but could be).
  elseif (ec_product_can_be_converted($form['#node']->type, TRUE)) {
    $form['product'] = _ec_product_alter_node_form($form['#node']);
  }
}

function _ec_product_alter_node_form_callback($form, &$form_state) {
  $pform = $form['product'];
  unset($pform['#type'], $pform['#title'], $pform['#attributes'], $pform['#group'], $pform['#groups']);
  return $pform;
}

function ec_product_convert_node(&$form, &$form_state) {
  $form_state['node']->ptype = $form_state['values']['ptype'];
  $form_state['rebuild'] = TRUE;
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function ec_product_form_node_type_form_alter(&$form, &$form_state) {
  module_load_include('inc', 'ec_product', 'ec_product.admin');
  _ec_product_alter_node_type_form($form, $form_state);
}

/**
 * Check a form to see if it is the form of a node that has been converted to a product.
 *
 * @param $form_id, $form
 *  The same parameteres as hook_form_alter().
 *
 * @param $ptype
 *  If the form is dependent on a type of product, then this can be passed to
 *  add an additional check.
 */
function ec_product_form_is_product(&$form, $ptype = NULL) {
  return (isset($ptype) ? (isset($form['#node']->ptype) && $form['#node']->ptype == $ptype ? TRUE : FALSE) : (isset($form['#node']->ptype) ? TRUE : FALSE));
}

/**
 * Determine whether this product can be converted, and optionally check if the
 * the current user is allowed to do it.
 *
 * @param $node_type
 *  A content type.
 *
 * @param $check_access
 *  pass TRUE to check access of the current user
 *
 * @return boolean
 *  - if just checking a node type, return a constant EC_PRODUCT_CONVERT_NEVER, EC_PRODUCT_CONVERT_ALWAYS, EC_PRODUCT_CONVERT_OPTIONAL
 *  - if also checking permissions, return TRUE or FALSE
 */
function ec_product_can_be_converted($node_type, $check_access = FALSE) {
  $allowed = variable_get('ec_product_convert_' . $node_type, variable_get('ec_product_convert', EC_PRODUCT_CONVERT_NEVER));
  if ($check_access && $allowed) {
    return (user_access('administer products') || ec_product_ptypes_access());
  }
  return $allowed;
}

/**
 * Implements hook_node_load().
 */
function ec_product_node_load($node, $types) {
  if ($product = ec_product_load($node)) {
    foreach ($product as $key => $value) {
      $node->$key = $value;
    }
  }
}

/**
 * Implements hook_node_prepare().
 */
function ec_product_node_prepare($node) {
  // Prepare if the node is new.
  if (empty($node->ptype)) {
    $convert_optional_or_always = ec_product_can_be_converted($node->type);
    if ($convert_optional_or_always) {
      ec_product_prepare($node, $convert_optional_or_always);
    }
  }
}

/**
 * Implements hook_node_validate().
 */
function ec_product_node_validate($node, $form) {
  if (!empty($node->ptype)) {
    ec_product_invoke_productapi($node, 'validate', $form);
    return ((form_get_errors()) ? FALSE : TRUE);
  }
}

/**
 * Implements hook_node_insert().
 */
function ec_product_node_insert($node) {
  if (!empty($node->product_remove)) {
    // user has checked 'remove this item from store'.
    ec_product_delete($node);
  }
  elseif (!empty($node->ptype)) {
    ec_product_save($node);
  }
}

/**
 * Implements hook_node_update().
 */
function ec_product_node_update($node) {
  if (!empty($node->product_remove)) {
    // user has checked 'remove this item from store'.
    ec_product_delete($node);
  }
  elseif (!empty($node->ptype)) {
    ec_product_save($node);
  }
}

/**
 * Implements hook_node_view().
 */
function ec_product_node_view($node, $view_mode = 'full') {
  if (!empty($node->ptype) && !ec_product_attributes_get($node, 'hide_product_price')) {
    // Include the price
    $node->content['price'] = array(
      '#markup' => theme('ec_product_price', array('node' => $node)),
      '#weight' => 1,
    );
  }
}

/**
 * Implements hook_node_delete().
 */
function ec_product_node_delete($node) {
  if (!empty($node->ptype)) {
    ec_product_delete($node);
  }
}

/**
 * Implements hook_node_update_index().
 */
function ec_product_node_update_index($node) {
  if (!empty($node->type) && !empty($node->sku)) {
    return $node->sku;
  }
}

/**
 * Load the product onto a node.
 * Called from product_nodeapi()  $op == 'load'
 */
function ec_product_load(&$nodes) {
  foreach ($nodes as $nid => &$node) {
    $products = & drupal_static(__FUNCTION__ . '_products', array());
    $vid_xref = & drupal_static(__FUNCTION__ . '_vid_xref', array());

    if (empty($node->vid)) {
      if (empty($node->nid)) {
        $node->vid = NULL;
      }
      else {
        $node->vid = db_select('node', 'n')
          ->fields('n', array('vid'))
          ->condition('nid', $node->nid)
          ->execute()
          ->fetchCol();
      }
    }

    if (empty($products[$node->vid])) {
      $product = db_select('ec_product', 'p')
        ->fields('p')
        ->condition('vid', $node->vid)
        ->execute()
        ->fetchObject();

      if ($product) {
        // Merge the product info for the specific type.
        if (!empty($product) and $product_type = ec_product_invoke_productapi($product, 'load')) {
          foreach ($product_type as $key => $value) {
            $product->$key = $value;
          }
        }
        if (!empty($product) && $extra = ec_product_invoke_feature_all($product, 'load')) {
          foreach ($extra as $key => $value) {
            $product->$key = $value;
          }
        }
        $products[$node->vid] = $product;
      }
    }
    if (isset($products[$node->vid])) {
      foreach ($products[$node->vid] as $property => &$value) {
        $node->$property = $value;
      }
    }
  }
}

/**
 * Use the 'prepare' operation of nodeapi to convert a node to a product.
 * Called by product_nodeapi  $op == 'prepare'
 */
function ec_product_prepare(&$node, $convert_type) {
  // If the normal node can be converted to a product
  if ($convert_type == EC_PRODUCT_CONVERT_ALWAYS) {
    $ptypes = array_keys(ec_product_get_node_ptypes($node->type));
    if (empty($ptypes)) {
      $ptypes = array_keys(ec_product_get_types('names'));
    }
    $arg3 = str_replace('-', '_', arg(3));
    if (!empty($arg3) && in_array($arg3, $ptypes)) {
      $node->ptype = $arg3;
    }
    elseif (count($ptypes) == 1) {
      $node->ptype = reset($ptypes);
    }
    elseif (!empty($node->cck_dummy_node_form)) {
      $node->ptype = reset($ptypes);
    }
    else {
      $type_url_str = str_replace('_', '-', $node->type);
      drupal_goto('node/add/' . $type_url_str . '/listing');
    }
  }
}

/**
 * Delete a product
 * Called from ec_product_nodeapi() $op == 'delete' and 'update' (ie. when removing a node from store).
 */
function ec_product_delete($node, $revision_only = FALSE) {
  if (!empty($revision_only)) {
    db_delete('ec_product')
      ->condition('nid', $node->nid)
      ->condition('vid', $node->vid)
      ->execute();
  }
  else {
    db_delete('ec_product')
      ->condition('nid', $node->nid)
      ->execute();
  }
  module_invoke('cart', 'productapi', $node, 'delete');
  ec_product_invoke_productapi($node, 'delete', $revision_only);
  ec_product_invoke_feature_all($node, 'delete', $revision_only);
  drupal_set_message(t('Product deleted'));
}

/**
 * Assumes the node data has already been saved to its respective tables and
 * only updates the main product table and the plugin of the product type
 * (e.g., product_tangible).
 *
 * @param $node
 *   Object, the node object
 */
function ec_product_save($node) {
  if (!empty($node->ptype)) {
    $existing = db_select('ec_product', 'p')
      ->fields('p', array('vid'))
      ->condition('vid', $node->vid)
      ->execute()
      ->fetchCol();

    if ($existing) {
      if (drupal_write_record('ec_product', $node, 'vid')) {
        ec_product_invoke_productapi($node, 'update');
        ec_product_invoke_feature_all($node, 'update');
      }
    }
    else {
      if (drupal_write_record('ec_product', $node)) {
        ec_product_invoke_productapi($node, 'insert');
        ec_product_invoke_feature_all($node, 'insert');
      }
    }
  }
  else {
    // Need to delete the product information if there is any.
    $ret = db_delete('ec_product')
      ->condition('vid', $node->vid)
      ->execute();
    if ($ret) {
      ec_product_invoke_productapi($node, 'delete');
      ec_product_invoke_feature_all($node, 'delete');
    }
  }
}

/**
 * Adjust the price of a product
 */
function ec_product_price_adjust(&$node, $type = 'ec_product', $txn = NULL) {
  $old_price  = $node->price;
  $new_price = ec_product_invoke_productapi($node, 'adjust_price', $old_price, $type, $txn);
  if ($info = ec_product_get_types('type', $node->ptype)) {
    foreach ($info->features as $ftype => $feature) {
      $return = ec_product_invoke_feature($ftype, $node, 'adjust_price', $new_price, $old_price, $type, $txn);
      if (isset($return)) {
        $new_price = $return;
      }
    }
  }
  return (($new_price > 0) ? $new_price : $old_price);
}

/**
 * Check if the price is valid or not. If not, stop the form
 * process acusing it an error
 *
 * @param $element
 *   Array. The form element (field)
 */
function ec_product_price_valid(&$element, &$form_state) {
  $price = ec_product_price_normalize($element['#value']);
  if ($price === FALSE) {
    $message = empty($element['#required']) ?
      t('Please enter a numeric value for the product price.') :
      t('Please enter a numeric or blank value for the product price.');
    form_error($element, $message);
  }
  else {
    form_set_value($element, $price, $form_state);
  }
}

/**
 * Get the function that is called from a certian productapi hook.
 *
 * @param $node
 *  The product node which is being called.
 * @param $hook
 *  The hook which is to be called.
 *
 * @return
 *  Return the function to be called, or NULL if no function exists
 */
function ec_product_productapi_get_function($node, $hook) {
  $func = ec_product_get_types('module', $node) . '_product_' . $hook;
  if (function_exists($func)) {
    return $func;
  }
}

/**
 * Implements hook_token_list() from the token module().
 */
function ec_product_token_list($type = 'all') {
  $vars = array();

  if ($type == 'all' || $type == 'node') {
    $vars['node']['product-sku'] = t('Product SKU.');
    $vars['node']['product-price'] = t('Product price.');
  }

  return $vars;
}

/**
 * Implements hook_token_values() from the token module().
 */
function ec_product_token_values($type, $object = NULL) {
  $values = array();

  if ($type == 'node') {
    $node = (object) $object;
    $values['product-sku'] = check_plain($node->sku);
    $values['product-price'] = format_currency($node->price);
  }

  return $values;
}

/**
 * Implements hook_element_info().
 *
 * List aditional form fields
 */
function ec_product_element_info() {
  $items['price'] = array(
    '#input' => TRUE,
    '#autocomplete_path' => FALSE,
    '#element_validate' => array('ec_product_price_valid'),
    '#theme' => 'textfield', 
    '#theme_wrappers' => array('form_element'),
  );

  return $items;
}

/**
 * Product Autocomplete.
 */
function ec_product_autocomplete($type, $string) {
  if ((strpos($string, ',')) !== FALSE) {
    $pre_string = drupal_substr($string, 0, drupal_strrpos($string, ',') + 1);
    $string = drupal_substr($string, drupal_strrpos($string, ',') + 1);
  }

  $result = db_select('node', 'n')
    ->join('ec_product', 'p', 'n.vid = p.vid')
    ->fields(array(
        'n.nid',
        'n.title',
        'p.sku',
        'p.price',
      ))
    ->condition('n.status', 1)
    ->condition(db_or()
        ->condition('n.nid', db_like($string) . '%', 'LIKE')
        ->condition('n.title', db_like($string) . '%', 'LIKE')
        ->condition('p.sku', db_like($string) . '%', 'LIKE')
      )
    ->execute();
    

  foreach ($result as $product) {
    $matches[$pre_string . $product->nid] = theme('ec_product_autocomplete', array('product' => $product));
  }
  echo drupal_json_encode($matches);
  exit();
}

/**
 * Returns a price normalized for the price database fields in e-Commerce. The
 * price is normalized to a float format and that value is returned. If $price
 * contains characters other than a leading payment_symbol, decimal point or
 * thousands separator this function returns FALSE.
 *
 * @param $price String representation of the price.
 * @return Normalized price string (as a float) or FALSE if $price contains
 * invalid characters. If $price is an empty string it is returned without
 * flagging it as an error.
 */
function ec_product_price_normalize($price) {
  $price = trim($price);

  if (!empty($price)) {
    $symb = variable_get('payment_symbol', '$');
    $symblen = drupal_strlen($symb);
    $symbpos = (variable_get('payment_symbol_position', 1) == 1 ? 0 : -$symblen);
    $pricestart = ($symbpos == 0 ? $symblen : 0);
    $decimal = variable_get('payment_decimal', '.');

    if (drupal_substr($price, $symbpos, $symblen) == $symb) {
      $price = drupal_substr($price, $pricestart, drupal_strlen($price) - $symblen);
    }

    $price = str_replace(variable_get('payment_thousands', ','), '', $price);
    $price = str_replace(variable_get('payment_decimal', '.'), '.', $price);

    if (is_numeric($price)) {
      return $price;
    }
  }
  else {
    return '';
  }

  return FALSE;
}

/**
 * List all price adjustments for a product.
 *
 * @param $node
 *   Object. The product.
 * @param $type
 * @param $total_only
 *   Boolean, TRUE if only the total price is important.
 * @param $txn
 */
function ec_product_specials_get($node, $type, $total_only = FALSE, $txn = NULL) {
  $specials = array();
  if (!(ec_product_attributes_get($node, 'no_discounts'))) {
    foreach (module_implements('product_specials') as $name) {
      if ($extra = module_invoke($name, 'product_specials', $node, $specials, $type, $txn)) {
        $specials = array_merge($specials, $extra);
      }
    }
  }
  if (!empty($total_only)) {
    $total = 0;
    foreach ($specials as $special) {
      if (is_array($special)) {
        $total += $special['price'] * (isset($special['qty']) ? $special['qty'] :
          (isset($node->qty) ? $node->qty : 1));
      }
      else {
        $total += $special * (isset($node->qty) ? $node->qty : 1);
      }
    }
    return $total;
  }
  else {
    return $specials;
  }
}

/**
 * Save a product type.
 */
function ec_product_ptypes_save($info, $menu_rebuild = TRUE) {
  $ptype = isset($info->old_ptype) ? $info->old_ptype : $info->ptype;
  if (db_query("SELECT COUNT(*) FROM {ec_product_ptypes}
      WHERE ptype = :ptype", array(':ptype' => $ptype))->fetchField()) {
    db_update('ec_product_ptypes')
      ->fields(array(
        'name' => $info->name,
        'ptype' => $info->ptype,
        'description' => $info->description,
      ))
      ->condition('ptype', $ptype)
      ->execute();
  }
  else {
    $id = db_insert('ec_product_ptypes')
      ->fields(array(
        'name' => $info->name,
        'ptype' => $info->ptype,
        'description' => $info->description,
      ))
      ->execute();
    if ($menu_rebuild) {
      menu_rebuild();
    }
  }
  $info = ec_product_get_types('type', $info->ptype, TRUE);
  module_invoke_all('product_types', $info, 'update');
}

/**
 * Title for ptypes form
 * FIXME: I think it can be done by ec_product_get_types();
 */
function ec_product_admin_ptypes_title($ptype) {
  if ($info = ec_product_get_types('type', $ptype)) {
    return $info->name;
  }
  return $ptype;
}

/**
 * Implements hook_checkout_info().
 */
function ec_product_checkout_info() {
  return array(
    'product' => array(
      'name' => t('Product'),
      'description' => t('Provides product handling for checkout.'),
      'module' => 'ec_product',
      'file' => 'ec_product.checkout.inc',
      'weight' => -9,
    ),
  );
}

/**
 * Implementation of hooks_views_api().
 */
function ec_product_views_api() {
  return array('api' => 2.0);
}

/**
 * Check a product and see if it can be sold to the current user.
 */
function ec_product_can_purchase($node, $type = 'any') {
  $qty = 1;
  $data = array();
  
  // Since nodes can be changed during the ec_checkout_validate_item() (i.e. ec_subproducts) then clone the node so it
  // is not changed when it is returned to it's calling function.
  $product = clone $node;

  if (isset($node->ptype) && ec_checkout_validate_item($product, $type, $qty, $data, EC_VALIDATE_ITEM_SEVERITY_LOW)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Get final product price
 */
function ec_product_get_final_price($node, $type) {
  return ec_product_price_adjust($node, $type) + ec_product_specials_get($node, $type, TRUE) + (module_invoke('ec_charge', 'product_charges', $node, $type, TRUE));
}

/**
 * Implements hook_ec_charge_filter_info().
 */
function ec_product_ec_charge_filter_info() {
  return array(
    'shippable' => array(
      'name' => t('Shippable'),
      'description' => t('Filters transactions which have shippable products'),
      'module' => 'ec_product_shippable',
      'file' => 'ec_product.charge.inc',
    ),
    'total_sold' => array(
      'name' => t('Total items sold'),
      'description' => t('Filter product based upon how many items have ever been sold.'),
      'module' => 'ec_product_sold',
      'file' => 'ec_product.charge.inc',
    ),
  );
}

/**
 * Implements hook_ec_charge_variable_info().
 */
function ec_product_ec_charge_variable_info() {
  return array(
    'shippable' => array(
      'name' => t('Shippable'),
      'description' => t('Return the values of all the shippable products'),
      'module' => 'ec_product_shippable',
      'file' => 'ec_product.charge.inc',
    ),
  );
}


/**
 * Implements hook_ec_charge_default_variables().
 */
function ec_product_ec_charge_default_variables($type, $object, $charges) {
  $$type = & $object;
  $variables = array();

  switch ($type) {
    case 'node':
      $variables = array(
        'start' => $node->price,
        'adjusted' => ec_product_price_adjust($node, $type),
        'specials' => ec_product_specials_get($node, $type, TRUE),
        'qty' => isset($node->qty) ? $node->qty : 1,
      );

      $variables['price'] = $variables['adjusted'] + $variables['specials'];

      foreach ($charges as $misc) {
        $variables['price'] += $misc->price;
      }
      break;
  }

  return $variables;
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function ec_product_ec_charge_default_variables_description($type, $object, $variables) {
  $$type = & $object;
  $descriptions = array();

  switch ($type) {
    case 'node':
      $descriptions = array(
        'start' => t('Initial price of the product before any adjustments or specials have been loaded.'),
        'adjusted' => t('Price of the product after the price adjustments have been done.'),
        'specials' => t('Values of any specials'),
        'qty' => t('The number of items that are going to be purchased.'),
        'price' => t('The final price of the product after all adjustments and discounts have been added.'),
      );
      break;
  }

  return $descriptions;
}

/*
 * API call to consolidate "productapi" and "product feature" functions
 *
 *
 */
/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function ec_product_get_all_functions($node, $hook) {
  $functions = ec_product_feature_get_all_functions($node, $hook);

  if ($function = ec_product_productapi_get_function($node, $hook)) {
    array_unshift($functions, $function);
  }
  return $functions;
}

/**
 * Implements hook_ec_ptypes_alter().
 */
function ec_product_ec_ptypes_alter($ptypes) {
  $feature = ec_product_feature_get('type', 'purchase_permission');

  foreach ($ptypes as $type => $ptype) {
    $feature->ptype = $type;
    $feature->weight = isset($ptype->features['anonymous']) ? $ptype->features['anonymous']->weight + 1 : array_reduce($ptype->features, 'ec_reduce_weight_lightest') - 1;

    $ptypes[$type]->features['purchase_permission'] = clone $feature;
  }
}

/**
 * Implements hook_permission();().
 */
function ec_product_permission() {
  return array(
    'administer products' => array(
      'title' => t('Administer products'),
      'description' => t('Allow users to administer products'),
    ),
    'purchase products' => array(
      'title' => t('Purchase products'),
      'description' => t('Allow user to purchase products'),
    ),
  );
}

/**
 * Load ptype from the URL
 */
function ec_product_ptype_load($ptype) {
  return ec_product_get_types('type', $ptype);
}

/**
 * Get list of all product types which implement a feature.
 *
 * @param $feature
 *  Id of the feature that you want to know which product types it is being used on.
 *
 * @return
 *  Return a list of product types the requested feature has been attached to.
 */
function ec_product_ptype_implements($feature) {
  $features = drupal_static(__FUNCTION__);

  if (!isset($features)) {
    $types = ec_product_get_types();

    foreach ($types as $ptype => $info) {
      foreach ($info->features as $ftype => $finfo) {
        if (!isset($features[$ftype])) {
          $features[$ftype] = array();
        }
        $features[$ftype][$ptype] = $info;
      }
    }
  }

  return isset($features[$feature]) ? $features[$feature] : array();
}

function ec_product_form_special_options(&$element, &$form_state) {
  if (element_children($element['special_options'])) {
    $element['special_options']+= array(
      '#type' => 'fieldset',
      '#title' => t('Special options'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#weight' => 99,
      '#attached' => array(
        'css' => array(drupal_get_path('module', 'ec_product') . '/css/verticaltabs-fieldset-fix.css'),
      ),
    );
  }
  return $element;
}
