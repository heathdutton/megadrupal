<?php

/**
 * @file
 * Universal reference module.
 *
 * Provides a link field than can refer to both node IDs and external URLs.
 */

/**
 * Implements hook_menu().
 */
function universal_reference_menu() {
  $items['universal_reference/autocomplete/%/%/%'] = array(
    'page callback' => 'universal_reference_autocomplete',
    'page arguments' => array(2, 3, 4),
    'access callback' => 'universal_reference_autocomplete_access',
    'access arguments' => array(2, 3, 4),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Menu access callback for reference autocomplete paths.
 *
 * Check for both 'edit' and 'view' access in the unlikely event
 * a user has edit but not view access.
 */
function universal_reference_autocomplete_access($entity_type, $bundle, $field_name, $entity = NULL, $account = NULL) {
  return user_access('access content', $account)
      && ($field = field_info_field($field_name))
      && field_info_instance($entity_type, $field_name, $bundle)
      && field_access('view', $field, $entity_type, $entity, $account)
      && field_access('edit', $field, $entity_type, $entity, $account);
}

/**
 * Implements hook_field_widget_settings_form().
 *
 * Setup a form to be able to decide which type of contents can be referenced
 * on this field.
 */
function universal_reference_field_widget_settings_form($field, $instance) {
  $widget = $instance['widget'];
  $defaults = field_info_widget_settings($widget['type']);
  $settings = array_merge($defaults, $widget['settings']);

  $form = array();
  $form['autocomplete_match'] = array(
    '#type' => 'select',
    '#title' => t('Autocomplete matching'),
    '#default_value' => $settings['autocomplete_match'],
    '#options' => array(
      'starts_with' => t('Starts with'),
      'contains' => t('Contains'),
    ),
    '#description' => t('Select the method used to collect autocomplete suggestions. Note that <em>Contains</em> can cause performance issues on sites with thousands of nodes.'),
  );
  $form['size'] = array(
    '#type' => 'textfield',
    '#title' => t('Size of textfield'),
    '#default_value' => $settings['size'],
    '#element_validate' => array('_element_validate_integer_positive'),
    '#required' => TRUE,
  );

  return $form;
}

/**
 * Implements hook_field_settings_form().
 */
function universal_reference_field_settings_form($field, $instance, $has_data) {
  $settings = $field['settings'];

  if (!isset($settings['referenceable_types'])) {
    $settings['referenceable_types'] = array();
  }

  $form = array();
  $form['referenceable_types'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Content types that can be referenced'),
    '#multiple' => TRUE,
    '#default_value' => $settings['referenceable_types'],
    '#options' => array_map('check_plain', node_type_get_names()),
  );

  return $form;
}

/**
 * Retrieves an array of candidate referenceable nodes.
 *
 * This info is used in various places (allowed values, autocomplete
 * results, input validation...). Some of them only need the nids,
 * others nid + titles, others yet nid + titles + rendered row (for
 * display in widgets).
 *
 * The array we return contains all the potentially needed information,
 * and lets consumers use the parts they actually need.
 *
 * @param array $field
 *   The field definition.
 * @param array $options
 *   An array of options to limit the scope of the returned list. The following
 *   key/value pairs are accepted:
 *   - string: string to filter titles on (used by autocomplete).
 *   - match: operator to match the above string against, can be any of:
 *     'contains', 'equals', 'starts_with'. Defaults to 'contains'.
 *   - ids: array of specific node ids to lookup.
 *   - limit: maximum size of the the result set. Defaults to 0 (no limit).
 *
 * @return array
 *   An array of valid nodes in the form:
 *   array(
 *     nid => array(
 *       'title' => The node title,
 *       'rendered' => The text to display in widgets (can be HTML)
 *     ),
 *     ...
 *   )
 */
function universal_reference_potential_references($field, $options = array()) {
  // Fill in default options.
  $options += array(
    'string' => '',
    'match' => 'contains',
    'ids' => array(),
    'limit' => 0,
  );

  $results = &drupal_static(__FUNCTION__, array());

  // Create unique id for static cache.
  $cid = $field['field_name'] . ':' . $options['match'] . ':'
      . ($options['string'] !== '' ? $options['string'] : implode('-', $options['ids']))
      . ':' . $options['limit'];
  if (!isset($results[$cid])) {
    $references = FALSE;

    if ($references === FALSE) {
      $references = _universal_reference_potential_references_standard($field, $options);
    }

    // Store the results.
    $results[$cid] = !empty($references) ? $references : array();
  }

  return $results[$cid];
}

/**
 * Helper function for universal_reference_potential_references().
 *
 * List of referenceable nodes defined by content types.
 */
function _universal_reference_potential_references_standard($field, $options) {
  // Avoid useless work.
  if (!count($field['settings']['referenceable_types'])) {
    return array();
  }

  $query = db_select('node', 'n');
  $node_nid_alias = $query->addField('n', 'nid');
  $node_title_alias = $query->addField('n', 'title', 'node_title');
  $node_type_alias = $query->addField('n', 'type', 'node_type');
  $query->addTag('node_access')
      ->addMetaData('id', '_universal_reference_potential_references_standard')
      ->addMetaData('field', $field)
      ->addMetaData('options', $options);

  if (is_array($field['settings']['referenceable_types'])) {
    $query->condition('n.type', $field['settings']['referenceable_types'], 'IN');
  }

  if ($options['string'] !== '') {
    switch ($options['match']) {
      case 'contains':
        $query->condition('n.title', '%' . $options['string'] . '%', 'LIKE');
        break;

      case 'starts_with':
        $query->condition('n.title', $options['string'] . '%', 'LIKE');
        break;

      case 'equals':
      default:
        // No match type or incorrect match type: use "=".
        $query->condition('n.title', $options['string']);
        break;
    }
  }

  if ($options['ids']) {
    $query->condition('n.nid', $options['ids'], 'IN');
  }

  if ($options['limit']) {
    $query->range(0, $options['limit']);
  }

  $query
      ->orderBy($node_title_alias)
      ->orderBy($node_type_alias);

  $result = $query->execute()->fetchAll();
  $references = array();
  foreach ($result as $node) {
    $references[$node->nid] = array(
      'title' => $node->node_title,
      'rendered' => check_plain($node->node_title),
    );
  }
  return $references;
}

/**
 * Menu callback for the autocomplete results.
 *
 * This is the callback we are using in the universal_reference_menu() function.
 * Takes our selected entites and returns a JSON response for the autocomplete.
 */
function universal_reference_autocomplete($entity_type, $bundle, $field_name, $string = '') {
  $protocol = &drupal_static(__FUNCTION__);

  if (!isset($protocol)) {
    $allowed_protocols = variable_get('filter_allowed_protocols', array(
      'ftp',
      'http',
      'https',
      'irc',
      'mailto',
      'news',
      'nntp',
      'rtsp',
      'sftp',
      'ssh',
      'tel',
      'telnet',
      'webcal',
    ));
    // Starting a parenthesis group with (?: means that it is grouped, but is
    // not captured.
    $protocol = '((?:' . implode('|', $allowed_protocols) . '):\/\/)';
  }

  // Return if value is an URL.
  if (preg_match('/^' . $protocol . '.*$/', $string)) {
    return drupal_json_output(array());
  }
  $field = field_info_field($field_name);
  $instance = field_info_instance($entity_type, $field_name, $bundle);

  $options = array(
    'string' => $string,
    'match' => $instance['widget']['settings']['autocomplete_match'],
    'limit' => 10,
  );
  $references = universal_reference_potential_references($field, $options);

  $matches = array();
  foreach ($references as $id => $row) {
    // Markup is fine in autocompletion results (might happen when rendered
    // through Views) but we want to remove hyperlinks.
    $suggestion = preg_replace('/<a href="([^<]*)">([^<]*)<\/a>/', '$2', $row['rendered']);
    // Add a class wrapper for a few required CSS overrides.
    $matches[$row['title'] . " [nid:$id]"] = '<div class="reference-autocomplete">' . $suggestion . '</div>';
  }

  drupal_json_output($matches);
}

/**
 * Value callback for a universal_reference autocomplete element.
 *
 * Replace the node nid with a node title.
 */
function universal_reference_autocomplete_value($element, $input, $form_state) {
  $protocol = &drupal_static(__FUNCTION__);

  if (!isset($protocol)) {
    $allowed_protocols = variable_get('filter_allowed_protocols', array(
      'ftp',
      'http',
      'https',
      'irc',
      'mailto',
      'news',
      'nntp',
      'rtsp',
      'sftp',
      'ssh',
      'tel',
      'telnet',
      'webcal',
    ));
    // Starting a parenthesis group with (?: means that it is grouped, but is
    // not captured.
    $protocol = '((?:' . implode('|', $allowed_protocols) . '):\/\/)';
  }

  if ($input === FALSE) {
    // We're building the displayed 'default value': expand the raw nid into
    // "node title [nid:n]".
    $nid = $element['#default_value'];
    if (!empty($nid)) {

      if (!is_numeric($nid) && preg_match('/^' . $protocol . '.*$/', $nid)) {
        $value = $nid;
      }
      else {
        $query = db_select('node', 'n');
        $node_title_alias = $query->addField('n', 'title');
        $query->addTag('node_access')
              ->condition('n.nid', $nid)
              ->range(0, 1);
        $result = $query->execute();
        // @todo If no result (node doesn't exist or no access).
        $value = $result->fetchField();
        $value .= ' [nid:' . $nid . ']';
      }
      return $value;
    }
  }
}

/**
 * Validation callback for a universal_reference autocomplete element.
 */
function universal_reference_autocomplete_validate($element, &$form_state, $form) {
  $protocol = &drupal_static(__FUNCTION__);

  if (!isset($protocol)) {
    $allowed_protocols = variable_get('filter_allowed_protocols', array(
      'ftp',
      'http',
      'https',
      'irc',
      'mailto',
      'news',
      'nntp',
      'rtsp',
      'sftp',
      'ssh',
      'tel',
      'telnet',
      'webcal',
    ));
    // Starting a parenthesis group with (?: means that it is grouped, but is
    // not captured.
    $protocol = '((?:' . implode('|', $allowed_protocols) . '):\/\/)';
  }

  $field = field_widget_field($element, $form_state);
  $instance = field_widget_instance($element, $form_state);

  $value = $element['#value'];
  $nid = NULL;

  if (!empty($value)) {
    if (preg_match('/^' . $protocol . '.*$/', $value)) {
      $nid = $value;
    }
    else {

      // Check whether we have an explicit "[nid:n]" input.
      preg_match('/^(?:\s*|(.*) )?\[\s*nid\s*:\s*(\d+)\s*\]$/', $value, $matches);
      if (!empty($matches)) {
        // Explicit nid. Check that the 'title' part matches the actual title
        // for the nid.
        list(, $title, $nid) = $matches;
        if (!empty($title)) {
          $real_title = db_select('node', 'n')
              ->fields('n', array('title'))
              ->condition('n.nid', $nid)
              ->execute()
              ->fetchField();
          if (trim($title) != trim($real_title)) {
            form_error($element, t('%name: title mismatch. Please check your selection.', array('%name' => $instance['label'])));
          }
        }
      }
      else {
        // No explicit nid (the submitted value was not populated by
        // autocomplete selection). Get the nid of a referencable node from the
        // entered title.
        $options = array(
          'string' => $value,
          'match' => 'equals',
          'limit' => 1,
        );
        $references = universal_reference_potential_references($field, $options);
        if ($references) {
          // @todo The best thing would be to present the user with an
          // additional form, allowing the user to choose between valid
          // candidates with the same title. ATM, we pick the first
          // matching candidate...
          $nid = key($references);
        }
        else {
          form_error($element, t('%name: found no valid post with that title.', array('%name' => $instance['label'])));
        }
      }
    }
  }

  // Set the element's value as the node id that was extracted from the entered
  // input.
  form_set_value($element, $nid, $form_state);
}

/**
 * Implements hook__field_info().
 *
 * Initialize the universal reference to be used as a field when creating
 * content types.
 */
function universal_reference_field_info() {
  return array(
    // We name our field as the associative name of the array.
    'universal_reference' => array(
      'label' => t('Universal reference'),
      'description' => t('Makes a reference to another node or an external URL.'),
      'default_widget' => 'title_and_reference',
      'default_formatter' => 'link_with_title',
      // For entity API wrappers.
      'property_type' => 'universal_reference',
      'property_callbacks' => array('universal_reference_property_info_callback'),
    ),
  );
}

/**
 * Callback to alter the property info of universal_reference fields.
 *
 * Largely nicked from geofield.module.
 *
 * @see universal_reference_field_info()
 */
function universal_reference_property_info_callback(&$info, $entity_type, $field, $instance, $field_type) {
  $name = $field['field_name'];
  $property = &$info[$entity_type]['bundles'][$instance['bundle']]['properties'][$name];

  $property['type'] = ($field['cardinality'] != 1) ? 'list<universal_reference>' : 'universal_reference';
  $property['getter callback'] = 'entity_metadata_field_verbatim_get';
  $property['setter callback'] = 'entity_metadata_field_verbatim_set';

  $property['property info'] = array(
    'nid' => array(
      'label' => 'Node id',
      'type' => 'integer',
      'description' => t('Node id of universal reference field'),
      'getter callback' => 'entity_property_verbatim_get',
      'setter callback' => 'entity_property_verbatim_set',
    ),
    'url' => array(
      'label' => 'URL',
      'type' => 'string',
      'description' => t('URL of universal reference field'),
      'getter callback' => 'entity_property_verbatim_get',
      'setter callback' => 'entity_property_verbatim_set',
    ),
    'title' => array(
      'label' => 'Title',
      'type' => 'string',
      'description' => t('Title of universal reference field'),
      'getter callback' => 'entity_property_verbatim_get',
      'setter callback' => 'entity_property_verbatim_set',
    ),
  );

  unset($property['query callback']);
}

/**
 * Implements hook_field_presave().
 *
 * Check if we are saving a node reference or URL.
 */
function universal_reference_field_presave($entity_type, $entity, $field, $instance, $langcode, &$items) {
  $protocol = &drupal_static(__FUNCTION__);

  if (!isset($protocol)) {
    $allowed_protocols = variable_get('filter_allowed_protocols', array(
      'ftp',
      'http',
      'https',
      'irc',
      'mailto',
      'news',
      'nntp',
      'rtsp',
      'sftp',
      'ssh',
      'tel',
      'telnet',
      'webcal',
    ));
    // Starting a parenthesis group with (?: means that it is grouped, but is
    // not captured.
    $protocol = '((?:' . implode('|', $allowed_protocols) . '):\/\/)';
  }

  foreach ($items as &$item) {
    if (!is_numeric($item['nid'])) {
      if (preg_match('/^' . $protocol . '.*$/', $item['nid'])) {
        $item['url'] = $item['nid'];
      }
      $item['nid'] = NULL;
    }
  }
}

/**
 * Implements hook_field_is_empty().
 *
 * Part of the field functioniality to check when field is empty.
 */
function universal_reference_field_is_empty($item, $field) {
  return empty($item['nid']) && empty($item['url']);
}

/**
 * Implements hook_field_formatter_info().
 *
 * Initialize a field formatter for our universal reference field.
 */
function universal_reference_field_formatter_info() {
  return array(
    // This formatter just displays the hex value in the color indicated.
    'link_with_title' => array(
      'label' => t('Link with title as text'),
      'field types' => array('universal_reference'),
    ),
  );
}

/**
 * Implements hook_field_prepare_view().
 *
 * Prepare the view and check access and if items are published and can be shown
 * at current time.
 */
function universal_reference_field_prepare_view($entity_type, $entities, $field, $instances, $langcode, &$items) {
  $checked_ids = &drupal_static(__FUNCTION__, array());

  // Set an 'access' property on each item (TRUE if the node exists and is
  // accessible by the current user.
  // Extract ids to check.
  $ids = array();
  foreach ($items as $id => $entity_items) {
    foreach ($entity_items as $delta => $item) {
      if (is_array($item)) {
        // Default to 'not accessible'.
        $items[$id][$delta]['access'] = FALSE;
        if (!empty($item['nid']) && is_numeric($item['nid'])) {
          $ids[$item['nid']] = $item['nid'];
        }
      }
    }
  }
  if ($ids) {
    // Load information about ids that we haven't already loaded during this
    // page request.
    $ids_to_check = array_diff($ids, array_keys($checked_ids));
    if (!empty($ids_to_check)) {
      $query = db_select('node', 'n')
          ->fields('n', array('nid'))
          ->addTag('node_access');
      $condition = db_and()
          ->condition('n.nid', $ids_to_check, 'IN')
          ->condition('n.status', NODE_PUBLISHED);
      // Take the 'view own unpublished content' permission into account to
      // decide whether unpublished nodes should be hidden.
      if (!user_access('administer nodes') && !user_access('bypass node access')) {
        if (user_access('view own unpublished content') && $own_unpublished = db_query('SELECT nid FROM {node} WHERE uid = :uid AND status = :status', array(':uid' => $GLOBALS['user']->uid, ':status' => NODE_NOT_PUBLISHED))->fetchCol()) {
          // (n.nid IN (nodes) AND n.status = 1) OR n.nid = (unpublished).
          $condition = db_or()
              ->condition($condition)
              ->condition('n.nid', $own_unpublished, 'IN');
        }
      }
      $query->condition($condition);

      $accessible_ids = $query->execute()->fetchAllAssoc('nid');

      // Populate our static list so that we do not query on those ids again.
      foreach ($ids_to_check as $id) {
        $checked_ids[$id] = isset($accessible_ids[$id]);
      }
    }

    foreach ($items as $id => $entity_items) {
      foreach ($entity_items as $delta => $item) {
        if (is_array($item) && !empty($item['nid']) && !empty($checked_ids[$item['nid']])) {
          $items[$id][$delta]['access'] = TRUE;
        }
      }
    }
  }
}

/**
 * Implements hook_field_formatter_prepare_view().
 *
 * Preload all nodes referenced by items using 'full entity' formatters.
 */
function universal_reference_field_formatter_prepare_view($entity_type, $entities, $field, $instances, $langcode, &$items, $displays) {
  // Load the referenced nodes, except for the 'universal_reference_nid'
  // which does not need full objects.
  // Collect ids to load.
  $ids = array();
  foreach ($displays as $id => $display) {
    foreach ($items[$id] as $delta => $item) {
      if ($item['access']) {
        $ids[$item['nid']] = $item['nid'];
      }
    }
  }
  $entities = node_load_multiple($ids);

  // Add the loaded nodes to the items.
  foreach ($displays as $id => $display) {
    foreach ($items[$id] as $delta => $item) {
      if ($item['access']) {
        $items[$id][$delta]['node'] = $entities[$item['nid']];
      }
    }
  }
}

/**
 * Implements hook_field_formatter_view().
 *
 * Format the view result array for proper HTML.
 */
function universal_reference_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $result = array();

  switch ($display['type']) {
    // This formatter simply outputs the field as text and with a color.
    case 'link_with_title':
      foreach ($items as $delta => $item) {
        // Only show external links or nodes that are accessible.
        if ($item['access'] || !empty($item['url'])) {
          if (isset($item['node'])) {
            $node = $item['node'];
            $label = entity_label('node', $node);
            $uri = entity_uri('node', $node);
            $url = $uri['path'];
            $class = array('internal-reference');
          }
          else {
            $url = $item['url'];
            $label = $item['url'];
            $class = array('external-reference');
          }
          $result[$delta] = array(
            '#type' => 'link',
            '#title' => !empty($item['title']) ? $item['title'] : $label,
            '#href' => $url,
            '#attributes' => array('class' => $class),
          );
        }
      }
  }

  return $result;
}

/**
 * Implements hook_field_widget_info().
 *
 * Initialize the widget that will be available for the field.
 */
function universal_reference_field_widget_info() {
  return array(
    'title_and_reference' => array(
      'label' => t('URL or node title'),
      'field types' => array('universal_reference'),
      'settings' => array(
        'autocomplete_match' => 'contains',
        'size' => 60,
        'autocomplete_path' => 'universal_reference/autocomplete',
      ),
    ),
  );
}

/**
 * Implements hook_field_widget_form().
 *
 * The actual field-form that is shown when the field are used on a node form.
 */
function universal_reference_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {

  $value_title = isset($items[$delta]['title']) ? $items[$delta]['title'] : NULL;

  if (isset($items[$delta]['nid'])) {
    $value_nid = $items[$delta]['nid'];
  }
  elseif (isset($items[$delta]['url'])) {
    $value_nid = $items[$delta]['url'];
  }
  else {
    $value_nid = NULL;
  }

  $widget = $element;

  switch ($instance['widget']['type']) {
    case 'title_and_reference':
      $element['nid'] = array(
        '#type' => 'textfield',
        '#title' => t('Node title or URL'),
        '#maxlength' => '2048',
        '#default_value' => $value_nid,
        '#description' => t('Type a part of the node title and select the result, or enter an external URL'),
        '#autocomplete_path' => $instance['widget']['settings']['autocomplete_path'] . '/' . $instance['entity_type'] . '/' . $instance['bundle'] . '/' . $field['field_name'],
        '#element_validate' => array('universal_reference_autocomplete_validate'),
        '#value_callback' => 'universal_reference_autocomplete_value',
        '#weight' => -5,
      ) + $widget;
      $element['title'] = array(
        '#type' => 'textfield',
        '#title' => t('Title'),
        '#default_value' => $value_title,
        '#maxlength' => '128',
        '#description' => t('Optional title. If no title has been set, the node title or raw URL will be shown'),
        '#weight' => 5,
      ) + $widget;

      $element['url'] = array(
        '#type' => 'value',
        '#value' => '',
      );

      break;
  }
  return $element;
}

/**
 * Implements hook_field_widget_error().
 *
 * Add error to the form when field data fails.
 */
function universal_reference_field_widget_error($element, $error, $form, &$form_state) {
  switch ($error['error']) {
    case 'field_example_invalid':
      form_error($element, $error['message']);
      break;
  }
}

/**
 * Implements hook_field_schema().
 *
 * Database setting schema for the universal field.
 */
function universal_reference_field_schema($field) {
  $columns = array(
    'nid' => array(
      'type' => 'int',
      'unsigned' => TRUE,
      'not null' => FALSE,
    ),
    'url' => array(
      'type' => 'varchar',
      // Maximum URLs length.
      'length' => 2048,
      'not null' => FALSE,
      'sortable' => TRUE,
    ),
    'title' => array(
      'type' => 'varchar',
      'length' => 255,
      'not null' => FALSE,
      'sortable' => TRUE,
    ),
  );
  return array(
    'columns' => $columns,
    'indexes' => array('nid' => array('nid')),
    'foreign keys' => array(
      'nid' => array(
        'table' => 'node',
        'columns' => array('nid' => 'nid'),
      ),
    ),
  );
}
