<?php

/**
 * Module file for the Past DB module.
 */

/**
 * Implements hook_entity_info()
 */
function past_db_entity_info() {
  $info['past_event'] = array(
    'label' => t('Past Event'),
    'module' => 'past_db',
    'fieldable' => TRUE,
    'controller class' => 'PastEventController',
    'metadata controller class' => 'PastDBEventMetadataController',
    'views controller class' => 'PastDBEventViewsController',
    'entity class' => 'PastEvent',
    'base table' => 'past_event',
    'uri callback' => 'entity_class_uri',
    'label callback' => 'entity_class_label',
    'access callback' => 'past_db_access',
    'entity keys' => array(
      'id' => 'event_id',
      'bundle' => 'type',
    ),
    'bundle keys' => array(
      'bundle' => 'type',
    ),
    'bundles' => array(),
    'admin ui' => array(
      'controller class' => 'PastDBEventUIController',
      'path' => 'admin/reports/past',
      'menu wildcard' => '%entity_object',
    ),
  );

  // Add bundle info but bypass entity_load() as we cannot use it here.
  $types = db_select('past_event_type', 'p')
      ->fields('p')
      ->execute()
      ->fetchAllAssoc('type');

  foreach ($types as $type => $bundle) {
    $info['past_event']['bundles'][$type] = array(
      'label' => $bundle->label,
      'admin' => array(
        'path' => 'admin/config/development/past-types/manage/%past_event_type',
        'real path' => 'admin/config/development/past-types/manage/' . $type,
        'bundle argument' => 5,
        'access arguments' => array('administer past'),
      ),
    );
  }

  $info['past_event_argument'] = array(
    'label' => t('Past Event Argument'),
    'module' => 'past_db',
    'controller class' => 'PastEventArgumentController',
    'metadata controller class' => 'PastDBEventArgumentMetadataController',
    'entity class' => 'PastEventArgument',
    'base table' => 'past_event_argument',
    'uri callback' => 'entity_class_uri',
    'label callback' => 'entity_class_label',
    'access callback' => 'past_db_access',
    'entity keys' => array(
      'id' => 'argument_id',
    ),
  );

   $info['past_event_data'] = array(
     'label' => t('Past Event Data'),
     'module' => 'past_db',
     'controller class' => 'EntityAPIController',
     'metadata controller class' => 'PastDBEventDataMetadataController',
     'entity class' => 'PastEventData',
     'base table' => 'past_event_data',
     'uri callback' => 'entity_class_uri',
     'label callback' => 'entity_class_label',
     'access callback' => 'past_db_access',
     'entity keys' => array(
       'id' => 'data_id',
     ),
   );

  $info['past_event_type'] = array(
    'label' => t('Past Event type'),
    'plural label' => t('Past Event types'),
    //'description' => t('Past Event types.'),
    'entity class' => 'PastEventType',
    'controller class' => 'EntityAPIControllerExportable',
    'base table' => 'past_event_type',
    'fieldable' => FALSE,
    'bundle of' => 'past_event',
    'exportable' => TRUE,
    'entity keys' => array(
      'id' => 'id',
      'name' => 'type',
      'label' => 'label',
    ),
    'access callback' => 'past_event_type_access',
    'module' => 'past_db',
    // Enable the entity API's admin UI.
    'admin ui' => array(
      'path' => 'admin/config/development/past-types',
      'file' => 'past_db.admin.inc',
      'file path' => drupal_get_path('module', 'past_db'),
      'controller class' => 'PastEventTypeUIController',
    ),
  );

  return $info;
}

/**
 * Menu argument loader; Load a event type by string.
 *
 * @param $type
 *   The machine-readable name of a event type to load.
 *
 * @return array
 *   A event type array or FALSE if $type does not exist.
 */
function past_event_type_load($type) {
  return past_event_get_types($type);
}

/**
 * Creates past event type entity.
 *
 * @param string $type
 *   Event type.
 * @param string $label
 *   Event type label.
 * @param array $values
 *   Additional event type values.
 *
 * @return PastEventType
 */
function past_event_type_create($type, $label, $values = array()) {
  $values['type'] = $type;
  $values['label'] = $label;
  return entity_create('past_event_type', $values);
}

/**
 * Gets an array of all past event types, keyed by the type name.
 *
 * @param $type_name
 *   If set, the type with the given name is returned.
 *
 * @return PastEventType[]
 *   Depending whether $type isset, an array of past event types or a single one.
 */
function past_event_get_types($type_name = NULL) {
  $types = entity_load_multiple_by_name('past_event_type', isset($type_name) ? array($type_name) : FALSE);
  return isset($type_name) ? reset($types) : $types;
}

/**
 * Access callback for the entity API.
 */
function past_event_type_access($op, $type = NULL, $account = NULL) {
  return user_access('administer past', $account);
}

/**
 * Access callback implementation.
 * @param $operation
 *   The performed operation - view, delete, create, update, customs...
 * @param $entity
 *   (optional) The entity on which $operation should be performed.
 * @param $account
 *   (optional) The account to check if it has access.
 * @return boolean
 *    TRUE if $account can perform $operation on $entity
 */
function past_db_access($op, $entity = NULL, $account = NULL) {
  return user_access('administer past', $account);
}

/**
 * Implements hook_cron().
 */
function past_db_cron() {
  // Check if expiration is enabled.
  if ($expire = variable_get('past_events_expire', 0)) {
    // Fetch up to 100 past events to delete, delete oldest first.
    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'past_event');
    $query->propertyCondition('timestamp', REQUEST_TIME - $expire, '<');
    $query->propertyOrderBy('timestamp');
    $query->range(0, 100);
    $result = $query->execute();
    if ($result) {
      entity_delete_multiple('past_event', array_keys($result['past_event']));
    }
  }
}

/**
 * Implements views arguments details.
 * defined in PastDBEventUIController::hook_menu().
 */
function past_db_event_view($event) {
  return entity_view($event->entityType(), array($event), 'full', NULL, TRUE);
}

function past_db_form_views_exposed_form_alter(&$form, $form_state, $form_id) {
  $form['reset'] = array(
    '#type' => 'markup',
    '#weight' => 1000,
    '#markup' => '<input '. drupal_attributes(array('type' => 'reset', 'value' => t('Reset') )) .' class="form-submit" onClick="javascript:jQuery(this.form).find(\':input\').each(function(){if(this.type==\'text\' || this.type==\'select-multiple\' || this.type==\'select\'){jQuery(this).val(\'\');this.setAttribute(\'value\',\'\');}});this.form.submit();" />',
  );
}

/**
 * Implements hook_views_api().
 */
function past_db_views_api() {
  return array(
    'api' => 3,
    'template path' => drupal_get_path('module', 'past_db') . '/themes',
  );
}

/**
 * Implements hook_preprocess_HOOK().
 *
 * Display a view as a table style.
 */
function past_db_preprocess_views_view_table(&$vars) {
  // Do this only for the Past views.
  if (strpos($vars['view']->name, 'past_event_log') === FALSE) {
    return;
  }
  past_db_add_row_colors($vars);
}

/**
 * Adds severity classes to rows.
 *
 * This works only if the field past_event_severity is added to the view.
 *
 * @param $vars
 *   The variables array as passed into the theme function.
 */
function past_db_add_row_colors(&$vars) {
  // Add the corresponding class to the row.
  $class_names = past_db_severity_css_classes_map();
  foreach ($vars['rows'] as $num => $row) {
    if (isset($vars['result'][$num]->past_event_severity) && !empty($class_names[$vars['result'][$num]->past_event_severity])) {
      $vars['row_classes'][$num][] = $class_names[$vars['result'][$num]->past_event_severity];
    }
  }
  // Add the CSS.
  drupal_add_css(drupal_get_path('module', 'past_db') . '/past_db.css');
}

/**
 * Getter for the severity css classes.
 *
 * @return array
 *   The map of severities to css classes.
 */
function past_db_severity_css_classes_map() {
  return array(
    PAST_SEVERITY_DEBUG => 'past-debug',
    PAST_SEVERITY_INFO => 'past-info',
    PAST_SEVERITY_NOTICE => 'past-notice',
    PAST_SEVERITY_WARNING => 'past-warning',
    PAST_SEVERITY_ERROR => 'past-error',
    PAST_SEVERITY_EMERGENCY => 'past-emergency',
    PAST_SEVERITY_ALERT => 'past-alert',
    PAST_SEVERITY_CRITICAL => 'past-critical',
  );
}

/**
 * Implements hook_entity_insert().
 */
function past_db_entity_past_event_type_insert($entity) {
  field_attach_create_bundle('past_event', $entity->type);
}

/**
 * Implements hook_entity_update().
 */
function past_db_entity_past_event_type_update($entity) {
  if ($entity->type != $entity->original->type) {
    field_attach_rename_bundle('past_event', $entity->original->type, $entity->type);
  }
}

/**
 * Implements hook_entity_delete().
 */
function past_db_entity_past_event_type_delete($entity) {
  field_attach_delete_bundle('past_event', $entity->type);
}

/**
 * Implements hook_field_extra_fields().
 */
function past_db_field_extra_fields() {
  $extra = array();

  $info = entity_get_info('past_event');
  foreach ($info['bundles'] as $key => $bundle) {
    $extra['past_event'][$key] = array(
      'display' => array(
        'message' => array(
          'label' => t('Message'),
          'description' => t('The event log message.'),
          'weight' => 0,
        ),
        'module' => array(
          'label' => t('Module'),
          'description' => t('Module which triggered the event.'),
          'weight' => 1,
        ),
        'machine_name' => array(
          'label' => t('Machine name'),
          'description' => t('The event machine name.'),
          'weight' => 2,
        ),
        'timestamp' => array(
          'label' => t('Event time'),
          'description' => t('The time when the event occurred.'),
          'weight' => 3,
        ),
        'user' => array(
          'label' => t('User'),
          'description' => t('The user that triggered the event.'),
          'weight' => 4,
        ),
        'arguments' => array(
          'label' => t('Arguments'),
          'description' => t('The event arguments.'),
          'weight' => 5,
        ),
      ),
    );
  }

  return $extra;
}
