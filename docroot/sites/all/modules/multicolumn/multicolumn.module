<?php

/**
 * @file
 * A filter that generates a multi-column unordered list.
 *
 * Lines between the tags <multicolumn cols="3"> and </multicolumn> are turned
 * into 3 unordered lists, and these lists are arranged side by side.
 *
 * The module provides themeable functions theme_multicolumn_list() and
 * theme_multicolumn_row() that the designer can override. The first specifies
 * how lines are made into a list, and the default implementation returns a
 * renderable array.  The second specifies how columns are arranged into a
 * row, and the default implementation uses a <div class="..."> for each row.
 * A third function, theme_multicolumn_comment(), is used to format HTML
 * comments such as <!-- multicolumn start -->.
 */

/**
 * Implements hook_help().
 */
function multicolumn_help($path, $arg) {
  if ($path == 'admin/help#multicolumn') {
    $output = '';
    $output .= '<p>' . t('A filter that generates a multi-column unordered list.') . '</p>';
    $output .= '<p>' . t('Lines between the tags %open and %close are turned into 3 unordered lists, and these lists are arranged side by side.', array('%open' => '<multicolumn cols="3">', '%close' => '</multicolumn>')) . '</p>';
    $output .= '<p>' . t('If you use the HTML filter after this one, be sure that it allows the tags used to format the lists.  By default, the tags used are @tags, but these can be changed by the theme.', array('@tags' => 'ol, ul, li, div')) . '</p>';
    $output .= '<p>' . t('You can add the Multicolumn filter to a text format on the <a href="@formats">Text formats page</a>.  Once you have done so, detailed usage information will be available on the <a href="@tips">Filter tips</a> page.', array('@formats' => url('admin/config/content/formats'), '@tips' => url('filter/tips'))) . '</p>';
    return $output;
  }
}

/**
 * Implements hook_filter_info().
 */
function multicolumn_filter_info() {
  $filters['multicolumn'] = array(
    'title' => t('Make a multi-column list.'),
    'description' => t('Replace lines between %open and %close tags with several lists, arranged side by side.',
      array(
        '%open' => '<multicolumn>',
        '%close' => '</multicolumn>',
      )
    ),
    'prepare callback' => '_multicolumn_multicolumn_prepare',
    'process callback' => '_multicolumn_multicolumn_process',
    'tips callback' => '_multicolumn_multicolumn_tips',
    'cache' => TRUE,
  );
  return $filters;
}

/**
 * Implements hook_theme().
 */
function multicolumn_theme() {
  return array(
    'multicolumn_list' => array(
      'variables' => array('items' => array(), 'columns' => 1, 'type' => 'ul', 'attributes' => array()),
    ),
    'multicolumn_row' => array(
      'variables' => array('items' => array()),
    ),
    'multicolumn_comment' => array(
      'variables' => array('text' => 'multicolumn'),
    ),
  );
}

/**
 * Multicolumn filter prepare callback
 *
 * Change the tags <multicolumn cols="3"> and </multicolumn> to
 * [multicolumn cols="3"] and [/multicolumn] so they will not be stripped by
 * the HTML filter (if it is enabled).
 */
function _multicolumn_multicolumn_prepare($text, $filter) {
  return preg_replace('@<(\s*/?multicolumn(\s+\w+\s*=\s*"\s*\w+\s*")*\s*)>@i',
    '[\1]', $text);
}

/**
 * Multicolumn filter process callback
 *
 * Generate a multi-column list from
 * [multicolumn cols="3"]
 * // lines ...
 * [/multicolumn]
 */
function _multicolumn_multicolumn_process($text, $filter) {
  // Split into chunks at the opening and closing "tags".
  $tagpattern = '@(\[\s*/?multicolumn(?:\s+\w+\s*=\s*"\w+")*\s*\])@i';
  $tagopen = '@^\[\s*multicolumn(\s+\w+\s*=\s*"\w+")*\s*\]@i';
  $tagclose = '@^\[\s*/multicolumn\s*\]@i';
  $chunks = preg_split($tagpattern, $text, -1, PREG_SPLIT_DELIM_CAPTURE);
  // Note: PHP ensures the array consists of alternating delimiters and
  // literals and begins and ends with a literal (inserting NULL as required).
  if (count($chunks) == 1) {
    return $text;
  }

  // In the foreach loop, $columns is set to a positive integer when an opening
  // tag is found, then reset to 0 when a closing tag is found.
  $columns = 0;
  foreach ($chunks as $i => $chunk) {
    if (preg_match($tagopen, $chunk)) {
      // I love this combination of preg_match_all() and array_combine()!
      // It turns 'attr="val"' into array('attr' => 'val').
      // Since the matches are of the form \w+, I do not think I have to
      // sanitize them (e.g., with check_plain()).
      $attributes
        = preg_match_all('/(\w+)\s*=\s*"(\w+)\s*"/', $chunk, $matches)
        ? array_combine($matches[1], $matches[2]) : array();
      $columns = (isset($attributes['cols'])) ? intval($attributes['cols']) : 1;
      unset($attributes['cols']);
      // Mark the start of a multicolumn section.
      $chunks[$i] = theme('multicolumn_comment',
        array('text' => t('multicolumn start')));
    }
    elseif (preg_match($tagclose, $chunk)) {
      $columns = 0;
      // Mark the end of a multicolumn section.
      $chunks[$i] = theme('multicolumn_comment',
        array('text' => t('multicolumn end')));
    }
    elseif ($columns > 0) {
      // $columns and $attributes were defined while processing the opening tag.
      // Start building the render element to pass to the theme function.
      $variables = array('#theme' => 'multicolumn_list', '#columns' => $columns);
      if (isset($attributes['type'])) {
        $variables['#type'] = $attributes['type'];
        unset($attributes['type']);
      }
      else {
        $variables['#type'] = 'ul';
      }
      // We removed 'cols' and 'type' from $attributes.  Pass whatever is left
      // to the theme function.
      $variables['#attributes'] = $attributes;
      // $rows = preg_split('/\n/', trim($chunk));
      $rows = explode("\n", $chunk);
      // If (as usual) there are newlines after the opening tag and before the
      // closing tag, remove the blank entries.
      if ($item = array_pop($rows)) {
        $rows[] = $item;
      }
      if ($item = array_shift($rows)) {
        array_unshift($rows, $item);
      }
      // Each entry in $cells will be the render element for one column.
      $cells = array();
      for ($j = 0; $columns > 0; --$columns) {
        // For ordered lists, do not start each at 1.
        // The start attribute is deprecated in HTML 4.01, supported in 5:
        // http://www.w3schools.com/html5/tag_ol.asp .
        if ($variables['#type'] == 'ol') {
          $variables['#attributes']['start'] = $j + 1;
        }
        // Calculate how many rows to use for this column.
        $delta = ceil((count($rows) - $j) / $columns);
        $cells[] = $variables
          + array('#items' => array_slice($rows, $j, $delta));
        $j += $delta;
      }
      $chunks[$i] = theme('multicolumn_row', array('items' => $cells));
      // Done processing until the next opening tag.
      $columns = 0;
    }
  }

  $text = implode("\n", $chunks);
  return trim($text);
}

/**
 * Filter tips callback for Multicolumn filter.
 */
function _multicolumn_multicolumn_tips($filter, $format, $long = FALSE) {
  $output = t('Generate a multi-column list with the %tag tag.',
    array('%tag' => '<multicolumn>'));
  if (!$long) {
    return $output;
  }

  $output = '<p>' . $output . '</p>';
  $output .= '<p>' . t('Start a multi-column list with %start and end it with %end.  The 3 is just for the sake of example.  This will create 3 unordered lists and place them side by side.  One list item will be created for each line between the start and end tags, so do not add %li nor %endli tags yourself.  In addition to %cols, you can specify %type to be one of %types.',
    array(
      '%start' => '<multicolumn cols="3">',
      '%end' => '</multicolumn>',
      '%li' => '<li>',
      '%endli' => '</li>',
      '%cols' => 'cols',
      '%type' => 'type',
      '%types' => "'ul', 'ol', 'plain'",
  )) . '</p>';
  $output .= '<p>' . t('Any other attributes in the multicolumn tag will be passed to the lists that make up each column, unless a custom theme function changes this behavior.  Attributes and their values should contain only alphanumeric characters and underscores.') . '</p>';
  return $output;
}

/**
 * Theme function that formats a list for one column of a multicolumn.
 *
 * @param array $variables
 *   An associative array containing:
 *   - items:  An array of items in the list.
 *   - columns:  The number of columns, of which this will be one.
 *   - type:  The type of the list (e.g., "ul" or "ol").
 *   - attributes: An array of attributes to be added to the outer element.
 */
function theme_multicolumn_list($variables) {
  // Tweak the attributes.
  $attributes = $variables['attributes'];
  $width = floor(100 / $variables['columns']);
  // Make sure $attributes['style'] is set.
  $attributes += array('style' => '');
  $attributes['style'] = "width: $width%;" . $attributes['style'];

  // Tweak the type.
  $type = $variables['type'];
  if ($type == 'plain') {
    // Add a class.  multicolumn.css contains corresponding CSS rules.
    // First, make sure $attributes['class'] is set.
    $attributes += array('class' => '');
    $attributes['class'] = rtrim('plain ' . $attributes['class']);
  }
  if ($type != 'ol') {
    // Convert 'plain' or anything strange to 'ul'.
    $type = 'ul';
  }

  // Build the output string.
  $output = "<$type" . drupal_attributes($attributes) . '>';
  $items = $variables['items'];
  if (!empty($items)) {
    $output .= '<li>' . implode('</li><li>', $items) . '</li>';
  }
  $output .= "</$type>";
  return $output;
}

/**
 * Theme function that formats columns into a multicolumn.
 *
 * @param array $variables
 *   An associative array containing:
 *   - items:  An array of render elements, one for each column.
 */
function theme_multicolumn_row($variables) {
  $columns = count($variables['items']);
  $class = "multicolumn multicolumn-$columns";
  $variables['items'] = array_map('render', $variables['items']);
  return '<div class="' . $class . '">' .
    implode('', $variables['items']) . '</div>';
}

/**
 * Theme function that formats HTML comments for multicolumn.
 *
 * @param array $variables
 *   An associative array containing:
 *   - text:  a string to be added as an HTML comment.
 *
 * It will not hurt if your theme's version of this function simply returns ''.
 */
function theme_multicolumn_comment($variables) {
  return '<!-- ' . $variables['text'] . ' -->';
}
