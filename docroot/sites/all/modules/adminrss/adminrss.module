<?php
/**
 * @file
 * Creator: James Blake <james at webgeer dot com>
 *
 * Drupal 5, 6 and 7 versions: Frederic G. MARAND <fgm at osinet dot fr>
 *
 * Enables one to view pending items (node, comments, ...) using an RSS reader.
 *
 * This module was made a lot easier for me (webgeer) by both adminblock.module
 * and commentrss.module. Thanks to both Fredrik Jonsson and Gabor Hojtsy.
 *
 * @link http://drupal.org/project/adminblock
 * @link http://drupal.org/project/commentrss
 *
 * @since DRUPAL-4-6
 * @license General Public License version 2.0 and later
 */

// Bring in constants.
require_once __DIR__ . '/adminrss_data.inc';

// Bring in surrogate hook implementations.
require_once __DIR__ . '/modules/adminrss.node.inc';
require_once __DIR__ . '/modules/adminrss.comment.inc';

/**
 * Form builder for settings form.
 */
function adminrss_admin_settings() {
  $key = variable_get(ADMINRSS_VAR_KEY, '');

  // Settings form is a good place to reset the implementations cache.
  $feeds_info = adminrss_get_feed_info(TRUE);

  $form = array();
  $form[ADMINRSS_VAR_KEY] = array(
    '#type'          => 'textfield',
    '#title'         => t('Admin RSS Key'),
    '#required'      => TRUE,
    '#description'   => t('This is the key that will be required in order to get access to the admin RSS feeds.'),
    '#size'          => 50,
    '#maxlength'     => 255,
    '#default_value' => $key,
    '#weight'        => -5,
  );

  if (!empty($key)) {
    $form['feeds'] = array(
      '#type'        => 'fieldset',
      '#title'       => t('Admin RSS Feeds locations'),
      '#description' => t('Copy and paste these links to your RSS aggregator.'),
    );
    $items = array();
    foreach ($feeds_info as $name => $info) {
      $items[] = l($info['label'], adminrss_get_feed_path($name), array('absolute' => TRUE));
    }

    $form['feeds']['links'] = array(
      '#theme' => 'item_list',
      '#items' => $items,
    );
  }

  // Inject per-feed settings.
  foreach ($feeds_info as $name => $info) {
    if (!empty($info['configure'])) {
      $hook = "adminrss_feed_settings_{$name}";
      $form["{$name}-settings"] = array(
        '#type' => 'fieldset',
        '#title' => $info['label'],
      ) + module_invoke_all($hook);
    }
  }

  return system_settings_form($form);
}

/**
 * Implements hook_help().
 */
function adminrss_help($path, $arg) {
  switch ($path) {
    case 'admin/help#adminrss':
      $types = implode(', ', array_map(function ($info) {
        return $info['label'];
      }, adminrss_get_feed_info()));
      $ret = t('Provide an RSS feed for unapproved items: %types.', array('%types' => $types));
      break;

    default:
      $ret = NULL;
  }

  return $ret;
}

/**
 * Implements hook_menu().
 */
function adminrss_menu() {
  $type_offset = count(explode('/', ADMINRSS_PATH_HOME));

  $items[ADMINRSS_PATH_HOME . "/%adminrss_type/%"] = array(
    'title'           => 'Admin RSS Feed',
    'page callback'   => 'adminrss_page_feed',
    'page arguments'  => array($type_offset),
    'access callback' => TRUE,
    'type'            => MENU_CALLBACK,
    'load arguments' => array($type_offset + 1),
  );

  $items[ADMINRSS_PATH_SETTINGS] = array(
    'title'            => 'Admin RSS Feeds',
    'description'      => 'Configure access to the Admin RSS feeds.',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('adminrss_admin_settings'),
    'access arguments' => array('administer site configuration'),
  );

  return $items;
}

/**
 * Menu loader for %adminrss_type and key.
 *
 * @param string $type
 *   Entity type.
 * @param string $key
 *   The secret key configured in the module settings to access these feeds.
 *
 * @return string|bool
 *   Return the feed building function if it exists and access is granted by the
 *   key, FALSE otherwise.
 */
function adminrss_type_load($type, $key) {
  $valid_types = array_keys(adminrss_get_feed_info());
  $builder = "adminrss_feed_$type";

  $key_check = $key == variable_get(ADMINRSS_VAR_KEY, '');
  $type_check = in_array($type, $valid_types);
  $builder_check = function_exists($builder);

  $ret = ($key_check && $type_check && $builder_check) ? $builder : FALSE;
  return $ret;
}

/**
 * Page callback for admin RSS feeds.
 *
 * Access control and type validity is performed by the menu loader, so there is
 * no acces or existence check to perform.
 *
 * @param string $feed_builder
 *   The name of the actual feed building function.
 *
 * @return mixed
 *   Feed builders are supposed to return on their own and exit, but they could
 *   return.
 */
function adminrss_page_feed($feed_builder) {
  return $feed_builder();
}

/**
 * Builds and outputs a RSS feed.
 *
 * @see node_feed()
 *
 * @param array $items
 *   An array of feed items in memory format.
 * @param array $channel
 *   An array of channel metadata.
 *
 * @return void
 *   Builder emits data and does not return any content.
 */
function adminrss_format_feed($items, $channel = array()) {
  global $base_url;

  $channel_defaults = array(
    'version'     => '2.0',
    'title'       => t('@site - AdminRSS Feed', array('@site' => variable_get('site_name', 'drupal'))),
    'link'        => $base_url,
    'description' => t('Items'),
    'language'    => language_default('language'),
  );
  $channel_extras = array_diff_key($channel, $channel_defaults);
  $channel = array_merge($channel_defaults, $channel);
  $cooked_channel = format_rss_channel($channel['title'], $channel['link'], $channel['description'], $items, $channel['language'], $channel_extras);
  $ret = <<<EOT
<!DOCTYPE rss [<!ENTITY % HTMLlat1 PUBLIC "-//W3C//ENTITIES Latin 1 for XHTML//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent">]>
<rss version="{$channel["version"]}" xml:base="{$base_url}"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:dc="http://purl.org/dc/elements/1.1/">
  $cooked_channel
  </rss>
EOT;

  drupal_add_http_header('Content-Type', 'application/rss+xml; charset=utf-8');
  print $ret;
}

/**
 * Return information about existing Admin RSS feeds.
 *
 * @param bool $reset
 *   Reset the implementation cache ?
 *
 * @return array
 *   A machine-name-indexed hash of feed information.
 *     - only ony key: "configure", boolean: expose a configuration form.
 */
function adminrss_get_feed_info($reset = FALSE) {
  if ($reset) {
    cache_clear_all(ADMINRSS_CID, 'cache');
    $cached = FALSE;
  }
  else {
    $cached = cache_get(ADMINRSS_CID);
  }

  if ($cached === FALSE) {
    $info = module_invoke_all('adminrss_feed_info');
    cache_set(ADMINRSS_CID, $info);
  }
  else {
    $info = $cached->data;
  }
  return $info;
}

/**
 * Return the path for a given feed.
 *
 * @param string $name
 *   Machine name of the feed.
 *
 * @return string
 *   Internal path to the feed, secret key included in plain sight.
 */
function adminrss_get_feed_path($name) {
  $key = variable_get(ADMINRSS_VAR_KEY, '');
  $feeds_info = adminrss_get_feed_info();
  $info = $feeds_info[$name];
  $ret = ADMINRSS_PATH_HOME . "/$name/$key";
  return $ret;
}

/**
 * Implements hook_adminrss_feed_info().
 */
function adminrss_adminrss_feed_info() {
  $ret = array(
    'comment' => array(
      'configure' => TRUE,
      'label' => t('Comments approval queue'),
    ),
    'node' => array(
      // 'configure' defaults to FALSE.
      'label' => t('Nodes feed'),
    ),
  );

  return $ret;
}
