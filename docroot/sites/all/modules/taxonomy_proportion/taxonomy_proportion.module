<?php
/**
 * @file
 * Main module file
 */


// Include the field element.
module_load_include('inc', 'taxonomy_proportion', 'taxonomy_proportion.field');

/**
 * Implements hook_menu().
 */
function taxonomy_proportion_menu() {
  $items['taxonomy-proportion/autocomplete'] = array(
    'title' => 'Autocomplete taxonomy proportion',
    'page callback' => 'taxonomy_proportion_autocomplete',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Submit handler for the "add-one-more" button.
 */
function taxonomy_proportion_add_more_add_one($form, &$form_state) {

  $button = $form_state['triggering_element'];

  // Go one level up in the form, to the widgets container.
  $element = drupal_array_get_nested_value($form, array_slice($button['#array_parents'], 0, -1));
  $field_name = $element['#field_name'];
  $langcode = $element['#language'];
  $parents = $element['#field_parents'];

  // Increment the items count.
  $field_state = field_form_get_state($parents, $field_name, $langcode, $form_state);
  $field_state['items_count']++;
  field_form_set_state($parents, $field_name, $langcode, $form_state, $field_state);

  $form_state['rebuild'] = TRUE;
}

/**
 * Callback for both ajax-enabled buttons.
 *
 * Selects and returns the fieldset with the names in it.
 */
function taxonomy_proportion_add_more_callback_js($form, $form_state) {
  $field_name = $form_state['triggering_element']['#parents'][0];
  return $form[$field_name][LANGUAGE_NONE];
}

/**
 * Implements hook_entity_insert().
 */
function taxonomy_proportion_entity_insert($entity, $type) {
  taxonomy_proportion_attach_terms($entity, $type);
}

/**
 * Implements hook_entity_update().
 */
function taxonomy_proportion_entity_update($entity, $type){
  taxonomy_proportion_attach_terms($entity, $type);
}

/**
 * Implements hook_entity_delete().
 */
function taxonomy_proportion_entity_delete($entity, $type) {
  taxonomy_proportion_attach_terms($entity, $type, TRUE);
}

/**
 * Update taxonomy_index table.
 *
 * @TODO remove items form taxonomy_index when field or content type is deleted... if needed
 *
 * @param string $node
 *   The node with taxonomy proportion field.
 *
 * @param boolean $delete
 *   The node action.
 */
function taxonomy_proportion_attach_terms($entity, $type, $delete = FALSE) {
  if (isset($entity->taxonomy_proportion)) {
    db_query("delete taxonomy_index from taxonomy_index inner join taxonomy_term_data using(tid) where
         nid = :nid and vid = :vid", array(
        ':nid' => $entity->nid,
        ':vid' => $entity->taxonomy_proportion['vid']
    ));

    if (!$delete) {
      $tids = field_get_items($type, $entity, $entity->taxonomy_proportion['field_name']);
      $query = db_insert('taxonomy_index')->fields(array(
        'nid', 'tid', 'sticky', 'created'
      ));

      foreach ($tids as $tid ) {
        $query->values(array(
          'nid' => $entity->nid,
          'tid' => $tid['tid'],
          'sticky' => $entity->sticky,
          'created' => $entity->created
        ));
      }
      $query->execute();
    }
  }
}

/**
 * Override the core taxonomy_autocomplete function.
 *
 */
function taxonomy_proportion_autocomplete($field_name = '', $tags_typed = '') {
  // If the request has a '/' in the search text, then the menu system will have
  // split it into multiple arguments, recover the intended $tags_typed.
  $args = func_get_args();
  // Shift off the $field_name argument.
  array_shift($args);
  $tags_typed = implode('/', $args);

  // Make sure the field exists and is a taxonomy_proportion field.
  if (!($field = field_info_field($field_name)) || $field['type'] !== 'taxonomy_proportion') {
    // Error string. The JavaScript handler will realize this is not JSON and
    // will display it as debugging information.
    print t('Taxonomy field @field_name not found.', array('@field_name' => $field_name));
    exit;
  }

  // The user enters a comma-separated list of tags. We only autocomplete the last tag.
  $tags_typed = drupal_explode_tags($tags_typed);
  $tag_last = drupal_strtolower(array_pop($tags_typed));

  $term_matches = array();
  if ($tag_last != '') {
    // Part of the criteria for the query come from the field's own settings.
    $vids = array();
    $vocabularies = taxonomy_vocabulary_get_names();
    foreach ($field['settings']['allowed_values'] as $tree) {
      $vids[] = $vocabularies[$tree['vocabulary']]->vid;
    }

    $query = db_select('taxonomy_term_data', 't');
    $query->addTag('translatable');
    $query->addTag('term_access');

    // Do not select already entered terms.
    if (!empty($tags_typed)) {
      $query->condition('t.name', $tags_typed, 'NOT IN');
    }
    // Select rows that match by term name.
    $tags_return = $query
      ->fields('t', array('tid', 'name'))
      ->condition('t.vid', $vids)
      ->condition('t.name', '%' . db_like($tag_last) . '%', 'LIKE')
      ->range(0, 10)
      ->execute()
      ->fetchAllKeyed();

    $prefix = count($tags_typed) ? drupal_implode_tags($tags_typed) . ', ' : '';

    foreach ($tags_return as $tid => $name) {
      $n = $name;
      // Term names containing commas or quotes must be wrapped in quotes.
      if (strpos($name, ',') !== FALSE || strpos($name, '"') !== FALSE) {
        $n = '"' . str_replace('"', '""', $name) . '"';
      }
      $term_matches[$prefix . $n] = check_plain($name);
    }
  }

 drupal_json_output($term_matches);
}

/**
 * Implements hook_theme().
 */
function taxonomy_proportion_theme() {
  return array(
    'taxonomy_proportion_termlink' => array(
      'variables' => array(
        'tid' => NULL,
        'term_name' => NULL,
        'proportion' => NULL,
        'field_prefix' => NULL,
        'field_suffix' => NULL,
        'field_location' => NULL
        )
    ),

    'taxonomy_proportion_form_field' => array(
      'render element' => 'element'
    ),

    'taxonomy_proportion_formelement' => array(
      'render element' => 'element'
    ),
    'taxonomy_proportion_multiple_checkboxes' => array(
      'render element' => 'element'
    ),
    'taxonomy_proportion_autocomplete' => array(
      'render element' => 'element'
    ),
  );
}

/**
 * Returns wrapper HTML for autocomplete widget.
 *
 * @param $variables
 *   An associative array containing:
 *   - element: the widget
 *
 * @ingroup themeable
 */
function theme_taxonomy_proportion_autocomplete($vars) {
  $element = $vars['element'];

  $output =  '<div id="names-fieldset-wrapper">';
  $output .= theme('form_element_label', $element);
  $output .= drupal_render_children($element);
  if (!empty($element['#description'])) {
    $output .= '<div class="description">'.t($element['#description']).'</div>';
  }
  $output .= '</div>';

  return $output;
}

/**
 * Returns wrapper HTML for multiple checkboxes widget.
 *
 * @param $variables
 *   An associative array containing:
 *   - element: the widget
 *
 * @ingroup themeable
 */
function theme_taxonomy_proportion_multiple_checkboxes($vars) {
  $element = $vars['element'];

  $output = theme('form_element_label', $element) . '<div class="form-checkboxes">';
  $output .= drupal_render_children($element);
  $output .= '</div>';
  if (!empty($element['#description'])) {
    $output .= '<div class="description">'.t($element['#description']).'</div>';
  }

  return $output;
}

/**
 * Returns HTML to display term + proportion.
 *
 * @param $variables
 *   An associative array containing:
 *   - field_prefix: as defined in the widget settings.
 *   - field_suffix: as defined in the widget settings.
 *   - term_name: the name of the term.
 *   - proportion: the weight of the term.
 *   - field_location: proprotion displayed before or after the term.
 *
 * @ingroup themeable
 */
function theme_taxonomy_proportion_termlink($vars) {
  $lbl_prefix = !empty ($vars ['field_prefix']) ? ' <span class="prefix">' . $vars['field_prefix'] . '</span>' : '';
  $lbl_suffix = !empty ($vars ['field_suffix']) ? '<span class="sufix">' . $vars['field_suffix'] . '</span>' : '';
  $term_link = l($vars['term_name'], 'taxonomy/term/' . $vars['tid']);
  $proportion = '';
  if (!empty($vars['proportion'])) $proportion = $lbl_prefix . '<span class="proportion">' . $vars['proportion'] . '</span>' . $lbl_suffix;

  return $vars['field_location'] == 'before' ? $proportion . ' ' . $term_link : $term_link . ' ' . $proportion;
}

/**
 * Returns wrapper HTML for the form field item.
 *
 * @param $variables
 *   An associative array containing:
 *   - element: the widget
 *
 * @ingroup themeable
 */
function theme_taxonomy_proportion_form_field($vars) {
  $element = $vars['element'];

  // Override default theme to remove div wrapper.
  $element['tid']['#theme_wrappers'][0] = 'taxonomy_proportion_formelement';
  $element['proportion']['#theme_wrappers'][0] = 'taxonomy_proportion_formelement';

  $output = '<div class="proportion_wrapper">';
  $output .= drupal_render_children($element);
  $output .= '</div>';

  return $output;
}

/**
 * Returns HTML to display field widget term + proportion.
 *
 * @param $variables
 *   An associative array containing:
 *   - field_prefix: as defined in the widget settings.
 *   - field_suffix: as defined in the widget settings.
 *   - fstate: for checkbox if checked the proportion field must be shown
 *
 * @ingroup themeable
 */
function theme_taxonomy_proportion_formelement($vars) {
  $element = $vars['element'];

  $output = '';
  $visibility = isset($element['#fstate']) ? $element['#fstate'] : '';
  $elmt = !empty($element['#children']) ? $element['#children'] : theme('textfield', $vars);

  $prefix = !empty ( $element ['#field_prefix'] ) ? '<span class="field-prefix">' . $element['#field_prefix'] . '</span> ' : '';
  $suffix = !empty ( $element ['#field_suffix'] ) ? ' <span class="field-sufix">' . $element['#field_suffix'] . '</span>' : '';
  $output .= ' <span class="form-proportion-' . $element['#type'] . ' ' . $visibility . '">' . $prefix . $elmt . $suffix . '</span>';
  $output .= ' ' . theme('form_element_label', $vars) . "\n";

  return $output;
}
