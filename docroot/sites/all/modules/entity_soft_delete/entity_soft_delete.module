<?php

/**
 * Global Flags.
 */
define('ENTITY_SOFT_DELETE_SOFT_DELETE', 1);
define('ENTITY_SOFT_DELETE_UNDELETE', 2);

// @todo: using entity_soft_delete.rdf for backwards compatibility with 6.x-1.x, but it would be nice to be able to define this on a site-by-site basis using variables.
define('ENTITY_SOFT_DELETE_FEED_PATH', 'entity_soft_delete.rdf');
define('ENTITY_SOFT_DELETE_NAMESPACE', 'http://drupal.org/project/entity_soft_delete/rdf#');

/**
 * Implements hook_help().
 */
function entity_soft_delete_help($path, $arg = NULL) {
  if (cf_is_empty_or_non_string('path', $path, WATCHDOG_ERROR)) {
    return;
  }

  switch ($path) {
    case 'admin/help#entity_soft_delete':
      $help = "Provides a entity_soft_delete or trash-bin functionality for drupal node content.";
      $help .= " Entity soft delete can be enabled/disabled on a per content type basis.";
      $help .= " Integrates with views api, such as filtering out entity_soft_delete nodes from a view.";
      $help .= " Integrates with rules api, such as having a given node be auto-deleted after some given amount of time.";
      $help .= " Integrates with token api, providing tokens for different entity_soft_delete variables.";

      return "<p>" . t($help) . "</p>";
  }
}

/**
 * Implements hook_permission().
 */
function entity_soft_delete_permission() {
  $perms = array();

  $perms['access soft deleted content'] = array(
    'title' => t("Access Soft deleted Content"),
    'description' => t("Specify whether or not soft deleted content may be accessed by some user or role."),
  );

  $perms['bypass soft deleted content'] = array(
    'title' => t("Bypass Soft deleted Content"),
    'description' => t("Grant the user or role the ability to bypass the entity_soft_delete and permanently delete a node."),
  );

  $perms['undelete soft deleted content'] = array(
    'title' => t("Undelete Soft deleted Content"),
    'description' => t("Specify whether or not soft deleted content may be undeleted by some user or role."),
  );

  $perms['access entity_soft_delete feed'] = array(
    'title' => t("Access Soft deleted Feed"),
    'description' => t("Specify whether or not soft deleted feed '%feed_path' may be accessed by some user or role.", array('%feed_path' => ENTITY_SOFT_DELETE_FEED_PATH)),
  );

  return $perms;
}

/**
 * Implements hook_admin_paths().
 */
function entity_soft_delete_admin_paths() {
  $paths = array(
    'node/*/undelete' => TRUE,
  );

  return $paths;
}

/**
 * Implements hook_menu().
 */
function entity_soft_delete_menu() {
  $items = array();

  $items['node/%node/undelete'] = array(
    'title' => "Undelete",
    'page callback' => 'drupal_get_form',
    'page arguments' => array('entity_soft_delete_unentity_soft_delete_form', 1),
    'access callback' => 'entity_soft_delete_can_undelete',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'file' => 'unentity_soft_delete.inc',
    'file path' => drupal_get_path('module', 'entity_soft_delete') . '/includes',
  );

  $items[ENTITY_SOFT_DELETE_FEED_PATH] = array(
    'page callback' => 'entity_soft_delete_feed_page',
    'access callback' => 'user_access',
    'access arguments' => array('access entity_soft_delete feed'),
    'type' => MENU_CALLBACK,
    'file' => 'feeds.inc',
    'file path' => drupal_get_path('module', 'entity_soft_delete') . '/includes',
  );

  $items['admin/config/content/entity_soft_delete'] = array(
    'title' => 'Entity soft delete Settings',
    //'type' => MENU_NORMAL_ITEM,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('entity_soft_delete_settings_form'),
    'access arguments' => array('administer entity_soft_delete'),
  );

  return $items;
}

/**
 * Page callback for entity_soft_delete.
 */
function entity_soft_delete_settings_form($form, $form_state) {
  $form = array();
  $entity_bundles = variable_get('entity_soft_delete_entity_bundles_settings');

  $form['additional_settings'] = array(
    '#type' => 'vertical_tabs',
    /*
    '#attached' => array(
        'js' => array(
            'vertical-tabs' => drupal_get_path('module', 'entity_soft_delete') . '/vertical_tabs.admin.js',
        ),
    ),
    */
  );

  $form['entitites'] = array(
    '#type' => 'item',
    '#title' => t('Entities'),
    //'#collapsible' => FALSE,
    //'#group' => 'additional_settings',
    //'#tree' => TRUE,
    '#weight' => -1,
    '#description' => t('Config the entities that need soft delete feature'),
  );

  $entity_types = _entity_soft_delete_entity_types();
  //dsm($entity_types);
  foreach ($entity_types as $entity_type => $entity_type_info) {
    if ($entity_type != 'comment')
      foreach ($entity_type_info['bundles'] as $bundle => $bundle_info) {
        $form['entity_bundles']['entity_bundles_' . $entity_type . '|' . $bundle] = array(
          '#type' => 'fieldset',
          '#title' => t($entity_type_info['label'] . ' -> ' . $bundle_info['label']),
          '#collapsible' => FALSE,
          '#group' => 'additional_settings',
          '#tree' => TRUE,
          /*
          '#states' => array(
              'invisible' => array(
                  // If the checkbox is not enabled, show the container.
                  'input[name="vertical_tabs_example[enabled]"]' => array('checked' => FALSE),
              ),
          ),
          */
        );
        $form['entity_bundles']['entity_bundles_' . $entity_type . '|' . $bundle]['enabled'] = array(
          '#type' => 'checkbox',
          '#title' => t("Enable soft delete for this Entity Bundle"),
          '#tree' => TRUE,
          '#default_value' => @$entity_bundles[$entity_type . '.' . $bundle]['enabled'],
        );
        $form['entity_bundles']['entity_bundles_' . $entity_type . '|' . $bundle]['unpublish_on_delete'] = array(
          '#type' => 'checkbox',
          '#title' => t("UnPublish entities when that entity is deleted"),
          '#tree' => TRUE,
          '#default_value' => @$entity_bundles[$entity_type . '.' . $bundle]['unpublish_on_delete'],
        );
        $form['entity_bundles']['entity_bundles_' . $entity_type . '|' . $bundle]['publish_on_undelete'] = array(
          '#type' => 'checkbox',
          '#title' => t("Publish entities when that entity is undeleted"),
          '#tree' => TRUE,
          '#default_value' => @$entity_bundles[$entity_type . '.' . $bundle]['publish_on_undelete'],
        );
        if ($entity_type == 'node') {
          $form['entity_bundles']['entity_bundles_' . $entity_type . '|' . $bundle]['comments_enabled'] = array(
            '#type' => 'checkbox',
            '#title' => t("Enable soft delete for comments"),
            '#tree' => TRUE,
            '#default_value' => @$entity_bundles[$entity_type . '.' . $bundle]['comments_enabled'],
          );
        }
      }
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
    '#weight' => 50,
  );

  //$form['#validate'] = 'entity_soft_delete_node_type_form_validate';
  $form['#submit'][] = 'entity_soft_delete_settings_form_submit';

  return $form;
}

/**
 * @param $form
 * @param $form_state
 */
function entity_soft_delete_settings_form_submit($form, &$form_state) {
  $entity_bundles = array();
  //$form_state['values']
  foreach ($_POST as $item_name => $item) {
    if (strpos($item_name, 'entity_bundles_') !== FALSE) {
      $entity_bundle_name = str_replace('entity_bundles_', '', $item_name);
      list($entity_type, $bundle_name) = explode('|', $entity_bundle_name);
      $entity_bundle_full_name = "{$entity_type}_$bundle_name";
      $entity_bundle_name = str_replace('|', '.', $entity_bundle_name);
      $entity_bundles[$entity_bundle_name] = array(
        'publish_on_undelete' => 0,
        'unpublish_on_delete' => 0,
        'enabled' => 0,
        'comments_enabled' => 0
      );
      $entity_bundles[$entity_bundle_name] = array_merge($entity_bundles[$entity_bundle_name], $item);
      if (@$item['comments_enabled']) {
        $entity_bundles['comment.comment_' . $entity_bundle_full_name] = array(
          'publish_on_undelete' => @$item['publish_on_undelete'],
          'unpublish_on_delete' => @$item['unpublish_on_delete'],
          'enabled' => 1,
          'comments_enabled' => 0
        );
      }
    }
  }
  drupal_set_message(t('The configuration options have been saved.'));
  variable_set('entity_soft_delete_entity_bundles_settings', $entity_bundles);
  cache_clear_all('schema', 'cache');
  entity_info_cache_clear();
  if (function_exists('views_invalidate_cache')) {
    views_invalidate_cache();
  }
  _entity_soft_delete_schema_apply_change();
}

/**
 * Implements hook_node_operations().
 */
function entity_soft_delete_node_operations() {
  $operations = array(
    'entity_soft_delete_operation_delete' => array(
      'label' => t("Soft delete selected content"),
      'callback' => 'entity_soft_delete_operation_update',
      'callback arguments' => array('updates' => array('operation' => ENTITY_SOFT_DELETE_SOFT_DELETE)),
    ),
    'entity_soft_delete_operation_undelete' => array(
      'label' => t("Un-soft-delete selected content"),
      'callback' => 'entity_soft_delete_operation_update',
      'callback arguments' => array('updates' => array('operation' => ENTITY_SOFT_DELETE_UNDELETE)),
    ),
  );

  return $operations;
}

/**
 * Implements hook_action_info().
 * @return array
 */
function entity_soft_delete_action_info() {
  return array(
    'entity_soft_delete_operation_delete' => array(
      'type' => 'entity',
      'label' => t("Soft delete selected content"),
      'configurable' => FALSE,
      //'behavior' => array('changes_property'),
      //'triggers' => array('comment_presave', 'comment_insert', 'comment_update'),
    ),
    'entity_soft_delete_operation_undelete' => array(
      'type' => 'entity',
      'label' => t("Un-entity_soft_delete selected content"),
      'configurable' => FALSE,
      //'behavior' => array('changes_property'),
      //'triggers' => array('comment_presave', 'comment_insert', 'comment_update'),
    ),
  );
}

/**
 * Implements hook_form_alter().
 */
function entity_soft_delete_form_alter(&$form, &$form_state, $form_id) {
    return entity_soft_delete_add_soft_delete_actions($form, $form_state, $form_id);
}

/**
 * Button submit function: handle the 'undelete' button on the node form.
 */
function entity_soft_delete_entity_undelete_submit($form, &$form_state) {
  $entity_info = _entity_soft_delete_entity_info_from_form($form);

  if (!is_array($form)) {
    cf_error::invalid_array('form');
    return;
  }

  if (!is_object($entity_info['entity'])) {
    cf_error::invalid_object('entity');
    return;
  }

  if (cf_is_not_form_state('form_state', $form_state)) {
    return;
  }

  if (!entity_soft_delete_can_undelete($entity_info['entity'], $entity_info['entity_type'], NULL)) {
    return;
  }

  $result = entity_soft_delete_operate_on_entities('undelete', array($entity_info['entity']), $entity_info['entity_type'], NULL);

  if ($result) {
    // redirect to if not already redirecting somewhere
    if (!isset($form_state['redirect'])) {
      if ($entity_info['redirect_path']) {
        $form_state['redirect'] = $entity_info['redirect_path'];
      }
    }

    drupal_set_message(t("This content has been undeleted."));
  } else {
    drupal_set_message(t("Failed to undelete this content."), 'error');
  }
}

/**
 * Implements hook_entity_view().
 */
function entity_soft_delete_entity_view($entity, $type, $view_mode, $langcode) {
  entity_soft_delete_entity_deleted_notice(array($entity), $type);
}

/**
 * Implements hook_entity_access().
 */
function __entity_soft_delete_entity_access($op, $entity = NULL, $account = NULL, $entity_type = NULL) {
  if (cf_is_empty_or_non_string('op', $op, WATCHDOG_ERROR)) {
    return NULL;
  }

  // when node is a string, then it does not exist and therefore cannot have been deleted
  if (is_string($entity)) {
    return NULL;
  }

  if (!is_object($entity)) {
    cf_error::invalid_object('entity');
    return NULL;
  }

  // only process deleted nodes
  if (!property_exists($entity, 'deleted') || $entity->deleted != TRUE) {
    return NULL;
  }

  // if the user is allowed to access deleted content, return ignore so that other modules can determine if the user has access to this content for other reasons
  if (user_access('access soft deleted content', $account)) {
    return NULL;
  }

  return 'deny';
}

/**
 * Implements hook_node_access().
 */
function entity_soft_delete_node_access($node, $op, $account) {
  if (cf_is_empty_or_non_string('op', $op, WATCHDOG_ERROR)) {
    return NODE_ACCESS_IGNORE;
  }

  if (!is_object($account)) {
    cf_error::invalid_object('account');
    return NODE_ACCESS_IGNORE;
  }

  // when node is a string, then it does not exist and therefore cannot have been deleted
  if (is_string($node)) {
    return NODE_ACCESS_IGNORE;
  }

  if (!is_object($node)) {
    cf_error::invalid_object('node');
    return NODE_ACCESS_IGNORE;
  }

  // only process deleted nodes
  if (!property_exists($node, 'deleted') || $node->deleted != TRUE) {
    return NODE_ACCESS_IGNORE;
  }

  // if the user is allowed to access deleted content, return ignore so that other modules can determine if the user has access to this content for other reasons
  if (user_access('access soft deleted content', $account)) {
    return NODE_ACCESS_IGNORE;
  }

  return NODE_ACCESS_DENY;
}

/**
 * Implements hook_views_api().
 */
function entity_soft_delete_views_api() {
  return array(
    'api' => 2.0,
    'path' => drupal_get_path('module', 'entity_soft_delete'),
  );
}

/**
 * Change any number of nodes.
 *
 * @param $entities_or_ids
 *   An array of node objects or node ids
 * @param $updates
 *   An array of operations to perform for each node id in the entities_or_ids parameter
 */
function entity_soft_delete_operation_update($entities_or_ids, $updates) {
  if (!is_array($updates)) {
    cf_error::invalid_array('updates');
    return;
  }

  if (!is_array($entities_or_ids)) {
    cf_error::invalid_array('entities_or_ids');
    return;
  }

  if (count($entities_or_ids) == 0) {
    return;
  }

  if (!array_key_exists('operation', $updates)) {
    cf_error::missing_array_key( 'updates', 'operation');
    return;
  }

  if ($updates['operation'] == ENTITY_SOFT_DELETE_SOFT_DELETE || $updates['operation'] == ENTITY_SOFT_DELETE_UNDELETE) {
    $nodes = array();

    foreach ($entities_or_ids as $key => $nid) {
      if (is_object($nid)) {
        $nodes[] = $nid;
        unset($entities_or_ids[$key]);
      }
    }

    if (count($entities_or_ids) > 0) {
      $nodes += node_load_multiple($entities_or_ids);
    }

    foreach ($nodes as $key => $node) {
      if (is_object($node)) {
        $node_type_settings = entity_soft_delete_get_entity_bundle_settings(array('type' => 'node', 'bundle' => $node->type));
        if (!$node_type_settings['enabled']) {
          // @todo: present some sort of watchdog message about not being able to entity_soft_delete or unentity_soft_delete a node because the content type does not have entity_soft_delete enabled
          unset($nodes[$key]);
        }
      }
    }

    $result = TRUE;

    if ($updates['operation'] == ENTITY_SOFT_DELETE_SOFT_DELETE) {
      entity_soft_delete_operate_on_entities('soft_delete', $nodes, 'node', NULL);
    } else if ($updates['operation'] == ENTITY_SOFT_DELETE_UNDELETE) {
      entity_soft_delete_operate_on_entities('undelete', $nodes, 'node', NULL);
    }

    if ($result) {
      drupal_set_message(t("The update has been performed."));
    } else {
      drupal_set_message(t("The update has failed."), 'error');
    }
  }
}

/**
 * Provides a delete submit confirmation page handles soft and hard deletes.
 *
 * @param $form
 *   A form array
 * @param $form_state
 *   A form state
 */
function entity_soft_delete_entity_delete_confirm_submit($form, &$form_state) {
  if (!is_array($form)) {
    cf_error::invalid_array('form');
    return;
  }

  if (cf_is_not_form_state('form_state', $form_state)) {
    return;
  }

  $entity_info = _entity_soft_delete_entity_info_from_form($form, $form_state);

  $redirect_to = '<front>';

  if (!empty($entity_info['delete_confirmed'])) {
    if (user_access('bypass soft deleted content') && !empty($form_state['values']['permanent'])) {
      entity_soft_delete_operate_on_entities('permanent_delete', array($entity_info['entity']), $entity_info['entity_type'], NULL);
    } else {
      entity_soft_delete_operate_on_entities('soft_delete', array($entity_info['entity']), $entity_info['entity_type'], NULL);

      // redirect to the front only if the user does not have view access on soft deleted content
      if (user_access('access soft deleted content')) {
        $redirect_to = $entity_info['view_path'];
      }
    }
  }

  $form_state['redirect'] = $redirect_to;
}

/**
 * Loads the node type settings table data for the given node type.
 *
 * @param $node_types
 *   An array of node type strings or node objects
 *
 * @return
 *   A prepared statement object, already executed.
 */
function entity_soft_delete_get_entity_bundle_settings(array $entity_bundle) {
  if (!is_array($entity_bundle)) {
    cf_error::invalid_array('entity_bundle');
    return array();
  }

  if (count($entity_bundle) == 0) {
    return array();
  }

  $entity_bundles_settings = variable_get('entity_soft_delete_entity_bundles_settings');

  $result = array();

  if (isset($entity_bundles_settings[$entity_bundle['type'] . '.' . $entity_bundle['bundle']])) {
    $result = $entity_bundles_settings[$entity_bundle['type'] . '.' . $entity_bundle['bundle']];
  } else {
    $result['enabled'] = FALSE;
  }

  return $result;
}

/**
 * Loads the soft deleted node settings table data for the given node ids or nodes.
 *
 * @param $entities_or_ids
 *   An array of node objects or node ids
 *
 * @return
 *   An array of node delete settings.
 */
function entity_soft_delete_get_entity_delete_settings($entities_or_ids, $entity_type) {
  if (!is_array($entities_or_ids)) {
    cf_error::invalid_array('entities_or_ids');
    return array();
  }

  if (count($entities_or_ids) == 0) {
    return array();
  }

  $results = array();
  foreach ($entities_or_ids as $entity_or_id) {
    $contain_info = FALSE;
    $is_deleted = FALSE;

    if (is_object($entity_or_id)) {
      if (property_exists($entity_or_id, 'deleted')) {
        $contain_info = TRUE;
      }
    } else {
      $entity_or_id = entity_load($entity_type, array($entity_or_id));
    }
    if (property_exists($entity_or_id, 'deleted')) {
      list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity_or_id);
      if ($entity_or_id->deleted) {
        $is_deleted = TRUE;
        $item = array(
          'id' => $id
        );
        $results[] = (object)$item;
      }
    }
  }

  return $results;
}

/**
 * If the given node has been soft deleted, then print a message to the screen.
 *
 * @param $node
 *   A node object
 */
function entity_soft_delete_entity_deleted_notice(array $entities, $entity_type) {
  if (!is_array($entities)) {
    cf_error::invalid_array('entity');
    return;
  }

  foreach ($entities as $entity) {
    if (property_exists($entity, 'deleted') && $entity->deleted != FALSE) {
      list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);

      $entity_title = $id;
      if (property_exists($entity, 'title')) {
        $entity_title = isset($entity->title) ? $entity->title : '';
      }

      if (property_exists($entity, 'deleted')) {
        $formatted_date = format_date($entity->deletion_timestamp, 'short');
      } else {
        $formatted_date = '';
      }
      if (property_exists($entity, 'deletion_uid')) {
        $account = user_load($entity->deletion_uid);
      }

      if (is_object($account)) {
        $username = $account->name;
      } else {
        $username = '';
      }

      drupal_set_message(t("The @type '@title' has been deleted on @date by @user.", array('@type' => $bundle, '@title' => $entity_title, '@date' => $formatted_date, '@user' => $username)), 'warning', FALSE);
    }
  }
}

/**
 * @param $action
 * @param $entities_or_ids
 * @param $entity_type
 * @param null $account
 */
function entity_soft_delete_operate_on_entities($action, $entities_or_ids, $entity_type, $account = NULL) {
  if (empty($action)) {
    cf_error::empty_string('action');
    return FALSE;
  }
  if (!is_array($entities_or_ids)) {
    cf_error::invalid_array('entities_or_ids');
    return FALSE;
  }
  if (empty($entity_type)) {
    cf_error::empty_string('entity_type');
    return FALSE;
  }

  $results = array();
  $ids = array();

  if (!is_object($account)) {
    $acting_user = cf_current_user(FALSE);
  } else {
    $acting_user = $account;
  }

  $entity_bundles_settings = variable_get('entity_soft_delete_entity_bundles_settings');

  $transaction = db_transaction();

  try {
    foreach ($entities_or_ids as $key => $entity_or_id) {
      if (is_object($entity_or_id)) {
        $entity = $entity_or_id;
      } else if (is_numeric($entity_or_id)) {
        $entity = entity_load($entity_type, $entity_or_id);

        if (!is_object($entity)) {
          cf_error::invalid_object('entity');
          $results[$key] = FALSE;
          continue;
        }
      } else {
        cf_error::invalid_variable('entity_or_id', "Must be either a entity object or a number");
        $results[$key] = FALSE;
        continue;
      }


      list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);
      $ids[] = $id;


      if ($action == 'permanent_delete') {
        $results[$key] = TRUE;
      }

      // Make sure the entity is not already soft deleted
      $setting_results = entity_soft_delete_get_entity_delete_settings(array($entity), $entity_type);

      if ($action == 'soft_delete') {
        if (count($setting_results) > 0) {
          $results[$key] = TRUE;
          continue;
        }

        // first unpublish the node
        $entity_bundle_settings = entity_soft_delete_get_entity_bundle_settings(array('type' => $entity_type, 'bundle' => $bundle));
        if (property_exists($entity, 'status')) {
            if ($entity_bundle_settings['unpublish_on_delete']) {
                $entity->status = NODE_NOT_PUBLISHED;
            }
        }
        if (!is_null($vid)) {
          $entity->revision = TRUE;
        }
        $entity->log = t("Deleted by %username.", array('%username' => $acting_user->name));

        // last register the node as soft deleted
        $record = array();
        $record['id'] = $id;
        $record['title'] = $vid;
        $record['vid'] = $vid;
        $record['entity_type'] = $entity_type;
        $record['entity_bundle'] = $bundle;
        $record['uid'] = $acting_user->uid;
        $record['timestamp'] = time();
        if (property_exists($entity, 'title')) {
          $record['title'] = $entity->title;
        }

        $entity->deleted = TRUE;
        $entity->deletion_uid = $record['uid'];
        $entity->deletion_timestamp = $record['timestamp'];

        entity_save($entity_type, $entity);

        $results[$key] = drupal_write_record('entity_soft_delete_entities', $record);

        if ($results[$key]) {
          if (module_exists('rules')) {
            rules_invoke_event('entity_soft_delete_after_deleting', $entity, $entity_type);
          }
        }
      }

      if ($action == 'undelete') {
        if (count($setting_results) == 0) {
          $results[$key] = TRUE;
          continue;
        }

        // publish if necessary
        $entity_bundle_settings = entity_soft_delete_get_entity_bundle_settings(array('type' => $entity_type, 'bundle' => $bundle));
        if ($entity_bundle_settings['publish_on_undelete']) {
          if (property_exists($entity, 'status')) {
            $entity->status = NODE_PUBLISHED;
          }
        }

        // make sure a record of this undelete exists
        if (!is_null($vid)) {
          $entity->revision = TRUE;
        }
        $entity->log = t("Undeleted by %username.", array('%username' => $acting_user->name));
        $entity->deleted = FALSE;
        $entity->deletion_uid = $acting_user->uid;
        $entity->deletion_timestamp = time();

        entity_save($entity_type, $entity);

        $results[$key] = db_delete('entity_soft_delete_entities')
            ->condition('id', $id)
            ->condition('entity_type', $entity_type)
            ->execute();

        if (module_exists('rules')) {
          rules_invoke_event('entity_soft_delete_after_undeleting', $entity, $entity_type);
        }
      }
    }

    if ($action == 'permanent_delete') {
      db_delete('entity_soft_delete_entities')
          ->condition('id', $ids, 'IN')
          ->condition('entity_type', $entity_type)
          ->execute();

      entity_delete_multiple($entity_type, $ids);

      // force transaction to execute
      unset($transaction);
    }

  } catch (Exception $e) {
    $transaction->rollback();
    watchdog_exception('entity_soft_delete', $e);
    throw $e;
  }

  return $results;
}

/**
 * Returns TRUE if entity_soft_delete functionality is enabled for the given entity bundle.
 *
 * @param $entity_bundle
 *   A entity type string
 *
 * @return
 *   TRUE or FALSE depending on whether or not entity_soft_delete functionality is enabled for the given node type.
 */
function entity_soft_delete_is_enabled(array $entity_bundle) {

  //if (cf_is_empty_or_non_string('entity_bundle', $entity_bundle)){
  //  return FALSE;
  //}

  $entity_bundle_settings = entity_soft_delete_get_entity_bundle_settings($entity_bundle);
  if ($entity_bundle_settings['enabled'] == TRUE) {
    return TRUE;
  }

  return FALSE;
}

/**
 * This returns TRUE or FALSE depending on whether or not a user can undelete content.
 *
 * There are two possible approaches here:
 *   The first is to allow undelete if the user has node update permissions.
 *   The second is to allow undelete if the user has node delete permissions.
 *
 * The function chooses the second approach to allow roles to exist such that a role has no update permissions but can delete/undelete content.
 *
 * @param $entities_or_ids
 *   An array of entity objects or entity ids
 * @param $account
 *   (optional) A user object of the user who is performing this operation
 *
 * @return
 *   TRUE or FALSE depending on whether or not a user can undelete content.
 */
function entity_soft_delete_can_undelete($entity, $entity_type = NULL, $account = NULL) {
  if (!is_object($entity)) {
    cf_error::invalid_object('entity');
    return FALSE;
  }

  return (entity_access('delete', $entity_type, $entity, $account) && user_access('undelete soft deleted content', $account));
}

/**
 * Implements hook_schema_alter().
 *
 * @param $schema
 *   The system-wide schema
 */
function entity_soft_delete_schema_alter(&$schema) {
  $entity_types = _entity_soft_delete_entity_types();
  foreach ($entity_types as $entity_type => $entity_type_info) {
    if (isset($entity_type_info['integrated']) && $entity_type_info['integrated']) {
      $schema[$entity_type_info['base table']]['fields']['deleted'] = array(
        'description' => 'Content deletion status.',
        'type' => 'int',
        'not null' => TRUE,
        'default' => 0,
      );
      $schema[$entity_type_info['base table']]['fields']['deletion_uid'] = array(
        'description' => 'The use whom deleted the content.',
        'type' => 'int',
        'not null' => FALSE,
        'default' => NULL,
      );
      $schema[$entity_type_info['base table']]['fields']['deletion_timestamp'] = array(
        'description' => 'Content deletion time.',
        'type' => 'int',
        'not null' => FALSE,
        'default' => NULL,
      );
    }
  }
}

/**
 * @param $info
 */
function entity_soft_delete_entity_property_info_alter(&$info) {
  $entity_types = _entity_soft_delete_entity_types();
  foreach ($entity_types as $entity_type => $entity_type_info) {
    if (isset($entity_type_info['integrated']) && $entity_type_info['integrated']) {
      $properties = &$info[$entity_type];
      $properties['properties']['deleted'] = array(
        'label' => t('Deleted'),
        'type' => 'integer',
        'description' => t('Content deletion status'),
        // This is the schema field you made.
        'schema field' => 'deleted',
        'getter callback' => 'entity_property_verbatim_get',
        'setter callback' => 'entity_property_verbatim_set',
      );
      $properties['properties']['deletion_uid'] = array(
        'label' => t('Deleted By'),
        'type' => 'integer',
        'description' => 'The use whom deleted the content.',
        // This is the schema field you made.
        'schema field' => 'deletion_uid',
        'getter callback' => 'entity_property_verbatim_get',
        'setter callback' => 'entity_property_verbatim_set',
      );
      $properties['properties']['deletion_timestamp'] = array(
        'label' => t('Delete time'),
        'type' => 'integer',
        'description' => t('Content deletion time.'),
        // This is the schema field you made.
        'schema field' => 'deletion_timestamp',
        'getter callback' => 'entity_property_verbatim_get',
        'setter callback' => 'entity_property_verbatim_set',
      );
    }
  }
}

/**
 * Implement hook_entity_info_alter
 * @param $info
 */
function  entity_soft_delete_entity_info_alter(&$info) {
  $entity_types = _entity_soft_delete_entity_types();
  foreach ($entity_types as $entity_type => $entity_type_info) {
    if ($entity_type_info['integrated']) {
      if (@$info[$entity_type]['access callback'] == 'eck__entity_access') {
        //$info[$entity_type]['access callback'] = 'entity_access';
        $info[$entity_type]['access callback'] = '__entity_soft_delete_entity_access';
      }
    }
  }
}

/**
 * @return array
 */
function _entity_soft_delete_entity_types() {
  $selected_bundles = variable_get('entity_soft_delete_entity_bundles_settings');
  $bundles = field_info_bundles();
  $entity_types = array();
  foreach ($bundles as $entity_type => $entity_type_bundles) {
    $entity_type_info = entity_get_info($entity_type);
    $entity_types[$entity_type] = $entity_type_info;
    $entity_types[$entity_type]['bundles'] = $entity_type_bundles;
    $integrated = FALSE;
    if (is_array($entity_type_bundles))
    foreach ($entity_type_bundles as $bundle => $bundle_info) {
      $entity_types[$entity_type]['bundles'][$bundle]['integrated'] = FALSE;
      if (isset($selected_bundles[$entity_type . '.' . $bundle]) && !empty($bundle_info))
        if ($selected_bundles[$entity_type . '.' . $bundle]['enabled'] == TRUE) {
          $entity_types[$entity_type]['bundles'][$bundle]['integrated'] = TRUE;
          $integrated = TRUE;
        }
    }
    $entity_types[$entity_type]['integrated'] = $integrated;
  }
  return $entity_types;
}

/**
 *
 */
function _entity_soft_delete_schema_apply_change($remove = FALSE) {
  $entity_types = _entity_soft_delete_entity_types();

  foreach ($entity_types as $entity_type => $entity_type_info) {
    if ($entity_type_info['integrated']) {
      if (!db_field_exists($entity_type_info['base table'], 'deleted')) {
        db_add_field($entity_type_info['base table'], 'deleted', array('type' => 'int', 'length' => 1, 'not null' => TRUE, 'default' => 0));
      }
      if (!db_field_exists($entity_type_info['base table'], 'deletion_uid')) {
        db_add_field($entity_type_info['base table'], 'deletion_uid', array('type' => 'int', 'length' => 11, 'not null' => FALSE, 'default' => NULL));
      }
      if (!db_field_exists($entity_type_info['base table'], 'deletion_timestamp')) {
        db_add_field($entity_type_info['base table'], 'deletion_timestamp', array('type' => 'int', 'length' => 11, 'not null' => FALSE, 'default' => NULL));
      }
    } else {
      if ($remove) {
        if (db_field_exists($entity_type_info['base table'], 'deleted')) {
          db_drop_field($entity_type_info['base table'], 'deleted');
        }
        if (db_field_exists($entity_type_info['base table'], 'deletion_uid')) {
          db_drop_field($entity_type_info['base table'], 'deletion_uid');
        }
        if (db_field_exists($entity_type_info['base table'], 'deletion_timestamp')) {
          db_drop_field($entity_type_info['base table'], 'deletion_timestamp');
        }
      }
    }
  }
}

/**
 *
 */
function _entity_soft_delete_entity_info_from_form($form, $form_state = NULL) {
  $entity = NULL;
  $entity_id = NULL;
  $entity_title = NULL;
  $entity_type = NULL;
  $entity_bundle = NULL;
  $redirect_path = NULL;
  $view_path = NULL;
  $delete_confirmed = NULL;

  if (array_key_exists('#node', $form) || array_key_exists('entity', $form) || array_key_exists('#comment', $form)) {
    if (array_key_exists('#node', $form) && @$form['#entity_type'] != 'comment') {
      $entity = $form['#node'];
      if (is_object($entity)) {
        if (property_exists($entity, 'nid')) {
          $entity_id = $entity->nid;
        }
        $entity_type = 'node';
        $entity_bundle = $entity->type;
        $entity_title = $entity->title;
        if (property_exists($entity, 'uri')) {
          $redirect_path = $entity->uri['path'];
        }
        if ($entity_id) {
          $view_path = 'node/' . $entity_id;
        }

        if (@$form_state['values']['confirm'] == 1) {
          $delete_confirmed = 1;
        }
      }
    } elseif (array_key_exists('#comment', $form) || (@$form['#entity_type'] == 'comment' && $form['#entity'])) {
      $entity = @$form['#comment'] ? @$form['#comment'] : @$form['#entity'];
      if (is_object($entity)) {
        if (property_exists($entity, 'cid')) {
          $entity_id = $entity->cid;
        }
        $entity_type = 'comment';
        $entity_bundle = $entity->node_type;
        $entity_title = $entity->subject;
        if (property_exists($entity, 'uri')) {
          $redirect_path = $entity->uri['path'];
        }
        if ($entity_id) {
          $view_path = 'comment/' . $entity_id;
        }
        if (@$form_state['values']['comment_confirm_delete'] == 1) {
          $delete_confirmed = 1;
        }
      }
    } elseif (array_key_exists('entity', $form)) {
      $entity = $form['entity']['#value'];
      if (is_object($entity)) {


        if (array_key_exists('bundle', $form)) {
          $entity_type = $form['bundle']['#value']->data['entity_type'];
          $entity_bundle = $form['bundle']['#value']->data['name'];
        }
        if (array_key_exists('#entity_type', $form)) {
          $entity_type = $form['#entity_type'];
        }
        if (array_key_exists('#bundle', $form)) {
          $entity_bundle = $form['#bundle'];
        }
        if (property_exists($entity, 'title')) {
          $entity_title = $entity->title;
        }
        $data = entity_extract_ids($entity_type, $entity);
        if ($data[0]) {
          $entity_id = $data[0];
        }
        $entity_types = _entity_soft_delete_entity_types();
        if ($entity_id) {
          if (@$entity_types[$entity_type]['bundles'][$entity_bundle]['crud']['view']) {
            $view_path = str_replace('%', $entity_id, $entity_types[$entity_type]['bundles'][$entity_bundle]['crud']['view']['path']);
          }
        }

        if (@$form_state['values']['confirm']) {
          $delete_confirmed = 1;
        }
      }
    }
  }

  $result = array(
    'entity' => $entity,
    'redirect_path' => $redirect_path,
    'title' => $entity_title,
    'entity_id' => $entity_id,
    'entity_type' => $entity_type,
    'entity_bundle' => $entity_bundle,
    'view_path' => $view_path,
    'delete_confirmed' => $delete_confirmed,
  );

  return $result;
}

/**
 * Implements hook_rdf_namespaces().
 */
function entity_soft_delete_rdf_namespaces() {
  return array(
    'entity_soft_delete' => ENTITY_SOFT_DELETE_NAMESPACE,
  );
}

/**
 * Implements hook_rdf_mapping().
 */
function entity_soft_delete_rdf_mapping() {
  return array(
    array(
      'type' => 'entity_soft_delete',
      'bundle' => RDF_DEFAULT_BUNDLE,
      'mapping' => array(
        'rdftype' => array('rss:channel'),
        'title' => array(
          'predicates' => array('rss:title'),
        ),
        'link' => array(
          'predicates' => array('rss:link'),
          'type' => 'rel',
        ),
        'description' => array(
          'predicates' => array('rss:description'),
        ),
        'items' => array(
          'predicates' => array('rss:items'),
        ),
      ),
    ),
  );
}

/**
 * Implements hook_token_info().
 */
function entity_soft_delete_token_info() {
  $info = array('tokens' => array('node' => array()));

  $info['tokens']['node']['is-soft-deleted'] = array(
    'name' => t("Is Soft deleted"),
    'description' => t("A boolean representing whether or not this node was soft deleted."),
  );

  $info['tokens']['node']['soft-deleted-on'] = array(
    'name' => t("Soft deleted On"),
    'description' => t("The date the node was soft deleted."),
    'type' => 'date',
  );

  $info['tokens']['node']['soft-deleted-by'] = array(
    'name' => t("Soft deleted By"),
    'description' => t("The user who soft deleted the node."),
    'type' => 'user',
  );

  return $info;
}

/**
 * Implements hook_tokens().
 */
function entity_soft_delete_tokens($type, $tokens, array $data = array(), array $options = array()) {
  $replacements = array();

  if ($type == 'node' && isset($data['node']) && is_object($data['node'])) {
    $node = $data['node'];

    if (!property_exists($node, 'deleted') || $node->deleted != TRUE) {
      foreach ($tokens as $name => $original) {
        if ($name == 'is-soft-deleted') {
          $replacements[$original] = FALSE;
        } else if ($name == 'soft-deleted-on') {
          $replacements[$original] = NULL;
        } else if ($name == 'soft-deleted-by') {
          $replacements[$original] = NULL;
        }
      }
    } else {
      foreach ($tokens as $name => $original) {
        if ($name == 'is-soft-deleted') {
          $replacements[$original] = TRUE;
        } else if ($name == 'soft-deleted-on') {
          $replacements[$original] = $node->deleted['timestamp'];
        } else if ($name == 'soft-deleted-by') {
          $replacements[$original] = $node->deleted['uid'];
        }
      }
    }

    if ($soft_deleted_by_tokens = token_find_with_prefix($tokens, 'soft-deleted-by')) {
      $soft_deleted_by = user_load($node->deleted['uid']);
      $replacements += token_generate('user', $soft_deleted_by_tokens, array('user' => $soft_deleted_by), $options);
    }

    if ($soft_deleted_on_tokens = token_find_with_prefix($tokens, 'soft-deleted-on')) {
      $replacements += token_generate('date', $soft_deleted_on_tokens, array('date' => $node->deleted['timestamp']), $options);
    }
  }

  return $replacements;
}

/**
 * Pass entity object as #node, entity, #comment item in $form
 *
 * @param $form
 * @param $form_state
 * @param $form_id
 * @param $force
 *   adds the actions regardless of form_id
 */
function entity_soft_delete_add_soft_delete_actions(&$form, &$form_state, $form_id, $force = FALSE) {
  if (!is_array($form)) {
    cf_error::invalid_array('form');
    return;
  }

  if (cf_is_not_form_state('form_state', $form_state, WATCHDOG_ERROR)) {
    return;
  }

  if (cf_is_empty_or_non_string('form_id', $form_id, WATCHDOG_ERROR)) {
    return;
  }
  $entity_info = _entity_soft_delete_entity_info_from_form($form);

  if ($entity_info) {
    $entity = $entity_info['entity'];
    $entity_id = $entity_info['entity_id'];
    $entity_type = $entity_info['entity_type'];
    $entity_bundle = $entity_info['entity_bundle'];
  }

  if (isset($entity_info['entity']))
    if ($form_id == 'node_delete_confirm' || $form_id == 'eck__entity__delete_form' || $form_id == 'comment_confirm_delete') {
      if (!is_object($entity) || !entity_soft_delete_is_enabled(array('type' => $entity_type, 'bundle' => $entity_bundle))) {
        return;
      }

      // Override node_delete_confirm_submit() submit handler
      $form['#submit'][0] = 'entity_soft_delete_entity_delete_confirm_submit';

      if (user_access('bypass soft deleted content')) {
        $form['permanent'] = array(
          '#type' => 'checkbox',
          '#title' => t("Permanently delete this content"),
          '#default_value' => '',
      );
      } else {
        // users can still manually go to /node/edit/[nid]/delete
        // already deleted content cannot be deleted again so if the user does not have permanent delete access, let them know that the content is already deleted
        // the form submit buttons and actions will be removed in this case
        $results = entity_soft_delete_get_entity_delete_settings(array($entity), $entity_type);

        if (!empty($results)) {
          drupal_set_message(t("This content is already deleted, you are not authorized to permanently delete this content."), 'warning');

          unset($form['#submit']);
          unset($form['actions']['submit']);
        }
      }
    } else if (is_object($entity)) {
      // Find-out if it's an add form
      $this_an_add_form = FALSE;
      if (isset($entity) && $entity_type == 'node' && $entity_bundle .'_node_form' === $form_id && !property_exists($entity, 'nid')) {
        $this_an_add_form = TRUE;
      }
      // alter the entity edit form to alter the delete button
      if (!$this_an_add_form && ($entity_bundle . '_node_form' == $form_id || 'eck__entity__form_edit_' . $entity_type . '_' . $entity_bundle == $form_id || @$form['#id'] == 'comment-form') || $force) {
        if (entity_access('delete', $entity_type, $entity)) {
          $results = entity_soft_delete_get_entity_delete_settings(array($entity), $entity_type);
          if (!empty($results)) {
            if (entity_soft_delete_can_undelete($entity, $entity_type, NULL)) {
              $form['actions']['undelete'] = array(
                '#type' => 'submit',
                '#value' => t("Undelete"),
                '#weight' => 16,
                '#submit' => array('entity_soft_delete_entity_undelete_submit'),
              );
            }

            // remove the delete button for users who cannot bypass entity_soft_delete functionality
            if (!user_access('bypass soft deleted content')) {
                unset($form['actions']['delete']);
            }
          }
      }
    }
  }
}

/**
 * Returns an array of all soft-deleted nodes, sorted by timestamp.
 *
 * @return
 *   An array of node delete settings.
 */
function entity_soft_delete_get_soft_deleted_nodes() {
  $query = db_select('entity_soft_delete_entities', 'se');

  $query->innerjoin('node', 'n', 'se.id = n.nid');
  $query->innerjoin('node_revision', 'nr', 'se.id = nr.nid AND se.vid = nr.vid');
  $query->fields('se');
  $query->fields('n');
  $query->fields('nr');
  $query->condition('se.entity_type', 'node');
  $query->orderBy('se.timestamp', 'DESC');

  return $query->execute()->fetchAll();
}
