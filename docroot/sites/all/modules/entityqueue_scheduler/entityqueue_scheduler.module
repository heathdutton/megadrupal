<?php
/**
 * @file
 * Extends entityqueue to add a 'scheduled' queue type.
 */

/**
 * Implements hook_entityqueue_api().
 */
function entityqueue_scheduler_entityqueue_api() {
  return array(
    'api' => 1,
    'path' => drupal_get_path('module', 'entityqueue_scheduler'),
  );
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function entityqueue_scheduler_ctools_plugin_directory($module, $plugin) {
  return 'plugins/' . $module . '/' . $plugin;
}

/**
 * Form validate callback.
 *
 * @see EntityQueueSchedulerEntityQueueHandler::subqueueForm()
 */
function entityqueue_scheduler_subqueue_form_validate($form, &$form_state) {
  $values = isset($form_state['values']) ? $form_state['values'] : array();
  $queue = $form_state['build_info']['args'][0];
  $subqueue = $form_state['build_info']['args'][1];
  $handler = entityqueue_get_handler($queue);

  $date = isset($values['date']) ? $values['date'] : NULL;
  // Ensure that date is set for all subqueues, unless it's the live subqueue.
  if (empty($date) && !$handler->isLiveQueue($subqueue)) {
    form_error($form['date'], t('Enter the date that this version of the queue should be published.'));
  }
  elseif (!$handler->isLiveQueue($subqueue)) {
    $timezone = date_default_timezone();
    $now = date_now($timezone);
    $date_object = new DateObject($date, $timezone);

    if ($date_object <= $now) {
      if (isset($subqueue->subqueue_id)) {
        form_error($form['date'], t('This subqueue was scheduled to be published already and cannot be edited. Please make sure that <a href="@url">cron is running</a>.', array(
          '@url' => url('admin/reports/status'),
        )));
      }
      else {
        form_error($form['date'], t('The scheduled date must be in the future.'));
      }
    }
    elseif (!isset($subqueue->subqueue_id)) {
      // Use UTC in the database.
      $date_object->setTimezone(new DateTimeZone('UTC'));
      $machine_name = $queue->name . '__' . $date_object->format('Y_m_d_H_i');
      $existing = entityqueue_subqueue_load($machine_name);
      if (!empty($existing)) {
        form_error($form['date'], t('Another %queue subqueue is scheduled to be published at the same time. Subqueue publish dates must be unique.', array(
          '%queue' => $queue->label,
        )));
      }
      else {
        $form_state['values']['name'] = $machine_name;
        $subqueue->scheduler_date = $date_object->format(DATE_FORMAT_DATETIME);
      }
    }
  }

  $subqueue->label = $handler->getSubqueueLabel($subqueue);
}

/**
 * Implements hook_cron().
 */
function entityqueue_scheduler_cron() {
  module_load_include('inc', 'date_api', 'date_api_sql');
  $publish_subqueues = array();
  $live_subqueues = array();

  // Loop through our subqueues to see if any should be published now.
  $date_sql_handler = new date_sql_handler(DATE_DATETIME);
  $now_sql = $date_sql_handler->sql_where_date('field', 'sq.scheduler_date', '<=', 'NOW');
  $query = db_select('entityqueue_subqueue', 'sq')
    ->fields('sq', array('name', 'queue'))
    ->condition('sq.module', 'entityqueue_scheduler');
  $is_past_alias = $query->addExpression($now_sql, 'is_past');
  $subqueues = $query->havingCondition($is_past_alias, 1)
    ->orderBy('sq.scheduler_date', 'ASC')
    ->execute();

  foreach ($subqueues as $subqueue) {
    $publish_subqueues[] = $subqueue->name;
    $live_subqueues[$subqueue->queue] = $subqueue->queue . '__live';
  }
  if (!empty($publish_subqueues) && !empty($live_subqueues)) {
    $publish_subqueues_loaded = entityqueue_subqueue_load_multiple($publish_subqueues);
    $live_subqueues_loaded = entityqueue_subqueue_load_multiple($live_subqueues);

    unset($live_subqueues, $publish_subqueues);
    $live_subqueues = array();
    // Key live subqueues by queue name.
    foreach ($live_subqueues_loaded as $subqueue) {
      $live_subqueues[$subqueue->queue] = $subqueue;
    }
    $queue_names = array_keys($live_subqueues);
    unset($live_subqueues_loaded);
    $fields = field_read_instances(array('entity_type' => 'entityqueue_subqueue', 'bundle' => $queue_names));
    foreach ($publish_subqueues_loaded as $subqueue) {
      // Set the subqueue fields to the values from the queue being published.
      foreach ($fields as $field) {
        if ($field['bundle'] == $subqueue->queue) {
          $field_name = $field['field_name'];
          $live_subqueues[$subqueue->queue]->{$field_name} = $subqueue->{$field_name};
        }
      }

      // Save the live subqueue.
      entityqueue_subqueue_save($live_subqueues[$subqueue->queue]);
      // Delete the published subqueue.
      entity_delete('entityqueue_subqueue', $subqueue->subqueue_id);
    }
  }
}
