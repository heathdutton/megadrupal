<?php

/**
 * @file
 * Defines a product feature that grants customers access to various items via available universal access handler modules
 * on your site upon order completion.
 *
 * This modules is an "Access API". It handles business logic of setting up
 * access to various "access items" (content, roles, taxonomy terms, etc.) as
 * product features for sale, handling order status changes (i.e. responding to
 * "payment received" event) and tracking schedule of the access.
 *
 * Access can be set up with a schedule, such as a delay or fixed period of time
 * when access is given. Access schedule can have a start time and expiration.
 * Schedule allows use cases like selling online courses that are given in
 * certain intervals. Purchases can be made ahead of time, then the start time
 * is delayed. Access may expire (i.e. if the course is not available after the
 * semester). This module handles all scheduling and ties it to purchases made.
 *
 * Actual access grants are delegated to extension "access handler" modules
 * using "Universal Access API". This module generates all setting forms on the
 * product feature side. It includes any specific fields from the access handler
 * modules in the UI. All UI for their "access items" is taken care by the
 * access handler modules. For example, a node/fields access module would add
 * information about which fields have access sold as product features on the
 * node form.
 *
 * Currently only 'view' access is managed by this module, but the intent is to
 * develop features for any type of access. That will allow to sell access to
 * edit the content. In this scenario users can buy access to post ads on the
 * website.
 *
 * Concepts
 * $uaid - An id we keep for the extension access handler modules. It is up to
 *         these modules to define what uaid means for them.
 * $access - Array with access data
 *
 * Universal Access API
 * A modular API for separating access handlers from product feature operations.
 * Individual access handlers are Drupal modules that implement
 * hook_universal_access().
 * This module provides callback hooks for access handlers:
 *   hook_universal_access_delete_notify() - call when access handler's item is deleted.
 *   hook_universal_access_schedule() - call when access handler's item is edited to change the schedule (i.e. in an admin interface)
 *
 * Extension API - hook_universal_access()
 * A hook that is a manifest (to discover handlers) and a handler that is used
 * to perform actions for the UC CCK Access module based on $op.
 * Couple of helper wrappers call the handler:
 *   uc_cck_access_call_handler()
 *   uc_cck_access_op()
 * $op Values:
 *   Operations (invoked by uc_cck_access_op() wrapper)
 *     'revoke' - ($nid, $uid, $data) revoke access grant
 *     'delay'  - ?
 *     'delete' - ($nid, $uid, $data) delete access grant
 *     'grant'  - ($nid, $uid, $data) grant access
 *   Information / Utility:
 *     Empty or 'info'       - returns the API manifest
 *     'describe'            - ($access, ?$options) describes the access item, $access should have 'node' set for calls from node_load() context.
 *     'describe_data'       - ($access) describe the access handler data, $access should have 'node' set for calls from node_load() context.
 *     'lesser_data'         - ($data1, $data2) compare access handler data - determine if one data1 covers less than data2
 *     'intersecting_data'   - ?
 *     'handler_form'        - ($form_state, $values, $access) returns settings form of the handler instance
 *     'handler_form_submit' - ($arg - object wrapper of array($form, &$form_state, $values, &$access)) invoke submit for the settings form of the handler instance
 *     'item_uaid'           - ($nid, $fields) return an array of uaid's that a 'grant' operation would create
 *     'item_uaid_data'      - ?
 *     'items_granted'       - ($conditions, $key_by) return list of nodes granted to the user
 */

define('UCCA_DEBUG', 0); //FIXME: DEBUGGING Test only, remove in final version
define('UCCA_USE_DATEAPI', module_exists('date_api')); // Soft dependency on Date API module
define('UCCA_USE_DATEPOPUP', module_exists('date_popup')); // Soft dependency on Date Popup module


/**
 * Implements hook_init().
 */
function uc_cck_access_init() {
  drupal_add_css(drupal_get_path('module', 'uc_cck_access') . '/uc_cck_access.css');
  drupal_add_js(drupal_get_path('module', 'uc_cck_access') . '/uc_cck_access.js');
}

/**
 * Implements hook_help().
 */
function uc_cck_access_help($path, $arg) {
  $output = '';

  switch ($path) {
    case 'admin/help#uc_cck_access':
      $output = '<p>' .  t('Lets you sell access to CCK Fields in your Ubercart store.') . '</p>';
      break;
  }

  return $output;
}

/**
 * Implements hook_menu().
 */
function uc_cck_access_menu() {
  $items = array();

  $items['user/%user/content_orders'] = array(
    'title' => 'Premium Content',
    'description' => 'View your premium content.',
    'page callback' => 'uc_cck_access_user_content_orders',
    'page arguments' => array(1),
    'access callback' => 'uc_cck_access_can_view_order',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
//    'file' => 'uc_cck_access.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function uc_cck_access_theme() {
  return array(
    'uc_cck_access_grant_items' => array(
      'render element' => 'form',
    ),
    'uc_cck_access_add_grant' => array(
      'render element' => 'form',
    ),
    'uc_cck_access_node' => array(
      'variables' => array('uc_cck_access' => NULL),
    ),
  );
}

function _uc_cck_access_user($uid) {
  $user = user_load($uid);
  if (!$user) {
    return t('@uid', array('@uid' => $uid));
  }
  return t('<a href="!url">%username</a>', array('!url' => url('user/' . $uid), '%username' => $user->name));
}

/**
 * Process all expirations that satisfy given $conditions.
 * @param $conditions - associative array ($field => $condition) of conditions (all will be 'AND'ed, time condition is <=)
 * fields are: expiration, pfid, uid (all %d format)
 */
function uc_cck_access_process_expirations($conditions) {
  // Load and process any expired CCK access rules.
  $query = db_select('uc_cck_access_expirations', 'ae')->fields('ae');
  $where = '';
  $sep = '';
  foreach ($conditions as $field => $condition) {
    $query->condition('ae.' . $field, $condition, (($field == 'expiration') ? '<=' : '='));
    $where .= $sep . $field . (($field == 'expiration') ? '<=' : '=') . $condition;
    $sep = ' AND ';
  }

  $result = $query->execute();
  $items = array();
  while ($access = $result->fetchAssoc()) {
    if (isset($access['pfid']) && $access['pfid']) {
      unset($access['handler'], $access['access_id'], $access['data']);
      // Load up the CCK access product feature and all access data.
      $access += uc_cck_access_feature_load($access['pfid']);
    }
    else {
      $access['data'] = unserialize($access['data']);
    }

    $item = uc_cck_access_call_handler($access, 'describe', $access);
    $items[] = t('User !user lost !item.',
      array('!user' => _uc_cck_access_user($access['uid']), '!item' => $item));

    // Revoke access for the user through the current universal access handler.
    uc_cck_access_op($access['handler'], 'revoke', NULL, $access['uid'], $access['access_id'], $access['data']);

    // Delete the expiration from the database.
    db_delete('uc_cck_access_expirations')
      ->condition('eid', $access['eid'])
      ->execute();
  }

  if (!empty($items)) {
    watchdog('uc_cck_access', 'The following expirations occurred (SQL: @sql): !expirations',
      array('@sql' => $where, '!expirations' => theme('item_list', array('items' => $items))));
  }
}

/**
 * Process all delays that satisfy given $conditions.
 * @param $conditions - associative array ($field => $condition) of conditions (all will be 'AND'ed, time condition is <=)
 * fields are: inception, pfid, uid (all %d format)
 */
function uc_cck_access_process_delays($conditions) {
  // Load and process any expired CCK access rules.
  $query = db_select('uc_cck_access_delays', 'ad')->fields('ad');
  $where = '';
  $sep = '';
  foreach ($conditions as $field => $condition) {
    $query->condition('ad.' . $field, $condition, (($field == 'inception') ? '<=' : '='));
    $where .= $sep . $field . (($field == 'inception') ? '<=' : '=') . $condition;
    $sep = ' AND ';
  }

  $result = $query->execute();
  $items = array();
  while ($access = $result->fetchAssoc()) {
    if (isset($access['pfid']) && $access['pfid']) {
      // _uc_cck_access_grant_user_access() calls uc_cck_access_feature_load() so we don't need to here.
    }
    else {
      list($access['duration_period_value'], $access['duration_period_unit']) = explode(' ', $access['duration_period']);
      $access['duration_date'] = unserialize($access['duration_date']);
      $access['data'] = unserialize($access['data']);
    }
    $item = uc_cck_access_call_handler($access, 'describe', $access);
    $items[] = t('User !user acquired delayed !item.',
      array('!user' => _uc_cck_access_user($access['uid']), '!item' => $item));

    // Grant access for the user.
    $log = _uc_cck_access_grant_user_access($access, $access['uid']);
    // $log is ignored - we're posting to watchdog our own version

    // Delete the delay from the database.
    db_delete('uc_cck_access_delays')
      ->condition('did', $access['did'])
      ->execute();
  }

  if (!empty($items)) {
    watchdog('uc_cck_access', 'The following delayed grants occurred (SQL: @sql): !delays',
      array('@sql' => $where, '!delays' => theme('item_list', array('items' => $items))));
  }
}

/**
 * Implements hook_cron().
 */
function uc_cck_access_cron() {
  $time = REQUEST_TIME; // UTC

  // Process any expired CCK access rules.
  uc_cck_access_process_expirations(array('expiration' => $time));

  // Process any delayed CCK access rules.
  uc_cck_access_process_delays(array('inception' => $time));

}

/**
 * Implements hook_uc_product_feature().
 */
function uc_cck_access_uc_product_feature() {
  $features[] = array(
    'id' => 'cck_access',
    'title' => t('CCK access'),
    'callback' => 'uc_cck_access_feature_form',
    'delete' => 'uc_cck_access_feature_delete',
    'settings' => 'uc_cck_access_feature_settings_form',
  );

  return $features;
}

/**
 * Invoke handler method.
 */
function uc_cck_access_call_handler($access, $hook) {
  $handler = $access['handler'];
  $args = func_get_args();
  array_shift($args); // remove first argument $access
  $return = ($handler && function_exists($handler))
    ? call_user_func_array($handler, $args)
    : FALSE;
  return $return;
}

/**
 * Get handler's feature form based on selected handler.
 */
function _uc_cck_access_handler_feature_form($form_state, $values, $access) {
  return (array) uc_cck_access_call_handler($access, 'handler_form', $form_state, $values, $access);
}

/**
 * Invoke handler's feature form submit based on selected handler.
 *
 * Inputs:
 *   $access['handler'] - access handler
 *
 */
function _uc_cck_access_handler_feature_form_submit($form, &$form_state, $values, &$access) {
  // uc_cck_access_call_handler won't work here as we need to pass $form_state by reference:
  $handler = $access['handler'];
  $return = ($handler && function_exists($handler))
    ? call_user_func_array($handler, array('handler_form_submit', (object) array($form, &$form_state, $values, &$access)))
    : FALSE;
  return $return;
}

function _uc_cck_access_time_unit_options() {
  $options = array(
    'hours'  => t('hour(s)'),
    'days'   => t('day(s)'),
    'weeks'  => t('week(s)'),
    'months' => t('month(s)'),
    'years'  => t('year(s)'),
  );
  if (UCCA_DEBUG || isset($GLOBALS['drupal_test_info'])) {
    $options = array_merge(array('minutes' => t('minute(s)')), $options);
    $options = array_merge(array('seconds' => t('second(s)')), $options);
  }
  return $options;
}

/*
 * Form with time interval settings (delayed start, duration)
 */
function _uc_cck_access_time_interval_form($form_state, $access) {
  $item = t('item'); // this could be more descriptive if we were up to reloading the whole form upon handler change
  $access += array(
    'delay_date' => REQUEST_TIME,
    'delay_type' => 'immediate',
    'delay_period_value' => '',
    'delay_period_unit' => 'months',
    'duration_date' => REQUEST_TIME,
    'duration_type' => 'unlimited',
    'duration_period_value' => '',
    'duration_period_unit' => 'months',
  );
  // What widget, format and timezone to use for date fields
  // Gracefully degrade 'date_popup' -> 'date_select' -> 'date' depending on what module is available
  $date_widget_type = UCCA_USE_DATEPOPUP ? 'date_popup' : (UCCA_USE_DATEAPI ? 'date_select' : 'date');
  $format = variable_get('ucca_date_format', variable_get('date_format_short', 'm/d/Y - H:i'));
  $format = _ucca_date_format_cleanup($format);
  $widget_format = function_exists('date_limit_format') ? date_limit_format($format, array('year', 'month', 'day', 'hour', 'minute')) : $format;
  // Contrary to their documentation, 'date_select' and 'date_popup' widgets
  // reliably support only #default_value given in DATE_FORMAT_DATETIME , but
  // still display entry fields in the #date_format. So we prepare 2 formats.
  $format = 'Y-m-d H:i';
  $tz_name = _ucca_timezone_name();

  $form['delay_fieldset'] = array(
    '#type' => 'fieldset',
    '#title' => t('Access delay'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#description' => t('Specify when customer will receive access to the !item after purchasing this product.', array('!item' => $item)),
    '#attributes' => array('class' => array('delay-fieldset')),
  );

  $form['delay_fieldset']['delay_type'] = array(
    '#type' => 'radios',
    '#title' => t('Delay'),
    '#options' => array(
      'immediate' => t('No delay (access given immediately)'),
      'period' => t('Fixed wait (access given after fixed time from the moment of the purchase)'),
      'date' => t('Fixed date (access given at specific date)'),
    ),
    '#default_value' => $access['delay_type'],
    '#attributes' => array('class' => array('ucca_delay_type')),
    '#required' => TRUE,
  );

  $form['delay_fieldset']['delay_period_fieldset'] = array(
    '#type' => 'fieldset',
    '#title' => t('Fixed wait'),
    '#collapsible' => FALSE,
    '#description' => t('Specify the length of time after purchase the customer must wait to have access to the !item.', array('!item' => $item)),
    '#attributes' => array('class' => array('delay-period-fieldset')),
  );
  $form['delay_fieldset']['delay_period_fieldset']['delay_period_value'] = array(
    '#type' => 'select',
    '#options' => drupal_map_assoc(range(1, 52)),
    '#default_value' => $access['delay_period_value'],
  );
  $form['delay_fieldset']['delay_period_fieldset']['delay_period_unit'] = array(
    '#type' => 'select',
    '#options' => _uc_cck_access_time_unit_options(),
    '#default_value' => $access['delay_period_unit'],
  );

  $form['delay_fieldset']['delay_date_fieldset'] = array(
    '#type' => 'fieldset',
    '#title' => t('Fixed start date'),
    '#collapsible' => FALSE,
    '#description' => t('Specify the start date on which the customer will receive access to the !item.', array('!item' => $item)),
    '#attributes' => array('class' => array('delay-date-fieldset')),
  );
  $form['delay_fieldset']['delay_date_fieldset']['delay_date'] = array(
    '#type' => $date_widget_type,
    '#default_value' => ($date_widget_type == 'date')
      ? _ucca_date_change_timezone($access['delay_date'], 'UTC', '')  // convert to user's timezone
      : _ucca_date_format($access['delay_date'], $format),
    '#date_timezone' => $tz_name,
    '#date_format' => $widget_format,
    '#date_text_parts' => array(),
    '#date_increment' => 1,
    '#date_year_range' => '-0:+5',
    '#date_label_position' => 'above',
    '#description' => ($date_widget_type == 'date')
      ? t('Set the date (time is midnight in your timezone %timezone).', array('%timezone' => $tz_name))
      : t('Set the date/time in your timezone (%timezone).', array('%timezone' => $tz_name)),
  );

  $form['duration_fieldset'] = array(
    '#type' => 'fieldset',
    '#title' => t('Access duration'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    '#description' => t('Specify when customer will loose access to the !item after receiving access.', array('!item' => $item)),
    '#attributes' => array('class' => array('duration-fieldset')),
  );


  $form['duration_fieldset']['duration_type'] = array(
    '#type' => 'radios',
    '#title' => t('Duration'),
    '#options' => array(
      'unlimited' => t('Unlimited duration (access never expires)'),
      'period' => t('Fixed duration (access expires after fixed period)'),
      'date' => t('Fixed date (access expires on specific date)'),
    ),
    '#default_value' => $access['duration_type'],
    '#attributes' => array('class' => array('ucca_duration_type')),
    '#required' => TRUE,
  );

  $form['duration_fieldset']['duration_period_fieldset'] = array(
    '#type' => 'fieldset',
    '#title' => t('Fixed duration'),
    '#collapsible' => FALSE,
    '#description' => t('Specify the length of time the customer should have access to the !item after first receiving access.', array('!item' => $item)),
    '#attributes' => array('class' => array('duration-period-fieldset')),
  );
  $form['duration_fieldset']['duration_period_fieldset']['duration_period_value'] = array(
    '#type' => 'select',
    '#options' => drupal_map_assoc(range(1, 52)),
    '#default_value' => $access['duration_period_value'],
  );
  $form['duration_fieldset']['duration_period_fieldset']['duration_period_unit'] = array(
    '#type' => 'select',
    '#options' => _uc_cck_access_time_unit_options(),
    '#default_value' => $access['duration_period_unit'],
  );

  $form['duration_fieldset']['duration_date_fieldset'] = array(
    '#type' => 'fieldset',
    '#title' => t('Fixed end date'),
    '#collapsible' => FALSE,
    '#description' => t('Specify the end date on which the customer will lose access to the !item.', array('!item' => $item)),
    '#attributes' => array('class' => array('duration-date-fieldset')),
  );
  $form['duration_fieldset']['duration_date_fieldset']['duration_date'] = array(
    '#type' => $date_widget_type,
    '#default_value' => ($date_widget_type == 'date')
      ? _ucca_date_change_timezone($access['duration_date'], 'UTC', '')  // convert to user's timezone
      : _ucca_date_format($access['duration_date'], $format),
    '#date_timezone' => $tz_name,
    '#date_format' => $widget_format,
    '#date_text_parts' => array(),
    '#date_increment' => 1,
    '#date_year_range' => '-0:+5',
    '#date_label_position' => 'above',
    '#description' => ($date_widget_type == 'date')
      ? t('Set the date (time is midnight in your timezone %timezone).', array('%timezone' => $tz_name))
      : t('Set the date/time in your timezone (%timezone).', array('%timezone' => $tz_name)),
  );

  return $form;
}

function _uc_cck_access_period_description($duration) {
  list($value, $unit) = explode(' ', $duration);
  switch ($unit) {
    case 'seconds':
      return format_plural($value, '1 second', '@count seconds');
    case 'minutes':
      return format_plural($value, '1 minute', '@count minutes');
    case 'hours'  :
      return format_plural($value, '1 hour',    '@count hours');
    case 'days'   :
      return format_plural($value, '1 day',     '@count days');
    case 'weeks'  :
      return format_plural($value, '1 week',    '@count weeks');
    case 'months' :
      return format_plural($value, '1 month',   '@count months');
    case 'years'  :
      return format_plural($value, '1 year',    '@count years');
  }
  return $duration;
}

function _uc_cck_access_delay_description($access, $tz_name = '') {
  switch ($access['delay_type']) {
    case 'period':
      $description = t('!period after purchase', array('!period' => _uc_cck_access_period_description($access['delay_period'])));
      break;
    case 'date':
      $date = _ucca_format_date(_ucca_date_to_timestamp($access['delay_date']), $tz_name);
      $description = t('on @date', array('@date' => $date));
      break;
    case 'immediate':
    default:
      $description = t('immediately after purchase');
      break;
  }
  return $description;
}

function _uc_cck_access_duration_description($access, $tz_name = '') {
  switch ($access['duration_type']) {
    case 'period':
      $description = t('for !period', array('!period' => _uc_cck_access_period_description($access['duration_period'])));
      break;
    case 'date':
      $date = _ucca_format_date(_ucca_date_to_timestamp($access['duration_date']), $tz_name);
      $description = t('until @date', array('@date' => $date));
      break;
    case 'unlimited':
    default:
      $description = t('unlimited time');
      break;
  }
  return $description;
}

/**
 * Submit function for _uc_cck_access_time_interval_form subform.
 * Processes input and fills $access record.
 *
 * Inputs:
 *   $access['handler_description'] - description from access handler
 *
 */
function _uc_cck_access_time_interval_form_submit($form, &$form_state, &$access) {
  $access['delay_type']      = $form_state['values']['delay_type'];
  $access['delay_period']    = $form_state['values']['delay_period_value'] . ' ' . $form_state['values']['delay_period_unit'];
  $access['delay_date']      = $form_state['values']['delay_date'];
  $access['duration_type']   = $form_state['values']['duration_type'];
  $access['duration_period'] = $form_state['values']['duration_period_value'] . ' ' . $form_state['values']['duration_period_unit'];
  $access['duration_date']   = $form_state['values']['duration_date'];

  foreach (array('delay_date' => 'delay_fieldset', 'duration_date' => 'duration_fieldset') as $f => $fieldset) {
    $date_widget_type = $form[$fieldset][$f . '_fieldset'][$f]['#type'];
    $format = $form[$fieldset][$f . '_fieldset'][$f]['#date_format'];
    if ($date_widget_type == 'date') {
      // Convert from user timezone to UTC
      $access[$f] = _ucca_date_change_timezone($access[$f], '', 'UTC');
    }
    else { // if ($date_widget_type == 'date_select' || $date_widget_type == 'date_popup')
      // 'date_select' and 'date_popup' widgets outputs thier value formatted in
      // a subset of DATE_FORMAT_DATETIME based on '#date_format' granularity.
      $granularity = date_format_order($format);
      $format = date_granularity_format($granularity);
      // Convert 1. string in DATE_FORMAT_DATETIME to array, 2. from user timezone to UTC
      $access[$f] = _ucca_date_from_str($access[$f], '', $format);
    }
  }
  $handler_description = $access['handler_description'];

  // PARENT DESIGN LIMITATION - This translated string goes into the uc_product database. Not multilingual! Not timezone-aware!
  $delay_description = _uc_cck_access_delay_description($access);
  $duration_description = _uc_cck_access_duration_description($access);
  $verbs = array('!item' => $handler_description, '!delay' => $delay_description, '!duration' => $duration_description);
  switch ($access['duration_type']) {
    case 'period':
    case 'date':
      $description = t('Grant access to !item !delay !duration.', $verbs);
      break;
    case 'unlimited':
    default:
      $description = t('Grant access to !item !delay for !duration.', $verbs);
      break;
  }
  $access['description'] = $description;
}

/**
 * Display the settings form for the CCK access product feature.
 */
function uc_cck_access_feature_form($form, &$form_state, $node, $feature) {
  if (!empty($feature)) {
    $access = uc_cck_access_feature_load($feature['pfid']);
  }
  else {
    $access = array(
      'model' => '',
    );
  }

  $options = array('' => t('<Any>'), $node->model => $node->model);
  if (module_exists('uc_attribute')) {
    $result = db_query("SELECT model FROM {uc_product_adjustments} WHERE nid = :nid", array(':nid' => $node->nid));
    while ($row = $result->fetch()) {
      if (!in_array($row->model, $options)) {
        $options[$row->model] = $row->model;
      }
    }
  }
  $form['model'] = array(
    '#type' => 'select',
    '#title' => t('Product Model/SKU'),
    '#description' => t('Select which model/SKU of the product this feature applies to.'),
    '#options' => $options,
    '#default_value' => $access['model'],
  );

  $form += _uc_cck_access_handler_form($form_state, $access, FALSE); // SUBFORM
  // $form['handler_form'] is preset by _uc_cck_access_handler_form() and has '#tree' = TRUE.
  $form['handler_form'] += _uc_cck_access_handler_feature_form($form_state, isset($form_state['values']['handler_form']) ? $form_state['values']['handler_form'] : array(), $access); // SUBFORM
  $form += _uc_cck_access_time_interval_form($form_state, $access); // SUBFORM

  return uc_product_feature_form($form, $form_state, $node, $feature);
}

function _uc_cck_access_log_to_message($log) {
  foreach ($log as $entry) {
    if (is_array($entry)) {
      drupal_set_message(t($entry[0], $entry[1]));
    }
  }
}
function _uc_cck_access_log_to_watchdog($log, $consolidated = TRUE) {
  $text = '';
  foreach ($log as $entry) {
    if (is_array($entry)) {
      if ($consolidated) {
        $text .= ($text ? '<br>' : '') . t($entry[0], $entry[1]);
      }
      else {
        watchdog('uc_cck_access', $entry[0], $entry[1]);
      }
    }
  }
  if ($text) {
    watchdog('uc_cck_access', $text);
  }
}

/**
 * Submit handler for uc_cck_access_feature_form().
 */
function uc_cck_access_feature_form_submit($form, &$form_state) {
  // If an AHAH submission, it's just the dependent field working (take into account no-js case).
  if (isset($form_state['clicked_button'])
    ? ($form_state['clicked_button']['#value'] != t('Save feature'))
    : !empty($form_state['ahah_submission'])) {
    return;
  }

  $access = isset($form_state['ucca_access']) ? (array) $form_state['ucca_access'] : array();
  $access['pfid'] = isset($form_state['values']['pfid']) ? $form_state['values']['pfid'] : NULL;
  $access['model'] = $form_state['values']['model'];

  _uc_cck_access_handler_form_submit($form, $form_state, $access); // SUBFORM
  _uc_cck_access_handler_feature_form_submit($form, $form_state, $form_state['values']['handler_form'], $access); // SUBFORM
  _uc_cck_access_time_interval_form_submit($form, $form_state, $access); // SUBFORM
  $description = $access['description'];

  if (!empty($access['model'])) {
    $description .= '<br />' . t('Applies to SKU: @sku', array('@sku' => $access['model']));
  }
  else {
    $description .= '<br />' . t('Applies to any SKU.');
  }
  $access['description'] = $description;

  $data = array(
    'pfid' => $access['pfid'],
    'nid' => $form_state['values']['nid'],
    'fid' => 'cck_access',
    'description' => $description,
  );

  $form_state['redirect'] = uc_product_feature_save($data);

  // On an insert, get the pfid used for the CCK access product feature.
  if (empty($access['pfid'])) {
    $access['pfid'] = $data['pfid'];
  }

  uc_cck_access_feature_save($access);
  $form_state['ucca_access'] = $access;
}

/**
 * Implements hook_universal_access_delete_notify().
 * @return - log array() where each element is an array(text, array(vars)) with elements suitable for t()
 */
function uc_cck_access_universal_access_delete_notify($op, $uaid, $uid, $access_id, $handler, $reason = '') {
// $op is unused;
  $log = array();
  $conditions = array('access_id' => $access_id, 'handler' => $handler, 'uid' => $uid);
  foreach ($delay_items = uc_cck_access_find_delays($conditions) as $did => $item) {
    $uaids = uc_cck_access_call_handler(array('handler' => $item['handler']), 'item_uaid', $item['access_id'], $item['data']);
    foreach ($uaids as $item_uaid) {
      if ($item_uaid == $uaid) {
        db_delete('uc_cck_access_delays')
          ->condition('did', $did)
          ->execute();
        $log[] = array('User !user delayed access record @did was removed for !reason.', array('!user' => _uc_cck_access_user($uid), '!reason' => $reason ? $reason : t('unspecified reason'), '@did' => $did));
      }
    }
  }
  foreach ($expiration_items = uc_cck_access_find_expirations($conditions) as $eid => $item) {
    $uaids = uc_cck_access_call_handler(array('handler' => $item['handler']), 'item_uaid', $item['access_id'], $item['data']);
    foreach ($uaids as $item_uaid) {
      if ($item_uaid == $uaid) {
        db_delete('uc_cck_access_expirations')
          ->condition('eid', $eid)
          ->execute();
        $log[] = array('User !user access expiration record @eid was removed for !reason.', array('!user' => _uc_cck_access_user($uid), '!reason' => $reason ? $reason : t('unspecified reason'), '@eid' => $eid));
      }
    }
  }
  return $log;
}

/**
 * Implements hook_universal_access_schedule().
 * @param $items - access items in structured array, key by [$uaid]['users'][$uid]
 * We add:
 * - delay records to [$uaid]['users'][$uid]['dids'][$did]
 * - expiration records to [$uaid]['users'][$uid]['eids'][$eid]
 * - inceptions  to [$uaid]['users'][$uid]['inceptions']
 * - expirations to [$uaid]['users'][$uid]['expirations']
 * - user name to [$uaid]['users'][$uid]['name'] (for convenience)
 * - url to user schedule page to [$uaid]['users'][$uid]['schedule_url']
 */
function uc_cck_access_universal_access_schedule(&$items, $op, $access_id, $handler) {
// $op is unused;
$admin = TRUE;
$conditions = array('access_id' => $access_id, 'handler' => $handler);

  foreach ($expiration_items = uc_cck_access_find_expirations($conditions) as $eid => $item) {
    if (!$item['access_id']) {
      continue;
    }
    $access_id = $item['access_id'];
    $expiration = $item['expiration'];
    $item += array('handler' => $handler, 'inceptions' => array(FALSE), 'inceptions_calc' => array());
    $item['expirations'] = $expiration ? array($eid => $expiration) : array();
    $item['expirations_calc'] = $expiration ? array($eid => $expiration) : array();

    $uaids = uc_cck_access_call_handler(array('handler' => $item['handler']), 'item_uaid', $item['access_id'], $item['data']);
    foreach ($uaids as $uaid) {
      $item['uaid'] = $uaid;
      $uid = $item['uid'];
      if (isset($items[$uaid])) {
        if (isset($items[$uaid]['users'][$uid]['eids'][$eid])) {
          $items[$uaid]['users'][$uid]['eids'][$eid] += $item;
        }
        else {
          $items[$uaid]['users'][$uid]['eids'][$eid] = $item;
        }

        foreach (array('expirations', 'expirations_calc') as $field) {
          foreach ($item[$field] as $k => $v) {
            $items[$uaid]['users'][$uid][$field][$k] = $v;
          }
        }
        $items[$uaid]['users'][$uid]['name'] = $item['name'];
      }
      else {
        // If there is a delay or expiration, but we don't have acl_id in $items - we did not call 'delay' on our handler properly
      }
    } // foreach($uaid)
  } // foreach ($eid => $item)

  // After merging expirations into grants, fill inceptions/expirations array
  foreach ($items as $uaid => $item) {
    $p = &$items[$uaid]['users'];
    _uc_cck_access_get_schedule_fill_bookends($p);
  }

  foreach ($delay_items = uc_cck_access_find_delays($conditions) as $did => $item) {
    if (!$item['access_id']) {
      continue;
    }
    $access_id = $item['access_id'];
    $inception = $item['inception'];
    $expiration = _uc_cck_access_expiration($item, $inception);
    $item['expirations'] = $expiration ? array('did' . $did => $expiration) : array(FALSE);
    $item['inceptions']  = $inception  ? array($did => $inception)  : array(FALSE);
    $item['expirations_calc'] = $expiration ? array('did' . $did => $expiration) : array();
    $item['inceptions_calc']  = $inception  ? array($did => $inception)  : array();
    $uaids = uc_cck_access_call_handler(array('handler' => $item['handler']), 'item_uaid', $item['access_id'], $item['data']);
    foreach ($uaids as $uaid) {
      $item['uaid'] = $uaid;
      $uid = $item['uid'];
      if (isset($items[$uaid])) {
        if (isset($items[$uaid]['users'][$uid]['dids'][$did])) {
          $items[$uaid]['users'][$uid]['dids'][$did] += $item;
        }
        else {
          $items[$uaid]['users'][$uid]['dids'][$did] = $item;
        }

        foreach (array('inceptions', 'inceptions_calc', 'expirations', 'expirations_calc') as $field) {
          foreach ($item[$field] as $k => $v) {
            $items[$uaid]['users'][$uid][$field][$k] = $v;
          }
        }
        $items[$uaid]['users'][$uid]['name'] = $item['name'];
      }
      else {
        // If there is a delay or expiration, but we don't have acl_id in $items - we did not call 'delay' on our handler properly
      }
    } // foreach($uaid)
  } // foreach ($did => $item)

  // Fill inceptions & expirations min/max elements
  foreach ($items as $uaid => $item) {
    $p = &$items[$uaid]['users'];
    _uc_cck_access_get_schedule_fill_minmax($p, $admin);
    if (is_array($items[$uaid]['users'])) {
      foreach ($items[$uaid]['users'] as $uid => $item) {
        $items[$uaid]['users'][$uid]['schedule_url'] = url('user/' . $uid . '/content_orders');
      }
    }
  }

}

/**
 * Collect a list of all installed access handlers using hook_universal_access.
 */
function uc_cck_access_handlers_list() {
  $handlers = module_invoke_all('universal_access');
  foreach ($handlers as $handler => $data) {
    $options[$handler] = $data['title'];
  }
  if (UCCA_DEBUG) {
    $options['bogus'] = 'Dummy'; // create a dummy handler (one more item to select, emulate handler failures)
  }
  return $options;
}

/**
 * Takes date array (second, minute, hour, day, month, year) in timezone $from_tz_name
 * and outputs a date array in timezone $to_tz_name.
 */
function _ucca_date_change_timezone($date, $from_tz_name, $to_tz_name) {
  if (!$from_tz_name) {
    $from_tz_name = _ucca_timezone_name();
  }
  if (!$to_tz_name  ) {
    $to_tz_name   = _ucca_timezone_name();
  }
  if (UCCA_USE_DATEAPI) { // using date_api
    $date = $date ? (array) $date : array();
    $date += array('hour' => 0, 'minute' => 0, 'second' => 0);
    $date = new DateObject($date, $from_tz_name, DATE_ARRAY);
    date_timezone_set($date, timezone_open($to_tz_name)); // PHP5.2.0
    $arr = date_convert($date, DATE_OBJECT, DATE_ARRAY);
    $return = array();
    foreach (array('second', 'minute', 'hour', 'day', 'month', 'year') as $f) {
      $return[$f] = $arr[$f];
    }
  }
  else { // using PHP5
    if (is_array($date)) {
      $date += array('hour' => 0, 'minute' => 0, 'second' => 0);
      $date = sprintf("%04d-%02d-%02d %02d:%02d:%02d", $date['year'], $date['month'], $date['day'], $date['hour'], $date['minute'], $date['second']);
    } else {
      $date = '@' . $date;
    }
    $date = date_create($date, timezone_open($from_tz_name)); // PHP5.2.0
    date_timezone_set($date, timezone_open($to_tz_name)); // PHP5.2.0
    $return = array(
      'second' => (integer) date_format($date, 's'),
      'minute' => (integer) date_format($date, 'i'),
      'hour' => date_format($date, 'G'),
      'day' => date_format($date, 'j'),
      'month' => date_format($date, 'n'),
      'year' => date_format($date, 'Y'),
    );
  }
  return $return;
}

/**
 * Takes either date array (second, minute, hour, day, month, year) or timestamp (both in UTC)
 * and outputs a formatted date string in timezone $tz_name.
 * If $tz_name is not given, user's timezone is used.
 */
function _ucca_date_format($date_or_timestamp, $format, $tz_name = '') {
  $timestamp = is_array($date_or_timestamp)
    ? _ucca_date_to_timestamp($date_or_timestamp) // UTC to UTC
    : ($date_or_timestamp ? $date_or_timestamp : REQUEST_TIME);
  if (!$tz_name) {
    $tz_name = _ucca_timezone_name();
  }
  if (UCCA_USE_DATEAPI) { // using date_api
    $date = new DateObject($timestamp, 'UTC', DATE_FORMAT_UNIX);
    date_timezone_set($date, timezone_open($tz_name)); // PHP 5.2.0
    $return = date_format_date($date, 'custom', $format);
  }
  else { // using PHP5
    $date = date_create("@$timestamp", timezone_open('UTC')); // PHP5.2.0
    date_timezone_set($date, timezone_open($tz_name)); // PHP5.2.0
    $return = format_date($timestamp, 'custom', $format, $tz_name);
  }
  return $return;
}

/**
 * Try to rectify some date formats (the ones with weekday first, and space-dash-space between date & time)
 * Takes formatted date or date format string, removes unneeded parts and cleans it up.
 */
function _ucca_date_format_cleanup($date_string) {
  $date_parts = explode(',', implode(' ', explode(' - ', $date_string)));
  if (
    count($date_parts) > 1
     && (strpos($date_parts[0], ' ') === FALSE)  // Has no space in first part
     && (!is_numeric($date_parts[0]))  // Is not a number
  ) {
    array_shift($date_parts); // Remove first part
  }
  $date_str = trim(implode(',', $date_parts));
  return $date_str;
}

/**
 * Takes formatted date (in given timezone) and returns date array (second, minute, hour, day, month, year) in UTC
 * If $tz_name is not given, user's timezone is used.
 * There are possible limitations on what date formats it can translate from
 * depending on PHP version and if date_api.module is installed.
 */
function _ucca_date_from_str($date_str, $tz_name = '', $format = '') {
  if (!$tz_name) {
    $tz_name = _ucca_timezone_name();
  }
  if (!$format) {
    $format = variable_get('ucca_date_format', variable_get('date_format_short', 'm/d/Y - H:i'));
  }
  $date = FALSE;
  if (function_exists('date_create_from_format')) {
    $date = date_create_from_format($format, $date_str, timezone_open($tz_name)); // PHP5.3.0
  }
  if (!$date && UCCA_USE_DATEAPI && class_exists('DateObject')) { // using date_api
    $date = new DateObject($date_str, $tz_name, $format);
  }

  if (!$date) { // using PHP5
    $date = date_create($date_str, timezone_open($tz_name)); // PHP5.2.0
    if (!$date) {
      // Try to rectify some formats (the ones with weekday first, and space-dash-space between date & time)
      $date_str = _ucca_date_format_cleanup($date_str);
      $date = date_create($date_str, timezone_open($tz_name)); // PHP5.2.0
    }
    if (!$date) {
      return array('day' => '1', 'month' => 1, 'year' => 1970); // Give up
    }
  }

  date_timezone_set($date, timezone_open('UTC')); // PHP 5.2.0
  if (UCCA_USE_DATEAPI && function_exists('date_convert')) {
    $arr = date_convert($date, DATE_OBJECT, DATE_ARRAY);
    $return = array();
    foreach (array('second', 'minute', 'hour', 'day', 'month', 'year') as $f) {
      $return[$f] = $arr[$f];
    }
  }
  else {
    $return = array(
      'second' => (integer) date_format($date, 's'),  // PHP5.2.0
      'minute' => (integer) date_format($date, 'i'),
      'hour' => date_format($date, 'G'),
      'day' => date_format($date, 'j'),
      'month' => date_format($date, 'n'),
      'year' => date_format($date, 'Y'),
    );
  }
  return $return;
}

/**
 * User's or website default timezone name.
 */
function _ucca_timezone_name($check_user = TRUE) {
  global $user;
  if ($check_user && variable_get('configurable_timezones', 1) && $user->uid && !empty($user->timezone_name)) {
    return $user->timezone_name;
  }
  else {
    $default = variable_get('date_default_timezone_name', '');
    return empty($default) ? 'UTC' : $default;
  }
}

function _ucca_date_to_timestamp($date) {
  $date = $date ? (array) $date : array();
  $date += array('hour' => 0, 'minute' => 0, 'second' => 0);
  return gmmktime($date['hour'], $date['minute'], $date['second'], $date['month'], $date['day'], $date['year']);
}

/**
 * Our variant of drupal's format_date, uses date format from our settings
 */
function _ucca_format_date($timestamp, $tz_name = '') {
  $format = variable_get('ucca_date_format', variable_get('date_format_short', 'm/d/Y - H:i'));
  return _ucca_date_format($timestamp, $format, $tz_name);
}

/**
 * Submit form for no-js fallback of AHAH.
 */
function uc_cck_access_form_nojs_submit($form, &$form_state) {
  // Same as in AHAH submission, it's just the dependent field working.
  $form_state['ahah_submission'] = TRUE;
  $form_state['rebuild'] = TRUE;
}

/**
 * Form after build handler.
 * Disables validation for AHAH event.
 */
function uc_cck_access_handler_form_after_build($form, &$form_state) {
  //  We can't rely on $form_state['ahah_submission'] here
  if (isset($form_state['clicked_button']) && $form_state['clicked_button']['#value'] == t('Use handler (update form)')) {
    // Disable the subform
    _uc_cck_access_disable_validation($form);
  }
  return $form;
}

/**
 * Access handler selection form.
 * @param $default
 *  TRUE selects form for site-wide default configuration, FALSE selects product-feature specific form.
 */
function _uc_cck_access_handler_form($form_state, &$access = NULL, $default = TRUE) {
  $options = uc_cck_access_handlers_list();
  if (!$access) {
    $access = array();
  }
  if (empty($options)) {
    $options[''] = t('No access handlers available. You must install one to use this feature.');
  }

  if (isset($form_state['values']['ucca_default_handler'])) {
    $access['handler'] = $form_state['values']['ucca_default_handler'];
  }
  elseif (!isset($access['handler'])) {
    $access['handler'] = variable_get('ucca_default_handler', (count($options) == 1) ? reset($options) : '');
  }

  if ($default) {
    // Allow removal of default handler
    $options = array_merge(array(0 => t('(none)')), $options);
  }
  $form['ucca_default_handler'] = array(
    '#type' => 'radios',
    '#title' => $default ? t('Default access type') : t('Access type'),
    '#description' => ($default
        ? t('Select what access type will be automatically chosen in new CCK Access product features.')
        : t('Select what access type to include with this product.')),
    '#options' => $options,
    '#default_value' => $access['handler'],
    '#required' => TRUE,
    '#ajax' => $default ? '' : array(
      'callback' => 'uc_cck_access_handler_ahah',
      'wrapper' => 'handler-wrapper',
      'effect' => 'fade',
    ),
  );
  if (!$default) {
    $form['ucca_default_handler_pick'] = array(
      '#type' => 'submit',
      '#value' => t('Use handler (update form)'),
      // Submit the form so the handler options get updated.
      // This is typically only used when JS is disabled.  Since the handler options
      // won't be changed via AJAX, a button is provided in the form to submit
      // the form and generate options in the handler form corresponding to the
      // selected handler.
      '#submit' => array('uc_cck_access_form_nojs_submit'),
      // We set the 'js-hide' class, which means this submit button will be hidden
      // automatically by Drupal if JS is enabled (opposite of no-js).
      '#attributes' => array('class' => array('js-hide')),
    );
  }

  if ($default) {
    $time = REQUEST_TIME; // UTC
    // Date settings: possible date formats
    $date_formats = array('Y-m-d', 'm/d/Y', 'd/m/Y', 'Y/m/d',
             'd.m.Y',
             'M j Y', 'j M Y', 'Y M j');
    $date_formats = array_merge($date_formats, array('Y-m-d H:i', 'm/d/Y - H:i', 'd/m/Y - H:i', 'Y/m/d - H:i',
             'd.m.Y - H:i', 'm/d/Y - g:ia', 'd/m/Y - g:ia', 'Y/m/d - g:ia',
             'M j Y - H:i', 'j M Y - H:i', 'Y M j - H:i',
             'M j Y - g:ia', 'j M Y - g:ia', 'Y M j - g:ia'));
    $date_formats = array_merge($date_formats, array('D, Y-m-d H:i', 'D, m/d/Y - H:i', 'D, d/m/Y - H:i',
            'D, Y/m/d - H:i', 'F j, Y - H:i', 'j F, Y - H:i', 'Y, F j - H:i',
            'D, m/d/Y - g:ia', 'D, d/m/Y - g:ia', 'D, Y/m/d - g:ia',
            'F j, Y - g:ia', 'j F Y - g:ia', 'Y, F j - g:ia', 'j. F Y - G:i'));
    $date_formats = array_merge($date_formats, array('l, F j, Y - H:i', 'l, j F, Y - H:i', 'l, Y, F j - H:i',
          'l, F j, Y - g:ia', 'l, j F Y - g:ia', 'l, Y, F j - g:ia', 'l, j. F Y - G:i'));
    // Date settings: construct choices for user
    $date_format_choices = array();
    foreach ($date_formats as $f) {
      $str = format_date($time, 'custom', $f);
      // Verify that our date parser _ucca_date_from_str() can read the format back
      $date = _ucca_date_from_str($str, '', $f);
      $check = _ucca_date_format($date, $f, '');
      if ($str == $check) {
        $date_format_choices[$f] = $str;
      }
//@todo: Formats not working w/o date_api: 'd/m/Y' 'd/m/Y - H:i' 'd/m/Y - g:ia' 'Y M j' 'Y M j - H:i' 'Y M j - g:ia' 'D, d/m/Y - H:i' 'D, d/m/Y - g:ia' 'j F, Y - H:i' 'Y, F j - H:i' 'Y, F j - g:ia' 'l, j F, Y - H:i' 'l, Y, F j - H:i' 'l, Y, F j - g:ia'
//else drupal_set_message('Missing format '.$f.' str='.$str.' check='.$check);
    }

    $date_format = variable_get('ucca_date_format', variable_get('date_format_short', 'm/d/Y - H:i'));
    $form['ucca_date_format'] = array(
      '#prefix' => '<div class="date-container"><div class="select-container">',
      '#suffix' => '</div></div>',
      '#type' => 'select',
      '#title' => t('Display date format'),
      '#attributes' => array('class' => array('date-format')),
      '#default_value' => (isset($date_format_choices[$date_format]) ? $date_format : 'custom'),
      '#options' => $date_format_choices,
      '#description' => t('The format of date display for all UC CCK Access items (user and admin pages, log messages).'),
    );

    $form['ucca_node_weight'] = array(
      '#type' => 'weight',
      '#title' => t('Node item page weight'),
      '#description' => t('Set the default position for the list of content on the product page.<br />Refer to the <a href="/admin/store/settings/products/edit/fields">Product Field settings</a> for other element weights.'),
      '#default_value' => variable_get('ucca_node_weight', 9),
      '#delta' => 100,
    );
  }
  // Add AHAH handler and prepare container for dependent subform
  $form['handler_form'] = array(
    '#tree' => TRUE,
    '#prefix' => "<div id='handler-wrapper'>",
    '#suffix' => "</div>",
  );

  $form['#after_build'][] = 'uc_cck_access_handler_form_after_build';

  return $form;
}

/**
 * Submit function for _uc_cck_access_handler_form subform.
 * Processes input and fills $access record.
 *
 * Outputs:
 *   $access['handler'] - access handler
 *
 */
function _uc_cck_access_handler_form_submit($form, &$form_state, &$access) {
  $access['handler'] = $form_state['values']['ucca_default_handler'];
}

/**
 * Adds the fields for this feature in the product features settings form.
 */
function uc_cck_access_feature_settings_form($form, &$form_state) {
  $form += _uc_cck_access_handler_form($form_state); // SUBFORM
  return $form;
}

/**
 * Save feature record to DB.
 */
function uc_cck_access_feature_save($data) {
  // Prepare access records through the current universal access handler.
  uc_cck_access_op($data['handler'], 'delay', NULL, 0, $data['access_id'], $data['data']);

  // Attempt to update an existing row or insert a new one.
  db_merge('uc_cck_access_products')
    ->key(array('pfid' => $data['pfid']))
    ->fields(array(
      'model' => $data['model'],
      'access_id' => $data['access_id'],
      'delay_type' => $data['delay_type'],
      'delay_period' => $data['delay_period'],
      'delay_date' => serialize($data['delay_date']),
      'duration_type' => $data['duration_type'],
      'duration_period' => $data['duration_period'],
      'duration_date' => serialize($data['duration_date']),
      'handler' => $data['handler'],
      'data' => serialize($data['data']),
    ))
    ->execute();
}

/**
 * Load feature record from DB.
 */
function uc_cck_access_feature_load($pfid) {
  $query = db_select('uc_cck_access_products', 'cap');
  $query->innerJoin('uc_product_features', 'pf', 'cap.pfid = pf.pfid');
  $query->fields('cap');
  $query->fields('pf', array('nid'));
  $query->condition('cap.pfid', $pfid);
  $access = $query->execute()->fetchAssoc();
  if (!empty($access)) {
    list($access['delay_period_value'], $access['delay_period_unit']) = explode(' ', $access['delay_period']);
    $access['delay_date'] = unserialize($access['delay_date']);
    list($access['duration_period_value'], $access['duration_period_unit']) = explode(' ', $access['duration_period']);
    $access['duration_date'] = unserialize($access['duration_date']);
    $access['data'] = unserialize($access['data']);
  }
  return $access;
}

/**
 * Load node feature records from DB.
 */
function uc_cck_access_node_features($node, $prepare_details = FALSE) {
  $return = array();
  $query = db_select('uc_cck_access_products', 'cap');
  $query->innerJoin('uc_product_features', 'pf', 'cap.pfid = pf.pfid');
  $query->fields('cap')
    ->condition('pf.nid', $node->nid)
    ->condition('pf.fid', 'cck_access');
  $result = $query->execute();
  while ($access = $result->fetchAssoc()) {
    list($access['delay_period_value'], $access['delay_period_unit']) = explode(' ', $access['delay_period']);
    $access['delay_date'] = unserialize($access['delay_date']);
    list($access['duration_period_value'], $access['duration_period_unit']) = explode(' ', $access['duration_period']);
    $access['duration_date'] = unserialize($access['duration_date']);
    $access['data'] = unserialize($access['data']);

    if ($prepare_details) {
      // Pass $node into info functions to avoid calling infinite nesting of node_load().
      $access['node'] = $node;
      $access['item_description'] = uc_cck_access_call_handler($access, 'describe', $access, array('short' => 1));
      $access['items'] = uc_cck_access_call_handler($access, 'describe_data', $access);
      $access['delay_description'] = _uc_cck_access_delay_description($access);
      $access['duration_description'] = _uc_cck_access_duration_description($access);
    }

    $return[$access['pfid']] = $access;
  }
  return $return;
}

/**
 * Delete records associated with the feature from DB.
 *
 * @param $access_or_feature
 *   Either uc_product feature array or our $access record array.
 * @param $do_pf
 *   Optional. If set, also delete record from uc_product_features
 */
function uc_cck_access_feature_delete($access_or_feature, $do_pf = FALSE) {
  if (!empty($access_or_feature) && !isset($access_or_feature['handler'])) {
    $access = uc_cck_access_feature_load($access_or_feature['pfid']);
  }
  else {
    $access = $access_or_feature;
  }
  uc_cck_access_op($access['handler'], 'delete', NULL, NULL, $access['access_id'], $access['data']);
  // expire all (regardless of time) for $access['pfid'] and delete {uc_cck_access_expirations}
  uc_cck_access_process_expirations(array('pfid' => $access['pfid']));
  db_delete('uc_cck_access_delays')
    ->condition('pfid', $access['pfid'])
    ->execute();
  db_delete('uc_cck_access_products')
    ->condition('pfid', $access['pfid'])
    ->execute();
  if ($do_pf) {
    db_delete('uc_product_features')
      ->condition('pfid', $access['pfid'])
      ->execute();
    // @todo: shall we call some hook or API function instead (so appropriate cleanup is done)? Watch out for infinite recursion.
  }
}

/**
 * Find UC CCK Access product features that satisfy given $conditions.
 * @param $conditions - associative array ($field => $condition) of conditions (all checks are equal and will be 'AND'ed)
 * fields are: pfid, access_id, ... (all %d format)
 */
function uc_cck_access_find_features($conditions) {
  $query = db_select('uc_cck_access_products', 'cap');
  $query->innerJoin('uc_product_features', 'pf', 'pf.pfid = cap.pfid');
  $query->fields('cap')->fields('pf');
  foreach ($conditions as $field => $condition) {
    $query->condition($field, $condition);
  }

  $return = array();
  $result = $query->execute();
  while ($feature = $result->fetchAssoc()) {
    list($feature['delay_period_value'], $feature['delay_period_unit']) = explode(' ', $feature['delay_period']);
    $feature['delay_date'] = unserialize($feature['delay_date']);
    list($feature['duration_period_value'], $feature['duration_period_unit']) = explode(' ', $feature['duration_period']);
    $feature['duration_date'] = unserialize($feature['duration_date']);
    $feature['data'] = unserialize($feature['data']);
    $return[] = $feature;
  }
  return $return;
}

/**
 * Invoke feature's handler operation.
 */
function uc_cck_access_op($handler, $op, $uaid, $uid, $access_id, $data = NULL) {
  // Fail if we receive an invalid uaid/access_id or uid or if the access handler hasn't been specified or has been uninstalled.
  if (
    (intval($uaid) <= 0 && intval($access_id) <= 0)
    || (intval($uid) <= 0 && $op != 'delay' && $op != 'delete')
    || empty($handler) || !function_exists($handler)
  ) {
    watchdog('uc_cck_access', 'Invalid arguments passed to Universal Access ($op=@op, $uaid=@uaid, $uid=@uid, $access_id=@access_id $handler=@handler).',
      array('@op' => $op, '@uaid' => $uaid, '@uid' => $uid, '@access_id' => $access_id, '@handler' => $handler), WATCHDOG_WARNING);
    return;
  }

  // Pass the arguments onto the handler for processing.
  $result = $handler($op, $uaid, $access_id, $uid, $data);

  // Log failed universal access operations.
  if ($result === FALSE) {
    watchdog('uc_cck_access', 'Universal Access operation failed ($op=@op, $uid=@uid, $access_id=@access_id, $data=<pre>@data</pre>)',
      array('@op' => $op, '@access_id' => $access_id, '@uid' => $uid, '@data' => print_r($data, 1)), WATCHDOG_WARNING);
  }
}

/**
 * Calculate an inception timestamp based on the site's timezone.
 */
function _uc_cck_access_inception($access) {
  switch ($access['delay_type']) {
    case 'period':
      $inception = strtotime('+' . $access['delay_period']);
      break;
    case 'date':
      $inception = _ucca_date_to_timestamp($access['delay_date']);
      break;
    default:
      $inception = FALSE;
  }
  return $inception;
}

/**
 * Calculate an expiration timestamp based on the site's timezone.
 */
function _uc_cck_access_expiration($access, $inception = FALSE) {
  switch ($access['duration_type']) {
    case 'period':
      $expiration = $inception ? strtotime('+' . $access['duration_period'], $inception) : strtotime('+' . $access['duration_period']);
      break;
    case 'date':
      $expiration = _ucca_date_to_timestamp($access['duration_date']);
      break;
    default:
      $expiration = FALSE;
  }
  return $expiration;
}

/**
 * Compare two access items - $item against $access
 * @return - an array of $lesser, $more, $conflict, $interfere (boolean)
 *  lesser=1    if $item gives less time & access aspects than $access
 *  more=1      if $access gives less time & access aspects than $item
 *  interfere=1 if $item has expiration that will affect $access aspects
 *  conflict=1  if $access has expiration that will affect $item aspects
 */
function _uc_cck_access_compare_items($item, $access, $time) {
  $my_inception = $access['inception'] ? $access['inception'] : $time; // Effective inception time
  $lesser = (
    ($item['inception'] >= $my_inception)
    && (!$access['expiration'] || ($item['expiration'] && ($item['expiration'] <= $access['expiration'])))
    && uc_cck_access_call_handler($access, 'lesser_data', $item['data'], $access['data'])
  );

  $more = (
    ($item['inception'] <= $my_inception)
    && (!$item['expiration'] || ($access['expiration'] && ($item['expiration'] >= $access['expiration'])))
    && uc_cck_access_call_handler($access, 'lesser_data', $access['data'], $item['data'])
  );

  // Interfering item is the one that will inadvertently expire one of aspects in our access item
  // and the one we cannot remove as it gives access to other aspects that we don't have.
  $interfere = !$lesser && $item['expiration']
    && ($my_inception <= $item['expiration'])
    && (!$access['expiration'] || ($item['expiration'] <= $access['expiration']))
    && uc_cck_access_call_handler($access, 'intersecting_data', $item['data'], $access['data'])
  ;

  // Conflict item is the one that will inadvertently expire one of aspects in other item
  // and the one we cannot remove as it gives access to other aspects that access doesn't have.
  $conflict = !$more && $access['expiration']
    && (!$item['inception'] || ($item['inception'] <= $access['expiration']))
    && (!$item['expiration'] || ($access['expiration'] <= $item['expiration']))
    && uc_cck_access_call_handler($access, 'intersecting_data', $access['data'], $item['data'])
  ;

  return array($lesser, $more, $interfere, $conflict);
}

/**
 * Main worker for adding new schedule items and resolving conflicts with existing items.
 * @param $access - fully populated access record, pfid expanded into handler,access_id,data
 * @param $uid - user id
 * @param $replace_all - if TRUE, replace all current schedule that affects given $access (note: can be very destructive and affect access to other items!)
 * @return - log array() where each element is an array(text, array(vars)) with elements suitable for t()
 *
 * In our schema there can be no pfid so a direct schedule without product
 * feature can be created. There is no easy way to find delay or expiration
 * records that will conflict with our new grant schedule. So we are looking
 * at all scheduled items and replace all lesser (from customer's perspective)
 * items. Lesser from that perspective means an item that is completely
 * covered by new delay and expiration if we're to plot a time chart of
 * access item aspects (elements that are inside the data record), i.e. the
 * lesser item starts later and ends sooner, and has access aspects that are
 * also present in the new grant. We can keep multiple delays and expirations
 * as long as they will not revoke access grant set by the new record. We
 * check for their expiration that it won't remove our grant prematurely. If
 * we find items that have expiration that will remove our grant (we call
 * those "conflict" items) - we will schedule another delayed grant right
 * after the conflicting expiration. Thus we avoid a need to come up with
 * any calculations for sets of aspects (which can be quite tricky to
 * delegate to access handlers).
 */
function _uc_cck_access_process_user_access($access, $uid, $replace_all = FALSE) {
$op = 'view';
$tz_name = 'UTC';  // Use for log purpose
  $log = array();
  if (empty($access) || $uid == 0) {
    return $log;
  }
  $time = REQUEST_TIME; // UTC

  // If cron was not running, we may have a bunch of schedule items that just
  // need to go away.
  // Perform our housekeeping - ala poorman's cron.
  // Process any expired CCK access rules.
  uc_cck_access_process_expirations(array('expiration' => $time));
  // Process any delayed CCK access rules.
  uc_cck_access_process_delays(array('inception' => $time));
  // Delayed grants from the above call can create new expiration records that
  // suppose to happen in the past. Do the processing once more to clear them out.
  uc_cck_access_process_expirations(array('expiration' => $time));

  // Sanitize the record
  if (!$access['duration_type']) {
    $access['duration_type'] = 'unlimited';
  }

  $access['item_description']  = $item = uc_cck_access_call_handler($access, 'describe', $access);

  $access['inception']  = $inception  = _uc_cck_access_inception($access);
  $access['expiration'] = $expiration = _uc_cck_access_expiration($access, $inception ? $inception : $time);

  $log_args = array(
    '!user' => _uc_cck_access_user($uid),
    '!new_item' => $item,
    '!new_start_date' => $inception
      ? t('start @date', array('@date' => _ucca_format_date($inception, $tz_name)))
      : t('start immediately'),
    '!new_end_date' => $expiration
      ? t('expire on @date', array('@date' => _ucca_format_date($expiration, $tz_name)))
      : t('unlimited time'),
    '!reason1' => $replace_all ? t('is forced') : t('gives more time and/or sooner access'),
    '!reason2' => $replace_all ? t('is forced') : t('gives more time'),
  );

  // We will collect expirations of interfering and conflicting records here
  $interfere_expirations = array();
  $conflict_expirations = array();

  // Scan through all existing schedule records for the uid, pfid (if given), access_id and handler
  $conditions = array('uid' => $uid);
  foreach (array('pfid', 'handler', 'access_id') as $field) {
    if ($access[$field]) {
      $conditions[$field] = $access[$field];
    }
  }
  $items = uc_cck_access_get_schedule($conditions, TRUE);

  foreach ($items as $row) {
    $log_args['!old_item'] = uc_cck_access_call_handler($row, 'describe', $row);
    // Process all delay items in the row
    if (isset($row['dids'])) {
      foreach ($row['dids'] as $did => $item) {
        $log_args['!old_start_date'] = $item['inception']
          ? _ucca_format_date($item['inception'], $tz_name)
          : t('already available');
        if (!$item['inception']) {
          $item['inception'] = $time;  // Assume all grants just recently given
          $item['granted'] = TRUE;
        }
        $log_args['!old_end_date'] = $item['expiration']
          ? t('expire on @date', array('@date' => _ucca_format_date($item['expiration'], $tz_name)))
          : t('unlimited time');
        list($lesser, $more, $interfere, $conflict) = $replace_all
          ? array(1, 0, 0, 0)
          : _uc_cck_access_compare_items($item, $access, $time);

        if ($more) {
          // Detected duplicate access
          $log[] = array('User !user purchased duplicate !new_item (!new_start_date, !new_end_date) that won\'t give more access and/or longer time than their current access. Old item kept and new item ignored.', $log_args);
          return $log;
        }
        if ($lesser) {
          if (!empty($item['granted']) && empty($row['revoked'])) { // it would have been (!$item['inception']), but we set it few lines above
            // There is no real delay record - it is a fake/virtual granted access item that we inserted and marked 'inception'=FALSE
            // It may have a real expiration record, but we won't touch it here - it will be dealt with later in the foreach eids loop
            // Remove access grant through the current universal access handler.
            uc_cck_access_op($access['handler'], 'revoke', NULL, $uid, $row['access_id'], $row['data']);
            $row['revoked'] = TRUE;
            $log[] = array('User !user !old_item (!old_start_date, !old_end_date) was removed as new !new_item !reason1 (!new_start_date, !new_end_date).', $log_args);
          }
          else {
            // Delete {uc_cck_access_delays} record, so it does not interfere with new grants schedule
            db_delete('uc_cck_access_delays')
              ->condition('did', $did)
              ->execute();
            $log[] = array('User !user delayed !old_item (!old_start_date, !old_end_date) was removed as new !new_item !reason1 (!new_start_date, !new_end_date).', $log_args);
          }
          unset($row['inceptions'][$did], $row['inceptions_calc'][$did]);
          unset($row['expirations']['did' . $did], $row['expirations_calc']['did' . $did]);
        }
        else {
          // Save it so we can consolidate them all and process at once later (if we don't kill our access in case of $more)
          if ($interfere) {
            $interfere_expirations[] = $item['expiration'];
          }
          if ($conflict) {
            $conflict_expirations[] = $item; // need whole item so we can create delay grant
          }
        }
      } // foreach ($did=> $item)
    }

    // Process all expiration items in the row
    if (isset($row['eids'])) {
      foreach ($row['eids'] as $eid => $item) {
        $item['inception'] = $time; // Pretend all expirations were just granted (as we don't know better)
        $log_args['!old_start_date'] = $item['inception']
          ? _ucca_format_date($item['inception'], $tz_name)
          : t('already available');
        if (!$item['inception']) {
          $item['inception'] = $time; // Assume all grants just recently given
          $item['granted'] = TRUE;
        }
        $log_args['!old_end_date'] = $item['expiration']
          ? t('expire on @date', array('@date' => _ucca_format_date($item['expiration'], $tz_name)))
          : t('unlimited time');
        list($lesser, $more, $interfere, $conflict) = $replace_all
          ? array(1, 0, 0, 0)
          : _uc_cck_access_compare_items($item, $access, $time);

        if ($more) {
          // Detected duplicate access
          $log[] = array('User !user purchased duplicate !new_item (!new_start_date, !new_end_date) that won\'t give more access and/or longer time than their current access. Old item kept and new item ignored.', $log_args);
          return $log;
        }
        if ($lesser) {
          // This is redundand and should be no-op as $row['revoked'] must be already set above.
          // Left here just in case some edit to uc_cck_access_get_schedule() populates bookends incorrectly.
          if ($access['inception'] && empty($row['revoked'])) {
            // This is a forced new delay record ($replace_all == TRUE, $item['granted'] == TRUE)
            // Remove access grant through the current universal access handler.
            uc_cck_access_op($access['handler'], 'revoke', NULL, $uid, $access['access_id'], $access['data']);
            $row['revoked'] = TRUE;
            $log[] = array('eid=' . $eid . ' User !user !old_item (!old_start_date, !old_end_date) was removed as new !new_item !reason1 (!new_start_date, !new_end_date).', $log_args);
          }
          // Delete {uc_cck_access_expirations} record, so it does not interfere with new grants schedule
          db_delete('uc_cck_access_expirations')
            ->condition('eid', $eid)
            ->execute();
          unset($row['expirations'][$eid], $row['expirations_calc'][$eid]);
          $log[] = array('User !user expiration of !old_item (!old_end_date) was removed as new !new_item !reason2 (!new_start_date, !new_end_date).', $log_args);
          continue; // foreach ($eid=> $item)
        }
        else {
          // Save it so we can consolidate them all and process at once later (if we don't kill our access in case of $more)
          if ($interfere) {
            $interfere_expirations[] = $item['expiration'];
          }
          if ($conflict) {
            $conflict_expirations[] = $item; // need whole item so we can create delay grant
          }
        }
      } // foreach ($eid=> $item)
    }
  }  // foreach ($row)

  // Create delayed grant
  if ($inception) {
    // Notify current universal access handler of new greant.
    $access['inception'] = $inception;
    $log = array_merge($log, _uc_cck_access_delay_user_access($access, $uid));
  }

  // Process the list of interferences - create delayed grants (no expiration) to reinstate access
  $interfere_expirations = array_unique($interfere_expirations, SORT_NUMERIC);
  foreach ($interfere_expirations as $new_delay) {
    $new_delay = $new_delay + 1;
    // +1 to ensure that delay never kicks in before the expiration time which it is supposed to fix
    $log_args['!new_start_date'] = t('start @date', array('@date' => _ucca_format_date($new_delay, $tz_name)));
    $id = db_insert('uc_cck_access_delays')
      ->fields(array(
        'uid' => $uid,
        'pfid' => $access['pfid'] ? $access['pfid'] : NULL,
        'inception' => $new_delay,
        'duration_type' => 'unlimited',
        'duration_period' => '',
        'duration_date' => '',
        'handler' => $access['handler'],
        'access_id' => $access['access_id'],
        'data' => serialize($access['data']),
      ))
      ->execute();
    $log[] = array('Added delayed grant for user !user (!new_start_date) to compensate for interference from expiration of other item.', $log_args);
  } // foreach ($new_delay)

  // Process the list of conflicts - we create new delay for each item we create conflict that would reinstate what our record will screw up
  $new_delay = $expiration + 1;
  $log_args['!new_start_date'] = t('start @date', array('@date' => _ucca_format_date($new_delay, $tz_name)));
  foreach ($conflict_expirations as $item) {
    $id = db_insert('uc_cck_access_delays')
      ->fields(array(
        'uid' => $uid,
        'pfid' => $item['pfid'] ? $item['pfid'] : NULL,
        'inception' => $new_delay,
        'duration_type' => 'unlimited',
        'duration_period' => '',
        'duration_date' => '',
        'handler' => $item['handler'],
        'access_id' => $item['access_id'],
        'data' => serialize($item['data']),
      ))
      ->execute();
    $log[] = array('Added delayed grant for user !user (!new_start_date) to compensate for conflict from expiration of new item.', $log_args);
  } // foreach ($item)

  // If no inception we need to add a grant and set expiration in DB
  if (!$inception) {
    $log = array_merge($log, _uc_cck_access_grant_user_access($access, $uid));
  }
  return $log;
}

/**
 * @return - log array() where each element is an array(text, array(vars)) with elements suitable for t()
 */
function uc_cck_access_process_user_access($pfid, $uid, $replace_all = FALSE) {
  $access = uc_cck_access_feature_load($pfid);
  return _uc_cck_access_process_user_access($access, $uid, $replace_all);
}

/**
 * Build a SQL WHERE statement for metatable SELECT based on given $conditions.
 * Metatable is a JOIN between $base and {uc_cck_access_products} AS cap on pfid
 * @param $conditions - associative array($field => $value)
 *   'access_id' and 'handler' are treated to select both from $base and JOIN'ed {uc_cck_access_products}
 *   if 'pfid' is given, a special treatment of 'access_id' and 'handler' is done to build an OR-AND-OR query.
 * @param $base - table name for values
 */
function _uc_cck_access_sql_where_metatable($query, $conditions, $base) {
  if (!empty($conditions['pfid']) && !empty($conditions['handler']) && !empty($conditions['access_id'])) {
    $query->condition(
      db_or()
        ->condition(
          db_and()
            ->isNull("$base.pfid")
            ->condition("$base.handler", $conditions['handler'])
            ->condition("$base.access_id", $conditions['access_id'])
        )
        ->condition(
          db_and()
            ->isNotNull("$base.pfid")
            ->condition("cap.handler", $conditions['handler'])
            ->condition("cap.access_id", $conditions['access_id'])
        )
        ->condition("$base.pfid", $conditions['pfid'])
    );

    unset($conditions['pfid'], $conditions['handler'], $conditions['access_id']);
  }
  foreach ($conditions as $field => $condition) {
    if ($field == 'uid') {
      $field = $base . '.' . $field;
    }
    if ($field == 'pfid') {
      $field = $base . '.' . $field;
    }
    // Treat pfid = 0 and pfid != 0 for $field==access_id, handler
    if ($field == 'access_id' || $field == 'handler') {
      $query->condition(
        db_or()
          ->condition(
            db_and()
              ->isNull("$base.pfid")
              ->condition("$base.$field", $condition)
          )
          ->condition(
            db_and()
              ->isNotNull("$base.pfid")
              ->condition("cap.$field", $condition)
          )
      );
    }
    else {
      $query->condition($field, $condition);
    }
  }
  return $query;
}

/**
 * Get a list of access delays that satisfy given $conditions.
 */
function uc_cck_access_find_delays($conditions, $key_by = 'did') {
  $query = db_select('uc_cck_access_delays', 'ad')
    ->fields('ad');
  $query->innerJoin('users', 'u', 'ad.uid = u.uid');
  $query->leftJoin('uc_cck_access_products', 'cap', 'ad.pfid = cap.pfid');
  $query->fields('u', array('name'));
  $query->addField('cap', 'duration_type', 'cap_duration_type');
  $query->addField('cap', 'duration_period', 'cap_duration_period');
  $query->addField('cap', 'duration_date', 'cap_duration_date');
  $query->addField('cap', 'access_id', 'cap_access_id');
  $query->addField('cap', 'handler', 'cap_handler');
  $query->addField('cap', 'data', 'cap_data');
  $query = _uc_cck_access_sql_where_metatable($query, $conditions, 'ad');
  $result = $query->execute();
  $return = array();
  while ($row = $result->fetchAssoc()) {
    if ($row['pfid']) {
      // Copy from {uc_cck_access_products} fields if {uc_cck_access_delays}.pfid is set.
      $row['duration_type'] = $row['cap_duration_type'];
      $row['duration_period'] = $row['cap_duration_period'];
      $row['duration_date'] = $row['cap_duration_date'];
      $row['access_id'] = $row['cap_access_id'];
      $row['handler'] = $row['cap_handler'];
      $row['data'] = $row['cap_data'];
    }
    list($row['duration_period_value'], $row['duration_period_unit']) = explode(' ', $row['duration_period']);
    $row['duration_date'] = unserialize($row['duration_date']);
    // Calculate expiration for this delay record
    $row['expiration'] = _uc_cck_access_expiration($row, $row['inception']);
    $row['data'] = unserialize($row['data']);
    $row['item_type'] = 'delay';
    $row['items'] = uc_cck_access_call_handler($row, 'describe_data', $row);
    if ($key_by) {
      $return[$row[$key_by]] = $row;
    }
    else {
      $return[] = $row;
    }
  }
  return $return;
}

/**
 * Get a list of granted access expirations that satisfy given $conditions.
 * @param $conditions - associative array ($field => $condition) of conditions (all checks are equal and will be 'AND'ed)
 * acess_id and handler fields will be checked for both pfid=NULL and pfid!=NULL
 * fields are: pfid, access_id, handler, ... (all %d format)
 */
function uc_cck_access_find_expirations($conditions, $key_by = 'eid') {
  $time = REQUEST_TIME; // UTC
  $query = db_select('uc_cck_access_expirations', 'ae')
    ->fields('ae');
  $query->innerJoin('users', 'u', 'ae.uid = u.uid');
  $query->leftJoin('uc_cck_access_products', 'cap', 'ae.pfid = cap.pfid');
  $query->fields('u', array('name'));
  $query->addField('cap', 'access_id', 'cap_access_id');
  $query->addField('cap', 'handler', 'cap_handler');
  $query->addField('cap', 'data', 'cap_data');
  $query = _uc_cck_access_sql_where_metatable($query, $conditions, 'ae');
  $result = $query->execute();
  $return = array();
  while ($row = $result->fetchAssoc()) {
    if ($row['pfid']) {
      // Copy from {uc_cck_access_products} fields if {uc_cck_access_expirations}.pfid is set.
      $row['access_id'] = $row['cap_access_id'];
      $row['handler'] = $row['cap_handler'];
      $row['data'] = $row['cap_data'];
    }
    $row['inception'] = $time; // Assume all expiration records started now
    $row['data'] = unserialize($row['data']);
    $row['item_type'] = 'expiration';
    $row['items'] = uc_cck_access_call_handler($row, 'describe_data', $row);
    if ($key_by) {
      $return[$row[$key_by]] = $row;
    }
    else {
      $return[] = $row;
    }
  }
  return $return;
}

/**
 * Worker function to queue delayed access.
 * @return - log array() where each element is an array(text, array(vars)) with elements suitable for t()
 * No processing of conflicts is done - it all should be already processed.
 * All elements of $access should be loaded, (e.g. pfid expanded into handler,access_id,data),
 * 'inception', 'expiration' and 'duration_*' calculated
 * $access['handler']   - access handler to set/remove grants
 * $access['access_id'] - for $access['handler'] only
 * $access['data']      - for $access['handler'] only
 * $access['inception']       - already calculated inception timestamp,
 * $access['expiration']      - already calculated expiration timestamp (for log purposes),
 */
function _uc_cck_access_delay_user_access($access, $uid) {
$tz_name = 'UTC';  // Use for log purpose
  $inception = $access['inception'];
  $log = array();
  $log_args = array(
    '!user' => _uc_cck_access_user($uid),
    '!new_item' => $access['item_description'],
    '!new_start_date' => t('start @date', array('@date' => _ucca_format_date($inception, $tz_name))),
    '!new_end_date' => $access['expiration']
      ? t('expire on @date', array('@date' => _ucca_format_date($access['expiration'], $tz_name)))
      : t('unlimited time'),
  );

  // Prepare access records through the current universal access handler.
  uc_cck_access_op($access['handler'], 'delay', NULL, $uid, $access['access_id'], $access['data']);

  $id = db_insert('uc_cck_access_delays')
    ->fields(array(
      'uid' => $uid,
      'pfid' => $access['pfid'] ? $access['pfid'] : NULL,
      'inception' => $inception,
      'duration_type' => $access['duration_type'],
      'duration_period' => $access['duration_period'],
      'duration_date' => serialize($access['duration_date']),
      'handler' => $access['handler'],
      'access_id' => $access['access_id'],
      'data' => serialize($access['data']),
    ))
    ->execute();
  $log[] = array('User !user will be granted !new_item (!new_start_date, !new_end_date).', $log_args);

  return $log;
}

/**
 * Worker function to grant access and set expiration.
 * @return - log array() where each element is an array(text, array(vars)) with elements suitable for t()
 * No processing of conflicts is done - it all should be already processed.
 * $access['pfid'] - (optional) if set, use product feature to set expiration
 * if $access['pfid'] is not set, then:
 * $access['handler']   - access handler to set/remove grants
 * $access['access_id'] - for $access['handler'] only
 * $access['data']      - for $access['handler'] only
 * Either $access['expiration']      - already calculated expiration timestamp,
 * Or     $access['duration_type']   - one of 'period', 'date', other = unlimited
 *        $access['duration_period'] - duration string
 *        $access['duration_date']   - array of 'month', 'day', 'year'
 */
function _uc_cck_access_grant_user_access($access, $uid) {
$tz_name = 'UTC';  // Use for log purpose
  $log = array();
  if (isset($access['pfid']) && $access['pfid']) {
    // Load up the CCK access product feature and access data.
    $access = uc_cck_access_feature_load($access['pfid']);
  }
  if (empty($access) || $uid == 0) {
    return $log;
  }

  // Grant access for the user through the current universal access handler.
  uc_cck_access_op($access['handler'], 'grant', NULL, $uid, $access['access_id'], $access['data']);

  if (!isset($access['expiration'])) {
    $access['expiration'] = _uc_cck_access_expiration($access);
  }
  if (!isset($access['item_description'])) {
    $access['item_description'] = uc_cck_access_call_handler($access, 'describe', $access);
  }

  // Set the expiration in the DB if necessary.
  if ($access['expiration']) {
    $id = db_insert('uc_cck_access_expirations')
      ->fields(array(
        'uid' => $uid,
        'pfid' => $access['pfid'] ? $access['pfid'] : NULL,
        'expiration' => $access['expiration'],
        'handler' => $access['handler'],
        'access_id' => $access['access_id'],
        'data' => serialize($access['data']),
      ))
      ->execute();
    $log[] = array('User !user granted !new_item until @new_end_date.',
      array('!user' => _uc_cck_access_user($uid), '!new_item' => $access['item_description'], '@new_end_date' => _ucca_format_date($access['expiration'], $tz_name)));
  }
  else {
    $log[] = array('User !user granted !new_item for unlimited time.',
      array('!user' => _uc_cck_access_user($uid), '!new_item' => $access['item_description']));
  }
  return $log;
}

/**
 * Utility function for the ahah handler
 * Adopted from ahah_helper module's code http://drupal.org/project/ahah_helper
 * Disable #required and #element_validate validation.
 *
 * @param unknown_type $form
 */
function _uc_cck_access_disable_validation(&$form) {
  foreach (element_children($form) as $child) {
    $form[$child]['#validated'] = TRUE;
    _uc_cck_access_disable_validation($form[$child]);
  }
}

/**
 * Returns an AHAH response for handler selector on the CCK access product feature form.
 */
function uc_cck_access_handler_ahah($form, $form_state) {
  // Enable the submit/validate handlers to determine whether AHAH-submittted.
  $form_state['ahah_submission'] = TRUE;

  // Disable validation since the form may be not yet filled in completely
  if (!isset($_POST['op'])) {
    _uc_cck_access_disable_validation($form);
  }

  // Get the specific form item
  $subform =
    isset($form['handler_form']) ? $form['handler_form']
      : (isset($form['add_grant']['grant']['handler_form']) ? $form['add_grant']['grant']['handler_form']
        : array());
  return $subform;
}

/*******************************************************************************
 * Rules Integration
 ******************************************************************************/

/**
 * Action for rules, process all uc_cck_access product features and set up access schedule
 */
function uc_cck_access_delay_access($order) {
  if (is_array($order->products)) {
    $nids = array();
    $models = array();
    foreach ($order->products as $product) {
      $nids[] = $product->nid;
      $models[] = $product->model;
    }

    $query = db_select('uc_product_features', 'pf');
    $query->leftJoin('uc_cck_access_products', 'cap', 'pf.pfid = cap.pfid');
    $query->condition('pf.nid', $nids, 'IN');
    $query->condition('pf.fid', 'cck_access');
    $query->addField('pf', 'pfid');
    $query->addField('cap', 'model');
    $result = $query->execute();
    while ($row = $result->fetchAssoc()) {
      if (empty($row['model']) || in_array($row['model'], $models)) {
        $log = uc_cck_access_process_user_access($row['pfid'], $order->uid);
        _uc_cck_access_log_to_watchdog($log);
      }
    }
  }
}

/**
 * Action for rules, process all uc_cck_access product features and set up access schedule, overriding delay setting (forcing immediate access grant)
 */
function uc_cck_access_grant_access($order) {
  if (is_array($order->products)) {
    $nids = array();
    $models = array();

    foreach ($order->products as $product) {
      $nids[] = $product->nid;
      $models[] = $product->model;
    }

    $query = db_select('uc_product_features', 'pf');
    $query->leftJoin('uc_cck_access_products', 'cap', 'pf.pfid = cap.pfid');
    $query->condition('pf.nid', $nids, 'IN');
    $query->condition('pf.fid', 'cck_access');
    $query->addField('pf', 'pfid');
    $query->addField('cap', 'model');
    $result = $query->execute();
    while ($row = $result->fetchAssoc()) {
      if (empty($row['model']) || in_array($row['model'], $models)) {
        // Use _uc_cck_access_process_user_access() so we remove conflicts properly
        // Implement uc_cck_access_process_user_access($row['pfid'], $order->uid), but override delay setting
        $access = uc_cck_access_feature_load($row['pfid']);
        $access['delay_type'] = 'immediate'; // Force immediate access
        $log = _uc_cck_access_process_user_access($access, $order->uid);
        _uc_cck_access_log_to_watchdog($log);
      }
    }
  }
}

/*******************************************************************************
 * Themes and Output
 ******************************************************************************/

/**
 * Theme the admin add new access form on the user's content page.
 *
 * @ingroup themeable
 */
function theme_uc_cck_access_add_grant($variables) {
  $form = $variables['form'];
  $output = '';

  $output .= '<div class="uc-cck-access-add-grant">';
  $output .= drupal_render($form['new_cck_access']);
  $output .= drupal_render($form['new_cck_access_force']);
  $output .= drupal_render($form['ucca_default_handler']);
  $output .= drupal_render($form['ucca_default_handler_pick']);
  $output .= drupal_render($form['handler_form']);
  $output .= drupal_render_children($form); // The rest of the form (items already rendered will not be included again)
  $output .= '</div>';

  return $output;
}

/**
 * Theme the access items table on the user's content page.
 *
 * @ingroup themeable
 */
function theme_uc_cck_access_grant_items($variables) {
  $form = $variables['form'];
  $admin = $form['##admin'];
  $self = $form['##self'];
  $output = '';
  $rows = array();

  $header = array();
  if ($admin) {
    $header[] = array('data' => t('Operations'));
  }
  $header[] = array('data' => t('Item'));
  $header[] = array('data' => t('Available on'));
  $header[] = array('data' => t('Expiration'));
  if ($admin) {
    $header[] = array('data' => t('Adjust expiration'));
  }

  foreach (element_children($form) as $handler) {
    $handler_data = &$form[$handler];
    if (empty($handler_data['grant_items_table'])) {
      continue;
    }
    foreach (element_children($handler_data['grant_items_table']) as $key) {
      $data = &$handler_data['grant_items_table'][$key];
      $expiration_widget = '<div class="expiration">';
      $expiration_widget .= drupal_render($data['polarity']);
      $expiration_widget .= drupal_render($data['quantity']);
      $expiration_widget .= drupal_render($data['granularity']);
      $expiration_widget .= '</div>';

      $row = array();
      if ($admin) {
        $row[] = array('data' => drupal_render($data['operations']));
      }
      $row[] = array('data' => $data['name']['#value']
        . ($data['items']['#value'] ? '<br />' . t('(items: %items)', array('%items' => implode(', ', $data['items']['#value']))) : ''));
      if ($data['inceptions']['#value']) {
        $cell = array();
        foreach ($data['inceptions']['#value'] as $inception) {
          if ($inception) {
            $cell[] = _ucca_format_date($inception);
          }
          else {
            $cell[] = t('(access granted)');
          }
        }
        $row[] = array('data' => implode('<br />', $cell));
      }
      else {
        $row[] = array('data' => t('(access granted)'));
      }
      if ($data['expirations']['#value']) {
        $cell = array();
        foreach ($data['expirations']['#value'] as $expiration) {
          if ($expiration) {
            $cell[] = _ucca_format_date($expiration);
          }
          else {
            $cell[] = t('(unlimited time)');
          }
        }
        $row[] = array('data' => implode('<br />', $cell));
      }
      else {
        $row[] = array('data' => t('(unlimited time)'));
      }
      if ($admin) {
        $row[] = array('data' => $expiration_widget);
      }
      $rows[] = $row;
    }
  }

  if (!count($rows)) {
    $rows[] = array(
      array('data' => $self
        ? t('You have no premium items.')
        : t('There are no premium items for this user.'), 'colspan' => $admin ? 5 : 3),
    );
  }

  $output .= theme('table', array('header' => $header, 'rows' => $rows, 'attributes' => array(), 'caption' => $admin
      ? t('Below you can revoke access or adjust access expirations.<br />') .
        t('<em>Note that changing one item may affect other items that are internally connected.</em>')
      : t('Content you purchased.')));
  $output .= drupal_render_children($form);

  return $output;
}

/**
 * Theme the content items associated with the product.
 */
function theme_uc_cck_access_node($variables) {
  $uc_cck_access = $variables['uc_cck_access'];
  $output = '';
  $rows = array();

  $header = array();
  $header[] = array('data' => t('Item'));
  $header[] = array('data' => t('Details'));
  $header[] = array('data' => t('Available'));
  $header[] = array('data' => t('Duration'));

  foreach ($uc_cck_access as $pfid => $access) {

    $row[] /* Node    */ = array('data' => $access['item_description']);
    $row[] /* Details */ = array('data' => $access['items'] ? t('%items', array('%items' => implode(', ', $access['items']))) : '');
    $row[] /* Delay   */ = array('data' => $access['delay_description']);
    $row[] /* Expir.  */ = array('data' => $access['duration_description']);

    $rows[] = $row;
  } // foreach (... $pfid => $access)

  if (!count($rows)) {
    $rows[] = array(
      array('data' => t('There are no content items for this product.'), 'colspan' => 4),
    );
  }

  $output .= theme('table', array('header' => $header, 'rows' => $rows, 'attributes' => array(), 'caption' => t('Content included with this product.')));

  return $output;
}

/**
 * Access callback for user/%user/content_orders*.
 * [copied from uc_order_can_view_order()]
 */
function uc_cck_access_can_view_order($order_user /*, $order = NULL */) {
  global $user;

  $access = user_access('view all orders') || ($user->uid && user_access('view own orders') && $user->uid == $order_user->uid);

//  if (!is_null($order)) {
//    $access = $access && $order_user->uid == $order->uid;
//  }

  return $access;
}

function _uc_cck_access_user_self($account) {
  global $user;
  return ($user->uid == $account->uid);
}

function _uc_cck_access_user_content_orders_title($account) {
  return _uc_cck_access_user_self($account) ? t('My content') : FALSE; //t('Premium content');
}

/**
 * Helper function for uc_cck_access_get_schedule()
 * Fill inceptions & expirations array with immediate/unlimited elements
 */
function _uc_cck_access_get_schedule_fill_bookends(&$items) {
  if (is_array($items)) {
    foreach ($items as $key => $item) {
      if (empty($item['expirations'])) {
        $items[$key]['expirations'] = array(FALSE);
      }
      if (empty($item['inceptions'])) {
        $items[$key]['inceptions']  = array(FALSE);
        // Create a fake delay record entry in 'dids' array
        $items[$key]['dids'][0] = array(
          'did' => 0,
          'inception' => FALSE,
          'expiration' => empty($item['expirations']) ? FALSE : min($item['expirations']),
          'data' => is_array($item['data']) ? $item['data'] : array(),
        );
        $items[$key]['dids'][0] += $item;
      }
    }  // foreach ($item)
  }
}

/**
 * Helper function for uc_cck_access_get_schedule()
 * Fill inceptions & expirations min/max elements
 */
function _uc_cck_access_get_schedule_fill_minmax(&$items, $admin) {
  if (is_array($items)) {
    foreach ($items as $key => $item) {
      // Calculate outer range of inception - expiration
      $items[$key]['inception']  = empty($item['inceptions_calc'])  ? FALSE : min($item['inceptions_calc']);
      $items[$key]['expiration'] = empty($item['expirations_calc']) ? FALSE : max($item['expirations_calc']);
      unset($items[$key]['inceptions_calc'], $items[$key]['expirations_calc']);
      if (!$admin) {
        // Simplify the lists of inceptions and expirations for the end user
        // (multiple 'access granted' and 'unlimited time' from convoluted
        // delays/expirations records can be very confusing)
        if (!empty($item['inceptions'])) {
          $items[$key]['inceptions']  = array_unique($item['inceptions']);
        }
        if (!empty($item['expirations'])) {
          $items[$key]['expirations'] = array_unique($item['expirations']);
        }
      }
    }  // foreach ($item)
  }
}

/**
 * Get schedule for items that satisfy given $conditions.
 * @param $conditions - associative array ($field => $condition) of conditions (all will be 'AND'ed except special cases of pfid/handler/access_id)
 * fields are: uid, one of pfid or (handler, access_id)
 * @param $admin - for non-admin user merging of inceptions/expirations is simplified
 * @return - array keyed by "$access_id-" . one of {"uaid$uaid"|"did$did"|"eid$eid"}
 *  prepared fields:
 *  inceptions,
 *  expirations,
 *  inceptions_calc,
 *  expirations_calc,
 */
function uc_cck_access_get_schedule($conditions, $admin = FALSE, $combined = NULL) {
  if ($combined === NULL) {
    $combined = !$admin; // Combine items for non-admins (use 'access_id" as key to combine, items with non-empty 'data' are prioritized
  }
  $items = array(); // Key by (for !$combined) "$access_id-" . one of {"uaid$uaid"|"did$did"|"eid$eid"}
  $one_uid = !empty($conditions['uid']); // For this case we create one more level [$uid] in $items ($items[$uid][$key])
  $handler = $conditions['handler'];
  if (!$handler) {
    return $items;
  }
  $op = 'view'; // We don't support other access op's
  $conditions1 = $conditions;
  $conditions1['op'] = $op;
  unset($conditions1['pfid']);
  $items_granted = uc_cck_access_call_handler(array('handler' => $handler), 'items_granted', $conditions1, NULL);
  if (!$items_granted) {
    $items_granted = array();
  }
  $p = &$items; // Set the pointer out of loop for $one_uid (for !$one_uid set for each element inside the loop)
  foreach ($items_granted as $item) {
    $item += array('handler' => $handler, 'item_type' => 'grant', 'inceptions' => array(), 'expirations' => array(), 'inceptions_calc' => array(), 'expirations_calc' => array());
    $key = $combined ? $item['access_id'] : ($item['access_id'] . '-uaid' . $item['uaid']);
    if (!$one_uid) {
      // Create one more level and group by uid
      $uid = $item['uid'];
      if (!isset($items[$uid])) {
        $items[$uid] = array();
      }
      $p = &$items[$uid];
    }
    if (!isset($p[$key]) || ($combined && empty($p[$key]['data']))) {
      $p[$key] = $item;
    }
  } // foreach ($items_granted as $item)

  // Load up all the expirations for the given conditions and add them to the corresponding items
  foreach ($expiration_items = uc_cck_access_find_expirations($conditions) as $eid => $item) {
    if (!$item['access_id']) {
      continue;
    }
    $access_id = $item['access_id'];
    $expiration = $item['expiration'];
    $item += array('handler' => $handler, 'inceptions' => array(FALSE), 'inceptions_calc' => array());
    $item['expirations'] = $expiration ? array($eid => $expiration) : array();
    $item['expirations_calc'] = $expiration ? array($eid => $expiration) : array();
    if (!$one_uid) {
      // Create one more level and group by uid
      $uid = $item['uid'];
      if (!isset($items[$uid])) {
        $items[$uid] = array();
      }
      $p = &$items[$uid];
    }
    unset($item['expiration']); // temporarily unset so we won't pollute expiration field in target row in $items
    $uaids = uc_cck_access_call_handler(array('handler' => $handler), 'item_uaid', $item['access_id'], $item['data']);
    foreach ($uaids as $uaid) {
      $item['uaid'] = $uaid;
      $key = $combined ? $item['access_id'] : ($item['access_id'] . '-uaid' . $item['uaid']);
      if (isset($p[$key])) {
        $p[$key] += $item;
        foreach (array('expirations', 'expirations_calc') as $field) {
          foreach ($item[$field] as $k => $v) {
            $p[$key][$field][$k] = $v;
          }
        }
      }
      else {
        $p[$key] = $item;
        // If we're here - somehow we have an expiration but no grant reported by any handler
        // Problem we can't fix here. Best we can do is just show it as an expiration (no inception).
      }
      if ($admin) {
        $item['expiration'] = $expiration; // restore expiration field
        $p[$key]['eids'][$eid] = $item;
      }
    } // foreach($uaid)
    if (empty($uaids) && $admin) {
      // The expiration id does not create an access grant - probably this item has no effect
      $key = $combined ? $item['access_id'] : ($item['access_id'] . '-eid' . $item['eid']);
      if (!isset($p[$key])) {
        $p[$key] = $item;
      }
      else {
        foreach (array('expirations', 'expirations_calc') as $field) {
          foreach ($item[$field] as $k => $v) {
            $p[$key][$field][$k] = $v;
          }
        }
      }
      if ($admin) {
        $item['expiration'] = $expiration; // restore expiration field
        $p[$key]['eids'][$eid] = $item;
      }
    }
  } // foreach (expirations as $eid => $item)

  // After merging expirations into grants, fill inceptions/expirations array
  if (!$one_uid) {
    foreach ($items as $uid => $p) {
      $p = &$items[$uid];
      _uc_cck_access_get_schedule_fill_bookends($p);
    }
  }
  else {
    _uc_cck_access_get_schedule_fill_bookends($p);
  }

  // Load up all delayed access for the given conditions and add them only as new items
  foreach ($delay_items = uc_cck_access_find_delays($conditions) as $did => $item) {
    if (!$item['access_id']) {
      continue;
    }
    $access_id = $item['access_id'];
    $inception = $item['inception'];
    $expiration = _uc_cck_access_expiration($item, $inception);
    $item['expirations'] = $expiration ? array('did' . $did => $expiration) : array(FALSE);
    $item['inceptions']  = $inception  ? array($did => $inception)  : array(FALSE);
    $item['expirations_calc'] = $expiration ? array('did' . $did => $expiration) : array();
    $item['inceptions_calc']  = $inception  ? array($did => $inception)  : array();
    if (!$one_uid) {
      // Create one more level and group by uid
      $uid = $item['uid'];
      if (!isset($items[$uid])) {
        $items[$uid] = array();
      }
      $p = &$items[$uid];
    }
    unset($item['inception']); // temporarily unset so we won't pollute inception field in target row in $items
    $uaids = uc_cck_access_call_handler(array('handler' => $handler), 'item_uaid', $item['access_id'], $item['data']);
    foreach ($uaids as $uaid) {
      $item['uaid'] = $uaid;
      // One combination of handler/access_id/data may product multiple uaid's, but they will have different data part
      // We can't guess it here, so ask the handler for details:
      $item['data'] = uc_cck_access_call_handler(array('handler' => $handler), 'item_uaid_data', $uaid);
      $item['items'] = uc_cck_access_call_handler($item, 'describe_data', $item);
      $key = $combined ? $item['access_id'] : ($item['access_id'] . '-uaid' . $item['uaid']);
      if (!isset($p[$key])) {
        $p[$key] = $item;
      }
      else { // Delayed access is to an item with already granted access.
//        if ($admin) // Ignore the delay to minimize non-$admin users confusion.
        foreach (array('inceptions', 'inceptions_calc', 'expirations', 'expirations_calc') as $field) {
          foreach ($item[$field] as $k => $v) {
            $p[$key][$field][$k] = $v;
          }
        }
      }
      if ($admin) {
        $item['inception'] = $inception; // restore inception field
        $p[$key]['dids'][$did] = $item;
      }
    } // foreach($uaid)
    if (empty($uaids) && $admin) {
      // The delay id does not create an access grant - probably this item has no effect
      $key = $combined ? $item['access_id'] : ($item['access_id'] . '-did' . $item['did']);
      if (!isset($p[$key])) {
        $p[$key] = $item;
      }
      else {
        foreach (array('inceptions', 'inceptions_calc', 'expirations', 'expirations_calc') as $field) {
          foreach ($item[$field] as $k => $v) {
            $p[$key][$field][$k] = $v;
          }
        }
      }
      if ($admin) {
        $item['inception'] = $inception; // restore inception field
        $p[$key]['dids'][$did] = $item;
      }
    }
  } // foreach (delays as $did => $item)

  // Fill inceptions & expirations min/max elements
  if (!$one_uid) {
    foreach ($items as $uid => $p) {
      $p = &$items[$uid];
      _uc_cck_access_get_schedule_fill_minmax($p, $admin);
    }
  }
  else {
    _uc_cck_access_get_schedule_fill_minmax($p, $admin);
  }

  return $items;
}

/**
 * Form after build handler.
 * Disables validation for AHAH event and conditionally based on form values.
 */
function uc_cck_access_user_content_orders_form_after_build($form, &$form_state) {
  if (empty($form_state['values']['new_cck_access'])) {
    // Disable the subform validation
    _uc_cck_access_disable_validation($form['add_grant']['grant']);
  }
  return $form;
}

/**
 * Returns list of purchased content and admin (if allowed) forms.
 *
 * @param $account
 *   The user account whose orders you wish to list.
 */
function uc_cck_access_user_content_orders_form($form, $form_state, $account) {
  $admin = user_access('administer users')
    && user_access('administer product features')
    && user_access('edit orders');
  $self = _uc_cck_access_user_self($account);

  $polarity_widget = array(
    '#type' => 'select',
    '#options' => array(
      'add' => '+',
      'remove' => '-',
    ),
  );

  $quantity_widget = array(
    '#type' => 'textfield',
    '#size' => 4,
    '#maxlength' => 4
  );

  $granularity_widget = array(
    '#type' => 'select',
    '#options' => _uc_cck_access_time_unit_options(),
    '#default_value' => 'months',
  );

  $form['_account'] = array('#type' => 'value', '#value' => $account);

  $form['grant_items'] = array(
    '#type' => 'fieldset',
    '#title' => t('Premium content'), //_uc_cck_access_user_content_orders_title($account),
    '#collapsible' => FALSE,
    '#weight' => 0,
    '#theme' => 'uc_cck_access_grant_items',
    '##admin' => $admin, // Pass arguments to theme function
    '##self' => $self, // Pass arguments to theme function
  );

  foreach (uc_cck_access_handlers_list() as $handler => $title) {
    $form['grant_items'][$handler] = array(
      '#tree' => TRUE,
      'grant_items_table' => array('#tree' => TRUE),
    );

    // Collect all items for the grant_items_table
    // Key by "$access_id-" . one of {"uaid$uaid"|"did$did"|"eid$eid"}
    $items = uc_cck_access_get_schedule(array('handler' => $handler, 'uid' => $account->uid), $admin);

    if (empty($items)) {
      unset($form['grant_items'][$handler]['grant_items_table']);
      continue;
    }
    foreach ($items as $id => $item) {
      $form['grant_items'][$handler]['grant_items_table'][$id] = array(
        'name' => array(
          '#type' => 'value',
          '#value' => uc_cck_access_call_handler($item, 'describe', $item, array('short' => 1)),
        ),
        'items' => array(
          '#type' => 'value',
          '#value' => $item['items'],
        ),
        'operations' => $admin ? array(
          'revoke' => array(
            '#type' => 'checkbox',
            '#title' => t('revoke access'),
          ),
          'make_unlimited' => array(
            '#type' => 'checkbox',
            '#title' => t('remove expiration'),
          ),
        ) : NULL,
        'item' => array(
          '#type' => 'value',
          '#value' => $item,
        ),
        'inceptions' => array(
          '#type' => 'value',
          '#value' => $item['inceptions'],
        ),
        'expirations' => array(
          '#type' => 'value',
          '#value' => $item['expirations'],
        ),
        'polarity'    => $admin ? $polarity_widget : NULL,
        'quantity'    => $admin ? $quantity_widget : NULL,
        'granularity' => $admin ? $granularity_widget : NULL,
      );
    } // foreach ($items)
  } // foreach($handler)

  if ($admin) {
    $form['add_grant'] = array(
      '#type' => 'fieldset',
      '#title' => t('Add access'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#weight' => 10,
      '#theme' => 'uc_cck_access_add_grant',
    );

    $form['add_grant']['new_cck_access'] = array(
      '#type' => 'checkbox',
      '#title' => t('Add new access for user %name', array('%name' => $account->name)),
      '#attributes' => array('class' => array('ucca_new_cck_access')),
    );
    $form['add_grant']['new_cck_access_force'] = array(
      '#type' => 'checkbox',
      '#title' => t('Force this new access', array('%name' => $account->name)),
      '#description' => t('ATTENTION! This will remove all existing schedule entries, potentially affecting other items for that user!'),
      '#attributes' => array('class' => array('ucca_new_cck_access_force')),
    );
    $form['#after_build'][] = 'uc_cck_access_user_content_orders_form_after_build';

    $access = array(
      'nid' => 0, // Dummy product node id, just to have a placeholder
      'pfid' => '', // Dummy product feature id, just to have a placeholder
    );
    $form['add_grant']['grant'] = array();
    $form['add_grant']['grant'] += _uc_cck_access_handler_form($form_state, $access, FALSE); // SUBFORM
    // $form['add_grant']['grant']['handler_form'] is preset by _uc_cck_access_handler_form() and has '#tree' = TRUE.
    $form['add_grant']['grant']['handler_form'] += _uc_cck_access_handler_feature_form($form_state, isset($form_state['values']['handler_form']) ? $form_state['values']['handler_form'] : array(), $access); // SUBFORM
    $form['add_grant']['grant'] += _uc_cck_access_time_interval_form($form_state, $access); // SUBFORM

    $form['buttons']['#weight'] = 20;
    $form['buttons']['submit'] = array(
      '#type' => 'submit',
      '#value' => t('Save'),
    );

  }

  return $form;
}

/**
 * Find accurate representation of the interval with largest unit
 * @param $period - duration in timestamp format (seconds)
 */
function _uc_cck_access_to_period($period, $granularity) {
  $new_period = $period . ' seconds'; // This will always work
  $formats = array('minutes' => 60, 'hours' => 60 * 60, 'days' => 60 * 60 * 24, 'weeks' => 60 * 60 * 24 * 7, 'months' => 60 * 60 * 24 * 31, 'years' => 60 * 60 * 24 * 365);
  foreach ($formats as $g => $v) {
    $value = intval($period / $v);
    if ($value * $v != $period) {
      break;
    }
    $new_period = $value . ' ' . $g;
  }
  return $new_period;
}

/**
 * Submit handler for uc_cck_access_user_content_orders_form().
 */
function uc_cck_access_user_content_orders_form_submit($form, &$form_state) {
  // If an AHAH submission, it's just the dependent field working (take into account no-js case).
  if (isset($form_state['clicked_button'])
    ? ($form_state['clicked_button']['#value'] != t('Save'))
    : !empty($form_state['ahah_submission'])) {
    return;
  }

  $account = $form_state['values']['_account'];
  unset($form_state['values']['_account']);

  // @see _uc_cck_access_grant_user_access().
  // New expirations.
  if ($form_state['values']['new_cck_access']) {
    $force = $form_state['values']['new_cck_access_force'];
    $access = isset($form_state['ucca_access']) ? (array) $form_state['ucca_access'] : array();
    $access['nid'] = 0;
    $access['pfid'] = '';
//    $access['model'] = '';

    _uc_cck_access_handler_form_submit($form['add_grant']['grant'], $form_state, $access); // SUBFORM
    _uc_cck_access_handler_feature_form_submit($form['add_grant']['grant']['handler_form'], $form_state, $form_state['values']['handler_form'], $access); // SUBFORM
    _uc_cck_access_time_interval_form_submit($form['add_grant']['grant'], $form_state, $access); // SUBFORM

    $log = _uc_cck_access_process_user_access($access, $account->uid, $force);
    _uc_cck_access_log_to_message($log);
    _uc_cck_access_log_to_watchdog($log);
    $form_state['ucca_access'] = $access;
  }

  // Manual changes to existing expirations.
  $deleted_db_delays = $deleted_db_expirations = 0;
  foreach (uc_cck_access_handlers_list() as $handler => $title) {
    if (!isset($form_state['values'][$handler]) || !is_array($form_state['values'][$handler]['grant_items_table'])) {
      continue;
    }

    foreach ($form_state['values'][$handler]['grant_items_table'] as $id => $row) {
      $item = $row['item'];
      // Revoke access (remove all delays, expirations and grants)
      if (!empty($row['operations']['revoke']) || !empty($row['operations']['make_unlimited'])) {
        // Remove all delays/expirations (but not the access yet).
        // Delete all delay records from the database.
        // We can't ensure the delay does actually belong primarily to this row (and not some other one)
        if (!empty($item['dids'])) {
          foreach ($item['dids'] as $did => $delay) {
            db_delete('uc_cck_access_delays')
              ->condition('did', $did)
              ->execute();
            $deleted_db_delays += 1;
          }
        }
        // Delete all expiration records from the database.
        // We can't ensure the expiration does actually belong primarily to this row (and not some other one)
        if (!empty($item['eids'])) {
          foreach ($item['eids'] as $eid => $expiration) {
            db_delete('uc_cck_access_expirations')
              ->condition('eid', $eid)
              ->execute();
            $deleted_db_expirations += 1;
          }
        }
        if (!empty($row['operations']['revoke'])) {
          // Revoke access for the user through the current universal access handler.
          uc_cck_access_op($item['handler'], 'revoke', NULL, $account->uid, $item['access_id'], $item['data']);
        }
        elseif (!empty($row['operations']['revoke']) || !empty($row['operations']['make_unlimited'])) {
          // Just to be sure we don't end up with revoked access -
          // Grant access for the user through the current universal access handler.
          uc_cck_access_op($item['handler'], 'grant', NULL, $account->uid, $item['access_id'], $item['data']);
        }
      }
      else if (!empty($row['quantity'])) {
        $expiration = $eid = FALSE;
        // Find max
        // "$expiration = max($row['expirations']);" won't work as we might have a FALSE in the array
        if (!empty($row['expirations'])) {
          foreach ($row['expirations'] as $key => $value) {
            if ($value && $expiration < $value) {
              $expiration = $value;
              $eid = $key;
            }
          }
        }

        if ($expiration && $eid) {
          $quantity = ($row['polarity'] == 'add' ? '+' : '-') . $row['quantity'] . ' ' . $row['granularity'];
          if (substr($eid, 0, 3) == 'did') {
            // It's a delay record
            $did = substr($eid, 3);
            $old_delay = $delay = db_query("SELECT * FROM {uc_cck_access_delays} WHERE did = :did", array(':did' => $did))->execute()->fetchAssoc();
            list($delay['duration_period_value'], $delay['duration_period_unit']) = explode(' ', $delay['duration_period']);
            $delay['duration_date'] = unserialize($delay['duration_date']);

            // Calculate new expiration - duration_period
            // Select the smallest granularity
            $new_granularity = (strtotime('+1 ' . $row['granularity']) > strtotime('+1 ' . $delay['duration_period_unit']))
              ? $delay['duration_period_unit']
              : $row['granularity'];
            $period = strtotime($quantity, 0) + strtotime('+' . $delay['duration_period'], 0);
            $new_period = _uc_cck_access_to_period($period, $new_granularity);
            $delay['duration_period'] = $new_period;
            // Calculate new expiration - duration_date
            $expiration = _ucca_date_to_timestamp($delay['duration_date']);
            $expiration = strtotime($quantity, $expiration);
            $delay['duration_date'] = array(
              'month' => gmdate('m', $expiration),
              'day'   => gmdate('d', $expiration),
              'year'  => gmdate('Y', $expiration),
            );
            db_update('uc_cck_access_delays')
              ->fields(array(
                'duration_date' => serialize($delay['duration_date']),
                'duration_period' => $delay['duration_period'],
              ))
              ->condition('did', $did)
              ->execute();
          }
          else {
            // It's an expiration record
            $timestamp = strtotime($quantity, $expiration);
            db_update('uc_cck_access_expirations')
            ->fields(array(
              'expiration' => $timestamp,
            ))
            ->condition('eid', $eid)
            ->execute();
          }
        }
        else {
          drupal_set_message(t('There are no expirations that can be adjusted for the selected !item',
            array('!item' => $row['name'] . ' (' . implode(', ', $row['items']) . ')')));
        }
      }
    } // foreach ($row)
  } // foreach($handler)
  if ($deleted_db_delays || $deleted_db_expirations) {
    drupal_set_message(t('Deleted @delays delay record(s), @expirations expiration record(s).',
      array('@expirations' => $deleted_db_expirations, '@delays' => $deleted_db_delays)));
  }
}

/**
 * Returns the sortable table listing of customer's orders.
 *
 * @param $uid
 *   The user ID whose orders you wish to list.
 */
function uc_cck_access_user_content_orders($account) {
  $title = _uc_cck_access_user_content_orders_title($account);
  if ($title) {
    drupal_set_title($title);
  }
  return drupal_get_form('uc_cck_access_user_content_orders_form', $account);
}

/**
 * Implements hook_node_load().
 */
function uc_cck_access_node_load($nodes, $types) {
  foreach ($nodes as $node) {
    // Load our product features
    $node->uc_cck_access = uc_cck_access_node_features($node, TRUE);
  }
}

/**
 * Implements hook_node_view().
 */
function uc_cck_access_node_view($node, $view_mode, $langcode) {
  if ($node->uc_cck_access) {
    // View our items on product nodes
    $node->content['uc_cck_access'] = array(
          '#markup' => theme('uc_cck_access_node', array('uc_cck_access' => $node->uc_cck_access)),
          '#weight' => variable_get('ucca_node_weight', 9),
        );
  }
}

/**
 * Implements hook_node_delete().
 * Delete our features as uc_product does not deal with its product node deletion.
 */
function uc_cck_access_node_delete($node) {
  // Delete corresponding data from {uc_product_features} and {uc_cck_access_products} tables
  $features = uc_cck_access_node_features($node);
  foreach ($features as $pfid => $feature) {
    uc_cck_access_feature_delete($feature, TRUE);
  }
}

/**
 * Preprocesses template variables for the access item template.
 * It pre-populates variables that help custom themes to give some additional information about the access item.
 *  $date_format - date format string from UC CCK Access settings
 *  $expiration  - expiration date (UTC)
 *  $duration    - time (seconds) left before access expiration
 *  $expiration_text  - formatted expiration date (User's timezone)
 *  $duration_text    - formatted text describing the duration left before access expiration
 *  $delay       - delay date (UTC)
 *  $wait        - time (seconds) left before delayed access
 *  $delay_text  - formatted delay date (User's timezone)
 *  $wait_text   - formatted text describing the wait left before delayed access
 *  $products    - array of product nodes that sell access to content of this node
 */
function uc_cck_access_preprocess_variables($account, $access_id, &$variables) {
  if (variable_get('configurable_timezones', 1) && $account->uid && strlen($account->timezone)) {
    $timezone = $account->timezone;
  }
  else {
    $timezone = variable_get('date_default_timezone', 0);
  }
  $now = strtotime('+0') - $timezone;  // In UTC

  $date_format = variable_get('ucca_date_format', variable_get('date_format_short', 'm/d/Y - H:i'));
  $variables['date_format'] = $date_format;

  // Prepare variables for info on delayed access
  $delays = uc_cck_access_find_delays(array('access_id' => $access_id, 'uid' => $account->uid));
  foreach ($delays as $did => $grant) {
    if (empty($delay) || $delay > $grant['inception']) {
      $delay = $grant['inception'];
      break;
    }
  }
  if (!empty($delay)) {
    $wait = ($delay - $now); // seconds
    if ($wait < 0) {
      $wait = 0;
      // This can occur if delay is supposed to happen, but cron has not run yet.
      // We can be poor man's cron here and pull the trigger on expirations/delays procesing, but then we will need to restart
    }

    $wait = $wait / 60; // minutes
    if ($wait <= 1) {
      $wait_text = t('few minutes (access will be granted any minute now)');
    }
    elseif ($wait > 2 * 24 * 60) {
      $wait_text = format_plural(intval($wait / 60 / 24 + 0.5), 'one day', '@count days');
    }
    elseif ($wait > 2 * 60) {
      $wait_text = format_plural(intval($wait / 60 + 0.5), 'one hour', '@count hours');
    }
    else {
      $wait_text = format_plural(intval($wait + 0.5), 'one minute', '@count minutes');
    }

    $variables['wait'] = $wait;
    $variables['wait_text'] = $wait_text;
    $variables['delay'] = $delay;
    $variables['delay_text'] = format_date($delay, 'custom', $date_format);
  }

  // Prepare variables for info on access expiration
  $expirations = uc_cck_access_find_expirations(array('access_id' => $access_id, 'uid' => $account->uid));
  foreach ($expirations as $eid => $grant) {
    if (empty($expiration) || $expiration > $grant['expiration']) {
      $expiration = $grant['expiration'];
      break;
    }
  }
  if (!empty($expiration)) {
    $duration = ($expiration - $now); // seconds
    if ($duration < 0) {
      $duration = 0;
      // This can occur if expiration is supposed to happen, but cron has not run yet.
      // We can be poor man's cron here and pull the trigger on expirations/delays procesing, but then we will need to restart
    }

    $duration = $duration / 60; // minutes
    if ($duration <= 1) {
      $duration_text = t('no time left (access will expire any minute now)');
    }
    elseif ($duration > 2 * 24 * 60) {
      $duration_text = format_plural(intval($duration / 60 / 24 + 0.5), 'one day', '@count days');
    }
    elseif ($duration > 2 * 60) {
      $duration_text = format_plural(intval($duration / 60 + 0.5), 'one hour', '@count hours');
    }
    else {
      $duration_text = format_plural(intval($duration + 0.5), 'one minute', '@count minutes');
    }

    $variables['duration'] = $duration;
    $variables['duration_text'] = $duration_text;
    $variables['expiration'] = $expiration;
    $variables['expiration_text'] = format_date($expiration, 'custom', $date_format);
  }

  // Build a list of all products that sell access to this node
  $products = array();
  foreach (uc_cck_access_find_features(array('access_id' => $access_id)) as $feature) {
    $products[$feature['nid']] = node_load($feature['nid']);
  }
  $variables['products'] = $products;
}

