<?php

/**
 * @file
 * Implements the main csremind (Contact Save Remind) functionality.
 */

/**
 * Define a default set of paths not to show reminders on.
 */
define('CSREMIND_EXCLUDE_PAGES',
'user/*/reminders
admin/structure/contact/csremind'
);

/**
 * Implements hook_menu().
 */
function csremind_menu() {
  $items = array();

  $items['admin/structure/contact/csremind'] = array(
    'title' => 'Contact Save Remind settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('csremind_settings'),
    'access arguments' => array('administer contact forms'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
    'file' => 'csremind.admin.inc',
  );

  $items['user/%user/reminders'] = array(
    'title' => 'Reminders',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('csremind_user_reminder_config_form', 1),
    'access callback' => 'csremind_reminder_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Custom access callback for 'Reminders' user profile tab.
 *
 * If the current user's ID is the same as the user ID in the URL, and that
 * user has permission to administer site wide contact forms, grant access,
 * otherwise deny it.
 *
 * @param object $account
 *   User account object.
 */
function csremind_reminder_access($account) {
  global $user;

  if ($user->uid == $account->uid) {
    return user_access('administer contact forms', $account);
  }

  return FALSE;
}

/**
 * Reminder configuration form build.
 *
 * @param array $form
 *   Current form.
 * @param array $form_state
 *   Current form state.
 * @param object $account
 *   User account object.
 *
 * @return array
 *   Drupal Form API array.
 */
function csremind_user_reminder_config_form($form, &$form_State, $account) {
  $form['description'] = array(
    '#prefix' => '<p>',
    '#suffix' => '</p>',
    '#markup' => t("This form lets you configure your reminders for unread saved
      contact form messages, both permanently and in your current session. When
      you restart your session (log out and back in again) any currently active,
      suppressed reminder will be available again, whereas any reminder that is
      inactive, won't ever be used whatever the suppression state."),
  );

  $form['reminder'] = array(
    '#type' => 'container',
    '#attributes' => array(
      'class' => array('reminder-config'),
    ),
    '#tree' => TRUE,
  );

  $reminders = csremind_all_user_reminders($account->uid);

  foreach ($reminders as $reminder) {
    $form['reminder'][$reminder['id']]['active'] = array(
      '#type' => 'radios',
      '#title' => t('Reminder active state for unread @type contact form messages', array('@type' => $reminder['form_type'])),
      '#default_value' => $reminder['active'],
      '#options' => array(0 => t('Inactive'), 1 => t('Active')),
      '#description' => t('This option lets you permanently deactivate your reminder. This reminder will not be triggered ever.'),
    );

    $form['reminder'][$reminder['id']]['suppress'] = array(
      '#type' => 'radios',
      '#title' => t('Reminder suppression state for unread @type contact form messages', array('@type' => $reminder['form_type'])),
      '#default_value' => $reminder['suppress'],
      '#options' => array(0 => t('Unsuppressed'), 1 => t('Suppressed')),
      '#description' => t('This option lets you suppress your reminder during
        the current session. The reminder will be reactivated next time you log
        in.'),
    );

    $form['reminder'][$reminder['id']]['frequency'] = array(
      '#type' => 'select',
      '#title' => t('Frequency of reminder'),
      '#default_value' => $reminder['frequency'],
      '#options' => array(
        0 => t('Immediately (every request)'),
        30 => t('Every 30 seconds'),
        300 => t('Every 5 minutes'),
        900 => t('Every 15 minutes'),
        1800 => t('Every 30 minutes'),
        3600 => t('Every hour'),
        7200 => t('Every 2 hours'),
        14400 => t('Every 4 hours'),
        28800 => t('Every 8 hours'),
        57600 => t('Every 16 hours'),
        86400 => t('Every 24 hours'),
      ),
      '#description' => t('How often would you like to be reminded if there are
        unread saved contact form messages?'),
    );

    $classes = &$form['reminder']['#attributes']['class'];
    $classes[] = 'reminder-' . $reminder['id'];
    ($reminder['active'] == 1) ? $classes[] = 'reminder-active' : $classes[] = 'reminder-inactive';
    ($reminder['suppress'] == 1) ? $classes[] = 'reminder-supressed' : $classes[] = 'reminder-unsupressed';
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Update configuration'),
  );

  return $form;
}

/**
 * Submit handler for reminder configuration form.
 */
function csremind_user_reminder_config_form_submit($form, &$form_state) {
  foreach ($form_state['values']['reminder'] as $reminder_id => $config) {
    csremind_update_reminder($reminder_id, $config);
  }

  drupal_set_message(t('Reminder configuration updated.'));
}

/**
 * Update reminder details.
 *
 * @param int $reminder_id
 *   Unique identifier for a reminder in the csremind table.
 * @param array $updates
 *   Reminder update values.
 */
function csremind_update_reminder($reminder_id, $updates) {
  $current = csremind_load($reminder_id);
  $config = array_merge($current, $updates);

  db_merge('csremind')
    ->key(array('id' => $reminder_id))
    ->fields(array(
      'frequency' => $config['frequency'],
      'last' => $config['last'],
      'active' => $config['active'],
      'suppress' => $config['suppress'],
    ))
    ->execute();
}

/**
 * Auto-loader wildcard function for reminder details.
 *
 * @param int $reminder_id
 *   Unique identifier for a reminder in the csremind table.
 *
 * @return array
 *   Array of reminder information.
 */
function csremind_load($reminder_id) {
  return db_query(
    "SELECT id, uid, form_type, frequency, last, active, suppress
    FROM {csremind}
    WHERE id = :id",
    array(':id' => $reminder_id)
  )->fetchAssoc();
}

/**
 * Implements hook_page_build().
 *
 * Using this hook gives more options than just using hook_boot() or
 * hook_init(), where there are restrictions on what's available or for which
 * users the hook is run for.
 */
function csremind_page_build(&$page) {
  $reminders_excluded = csremind_reminders_excluded(current_path());

  if (user_is_logged_in() && !$reminders_excluded) {
    $unread_message_count = contact_save_unread_messages();

    if ($unread_message_count) {
      global $user;

      $query = "SELECT id, uid, form_type, frequency, last, active, suppress
        FROM {csremind} csr
        WHERE csr.uid = :uid
        AND csr.active = :active
        AND csr.suppress = :suppress";

      $result = db_query($query, array(
        ':uid' => $user->uid,
        ':active' => 1,
        ':suppress' => 0,
      ));

      foreach ($result as $record) {
        $last = $record->last;
        $frequency = $record->frequency;
        $reminder_is_due = csremind_is_due($last, $frequency);

        if ($reminder_is_due) {
          $reminder = array(
            'id' => $record->id,
            'uid' => $record->uid,
            'form_type' => $record->form_type,
            'last' => $last,
            'frequency' => $frequency,
          );

          // Invoke hook so any other modules can remind a user however they
          // decide to implement that functionality.
          module_invoke_all('csremind_remind_user', $reminder, $unread_message_count);
          // Now the user has been reminded, record that just happened.
          csremind_update_reminder($reminder['id'], array('last' => time()));
        }
      }
    }
  }
}

/**
 * Evaluate whether or not to show a reminder for a given path.
 *
 * Logic here for matching paths is borrowed heavily from the Securepages
 * module.
 *
 * @param string $path
 *   Path value.
 *
 * @return bool
 *  TRUE if a path is in the exclusion list, FALSE otherwise.
 *
 * @see securepages_match()
 */
function csremind_reminders_excluded($path = NULL) {
  $path_to_match = drupal_get_normal_path($path);
  $exclude_list = drupal_strtolower(variable_get('csremind_exclude_pages', CSREMIND_EXCLUDE_PAGES));

  // Is the path in the exclusion list?
  $result = drupal_match_path($path_to_match, $exclude_list);

  if (!$result && function_exists('drupal_get_path_alias')) {
    // Is the path aliased, and is that in the exclusion list?
    $path_alias = drupal_get_path_alias($path_to_match);
    $result = drupal_match_path($path_alias, $exclude_list);
  }

  if ($result) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Calculate if a reminder is due to be triggered.
 *
 * By using the current time, the last time the reminder was triggered and a
 * frequency value, we can calculate if a reminder is due.
 *
 * @param int $last
 *   The last time the reminder was triggered as a timestamp.
 * @param int $frequency
 *   How often the reminder should be shown, in seconds.
 *
 * @return bool
 *   TRUE or FALSE depending on whether the reminder should be triggered.
 */
function csremind_is_due($last, $frequency) {
  $triggered = ($last > 0) ? TRUE : FALSE;
  $next_due = ($last + $frequency);

  if (!$triggered || $next_due <= time()) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Count of the number of reminders a user has.
 *
 * @param int $user_id
 *   User identifier.
 *
 * @return int
 *   Number of reminders that the user has.
 */
function csremind_user_reminder_count($user_id) {
  $query = "SELECT COUNT(id)
    FROM {csremind} WHERE
    uid = :uid";

  return db_query($query, array(':uid' => $user_id))
    ->fetchField();
}

/**
 * Return a list of all reminders a user has.
 */
function csremind_all_user_reminders($user_id) {
  $reminders = array();

  $query = "SELECT id, uid, form_type, frequency, last, active, suppress
    FROM {csremind}
    WHERE uid = :uid
    ORDER BY id";

  $result = db_query($query, array(':uid' => $user_id));

  foreach ($result as $record) {
    $reminders[] = array(
      'id' => $record->id,
      'uid' => $record->uid,
      'form_type' => $record->form_type,
      'frequency' => $record->frequency,
      'last' => $record->last,
      'active' => $record->active,
      'suppress' => $record->suppress,
    );
  }

  return $reminders;
}

/**
 * Implements hook_user_login().
 */
function csremind_user_login(&$edit, $account) {
  // Manage 'csremind' records. This would be better done on some
  // kind of 'user was assigned X permission' type event.
  if (user_access('administer contact forms', $account)) {
    $user_has_reminder = csremind_user_reminder_count($account->uid);

    if (!$user_has_reminder) {
      $id = db_insert('csremind')
        ->fields(array(
          'uid' => $account->uid,
          'form_type' => 'site',
          'frequency' => variable_get('csremind_default_frequency', 1800),
          'last' => 0,
          'active' => 1,
          'suppress' => 0,
        ))
        ->execute();
    }
  }
}

/**
 * Implements hook_user_logout().
 */
function csremind_user_logout($account) {
  // Manage 'csremind' records. This would be better done on some
  // kind of 'user was assigned X permission' type event.
  if (user_access('administer contact forms', $account)) {
    $user_has_reminder = csremind_user_reminder_count($account->uid);

    if ($user_has_reminder) {
      // Reset suppressed reminders, as we're ending the session.
      $number_updated = db_update('csremind')
        ->fields(array(
          'suppress' => 0,
        ))
        ->condition('uid', $account->uid, '=')
        ->condition('suppress', 1, '=')
        ->condition('active', 1, '=')
        ->execute();
    }
  }
  else {
    // Remove reminders, if the user no longer has the right permissions.
    // This would be better done on some kind of 'permission X was removed from
    // user' type event.
    if ($account->uid > 1) {
      $number_deleted = db_delete('csremind')
        ->condition('uid', $account->uid, '=')
        ->execute();
    }
  }
}
