<?php

/**
 * @file
 * Clientcert module main file.
 */

/**
 * Implements hook_views_api().
 */
function clientcert_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'clientcert') . '/includes/views',
  );
}

/**
 * Implements hook_entity_info().
 */
function clientcert_entity_info() {
  $return = array(
    'clientcert' => array(
      'label' => t('Clientcert item'),
      'plural label' => t('Clientcert items'),
      'description' => t('An entity type to store client certificates (SSL/TLS) with additional information for login and/or encryption.'),
      'entity class' => 'Entity',
      'controller class' => 'EntityAPIController',
      'base table' => 'clientcert',
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'ccid',
      ),
      'label callback' => 'entity_class_label',
      'uri callback' => 'entity_class_uri',
      'bundles' => array(
        'clientcert' => array(
          'label' => t('Clientcert item'),
          'admin' => array(
            'path' => 'admin/config/people/clientcert',
            'access arguments' => array('administer clientcert'),
          ),
        ),
      ),
      'view modes' => array(
        'full' => array(
          'label' => t('Cientcert item view'),
          'custom settings' => FALSE,
        ),
      ),
      'module' => 'clientcert',
    ),

  );

  return $return;
}

/**
 * Load multiple clientcert item entities based on certain conditions.
 *
 * @param array $ccids
 *   An array of entity IDs.
 * @param array $conditions
 *   An array of conditions to match against the {entity} table.
 * @param bool $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return array
 *   An array of test entity objects, indexed by ccid.
 */
function clientcert_load_multiple($ccids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('clientcert', $ccids, $conditions, $reset);
}

/**
 * Delete multiple clientcert item  entities.
 *
 * @param array $ccids
 *   An array of clientcert item entity IDs.
 */
function clientcert_delete_multiple(array $ccids) {
  entity_get_controller('clientcert')->delete($ccids);
}

/**
 * Clientcert save.
 *
 * @param object $clientcert
 *   A clientcert instance object.
 *
 * @return object
 *   The saved clientcert instance object.
 */
function clientcert_save($clientcert) {
  if (empty($clientcert->created)) {
    $clientcert->created = REQUEST_TIME;
  }
  $clientcert->changed = REQUEST_TIME;
  return entity_save('clientcert', $clientcert);
}

/**
 * Load a clientcert item object.
 */
function clientcert_load($ccid, $reset = FALSE) {
  $entities = clientcert_load_multiple(array($ccid), array(), $reset);
  return reset($entities);
}

/**
 * Delete a clientcert item object.
 */
function clientcert_delete($ccid) {
  clientcert_delete_multiple(array($ccid));
}

/**
 * Implements hook_menu().
 */
function clientcert_menu() {
  $items = array();

  $items['admin/config/people/clientcert'] = array(
    'title' => 'Clientcert settings',
    'description' => 'Configure clientcert module.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('clientcert_admin_form'),
    'access arguments' => array('administer clientcert'),
    'file' => 'includes/clientcert.pages.inc',
    'weight' => -10,
  );

  $items['admin/config/people/clientcert/settings'] = array(
    'title' => 'Settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  $items['clientcert/require/%'] = array(
    'title' => 'Clientcert verify url path (require)',
    'page callback' => 'clientcert_page_verify',
    'page arguments' => array(2),
    'access arguments' => array('access clientcert paths'),
    'file' => 'includes/clientcert.pages.inc',
  );

  $items['clientcert/optional/%'] = array(
    'title' => 'Clientcert verify url path (optional_no_ca)',
    'page callback' => 'clientcert_page_verify',
    'page arguments' => array(2),
    'access arguments' => array('access clientcert paths'),
    'file' => 'includes/clientcert.pages.inc',
  );

  $items['clientcert/add/item'] = array(
    'title' => 'Add clientcert item',
    'page callback' => 'clientcert_page_item_add',
    'access callback' => 'clientcert_access',
    'access arguments' => array('create'),
    'weight' => 1,
    'menu_name' => 'navigation',
    'file' => 'includes/clientcert.pages.inc',
  );

  $items['clientcert/item/%clientcert'] = array(
    'page callback' => 'clientcert_page_item_view',
    'page arguments' => array(2),
    'access callback' => 'clientcert_access',
    'access arguments' => array('view', 2),
    'type' => MENU_CALLBACK,
    'file' => 'includes/clientcert.pages.inc',
  );

  $items['clientcert/item/%clientcert/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  $items['clientcert/item/%clientcert/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'clientcert_page_item_edit',
    'page arguments' => array(2),
    'access callback' => 'clientcert_access',
    'access arguments' => array('update', 2),
    'weight' => 0,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'file' => 'includes/clientcert.pages.inc',
  );

  $items['clientcert/item/%clientcert/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('clientcert_page_item_delete_confirm', 2),
    'access callback' => 'clientcert_access',
    'access arguments' => array('delete', 2),
    'weight' => 1,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'file' => 'includes/clientcert.pages.inc',
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function clientcert_permission() {

  return array(
    'administer clientcert' => array(
      'title' => t('Administer clientcert.'),
    ),
    'access clientcert paths' =>  array(
      'title' => t('Access clientcert paths (needed for guests for login solution)'),
    ),
    'create clientcert item' => array(
      'title' => t('Create clientcert item'),
    ),
    'update any clientcert item' => array(
      'title' => t('Update any clientcert item settings and fields'),
    ),
    'update own clientcert item' => array(
      'title' => t('Update own clientcert item settings and fields'),
    ),
    'view any clientcert item' => array(
      'title' => t('View any clientcert item with additional information'),
    ),
    'view own clientcert item' => array(
      'title' => t('View own clientcert item with additional information'),
    ),
    'delete any clientcert item' => array(
      'title' => t('Delete any clientcert item'),
    ),
    'delete own clientcert item' => array(
      'title' => t('Delete own clientcert item'),
    ),

  );
}

/**
 * Access callback for clientcert.
 */
function clientcert_access($op, $clientcert = NULL, $account = NULL) {
  if (!isset($account)) {
    global $user;
    $account = $user;
  }
  switch ($op) {
    case 'create':
      $return = user_access('create clientcert item', $account);
      return $return;

    case 'update':
      $return = user_access('update any clientcert item')
          || (user_access('update own clientcert item')
          && ($clientcert->uid == $account->uid));
      return $return;

    case 'delete':
      $return = user_access('delete any clientcert item')
          || (user_access('delete own clientcert item')
          && ($clientcert->uid == $account->uid));
      return $return;

    case 'view':
      $return = user_access('view any clientcert item', $account)
          || (user_access('view own clientcert item')
          && ($clientcert->uid == $account->uid));
      return $return;

  }
}

/**
 * Implements hook_entity_property_info().
 */
function clientcert_entity_property_info() {
  $info = array();
  $properties = &$info['clientcert']['properties'];

  $properties['ccid'] = array(
    'label' => t("Clientcert item ID"),
    'type' => 'integer',
    'description' => t("The primary identifier for an clientcert item."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer clientcert',
    'schema field' => 'ccid',
  );

  $properties['created'] = array(
    'label' => t("Clientcert item created"),
    'type' => 'date',
    'description' => t("The date the clientcert item was created."),
    'schema field' => 'created',
  );

  $properties['changed'] = array(
    'label' => t("Clientcert item changed"),
    'type' => 'date',
    'description' => t("The date the clientcert item was most recently updated."),
    'schema field' => 'changed',
  );

  $properties['title'] = array(
    'label' => t("Clientcert item title"),
    'type' => 'text',
    'description' => t("The title for an clientcert item."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'create clientcert item',
    'required' => TRUE,
    'schema field' => 'title',
  );

  $properties['uid'] = array(
    'label' => t("User ID"),
    'type' => 'integer',
    'description' => t("The User ID where the clientcert item belongs to."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'create clientcert item',
    'required' => TRUE,
    'schema field' => 'uid',
  );

  $properties['cert'] = array(
    'label' => t("Client Certificate (PEM)"),
    'type' => 'text',
    'description' => t("PEM-encoded client certificate."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'create clientcert item',
    'required' => TRUE,
    'schema field' => 'cert',
  );

  $properties['cert_hash'] = array(
    'label' => t("Certificate hash"),
    'type' => 'text',
    'description' => t("Calculated hash of client certificate."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'create clientcert item',
    'required' => FALSE,
    'schema field' => 'cert_hash',
  );

  $properties['verify'] = array(
    'label' => t("Verify report"),
    'type' => 'text',
    'description' => t("Servers verify report."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'create clientcert item',
    'required' => TRUE,
    'schema field' => 'verify',
  );

  $properties['serial'] = array(
    'label' => t("Serial"),
    'type' => 'text',
    'description' => t("Serial of the client certificate."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'create clientcert item',
    'required' => TRUE,
    'schema field' => 'serial',
  );

  $properties['dn_subject'] = array(
    'label' => t("DN subject"),
    'type' => 'text',
    'description' => t("Subject DN in client's certificate"),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'create clientcert item',
    'required' => TRUE,
    'schema field' => 'dn_subject',
  );

  $properties['dn_issuer'] = array(
    'label' => t("DN issuer"),
    'type' => 'text',
    'description' => t("Issuer DN of client's certificate."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'create clientcert item',
    'required' => TRUE,
    'schema field' => 'dn_issuer',
  );

  $properties['validity_start'] = array(
    'label' => t("Validity start"),
    'type' => 'date',
    'description' => t("Validity of client's certificate (start time)."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'create clientcert item',
    'required' => TRUE,
    'schema field' => 'validity_start',
  );

  $properties['validity_end'] = array(
    'label' => t("Validity end"),
    'type' => 'date',
    'description' => t("Validity of client's certificate (end time)."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'create clientcert item',
    'required' => TRUE,
    'schema field' => 'validity_end',
  );

  $properties['status'] = array(
    'label' => t("Active"),
    'type' => 'boolean',
    'description' => t("Boolean indicating whether the clientcert item is active."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer clientcert',
    'required' => TRUE,
    'schema field' => 'status',
  );

  $properties['status_login'] = array(
    'label' => t("Login active"),
    'type' => 'boolean',
    'description' => t("Boolean indicating whether the clientcert item can be used for login."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer clientcert',
    'required' => TRUE,
    'schema field' => 'status_login',
  );

  $properties['status_encrypt'] = array(
    'label' => t("Encryption active"),
    'type' => 'boolean',
    'description' => t("Boolean indicating whether the clientcert item can be used for encryption."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer clientcert',
    'required' => TRUE,
    'schema field' => 'status_encrypt',
  );

  $properties['status_public'] = array(
    'label' => t("Public"),
    'type' => 'boolean',
    'description' => t("Boolean indicating whether the client certificate can be presented to others."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer clientcert',
    'required' => TRUE,
    'schema field' => 'status_public',
  );

  return $info;
}

/**
 * Create or retrieving and updating clientcert item entity.
 *
 * Rules action 'clientcert_item_set' callback
 *
 * @param array $data
 *   Array with clientcert item data including text with special tokens.
 *
 * @return array
 *   Returns an array with the clientcert entity.
 */
function _clientcert_item_set($data) {
  $return = array('clientcert_item' => NULL);

  $specialtoken = $data['specialtoken'];

  $uid = 0;
  if (isset($data['uid'])) {
    $uid = $data['uid'];
  }
  else {
    drupal_set_message(t('No correct user ID provided.'), "error");
    return $return;
  }

  $keys = array(
    'title',
    'cert',
    'serial',
    'verify',
    'dn_subject',
    'dn_issuer',
    'verify',
    'validity_start',
    'validity_end',
  );

  $values = array();
  foreach ($keys as $key) {
    $server_value = '';
    if (isset($data[$key])) {

      if ($specialtoken == 1) {
        $server_value = _clientcert_token_replace_server_variable($data[$key]);
      }
      else {
        $server_value = $data[$key];
      }
    }
    $values[$key] = $server_value;
  }

  $values['validity_start'] = strtotime($values['validity_start']);
  $values['validity_end'] = strtotime($values['validity_end']);

  $hash = '';
  if ($values['cert'] == '') {
    drupal_set_message(t('Empty value for certificate.'), "error");
    return $return;
  }
  else {
    $hash = sha1(_clientcert_decode_pem($values['cert']));
  }
  $values['cert_hash'] = $hash;
  $values['uid'] = $uid;

  if (isset($data['verify_active'])) {
    if ($values['verify'] = $data['verify_active']) {
      $values['status'] = 1;
    }
  }
  $hash_list = _clientcert_hash_search($hash);
  $hash_list_uid = array_flip($hash_list);
  $clientcert_count = count($hash_list);
  if ($clientcert_count > 1) {
    drupal_set_message(t('Clientcert hash found in more than one items.'), 'warning');
  }

  if (array_key_exists($uid, $hash_list_uid)) {
    $clientcert = clientcert_load($hash_list_uid[$uid]);
    $update = FALSE;
    foreach ($values as $value_key => $value) {
      if ($clientcert->$value_key != $value) {
        $clientcert->$value_key = $value;
        $update = TRUE;
      }
    }
    if ($update == TRUE) {
      $clientcert = clientcert_save($clientcert);
    }
  }
  else {
    $clientcert = entity_create('clientcert', $values);
    $clientcert = clientcert_save($clientcert);
  }

  $return['clientcert_item'] = $clientcert;
  return $return;
}

/**
 * Retrieve clientcert items by PEM.
 *
 * Rules action 'clientcert_items_pem' callback
 *
 * @param array $data
 *   Array with with data send by rules.
 *
 * @return array
 *   Returns an array with data to use in rules as variables.
 */
function _clientcert_items_pem($data) {
  $return = array(
    'clientcert_items' => array(),
    'clientcert_items_count' => 0,
  );
  $specialtoken = NULL;
  if (isset($data['specialtoken'])) {
    $specialtoken = $data['specialtoken'];
  }

  $uid_search = NULL;
  if (isset($data['uid_token'])) {
    $uid_token = $data['uid_token'];
    if (isset($_REQUEST[$uid_token])) {
      $uid_raw = (int) $_REQUEST[$uid_token];
      if (is_int($uid_raw)) {
        $uid_search = $uid_raw;
      }
    }
  }

  $pem = '';
  if ($specialtoken == 1) {
    $pem = _clientcert_token_replace_server_variable($data['cert']);
  }
  else {
    $pem = $data['cert'];
  }

  // Stop if certificate information is empty.
  if ($pem == '') {
    drupal_set_message(t('Certificate is empty.'), "error");
    return $return;
  }

  $decoded_pem = _clientcert_decode_pem($pem);

  $hash = sha1($decoded_pem);

  $hash_list = _clientcert_hash_search($hash, $uid_search);
  $clientcerts = array();
  if (count($hash_list) > 0) {
    $ccids = array_keys($hash_list);
    $clientcerts_load = clientcert_load_multiple($ccids);
  }

  foreach ($clientcerts_load as $clientcert) {
    // Some security and other checks. Inactive items can be provided,
    // because of update possibility. Other checks should be done with Rules:
    // Is certificate field not empty?
    if ( ($clientcert->cert != '')
    // And is clientcert item already connect to a user?
        && ($clientcert->uid > 0)
    // And is clientcert item allowed for login?
        && ($clientcert->status_login == 1)
    // And is saved PEM encoded certificate identical with provded certificate?
        && (_clientcert_decode_pem($clientcert->cert) == $decoded_pem)) {
      $clientcerts[] = $clientcert;
    }
  }

  $return['clientcert_items'] = $clientcerts;
  $return['clientcert_items_count'] = count($clientcerts);

  return $return;
}

/**
 * Search and replace special tokens of cliencert module.
 *
 * @param string $text
 *   Text where special token can be used.
 *
 * @return string
 *   Returns text where special token are replaced with values of $_SERVER
 */
function _clientcert_token_replace_server_variable($text) {
  $pattern = '/\(SERVER:(.*)\)/';
  $callback = '_clientcert_token_replace_server_variable_callback';
  $text = preg_replace_callback($pattern, $callback, $text);
  return $text;
}

/**
 * Callback for search and replace special tokens of cliencert module.
 *
 * @param array $matches
 *   Array with match information of preg_replace_callback.
 *
 * @return string
 *   Returns value to replace special token.
 */
function _clientcert_token_replace_server_variable_callback($matches) {
  if (!isset($matches[1])) {
    return '';
  }
  $server_value = _clientcert_load_server_variable($matches[1]);
  if (!isset($server_value)) {
    $server_value = _clientcert_load_server_variable('REDIRECT_' . $matches[1]);
  }
  return $server_value;
}

/**
 * Loads data from $_SERVER variable.
 *
 * @param string $data_key
 *   Key in $_SERVER variable.
 *
 * @return string
 *   Returns the server variable data.
 */
function _clientcert_load_server_variable($data_key = '') {
  if (isset($_SERVER[$data_key])) {
    return $_SERVER[$data_key];
  }
  return NULL;
}

/**
 * Clean and decode PEM data.
 *
 * @param string $pem
 *   PEM encoded data usually a SSL/TLS certificate.
 *
 * @return string
 *   Returns a cleaned and decoded string prepared to be hashed or compared.
 */
function _clientcert_decode_pem($pem) {
  $pem = preg_replace('/\-+BEGIN CERTIFICATE\-+/', '', $pem);
  $pem = preg_replace('/\-+END CERTIFICATE\-+/', '', $pem);
  $pem = trim($pem);
  $pem = str_replace(array("\n\r", "\n", "\r"), '', $pem);
  $pem = base64_decode($pem);
  return $pem;
}

/**
 * Search clientcert items by hash.
 *
 * @param string $hash
 *   Calculated and saved hash of certificate.
 *
 * @return array
 *   Returns an array of all found clientcert items as simple database object.
 */
function _clientcert_hash_search($hash, $uid_search = NULL) {
  $return = array();
  $query = db_select('clientcert', 'c');
  $query->condition('c.cert_hash', $hash, '=');
  if ($uid_search) {
    $query->condition('c.uid', $uid_search, '=');
  }
  $query->fields('c', array('ccid', 'uid'));
  $query->orderBy('c.uid', 'ASC');
  $result = $query->execute();
  foreach ($result as $record) {
    $return[$record->ccid] = $record->uid;
  }
  return $return;
}

/**
 * Helper function to handle views page access.
 *
 * @param $perm
 *   The clientcert permission to search for.
 * @param $clientcert_id_arg
 *   Optional; The position in arg() where the clientcert ID can be found.
 *
 * @return
 *   TRUE if user has permission.
 */
function _clientcert_views_page_access($perm, $clientcert_id_arg = FALSE) {
  if ($clientcert_id_arg !== '') {
    $ccid = arg($clientcert_id_arg);
    if (is_numeric($ccid)) {
      $clientcert = clientcert_load($ccid);
      return clientcert_access($perm, $clientcert);
    }
  }
  return FALSE;
}
