<?php

/**
 * @file
 * Provides a framework to allow pre-order products
 */

/**
 * Implements hook_views_api().
 */
function commerce_preorder_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'commerce_preorder') . '/includes/views',
  );
}

/**
 * Implements hook_enable().
 */
function commerce_preorder_enable() {
  commerce_preorder_configure_product_types();
  commerce_preorder_configure_order_types();
}

/**
 * Implements hook_modules_enabled().
 */
function commerce_preorder_modules_enabled($modules) {
  commerce_preorder_configure_product_fields($modules);

  // Configure order types if $modules enabled is not only this module
  if (!empty($modules) && (!in_array('commerce_preorder', $modules) || count($modules) > 1)) {
    commerce_preorder_configure_order_types();
  }
}


// -----------------------------------------------------------------------
// Product types

/**
 * Configure the product types defined by enabled modules.
 */
function commerce_preorder_configure_product_types() {
  foreach (commerce_product_types() as $type => $product_type) {
    commerce_preorder_configure_product_type($type);
  }
}

/**
 * Configures the fields on product types provided by other modules.
 *
 * @param $modules
 *   An array of module names whose product type fields should be configured;
 *   if left NULL, will default to all modules that implement
 *   hook_commerce_product_type_info().
 */
function commerce_preorder_configure_product_fields($modules = NULL) {
  // If no modules array is passed, recheck the fields for all product types
  // defined by enabled modules.
  if (empty($modules)) {
    $modules = module_implements('commerce_product_type_info');
  }

  // Reset the product type cache to get types added by newly enabled modules.
  commerce_product_types_reset();

  // Loop through all the enabled modules.
  foreach ($modules as $module) {
    // If the module implements hook_commerce_product_type_info()...
    if (module_hook($module, 'commerce_product_type_info')) {
      $product_types = module_invoke($module, 'commerce_product_type_info');

      // Loop through and configure the product types defined by the module.
      foreach ($product_types as $type => $product_type) {
        commerce_preorder_configure_product_type($type);
      }
    }
  }
}

/**
 * Add fields on a product type bundle.
 */
function commerce_preorder_configure_product_type($type) {
  $entity_type = 'commerce_product';

  // Get managed field defintions
  $managed_fields = _commerce_preorder_managed_product_fields($type);
  if (empty($managed_fields['fields'])) {
    return;
  }

  // Clear the cache
  field_cache_clear();

  // Get the entity view modes
  $entity_info = entity_get_info($entity_type);

  // Spoof the default view mode and node teaser so its display type is set.
  $entity_info['view modes'] += array(
    'default' => array(),
    'node_teaser' => array(),
  );

  // Create fields & instances if necessary.
  $weight = 10;
  foreach($managed_fields['fields'] as $field_name => $managed_field) {
    commerce_activate_field($field_name);

    $field = field_info_field($field_name);
    $instance = field_info_instance($entity_type, $field_name, $type);

    if (empty($field)) {
      field_create_field($managed_field);
    }

    if (empty($instance) && !empty($managed_fields['instances'][$field_name])) {
      $instance = $managed_fields['instances'][$field_name];

      $default_display = array();
      if (isset($instance['display']['default'])) {
        $default_display = $instance['display']['default'];
      }

      foreach ($entity_info['view modes'] as $view_mode => $data) {
        $display = $default_display;
        if (isset($instance['display'][$view_mode])) {
          $display = $instance['display'][$view_mode];
        }

        $instance['display'][$view_mode] = $display + array(
          'label' => 'hidden',
          'weight' => $weight++,
        );
      }

      field_create_instance($instance);
    }
  }
}

/**
 * Product fields and instances managed by this module
 *
 * @param $bundle
 *   The specific bundle to build the definitions
 *
 * @return
 *   An array keyed with 'fields' and 'instances' managed by this module
 */
function _commerce_preorder_managed_product_fields($bundle = NULL) {
  $entity_type = 'commerce_product';

  // Fields
  $fields = array(
    'commerce_preorder_status' => array(
      'type' => 'list_boolean',
      'cardinality' => 1,
      'translatable' => FALSE,
      'locked' => TRUE,
      'settings' => array(
        'allowed_values' => array(0, 1),
      ),
    ),
    'commerce_preorder_price' => array(
      'type' => 'commerce_price',
      'cardinality' => 1,
      'translatable' => FALSE,
      'locked' => TRUE,
    ),
  );

  // Field instances.
  $instances = array(
    'commerce_preorder_status' => array(
      'label' => t('Enable pre-order'),
      'description' => t('Enables pre-ordering for this product.'),
      'required' => FALSE,

      'widget' => array(
        'type' => 'options_onoff',
        'settings' => array(
          'display_label' => 1,
        ),
      ),

      'display' => array(
        'default' => array(
          'label' => 'hidden',
          'type' => 'hidden',
        ),
      ),
    ),

    'commerce_preorder_price' => array(
      'label' => t('Pre-order price'),
      'required' => FALSE,
      'settings' => array(),

      // Because this widget is locked, we need it to use the full price widget
      // since the currency option can't be adjusted at the moment.
      'widget' => array(
        'type' => 'commerce_price_full',
        'settings' => array(
          'currency_code' => 'default',
        ),
      ),

      'display' => array(
        'default' => array(
          'label' => 'hidden',
          'type' => 'hidden',
        ),
      ),
    ),
  );


  $info = array('fields' => $fields, 'instances' => $instances);
  $context = array(
    'entity_type' => $entity_type,
    'bundle' => $bundle,
  );

  _commerce_preorder_process_managed_fields($info, $context);
  return $info;
}

/**
 * Implements hook_field_widget_form_alter()
 * - Alter for managed fields
 */
function commerce_preorder_field_widget_form_alter(&$element, &$form_state, $context) {
  if (!isset($context['field']['field_name'])) {
    return;
  }

  // Alter preorder price widget
  if ($context['field']['field_name'] == 'commerce_preorder_price' && !empty($element['amount'])) {
    // Add toggle state to preorder price field
    $toggle_states = array(
      'invisible' => array(
        ':input[name^="commerce_preorder_status"]' => array('checked' => FALSE),
      ),
    );

    if (empty($element['amount']['#states'])) {
      $element['amount']['#states'] = $toggle_states;
    }
    else {
      $element['amount']['#states'] = $toggle_states + $element['amount']['#states'];
    }

    if ($element['currency_code']['#type'] != 'value') {
      if (empty($element['currency_code']['#states'])) {
        $element['currency_code']['#states'] = $toggle_states;
      }
      else {
        $element['currency_code']['#states'] = $toggle_states + $element['currency_code']['#states'];
      }
    }
  }
}

/**
 * Implements hook_field_attach_validate()
 * - Validate pre-order price < base price
 */
function commerce_preorder_field_attach_validate($entity_type, $entity, &$errors) {
  if ($entity_type != 'commerce_product' || empty($entity)) {
    return;
  }

  if (!isset($entity->commerce_price) || !isset($entity->commerce_preorder_status)) {
    return;
  }

  $entity_wrapper = entity_metadata_wrapper($entity_type, $entity);

  $preorder_enabled = $entity_wrapper->commerce_preorder_status->value();
  if ($preorder_enabled) {
    $price_langcode = field_language($entity_type, $entity, 'commerce_preorder_price');
    if (empty($price_langcode)) {
      $price_langcode = LANGUAGE_NONE;
    }

    $base_price = $entity_wrapper->commerce_price->value();
    $preorder_price = $entity_wrapper->commerce_preorder_price->value();

    if (empty($preorder_price) ||
        (isset($preorder_price['amount']) &&
        ($preorder_price['amount'] == '' || !is_numeric($preorder_price['amount'])))) {

      $errors['commerce_preorder_price'][$price_langcode][0][] = array(
        'error' => 'commerce_preorder_price_invalid',
        'message' => t('A pre-order price must be defined if pre-order is enabled.'),
      );
      return;
    }

    if ($preorder_price['currency_code'] == $base_price['currency_code'] &&
        $preorder_price['amount'] > $base_price['amount']) {

      $errors['commerce_preorder_price'][$price_langcode][0][] = array(
        'error' => 'commerce_preorder_price_invalid',
        'message' => t('A pre-order price must be less than the base price of the product.'),
      );
      return;
    }
  }
}


// -----------------------------------------------------------------------
// Product type settings

/**
 * Implements hook_form_FORM_ID_alter().
 * - commerce_product_ui_product_type_form
 */
function commerce_preorder_form_commerce_product_ui_product_type_form_alter(&$form, &$form_state, $form_id) {
  $product_type = $form_state['product_type'];

  $type = !empty($product_type['type']) ? $product_type['type'] : NULL;
  $defaults = _commerce_preorder_product_type_settings($type);

  $form['product_type']['commerce_preorder'] = array(
    '#tree' => TRUE,
  );

  $form['product_type']['commerce_preorder']['combine_order'] = array(
    '#type' => 'checkbox',
    '#title' => t('Combine pre-ordered products of this type into a single order.'),
    '#default_value' => $defaults['combine_order'],
  );

  $form['actions']['submit']['#submit'][] = 'commerce_preorder_form_commerce_product_ui_product_type_form_submit';
  $form['actions']['save_continue']['#submit'][] = 'commerce_preorder_form_commerce_product_ui_product_type_form_submit';
}

/**
 * Prodcut type Form submit handler: save a product type.
 */
function commerce_preorder_form_commerce_product_ui_product_type_form_submit($form, &$form_state) {
  $product_type = $form_state['product_type'];
  $values = $form_state['values'];

  if (!empty($product_type['type']) && isset($values['product_type']['commerce_preorder'])) {
    variable_set('commerce_preorder_product_type_' . $product_type['type'], $values['product_type']['commerce_preorder']);
  }
}

/**
 * Implements hook_commerce_product_type_delete()
 */
function commerce_preorder_commerce_product_type_delete($product_type, $skip_reset) {
  variable_del('commerce_preorder_product_type_' . $product_type['type']);
}

/**
 * Returns an array of default product type settings
 */
function _commerce_preorder_product_type_settings_defaults() {
  return array(
    'combine_order' => 0,
  );
}

/**
 * Returns an array of active product type settings
 */
function _commerce_preorder_product_type_settings($type = NULL) {
  $defaults = _commerce_preorder_product_type_settings_defaults();
  if (!empty($type)) {
    return variable_get('commerce_preorder_product_type_' . $type, $defaults);
  }

  return $defaults;
}


// -----------------------------------------------------------------------
// Price handling

/**
 * Implements hook_commerce_price_component_type_info()
 */
function commerce_preorder_commerce_price_component_type_info() {
  return array(
    'preorder' => array(
      'title' => t('Pre-order'),
      'display_title' => t('Future due'),
      'weight' => -30,
    ),
  );
}

/**
 * Implements hook_commerce_price_formatted_components_alter()
 * - Display preorder price component as positive if negative to reflect "future due"
 */
function commerce_preorder_commerce_price_formatted_components_alter(&$components, $price, $entity) {
  if (isset($components['preorder']) && isset($components['preorder']['price']['amount']) &&
      is_numeric($components['preorder']['price']['amount'])) {
    $components['preorder']['price']['amount'] *= (-1);
  }
}


// -----------------------------------------------------------------------
// Order handling

/**
 * Implements hook_commerce_order_status_info()
 */
function commerce_preorder_commerce_order_status_info() {
  $statuses = array();

  $statuses['preordered'] = array(
    'name' => 'preordered',
    'title' => t('Pre-ordered'),
    'state' => 'cart',
    'weight' => -5,
  );

  $statuses['preordered_success'] = array(
    'name' => 'preordered_success',
    'title' => t('Pre-order paid'),
    'state' => 'pending',
    'weight' => 10,
  );

  $statuses['preordered_failed'] = array(
    'name' => 'preordered_failed',
    'title' => t('Pre-order processing failed'),
    'state' => 'cart',
    'weight' => 10,
  );

  return $statuses;
}

/**
 * Configure the order types defined by enabled modules.
 */
function commerce_preorder_configure_order_types() {
  foreach (commerce_order_type_get_name() as $type => $type_label) {
    commerce_preorder_configure_order_type($type);
  }
}

/**
 * Add fields on an order type bundle.
 */
function commerce_preorder_configure_order_type($type) {
  $entity_type = 'commerce_order';

  // Get managed field defintions
  $managed_fields = _commerce_preorder_managed_order_fields($type);
  if (empty($managed_fields['fields'])) {
    return;
  }

  // Clear the cache
  field_cache_clear();

  // Get the entity view modes
  $entity_info = entity_get_info($entity_type);

  // Create available view modes
  $view_modes = array('default', 'customer', 'administrator');
  if (!empty($entity_info['view modes'])) {
    $view_modes = array_intersect($view_modes, array_keys($entity_info['view modes']));
  }

  // Create fields & instances if necessary.
  $weight = 10;
  foreach($managed_fields['fields'] as $field_name => $managed_field) {
    commerce_activate_field($field_name);

    $field = field_info_field($field_name);
    $instance = field_info_instance($entity_type, $field_name, $type);

    if (empty($field)) {
      field_create_field($managed_field);
    }

    if (empty($instance) && !empty($managed_fields['instances'][$field_name])) {
      $instance = $managed_fields['instances'][$field_name];

      $default_display = array();
      if (isset($instance['display']['default'])) {
        $default_display = $instance['display']['default'];
      }

      foreach ($view_modes as $view_mode => $data) {
        $display = $default_display;
        if (isset($instance['display'][$view_mode])) {
          $display = $instance['display'][$view_mode];
        }

        $instance['display'][$view_mode] = $display + array(
          'weight' => $weight++,
        );
      }

      field_create_instance($instance);
    }
  }
}

/**
 * Order fields and instances managed by this module
 *
 * @param $bundle
 *   The specific bundle to build the definitions
 *
 * @return
 *   An array keyed with 'fields' and 'instances' managed by this module
 */
function _commerce_preorder_managed_order_fields($bundle = NULL) {
  $entity_type = 'commerce_order';

  // Fields
  $fields = array(
    'commerce_preorder_order' => array(
      'type' => 'entityreference',
      'cardinality' => 1,
      'translatable' => FALSE,
      'locked' => TRUE,
      'settings' => array(
        'target_type' => 'commerce_order',
        'handler' => 'base',
        'handler_settings' => array(),
      ),
    ),
  );

  // Field instances.
  $instances = array(
    'commerce_preorder_order' => array(
      'label' => t('Pre-order purchase'),
      'required' => FALSE,
      'settings' => array(),
      'widget' => array(
        'type' => 'entityreference_autocomplete',
        'module' => 'entityreference',
      ),
      'display' => array(
        'default' => array(
          'label' => 'inline',
          'type' => 'entityreference_label',
          'settings' => array(
            'link' => TRUE,
          ),
        ),
      ),
    ),
  );


  $info = array('fields' => $fields, 'instances' => $instances);
  $context = array(
    'entity_type' => $entity_type,
    'bundle' => $bundle,
  );

  _commerce_preorder_process_managed_fields($info, $context);
  return $info;
}

/**
 * Order properties getter callback
 */
function commerce_preorder_order_property_get($entity, array $options, $name) {
  switch ($name) {
    case 'preOrderCheckoutURL':
      if (!empty($entity->order_id) && isset($entity->status)) {
        $status = commerce_order_status_load($entity->status);
        if (isset($status['state']) && $status['state'] == 'cart') {
          $url_options = array('absolute' => TRUE);
          return url("checkout/{$entity->order_id}", $url_options);
        }
      }
      break;

    case 'preOrderLineItems':
      $preorder_line_items = array();
      $entity_wrapper = entity_metadata_wrapper('commerce_order', $entity);
      foreach ($entity_wrapper->commerce_line_items as $delta => $line_item_wrapper) {
        if ($line_item_wrapper->isPreOrdered->value()) {
          $preorder_line_items[] = $line_item_wrapper->line_item_id->value();
        }
      }
      return $preorder_line_items;

    case 'preOrderTotal':
      $total = array(
        'amount' => 0,
        'currency_code' => commerce_default_currency(),
        'data' => array(),
      );

      $entity_wrapper = entity_metadata_wrapper('commerce_order', $entity);
      if (isset($entity_wrapper->commerce_order_total)) {
        $total = commerce_price_component_total($entity_wrapper->commerce_order_total->value(), 'preorder');
      }
      return $total;
  }
}

/**
 * Line item properties getter callback
 */
function commerce_preorder_line_item_property_get($entity, array $options, $name) {
  switch ($name) {
    case 'isPreOrdered':
      $entity_wrapper = entity_metadata_wrapper('commerce_line_item', $entity);
      if (!isset($entity_wrapper->commerce_product)) {
        return FALSE;
      }

      $total = $entity_wrapper->preOrderTotal->value();
      return !empty($total['amount']);

    case 'preOrderUnitPrice':
      $total = array(
        'amount' => 0,
        'currency_code' => commerce_default_currency(),
        'data' => array(),
      );

      $entity_wrapper = entity_metadata_wrapper('commerce_line_item', $entity);
      if (isset($entity_wrapper->commerce_unit_price)) {
        $total = commerce_price_component_total($entity_wrapper->commerce_unit_price->value(), 'preorder');
      }
      return $total;

    case 'preOrderTotal':
      $total = array(
        'amount' => 0,
        'currency_code' => commerce_default_currency(),
        'data' => array(),
      );

      $entity_wrapper = entity_metadata_wrapper('commerce_line_item', $entity);
      if (isset($entity_wrapper->commerce_total)) {
        $total = commerce_price_component_total($entity_wrapper->commerce_total->value(), 'preorder');
      }
      return $total;
  }
}

/**
 * Create pending orders based on given order
 */
function commerce_preorder_generate_orders($order, $new_status = 'preordered') {
  if (empty($order->order_id)) {
    return array();
  }

  // Wrap the order
  $line_item_groups = _commerce_preorder_pending_line_item_groups($order);
  if (empty($line_item_groups)) {
    return array();
  }

  // Validate status
  if (!commerce_order_status_load($new_status)) {
    $new_status = $new_status != 'preordered' ? 'preordered' : 'pending';
  }

  // Generate orders
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  $generated_orders = array();
  foreach ($line_item_groups as $group_name => $line_items) {
    // Generate a new order with that product.
    $new_order = commerce_order_new($order->uid, $new_status);
    $new_order->log = t('Created from pre-order.');

    $new_order_wrapper = entity_metadata_wrapper('commerce_order', $new_order);

    // Set pre-order order reference
    if (isset($new_order_wrapper->commerce_preorder_order)) {
      $new_order_wrapper->commerce_preorder_order = $order->order_id;
    }

    // Set order customer profiles
    $profile_instances = _commerce_preorder_order_profile_info_instances($order->type);
    foreach ($profile_instances as $field_name => $profile_instance) {
      if (isset($order->{$field_name})) {
        $new_order->{$field_name} = $order->{$field_name};
      }
    }

    // Save the new order
    $new_order_wrapper->save();
    $generated_orders[] = $new_order->order_id;

    // Create the new line items
    foreach ($line_items as $line_item_id => $line_item) {
      $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);

      // Create new product line item
      $new_line_item = commerce_product_line_item_new($line_item_wrapper->commerce_product->value(), $line_item_wrapper->quantity->value());
      $new_line_item->order_id = $new_order->order_id;

      // Set future due price
      /** @todo: remove if go with all rules based to account for going back to 'in cart' status **/
      //$new_line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $new_line_item);
      //$pending_price = $line_item_wrapper->preOrderUnitPrice->value();
      //$pending_price['amount'] *= (-1);
      //$new_line_item_wrapper->commerce_unit_price = $pending_price;

      // Update the line item price.
      rules_invoke_event('commerce_product_calculate_sell_price', $new_line_item);
      commerce_line_item_save($new_line_item);

      $new_order_wrapper->commerce_line_items[] = $new_line_item->line_item_id;
    }

    // save the updated order
    $new_order_wrapper->save();
  }

  return $generated_orders;
}


/**
 * Split the order into line item groups per product type settings for future orders
 */
function _commerce_preorder_pending_line_item_groups($order) {
  // Wrap the order
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

  // Initialize product type settings
  $combine_orders_enabled = array();
  foreach (commerce_product_types() as $product_type => $product_type_info) {
    $product_bundle_settings = _commerce_preorder_product_type_settings($product_type);
    if (!empty($product_bundle_settings['combine_order'])) {
      $combine_orders_enabled[$product_type] = TRUE;
    }
  }

  // Split the line items per product type settings
  $line_item_groups = array();
  foreach ($order_wrapper->preOrderLineItems as $line_item_wrapper) {
    if (!isset($line_item_wrapper->commerce_product)) {
      return;
    }

    $line_item_id = $line_item_wrapper->getIdentifier();
    $product_type = $line_item_wrapper->commerce_product->getBundle();

    if (!empty($combine_orders_enabled[$product_type])) {
      $line_item_groups[$product_type][$line_item_id] = $line_item_wrapper->value();
    }
    else {
      $line_item_groups['_line_item_' . $line_item_id][$line_item_id] = $line_item_wrapper->value();
    }
  }

  // Allow others to alter the groups
  $context = array(
    'order' => clone($order),
  );
  drupal_alter('commerce_preorder_pending_line_item_groups', $line_item_groups, $context);


  return $line_item_groups;
}

/**
 * Returns customer profile field instances for the given order bundle
 */
function _commerce_preorder_order_profile_info_instances($bundle_name) {
  $instances = array();
  $profile_fields  = commerce_info_fields('commerce_customer_profile_reference', 'commerce_order');
  foreach ($profile_fields as $field_name => $field) {
    if ($instance = field_info_instance('commerce_order', $field_name, $bundle_name)) {
      $instances[$field_name] = $instance;
    }
  }

  return $instances;
}


// -----------------------------------------------------------------------
// Helpers

/**
 * Set common field and instance definition properties
 *
 * @param $info
 *   An array of 'fields' and 'instance' defintions
 * @param $context
 *   An array of 'entity_type' and 'bundle'
 */
function _commerce_preorder_process_managed_fields(&$info, $context) {
  $entity_type = !empty($context['entity_type']) ? $context['entity_type'] : NULL;
  $entity_type_exists = !empty($entity_type);

  $bundle = !empty($context['bundle']) ? $context['bundle'] : NULL;
  $bundle_exsits = !empty($bundle);

  if (!empty($info['fields'])) {
    // Set entity type
    foreach ($info['fields'] as $field_name => &$field) {
      $field['field_name'] = $field_name;
      if ($entity_type_exists) {
        $field['entity_types'] = array($entity_type);
      }
    }
    unset($field);
  }

  if (!empty($info['instances'])) {
    // Set entity type and bundle

    foreach ($info['instances'] as $field_name => &$instance) {
      $instance['field_name'] = $field_name;
      $instance['entity_type'] = $entity_type;

      if ($bundle_exsits) {
        $instance['bundle'] = $bundle;
      }
    }
    unset($instance);
  }
}
