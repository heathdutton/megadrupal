<?php

/**
 * @file
 * Add a javascript free responsive image formatter.
 */


// Directory for generated CSS files.
define('MEDIA_QUERY_IMAGES_CSS_DIRECTORY', 'public://media_query_images_css');

/**
 * Implements hook_flush_caches().
 */
function media_query_images_flush_caches() {
  file_scan_directory(MEDIA_QUERY_IMAGES_CSS_DIRECTORY, '/.*/', array('callback' => 'file_unmanaged_delete'));
}

/**
 * Implements hook_element_info().
 */
function media_query_images_element_info() {
  $types = array();
  
  $types['media_query_images'] = array(
    '#theme' => 'media_query_images',
    '#attributes' => array(),
    '#src' => NULL,
    '#image_style' => NULL,
    '#image_styles' => NULL,
    '#item' => NULL,
    
    '#input' => FALSE,
    '#title_display' => 'invisible',
  );
  
  return $types;
}

/**
 * Generates the media query for multipliers of an image
 *
 * @param $multiplier
 *   A string containing the multiplier for which the media query is for.
 *
 * @param $breakpoint
 *   A string containing the breakpoint media query.
 *
 * @return sting
 *   The sting containing the media query for the multiplier.
 * 
 * @see picture_get_multiplier_media_query()
 */
function _media_query_images_multiplier_media_query($multiplier, $breakpoint) {
  $media_query = array(
    $breakpoint,
  );
  if($multiplier != '1x') {
    $multiplier_formatted = str_replace('x', '', $multiplier);
    $media_query = array(
      $breakpoint . ' and (min-device-pixel-ratio: ' . $multiplier_formatted . ')',
      $breakpoint . ' and (-o-min-device-pixel-ratio: ' . $multiplier_formatted . ')',
      $breakpoint . ' and (-webkit-min-device-pixel-ratio: ' . $multiplier_formatted . ')',
      $breakpoint . ' and (min-resolution: ' . $multiplier_formatted . 'dppx)',
    );
  }
  return implode(',', $media_query);
}

/**
 * Field hooks.
 */

/**
 * Implements hook_field_formatter_info().
 */
function media_query_images_field_formatter_info() {
  
  $formatters = array();
  
  if (module_exists('picture')) {
    
    $formatters['media_query_images_picture_mappings'] = array(
      'label' => t('Media Query Images with Picture mappings'),
      'field types' => array(
        'image',
        'imagefield_crop',
      ),
      'settings' => array(
        'picture_mapping' => '',
        'image_link' => '',
      ),
    );
  }
  
  if (module_exists('breakpoints')) {
  
    $formatters['media_query_images_breakpoints'] = array(
      'label' => t('Media Query Images with Breakpoints'),
      'field types' => array(
        'image',
        'imagefield_crop',
      ),
      'settings' => array(
        'breakpoint_group' => '',
        'breakpoint_group_styles' => '',
        'image_link' => '',
      ),
    );
  }
  
  $formatters['media_query_images'] = array(
    'label' => t('Media Query Images'),
    'field types' => array(
      'image',
      'imagefield_crop',
    ),
    'settings' => array(
      'image_styles' => '',
      'image_link' => '',
    ),
  );
  
  return $formatters;
}

/**
 * Implements hook_field_formatter_settings_form().
 * 
 * @ingroup forms
 */
function media_query_images_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $image_styles = image_style_options(FALSE);
  
  $element = array();
  
  // Multiple field formatters are in the same module, check type.
  
  switch ($display['type']) {
    case 'media_query_images_picture_mappings':
      
      $picture_mappings = picture_mapping_load_all();
      
      $picture_mapping_options = array();
      
      foreach ($picture_mappings as $key => $picture_mapping) {
        
        $breakpoint_group = breakpoints_breakpoint_group_load($picture_mapping->breakpoint_group);
        
        $picture_mapping_options[$key] = $breakpoint_group->name;
      }
      
      $element['picture_mapping'] = array(
        '#type' => 'select',
        '#title' => t('Picture Mapping'),
        '#options' => $picture_mapping_options,
        '#default_value' => $settings['picture_mapping'],
      );
      
      
      $link_types = array(
        'content' => t('Content'),
        'file' => t('File'),
      );
      
      $element['image_link'] = array(
        '#title' => t('Link image url to'),
        '#type' => 'select',
        '#default_value' => $settings['image_link'],
        '#empty_option' => t('Nothing'),
        '#options' => $link_types,
      );
      
      break;
    case 'media_query_images_breakpoints':
      
      $breakpoint_groups = breakpoints_breakpoint_group_load_all();
      
      $breakpoint_group_options = array();
      
      foreach ($breakpoint_groups as $breakpoint_group) {
        $breakpoint_group_options[$breakpoint_group->machine_name] = $breakpoint_group->name;
      }
      
      $element['breakpoint_group'] = array(
        '#type' => 'select',
        '#title' => t('Breakpoint'),
        '#options' => $breakpoint_group_options,
        '#default_value' => $settings['breakpoint_group'],
      );
      
      $breakpoints = breakpoints_breakpoint_load_all_active();
      
      // Saved settings must be explicitly set, so #tree here to save all styles.
      $element['breakpoint_group_styles'] = array(
        '#tree' => TRUE,
      );
      
      foreach ($breakpoint_groups as $breakpoint_group) {
        
        $element['breakpoint_group_styles'][$breakpoint_group->machine_name] = array(
          '#type' => 'fieldset',
          '#title' => $breakpoint_group->name,
          '#tree' => TRUE,
          '#states' => array(
            'visible' => array(
              'select[name="fields[' . $field['field_name'] . '][settings_edit_form][settings][breakpoint_group]"], select[name="options[settings][breakpoint_group]"], select[name="breakpoint_group"]' => array('value' => $breakpoint_group->machine_name),
            ),
          ),
        );
        
        foreach ($breakpoint_group->breakpoints as $breakpoint) {
          $breakpoint_data = breakpoints_breakpoint_load_by_fullkey($breakpoint);
          
          foreach ($breakpoint_data->multipliers as $multiplier) {
            
            $string_vars = array(
              '@multiplier' => $multiplier,
              '@name' => $breakpoint_data->name,
              '@breakpoint' => $breakpoint_data->breakpoint,
            );
            
            $breakpoint_element = array(
              '#type' => 'select',
              '#title' => t('@multiplier @name [@breakpoint]', $string_vars),
              '#options' => $image_styles,
              '#empty_option' => t('<none>'),
            );
            
            if (!empty($settings['breakpoint_group_styles']) && !empty($settings['breakpoint_group_styles'][$breakpoint_group->machine_name][$breakpoint][$multiplier])) {
              $breakpoint_element['#default_value'] = $settings['breakpoint_group_styles'][$breakpoint_group->machine_name][$breakpoint][$multiplier];
            }
            
            $element['breakpoint_group_styles'][$breakpoint_group->machine_name][$breakpoint][$multiplier] = $breakpoint_element;
            
          }
          
          
        }
        
      }
      
      $link_types = array(
        'content' => t('Content'),
        'file' => t('File'),
      );
      
      $element['image_link'] = array(
        '#title' => t('Link image url to'),
        '#type' => 'select',
        '#default_value' => $settings['image_link'],
        '#empty_option' => t('Nothing'),
        '#options' => $link_types,
      );
      
      break;
    case 'media_query_images':
      
      $element['image_styles'] = array(
        '#title' => t('Image styles'),
        '#type' => 'select',
        '#default_value' => $settings['image_styles'],
        '#empty_option' => t('None (original image)'),
        '#options' => $image_styles,
        '#multiple' => TRUE, // Allow for multiple styles of same image field.
      );
    
      $link_types = array(
        'content' => t('Content'),
        'file' => t('File'),
      );
      
      $element['image_link'] = array(
        '#title' => t('Link image url to'),
        '#type' => 'select',
        '#default_value' => $settings['image_link'],
        '#empty_option' => t('Nothing'),
        '#options' => $link_types,
      );
      
      break;
  }
  
  return $element;
}

/**
 * Implements hook_field_formatter_settings_summary().
 */
function media_query_images_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  $summary = array();

  $image_styles = image_style_options(FALSE);
  
  // Unset possible 'No defined styles' option.
  unset($image_styles['']);
  
  switch ($display['type']) {
    case 'media_query_images_picture_mappings':
      
      $summary[] = t('Picture mappings');
      
      $link_types = array(
        'content' => t('Linked to content'),
        'file' => t('Linked to file'),
      );
      
      // Display this setting only if image is linked.
      if (isset($link_types[$settings['image_link']])) {
        $summary[] = $link_types[$settings['image_link']];
      }
      
      break;
    case 'media_query_images_breakpoints':
      
      $breakpoint_group = breakpoints_breakpoint_group_load($settings['breakpoint_group']);
      
      $summary[] = t('Breakpoint group: @breakpoint_group', array('@breakpoint_group' => $breakpoint_group->name));
      
      $link_types = array(
        'content' => t('Linked to content'),
        'file' => t('Linked to file'),
      );
      
      // Display this setting only if image is linked.
      if (isset($link_types[$settings['image_link']])) {
        $summary[] = $link_types[$settings['image_link']];
      }
      
      break;
    case 'media_query_images':
      
      // Styles could be lost because of enabled/disabled modules that defines
      // their styles in code.
      $matching_styles = array_intersect($image_styles, $settings['image_styles']);
      
      if (count($matching_styles) > 0) {
        $summary[] = t('URL for image style: @style', array('@style' => implode(', ', $matching_styles)));
      }
      else {
        $summary[] = t('Original image URL');
      }
    
      $link_types = array(
        'content' => t('Linked to content'),
        'file' => t('Linked to file'),
      );
      
      // Display this setting only if image is linked.
      if (isset($link_types[$settings['image_link']])) {
        $summary[] = $link_types[$settings['image_link']];
      }
      
      break;
  }
  
  return implode('<br />', $summary);
}

/**
 * Implements hook_field_formatter_view().
 */
function media_query_images_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $settings = $display['settings'];
  
  $element = array();
  
  $hash = '';
  
  switch ($display['type']) {
    case 'media_query_images_picture_mappings':
      /**
       * Using Picture module mappings, prepare breakpoints for fall-through.
       */
      
      $settings['breakpoint_group'] = $settings['picture_mapping'];
      
      $picture_mappings = picture_mapping_load_all();
      
      $settings['breakpoint_group_styles'] = array();
      
      foreach ($picture_mappings as $bp_group_machine => $picture_mapping) {
        $settings['breakpoint_group_styles'][$bp_group_machine] = $picture_mapping->mapping;
      }
      
      // Fall-through with valid breakpoints.
      
    case 'media_query_images_breakpoints':
      /**
       * Using Breakpoints, prepare CSS and fall-through with styles to output.
       */
      
      // Get a unique list of used styles.
      $settings['image_styles'] = array();
      
      foreach ($settings['breakpoint_group_styles'][$settings['breakpoint_group']] as $multipliers) {
        
        // Only interate over non-empty multipliers.
        foreach (array_filter($multipliers) as $multiplier => $image_style_name) {
          
          // De-duplicate by keying array with value.
          $settings['image_styles'][$image_style_name] = $image_style_name;
        }
      }
      
      
      // Base hash on currently used settings. Prepend with non-numeric to be CSS safe.
      $hash = drupal_hash_base64(json_encode($settings['breakpoint_group_styles'][$settings['breakpoint_group']]));
      
      $directory = MEDIA_QUERY_IMAGES_CSS_DIRECTORY;
      
      if (file_prepare_directory($directory, FILE_CREATE_DIRECTORY)) {
        
        $destination = $directory . '/media_query_images.' . $hash . '.css';
        
        // Only generate CSS if it doesn't exist.
        if (!file_exists($destination)) {
          
          // Used for debugging.
          $spacer = '';
          
          $styles = array();
          
          // Generate the CSS that determines visiblity for each style.
          foreach ($settings['breakpoint_group_styles'][$settings['breakpoint_group']] as $breakpoint_name => $multipliers) {
    
            $breakpoint_data = breakpoints_breakpoint_load_by_fullkey($breakpoint_name);
            
            foreach (array_filter($multipliers) as $multiplier => $bp_image_style_name) {
              
              $breakpoint_styles = array(
                'none' => array(),
                'inline-block' => array(),
              );
              
              // Get the appropriate media query for breakpoint multipliers.
              $media_query = _media_query_images_multiplier_media_query($multiplier, $breakpoint_data->breakpoint);
              
              foreach ($settings['image_styles'] as $image_style) {
                
                $breakpoint_selector = '';
                
                // Class for faster CSS selection by browser rendering engine.
                $breakpoint_selector .= '.mqi-wrapper';
                
                // Group for this particular output. Fix for views and other places a field can be rendered twice with different settings.
                $breakpoint_selector .= '[mqi-group="' . drupal_clean_css_identifier($hash) . '"]';
                
                // Image style name.
                $breakpoint_selector .= '[mqi-style="' . drupal_clean_css_identifier($image_style) . '"]';
                
                // Only display image style if its the current one for this breakpoint.
                if ($image_style == $bp_image_style_name) {
                  $breakpoint_styles['inline-block'][] = $breakpoint_selector;
                }
                else {
                  $breakpoint_styles['none'][] = $breakpoint_selector;
                }
                
              }
              
              $breakpoint_style = array();
              
              foreach (array_filter($breakpoint_styles) as $display => $selectors) {
                $breakpoint_style[] = implode(',' . $spacer, $selectors) . '{display: ' . $display . ';}';
              }
              
              $styles[] = '@media ' . $media_query . ' {' . $spacer . implode($spacer, $breakpoint_style) . $spacer . '}';
              
            }
            
          }
      
          $destination = file_unmanaged_save_data(implode($spacer, $styles), $destination, FILE_EXISTS_REPLACE);
        }
        
        $options = array(
          'type' => 'file',
        );
        
        // If aggregate CSS is off, disable preprocess on this file so it works with respond.js, since respond.js only works with files in a <link /> tag.
        if (!variable_get('preprocess_css', FALSE)) {
          $options['preprocess'] = FALSE;
        }
        
        drupal_add_css($destination, $options);
      }
      
      // Fall-through with image styles for output.
      
    case 'media_query_images':
      
      // Check if the formatter involves a link.
      if ($settings['image_link'] == 'content') {
        $uri = entity_uri($entity_type, $entity);
      }
      elseif ($settings['image_link'] == 'file') {
        $link_file = TRUE;
      }

      foreach ($items as $delta => $item) {
        
        if (isset($link_file)) {
          $uri = array(
            'path' => file_create_url($item['uri']),
            'options' => array(),
          );
        }
        
        $element[$delta] = array(
          '#type' => 'media_query_images',
          '#item' => $item,
          '#image_styles' => $settings['image_styles'],
          '#path' => isset($uri) ? $uri : '',
          '#src' => $item['uri'],
          '#attributes' => array(
            'mqi-group' => $hash,
          ),
        );
      }

      break;
  }

  return $element;
}


/**
 * Theme hooks.
 */

/**
 * Implements hook_theme().
 */
function media_query_images_theme($existing, $type, $theme, $path) {
  return array(
    'media_query_images' => array(
      'variables' => array(
        'item' => NULL, 
        'path' => NULL, 
        'image_style' => NULL,
        'image_styles' => NULL,
        'src' => NULL,
        'attributes' => NULL,
      ),
    ),
  );
}

/**
 * Returns HTML for an image field formatter.
 *
 * @param $variables
 *   An associative array containing:
 *   - item: Associative array of image data, which may include "uri", "alt",
 *     "width", "height", "title" and "attributes".
 *   - image_style: An optional image style.
 *   - path: An array containing the link 'path' and link 'options'.
 *
 * @ingroup themeable
 */
function theme_media_query_images($variables) {
  
  // Only add if there is an actual element being displayed.
  // 'group' = 'CSS_SYSTEM' to ensure before breakpoints CSS.
  drupal_add_css(drupal_get_path('module', 'media_query_images') . '/media_query_images.css', array('group' => CSS_SYSTEM));
      
  if (!($item = $variables['item'])) {
    
    $image_info = image_get_info($variables['src']);
    
    $item = array(
      'width' => $image_info['width'],
      'height' => $image_info['height'],
      'alt' => '',
      'title' => '',
    );
  }
  
  if (empty($variables['image_styles'])) {
    // No image styles, placeholder for foreach loop to display unstyled.
    $variables['image_styles'][] = !empty($variables['image_style']) ? $variables['image_style'] : '';
  }
  
  $render_array = array();
  
  foreach ($variables['image_styles'] as $image_style) {
    
    $image = array(
      'alt' => $item['alt'],
      'dimensions' => array(
        'width' => $item['width'],
        'height' => $item['height'],
      ),
      'title' => $item['title'],
    );
    
    if (!empty($image_style)) {
      
      $image['src'] = image_style_url($image_style, $variables['src']);
      
      // Get the dimensions of the final, styled image.
      image_style_transform_dimensions($image_style, $image['dimensions']);
    }
    else {
      // No image style, render unstyled.
      $image['src'] = file_create_url($variables['src']);
    }
    
    // Calculate ratio after potential image resizing for best 1:1.
    $ratio = $image['dimensions']['height'] / $image['dimensions']['width'];
    $percent = $ratio * 100;
    
    $render_array[$image_style]['wrapper'] = array(
      '#type' => 'container',
      '#attributes' => array(
        'class' => array(
          'mqi-wrapper',
        ),
        'style' => array(
          'width: ' . $image['dimensions']['width'] . 'px;',
        ),
      ),
    );
    
    if (!empty($image_style)) {
      $render_array[$image_style]['wrapper']['#attributes']['mqi-style'] = drupal_clean_css_identifier($image_style);
    }
    
    if (!empty($variables['attributes']['mqi-group'])) {
      $render_array[$image_style]['wrapper']['#attributes']['mqi-group'] = drupal_clean_css_identifier($variables['attributes']['mqi-group']);
    }
    
    $render_array[$image_style]['wrapper']['image'] = array(
      '#type' => 'container',
      '#attributes' => array(
        'class' => array(
          'mqi-image',
        ),
        'style' => array(
          // Element's vertical % padding is based on the width of parent.
          'padding-top: ' . $percent . '%;',
          'background-image: url(' . $image['src'] . ');',
          // IE compatibility
          'filter: progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\'' . $image['src'] . '\', sizingMethod=\'scale\');',
        ),
      ),
    );
    
    
    /**
     * 'img' tag to handle alt and title attributes for Accessibility.
     */
    $img = array(
      // 1x1 GIF in base64 rather than having another remote request.
      // Also prevents "missing image" icon from displaying.
      'src' => 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',
      'alt' => $image['alt'],
      'title' => $image['title'],
      'class' => 'mqi-img',
    );
    
    $render_array[$image_style]['wrapper']['image']['accessibility'] = array(
      '#type' => 'markup',
      // array_filter() removes any empty() values, either alt or title.
      '#markup' => '<img ' . drupal_attributes(array_filter($img)) . ' />',
    );
  }
  
  $output = drupal_render($render_array);
  
  if ($variables['path']) {
    
    $path = $variables['path']['path'];
    $options = $variables['path']['options'];
    
    // When displaying HTML inside a link, the html option must be TRUE.
    $options['html'] = TRUE;
    
    $output = l($output, $path, $options);
  }

  return $output;
}
