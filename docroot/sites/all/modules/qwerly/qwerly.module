<?php

/**
 * Implements hook_menu().
 */
function qwerly_menu() {
  // main Qwerly settings page
  $items = array();
  $access = array('administer qwerly');
  $items['admin/config/people/qwerly'] = array(
    'title' => 'Qwerly Settings',
    'description' => 'Configure how Qwerly interacts with user data',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('qwerly_settings_page', 4),
    'access arguments' => $access,
    'file' => 'qwerly.admin.inc',
  );

  // adds all existing users to the queue.
  $items['admin/config/people/qwerly/process_existing'] = array(
    'page callback' => 'qwerly_process_existing',
    'type' => MENU_CALLBACK,
    'access arguments' => $access,
    'file' => 'qwerly.admin.inc',
  );

  // not access gaurded, might be an issue if someone wants
  // to spam the site into submission via this URL?
  // possibly not, as after a short while the cache update queue
  // will be empty and requests will take the same time as any
  // other DDOS-style request.
  $items['_qwerly/cron'] = array(
    'page callback' => 'qwerly_do_cron',
    'type' => MENU_CALLBACK,
    'access arguments' => array('access content'),
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function qwerly_permission() {
  return array(
    'administer qwerly' => array(
      'title' => t('Administer Qwerly settings'),
      'description' => t('Manage the Qwerly API configuration'),
    ),
  );
}


/**
 * Implements hook_enable().
 */
function qwerly_enable() {
  global $base_url;
  $path = str_replace('//', '/', $_SERVER['DOCUMENT_ROOT'] . base_path() . drupal_get_path('module', 'qwerly'));
  $command = 'php ' . escapeshellarg($path . '/cron.php') . ' ' . escapeshellarg($base_url . '/_qwerly/cron');

  drupal_set_message(t('In order for the Qwerly module to update user data, a cronjob must be set. '
    . 'Add the following to your crontab manually.<pre>:command</pre>',
    array('@url' => url('admin/config/people/qwerly/add_cron'), ':command' => $command)));
}


/**
 * Qwerly-specific cron task (every minute)
 */
function qwerly_do_cron() {
  $qwerly = new QwerlyCache();
  $settings = $qwerly->settings;

  // if the API key hasn't been set yet, then don't bother.
  if($settings->api_key == '') {
    return;
  }

  // get all expired caches.
  $exp = $qwerly->get_expired();

  // rate limiting.
  if ($settings->max_requests > 0 && (count($exp)/10 > $settings->max_requests)) {
    $exp = array_slice($exp, 0, $settings->max_requests * 10);
  }


  for ($i = 0; $i < count($exp); $i++) {

    $list = array();
    $mails = array();
    for ($j = $i; $j < min(count($exp), $i+10); $j++) {
      $user = user_load($exp[$j]->data->uid);
      $list[] = $user->mail;
      $mails[$user->mail] = $exp[$j];
    }

    // add ign to force batch-style response
    if (count($list) == 1) {
      array_push($list, 'ign');
    }

    $qwerly->email(implode(',', $list));

    if ($qwerly->last_request->error) {
      drupal_set_message(t('Qwerly CRON error: :error', array(':error' => $qwerly->last_request->error)), 'error');
    }

    foreach ($qwerly->last_request->result as $email => $object) {
      if (isset($mails[$email])) {
        $mails[$email]->last_request->result = $object;
        $mails[$email]->mergesave();
      }
    }
  }

  variable_set('qwerly_last_run', time());
  variable_set('qwerly_last_count', count($exp));
}

/**
 * Implements hook_user_insert().
 * Called when a new user is created.
 * Sets up initial cache and first data request.
 */
function qwerly_user_insert($edit, $account, $category) {
  // insert a new record to the qwerly_data table.
  $uid = $account->uid;
  $email = $account->mail;

  // create a new cache for this user.
  // this is an instance where an HTTP call will occur
  // in a user's load time.
  $qwerly = new QwerlyCache();
  $qwerly->create_user_cache($uid, $email);
}

/**
 * Implements hook_user_update().
 *
 * Detects wether the user email has changed and clears data
 * if we need to do that.
 */
function qwerly_user_update($edit, $account, $category) {

  if ($account->original->mail == $account->mail) {
    return;
  }

  $settings = qwerly_get_settings();

  if ($settings->new_email_action != 'clear') {
    return;
  }

  // this is an instance where an HTTP call will occur
  // in a user's load time.
  $qwerly = new QwerlyCache($settings->api_key);
  $qwerly->by_uid($account->uid);
  $qwerly->email($account->mail);

  // overwrite instead of mergesave
  $qwerly->data->data = $qwerly->last_request->result;

  $qwerly->save();
}

/**
 * Implements hook_user_cancel().
 * Implements hook_user_delete(). (passthrough to _cancel)
 */
function qwerly_user_cancel($e, $account) {
  db_delete('qwerly_data')
    ->condition('uid', $account->uid)
    ->execute();
}
function qwerly_user_delete($account) {
  qwerly_user_cancel(FALSE, $account);
}

/**
 * This hook is defined by this module.
 * It is used by implementing modules to get data pertaining
 * to a user.
 *
 * $user       may be either a UID or an object containing a (U)ID
 *
 * $extended   indicates wether to return just the Qwerly data or
 *             a wrapping inferred data block, including TTL and
 *             the related User object
 */
function qwerly_get_user_data($user, $extended = FALSE) {
  if (is_object($user)) {
    if (isset($user->uid)) {
      $user = $user->uid;
    }
    elseif (isset($user->id)) {
      $user = $user->id;
    }
  }

  $qwerly = new QwerlyCache();
  $qwerly->by_uid($user, TRUE, $extended);

  if (!$qwerly || !isset($qwerly->data)) {
    return FALSE;
  }

  return $extended ? $qwerly->edata : $qwerly->data->data->profile;
}


/**
 * Retrieve all settings into an object.
 */
function qwerly_get_settings() {
  $o = new stdClass;
  $o->api_key =             variable_get('qwerly_api_key', FALSE);
  $o->cache_time =          variable_get('qwerly_cache_time', 86400);
  $o->update_indefinitely = variable_get('qwerly_update_indefinitely', TRUE);
  $o->max_requests =        variable_get('qwerly_max_requests', '0');
  $o->new_email_action =    variable_get('qwerly_new_email_action', 'append');
  return $o;
}

/**
 * Save settings back to the database.
 * Does not do any sanity checking!
 */
function qwerly_save_settings($o) {
  foreach (array('api_key', 'cache_time', 'update_indefinitely', 'max_requests', 'new_email_action',) as $key) {
    if (isset($o->$key)) {
      variable_set('qwerly_' . $key, $o->$key);
    }
  }
}
