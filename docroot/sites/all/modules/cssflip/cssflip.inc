<?php // $Id $ 

/* 

CSSFlip class parses CSS files or strings and flips the direction of all attributes from LTR to RTL and vice versa.
It has been designed to fit Drupal theming needs in a way that supresses duplicate styles.
  
@version        0.1 

@example 

    $oldcss = new CSSFlip(); 
    $oldcss->parseFile("style.css"); 
    $flippedcss = $oldcss->flip(); 

@author     Ahmad Kharbat (kharbat@gmail.com) 

http://www.vardot.com

@TODO flip operator ex: text-indent

*/ 

class CSSFlip extends CSSParser {

  var $flippedCSS = array(); 
  	
  // Enable overriding values for old attribtues
  var $override = TRUE;
  
  // Supress and remove duplicate attributes generated by CSS Flip
  var $suppress = TRUE;  
	
	// Alter image names to -rtl , to support flipping naming convention
	var $rename_images = FALSE;
	
	// Rotate images horizontal and save them in files directory.
	var $rotate_images = FALSE;
	
	// Alter image paths respectivley to the path of parsed file
	var $path_correction = TRUE;	
	
	// Valid css properties that can be flipped along with the suitable callback
	var $properties = array(
		'background'		 		=> 'flip_position',
    'background-position'     => 'flip_position',
    'background-image'     => 'flip_position',	
		'border-left'				=> 'flip_attribute',
		'border-left-color'			=> 'flip_attribute',
		'border-left-style'			=> 'flip_attribute',
		'border-left-width'			=> 'flip_attribute',
		'border-right'				=> 'flip_attribute',
		'border-right-color'		=> 'flip_attribute',
		'border-right-style'		=> 'flip_attribute',
		'border-right-width'		=> 'flip_attribute',
		'list-style-position'		=> 'flip_position',
		'margin'          => 'flip_value',
		'margin-left'				=> 'flip_attribute',
		'margin-right'				=> 'flip_attribute',
		'padding'					=> 'flip_value',
		'padding-left'				=> 'flip_attribute',
		'padding-right'				=> 'flip_attribute',
		'float'						=> 'flip_direction',
		'left'						=> 'flip_attribute',
		'right'						=> 'flip_attribute',
		'text-align'        => 'flip_direction',
	  'text-indent'       => 'flip_operator',
		'direction'					=> 'flip_direction',	

	   'border-radius' => 'flip_value_set',
	   'border-top-left-radius' => 'flip_attribute',
		 'border-top-right-radius' => 'flip_attribute',
		 'border-bottom-left-radius' => 'flip_attribute',
		 'border-bottom-right-radius' => 'flip_attribute',
	
	    // Moz and Webkit
	   '-moz-border-radius' => 'flip_value_set',
     '-moz-border-radius-topleft' => 'flip_attribute',
     '-moz-border-radius-topright' => 'flip_attribute',
     '-moz-border-radius-bottomleft' => 'flip_attribute',
     '-moz-border-radius-bottomright' => 'flip_attribute',
		
     '-webkit-border-radius' => 'flip_value_set',
     '-webkit-border-top-left-radius' => 'flip_attribute',
     '-webkit-border-top-right-radius' => 'flip_attribute',
     '-webkit-border-bottom-left-radius' => 'flip_attribute',
     '-webkit-border-bottom-right-radius' => 'flip_attribute',	
	);
	
	function CSSFlip() {
		parent::CSSParser();
	}
	
	function flip() {
		foreach($this->css as $selector => $attributes) {
			foreach($attributes as $attr => $val) {
				if(isset($this->properties[$attr]) && $callback = $this->properties[$attr]) {
					$this->flippedCSS[$selector] = (isset($this->flippedCSS[$selector]) ? $this->flippedCSS[$selector] : array());
					$this->flippedCSS[$selector] += $this->$callback($attr, $val);
				} else if(! $this->override) {
					$this->flippedCSS[$selector][$attr] = $this->css[$selector][$attr];
				}
			}
		}
		
		return $this->getFlippedCSS();
	}
	
	function getFlippedCSS() { 
	    $result = ""; 
	    foreach($this->flippedCSS as $key => $values) { 
	      $result .= $key." {\n"; 
	      foreach($values as $key => $value) { 
	        $result .= "  $key: $value;\n"; 
	      } 
	      $result .= "}\n\n"; 
	    } 
	    return $result; 
	} 	
	
	/**
	 * Below are CSS Flip callbacks that cover almost all cases
	 */
	
	function flip_direction($attr, $val) {
		if($attr == 'direction') {
			$val = ($val == 'ltr' ? 'rtl' : 'ltr');
		} else {
			if($val == 'left')
				$val = 'right';
			else if($val == 'right')
				$val = 'left';		
		}
		
		return array($attr => $val);
	}
	
  function flip_operator($attr, $val) {
    if(preg_match("/-/", $val, $matches)) {
      $val = preg_replace("/-/", '', $val);
    }
    
    return array($attr => $val);
  }	
	
  function flip_attribute($attr, $val) {
    $output = ($this->override ? array($attr => 'auto !important') : array());
    
    if(preg_match("/left/", $attr, $matches)) {
      $attr = preg_replace("/left/", 'right', $attr);
    } else if(preg_match("/right/", $attr, $matches)) {
      $attr = preg_replace("/right/", 'left', $attr);
    }
    
    return ($output + array($attr => $val));
  }
	
  function flip_value($attr, $val) {
    $values = explode(' ', $val);
    
    if(sizeof($values) == 4) {
      $temp = $values[1];
      $values[1] = $values[3];
      $values[3] = $temp;
      unset($temp);
      $val = implode(' ', $values);
    }
    
    return array($attr => $val);
  }
  
  function flip_value_set($attr, $val) {
    $values = explode(' ', $val);
    
    if(sizeof($values) == 4) {
      $temp = $values[0];
      $values[0] = $values[1];
      $values[1] = $temp;
      
      $temp = $values[2];
      $values[2] = $values[3];
      $values[3] = $temp;      
      unset($temp);
      $val = implode(' ', $values);
    }
    
    return array($attr => $val);
  }  
	
	function flip_position($attr, $val) {
		if(preg_match("/ left /", $val, $matches)) {
			$val = preg_replace("/ left /", ' right ', $val, 1);
		} else if(preg_match("/ right /", $val, $matches)) {
			$val = preg_replace("/ right /", ' left ', $val, 1);
		}
		
		
		if(preg_match('/url\(([\'"]?)(?![a-z]+:)([^\'")]+)[\'"]?\)?/i', $val, $matches)){
			$url = $matches[2];
			$newUrl = $url;
			
			/** Respect stylesheet original path */
			if($this->file_path && $this->path_correction) {
				$dir = dirname($this->file_path);
				$cwd = getcwd();
				chdir($dir);
				$realpath = str_replace($cwd, '', realpath($url));
				chdir($cwd);
				$lang = new stdClass();
				$lang->language = 'en';
				
				$newUrl = url($realpath, array('language' => $lang));
				$newUrl = str_replace('\\', '/', $newUrl);
				$newUrl = str_replace('//', '/', $newUrl);				
			}
			
			$filename = basename($url);
			$fileparts = explode('.', $filename);
			
			/** Add -flp to filename for flipped images naming convention */
			if($this->convention) {
				$fileparts[sizeof($fileparts) - 2] .= '-rtl';
				$flpfilename = implode('.', $fileparts);
				$newUrl = preg_replace("/$filename/", $flpfilename, $newUrl);
			}

			$val = preg_replace("`$url`", $newUrl, $val, 1);
		}
		
		return array($attr => $val);
	}
}


class CSSParser { 
  var $css;
  var $html; 
  var $file_path;
   
  function CSSParser($html = true) { 
    // Register "destructor" 
    register_shutdown_function(array(&$this, "finalize")); 
    $this->html = ($html != false); 
    $this->clear(); 
  } 
   
  function finalize() { 
    unset($this->css); 
  } 
   
  function clear() { 
    unset($this->css); 
    $this->css = array();
  } 
   
  function setHTML($html) { 
    $this->html = ($html != false); 
  } 
   
  function add($key, $codestr) { 
    $key = strtolower($key); 
    $codestr = strtolower($codestr); 
    if(!isset($this->css[$key])) { 
      $this->css[$key] = array(); 
    } 
    $codes = explode(";",$codestr); 
    if(count($codes) > 0) { 
      foreach($codes as $code) { 
        $code = trim($code); 
        
        // @TODO log potential css error.
        @list($codekey, $codevalue) = explode(":", $code); 
        if(strlen($codekey) > 0) { 
          $this->css[$key][trim($codekey)] = trim($codevalue); 
        } 
      } 
    } 
  } 
   
  function get($key, $property) { 
    $key = strtolower($key); 
    $property = strtolower($property); 
     
    list($tag, $subtag) = explode(":",$key); 
    list($tag, $class) = explode(".",$tag); 
    list($tag, $id) = explode("#",$tag); 
    $result = ""; 
    foreach($this->css as $_tag => $value) { 
      list($_tag, $_subtag) = explode(":",$_tag); 
      list($_tag, $_class) = explode(".",$_tag); 
      list($_tag, $_id) = explode("#",$_tag); 
       
      $tagmatch = (strcmp($tag, $_tag) == 0) | (strlen($_tag) == 0); 
      $subtagmatch = (strcmp($subtag, $_subtag) == 0) | (strlen($_subtag) == 0); 
      $classmatch = (strcmp($class, $_class) == 0) | (strlen($_class) == 0); 
      $idmatch = (strcmp($id, $_id) == 0); 
       
      if($tagmatch & $subtagmatch & $classmatch & $idmatch) { 
        $temp = $_tag; 
        if((strlen($temp) > 0) & (strlen($_class) > 0)) { 
          $temp .= ".".$_class; 
        } elseif(strlen($temp) == 0) { 
          $temp = ".".$_class; 
        } 
        if((strlen($temp) > 0) & (strlen($_subtag) > 0)) { 
          $temp .= ":".$_subtag; 
        } elseif(strlen($temp) == 0) { 
          $temp = ":".$_subtag; 
        } 
        if(isset($this->css[$temp][$property])) { 
          $result = $this->css[$temp][$property]; 
        } 
      } 
    } 
    return $result; 
  } 
   
  function getSection($key) { 
    $key = strtolower($key); 
     
    list($tag, $subtag) = explode(":",$key); 
    list($tag, $class) = explode(".",$tag); 
    list($tag, $id) = explode("#",$tag); 
    $result = array(); 
    foreach($this->css as $_tag => $value) { 
      list($_tag, $_subtag) = explode(":",$_tag); 
      list($_tag, $_class) = explode(".",$_tag); 
      list($_tag, $_id) = explode("#",$_tag); 
       
      $tagmatch = (strcmp($tag, $_tag) == 0) | (strlen($_tag) == 0); 
      $subtagmatch = (strcmp($subtag, $_subtag) == 0) | (strlen($_subtag) == 0); 
      $classmatch = (strcmp($class, $_class) == 0) | (strlen($_class) == 0); 
      $idmatch = (strcmp($id, $_id) == 0); 
       
      if($tagmatch & $subtagmatch & $classmatch & $idmatch) { 
        $temp = $_tag; 
        if((strlen($temp) > 0) & (strlen($_class) > 0)) { 
          $temp .= ".".$_class; 
        } elseif(strlen($temp) == 0) { 
          $temp = ".".$_class; 
        } 
        if((strlen($temp) > 0) & (strlen($_subtag) > 0)) { 
          $temp .= ":".$_subtag; 
        } elseif(strlen($temp) == 0) { 
          $temp = ":".$_subtag; 
        } 
        foreach($this->css[$temp] as $property => $value) { 
          $result[$property] = $value; 
        } 
      } 
    } 
    return $result; 
  } 
   
  function parseStr($str) { 
    $this->Clear(); 
    // Remove comments 
    $str = preg_replace("/\/\*(.*)?\*\//Usi", "", $str); 
    // Parse this damn csscode 
    $parts = explode("}",$str); 
    if(count($parts) > 0) { 
      foreach($parts as $part) { 
      	// @TODO report potential css error
        @list($keystr,$codestr) = explode("{",$part); 
        $keys = explode(",",trim($keystr)); 
        if(count($keys) > 0) { 
          foreach($keys as $key) { 
            if(strlen($key) > 0) { 
              $key = str_replace("\n", "", $key); 
              $key = str_replace("\\", "", $key); 
              $this->add($key, trim($codestr)); 
            } 
          } 
        } 
      } 
    } 
    // 
    return (count($this->css) > 0); 
  } 
   
  function parse($filename) { 
    $this->clear(); 
    if(file_exists($filename)) { 
      $this->file_path = $filename;
      return $this->parseStr(file_get_contents($filename)); 
    } else { 
      return false; 
    } 
  } 
   
  function getCSS() { 
    $result = ""; 
    foreach($this->css as $key => $values) { 
      $result .= $key." {\n"; 
      foreach($values as $key => $value) { 
        $result .= "  $key: $value;\n"; 
      } 
      $result .= "}\n\n"; 
    } 
    return $result; 
  } 
} 