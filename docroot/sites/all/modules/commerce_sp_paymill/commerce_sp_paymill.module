<?php

/**
 * @file
 * Paymill subscriptions integration.
 *
 * Parts copied from http://drupalcode.org/sandbox/7wonders/1906916.git.
 */

define('COMMERCE_SP_PAYMILL_BRIDGE', 'https://bridge.paymill.com/');
define('COMMERCE_SP_PAYMILL_SERVER', 'https://api.paymill.com/v2/');
define('COMMERCE_SP_PAYMILL_QUEUE_NAME', 'commerce_sp_paymill_queue');

include_once('includes/commerce_sp_paymill.inc');
include_once('commerce_sp_paymill.features.inc');

/**
 * Implements hook_menu().
 */
function commerce_sp_paymill_menu() {
  $items['admin/commerce/config/commerce_sp_paymill'] = array(
    'title' => 'Paymill subscriptions',
    'description' => 'Configure your Paymill API settings and points of integration with Drupal.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_sp_paymill_settings_form'),
    'access arguments' => array('administer payment methods'),
    'file' => 'includes/commerce_sp_paymill.admin.inc',
  );

  // Define an always accessible paymill webhook. The URL to it is based on a
  // random key and validation is performed based on the subscription id, which
  // is generated by Paymill.
  $webhookkey = variable_get('commerce_sp_paymill_webhook_key', '');
  if (!empty($webhookkey)) {
    $items['commerce_sp_paymill/webhook/' . $webhookkey] = array(
      'page callback' => 'commerce_sp_paymill_webhook_process',
      'access callback' => TRUE,
      'type' => MENU_CALLBACK,
      'file' => 'includes/commerce_sp_paymill.webhook.inc',
    );
  }

  $items['commerce_sp_paymill/cancel/%commerce_sp_paymill_sub'] = array(
    'title' => 'Cancel subscriptions',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_sp_paymill_cancel_form', 2),
    'access callback' => 'commerce_sp_paymill_cancel_access',
    'access arguments' => array(2),
  );

  return $items;
}

/**
 * Implements hook_libraries_info_alter().
 */
function commerce_sp_paymill_libraries_info_alter(&$libraries) {
  // @todo Commerce SP should include the Webhooks class.
  if (isset($libraries['paymill'])) {
    $libraries['paymill']['files']['php'][] = 'Webhooks.php';
  }
}

/**
 * Implements hook_commerce_payment_method_info_alter().
 */
function commerce_sp_paymill_commerce_payment_method_info_alter(&$payment_methods) {
  // Unfortunately we have to override the submit handler for the Paymill
  // payment method, as the default implementation always creates a transaction,
  // which is not valid when creating a new subscription
  if (isset($payment_methods['commerce_paymill'])) {
    $payment_methods['commerce_paymill']['callbacks']['submit_form_submit'] = 'commerce_sp_paymill_payment_submit_form_submit';
  }
}

/**
 * Implements hook_entity_info().
 */
function commerce_sp_paymill_entity_info() {
  return array(
    'commerce_sp_paymill_sub' => array(
      'label' => t('Commerce SP Paymill subscription'),
      'controller class' => 'EntityAPIController',
      'entity class' => 'CommerceSPPaymillSub',
      'base table' => 'commerce_sp_paymill_sub',
      'fieldable' => FALSE,
      'entity keys' => array(
        'id' => 'id',
        'label' => FALSE,
      ),
      'bundles' => array(),
      'metadata controller class' => 'CommerceSPPaymillSubMetadataController',
      'views controller class' => 'EntityDefaultViewsController',
    ),
  );
}

/**
 * Loads a single subscription entity by id.
 */
function commerce_sp_paymill_sub_load($id) {
  return entity_load_single('commerce_sp_paymill_sub', $id);
}

/**
 * Creates a new subscription entity.
 */
function commerce_sp_paymill_sub_create(array $values) {
  return new CommerceSPPaymillSub($values);
}

/**
 * Checks whether a subscription already exists for an order. Having more than
 * one subscription per order is not valid.
 *
 * @param $order_id
 *   The order id from the commerce order entity.
 *
 * @return
 *   TRUE if subscription already exists, else FALSE.
 */
function commerce_sp_paymill_sub_order_exists($order_id) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_sp_paymill_sub')
    ->propertyCondition('order_id', $order_id);

  $count = $query->count()->execute();
  return $count >= 1 ? TRUE : FALSE;
}

/**
 * Loads subscription entity based on the provided order id.
 *
 * @param $order_id
 *   The order id from the commerce order entity.
 *
 * @return
 *   Subscription object, if it exists, else FALSE.
 */
function commerce_sp_paymill_sub_load_by_order($order_id) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_sp_paymill_sub')
    ->propertyCondition('order_id', $order_id);

  $result = $query->execute();
  if (isset($result['commerce_sp_paymill_sub']) && count($result['commerce_sp_paymill_sub']) === 1) {
    $entities = entity_load('commerce_sp_paymill_sub', array_keys($result['commerce_sp_paymill_sub']));
    return reset($entities);
  }
  return FALSE;
}

/**
 * Loads subscription entity based on the provided Paymill subscription id.
 *
 * @param $paymill_subscription_id
 *   The Paymill subscription id string.
 *
 * @return
 *   Subscription object, if it exists, else FALSE.
 */
function commerce_sp_paymill_sub_load_by_subscription_id($paymill_subscription_id) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_sp_paymill_sub')
    ->propertyCondition('subscription_id', $paymill_subscription_id);

  $result = $query->execute();
  if (isset($result['commerce_sp_paymill_sub']) && count($result['commerce_sp_paymill_sub']) === 1) {
    $entities = entity_load('commerce_sp_paymill_sub', array_keys($result['commerce_sp_paymill_sub']));
    return reset($entities);
  }
  return FALSE;
}

/**
 * Loads subscription entity based on the provided Paymill subscription id.
 *
 * @param $paymill_subscription_id
 *   The Paymill subscription id string.
 *
 * @param $status
 *   Possible values:
 *     - NULL: do not filter by status
 *     - TRUE: only return active subscriptions
 *     - FALSE: only return inactive subscriptions
 *
 * @return
 *   An array of subscription entities, if they exists, else FALSE.
 */
function commerce_sp_paymill_sub_load_by_user($user, $status = NULL) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_sp_paymill_sub')
    ->propertyCondition('uid', $user->uid);

  // Filter by status if boolean (TRUE | FALSE) is provided.
  if (!is_null($status) && is_bool($status)) {
    $query->propertyCondition('status', $status);
  }

  $result = $query->execute();
  if (isset($result['commerce_sp_paymill_sub'])) {
    return entity_load('commerce_sp_paymill_sub', array_keys($result['commerce_sp_paymill_sub']));
  }
  return FALSE;
}

/**
 * Returns TRUE if the given product is of type subscription and the field
 * 'Paymill recurring billing' is set.
 */
function commerce_sp_paymill_is_recurrent_product($product) {
  if ($product->type == 'commerce_sp_subscription' && isset($product->field_commerce_sp_paymill[LANGUAGE_NONE][0]['value']) && !empty($product->field_commerce_sp_paymill[LANGUAGE_NONE][0]['value'])) {
    return TRUE;
  }
  return FALSE;
}

/**
 * List of Paymill webhooks events that are used by this module.
 */
function commerce_sp_paymill_webhook_event_types() {
  return array(
    'subscription.created'   => t('Subscription created'), // returns a subscription-object
    'subscription.updated'   => t('Subscription updated'), // returns a subscription-object
    'subscription.deleted'   => t('Subscription deleted'), // returns a subscription-object
    'subscription.succeeded' => t('Subscription succeeded'), // returns a transaction-object and a subscription-object
    'subscription.failed'    => t('Subscription fucceeded'), // returns a transaction-object and a subscription-object
  );
}

/**
 * Creates a new inactive subscription entity. Once the first
 * subscription.succeeded webhook event is invoked, the subscription gets
 * activated.
 */
function commerce_sp_paymill_init_subscription($order, $paymill_subscription_id) {
  $values = array(
    'uid' => $order->uid,
    'order_id' => $order->order_id,
    'subscription_id' => $paymill_subscription_id,
    'status' => 1,
    // We already issued the first payment transaction, so start with 1.
    'payment_count' => 1,
  );
  $subscription = commerce_sp_paymill_sub_create($values);
  $subscription->save();
  return $subscription;
}

/**
 * Activates the subscriptions and marks the 'skip_expire' field on the user
 * account, meaning that the recurrent subscription is currently handled by a
 * payment provider.
 */
function commerce_sp_paymill_activate_subscription($subscription, $paymill_transaction) {
  // Set subscription to active.
  $subscription->status = 1;
  $subscription->payment_count = 1;
  $subscription->save();

  // Set skip expiration on user account to indicate this subscription is
  // handled by Paymill.
  $account = $subscription->user();
  if ($account) {
    $account->field_commerce_sp_skip_expire[LANGUAGE_NONE][0]['value'] = 1;
    user_save($account);
  }
}

/**
 * Stops the subscriptions and unmarks the 'skip_expire' field. The subscription
 * will now automatically end as soon as the subscription validity date has
 * been reached.
 *
 * @return TRUE in case of success, else FALSE.
 */
function commerce_sp_paymill_stop_subscription($subscription) {
  // Delete subscription at Paymill.
  $result = commerce_sp_paymill_api_subscription_delete($subscription->subscription_id);
  if (isset($result['error'])) {
    watchdog('commerce_sp_paymill', 'Could not delete subscription with id %id, error response from Paymill: %reason', array('%id' => $subscription->subscription_id, '%reason' => $result['error']), WATCHDOG_ERROR);
    return FALSE;
  }

  // Set subscription to inactive.
  $subscription->status = 0;
  $subscription->save();

  // Unset skip expiration on user account to indicate this subscription is
  // no longer handled by Paymill.
  $account = $subscription->user();
  if ($account) {
    $account->field_commerce_sp_skip_expire[LANGUAGE_NONE][0]['value'] = 0;
    user_save($account);
  }
  return TRUE;
}

/**
 * Implements hook_cron_queue_info().
 */
function commerce_sp_paymill_cron_queue_info() {
  $queues = array();
  $queues[COMMERCE_SP_PAYMILL_QUEUE_NAME] = array(
    'worker callback' => 'commerce_sp_paymill_renew_subscription_queue_execute',
    'time' => 120,
  );
  return $queues;
}

/**
 * Renew the subscription after the system has been notified about a new
 * payment.
 *
 * The execution of this is queued, as Paymill might send multiple subscription
 * renewals at once which can cause some strange bugs.
 */
function commerce_sp_paymill_renew_subscription($subscription, $paymill_transaction) {
  $queue = DrupalQueue::get(COMMERCE_SP_PAYMILL_QUEUE_NAME);
  $queue->createItem(array('order' => $subscription->order(), 'paymill_transaction' => $paymill_transaction));
}

/**
 * Helper function that executes a specific item from our queue and clones the
 * order.
 *
 * @param $item
 *   The queue item including the order and the PayPal IPN.
 */
function commerce_sp_paymill_renew_subscription_queue_execute($item) {
  try {
    commerce_sp_paymill_clone_order($item['order'], $item['paymill_transaction']);
  }
  catch (Exception $e) {
    watchdog('commerce_sp_paymill', 'Error cloning order with id %id on new Paymill subscription payment.', array('%id' => $item['order']->order_id), WATCHDOG_ERROR);
  }

  // Increase the payment count.
  $subscription = commerce_sp_paymill_sub_load_by_order($item['order']->order_id);
  if ($subscription) {
    $subscription->payment_count++;
    $subscription->save();

    // Stop the subscription once we've reached the maximum number of billing
    // cycles.
    $cycles = commerce_sp_paymill_order_get_cycles_limit($item['order']);
    if ($cycles && $subscription->payment_count >= $cycles) {
      commerce_sp_paymill_stop_subscription($subscription);
    }
  }
}

/**
 * Creates a new order based on the information given in $order.
 *
 * Billing address and line items get cloned. Furthermore the order completion
 * is invoked so that Rules action can react upon it (e.g. add subscription
 * time).
 *
 * @param $order
 *   The commerce order to clone.
 * @param $paymill_transaction
 *   The paymill transaction array.
 *
 * @return
 *   The cloned commerce order.
 */
function commerce_sp_paymill_clone_order($order, $paymill_transaction) {
  // Create a new order
  $new_order = commerce_order_new($order->uid, 'pending');

  // Clone the billing address.
  $new_order->commerce_customer_billing = $order->commerce_customer_billing;

  // Save it so it gets an order ID and return the full object.
  commerce_order_save($new_order);

  // Wrap the order for easy access to field data.
  $new_order_wrapper = entity_metadata_wrapper('commerce_order', $new_order);

  // Wrap the master order for easy access to field data.
  $master_order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  foreach ($master_order_wrapper->commerce_line_items as $delta => $line_item_wrapper) {
    if ($line_item_wrapper->type->value() == 'product') {
      $new_line_item = commerce_product_line_item_new($line_item_wrapper->commerce_product->value(), $line_item_wrapper->quantity->value(), $new_order->order_id);
    }
    elseif ($line_item_wrapper->type->value() == 'coupon' && function_exists("commerce_coupon_line_item_new")) {
      // We can programmatically reuse the coupon and thus ensure the same price.
      $coupon = entity_load_single('commerce_coupon', $line_item_wrapper->commerce_coupon_reference->value());
      if ($coupon) {
        $new_line_item = commerce_coupon_line_item_new($coupon, $new_order->order_id);
      }
    }
    if (isset($new_line_item)) {
      // Ensure the same price on the line items. The order total will always
      // be calculated base on this information.
      $new_line_item->commerce_unit_price = $line_item_wrapper->value()->commerce_unit_price;
      commerce_line_item_save($new_line_item);
      $new_order_wrapper->commerce_line_items[] = $new_line_item;
      unset($new_line_item);
    }
  }
  // Save the updated order.
  commerce_order_save($new_order);

  // Create a transaction so that we have a correct order balance. This will
  // invoke the event 'When an order is first paid in full'
  commerce_sp_paymill_create_payment_transaction($new_order, $paymill_transaction, $order->data['payment_method']);

  // Invoke the commerce_checkout_complete Rules event.
  commerce_checkout_complete($new_order);
  return $new_order;
}

/**
 * Helper function that creates a new commerce payment transaction based on the
 * Paymill transaction array.
 */
function commerce_sp_paymill_create_payment_transaction($order, $paymill_transaction, $payment_method = "") {
  // Create a transaction so that we have a correct order balance. This will
  // invoke the event 'When an order is first paid in full'
  $transaction = commerce_payment_transaction_new('commerce_paymill', $order->order_id);
  $transaction->instance_id = !empty($payment_method) ? $payment_method : $order->data['payment_method'];
  $transaction->amount = $paymill_transaction['amount'];
  $transaction->currency_code = $paymill_transaction['currency'];
  $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
  $transaction->remote_id = $paymill_transaction['id'];
  commerce_payment_transaction_save($transaction);
}


/**
 * Returns the maximum billing cycles for an order. 0 means unlimited.
 */
function commerce_sp_paymill_order_get_cycles_limit($order) {
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  foreach ($order_wrapper->commerce_line_items as $delta => $line_item_wrapper) {
    if ($line_item_wrapper->type->value() == 'product') {
      return commerce_sp_paymill_product_get_cycles_limit($line_item_wrapper->commerce_product);
    }
  }
  return 0;
}

/**
 * Returns the maximum billing cycles for a product. 0 means unlimited.
 */
function commerce_sp_paymill_product_get_cycles_limit($product_wrapper) {
  try {
    if ($product_wrapper->type->value() == 'commerce_sp_subscription') {
      $subscription_periods = $product_wrapper->field_commerce_sp_paymill_cycles->value();
      if ($subscription_periods) {
        return $subscription_periods;
      }
    }
  }
  catch (EntityMetadataWrapperException $e) {
    // In case a field is missing, silently return 0.
  }
  return 0;
}


/**
 * Custom submit handler for paymill payment method.
 *
 * @see commerce_sp_paymill_commerce_payment_method_info_alter()
 */
function commerce_sp_paymill_payment_submit_form_submit($payment_method, $pane_form, $pane_values, $order, $charge) {
  // If no subscription product is included, or multiple products are included
  // in the cart, skip creation of subscription and call default implementation.
  $sp_product = commerce_sp_paymill_extract_sp_from_order($order);
  if (!$sp_product) {
    return commerce_paymill_submit_form_submit($payment_method, $pane_form, $pane_values, $order, $charge);
  }

  // Check if we have an according Paymill offer.
  $currency = isset($order->commerce_order_total[LANGUAGE_NONE][0]['currency_code']) ? $order->commerce_order_total[LANGUAGE_NONE][0]['currency_code'] : FALSE;
  $offer = ($currency && isset($sp_product->data['commerce_sp_paymill'][$currency])) ? $sp_product->data['commerce_sp_paymill'][$currency] : FALSE;

  if (!$currency || !$offer || $offer['amount'] != $order->commerce_order_total[LANGUAGE_NONE][0]['amount']) {
    // If the current order configuration (e.g. price) does not match with the
    // default offer, check if we can find an alternative (stored in the custom
    // key). If still not found, create a new offer on the fly.
    $params = commerce_sp_paymill_prepare_offer_params($order->commerce_order_total[LANGUAGE_NONE][0]['amount'], $currency, $sp_product);
    $offer = FALSE;
    if (isset($sp_product->data['commerce_sp_paymill']['custom']) && is_array($sp_product->data['commerce_sp_paymill']['custom'])) {
      foreach ($sp_product->data['commerce_sp_paymill']['custom'] as $o) {
        if (commerce_sp_paymill_offer_params_equals($o, $params)) {
          $offer = $o;
          break;
        }
      }
    }
    if (!$offer) {
      $offer = commerce_sp_paymill_api_offer_create($params);
      if (isset($offer['error'])) {
        watchdog('commerce_sp_paymill', 'Could not create subscription, missing Paymill offer for product %title', array('%title' => $sp_product->title), WATCHDOG_ERROR);
        return FALSE;
      }
      $sp_product->data['commerce_sp_paymill']['custom'][] = $offer;
      commerce_product_save($sp_product);
    }
  }

  // Check that no subscription has been created for the same order before.
  if (commerce_sp_paymill_sub_order_exists($order->order_id)) {
    watchdog('commerce_sp_paymill', 'Could not create new subscription. Subscriptions already exists for order id: %id', array('%id' => $order->order_id), WATCHDOG_ERROR);
    return FALSE;
  }


  // Following code is mostly taken from the commerce_paymill module.
  $order->data['commerce_paymill'] = $pane_values;

  // Include Paymill libraries.
  libraries_load('paymill');

  // Get order total for order.
  $commerce_order_total = field_get_items('commerce_order', $order, 'commerce_order_total');

  // Get current API key
  $api_key = commerce_paymill_get_key($payment_method['settings']);

  // Create Commerce transaction.
  $transaction = commerce_payment_transaction_new('commerce_paymill', $order->order_id);
  $transaction->instance_id = $payment_method['instance_id'];
  $transaction->amount = $charge['amount'];
  $transaction->currency_code = $charge['currency_code'];
  // Set the transaction to failed per default and change that later to success.
  $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;

  // Get client ID
  $client_id = commerce_paymill_get_client($order, $payment_method['settings']);
  if (!$client_id) {
    $transaction->message = 'Failed to get client ID from Paymill.';
    commerce_payment_transaction_save($transaction);
    return FALSE;
  }

  // Create payment card
  $payment_params = array(
    'token' => $pane_values['credit_card']['token'],
    'client' => $client_id,
  );
  $payment_service = new Services_Paymill_Payments($api_key, COMMERCE_PAYMILL_SERVER);
  $payment = $payment_service->create($payment_params);
  if (isset($payment['error'])) {
    // The Paymill error structure is completely unknown, so only print it if we
    // get a flat string.
    if (is_scalar($payment['error'])) {
      $error = check_plain($payment['error']);
      drupal_set_message($error, 'error');
    }
    else {
      $error = 'Error when creating payment: ' . check_plain(print_r($payment, TRUE));
      drupal_set_message(t('A payment error occured, please contact the site administrator.'), 'error');
    }
    $transaction->message = $error;
    commerce_payment_transaction_save($transaction);
    return FALSE;
  }

  // Create transaction/preauth
  $transaction_params = array(
    'amount' => $commerce_order_total[0]['amount'],
    'currency' => $commerce_order_total[0]['currency_code'],
    'payment' => $payment['id'],
  );
  if ($payment_method['settings']['capture_mode'] == COMMERCE_CREDIT_AUTH_ONLY) {
    $preauthorization_service = new Services_Paymill_Preauthorizations($api_key, COMMERCE_PAYMILL_SERVER);
    $response = $preauthorization_service->create($transaction_params);
  }
  else {
    $transaction_service = new Services_Paymill_Transactions($api_key, COMMERCE_PAYMILL_SERVER);
    $transaction_params['description'] = 'Order:' . $order->order_id;
    $response = $transaction_service->create($transaction_params);
  }

  // Check for errors from the response.
  if (isset($response['error'])) {
    if (is_scalar($response['error'])) {
      $error = check_plain($response['error']);
      drupal_set_message($error, 'error');
    }
    else {
      $error = 'Error when creating transaction: ' . check_plain(print_r($response, TRUE));
      drupal_set_message(t('A transaction error occured, please contact the site administrator.'), 'error');
    }
    $transaction->message = $error;
    commerce_payment_transaction_save($transaction);
    return FALSE;
  }

  // Now handle the successful payment transaction.
  if ($payment_method['settings']['capture_mode'] == COMMERCE_CREDIT_AUTH_ONLY) {
    $transaction->status = COMMERCE_PAYMENT_STATUS_PENDING;
    $transaction->remote_id = $response['preauthorization']['id'];
  }
  else {
    $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
    $transaction->remote_id = $response['id'];
  }

  // Save transaction.
  commerce_payment_transaction_save($transaction);


  // Now create a subscription in the future depending on the offer interval.
  $params = array(
    'offer' => $offer['id'],
    'client' => $client_id,
    'payment' => $payment['id'],
    'start_at' => strtotime($offer['interval']),
  );
  $result = commerce_sp_paymill_api_subscription_create($params);
  if (isset($result['error'])) {
    drupal_set_message(t('An error occured creating your subscription, please contact the site administrator.'), 'error');
    watchdog('commerce_sp_paymill', 'Could not create subscription, error response from Paymill: %reason', array('%reason' => print_r($result, TRUE)), WATCHDOG_ERROR);
  }
  else {
    // Init an active subscription object.
    commerce_sp_paymill_init_subscription($order, $result['id']);
  }
}

/**
 * Implements hook_order_update().
 *
 * Update user if of subscription entity if user on order entity changes.
 */
function commerce_sp_paymill_commerce_order_update($order) {
  if (isset($order->original) && $order->original->uid != $order->uid) {
    $sub = commerce_sp_paymill_sub_load_by_order($order->order_id);
    if ($sub && $sub->uid != $order->uid) {
      $sub->uid = $order->uid;
      entity_save('commerce_sp_paymill_sub', $sub);

      // Set skip expiration on user account to indicate this subscription is
      // handled by Paymill. But only if the order is active.
      $account = $sub->user();
      if ($account && $sub->status == 1) {
        $account->field_commerce_sp_skip_expire[LANGUAGE_NONE][0]['value'] = 1;
        user_save($account);
      }
    }
  }
}

/**
 * Access callback for cancel subscription form.
 *
 * Access is only granted if the subscription is active and the user either has
 * administer payment permissions or is the owner of the subscription.
 */
function commerce_sp_paymill_cancel_access($subscription) {
  if (!$subscription->status) {
    return FALSE;
  }
  if (user_access('administer payments')) {
    return TRUE;
  }
  if ($subscription->uid && $GLOBALS['user']->uid === $subscription->uid) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Cancellation form.
 */
function commerce_sp_paymill_cancel_form($form, &$form_state, $subscription) {
  $form = confirm_form($form, t('Are you sure you want to cancel your subscription?'), '',  t('This action cannot be undone.'), t('Yes'), t('No'));
  $form['subscription'] = array('#value' => $subscription);
  return $form;
}

/**
 * Cancellation form submit handler.
 */
function commerce_sp_paymill_cancel_form_submit($form, &$form_state) {
  $success = FALSE;
  if (!empty($form_state['values']['confirm']) && isset($form['subscription']['#value'])) {
    $success = commerce_sp_paymill_stop_subscription($form['subscription']['#value']);
  }

  if ($success) {
    drupal_set_message(t('Your subscription has successfully been canceled.'));
  }
  else {
    drupal_set_message(t('Your subscription could not be canceled. Please contact the website administrator.'), 'error');
  }
  $form_state['redirect'] = '';
}

/**
 * Implements hook_commerce_product_presave().
 */
function commerce_sp_paymill_commerce_product_presave($product) {
  if (commerce_sp_paymill_is_recurrent_product($product)) {
    $data = isset($product->data['commerce_sp_paymill']) ? $product->data['commerce_sp_paymill'] : array();

    if (module_exists('commerce_multicurrency')) {
      // Multi currency module integration.
      $fields = field_info_instances('commerce_product', $product->type);
      foreach ($fields as $field_name => $field) {
        $field_info = field_info_field($field_name);
        // Take all commerce_price fields, except the default one.
        if ($field_info['type'] == 'commerce_price' && $field_name != 'commerce_price') {
          $params = commerce_sp_paymill_prepare_offer_params($product->{$field_name}[LANGUAGE_NONE][0]['amount'], $product->{$field_name}[LANGUAGE_NONE][0]['currency_code'], $product);
          $result = commerce_sp_paymill_add_offer_to_product($data, $params);
          if ($result) {
            $data[$params['currency']] = $result;
          }
        }
      }
    }
    else {
      $field_name = 'commerce_price';
      $params = commerce_sp_paymill_prepare_offer_params($product->{$field_name}[LANGUAGE_NONE][0]['amount'], $product->{$field_name}[LANGUAGE_NONE][0]['currency_code'], $product);
      $result = commerce_sp_paymill_add_offer_to_product($data, $params);
      if ($result) {
        $data[$params['currency']] = $result;
      }
    }
    $product->data['commerce_sp_paymill'] = $data;
  }
}

/**
 * Helper function that prepares the Paymill parameters for creating new offers.
 */
function commerce_sp_paymill_prepare_offer_params($amount, $currency, $product) {
  $params = array(
    'amount' => $amount,
    'currency' => $currency,
    'interval' => commerce_sp_paymill_convert_interval_field($product->field_commerce_sp_time),
  );
  $params['name'] = check_plain($product->title) . ' (' . commerce_currency_amount_to_decimal($params['amount'], $params['currency']) . check_plain($params['currency']) . ')';
  return $params;
}

/**
 * Helper function to register a new Paymill offer if the product data has
 * changed.
 */
function commerce_sp_paymill_add_offer_to_product($product_data, $params) {
  if (empty($product_data[$params['currency']]) || !commerce_sp_paymill_offer_params_equals($product_data[$params['currency']], $params)) {
    $result = commerce_sp_paymill_api_offer_create($params);
    if (isset($result['error'])) {
      drupal_set_message(t('Failed creating offer with Paymill. Please make sure you have filled in your !details and that all form fields are valid.', array(
        '!details' => l(t('Paymill API Keys'), 'admin/commerce/config/commerce_sp_paymill'),
      )), 'error');
    }
    drupal_set_message(t("Updated Paymill offer for currency %currency.", array('%currency' => $params['currency'])));
    return $result;
  }
  return FALSE;
}

/**
 * Helper function that checks whether two parameters arrays for Paymill offers
 * are identical.
 */
function commerce_sp_paymill_offer_params_equals($params1, $params2) {
  $keys = array('amount', 'interval', 'name');
  foreach ($keys as $key) {
    if (!isset($params1[$key]) || !isset($params2[$key]) || $params1[$key] != $params2[$key]) {
      return FALSE;
    }
  }
  return TRUE;
}

/**
 * Converts interval field values to Paymill representation, e.g "1 DAY".
 */
function commerce_sp_paymill_convert_interval_field($field_values) {
  $period = $field_values[LANGUAGE_NONE][0]['period'];
  $interval = $field_values[LANGUAGE_NONE][0]['interval'];

  // DAY | WEEK | MONTH | YEAR
  $paymill_period = strtoupper($period);
  return $interval . " " . $paymill_period;
}

/**
 * Helper function to extract the subscription product from an order.
 *
 * If multiple products are found, FALSE is returned (invalid for creating a
 * subscription).
 */
function commerce_sp_paymill_extract_sp_from_order($order) {
  $sp_product = FALSE;
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

  // Extract the subscription product.
  $products = array();
  foreach ($order_wrapper->commerce_line_items as $delta => $line_item_wrapper) {
    if ($line_item_wrapper->type->value() == 'product') {
      $products[] = $line_item_wrapper->commerce_product->value();
    }
  }
  if (count($products) === 1 && commerce_sp_paymill_is_recurrent_product($products[0])) {
    $sp_product = $products[0];
  }
  return $sp_product;
}
