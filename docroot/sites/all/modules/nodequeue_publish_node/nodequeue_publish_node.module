<?php

/**
 * @file
 * Maintains queues of Published nodes in arbitrary order.
 */

/**
 * Implements hook_form_alter().
 */
function nodequeue_publish_node_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'nodequeue_edit_queue_form') {
    $arg = arg();
    $queuelist = array();
    $published_queues = variable_get('nodequeue_publish_node_queue_id');
    $queuelist = unserialize($published_queues);
    $form['nodequeue_publish_node_check'] = array(
      '#type' => 'checkbox',
      '#title' => t('Check this if you need to show only published Node in the Nodequeue'),
      '#default_value' => is_array($queuelist) ? in_array($arg[3], $queuelist) ? 1 : 0 : '',
      '#weight' => '0',
    );
    $form['#submit'][] = 'nodequeue_publish_node_form_submit';
  }
}

/**
 * Implements Altered Submit Callback of Nodequeue Edit and Add Form.
 */
function nodequeue_publish_node_form_submit($form, &$form_state) {
  $published_queues = variable_get('nodequeue_publish_node_queue_id');
  $queuelist = unserialize($published_queues);
  $publishedstatus = $form_state['values']['nodequeue_publish_node_check'];
  if ($publishedstatus) {
    if (is_array($queuelist)) {
      if (!in_array($form_state['values']['qid'], $queuelist)) {
        $queuelist[] = $form_state['values']['qid'];
      }
    }
  }
  else {
    if (($key = array_search($form_state['values']['qid'], $queuelist)) !== FALSE) {
      unset($queuelist[$key]);
    }
  }
  $serializedvalue = serialize($queuelist);
  variable_set('nodequeue_publish_node_queue_id', $serializedvalue);
}

/**
 * Implements hook_menu_alter().
 */
function nodequeue_publish_node_menu_alter(&$items) {
  $items['nodequeue/autocomplete']['page callback'] = 'nodequeue_publish_node_callback';
}

/**
 * Page callback for autocomplete to display only published nodes.
 */
function nodequeue_publish_node_callback() {
  $args = func_get_args();
  $sqid = array_shift($args);
  $string = implode('/', $args);
  $nodequeue_publish_node_check_value = variable_get('nodequeue_publish_node_queue_id');
  $nodequeue_publish_node_check_value_array = unserialize($nodequeue_publish_node_check_value);
  if (in_array($sqid, $nodequeue_publish_node_check_value_array)) {
    $matches = nodequeue_publish_node_autocomplete_alter($sqid, $string);
  }
  else {
    $matches = _nodequeue_autocomplete($sqid, $string);
  }
  drupal_json_output(drupal_map_assoc($matches));
}

/**
 * Callback function of nodequeue_publish_node_callback().
 */
function nodequeue_publish_node_autocomplete_alter($sqid, $string) {
  $output = array();

  if (!is_numeric($sqid) || !$string) {
    return $output;
  }

  $subqueue = nodequeue_load_subqueue($sqid);
  if (!$subqueue) {
    return $output;
  }

  $queue = nodequeue_load($subqueue->qid);
  if (!$queue) {
    return $output;
  }

  $nodes = nodequeue_publish_node_api_autocomplete_alter($queue, $subqueue, $string);
  return $nodes;
}

/**
 * Fetch a list of nodes available to a given subqueue for autocomplete.
 *
 * @param $queue
 *   The queue that owns the subqueue
 * @param $subqueue
 *   The subqueue
 * @param $string
 *   The string being matched.
 *
 * @return array
 *   An keyed array $nid => $title
 */
function nodequeue_publish_node_api_autocomplete_alter($queue, $subqueue, $string) {
  $matches = array();
  if (empty($string)) {
    return $matches;
  }

  $query = db_select('node', 'n')
      ->addTag('node_access')
      ->condition('n.status', '1')
      ->fields('n', array('nid', 'tnid', 'title'))
      ->range(0, variable_get('nodequeue_autocomplete_limit', 10));

  if (!empty($queue->types)) {
    $query->condition('n.type', $queue->types, 'IN');
  }

  $where_args = array();
  global $user;
  if (!user_access('administer nodes', $user)) {
    $query->condition(db_or()->condition('n.status', 1)->condition('n.uid', $user->uid));
  }

  // Run a match to see if they're specifying by nid.
  $preg_matches = array();
  $match = preg_match('/\[nid: (\d+)\]/', $string, $preg_matches);
  if (!$match) {
    $match = preg_match('/^nid: (\d+)/', $string, $preg_matches);
  }

  if ($match) {
    // If it found a nid via specification, reduce our resultset to just that nid.
    $query->condition('n.nid', $preg_matches[1]);
  }
  else {
    // Build the constant parts of the query.
    $query->where('LOWER(n.title) LIKE LOWER(:string)', array(':string' => '%' . db_like($string) . '%'));
  }

  // Call to the API.
  $function = $queue->owner . "_nodequeue_autocomplete";
  if (function_exists($function)) {
    return $function($queue, $subqueue, $string, $where, $where_args);
  }
  else {
    $query->addTag('i18n_select');
    $result = $query->execute();

    foreach ($result as $node) {
      $id = nodequeue_get_content_id($queue, $node);
      $matches[$node->nid] = check_plain($node->title) . " [nid: $id]";
    }
  }

  return $matches;
}
