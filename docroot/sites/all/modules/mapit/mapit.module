<?php
/**
 * @file
 * Module for Extending the taxonomy fields so as to get location information
 * from the mapit website.
 */

/**
 * Implements hook_menu().
 */
function mapit_menu() {

  $items['admin/config/mapit'] = array(
    'title' => 'Mapit settings',
    'description' => 'Description of your Mapit settings page',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mapit_admin_settings_form'),
    'access arguments' => array('administer mapit settings'),
    'type' => MENU_NORMAL_ITEM,
  );

  $items['admin/config/mapit/test1'] = array(
    'title' => 'Number of items in queue',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('mapit_test_form'),
    'access arguments' => array('administer mapit settings'),
    'description' => 'Change size of items queued',
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/config/mapit/test2'] = array(
    'title' => '#2',
    'description' => 'For Test Purposes.',
    'page callback' => 'mapit_test',
    'access callback' => TRUE,
    'type' => MENU_NORMAL_ITEM,
  );
  return $items;
}


/**
 * Implements hook_permission().
 */
function mapit_permission() {
  return array(
    'administer mapit settings' => array(
      'title' => t('Administer mapit settings'),
      'description' => t('Administer mapit settings.'),
    ),
  );
}


/**
 * Implements hook_form().
 */
function mapit_test_form($form, &$form_state) {

  $form['description'] = array(
    '#type' => 'item',
    '#title' => t('A form with nothing but a textfield'),
  );
  // This is the first form element. It's a textfield with a label, "Name"
  $form['lon'] = array(
    '#type' => 'textfield',
    '#title' => t('Longititude'),
    '#default_value' => 10,
  );
  $form['lat'] = array(
    '#type' => 'textfield',
    '#title' => t('Latitude'),
    '#default_value' => 50,
  );
  if (isset($form_state['values']['terms'])) {
    $form['terms'] = array(
      '#type' => 'textfield',
      '#enabled' => FALSE,
      '#value' => flatten($form_state['values']['terms']),
      '#title' => t('Latitude'),
    );
  }

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Submit',
  );

  return $form;
}

/**
 * Implements hook_form_submit().
 */
function mapit_test_form_submit($form, &$form_state) {
  drupal_set_message(t('Thanx') . variable_get('mapit_vocabulary'));

  $lat = $form_state['values']['lat'];
  $lon = $form_state['values']['lon'];

  $term = mapit_point_taxonomy_term($lat, $lon);
}

/**
 * Implements hook_form_validate().
 */
function mapit_admin_settings_form_validate($form, &$form_state) {

  // Test if a field has been selected twice.
  $fields = array(
    'mapit_osm_id',
    'mapit_osm_rel',
    'mapit_geofield',
    'mapit_osm_type',
    'mapit_flag',
    'mapit_wikipedia',
    'mapit_longname',
  );

  for ($i = 0; $i < count($fields); $i++) {
    $freq = 0;
    $field_id = $form_state['values'][$fields[$i]];
    for ($j = 0; $j < count($fields); $j++) {
      if ($field_id == $form_state['values'][$fields[$j]]) {
        $freq++;
      }
    }

    if ($freq > 1) {
      form_set_error($fields[$i], t('%label : Field cant be selected more than once.',
          array(
            '%label' => $form[$fields[$i]]['#title'],
          )
      ));
    }
  }
}

/**
 * Implements hook_settings_form().
 */
function mapit_admin_settings_form($form, &$form_state) {

  $options_taxonomy = _mapit_taxonomy_get_list();
  $field_disabled = FALSE;
  $selected = isset($form_state['values']['mapit_vocabulary']) ? $form_state['values']['mapit_vocabulary'] : variable_get('mapit_vocabulary', 0);

  if ($selected != 0) {
    $vocabulary = current(taxonomy_vocabulary_load_multiple(array($selected), array()));
    $term_count = taxonomy_get_tree($vocabulary->vid);
    if (!empty($term_count)) {
      $field_disabled = TRUE;
    }
    $text_options = _mapit_entity_get_fields_list('taxonomy_term', $vocabulary->machine_name, 'text');
    $geofield_options = _mapit_entity_get_fields_list('taxonomy_term', $vocabulary->machine_name, 'geofield');
    $link_options = _mapit_entity_get_fields_list('taxonomy_term', $vocabulary->machine_name, 'link');
  }
  else {
    $text_options = array();
    $geofield_options = array();
    $link_options = array();
    
  }
  $form['mapit_max_queue_size'] = array(
  		'#type' => 'textfield',
  		'#title' => t('Maximum Queue size'),
  		'#default_value' => 20,
  );
  $form['mapit_vocabulary'] = array(
    '#title' => t('Vocabularies'),
    '#description' => t('Services specific to the selected country will be installed if they exist.'),
    '#options' => $options_taxonomy,
    '#type' => 'select',
    '#default_value' => variable_get('mapit_vocabulary'),
    '#disabled' => $field_disabled,
    // This field is not required when installing through drush.
    '#required' => TRUE,
    '#ajax' => array(
      'callback' => 'mapit_dependent_fields_dropdown_callback',
      'wrapper' => 'osm_id_wrapper',
    ),
  );
  $form['mapit_osm_id'] = array(
    '#type' => 'select',
    '#prefix' => '<div id="osm_id_wrapper" >',
    '#title' => t('OSM id'),
    '#description' => t("OSM ID"),
    '#options' => $text_options,
    '#default_value' => variable_get('mapit_osm_id'),
    '#required' => TRUE,
    '#disabled' => $field_disabled,
  );

  $form['mapit_osm_rel'] = array(
    '#type' => 'select',
    '#title' => t('OSM relation id'),
    '#description' => t("OSM relation"),
    '#options' => $text_options,
    '#default_value' => variable_get('mapit_osm_rel'),
    '#required' => TRUE,
    '#disabled' => $field_disabled,
  );
  $form['mapit_geofield'] = array(
    '#type' => 'select',
    '#title' => t('Geofield'),
    '#description' => t("Geofield"),
    '#options' => $geofield_options,
    '#default_value' => variable_get('mapit_geofield'),
    '#required' => TRUE,
    '#disabled' => $field_disabled,
  );
  $form['mapit_osm_type'] = array(
    '#type' => 'select',
    '#title' => t('OSM Type'),
    '#description' => t("OSM Type"),
    '#options' => $text_options,
    '#default_value' => variable_get('mapit_osm_type'),
    '#required' => TRUE,
    '#disabled' => $field_disabled,
  );
  $form['mapit_flag'] = array(
    '#type' => 'select',
    '#title' => t('Country Flag'),
    '#description' => t("Country flag"),
    '#options' => $text_options,
    '#default_value' => variable_get('mapit_flag'),
    '#required' => FALSE,
    '#disabled' => $field_disabled,
  );
  $form['mapit_wikipedia'] = array(
    '#type' => 'select',
    '#title' => t('Wikipedia Link'),
    '#description' => t("Wikipedia Link"),
    '#options' => $link_options,
    '#default_value' => variable_get('mapit_wikipedia'),
    '#required' => FALSE,
    '#disabled' => $field_disabled,
  );
  $form['mapit_longname'] = array(
    '#type' => 'select',
    '#title' => t('Longname of the location'),

    '#description' => t("The full name of the locations. This will be in the language the site is in."),
    '#options' => $text_options,
    '#default_value' => variable_get('mapit_longname'),
    '#required' => FALSE,
    '#disabled' => $field_disabled,
  );
  $form['mapit_discard_ids'] = array(
    '#type' => 'textarea',
    '#title' => t('Location IDs to dicard'),
    '#description' => t("The IDs that should be discarded. The discard ids have to be separated with commas e.g. xxx1, xxx2, xxx3"),
    '#default_value' => variable_get('mapit_discard_ids', 0),
    '#required' => FALSE,
    '#disabled' => $field_disabled,
  );

  $form['mapit_discard_types'] = array(
    '#type' => 'textarea',
    '#suffix' => '</div>',
    '#title' => t('Types to discard'),
    '#description' => t("The administrave levels that should be discarded. The discard type have to be entered separated with commas e.g. O02, O03"),
    '#default_value' => variable_get('mapit_discard_types', 'OLC'),
    '#required' => FALSE,
    '#disabled' => $field_disabled,
  );

//   $form['mapit_discard_types'] = array(
//   		'#type' => 'textarea',
//   		'#suffix' => '</div>',
//   		'#title' => t('Types to discard'),
//   		'#description' => t("The administrave levels that should be discarded. The discard type have to be entered separated with commas e.g. O02, O03"),
//   		'#default_value' => variable_get('mapit_discard_types', 'OLC'),
//   		'#required' => FALSE,
//   		'#disabled' => $field_disabled,
//   );  
  
  // Pass the form array through system_settings_form().
  return system_settings_form($form);
}

/**
 * Dropdown callback.
 *
 * @param array $form
 *   Current Form
 * @param array $form_state
 *   Form state
 *
 * @return array
 *   Array form fields to refresh.
 */
function mapit_dependent_fields_dropdown_callback($form, $form_state) {
  $fields = array(
    $form['mapit_osm_id'],
    $form['mapit_osm_rel'],
    $form['mapit_osm_type'],
    $form['mapit_geofield'],
    $form['mapit_wikipedia'],
    $form['mapit_longname'],
    $form['mapit_flag'],
    $form['mapit_discard_ids'],
    $form['mapit_discard_types'],
  );
  return $fields;
}

/**
 * Implements hook_cron_queue_info().
 */
function mapit_cron_queue_info() {
  return array(
    'mapit_tagentity' => array(
      'worker callback' => 'mapit_tagentity',
      'time' => 20,
    ),
  );
}

/**
 * Tagging entities with new taxonomy values.
 *
 * @param array $item
 *   Item from job queue
 */
function mapit_tagentity($item) {
  $langcode = 'und';

  $term = mapit_point_taxonomy_term($item['lat'], $item['lon']);
  watchdog('mapit', "lat/lon(" . $item['lat'] . ' ' . $item['lon'] . ") Enity: " . $item['entity_id'] . "tid :" . $term->tid);

  if ($term) {

    $entity = entity_load($item['entity_type'], array($item['entity_id']));
    $entity = current($entity);

    $entity->{$item['field_name']}[$langcode][0]['tid'] = $term->tid;
    $entity->mapitsave = true;
    entity_save($item['entity_type'], $entity);
    

  }
  else {
    watchdog('mapit', "No address for " . $item['lat'] . ' ' . $item['lon'] . " Enity: " . $item['entity_id']);
  }

}

/**
 * Implements hook_cron().
 */
function mapit_cron() {
	
	$queue = DrupalQueue::get('mapit_tagentity');
	$queue_size = $queue->numberOfItems();
	
	if($queue_size < 1) {
		mapit_find_mapit_fields();
	}
}


/**
 * Get fields in a taxonomy.
 *
 * @param int $vid
 *   Vocabulary ID
 * @param string $datatype
 *   Field Data type
 */
function _mapit_taxonomy_get_fields_list($vid, $datatype = '') {

  $vocabulary = taxonomy_vocabulary_load_multiple(array($vid), array());
  $fields = field_info_instances('taxonomy_term', $vocabulary[$vid]->machine_name);
  $return = array();

  foreach ($fields as $field) {
    if ($field['widget']['module'] == $datatype) {
      $return[$field['field_id']] = $field['label'];
    }
  }

  return $return;
}

/**
 * Get all fields that have a mapit widget.
 *
 * @param string $entity_type
 *   Entity type
 * @param string $bundle_name
 *   Bundle name
 * @param string $datatype
 *   Field Data type
 */
function _mapit_entity_get_fields_list($entity_type, $bundle_name, $datatype = NULL) {

  $fields = field_info_instances($entity_type, $bundle_name);
  $return = array();
  foreach ($fields as $field) {
    if ($datatype == NULL || $field['widget']['module'] == $datatype) {
      $return[$field['field_id']] = $field['label'];
    }
  }

  return $return;
}



/**
 * Get list of all taxonomy vocabularies for select list.
 *
 * @return array
 *   Array of all vocabularies. 
 */
function _mapit_taxonomy_get_list() {

  $taxonomies = taxonomy_get_vocabularies();
  $return = array();

  foreach ($taxonomies as $taxonomy) {

    $return[$taxonomy->vid] = $taxonomy->name;
  }

  return $return;
}

/**
 * Get a point(lat,lon) and return the address tree.
 *
 * @param float $lat
 *   Latitude value
 * @param float $lon
 *   Longititude value
 * @param int $projection
 *   Projection value
 *
 * @return array
 *   Location heirachy  
 */
function mapit_point_address_tree($lat, $lon, $projection = 4326) {
  $url = "http://global.mapit.mysociety.org/point/$projection/$lon,$lat.json";
  watchdog('mapit', 'url' . $url );
  $options = array(
    'headers' => array('Content-Type' => 'text/json; charset=UTF-8'),
  );
  $json = drupal_http_request($url, $options);

  if ($json->code != 200) {
    return 0;
  }

  $tree = drupal_json_decode($json->data);
  uasort($tree, "_mapit_array_cmp");
  return $tree;
}

/**
 * Get the term from the lat/lon values.
 *
 * @param int $lat
 *   Latitude value
 * @param int $lon
 *   Longititude value
 *
 * @return object
 *   Taxonomy term
 */
function mapit_point_taxonomy_term($lat, $lon, $projection = 4326) {

  $vid = variable_get('mapit_vocabulary');
  $langcode = LANGUAGE_NONE;

  $vocabulary = current(taxonomy_vocabulary_load_multiple(array($vid), array()));
  if (!$vocabulary) {
    return FALSE;
  }
  //get field api fields from the settings variables
  $geofield_field = field_info_field_by_id(variable_get('mapit_geofield', "0"));
  $osm_type_field = field_info_field_by_id(variable_get('mapit_osm_type', "0"));
  $osm_id_field = field_info_field_by_id(variable_get('mapit_osm_id', "0"));
  $osm_rel_field = field_info_field_by_id(variable_get('mapit_osm_rel', "0"));
  $osm_type_field = field_info_field_by_id(variable_get('mapit_osm_type', "0"));
  $osm_flag_field = field_info_field_by_id(variable_get('mapit_flag', "0"));
  $osm_wiki_field = field_info_field_by_id(variable_get('mapit_wikipedia', "0"));
  $osm_long_field = field_info_field_by_id(variable_get('mapit_longname', "0"));

  $osm_discard_ids = array_map('_mapit_string_to_integer', explode(',', variable_get('mapit_discard_ids', "0")));

  $osm_discard_types = array_map('trim', explode(',', variable_get('mapit_discard_types', "0")));

  $tree = mapit_point_address_tree($lat, $lon, $projection);
  watchdog('mapit','tree : ' . print_r(array_keys($tree),true));
  // If Location doesn't exist.
  if (is_array($tree) && empty($tree)) {
    $terms = taxonomy_get_term_by_name('Unknown Area', $vocabulary->machine_name);
    if (!$terms) {
      $term = new stdClass();
      $term->name = 'Unknown Area';
      $term->description = "No matching areas found for coordinates supplied.";
      $term->vid = $vocabulary->vid;
      taxonomy_term_save($term);
    }
    else {
      $term = array_shift($terms);
    }
    return $term;
  }
  elseif (!$tree) {
    return FALSE;
  }

  $parentterm = NULL;
  foreach ($tree as $treenode) {
    // Remove values that have to be discarded.
    if (in_array($treenode['type'], $osm_discard_types) || in_array(intval($treenode['id']), $osm_discard_ids)) {
      continue;
    }

    $term = FALSE;

    $metadata = array();
    $terms = taxonomy_get_term_by_name($treenode['name'], $vocabulary->machine_name);

    $query = new EntityFieldQuery();
    // ->addTag('efq_mapit_debug')
    $query->entityCondition('entity_type', 'taxonomy_term')->entityCondition('bundle', $vocabulary->machine_name)
    ->fieldCondition($osm_id_field['field_name'], 'value', $treenode['id'], '=');

    $result = $query->execute();

    $parent_osm_type = isset($parentterm) ? $parentterm[0]->{$osm_type_field['field_name']}[$langcode][0]['value'] : 0;
    $term_osm_type = $treenode['type'];

    if ($result) {
      $termobj = array_shift($result['taxonomy_term']);
      $term = taxonomy_term_load($termobj->tid);
    }
    else {
      $term = new stdClass();
      $term->vid = $vocabulary->vid;
      $term->name = $treenode['name'];

      if (isset($treenode['codes']['osm_rel'])) {
        $term->{$osm_rel_field['field_name']}[$langcode][0]['value'] = $treenode['codes']['osm_rel'];
        $metadata = mapit_get_metadata($treenode['codes']['osm_rel']);

        if (!empty($metadata)) {
          $term->name = $metadata['name'];
          $term->{$osm_flag_field['field_name']}[$langcode][0]['value'] = $metadata['flag'];
          $term->{$osm_long_field['field_name']}[$langcode][0]['value'] = $metadata['longname'];

          // Not that en has been used up to when and if the site becomes
          // fully multi lingual.
          $lang_wiki = explode(":",$metadata['wiki']);
          $lcode = count($lang_wiki) > 1 ? $lang_wiki[0] ."." : "";
          $term->{$osm_wiki_field['field_name']}[$langcode][0] = array(
            'title' => $metadata['name'],    		 
            'url' => "http://" . $lcode . "wikipedia.org/wiki/" . $metadata['wiki'],
          );
        }
      }

      if (isset($parentterm)) {
        if ($parent_osm_type != $term_osm_type) {
          $parentvalues = array();
          foreach ($parentterm as $parentitem) {
            $parentvalues[] = $parentitem->tid;
          }
          $term->parent = $parentvalues;
        }
        else {
          $term->parent = $parentterm[0]->parent;
        }
      }

      $term->{$geofield_field['field_name']}[$langcode][0]['geom'] = mapit_get_wkt_by_osmid($treenode['id']);

      $term->{$osm_id_field['field_name']}[$langcode][0]['value'] = $treenode['id'];
      if (isset($treenode['codes']['osm_rel'])) {
        $term->{$osm_rel_field['field_name']}[$langcode][0]['value'] = $treenode['codes']['osm_rel'];
      }
      $term->{$osm_type_field['field_name']}[$langcode][0]['value'] = $treenode['type'];
      taxonomy_term_save($term);
    }

    if ($parent_osm_type != $term_osm_type) {
      $parentterm = array();
      $parentterm[] = $term;
    }
    else {
      $parentterm[] = $term;
    }
  }

  return $term;
}

/**
 * Get load the wkt of a particular id.
 *
 * @param int $id
 *   Relation id
 *
 * @return string
 *   WKT string boundaries for a location
 */
function mapit_get_wkt_by_osmid($id) {

  $url = "http://global.mapit.mysociety.org/area/$id.wkt";

  $options = $options = array(
    'headers' => array('Content-Type' => 'text/plain; charset=UTF-8'),
  );
  $json = drupal_http_request($url, $options);
  // Used a trick to uncompress the always compressed return value
  // http://www.php.net/manual/en/function.gzuncompress.php#Vu101643
  // This is a bug in the mapitverver configuration.
  if ($json->code != '200') {
    return FALSE;
  }

  if (isset($json->headers['content-encoding']) && $json->headers['content-encoding'] == 'gzip') {
    $comp = file_get_contents('compress.zlib://data:who/cares;base64,' . base64_encode($json->data));
  }
  else {
    $comp = $json->data;
  }
  return $comp;
}

/**
 * Get svg from url.
 *
 * @param string $url
 *   Url for country flag
 *
 * @return string
 *   SVG string
 */
function mapit_get_map_svg($url) {

  $options = $options = array(
    'headers' => array('Content-Type' => 'text/xml'),
  );
  $json = drupal_http_request($url, $options);
  if ($json->code != '200') {
    return FALSE;
  }

  if (isset($json->headers['content-encoding']) && $json->headers['content-encoding'] == 'gzip') {
    $comp = file_get_contents('compress.zlib://data:who/cares;base64,' . base64_encode($json->data));
  }
  else {
    $comp = $json->data;
  }

  return $comp;
}

/**
 * Implements hook_field_widget_info().
 */
function mapit_field_widget_info() {
  return array(
    'mapit' => array(
      'label' => t('Mapit Autofill'),
      'field types' => array('taxonomy_term_reference'),
      'settings' => array(
        'size' => 60,
      ),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_DEFAULT,
      ),
    ),
  );
}

/**
 * Get dummy term un case term is undefined.
 *
 * @param string $vocabulary_name
 *   Vocabulary name
 *
 * @return int
 *   tid of 'Undefined term'
 */
function mapit_get_undefined_area_tid($vocabulary_name) {
  $vocabulary = taxonomy_vocabulary_machine_name_load($vocabulary_name);
  $terms = taxonomy_get_term_by_name('Undefined Area', $vocabulary->machine_name);
  if (!$terms) {
    $term = new stdClass();
    $term->name = 'Undefined Area';
    $term->description = "Waiting for a value from the Mapit widget.";
    $term->vid = $vocabulary->vid;
    taxonomy_term_save($term);
  }
  else {
    $term = array_shift($terms);
  }

  return $term->tid;
}

/**
 * Implements hook_field_widget_form().
 */
function mapit_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  switch ($instance['widget']['type']) {
    case 'mapit':
      // Copy what options_select widget does to get the select values
      // for our dropdown (see options module).
      $value_key = key($field['columns']);
      $multiple = $field['cardinality'] > 1 || $field['cardinality'] == FIELD_CARDINALITY_UNLIMITED;
      $has_value = isset($items[0][$value_key]);
      $properties = _options_properties('mapit', $multiple, $element['#required'], $has_value);

      $entity_type = $element['#entity_type'];
      $entity = $element['#entity'];

      $default_tid = mapit_get_undefined_area_tid($field['settings']['allowed_values'][0]['vocabulary']);
      
      
      
      // Prepare the list of options.
      $options = _options_get_options($field, $instance, $properties, $entity_type, $entity);
      $default_values = _options_storage_to_form($items, $options, $value_key, $properties);

      
      if (isset($default_values[$delta])){
        $default_tid = $default_values[$delta];
      }
      
      $widget = $element + array(
        '#type' => 'select',
        // Add a 0 option to the options array so that values can be unselected.
        '#options' => array(0 => '--select--') + $options,
        '#default_value' => $default_tid,
        '#disabled' => TRUE,
        '#attributes' => array('class' => array('mapit')),
      );

      $element['tid'] = $widget;
      break;
  }
  return $element;
}

/**
 * Implements hook_field_widget_settings_form().
 */
function mapit_field_widget_settings_form($field, $instance) {
  $form['mapit_setting_geofield'] = array(
    '#type' => 'select',
    '#title' => t('Geofield Field'),
    '#description' => t("Geofield field that will be attached with the mapit field"),
    '#options' => _mapit_entity_get_fields_list($instance['entity_type'], $instance['bundle']),
    '#required' => TRUE,
  );
  return $form;
}
/**
 * Implements hook_query_alter().
 */
function mapit_query_alter($query) {
  if ($query->hasTag('efq_mapit_debug')) {
    //dpm((string) $query);
    //watchdog("mapit",(string) $query);
  }
}

/**
 * Get all fields that have have a mapit widget.
 * @return string
 *   An fields with a mapit widget
 */
function mapit_find_mapit_fields() {

  $langcode = LANGUAGE_NONE;
  $mapit_fields = mapit_valid_mapit_fields();
  $queue = DrupalQueue::get('mapit_tagentity');
  $projection = '4326';
  $job = array();
  $max_queue_size = variable_get('mapit_max_queue_size',20);
  $itemcount = 0;

  foreach ($mapit_fields as $field) {
    $field_name = $field['field_name'];
    $entity_type = $field['entity_type'];
    $geofield_id = $field['widget']['settings']['mapit_setting_geofield'];
    $field_info = field_info_field_by_id($field['field_id']);

    $ids = array();
    $default_tid = mapit_get_undefined_area_tid($field_info['settings']['allowed_values'][0]['vocabulary']);

    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', $entity_type)
          ->entityCondition('bundle', $field['bundle'])
          //->addTag('efq_mapit_debug')
          ->fieldCondition($field_name, 'tid', $default_tid, '=');

    $result = $query->execute();
    if ($result) {
      $geofield = field_info_field_by_id($geofield_id);
      $ids = array_keys($result[$entity_type]);
      $entities = entity_load($entity_type, $ids);

      foreach ($entities as $entitykey => $entity) {
        $langcode = entity_language($entity_type, $entity) ? entity_language($entity_type, $entity) : 'und';
        if (!empty($entity->{$geofield['field_name']})) {
          $data = $entity->{$geofield['field_name']};

          $job = array(
            'lat' => $data[$langcode][0]['lat'],
            'lon' => $data[$langcode][0]['lon'],
            'projection' => $projection,
            'entity_id' => $entitykey,
            'entity_type' => $entity_type,
            'field_name' => $field_name,
          );
          $queue->createItem($job);
          
          //bail out if the max_queue_size has been exceeded
          if($max_queue_size < $itemcount++) {
          	return;
          }
        }
      }
    }
  }
  return '';
}

/**
 * Get all mapit fields in all entities.
 * 
 * @return array
 *   All field instances will widget mapit
 */
function mapit_valid_mapit_fields() {
  node_load();
  $nodes = field_info_instances();
  $mapit_fields = array();
  foreach ($nodes as $node) {
    foreach ($node as $bundle) {
      foreach ($bundle as $fieldkey => $field) {
        if ($field['widget']['module'] == 'mapit' && !empty($field['widget']['settings']['mapit_setting_geofield'])) {
          $mapit_fields[$fieldkey] = $field;
        }
      }
    }
  }
  return ($mapit_fields);
}

/**
 * Get taxonomy id of a particular term.
 *
 * @param int $vid
 *   Vocabulary id
 * @param string $term_name
 *   Taxonomy term
 *
 * @return array
 *   Taxonomy term id
 */
function _mapit_taxonomy_id_default_term($vid, $term_name) {
  $vocabulary = current(taxonomy_vocabulary_load_multiple(array($vid), array()));
  $langcode = $GLOBALS['language_content']->language;
  $terms = taxonomy_get_term_by_name($term_name, $vocabulary->machine_name);
  if ($terms) {
    $term = current($terms);
    return $term->tid;
  }
  else {
    $term = new stdClass();
    $term->name = $term_name;
    $term->vid = $vocabulary->vid;
    taxonomy_term_save($term);
    return $term->tid;
  }
}

/**
 * Get Location Metadata.
 *
 * @param int $rel
 *   OSM relation
 *
 * @return mixed
 *   Return location metadata
 */
function mapit_get_metadata($rel) {
  global $language_content;
  $langcode = $language_content->language;

  $url = "http://www.openstreetmap.org/api/0.6/relation/$rel";

  $options = $options = array(
    'headers' => array('Content-Type' => 'text/xml; charset=UTF-8'),
  );
  $json = drupal_http_request($url, $options);
  if ($json->code != 200) {
    return FALSE;
  }
  // Used a trick to uncompress the always compressed return value
  // http://www.php.net/manual/en/function.gzuncompress.php#Vu101643
  // This is a bug in the mapitverver configuration.
  if ($json->headers['content-encoding'] == 'gzip') {
    $comp = file_get_contents('compress.zlib://data:who/cares;base64,' . base64_encode($json->data));
  }
  else {
    $comp = $json->data;
  }
  $comp = new SimpleXMLElement($comp);

  $metadata = array();
  $flag = "";
  $name = "";
  $wiki = "";
  $longname = "";

  $xml = $comp->xpath('/osm/relation/tag[@k="flag"]');
  if (!empty($xml[0])) {
    $flag_url = (string) $xml[0]['v'];
    $flag = mapit_get_map_svg($flag_url);
  }

  $xml = $comp->xpath('/osm/relation/tag[@k="name:' . $langcode . '"]');
  if (!empty($xml[0])) {
    $name = (string) $xml[0]['v'];
  }
  else {
    $xml = $comp->xpath('/osm/relation/tag[@k="name"]');
    if (!empty($xml[0])) {
      $name = (string) $xml[0]['v'];
    }
  }

  $xml = $comp->xpath('/osm/relation/tag[@k="long_name:' . $langcode . '"]');
  if (!empty($xml[0])) {
    $longname = (string) $xml[0]['v'];
  }
  else {
    $xml = $comp->xpath('/osm/relation/tag[@k="long_name"]');
    if (!empty($xml[0])) {
      $longname = (string) $xml[0]['v'];
    }
  }

  $xml = $comp->xpath('/osm/relation/tag[@k="wikipedia"]');
  if (!empty($xml[0])) {
    $wiki = (string) $xml[0]['v'];
  }
  else {
  	$xml = $comp->xpath('/osm/relation/tag[contains(@k, "wikipedia")]');
  	if (!empty($xml[0])) {
  		$wiki = (string) $xml[0]['v'];
  	}
  }

  $metadata = array(
    'flag' => $flag,
    'name' => $name,
    'longname' => $longname,
    'wiki' => $wiki,
  );

  return $metadata;
}

function mapit_test() {
  mapit_point_taxonomy_term(0.2321, 30.2224);
}

function mapit_entity_presave($entity, $type) {
	//Check whether a mapit field exists in this entity.
	if(!isset($entity->type)) {
		return ;
	}
	
	if (isset($entity->mapitsave) && $entity->mapitsave) {
		watchdog('mapit','S');
		return ;
	}
	
	$fields = field_info_instances($type, $entity->type);
	//Go through all the fields in an entity.
	foreach($fields as $fieldkey => $field) {
		//Check whether one of the fields has a mapit widget.		
		if(isset($field['widget']['module']) && $field['widget']['module']=='mapit') {
			
			$entity_info = entity_get_info($type);
			$entity_key = $entity_info['entity keys']['id'];
			
			$field_info = field_info_field_by_id($field['field_id']);
			$vocabulary_name = $field_info['settings']['allowed_values'][0]['vocabulary'];
			$entity->{$field['field_name']}['und'][0]['tid'] = mapit_get_undefined_area_tid($vocabulary_name) ;
		}
	}
}

function _mapit_string_to_integer($idstr) {
	$tempstr = trim($idstr);
	if(is_numeric($tempstr)) {
		$id = (int) $tempstr;
	}
	else {
		$id = 0;
	}
	
	return $id;
}

/**
 * To sort arrays to respect the tree of admin boundaries.
 */
function _mapit_array_cmp($a, $b) {
  return strcmp($a["type"], $b["type"]);
}
