<?php

/**
 * @file
 * Vocabulary Queue.
 *
 * Vocabulary Queue creates a nodequeue for a defined set of vocabularies and
 * creates subqueues for each taxonomy term from the selected vocabularies have
 * their own unique subqueue.  You can place nodes into any of these subqueues.
 *
 * Vocabulary Queue is build using Nodequeue modules Smartqueue API and the
 * implementation based on smartqueue.module (part of Nodequeue module).
 *
 * Vocabulary Queue is similar in functionality to smartqueue.module and the
 * code based on code from smartqueue.module.
 *
 * They differ in that you can add nodes to any subqueue associated with the
 * vocabulary and not just the subqueues matching the taxonomy terms of the
 * node.
 *
 * Vocabulary Queue also creates subqueues when creating taxonomy terms and not
 * like smartqueue.module when trying to use the subqueue.
 *
 * @see smartqueue.module
 */

define('VOCABULARY_QUEUE_DATE_LIMIT', 86400 * 30);
define('VOCABULARY_QUEUE_INTERNAL_SUBQUEUE_TITLE', '[term:parents-all:join: > ]');

/**
 * Implements hook_menu().
 *
 * Add menu items for configuration and template callback.
 */
function vocabulary_queue_menu() {
  $items = array();

  $items['vocabulary_queue/vocabulary_queue_subnodequeue_autocomplete'] = array(
    'page callback' => 'vocabulary_queue_subnodequeue_autocomplete',
    'type' => MENU_CALLBACK,
    'access arguments' => array('manipulate queues'),
  );

  $items['admin/structure/taxonomy/%/vocabulary_queue'] = array(
    'title' => 'Vocabulary queues',
    'page callback' => 'vocabulary_queue_taxonomy_vocabulary_queues',
    'page arguments' => array(3),
    'access callback' => 'vocabulary_queue_vocabulary_has_queues',
    'access arguments' => array(3),
    'file' => 'vocabulary_queue.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  $items['taxonomy/term/%taxonomy_term/vocabulary_queue'] = array(
    'title' => 'Vocabulary queues',
    'page callback' => 'vocabulary_queue_taxonomy_term_queues',
    'page arguments' => array(2),
    'access callback' => 'vocabulary_queue_term_has_queues',
    'access arguments' => array(2),
    'file' => 'vocabulary_queue.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Implements hook_admin_paths().
 */
function vocabulary_queue_admin_paths() {
  $paths = array(
    'taxonomy/term/*/vocabulary_queue' => TRUE,
    'admin/structure/taxonomy/*/vocabulary_queue' => TRUE,
  );

  return $paths;
}

/**
 * Access handler for vocabulary queues tab.
 *
 * @param string $machine_name
 *   The vocabulary machine name.
 */
function vocabulary_queue_vocabulary_has_queues($machine_name) {
  $queues = vocabulary_queue_get_vocabulary_queues($machine_name);
  if ($queues) {
    foreach ($queues as $queue) {
      if (nodequeue_queue_access($queue)) {
        return TRUE;
      }
    }
  }
  return FALSE;
}

/**
 * Access handler for vocabulary queues tab.
 *
 * @param object $term
 *   The term.
 */
function vocabulary_queue_term_has_queues($term) {
  return $term ? vocabulary_queue_vocabulary_has_queues($term->vocabulary_machine_name) : FALSE;
}

/**
 * Load a vocabulary queue.
 *
 * @param int $qid
 *   The nodequeue id.
 */
function vocabulary_queue_load($qid) {
  return db_select('vocabulary_queue', 'q')
    ->fields('q')
    ->condition('q.qid', $qid)
    ->execute()
    ->fetchObject();
}

/**
 * Save a vocabulary queue.
 *
 * @param object $queue
 *   The nodequeue object.
 */
function vocabulary_queue_save($queue) {
  $queue->internal_subqueue_title = isset($queue->internal_subqueue_title) ? $queue->internal_subqueue_title : VOCABULARY_QUEUE_INTERNAL_SUBQUEUE_TITLE;
  $queue->date_limit = isset($queue->date_limit) ? $queue->date_limit : VOCABULARY_QUEUE_DATE_LIMIT;
  db_merge('vocabulary_queue')
    ->key(array('qid' => $queue->qid))
    ->fields(array(
      'internal_subqueue_title' => $queue->internal_subqueue_title,
      'date_limit' => $queue->date_limit,
    ))
    ->execute();

  vocabulary_queue_create_subqueues($queue);
}

/**
 * Implements hook_nodequeue_alter().
 */
function vocabulary_queue_nodequeue_alter(&$loaded, $context) {
  if ($context == 'load_queues') {
    foreach ($loaded as $queue) {
      if ($vocabulary_queue = vocabulary_queue_load($queue->qid)) {
        $queue->internal_subqueue_title = $vocabulary_queue->internal_subqueue_title;
        $queue->date_limit = $vocabulary_queue->date_limit;
      }
    }

    // If we don't reset the internal pointer for $loaded, then fe_nodequeue
    // cannot export the nodequeue, due to its use of current() instead of
    // reset().
    reset($loaded);
  }
}
/**
 * Implements hook_ctools_plugin_directory().
 */
function vocabulary_queue_ctools_plugin_directory($owner, $plugin_type) {
  return "plugins/$owner/$plugin_type";
}

/**
 * Implements hook_nodequeue_info().
 */
function vocabulary_queue_nodequeue_info() {
  return array(
    'vocabulary_queue' => array(
      'title' => t('Vocabulary queue'),
      'description' => t('Each taxonomy term from the selected vocabularies have their own unique subqueue. You can place nodes into any of these subqueues.'),
    ));
}

/**
 * Implements hook_nodequeue_form().
 */
function vocabulary_queue_nodequeue_form($queue, &$form) {
  $form['subqueue_title'] = array(
    '#type' => 'textfield',
    '#title' => t('Subqueue title'),
    '#default_value' => $queue->subqueue_title,
    '#size' => 50,
    '#maxlength' => 64,
    '#description' => t('What to display for the subqueue title; use %subqueue to embed the actual subqueue title. This is used to distinguish multiple nodequeues with subqueues from each other, as internal subqueue title is filled automatically.'),
  );

  $form['placeholder']['internal_subqueue_title'] = array(
    '#type' => 'textfield',
    '#title' => t('Internal subqueue title'),
    '#default_value' => isset($queue->internal_subqueue_title) ? $queue->internal_subqueue_title : VOCABULARY_QUEUE_INTERNAL_SUBQUEUE_TITLE,
    '#size' => 50,
    '#maxlength' => 64,
    '#description' => t('What to display for the subqueue title; use tokens.'),
  );

  $form['placeholder']['tokens_help'] = array(
    '#theme' => 'token_tree',
    '#token_types' => array('term'),
    '#global_types' => TRUE,
    '#click_insert' => TRUE,
    '#dialog' => TRUE,
  );

  // Load data about taxonomy vocabularies.
  $options = array();
  $query = db_select('taxonomy_term_data', 'ttd');
  $query->addExpression('COUNT(tid)', 'size');
  $vocabulary_sizes = $query
    ->fields('ttd', array('vid'))
    ->groupBy('vid')
    ->execute()
    ->fetchAllKeyed();

  foreach (taxonomy_get_vocabularies() as $vocabulary) {
    $option_name = t($vocabulary->name);
    if (!empty($vocabulary_sizes[$vocabulary->vid]) && $vocabulary_sizes[$vocabulary->vid] > variable_get('vocabulary_queue_large_threshold', 1000)) {
      $option_name = t('!vocab (!number terms)  <em>WARNING: Do not create vocabulary queues for large vocabularies. Performance will suffer.</em>', array('!vocab' => $option_name, '!number' => $vocabulary_sizes[$vocabulary->vid]));
    }
    $options[$vocabulary->machine_name] = $option_name;
  }

  $form['placeholder']['vocabularies'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Vocabularies'),
    '#description' => t('Choose which vocabularies to use; each term from these vocabularies will have a subqueue.'),
    '#options' => $options,
  );

  $form['placeholder']['date_limit'] = array(
    '#type' => 'textfield',
    '#title' => t('Date limit'),
    '#default_value' => isset($queue->date_limit) ? $queue->date_limit : VOCABULARY_QUEUE_DATE_LIMIT,
    '#size' => 50,
    '#maxlength' => 64,
    '#description' => t('Time in seconds on which to limit the autocomplete.'),
  );

  // You can only select vocabularies when creating a new vocabulary
  // vocabulary_queue.  Disable it after that.
  if (!empty($queue->qid)) {
    $form['placeholder']['vocabularies']['#disabled'] = TRUE;
    $form['placeholder']['vocabularies']['#default_value'] = explode('-', $queue->reference);
  }
}

/**
 * Implements hook_nodequeue_form_validate().
 */
function vocabulary_queue_nodequeue_form_validate($queue, &$form_state, &$form) {
  if (!isset($queue->qid)) {
    $vocabularies = array_keys(array_filter($form_state['values']['vocabularies']));
    if (empty($vocabularies)) {
      form_error($form['placeholder']['vocabularies'], t('You must select at least one vocabulary.'));
    }

    // Convert this to our reference.
    form_set_value($form['reference'], implode('-', $vocabularies), $form_state);
  }
}


/**
 * Implements hook_nodequeue_form_submit_finish().
 */
function vocabulary_queue_nodequeue_form_submit_finish($queue, $form_state) {
  vocabulary_queue_save($queue);
}

/**
 * Implements hook_nodequeue_subqueues().
 *
 * Returns list of references for subqueues that can host a given node.
 */
function vocabulary_queue_nodequeue_subqueues(&$queue, $node) {
  return vocabulary_queue_nodequeue_subqueues_internal($queue, $node, FALSE);
}

/**
 * Implements hook_nodequeue_subqueues().
 *
 * Returns list of references for subqueues that can host a given node.
 */
function vocabulary_queue_nodequeue_subqueues_internal(&$queue, $node = NULL, $create = FALSE) {
  $terms = array();
  $term_names = array();

  // Load all terms for vocabularies related to $queue.
  foreach (explode('-', $queue->reference) as $vocabulary_machine_name) {
    $vocabulary = taxonomy_vocabulary_machine_name_load($vocabulary_machine_name);
    if ($vocabulary) {
      foreach (taxonomy_get_tree($vocabulary->vid) as $term) {
        $terms[$term->tid] = $term;
      }
    }
  }

  // Bail out if we didn't find any terms.
  if (empty($terms)) {
    return array();
  }

  if (!$create) {
    return $terms;
  }

  // We're returning an array of references for efficiency, but we also have
  // to check to see if the references we've generated exist. If they don't,
  // we have to create them.
  $exists = array();
  $subqueues = nodequeue_load_subqueues_by_queue(array($queue->qid));
  foreach ($subqueues as $subqueue) {
    $exists[$subqueue->reference] = $subqueue->sqid;
  }

  // Create subqueues if needed.
  foreach ($terms as $tid => $term) {
    $title = vocabulary_queue_taxonomy_nodequeue_subqueue_title($queue, $tid, $terms);
    if (empty($exists[$tid])) {
      nodequeue_add_subqueue($queue, $title, $tid);
    }
    else {
      nodequeue_subqueue_update_title($exists[$tid], $title, $tid);
    }
  }

  return $terms;
}

/**
 * Create missing subqueues for $queue.
 *
 * Is actually just a wrapper around
 * vocabulary_queue_nodequeue_subqueues_internal().
 *
 * @see vocabulary_queue_nodequeue_subqueues_internal()
 */
function vocabulary_queue_create_subqueues(&$queue) {
  vocabulary_queue_nodequeue_subqueues_internal($queue, NULL, TRUE);
}

/**
 * Implements hook_taxonomy_term_insert().
 *
 * Add subqueue if new term belongs to vocabularies with a vocabulary_queue.
 */
function vocabulary_queue_taxonomy_term_insert($term) {
  // Call vocabulary_queue_create_subqueues() if $term is in a vocubulary that
  // has a vocabulary_queue.
  $result = db_query("SELECT qid FROM {nodequeue_queue} WHERE reference = ?", array(
              $term->vocabulary_machine_name,
            ))->fetchCol();
  $queues = nodequeue_load_queues($result);

  foreach ($queues as $queue) {
    $title = vocabulary_queue_taxonomy_nodequeue_subqueue_title($queue, $term->tid);
    nodequeue_add_subqueue($queue, $title, $term->tid);
  }
}

/**
 * Implements hook_taxonomy_term_update().
 *
 * Updates subqueue title if term name changes.
 */
function vocabulary_queue_taxonomy_term_update($term) {
  // Change name of a subqueue if $term is in a vocubulary that has a
  // vocabulary_queue and a subqueue exists.
  // Find subqueues that contain this term.
  $query = db_select('vocabulary_queue', 'vq');
  $query->join('nodequeue_subqueue', 'sq', 'sq.qid = vq.qid');
  $query->fields('vq');
  $query->fields('sq', array('sqid'));
  $query->condition('sq.reference', $term->tid);
  $result = $query->execute();

  foreach ($result as $row) {
    $title = vocabulary_queue_taxonomy_nodequeue_subqueue_title($row, $term->tid);
    nodequeue_subqueue_update_title($row->sqid, $title);
  }
}

/**
 * Implements hook_taxonomy_term_delete().
 *
 * Deletes subqueue when deleting a term.
 */
function vocabulary_queue_taxonomy_term_delete($term) {
  // Delete subqueue if $term is in a vocubulary that has a vocabulary_queue and
  // a subqueue exists.
  $query = db_select('vocabulary_queue', 'vq');
  $query->join('nodequeue_subqueue', 'sq', 'sq.qid = vq.qid');
  $query->fields('vq');
  $query->fields('sq', array('sqid'));
  $query->condition('sq.reference', $term->tid);
  $result = $query->execute();

  foreach ($result as $row) {
    nodequeue_remove_subqueue($row->sqid);
  }
}

/**
 * Implements hook_nodequeue_delete().
 *
 * Remove data from the vocabulary_queue table.
 */
function vocabulary_queue_nodequeue_delete($qid) {
  db_delete('vocabulary_queue')
    ->condition('qid', $qid)
    ->execute();
}

/**
 * Form title for a new taxonomy subqueue.
 *
 * @param object $queue
 *   Queue object.
 * @param string $tid
 *   Subqueue reference string (term id).
 * @param array $terms
 *   (optional) Terms keyed by tid.
 */
function vocabulary_queue_taxonomy_nodequeue_subqueue_title($queue, $tid, $terms = NULL) {
  if ($term = (!empty($terms[$tid]) ? $terms[$tid] : taxonomy_term_load($tid))) {
    if (!isset($queue->internal_subqueue_title)) {
      debug_print_backtrace();
    }
    return token_replace($queue->internal_subqueue_title, array('term' => $term));
  }
  else {
    return $tid;
  }
}

/**
 * Implements hook_form_taxonomy_manager_form_alter().
 *
 * Add links to vocabulary queue on taxonomy manager term data form.
 *
 * @see taxonomy_manager.module
 */
function vocabulary_queue_form_taxonomy_manager_form_alter(&$form, &$form_state, $form_id) {
  // Bail out if no taxonomy term data is present in the taxonomy manager form.
  if (!isset($form['term_data']['#term'])) {
    return;
  }

  // Figure out if taxonomy term relates to a vocabulary subqueue.
  $result = db_query("SELECT qid FROM {nodequeue_queue} WHERE reference = ?", array(
              $form['term_data']['#term']['vocabulary_machine_name'],
            ))->fetchCol();
  $queues = nodequeue_load_queues($result);

  $references = array();
  foreach ($queues as $queue) {
    $references[$queue->qid] = array($form['term_data']['#term']['tid']);
  }

  $subqueues = nodequeue_load_subqueues_by_reference($references);

  // Bail out if vocabulary didn't relate to a vocabulary subqueue.
  if (empty($subqueues)) {
    return;
  }

  // Add a fieldset to the taxonomy manager term data form with information
  // about the related vocabulary subqueues.
  $form['term_data']['vocabulary_queue'] = array(
    '#type' => 'fieldset',
    '#title' => t('Vocabulary Queues'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#prefix' => '<div class="vocabulary-queue">',
    '#suffix' => '</div>',
    '#weight' => 55,
  );

  $form['term_data']['vocabulary_queue']['prefix']['#markup'] = '<ul>';

  // List each related subqueue.
  foreach ($subqueues as $subqueue) {
    $title = nodequeue_title_substitute($queues[$subqueue->qid]->subqueue_title, $queues[$subqueue->qid], $subqueue);
    $form['term_data']['vocabulary_queue'][$subqueue->sqid] = array(
      '#markup' => '<li>' . l($queues[$subqueue->qid]->title . ': ' . $subqueue->title, 'admin/structure/nodequeue/' . $subqueue->qid . '/view/' . $subqueue->sqid) . '</li>',
    );
  }

  $form['term_data']['vocabulary_queue']['suffix']['#markup'] = '</ul>';
}

/**
 * Helper function to get vocabulary queues.
 *
 * @param bool $reset_cache
 *   Reset cache.
 *
 * @return array
 *   Array of vocabulary queues.
 */
function vocabulary_queue_get_vocabulary_queues($machine_name = NULL, $reset_cache = FALSE) {
  $vocabulary_queues = &drupal_static(__FUNCTION__);

  if ($reset_cache || is_null($vocabulary_queues)) {
    $vocabulary_queues = array();

    $result = db_select('vocabulary_queue', 'vq')
      ->fields('vq', array('qid'))
      ->execute()
      ->fetchAllKeyed(0, 0);

    $vocabulary_queues = nodequeue_load_queues($result);
  }
  if ($machine_name) {
    $queues = array();
    foreach ($vocabulary_queues as $queue) {
      $references = explode('-', $queue->reference);
      if (in_array($machine_name, $references)) {
        $queues[$queue->qid] = $queue;
      }
    }
    return $queues;
  }
  return $vocabulary_queues;
}

/**
 * Implements hook_nodequeue_autocomplete().
 */
function vocabulary_queue_nodequeue_autocomplete($queue, $subqueue, $string) {
  $matches = array();

  $query = db_select('node', 'n')
    ->addTag('node_access')
    ->fields('n', array('nid', 'tnid', 'title'))
    ->range(0, variable_get('nodequeue_autocomplete_limit', 10));

  if (!empty($queue->types)) {
    $query->condition('n.type', $queue->types, 'IN');
  }

  global $user;
  if (!user_access('administer nodes', $user)) {
    $query->condition(db_or()->condition('n.status', 1)->condition('n.uid', $user->uid));
  }

  // Run a match to see if they're specifying by nid.
  $preg_matches = array();
  $match = preg_match('/\[nid: (\d+)\]/', $string, $preg_matches);
  if (!$match) {
    $match = preg_match('/^nid: (\d+)/', $string, $preg_matches);
  }

  if ($match) {
    // If it found a nid via specification, reduce our resultset to just
    // that nid.
    $query->condition('n.nid', $preg_matches[1]);
  }
  else {
    // Build the constant parts of the query.
    // No need to use LOWER() since our table collation is case-insensitive.
    $query->where('n.title LIKE :string', array(':string' => '%' . db_like($string) . '%'));
  }
  $query->condition('n.created', time() - $queue->date_limit, '>=');
  $query->addTag('i18n_select');
  $result = $query->execute();

  foreach ($result as $node) {
    $id = nodequeue_get_content_id($queue, $node);
    $matches[$node->nid] = check_plain($node->title) . " [nid: $id]";
  }
  return $matches;
}
