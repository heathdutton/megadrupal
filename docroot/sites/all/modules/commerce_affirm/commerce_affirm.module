<?php

/**
 * @file
 * Main module for controlling the set up of the gateway.
 */

define('COMMERCE_AFFIRM_TXN_MODE_LIVE', 'live');
define('COMMERCE_AFFIRM_TXN_MODE_TEST', 'sandbox');

/**
 * Implements hook_menu().
 */
function commerce_affirm_menu() {
  $items = array();

  // Add a menu item for refunding settled transactions.
  $items['admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/affirm-refund'] = array(
    'title' => 'Refund',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_affirm_refund_form', 3, 5),
    'access callback' => 'commerce_affirm_refund_access',
    'access arguments' => array(5, 3),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'weight' => 4,
    'file' => 'includes/commerce_affirm.admin.inc',
  );
  // Add a menu item for voiding payments.
  $items['admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/affirm-void'] = array(
    'title' => 'Void',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_affirm_void_form', 3, 5),
    'access callback' => 'commerce_affirm_void_access',
    'access arguments' => array(5),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'weight' => 2,
    'file' => 'includes/commerce_affirm.admin.inc',
  );

  // Add a menu item for capturing payments.
  $items['admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/affirm-capture'] = array(
    'title' => 'Capture',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_affirm_capture_form', 3, 5),
    'access callback' => 'commerce_affirm_capture_access',
    'access arguments' => array(5),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'weight' => 2,
    'file' => 'includes/commerce_affirm.admin.inc',
  );

  return $items;
}

/**
 * Determines access to the prior authorization capture form.
 *
 * @param object $transaction
 *   The payment transaction object to be captured.
 *
 * @return bool
 *   TRUE or FALSE indicating capture access.
 */
function commerce_affirm_capture_access($transaction) {
  if ($transaction->payment_method != 'affirm' || $transaction->status != COMMERCE_PAYMENT_STATUS_PENDING || empty($transaction->remote_id)) {
    return FALSE;
  }

  return commerce_payment_transaction_access('update', $transaction);
}

/**
 * Determines access to the refund form for successful Affirm transactions.
 *
 * @param object $transaction
 *   The payment transaction object to be credited.
 * @param object $order
 *   The order the transaction is on.
 *
 * @return bool
 *   TRUE or FALSE indicating credit access.
 */
function commerce_affirm_refund_access($transaction, $order) {
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  $order_total = $order_wrapper->commerce_order_total->value();
  $balance = commerce_payment_order_balance($order);
  $remaining_amount = (int) $order_total['amount'] - $balance['amount'];

  if ($transaction->payment_method != 'affirm' || $transaction->status != COMMERCE_PAYMENT_STATUS_SUCCESS || $transaction->amount <= 0 || $remaining_amount <= 0 || empty($transaction->remote_id)) {
    return FALSE;
  }

  return commerce_payment_transaction_access('update', $transaction);
}

/**
 * Determines access to the void form for authorized Affirm transactions.
 *
 * @param object $transaction
 *   The payment transaction object to be voided.
 *
 * @return bool
 *   TRUE or FALSE indicating void access.
 */
function commerce_affirm_void_access($transaction) {
  if ($transaction->payment_method != 'affirm' || $transaction->status != COMMERCE_PAYMENT_STATUS_PENDING || empty($transaction->remote_id)) {
    return FALSE;
  }

  return commerce_payment_transaction_access('update', $transaction);
}

/**
 * Implements hook_commerce_payment_method_info().
 */
function commerce_affirm_commerce_payment_method_info() {
  $payment_methods = array();

  // Build the themed logo icon for the payment display.
  $icon_title = t('Affirm - Buy with Monthly Payments');
  $variables = array(
    'path' => drupal_get_path('module', 'commerce_affirm') . '/images/affirm-icon.png',
    'title' => $icon_title,
    'alt' => $icon_title,
    'attributes' => array(
      'class' => array('commerce-affirm-icon'),
    ),
  );
  $affirm_icon = theme('image', $variables);

  $payment_methods['affirm'] = array(
    'base' => 'commerce_affirm',
    'title' => t('Affirm Payment'),
    'display_title' => $affirm_icon . ' - ' . t('Buy with Monthly Payments'),
    'short_title' => t('Affirm'),
    'active' => FALSE,
    'terminal' => FALSE,
    'offsite_autoredirect' => FALSE,
    'offsite' => TRUE,
    'file' => 'includes/commerce_affirm.admin.inc',
  );

  return $payment_methods;
}

/**
 * Returns the default settings for the Affirm payment method.
 */
function commerce_affirm_default_settings() {
  return array(
    'private_key' => '',
    'public_key' => '',
    'financial_key' => '',
    'txn_mode' => COMMERCE_AFFIRM_TXN_MODE_TEST,
    'txn_type' => COMMERCE_CREDIT_AUTH_CAPTURE,
    'log' => 0,
  );
}

/**
 * Creates a form for general Affirm settings.
 *
 * @param array $settings
 *   Stored settings.
 *
 * @return array
 *   Return an array of settings.
 */
function commerce_affirm_settings_form($settings) {

  $settings = (array) $settings + commerce_affirm_default_settings();
  $form = array();

  // Add the Affirm logo to the settings.
  $logo_title = t('Affirm - Buy with Monthly Payments');
  $variables = array(
    'path' => drupal_get_path('module', 'commerce_affirm') . '/images/affirm-logo.png',
    'title' => $logo_title,
    'alt' => $logo_title,
    'attributes' => array(
      'class' => array('commerce-affirm-logo'),
      'style' => array('float: right; margin-right: 10px;'),
    ),
  );
  $form['logo'] = array(
    '#markup' => theme('image', $variables),
  );

  // Transactions mode.
  $form['txn_mode'] = array(
    '#type' => 'radios',
    '#title' => t('Transaction mode'),
    '#description' => t('Adjust to live transactions when you are ready to start processing real payments.'),
    '#options' => array(
      COMMERCE_AFFIRM_TXN_MODE_LIVE => t('Live transactions in a live account'),
      COMMERCE_AFFIRM_TXN_MODE_TEST => t('Test transactions in a sandbox account'),
    ),
    '#default_value' => $settings['txn_mode'],
  );
  // Private key.
  $form['private_key'] = array(
    '#type' => 'textfield',
    '#title' => t('Private Key'),
    '#description' => t('Add your private key for the gateway.'),
    '#default_value' => $settings['private_key'],
    '#required' => TRUE,
  );
  // Public key.
  $form['public_key'] = array(
    '#type' => 'textfield',
    '#title' => t('Public Key'),
    '#description' => t('Add your public key for the gateway.'),
    '#default_value' => $settings['public_key'],
    '#required' => TRUE,
  );
  // Financial Product Key.
  $form['financial_key'] = array(
    '#type' => 'textfield',
    '#title' => t('Financial Product Key'),
    '#description' => t('Add your financial key for the gateway.'),
    '#default_value' => $settings['financial_key'],
    '#required' => TRUE,
  );
  // Transactions type.
  $form['txn_type'] = array(
    '#type' => 'radios',
    '#title' => t('Default credit card transaction type'),
    '#description' => t('The default will be used to process transactions during checkout.'),
    '#options' => array(
      COMMERCE_CREDIT_AUTH_CAPTURE => t('Authorization and capture'),
      COMMERCE_CREDIT_AUTH_ONLY => t('Authorization only (requires manual or automated capture after checkout)'),
    ),
    '#default_value' => $settings['txn_type'],
  );

  $form['log'] = array(
    '#type' => 'checkbox',
    '#title' => t('Log API and related data for debugging'),
    '#default_value' => $settings['log'],
  );

  return $form;
}

/**
 * Payment method callback: redirect form.
 *
 * Returns form elements that should be submitted to the redirected
 * payment service.
 */
function commerce_affirm_redirect_form($form, &$form_state, $order, $payment_method) {
  // Return an error if the enabling action's settings haven't been configured.
  if (empty($payment_method['settings']['public_key']) || empty($payment_method['settings']['financial_key'])) {
    drupal_set_message(t('Affirm is not configured for use. You must check your settings.'), 'error');
    return array();
  }

  global $base_url;
  $settings = (array) $payment_method['settings'] + commerce_affirm_default_settings();

  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  $order_total = $order_wrapper->commerce_order_total->value();

  $commerce_module_info = system_get_info('module', 'commerce');
  $affirm_module_info = system_get_info('module', 'commerce');
  if ($commerce_module_info['version'] == '') {
    $commerce_module_info['version'] = '7.x-1.??';
  }

  // Creates a data array to be passed onto the request.
  $data = array(
    // General settings.
    'ApiMode'             => $settings['txn_mode'],
    'PublicKey'           => $settings['public_key'],
    'FinancialProductKey' => $settings['financial_key'],
    'OrderId'             => $order_wrapper->order_id->value(),
    'Email'               => $order_wrapper->mail->value(),
    'CancelUrl'           => url('checkout/' . $order_wrapper->order_id->value() . '/payment/back/' . $order->data['payment_redirect_key'], array('absolute' => TRUE)),
    'ConfirmUrl'          => url('checkout/' . $order_wrapper->order_id->value() . '/payment/return/' . $order->data['payment_redirect_key'], array('absolute' => TRUE)),
    'items'               => array(),
    'metadata'            => array(
      'platform_type' => 'Drupal',
      'platform_version' => 'Drupal ' . VERSION . '; Drupal Commerce ' . check_plain($commerce_module_info['version']),
      'platform_affirm' => check_plain($affirm_module_info['version']),
      'shipping_type' => '',
    ),
    'ShippingTotal'       => 0,
    'TaxAmount'           => 0,
    'ProductsTotal'       => $order_total['amount'],
  );

  // Adds information about the billing profile.
  if ($order_wrapper->commerce_customer_billing->value()) {
    $billing_address_wrapper = $order_wrapper->commerce_customer_billing->commerce_customer_address->value();
    $data += array(
      'BillingFullName'        => $billing_address_wrapper['name_line'],
      'BillingFirstName'       => $billing_address_wrapper['first_name'],
      'BillingLastName'        => $billing_address_wrapper['last_name'],
      'BillingAddressLn1'      => $billing_address_wrapper['thoroughfare'],
      'BillingAddressLn2'      => $billing_address_wrapper['premise'],
      'BillingAddressPostCode' => $billing_address_wrapper['postal_code'],
      'BillingAddressState'    => $billing_address_wrapper['administrative_area'],
      'BillingAddressCity'     => $billing_address_wrapper['locality'],
      'BillingAddressCountry'  => $billing_address_wrapper['country'],
      'BillingTelephone'       => '',
    );
  }

  // Use the shipping profile if the shipping module exists and the order
  // contain a shipping profile otherwise use the Billing profile.
  $shipping_address_wrapper = module_exists('commerce_shipping') && $order_wrapper->commerce_customer_shipping->value()
    ? $order_wrapper->commerce_customer_shipping->commerce_customer_address->value()
    : $billing_address_wrapper;

  $data += array(
    'ShippingFullName'        => $shipping_address_wrapper['name_line'],
    'ShippingFirstName'       => $shipping_address_wrapper['first_name'],
    'ShippingLastName'        => $shipping_address_wrapper['last_name'],
    'ShippingAddressLn1'      => $shipping_address_wrapper['thoroughfare'],
    'ShippingAddressLn2'      => $shipping_address_wrapper['premise'],
    'ShippingAddressCountry'  => $shipping_address_wrapper['country'],
    'ShippingAddressPostCode' => $shipping_address_wrapper['postal_code'],
    'ShippingAddressState'    => $shipping_address_wrapper['administrative_area'],
    'ShippingAddressCity'     => $shipping_address_wrapper['locality'],
    'ShippingTelephone'       => '',
  );

  foreach ($order_wrapper->commerce_line_items as $delta => $line_item_wrapper) {
    if (in_array($line_item_wrapper->type->value(), commerce_product_line_item_types())) {
      $unit_price = (int) $line_item_wrapper->commerce_unit_price->amount->value();

      // Check if the line item value is less than 0.
      if ($unit_price < 0) {
        $sku = $line_item_wrapper->commerce_product->sku->value();

        if (empty($data['discounts'])) {
          $data['discounts'] = array();
        }
        if (!isset($data['discounts'][$sku])) {
          // Go ahead and set it to the positive value of the current price.
          $data['discounts'][$sku]['discount_amount'] = 0 - $unit_price;
        }
        else {
          // Add extra line items just in case they exist.
          $data['discounts'][$sku]['discount_amount'] -= $unit_price;
        }
      }
      else {
        $data['items'][] = array(
          'sku' => $line_item_wrapper->commerce_product->sku->value(),
          'qty' => (int) $line_item_wrapper->quantity->value(),
          'display_name' => $line_item_wrapper->commerce_product->title->value(),
          'item_url' => $line_item_wrapper->commerce_display_path->value()
          ? url($line_item_wrapper->commerce_display_path->value(), array('absolute' => TRUE))
          : $base_url,
          'item_image_url' => '',
          'unit_price' => $unit_price,
        );
      }
    }
    if (module_exists('commerce_shipping') && $line_item_wrapper->type->value() == 'shipping') {
      // Extract the unit price.
      $shipping_price = $line_item_wrapper->commerce_unit_price->value();
      // Track the total costs of all shipping line items on the order to add to
      // the final payment request as a single amount, though typically this
      // should be limited to one shipping line item per order.
      $data["ShippingTotal"] += $shipping_price['amount'];
      $data["ShippingType"] = $line_item_wrapper->commerce_shipping_service->value();
    }
  }
  sort($data['items']);

  // Determine the order level item amount and tax amount line items. To prevent
  // rounding problems getting in the way, we calculate them based on the order
  // total instead of tallying it from each line item.
  if (module_exists('commerce_tax')) {
    $data['TaxAmount']  = commerce_tax_total_amount($order_total['data']['components'], TRUE, 'USD');
  }

  // Allow modules to alter the order data sent to Affirm before the request.
  drupal_alter('commerce_affirm_transaction_data', $data, $order, $settings);

  ksort($data);

  // Pass checkout settings through to front-end.
  drupal_add_js(array('commerce_affirm' => $data), 'setting');
  // Load affirm checkout script.
  drupal_add_js(drupal_get_path('module', 'commerce_affirm') . '/js/commerce_affirm.js', array('weight' => -10));
  drupal_add_js(drupal_get_path('module', 'commerce_affirm') . '/js/commerce_affirm_checkout.js', array('weight' => 50));

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Proceed with payment'),
  );

  if ($settings['log']) {
    watchdog('commerce_affirm', '!function debug data:!data', array(
      '!function' => __FUNCTION__,
      '!data' => '<pre>' . print_r($data, TRUE) . '</pre>',
    ), WATCHDOG_WARNING);
  }

  return $form;
}

/**
 * Payment method callback: redirect form return validation.
 */
function commerce_affirm_redirect_form_validate($order, $payment_method) {
  // Gets Affirm response.
  $checkout_token = $_POST['checkout_token'];
  $settings = $payment_method['settings'] + commerce_affirm_default_settings();

  // Exit now if the $_POST was empty.
  if (empty($checkout_token)) {
    watchdog('commerce_affirm', 'Affirm response returned without POST parameters.', array(), WATCHDOG_WARNING);
    return FALSE;
  }

  $data = array(
    'checkout_token' => $checkout_token,
  );

  if ($settings['log']) {
    watchdog('commerce_affirm', '!function debug:<br/>Token = !token<br/>!data', array(
      '!function' => __FUNCTION__,
      '!token' => $_POST['checkout_token'],
      '!data' => '<pre>' . print_r($data, TRUE) . '</pre>',
    ), WATCHDOG_WARNING);
  }

  return commerce_affirm_process_transaction($order, $payment_method, $data);
}

/**
 * Process the payment transaction with the info received from Affirm.
 *
 * @param object $order
 *   The loaded order that is being processed.
 * @param array $payment_method
 *   The payment method settings.
 * @param array $data
 *   Data to send to Affirm.
 *
 * @return bool
 *   Returns TRUE if the transaction was successful. FALSE if it was not.
 */
function commerce_affirm_process_transaction($order, $payment_method, $data) {

  // Query to API to ask for a Authorization payment.
  $response = commerce_affirm_api_request(COMMERCE_CREDIT_AUTH_ONLY, $payment_method, $order, array(), $data);

  if (empty($response)) {
    drupal_set_message(t('We could not complete your payment with Affirm. Please try again or contact us if the problem persists.'), 'error');
    return FALSE;
  }

  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  $charge = $order_wrapper->commerce_order_total->value();

  // Prepare a transaction object to log the API response.
  $transaction = commerce_payment_transaction_new('affirm', $order->order_id);
  $transaction->instance_id = $payment_method['instance_id'];
  $transaction->amount = $charge['amount'];
  $transaction->currency_code = $charge['currency_code'];
  $transaction->payload[REQUEST_TIME . '-authorization'] = $response;

  // Checks if the response contains an error.
  if (isset($response['status_code'])) {
    $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
    $transaction->remote_status = '';
    $transaction->message = t('Failed to authorize the payment. @date', array('@date' => format_date(REQUEST_TIME, 'short')));
    commerce_payment_transaction_save($transaction);

    // Display an error message and remain on the same page.
    drupal_set_message(t('We could not complete your payment with Affirm. Please try again or contact us if the problem persists.'), 'error');
    return FALSE;
  }

  $transaction->remote_id = $response['id'];
  $transaction->status = COMMERCE_PAYMENT_STATUS_PENDING;
  $transaction->remote_status = 'authorize';
  $transaction->message = t('The payment has been authorized.');
  commerce_payment_transaction_save($transaction);

  // In case the payment method is configured for Auth & Capture, the capture
  // request is triggered right after the authorization.
  if ($payment_method['settings']['txn_type'] == COMMERCE_CREDIT_AUTH_CAPTURE && $transaction) {
    $response = commerce_affirm_api_request(COMMERCE_CREDIT_CAPTURE_ONLY, $payment_method, $order, $transaction, $data);

    if (empty($response)) {
      drupal_set_message(t('We could not complete your payment with Affirm. Please try again or contact us if the problem persists.'), 'error');
      return FALSE;
    }

    $transaction->payload[REQUEST_TIME . '-capture'] = $response;

    if (isset($response['status_code'])) {
      $transaction->message = '<br />' . t('Failed to capture the amount. @date', array('@date' => format_date(REQUEST_TIME, 'short')));
      commerce_payment_transaction_save($transaction);
      drupal_set_message(t('We could not complete your payment with Affirm. Please try again or contact us if the problem persists.'), 'error');
      return FALSE;
    }

    $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
    $transaction->remote_status = $response['type'];
    $transaction->message .= '<br />' . t('Captured: @date', array('@date' => format_date(REQUEST_TIME, 'short')));
    commerce_payment_transaction_save($transaction);

    return TRUE;
  }
  return TRUE;
}

/**
 * Payment method callback.
 *
 * Adds a message to the submission form if enabled in the payment method
 * settings.
 */
function commerce_affirm_submit_form($payment_method, $pane_values, $checkout_pane, $order) {
  $form = array();

  $form['Affirm'] = array(
    '#markup' => '<span class="commerce-affirm-info"><strong>' . t('How does Affirm work?') . '</strong><p>' . t('Just enter your basic information and get approved instantly to pay over time. You will complete your payment on the Affirm website.') . '</p></span>',
  );

  return $form;
}

/**
 * Payment method callback: submit form validation.
 */
function commerce_affirm_submit_form_validate($payment_method, $pane_form, $pane_values, $order, $form_parents = array()) {
  // Return an error if the enabling action's settings haven't been configured.
  foreach (array('private_key', 'public_key', 'financial_key') as $key) {
    if (empty($payment_method['settings'][$key])) {
      drupal_set_message(t('Affirm is not configured for use. Please contact an administrator to resolve this issue.'), 'error');
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Implements hook_default_rules_configuration_alter().
 */
function commerce_affirm_default_rules_configuration_alter(&$configs) {
  // Forces the payment method to only works with USD.
  $configs['commerce_payment_affirm']->condition(rules_condition('data_is', array('data:select' => 'commerce-order:commerce-order-total:currency-code', 'value' => 'USD')));

}

/**
 * Post data to Affirm using cURL library.
 *
 * @param string $txn_type
 *   The transaction type (Authorization/Capture/Refund/Void).
 * @param array $payment_method
 *   The payment method instance array associated with this API request.
 * @param object $order
 *   The order object the payment request is being submitted for.
 * @param object|null $transaction
 *   The payment transaction object requested.
 * @param array $data
 *   Data to send to Affirm.
 *
 * @return array
 *   Return a cURL error or an Affirm response.
 */
function commerce_affirm_api_request($txn_type, $payment_method, $order, $transaction = NULL, $data = array()) {
  $settings = $payment_method['settings'] + commerce_affirm_default_settings();
  $response = NULL;

  $headers = array(
    'Content-Type: application/json',
  );
  // Prepare the CURL options.
  $options = array(
    CURLOPT_HTTPHEADER     => $headers,
    CURLOPT_HTTPAUTH       => CURLAUTH_BASIC,
    CURLOPT_USERPWD        => $settings['public_key'] . ':' . $settings['private_key'],
    CURLOPT_RETURNTRANSFER => TRUE,
    CURLOPT_POST           => 1,
    CURLOPT_POSTFIELDS     => drupal_json_encode($data),
  );

  // Get the API endpoint URL for the method's transaction mode.
  $url = commerce_affirm_api_server_url($settings['txn_mode'], $txn_type, $transaction);

  $ch = curl_init($url);
  curl_setopt_array($ch, $options);
  $response = curl_exec($ch);
  curl_close($ch);

  if ($settings['log']) {
    watchdog('commerce_affirm', '!function Response:!data', array(
      '!function' => __FUNCTION__,
      '!data' => '<pre>' . print_r(drupal_json_decode($response), TRUE) . '</pre>',
    ), WATCHDOG_WARNING);
  }

  if (($result = drupal_json_decode($response)) && (is_array($result))) {
    if (isset($result['status_code'])) {
      watchdog('commerce_affirm', "!message<br/>Transaction type: !txn_type<br/><br/>The request returned from Affirm with the following data: !data<br/>The request concerned the following order: !order", array(
        '!message' => $result['message'],
        '!txn_type' => $txn_type,
        '!data' => '<pre>' . check_plain(print_r($result, TRUE)) . '</pre>',
        '!order' => '<pre>' . check_plain(print_r($order, TRUE)) . '</pre>',
      ), WATCHDOG_ERROR);
    }
    return $result;
  }

  watchdog('commerce_affirm', 'The Affirm API server could not be reached. The request returned from Affirm with the following data: !response', array('!response' => '<pre>' . check_plain(print_r($response, TRUE)) . '</pre>'), WATCHDOG_ERROR);

  return array();
}

/**
 * Returns the URL to the Affirm server determined by the transaction type.
 *
 * @param string $txn_mode
 *   The transaction mode that relates to the production or test server.
 * @param string $txn_type
 *   The transaction type (Authorization/Capture/Refund/Void).
 * @param object|null $transaction
 *   The payment transaction object to be captured. The object is required if
 *   you want to do something else than an authorization.
 *
 * @return string|bool
 *   The URL to use to submit requests to the Affirm server.
 */
function commerce_affirm_api_server_url($txn_mode, $txn_type, $transaction = NULL) {

  // Gets the API endpoint of Affirm server.
  $api_url = commerce_affirm_server_url($txn_mode);

  switch ($txn_type) {
    case COMMERCE_CREDIT_AUTH_ONLY:
      return $api_url;

    case COMMERCE_CREDIT_CAPTURE_ONLY:
      if (empty($transaction)) {
        drupal_set_message(t("You can not create a capture request without specifying a transaction object"));
        return FALSE;
      }
      return $api_url . $transaction->remote_id . '/capture';

    case COMMERCE_CREDIT_CREDIT:
      if (empty($transaction)) {
        drupal_set_message(t("You can not create a credit request without specifying a transaction object"));
        return FALSE;
      }
      return $api_url . $transaction->remote_id . '/refund';

    case COMMERCE_CREDIT_VOID:
      if (empty($transaction)) {
        drupal_set_message(t("You can not create a void request without specifying a transaction object"));
        return FALSE;
      }
      return $api_url . $transaction->remote_id . '/void';
  }
  return FALSE;
}

/**
 * Returns the base URL to Affirm API server depending on the transaction mode.
 *
 * @param string $txn_mode
 *   The transaction mode that relates to the production or test server.
 *
 * @return string|bool
 *   The Base URL to use to submit requests to the Affirm API server.
 */
function commerce_affirm_server_url($txn_mode) {
  switch ($txn_mode) {
    case COMMERCE_AFFIRM_TXN_MODE_LIVE:
      return 'https://api.affirm.com/api/v2/charges/';

    case COMMERCE_AFFIRM_TXN_MODE_TEST:
      return 'https://sandbox.affirm.com/api/v2/charges/';
  }
  return FALSE;
}

/**
 * Implements hook_block_info().
 */
function commerce_affirm_block_info() {
  $blocks = array();

  $blocks['commerce_affirm_banners'] = array(
    'info' => t('Affirm banner'),
    'cache' => DRUPAL_CACHE_GLOBAL,
  );

  return $blocks;
}

/**
 * Returns the default settings for the Affirm banner feature.
 */
function commerce_affirm_banners_default_settings() {
  return array(
    'banner_key' => '',
    'banner_size' => '468x60',
  );
}

/**
 * Implements hook_block_configure().
 */
function commerce_affirm_block_configure($delta = '') {
  $form = array();

  if ($delta == 'commerce_affirm_banners') {
    // Load the Affirm banners settings.
    $settings = (array) variable_get('commerce_affirm_banners_settings', array()) + commerce_affirm_banners_default_settings();

    $form['affirm_banners'] = array(
      '#type' => 'fieldset',
      '#title' => t('Affirm Promotional Banners'),
      '#description' => commerce_affirm_banners_help_text(),
      '#collapsible' => FALSE,
      '#collapsed' => FALSE,
    );

    $form['affirm_banners']['settings'] = array(
      '#tree' => TRUE,
    );

    // API Email.
    $form['affirm_banners']['settings']['banner_key'] = array(
      '#type' => 'textfield',
      '#title' => t('Affirm banner key'),
      '#description' => t('Enter the banner key.'),
      '#default_value' => $settings['banner_key'],
      '#states' => array(
        'visible' => array(
          ':input[name$="[banner_agreement]"]' => array('checked' => TRUE),
        ),
      ),
    );

    $form['affirm_banners']['settings']['banner_size'] = array(
      '#type' => 'select',
      '#title' => t('Banner size'),
      '#description' => t('Select the image size of the banner you want to display in this block.'),
      '#options' => array(
        t('Small Horizontal') => array(
          '120x90' => '120 x 90',
          '150x100' => '150 x 100',
          '170x100' => '170 x 100',
          '190x100' => '190 x 100',
          '234x60' => '234 x 60',
          '350x50' => '350 x 50',
          '468x60' => '468 x 60',
        ),
        t('Large Horizontal') => array(
          '300x250' => '300 x 250',
          '336x280' => '336 x 280',
          '540x200' => '540 x 200',
          '728x90' => '728 x 90',
          '800x66' => '800 x 66',
        ),
        t('Square') => array(
          '250x250' => '250 x 250',
          '280x280' => '280 x 280',
        ),
        t('Small Vertical') => array(
          '120x240' => '120 x 240',
        ),
        t('Large Vertical') => array(
          '120x600' => '120 x 600',
          '234x400' => '234 x 400',
        ),
      ),
      '#default_value' => $settings['banner_size'],
    );
  }

  return $form;
}

/**
 * Returns the Affirm banners program help text.
 */
function commerce_affirm_banners_help_text() {
  return '<p>' . t('Give your sales a boost when you advertise financing!') . '</p>'
    . '<p>' . t('Merchants who promote Affirm financing have shown increased sales and average order value. We recommend you promote Affirm on your <strong>product</strong> and <strong>checkout pages</strong> to inform customers about their financing options as they are making their purchase decision.') . '</p>'
    . '<p>' . t('To help you with this, we’ve created a set of promotional banners (images below) that will easily integrate with your website.') . '</p>';
}

/**
 * Implements hook_block_save().
 *
 * Saves the settings filled in and the block configuration.
 */
function commerce_affirm_block_save($delta = '', $edit = array()) {
  if ($delta == 'commerce_affirm_banners') {
    if (!empty($edit['settings'])) {
      // Clean the entered values.
      $edit['settings'] = array_map('trim', $edit['settings']);
      variable_set('commerce_affirm_banners_settings', $edit['settings']);
    }
  }
}

/**
 * Implements hook_block_view().
 *
 * Adds Affirm banners into the block to display the ad.
 */
function commerce_affirm_block_view($delta = '') {
  $block = array();

  if ($delta == 'commerce_affirm_banners') {
    // Get the Affirm Banners settings.
    $settings = (array) variable_get('commerce_affirm_banners_settings', array()) + commerce_affirm_banners_default_settings();

    $settings['banner_key'] = 'W6WU7UK82RS34HDH';

    if ($settings['banner_key']) {
      $markup = '<div class="affirm-promo" data-promo-key="' . $settings['banner_key'] . '" data-promo-size="' . $settings['banner_size'] . '"></div>';
      $block['content'] = array(
        '#markup' => $markup,
        '#prefix' => '<span class="commerce-affirm-banner-wrapper">',
        '#suffix' => '</span>',
      );
      drupal_add_js(drupal_get_path('module', 'commerce_affirm') . '/js/commerce_affirm.js');
    }
  }

  return $block;
}
