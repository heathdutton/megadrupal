<?php

/**
 * @file
 *   XLIFF import and export functionality.
 */

/**
 * Implements hook_help().
 */
function xliff_help($path, $arg) {
  switch ($path) {
    case 'node/%/xliff':
    case 'node/%/xliff/export':
    case 'node/%/xliff/import':
      return t('XLIFF allows you to outsource translation to professional translators, using tools better tailored for a translation workflow, supporting reuse of existing translations and terminology.');
  }
}

/**
 * Implements of hook_menu().
 */
function xliff_menu() {
  $items['node/%node/xliff'] = array(
    'title' => 'XLIFF tools',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xliff_export_form', 1),
    'access callback' => 'user_access',
    'access arguments' => array('xliff export'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 20,
    'file' => 'includes/admin.inc',
  );
  $items['node/%node/xliff/export'] = array(
    'title' => 'XLIFF export',
    'description' => 'Export content into XLIFF format',
    'weight' => -10,
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['node/%node/xliff/import'] = array(
    'title' => 'XLIFF import',
    'description' => 'Import content form XLIFF format',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xliff_import_form', 1),
    'access callback' => 'user_access',
    'access arguments' => array('xliff import'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'includes/admin.inc',
  );
  $items['admin/config/regional/xliff'] = array(
    'title' => 'XLIFF',
    'description' => 'XLIFF tools and settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('xliff_settings'),
    'access callback' => 'user_access',
    'access arguments' => array('administer xliff'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'includes/admin.inc',
  );
  $items['admin/config/regional/xliff/tools'] = array(
    'title' => 'Settings',
    'weight' => 10,
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function xliff_permission() {
  return array(
    'xliff import' => array(
      'title' => t('XLIFF import'),
    ),
    'xliff export' => array(
      'title' => t('XLIFF export'),
    ),
    'administer xliff' => array(
      'title' => t('Adiminster XLIFF tools'),
    ),
  );
}

/**
 * Convert html special characters to utf8.
 */
function xliff_html2unicode($input) {
  static $htmlEntities, $utf8Entities;

  if (!isset($htmlEntities)) {
    $translation_table = get_html_translation_table(HTML_ENTITIES, ENT_NOQUOTES);
    $htmlEntities = array_values($translation_table);
    $entitiesDecoded = array_keys($translation_table);

    $count = count($entitiesDecoded);
    for ($u = 0; $u < $count; $u++) {
      $utf8Entities[$u] = '&#' . ord($entitiesDecoded[$u]) . ';';
    }
  }

  return str_replace($htmlEntities, $utf8Entities, $input);
}

/**
 * XLIFF export API
 * Export node as XLIFF file.
 */
function xliff_export($nid) {
  // Get latest title and body
  $node = node_load($nid);

  $body = isset($node->body[$node->language][0]['value']) ? xliff_html2unicode($node->body[$node->language][0]['value']) : '';
  $html = new DOMDocument();
  $doctype = '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">';
  @$html->loadXML($doctype . '<html><head><title>' . check_plain($node->title) . '</title></head><body>' . $body . '</body></html>');

  $xsl = new DOMDocument;
  $xsl->load(drupal_get_path('module', 'xliff') . '/xsl/xml2xliff.xsl');
  $proc = new XSLTProcessor();
  $proc->ImportStyleSheet($xsl);

  return $proc->transformToXML($html);
}

function xliff_bilingual_export($nid, &$message) {
  module_load_include('inc', 'xliff', 'includes/bilingual_export');
  $node = node_load($nid);
  return _xliff_bilingual_export($node, $message);
}

/**
 * XLIFF import API
 * Import an XLIFF file to node.
 *
 * @param $file
 *   XLIFF file. Filename must be in format node-$nid-$langcode.xliff to match
 *   validation. If the node is not translated to given language then the node
 *   translation will be created automatically.
 * @param $revision
 *   Create node revision.
 * @param $preserve_path
 *   Use the same path alias as the source node.
 */
function xliff_import(stdClass $file, $revision = TRUE, $preserve_path = TRUE, $test = FALSE, &$message) {
  if (!xliff_check_import_file($file, 0, $message)) {
    return FALSE;
  }

  $info = xliff_parse_filename($file);
  if (empty($info)) {
    // Incorrect filename format.
    return FALSE;
  }

  $xliff = new DOMDocument;
  $xliff->load($file->uri);

  $xsl = new DOMDocument;
  $xsl->load(drupal_get_path('module', 'xliff') . '/xsl/xliff2xml.xsl');
  $proc = new XSLTProcessor();
  $proc->ImportStyleSheet($xsl);

  $html = simplexml_import_dom($proc->transformToDoc($xliff));
  if (!isset($html)) {
    $message = t('Malformed XLIFF file, the HTML conversion failed.');
    return FALSE;
  }

  $title = (string) $html->head->title;

  // asXML() naturally requires a root tag to be present in the document, while
  // we only need the contents of that root tag, so we need to scrape it out.
  $body = preg_replace('!^<body>(.+)</body>$!', '\\1', (string) $html->body->asXML());

  $translation_source = node_load($info['nid']);
  if (empty($translation_source) || !node_access('view', $translation_source)) {
    $message = t('Content not found or content not accessible.');
    return FALSE;
  }

  if ($translation_source->language == $info['langcode'] || ($translation_source->language != LANGUAGE_NONE && language_default('language') == $info['langcode'])) {
     // Updating the source node.
    $node = $translation_source;
    $message = t('The content will be updated.');
  }
  else {
    if (!module_exists('translation')) {
      $message = t('Content translation module needs to be enabled.');
      return FALSE;
    }

    if (!translation_supported_type($translation_source->type)) {
      $message = t('This content type is not multilingual.');
      return FALSE;
    }

    if (!user_access('translate content')) {
      $message = t('Translate content permission is required.');
      return FALSE;
    }

    if (empty($translation_source->language)) {
      $message = t('The language of this content must be set before creating a translation.');
      return FALSE;
    }

    $translations = translation_node_get_translations($translation_source->tnid);
    if (isset($translations[$info['langcode']])) {
      // Updating the translation node.
      $node = node_load($translations[$info['langcode']]->nid);
      $message = t('Content translation will be updated.');
    }
    else {
      // Creating translation node.
      if (!($node = _xliff_create_translation($translation_source, $info['langcode'], $message))) {
        return FALSE;
      }
      if ($preserve_path && isset($translation_source->path)) {
        $node->path = array('alias' => $translation_source->path);
      }
      $message = t('Content translation will be created.');
    }
  }

  $node->title = $title;
  $node->body[$node->language][0]['value'] = $body;
  // $node->body[$node->language][0]['summary'] = text_summary($body);
  $node->revision = $revision;
  $node->log = t('XLIFF import.');

  if (!$test) {
    node_save($node);
    return $node;
  }

  return TRUE;
}

/**
 * Create the translation node.
 */
function _xliff_create_translation($translation_source, $langcode, &$message) {
  // Include for the node_object_prepare() function.
  module_load_include('inc', 'node', 'node.pages');

  $node = new stdClass;
  foreach (array('body', 'title', 'format') as $key) {
    $node->$key = NULL;
  }
  $node->type = $translation_source->type;
  $node->language = $langcode;
  node_object_prepare($node);

  // The hook_nodeapi() in the Content translation module for op = 'prepare'
  // does not run correctly. Copy the process.
  $node->translation_source = $translation_source;
  $node->title = $translation_source->title;
  $node->body = filter_access($translation_source->format) ? $translation_source->body : '';

  // Use the same input fomat.
  // @todo: input format access check?
  $node->format = $translation_source->format;
  // Let every module add custom translated fields.
  node_invoke_nodeapi($node, 'prepare translation');

  return $node;
}

/**
 * Parse the filename into values: nid, langcode.
 */
function xliff_parse_filename(stdClass $file) {
  // Parse the filename (example: node-42-en.xlf) into values: nid, langcode.
  if (preg_match('/^node-(?P<nid>\d+)-(?P<langcode>.*)\.(xlf|xliff)$/', $file->filename, $matches)) {
    return array('nid' => $matches['nid'], 'langcode' => $matches['langcode']);
  }
  return array();
}

/**
 * Import file check.
 */
function xliff_check_import_file(stdClass $file, $nid = 0, &$error_message) {
  $info = xliff_parse_filename($file);
  if (empty($info)) {
    $error_message = t('Incorrect filename format. @filename', array('@filename' => $file->filename));
    return FALSE;
  }

  if ($info['langcode'] != LANGUAGE_NONE && !in_array($info['langcode'], array_keys(language_list()))) {
    $error_message = t('The language specified in the filename is not used on this site.');
    return FALSE;
  }

  if (!empty($nid) && $info['nid'] != $nid ) {
    $error_message = t('The node ID specified in the filename does not match.');
    return FALSE;
  }

  return TRUE;
}
