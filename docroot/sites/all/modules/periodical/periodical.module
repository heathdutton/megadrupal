<?php

/**
 * @file
 * Manage publication dates for periodicals like journals and magazines
 *
 */

define("PERIODICAL_ALTER_TERM_ORDER_NO", 0);
define("PERIODICAL_ALTER_TERM_ORDER_DATE_DESC", 1);
define("PERIODICAL_ALTER_TERM_ORDER_DATE_ASC", 2);
define("PERIODICAL_ALTER_TERM_ORDER_NUM_DESC", 3);
define("PERIODICAL_ALTER_TERM_ORDER_NUM_ASC", 4);

/**
 * Manage publication dates for periodicals like journals and magazines
 */

/**
 * Implements hook_menu() to set up the URLs (menu entries) for the
 * form examples.
 */
function periodical_menu() {
  $items = array();
  $items['admin/structure/periodical'] = array(
    'title' => 'Periodical Issues',
    'description' => 'Manage periodical issues', 
    'page callback' => 'periodical_overview_page',
    'access arguments' => array('administer taxonomy'),
    'file' => 'periodical.admin.inc',
  );
  $items['admin/structure/periodical/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/structure/periodical/settings'] = array(
    'title' => t('Settings'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('periodical_form_settings'),
    'access arguments' => array('administer taxonomy'),
    'type' => MENU_LOCAL_TASK,
    'file' => 'periodical.admin.inc',
    'weight' => 10,
  );

  if (count(periodical_get_enabled_vocabularies()) > 0) {
    $items['admin/structure/periodical/generate'] = array(
      'title' => 'Generate',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('periodical_form_generate_dispatch'),
      'access arguments' => array('administer taxonomy'),
      'type' => MENU_LOCAL_TASK,
      'file' => 'periodical.admin.inc',
    );
    $items['admin/structure/periodical/generate/%taxonomy_vocabulary_machine_name'] = array(
      'title callback' => 'periodical_generate_terms_title',
      'title arguments' => array(4),
      'page callback' => 'drupal_get_form',
      'page arguments' => array('periodical_form_generate_terms', 4),
      'access arguments' => array('administer taxonomy'),
      'type' => MENU_LOCAL_TASK,
      'file' => 'periodical.admin.inc',
    );
  }

  return $items;
}

/**
 * Implements hook_intro().
 */
function periodical_intro() {
  $markup = t('Manage publication dates for periodicals like journals and magazines');
  return array('#markup' => $markup);
}


/**
 * Return a list of terms for the given vocabulary with a publication date
 * within the given time period.
 */
function periodical_issue_load_multiple(DateObject $fromdate, $count = 10,
  $vocabulary = NULL)
{
  _periodical_fix_granularity($fromdate);
  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'taxonomy_term')
    ->fieldCondition('periodical_issue_date', 'value',
        $fromdate->format(DATE_FORMAT_ISO), '>=')
    ->fieldOrderBy('periodical_issue_date', 'value')
    ->range(0, $count)
    ->addTag('term_access')
    ->addTag('translatable');

  if ($vocabulary != NULL) {
    $query->propertyCondition('vid', $vocabulary->vid, '=');
  }

  $result = $query->execute();
  $terms = taxonomy_term_load_multiple(array_keys($result['taxonomy_term']));

  return $terms;
}


/**
 * Return issue date of the given issue term as a date object.
 */
function periodical_get_issue_date($term) {
  if (empty($term->periodical_issue_date)) {
    return NULL;
  }

  $datevals = $term->periodical_issue_date[LANGUAGE_NONE][0];
  $date = date_create($datevals['value'],
    timezone_open($datevals['timezone_db']));
  date_timezone_set($date, timezone_open($datevals['timezone']));

  return $date;
}


/**
 * Return a number of preceeding terms based on the given term and periodical
 * issue dates.
 */
function periodical_get_preceeding_issues($term, $count = 1) {
  $date = $term->periodical_issue_date[LANGUAGE_NONE][0]['value'];

  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'taxonomy_term')
    ->fieldCondition('periodical_issue_date', 'value', $date, '<')
    ->fieldOrderBy('periodical_issue_date', 'value', 'DESC')
    ->range(0, $count)
    ->propertyCondition('vid', $term->vid, '=')
    ->addTag('term_access')
    ->addTag('translatable')
    ->execute();

  return isset($result['taxonomy_term']) ?
    array_keys($result['taxonomy_term']) : array();
}


/**
 * Return a number of terms following the given term based on periodical issue
 * dates.
 */
function periodical_get_following_issues($term, $count = 1) {
  $date = $term->periodical_issue_date[LANGUAGE_NONE][0]['value'];

  $query = new EntityFieldQuery();
  $result = $query
    ->entityCondition('entity_type', 'taxonomy_term')
    ->fieldCondition('periodical_issue_date', 'value', $date, '>')
    ->fieldOrderBy('periodical_issue_date', 'value')
    ->range(0, $count)
    ->propertyCondition('vid', $term->vid, '=')
    ->addTag('term_access')
    ->addTag('translatable')
    ->execute();

  return isset($result['taxonomy_term']) ?
    array_keys($result['taxonomy_term']) : array();
}


/**
 * Return a number of terms with an issue date greater or equal than the given
 * fromdate date and strictly less than the given end date.
 */
function periodical_get_issues_range(DateObject $fromdate,
    DateObject $todate, $vid = FALSE, $limit = 50) {

  $field = field_read_field('periodical_issue_date',
    array('include_inactive' => TRUE));
  $timezone_db = date_get_timezone_db($field['settings']['tz_handling']);

  date_timezone_set($fromdate, timezone_open($timezone_db));
  date_timezone_set($todate, timezone_open($timezone_db));

  _periodical_fix_granularity($fromdate);
  _periodical_fix_granularity($todate);
  $query = new EntityFieldQuery();
  $query
    ->entityCondition('entity_type', 'taxonomy_term')
    ->fieldCondition('periodical_issue_date', 'value',
        $fromdate->format(DATE_FORMAT_ISO), '>=')
    ->fieldCondition('periodical_issue_date', 'value',
        $todate->format(DATE_FORMAT_ISO), '<')
    ->fieldOrderBy('periodical_issue_date', 'value')
    ->addTag('term_access')
    ->addTag('translatable');

  if ($limit) {
    $query->range(0, $limit);
  }

  if ($vid) {
    $query->propertyCondition('vid', $vid, '=');
  }

  $result = $query->execute();

  return isset($result['taxonomy_term']) ?
    array_keys($result['taxonomy_term']) : array();
}


/**
 * Returns a term object if we are on a term-overview page and the periodical
 * issue date field is set.
 */
function periodical_get_current_issue_term() {
  if (arg(0) != 'taxonomy' || arg(1) != 'term') {
    return FALSE;
  }

  $term = menu_get_object('taxonomy_term', 2);

  if (!$term) {
    return FALSE;
  }
  if (empty($term->periodical_issue_date)) {
    return FALSE;
  }

  return $term;
}


/**
 * Implement hook_views_api
 */
function periodical_views_api() {
  if (module_exists('views_bulk_operations')) {
    return array("version" => "3.0");
  }
}


/**
 * Implement hook_field_formatter_info().
 */
function periodical_field_formatter_info() {
  return array(
    'periodical_zero_padding' => array(
      'label' => t('Zero padded'),
      'field types' => array('number_integer'),
      'settings' =>  array(
        'zero_padding' => 2,
      ),
    ),
  );
}


/**
 * Implements hook_field_formatter_settings_form().
 */
function periodical_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  if ($display['type'] == 'periodical_zero_padding') {
    $element['zero_padding'] = array(
      '#type' => 'textfield',
      '#title' => t('Zero padding'),
      '#default_value' => $settings['zero_padding'],
      '#description' => t('The amount of left zero padding.'),
    );
  }

  return $element;
}


/**
 * Implements hook_field_formatter_settings_summary().
 */
function periodical_field_formatter_settings_summary($field, $instance, $view_mode) {
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];

  if ($display['type'] == 'periodical_zero_padding') {
    $value = str_pad('7', $settings['zero_padding'], '0', STR_PAD_LEFT);
    return t('Display value with left-zero padding such that it always has at least %digits digits. For example %value.', array('%digits' => $settings['zero_padding'], '%value' => $value));
  }
}


/**
 * Implements hook_field_formatter_view().
 */
function periodical_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  $settings = $display['settings'];

  switch ($display['type']) {
    case 'periodical_zero_padding':
      foreach ($items as $delta => $item) {
        $element[$delta] = array('#markup' => str_pad($item['value'], $settings['zero_padding'], '0', STR_PAD_LEFT));
      }
      break;
  }

  return $element;
}


/**
 * Implement hook_query_TAG_alter
 *
 * Optionally alter term order by joining against periodical issue date or num
 * field.
 */
function periodical_query_term_access_alter(QueryAlterableInterface $query) {
  if (!periodical_vocabularies_exist()) {
    return;
  }

  $alter_order_method = variable_get('periodical_alter_term_order',
    PERIODICAL_ALTER_TERM_ORDER_DATE_DESC);

  if ($alter_order_method != PERIODICAL_ALTER_TERM_ORDER_NO) {
    // Figure out the table alias for taxonomy_term_data
    $term_data_alias = FALSE;
    foreach ($query->getTables() as $table) {
      if ($table['table'] == 'taxonomy_term_data') {
        $term_data_alias = $table['alias'];
        break;
      }
    }
    if (!$term_data_alias) {
      return;
    }

    // FIXME: A join is introduced for every vocabulary. Probably we may
    // try to get hold of the condition (t.vid = ?) and only continue if the
    // vocabulary in question actually is enabled for periodical.

    // Examine orderby clause
    $orderby =& $query->getOrderBy();
    if (!isset($orderby[$term_data_alias . '.name'])) {
      return;
    }

    switch($alter_order_method) {
    case PERIODICAL_ALTER_TERM_ORDER_DATE_DESC:
      $order_direction = 'DESC';
      $order_field = 'periodical_issue_date';
      break;
    case PERIODICAL_ALTER_TERM_ORDER_DATE_ASC:
      $order_direction = 'ASC';
      $order_field = 'periodical_issue_date';
      break;
    case PERIODICAL_ALTER_TERM_ORDER_NUM_DESC:
      $order_direction = 'DESC';
      $order_field = 'periodical_issue_num';
      break;
    case PERIODICAL_ALTER_TERM_ORDER_NUM_ASC:
      $order_direction = 'ASC';
      $order_field = 'periodical_issue_num';
      break;
    default:
      return;
    }

    // add the proper join and filter clause for ordering by date
    $query->addJoin('LEFT OUTER', 'field_data_' . $order_field, 'fpid',
      $term_data_alias . '.tid = fpid.entity_id AND fpid.entity_type = :entity_type',
      array(':entity_type' => 'taxonomy_term'));

    // copy orderby array and remove all elements
    $oldorderby = $orderby;
    while(count($orderby)) {
      array_shift($orderby);
    }

    // insert new orderby clause before t.name
    foreach ($oldorderby as $field => $direction) {
      if ($field == $term_data_alias . '.name') {
        $orderby['fpid.' . $order_field . '_value'] = $order_direction;
      }
      $orderby[$field] = $direction;
    }
  }
}


/**
 * Return a list of vocabularies which are enabled for periodical issues.
 */
function periodical_get_enabled_vocabularies() {
  $vocabularies = taxonomy_get_vocabularies();

  $enabled_vocabularies = array();
  foreach ($vocabularies as $vocabulary) {
    if (_periodical_fields_exist($vocabulary)) {
      $enabled_vocabularies[] = $vocabulary;
    }
  }

  return $enabled_vocabularies;
}


/**
 * Return true if there are any vocabularies enabled.
 */
function periodical_vocabularies_exist() {
  $result = variable_get('periodical_vocabularies_exist', NULL);

  if ($result === NULL) {
    $result = count(periodical_get_enabled_vocabularies()) > 0;
    variable_set('periodical_vocabularies_exist', $result);
  }

  return $result;
}


/**
 * Check if any vocabularies exist and store result in variable.
 */
function periodical_vocabularies_exist_reset() {
  variable_del('periodical_vocabularies_exist');
}


/**
 * Creates fields and instances for periodical issues on a given vocabulary
 */
function _periodical_fields_create($vocabulary) {
  // Create the fields if needed.
  $date_field = field_read_field('periodical_issue_date',
    array('include_inactive' => TRUE));
  if (!$date_field) {
    $date_field = array(
      'field_name' => 'periodical_issue_date',
      'type' => 'date',
      'entity_types' => array('taxonomy_term'),
      'settings' => array(
        'repeat' => 0,
        'granularity' => array('year', 'month', 'day'),
        'tz_handling' => 'none',
      ),
    );
    field_create_field($date_field);
  }

  $number_field = field_read_field('periodical_issue_num',
    array('include_inactive' => TRUE));
  if (!$number_field) {
    $number_field = array(
      'field_name' => 'periodical_issue_num',
      'type' => 'number_integer',
      'entity_types' => array('taxonomy_term'),
    );
    field_create_field($number_field);
  }

  // Create the instances if needed.
  $bundle = $vocabulary->machine_name;

  $date_instance = field_read_instance('taxonomy_term',
    'periodical_issue_date', $bundle, array('include_inactive' => TRUE));
  if (!$date_instance) {
    field_attach_create_bundle('taxonomy_term', $bundle);

    $date_instance = array(
      'field_name' => 'periodical_issue_date',
      'label' => 'Issue Date',
      'entity_type' => 'taxonomy_term',
      'bundle' => $bundle,
      'required' => TRUE,
    );
    field_create_instance($date_instance);
  }

  $number_instance = field_read_instance('taxonomy_term',
    'periodical_issue_num', $bundle, array('include_inactive' => TRUE));
  if (!$number_instance) {
    field_attach_create_bundle('taxonomy_term', $bundle);

    $number_instance = array(
      'field_name' => 'periodical_issue_num',
      'label' => 'Issue Number',
      'entity_type' => 'taxonomy_term',
      'bundle' => $bundle,
      'required' => TRUE,
    );
    field_create_instance($number_instance);
  }
}

/**
 * Return true if fields and instances for periodicals are present on the given
 * vocabulary.
 */
function _periodical_fields_exist($vocabulary) {
  $bundle = $vocabulary->machine_name;
  $date_instance = field_read_instance('taxonomy_term',
    'periodical_issue_date', $bundle, array('include_inactive' => TRUE));
  $number_instance = field_read_instance('taxonomy_term',
    'periodical_issue_num', $bundle, array('include_inactive' => TRUE));
  return $date_instance != NULL && $number_instance != NULL;
}

/**
 * Disables periodical issues for the given vocabulary and mark field data
 * for later removal.
 */
function _periodical_fields_disable($vocabulary) {
  $bundle = $vocabulary->machine_name;
  $date_instance = field_read_instance('taxonomy_term',
    'periodical_issue_date', $bundle, array('include_inactive' => TRUE));
  if ($date_instance) {
    field_delete_instance($date_instance, TRUE);
  }

  $number_instance = field_read_instance('taxonomy_term',
    'periodical_issue_num', $bundle, array('include_inactive' => TRUE));
  if ($number_instance) {
    field_delete_instance($number_instance, TRUE);
  }
}

/**
 * Work around a strange issue with relative dates:
 * DateObject::format(DATE_FORMAT_ISO) returns an empty string if no
 * granularity is set.
 */
function _periodical_fix_granularity(&$date) {
  if (!$date->hasGranularity()) {
    $date->granularity =
      array('year', 'month', 'day', 'hour', 'minute', 'second');
  }
}

/**
 * Implements hook_field_delete_field().
 */
function periodical_field_delete_field($field) {
  if (substr($field['field_name'], 0, 11) == 'periodical_') {
    periodical_vocabularies_exist_reset();
  }
}

/**
 * Implements hook_field_create_field().
 */
function periodical_field_create_field($field) {
  if (substr($field['field_name'], 0, 11) == 'periodical_') {
    periodical_vocabularies_exist_reset();
  }
}
