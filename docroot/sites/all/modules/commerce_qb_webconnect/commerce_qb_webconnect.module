<?php

// status codes
define('CQBWC_PENDING', 1);
define('CQBWC_DONE', 0);
define('CQBWC_ERROR', -1);

// WSDL. Intuit doesn't seem to host it anymore at this path.
// To keep things from breaking, we have moved it in the module.
//define('QBWC_WSDL', 'http://developer.intuit.com/uploadedFiles/Support/QBWebConnectorSvc.wsdl');
define('QBWC_WSDL', 'file://' . $_SERVER['DOCUMENT_ROOT'] . '/' . drupal_get_path('module', 'commerce_qb_webconnect') . '/QBWebConnectorSvc.wsdl');

/*
 * Implements hook_hook_info().
 */
function commerce_qb_webconnect_hook_info() {
  $hooks = array(
    'commerce_qb_webconnect_export_info' => array(
      'group' => 'qb'
    ),
    'commerce_qb_webconnect_export_info_alter' => array(
      'group' => 'qb'
    ),
    'commerce_qb_webconnect_order_customer_alter' => array(
      'group' => 'qb'
    ),
    'commerce_qb_webconnect_qbxml_alter' => array(
      'group' => 'qb'
    ),
    'commerce_qb_webconnect_order_products_alter' => array(
      'group' => 'qb'
    )
  );

  return $hooks;
}

/**
 * Implementation of hook_server_info().
 *
 * Since the Quickbooks client does not follow the canonical format for {resource}_soap_{method},
 * it is necessary to implement our own SOAP server, forked from the Soap Server module.
 */
function commerce_qb_webconnect_server_info() {
  return array(
    'name' => 'Quickbooks SOAP',
  );
}

/*
 * Implements hook_views_api().
 */
function commerce_qb_webconnect_views_api() {
  return array(
    'api' => '3.0-alpha1',
    'path' => drupal_get_path('module', 'commerce_qb_webconnect') . '/views',
  );
}

/*
 * Implements hook_theme().
 */
function commerce_qb_webconnect_theme() {
  $theme = array();
  $info = commerce_qb_webconnect_export_info();

  // Add theme templates for export types defining a template
  foreach ($info as $export_type => $export_info) {
    if (isset($export_info['template'])) {
      $theme['commerce_qb_webconnect_' . $export_type] = array(
        'variables' => $export_info['template_vars'],
        'path' => isset($export_info['template_path']) ? $export_info['template_path'] : null,
        'template' => $export_info['template']
      );
    }
  }

  // QBXML wrapper
  $theme['commerce_qb_webconnect_wrap_qbxml'] = array(
    'variables' => array('qbxml' => null)
  );

  return $theme;
}

/**
 * Implements hook_server().
 *
 * @see hook_server_info()
 */
function commerce_qb_webconnect_server() {
  $info =  services_server_info_object();
  $endpoint = services_endpoint_load($info->endpoint);

  $get = $_GET;
  // Serve the WSDL if ?wsdl is appended to the URL.
  if (in_array('wsdl', array_keys($get))) {
    // print quickbooks wsdl
    commerce_qb_webconnect_wsdl_output();
  }
  // Disable the WSDL cache so it's not stored in memory or on disk.
  ini_set("soap.wsdl_cache_enabled", "0");
  $wsdl_url = QBWC_WSDL;

  try {
    $server = new SoapServer($wsdl_url);
    $server->setClass('CommerceQBWebconnectSoapServer');
    $server->handle();
  }
  catch (Exception $e) {
    watchdog('Commerce Quickbooks Webconnect', $e->getMessage(), array(), 'error');
  }

  exit;
}

/**
 * Delivers XML suitable for supplying WSDL to Quickbooks Soap clients.
 */
function commerce_qb_webconnect_wsdl_output() {
  ob_end_clean();
  drupal_add_http_header('Connection', 'close');
  drupal_add_http_header('Content-Length', drupal_strlen($wsdl_content));
  drupal_add_http_header('Content-Type', 'application/wsdl+xml; charset=utf-8');
  drupal_add_http_header('Date', date('r'));
  print file_get_contents(QBWC_WSDL);
  exit;
}

/**
 * Soap Server 3 Class for handling soap requests.
 *
 * This function is copied almost verbatim from the soap server module, except that
 * we use commerce_qb_webconnect as the resource name in the soap method invocation,
 * since quickbooks does not prefix its methods with a resource.
 */
class CommerceQBWebconnectSoapServer {
  public function __call($method_name, $args) {
    global $user;

    // Handle the request.
    $info =  services_server_info_object();
    module_load_include('inc', 'commerce_qb_webconnect', 'commerce_qb_webconnect.logging');

    $endpoint = services_endpoint_load($info->endpoint);

    // this is the only line that differs from the soap server implementation
    $services_method_name = 'commerce_qb_webconnect.' . $method_name;

    $controller = services_controller_get($services_method_name, $endpoint->name);
    // make sure any arguments not passed have default values inserted if they are supplied
    // TODO: should we be validating argument types here?
    foreach ($controller['args'] as $key => $arg_config) {
      if (!isset($args[$key]) && isset($arg_config['default value'])) {
        $args[$key] = $arg_config['default value'];
      }
    }

    try {
      $ret = services_controller_execute($controller, $args);
    }
    catch (Exception $e) {
      $code = $e->getCode();
      $soap_fault = new SoapFault($e->getMessage(), $code);
      watchdog('Commerce Quickbooks Webconnect', $e->getMessage(), array(), 'error');
      throw $soap_fault;
    }
    return $ret;

  }
}

/*
 * Implements hook_permission()
 */
function commerce_qb_webconnect_permission() {
  return array(
    'access quickbooks SOAP' => array(
      'title' => t('Access Quickbooks SOAP'),
      'description' => t('Authenticate with Quickbooks resources through SOAP endpoints.'),
    ),
    'administer qb webconnect' => array(
      'title' => t('Administer Commerce QB Webconnect'),
      'description' => t('Change config and logging settings for Commerce QB Webconnect.'),
    ),
  );
}

/*
 * Implements hook_services_resources()
 */
function commerce_qb_webconnect_services_resources() {

  // Due to a peculiarity of the services module + qbwc wsdl, the request always comes in as a stdClass object
  $request_args = array(
    array(
      'name' => 'request',
      'type' => 'struct',
      'description' => 'standard request object',
      'source' => array('param'),
      'optional' => FALSE,
    ),
  );

  return array(
    'commerce_qb_webconnect' => array(
      'actions' => array(
        'serverVersion' => array(
          'help' => 'Send the server version to client',
          'callback' => 'commerce_qb_webconnect_qb_serverVersion',
          'access arguments' => array('access content'),
          'args' => $request_args
        ),
        'clientVersion' => array(
          'help' => 'Check client version',
          'callback' => 'commerce_qb_webconnect_qb_clientVersion',
          'access arguments' => array('access content'),
          'args' => $request_args
        ),
        'authenticate' => array(
          'help' => 'Authenticate and initiate session with client',
          'callback' => 'commerce_qb_webconnect_qb_authenticate',
          'access arguments' => array('access content'),
          'args' => $request_args
        ),
        'sendRequestXML' => array(
          'help' => 'Send data back to client',
          'callback' => 'commerce_qb_webconnect_qb_sendRequestXML',
          'access arguments' => array('access content'),
          'args' => $request_args
        ),
        'receiveResponseXML' => array(
          'help' => 'Get response from last quickbooks operation',
          'callback' => 'commerce_qb_webconnect_qb_receiveResponseXML',
          'access arguments' => array('access content'),
          'args' => $request_args
        ),
        'getLastError' => array(
          'help' => 'Quickbooks error handler',
          'callback' => 'commerce_qb_webconnect_qb_getLastError',
          'access arguments' => array('access content'),
          'args' => $request_args
        ),
         'closeConnection' => array(
          'help' => 'Close the connection',
          'callback' => 'commerce_qb_webconnect_qb_closeConnection',
          'access arguments' => array('access content'),
          'args' => $request_args
        ),
      ),
    ),
  );
}

/*
 * Implements hook_menu().
 */
function commerce_qb_webconnect_menu() {
  $items['admin/commerce/config/commerce_qb_webconnect'] = array(
    'title' => 'Commerce QB Webconnect settings',
    'description' => 'Logging and configuration settings for Commerce QB Webconnect.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_qb_webconnect_admin_form'),
    'file' => 'commerce_qb_webconnect.admin.inc',
    'access arguments' => array('administer qb webconnect'),
    'type' => MENU_NORMAL_ITEM
  );

  $items['admin/commerce/qb-exports'] = array(
    'title' => 'Manage Quickbooks Exports',
    'description' => 'View and manage quickbooks exports.',
    'page callback' => 'commerce_qb_webconnect_manage',
    'access arguments' => array('administer qb webconnect'),
    'file' => 'commerce_qb_webconnect.admin.inc',
  );

  return $items;
}

/*
 * Implements hook_entity_info()
 */
function commerce_qb_webconnect_entity_info() {
  return array(
    'commerce_qb_webconnect_qb_export' => array(
      'label' => t('Quickbooks export item'),
      'entity class' => 'Entity',
      'controller class' => 'CommerceQbWebconnectQbExportEntityController',
      'load hook' => 'commerce_qb_webconnect_qb_export_load',
      'views controller class' => 'EntityDefaultViewsController',
      'base table' => 'commerce_qb_exports',
      'module' => 'commerce_qb_webconnect',
      'label callback' => 'commerce_qb_webconnect_qb_export_label',
      'entity keys' => array(
        'id' => 'id',
      ),
    ),
  );
}

/**
 * Finds all exports with a failed status code and resets the status code.
 * Status code gets changed to a pending state.
 */
function commerce_qb_webconnect_reset_failed_exports(){
  $num_updated = db_update('commerce_qb_exports')
    ->fields(array(
      'status_code' => CQBWC_PENDING,
      'exported' => 0,
    ))
    ->condition('status_code', CQBWC_ERROR, '=')
    ->execute();

  return $num_updated;
}

/**
 * Loads an export by ID.
 */
function commerce_qb_webconnect_qb_export_load($id) {
  $exports = commerce_qb_webconnect_qb_export_load_multiple(array($id), array());
  return $exports ? reset($exports) : FALSE;
}

/*
 * Standard ENTITY_TYPE_load_multiple function
 */
function commerce_qb_webconnect_qb_export_load_multiple($export_ids = array(), $conditions = array(), $reset = FALSE) {
  $exports = entity_load('commerce_qb_webconnect_qb_export', $export_ids, $conditions, $reset);
  return $exports;
}

/*
 * Entity-based save function for QB exports. Automatically deals with encoding JSON data.
 */
function commerce_qb_webconnect_qb_export_entity_save($export) {
  if (is_object($export->data) || is_array($export->data)) {
    $export->data = drupal_json_encode($export->data);
  }

  return entity_save('commerce_qb_webconnect_qb_export', $export);
}

/**
 * Determine if a specified export type is exportable by user configuration
 *
 * @param string $type
 *  Type of export
 *  @see hook_commerce_qb_webconnect_export_info()
 *
 * @return boolean
 *  True if type is exportable
 */
function commerce_qb_webconnect_exportable_enabled($type) {
  $exportables = variable_get('commerce_qb_webconnect_exportables', array());

  if (isset($exportables[$type]) && $exportables[$type]) {
    return TRUE;
  }
}

/*
 * Implements hook_commerce_product_insert().
 */
function commerce_qb_webconnect_commerce_product_insert($product) {
  $product_type = variable_get('commerce_qb_webconnect_product_type', 'add_non_inventory_product');

  if (commerce_qb_webconnect_exportable_enabled($product_type)) {
    commerce_qb_webconnect_qb_export_save($product_type, $product);
  }
}

/*
 * Implements hook_commerce_product_delete().
 */
function commerce_qb_webconnect_commerce_product_delete($product) {
  $product_type = variable_get('commerce_qb_webconnect_product_type', 'add_non_inventory_product');

  if (commerce_qb_webconnect_exportable_enabled($product_type)) {
    commerce_qb_webconnect_purge_export($product_type, $product);
  }
}

/*
 * Implements hook_commerce_product_update().
 */
function commerce_qb_webconnect_commerce_product_update($product) {
  $product_type = variable_get('commerce_qb_webconnect_product_type', 'add_non_inventory_product');

  if (commerce_qb_webconnect_exportable_enabled($product_type)) {
    commerce_qb_webconnect_rebase_export($product_type, $product);
  }
}

/*
 * Implements hook_commerce_order_insert().
 */
function commerce_qb_webconnect_commerce_order_insert($order) {
  if (commerce_qb_webconnect_status_is_exportable($order->status)) {
    $order_export_type = variable_get('commerce_qb_webconnect_order_export_type', 'add_sales_receipt');

    // create the appropriate type of export for orders
    if (commerce_qb_webconnect_exportable_enabled($order_export_type)) {
      commerce_qb_webconnect_add_order_items($order, $order_export_type);
    }
  }
}

/*
 * Implements hook_commerce_order_delete().
 */
function commerce_qb_webconnect_commerce_order_delete($order) {
  if (commerce_qb_webconnect_exportable_enabled('add_invoice')) {

    // We delete the add_invoice export record associated with this order. However,
    // at this point we do not delete add_product and add_customer records associated
    // with the order, assuming that it is alright for Quickbooks for to be made aware of
    // new products and customers even though they haven't been associated with any orders.
    commerce_qb_webconnect_purge_export('add_invoice', $order);
  }
}

/*
 * Implements hook_commerce_order_update().
 */
function commerce_qb_webconnect_commerce_order_update($order) {

  // determine which type of Quickbooks export we need to create
  $order_export_type = variable_get('commerce_qb_webconnect_order_export_type', 'add_sales_receipt');

  if (!commerce_qb_webconnect_exportable_enabled($order_export_type)) {
    return;
  }

  $status_new_is_export = commerce_qb_webconnect_status_is_exportable($order->status);
  $status_original_is_export = commerce_qb_webconnect_status_is_exportable($order->original->status);

  // if we are going from non-exportable to exportable (e.g. checkout finished)
  if ($status_new_is_export && !$status_original_is_export) {

    // add the order and its referenced exportables
    commerce_qb_webconnect_add_order_items($order, $order_export_type);

  // if we are going from exportable to non-exportable (e.g. cancelling order)
  } else if ($status_original_is_export && !$status_new_is_export) {

    // We only delete the order, not the customer or the products.
    // @see commerce_qb_webconnect_commerce_order_delete().
    commerce_qb_webconnect_purge_export($order_export_type, $order);

  // if both old and new are export status, rebase and update (e.g. editing order manually)
  } else if ($status_new_is_export && $status_original_is_export) {
    commerce_qb_webconnect_rebase_order_exports($order, $order_export_type);
  }
}

/*
 * Implements hook_commerce_payment_transaction_insert().
 */
function commerce_qb_webconnect_commerce_payment_transaction_insert($transaction) {
  if (commerce_qb_webconnect_exportable_enabled('add_payment')
    && ($transaction->status == "success") 
    && ($transaction->amount > 0)) {
    commerce_qb_webconnect_qb_export_save('add_payment', $transaction);
  }
}

/*
 * Implements hook_commerce_payment_transaction_delete().
 */
function commerce_qb_webconnect_commerce_payment_transaction_delete($transaction) {
  if (commerce_qb_webconnect_exportable_enabled('add_payment')) {
    commerce_qb_webconnect_purge_export('add_payment', $transaction);
  }
}

/*
 * Implements hook_commerce_payment_transaction_update().
 */
function commerce_qb_webconnect_commerce_payment_transaction_update($transaction) {
  if (commerce_qb_webconnect_exportable_enabled('add_payment')) {
    commerce_qb_webconnect_rebase_export('add_payment', $transaction);
  }
}

/**
 * Determine whether a supplied order status is sufficient to trigger the creation
 * of an exportable.
 *
 * @param string $status
 *  Order status to check
 *
 * @return boolean
 *  True on success
 */
function commerce_qb_webconnect_status_is_exportable($status) {
  $export_statuses = variable_get('commerce_qb_webconnect_export_statuses', array());

  if (isset($export_statuses[$status]) && $export_statuses[$status]) {
    return TRUE;
  }
}

/**
 * Get a clean list of exportable statuses
 *
 * @return array
 *  List of statuses
 */
function commerce_qb_webconnect_exportable_statuses() {
  $export_statuses = variable_get('commerce_qb_webconnect_export_statuses', array());
  $return = array();

  // this variable comes from the system administration form with zeroes
  foreach ($export_statuses as $status) {
    if ($status) {
      $return[] = $status;
    }
  }

  return $return;
}

/**
 * Remove an export record for a specified data structure (e.g. product, customer,
 * order) and a type, then add it again with updated values.
 *
 * @param type $item_type
 *  Type of export item to rebase
 *  @see commerce_qb_webconnect_export_info().
 *
 * @param type $data
 *  Data structure of entity that needs to be rebased
 */
function commerce_qb_webconnect_rebase_export($item_type, $data) {

  // delete only pending exports. If an item has already been exported,
  // it is too late to change it
  commerce_qb_webconnect_purge_export($item_type, $data);

  // add the export record again
  commerce_qb_webconnect_qb_export_save($item_type, $data);
}
/**
 * Delete add_order and add_customer exportables for an order
 *
 * @param type $order
 *  Target commerce_order entity
 */
function commerce_qb_webconnect_rebase_order_exports($order, $type) {

  // Delete old add_invoice and add_customer associated with this order. Leave
  // add_products alone because product data will never change because of an order
  // update. Only delete any exports if the order export is found to be pending.
  if (commerce_qb_webconnect_purge_export($type, $order)) {

    // delete add_customer record for the original order
    $customer = commerce_qb_webconnect_get_order_customer($order->original);
    commerce_qb_webconnect_purge_export('add_customer', $customer);
  }

  // Add order again based on current entity data
  commerce_qb_webconnect_add_order_items($order, $type);
}

/**
 * Deletes an export related for single Quickbooks export represented by $data, of
 * type $export_type
 *
 * @param type $export_type
 *  Type of Quickbooks entity to delete
 *  @see commerce_qb_webconnect_export_info()
 *
 * @param type $data
 *  The data structure represented by the export
 *
 * @return boolean
 *  True if export found to delete
 */
function commerce_qb_webconnect_purge_export($export_type, $data, $statuses = array(CQBWC_PENDING)) {
  $info = commerce_qb_webconnect_export_info();
  module_load_include('inc', 'commerce_qb_webconnect', 'commerce_qb_webconnect.qb');

  $item_id = commerce_qb_webconnect_unique_id($export_type, $data);

  // delete the order export record
  return commerce_qb_webconnect_purge_export_by_item_id($export_type, $item_id, $statuses);
}

/**
 * Add export items for an order and all of its products, and its related customer.
 * May add either a sales receipt or an invoice
 *
 * @param commerce_order $order
 *  The order for which to add items
 */
function commerce_qb_webconnect_add_order_items($order, $export_type) {
  $supported = array(
    'add_invoice',
    'add_sales_receipt'
  );

  if (!in_array($export_type, $supported)) {
    return;
  }

  // Combine billing and shipping into one customer record for Quickbooks and create
  // export record (needs done before order)
  $customer = commerce_qb_webconnect_get_order_customer($order);
  commerce_qb_webconnect_qb_export_save('add_customer', $customer);

  $products = commerce_qb_webconnect_line_item_products($order);

  $product_type = variable_get('commerce_qb_webconnect_product_type', 'add_non_inventory_product');

  // make sure all products in the order get exported
  if ($products) {
    foreach ($products as $product) {
      commerce_qb_webconnect_qb_export_save($product_type, $product);
    }
  }


  // add the order itself to be exported as a Quickbooks invoice
  commerce_qb_webconnect_qb_export_save($export_type, $order);
}

/**
 * Retrieve an array containing all information needed to make a new customer in Quickbooks
 *
 * @param type $order
 * @return type
 */
function commerce_qb_webconnect_get_order_customer($order) {
  $profile_types = commerce_customer_profile_types();

  // load the information in each customer profile group into a single array
  foreach ($profile_types as $name => $profile_type) {
    $field_name = 'commerce_customer_' . $name;
    $lang = field_language('commerce_order', $order, $field_name);

    if (isset($order->{$field_name}[$lang])) {
      $customer[$name] = commerce_customer_profile_load($order->{$field_name}[$lang][0]['profile_id']);
    }
  }

  // add the email from the order
  $customer['mail'] = $order->mail;

  drupal_alter('commerce_qb_webconnect_order_customer', $customer, $order);

  return $customer;
}

/**
 * Delete a Quickbooks export entity
 *
 * @param string $item_id
 *  Unique item_id of the export
 *
 * @param type $item_type
 *  Type of the export
 *
 * @return boolean
 *  True if export found to delete
 */
function commerce_qb_webconnect_purge_export_by_item_id($item_type, $item_id, $statuses = array(CQBWC_PENDING)) {
  $query = new EntityFieldQuery;

  $results = $query->entityCondition('entity_type', 'commerce_qb_webconnect_qb_export')
                   ->propertyCondition('item_id', $item_id)
                   ->propertyCondition('item_type', $item_type)
                   ->propertyCondition('status_code', $statuses)
                   ->execute();

  if (isset($results['commerce_qb_webconnect_qb_export'])) {
    entity_delete_multiple('commerce_qb_webconnect_qb_export', array_keys($results['commerce_qb_webconnect_qb_export']));

    return TRUE;
  }
}

/*
 * Quickbooks RPC callbacks
 *
 * See http://developer.intuit.com/qbsdk-current/doc/pdf/qbwc_proguide.pdf
 *
 * The argument format for these functions is different than the examples shown in the
 * manual above.
 *
 * The key convention to follow is that you return a stdClass object with one property
 * named [quickbooks method name]Result that contains an array/string formatted like the
 * QBWC specs say. This seems to be the only way to send back responses that QBWC can
 * interpret.
 */

/*
 * Return the server version to the client. Runs pre-authentication.
 */
function commerce_qb_webconnect_qb_serverVersion($request) {
  cqbc_log_block_start();
  cqbc_log_write('Method: [serverVersion] called');
  $return->serverVersionResult = '1.0';
  return $return;
}

/*
 * Authenticate client. Unique token is a drupal session id. Uses standard drupal
 * authentication procedure.
 */
function commerce_qb_webconnect_qb_authenticate($request) {
  cqbc_log_write('Method: [authenticate] called');
  $strUserName = $request->strUserName;
  $strPassword = $request->strPassword;

  $path = drupal_get_path('module', 'services');
  require_once $path . '/resources/user_resource.inc';

  $login = _user_resource_login($strUserName, $strPassword);

  if ($login->sessid) {
    $retVal = array($login->sessid, '');
    $retVal = array($strUserName . "|" . $strPassword, '');
    cqbc_log_write('User ' . $strUserName . ' authenticated');
    commerce_qb_webconnect_reset_failed_exports();
  } else {
    $retVal = array(session_id(), 'nvu');
    cqbc_log_write('User ' . $strUserName . ' failed to authenticate');
  }

  $return->authenticateResult = $retVal;
  return $return;
}

/*
 * Return the client version to the server. Runs pre-authentication.
 */
function commerce_qb_webconnect_qb_clientVersion($request) {
  $strVersion = $request->strVersion;
  cqbc_log_write('Method: [clientVersion] called');

  $return->clientVersionResult = '';
  return $return;
}

/*
 * Sends a procedure request back to the server using QBXML. Requires authentication.
 *
 * See http://developer.intuit.com/qbSDK-current/OSR/OnscreenRef/index-QBD.html (use
 * IE to view this page).
 */
function commerce_qb_webconnect_qb_sendRequestXML($request) {
  $sid = $request->ticket;
  cqbc_log_write('Method: [sendRequestXML] called');

  if (!commerce_qb_webconnect_check_session($sid)) {
    return false;
  }

  cqbc_log_write('Searching for next export ...');
  $item = commerce_qb_webconnect_get_next_export();

  if ($item) {
    cqbc_log_write($item->item_type . ' found');

    // send to xml render procedure
    cqbc_log_write('Rendering qbxml ...');
    $qbxml = commerce_qb_webconnect_qbxml($item);
    cqbc_log_write('QBXML: ', $qbxml);
    cqbc_log_write('qbxml rendered successfully');

    if ($qbxml) {
      $value = $qbxml;
    }
  } else {
    cqbc_log_write('No export found, jobs finished');
    $value = '';
  }

  $return->sendRequestXMLResult = $value;
  return $return;
}

/*
 * Request containing information about last procedure initiated by sendRequestXML. Requires
 * authentication.
 */
function commerce_qb_webconnect_qb_receiveResponseXML($request) {
  $success = TRUE;
  $retry = FALSE;
  $sid = $request->ticket;
  cqbc_log_write('Method: [receiveResponseXML] called');

  if (!commerce_qb_webconnect_check_session($sid)) {
    return false;
  }

  // log any errors found

  //find out which item the response pertains to
  $item = commerce_qb_webconnect_get_next_export();

  if ($item) {
    $error = cqbc_qbxml_parse_error($request);
    foreach($error AS $errorInfo) {
      $error_msg = t("Response error statusCode:\nstatusMessage\n", $errorInfo);

      //Log error with export item data detail
      watchdog('Commerce Quickbooks Webconnect', nl2br($error_msg) . "<pre>" . var_export($item->data, true) . "</pre>", NULL, WATCHDOG_ERROR);

      //When logging $error_data is redundant as sendRequestXML is logged first
      cqbc_log_write(strip_tags(htmlspecialchars_decode($error_msg)));

      //Ignore statusCode 3100 (Already exists)
      if ($errorInfo['statusCode'] == "3100") {
        continue;
      }

      // 3180 is a temporary error with no clear reason. Just retry it.
      if ($errorInfo['statusCode'] == "3180") {
        $retry = TRUE;
      }
      $success = FALSE;
    }

    if (!$retry) {
      $qb_export = commerce_qb_webconnect_next_in_queue($item->item_type);
      commerce_qb_webconnect_qb_export_complete($qb_export, $success);
    }
    $return->receiveResponseXMLResult = 1;
  } else {
    $return->receiveResponseXMLResult = 100;
  }

  return $return;
}

/*
 * Called if sendRequestXML or receiveResponseXML returns an error code. Requires authentication.
 * This function seems to actually get called at the end of every request cycle.
 */
function commerce_qb_webconnect_qb_getLastError($request) {
  cqbc_log_write('Method: [getLastError] called');
  $sid = $request->ticket;

  if (!commerce_qb_webconnect_check_session($sid)) {
    return false;
  }

  $remaining = commerce_qb_webconnect_qb_exports_pending();

  if ($remaining < 1) {
    $return->getLastErrorResult = 'No jobs remaining';
  }

  return $return;
}

/*
 * Close the connection to the QBWC client.
 */
function commerce_qb_webconnect_qb_closeConnection($request) {
  cqbc_log_write('Method: [closeConnection] called');
  $sid = $request->ticket;

  if (!commerce_qb_webconnect_check_session($sid)) {
    cqbc_log_block_end();
    return false;
  }

  // allow connection to close
  $return->closeConnectionResult = 'OK';
  cqbc_log_block_end();
  return $return;
}

/* Helper functions */

/**
 * Determine whether or not session is valid and user has access to quickbooks SOAP permission
 *
 * @global object $user
 *   user object
 *
 * @param string $sid
 *   session token
 *
 * @return boolean
 */
function commerce_qb_webconnect_check_session($sid) {
  global $user;
  $sessionPieces = explode("|", $sid);
  $strUserName = $sessionPieces[0];
  $strPassword = $sessionPieces[1];

  $path = drupal_get_path('module', 'services');
  require_once $path . '/resources/user_resource.inc';

  $login = _user_resource_login($strUserName, $strPassword);

  if ($login->sessid) {
    if (user_access('access quickbooks SOAP', $login->user)) {
      return TRUE;
    }
  }
  cqbc_log_write('User session invalid');
}


/**
 * Wraps string in qbxml starting and ending tags
 *
 * @param string $qbxml
 *   xml to wrap
 *
 * @return string
 *   wrapped output
 */
function theme_commerce_qb_webconnect_wrap_qbxml($variables) {
  $qbxml = $variables['qbxml'];
  $output = '<?xml version="1.0" encoding="utf-8"?>
  <?qbxml version="7.0"?>
<QBXML>
  <QBXMLMsgsRq onError="stopOnError">' . $qbxml .
  '</QBXMLMsgsRq>
</QBXML>';

  return $output;
}

/*
 * Standard comparison function to sort export types by weight
 */
function commerce_qb_webconnect_export_type_weight_sort($a, $b) {
  if (isset($a['weight']) && isset($b['weight'])) {
    if ($a['weight'] > $b['weight']) {
      return 1;
    } else if ($a['weight'] < $b['weight']) {
      return -1;
    } else {
      return 0;
    }
  }

  return 0;
}

/**
 * Finds next qb export item to be processed. Since Quickbooks requires that customers
 * exist before adding references to them in invoices, this function has to make sure
 * that all pending customers have been imported before importing invoices.
 *
 * @return object
 *   qb export entity
 */
function commerce_qb_webconnect_get_next_export() {
  $info = commerce_qb_webconnect_export_info();

  uasort($info, 'commerce_qb_webconnect_export_type_weight_sort');

  // set priority order for types
  $priority_types = array_keys($info);

  // loop through types in priority order
  foreach ($priority_types as $type) {

    // find the qb export entity
    $qb_export = commerce_qb_webconnect_next_in_queue($type);

    if ($qb_export) {
      return $qb_export;
    }
  }
}

/**
 * Get all orders with exportable statuses
 *
 * @return array
 *  List of commerce_order entities
 */
function commerce_qb_webconnect_exportable_orders() {
  $export_statuses = commerce_qb_webconnect_exportable_statuses();

  $query = new EntityFieldQuery;

  $results = $query->entityCondition('entity_type', 'commerce_order')
                   ->propertyCondition('status', $export_statuses)
                   ->execute();

  if ($results) {
    $order_ids = array_keys($results['commerce_order']);

    return commerce_order_load_multiple($order_ids);
  } else {
    return FALSE;
  }
}

/*
 * Finished callback for update exports table action
 */
function commerce_qb_webconnect_batch_export_update_finished($success, $results, $operations) {
  $count = count($results);
  $msg = $count > 0 ? t($count . ' export records added.') : t('Export table already up to date.');

  drupal_set_message(check_plain(t('Batch update finished.') . ' ' . $msg));
}

/*
 * Operation callback for batch export update
 */
function commerce_qb_webconnect_qb_export_batch_save($type, $entity, &$context) {
  $export = commerce_qb_webconnect_qb_export_save($type, $entity);

  // handle order customers
  if ($type == 'add_invoice') {
    $customer = commerce_qb_webconnect_get_order_customer($entity);

    if ($customer) {
      $context['results'][] = commerce_qb_webconnect_qb_export_save('add_customer', $customer);
    }
  }

  if($export) {
    $context['results'][] = $export;
  }
}

/**
 * Finds either next item in queue, or next item of specified type in queue, provided
 * that the item is configured to be exportable.
 *
 * @param string $type
 *   value found in item_type column, or null for all records pending
 *
 * @return array
 *
 */
function commerce_qb_webconnect_next_in_queue($type = null) {
  if (!commerce_qb_webconnect_exportable_enabled($type)) {
    return;
  }

  // set entity type
  $items_query = new EntityFieldQuery;
  $items_query->entityCondition('entity_type', 'commerce_qb_webconnect_qb_export', '=')
              ->propertyCondition('status_code', CQBWC_PENDING, '=')
              ->range(null, 1);

  if ($type) {
    $items_query->propertyCondition('item_type', $type, '=');
  }

  // run query
  $items = $items_query->execute();

  if ($items) {
    $keys = array_keys($items['commerce_qb_webconnect_qb_export']);
    $id = $keys[0];

    // load full entity referenced
    $entity = entity_load('commerce_qb_webconnect_qb_export', array($id));
    return $entity[$id];
  }
}

/*
 * Render the QBXML to be sent as a response to the sendRequestXML RPC
 */
function commerce_qb_webconnect_qbxml($export) {
  $info = commerce_qb_webconnect_export_info();

  $callback = $info[$export->item_type]['callback'];

  if (function_exists($callback)) {

    // first argument is the export data
    $args = array($export->data, $export->item_type);

    // add arguments supplied by other modules
    if (isset($info[$export->item_type]['callback_args'])) {
      $args += $info[$export->item_type]['callback_args'];
    }

    // render xml
    $result = call_user_func_array($callback, $args);

    if (isset($info[$export->item_type]['template']) && is_array($result)) {
      $qbxml = theme('commerce_qb_webconnect_' . $export->item_type, $result);
    } else {
      $qbxml = $result;
    }

    $qbxml = theme('commerce_qb_webconnect_wrap_qbxml', array('qbxml' => $qbxml));

    // allow other modules to alter the xml output
    drupal_alter('commerce_qb_webconnect_qbxml', $qbxml, $export->item_type, $export);

    return $qbxml;
  }
}

/**
 * Determine a unique id for an export. Only works on pre-save data, not data
 * retrieved and alter by drupal_json_decode.
 *
 * @param string $item_type
 *  Type of export record
 *
 * @param struct $data
 *  Data used to be used in unique id callback.
 *
 * @return string
 *  Unique item id
 */
function commerce_qb_webconnect_unique_id($item_type, $data) {
  $info = commerce_qb_webconnect_export_info($item_type);

  if (isset($info[$item_type])) {
    $item_id_callback = $info[$item_type]['unique_id_callback'];

    // determine the unique id
    if (function_exists($item_id_callback)) {
      $item_id = $item_id_callback($data);
    } else {
      return;
    }
  } else {
    return;
  }

  return $item_id;
}

/**
 * Check for uniqueness, and then write one qb export entity
 *
 * @param object $export
 *   export entity presave object
 *
 * @return boolean
 *   TRUE if no duplicate found
 */
function commerce_qb_webconnect_qb_export_save($item_type, $data, $op = 'insert', $status = CQBWC_PENDING) {
  $item_id = commerce_qb_webconnect_unique_id($item_type, $data);

  if (!$item_id) {
    return;
  }

  // check for uniqueness
  if ($op == 'insert') {
    $items_query = new EntityFieldQuery;
    $items_query->entityCondition('entity_type', 'commerce_qb_webconnect_qb_export')
                ->propertyCondition('item_type', $item_type)
                ->propertyCondition('item_id', $item_id)
                ->count();

    $count = $items_query->execute();

    if ($count > 0) {
      return;
    }
  }

  $export = array(
    'item_type' => $item_type,
    'item_id' => $item_id,
    'status_code' => $status,
    'data' => drupal_json_encode($data),
    'added' => REQUEST_TIME,
  );

  // write a new record
  $entity = entity_create('commerce_qb_webconnect_qb_export', $export);
  entity_save('commerce_qb_webconnect_qb_export', $entity);
  return $entity;
}

/*
 * Retrieve hook info for export types
 */
function commerce_qb_webconnect_export_info() {
  $info = &drupal_static(__FUNCTION__);

  if (!$info) {
    $info = module_invoke_all('commerce_qb_webconnect_export_info');

    // allow modules to alter the export info
    drupal_alter('commerce_qb_webconnect_export_info', $info);
  }

  return $info;
}

function commerce_qb_webconnect_payment_mapping_info() {
  $info = &drupal_static(__FUNCTION__);

  if (!$info) {
    $info = module_invoke_all('commerce_qb_webconnect_payment_mapping_info');

    // allow modules to alter the export info
    drupal_alter('commerce_qb_webconnect_payment_mapping_info', $info);
  }

  return $info;
}

/**
 * Retrieve the number of pending exports
 *
 * @return int
 *  Number of exports remaining
 */
function commerce_qb_webconnect_qb_exports_pending() {
  $items_query = new EntityFieldQuery;
  $items_query->entityCondition('entity_type', 'commerce_qb_webconnect_qb_export', '=')
              ->propertyCondition('status_code', CQBWC_PENDING, '=')
              ->count();

  $count = $items_query->execute();

  if (is_numeric($count)) {
    return $count;
  }
}

/**
 * Set a quickbooks export entity status code to done
 *
 * @param object $export
 *   qb export entity
 */
function commerce_qb_webconnect_qb_export_complete($export, $success = TRUE) {
  if ($success) {
    $export->status_code = CQBWC_DONE;
  } else {
    $export->status_code = CQBWC_ERROR;
  }
  $export->exported = REQUEST_TIME;

  // save the entity
  commerce_qb_webconnect_qb_export_entity_save($export);
}

/**
 * Get all line item products associated with an order entity
 * @todo use entity metadata wrapper for this (see commerce_qb_webconnect_line_item_shipping()).
 *
 * @param object $order
 *   order entity with line items
 *
 * @return array
 *   list of products, each given an extra quantity field normally associated with the line item
 */
function commerce_qb_webconnect_line_item_products($order, $array_key = 'product_id') {
  $lang = field_language('commerce_order', $order, 'commerce_line_items');
  $line_items = isset($order->commerce_line_items[$lang]) ? $order->commerce_line_items[$lang] : null;
  $products = array();

  if ($line_items) {
    foreach ($line_items as $line_item) {
      $line_item_id = $line_item['line_item_id'];
      $line_item_entity = commerce_line_item_load($line_item_id);
      $lang = field_language('commerce_line_item', $line_item_entity, 'commerce_product');

      if ($line_item_entity->type == 'product') {
        $product_id = $line_item_entity->commerce_product[$lang][0]['product_id'];
        $product = commerce_product_load($product_id);

        if ($product) {

          // either use product_id or line_item_id as a key
          $key = ($array_key == 'product_id') ? $product_id : $line_item_id;
          $products[$key] = $product;

          // insert quantity, initialize first for good measure.
          if (!isset($products[$key]->quantity)){
            $products[$key]->quantity = 0;
          } 
          $products[$key]->quantity += $line_item_entity->quantity;
        }
      }
    }
  }

  return $products;
}

/**
 * Retrieve shipping line items from an order
 *
 * @param stdClass $order
 *  Order to check
 *
 * @param bool $single
 *  Whether to return a list of all shipping line items or just one
 *
 * @return mixed
 *  Depending on state of $single, array or line_item entity
 */
function commerce_qb_webconnect_line_item_load($order, $type, $single = false){
  $info = entity_metadata_wrapper('commerce_order', $order);
  $line_items = $info->commerce_line_items->value();

  if ($line_items) {
    $shipping = array();

    foreach ($line_items as $line_item) {
      if ($line_item->type == $type) {
        $shipping[] = $line_item;
      }
    }

    if (!empty($shipping)) {
      return $single ? array_pop($shipping) : $shipping;
    }
  }
}

/*
 * Label callback for export entities
 */
function commerce_qb_webconnect_qb_export_label($entity) {
  $info = commerce_qb_webconnect_export_info();

  $label_callback = isset($info[$entity->item_type]['label_callback']) ? $info[$entity->item_type]['label_callback'] : null;

  if (function_exists($label_callback)) {
    return $label_callback($entity->data);
  }
}

/**
 * Parse a SKU string containing ':" to denote parent-child hierarchy.
 *
 * @param string $sku
 *  Target SKU
 *
 * @return array
 * -sku: the last part of the original SKU
 * -parent: all the other parents of the original SKU
 */
function commerce_qb_webconnect_parse_sku($sku) {
  if (strpos($sku, ':')) {
    $sku = explode(':', $sku);

    $return['sku'] = array_pop($sku);
    $return['parent'] = implode(':', $sku);
  } else {
    $return['sku'] = $sku;
  }

  $return['sku'] = str_replace('_', ' ', $return['sku']);

  return $return;
}

/**
 * Based on a payment method type, retrieve its mapping to a Quickbooks payment method
 * by invoking its hook.
 *
 * @param string $payment_type
 *  Type of payment method
 *  @see commerce_payment_methods()
 *
 * @param string $export_type
 *  Type of Quickbooks export
 *  @see commerce_qb_webconnect_export_info()
 *
 * @param array $data
 *  JSON decoded structure stored in export entity
 *
 * @return string
 *  The mapped payment method name
 */
function commerce_qb_webconnect_payment_method_mapping($payment_type, $export_type, $data) {
  $method = null;

    // payment method
  foreach (module_implements('commerce_payment_method_info') as $module) {
    foreach (module_invoke($module, 'commerce_payment_method_info') as $method_id => $payment_method) {
      if ($method_id == $payment_type) {
        $method = module_invoke($module, 'commerce_qb_webconnect_payment_mapping', $payment_type, $export_type, $data);
      }
    }
  }

  return $method;
}

/**
 * Retrieve the first array key inside a provided data structure. Useful for determining
 * language of a field.
 *
 * @param array $data
 *  Data structure to search
 *
 * @return string
 *  Language code
 */
function _commerce_qb_webconnect_get_lang($data) {
  $lang = array_keys($data);

  return reset($lang);
}
