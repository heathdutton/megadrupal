<?php
/**
 * @file
 * Election Candidate: primary module file.
 */

// Required files.
require_once 'election_candidate.constants.inc';

/**
 * Implements hook_entity_info().
 */
function election_candidate_entity_info() {

  $entities = array();

  $entities['election_candidate'] = array(
    'label' => t('Election candidate'),
    'access callback' => 'election_candidate_access',
    'uri callback' => 'election_candidate_uri',
    'controller class' => 'ElectionCandidateController',
    'views controller class' => 'EntityDefaultViewsController',
    'base table' => 'election_candidate',
    'label callback' => 'election_candidate_label',
    'entity keys' => array(
      'id' => 'candidate_id',
      'bundle' => 'type',
    ),
    'static cache' => TRUE,
    'fieldable' => TRUE,
    'module' => 'election',
    'bundles' => array(),
    'bundle keys' => array(
      'bundle' => 'type',
    ),
    'view modes' => array(
      'full' => array(
        'label' => t('Full content'),
      ),
      'teaser' => array(
        'label' => t('Teaser'),
      ),
    ),
    'view callback' => 'entity_metadata_view_single',
    // Disable fields added by the Redirect module.
    'redirect' => FALSE,
    // Enable the Meta Tags module to integrate with candidates.
    'metatags' => TRUE,
  );

  // The entity that holds information about candidate types.
  $entities['election_candidate_type'] = array(
    'label' => t('Candidate type'),
    'entity class' => 'ElectionCandidateType',
    'controller class' => 'ElectionCandidateTypeController',
    'base table' => 'election_candidate_type',
    'fieldable' => FALSE,
    'bundle of' => 'election_candidate',
    'exportable' => TRUE,
    'entity keys' => array(
      'id' => 'id',
      'name' => 'type',
      'label' => 'label',
    ),
    'access callback' => 'election_candidate_type_access',
    'module' => 'election_candidate',
    'admin ui' => array(
      'path' => 'admin/config/election/candidate-types',
      'file' => 'election_candidate_type.admin.inc',
      'controller class' => 'ElectionCandidateTypeUIController',
    ),
  );

  return $entities;

}

/**
 * Implements hook_entity_info_alter().
 */
function election_candidate_entity_info_alter(&$entity_info) {

  // Add configuration for candidate types (bundles).
  foreach (election_candidate_get_types() as $type => $info) {
    $entity_info['election_candidate']['bundles'][$type] = array(
      'label' => $info->label,
      'admin' => array(
        'path' => 'admin/config/election/candidate-types/manage/%election_candidate_type',
        'real path' => 'admin/config/election/candidate-types/manage/' . $type,
        'bundle argument' => 5,
        'access arguments' => array('administer candidate types'),
      ),
    );
  }
}

/**
 * Get a list of defined candidate types.
 */
function election_candidate_get_types($type_name = NULL) {
  $types = entity_load_multiple_by_name('election_candidate_type', isset($type_name) ? array($type_name) : FALSE);
  return isset($type_name) ? reset($types) : $types;
}

/**
 * Define the default election candidate types.
 *
 * @see http://drupal.org/node/999942
 *
 * @return array
 *   An array of default candidate types, keyed by machine names.
 */
function election_candidate_default_election_candidate_type() {
  $defaults['candidate'] = entity_create('election_candidate_type', array(
    'type' => 'candidate',
    'label' => t('Candidate (default type)'),
  ));
  return $defaults;
}

/**
 * Implements hook_permission().
 */
function election_candidate_permission() {
  $permissions = array(
    'administer candidate types' => array(
      'title' => t('Administer candidate types'),
      'description' => t('This allows the user to add/edit/delete candidate types, and manage field and display settings for candidates.'),
    ),
    'submit nominations' => array(
      'title' => t('Submit nominations'),
      'description' => t('This allows the user to submit a nomination, provided nominations are open.'),
    ),
    'edit own nominations' => array(
      'title' => t('Edit own nominations'),
      'description' => t('This allows the user to edit his/her own nominations.'),
    ),
  );
  return $permissions;
}

/**
 * Determines whether the given user has access to a given election candidate.
 *
 * @param string $op
 *   The operation being performed. One of 'view', 'update', or 'delete'.
 * @param object $candidate
 *   Optionally a candidate to check access for. If nothing is
 *   given, access for all candidates is determined.
 * @param object $account
 *   The user to check for. Leave it to NULL to check for the global user.
 *
 * @return bool
 *   Whether access is allowed or not.
 */
function election_candidate_access($op, $candidate = NULL, $account = NULL) {
  if ($account === NULL) {
    $account = $GLOBALS['user'];
  }
  $election = empty($candidate) ? NULL : election_load($candidate->election_id);
  $post = empty($candidate) ? NULL : election_post_load($candidate->post_id);
  switch ($op) {
    case 'view':
      // Users who can update the election can view all its candidates.
      if (election_access('update', $election, $account)) {
        return TRUE;
      }
      // Users who can view the election and the post can also view published
      // candidates.
      if (election_access('view', $election, $account)
        && (empty($post) || election_post_access('view', $post, $account))
        && (empty($candidate) || $candidate->published)) {
        return TRUE;
      }
      break;

    case 'update':
    case 'delete':
      if (election_access('update', $election, $account)) {
        return TRUE;
      }
      break;

  }
  // Deal with candidates that belong to the current user.
  $own = ($account->uid != 0 && !empty($candidate) && $candidate->uid == $account->uid);
  if ($own) {
    switch ($op) {
      case 'view':
        // Users are always allowed to see their own nominations.
        return TRUE;

      case 'update':
        return (bool) user_access('edit own nominations', $account);

    }
  }
  return FALSE;
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function election_candidate_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  // Hide the 'Candidates' tab unless (1) there are some published candidates
  // and (2) the tab is enabled in the election settings.
  if (substr($root_path, 0, 10) == 'election/%' && is_numeric(arg(1)) && !empty($data['tabs'][0])) {
    $election = election_load(arg(1));
    if (!$election || !election_candidate_check_support($election)) {
      return;
    }
    // Check that the candidates tab is enabled in the election settings.
    if (!empty($election->settings['show_candidates_tab'])) {
      // Check whether the View has any results.
      $view = views_get_view('election_candidates');
      if (!$view) {
        return;
      }
      $view->set_display('embed_candidates_per_election');
      $view->set_arguments(array($election->election_id));
      $view->execute();
      if (!empty($view->result)) {
        return;
      }
    }
    // Hide the tab.
    foreach ($data['tabs'][0]['output'] as $key => $tab) {
      if ($tab['#link']['path'] == 'election/%/candidates') {
        unset($data['tabs'][0]['output'][$key]);
        $data['tabs'][0]['count']--;
        break;
      }
    }
  }
}

/**
 * Determine candidate access per election.
 */
function election_candidate_access_per_election($op, stdClass $election, $account = NULL) {
  // Check whether the election supports candidates at all.
  if (!election_candidate_check_support($election)) {
    return FALSE;
  }
  // Defer to the election access system.
  return election_access($op, $election, $account);
}

/**
 * Determine candidate access per election post.
 */
function election_candidate_access_per_post($op, stdClass $post, $account = NULL) {
  // Check whether the election supports candidates at all.
  if (!election_candidate_check_support($post->election)) {
    return FALSE;
  }
  // Defer to the election post access system.
  return election_post_access($op, $post, $account);
}

/**
 * Implements hook_menu().
 */
function election_candidate_menu() {
  $items = array();

  $items['election-post/%election_post/nomination-form'] = array(
    'title' => 'Nomination form',
    'page callback' => 'election_candidate_nomination_form_page',
    'page arguments' => array(1),
    'access callback' => 'election_candidate_nominate_access',
    'access arguments' => array(1),
    'file' => 'election_candidate.pages.inc',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'weight' => 4,
  );

  $items['election/%election/candidates'] = array(
    'title' => 'Candidates',
    'page callback' => 'election_candidate_list_page',
    'page arguments' => array(1),
    'file' => 'election_candidate.pages.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'access callback' => 'election_candidate_access_per_election',
    'access arguments' => array('view', 1),
  );

  $items['election/%election/candidates-admin'] = array(
    'title' => 'Manage candidates',
    'page callback' => 'election_candidate_manage_page',
    'page arguments' => array(1),
    'file' => 'election_candidate.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 6,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    // To manage candidates, the user needs to have update access to the
    // election.
    'access callback' => 'election_candidate_access_per_election',
    'access arguments' => array('update', 1),
  );

  $items['election/%election/candidates-admin/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );

  $items['election/%election/candidates-admin/download'] = array(
    'title' => 'Download',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('election_candidate_download_form', 1),
    'file' => 'election_candidate.download.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 1,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    // To download candidate data, the user needs to have update access to the
    // election.
    'access callback' => 'election_candidate_access_per_election',
    'access arguments' => array('update', 1),
  );

  $items['election-post/%election_post/add-candidate'] = array(
    'title' => 'Add new candidate',
    'page callback' => 'election_candidate_page_add',
    'page arguments' => array(1),
    'file' => 'election_candidate.admin.inc',
    'type' => MENU_LOCAL_ACTION,
    // To create a candidate, the user needs to have update access to the post.
    'access callback' => 'election_candidate_access_per_post',
    'access arguments' => array('update', 1),
    'weight' => 2,
  );

  $items['election-candidate/%election_candidate'] = array(
    'title callback' => 'election_candidate_page_title',
    'title arguments' => array(1),
    'page callback' => 'election_candidate_page_view',
    'page arguments' => array(1),
    'file' => 'election_candidate.pages.inc',
    'access callback' => 'election_candidate_access',
    'access arguments' => array('view', 1),
    'type' => MENU_CALLBACK,
  );

  $items['election-candidate/%election_candidate/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );

  $items['election-candidate/%election_candidate/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'election_candidate_page_edit',
    'page arguments' => array(1),
    'file' => 'election_candidate.admin.inc',
    'access callback' => 'election_candidate_access',
    'access arguments' => array('update', 1),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'weight' => 2,
  );

  $items['election-candidate/%election_candidate/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('election_candidate_form_delete_confirm', 1),
    'access callback' => 'election_candidate_access',
    'access arguments' => array('delete', 1),
    'file' => 'election_candidate.forms.inc',
    'weight' => 3,
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
  );

  return $items;
}

/**
 * Get an array of candidate types.
 */
function _election_candidate_get_type_options() {
  $type_options = array();
  foreach (election_candidate_get_types() as $bundle => $type) {
    // N.B. no sanitizing happens here.
    $type_options[$bundle] = $type->label;
  }
  return $type_options;
}

/**
 * Get an array of possible candidate statuses.
 */
function _election_candidate_get_cstatus_options() {
  return array(
    ELECTION_CANDIDATE_ELECTED => t('Elected'),
    ELECTION_CANDIDATE_HOPEFUL => t('Hopeful'),
    ELECTION_CANDIDATE_WITHDRAWN => t('Withdrawn'),
    ELECTION_CANDIDATE_REJECTED => t('Rejected'),
    ELECTION_CANDIDATE_DEFEATED => t('Defeated'),
  );
}

/**
 * Implements hook_field_extra_fields().
 */
function election_candidate_field_extra_fields() {
  $extra = array(
    'form' => array(
      'post' => array(
        'label' => t('Post'),
        'description' => t('The post for this nomination.'),
        'weight' => 0,
      ),
      'published' => array(
        'label' => t('Published'),
        'description' => t("Whether the candidate is published."),
        'weight' => 99,
      ),
    ),
    'display' => array(
      'election' => array(
        'label' => t('Election'),
        'description' => t('The election for this candidate.'),
        'weight' => 0,
      ),
      'post' => array(
        'label' => t('Post'),
        'description' => t('The post/position for this candidate.'),
        'weight' => 1,
      ),
      'status' => array(
        'label' => t('Status'),
        'description' => t("The candidate's status."),
        'weight' => 7,
      ),
    ),
  );
  // Add the above $extra array to every election_candidate bundle.
  $info['election_candidate'] = array();
  foreach (election_candidate_get_types() as $bundle => $type) {
    $info['election_candidate'][$bundle] = $extra;
  }
  return $info;
}

/**
 * Implements hook_field_extra_fields_alter().
 */
function election_candidate_field_extra_fields_alter(&$info) {
  foreach (election_types() as $machine_name => $type) {
    $bundle = $type['post machine name'];
    if (!empty($type['has candidates'])) {
      // Add properties to the 'Manage fields' form for election posts.
      $info['election_post'][$bundle]['form'] += array(
        'vacancy_count' => array(
          'label' => t('Number of vacancies'),
          'weight' => 1,
        ),
        'candidates_nominations' => array(
          'label' => t('Candidates and nominations'),
          'weight' => 80,
        ),
      );
      // Add a property to the 'Manage display' form for elections.
      $info['election'][$machine_name]['display'] += array(
        'nstatus' => array(
          'label' => t('Nominations status'),
          'weight' => -2,
        ),
      );
      // Add properties to the 'Manage display' form for election posts.
      $info['election_post'][$bundle]['display'] += array(
        'vacancy_count' => array(
          'label' => t('Number of vacancies'),
          'weight' => 1,
        ),
        'nominate_link' => array(
          'label' => t('Nomination form link'),
          'weight' => 2,
        ),
        'candidates' => array(
          'label' => t('Candidates'),
          'weight' => 100,
        ),
      );
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Add candidate settings to the election edit form.
 */
function election_candidate_form_election_form_alter(&$form, &$form_state) {
  $election = $form_state['election'];
  if (!election_candidate_check_support($election)) {
    return;
  }
  if (!isset($form['presentation'])) {
    $form['presentation'] = array(
      '#type' => 'fieldset',
      '#title' => t('Presentation'),
      '#collapsible' => TRUE,
    );
  }
  $form['presentation']['settings_show_candidates_tab'] = array(
    '#type' => 'checkbox',
    '#title' => t('Show the Candidates tab'),
    '#description' => t('If enabled, a Candidates tab will be shown for this election, listing non-rejected candidates (if there are any).'),
    '#default_value' => isset($election->settings['show_candidates_tab']) ? $election->settings['show_candidates_tab'] : 1,
  );
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Add candidate settings to the election post edit form.
 */
function election_candidate_form_election_post_form_alter(&$form, &$form_state) {

  $post = $form_state['post'];
  $election = $form_state['election'];
  if (!election_candidate_check_support($election)) {
    return;
  }

  $form['candidates_nominations'] = array(
    '#type' => 'fieldset',
    '#title' => t('Candidates and nominations'),
    '#collapsible' => TRUE,
  );

  $form['candidates_nominations']['vacancy_count'] = array(
    '#type' => 'textfield',
    '#title' => t('Number of vacancies'),
    '#default_value' => $post->vacancy_count,
    '#size' => 2,
    '#maxlength' => 2,
    '#required' => TRUE,
    '#weight' => -20,
    '#element_validate' => array('element_validate_number'),
  );

  $election_nstatus = theme('election_status', array('election' => $election, 'status_prefix' => 'n'));

  $form['candidates_nominations']['nstatus_inheritance'] = array(
    '#type' => 'radios',
    '#title' => t('Nominations status'),
    '#default_value' => isset($post->nstatus_inheritance) ? $post->nstatus_inheritance : ELECTION_POST_STATUS_INHERIT,
    '#options' => array(
      ELECTION_POST_STATUS_INHERIT => t('Inherited (currently: %status)', array(
          '%status' => strip_tags($election_nstatus),
        )
      ),
      ELECTION_POST_STATUS_CLOSED => t('Closed'),
    ),
    '#weight' => 20,
  );

  $form['candidates_nominations']['settings_candidate_type'] = array(
    '#type' => 'select',
    '#title' => t('Candidate type'),
    '#options' => _election_candidate_get_type_options(),
    '#default_value' => isset($post->settings['candidate_type']) ? $post->settings['candidate_type'] : 'candidate',
    '#required' => TRUE,
    '#description' => t('This determines which candidate fields are available (e.g. in the nomination form). This setting does not affect existing candidates.'),
    '#weight' => 10,
  );

  if (election_candidate_type_access('update')) {
    $form['candidates_nominations']['settings_candidate_type']['#description'] .= ' '
      . l(
        t('Manage candidate types'),
        'admin/config/election/candidate-types',
        array(
          'attributes' => array('target' => '_blank'),
        )
      );
  }

  $form['candidates_nominations']['settings_exclusive'] = array(
    '#type' => 'checkbox',
    '#title' => t('Exclusive'),
    '#description' => t(
      'A candidate can only stand for one exclusive @post per election.<br /><strong>N.B. if anonymous users are given permission to submit nominations, exclusivity cannot be enforced.</strong>',
      array(
        '@post' => election_get_post_name($election->type),
      )
    ),
    '#default_value' => isset($post->settings['exclusive']) ? $post->settings['exclusive'] : 1,
    '#weight' => 20,
  );

}

/**
 * Title callback for election/%election_candidate/view.
 *
 * @param object $candidate
 *   The election candidate object.
 */
function election_candidate_page_title($candidate) {
  // Output should not be escaped here; it is escaped later in the menu system.
  return election_candidate_get_name($candidate, FALSE);
}

/**
 * Wrapper function to allow saving an election candidate.
 *
 * @param object $candidate
 *   Election candidate object.
 */
function election_candidate_save($candidate) {
  return entity_get_controller('election_candidate')->save($candidate);
}

/**
 * Wrapper function to allow deleting multiple candidates.
 *
 * @param array $candidate_ids
 *   Array of candidate IDs.
 */
function election_candidate_delete_multiple(array $candidate_ids) {
  return entity_get_controller('election_candidate')->delete($candidate_ids);
}

/**
 * Wrapper function to allow deleting an individual election.
 *
 * @see election_candidate_delete_multiple()
 *
 * @param mixed $candidate_id
 *   Single candidate ID.
 */
function election_candidate_delete($candidate_id) {
  return election_candidate_delete_multiple(array($candidate_id));
}

/**
 * Access callback for candidate types administration.
 */
function election_candidate_type_access($op, $type = NULL, $account = NULL) {
  return user_access('administer candidate types', $account);
}

/**
 * Find the nominations for a specified account.
 *
 * This gets database records for candidates, joined to the election_post table.
 *
 * @param object $election
 *   Election object.
 * @param object $account
 *   Optional user account object (default: current user).
 *
 * @todo Remove this somehow, it's ugly.
 *
 * @return array
 *   An array of records, as objects. Empty array if the $account is anonymous.
 */
function election_candidate_get_nominations(stdClass $election, $account = NULL) {
  $nominations = &drupal_static(__FUNCTION__, array());
  if (!$account) {
    $account = $GLOBALS['user'];
  }
  if ($account->uid == 0) {
    return array();
  }
  if (!isset($nominations[$election->election_id][$account->uid])) {
    // @todo convert this into a standard EntityFieldQuery + entity load.
    $query = db_select('election_candidate', 'ec');
    $query->join('election_post', 'ep', 'ec.post_id = ep.post_id');
    $query->fields('ec')
      ->fields('ep', array('settings'))
      ->condition('ec.uid', $account->uid)
      ->condition('ep.election_id', $election->election_id);
    $nominations[$election->election_id][$account->uid] = $query->execute()->fetchAll();
  }
  return $nominations[$election->election_id][$account->uid];
}

/**
 * Check access to nominating for a post.
 *
 * @param object $post
 *   Election post object.
 * @param object $account
 *   User account object (default: current user).
 *
 * @return array
 *   Array of post IDs.
 */
function election_candidate_nominate_access(stdClass $post, $account = NULL) {
  if (empty($account)) {
    $account = $GLOBALS['user'];
  }
  $election = $post->election;
  // Check whether the election supports candidates.
  if (!election_candidate_check_support($election)) {
    return FALSE;
  }
  // Check if the user has global permission for submitting nominations.
  if (!user_access('submit nominations', $account)) {
    return FALSE;
  }
  // Check whether nominations are open.
  if (!election_post_nominations_open($post)) {
    return FALSE;
  }
  // Load the user's previous nominations, if any.
  $nominations = election_candidate_get_nominations($post->election, $account);
  $has_exclusive = FALSE;
  $prev_post_ids = array();
  foreach ($nominations as $nomination) {
    if (in_array($nomination->cstatus, array(ELECTION_CANDIDATE_REJECTED, ELECTION_CANDIDATE_WITHDRAWN))) {
      continue;
    }
    $settings = (array) unserialize($nomination->settings);
    if (!empty($settings['exclusive'])) {
      $has_exclusive = TRUE;
    }
    $prev_post_ids[] = $nomination->post_id;
  }
  // Prevent duplicate nominations for the same post by one account.
  if (in_array($post->post_id, $prev_post_ids)) {
    return FALSE;
  }
  // Prevent more than one nomination for an 'exclusive' post by one account.
  if (!empty($post->settings['exclusive']) && $has_exclusive) {
    return FALSE;
  }
  return TRUE;
}

/**
 * URI callback for a single election candidate.
 */
function election_candidate_uri($candidate) {
  $path = 'election-candidate/' . $candidate->candidate_id;
  return array(
    'path' => $path,
    'options' => array(),
  );
}

/**
 * Get the path part of the election candidate URI callback as a string.
 *
 * @see election_candidate_uri()
 */
function election_candidate_uri_path($candidate) {
  $uri = election_candidate_uri($candidate);
  return $uri['path'];
}

/**
 * Entity label callback for an election_candidate.
 */
function election_candidate_label(stdClass $entity, $entity_type) {
  return election_candidate_get_name($entity);
}

/**
 * Get the name of the candidate.
 *
 * @param object $candidate
 *   The candidate object.
 * @param bool $sanitize
 *   Whether to sanitize the name for display in a web page (default: TRUE).
 *
 * @return string
 *   The name of the candidate.
 */
function election_candidate_get_name($candidate, $sanitize = TRUE) {
  // Get the name from the default 'candidate_name' field if it's available.
  if (isset($candidate->candidate_name)) {
    $name = $candidate->candidate_name[LANGUAGE_NONE][0];
    // The name will be sanitized later, so get the raw value for now.
    // @see _name_formatter_output_types()
    $display = array('settings' => array('output' => 'raw'));
    $name = field_view_value('election_candidate', $candidate, 'candidate_name', $name, $display);
    $name = drupal_render($name);
  }
  else {
    $name = $candidate->candidate_id;
  }
  // Allow other modules to alter the name.
  drupal_alter('election_candidate_name', $name, $candidate);
  // Sanitize it for display.
  $name = $sanitize ? check_plain($name) : $name;
  return $name;
}

/**
 * Load an individual candidate.
 *
 * @param int $candidate_id
 *   A single election candidate ID.
 * @param bool $reset
 *   Whether to reset the internal cache for election candidate entities.
 *
 * @return object
 *   A stdClass election_candidate object.
 */
function election_candidate_load($candidate_id, $reset = FALSE) {
  $result = election_candidate_load_multiple((array) $candidate_id, $reset);
  if (!is_array($result) || !count($result)) {
    return FALSE;
  }
  return reset($result);
}

/**
 * Load multiple candidates.
 *
 * @param array $candidate_ids
 *   An array of election candidate IDs.
 * @param bool $reset
 *   Whether to reset the internal cache for election candidate entities.
 *
 * @return array
 *   An array of election candidate objects keyed by candidate ID.
 */
function election_candidate_load_multiple(array $candidate_ids = array(), $reset = FALSE) {
  // The $conditions parameter is not used as this is deprecated for D8.
  return entity_load('election_candidate', $candidate_ids, array(), $reset);
}

/**
 * Load a candidate type.
 *
 * @param string $type
 *   The machine-readable name of a candidate type to load.
 *
 * @return mixed
 *   A candidate type array or FALSE if $type does not exist.
 */
function election_candidate_type_load($type) {
  return election_candidate_get_types($type);
}

/**
 * Implements hook_theme().
 */
function election_candidate_theme() {
  return array(
    'election_candidate' => array(
      'render element' => 'elements',
      'template' => 'election-candidate',
      'file' => 'election_candidate.theme.inc',
    ),
    'election_candidate_ballot_item' => array(
      'variables' => array(
        'candidate' => NULL,
      ),
      'file' => 'election_candidate.theme.inc',
    ),
    'election_candidate_nominate_link' => array(
      'variables' => array(
        'post' => NULL,
      ),
      'file' => 'election_candidate.theme.inc',
    ),
    'election_candidate_status' => array(
      'variables' => array(
        'candidate' => NULL,
      ),
      'file' => 'election_candidate.theme.inc',
    ),
  );
}

/**
 * Generate an array for rendering the given candidate.
 *
 * @param object $candidate
 *   An election candidate object.
 * @param string $view_mode
 *   View mode, e.g. 'full', 'teaser'...
 *
 * @return array
 *   An array as expected by drupal_render().
 */
function election_candidate_view($candidate, $view_mode = 'full') {

  $election = election_load($candidate->election_id);
  $post = election_post_load($candidate->post_id);

  // Remove previously built content, if it exists.
  $candidate->content = array();

  $election_path = election_uri_path($election);
  $candidates_path = $election_path . '/candidates';
  $post_path = $post ? election_post_uri_path($post) : FALSE;
  $current_path = current_path();

  // Display a link to the election.
  $no_link = array($election_path, $post_path, $candidates_path);
  if (!in_array($current_path, $no_link)) {
    $candidate->content['election'] = array(
      '#theme' => 'election_info_item',
      '#label' => t('Election'),
      '#value' => l($election->title, election_uri_path($election)),
      '#html' => TRUE,
    );
  }

  // Display a link to the post.
  $no_link = array($post_path, $candidates_path);
  if ($post && !in_array($current_path, $no_link)) {
    $candidate->content['post'] = array(
      '#theme' => 'election_info_item',
      '#label' => drupal_ucfirst(election_get_post_name($election->type)),
      '#value' => l($post->title, election_post_uri_path($post)),
      '#html' => TRUE,
    );
  }

  // Display the candidate's status.
  $candidate->content['status'] = array(
    '#theme' => 'election_info_item',
    '#label' => t('Status'),
    '#value' => theme('election_candidate_status', array('candidate' => $candidate)),
    '#html' => TRUE,
  );

  // Build fields content.
  // In case of a multiple view, node_view_multiple() already ran the
  // 'prepare_view' step. An internal flag prevents the operation from running
  // twice.
  field_attach_prepare_view('election_candidate', array($candidate->candidate_id => $candidate), $view_mode);
  entity_prepare_view('election_candidate', array($candidate->candidate_id => $candidate));
  $candidate->content += field_attach_view('election_candidate', $candidate, $view_mode);

  $build = $candidate->content;
  // We don't need duplicate rendering info in $candidate->content.
  unset($candidate->content);

  $post = election_post_load($candidate->post_id);

  $build += array(
    '#theme' => 'election_candidate',
    '#candidate' => $candidate,
    '#election' => $election,
    '#post' => $post,
    '#view_mode' => $view_mode,
  );

  // Add contextual links for this candidate, except when the candidate is
  // already being displayed on its own page.
  if (!empty($candidate->candidate_id) && $view_mode != 'full') {
    $build['#contextual_links']['election_candidate'] = array('election-candidate', array($candidate->candidate_id));
  }

  // Invoke hook_entity_view().
  global $language;
  $langcode = $language->language;
  module_invoke_all('entity_view', $candidate, 'election_candidate', $view_mode, $langcode);

  // Invoke hook_ENTITY_view_alter() and hook_entity_view_alter().
  $type = 'election_candidate';
  drupal_alter(array('election_candidate_view', 'entity_view'), $build, $type);

  return $build;

}

/**
 * Get the human-readable name of the candidate's 'cstatus' property.
 */
function _election_candidate_status_name(stdClass $candidate) {
  $options = _election_candidate_get_cstatus_options();
  return $options[$candidate->cstatus];
}

/**
 * Implements hook_entity_update().
 */
function election_candidate_entity_update($entity, $type) {
  switch ($type) {
    case 'election_candidate':
      if (module_exists('pathauto')) {
        _election_candidate_pathauto_update_alias($entity, 'update');
      }
      break;

  }
}

/**
 * Implements hook_entity_delete().
 */
function election_candidate_entity_delete($entity, $type) {
  switch ($type) {

    case 'election':
      $election_id = $entity->election_id;
      // Delete associated candidates when an election is deleted.
      $candidate_ids = db_select('election_candidate')
        ->fields('election_candidate', array('candidate_id'))
        ->condition('election_id', $election_id)
        ->execute()
        ->fetchCol();
      election_candidate_delete_multiple($candidate_ids);
      break;

    // Clear the post_id property of candidates when their post is deleted.
    case 'election_post':
      db_update('election_candidate')
        ->fields(array('post_id' => NULL))
        ->condition('post_id', $entity->post_id)
        ->execute();
      break;

    // Delete Pathauto path aliases when a candidate is deleted.
    case 'election_candidate':
      if (function_exists('pathauto_entity_path_delete_all')) {
        pathauto_entity_path_delete_all('election_candidate', $entity);
      }
      break;

  }
}

/**
 * Implements hook_entity_insert().
 */
function election_candidate_entity_insert($entity, $type) {
  if ($type == 'election_candidate' && module_exists('pathauto')) {
    _election_candidate_pathauto_update_alias($entity, 'insert');
  }
  // Create default candidate type field instances.
  if ($type == 'election_candidate_type') {
    module_load_include('inc', 'election_candidate', 'election_candidate.field');
    foreach (_election_candidate_field_instances() as $instance) {
      $instance['bundle'] = $entity->type;
      field_create_instance($instance);
    }
  }
}

/**
 * Implements hook_file_download_access().
 *
 * Allow private files to be downloaded when they are attached to a candidate
 * entity, if the user has permission to view the candidate.
 */
function election_candidate_file_download_access($field, $entity_type, $entity) {
  if ($entity_type == 'election_candidate') {
    return election_candidate_access('view', $entity);
  }
}

/**
 * Implements hook_file_entity_access().
 */
function election_candidate_file_entity_access($op, $file, $account) {
  // If the user can view the election candidate, they should be allowed to view
  // attached file entities even if they are stored as 'private files'.
  if (($op == 'view' || $op == 'download') && is_object($file)) {
    $references = file_get_file_references($file);
    foreach ($references as $result) {
      if (!isset($result['election_candidate'])) {
        return FILE_ENTITY_ACCESS_IGNORE;
      }
      foreach (array_keys($result['election_candidate']) as $candidate_id) {
        $candidate = election_candidate_load($candidate_id);
        if ($candidate && election_candidate_access('view', $candidate, $account)) {
          return FILE_ENTITY_ACCESS_ALLOW;
        }
      }
    }
  }
  return FILE_ENTITY_ACCESS_IGNORE;
}

/**
 * Update the URL aliases for an individual election candidate.
 *
 * @param object $candidate
 *   An election candidate object.
 * @param string $op
 *   Operation being performed ('insert', 'update' or 'bulkupdate').
 * @param array $options
 *   An optional array of additional options.
 */
function _election_candidate_pathauto_update_alias(stdClass $candidate, $op, array $options = array()) {
  // Skip processing if the candidate has no pattern.
  if (!pathauto_pattern_load_by_entity('election_candidate', 'election_candidate')) {
    return;
  }
  $election = election_load($candidate->election_id);
  if (!$election) {
    watchdog('election_candidate', 'Could not update candidate alias: election ID @id could not be loaded', array('@id' => $candidate->election_id), WATCHDOG_WARNING);
    return;
  }
  module_load_include('inc', 'pathauto');
  pathauto_create_alias(
    'election_candidate',
    $op,
    election_candidate_uri_path($candidate),
    array('election_candidate' => $candidate, 'election' => $election),
    'election_candidate'
  );
}

/**
 * Update the URL aliases for multiple election candidates.
 *
 * @param array $candidate_ids
 *   An array of election candidate IDs.
 * @param string $op
 *   Operation being performed on the candidates ('insert', 'update' or
 *   'bulkupdate').
 * @param array $options
 *   An optional array of additional options.
 */
function _election_candidate_pathauto_update_alias_multiple(array $candidate_ids, $op, array $options = array()) {
  $options += array('message' => FALSE);
  $candidates = election_candidate_load_multiple($candidate_ids);
  foreach ($candidates as $candidate) {
    _election_candidate_pathauto_update_alias($candidate, $op, $options);
  }
  if (!empty($options['message'])) {
    drupal_set_message(format_plural(count($candidate_ids), 'Updated URL alias for 1 candidate.', 'Updated URL aliases for @count candidates.'));
  }
}

/**
 * Implements hook_views_api().
 */
function election_candidate_views_api() {
  return array(
    'api' => 3,
  );
}

/**
 * Implements hook_views_default_views().
 */
function election_candidate_views_default_views() {
  $views_dir = drupal_get_path('module', 'election_candidate') . '/views';
  $views_files = scandir($views_dir);
  $views = array();
  foreach ($views_files as $filename) {
    if (substr($filename, -4) == '.inc') {
      include_once $views_dir . '/' . $filename;
    }
  }
  return $views;
}

/**
 * Load candidates who are standing for the given post.
 *
 * @param object $post
 *   An election post object.
 * @param array $statuses
 *   An array of candidate statuses, by which to filter results (optional).
 * @param bool $only_published
 *   Whether to only find published candidates.
 * @param string $order_by
 *   A database column to order candidates by. Default is random (MySQL RAND()).
 *   Set FALSE for no ordering.
 *
 * @return array
 *   An array of candidate objects keyed by candidate ID.
 */
function election_candidate_load_by_post(stdClass $post, array $statuses = NULL, $only_published = TRUE, $order_by = 'RAND()') {
  $select = db_select('election_candidate', 'ec')
    ->fields('ec', array('candidate_id'))
    ->condition('post_id', $post->post_id);
  if ($only_published) {
    $select->condition('published', 1);
  }
  if ($statuses !== NULL) {
    $select->condition('cstatus', (array) $statuses, 'IN');
  }
  if (!empty($order_by)) {
    $select->orderBy($order_by);
  }
  $candidate_ids = $select->execute()->fetchCol();
  $candidates = election_candidate_load_multiple($candidate_ids);
  return $candidates;
}

/**
 * Implements hook_ENTITY_view_alter().
 */
function election_candidate_election_post_view_alter(&$build) {
  $post = $build['#post'];
  $election = $post->election;
  if (!election_candidate_check_support($election)) {
    return;
  }
  // Display the number of vacancies.
  $build['vacancy_count'] = array(
    '#theme' => 'election_info_item',
    '#label' => t('Number of vacancies'),
    '#value' => number_format($post->vacancy_count),
  );
  // Display a link to the nomination form for the post.
  $build['nominate_link'] = array(
    '#theme' => 'election_info_item',
    '#html' => TRUE,
    '#value' => theme('election_candidate_nominate_link', array('post' => $post)),
  );
  // Display a list of candidates on the post.
  if ($build['#view_mode'] == 'full') {
    $view = views_get_view('election_candidates');
    $output = $view->preview('embed_candidates_per_post', array($post->post_id));
    if ($view->result) {
      $build['candidates'] = array(
        '#prefix' => '<div class="election-post-candidates"><h2>' . t('Candidates') . '</h2>',
        '#markup' => $output,
        '#suffix' => '</div>',
      );
    }
  }
}

/**
 * Implements hook_action_info().
 */
function election_candidate_action_info() {
  return array(
    'election_candidate_publish_action' => array(
      'type' => 'election_candidate',
      'label' => t('Publish candidate'),
      'configurable' => FALSE,
      'behavior' => array('changes_property'),
      'triggers' => array('election_candidate_presave'),
    ),
    'election_candidate_unpublish_action' => array(
      'type' => 'election_candidate',
      'label' => t('Unpublish candidate'),
      'configurable' => FALSE,
      'behavior' => array('changes_property'),
      'triggers' => array('election_candidate_presave'),
    ),
  );
}

/**
 * Publishes a candidate.
 *
 * @ingroup actions
 */
function election_candidate_publish_action($candidate, $context = array()) {
  $candidate->published = 1;
}

/**
 * Unpublishes a candidate.
 *
 * @ingroup actions
 */
function election_candidate_unpublish_action($candidate, $context = array()) {
  $candidate->published = 0;
}

/**
 * Check whether an election type supports candidates.
 */
function election_candidate_check_support(stdClass $election) {
  return (!empty($election->type_info['has candidates']));
}

/**
 * Implements hook_hook_info().
 */
function election_candidate_hook_info() {
  return array(
    'election_candidate_post_has_enough_alter' => array(
      'group' => 'election',
    ),
    'election_candidate_name_alter' => array(
      'group' => 'election',
    ),
  );
}

/**
 * Determine whether the election post has enough candidates for voting.
 *
 * Other modules may alter the result of this function by implementing
 * hook_election_candidate_post_has_enough_alter().
 *
 * @param object $post
 *   The election post object.
 *
 * @return bool
 *   TRUE if there are enough candidates for voting, or if the election type
 *   does not support candidates; FALSE otherwise.
 */
function election_candidate_post_has_enough($post) {
  if (!election_candidate_check_support($post->election)) {
    return TRUE;
  }

  $cache = &drupal_static(__FUNCTION__, array());
  if (isset($cache[$post->post_id])) {
    return $cache[$post->post_id];
  }

  // Find the number of published, 'hopeful' candidates standing for the post.
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'election_candidate')
    ->propertyCondition('post_id', $post->post_id)
    ->propertyCondition('published', 1)
    ->propertyCondition('cstatus', ELECTION_CANDIDATE_HOPEFUL)
    ->count();
  $num_candidates = $query->execute();

  // If RON (Re-Open Nominations) is enabled for the post, that counts as a
  // candidate.
  if (!empty($post->settings['use_ron'])) {
    $num_candidates++;
  }

  // There should be at least one more candidate than the number of vacancies.
  if ($num_candidates - $post->vacancy_count >= 1) {
    $enough = TRUE;
  }

  // Allow other modules to alter the result.
  drupal_alter('election_candidate_post_has_enough', $enough, $post, $num_candidates);

  $cache[$post->post_id] = $enough;
  return $enough;
}

/**
 * Generate a table of a user's previous nominations in an election.
 *
 * @param object $election
 *   An election object.
 * @param array $previous_nominations
 *   An array of candidate objects representing the user's previous nominations.
 *
 * @todo make this themeable
 */
function election_candidate_display_previous_nominations(stdClass $election, array $previous_nominations) {
  if (empty($previous_nominations)) {
    return;
  }
  $caption = t('Your previous nominations in this election');
  $header = array(
    t('Nomination date'),
    drupal_ucfirst(election_get_post_name($election->type)),
    t('Name'),
    t('Status'),
  );
  $rows = array();
  foreach ($previous_nominations as $candidate) {
    $post = election_post_load($candidate->post_id);
    $post_title = empty($post) ? '?' : check_plain($post->title);
    $rows[] = array(
      format_date($candidate->created, 'short'),
      $post_title,
      election_candidate_get_name($candidate),
      theme('election_candidate_status', array('candidate' => $candidate)),
    );
  }
  return array(
    '#theme' => 'table',
    '#header' => $header,
    '#rows' => $rows,
    '#caption' => $caption,
  );
}
