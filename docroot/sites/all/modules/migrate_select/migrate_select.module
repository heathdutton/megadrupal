<?php

/**
 * @file
 * Module providing new action for Views Bulk Operations to mark selected
 * entities for migration.
 */

/**
 * Implements hook_action_info().
 *
 * 'triggers' => array('any') was not added to the action definition on purpose,
 * as adding it would make the action available to be used with Drupal triggers
 * too, which would only cause issues:
 * - in case of nodes, the node object is not passed to the action callback
 *   as first parameter ($entity), but instead in 'node' key in $context,
 * - in case of other entities, the entity object is passed as first parameter,
 * - in both cases we don't really know what entity type we are dealing with,
 *   as there is no 'entity_type' parameter in the $context (like VBO provides),
 *   and we can't know it in any way (see https://drupal.org/node/1042822 for
 *   discussion on this), therefore we wouldn't be able to easily find relevant
 *   migrations without trying all of them.
 */
function migrate_select_action_info() {
  return array(
    'migrate_select_entity_needs_update_action' => array(
      'type' => 'entity',
      'label' => t('Select for migration'),
    ),
  );
}

/**
 * Action callback: mark entity as 'needs update' for selected migration.
 *
 * @param object $entity
 *   An entity object.
 * @param array $context
 *   Array of additional information about what triggered the action.
 *
 * @see migrate_select_action_info()
 *
 * @ingroup actions
 */
function migrate_select_entity_needs_update_action(&$entity, $context = array()) {
  // Entity type should have been passed in context.
  $entity_type = $context['entity_type'];

  // To get entity bundle, first we need to check in which property it is stored.
  $entity_info = entity_get_info($entity_type);
  $bundle_key = $entity_info['entity keys']['bundle'];
  $bundle = $entity->$bundle_key;

  // $context we have received as this function parameter is not passed by
  // reference, and any modifications done to it are not passed to the next
  // batch call, therefore we need to introduce our own context variable,
  // and store it in Drupal cache to be able to pass it to next batch steps.
  $migrate_select_context = ($cached = cache_get('migrate_select:context', 'cache')) ? $cached->data : array();

  // Get all defined migrations grouped by entity type and bundle.
  if (!isset($migrate_select_context['entity_migrations'])) {
    $migrate_select_context['entity_migrations'] = migrate_select_entity_migrations();
  }

  // If at least one migration for current entity type exists, let's proceed.
  if (!empty($migrate_select_context['entity_migrations'][$entity_type][$bundle])) {
    foreach ($migrate_select_context['entity_migrations'][$entity_type][$bundle] as $migration_name) {
      // Load migration object for current entity type.
      $migration = migration_load($migration_name);

      // Counter for number of updated entities.
      if (!isset($migrate_select_context['initial_update_count'][$migration_name])) {
        $migrate_select_context['initial_update_count'][$migration_name] = $migration->updateCount();
      }

      // Mark entity as 'needs update'.
      $migration->setUpdate(array($entity->title));
    }
  }

  // When a very last entity has been processed, display messages with number
  // of entities marked for migration for each migration.
  if ($context['progress']['current'] == $context['progress']['total']) {
    $migrations = migrate_migrations();
    if (!empty($migrate_select_context['initial_update_count'])) {
      foreach ($migrate_select_context['initial_update_count'] as $migration_name => $initial_count) {
        $updated_count = $migrations[$migration_name]->updateCount() - $initial_count;
        drupal_set_message(t('Added %count entities to %migration_name migration.', array(
          '%count' => $updated_count,
          '%migration_name' => $migration_name,
        )));
      }
    }
    else {
      drupal_set_message(t('Could not find any migration the selected entities belong to.'), 'error');
    }
    // Clear cache from all temporary data.
    cache_clear_all('migrate_select:', 'cache', TRUE);
  }
  else {
    // This local context needs to be stored only between consecutive batch
    // steps, so 5 minutes of cache live-time should be more than enough.
    cache_set('migrate_select:context', $migrate_select_context, 'cache', 300);
  }
}

/**
 * Returns all migrations grouped by entity type/bundle.
 *
 * @return array
 *   A multi-level array, where first-level keys are entity types, second-level
 *   keys are bundles, and second-level values contain arrays of migration
 *   machine names for each such entity type/bundle pair.
 */
function migrate_select_entity_migrations() {
  $entity_migrations = array();

  foreach (migrate_migrations() as $machine_name => $migration) {
    $destination = $migration->getDestination();
    if (method_exists($destination, 'getEntityType') && method_exists($destination, 'getBundle')) {
      $entity_type = $destination->getEntityType();
      $bundle = $destination->getBundle();
      // There might be more than one migration defined for each
      // entity type/bundle, let's then put them in an array.
      $entity_migrations[$entity_type][$bundle][$machine_name] = $machine_name;
    }
  }

  return $entity_migrations;
}
