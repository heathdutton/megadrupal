<?php
/**
 * @file
 * Bazaarvoice productfeed functionality.
 */

/**
 * Implements hook_permission().
 */
function bazaarvoice_productfeed_permission() {
  $permissions = array();
  $permissions['administer bazaarvoice productfeed'] = array(
    'title' => t('Administer Bazaarvoice Product Feed'),
  );
  $permissions['create bazaarvoice custom attributes'] = array(
    'title' => t('Create Bazaarvoice custom attributes'),
  );
  $permissions['delete bazaarvoice custom attributes'] = array(
    'title' => t('Delete Bazaarvoice custom attributes'),
  );
  $permissions['administer bazaarvoice entity attribute mappings'] = array(
    'title' => t('Administer Bazaarvoice entity attribute mappings'),
  );
  return $permissions;
}

/**
 * Implements hook_menu().
 */
function bazaarvoice_productfeed_menu() {
  $items = array();
  // Only display admin menu item if UI module is enabled.
  if (module_exists('bazaarvoice_ui')) {
    // Configure Bazaarvoice product mappings.
    $items['admin/config/services/bazaarvoice/productfeed'] = array(
      'title' => 'Product Feed',
      'description' => 'Configure settings for Product Feed.',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('bazaarvoice_productfeed_settings_form'),
      'access callback' => 'user_access',
      'access arguments' => array('administer bazaarvoice productfeed'),
      'file' => 'includes/admin.inc',
      'type' => MENU_LOCAL_TASK,
    );
    $items['admin/config/services/bazaarvoice/productfeed/settings'] = array(
      'title' => 'Settings',
      'description' => 'Configure settings for Product Feed.',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('bazaarvoice_productfeed_settings_form'),
      'access callback' => 'user_access',
      'access arguments' => array('administer bazaarvoice productfeed'),
      'file' => 'includes/admin.inc',
      'type' => MENU_DEFAULT_LOCAL_TASK,
    );
    $items['admin/config/services/bazaarvoice/productfeed/attributes'] = array(
      'title' => 'Custom Attributes',
      'description' => 'Manage attributes to be included in the product feed.',
      'page callback' => 'bazaarvoice_productfeed_admin_attributes',
      'access callback' => 'user_access',
      'access arguments' => array('administer bazaarvoice productfeed'),
      'file' => 'includes/admin.inc',
      'parent_tab' => 'admin/config/services/bazaarvoice/productfeed',
      'type' => MENU_LOCAL_TASK,
    );
    $items['admin/config/services/bazaarvoice/productfeed/attributes/add'] = array(
      'title' => 'Add Custom Attribute',
      'description' => 'Add a custom product feed attribute.',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('bazaarvoice_productfeed_admin_attributes_add_form'),
      'access callback' => 'user_access',
      'access arguments' => array('create bazaarvoice custom attributes'),
      'file' => 'includes/admin.inc',
      'parent_tab' => 'admin/config/services/bazaarvoice/productfeed/attributes',
      'type' => MENU_LOCAL_ACTION,
    );
    $items['admin/config/services/bazaarvoice/productfeed/attributes/edit/%bazaarvoice_productfeed_attribute'] = array(
      'title' => 'Edit Custom Attribute',
      'description' => 'Edit a custom product feed attribute.',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('bazaarvoice_productfeed_admin_attributes_edit_form', 7),
      'access callback' => 'user_access',
      'access arguments' => array('create bazaarvoice custom attributes'),
      'file' => 'includes/admin.inc',
      'parent_tab' => 'admin/config/services/bazaarvoice/productfeed-attributes',
      'type' => MENU_CALLBACK,
    );
    $items['admin/config/services/bazaarvoice/productfeed/attributes/delete/%bazaarvoice_productfeed_attribute'] = array(
      'title' => 'Delete Custom Attribute',
      'description' => 'Delete a custom product feed attribute.',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('bazaarvoice_productfeed_admin_attributes_delete_form', 7),
      'access callback' => 'user_access',
      'access arguments' => array('delete create bazaarvoice custom attributes'),
      'file' => 'includes/admin.inc',
      'parent_tab' => 'admin/config/services/bazaarvoice/productfeed-attributes',
      'type' => MENU_CALLBACK,
    );
  }
  return $items;
}

/**
 * Implements hook_cron().
 */
function bazaarvoice_productfeed_cron() {
  module_load_include('inc', 'bazaarvoice_productfeed', 'includes/productfeed');
  // Rebuild productfeed.
  bazaarvoice_productfeed_rebuild_productfeed();
  // FTP the product feed?
  if ($frequency = variable_get('bazaarvoice_ftp_frequency', 0)) {
    // Get last time productfeed was FTP'd.
    $last_ftp = variable_get('bazaarovice_ftp_last', 0);
    // Get the difference in time from now.
    $diff = mktime() - $last_ftp;
    // Greater then frequency of run?
    if ($diff > $frequency) {
      // Get productfeed.
      if ($product_feed = bazaarvoice_productfeed_get_feed()) {
        // Attempt to FTP.
        bazaarvoice_productfeed_ftp_feed($product_feed);
      }
    }
  }
}

/**
 * Implements hook_entity_delete().
 */
function bazaarvoice_productfeed_entity_delete($entity, $type) {
  bazaarvoice_productfeed_entity_trigger_rebuild($entity, $type);
}

/**
 * Implements hook_entity_update().
 */
function bazaarvoice_productfeed_entity_update($entity, $type) {
  bazaarvoice_productfeed_entity_trigger_rebuild($entity, $type);
}

/**
 * Implements hook_entity_insert().
 */
function bazaarvoice_productfeed_entity_insert($entity, $type) {
  bazaarvoice_productfeed_entity_trigger_rebuild($entity, $type);
}

/**
 * Implements hook_field_delete().
 */
function bazaarvoice_productfeed_field_delete($entity_type, $entity, $field, $instance, $langcode, &$items) {
  // Get ids for the entity.
  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);
  // Build delete query, or condition.
  $or = db_or()->condition('field_name', $field['field_name'])
    ->condition('sub_field_name', $field['field_name']);
  // Run delete query.
  db_delete('bazaarvoice_productfeed_entity_mappings')
    ->condition('entity_type', $entity_type)
    ->condition('entity_bundle', $bundle)
    ->condition($or)
    ->execute();
  // Trigger rebuild of product feed.
  bazaarvoice_productfeed_entity_trigger_rebuild($entity, $entity_type);
}

/**
 * Implements hook_field_delete_field().
 */
function bazaarvoice_productfeed_field_delete_field($field) {
  $or = db_or()->condition('field_name', $field['field_name'])
    ->condition('sub_field_name', $field['field_name']);
  // Delete all mappings for this field.
  db_delete('bazaarvoice_productfeed_entity_mappings')
    ->condition($or)
    ->execute();
  bazaarvoice_productfeed_trigger_rebuild();
}

/**
 * Implements hook_field_attach_rename_bundle().
 */
function bazaarvoice_productfeed_field_attach_rename_bundle($entity_type, $bundle_old, $bundle_new) {
  if (bazaarvoice_products_is_product_type($entity_type, $bundle_old)) {
    // Update all mappings.
    db_update('bazaarvoice_productfeed_entity_mappings')
      ->fields(array('entity_bundle' => $bundle_new))
      ->condition('entity_type', $entity_type)
      ->condition('entity_bundle', $bundle_old)
      ->execute();
  }
}

/**
 * Implements hook_field_attach_delete_bundle().
 */
function bazaarvoice_productfeed_field_attach_delete_bundle($entity_type, $bundle, $instances) {
  if (bazaarvoice_products_is_product_type($entity_type, $bundle)) {
    // Delete all mappings.
    db_delete('bazaarvoice_productfeed_entity_mappings')
      ->condition('entity_type', $entity_type)
      ->condition('entity_bundle', $bundle)
      ->execute();
    bazaarvoice_productfeed_trigger_rebuild();
  }
}

/**
 * Implements hook_bazaarvoice_products_delete_type().
 */
function bazaarvoice_productfeed_bazaarvoice_products_delete_type($entity_type, $bundle) {
  if (!bazaarvoice_products_is_product_type($entity_type, $bundle)) {
    // Delete all mappings.
    db_delete('bazaarvoice_productfeed_entity_mappings')
      ->condition('entity_type', $entity_type)
      ->condition('entity_bundle', $bundle)
      ->execute();
    // Trigger productfeed rebuild.
    bazaarvoice_productfeed_trigger_rebuild();
  }
}

/**
 * Implements hook_theme().
 */
function bazaarvoice_productfeed_theme($existing, $type, $theme, $path) {
  $templates = array();
  $templates['bazaarvoice_productfeed_admin_mappings'] = array(
    'render element' => 'element',
  );
  return $templates;
}

/**
 * Implements hook_features_api().
 */
function bazaarvoice_productfeed_features_api() {
  return array(
    'bazaarvoice_productfeed_attribute' => array(
      'name' => t('Bazaarvoice Custom Attributes'),
      'default_hook' => 'bazaarvoice_productfeed_attribute',
      'feature_source' => TRUE,
      'default_file' => FEATURES_DEFAULTS_INCLUDED,
      'file' => drupal_get_path('module', 'bazaarvoice_productfeed') . '/includes/features.attributes.inc',
    ),
    'bazaarvoice_productfeed_mapping' => array(
      'name' => t('Bazaarvoice Attribute Mapping'),
      'default_hook' => 'bazaarvoice_productfeed_mapping',
      'feature_source' => TRUE,
      'default_file' => FEATURES_DEFAULTS_INCLUDED,
      'file' => drupal_get_path('module', 'bazaarvoice_productfeed') . '/includes/features.mappings.inc',
    ),
  );
}

/**
 * Check to see if a rebuild of the productfeed is needed.
 *
 * @param object $entity
 *   An entity object.
 * @param string $type
 *   The entity type.
 */
function bazaarvoice_productfeed_entity_trigger_rebuild($entity, $type) {
  // Get entity id and bundle.
  list($id, $vid, $bundle) = entity_extract_ids($type, $entity);
  // Is the entity type a bazaarvoice product?
  if (bazaarvoice_products_get_entity_type_product_id($type, $bundle)) {
    // Trigger rebuild.
    bazaarvoice_productfeed_trigger_rebuild();
  };
}

/**
 * Trigger product feed to be rebuilt.
 */
function bazaarvoice_productfeed_trigger_rebuild() {
  // Trigger productfeed to be updated.
  variable_set('bazaarvoice_rebuild_productfeed', TRUE);
}

/**
 * Implements hook_form_alter().
 */
function bazaarvoice_productfeed_form_node_type_form_alter(&$form, &$form_state) {
  module_load_include('inc', 'bazaarvoice_productfeed', 'includes/attributes');
  if (user_access('administer bazaarvoice entity attribute mappings')) {
    $type = 'node';
    $bundle = $form['#node_type']->type;
    // Add a vertical tab to the node type form.
    $has_access = user_access('administer bazaarvoice product feed');
    $attributes = bazaarvoice_productfeed_get_entity_attributes($type, $bundle);
    // Allow other modules to alter attributes for display in form.
    drupal_alter('bazaarvoice_productfeed_entityform_attributes', $attributes, $type, $bundle);
    // Store attributes in form.
    $form['#bazaarvoice_attributes'] = $attributes;
    // Have everything to build mappings?
    if ($has_access && $attributes) {
      // Any previously posted data?
      if (isset($form_state['values']['bazaarvoice_mappings'])) {
        // Merge those values into the attributes array.
        $attributes = array_replace_recursive($attributes, $form_state['values']['bazaarvoice_mappings']);
      }
      // Build fieldset.
      $form['bazaarvoice_products']['bazaarvoice_mappings'] = array(
        '#type' => 'fieldset',
        '#title' => t('ProductFeed Attribute Field Mappings'),
        '#description' => t('Configure mappings between fields and Bazaarvoice product attributes.'),
        '#states' => array(
          'visible' => array(
            ':input[name="bazaarvoice_product"]' => array('checked' => TRUE),
          ),
        ),
        '#theme' => 'bazaarvoice_productfeed_admin_mappings',
        '#tree' => TRUE,
        '#weight' => 1,
      );
      // Loop through each attribute.
      foreach ($attributes as $attribute => $attribute_data) {
        $form['bazaarvoice_products']['bazaarvoice_mappings'][$attribute] = array(
          '#label' => $attribute_data['label'],
          '#prefix' => '<div class="bazaarvoice_' . strtolower($attribute) . '">',
          '#suffix' => '</div>',
        );
        // Build default options array.
        $options = array('' => t('Select Field'));
        // Available fields to select?
        if (isset($attribute_data['field_options'])) {
          $options += $attribute_data['field_options'];
        }
        // No fields to select, reset the options array.
        else {
          $options = array('' => t('No Fields Available'));
        }
        // Field for mapping primary field.
        $form['bazaarvoice_products']['bazaarvoice_mappings'][$attribute]['field'] = array(
          '#type' => 'select',
          '#options' => $options,
          '#default_value' => isset($attribute_data['field']) ? $attribute_data['field'] : '',
          '#disabled' => (count($options) == 1) ? TRUE : FALSE,
        );
        // Field for mapping sub field. Wrapper only for AJAX functionality.
        $form['bazaarvoice_products']['bazaarvoice_mappings'][$attribute]['sub_field'] = array(
          '#prefix' => '<div id="bazaarvoice_' . strtolower($attribute) . '_sub">',
          '#suffix' => '</div>',
        );
        // Support a sub field?
        if (bazaarvoice_prouductfeed_attribute_supports_subfield($attribute_data)) {
          $form['bazaarvoice_products']['bazaarvoice_mappings'][$attribute]['field']['#ajax'] = array(
            'callback' => 'bazaarvoice_productfeed_attribute_subfield_callback',
            'wrapper' => 'bazaarvoice_' . strtolower($attribute) . '_sub',
            'method' => 'replace',
          );
          // Display sub field based on selected field?
          $field_supports_sub = FALSE;
          if ($attribute_data['field'] && isset($attribute_data['fields'][$attribute_data['field']])) {
            // Check if supports sub field.
            $field_supports_sub = bazaarvoice_prouductfeed_attribute_supports_subfield(array(
              'field_types' => array(
                $attribute_data['fields'][$attribute_data['field']],
              ),
            ));
          }
          // Current field supports a subfield?
          if ($field_supports_sub) {
            // Retrieve sub fields.
            $sub_fields = bazaarvoice_productfeed_get_subfield_fields($attribute, $attribute_data, $attribute_data['field']);
            // Build options array.
            $sub_fields = array_merge(array('' => t('Select Field')), $sub_fields);
            // Have fields?
            if (count($sub_fields) == 1) {
              $sub_fields = array('' => t('No Fields Available'));
            }
            // Add sub field selector.
            $form['bazaarvoice_products']['bazaarvoice_mappings'][$attribute]['sub_field'] += array(
              '#type' => 'select',
              '#options' => $sub_fields,
              '#default_value' => $attribute_data['sub_field'],
              '#disabled' => (count($sub_fields) == 1) ? TRUE : FALSE,
            );
          }
        }
      }
      // Add custom validate.
      $form['#validate'][] = 'bazaarvoice_productfeed_node_type_form_validate';
      // Add custom submit.
      $form['#submit'][] = 'bazaarvoice_productfeed_node_type_form_submit';
    }
  }
}

/**
 * Validation callback for node type form.
 */
function bazaarvoice_productfeed_node_type_form_validate($form, &$form_state) {
  foreach ($form_state['values']['bazaarvoice_mappings'] as $attribute => $mapping) {
    // If have a subfield, but not mapped then throw an error.
    if (isset($mapping['sub_field']) && !$mapping['sub_field']) {
      $label = $form['bazaarvoice_products']['bazaarvoice_mappings'][$attribute]['#label'];
      form_set_error('bazaarvoice_mappings][' . $attribute . '][sub_field', t('Select a sub field for @attribute', array('@attribute' => $label)));
    }
  }
}

/**
 * Submit callback for node type form.
 */
function bazaarvoice_productfeed_node_type_form_submit($form, &$form_state) {
  // Bazaarvoice product check field checked?(from bazaarvoice_products module).
  if ($form_state['values']['bazaarvoice_product']) {
    // Get mappings from submitted form values.
    $mappings = $form_state['values']['bazaarvoice_mappings'];
    $old_mappings = array();
    // Get old mappings.
    foreach ($form['#bazaarvoice_attributes'] as $attribute => $mapping) {
      // Was the attribute not set to a field?
      $old_mappings[$attribute] = array(
        'field' => $mapping['field'],
      );
      // Mapping has a sub_field?
      if ($mapping['sub_field']) {
        $old_mappings[$attribute]['sub_field'] = $mapping['sub_field'];
      }
    }
    // Was data changed?
    if ($old_mappings != $mappings) {
      // Save changes.
      bazaarvoice_productfeed_save_entity_attributes('node', $form['#node_type']->type, $mappings);
    }
  }
  // No checked as a product type.
  else {
    // Delete any existing mappings.
    bazaarvoice_productfeed_delete_entity_attributes('node', $form['#node_type']->type);
  }
}

/**
 * AJAX callback for displaying sub-field select for an attribute.
 */
function bazaarvoice_productfeed_attribute_subfield_callback($form, &$form_state) {
  list($section, $mappings, $attribute) = $form_state['triggering_element']['#array_parents'];
  $form_state['#rebuild'] = TRUE;
  return $form[$section][$mappings][$attribute]['sub_field'];
}

/**
 * Theme callback for rendering attributes in form as a table.
 */
function theme_bazaarvoice_productfeed_admin_mappings($variables) {
  $element = $variables['element'];
  $table = array(
    '#theme' => 'table',
    '#header' => array(
      array('data' => t('Attribute')),
      array('data' => t('Field')),
      array('data' => t('Sub Field')),
    ),
    '#rows' => array(),
  );

  // Loop through each child.
  foreach (element_children($element) as $attribute) {
    $table['#rows'][] = array(
      array('data' => $element[$attribute]['#label']),
      drupal_render($element[$attribute]['field']),
      drupal_render($element[$attribute]['sub_field']),
    );
  }

  return render($table);
}

/**
 * Load a specific product feed attribute.
 *
 * @param string $attribute_name
 *   The name of the attribute to load.
 *
 * @return bool
 *   Attribute data or boolean false.
 */
function bazaarvoice_productfeed_attribute_load($attribute_name) {
  module_load_include('inc', 'bazaarvoice_productfeed', 'includes/attributes');
  // Retrieve attribute from DB.
  $attribute = bazaarvoice_productfeed_get_custom_attributes($attribute_name);
  return isset($attribute[$attribute_name]) ? $attribute[$attribute_name] : FALSE;
}

/**
 * Save attribute/field mappings for a particular entity type.
 *
 * @param string $type
 *   The entity type.
 * @param string $bundle
 *   The entity bundle.
 * @param array $mappings
 *   Array of attribute name => field name mappings.
 */
function bazaarvoice_productfeed_save_entity_attributes($type, $bundle, array $mappings) {
  // @TODO: presave hook?
  // Loop through each mapping.
  foreach ($mappings as $attribute => $mapping) {
    // Perform a merge query to either insert or update attribute.
    db_merge('bazaarvoice_productfeed_entity_mappings')
      ->key(array(
        'entity_type' => $type,
        'entity_bundle' => $bundle,
        'attribute' => $attribute,
      ))
      ->fields(array(
        'field_name' => $mapping['field'],
        'sub_field_name' => isset($mapping['sub_field']) ? $mapping['sub_field'] : '',
      ))
      ->execute();
  }
  // Trigger productfeed to be updated.
  bazaarvoice_productfeed_trigger_rebuild();
  // Let other modules know.
  module_invoke_all('bazaarvoice_productfeed_save_entity_attributes', $type, $bundle, $mappings);
}

/**
 * Delete attribute mappings for a particular entity type.
 *
 * @param string $type
 *   The entity type.
 * @param string $bundle
 *   The entity bundle.
 */
function bazaarvoice_productfeed_delete_entity_attributes($type, $bundle) {
  // @TODO: Pre delete hook?
  db_delete('bazaarvoice_productfeed_entity_mappings')
    ->condition('entity_type', $type)
    ->condition('entity_bundle', $bundle)
    ->execute();
  // Trigger productfeed to be updated.
  bazaarvoice_productfeed_trigger_rebuild();
  // Let other modules know.
  module_invoke_all('bazaarovice_productfeed_delete_entity_attributes', $type, $bundle);
}

/**
 * Delete productfeed attributes.
 *
 * @param array $attributes
 *   Array of attribute names to delete.
 */
function bazaarvoice_productfeed_delete_attributes(array $attributes) {
  // @TODO: predelete hook?
  // Passed a single attribute?
  if (!is_array($attributes)) {
    $attributes = array($attributes);
  }
  // Delete attribute mappings.
  db_delete('bazaarvoice_productfeed_entity_mappings')
    ->condition('attribute', $attributes, 'IN')
    ->execute();
  // Delete the attribute.
  db_delete('bazaarvoice_productfeed_custom_attributes')
    ->condition('attribute', $attributes, 'IN')
    ->execute();
  // Trigger productfeed to be updated.
  bazaarvoice_productfeed_trigger_rebuild();
  // Let other modules know.
  module_invoke_all('bazaarvoice_productfeed_delete_attributes', $attributes);
}

/**
 * Retrieve an array of products and their attributes.
 *
 * @return mixed
 *   Array of products with attribute values.
 */
function bazaarvoice_productfeed_get_products() {
  $products = &drupal_static(__FUNCTION__);
  // Not already retrieved products and have entity types that are products?
  if (!isset($products) && $entity_types = bazaarvoice_products_get_product_entity_types()) {
    module_load_include('inc', 'bazaarvoice_productfeed', 'includes/attributes');
    // Get locales.
    $locales = bazaarvoice_get_locales();
    // Loop through the types.
    foreach ($entity_types as $type => $bundles) {
      // Loop through the bundles.
      foreach (array_keys($bundles) as $bundle) {
        // Get all entities of this type & bundle.
        $query = new EntityFieldQuery();
        $query->entityCondition('entity_type', $type);
        $query->entityCondition('bundle', $bundle);
        $query = $query->execute();
        // Entities retrieved?
        if (isset($query[$type])) {
          // Get the entity attributes.
          $attributes = bazaarvoice_productfeed_get_entity_attributes($type, $bundle);
          // Get the entity attribute mappings.
          $mappings = bazaarvoice_productfeed_get_entity_mappings($type, $bundle, $attributes);
          // Load the entities.
          $entities = entity_load($type, array_keys($query[$type]));
          // Loop through each entity.
          foreach ($entities as $eid => $entity) {
            $product = array();
            // Get metadata for entity?
            $metadata = entity_metadata_wrapper($type, $entity);
            // Loop through each attribute.
            foreach ($mappings as $attribute => $fields) {
              $field = $fields['field'];
              // No field set? skip.
              if (!$field) {
                continue;
              }
              // Sub field?
              $sub_field = isset($fields['sub_field']) ? $fields['sub_field'] : FALSE;
              // Field exists as part of metadata?
              if (isset($metadata->$field)) {
                // Get the default value.
                $field_value = $metadata->$field->value();
              }
              // Hmm.. not in metadata. Title or something?
              else {
                // Get value from entity itself.
                $field_value = $entity->$field;
              }
              // Get the value for the attribute.
              $attribute_value = bazaarvoice_productfeed_get_field_value($field_value, $field, $sub_field);
              // Format the value.
              bazaarvoice_productfeed_format_attribute_value($attribute_value, $attribute);
              // Assign to product attribute.
              $product[$attribute] = $attribute_value;
              // Attribute supports multiple values?
              if (isset($attributes[$attribute]['multiple'])) {
                // Supports translation?
                if (isset($attributes[$attribute]['translatable']) && $attributes[$attribute]['translatable']) {
                  // Loop through all languages to get values.
                  foreach ($locales as $language => $locale) {
                    // Get the language specific value.
                    if ($lang_value = bazaarvoice_productfeed_get_field_value($metadata->language($language)->$field->value(), $field, $sub_field)) {
                      // Format the value.
                      bazaarvoice_productfeed_format_attribute_value($lang_value, $attribute);
                      // Set to the product as an attribute value.
                      $product[$attributes[$attribute]['multiple']][$locale] = $lang_value;
                    }
                  }
                }
                // Else is the value an array?
                elseif (is_array($product[$attribute])) {
                  // Move array to multiple attribute.
                  $product[$attributes[$attribute]['multiple']][] = $product[$attribute];
                  // Set the attribute to the first array value.
                  $product[$attribute] = reset($product[$attribute]);
                }
              }
              // Does not support multiple, but value is an array?
              elseif (is_array($product[$attribute])) {
                // Use the first value.
                $product[$attribute] = reset($product[$attribute]);
              }
            }
            // Add to products array.
            $products[$eid] = $product;
          }
        }
      }
    }
  }
  // Allow other modules to alter the products.
  drupal_alter('bazaarvoice_productfeed_products', $products);
  return $products;
}

/**
 * Return a list of sub fields for an attribute field mapping.
 *
 * @param string $attribute_name
 *   Name of attribute.
 * @param array $attribute_data
 *   Attribute data, such as what field types are supported.
 * @param string $field_name
 *   The name of the field selected for the parent field.
 *
 * @return array
 *   Array of sub fields.
 */
function bazaarvoice_productfeed_get_subfield_fields($attribute_name, array $attribute_data, $field_name) {
  $sub_fields = array();
  // Only care about the field types.
  $attribute_data = array(
    'field_types' => $attribute_data['field_types'],
  );
  // Get field info.
  $field_info = field_info_field($field_name);
  // Field is a taxonomy_term_reference?
  if ($field_info['type'] == 'taxonomy_term_reference') {
    // For each taxonomy allowed.
    foreach ($field_info['settings']['allowed_values'] as $taxonomy) {
      // Get fields supported by this vocabulary for this attribute.
      $attributes = bazaarvoice_productfeed_get_entity_attributes('taxonomy_term', $taxonomy['vocabulary'], array($attribute_name => $attribute_data));
      // Field options returned?
      if (isset($attributes[$attribute_name]['field_options'])) {
        // Add to list of sub_fields.
        $sub_fields = array_merge($sub_fields, $attributes[$attribute_name]['field_options']);
      }
    }
  }
  elseif ($field_info['type'] == 'entityreference') {
    // Foreach entity bundle.
    foreach ($field_info['settings']['handler_settings']['target_bundles'] as $bundle) {
      // Get the attributes supported by this entity.
      $attributes = bazaarvoice_productfeed_get_entity_attributes($field_info['settings']['target_type'], $bundle, array($attribute_name => $attribute_data));
      // Field options returned?
      if (isset($product_fields[$attribute_name]['field_options'])) {
        // Add to list of sub_fields.
        $sub_fields = array_merge($sub_fields, $attributes[$attribute_name]['field_options']);
      }
    }
  }
  // Allow other modules to dictate.
  else {
    $sub_fields = module_invoke_all('bazaarvoice_productfeed_subfield_fields', $attribute_name, $attribute_data, $field_name);
  }
  // Allow other modules to alter.
  drupal_alter('bazaarvoice_productfeed_subfield_fields', $sub_fields, $attribute_data, $field_name);
  return $sub_fields;
}

/**
 * Retrieve the correct value from an entity field.
 *
 * @param mixed $data
 *   Data from the entity field.
 * @param string $field
 *   Field name.
 * @param bool $sub_field
 *   Sub field name or boolean FALSE.
 *
 * @return array|bool|string
 *   Properly retrieved value for field.
 */
function bazaarvoice_productfeed_get_field_value($data, $field, $sub_field = FALSE) {
  $value = $data;
  // Attempt to get field info.
  if ($field_info = field_info_field($field)) {
    // Switch based on field type.
    switch ($field_info['type']) {
      // Basic text field.
      case 'text':
        // Do nothing value = data.
        break;

      // Longer text areas.
      case 'text_long':
      case 'text_with_summary':
        // Get the 'value'.
        $value = $data['value'];
        break;

      // Image fields.
      case 'image':
        // Is an array?
        if (is_array($data)) {
          // This level have a uri? No? multiple images then.
          if (!isset($data['uri'])) {
            $value = array();
            // Loop through each data as an image.
            foreach ($data as $img) {
              // Have a uri?
              if (isset($img['uri'])) {
                // Create url.
                $value[] = file_create_url($img['uri']);
              }
            }
            // Empty array?
            if (!$value) {
              $value = '';
            }
          }
          // Has a uri value.
          else {
            // Create url.
            $value = file_create_url($data['uri']);
          }
        }
        else {
          $value = '';
        }
        break;

      // Taxonomy or Entity reference & entityreference.
      case 'taxonomy_term_reference':
      case 'entityreference':
        // Get the entity type.
        if ($field_info['type'] == 'entityreference') {
          $entity_type = $field_info['settings']['target_type'];
        }
        // Else is taxonomy_term_reference, know its a taxonomy_term.
        else {
          $entity_type = 'taxonomy_term';
        }
        // Only passed a single one? treat it like multiple.
        if (is_object($data)) {
          $data = array($data);
        }
        if (is_array($data)) {
          $value = array();
          // Loop through each entity.
          foreach ($data as $entity) {
            // Get the entity id fields.
            list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);
            // Have a sub_field ?
            if ($sub_field) {
              // Get the metadata.
              $metadata = entity_metadata_wrapper($entity_type, $id);
              // Subfield part of metadata?
              if (isset($metadata->$sub_field)) {
                $sub_field_value = $metadata->$sub_field->value();
              }
              // No? part of the entity then?
              elseif (isset($entity->$sub_field)) {
                $sub_field_value = $entity->$sub_field;
              }
              // Else use the id?
              else {
                $sub_field_value = $id;
              }
              // Get actual value.
              if ($sub_field_value = bazaarvoice_productfeed_get_field_value($sub_field_value, $sub_field)) {
                // Add sub field value to array.
                $value[] = $sub_field_value;
              }
              // Else use the id?
              else {
                $value[] = $id;
              }
            }
            // No sub field, use the id then?
            else {
              $value[] = $id;
            }
          }
          if (!$value) {
            $value = '';
          }
        }
        break;

      default:
        // Allow other modules to retrieve the value.
        $value = module_invoke_all('bazaarvoice_productfeed_field_value', $data, $field, $sub_field);
        break;
    }
  }
  $info = array(
    'field' => $field,
    'sub_field' => $sub_field,
  );
  // Allow other modules to alter.
  drupal_alter('bazaarvoice_productfeed_field_value', $value, $data, $info);
  return $value;
}
