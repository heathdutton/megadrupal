<?php
/**
 * @file
 * Provides integration with Moneris API payment method (on-site).
 */

define('COMMERCE_PAYMENT_STATUS_MONERIS_AUTHORISED', 'moneris_authorised');
define('COMMERCE_PAYMENT_STATUS_MONERIS_REVERSED', 'moneris_reversed');

define('COMMERCE_MONERIS_API_TRANSACTION_TYPE_PURCHASE', '00');
define('COMMERCE_MONERIS_API_TRANSACTION_TYPE_AUTH', '01');
define('COMMERCE_MONERIS_API_TRANSACTION_TYPE_CAPTURE', '02');
define('COMMERCE_MONERIS_API_TRANSACTION_TYPE_REFUND', '04');

/**
 * Implements hook_commerce_payment_method_info().
 */
function commerce_moneris_api_commerce_payment_method_info() {
  $payment_methods = array();

  $payment_methods['commerce_moneris_api'] = array(
    'title' => 'Moneris API',
    'display_title' => t('Credit card'),
    'description' => t('Moneris API payment method (on-site)'),
  );

  return $payment_methods;
}

/**
 * Implements hook_commerce_payment_transaction_status_info().
 *
 * We needed new success statuses for authorisation and reverse transactions,
 * as we cannot use standard COMMERCE_PAYMENT_STATUS_SUCCESS, because these
 * transactions should not be included in order balance calculations.
 */
function commerce_moneris_api_commerce_payment_transaction_status_info() {
  $statuses = array();

  $statuses[COMMERCE_PAYMENT_STATUS_MONERIS_AUTHORISED] = array(
    'status' => COMMERCE_PAYMENT_STATUS_MONERIS_AUTHORISED,
    'title' => t('Authorised'),
    'icon' => drupal_get_path('module', 'commerce_payment') . '/theme/icon-success.png',
    'total' => FALSE,
  );

  $statuses[COMMERCE_PAYMENT_STATUS_MONERIS_REVERSED] = array(
    'status' => COMMERCE_PAYMENT_STATUS_MONERIS_REVERSED,
    'title' => t('Reversed'),
    'icon' => drupal_get_path('module', 'commerce_payment') . '/theme/icon-success.png',
    'total' => FALSE,
  );

  return $statuses;
}

/**
 * Implements hook_libraries_info().
 */
function commerce_moneris_api_libraries_info() {
  $libraries['moneris-api-us'] = array(
    'name' => 'Moneris API (US)',
    'vendor url' => 'https://developer.moneris.com/',
    'download url' => 'https://github.com/maciejzgadzaj/moneris-api-us/archive/master.zip',
    'version' => '3.2.0+',
    'files' => array(
      'php' => array('mpgClasses.php'),
    ),
  );
  $libraries['moneris-api-ca'] = array(
    'name' => 'Moneris API (CA)',
    'vendor url' => 'https://developer.moneris.com/',
    'download url' => 'https://github.com/maciejzgadzaj/moneris-api-ca/archive/master.zip',
    'version' => '2.5.6+',
    'files' => array(
      'php' => array('mpgClasses.php'),
    ),
  );

  return $libraries;
}

/**
 * Loads required Moneris API library.
 *
 * @param string $library_name
 *   Name of the Moneris API library to load.
 */
function commerce_moneris_api_libraries_load($library_name) {
  if (module_exists('libraries')) {
    libraries_load($library_name);
  }
  else {
    module_load_include('php', 'commerce_moneris_api', "includes/$library_name/mpgClasses");
  }
}

/**
 * Implements hook_menu().
 */
function commerce_moneris_api_menu() {
  $items = array();

  // The Refund will credit a specified amount to the cardholderâ€™s credit card.
  // A Refund can be sent up to the full value of the original Capture or Purchase.
  $items['admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/moneris-api-refund'] = array(
    'title' => 'Refund',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_moneris_api_refund_form', 3, 5),
    'access callback' => 'commerce_moneris_api_access_refund',
    'access arguments' => array(3, 5),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'weight' => 2,
    'file' => 'commerce_moneris_api.admin.inc',
  );

  // The Capture transaction is used to secure the funds locked by a PreAuth
  // or ReAuth transaction. A PreAuth or ReAuth transaction can only be captured
  // once.
  $items['admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/moneris-api-capture'] = array(
    'title' => 'Capture',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_moneris_api_capture_form', 3, 5),
    'access callback' => 'commerce_moneris_api_access_capture',
    'access arguments' => array(3, 5),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'weight' => 2,
    'file' => 'commerce_moneris_api.admin.inc',
  );

  // Reverse.
  $items['admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/moneris-api-reverse'] = array(
    'title' => 'Reverse',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_moneris_api_reverse_form', 3, 5),
    'access callback' => 'commerce_moneris_api_access_reverse',
    'access arguments' => array(3, 5),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'weight' => 3,
    'file' => 'commerce_moneris_api.admin.inc',
  );

  // ReAuth.
  $items['admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/moneris-api-reauth'] = array(
    'title' => 'ReAuth',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_moneris_api_reauth_form', 3, 5),
    'access callback' => 'commerce_moneris_api_access_reauth',
    'access arguments' => array(3, 5),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'weight' => 3,
    'file' => 'commerce_moneris_api.admin.inc',
  );

  return $items;
}

/**
 * Determines user access to Refund operation on the prior payment transaction.
 *
 * @param $order
 *   The order the transaction was made on.
 * @param $transaction
 *   The original payment transaction object.
 *
 * @return
 *   TRUE or FALSE indicating access to the operation.
 */
function commerce_moneris_api_access_refund($order, $transaction) {
  if (
    !commerce_moneris_api_access_common($order, $transaction)
    // Refund could be done only for Purchase (00) or Capture (02) transactions.
    || (
      $transaction->remote_status != COMMERCE_MONERIS_API_TRANSACTION_TYPE_PURCHASE
      && $transaction->remote_status != COMMERCE_MONERIS_API_TRANSACTION_TYPE_CAPTURE
      // Moneris API payment solution is also used for Refund, Reverse, Capture
      // and ReAuth transactions done on HPP's Purchase and PreAuth transactions.
      && $transaction->remote_status != COMMERCE_MONERIS_HPP_TRANSACTION_TYPE_PURCHASE
    )
  ) {
    return FALSE;
  }

  // A refund can be sent only up to the full value of the original capture or
  // purchase - so if full amount of original transaction was already refunded,
  // we don't want to allow for another refund.
  $conditions = array(
    'order_id' => $order->order_id,
    'payment_method' => 'commerce_moneris_api',
    'remote_status' => COMMERCE_MONERIS_API_TRANSACTION_TYPE_REFUND,
    'status' => COMMERCE_PAYMENT_STATUS_SUCCESS,
  );
  // If the original transaction was done using the API payment method, we need
  // to make sure that possible Refunds are done using the same instance.
  if ($transaction->payment_method == 'commerce_moneris_api') {
    $conditions['instance_id'] = $transaction->instance_id;
  }
  $refunded_amount = 0;
  foreach (commerce_payment_transaction_load_multiple(array(), $conditions) as $refund_transaction) {
    if ($refund_transaction->payload['related_order_id'] == $transaction->payload['unique_order_id']) {
      $refunded_amount += $refund_transaction->amount;
    }
  }
  // Refund transactions have negative amounts, so we need to check their
  // absolute amounts.
  if (abs($refunded_amount) >= $transaction->amount) {
    return FALSE;
  }

  // Allow access if the user can update this transaction.
  return commerce_payment_transaction_access('update', $transaction);
}

/**
 * Determines user access to Capture operation on the prior authorisation
 * transaction.
 *
 * @param $order
 *   The order the transaction was made on.
 * @param $transaction
 *   The original payment transaction object.
 *
 * @return
 *   TRUE or FALSE indicating access to the operation.
 */
function commerce_moneris_api_access_capture($order, $auth_transaction) {
  if (
    !commerce_moneris_api_access_common($order, $auth_transaction)
    // Capture could be done only for PreAuth/ReAuth (01) transactions.
    || (
      $auth_transaction->remote_status != COMMERCE_MONERIS_API_TRANSACTION_TYPE_AUTH
      // Moneris API payment solution is also used for Refund, Reverse, Capture
      // and ReAuth transactions done on HPP's Purchase and PreAuth transactions.
      && $auth_transaction->remote_status != COMMERCE_MONERIS_HPP_TRANSACTION_TYPE_AUTH
    )
  ) {
    return FALSE;
  }

  // A PreAuth or ReAuth transaction can be captured only once, therefore we
  // need to make sure that there are no already existing successful capture
  // (or reverse) transactions for this authorisation transaction.
  $conditions = array(
    'order_id' => $order->order_id,
    'payment_method' => 'commerce_moneris_api',
    'remote_status' => array(
      COMMERCE_MONERIS_API_TRANSACTION_TYPE_CAPTURE,
      COMMERCE_MONERIS_HPP_TRANSACTION_TYPE_AUTH,
    ),
    'status' => array(
      COMMERCE_PAYMENT_STATUS_SUCCESS,
      COMMERCE_PAYMENT_STATUS_MONERIS_REVERSED,
    ),
  );
  // If the original transaction was done using the API payment method, we need
  // to make sure that possible Captures are done using the same instance.
  if ($auth_transaction->payment_method == 'commerce_moneris_api') {
    $conditions['instance_id'] = $auth_transaction->instance_id;
  }
  foreach (commerce_payment_transaction_load_multiple(array(), $conditions) as $capture_transaction) {
    if ($capture_transaction->payload['related_order_id'] == $auth_transaction->payload['unique_order_id']) {
      return FALSE;
    }
  }

  // Allow access if the user can update this transaction.
  return commerce_payment_transaction_access('update', $auth_transaction);
}

/**
 * Determines user access to Reverse operation on the prior authorisation
 * transaction.
 *
 * @param $order
 *   The order the transaction was made on.
 * @param $transaction
 *   The original payment transaction object.
 *
 * @return
 *   TRUE or FALSE indicating access to the operation.
 */
function commerce_moneris_api_access_reverse($order, $auth_transaction) {
  if (
    !commerce_moneris_api_access_common($order, $auth_transaction)
    // Reverse could be done only for PreAuth (01) transactions.
    || (
      $auth_transaction->remote_status != COMMERCE_MONERIS_API_TRANSACTION_TYPE_AUTH
      // Moneris API payment solution is also used for Refund, Reverse, Capture
      // and ReAuth transactions done on HPP's Purchase and PreAuth transactions.
      && $auth_transaction->remote_status != COMMERCE_MONERIS_HPP_TRANSACTION_TYPE_AUTH
    )
  ) {
    return FALSE;
  }

  // Reverse could be done only on the full amount of PreAuth transaction,
  // therefore we need to make sure that there is no already existing
  // successful capture transaction for this authorisation transaction.
  // Also, no already existing reverse transaction either.
  $conditions = array(
    'order_id' => $order->order_id,
    'payment_method' => 'commerce_moneris_api',
    'remote_status' => array(
      COMMERCE_MONERIS_API_TRANSACTION_TYPE_CAPTURE,
      COMMERCE_MONERIS_HPP_TRANSACTION_TYPE_AUTH,
    ),
    'status' => array(
      COMMERCE_PAYMENT_STATUS_SUCCESS,
      COMMERCE_PAYMENT_STATUS_MONERIS_REVERSED,
    ),
  );
  // If the original transaction was done using the API payment method, we need
  // to make sure that possible Reverses are done using the same instance.
  if ($auth_transaction->payment_method == 'commerce_moneris_api') {
    $conditions['instance_id'] = $auth_transaction->instance_id;
  }
  foreach (commerce_payment_transaction_load_multiple(array(), $conditions) as $capture_transaction) {
    if (
      !empty($capture_transaction->payload['related_order_id'])
      && $capture_transaction->payload['related_order_id'] == $auth_transaction->payload['unique_order_id']
    ) {
      return FALSE;
    }
  }

  // Allow access if the user can update this transaction.
  return commerce_payment_transaction_access('update', $auth_transaction);
}

/**
 * Determines user access to ReAuth operation on the prior authorisation
 * transaction.
 *
 * @param $order
 *   The order the transaction was made on.
 * @param $transaction
 *   The original payment transaction object.
 *
 * @return
 *   TRUE or FALSE indicating access to the operation.
 */
function commerce_moneris_api_access_reauth($order, $auth_transaction) {
  if (
    !commerce_moneris_api_access_common($order, $auth_transaction)
    // Reverse could be done only for PreAuth (01) transactions.
    || (
      $auth_transaction->remote_status != COMMERCE_MONERIS_API_TRANSACTION_TYPE_AUTH
      // Moneris API payment solution is also used for Refund, Reverse, Capture
      // and ReAuth transactions done on HPP's Purchase and PreAuth transactions.
      && $auth_transaction->remote_status != COMMERCE_MONERIS_HPP_TRANSACTION_TYPE_AUTH
    )
  ) {
    return FALSE;
  }

  // ReAuth should only be available for PreAuth transactions, for which only
  // part of the authorised amount was already captured (but not all of it).
  // That's because PreAuth may be captured only once, and if it is done for
  // the smaller amount than original authorisation, ReAuth is needed for the
  // merchant to be able to capture the remaining amount.
  $conditions = array(
    'order_id' => $order->order_id,
    'payment_method' => 'commerce_moneris_api',
    'remote_status' => array(
      COMMERCE_MONERIS_API_TRANSACTION_TYPE_AUTH,
      COMMERCE_MONERIS_API_TRANSACTION_TYPE_CAPTURE,
      COMMERCE_MONERIS_HPP_TRANSACTION_TYPE_AUTH,
    ),
    'status' => array(
      COMMERCE_PAYMENT_STATUS_SUCCESS,
      COMMERCE_PAYMENT_STATUS_MONERIS_AUTHORISED,
    ),
  );
  // If the original transaction was done using the API payment method, we need
  // to make sure that possible ReAuths are done using the same instance.
  if ($auth_transaction->payment_method == 'commerce_moneris_api') {
    $conditions['instance_id'] = $auth_transaction->instance_id;
  }
  $captured_amount = 0;
  foreach (commerce_payment_transaction_load_multiple(array(), $conditions) as $capture_transaction) {
    if (
      !empty($capture_transaction->payload['related_order_id'])
      && $capture_transaction->payload['related_order_id'] == $auth_transaction->payload['unique_order_id']
    ) {
      $captured_amount += $capture_transaction->amount;
    }
  }
  // If nothing was yet captured, or captured amount equals or is higher than
  // initially authorised amount, ReAuth should not be available.
  if (
    $captured_amount == 0
    || $captured_amount >= $auth_transaction->amount
  ) {
    return FALSE;
  }

  // Allow access if the user can update this transaction.
  return commerce_payment_transaction_access('update', $auth_transaction);
}

/**
 * Determines generic access to am operation on the prior transactions.
 *
 * @param $order
 *   The order the transaction was made on.
 * @param $transaction
 *   The original payment transaction object.
 *
 * @return
 *   TRUE or FALSE indicating access to the operation.
 */
function commerce_moneris_api_access_common($order, $transaction) {
  // Return FALSE if the original transaction wasn't for Moneris API,
  // wasn't successful, or we don't have its remote_id.
  if (
    $transaction->payment_method != 'commerce_moneris_api'
    && $transaction->payment_method != 'commerce_moneris_hpp'
    || (
      $transaction->status != COMMERCE_PAYMENT_STATUS_SUCCESS
      && $transaction->status != COMMERCE_PAYMENT_STATUS_MONERIS_AUTHORISED
    )
    || empty($transaction->remote_id)
  ) {
    return FALSE;
  }

  // Get all *enabled* API payment method instances.
  $enabled_api_instances = commerce_moneris_payment_method_instances('commerce_moneris_api');

  // Refuse access if original API payment method instance is no longer enabled.
  if (
    $transaction->payment_method == 'commerce_moneris_api'
    && !in_array($transaction->instance_id, array_keys($enabled_api_instances))
  ) {
    return FALSE;
  }

  // Original payment was done using HPP payment method.
  if ($transaction->payment_method == 'commerce_moneris_hpp') {
    $hpp_instance = commerce_payment_method_instance_load($transaction->instance_id);
    // No API payment method is selected for original HPP method instance.
    if (empty($hpp_instance['settings']['moneris_api'])) {
      return FALSE;
    }
    // API payment method selected in HPP configuration is not enabled.
    $api_instance = commerce_payment_method_instance_load($hpp_instance['settings']['moneris_api']);
    if (!$api_instance || !in_array($hpp_instance['settings']['moneris_api'], array_keys($enabled_api_instances))) {
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Implements hook_help().
 */
function commerce_moneris_api_help($path, $arg) {
  switch ($path) {
    // Display help on Moneris transaction operations on order Payment page.
    case 'admin/commerce/orders/%/payment':
      // Display help only if at least one Moneris API transaction already exists.
      $conditions = array(
        'order_id' => $arg[3],
        'payment_method' => array('commerce_moneris_api', 'commerce_moneris_hpp'),
      );
      if (commerce_payment_transaction_load_multiple(array(), $conditions)) {
        return '<p>' . t('Possible operations on <em>Moneris API</em> transactions:') . '</p><p><ul>'
          . '<li>' . t('<b><em>Refund</em></b> will credit a specified amount to the cardholderâ€™s credit card. A <em>Refund</em> can be sent up to the full value of the original <em>Capture</em> or <em>Purchase</em>.') . '</li>'
          . '<li>' . t('<b><em>PreAuth</em></b> transactions <b>must</b> be reversed if they are not to be captured. <em>PreAuth</em> may only be captured <b>once</b> for less than, equal to, or greater than the original <em>PreAuth</em> amount. If the <em>PreAuth</em> is captured for less than its total amount, then a <em>ReAuth</em> is first required to be able to capture the remainder.') . '</li>'
          . '<li>' . t('<b><em>ReAuth</em></b> will only allow the merchant to re-authorise funds on the credit card used in the original transaction for no more than the uncaptured amount.') . '</li>'
          . '<li>' . t('<b><em>Capture</em></b> transaction is used to secure the funds locked by a <em>PreAuth</em> or <em>ReAuth</em> transaction.') . '</li>'
          . '<li>' . t('<b><em>Reverse</em></b> transaction is used to release the funds locked by a <em>PreAuth</em> or <em>ReAuth</em> transaction.') . '</li>'
          . '</ul></p>';
      }
  }
}

/**
 * Payment method callback: settings form.
 */
function commerce_moneris_api_settings_form($settings = array()) {
  // Merge default settings into the stored settings array.
  // Settings are stored in multi-level array, so we need recursive merge. And
  // actually replace instead of merge, to make sure the default settings are
  // correctly overriden by custom user settings (array_merge_recursive() would
  // just add new array elements instead of overriding existing ones).
  $settings = array_replace_recursive(commerce_moneris_api_settings_default(), $settings);

  $form = array();

  $form['gateway'] = array(
    '#type' => 'select',
    '#title' => t('Gateway'),
    '#options' => commerce_moneris_gateways(TRUE),
    '#default_value' => $settings['gateway'],
  );

  $form['server'] = array(
    '#type' => 'radios',
    '#title' => t('Environment'),
    '#options' => commerce_moneris_environments(TRUE),
    '#default_value' => $settings['server'],
  );

  // Collect Moneris Store ID and API Token for each available environment.
  foreach (commerce_moneris_gateways() as $gateway_id => $gateway) {
    foreach (commerce_moneris_environments() as $environment_id => $environment) {

      $form[$gateway_id][$environment_id]['store_id'] = array(
        '#type' => 'textfield',
        '#title' => t('@gateway @environemnt Store ID', array(
          '@gateway' => $gateway,
          '@environemnt' => $environment,
        )),
        '#default_value' => $settings[$gateway_id][$environment_id]['store_id'],
        '#states' => array(
          'visible' => array(
            ':input[name*="gateway"]' => array('value' => $gateway_id),
            ':input[name*="server"]' => array('value' => $environment_id),
          ),
          'required' => array(
            ':input[name*="gateway"]' => array('value' => $gateway_id),
            ':input[name*="server"]' => array('value' => $environment_id),
          ),
        ),
      );

      $form[$gateway_id][$environment_id]['api_token'] = array(
        '#type' => 'textfield',
        '#title' => t('@gateway @env API Token', array(
          '@gateway' => $gateway,
          '@env' => $environment,
        )),
        '#default_value' => $settings[$gateway_id][$environment_id]['api_token'],
        '#states' => array(
          'visible' => array(
            ':input[name*="gateway"]' => array('value' => $gateway_id),
            ':input[name*="server"]' => array('value' => $environment_id),
          ),
          'required' => array(
            ':input[name*="gateway"]' => array('value' => $gateway_id),
            ':input[name*="server"]' => array('value' => $environment_id),
          ),
        ),
      );
    }

    $form[$gateway_id]['txn_type'] = array(
      '#type' => 'radios',
      '#title' => t('Default @gateway credit card transaction type', array('@gateway' => $gateway)),
      '#options' => commerce_moneris_api_get_transaction_types($gateway_id),
      '#default_value' => $settings[$gateway_id]['txn_type'],
      '#states' => array(
        'visible' => array(
          ':input[name*="gateway"]' => array('value' => $gateway_id),
        ),
        'required' => array(
          ':input[name*="gateway"]' => array('value' => $gateway_id),
        ),
      ),
    );

    $form[$gateway_id]['extra'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Extra features'),
      '#description' => t('To have the eFraud features added to your merchant profile, please call Moneris Service Centre to have your profile updated.'),
      '#options' => array(
        'cvd' => t('eFraud: Enable CVD (Card Validation Digits)'),
        'avs' => t('eFraud: Enable AVS verification (Address Verification System)'),
        'ssl' => t('Use SSL'),
      ),
      '#default_value' => $settings[$gateway_id]['extra'],
      '#states' => array(
        'visible' => array(
          ':input[name*="gateway"]' => array('value' => $gateway_id),
        ),
      ),
    );

    $form[$gateway_id]['curl_certificate_path'] = array(
      '#type' => 'textfield',
      '#title' => t('cURL certificate'),
      '#description' => t('Path to the cURL certificate file <em>cacert.pem</em>, either absolute or relative to Drupal installation (including certificate file name - for example <em>/etc/ssl/certs/cacert.pem</em>). You can download it from <a href="@download_url">CA Extract page</a>.', array('@download_url' => url('http://curl.haxx.se/docs/caextract.html'))),
      '#default_value' => $settings[$gateway_id]['curl_certificate_path'],
      '#states' => array(
        'visible' => array(
          ':input[name*="gateway"]' => array('value' => $gateway_id),
          ':input[name*="' . $gateway_id . '][extra][ssl]"]' => array('checked' => TRUE),
        ),
        'required' => array(
          ':input[name*="' . $gateway_id . '][extra][ssl]"]' => array('checked' => TRUE),
        ),
      ),
    );

  }

  $form['log'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Log the following messages for debugging'),
    '#description' => t('Basic transaction-related request and response data will be saved in transaction <em>payload</em> property regardless of this setting. Enabling this option will save additional information on each transaction request and response in the dblog.'),
    '#options' => array(
      'request' => t('API request messages'),
      'response' => t('API response messages'),
    ),
    '#default_value' => $settings['log'],
  );

  return $form;
}

/**
 * Returns default settings for the Moneris API payment method.
 *
 * @see commerce_moneris_api_settings_form()
 */
function commerce_moneris_api_settings_default() {
  $default_settings = array(
    'gateway' => COMMERCE_MONERIS_USA,
    'server' => 'test',
    'log' => array(),
  );
  foreach (commerce_moneris_gateways() as $gateway_id => $gateway) {
    foreach (commerce_moneris_environments() as $environment_id => $environment) {
      $default_settings[$gateway_id][$environment_id]['store_id'] = '';
      $default_settings[$gateway_id][$environment_id]['api_token'] = '';
    }
    // For default transaction type we return key of the first defined type.
    $transaction_types = commerce_moneris_api_get_transaction_types($gateway_id);
    reset($transaction_types);
    $default_settings[$gateway_id]['txn_type'] = key($transaction_types);
    $default_settings[$gateway_id]['extra'] = array(
      'avs' => 'avs',
      'cvd' => 'cvd',
      'ssl' => FALSE,
    );
    $default_settings[$gateway_id]['curl_certificate_path'] = '';
  }
  return $default_settings;
}

/**
 * Payment method callback: checkout form.
 */
function commerce_moneris_api_submit_form($payment_method, $pane_values, $checkout_pane, $order) {
  module_load_include('inc', 'commerce_payment', 'includes/commerce_payment.credit_card');
  return commerce_payment_credit_card_form(array('code' => ''));
}

/**
 * Payment method callback: checkout form validation.
 */
function commerce_moneris_api_submit_form_validate($payment_method, $pane_form, $pane_values, $order, $form_parents = array()) {
  $gateway = $payment_method['settings']['gateway'];
  $wrapper = entity_metadata_wrapper('commerce_order', $order);
  $order_total = $wrapper->commerce_order_total->value();

  // Make sure the order uses the same currency as the gateway, otherwise
  // return an error.
  // The problem is that both Moneris gateways support only one currency native
  // to their relevant country, so the currency of the requested transactions
  // is not configurable - therefore is has to be the same as the gateway
  // supported currency.
  $gateway_currency_code = commerce_moneris_currency($gateway);
  if ($order_total['currency_code'] != $gateway_currency_code) {
    $order_link = l(t('view order'), 'admin/commerce/orders/' . $order->order_id);
    watchdog('commerce_moneris_api', 'Unable to request the payment for order ID @order_id. Order currency (@order_currency) must be the same as selected Moneris gateway currency (@gateway_currency) for payment method @payment_method.', array(
      '@order_id' => $order->order_id,
      '@order_currency' => $order_total['currency_code'],
      '@gateway_currency' => $gateway_currency_code,
      '@payment_method' => $payment_method['instance_id'],
    ), WATCHDOG_ERROR, $order_link);
    drupal_set_message('We encountered an error processing your transaction. Please contact us to resolve the issue.', 'error');
    return FALSE;
  }

  module_load_include('inc', 'commerce_payment', 'includes/commerce_payment.credit_card');

  // Validate the credit card fields.
  $settings = array(
    'form_parents' => array_merge($form_parents, array('credit_card')),
  );

  if (!commerce_payment_credit_card_validate($pane_values['credit_card'], $settings)) {
    return FALSE;
  }
}

/**
 * Payment method callback: checkout form submission.
 */
function commerce_moneris_api_submit_form_submit($payment_method, $pane_form, $pane_values, $order, $charge) {
  return commerce_moneris_api_transaction_purchase($payment_method, $order, $charge, $pane_values);
}

/**
 * Prepares and posts data to Moneris API, processes its response
 * and creates a payment transaction.
 *
 * @param array $payment_method
 *   The payment method instance object used to charge this payment.
 * @param object $order
 *   The order object the payment applies to.
 * @param array $charge
 *   An array indicating the amount and currency code to charge.
 * @param array $values
 *   The values submitted by user.
 */
function commerce_moneris_api_transaction_purchase($payment_method, $order, $charge, $values) {
  $gateway = $payment_method['settings']['gateway'];
  $environment = $payment_method['settings']['server'];
  $transaction_type = $payment_method['settings'][$gateway]['txn_type'];

  // Save initial transaction.
  $transaction = commerce_payment_transaction_new('commerce_moneris_api', $order->order_id);
  $transaction->instance_id = $payment_method['instance_id'];
  $transaction->status = COMMERCE_PAYMENT_STATUS_PENDING;
  $transaction->payload = array(
    'gateway' => $gateway,
    'server' => $environment,
  );

  $transaction->amount = $charge['amount'];
  $transaction->currency_code = $charge['currency_code'];
  commerce_payment_transaction_save($transaction);

  // Order number sent to Moneris must be unique per transaction.
  // Therefore we will combine it with our local transaction ID.
  $unique_order_id = $order->order_id . '-' . $transaction->transaction_id;
  $transaction->payload['unique_order_id'] = $unique_order_id;
  commerce_payment_transaction_save($transaction);

  // Tax amount - as seen in commerce_paypal_ec_itemise_order().
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  $order_total = $order_wrapper->commerce_order_total->value();
  $tax_amount = (module_exists('commerce_tax')) ? commerce_round(COMMERCE_ROUND_HALF_UP, commerce_tax_total_amount($order_total['data']['components'], FALSE, $order_total['currency_code'])) : 0;

  // Create transaction data.
  $txn_array = array(
    'type' => $transaction_type,
    'order_id' => $unique_order_id,
    'amount' => number_format(commerce_currency_amount_to_decimal($charge['amount'], $charge['currency_code']), 2, '.', ''),
    // '7' stands for 'SSL enabled merchant'.
    'crypt_type' => '7',
    // Optional fields.
    'cust_id' => $order->uid,
    'dynamic_descriptor' => variable_get('site_name', ''),
    // Optional Level 2 variables.
    'commcard_invoice' => $order->order_number,
    'commcard_tax_amount' => $tax_amount,
  );
  // We don't want credit card data to go through alter hook implementations
  // below, so we add them only after they have been already called.

  // Allow other modules to alter the transaction array.
  drupal_alter('commerce_moneris_api_data', $txn_array, $order);

  // Prepare credit card data to be added to transaction array.
  $cc_data = array(
    'pan' => $values['credit_card']['number'],
    'expdate' => substr($values['credit_card']['exp_year'], 2, 2) . $values['credit_card']['exp_month'],
    'cvd_indicator' => 1,
    'cvd_value' => $values['credit_card']['code'],
  );
  // With array_merge() all credit card details that might have been added
  // in hook_commerce_moneris_txnarray_alter() implementations will be
  // overwritten by our $cc_data values.
  $txn_array = array_merge($txn_array, $cc_data);

  $transaction->payload['request'] = $txn_array;
  $transaction->payload['request']['pan'] = str_repeat('*', strlen($transaction->payload['request']['pan']) - 4) . substr($transaction->payload['request']['pan'], -4);
  $transaction->payload['request']['cvd_value'] = str_repeat('*', strlen($transaction->payload['request']['cvd_value']));
  commerce_payment_transaction_save($transaction);

  // Load native Moneris library relevant to selected gateway.
  commerce_moneris_api_libraries_load('moneris-api-' . $gateway);

  // Create Moneris-compatible transaction request object.
  $mpg_transaction = new mpgTransaction($txn_array);

  // eFraud: CVD (Card Validation Digits) verification.
  if (!empty($payment_method['settings'][$gateway]['extra']['cvd'])) {
    $cvd_template = array(
      'cvd_indicator' => $txn_array['cvd_indicator'],
      'cvd_value' => $txn_array['cvd_value'],
    );
    $mpg_cvd_info = new mpgCvdInfo($cvd_template);
    $mpg_transaction->setCvdInfo($mpg_cvd_info);
  }

  // eFraud: AVS (Address Verification Service) verification.
  if (!empty($payment_method['settings'][$gateway]['extra']['avs'])) {
    if ($order_wrapper->commerce_customer_billing->value()) {
      $billing_address = $order_wrapper->commerce_customer_billing->commerce_customer_address->value();
      // Moneris technical support said over the phone that both street number
      // and street name could be sent in avs_street_number value, with
      // avs_street_name left empty, so we don't have to explode them.
      $avs_template = array(
        'avs_street_number' => $billing_address['thoroughfare'],
        'avs_street_name' => '',
        'avs_zipcode' => $billing_address['postal_code'],
      );
      $mpg_avs_info = new mpgAvsInfo($avs_template);
      $mpg_transaction->setAvsInfo($mpg_avs_info);
    }
  }

  // Send the transaction request to Moneris.
  $mpg_response = commerce_moneris_api_request($mpg_transaction, $payment_method, $order);

  // Process the response and update its relevant transaction accordingly.
  return commerce_moneris_api_response_process($mpg_response, $transaction);
}

/**
 * Refunds a purchase or capture transaction.
 *
 * @param object $purchase_transaction
 *   Transaction to be refunded.
 * @param decimal $amount
 *   Ammount to be refunded as a decimal.
 *
 * @return boolean
 *   Boolean indicating whether a transaction was successful or not.
 */
function commerce_moneris_api_transaction_refund($purchase_transaction, $amount, $payment_method) {
  $order = commerce_order_load($purchase_transaction->order_id);
  $gateway = $payment_method['settings']['gateway'];
  $environment = $payment_method['settings']['server'];

  // Save initial transaction.
  $transaction = commerce_payment_transaction_new('commerce_moneris_api', $purchase_transaction->order_id);
  $transaction->instance_id = $payment_method['instance_id'];
  $transaction->amount = -commerce_currency_decimal_to_amount($amount, $purchase_transaction->currency_code);
  $transaction->currency_code = $purchase_transaction->currency_code;
  $transaction->status = COMMERCE_PAYMENT_STATUS_PENDING;
  $transaction->payload = array(
    'gateway' => $gateway,
    'server' => $environment,
    'related_order_id' => $purchase_transaction->payload['unique_order_id'],
  );
  commerce_payment_transaction_save($transaction);

  // Order number sent to Moneris must be unique per transaction.
  // Therefore we will combine it with our local transaction ID.
  $unique_order_id = $order->order_id . '-' . $transaction->transaction_id;
  $transaction->payload['unique_order_id'] = $unique_order_id;

  $related_order_id = $purchase_transaction->payload['unique_order_id'];
  // When doing a Refund on the Capture transactions, we need to reference
  // not the Capture transaction itself, but one step earlier - original
  // PreAuth/ReAuth instead.
  if (!empty($purchase_transaction->payload['request']['type'])) {
    $related_type = $purchase_transaction->payload['request']['type'];
    if ($related_type == 'us_completion' || $related_type == 'completion') {
      $related_order_id = $purchase_transaction->payload['related_order_id'];
    }
  }

  // Create transaction data.
  $txn_array = array(
    'type' => ($gateway == COMMERCE_MONERIS_USA) ? 'us_refund' : 'refund',
    'order_id' => $related_order_id,
    'amount' => number_format($amount, 2, '.', ''),
    'txn_number' => $purchase_transaction->remote_id,
    // '7' stands for 'SSL enabled merchant'.
    'crypt_type' => '7',
  );

  // Allow other modules to alter the transaction array.
  drupal_alter('commerce_moneris_api_data', $txn_array, $order);

  $transaction->payload['request'] = $txn_array;
  commerce_payment_transaction_save($transaction);

  // Load native Moneris library relevant to selected gateway.
  commerce_moneris_api_libraries_load('moneris-api-' . $gateway);

  // Create Moneris-compatible transaction request object.
  $mpg_transaction = new mpgTransaction($txn_array);

  // Send the transaction request to Moneris.
  $response_data = commerce_moneris_api_request($mpg_transaction, $payment_method, $order);

  // Process the response and update its relevant transaction accordingly.
  return commerce_moneris_api_response_process($response_data, $transaction);
}

/**
 * Captures an authorisation transaction.
 *
 * @param object $auth_transaction
 *   Transaction to be captured.
 * @param decimal $amount
 *   Ammount to be refunded as a decimal.
 *
 * @return boolean
 *   Boolean indicating whether a transaction was successful or not.
 */
function commerce_moneris_api_transaction_capture($auth_transaction, $amount, $payment_method) {
  $order = commerce_order_load($auth_transaction->order_id);
  $gateway = $payment_method['settings']['gateway'];
  $environment = $payment_method['settings']['server'];

  // Save initial transaction.
  $transaction = commerce_payment_transaction_new('commerce_moneris_api', $auth_transaction->order_id);
  $transaction->instance_id = $payment_method['instance_id'];
  $transaction->amount = commerce_currency_decimal_to_amount($amount, $auth_transaction->currency_code);
  $transaction->currency_code = $auth_transaction->currency_code;
  $transaction->status = COMMERCE_PAYMENT_STATUS_PENDING;
  $transaction->payload = array(
    'gateway' => $gateway,
    'server' => $environment,
    'related_order_id' => $auth_transaction->payload['unique_order_id'],
  );
  commerce_payment_transaction_save($transaction);

  // Order number sent to Moneris must be unique per transaction.
  // Therefore we will combine it with our local transaction ID.
  $unique_order_id = $order->order_id . '-' . $transaction->transaction_id;
  $transaction->payload['unique_order_id'] = $unique_order_id;

  // Tax amount - as seen in commerce_paypal_ec_itemise_order().
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);
  $order_total = $order_wrapper->commerce_order_total->value();
  $tax_amount = (module_exists('commerce_tax')) ? commerce_round(COMMERCE_ROUND_HALF_UP, commerce_tax_total_amount($order_total['data']['components'], FALSE, $order_total['currency_code'])) : 0;

  // Create transaction data.
  $txn_array = array(
    'type' => ($gateway == COMMERCE_MONERIS_USA) ? 'us_completion' : 'completion',
    'order_id' => $auth_transaction->payload['unique_order_id'],
    'comp_amount' => number_format($amount, 2, '.', ''),
    'txn_number' => $auth_transaction->remote_id,
    // '7' stands for 'SSL enabled merchant'.
    'crypt_type' => '7',
    // Optional Level 2 variables.
    'commcard_invoice' => $order->order_number,
    'commcard_tax_amount' => $tax_amount,
  );

  // Allow other modules to alter the transaction array.
  drupal_alter('commerce_moneris_api_data', $txn_array, $order);

  $transaction->payload['request'] = $txn_array;
  commerce_payment_transaction_save($transaction);

  // Load native Moneris library relevant to selected gateway.
  commerce_moneris_api_libraries_load('moneris-api-' . $gateway);

  // Create Moneris-compatible transaction request object.
  $mpg_transaction = new mpgTransaction($txn_array);

  // Send the transaction request to Moneris.
  $response_data = commerce_moneris_api_request($mpg_transaction, $payment_method, $order);

  // Process the response and update its relevant transaction accordingly.
  return commerce_moneris_api_response_process($response_data, $transaction);
}

/**
 * Reverses an authorisation transaction.
 *
 * @param object $auth_transaction
 *   Transaction to be reversed.
 * @param decimal $amount
 *   Ammount to be refunded as a decimal.
 *
 * @return boolean
 */
function commerce_moneris_api_transaction_reverse($auth_transaction, $amount, $payment_method) {
  $order = commerce_order_load($auth_transaction->order_id);
  $gateway = $payment_method['settings']['gateway'];
  $environment = $payment_method['settings']['server'];

  // Save initial transaction.
  $transaction = commerce_payment_transaction_new('commerce_moneris_api', $auth_transaction->order_id);
  $transaction->instance_id = $payment_method['instance_id'];
  $transaction->amount = -commerce_currency_decimal_to_amount($amount, $auth_transaction->currency_code);
  $transaction->currency_code = $auth_transaction->currency_code;
  $transaction->status = COMMERCE_PAYMENT_STATUS_PENDING;
  $transaction->payload = array(
    'gateway' => $gateway,
    'server' => $environment,
    'related_order_id' => $auth_transaction->payload['unique_order_id'],
  );
  commerce_payment_transaction_save($transaction);

  // Order number sent to Moneris must be unique per transaction.
  // Therefore we will combine it with our local transaction ID.
  $unique_order_id = $order->order_id . '-' . $transaction->transaction_id;
  $transaction->payload['unique_order_id'] = $unique_order_id;
  commerce_payment_transaction_save($transaction);

  // Create transaction data.
  $txn_array = array(
    'type' => ($gateway == COMMERCE_MONERIS_USA) ? 'us_completion' : 'completion',
    'order_id' => $auth_transaction->payload['unique_order_id'],
    'comp_amount' => '0.00',
    'txn_number' => $auth_transaction->remote_id,
    // '7' stands for 'SSL enabled merchant'.
    'crypt_type' => '7',
  );

  // Allow other modules to alter the transaction array.
  drupal_alter('commerce_moneris_api_data', $txn_array, $order);

  $transaction->payload['request'] = $txn_array;
  commerce_payment_transaction_save($transaction);

  // Load native Moneris library relevant to selected gateway.
  commerce_moneris_api_libraries_load('moneris-api-' . $gateway);

  // Create Moneris-compatible transaction request object.
  $mpg_transaction = new mpgTransaction($txn_array);

  // Send the transaction request to Moneris.
  $response_data = commerce_moneris_api_request($mpg_transaction, $payment_method, $order);

  // Process the response and update its relevant transaction accordingly.
  return commerce_moneris_api_response_process($response_data, $transaction);
}

/**
 * Reauthorises an authorisation transaction.
 *
 * @param object $auth_transaction
 *   Transaction to be reauthorised.
 * @param decimal $amount
 *   Ammount to be reauthorised as a decimal.
 *
 * @return boolean
 */
function commerce_moneris_api_transaction_reauth($auth_transaction, $amount, $payment_method) {
  $order = commerce_order_load($auth_transaction->order_id);
  $gateway = $payment_method['settings']['gateway'];
  $environment = $payment_method['settings']['server'];

  // Save initial transaction.
  $transaction = commerce_payment_transaction_new('commerce_moneris_api', $auth_transaction->order_id);
  $transaction->instance_id = $payment_method['instance_id'];
  $transaction->amount = commerce_currency_decimal_to_amount($amount, $auth_transaction->currency_code);
  $transaction->currency_code = $auth_transaction->currency_code;
  $transaction->status = COMMERCE_PAYMENT_STATUS_PENDING;
  $transaction->payload = array(
    'gateway' => $gateway,
    'server' => $environment,
    'related_order_id' => $auth_transaction->payload['unique_order_id'],
  );
  commerce_payment_transaction_save($transaction);

  // Order number sent to Moneris must be unique per transaction.
  // Therefore we will combine it with our local transaction ID.
  $unique_order_id = $order->order_id . '-' . $transaction->transaction_id;
  $transaction->payload['unique_order_id'] = $unique_order_id;
  commerce_payment_transaction_save($transaction);

  // Create transaction data.
  $txn_array = array(
    'type' => ($gateway == COMMERCE_MONERIS_USA) ? 'us_reauth' : 'reauth',
    'order_id' => $unique_order_id,
    'orig_order_id' => $auth_transaction->payload['unique_order_id'],
    'txn_number' => $auth_transaction->remote_id,
    'amount' => $amount,
    // '7' stands for 'SSL enabled merchant'.
    'crypt_type' => '7',
    // Optional fields.
    'cust_id' => $order->uid,
  );

  // Allow other modules to alter the transaction array.
  drupal_alter('commerce_moneris_api_data', $txn_array, $order);

  $transaction->payload['request'] = $txn_array;
  commerce_payment_transaction_save($transaction);

  // Load native Moneris library relevant to selected gateway.
  commerce_moneris_api_libraries_load('moneris-api-' . $gateway);

  // Create Moneris-compatible transaction request object.
  $mpg_transaction = new mpgTransaction($txn_array);

  // Send the transaction request to Moneris.
  $response_data = commerce_moneris_api_request($mpg_transaction, $payment_method, $order);

  // Process the response and update its relevant transaction accordingly.
  return commerce_moneris_api_response_process($response_data, $transaction);
}

/**
 * Posts data to Moneris API.
 *
 * @param object $mpg_transaction
 *   The mpgTransaction object which mpgRequest will be created from.
 * @param array $payment_method
 *   The payment method instance object used to charge this payment.
 * @param object $order
 *   The order object the payment applies to.
 */
function commerce_moneris_api_request($mpg_transaction, $payment_method, $order) {
  $gateway = $payment_method['settings']['gateway'];
  $environment = $payment_method['settings']['server'];
  $store_id = $payment_method['settings'][$gateway][$environment]['store_id'];
  $api_token = $payment_method['settings'][$gateway][$environment]['api_token'];
  $cacert_path = (!empty($payment_method['settings'][$gateway]['extra']['ssl'])) ? $payment_method['settings'][$gateway]['curl_certificate_path'] : '';

  // Load native Moneris library relevant to selected gateway.
  commerce_moneris_api_libraries_load('moneris-api-' . $gateway);

  // Mask and log transaction object.
  if (!empty($payment_method['settings']['log']['request'])) {
    // We can't change original transaction details, so let's work on its copy.
    $log = clone($mpg_transaction);
    // Mask the credit card number, expiraton date and CVV code
    // before saving it to the dblog.
    if (!empty($log->txn['pan'])) {
      $log->txn['pan'] = str_repeat('*', strlen($log->txn['pan']) - 4) . substr($log->txn['pan'], -4);
    }
    if (!empty($log->txn['cvd_value'])) {
      $log->txn['cvd_value'] = str_repeat('*', strlen($log->txn['cvd_value']));
    }
    // We are sending 'cvdInfo' for CA gateway...
    if (!empty($log->cvdInfo->params['cvd_value'])) {
      $log->cvdInfo->params['cvd_value'] = str_repeat('*', strlen($log->cvdInfo->params['cvd_value']));
    }
    // ...but 'cvd' to US gateway.
    if (!empty($log->cvd->params['cvd_value'])) {
      $log->cvd->params['cvd_value'] = str_repeat('*', strlen($log->cvd->params['cvd_value']));
    }
    watchdog('commerce_moneris_api', '<pre>' . check_plain(print_r($log, TRUE)) . '</pre>', array(), WATCHDOG_DEBUG);
  }

  // Prepare Moneris request object and send it to their gateway.
  $mpg_request = new mpgRequest($mpg_transaction);
  $mpg_result = new mpgHttpsPost($store_id, $api_token, $mpg_request, $environment, $cacert_path);
  $mpg_response = $mpg_result->getMpgResponse();

  // Log the full response.
  if (!empty($payment_method['settings']['log']['response'])) {
    // Log the cURL response.
    $curl_log = array('response' => $mpg_result->getCurlResponse());
    if ($curl_error = $mpg_result->getCurlError()) {
      $curl_log += $curl_error;
    }
    watchdog('commerce_moneris_api', 'cURL response: <pre>' . check_plain(print_r($curl_log, TRUE)) . '</pre>', array(), WATCHDOG_DEBUG);
    // Log the gateway response.
    watchdog('commerce_moneris_api', '<pre>' . check_plain(print_r($mpg_response, TRUE)) . '</pre>', array(), WATCHDOG_DEBUG);
  }

  return $mpg_response->responseData;
}

/**
 * Processed the response received from Moneris.
 *
 * @param array $response_data
 *   Moneris mpgResponse->response_data array.
 * @param array $transaction
 *   The commerce payment transaction.
 *
 * @return bool
 *   Boolean indicating whether the transaction was successful or not.
 */
function commerce_moneris_api_response_process($response_data, $transaction) {
  // Log received response.
  $transaction->payload['responseData'] = $response_data;

  // eSelectPlus Response Handling guide says that first step of making sure
  // the transaction was successful is checking values of Complete, TimedOut
  // ResponseCode and Message parameters.
  if (
    empty($response_data['Complete']) || $response_data['Complete'] != 'true'
    || empty($response_data['TimedOut']) || $response_data['TimedOut'] != 'false'
    || empty($response_data['ResponseCode']) || $response_data['ResponseCode'] == 'null'
  ) {
    $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
    $transaction->message = $response_data['Message'];
  }
  // Transaction was processed successfully
  // (although still might have been declined).
  else {
    // Response code will be returned as a string like '027', so we need
    // to convert it to a proper integer first before checking its value.
    $response_code = (int) $response_data['ResponseCode'];

    // Transaction was approved.
    if ($response_code >= 0 && $response_code <= 49) {
      $transaction->status = commerce_moneris_api_get_transaction_success_status($response_data['TransType'], $response_data['TransAmount']);
    }
    // Transaction was declined.
    else {
      $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
    }

    $transaction->remote_id = $response_data['TransID'];

    // Build transaction message from main status message and all validators.
    $transaction->message = t('@txn_type: !message', array(
      '@txn_type' => commerce_moneris_api_get_transaction_type($transaction),
      '!message' => $response_data['Message'],
    ));
    // Add eFraud information if available.
    if (!empty($response_data['CvdResultCode']) && $response_data['CvdResultCode'] != 'null') {
      $transaction->message .= '<br />' . t('CVD result: @result', array('@result' => commerce_moneris_get_cvd_response(substr($response_data['CvdResultCode'], 1))));
    }
    if (!empty($response_data['AvsResultCode']) && $response_data['AvsResultCode'] != 'null') {
      $gateway = $transaction->payload['gateway'];
      $transaction->message .= '<br />' . t('AVS result: @result', array('@result' => commerce_moneris_get_avs_response($response_data['AvsResultCode'], $response_data['CardType'], $gateway)));
    }
    if (!empty($response_data['CavvResultCode']) && $response_data['CavvResultCode'] != 'null') {
      $transaction->message .= '<br />' . t('CAVV result: @result', array('@result' => commerce_moneris_get_cavv_response($response_data['CavvResultCode'])));
    }
  }

  // Store the type of transaction in the remote status.
  $transaction->remote_status = $response_data['TransType'];

  commerce_payment_transaction_save($transaction);

  if ($transaction->status == COMMERCE_PAYMENT_STATUS_FAILURE) {
    drupal_set_message(t('We encountered an error processing your transaction. Please enter your information again or try a different card.'), 'error');
    return FALSE;
  }

  return TRUE;
}

/**
 * Returns supported transaction types for a specified gateway (country).
 *
 * @param string $gateway_id
 *   A gateway ID indicating which country to return transaction types for.
 * @param bool $translated
 *   A boolean indicating whether returned strings should be translated or not.
 *
 * @return array
 *   An array of available transaction types for a specified gateway (country).
 */
function commerce_moneris_api_get_transaction_types($gateway_id, $translated = FALSE) {
  $transaction_types = array(
    COMMERCE_MONERIS_USA => array(
      'us_purchase' => t('Purchase'),
      'us_preauth' => t('PreAuth'),
    ),
    COMMERCE_MONERIS_CANADA => array(
      'purchase' => t('Purchase'),
      'preauth' => t('PreAuth'),
    ),
  );

  if ($translated) {
    $transaction_types[$gateway_id] = array_map('t', $transaction_types[$gateway_id]);
  }

  return $transaction_types[$gateway_id];
}

/**
 * Returns transaction type for specific TransType response code.
 *
 * @param string $trans_type
 *   TransType response code received in response from Moneris API.
 *
 * @return string
 *   Transaction type.
 */
function commerce_moneris_api_get_transaction_type($transaction) {
  switch ($transaction->payload['responseData']['TransType']) {
    case COMMERCE_MONERIS_API_TRANSACTION_TYPE_PURCHASE:
      return 'Purchase';
    case COMMERCE_MONERIS_API_TRANSACTION_TYPE_AUTH:
      return (!empty($transaction->payload['related_order_id'])) ? 'ReAuth' : 'PreAuth';
    case COMMERCE_MONERIS_API_TRANSACTION_TYPE_CAPTURE:
      return ($transaction->payload['responseData']['TransAmount'] == '0.00') ? 'Reverse' : 'Capture';
    case COMMERCE_MONERIS_API_TRANSACTION_TYPE_REFUND:
      return 'Refund';
  }
}

/**
 * Returns Drupal-Commerce compatible transaction status for a transaction type.
 *
 * @param string $trans_type
 *   Moneris transaction type.
 * @param $amount
 *   Transaction amount.
 *
 * @return string
 *   Drupal Commerce-compatible transaction status for a given transaction type.
 */
function commerce_moneris_api_get_transaction_success_status($trans_type, $amount) {
  switch ($trans_type) {
    // Purchase, Refund.
    case COMMERCE_MONERIS_API_TRANSACTION_TYPE_PURCHASE:
    case COMMERCE_MONERIS_API_TRANSACTION_TYPE_REFUND:
      return COMMERCE_PAYMENT_STATUS_SUCCESS;
    // PreAuth.
    case COMMERCE_MONERIS_API_TRANSACTION_TYPE_AUTH:
      return COMMERCE_PAYMENT_STATUS_MONERIS_AUTHORISED;
    // Capture/Reverse.
    case COMMERCE_MONERIS_API_TRANSACTION_TYPE_CAPTURE:
      return ($amount != '0.00') ? COMMERCE_PAYMENT_STATUS_SUCCESS : COMMERCE_PAYMENT_STATUS_MONERIS_REVERSED;
  }
}
