<?php
// $Id$

/**
 * @file
 *
 */

/**
 * Implements hook_menu().
 * 
 * Skinr lite has a settings page at admin/appearance/skinrlite.
 */
function skinr_lite_menu() {

  $items['admin/appearance/skinrlite'] = array(
    'title' => 'Adjust theme options',
    'description' => 'Use skinr lite to choose theme colors and settings.',
    'access callback' => 'user_access',
    'access arguments' => array('set skin options'),
    'page callback' => 'skinr_lite_enable_chooser',
    'type' => MENU_NORMAL_ITEM,
    'file' => 'skinr_lite.admin.inc',
  );
  
  return $items;
}

/**
 * Implements hook_permission().
 * 
 * Skinr lite adds the permission "set skin options" for operations involving 
 * changing skin options provided by themes.
 */
function skinr_lite_permission() {
  return array('set skin options' => array(
    'title' => t('Set skin options'),
    'description' => t('Choose site-wide skin options provided by a theme or module.'),
  ));
}

/**
 * Implements hook_init().
 * 
 * It seems easiest and safest when using the javascript theme chooser
 * to disable page caching for requests from theme administrators. This is
 * mainly for other modules that implement caching for logged-in users, since
 * theme administrators should really be logged in. I'm not even sure if this
 * will really be useful.
 * 
 * @todo: investigate if this is needed.
 */
function skinr_lite_init() {
  if (variable_get('skinr_lite_chooser_enabled', FALSE) && user_access('set skin options')) {
    drupal_page_is_cacheable(FALSE);
  }
}

/**
 * Implements hook_preprocess_block().
 * 
 * @todo: implement block-level skinning
 */
//function skinr_lite_preprocess_block(&$vars) {
//  
//}

/**
 * Implements hook_preprocess_html().
 * 
 * Skinr Lite uses this hook to add classes to the html element based on the
 * options that have been enabled on the theme settings page.
 * 
 * @param array $vars
 */
function skinr_lite_preprocess_html(&$vars) {
  global $theme_key;
  
  $skins = variable_get("skinr_lite_theme_{$theme_key}_skins", array());
  $skin_settings = skinr_lite_get_theme_settings();
  
  // THIS SECTION PRESENTS A JAVASCRIPT THEME CHOOSER TO THEME ADMINISTRATORS
  if (variable_get('skinr_lite_chooser_enabled', FALSE) && user_access('set skin options')) {
    
    // @todo: Add toggle button to page
    
    module_load_include('inc', 'skinr_lite');
    
    // We should fetch all the skins
    if ($skins = skinr_lite_get_skin_info($theme_key)) {

      // Add all skin css files
      foreach ($skins as $skin) {
        skinr_lite_attach_files($vars, $skin);
      }

      if (!empty($skin_settings)) {
        // Add selected classes
        foreach ($skin_settings as $name => $values) {
          $values = is_array($values) ? array_filter($values) : array($values);
          foreach ($values as $value) {
            if (!empty($skins[$name]['options'][$value]['class']) && is_array($skins[$name]['options'][$value]['class'])) {
              $vars['classes_array'] = array_merge($vars['classes_array'], $skins[$name]['options'][$value]['class']);
            }
          }
        }
      }

      // Build a form
      $form = drupal_get_form('skinr_lite_skin_form', $theme_key, $skins);
      $form['#attributes'] = array('id' => 'skinr-lite-chooser');
      
    }
    else {
      $form = array(
        '#markup' => '<div id="skinr-lite-chooser">' . 
            t('The %theme theme has not implemented any skins.', 
            array('%theme' => $theme_key)) . '</div>',
      );
    }


    
    // Add the form to the html page
    $vars['page']['page_bottom']['skinr_lite_chooser'] = array(
      '#attached' => array(
        'css' => array(
          drupal_get_path('module', 'skinr_lite') . '/skinr_lite_chooser.css' => array('preprocess' => 0),
        ),
        'js' => array(
          drupal_get_path('module', 'skinr_lite') . '/skinr_lite_chooser.js' => array('preprocess' => 0),
        ),
      ),
      'form' => $form,
    );
    
    // Add a toggle button to the page
    $vars['page']['page_bottom']['skinr_lite_chooser_show'] = array(
      '#markup' => '<a id="skinr-lite-chooser-toggle" title="' . t('Set skin options') . '">' . t('Set skin options') . '</a>'
    );
    
  }
  
  // THIS SECTION SKINS THE SITE FOR NORMAL USE
  elseif (!empty($skins) && !empty($skin_settings)) {
    // Get available skins.
    foreach ($skin_settings as $name => $values) {
      
      // Filter theme settings to selected values
      if (!is_array($values)) {
        $values = array($values);
      }
      $values = array_filter($values);
      
      foreach ($values as $value) {
        
        // Apply classes based on theme settings.
        if (!empty($skins[$name]['options'][$value]['class']) && is_array($skins[$name]['options'][$value]['class'])) {
          $vars['classes_array'] = array_merge($vars['classes_array'], $skins[$name]['options'][$value]['class']);
        }

        // Include css and js files from cached available skins.
        skinr_lite_attach_files($vars, $skins[$name], $value);

      }
    }
  }
  
  // Process the attached css files
  if (!empty($vars['#attached'])) {
    drupal_process_attached($vars);
  }
  
}

/**
 * Form builder function for drupal_get_form and ajax callbacks.
 * 
 * @param type $form
 * @param type $form_state
 * @param type $skins
 * @param type $theme_key
 * @return type
 */
function skinr_lite_skin_form($form, &$form_state, $theme_key, $skins = array(), $ajax = TRUE) {
  module_load_include('inc', 'skinr_lite');
  
  if (empty($skins)) {
    $skins = skinr_lite_get_skin_info($theme_key);
  }
  $form['skins'] = _skinr_lite_skin_form_element($theme_key, $skins, $ajax);
  
  if (module_exists('color') && $color_info = color_get_info($theme_key)) {
    if ($color_cache = cache_get("skinr_lite:{$theme_key}:color")) {
      $color_data = $color_cache->data;
    }
    else {
      $styles = array();
      
      // Get the array of default colors
      $palette = $color_info['schemes']['default']['colors'];
      
      
      // Parse all stylesheets into an array of colors
      if (!empty($color_info['css'])) {
        skinr_lite_process_color_stylesheets($theme_key, $color_info['css'], $palette);
      }

    }
    // Build color form
    
    $form['skinr_lite_colors'] = array(
      '#type' => 'fieldset',
      '#title' => t('Color scheme'),
      '#weight' => -5,
      '#prefix' => '<div id="system-theme-settings"><div class="color-form">',
      '#suffix' => '</div></div>',
    );
    $form['skinr_lite_colors'] += color_scheme_form($form, $form_state, $theme_key);
    
    // Add ajax for saving when changing colors
    $ajax = array(
      'callback' => 'skinr_lite_save_form_colors',
      'progress' => array('type' => 'throbber'),
      'event' => 'blur',
    );
    $form['skinr_lite_colors']['scheme']['#ajax'] = $ajax;
    foreach (element_children($form['skinr_lite_colors']['palette']) as $palette_input) {
      $form['skinr_lite_colors']['palette'][$palette_input]['#ajax'] = $ajax;
    }
    
    $form['skinr_lite_colors']['palette']['#prefix'] = '<div id="palette">';
    $form['skinr_lite_colors']['palette']['#suffix'] = '</div>';
    
    // Memory slots for saved palettes
    $form['skinr_lite_colors']['memory']['#prefix'] = '<div id="skinr-lite-memory">';
    $form['skinr_lite_colors']['memory']['#suffix'] = '</div>';
    foreach(array(1,2,3,4,5) as $slot_number) {
      $form['skinr_lite_colors']['memory']["saved-palette-$slot_number"] = array(
        '#type' => 'button',
        '#value' => $slot_number,
        '#ajax' => array(
          'callback' => 'skinr_lite_toggle_color_memory_ajax',
          'progress' => array(
            'type' => 'throbber',
            'message' => NULL,
          ),
        ),
        '#attributes' => array(
          'class' => array(
            'skinr-lite-memory',
          ),
        ),
      );
      $form['skinr_lite_colors']['memory']["saved-palette-$slot_number"]['#attributes']['class']['active'] = '';
    }
    
    // Processing for ajax calls
    $memory = skinr_lite_get_color_memory($theme_key);
    $current_palette = color_get_palette($theme_key);
    foreach ($memory as $slot => $slot_palette) {
      $slot_number = str_replace('saved-palette-', '', $slot);
      
      if (is_numeric($slot_number)) {
        
        // If this is an ajax request, and this is the slot requested...
        if (!empty($form_state['values']['op']) && $form_state['values']['op'] == $slot_number) {
          // ...remove an old record if it is exactly the same...
          if ($form_state['values']['palette'] == $slot_palette) {
            $saved_palette = array();
            $form_state['storage']['skinr_lite_saved_palettes_op'] = 'delete';
            $form_state['storage']['skinr_lite_saved_palette_last'] = FALSE;
          }
          // ...or add a new one if it doesn't exist, or if it was the last one added...
          elseif (empty($slot_palette) || 
              ($form_state['storage']['skinr_lite_saved_palette_last'] == $slot_number)) {
            $saved_palette = $form_state['values']['palette'];
            $form_state['storage']['skinr_lite_saved_palettes_op'] = empty($slot_palette) ? 'insert' : 'update';
            $form_state['storage']['skinr_lite_saved_palette_last'] = $slot_number;
          }
          // ...or switch to one that already exists.
          else {
            $saved_palette = $slot_palette;
            $form_state['storage']['skinr_lite_saved_palettes_op'] = 'select';
            $form_state['storage']['skinr_lite_saved_palette_last'] = $slot_number;
            $form_state['values']['palette'] = $saved_palette;
          }
          skinr_lite_save_color_memory($theme_key, $saved_palette, $slot);
        }
        
        // If this is not an ajax request, or this is not the slot requested...
        else {
          $saved_palette = $slot_palette;
          if ($slot_palette == $current_palette && 
              empty($form_state['storage']['skinr_lite_saved_palette_last'])) {
            $form_state['storage']['skinr_lite_saved_palette_last'] = $slot_number;
          }
        }
        
        // If there is a saved palette...
        if (!empty($saved_palette)) {
          $form['skinr_lite_colors']['memory'][$slot]['#attributes']['class'][] = 'in-use';
          $form['skinr_lite_colors']['scheme']['#options'][$slot] = t('Saved palette !number', array('!number' => $slot_number));
          $form['skinr_lite_colors']['scheme']['#attached']['js'][1]['data']['color']['schemes'][$slot] = $saved_palette;
          $active_slot = $form_state['storage']['skinr_lite_saved_palette_last'];
          $form['skinr_lite_colors']['memory']["saved-palette-$active_slot"]['#attributes']['class']['active'] = 'active';
        }
      }
    }
    
    if (variable_get('skinr-lite-dev', FALSE)) {
      $form['skinr_lite_colors']['export_colors'] = array(
        '#type' => 'markup',
        '#markup' => '<a id="skinr-lite-export-colors" href="#" title="' . t('Export the colors for use as a color scheme') . '">' . t('Export colors') . '</a>',
      );
    }
    
  }
  
  $form['theme_key'] = array(
    '#type' => 'hidden',
    '#value' => $theme_key,
  );
  
  $form['actions'] = array(
    '#type' => 'actions',
    'reload' => array(
      '#type' => 'submit',
      '#value' => t('Reload'),
      '#attributes' => array('title' => t('This will reload the page. Unsaved changes to the color scheme will be lost.')),
    ),
    'done' => array(
      '#type' => 'submit',
      '#value' => t('Done!'),
    ),
  );
  
  // @todo: add color scheme forms
  // @todo: add "Done" button
  
  return $form;
}

/**
 * Submit handler for skinr_lite_skin_form.
 */
function skinr_lite_skin_form_submit(&$form, &$form_state) {
  
  // Turn off skinr lite chooser
  if ($form_state['clicked_button']['#value'] == t('Done!')) {
    color_scheme_form_submit($form, $form_state);
    drupal_set_message(t('Finished with skin editing! You can turn on the editor again at !link.', array('!link' => l('/admin/appearance/skinrlite', 'admin/appearance/skinrlite'))));
    variable_del('skinr_lite_chooser_enabled');
    drupal_flush_all_caches();
  }
  
}

/**
 * Ajax handler for memory buttons on skinr_lite_skin_form.
 */
function skinr_lite_toggle_color_memory_ajax($form, $form_state) {
  if (!empty($form_state['storage']['skinr_lite_saved_palettes_op']) &&
      $op = $form_state['storage']['skinr_lite_saved_palettes_op']) {
    $slot_number = $form_state['values']['op'];
    $slot = "saved-palette-$slot_number";
    $commands = array();
    $commands[] = ajax_command_replace('#skinr-lite-memory', drupal_render($form['skinr_lite_colors']['memory']));
    switch ($op) {
      case 'insert':
        $commands[] = ajax_command_append('#edit-scheme', '<option value="' . $slot . 
            '">' . t('Saved palette !number', array('!number' => $slot_number)) . 
            '</option>');
      case 'update':
        $commands[] = ajax_command_invoke('#edit-scheme', 'val', array($slot));
        $settings = array();
        $settings['color']['schemes'][$slot] = $form_state['values']['palette'];
        $commands[] = ajax_command_settings($settings, TRUE);
        break;
      case 'delete':
        $commands[] = ajax_command_remove('#edit-scheme option[value="' . $slot . '"]');
        break;
      case 'select':
        $commands[] = ajax_command_invoke('#edit-scheme', 'val', array($slot));
        $commands[] = ajax_command_invoke('#edit-scheme', 'trigger', array('change'));
        $commands += skinr_lite_save_form_colors($form, $form_state);
        break;
    }
  }
  return array(
    '#type' => 'ajax',
    '#commands' => $commands,
  );
}

/**
 * Callback function for ajax requests to save skin settings.
 * 
 * @param array $form
 * The $form array as returned by drupal_get_form('skinr_lite_skin_form').
 * 
 * @param type $form_state
 * The $form_state array from Drupal's form processing.
 * 
 * @return array
 * Ajax array to replace original form elements.
 */
function skinr_lite_save_form_setting($form, $form_state) {
  if (!empty($form_state['triggering_element']['#attributes']['skinrlite'])) {
    
    $setting_name = $form_state['triggering_element']['#attributes']['skinrlite'];
    $settings = array($setting_name => $form_state['input']['skins'][$setting_name]);
    $theme_key = $form_state['input']['theme_key'];
    
    $commands = array();
    
    if (skinr_lite_save_skin_settings($settings, $theme_key)) {
      $commands[] = ajax_command_changed($setting_name);
    }
    
    return array(
      '#type' => 'ajax', 
      '#commands' => $commands,
    );
  }
}

/**
 * Callback function for ajax requests to save color form when changes are made.
 */
function skinr_lite_save_form_colors($form, $form_state) {
  color_scheme_form_submit($form, $form_state);
  $selector = '#palette';
  $commands = array();
  $commands[] = ajax_command_changed($selector);
  return array('#type' => 'ajax', '#commands' => $commands);
}

/**
 * Implements hook_form_FORM_ID_alter() for system_theme_settings form.
 * 
 * Skinr Lite uses this hook to render available skins as theme options.
 */
function skinr_lite_form_system_theme_settings_alter(&$form, &$form_state) {
  
  // Display the form on theme-specific settings page only.
  if (isset($form['var']['#value']) && $form['var']['#value'] != 'theme_settings') {
    $matches = array();
    if ($count = preg_match('|^theme_(.+)_settings$|', $form['var']['#value'], $matches)) {
      $theme_key = $matches[1];
      
      // Clear the cache in case we are using Skinr module.
      cache_clear_all('skinr_skin_info', 'cache');
      
      module_load_include('inc', 'skinr_lite');

      // Get all available skins.
      if ($skins = skinr_lite_get_skin_info($theme_key)) {
        
        $formelement = array(
          '#type' => 'markup',
          '#markup' => t('You can choose options for this theme at !link',
              array ('!link' => l('/admin/appearance/skinrlite', '/admin/appearance/skinrlite')))
        );
        
        if (module_exists('color') && !empty($form['color'])) {
          $form['color']['skinrlite'] = $formelement;
        }
        else {
          $form['skinrlite'] = $formelement;
        }

      }
    }
  }
  
}

/**
 * Helper function to attach necessary css and js files for skin settings.
 * 
 * @param array $element
 * Render array element, passed by reference, to which css and js files may be
 * #attached.
 * 
 * @param array $skin_info
 * The skin definition as defined in hook_skinr_skin_info.
 * 
 * @param mixed $value
 * The value of the skin setting. If not given, css files for all values will
 * be attached.
 */
function skinr_lite_attach_files(&$element, $skin_info, $value = FALSE) {
  
  // Set up the '#attached' key on the element
  if (empty($element['#attached']) || !is_array($element['#attached'])) {
    $element['#attached'] = array();
  }
  
  // Merge the attached files from $skin_info into the $element
  if (!empty($skin_info['attached']) && is_array($skin_info['attached'])) {
    $element['#attached'] = array_merge_recursive($element['#attached'], $skin_info['attached']);
  }
  
  // If no $value was given, add attached files from all values (for forms and pages that need all styles)
  if ($value === FALSE) {
    if (!empty($skin_info['options'])) {
      foreach ($skin_info['options'] as $option) {
        if (!empty($option['attached'])) {
          $element['#attached'] = array_merge_recursive($element['#attached'], $option['attached']);
        }
      }
    }
  }
  // If a value was given, attach the file only for that value (for normal page loads)
  else {
    if (!empty($skin_info['options'][$value]['attached'])) {
      $element['#attached'] = array_merge_recursive($element['#attached'], $skin_info['options'][$value]['attached']);
    }
  }
}

/**
 * THIS FUNCTION IS NOT USED.
 * 
 * @param type $theme_key
 * @param type $skin_settings
 * @param type $scheme
 * 
 * @todo: implement support for colors.
 */
function skinr_lite_set_theme_skin_options($theme_key, $skin_settings = array(), $scheme = NULL) {
  
  // Set color scheme if possible
  if (!empty($scheme) && module_exists('color')) {
    $info = color_get_info($theme_key);
    $form = $form_state = array();
    $form_state['values']['theme'] = $theme_key;
    $form_state['values']['info'] = $info;
    if (is_string($scheme) && !empty($info['schemes'][$scheme])) {
      $form_state['values']['scheme'] = $scheme;
      $form_state['values']['palette'] = $info['schemes']['default']['colors'];
      color_scheme_form_submit($form, $form_state);
      drupal_flush_all_caches();
    }
    elseif (is_array($scheme)) {
      $form_state['values']['scheme'] = '';
      $form_state['values']['palette'] = array_merge(
        $info['schemes']['default']['colors'],
        array_intersect_key(
          $scheme,
          $info['schemes']['default']['colors']
        )
      );
      color_scheme_form_submit($form, $form_state);
      drupal_flush_all_caches();
    }
  }

  // Set skin options if possible
  module_load_include('inc', 'skinr_lite');
  if (!empty($skin_settings) && $skins = skinr_lite_get_skin_info($theme_key)) {
    
    if (!$theme_info = variable_get("theme_{$theme_key}_settings", FALSE)) {
      $theme_info = array('skins' => array());
    }
    
    foreach ($skin_settings as $name => $setting) {
      if (!empty($skins[$name]['options'])) {
        $real_options = array_keys($skins[$name]['options']);
        $is_multiple = $skins[$name]['type'] == 'checkboxes';
        
        // Empty indicates to reset to default
        if (empty($setting)) {
          if (!empty($theme_info['skins'][$name])) {
            $theme_info['skins'][$name] = 
              $is_multiple ? array_fill_keys($real_options, 0) : '';
          }
        }
        
        // Multiple options
        elseif ($is_multiple) {
          $setting = is_array($setting) ? $setting : array($setting);
          foreach($real_options as $real_option_name) {
            $theme_info['skins'][$name][$real_option_name] = 
              in_array($real_option_name, $setting) ? $real_option_name : 0;
          }
        }
        
        // Singular options
        else {
          if (in_array($setting, $real_options)) {
            $theme_info['skins'][$name] = $setting;
          }
        }
        
      }
    }
    
    if (!empty($theme_info['skins'])) {
      variable_set("theme_{$theme_key}_settings", $theme_info);
    }
  }
  
}

/**
 * Helper function to save skin settings.
 * 
 * @param array $settings
 * An array of skin settings whose keys are the skin name as reported in the 
 * hook_skinr_skin_info and whose values are either an array (for checkboxes) 
 * or a single value (for radios or selects).
 * 
 * @param string $theme_key
 * Optional: the machien name of the theme for which settings are to be saved. 
 * Defaults to the currently active theme.
 * 
 * @return boolean
 * TRUE if the operation was successful, FALSE if it could not be saved.
 * 
 * @todo: Decide if we are going to be compatible with Skinr module, which saves
 *  skin settings in its own table. If we are going to be compatible, we must 
 * use that system to save our data when skinr module is enabled.
 *  
 * @todo: add support for colors (@see skinr_lite_set_theme_skin_options).
 * 
 */
function skinr_lite_save_skin_settings($settings, $theme_key = NULL) {
  if (empty($theme_key)) {
    global $theme_key;
  }
  if (empty($theme_key)) {
    return FALSE;
  }
  $existing = skinr_lite_get_theme_settings($theme_key);
  variable_set("skinr_lite_theme_{$theme_key}_skin_settings", array_merge($existing, $settings));
  return TRUE;
}

/**
 * Helper function to retrieve skin settings. This function should always be
 * called when skin settings are needed.
 * 
 * @param string $theme_key
 * The machine name of the theme whose settings should be retrieved. Defaults to
 * the currently active theme.
 * 
 * @return array
 * An array of skin settings whose keys are the skin names as reported in the 
 * hook_skinr_skin_info and whose values are either an array (for checkboxes)
 * or a single value (for radios or selects).
 * 
 * @todo: decide whether we want to keep skin settings with theme settings.
 */
function skinr_lite_get_theme_settings($theme_key = FALSE) {
  if (empty($theme_key)) {
    global $theme_key;
  }
  if ($settings = variable_get("skinr_lite_theme_{$theme_key}_skin_settings", FALSE)) {
    return $settings;
  }
  // Allow the use of theme settings as defaults
  elseif ($settings = theme_get_setting('skins', $theme_key)) {
    return $settings;
  }
  else {
    return array();
  }
}

/**
 * Helper function to save a color palette into a memory slot
 * 
 * @param string $theme_key
 * The machine name of the theme for which data will be saved.
 * 
 * @param array $palette
 * Array of color palette data.
 * 
 * @param string $slot
 * Slot in which to save the palette data. There are five slots, saved-palette-1
 * through saved-palette-5.
 * 
 * @return boolean
 * Whether or not the data was successfully saved.
 */
function skinr_lite_save_color_memory($theme_key, $palette, $slot = 'saved-palette-1') {
  $memory = skinr_lite_get_color_memory($theme_key);
  if (!isset($memory[$slot])) {
    return FALSE;
  }
  else {
    $memory[$slot] = $palette;
    variable_set("skinr_lite_color_memory_$theme_key", $memory);
    return TRUE;
  }
}

/**
 * Wrapper for variable_get because the default is a little long.
 * 
 * @param string $theme_key
 * The machine name of the theme for which to get the data.
 * 
 * @return array
 * An array of saved palettes, keyed by slot name.
 */
function skinr_lite_get_color_memory($theme_key) {
  return variable_get("skinr_lite_color_memory_$theme_key", array(
    "saved-palette-1" => array(),
    "saved-palette-2" => array(),
    "saved-palette-3" => array(),
    "saved-palette-4" => array(),
    "saved-palette-5" => array(),
  ));
}
