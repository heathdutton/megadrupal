<?php

/*----------------------------------------------------------------------------
      SETUP & CONFIG
----------------------------------------------------------------------------*/

define('ENTITY_CONTEXT_SEPARATOR', '--');
define('ENTITY_CONTEXT_CATCHALL', 'entity_context_catchall');

/*----------------------------------------------------------------------------
      DRUPAL HOOKS
----------------------------------------------------------------------------*/

/**
 * Implements hook_menu();
 */
function entity_context_menu() {
  $items = array();
  
  $items['admin/config/content/personalize/entity_context'] = array(
    'type' => MENU_LOCAL_TASK,
    'title' => 'Entity Contexts',
    'description' => 'Configure which Entity values can be used as visitor contexts.',
    'page callback' => 'entity_context_admin_page',
    'access arguments' => array('administer personalize configuration'),
  );

  $items['admin/config/content/personalize/entity_context/%/delete'] = array(
    'title' => 'Delete Entity Context Item',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('entity_context_context_delete_form', 5),
    'access arguments' => array('administer personalize configuration'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_entity_load();
 */
function entity_context_entity_load($entities, $type) {
  // add the entity type & id to all entity objects for easy data access
  // from other hooks
  array_walk($entities, function (&$entity) use ($type) {
    // we don't want to add these entity fields when the entity is being exported into
    // a feature, otherwise the feature will always show as overridden and will not 
    // revert
    if (  preg_match('#admin/structure/features#', $_GET['q'])  // features page
            || 
          (                                                     // drush fu command
            isset($_SERVER['SCRIPT_FILENAME']) && 
            preg_match('/drush\.php$/', $_SERVER['SCRIPT_FILENAME']) &&
            isset($_SERVER['argv'][2]) &&
            $_SERVER['argv'][2] == 'fu'
          )
       ) {
      return;
    }

    // set entity_type and id
    if (!isset($entity->entity_type)) {
      $entity->entity_type = $type;
    }

    if (!isset($entity->entity_id)) {
      list($entity->entity_id) = entity_extract_ids($type, $entity);
    }
  });
}

/**
 * Implements hook_page_build();
 */
function entity_context_page_build(&$page) {
  $entity = menu_get_object();

  $contexts = variable_get('acquia_lift_profiles_udf_mappings', array());

  $values = entity_context_get_context_values($entity, $contexts);

  if (isset($_GET['debug'])) {
    drupal_set_message('entity_context values:', 'notice');
    drupal_set_message('<pre>' . print_r($values, 1) . '</pre>', 'notice');
  }

  if (!$values) {
    return;
  }

  $page['page_top']['entity_context'] = array(
    '#attached' => array(
      'js' => array(
        drupal_get_path('module', 'entity_context') . '/js/entity_context.js' => array(),
        array(
          'data' => array('entity_context' => $values),
          'type' => 'setting'
        ),
      ),
    )
  );
}

/*----------------------------------------------------------------------------
      MODULE HOOKS
----------------------------------------------------------------------------*/

/**
 * Implements hook_personalize_visitor_contexts();
 */
function entity_context_personalize_visitor_context() {
  $info = array();
  $path = drupal_get_path('module', 'entity_context') . '/plugins';

  $info['entity_context'] = array(
    'path' => $path . '/visitor_context',
    'handler' => array(
      'file' => 'EntityContext.inc',
      'class' => 'EntityContext',
    ),
  );

  return $info;
}

/**
 * Implements hook_ctools_plugin_api();
 */
function entity_context_ctools_plugin_api($owner, $api) {
  if ($owner == 'personalize' && $api == 'personalize') {
    return array('version' => 1);
  }
}

/**
 * Implements hook_entity_context_field_types();
 */
function entity_context_entity_context_field_types() {
  // @TODO: add support for more core field types: node
  $info = array();
  $path = drupal_get_path('module', 'entity_context') . '/plugins';

  $info['boolean'] = array(
    'path' => $path . '/entity_context',
    'handler' => array(
      'file' => 'Boolean.inc',
      'class' => 'Boolean',
    ),
    'dependencies' => array(
      'text',
    ),
  );

  $info['date'] = array(
    'path' => $path . '/entity_context',
    'handler' => array(
      'file' => 'Date.inc',
      'class' => 'Date',
    ),
    'dependencies' => array(
      'text',
    ),
  );

  $info['datetime'] = array(
    'path' => $path . '/entity_context',
    'handler' => array(
      'file' => 'DateTime.inc',
      'class' => 'DateTime',
    ),
    'dependencies' => array(
      'text',
    ),
  );

  $info['entity_context_undefined'] = array(
    'path' => $path . '/entity_context',
    'handler' => array(
      'file' => 'EntityContextUndefined.inc',
      'class' => 'EntityContextUndefined',
    ),
    'dependencies' => array(
      'text',
    ),
  );

  $info['entityreference'] = array(
    'path' => $path . '/entity_context',
    'handler' => array(
      'file' => 'EntityReference.inc',
      'class' => 'EntityReference',
    ),
  );

  $info['integer'] = array(
    'path' => $path . '/entity_context',
    'handler' => array(
      'file' => 'Integer.inc',
      'class' => 'Integer',
    ),
    'dependencies' => array(
      'text',
    ),
  );

  $info['list_boolean'] = array(
    'path' => $path . '/entity_context',
    'handler' => array(
      'file' => 'ListBoolean.inc',
      'class' => 'ListBoolean',
    ),
    'dependencies' => array(
      'boolean',
    ),
  );

  $info['list_integer'] = array(
    'path' => $path . '/entity_context',
    'handler' => array(
      'file' => 'ListInteger.inc',
      'class' => 'ListInteger',
    ),
    'dependencies' => array(
      'text',
    ),
  );

  $info['list_text'] = array(
    'path' => $path . '/entity_context',
    'handler' => array(
      'file' => 'ListText.inc',
      'class' => 'ListText',
    ),
    'dependencies' => array(
      'text',
    ),
  );

  $info['text'] = array(
    'path' => $path . '/entity_context',
    'handler' => array(
      'file' => 'Text.inc',
      'class' => 'Text',
    ),
  );

  $info['text_formatted'] = array(
    'path' => $path . '/entity_context',
    'handler' => array(
      'file' => 'TextFormatted.inc',
      'class' => 'TextFormatted',
    ),
  );

  $info['text_long'] = array(
    'path' => $path . '/entity_context',
    'handler' => array(
      'file' => 'TextLong.inc',
      'class' => 'TextLong',
    ),
    'dependencies' => array(
      'text_formatted',
    ),
  );

  $info['text_with_summary'] = array(
    'path' => $path . '/entity_context',
    'handler' => array(
      'file' => 'TextWithSummary.inc',
      'class' => 'TextWithSummary',
    ),
    'dependencies' => array(
      'text_formatted',
    ),
  );

  $info['token'] = array(
    'path' => $path . '/entity_context',
    'handler' => array(
      'file' => 'Token.inc',
      'class' => 'Token',
    ),
    'dependencies' => array(
      'text',
    ),
  );

  $info['user'] = array(
    'path' => $path . '/entity_context',
    'handler' => array(
      'file' => 'User.inc',
      'class' => 'User',
    ),
  );

  $info['uri'] = array(
    'path' => $path . '/entity_context',
    'handler' => array(
      'file' => 'Uri.inc',
      'class' => 'Uri',
    ),
    'dependencies' => array(
      'text',
    ),
  );

  return $info;
}

/*----------------------------------------------------------------------------
      CALLBACKS
----------------------------------------------------------------------------*/

/**
 * Menu callback for /admin/config/content/personalize/entity_context
 */
function entity_context_admin_page() {
  $output = '';

  // pull up existing entity contexts
  $result = db_select('entity_context', 'ec')
    ->fields('ec', array('id', 'context'))
    ->orderBy('id', 'ASC')
    ->execute();

  $rows = array();
  foreach ($result as $row) {
    $rows[] = array(
      'context' => entity_context_get_nice_context_name($row->context),
      'machine_name' => $row->context,
      'id' => $row->id,
      'actions' => l('Delete', 'admin/config/content/personalize/entity_context/' . $row->id . '/delete'),
    );
  }

  if ($rows) {
    $output .= theme('table', array(
      'header' => array(t('Context'), t('Machine Name'), t('ID'), t('Actions')),
      'rows' => $rows,
      'attributes' => array(
        'class' => array('entity-context-data'),
      ),
      'caption' => 'Entity Contexts',
    ));
  }

  $entity_types_form = drupal_get_form('entity_context_entity_types_form');
  $output .= drupal_render($entity_types_form);

  $new_context_form = drupal_get_form('entity_context_new_context_form');
  $output .= drupal_render($new_context_form);

  return $output;
}

/*----------------------------------------------------------------------------
      FORMS
----------------------------------------------------------------------------*/

/**
 * Form for choosing entity types that can be used for context creation.
 */
function entity_context_entity_types_form($form, &$form_state) {
  $form['wrapper'] = array(
    '#title' => t('Select Entity Types'),
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );

  $form['wrapper']['entity_context_entity_types'] = array(
    '#title' => t('Entity Types'),
    '#description' => t('Select entity types that can be used to create new contexts.'),
    '#type' => 'checkboxes',
    '#options' => array(),
    '#default_value' => variable_get('entity_context_entity_types', array()),
  );

  $info = entity_get_info();
  array_walk($info, function($entity_type_data, $entity_type) use (&$form) {
    $form['wrapper']['entity_context_entity_types']['#options'][$entity_type] = $entity_type_data['label'];
  });

  $form = system_settings_form($form);
  $form['wrapper']['actions'] = $form['actions'];
  unset($form['actions']);

  return $form;
}

/**
 * Form for creating new contexts.
 */
function entity_context_new_context_form($form, &$form_state) {
  // get list of configured entity types
  if (!$allowed_entity_types = entity_context_allowed_entity_types()) {
    return $form;
  }

  $form['#attached']['css'][] = drupal_get_path('module', 'entity_context') . '/css/entity_context.css';
  $form['info']['#markup'] = t('Create new Contexts by selecting the desired Entity Type and drilling down to a specific field.');
  
  // wrapper for AJAX replacement
  $id = 'entity_context_wrapper';
  $form['#prefix'] = '<div id="' . $id . '" class="entity-context-wrapper">';
  $form['#suffix'] = '</div>';

  // common FAPI structure for all our select elements
  $common_fapi = array(
    '#type' => 'select',
    '#options' => array(),
    '#ajax' => array(
      'wrapper' => $id,
      'callback' => 'entity_context_ajax_callback',
    ),
  );

  // entity type select
  $form['entity_type'] = array(
    '#title' => t('Entity Type'),
  ) + $common_fapi;

  // add supported entity type options
  $info = entity_get_info();
  array_walk($info, function($entity_type_data, $entity_type) use (&$form, $allowed_entity_types) {
    if (in_array($entity_type, $allowed_entity_types)) {
      $form['entity_type']['#options'][$entity_type] = $entity_type_data['label'];
    }
  });

  // track the selected values for easy access
  $selected = array();
  // get selected entity type value
  $selected['entity_type'] = entity_context_get_selected('entity_type', $form, $form_state);

  // bundle element and catchall bundle
  $form['bundle'] = array(
    '#title' => t('Bundle'),
    '#options' => array(
      ENTITY_CONTEXT_CATCHALL => t('All bundles'),
    ),
  ) + $common_fapi;

  // add bundle options
  array_walk($info, function($entity_type_data, $entity_type) use (&$form, $selected) {
    // make sure this is the selected entity type
    if ($entity_type == $selected['entity_type']) {
      array_walk($entity_type_data['bundles'], function($bundle_data, $bundle) use (&$form, $entity_type) {
        $form['bundle']['#options'][$bundle] = $bundle_data['label'];
      });
    }
  });

  // get selected bundle value
  $selected['bundle'] = entity_context_get_selected('bundle', $form, $form_state);

  // add fields and properties
  $form['field'] = array(
    '#title' => t('Field'),
    '#options' => entity_context_get_options_field($selected['entity_type'], $selected['bundle']),
  ) + $common_fapi;

  // get selected field value
  $selected['field'] = entity_context_get_selected('field', $form, $form_state);

  // we don't need to do anything more for properties, but for fields this will bring up more data
  if ($field_info = field_info_field($selected['field'])) {
    // make sure field exists within specified entity type; the $field_info['entity_types']
    // data is unreliable!
    if (isset($field_info['bundles'][$selected['entity_type']])) {
      // default the label to the field's machine
      $field_label = $selected['field'];

      // if we're not using the catchall bundle, we can go a step further and pull up
      // the actual label of this field instance
      if ($selected['bundle'] !== ENTITY_CONTEXT_CATCHALL && in_array($selected['bundle'], $field_info['bundles'][$selected['entity_type']])) {
        $field_info_instance = field_info_instance($selected['entity_type'], $selected['field'], $selected['bundle']);
        $field_label = $field_info_instance['label'];
      }

      // if we've gotten this far, then the $field_info['type'] will be one of the
      // field types aggregated by hook_entity_context_field_types; we 
      // pick and choose which field types we want to continue working with; 
      // 
      // @TODO: this is a good spot to pass off the form back to child modules that
      //        declared support for the current field type (and let them handle
      //        further form extension)
      if ($field_info['type'] == 'entityreference') {
        $target_entity_type = $field_info['settings']['target_type'];
        $target_bundle = ENTITY_CONTEXT_CATCHALL;

        // if there is only one target bundle in the entityreference field, we can 
        // pull up bundle-specific field information, othwerise we stick to catchall
        // values
        if (sizeof($field_info['settings']['handler_settings']['target_bundles']) == 1) {
          $target_bundle = reset($field_info['settings']['handler_settings']['target_bundles']);
        }

        $form['entityreference'] = array(
          '#title' => t('!field_label - EntityReference', array(
            '!field_label' => $field_label,
          )),
          '#options' => entity_context_get_options_field($target_entity_type, $target_bundle),
        ) + $common_fapi;

        // get selected entityreference value
        $selected['entityreference'] = entity_context_get_selected('entityreference', $form, $form_state);
      }
    }
  }

  // the submit button
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Add context'),
  );

  // for a nicer form structure, move all elements into a fieldset
  $new_form = array();
  $new_form['wrapper'] = array(
    '#title' => t('Add new context'),
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
  );

  array_walk($form, function ($element, $key) use (&$new_form) {
    if ($key{0} == '#') {
      $new_form[$key] = $element;
    }
    else {
      $new_form['wrapper'][$key] = $element;
    }
  });

  return $new_form;
}

/**
 * Submit handler for entity_context_new_context_form
 */
function entity_context_new_context_form_submit($form, &$form_state) {
  $fields = entity_context_form_fields();

  $context = array();

  array_walk($form_state['values'], function ($value, $key) use ($fields, &$context) {
    if (in_array($key, $fields)) {
      $context[] = $value;
    }
  });

  $context = implode(ENTITY_CONTEXT_SEPARATOR, $context);

  entity_context_save_context($context);

  drupal_set_message(t('Context item saved.'));
}

/**
 * Callback for AJAX requests on entity_context_new_context_form
 * @return [type] [description]
 */
function entity_context_ajax_callback($form, $form_state) {
  $output = theme('status_messages') . drupal_render($form);

  return $output;
}

/**
 * Menu callback for /admin/config/content/personalize/entity_context/%/delete
 */
function entity_context_context_delete_form($form, &$form_state, $id) {
  $form = array();

  $form['id'] = array(
    '#type' => 'value',
    '#value' => $id,
  );

  return confirm_form($form, t('Are you sure you want to delete this item?'), 
                            'admin/config/content/personalize/entity_context', 
                            t('This action cannot be undone.'), 
                            t('Delete'), 
                            t('Cancel'));
}

/**
 * Submit handler for entity_context_context_delete_form
 */
function entity_context_context_delete_form_submit($form, &$form_state) {
  $num_deleted = entity_context_delete_context($form_state['values']['id']);

  if ($num_deleted) {
    drupal_set_message(t('Context item deleted.'));
  }
  else {
    drupal_set_message(t('Could not delete specified item.'), 'error');
  }

  $form_state['redirect'] = 'admin/config/content/personalize/entity_context';
}

/*----------------------------------------------------------------------------
      INTERNAL / HELPERS
----------------------------------------------------------------------------*/

/**
 * Returns array of entity types which can be used to create new contexts.
 */
function entity_context_allowed_entity_types() {
  return array_filter(variable_get('entity_context_entity_types', array()), function ($value) {
    return $value !== 0;
  });
}

/**
 * Return an array of possible fields in the 'add new context' form; fields
 * are in the order they're built in the form.
 * @return [type] [description]
 */
function entity_context_form_fields() {
  return array('entity_type', 'bundle', 'field', 'entityreference');
}

/**
 * Checks $form_state for given $field value and returns it, otherwise 
 * defaulting to the first available value in $field's #options within $form
 * 
 * @param  [type] $field      [description]
 * @param  [type] $form       [description]
 * @param  [type] $form_state [description]
 * @return [type]             [description]
 */
function entity_context_get_selected($field, $form, &$form_state) {
  reset($form[$field]['#options']);
  $selected = key($form[$field]['#options']); 
  if (isset($form_state['values'][$field])) {
    $selected = $form_state['values'][$field];

    // if we're updating the form via one of the selects, we need to get rid of
    // the data present in all of the subsequent (child) selects; this $fields
    // array specifies the field tree
    $fields = entity_context_form_fields();
    if (($i = array_search($form_state['input']['_triggering_element_name'], $fields)) !== FALSE) {
      for (++$i; $i < sizeof($fields); $i++) {
        unset($form_state['values'][$fields[$i]]);
        unset($form_state['input'][$fields[$i]]);
      }
    }
  }

  return $selected;
}

/**
 * Returns a nice name from a context's machine name.
 * 
 * @param  [type] $context [description]
 * @return [type]          [description]
 */
function entity_context_get_nice_context_name($context) {
  $name = array();

  // map the individual context parts to their respective field names
  $values = explode(ENTITY_CONTEXT_SEPARATOR, $context);
  $values = entity_context_combine_field_keys($values);

  $info = entity_get_info($values['entity_type']);
  $name[] = $info['label'];

  if ($values['bundle'] == ENTITY_CONTEXT_CATCHALL) {
    $name[] = t('All Bundles');

    $entity_property_info = entity_get_property_info($values['entity_type']);
    if (isset($entity_property_info['properties'][$values['field']])) {
      $name[] = $entity_property_info['properties'][$values['field']]['label'];
    }
    else {
      $name[] = $values['field'];
    }
  }
  else {
    $name[] = $info['bundles'][$values['bundle']]['label'];

    $field_info_instance = field_info_instance($values['entity_type'], $values['field'], $values['bundle']);
    $name[] = $field_info_instance['label'];
  }

  if (isset($values['entityreference'])) {
    $info = field_info_field($values['field']);
    // grab the entity type and first target bundle
    $target_entity_type = $info['settings']['target_type'];
    $target_bundle = reset($info['settings']['handler_settings']['target_bundles']);

    $entity_info = entity_get_property_info($target_entity_type);
    $field_label = $values['entityreference'];

    if (isset($entity_info['properties'][$values['entityreference']])) {
      $field_label = $entity_info['properties'][$values['entityreference']]['label'];
    }

    $name[] = $field_label;
  }

  return implode(' > ', $name);
}

/**
 * Maps the elements in $values to their respective field names in $keys,
 * ensuring equal array lengths
 * @param  [type] $values [description]
 * @param  [type] $keys   [description]
 * @return [type]         [description]
 */
function entity_context_combine_field_keys($values, $keys = NULL) {
  if (is_null($keys)) {
    $keys = entity_context_form_fields();
  }

  // the $values may contain less items than there are max possible $keys,
  // so we get rid of unnecessary keys
  if ($diff = (sizeof($keys) - sizeof($values))) {
    do {
      array_pop($keys);
      $diff--;
    }
    while ($diff);
  }

  return array_combine($keys, $values);
}

/**
 * Saves context string to database.
 * @param  [type] $context [description]
 * @return [type]          [description]
 */
function entity_context_save_context($context) {
  db_merge('entity_context')
    ->key(array('context' => $context))
    ->fields(array(
        'context' => $context,
    ))
    ->execute();
}

/**
 * Deletes context string from database by context ID.
 * @param  [type] $id [description]
 * @return [type]     [description]
 */
function entity_context_delete_context($id) {
  return db_delete('entity_context')
          ->condition('id', $id)
          ->execute();
}

/**
 * Deletes context string from database by context string.
 * @param  [type] $context [description]
 * @return [type]          [description]
 */
function entity_context_delete_context_by_name($context) {
  return db_delete('entity_context')
          ->condition('context', $context)
          ->execute();
}

/**
 * Builds and returns context values.
 * 
 * @param  [type] $entity   [description]
 * @param  [type] $contexts [description]
 * @return [type]           [description]
 */
function entity_context_get_context_values($entity, $contexts) {
  $values = array();

  if ($entity && $contexts) {
    // entity_type property is set for all entities in entity_context_entity_load();
    $wrapper = entity_metadata_wrapper($entity->entity_type, $entity);

    // loop through types
    array_walk($contexts, function ($items, $type) use ($entity, $wrapper, &$values) {
      // loop through context within each type
      array_walk($items, function ($context, $udf) use ($entity, $wrapper, &$values, $type) {
        // bail out if it's not one of our contexts
        if (!preg_match('#^entity_context__((.+)' . ENTITY_CONTEXT_SEPARATOR . '(.+))$#', $context, $matches)) {
          return;
        }

        $simple_context = $matches[1];
        $context_values = explode(ENTITY_CONTEXT_SEPARATOR, $simple_context);
        $context_values = entity_context_combine_field_keys($context_values);

        // bail out if the specified entity-type doesn't match current entity
        if ($entity->entity_type != $context_values['entity_type']) {
          return;
        }
        
        // bail out if we're not using the catchall-bundle and the specified bundle doesn't match current entity
        if ($context_values['bundle'] !== ENTITY_CONTEXT_CATCHALL && $wrapper->getBundle() != $context_values['bundle']) {
          return;
        }

        list($field_group, $field_type) = entity_context_get_field_info($context_values['field'], $wrapper);

        // build the Handler class and set value
        if ($field_group && $field_type && $handler_class = entity_context_get_field_handler_class($field_type)) {
          $handler = new $handler_class($wrapper, $field_group, $context_values);

          // there is an edge-case that can throw an exception from within Entity:
          // content structure is modified to add a field on a node type, and that field is
          // mapped to a UDF, while not actually being present on an existing node.
          $value = FALSE;
          try {
            // we may get a legitimate empty array or 0, so use strict matching
            if (($value = $handler->getValue()) !== FALSE) {
              if ($value_string = $handler->getValueString($value)) {
                $values[$matches[1]] = $value_string;
              }
            }
          }
          catch(Exception $e) {}
        }
      });
    });
  }

  return $values;
}

/**
 * Returns the field types and their relevant class information.
 * @return [type] [description]
 */
function entity_context_get_field_types_info() {
  // build the array of field types we know how to handle
  $info = array();
  foreach (module_implements('entity_context_field_types') as $module) {
    $info = array_merge($info, module_invoke($module, 'entity_context_field_types'));
  }

  return $info;
}

/**
 * Returns an array containing the field group (property|field) and field type
 *  for given field name.
 * @param  [type] $field_name [description]
 * @param  [type] $wrapper    [description]
 * @return [type]             [description]
 */
function entity_context_get_field_info($field_name, $wrapper) {
  $field_group = NULL;
  $field_type = NULL;

  // try to load the field
  if ($field_info = field_info_field($field_name)) {
    $field_group = 'field';
    $field_type = $field_info['type'];

    // bail out if the field doesn't exist in the current bundle
    if (!in_array($wrapper->getBundle(), $field_info['bundles'][$wrapper->type()])) {
      return array(NULL, NULL);
    }
  }
  // loading the field failed, this must be a property
  else {
    $properties = $wrapper->getPropertyInfo();
    if (isset($properties[$field_name])) {
      $field_group = 'property';
      
      // the 'type' key is not set on the Node 'title' property data (because Drupal), so set a
      // custom one that we'll treat as a string
      if (!isset($properties[$field_name]['type'])) {
        $field_type = 'entity_context_undefined';
      }
      else {
        $field_type = $properties[$field_name]['type'];
      }
    }
  }

  return array(
    $field_group,
    $field_type,
  );
}

/**
 * Returns handler object's class_name for specified field type.
 * @param  [type] $type [description]
 * @return [type]       [description]
 */
function entity_context_get_field_handler_class($type) {
  $info = entity_context_get_field_types_info();

  if (isset($info[$type])) {
    module_load_include('inc', 'entity_context', 'includes/FieldHandler');

    // field handlers may build off of other field handlers, and child classes
    // are loaded via the 'dependecies' key/array
    if (isset($info[$type]['dependencies'])) {
      foreach ($info[$type]['dependencies'] as $dependency) {
        if (isset($info[$dependency])) {
          // rather than loading the class file directly, we recurse to allow for
          // proper handling of (possible) child-dependencies for current dependency
          entity_context_get_field_handler_class($dependency);
        }
      }
    }

    require_once('./' . $info[$type]['path'] . '/' . $info[$type]['handler']['file']);

    $class_name = implode('\\', array(
      'entity_context',
      'handler',
      $info[$type]['handler']['class'],
    ));

    return $class_name;
  }

  return FALSE;
}

/**
 * Returns an array of properties and fields present in the entity_type/bundle combination.
 * @param  [type] $entity_type [description]
 * @param  [type] $bundle      [description]
 * @return [type]              [description]
 */
function entity_context_get_options_field($entity_type, $bundle) {
  $types_info = entity_context_get_field_types_info();
  $supported_types = array_keys($types_info);

  // options array for 'Field' select
  $options = array();

  // set properties
  $info = entity_get_property_info($entity_type);
  array_walk($info['properties'], function ($property_data, $property) use (&$options, $supported_types) {
    // the 'type' key is not set on the Node 'title' property data, so set a
    // custom one that we'll treat as a string
    if (!isset($property_data['type'])) {
      $property_data['type'] = 'entity_context_undefined';
    }

    // restrict to properties we know how to handle;
    if (!in_array($property_data['type'], $supported_types)) {
      return;
    }

    $options[$property] = t('!label (!property)', array(
      '!label' => $property_data['label'],
      '!property' => $property,
    ));
  });

  // loop through all fields and find the ones applicable to current bundle
  $fields = field_info_field_map();
  array_walk($fields, function($field_data, $field) use (&$options, $entity_type, $bundle, $supported_types) {
    // restrict to fields present in selected entity type
    if (!isset($field_data['bundles'][$entity_type])) {
      return;
    }

    // restrict to fields present in selected bundle
    if ($bundle != ENTITY_CONTEXT_CATCHALL && !in_array($bundle, $field_data['bundles'][$entity_type])) {
      return;
    }

    // restrict to fields we know how to handle
    if (!in_array($field_data['type'], $supported_types)) {
      return;
    }

    // restrict to fields that only allow a single value
    // $field_info = field_info_field($field);
    // if ($field_info['cardinality'] != 1) {
    //   return;
    // }

    // add field
    $options[$field] = $field;

    // if we have a bundle, pull in the field's label for improved usability
    if ($bundle != ENTITY_CONTEXT_CATCHALL) {
      $field_info = field_info_instance($entity_type, $field, $bundle);
      $options[$field] = t('!label (!field)', array(
        '!field' => $field,
        '!label' => $field_info['label'],
      ));
    }
  });

  return $options;
}

/**
 * Sets default context values for contexts that don't have a value.
 * 
 * @param  [type] $contexts [description]
 * @param  [type] &$values  [description]
 * @param  string $module   [description]
 * @return [type]           [description]
 */
function entity_context_check_defaults($contexts, &$values, $module = 'entity_context') {
  $defaults = variable_get($module . '_default_udf_values', array());

  array_walk($defaults, function ($items, $type) use ($contexts, &$values, $module) {
    array_walk($items, function ($value, $udf) use ($contexts, &$values, $module, $type) {
      if (isset($contexts[$type][$udf])) {
        $context_key = $contexts[$type][$udf];
        $front_end_key = preg_replace('/^(' . $module . '__)(.+)/', '$2', $context_key);

        if (!isset($values[$front_end_key])) {
          $values[$front_end_key] = $value;
        }
      }
    });
  });
}

