<?php

/**
 * @file
 * Paginate
 *
 * Allow to override Drupal's core pager as link or input box.
 *
 * @package  User interface
 * @author   devendra.yadav <dev.firoza@gmail.com>
 */

/**
 * Implements hook_help().
 */
function paginate_help($path, $arg) {
  $help = '';
  switch ($path) {
    case 'admin/help#paginate':
      $help = check_markup(file_get_contents(dirname(__FILE__) . "/README.txt"));
      break;
  }
  return $help;
}

/**
 * Implements hook_theme().
 */
function paginate_theme() {
  $common_theme = drupal_common_theme();
  $theme = array(
    'paginate_link' => array(
      'variables' => $common_theme['pager_link']['variables'],
    ),
    'paginate_standard' => array(
      'variables' => array(
        'element' => $common_theme['pager']['variables']['element'],
        'parameters' => $common_theme['pager']['variables']['parameters'],
        'quantity' => $common_theme['pager']['variables']['quantity'],
        'display' => 'pages',
        'label_display' => 'none',
        'current_display' => 'normal',
        'total_display' => 'none',
        'first_link' => 'always',
        'previous_link' => 'always',
        'next_link' => 'always',
        'last_link' => 'always',
      ),
    ),
    'paginate_istandard' => array(
      'variables' => array(
        'element' => $common_theme['pager']['variables']['element'],
        'parameters' => $common_theme['pager']['variables']['parameters'],
        'quantity' => $common_theme['pager']['variables']['quantity'],
        'display' => 'pages',
        'label_display' => 'none',
        'current_display' => 'input',
        'total_display' => 'none',
        'first_link' => 'always',
        'previous_link' => 'always',
        'next_link' => 'always',
        'last_link' => 'always',
      ),
    ),
    'paginate_mini' => array(
      'variables' => array(
        'element' => $common_theme['pager']['variables']['element'],
        'parameters' => $common_theme['pager']['variables']['parameters'],
        'quantity' => $common_theme['pager']['variables']['quantity'],
        'display' => 'pages',
        'label_display' => 'before_current',
        'current_display' => 'normal',
        'total_display' => 'after_current',
        'first_link' => 'always',
        'previous_link' => 'always',
        'next_link' => 'always',
        'last_link' => 'always',
      ),
    ),
    'paginate_imini' => array(
      'variables' => array(
        'element' => $common_theme['pager']['variables']['element'],
        'parameters' => $common_theme['pager']['variables']['parameters'],
        'quantity' => $common_theme['pager']['variables']['quantity'],
        'display' => 'pages',
        'label_display' => 'before_current',
        'current_display' => 'input',
        'total_display' => 'after_current',
        'first_link' => 'always',
        'previous_link' => 'always',
        'next_link' => 'always',
        'last_link' => 'always',
      ),
    ),
  );
  return $theme;
}

/**
 * Implements hook_theme_registry_alter().
 *
 * Paginate replaces the theme_pager function defined in the theme registry
 * with its own internal function, and stores the overriden function
 * where abouts in a cache entry, so it can be called when needed.
 */
function paginate_theme_registry_alter(&$theme_registry) {
  global $theme_key;
  $theme_registry['pager']['type'] = 'module';
  $theme_registry['pager']['theme path'] = drupal_get_path('module', 'paginate');
}

/**
 * Default tags for Paginate's themes.
 *
 * @param string $theme
 *   theme name
 * @param string $display_mode
 *   what is being displayed within [pages]
 * @param array $tags
 *   an array of tags to be merged with defaults
 *
 * @return array
 *   merged array of custom and default tags
 */
function _paginate_tags_merge_default($theme, $display_mode, $tags = NULL) {

  switch ($theme) {
    case 'paginate_standard':
    case 'paginate_istandard':
      $default_tags = array(
        'page' => t("@number"),
        'first' => t("« first"),
        'previous' => t("‹ previous"),
        'next' => t("next ›"),
        'last' => t("last »"),
        'total' => t("out of @total"),
        'page_label' => t("Page"),
      );
      break;

    case 'paginate_mini':
    case 'paginate_imini':
      $default_tags = array(
        'page' => t("@number"),
        'first' => t("« first"),
        'previous' => t("‹ previous"),
        'next' => t("next ›"),
        'last' => t("last »"),
        'total' => t("out of @total"),
        'page_label' => t("Page"),
      );
      break;

    default:
      $default_tags = array(
        'page' => t("@number"),
        'first' => t("Â«"),
        'previous' => t("<"),
        'next' => t(">"),
        'last' => t("Â»"),
        'total' => t("out of @total"),
        'page_label' => t("Page"),
      );
      break;
  }

  switch ($display_mode) {
    case 'pages':
      $default_titles = array(
        'page_title' => t("Go to page @number"),
        'first_title' => t("Go to first page"),
        'previous_title' => t("Go to previous page"),
        'next_title' => t("Go to next page"),
        'last_title' => t("Go to last page"),
      );
      break;
  }

  $default_tags += $default_titles;
  if ($tags) {
    return array_merge($default_tags, $tags);
  }
  else {
    return $default_tags;
  }
}

/**
 * This theme is alike standard Drupal pager theme.
 *
 * Provides links to the current page, plus first/previous/next/last page.
 * Extended control on the pager is available through paginate's specific
 * $variables.
 */
function theme_paginate_standard($variables) {
  return _paginate_theme_handler('paginate_standard', $variables);
}

/**
 * This theme is alike standard Drupal pager theme.
 *
 * Provides links to the current page as inputbox, plus first/previous/next/last
 * page. Extended control on the pager is available through paginate's specific
 * $variables.
 */
function theme_paginate_istandard($variables) {
  return _paginate_theme_handler('paginate_istandard', $variables);
}

/**
 * This theme displays current page (or item).
 *
 * Examples:
 *
 * page 31 out of 101, display 'pages':
 * -----------------------------------------------------------
 * «  <  Page 31 of 101  >  »
 * -----------------------------------------------------------
 */
function theme_paginate_mini($variables) {
  return _paginate_theme_handler('paginate_mini', $variables);
}

/**
 * This theme displays current page (or item).
 *
 * Examples:
 *
 * page 31 out of 101, display 'pages':
 * -----------------------------------------------------------
 * «  <  Page 31 out of 101  >  »
 * -----------------------------------------------------------
 */
function theme_paginate_imini($variables) {

  return _paginate_theme_handler('paginate_imini', $variables);
}

/**
 * Paginate's theme handler.
 *
 * Calls to any theme_paginate_xxx() function are channeled to this handler.
 *
 * @param string $theme
 *   theme name
 * @param array  $variables
 *   theme's variables
 *
 * @return string
 *   HTML item list
 */
function _paginate_theme_handler($theme, $variables) {
  global $pager_total, $pager_limits;

  // Check if pager is needed; if not, return immediately.
  if ($pager_total[$variables['element']] <= 1) {
    return NULL;
  }

  $tags = isset($variables['tags']) ? $variables['tags'] : array();
  // Resolve tags. The tags key bears already localised strings.
  $variables['tags'] = _paginate_tags_merge_default($theme, $variables['display'], $tags);
  // Resolve links.
  $links = _paginate_resolve_links($variables);
  // Short to main links.
  $c = $links['pager_current'] - 1;
  $m = $links['pager_max'] - 1;

  // Determine pager items needed.
  $pages = array();
  switch ($theme) {
    case 'paginate_mini':
    case 'paginate_imini':
      $pages[$c]['interval'] = 0;
      list($pages[$c]['text'], $pages[$c]['text_title']) = _paginate_get_page_text($variables, $links, 0);
      break;

    case 'paginate_standard':
    case 'paginate_istandard':
    default:
      // Proximity/neigborhood.
      $pages += _paginate_get_proximity_pages($variables, $links);
  }

  // Compose pager.
  $items = array();
  if ($variables['total_display'] == 'first') {
    $items[] = array(
      'class' => array('pager-item'),
      'data' => format_string($variables['tags']['total'], array('@total' => _paginate_get_total($variables, $links))),
    );
  }
  // 2 - First + previous links.
  if ($variables['first_link'] == 'always' || ($variables['first_link'] == 'not_on_first' && $c <> 0)) {
    $items[] = _paginate_itemize_link('first', $variables, $links);
  }
  if ($variables['previous_link'] == 'always' || ($variables['previous_link'] == 'not_on_first' && $c <> 0)) {
    $items[] = _paginate_itemize_link('previous', $variables, $links);
  }
  // 3 - Pages.
  $items = array_merge($items, _paginate_itemize_page_links($variables, $links, $pages));
  // 4 - Next + last links.
  if ($variables['next_link'] == 'always' || ($variables['next_link'] == 'not_on_last' && $c <> $m)) {
    $items[] = _paginate_itemize_link('next', $variables, $links);
  }
  if ($variables['last_link'] == 'always' || ($variables['last_link'] == 'not_on_last' && $c <> $m)) {
    $items[] = _paginate_itemize_link('last', $variables, $links);
  }
  if ($variables['total_display'] == 'last') {
    $items[] = array(
      'class' => array('pager-item'),
      'data' => format_string($variables['tags']['total'], array('@total' => _paginate_get_total($variables, $links))),
    );
  }

  $output = '<h2 class="element-invisible">';
  $output .= t("Pages");
  $output .= '</h2>';
  $output .= '<div class="paginate">';
  $output .= theme('item_list', array(
    'items' => $items,
    'attributes' => array('class' => array('pager')),
  ));
  $output .= '</div>';
  drupal_add_css(drupal_get_path('module', 'paginate') . '/paginate.css');
  drupal_add_js(drupal_get_path('module', 'paginate') . '/paginate.js');
  return $output;
}

/**
 * Helper to calculate some links needed by all themes.
 *
 * @param array $variables
 *   theme's variables
 *
 * @return array
 *   associative array of integer values representing the links
 */
function _paginate_resolve_links($variables) {
  global $pager_page_array, $pager_total, $pager_total_items, $pager_limits;

  $links = array();

  // Pages.
  // Middle is used to "center" pages around the current page.
  $links['pager_middle'] = ceil($variables['quantity'] / 2);
  // Current is the page we are currently paged to.
  $links['pager_current'] = $pager_page_array[$variables['element']] + 1;
  // First is the first page listed by this pager piece (re quantity).
  $links['pager_first'] = $links['pager_current'] - $links['pager_middle'] + 1;
  // Last is the last page listed by this pager piece (re quantity).
  $links['pager_last'] = $links['pager_current'] + $variables['quantity'] - $links['pager_middle'];
  // Max is the maximum page number.
  $links['pager_max'] = $pager_total[$variables['element']];

  // Items.
  // 'pager_current_first_item' is the first item listed on the current page.
  $links['pager_current_first_item'] = $pager_limits[$variables['element']] * $pager_page_array[$variables['element']] + 1;
  // 'pager_current_last_item' is the last item listed on the current page.
  $links['pager_current_last_item'] = ($pager_limits[$variables['element']] * $links['pager_current']) > $pager_total_items[$variables['element']] ? $pager_total_items[$variables['element']] : $pager_limits[$variables['element']] * $links['pager_current'];
  // 'pager_item_max' is the maximum item number.
  $links['pager_item_max'] = $pager_total_items[$variables['element']];
  // 'pager_items_next' is the number of items expected on next page.
  if ($links['pager_current'] * $pager_limits[$variables['element']] > $links['pager_item_max']) {
    $links['pager_items_next'] = NULL;
  }
  else {
    $links['pager_items_next'] = $pager_total_items[$variables['element']] - ($links['pager_current'] * $pager_limits[$variables['element']]) > $pager_limits[$variables['element']] ? $pager_limits[$variables['element']] : $pager_total_items[$variables['element']] - ($links['pager_current'] * $pager_limits[$variables['element']]);
  }
  // 'pager_item_previous' is the number of items expected on previous page.
  if ($links['pager_current'] == 1) {
    $links['pager_items_previous'] = NULL;
  }
  else {
    $links['pager_items_previous'] = $pager_limits[$variables['element']];
  }

  return $links;
}

/**
 * Return link/button to first/previous/next/last element in the pager.
 *
 * @param string $scope
 *   target page [first|previous|next|last]
 * @param array $variables
 *   theme's variables
 * @param array $links
 *   precalculated links for the pager
 * @param string $type
 *   'anchor' returns a link via theme('paginate_link', ...),
 *   'button' returns a div that jQuery will transform in a ui button
 *
 * @return array
 *   pre-rendered item
 */
function _paginate_itemize_link($scope, $variables, $links, $type = 'anchor') {
  global $pager_page_array;
  $current_page = $links['pager_current'] - 1;
  $max_page = $links['pager_max'] - 1;

  // Determine the offset to current page and whether the link is
  // active or not.
  switch ($scope) {
    case 'first':
      $offset = -$current_page;
      $active_link = ($current_page > 0);
      break;

    case 'previous':
      $offset = -1;
      $active_link = ($current_page > 0);
      break;

    case 'next':
      $offset = 1;
      $active_link = ($current_page < $max_page);
      break;

    case 'last':
      $offset = $max_page - $current_page;
      $active_link = ($current_page < $max_page);
      break;
  }

  list($text, $text_title) = _paginate_get_page_text($variables, $links, $offset, $scope, 'absolute', $scope);

  if ($active_link && $type == 'anchor') {
    $li_data = theme(
      'paginate_link', array(
      'text' => $text,
      'page_new' => pager_load_array($current_page + $offset, $variables['element'], $pager_page_array),
      'element' => $variables['element'],
      'parameters' => $variables['parameters'],
      'attributes' => array('title' => $text_title),
      )
    );
    $li_active = TRUE;
  }
  else {
    $li_data = NULL;
    $li_active = FALSE;
  }

  return array(
    'class' => array('pager-' . $scope, $li_active ? 'active' : NULL),
    'data' => $li_data ? _paginate_resolve_link_data($li_data) : $text,
  );
}

/**
 * Return rendered items representing the links to 'page' elements in the pager.
 *
 * @param array $variables
 *   theme's variables
 * @param array $links
 *   precalculated links for the pager
 * @param array $pages
 *   the pages that are to be displayed in the pager
 *
 * @return array
 *   pre-rendered items
 */
function _paginate_itemize_page_links($variables, $links, $pages) {
  global $pager_page_array, $_paginate_ak_array;

  $element = $variables['element'];
  $items = array();
  if (!empty($pages)) {
    $i = 0;
    $previous_page = NULL;
    foreach ($pages as $page => $page_data) {
      // Sets previous page.
      $previous_page = $page;
      $text = isset($page_data['text']) ? $page_data['text'] : NULL;
      $text_title = isset($page_data['text_title']) ? $page_data['text_title'] : NULL;
      if ($page_data['interval'] < 0) {
        // Link to page before the current.
        // Target page.
        $page_new = pager_load_array($page, $element, $pager_page_array);

        // Get link data from theme_paginate_link().
        $link_data = theme(
          'paginate_link', array(
          'text' => $text,
          'page_new' => $page_new,
          'element' => $variables['element'],
          'interval' => -$page_data['interval'],
          'parameters' => $variables['parameters'],
          'attributes' => array('title' => $text_title),
          )
        );

        $items[] = array(
          'class' => array('pager-item', 'active'),
          'data' => _paginate_resolve_link_data($link_data),
        );
      }
      elseif ($page_data['interval'] == 0) {
        switch ($variables['current_display']) {
          case 'input':
            $items[] = array(
              'class' => array('pager-current'),
              'data' => '<div class="ipaginate"><input type="text" value="' . $text . '"><span id="errmsg"></span></div>',
            );
            break;

          case 'normal':
          default:
            $items[] = array(
              'class' => array('pager-current'),
              'data' => $text,
            );
        }
        if ($variables['total_display'] == 'after_current') {
          $items[] = array(
            'class' => array('pager-item'),
            'data' => format_string($variables['tags']['total'], array('@total' => _paginate_get_total($variables, $links))),
          );
        }
      }
      elseif ($page_data['interval'] > 0) {
        // Link to page after the current.
        // Target page.
        $page_new = pager_load_array($page, $element, $pager_page_array);

        // Get link data from theme_paginate_link().
        $link_data = theme(
          'paginate_link', array(
          'text' => $text,
          'page_new' => $page_new,
          'element' => $variables['element'],
          'interval' => $page_data['interval'],
          'parameters' => $variables['parameters'],
          'attributes' => array('title' => $text_title),
          )
        );
        $items[] = array(
          'class' => array('pager-item', 'active'),
          'data' => _paginate_resolve_link_data($link_data),
        );
      }
      $i++;
    }
  }

  drupal_add_js(array('paginate' => array('maxpage' => $links['pager_max'], 'curpage' => $links['pager_current'])), 'setting');
  return $items;
}

/**
 * Return textual elements for a 'page' element in the pager.
 *
 * Value returned is dependent on what's being displayed in the pager via the
 * $variable['display'] and the $page_mode selected ['absolute'|'relative'].
 *
 * @param array   $variables
 *   theme's variables
 * @param array   $links
 *   precalculated links for the pager
 * @param int $offset
 *   offset of page to be rendered, from current page
 * @param string  $page_tag
 *   page tag [page|first|previous|next|last]
 * @param string  $page_mode
 *   ['absolute']
 *   - 'absolute' returns the page at offset
 * @param string  $title_tag
 *   title tag [page|first|previous|next|last]
 *
 * @return array
 *   0 => qualified page text to be displayed on the page
 *   1 => qualified page text to be used as the HTML title
 */
function _paginate_get_page_text($variables, $links, $offset, $page_tag = 'page', $page_mode = 'absolute', $title_tag = 'page') {
  $c = $links['pager_current'] - 1;
  // Determine the text to be used to render the link. That is dependent
  // on the display mode and on the page mode.
  switch ($variables['display']) {
    default:
      $absolute_page_num = $c + $offset + 1;
      break;
  }
  if ($page_mode == 'absolute') {
    // Use the normal page tag.
    $text = format_string(
      $variables['tags'][$page_tag], array(
      '@number' => $absolute_page_num,
      '@total' => _paginate_get_total($variables, $links),
      )
    );
  }

  // Format the HTML title, used by the browser to display help text.
  $text_title = format_string(
    $variables['tags'][$title_tag . '_title'], array(
    '@number' => $absolute_page_num,
    '@total' => _paginate_get_total($variables, $links),
    )
  );

  return array($text, $text_title);
}

/**
 * Return total number of pages or items in the pager.
 *
 * Depending on $variables['display'], return a number either in
 * pages or in items.
 *
 * @param array $variables
 *   theme's variables
 * @param array $links
 *   precalculated links for the pager
 *
 * @return int
 *   total number of pages or items in the pager
 */
function _paginate_get_total($variables, $links) {

  switch ($variables['display']) {
    case 'pages':
    default:
      return $links['pager_max'];
  }
}

/**
 * Alternative to standard theme_pager_link().
 *
 * @see http://drupal.org/node/1588138
 */
function theme_paginate_link($variables) {
  $text = $variables['text'];

  $page_new = $variables['page_new'];
  $element = $variables['element'];
  $parameters = $variables['parameters'];
  $attributes = $variables['attributes'];

  $page = isset($_GET['page']) ? $_GET['page'] : '';
  if ($new_page = implode(',', pager_load_array($page_new[$element], $element, explode(',', $page)))) {
    $parameters['page'] = $new_page;
  }

  $query = array();
  if (count($parameters)) {
    $query = drupal_get_query_parameters($parameters, array());
  }
  if ($query_pager = pager_get_query_parameters()) {
    // @see http://drupal.org/node/1588138
    $query = array_merge($query_pager, $query);
  }

  // Set each pager link title
  if (!isset($attributes['title'])) {
    static $titles = NULL;
    if (!isset($titles)) {
      $titles = array(
        t('« first') => t('Go to first page'),
        t('‹ previous') => t('Go to previous page'),
        t('next ›') => t('Go to next page'),
        t('last »') => t('Go to last page'),
      );
    }
    if (isset($titles[$text])) {
      $attributes['title'] = $titles[$text];
    }
    elseif (is_numeric($text)) {
      $attributes['title'] = t('Go to page @number', array('@number' => $text));
    }
  }

  // @see http://drupal.org/node/1410574
  $attributes['href'] = url($_GET['q'], array('query' => $query));
  drupal_add_js(array('paginate' => array('url' => $attributes['href'])), 'setting');
  return '<a' . drupal_attributes($attributes) . '>' . check_plain($text) . '</a>';
}

/**
 * Helper to convert data returned from theme_pager_xxxx() calls.
 *
 * Tao based-themes override Drupal core theme_pager_xxxx() calls and
 * return an array that can be used by theme_links(), instead of
 * HTML markup. In this case the input is themed and HTML returned.
 *
 * @param string|array $link
 *   result of theme_pager_xxxx() call
 *
 * @return string
 *   HTML markup
 */
function _paginate_resolve_link_data($link) {
  if (is_array($link)) {
    if (isset($link['title']) && isset($link['href'])) {
      $link = l($link['title'], $link['href'], $link);
    }
  }
  return $link;
}

/**
 * Return an array of 'pages' in the neighborhood of the current one.
 *
 * This is in fact generating the same list of pages as standard Drupal
 * pager. The neighborhood is centered on the current page, with
 * ($variables['quantity'] / 2) pages falling aside left and right
 * of the current, provided there are enough pages.
 *
 * @param array $variables
 *   theme's variables
 * @param array $links
 *   precalculated links for the pager
 *
 * @return array
 *   associative array of pages, with key = page and value an array
 *   having 'text' and 'interval' (the offset from current page)
 *   keys/values
 */
function _paginate_get_proximity_pages($variables, $links) {

  // Prepare for generation loop.
  $i = $links['pager_first'];
  // Adjust "center" if at end of query.
  if ($links['pager_last'] > $links['pager_max']) {
    $i = $i + ($links['pager_max'] - $links['pager_last']);
    $links['pager_last'] = $links['pager_max'];
  }
  // Adjust "center" if at start of query.
  if ($i <= 0) {
    $links['pager_last'] = $links['pager_last'] + (1 - $i);
    $i = 1;
  }

  $pages = array();
  for (; $i <= $links['pager_last'] && $i <= $links['pager_max']; $i++) {
    $offset = $i - $links['pager_current'];
    $pages[$i - 1]['interval'] = $offset;
    list($pages[$i - 1]['text'], $pages[$i - 1]['text_title']) = _paginate_get_page_text($variables, $links, $offset);
  }
  return $pages;
}
