<?php
/**
 * @file
 * Version Control / Project Node integration - Integrates project nodes
 * (provided by the Project module) with version control systems supported
 * by the Version Control API.
 *
 * Copyright 2006, 2007, 2009 by Derek Wright ("dww", http://drupal.org/user/46549)
 * Copyright 2007, 2008, 2009 by Jakob Petsovits ("jpetso", http://drupal.org/user/56020)
 */

/**
 * Implements hook_menu().
 */
function versioncontrol_project_menu() {
  $items = array();

  $items['node/%project/committers'] = array(
    'title' => 'Committers',
    'page callback' => 'versioncontrol_project_committers_page',
    'page arguments' => array(1),
    'type' => MENU_CALLBACK,
    'access callback' => 'node_access',
    'access arguments' => array('view', 1),
  );
  $items['node/%project/commits'] = array(
    'title' => 'Commits',
    'page callback' => 'versioncontrol_project_commits_page',
    'page arguments' => array('default', 1),
    'type' => MENU_CALLBACK,
    'access callback' => 'versioncontrol_project_commits_page_access',
    'access arguments' => array(1),
  );
  $items['node/%project/commits/feed'] = array(
    'title' => 'Commits',
    'page callback' => 'versioncontrol_project_commits_page',
    'page arguments' => array('feed', 1),
    'type' => MENU_CALLBACK,
    'access callback' => 'versioncontrol_project_commits_page_access',
    'access arguments' => array(1),
  );

  return $items;
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function versioncontrol_project_ctools_plugin_directory($module, $plugin) {
  if ($module == 'versioncontrol') {
    return "plugins/$plugin";
  }
}

/**
 * Helper function to control access to per-project commit view.
 */
function versioncontrol_project_commits_page_access($node) {
  return node_access('view', $node) && user_access('access commit messages');
}

/**
 * Implements hook_block_info().
 */
function versioncontrol_project_block_info() {
  return array(
    'project_maintainers' => array(
      'info' => t('Version Control Project: Project maintainers'),
      'cache' => DRUPAL_NO_CACHE,
    ),
  );
}

/**
 * Implements hook_theme().
 */
function versioncontrol_project_theme() {
  return array(
    'versioncontrol_project_maintainer_list' => array(
      'variables' => array('node', 'maintainers', 'block_length'),
    ),
  );
}

/**
 * Implements hook_node_load().
 *
 * Load versioncontrol_project fields into project node object.
 */
function versioncontrol_project_node_load($nodes, $types) {
  foreach ($nodes as $nid => $node) {
    $query = db_query('SELECT * FROM {versioncontrol_project_projects} WHERE nid = :nid', array(':nid' => $node->nid));
    // should only have one result, but iterating is easiest.
    foreach ($query as $result) {
      $fields = array('repo_id');
      foreach ($fields as $field) {
        $node->versioncontrol_project[$field] = $result->$field;
      }
      $node->versioncontrol_project['repo'] = versioncontrol_project_repository_load($node->nid);
    }
  }
}

/**
 * Implements hook_node_insert().
 *
 * Save versioncontrol_project information when a new project is created.
 */
function versioncontrol_project_node_insert($node) {
  if (!project_node_is_project($node)) {
    return;
  }
  $id = db_insert('versioncontrol_project_projects')
    ->fields(array(
      'nid' => $node->nid,
      'repo_id' => 0,
    ))
    ->execute();
}

/**
 * Implements hook_node_delete().
 *
 * Delete versioncontrol_project information when a new project is deleted.
 */
function versioncontrol_project_node_delete($node) {
  if (!project_node_is_project($node)) {
    return;
  }
  db_delete('versioncontrol_project_projects')
    ->condition('nid', $node->nid)
    ->execute();
}

/**
 * Update or add repo associated with a given project.
 *
 * @param $project_id
 *   Node ID of the project.
 * @param $repo_id
 *   The repo ID of the versioncontrol repo to associate.
 */
function versioncontrol_project_set_project($project_id, $repo_id) {
  $affected = db_update('versioncontrol_project_projects')
    ->fields(array(
      'repo_id' => $repo_id,
    ))
    ->condition('nid', $project_id)
    ->execute();

  if (!empty($affected)) {
    // Didn't update anything, add this as a new project.
    $id = db_insert('versioncontrol_project_projects')
      ->fields(array(
        'nid' => $project_id,
        'repo_id' => $repo_id,
      ))
      ->execute();
  }
}

/**
 * Implements hook_query_TAG_alter().
 *
 * Ensure that, for any repositories that are associated with projects, the
 * project nid is added directly to the
 * If the repository is associated with a project, add the project nid directly
 * to the repository object
 *
 * @param QueryAlterableInterface $query
 */
function versioncontrol_project_query_versioncontrol_repo_load_multiple_alter(QueryAlterableInterface $query) {
  $alias = $query->leftJoin('versioncontrol_project_projects', 'vcpp', 'base.repo_id = vcpp.repo_id');
  $query->addField($alias, 'nid', 'project_nid');
}

/**
 * Load the repository object associated with a project.
 */
function versioncontrol_project_repository_load($project_id) {
  $repo_id = db_query("SELECT repo_id FROM {versioncontrol_project_projects} WHERE nid = :nid", array(':nid' => $project_id))->fetchField();
  if (!empty($repo_id)) {
    $repository = versioncontrol_repository_load_multiple(array($repo_id));
    return empty($repository) ? FALSE : reset($repository);
  }
  return FALSE;
}

/**
 * Load the project object associated with a repo.
 */
function versioncontrol_project_project_load($repo_id) {
  $nid = db_query("SELECT nid FROM {versioncontrol_project_projects} WHERE repo_id = :repo_id", array(':repo_id' => $repo_id))->fetchField();
  if (!empty($nid)) {
    return node_load($nid);
  }
  return FALSE;
}

/**
 * Implements hook_versioncontrol_entity_repository_delete().
 */
function versioncontrol_project_versioncontrol_entity_repository_delete($repository) {
  // Delete mapping when repo is deleted.
  $project = versioncontrol_project_project_load($repository->repo_id);
  if (!empty($project)) {
    versioncontrol_project_set_project($project->nid, 0);
  }
}

/**
 * Implements hook_project_permission_info().
 */
function versioncontrol_project_project_permission_info($project = NULL) {
  // Make sure that we have a valid repo associated with this project, and
  // that it is using the auth plugin that we care about.
  if (!is_null($project) && $repo = versioncontrol_project_repository_load($project->nid)) {
    if (versioncontrol_project_verify_repo_auth_handler($repo)) {
      return array(
        'write to vcs' => array(
          'title' => t('Write to VCS'),
          'description' => t('Allows a user to commit or push to the repository associated with this project.'),
        ),
      );
    }
  }
}

/**
 * Implements hook_project_maintainer_save().
 *
 * TODO this more properly belongs in drupalorg.
 */
function versioncontrol_project_project_maintainer_save($nid, $uid, $permissions = array()) {
  $repo = versioncontrol_project_repository_load($nid);
  if ($repo && versioncontrol_project_verify_repo_auth_handler($repo)) {
    $auth_handler = $repo->getAuthHandler();
    $auth_data = $auth_handler->getUserData();
    if (!isset($auth_data[$uid])) {
      $auth_data[$uid] = array(
        'branch_create' => VersioncontrolAuthHandlerMappedAccounts::DENY,
        'branch_update' => VersioncontrolAuthHandlerMappedAccounts::DENY,
        'branch_delete' => VersioncontrolAuthHandlerMappedAccounts::DENY,
        'tag_create' => VersioncontrolAuthHandlerMappedAccounts::DENY,
        'tag_update' => VersioncontrolAuthHandlerMappedAccounts::DENY,
        'tag_delete' => VersioncontrolAuthHandlerMappedAccounts::DENY,
        'per-label' => array(),
      );
    }
    $auth_data[$uid]['access'] = ($permissions['write to vcs']) ? VersioncontrolAuthHandlerMappedAccounts::ALL : VersioncontrolAuthHandlerMappedAccounts::DENY;
    $auth_handler->setUserData($uid, $auth_data[$uid]);
    $auth_handler->save();
    // Clear cache for the maintainers block
    $cid = 'project_maintainers:' . $nid;
    _versioncontrol_project_block_cache_set($cid, NULL);
  }
}

/**
 * Implements hook_project_maintainer_remove().
 */
function versioncontrol_project_project_maintainer_remove($nid, $uid) {
  $repo = versioncontrol_project_repository_load($nid);
  if ($repo && versioncontrol_project_verify_repo_auth_handler($repo)) {
    $auth_handler = $repo->getAuthHandler();
    $auth_handler->deleteUserData($uid);
    $auth_handler->save();
    // Clear cache for the maintainers block
    $cid = 'project_maintainers:' . $nid;
    _versioncontrol_project_block_cache_set($cid, NULL);
  }
}

/**
 * Implements hook_project_maintainer_project_load().
 */
function versioncontrol_project_project_maintainer_project_load($nid, &$maintainers) {
  $repo = versioncontrol_project_repository_load($nid);
  if ($repo && versioncontrol_project_verify_repo_auth_handler($repo)) {
    $auth_data = $repo->getAuthHandler()->getUserData();
    if (!empty($auth_data)) {
      foreach ($auth_data as $account) {
        if (empty($maintainers[$account['uid']])) {
          $maintainers[$account['uid']]['name'] = db_query("SELECT name FROM {users} WHERE uid = :uid", array(':uid' => $account['uid']))->fetchField();
        }
        $maintainers[$account['uid']]['permissions']['write to vcs'] = ($account['access'] == VersioncontrolAuthHandlerMappedAccounts::ALL) ? 1 : 0;
      }
    }
  }
}

/**
 * Verify that a repo that is using a specific auth plugin.
 *
 * @param $repo
 *   A fully loaded repo
 *
 * @param $plugin
 *   (optional) The name of the plugin to check against. Defaults to 'account'
 *
 * @return bool
 *   TRUE is the auth_handler plugin matches the requested plugin, else FALSE.
 */
function versioncontrol_project_verify_repo_auth_handler($repo, $plugin = NULL) {
  $plugin = is_null($plugin) ? 'account' : $plugin;
  return $repo && isset($repo->plugins['auth_handler']) && $repo->plugins['auth_handler'] == $plugin;
}

/**
 * Implements hook_views_api().
 */
function versioncontrol_project_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'versioncontrol_project') . '/views',
  );
}

/**
 * Return a list of users who committed to the specified project.
 *
 * @param $nid
 *   Project node ID to get committers for.
 * @param $header_with_order
 *   The value used by TableSort::orderByHeader() in the query or NULL to use
 *   the default.
 * @param $only_maintainers
 *   Optional boolean to indicate if the list should only include users that
 *   currently have VCS write access to the project. Defaults to TRUE.
 *
 * @return
 *   Array containing objects of committer information, keyed by uid.
 */
function versioncontrol_project_get_project_committers($nid, $header_with_order = NULL, $only_maintainers = TRUE) {
  if (is_null($header_with_order)) {
    $header_with_order = array(
      array(
        'data' => t('User'),
        'field' => 'u.name',
      ),
      array(
        'data' => t('Last commit'),
        'field' => 'last_commit',
        'sort' => 'desc',
      ),
      array(
        'data' => t('First commit'),
        'field' => 'first_commit',
      ),
      array(
        'data' => t('Commits'),
        'field' => 'commits',
      ),
    );
  }
  $repo = versioncontrol_project_repository_load($nid);
  $query = db_select('versioncontrol_operations', 'o')->extend('TableSort');
  $query->join('users', 'u', 'o.author_uid = u.uid');
  $query->addExpression('MIN(o.author_date)', 'first_commit');
  $query->addExpression('MAX(o.author_date)', 'last_commit');
  $query->addExpression('COUNT(o.vc_op_id)', 'commits');
  $query->addField('o', 'author_uid', 'uid');
  $result = $query
    ->fields('u', array('name'))
    ->condition('o.repo_id', $repo->repo_id)
    ->condition('o.author_uid', 0, '!=')
    ->groupBy('repo_id')
    ->groupBy('uid')
    ->orderByHeader($header_with_order)
    ->execute();
  $committers = array();
  foreach ($result as $committer) {
    $committers[$committer->uid] = $committer;
  }
  if ($only_maintainers) {
    return array_intersect_key($committers, versioncontrol_project_get_project_maintainers($repo->repo_id));
  }
  return $committers;
}

/**
 * Page callback to display all committers for a given project.
 */
function versioncontrol_project_committers_page($project) {
  drupal_set_title(t('Committers for %name', array('%name' => $project->title)), PASS_THROUGH);
  $time = REQUEST_TIME;
  project_project_set_breadcrumb($project, TRUE);
  $header = array(
    array(
      'data' => t('User'),
      'field' => 'u.name',
    ),
    array(
      'data' => t('Last commit'),
      'field' => 'last_commit',
      'sort' => 'desc',
    ),
    array(
      'data' => t('First commit'),
      'field' => 'first_commit',
    ),
    array(
      'data' => t('Commits'),
      'field' => 'commits',
    ),
  );
  // Use FALSE for the 3rd argument to get all committers, not just the users
  // that currently have commit access.
  $committers = versioncontrol_project_get_project_committers($project->nid, $header, FALSE);
  $rows = array();
  foreach ($committers as $committer) {
    $rows[] = array(
      theme('username', array('account' => $committer)),
      t('!time ago', array('!time' => format_interval($time - $committer->last_commit, 1))),
      t('!time ago', array('!time' => format_interval($time - $committer->first_commit, 1))),
      format_plural($committer->commits, '1 commit', '@count commits'),
    );
  }
  return theme('table', array('header' => $header, 'rows' => $rows));
}

/**
 * Implements hook_block_configure().
 */
function versioncontrol_project_block_configure($delta) {
  $form = array();
  switch ($delta) {
    case 'project_maintainers':
      for ($i = 1; $i <= 10; $i++) {
        $options[$i] = $i;
      }
      $options['all'] = t('All committers');
      $form['versioncontrol_project_maintainers_block_length'] = array(
        '#type' => 'select',
        '#options' => $options,
        '#title' => t('Number of maintainers to display'),
        '#default_value' => variable_get('versioncontrol_project_maintainers_block_length', 5),
      );
      break;
  }
  return $form;
}

/**
 * Implements hook_block_save().
 */
function versioncontrol_project_block_save($delta, $edit) {
  switch ($delta) {
    case 'project_maintainers':
      variable_set('versioncontrol_project_maintainers_block_length', $edit['versioncontrol_project_maintainers_block_length']);
      break;
  }
}

/**
 * Implements hook_block_view().
 */
function versioncontrol_project_block_view($delta) {
  $block = array();
  switch ($delta) {
    case 'project_maintainers':
      $node = project_get_project_from_menu();
      if (($node = project_get_project_from_menu()) && !empty($node->versioncontrol_project['repo_id']) && node_access('view', $node)) {
        $cid = 'project_maintainers:' . $node->nid;
        $maintainers = _versioncontrol_project_block_cache_get($cid);
        if (empty($maintainers)) {
          $maintainers = versioncontrol_project_get_project_committers($node->nid);
          _versioncontrol_project_block_cache_set($cid, $maintainers);
        }
        $block = array(
          'subject' => t('Maintainers for @project', array('@project' => $node->title)),
          'content' => theme('versioncontrol_project_maintainer_list', array(
            'node' => $node,
            'maintainers' => $maintainers,
            'block_length' => variable_get('versioncontrol_project_maintainers_block_length', 5)
          )),
        );
      }
      break;
  }
  return $block;
}

function _versioncontrol_project_block_cache_get($cid) {
  $data = db_query("SELECT data FROM {versioncontrol_project_maintainers_block_cache} WHERE cid = :cid", array(':cid' => $cid))->fetchField();
  if (!empty($data)) {
    return unserialize($data);
  }
}

function _versioncontrol_project_block_cache_set($cid, $data) {
  if (empty($data)) {
    db_delete('versioncontrol_project_maintainers_block_cache')
      ->condition('cid', $cid)
      ->execute();
  }
  else {
    $serialized = serialize($data);
    db_merge('versioncontrol_project_maintainers_block_cache')
      ->key(array('cid' => $cid))
      ->fields(array(
          'data' => $serialized,
        ))
      ->execute();
  }
}

/**
 * Return themed HTML for the Versioncontrol project maintainers block.
 */
function theme_versioncontrol_project_maintainer_list($variables) {
  $node = $variables['node'];
  $maintainers = $variables['maintainers'];
  $block_length = isset($variables['block_length']) ? $variables['block_length'] : 'all';
  $i = 0;
  $time = REQUEST_TIME;
  $items = array();
  foreach ($maintainers as $maintainer) {
    if (is_numeric($block_length) && $i >= $block_length) {
      break;
    }
    $item = '<li><div class="vc-user">';
    $item .= theme('username', array('account' => $maintainer)) . ' - ';
    $item .= '<span class="vc-commits">' . format_plural($maintainer->commits, '1 commit', '@count commits') . '</span></div>';
    $item .= '<div class="vc-commit-times">';
    $item .= t('last: !last_time ago, first: !first_time ago', array('!last_time' => format_interval($time - $maintainer->last_commit, 1), '!first_time' => format_interval($time - $maintainer->first_commit, 1)));
    $item .= '</div>';
    $item .= '</li>';
    $i++;
    $items[] = $item;
  }
  $output = theme('item_list', array('items' => $items));
  $output .= '<div id="project-committers">' . l('View all committers', 'node/' . $node->nid . '/committers') . '</div>';
  $output .= '<div id="project-commits">' . l('View commits', 'node/' . $node->nid . '/commits') . '</div>';
  return $output;
}

/**
 * Return a list of all maintainers with VCS write access to the repo.
 *
 * @return array
 *   An array of users keyed by uid.
 */
function versioncontrol_project_get_project_maintainers($repo_id) {
  $maintainers = array();
  $repo = versioncontrol_repository_load($repo_id);
  if (versioncontrol_project_verify_repo_auth_handler($repo)) {
    $auth_data = $repo->getAuthHandler()->getUserData();
    foreach ($auth_data as $maintainer) {
      if ($maintainer['access'] == VersioncontrolAuthHandlerMappedAccounts::ALL) {
        $maintainers[$maintainer['uid']] = $maintainer;
      }
    }
  }
  return $maintainers;
}

/**
 * Implements hook_versioncontrol_entity_commit_insert().
 *
 * TODO This should be moved to be tied to hooks notifying that history syncs
 * are happening, rather than the individual entity insert.
 */
function versioncontrol_project_versioncontrol_entity_commit_insert($operation) {
  if (isset($operation->repo_id)) {
    // invalidate block cache for maintainers block
    $project = versioncontrol_project_project_load($operation->repo_id);
    if (!empty($project)) {
      $cid = 'project_maintainers:' . $project->nid;
      _versioncontrol_project_block_cache_set($cid, NULL);
    }
  }
}

/**
 * Implements hook_user_view().
 */
function versioncontrol_project_user_view($account, $view_mode) {
  // Print a list of projects the specified user contributed to.
  if (!empty($account->uid)) {
    // @todo replace with EFQ
    $query = db_select('versioncontrol_operations', 'o')
      ->fields('n', array('nid', 'title'))
      ->orderBy('commits', 'DESC')
      ->groupBy('n.nid')
      ->condition(
        db_and()
          ->condition('o.author_uid', $account->uid)
          ->condition(
            db_or()
              ->condition('t.field_project_type_value', 'full')
              ->condition(
                db_and()
                  ->condition('t.field_project_type_value', 'sandbox')
                  ->condition('n.uid', $account->uid)
              )
          )
      );
    $query->innerJoin('versioncontrol_project_projects', 'vcp', 'vcp.repo_id = o.repo_id');
    $query->innerJoin('node', 'n', 'n.status = 1 AND n.nid = vcp.nid');
    $query->innerJoin('field_data_field_project_type', 't', 't.entity_id = n.nid');
    $query->addExpression('COUNT(o.vc_op_id)', 'commits');
    $result = $query->execute();

    $total = 0;
    $projects = array();
    foreach ($result as $project) {
      $project_link = l($project->title, 'node/' . $project->nid);
      $projects[] = format_plural($project->commits, '!project (1 commit)', '!project (@count commits)', array('!project' => $project_link));
      $total += $project->commits;
    }
    if ($total > 0) {
      $projects[] = format_plural($total, 'Total: 1 commit', 'Total: @count commits');
    }
    if (!empty($projects)) {
      $account->content['versioncontrol_project'] = array(
        '#type' => 'user_profile_category',
        '#title' => t('Projects'),
        '#weight' => 10,
        '#attributes' => array('class' => 'versioncontrol-project-user-commits'),
      );
      $account->content['versioncontrol_project']['items'] = array(
        '#type' => 'user_profile_item',
        '#title' => '',
        '#markup' => theme('item_list', array('items' => $projects)),
      );
    }
  }
}

/**
 * Gets the auth data related to a project's repository.
 *
 * @param string $machinename
 *   The project.module's project machine name.
 *
 * @return array
 *   A multidimensional array of auth data.
 */
function versioncontrol_project_get_auth_data($machinename) {
  $data = array();
  $nid = project_get_nid_from_machinename($machinename);
  if ($nid && $project = node_load($nid)) {
    $repository = $project->versioncontrol_project['repo'];
    $account_perms = array();
    $data['project'] = $project->title;
    $data['project_nid'] = $project->nid;
    $data['repository_name'] = $repository->name;
    $data['repo_id'] = $repository->repo_id;
    $auth_data = $repository->getAuthHandler()->getUserData();
    foreach ($auth_data as $uid => $value) {
      $account = user_load($uid);
      $account_perms[$account->name] = $value;
      $account_perms[$account->name]['name'] = $account->name;
      $account_perms[$account->name]['pass'] = $account->pass;
    }
    $data['users'] = $account_perms;
    drupal_alter('versioncontrol_project_auth_data', $data, $repository, $project);
  }
  return $data;
}

/**
 * Implements hook_versioncontrol_project_auth_data_alter().
 *
 * Adds user's sshkeys to the repository data if the sshkey module is present.
 */
function versioncontrol_project_versioncontrol_project_auth_data_alter(&$data, $repository) {
  if (module_exists('sshkey')) {
    foreach ($data['users'] as $name => &$value) {
      module_load_include('inc', 'sshkey');
      $keys = sshkey_load_all_by_entity('user', $value['uid']);
      $value['ssh_keys'][' '] = ' ';
      foreach ($keys as &$key) {
        $value['ssh_keys'][$key->title] = $key->fingerprint;
      }
    }
  }
}

/**
 * Menu callback for per-project commits page
 */
function versioncontrol_project_commits_page($display_type, $node) {
  //TODO replace this way in favour of setting title through the view
//     itself: aka implement title_query() on a
//     versioncontrol_project_handler_argument_node_nid analogous to
//     versioncontrol_handler_argument_repository_repo_id
  drupal_set_title(t('Commits for @project', array('@project' => $node->title)), PASS_THROUGH);
  $set = versioncontrol_get_views_set('project_commit_view');
  if ($node->versioncontrol_project['repo'] instanceof VersioncontrolRepository) {
    $repository = $node->versioncontrol_project['repo'];
    $view_name = $set->getViewNameByEntity($repository);
  }
  else {
    $view_name = $set->getViewName();
  }
  $feed_url = "node/{$node->nid}/commits/feed";

  if ($display_type == 'feed') {
    return versioncontrol_render_commitlog_view($view_name, 'feed', array($node->nid), $feed_url);
  }
  return versioncontrol_render_commitlog_view($view_name, 'default', array($node->nid), '', $feed_url);
}
