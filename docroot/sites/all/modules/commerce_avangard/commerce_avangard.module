<?php

/**
 * @file
 * Provides a Avangard API (via XML) payment method for Drupal Commerce (width redirection).
 */

define('COMMERCE_AVANGARD_SERVER_PAY_URL', 'https://www.avangard.ru/iacq/pay');
define('COMMERCE_AVANGARD_SERVER_METHODS_URL', 'https://www.avangard.ru/iacq/h2h/');

define('METHOD_REGISTER_ORDER', 'reg');
define('METHOD_GET_ORDER_INFO', 'get_order_info');
define('METHOD_GET_OPERS_LIST', 'get_opers_list');
define('METHOD_GET_OPERS_BY_DATE', 'get_opers_by_date');
define('METHOD_ORDER_REFUND', 'reverse_order');

define('AVANGARD_ORDER_STATUS_LOST', 0);
define('AVANGARD_ORDER_STATUS_PENDING', 1);
define('AVANGARD_ORDER_STATUS_REJECTED', 2);
define('AVANGARD_ORDER_STATUS_COMPLETE', 3);
define('AVANGARD_ORDER_STATUS_PARTLY_REFUNDED', 5);
define('AVANGARD_ORDER_STATUS_REFUNDED', 6);

define('AVANGARD_SKIP_TRANSACTION', 4);

/**
 * Implements hook_menu().
 */
function commerce_avangard_menu() {
  $items = array();
  
  $items['checkout/%commerce_order/avangard_response'] = array(
    'page callback' => 'commerce_avangard_checkout_response',
    'page arguments' => array(1),
    'access arguments' => array('access content'),
    'file' => 'commerce_avangard.pages.inc',
    'type' => MENU_CALLBACK,
  );
  $items['checkout/%commerce_order/payment_back'] = array(
    'page callback' => 'commerce_avangard_payment_back',
    'page arguments' => array(1),
    'access arguments' => array('access content'),
    'file' => 'commerce_avangard.pages.inc',
    'type' => MENU_CALLBACK,
  );
  $items['user/%user/orders/%commerce_order/avangard_add_payment'] = array(
    'title' => 'Add payment',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_avangard_order_add_payment_form', 1, 3),
    'file' => 'commerce_avangard.pages.inc',
    'access arguments' => array('access content'),
  );
  $items['user/%user/orders/%commerce_order/avangard_payment_added'] = array(
    'title callback' => 'Add payment',
    'page callback' => 'commerce_avangard_add_payment_response',
    'page arguments' => array(1, 3),
    'file' => 'commerce_avangard.pages.inc',
    'access arguments' => array('access content'),
  );
  $items['admin/commerce/orders/%commerce_order/payment/%commerce_payment_transaction/avangard_refund'] = array(
    'title' => 'Refund',
    'page arguments' => array('commerce_avangard_transaction_refund_form', 3, 5),
    'page callback' => 'drupal_get_form',
    'access callback' => 'commerce_avangard_transaction_refund_access',
    'access arguments' => array(5),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_INLINE,
    'file' => 'commerce_avangard.admin.inc',
    'weight' => 10,
  );
  $items['admin/commerce/config/payment-methods/avangard'] = array(
    'title' => 'Commerce Avangard settings',
    'page callback' => 'drupal_get_form',
    'access arguments' => array('configure commerce avangard'),
    'page arguments' => array('variable_group_form', 'commerce_avangard_main_settings'),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 100,
  );
  $items['admin/commerce/config/payment-methods/avangard/operations'] = array(
    'title' => 'Today operations',
    'page callback' => 'commerce_avangard_date_operations',
    'file' => 'commerce_avangard.admin.inc',
    'type' => MENU_NORMAL_ITEM,
    'access arguments' => array('administer payments'),
  );
  $items['admin/commerce/config/payment-methods/avangard/operations/%'] = array(
    'title' => 'Date operations',
    'page callback' => 'commerce_avangard_date_operations',
    'page arguments' => array(6),
    'file' => 'commerce_avangard.admin.inc',
    'access arguments' => array('administer payments'),
  );

  return $items;
}

/**
 * Implements hook_permission().
 */
function commerce_avangard_permission() {
  $permissions = array();

  $permissions['configure commerce avangard'] = array(
    'title' => t('Configure avangard payment settings'),
    'description' => t('Allows users to configure Avangard payment settings.'),
    'restrict access' => TRUE,
  );
  $permissions['refund avangard transactions'] = array(
    'title' => t('Refund avangard transactions'),
    'description' => t('Allows users to refund Avangard transactions.'),
    'restrict access' => TRUE,
  );

  return $permissions;
}

function commerce_avangard_transaction_refund_access($transaction) {
  return $transaction->payment_method == 'commerce_avangard'
          && $transaction->amount > 0 && $transaction->status == COMMERCE_PAYMENT_STATUS_SUCCESS
          && user_access('refund avangard transactions');
}

/**
 * Implements hook_commerce_payment_method_info().
 */
function commerce_avangard_commerce_payment_method_info() {
  $payment_methods = array();

  $payment_methods['commerce_avangard'] = array(
    'title' => t('Avangard API'),
    'short_title' => t('Bank Card'),
    'display_title' => t('Bank Card'),
    'description' => t('Integration with Avangard API.'),
    'terminal' => TRUE,
    'offsite' => TRUE,
    'offsite_autoredirect' => FALSE,
    'active' => TRUE,
  );

  return $payment_methods;
}

/**
 * Implements hook_cronapi().
 */
function commerce_avangard_cronapi($op, $job = NULL) {
  $items = array();

  $items['commerce_avangard_check_transactions_statuses'] = array(
    'description' => 'Check bank card payment transactions statuses',
    'rule' => '*/5 * * * *', // Each 5 minutes.
  );

  return $items;
}

function commerce_avangard_unfinished_payments_statuses() {
  // First check the static cache for an order states array.
  $order_statuses = &drupal_static(__FUNCTION__);

  // If it did not exist, fetch the statuses now.
  if (empty($order_statuses)) {
    $order_statuses = module_invoke_all('commerce_avangard_unfinished_payments_statuses_info');
  }

  return $order_statuses;
}

function commerce_avangard_commerce_avangard_unfinished_payments_statuses_info() {
  return array(
    'checkout_payment' => array(
      'success_status' => 'checkout_complete',
      'fail_status' => 'cart',
    ),
  );
}

/**
 * Payment method callback: checkout form.
 */
function commerce_avangard_submit_form($payment_method, $pane_values, $checkout_pane, $order) {
  $form = array();

  $text = theme('image', array(
    'path' => drupal_get_path('module', 'commerce_avangard') . '/css/payment.png',
    'alt' => t('VISA / MasterCard / MaestroCard'),
    'title' => t('VISA / MasterCard / MaestroCard'),
    'attributes' => array('class' => 'cards'),
  ));
  $text .= '<div class="acquiring-desc">' . t('Pay via VISA / MasterCard / MaestroCard') . '</div>';
  $form['avangard_information'] = array('#markup' => $text);

  return $form;
}

/**
 * Payment method callback: checkout form submission.
 */
function commerce_avangard_submit_form_submit($payment_method, $pane_form, $pane_values, &$order, $charge) {
  if (!isset($payment_method['settings']['merchant_id']) && !isset($payment_method['settings']['hash_password'])) {
    watchdog('commerce_avangard', '%method : Merchant id and hash password have not been set in the payment settings. Cannot proceed with transaction', WATCHDOG_ERROR);
    drupal_set_message(t('The Avangard gateway has not been correctly configured - see watchdog for details. Cannot proceed with payment'), 'error');

    return FALSE;
  }
  if (isset($pane_values['mode']) && $pane_values['mode'] == 'terminal_refund' && $charge['amount'] < 0) {
    commerce_avangard_order_refund($order, -$charge['amount']);
  }

  return TRUE;
}

function commerce_avangard_form_commerce_payment_order_transaction_add_form_alter(&$form, &$form_state) {
  $balance = commerce_payment_order_balance($form_state['order']);
  if ($balance['amount'] == 0) {
    $options_keys = array_keys($form['payment_method']['#options']);
    foreach ($options_keys as $key) {
      if (strpos($key, 'commerce_avangard') === 0) {
        unset($form['payment_method']['#options'][$key]);
        break;
      }
    }
  }

  $form['payment_terminal']['amount']['#default_value'] = $balance['amount'] / 100;
  if (isset($form_state['payment_method']) && $form_state['payment_method']['method_id'] == 'commerce_avangard') {
    if ($balance['amount'] > 0) {
      _commerce_avangard_order_transaction_payment_terminal_add_payment_modify($form, $form_state['order']);
    }
    else {
      _commerce_avangard_order_transaction_payment_terminal_refund_modify($form['payment_terminal']);
    }
  }
}

function _commerce_avangard_order_transaction_payment_terminal_refund_modify(&$terminal_form) {
  $terminal_form['#title'] = t('Money refund to client');
  $terminal_form['amount']['#title'] = t('Refund sum');
  $terminal_form['amount']['#default_value'] = -$terminal_form['amount']['#default_value'];
  $terminal_form['#element_validate'][] = 'commerce_avangard_order_transaction_add_form_payment_terminal_validate';

  $terminal_form['payment_details']['mode'] = array(
    '#type' => 'hidden',
    '#value' => 'terminal_refund',
  );
}

function _commerce_avangard_order_transaction_payment_terminal_add_payment_modify(&$form, $order) {
  $form['payment_terminal']['amount']['#disabled'] = TRUE;
  $form['payment_terminal']['currency_code']['#disabled'] = TRUE;
  unset($form['payment_terminal']['payment_details']);
  $form['payment_terminal']['user_url'] = array(
    '#type' => 'textfield',
    '#title' => t('URL for user to follow to add payment'),
    '#value' => url("user/{$order->uid}/orders/{$order->order_id}/avangard_add_payment", array('absolute' => TRUE)),
    '#size' => 80,
  );
  unset($form['actions']['submit']);
}

function commerce_avangard_order_transaction_add_form_payment_terminal_validate($element, &$form_state) {
  if (!empty($form_state['payment_method']) && !empty($form_state['values']['amount'])) {
    form_set_value($element['amount'], -$form_state['values']['amount'], $form_state);
  }
}

/**
 * Payment method callback: payment redirect form.
 */
function commerce_avangard_redirect_form($form, &$form_state, $order, $payment_method) {
  $form_state['order'] = $order;

  $back_url = url("/checkout/{$order->order_id}/avangard_response", array('absolute' => TRUE));
  $form = _commerce_avangard_payment_redirect_form($back_url);

  $form['actions']['back'] = array(
    '#type' => 'link',
    '#title' => t('Back'),
    '#href' => "checkout/{$order->order_id}/payment_back",
    '#attributes' => array(
      'title' => t('Back to order settings page'),
    ),
  );

  return $form;
}

/**
 * Creates form to ask user to redirect them to payment gate.
 *
 * @param string $back_url
 *   Url to redirect user after when he returns from payment gate.
 *
 * @return array
 *   Redirect form.
 */
function _commerce_avangard_payment_redirect_form($back_url) {
  $form['ticket'] = array(
    '#type' => 'hidden',
    '#value' => '',
  );
  $form['back_url'] = array(
    '#type' => 'value',
    '#value' => $back_url,
  );
  $form['actions'] = array(
    '#type' => 'actions',
  );
  $form['actions']['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Pay via Bank Card'),
    '#executes_submit_callback' => FALSE,
    '#ajax' => array(
      'callback' => '_commerce_avangard_payment_redirect_form_ajax_submit',
    ),
  );
  $form['actions']['#attached']['js'][] = drupal_get_path('module', 'commerce_avangard') .
    '/js/payment_redirect_form.js';

  return $form;
}

function _commerce_avangard_payment_redirect_form_ajax_submit($form, $form_state) {
  $ticket = commerce_avangard_register_order_payment_transaction($form_state['order'], $form_state['values']['back_url']);

  $commands = array();
  if ($ticket) {
    $commands[] = array(
      'command' => 'avangard_form_post',
      'ticket' => $ticket,
      'external_action' => COMMERCE_AVANGARD_SERVER_PAY_URL,
    );
  }
  else {
    drupal_set_message(t('Error while registering payment transaction. Please contact our client support.'), 'error');
    $commands[] = ajax_command_remove('div.messages');
    $commands[] = ajax_command_prepend('#commerce-avangard-order-add-payment-form', theme('status_messages'));
  }

  return array(
    '#type' => 'ajax',
    '#commands' => $commands,
  );
}

function commerce_avangard_form_commerce_checkout_form_checkout_alter(&$form, &$form_state, $form_id) {
  $order = &$form_state['order'];
 
  // Workarounding commerce_payment losing messages on redirect.
  if (isset($order->data['commerce_avangard']['last_error_message'])) {
    drupal_set_message($order->data['commerce_avangard']['last_error_message'], 'error');
    unset($order->data['commerce_avangard']['last_error_message']);
    commerce_order_save($order);
  }
}

function commerce_avangard_check_transactions_statuses() {
  _commerce_avangard_check_pending_transactions();
  _commerce_avangard_check_unfinished_payments();
}

/**
 * Checks pending commerce transactions.
 *
 * Iterates over all pending commerce_avangard transactions in orders,
 * checks their state in bank and changes their status correspondingly.
 */
function _commerce_avangard_check_pending_transactions() {
  $transactions = commerce_payment_transaction_load_multiple(array(), array(
    'status' => COMMERCE_PAYMENT_STATUS_PENDING,
    'payment_method' => 'commerce_avangard',
  ));

  watchdog('commerce_avangard', 'Pending transactions found: %num_transactions', array('%num_transactions' => count($transactions)), WATCHDOG_NOTICE);

  foreach ($transactions as $transaction) {
    if (!isset($transaction->data['ticket']) || empty($transaction->data['ticket'])) {
      watchdog('commerce_avangard', 'Corrupt pending transaction %transaction_id found (no ticket) for order %order_id',
              array('%transaction_id' => $transaction->transaction_id, '%order_id' => $transaction->order_id), WATCHDOG_ERROR);
      continue;
    }

    $order = commerce_order_load($transaction->order_id);
    $response = _commerce_avangard_order_get_operation_info($order, $transaction->data['ticket']);
    _commerce_avangard_set_transaction_status($transaction, $response['status_code']);
    $transaction->remote_id = $response['id'];
    $transaction->revision = TRUE;
    $transaction->log = t('Transaction data synced with remote transaction via cron.');
    commerce_payment_transaction_save($transaction);

    watchdog('commerce_avangard', 'Pending transaction %transaction_id updated for order %order_id: %status',
            array(
              '%transaction_id' => $transaction->transaction_id,
              '%order_id' => $order->order_id,
              '%status' => $response['status_code'],
            ), WATCHDOG_NOTICE);
  }
}

/**
 * Iterates over all unpinished orders and check their state in bank.
 *
 * If user didn't returned to checkout page after finishing payment on bank's
 * gate page we don't have transaction created for his payment so we need to
 * check if the order is registered in bank's API and if it is then we can check
 * its' transaction state.
 */
function _commerce_avangard_check_unfinished_payments() {
  $unfinished_statuses = commerce_avangard_unfinished_payments_statuses();
  $hours_to_check = variable_get_value('commerce_avangard_payment_process_timeout');

  // We don't want really old orders to be processed here so check only last
  // few hours as older orders should be already processed or became irrelevant.
  $timestamp = strtotime("-{$hours_to_check} hours");
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_order')
      ->propertyCondition('status', array_keys($unfinished_statuses))
      ->propertyCondition('changed', $timestamp, '>=');
  $orders = $query->execute();

  if (empty($orders) || !isset($orders['commerce_order']) || empty($orders['commerce_order'])) {
    return;
  }

  watchdog('commerce_avangard', 'Total orders with unfinished checkout process found: %num_orders',
          array('%num_orders' => count($orders['commerce_order'])), WATCHDOG_NOTICE);

  foreach (array_keys($orders['commerce_order']) as $order_id) {
    $order = commerce_order_load($order_id);
    
    // Since we could have dozens of orders to check here and each order takes
    // up to seconds to inquire in bank, we double check here that order status
    // hasn't been changed externally.
    if (!isset($unfinished_statuses[$order->status])) {
      watchdog('commerce_avangard', 'Order status changed externally to non-unfinished befor processing so skipping it: %order_id became "%status"',
              array('%order_id' => $order_id, '%status' => $order->status), WATCHDOG_NOTICE);
      continue;
    }

    if (!_commerce_avangard_check_order_payment_method($order)) {
      watchdog('commerce_avangard', 'Non Avangard payment method so skipping this order: %order_id',
              array('%order_id' => $order_id), WATCHDOG_INFO);
      continue;
    }
    
    $response = _commerce_avangard_order_get_operations_list($order);
    if ($response['response_code'] || !isset($response['oper_info']) || empty($response['oper_info'])) {
      if ($response['response_code']) {
        watchdog('commerce_avangard', 'Error occurred while getting bank operations list for %order_id: %status %message',
                array(
                  '%order_id' => $order_id,
                  '%status' => $response['response_code'],
                  '%message' => $response['response_message'],
                ), WATCHDOG_WARNING);
      }
      continue;
    }

    $bank_operations = isset($response['oper_info']['id']) ? array($response['oper_info']) : $response['oper_info'];
    if (empty($bank_operations)) {
      continue;
    }
    
    $num_transactions = _commerce_avangard_update_order_transactions($order, $bank_operations);
    watchdog('commerce_avangard', 'Created %num_transactions transactions for unfinished order %order_id: [%status] %message',
            array(
              '%num_transactions' => $num_transactions,
              '%order_id' => $order_id,
              '%status' => $response['response_code'],
              '%message' => $response['response_message'],
            ), WATCHDOG_NOTICE);

    $last_operation = array_pop($bank_operations);
    _commerce_avangard_unfinished_order_status_change($order, $last_operation, $unfinished_statuses);
  }
}

/**
 * Changing status of given unfinished order according to last bank operation status and $unfinished_statuses
 * information about order status transition.
 *
 * @param object $order
 * @param array $last_operation
 * @param array $unfinished_statuses
 */
function _commerce_avangard_unfinished_order_status_change($order, array $last_operation, array $unfinished_statuses) {
  if (!isset($unfinished_statuses[$order->status])) {
    watchdog('commerce_avangard', 'Order status changed externally to non-unfinished during processing so skipping status change: %order_id became "%status"',
            array('%order_id' => $$order->order_id, '%status' => $order->status), WATCHDOG_NOTICE);
    return FALSE;
  }

  switch ($last_operation['status_code']) {
    case AVANGARD_ORDER_STATUS_LOST:
    case AVANGARD_ORDER_STATUS_REJECTED:
      $next_status = $unfinished_statuses[$order->status]['fail_status'];
      break;

    case AVANGARD_ORDER_STATUS_COMPLETE:
      $next_status = $unfinished_statuses[$order->status]['success_status'];
      break;
    
    default:
      return FALSE;
  }

  commerce_order_status_update($order, $next_status, FALSE, TRUE,
          t('Unfinished payment order status fixed'));
  if ($next_status == 'checkout_complete') {
    commerce_checkout_complete($order);
  }

  return TRUE;
}

/**
 * Check if the order has avangard payment method.
 * 
 * @param object $order
 * 
 * @return bool
 */
function _commerce_avangard_check_order_payment_method($order) {
  if (!isset($order->data['payment_method']) || empty($order->data['payment_method'])) {
    return FALSE;
  }

  // Looks hacky but found in commerce_payment.rules.inc so considered valid.
  list($method_id,) = explode('|', $order->data['payment_method']);

  return $method_id == 'commerce_avangard';
}

/**
 * @param object $order
 * @param array $bank_operations
 *
 * @return int
 *  Number of actually created transactions
 */
function _commerce_avangard_update_order_transactions($order, array $bank_operations) {
  $num_created_transactions = 0;

  foreach ($bank_operations as $operation) {
    // Checking one transaction at a time as they could get created asynchronously
    // Ideally need to lock commerce_payment_transaction table for writing
    // till the end of each iteration to keep it atomic.
    $existing_transactions = commerce_payment_transaction_load_multiple(array(), array(
      'order_id' => $order->order_id,
      'payment_method' => 'commerce_avangard',
      'remote_id' => $operation['id'],
    ));
    if (!empty($existing_transactions)) {
      // As this transaction already exists it would be processed by other methods.
      continue;
    }

    // We don't want to create any pending transactions as they don't influence.
    // order status.
    if ($operation['status_code'] != AVANGARD_ORDER_STATUS_PENDING && $operation['amount'] != 0) {
      $num_created_transactions++;
      commerce_avangard_create_transaction($order, $operation['status_code'], COMMERCE_CREDIT_AUTH_CAPTURE, $operation['amount'], $operation['id'], array(
        'ticket' => $operation['ticket'],
        'remote_time' => strtotime($operation['status_date']),
      ));
    }
  }

  return $num_created_transactions;
}

/**
 * @param object $order
 *
 * @return string
 */
function _commerce_avangard_get_checkout_payment_back_url($order) {
  return "/checkout/{$order->order_id}/payment/back/{$order->data['payment_redirect_key']}";
}

/**
 * @param object $order
 * @param string $back_url
 *
 * @return string order ticket
 */
function commerce_avangard_register_order_payment_transaction($order, $back_url) {
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

  $address = $order_wrapper->commerce_customer_shipping->commerce_customer_address->locality->value() . ". " . $order_wrapper->commerce_customer_shipping->commerce_customer_address->thoroughfare->value();
  $balance = commerce_payment_order_balance($order);
  $response = _commerce_avangard_call_order_method(METHOD_REGISTER_ORDER, 'new_order', $order, array(
    'amount' => $balance['amount'],
    'order_number' => $order->order_id,
    'client_name' => $order_wrapper->commerce_customer_shipping->commerce_customer_address->name_line->value(),
    'client_phone' => $order_wrapper->commerce_customer_shipping->field_customer_phone->value(),
    'client_address' => $address,
    'client_email' => $order->mail,
    'order_description' => 'site payment',
    'language' => 'RU',
    'back_url' => $back_url,
  ));

  if ($response['response_code']) {
    return '';
  }

  $order->data['commerce_avangard']['tickets_map'][$response['ok_code']] = $response['ticket'];
  $order->data['commerce_avangard']['ok_codes'][] = $response['ok_code'];
  $order->data['commerce_avangard']['failure_codes'][] = $response['failure_code'];
  
  // Store order currency and later rely on it when creating transactions.
  // Suppose that order currency not to be changed later.
  $order->data['commerce_avangard']['currency_code'] = $balance['currency_code'];
  
  commerce_order_save($order);

  return $response['ticket'];
}

/**
 * @param object $order
 * @param int $refund_amount
 */
function commerce_avangard_order_refund($order, $refund_amount) {
  $transaction_balances = _commerce_avangard_get_order_transactions_balances($order);
  $total_transaction_balance = array_reduce($transaction_balances, function ($balance, $transaction_balance) {
    return $balance + $transaction_balance['balance'];
  }, 0);

  if ($total_transaction_balance <= $refund_amount) {
    drupal_set_message(t('Transactions balance is not big enough to refund this amount.'), 'error');
    return;
  }

  $remaining_amount = $refund_amount;
  foreach ($transaction_balances as $transaction_balance) {
    $amount = $remaining_amount >= $transaction_balance['balance'] ? $transaction_balance['balance'] : $remaining_amount;
    if (isset($transaction_balance['transaction']) && commerce_avangard_transaction_refund($order, $transaction_balance['transaction'], $amount)) {
      $remaining_amount -= $amount;
    }
    if ($remaining_amount == 0) {
      break;
    }
  }

  drupal_set_message(t('Total %amount refunded.', array('%amount' => $refund_amount - $remaining_amount)));
}

/**
 * @param object $order
 */
function commerce_avangard_order_full_refund($order) {
  $transaction_balances = _commerce_avangard_get_order_transactions_balances($order);

  foreach ($transaction_balances as $transaction_balance) {
    if ($transaction_balance['balance'] > 0 && isset($transaction_balance['transaction'])) {
      commerce_avangard_transaction_refund($order, $transaction_balance['transaction'], $transaction_balance['balance']);
    }
  }
}

/**
 * @param object $order
 * @param int $transaction_remote_id
 *
 * @return int
 */
function _commerce_avangard_get_order_transactions_balances($order, $transaction_remote_id = 0) {
  $conditions = array(
    'order_id' => $order->order_id,
    'payment_method' => 'commerce_avangard',
  );
  if ($transaction_remote_id) {
    $conditions['remote_id'] = $transaction_remote_id;
  }
  $transactions = commerce_payment_transaction_load_multiple(array(), $conditions);

  $transaction_balances = array();
  foreach ($transactions as $transaction) {
    if (empty($transaction->remote_id)) {
      continue;
    }
    if (!isset($transaction_balances[$transaction->remote_id])) {
      $transaction_balances[$transaction->remote_id] = array(
        'balance' => 0,
      );
    }
    if ($transaction->amount > 0 && isset($transaction->data['ticket'])) {
      $transaction_balances[$transaction->remote_id]['transaction'] = $transaction;
    }
    $transaction_balances[$transaction->remote_id]['balance'] += $transaction->amount;
  }

  return $transaction_balances;
}

/**
 * @param object $order
 * @param string $ticket
 * @param bool $save_order
 *
 * @return array
 */
function _commerce_avangard_order_get_operation_info($order, $ticket, $save_order = TRUE) {
  $response = _commerce_avangard_call_order_method(METHOD_GET_ORDER_INFO, 'get_order_info', $order, array(
    'ticket' => $ticket,
  ));

  if ($save_order) {
    commerce_order_save($order);
  }

  return $response;
}

/**
 * @param object $order
 *
 * @return array
 */
function _commerce_avangard_order_get_operations_list($order) {
  $response = _commerce_avangard_call_order_method(METHOD_GET_OPERS_LIST, 'get_opers_list', $order, array(
    'order_number' => $order->order_id,
  ));

  commerce_order_save($order);

  return $response;
}

/**
 * @param string $date
 *
 * @return array
 */
function _commerce_avangard_order_get_date_operations_list($date) {
  $response = _commerce_avangard_call_method(METHOD_GET_OPERS_BY_DATE, 'get_opers_by_date', array(
    'date' => $date,
  ));

  return $response;
}

/**
 * @param string $url_suffix
 * @param string $method_name
 * @param object $order
 * @param array $parameters
 *
 * @return array
 */
function _commerce_avangard_call_order_method($url_suffix, $method_name, &$order, array $parameters) {
  $response = _commerce_avangard_call_method($url_suffix, $method_name, $parameters);

  if (variable_get('commerce_avangard_log_api_requests')) {
    if (!isset($order->data['commerce_avangard']['log'])) {
      $order->data['commerce_avangard']['log'] = array();
    }
    $order->data['commerce_avangard']['log'][] = array(
      'id' => isset($response['id']) ? $response['id'] : '',
      'method' => $method_name,
      'response_code' => $response['response_code'],
      'response_message' => $response['response_message'],
      'timestamp' => time(),
    );
  }

  if ($response['response_code']) {
    watchdog('commerce_avangard', '"%payment_method" payment method failed: %message', array(
      '%payment_method' => $method_name,
      '%message' => $response['response_message'],
    ), WATCHDOG_WARNING);
  }

  watchdog('commerce_avangard', "method data: server url: %server_url<br/> data: %post<br/> response: %response", array(
    '%server_url' => $url_suffix,
    '%post' => htmlentities(print_r($parameters, TRUE)),
    '%response' => htmlentities(print_r($response, TRUE)),
  ), WATCHDOG_INFO);

  return $response;
}

/**
 * @param string $url_suffix
 * @param string $method_name
 * @param array $parameters
 *
 * @return array
 */
function _commerce_avangard_call_method($url_suffix, $method_name, array $parameters) {
  $parameters['shop_id'] = variable_get('commerce_avangard_merchant_id');
  $parameters['shop_passwd'] = variable_get('commerce_avangard_hash_password');
  $server_timeout = variable_get_value('commerce_avangard_server_timeout');

  $sender = new CommerceAvangardRemoteRequestSender(COMMERCE_AVANGARD_SERVER_METHODS_URL, $server_timeout);
  return $sender->callMethod($url_suffix, $method_name, $parameters);
}

/**
 * @param object $order
 * @param string $status_code
 * @param string $remote_status
 * @param int $amount
 * @param string $remote_id
 * @param array $data
 *
 * @return int
 */
function commerce_avangard_create_transaction(&$order, $status_code, $remote_status, $amount, 
        $remote_id = '', array $data = array()) {
  $transaction = commerce_payment_transaction_new('commerce_avangard', $order->order_id);
  $transaction->instance_id = $order->data['payment_method'];
  $transaction->amount = $amount;
  $transaction->remote_id = $remote_id;
  $transaction->currency_code = $order->data['commerce_avangard']['currency_code'];
  $transaction->remote_status = $remote_status;
  $transaction->created = REQUEST_TIME;
  $transaction->data = $data;

  _commerce_avangard_set_transaction_status($transaction, $status_code);

  return commerce_payment_transaction_save($transaction);
}

/**
 * @param object $transaction
 * @param int $status_code
 */
function _commerce_avangard_set_transaction_status(&$transaction, $status_code) {
  switch ($status_code) {
    case AVANGARD_ORDER_STATUS_PENDING:
      $transaction->status = COMMERCE_PAYMENT_STATUS_PENDING;
      $transaction->message = t('Payment is pending.');
      break;

    case AVANGARD_ORDER_STATUS_COMPLETE:
      $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
      $transaction->message = t('Payment is complete.');
      break;

    case AVANGARD_ORDER_STATUS_LOST:
    case AVANGARD_ORDER_STATUS_REJECTED:
      $transaction->status = COMMERCE_PAYMENT_STATUS_FAILURE;
      $transaction->message = t('Payment has failed.');
      break;

    case AVANGARD_ORDER_STATUS_REFUNDED:
    case AVANGARD_ORDER_STATUS_PARTLY_REFUNDED:
      $transaction->status = COMMERCE_PAYMENT_STATUS_SUCCESS;
      $transaction->message = t('Payment has been refunded.');
      break;
  }
}

/**
 * Creates transaction assuming that the whole order balance should be debited.
 * 
 * (This is the only option available to user when paying order in full or
 * making additional payment). 
 *
 * @param object $order
 * @param string $result_code
 *
 * @return SAVED_NEW on success, AVANGARD_SKIP_TRANSACTION when there's no need to create transaction
 *   when failed.
 */
function _commerce_avangard_create_debit_transaction(&$order, $result_code) {
  $ticket = $order->data['commerce_avangard']['tickets_map'][$result_code];
  $order->data['commerce_avangard']['used_tickets'][$ticket] = $result_code;
  unset($order->data['commerce_avangard']['tickets_map'][$result_code]);

  $balance = commerce_payment_order_balance($order);
  if (empty($balance) || !isset($balance['amount']) || empty($balance['amount'])) {
    // This could happen if user successfully paid but returned to the site
    // after this transaction was processed by cron.
    watchdog('commerce_avangard', 'Zero balance when trying to save transaction for %order_id (ticket %ticket).',
            array('%order_id' => $order->order_id, '%ticket' => $ticket), WATCHDOG_INFO);
    return AVANGARD_SKIP_TRANSACTION;
  }

  $tickets = _commerce_avangard_get_order_transactions_tickets($order->order_id);
  if (in_array($ticket, $tickets)) {
    // Avoid creating duplicate of remote transaction
    watchdog('commerce_avangard', 'Trying to create transaction with already used ticket for %order_id (ticket %ticket).',
            array('%order_id' => $order->order_id, '%ticket' => $ticket), WATCHDOG_INFO);
    return AVANGARD_SKIP_TRANSACTION;
  }
  
  return commerce_avangard_create_transaction($order, AVANGARD_ORDER_STATUS_PENDING, COMMERCE_CREDIT_AUTH_CAPTURE, $balance['amount'], '', array(
    'ticket' => $ticket,
  ));
}

/**
 * @param int $order_id
 *
 * @return array
 */
function _commerce_avangard_get_order_transactions_tickets($order_id) {
  $transactions = commerce_payment_transaction_load_multiple(array(), array(
    'order_id' => $order_id,
    'payment_method' => 'commerce_avangard',
  ));
  $existing_tickets = array_map(function ($transaction) {
    return isset($transaction->data['ticket']) ? $transaction->data['ticket'] : '';
  }, $transactions);

  return array_filter($existing_tickets);
}

/**
 * @param object $order
 * @param object $transaction
 * @param int $refund_amount
 *
 * @return bool
 */
function commerce_avangard_transaction_refund($order, $transaction, $refund_amount) {
  if (!isset($transaction->data['ticket']) || empty($transaction->data['ticket'])) {
    drupal_set_message(t("Transaction ticket not found. Unable to refund."), 'error');
    return FALSE;
  }

  $response = _commerce_avangard_call_order_method(METHOD_ORDER_REFUND, 'reverse_order', $order, array(
    'ticket' => $transaction->data['ticket'],
    'amount' => $refund_amount,
  ));
  if ($response['response_code'] == 0) {
    commerce_avangard_create_transaction($order, AVANGARD_ORDER_STATUS_COMPLETE, COMMERCE_CREDIT_CREDIT, -$refund_amount, $response['id']);
    commerce_order_save($order);

    return TRUE;
  }
  else {
    drupal_set_message($response['response_message'], 'error');

    return FALSE;
  }
}

/**
 * Implements hook_views_api().
 */
function commerce_avangard_views_api() {
  return array(
    'api' => 3.0,
    'path' => module_get_path('commerce_avangard') . '/views',
  );
}
