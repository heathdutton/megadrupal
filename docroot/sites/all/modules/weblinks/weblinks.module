<?php

/**
 * @file
 * Enable submission and display of categorized web links.
 * Drupal 7 Version
 */

// Include always, CCK is now in core.
module_load_include('inc', 'weblinks', 'weblinks.cck');

/**
 * Implements hook_help().
 */
function weblinks_help($path, $args) {
  switch ($path) {
    case 'admin/modules#description':
    case 'admin/help#weblinks':
      return '<p>' . t('Enables the submission and display of categorized links to other web sites.') . '</p>';

    case 'node/%':
      $node = node_load($args[1]);
      if ($node->type != 'weblinks') {
        return NULL;
      }
      // Fall through to get css.

    case 'weblinks/%':
    case 'weblinks':
      drupal_add_css(drupal_get_path('module', 'weblinks') . '/weblinks.css');
  }
}

/**
 * Implements hook_permission().
 */
function weblinks_permission() {
  return module_invoke_all('weblinks_permission');
}

/**
 * Implements hook_weblinks_permission().
 */
function weblinks_weblinks_permission() {
  return array(
    'access weblinks' => array(
      'title' => t('Access Web Links'),
      'description' => t('Access the main Web Links page, group pages, author pages and blocks.'),
    ),
    'view weblinks click count' => array(
      'title' => t('View Web Links click count'),
      'description' => t('Display the number of times the link has been clicked and the date and time of the last click.'),
    ),
    'view my weblinks' => array(
      'title' => t('View my Web Links'),
      'description' => t("Provides a tab on the user's account page showing the Web Links they have added."),
    ),
    'edit group weblinks' => array(
      'title' => t('Maintain Web Links groups'),
      'description' => t('Create Web Links groups, rename, change description and alter display settings.')
        . ' ' . t('Roles with this permission also need "Access Web Links" permission.'),
    ),
    'administer weblinks' => array(
      'title' => t('Administer Web Links'),
      'description' => t('Full control over Web Links settings for the main module and all sub-modules.')
        . ' ' . t('Roles with this permission also need "Access Web Links" permission.'),
    ),
  );
}

/**
 * Implements hook_node_info().
 */
function weblinks_node_info() {
  return array(
    'weblinks' => array(
      'name' => t('Web Links'),
      'description' => t('Web links are pointers to other sites or pages on the Internet.'),
      'has_title' => TRUE,
      'title_label' => t('Link Name'),
      'has_body' => TRUE,
      'body_label' => t('Link Description'),
      'base' => 'weblinks',
    )
  );
}

/**
 * Implements hook_init().
 */
function weblinks_init() {
  global $base_path;
  // The menu title is not correct if the menu item has been moved to
  // a menu other than Navigation. See http://drupal.org/node/184955.
  if (arg(0) == 'weblinks') {
    $active_trail = menu_set_active_trail();
    foreach ($active_trail as $key => $item) {
      if (isset($item['link_path'])) {
        if ($item['link_path'] == 'weblinks') {
          $active_trail[$key]['title'] = _weblinks_get_menu_title();
        }
      }
    }
    menu_set_active_trail($active_trail);
  }
}

/**
 * Get the correct menu title.
 * This is a helper function for hook_init and hook_view.
 */
function _weblinks_get_menu_title() {
  return db_query("SELECT link_title FROM {menu_links} WHERE link_path = 'weblinks'")->fetchField();
}

/**
 * Retrieve ids of term children.
 *
 * @param $tid
 *   The term's ID.
 * @param $tids
 *   An array where ids of term children will be added
 */
function term_get_children_ids($tid) {
  $children = taxonomy_get_children($tid);
  $tids = array();

  if (!empty($children)) {
    foreach ($children as $child) {
      $tids[] = $child->tid;
      $tids = array_merge($tids, term_get_children_ids($child->tid));
    }
  }

  return $tids;
}

/**
 * Get table and field information for the vocabulary used in weblinks, which
 * may not be the default 'taxonomy_weblinks' field.
 *
 * @return array
 *   Array giving the taxonomy table name, taxonomy tid field name and weblinks
 *   field name for the vocabulary used to group weblinks. Also return the field
 *   name and vocabulary name of all taxonomies attached to our content type.
 */
function _weblinks_vocabulary_field_info() {
  // Define default to be the standard weblinks vocabulary, so that in the worst
  // case, if anything fails below, we fall back to no worse than the previously
  // hard-coded table and column name.
  // @see http://www.drupal.org/node/2468615
  $vocab_info = array(
    'table_name' => 'field_data_taxonomy_weblinks',
    'tid' => 'taxonomy_weblinks_tid',
    'field_name' => 'taxonomy_weblinks',
    'vocab_machine_name' => 'weblinks',
  );
  if ($vocid = _weblinks_get_vocid()) {
    // Get the vocabulary used for weblinks and the fields in the content type.
    $weblinks_vocabulary = taxonomy_vocabulary_load($vocid);
    $weblinks_fields = field_read_fields(array('bundle' => 'weblinks'));

    // Locate the field which is used for grouping weblinks by looking through
    // all the fields that are taxonomy references, and taking the one where the
    // 'allowed_values' vocabulary matches the weblinks navigation vocabulary.
    foreach ($weblinks_fields as $name => $field_info) {
      if ($field_info['type'] == 'taxonomy_term_reference') {
        $vocab_machine_name = $field_info['settings']['allowed_values']['0']['vocabulary'];
        $vocab_info['all_vocab_fields'][$vocab_machine_name] = array(
          'field_name' => $field_info['field_name'],
          'vocab_machine_name' => $vocab_machine_name,
        );
        if ($vocab_machine_name == $weblinks_vocabulary->machine_name) {
          $vocab_info['field_name'] = $name;
          $vocab_info['vocab_machine_name'] = $vocab_machine_name;
          if (isset($field_info['storage']['details'])) {
            // FIELD_LOAD_CURRENT has the name of the table and the tid field.
            $flc = $field_info['storage']['details']['sql']['FIELD_LOAD_CURRENT'];
            $keys = array_keys($flc);
            $vocab_info['table_name'] = $keys['0'];
            $vocab_info['tid'] = $flc[$keys['0']]['tid'];
          }
        }
      }
    }
  }
  return $vocab_info;
}

/**
 * Retrieve taxonomy node count by Term ID.
 *
 * @param int $tid
 *   Term ID
 * @param bool $child_count
 *   TRUE - Also count all nodes in child terms (if they exists) - Default
 *   FALSE - Count only nodes related to Term ID
 *
 * @return int $count
 *   The number of weblinks tagged with that term.
 */
function weblinks_term_node_count($tid, $child_count = TRUE) {
  $tids = array($tid);
  if ($child_count) {
    $tids = array_merge($tids, term_get_children_ids($tid));
  }

  global $language;
  $langs = array($language->language);
  $langs[] = 'und';

  // Get the table and field name of the vocabulary being used for weblinks.
  $vocab_info = _weblinks_vocabulary_field_info();

  $query = db_select($vocab_info['table_name'], 't');
  $query->condition($vocab_info['tid'], $tids, 'IN');
  $query->join('node', 'n', 't.entity_id = n.nid');
  $query->condition('n.status', 1);
  $query->condition('n.type', 'weblinks');
  // Use 'language' from the node table not field data table.
  $query->condition('n.language', $langs, 'IN');

  $count = $query->countQuery()->execute()->fetchField();
  return $count;
}

/**
 * Display a select box of taxonomy terms.
 * This is a helper function.
 */
function _d7_taxonomy_term_select($title, $name, $value, $vocabulary_id, $description, $multiple, $blank, $exclude = array()) {
  $tree = taxonomy_get_tree($vocabulary_id);
  $options = array();

  if ($blank) {
    $options[''] = $blank;
  }
  if ($tree) {
    foreach ($tree as $term) {
      if (!in_array($term->tid, $exclude)) {
        $choice = new stdClass();
        $choice->option = array($term->tid => str_repeat('-', $term->depth) . $term->name);
        $options[] = $choice;
      }
    }
  }

  return array(
    '#type' => 'select',
    '#title' => $title,
    '#default_value' => $value,
    '#options' => $options,
    '#description' => $description,
    '#multiple' => $multiple,
    '#size' => $multiple ? min(9, count($options)) : 0,
    '#weight' => -5,
    '#theme' => 'select',
  );
}

/**
 * Display a select box of taxonomy terms.
 * This is a helper function for hook_form. See http://drupal.org/node/1204750.
 * Like D6 taxonomy_form.
 */
function d7_taxonomy_form($vid, $value = 0, $help = NULL, $name = 'taxonomy') {
  $vocabulary = taxonomy_vocabulary_load($vid);
  $multiple = FALSE;
  $required = FALSE;
  if (!$multiple) {
    $blank = ($required) ? t('- Please choose -') : t('- None selected -');
  }
  else {
    $blank = ($required) ? 0 : t('- None -');
  }
  return _d7_taxonomy_term_select(check_plain($vocabulary->name), $name, $value, $vid, "", intval($multiple), $blank);
}

/**
 * Implements hook_form().
 *
 * Validation of the url, if desired, is performed by the weblinks_checker module.
 */
function weblinks_form(&$node) {
  $type = node_type_get_type($node);

  if ($type->has_title) {
    $form['title'] = array(
      '#type' => 'textfield',
      '#title' => check_plain($type->title_label),
      '#required' => TRUE,
      '#maxlength' => 255,
      '#default_value' => $node->title,
      '#weight' => 2,
    );
  }

  $form['url'] = array(
    '#type' => 'textarea',
    '#rows' => 2,
    '#title' => t('URL'),
    '#description' => t('Enter a single web address (URL), including the "http://".'),
    '#default_value' => isset($node->url) ? $node->url : variable_get('weblinks_url_stub', 'http://'),
    '#required' => TRUE,
    '#weight' => 1,
  );

  // Stick our basic validation in before the node module.
  if (isset($form['#validate'])) {
    array_unshift($form['#validate'], 'weblinks_form_validate');
  }
  else {
    $form['#validate'] = array('weblinks_form_validate');
  }
  // Add a submit handler. This will create the array if #submit is not set yet.
  $form['#submit'][] = 'weblinks_form_submit';

  return $form;
}

/**
 * Implements hook_form_BASE_FORM_ID_alter() for node_form().
 */
function weblinks_form_node_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'weblinks_node_form') {
    if (isset($form['revision_information'])) {
      // When editing a weblinks node and creating a new revision, give the
      // option to save or reset the click count statistics.
      $form['revision_information']['revision_save_click_data'] = array(
        '#type' => 'checkbox',
        '#title' => t('Save Web Links click data'),
        '#description' => variable_get('weblinks_redirect', FALSE)
          ? t('Web Links click count and last click data can be saved or erased when creating a new revision.')
          : t('Web Links click tracking is not enabled, but any previously stored data will be retained. Enable tracking via <a href="@settings">Link Settings</a>', array('@settings' => url('admin/config/content/weblinks'))),
        // Disable if click tracking is not turned on.
        '#disabled' => !(variable_get('weblinks_redirect', FALSE)),
        // Default to save the data, even if the checkbox is disabled.
        '#default_value' => 1,
        // Only show this checkbox if the 'revision' checkbox is ticked.
        '#states' => array(
          'visible' => array(
            ':input[name="revision"]' => array('checked' => TRUE),
          ),
        ),
      );
      // Keep the log textarea as the lowest field.
      $form['revision_information']['log']['#weight'] = 1;
    }
  }
}

/**
 * Simple validation for weblinks_form().
 */
function weblinks_form_validate($form, &$form_state) {
  if ($form_state['values']['url'] == variable_get('weblinks_url_stub', 'http://')) {
    form_set_error('url', t('You must enter a complete URL.'));
  }
}

/**
 * Submit handler for weblinks node form.
 */
function weblinks_form_submit($form, &$form_state) {
  if ($form_state['values']['revision'] && !$form_state['values']['revision_save_click_data']) {
    // When resetting the click data add the current values to the revision log.
    $form_state['values']['log'] .= "\n" . t('Resetting click data. Current click count @click_count, last click @last_click.', array(
      '@click_count' => $form['#node']->click_count,
      '@last_click' => $form['#node']->last_click,
    ));
  }
}

/**
 * Implements hook_node_access().
 *
 * Requires to check the node type for own content type.
 *
 */
function weblinks_node_access($node, $op, $account) {
  $type = is_string($node) ? $node : $node->type;

  // Ignore non-Web Links node.
  if ($type !== 'weblinks') {
    return NODE_ACCESS_IGNORE;
  }

  // Allow a user with 'administer weblinks' to edit or delete any link.
  if ($op == 'update' || $op == 'delete') {
    if (user_access('administer weblinks', $account)) {
      return  NODE_ACCESS_ALLOW;
    }
  }

  return NODE_ACCESS_IGNORE;
}

/**
 * Implements hook_entity_info_alter().
 *
 * Replaces the taxonomy term path with one for Weblinks.
 */
function weblinks_entity_info_alter(&$info) {
  // Do not call _weblinks_get_vocid() here as this leads to nested calls to
  // hook_entity_info_alter(). Instead use the direct variable_get but also
  // protect it by verifying that the Taxonomy module is available.
  if (($vid = variable_get('weblinks_nav_vocabulary', 0)) && module_exists('taxonomy')) {
    // Within hook_entity_info(), we can't invoke entity_load() as that would
    // cause infinite recursion, so we call taxonomy_vocabulary_get_names()
    // instead of taxonomy_vocabulary_load(). All we need is the machine name
    // of $vid, so retrieving and iterating all the vocabulary names is somewhat
    // inefficient, but entity info is cached across page requests, and an
    // iteration of all vocabularies once per cache clearing isn't a big deal,
    // and is done as part of taxonomy_entity_info() anyway.
    foreach (taxonomy_vocabulary_get_names() as $machine_name => $vocabulary) {
      // Take over URI construction for taxonomy terms that are weblinks.
      if ($vid == $vocabulary->vid) {
        $info['taxonomy_term']['bundles'][$machine_name]['uri callback'] = 'weblinks_uri';
      }
    }
  }
}

/**
 * URI callback for Web Links terms.
 *
 * @see node_uri()
 */
function weblinks_uri($term) {
  $uri['path'] = 'weblinks/' . $term->tid;
  return $uri;
}

/**
 * Checks whether a node can be used as a weblink, based on its content type.
 *
 * @param $node
 *   A node object.
 *
 * @return
 *   Boolean indicating if the node can be assigned to a weblink.
 */
function _weblinks_node_check_node_type($node) {
  // Fetch information about the weblinks field.
  $field = field_info_instance('node', 'taxonomy_weblinks', $node->type);

  return is_array($field) || ($node->type == 'weblinks');
}

/**
 * Return the vocabulary id for weblinks navigation.
 *
 * This function should be used in preference to just calling
 * variable_get('weblinks_nav_vocabulary') so that extra checks can be made,
 * for example ensuring that the taxonomy module has not been disabled.
 *
 * @param none.
 *
 * @return int vocid
 *   Integer specifying the vocabulary in use for Weblinks.
 */
function _weblinks_get_vocid() {
  if (!module_exists('taxonomy')) {
    // If the Taxonomy module is not available (for whatever reason) we must
    // return 0 as the groupings cannot be used. However we do not delete our
    // vocabulary, as the taxonomy module may be re-enabled later.
    return 0;
  }
  $vocid = variable_get('weblinks_nav_vocabulary', 0);
  if (empty($vocid) && function_exists('taxonomy_vocabulary_load')) {
    // Check to see if a weblinks vocabulary exists.
    $vocid = db_query("SELECT vid FROM {taxonomy_vocabulary} WHERE module='weblinks'")->fetchField();
    if ($vocid) {
      // We found a vocabulary.
      $vocabulary = taxonomy_vocabulary_load($vocid);
    }
    else {
      // Didn't find one, so create vocabulary from scratch.
      $vocabulary = new stdClass();
      $vocabulary->module = 'weblinks';
    }
    $vocabulary->name = t('Web Links');
    $vocabulary->machine_name = 'weblinks';
    $vocabulary->description = t('Web Links navigation vocabulary');
    $vocabulary->hierarchy = 2; // Hierarchy type. 2 = allow multiple parents.
    $status = taxonomy_vocabulary_save($vocabulary);
    $vocid = $vocabulary->vid;
    variable_set('weblinks_nav_vocabulary', $vocid);

    field_associate_fields('weblinks');

    // Create the 'taxonomy_weblinks' field if it doesn't already exist.
    if (!field_info_field('taxonomy_weblinks')) {
      $field = array(
        'field_name' => 'taxonomy_weblinks',
        'type' => 'taxonomy_term_reference',
        'settings' => array(
          'allowed_values' => array(
            array(
              'vocabulary' => $vocabulary->machine_name,
              'parent' => 0,
            ),
          ),
        ),
      );
      field_create_field($field);

      // Create the instance on the bundle.
      $instance = array(
        'field_name' => 'taxonomy_weblinks',
        'entity_type' => 'node',
        'label' => $vocabulary->name,
        'bundle' => 'weblinks',
        'required' => FALSE,
        'widget' => array(
          'type' => 'options_select',
        ),
        'display' => array(
          'default' => array(
            'type' => 'taxonomy_term_reference_link',
           'weight' => 10,
          ),
          'teaser' => array(
            'type' => 'taxonomy_term_reference_link',
           'weight' => 10,
          ),
        ),
      );
      field_create_instance($instance);
    }
  }
  return $vocid;
}

/**
 * Implements hook_taxonomy_vocabulary_delete().
 *
 * @param obj $vocabulary
 *   The vocabulary object being deleted.
 */
function weblinks_taxonomy_vocabulary_delete($vocabulary) {
  // If the vocabulary being deleted is 'weblinks' then delete our nav variable.
  if ($vocabulary->machine_name == 'weblinks') {
    variable_del('weblinks_nav_vocabulary');
  }
}

/**
 * Implements hook_insert().
 */
function weblinks_insert($node) {
  if (!isset($node->is_converted) || !$node->is_converted) {
    $node->last_click = NULL;
    $node->click_count = 0;
  }
  weblinks_write($node);
}

/**
 * Generic write function.
 */
function weblinks_write($node) {
  $node->url = strip_tags(trim($node->url));
  $node->urlhash = md5($node->url);
  // Use !empty() to cater for when the revision property may not exist.
  if (!empty($node->revision) || $node->is_new) {
    drupal_write_record('weblinks', $node);
  }
  else {
    drupal_write_record('weblinks', $node, array('nid', 'vid'));
  }
  if (variable_get('weblinks_new_redirect', TRUE)) {
    $_REQUEST['destination'] = 'weblinks';
  }
}

/**
 * Implements hook_update().
 */
function weblinks_update($node) {
  // When creating a new revision, reset the click data if required.
  if (!empty($node->revision) && empty($node->revision_save_click_data)) {
    $node->last_click = NULL;
    $node->click_count = 0;
  }
  weblinks_write($node);
}

/**
 * Implements hook_delete().
 */
function weblinks_delete($node) {
  db_delete('weblinks')
    ->condition('nid', $node->nid, '=')
    ->execute();
  $_REQUEST['destination'] = 'weblinks';
}

/**
 * Implements hook_node_revision_delete().
 */
function weblinks_node_revision_delete($node) {
  db_delete('weblinks')->condition('vid', $node->vid)->execute();
}

/**
 * Implements hook_node_update_index().
 */
function weblinks_node_update_index($node) {
  // Adds URL to the search text search.
  $text = '';
  if (isset($node->url)) {
    $text = '<h2>' . $node->url . '</h2>';
    $parts = parse_url($node->url);
    $pieces = explode('.', $parts['host']);
    if (substr($pieces[0], 0, 3) == 'www') {
      unset($pieces[0]);
    }
    $j = count($pieces);
    for ($i = 0; $i < $j; ++$i) {
      $text .= '<h2>' . implode('.', array_slice($pieces, 0, $i + 1)) . '</h2>';
    }
  }
  return $text;
}

/**
 * Implements hook_node_presave().
 */
function weblinks_node_presave($node) {
  // If the node is being created via Devel Generate then provide a random
  // three-letter .com url. This avoids messages during node save and allows the
  // node to be editted later without further problems.
  // @TODO If/when 'url' is converted into a proper D7 field this code can be
  // moved into a separate weblinks.devel_generate.inc file.
  // See https://www.drupal.org/node/2414531 for more details.
  if ($node->type == 'weblinks' && isset($node->devel_generate['node_types']['weblinks'])) {
    $node->url = 'http://www.' . substr(str_shuffle("abcdefghijklmnopqrstuvwxyz"), 0, 3) . '.com';
  }
}

/**
 * Implements hook_load().
 */
function weblinks_load($nodes) {
  // note that $nodes is an array of object references, keyed by nid
  $obj = db_select('weblinks', 'w')
    ->condition('w.nid', array_keys($nodes), 'IN')
    ->fields('w', array('nid', 'urlhash', 'url', 'last_status', 'last_status_info', 'last_checked', 'click_count', 'last_click', 'reciprocal'))
    ->execute();
  // run through each result row and add in the needed attributes
  foreach ($obj as $record) {
    $nodes[$record->nid]->urlhash = $record->urlhash;
    $nodes[$record->nid]->url = $record->url;
    $nodes[$record->nid]->last_status = $record->last_status;
    $nodes[$record->nid]->last_status_info = $record->last_status_info;
    $nodes[$record->nid]->last_checked = $record->last_checked;
    $nodes[$record->nid]->click_count = $record->click_count;
    $nodes[$record->nid]->last_click = $record->last_click;
    $nodes[$record->nid]->reciprocal = $record->reciprocal;
  }
}

/**
 * Implements hook_view().
 *
 * This formats a viewable link node.
 */
function weblinks_view($node, $view_mode) {
  if ($view_mode == 'full' && node_is_page($node)) {
    // Breadcrumb navigation
    $breadcrumb = array();
    $breadcrumb[] = l(t('Home'), '<front>');

    // See the comments in hook_init.
    $breadcrumb[] = l(_weblinks_get_menu_title(), 'weblinks');

    if (!empty($node->taxonomy_weblinks)) {
      $taxonomy_weblinks = reset($node->taxonomy_weblinks); // ### JSS. Is it OK to take the first item. Key is 'und'. Should we search for specific language?
      $parent_links = array();
      foreach ($taxonomy_weblinks as $key => $item) {
        if ($parents = taxonomy_get_parents_all($item['tid'])) {
          $parents = array_reverse($parents);
          foreach ($parents as $p) {
            // @@@ $uri = entity_uri('taxonomy_term', $p)
            // @@@ $link = l($p->name, $uri['path'])
            $parent_links[] = l($p->name, 'weblinks/' . $p->tid);
          }
        }
      }
      $breadcrumb[] = implode(' | ', $parent_links);
    }
    drupal_set_breadcrumb($breadcrumb);
  }
  $node->is_teaser = !node_is_page($node);
  $node->content['body']['#markup'] = theme('weblinks_link', array('node' => $node, 'teaser' => ($view_mode == 'teaser')));
  return $node;
}

/**
 * Implements hook_preprocess_node().
 */
function weblinks_preprocess_node(&$variables) {
  // We only do this for our content and only on the links page.
  if ($variables['type'] == 'weblinks') {
    // Set the node title destination. The variable 'weblinks_title_link' is the
    // setting for whether the node title should link to the node (1, default)
    // or the site (0). The same name 'weblinks_title_link' is also used to hold
    // the intermediate url value of that link. This is created as a property of
    // $node in weblinks_node_view.tpl.php which then becomes available via the
    // $variables[] array here. Finally $node_url is used in node.tpl.php.
    if (arg(0) == 'weblinks') {
      if (variable_get('weblinks_title_link', TRUE)) {
        $variables['node_url'] = url(drupal_get_path_alias('node/' . $variables['nid']));
      }
      else {
        $variables['node_url'] = url($variables['weblinks_title_link']);
      }
    }
    // Sanitise the title. This is required even though it is already done in
    // weblinks_weblinks_preprocess().
    $variables['title'] = filter_xss($variables['node']->title);
  }
}

/**
 * Build template variables.
 */
function template_preprocess_weblinks_link(&$variables) {
  $node = $variables['node'];
  node_object_prepare($node);

  $variables['teaser'] = $node->is_teaser;
  $items = field_get_items('node', $node, 'body');
  // $variables['weblinks_body'] = $items['0']['safe_value'];

  // Call all contribs to add to the variables.
  $variables += module_invoke_all('weblinks_preprocess', $node);
  if (!array_key_exists('link_status', $variables)) {
    $variables['link_status'] = NULL; // Link checker not available, fake its output
  }
}

/**
 * Implements hook_weblinks_preprocess().
 */
function weblinks_weblinks_preprocess($node) {
  global $user;
  // Making these static means we only need to set them the first time we come here.
  static $description, $urlnode, $options, $dest, $comments, $user_link;
  if (!isset($description)) {
    $description = variable_get('weblinks_linkdesc', 'teaser');
    $dest = drupal_get_destination();
    $user_link = variable_get('weblinks_user_links', FALSE);

    $options = array();
    if ($extra_classes = variable_get('weblinks_extra_classes', '')) {
      $options['attributes']['class'] = $extra_classes;
    }

    if (variable_get('weblinks_external', TRUE)) {
      $options['attributes']['target'] = '_blank';
    }

    if (variable_get('weblinks_nofollow', FALSE)) {
      $options['attributes']['rel'] = 'nofollow';
    }
  }
  $variables = array();

  // Link hover text. Note that drupal_attributes will do a check_plain.
  $options['attributes']['title'] = $node->title;

  if (variable_get('weblinks_title_link', TRUE)) {
    // Used if 'show title' is yes and 'link title to node' = 'node'.
    $variables['title'] = l(filter_xss($node->title), 'node/' . $node->nid);
  }
  else {
    // Used if 'show title' is yes and 'link title to node' = 'site'.
    $variables['title'] = filter_xss($node->title);
  }
  // If this is a full-page view (node/xxx), then disregard "description" setting.
  if (!$node->is_teaser) {
    $description = 'body';
  }

  if ($items = field_get_items('node', $node, 'body')) {
    $instance = field_info_instance('node', 'body', $node->type);
    $field_langcode = field_language('node', $node, 'body');
    $sanitize = 1;  // Sanitize link description always
  }
  else {
    // There seems to be no body field?!
    $description = 'none';
  }
  switch ($description) {
    case 'none':
      $variables['weblinks_body'] = NULL;
      break;
    case 'teaser':
      if (!empty($items[0]['summary'])) {
        $variables['weblinks_body'] = $sanitize ? _text_sanitize($instance, $field_langcode, $items[0], 'summary') : $items[0]['summary'];
      }
      else {
        if (isset($instance['display']['teaser']['settings']['trim_length'])) {
          $trim_length = $instance['display']['teaser']['settings']['trim_length'];
        }
        else {
          // Use default value.
          $trim_length = NULL;
        }
        $format = $instance['settings']['text_processing'] ? $items[0]['format'] : NULL;
        $variables['weblinks_body'] = text_summary($items[0]['value'], $format, $trim_length);
      }
      break;
    case 'body':
      $variables['weblinks_body'] = $sanitize ? _text_sanitize($instance, $field_langcode, $items[0], 'value') : $items[0]['value'];
      break;
    default:
      drupal_set_message(t('Unknown value "%description" for $description in weblinks_weblinks_preprocess()', array('%description' => $description)), 'error');
  }
  $variables['link'] = theme('weblinks_node_view', array('node' => $node, 'options' => $options));

  if (user_access('view weblinks click count')) {
    $variables['click_count'] = $node->click_count;
    $last_click = strtotime($node->last_click);
    if ($last_click > 0) {
      $variables['last_click'] = format_date($last_click, 'small');
    }
    else {
      $variables['last_click'] = '';
    }
  }

  return $variables;
}

/**
 * Implements hook_node_view().
 */
function weblinks_node_view($node, $view_mode, $langcode) {
  global $user;
  static $user_link, $edit_any, $delete_any;

  // Make sure it's only our content and on a node page.
  if ($node->type != 'weblinks') {
    return;
  }
  if (arg(0) != 'weblinks') {
    return;  // TBC
  }

  // Check our static variables.
  if (!isset($user_link)) {
    $user_link = variable_get('weblinks_user_links', FALSE);
    $edit_any = user_access('administer weblinks') || user_access('edit any weblinks content');
    $delete_any = user_access('administer weblinks') || user_access('delete any weblinks content');
  }

  $links = array();
  $dest = drupal_get_destination();
  if ($edit_any || (user_access('edit own weblinks content') && $node->uid == $user->uid)) {
    $links['edit'] = array(
      'title' => t('Edit link'),
      'href' => "node/{$node->nid}/edit",
      'query' => $dest,
      'attributes' => array('class' => array('weblinks-ops')),
    );
  }
  if ($delete_any || (user_access('delete own weblinks content') && $node->uid == $user->uid)) {
    $links['delete'] = array(
      'title' => t('Delete link'),
      'href' => "node/{$node->nid}/delete",
      'query' => $dest,
      'attributes' => array('class' => array('weblinks-ops')),
    );
  }
  if (sizeof($links)) {
    $node->content['links']['weblinks'] = array(
      '#theme' => 'links__node',
      '#links' => $links,
      '#attributes' => array('class' => array('links', 'inline')),
    );
  }

  // We don't want the link if we are asking for a specific user.
  // This way we don't see every link on the page saying "xxx's links".
  if ($user_link && $node->uid != $user->uid && !(arg(0) == 'user' && arg(1) == $node->uid))  {
    // Check for correct implementation of theme_username (done by D7 now).
    $name = format_username($node);
    $links['weblinks-user-link'] = array(
      'title' => t("!name's links", array('!name' => $name)),
      'href' => 'weblinks/user/' . $node->uid,
    );
    $node->content['links']['weblinks'] = array(
      '#theme' => 'links__node',
      '#links' => $links,
      '#attributes' => array('class' => array('links', 'inline')),
    );
  }
}

/**
 * Implements hook_menu().
 */
function weblinks_menu() {
  $items = array();
  // Full group listing of all weblinks categories.
  $items['weblinks'] = array(
    'title' => 'Web Links',
    'page callback' => 'weblinks_page',
    'access arguments' => array('access weblinks'),
    'type' => MENU_NORMAL_ITEM,
    ); /* */

  // Main links page.
  $items['weblinks/%weblink_placeholder'] = array(
    'title' => 'Links page',
    'page callback' => 'weblinks_page',
    'page arguments' => array(1),
    'access arguments' => array('access weblinks'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -5,
    ); /* */

  // Add new link.
  $items['weblinks/add'] = array(
    'title' => 'Add a new link',
    'page callback' => 'drupal_goto',
    'page arguments' => array('node/add/weblinks'),
    'access arguments' => array('create weblinks content'),
    'type' => MENU_LOCAL_TASK,
    );

  // Group operations - Add new group.
  $items['weblinks/group/add'] = array(
    'title' => 'Add a group',
    'page callback' => '_weblinks_group_operations',
    'page arguments' => array(2),
    'access callback' => 'weblinks_group_access',
    'type' => MENU_LOCAL_TASK,
    );

  // Group operations - Edit existing group.
  $items['weblinks/group/edit'] = array(
    'title' => 'Edit a group',
    'page callback' => '_weblinks_group_operations',
    'page arguments' => array(2, 3),
    'access callback' => 'weblinks_group_access',
    'type' => MENU_CALLBACK,
    );

  // Admin settings for the site.
  $items['weblinks/settings'] = array(
    'title' => 'Settings',
    'description' => 'Set a variety of options for web link display and categorization.',
    'page callback' => 'drupal_goto',
    'page arguments' => array('admin/config/content/weblinks'),
    'access arguments' => array('administer weblinks'),
    'type' => MENU_LOCAL_TASK,
    );

  // Links redirect.
  $items['weblinks/goto/%'] = array(
    'title' => 'Web Links',
    'page callback' => 'weblinks_goto',
    'page arguments' => array(2),
    'access arguments' => array('access weblinks'),
    'type' => MENU_CALLBACK,
    );

  // User-limited links.
  $items['weblinks/user/%'] = array(
    'title' => 'Web Links',
    'page callback' => '_weblinks_user',
    'page arguments' => array(2),
    'access arguments' => array('access weblinks'),
    'type' => MENU_CALLBACK,
    );

  // User Edit weblinks
  $items['user/%user/weblinks'] = array(
    'title' => 'Web Links',
    'page callback' => 'weblinks_user_page',
    'page arguments' => array(1),
    'file' => 'weblinks.user.inc',
    'access arguments' => array('view my weblinks'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
    );

  // Admin settings for the site.
  $items['admin/config/content/weblinks'] = array(
    'title' => 'Web Links',
    'description' => 'Set a variety of options for web link display and categorization.',
    'page callback' => 'weblinks_settings_page',
    'file' => 'weblinks.admin.inc',
    'access arguments' => array('administer weblinks'),
    'type' => MENU_NORMAL_ITEM,
    );

  $items['admin/config/content/weblinks/general'] = array(
    'title' => 'General',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('weblinks_admin_settings'),
    'file' => 'weblinks.admin.inc',
    'access arguments' => array('administer weblinks'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -1,
    );

  // Tab for Admins to have quick access back to main weblinks page.
  $items['admin/config/content/weblinks/links'] = array(
    'title' => 'Links page',
    'page callback' => 'drupal_goto',
    'page arguments' => array('weblinks'),
    'access arguments' => array('administer weblinks'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,
    );

  return $items;
}

/**
 * Returns NULL or $arg so to remove PHP notices.
 */
function weblink_placeholder_to_arg($arg) {
  return $arg;
}

/**
 * Determine menu access for group adding/editing.
 */
function weblinks_group_access() {
  // Providing we have an active weblinks vocabulary, then any one of the three
  // permissions is enough to allow the user to edit the term/group.
  return _weblinks_get_vocid() && (user_access('administer weblinks') || user_access('edit group weblinks') || user_access('administer taxonomy'));
}

/**
 * Make a dummy term for unclassified links.
 *
 * @param none.
 * @return Pseudo term object.
 */
function _weblinks_unclassed() {
  $noclass = new stdClass();
  $noclass->tid = $noclass->vid = $noclass->depth = 0;
  $noclass->name = variable_get('weblinks_unclassified_title', t('Unclassified'));
  $noclass->description = variable_get('weblinks_unclassified_desc', t('These links have not been assigned a group.'));

  return $noclass;
}

/**
 * Make a dummy term for unpublished links.
 *
 * @param none.
 * @return Pseudo term object.
 */
function _weblinks_unpublished() {
  $noclass = new stdClass();
  $noclass->vid = $noclass->depth = 0;
  $noclass->tid = 'unpublished';
  $noclass->name = variable_get('weblinks_unpublished_title', t('Unpublished'));
  $noclass->description = variable_get('weblinks_unpublished_desc', t('These links are not published and need to be reviewed.'));

  return $noclass;
}

/**
 * Format a group's fieldset.
 *
 * @param $term
 *   the term object being formatted.
 * @param $tree
 *   the entire array of terms (array of objects) - will be used for handling child terms.
 * @return
 *   The formatted HTML string.
 */
function _weblinks_format_group($term, $tree) {
  static $admin;
  if (!isset($admin)) {
    $admin = weblinks_group_access() && arg(0) != 'node';
  }

  $data = $term->desc;

  if ($admin && is_numeric($term->tid) && $term->tid !== 0) {
    $data .= '<div class="more-link">' . l(t('Edit group'), 'weblinks/group/edit/' . $term->tid, array('query' => drupal_get_destination())) . '</div>';
  }

  $data .= _weblinks_links($term);
  foreach ($term->children as $child) {
    $data .= _weblinks_format_group($tree[$child], $tree);
  }
  $fieldset = array(
    '#title' => $term->title . ' (' . $term->node_count . ')',
    '#id' => 'weblinks-fieldset-' . $term->tid,
    '#value' => $data,
    '#attributes' => array('class' => array(
      $term->collapsible ? 'collapsible' : '',
      $term->collapsed ? 'collapsed' : '',
    )),
    '#children' => '',
  );
  $theme_fieldset = theme('fieldset', array('element' => $fieldset));
  $output = '<div class="weblinkCat weblinkCat-depth-' . $term->depth . '">' . $theme_fieldset . "</div>\n";
  return $output;
}

/**
 * Returns tree of existing containers.
 * Replacement for taxonomy_get_tree.
 *
 * @param int $parent
 *   The parent term to restrict the tree to. (optional)
 * @param bool $quick
 *   ### This parameter is not used in the function, but is set to TRUE in
 *   ### weblinks_blocks.module. @TODO Needs fixing.
 * @param bool $ismainlinkspage
 *   TRUE to return all links for the main weblinks page.
 *   FALSE to return only the links in one group.
 *
 * @return array
 *   An array of term objects, keyed by term id $tid.
 */
function weblinks_get_tree($parent = 0, $quick = FALSE, $ismainlinkspage = TRUE) {
  $admin = user_access('administer weblinks');

  $collapsible = variable_get('weblinks_collapsible', TRUE);
  $collapsed = variable_get('weblinks_collapsed', FALSE);
  $empty_text = variable_get('weblinks_empty_text', NULL);
  $skip_empty = empty($empty_text);
  if ($admin) {
    $skip_empty = FALSE;
  }
  $show_desc = variable_get('weblinks_catdesc', TRUE);
  $format = variable_get('weblinks_format', filter_fallback_format());
  $max_depth = $ismainlinkspage ? variable_get('weblinks_maxfrontdepth', 100) : variable_get('weblinks_maxdepth', 100);
  $show_or_hide = $admin ? variable_get('weblinks_admin_override', 'collapse') : 'hide';

  $tree = array();
  $vocid = _weblinks_get_vocid();
  if ($vocid) {
    $tree = taxonomy_get_tree($vocid, $parent);
  }
  else {
    // If the url was /weblinks/x but we no longer have Taxonomy and groupings
    // then avoid problems by ensuring that $parent is 0.
    $parent = 0;
  }

  // Is this a top level request?
  if ($parent) {
    foreach ($tree as $term) {
      // Increase the depth of each existing term by 1, so that we can insert
      // the requested parent at depth 0.
      ++$term->depth;
    }
    // Get the requested term and put it at the front of the tree.
    $parent_term = taxonomy_term_load($parent);
    if (!$parent_term || $parent_term->vid != $vocid) {
      // The numeric $parent id is not a valid group, so give error and exit.
      $backtrace = debug_backtrace();
      drupal_set_message(t('Invalid group requested (%tid) in function %function0, called from %function1.', array(
        '%tid' => $parent,
        '%function0' => $backtrace[0]['function'],
        '%function1' => $backtrace[1]['function'],
      )), 'error');
      return array();
    }
    // Put parent term at top of array and set depth to 0.
    array_unshift($tree, $parent_term);
    $tree[0]->depth = 0;
    // Remove 'parents' as this is not returned by the core taxonomy_term_load()
    // but may be added by other modules hook_taxonomy_term_load()
    unset($tree[0]->parents);
  }
  else {
    // Top level, so do we have unclassified links?
    $unclassed_count = db_query(_weblinks_get_query(0, 'count'))->fetchField();
    if ($admin || $unclassed_count > 0) {
      // Add our dummy unclassified term object to the list.
      $tree[] = _weblinks_unclassed();
    }

    // Do we want a separate unpublished group?
    if (variable_get('weblinks_unpublished_title', t('Unpublished'))) {
      // Do we have unpublished nodes?
      $unpub_count = db_query(_weblinks_get_query('unpublished', 'count'))->fetchField();
      if ($admin && $unpub_count > 0) {
        $tree[] = _weblinks_unpublished();
      }
    }
  }

  $new_tree = array();
  foreach ($tree as $term) {
    $tid = $term->tid;
    // If we are too deep already, or the term should be hidden from the main
    // links page, skip the whole term.
    $show_this_term = variable_get('weblinks_page_' . $tid, TRUE);
    if ($show_or_hide == 'hide' && ($term->depth >= $max_depth || ($ismainlinkspage && !$show_this_term))) {
      continue;
    }
    if ($tid === 0) {
      $term->node_count = $unclassed_count;
    }
    elseif ($tid == 'unpublished') {
      $term->node_count = $unpub_count;
    }
    else {
      $term->node_count = weblinks_term_node_count($tid, TRUE);
    }
    // Skip if we are suppressing empty groups and there are no links here.
    if ($skip_empty && $term->node_count == 0) {
      continue;
    }

    $new_tree[$tid] = $term;
    $new_tree[$tid]->children = array();
    // Use the data about the current term's parents ($term->parents) to
    // populate the 'children' array for that parent object.
    if (isset($term->parents)) {
      foreach ($term->parents as $tid_parent) {
        if (isset($new_tree[$tid_parent]) && $tid_parent != 0) {
          $new_tree[$tid_parent]->children[] = $tid;
        }
      }
    }

    $new_tree[$tid]->limit = variable_get('weblinks_maxdisp_' . $tid, '');
    $new_tree[$tid]->sort = variable_get('weblinks_group_sort_' . $term->tid, '');

    // The group is collapsible if the main option is on and a name exists.
    $new_tree[$tid]->collapsible = $collapsible && !empty($term->name);

    // The group is initally collapsed if it is collapsible and at least one of
    // the following is true:
    // (a) the overall 'collapse all groups' option $collapsed is on, or
    // (b) the specific 'collapse this group' option $collapse_me is on, or
    // (c) the group is deeper than maximum depth and admin wants it collapsed.
    $collapse_me = variable_get('weblinks_collapse_' . $tid, FALSE);
    $new_tree[$tid]->collapsed = $new_tree[$tid]->collapsible &&
      ($collapsed || $collapse_me || ($term->depth >= $max_depth && $show_or_hide == 'collapse'));

    if ($new_tree[$tid]->collapsible) {
      $new_tree[$tid]->title = check_plain($term->name);
    }
    else {
      if (variable_get('weblinks_linktitle', TRUE)) {
        // Link fieldset title to the group. For $tid 0 we need 'unclassified'.
        $new_tree[$tid]->title = l($term->name, 'weblinks/' . ($tid === 0 ? 'unclassified' : $tid));
      }
      else {
        $new_tree[$tid]->title = check_plain($term->name);
      }
    }

    $new_tree[$tid]->desc = '';
    if ($show_desc && !empty($term->description)) {
      $new_tree[$tid]->desc = '<div class="weblinks-cat-desc">' . check_markup($term->description, $format, '', FALSE) . '</div><!--class="weblinks-cat-desc"-->';
    }
    // Add 'clear-block' to ensure the subsequent content does not flow inline.
    $new_tree[$tid]->desc .= '<div class="clear-block"></div>';
  }
  return $new_tree;
}

/**
 * Display the main web links page, or a group page, separated by category.
 *
 * @param string $tid
 *   The term for which to display the links. Valid values are:
 *     a numeric term id
 *     'popular' to show the links with the most clicks,
 *     'recent' to show newly-added links,
 *     'unpublished' to show the unpublished links,
 *     'unclassified' to show the unclassified links,
 *     0, NULL or blank will show all weblinks
 *
 * @return
 *   HTML formatted page.
 */
function weblinks_page($tid = 0) {
  // Allow collapsible form elements.
  drupal_add_library('system', 'drupal.collapse');

  // Get the page description, if there is one.
  $pagedesc = theme('weblinks_pagedesc');

  // If the tid is not numeric, we came from a block "more".
  if (!is_numeric($tid)) {
    if (!in_array($tid, array('popular', 'recent', 'unpublished', 'unclassified')) || !module_exists('weblinks_blocks')) {
      $backtrace = debug_backtrace();
      drupal_set_message(t('Invalid group requested (%tid) in function %function0, called from %function1.', array(
        '%tid' => $tid,
        '%function0' => $backtrace[0]['function'],
        '%function1' => $backtrace[1]['function'],
      )), 'error');
      return ' ';
    }

    // For 'popular' or 'recent' there may be a second argument which is the id
    // of the group to further filter the links that are shown.
    $group_id = arg(2);

    // Generate the subject and content by re-using our hook_block_view().
    $block = weblinks_blocks_block_view('weblink-' . $tid . '-' . $group_id, array('limit' => 0));

    $fieldset = array(
      '#title' => $block['subject'],
      '#value' => $block['content']['#markup'],
      '#attributes' => array('class' => array(
        variable_get('weblinks_collapsible', TRUE) ? 'collapsible' : '',
      )),
      '#children' => NULL,
    );
    $output = $pagedesc . '<div class="weblinkCat weblinkCat-depth-0">'
      . theme('fieldset', array('element' => $fieldset)) . "</div>\n";
    return $output;
  }

  // Get the tree for this term. Third parameter will be TRUE if displaying all
  // terms (for main links page) and FALSE if displaying just one group page.
  $output = '';
  $tree = weblinks_get_tree($tid, FALSE, $tid == 0);
  if (empty($tree)) {
    // The 'invalid group' message is produced in weblinks_get_tree() so all we
    // need to do here is exit.
    return ' ';
  }
  foreach ($tree as $term) {
    if ($term->depth == 0) {
      $output .= _weblinks_format_group($term, $tree);
    }
  }
  if (!$output) {
    $output = '<p>' . t('There are no weblinks to display yet.') . '</p>';
  }

  return '<div class="weblinks">' . $pagedesc . $output . '</div>';
}

/**
 * Handle group operations.
 */
function _weblinks_group_operations($op, $tid = NULL) {
  if (!weblinks_group_access()) {
    drupal_access_denied();
  }

  // Force admin theme.
  global $custom_theme; // @todo: This is D6 code, it does not work like this in D7. Maybe try hook_custom_theme() ?
  $custom_theme = variable_get('admin_theme', '0');
  drupal_add_css(drupal_get_path('module', 'system') . '/admin.css');
  drupal_add_css(drupal_get_path('module', 'weblinks') . '/weblinks.admin.css');

  drupal_set_title(t('Group !op', array('!op' => $op)));

  module_load_include('inc', 'taxonomy', 'taxonomy.admin');

  $vocabulary = taxonomy_vocabulary_load(_weblinks_get_vocid());
  $_REQUEST['destination'] = 'weblinks';

  switch ($op) {
    case 'add':
      return drupal_get_form('taxonomy_form_term', 0, $vocabulary);

    case 'edit':
      if (($term = taxonomy_term_load($tid)) && $term->vid == $vocabulary->vid) {
        return drupal_get_form('taxonomy_form_term', $term);
      }
      else {
        $backtrace = debug_backtrace();
        drupal_set_message(t('Invalid group requested (%tid) in function %function0, called from %function1.', array(
          '%tid' => $tid,
          '%function0' => $backtrace[0]['function'],
          '%function1' => $backtrace[1]['function'],
        )), 'error');
        // This case falls through to the default return.
      }
    default:
      return '';
  }
}

/**
 * Process page for specific user.
 *
 * @param $uid
 *   user id to retrieve.
 *
 * @return the page of links submitted by the user.
 */
function _weblinks_user($uid) {
  $output = $username = NULL;
  $viewmode = variable_get('weblinks_viewmode', 'teaser');

  // See if name instead of id.
  if (!is_numeric($uid)) {
    $uid = _weblinks_find_user($uid);
  }

  $result = _weblinks_get_query($uid, 'user', 0);
  foreach ($result as $row) {
    $node = node_load($row->nid);
    if (!$username) {
      $username = theme('username', array('account' => $node));
    }
    $build = node_view($node, $viewmode);
    $output .= drupal_render($build);
  }
  drupal_set_title(t('Links submitted by !name', array('!name' => $username)), PASS_THROUGH);
  $breadcrumb = drupal_get_breadcrumb();
  $breadcrumb[] = l(_weblinks_get_menu_title(), 'weblinks');
  drupal_set_breadcrumb($breadcrumb);
  return $output;
}

/**
 * Helper function for _weblinks_user().
 */
function _weblinks_find_user($name) {
  if (function_exists('user_locate')) {
    $account = user_locate(array('name' => $name));
    $uid = $account->uid;
  }
  else {
    $uid = db_query("SELECT uid FROM {users} WHERE name=':uid'", array(':uid' => $name))->fetchField();
  }
  return $uid;
}

/**
 * Process redirect for URL. Count clicks and node views.
 *
 * @param $nid
 *   node id that contains the link.
 * $param $update_node_counter
 *   bool indicating whether or not the node view counter should be updated.
 *
 * @return none.
 *   the page will be redirected (302) to the desired URL.
 */
function weblinks_goto($nid) {
  $node = db_query("SELECT n.nid, n.vid, l.url FROM {node} n LEFT JOIN {weblinks} l USING(nid, vid) WHERE n.nid=:nid", array(':nid' => $nid))->fetchObject();
  $qargs = array(':date' => date('Y-m-d H:i:s'), ':nid' => $nid, ':vid' => $node->vid);
  db_query("UPDATE {weblinks} SET click_count=click_count+1, last_click=:date WHERE nid=:nid AND vid=:vid", $qargs);
  if (module_exists('statistics')) {
    statistics_exit('node', $nid, '');
  }
  header('Location: ' . $node->url);
}

/**
 * Prepare links content.
 *
 * @param $term
 *   a term object to process links for.
 *
 * @return
 *   list of links for the given term (HTML).
 */
function _weblinks_links($term) {
  global $user;
  // Making these static means we only need to set them the first time we come here.
  static $options, $empty_text, $filter_format, $viewmode;
  if (!isset($empty_text)) {
    $empty_text = variable_get('weblinks_empty_text', NULL);
    $filter_format = variable_get('weblinks_format', filter_fallback_format());
    $viewmode = variable_get('weblinks_viewmode', 'teaser');

    $options = array();
    if (variable_get('weblinks_external', TRUE)) {
      $options['attributes']['target'] = '_blank';
    }

    if (variable_get('weblinks_nofollow', FALSE)) {
      $options['attributes']['rel'] = 'nofollow';
    }
  }

  $output = NULL;

  // The limit should only be applied for child groups, that is, groups with a
  // depth more than 0. We cannot limit the parent group because those later
  // links would never get shown.
  $limit = (!empty($term->limit) && $term->depth > 0) ? $term->limit : 0;
  if ($term->tid === 'unpublished') {
    $sort_order = 'recent';
  }
  else {
    $sort_order = variable_get('weblinks_group_sort_' . $term->tid, variable_get('weblinks_page_sort', 'title'));
  }
  $result = _weblinks_get_query($term->tid, $sort_order, $limit);

  foreach ($result as $row) {
    $node = node_load($row->nid);
    $build = node_view($node, $viewmode);
    $output .= drupal_render($build);
  }

  // Do we need a "more" link?
  $need_more = 0 < $limit && $limit < $term->node_count;
  if ($need_more) {
    $more_link = '<div class="more-link">' . l(t('more') . ' &hellip;', 'weblinks/' . $term->tid) . '</div>';
    $output .= $more_link;
  }
  elseif ($term->node_count == 0) {
    $output = check_markup($empty_text, $filter_format, '', FALSE);
  }

  return decode_entities($output);
}

/**
 * Trim the link title (either text or the url itself) to the admin-specified length.
 */
function _weblinks_trim($text, $length = NULL) {
  if (!$length) {
    // Blocks have to specify the length.
    $length = variable_get('weblinks_trim', 0);
  }

  // Zero means no limit;
  if ($length == 0) {
    return $text;
  }

  // Use +3 for '...' string length.
  if (drupal_strlen($text) > $length + 3) {
    $text = drupal_substr($text, 0, $length) . '...';
  }

  return $text;
}

/**
 * General database query function.
 *
 * @param string $tid
 *   Identifies which links to fetch, and can have a variety of values:
 *     a term id, or a comma separated list of term ids
 *     0 to return the unclassified links (those with no terms)
 *     a userid to return that user's links when $sort = user
 *     'unpublished' to return the unpublished links
 *     'all' for no filter on term id
 * @param string $sort
 *   The order in which to return the results. Valid values are 'standard',
 *   'title', 'popular', 'recent' and 'random'.
 *   There are also special values 'user' and 'count' which control more than
 *   just the sorting.
 * @param int $limit
 *   The maximum number of rows to retrieve - 0 means unlimited.
 *
 * @return
 *   The result set from the query.
 */
function _weblinks_get_query($tid = 0, $sort = 'title', $limit = 0) {
  $query = db_select('node', 'n');
  $query->fields('n', array('nid', 'title', 'sticky', 'created', 'changed', 'uid', 'status'));
  $query->addJoin('INNER', 'weblinks', 'w', 'n.vid = w.vid');
  $query->fields('w', array('click_count', 'last_click'));

  if ($tid === 'unpublished') {
    $query->condition('n.status', 0);
  }
  elseif (variable_get('weblinks_unpublished_title', t('Unpublished'))) {
    // If there is an "unpublished" group title, then don't show the
    // unpublished links in this group.
    $query->condition('n.status', 1);
  }

  // Join on vocabulary data table to filter for specific term(s).
  if (_weblinks_get_vocid() && $tid !== 'all' && $tid !== 'unpublished' && $sort != 'user') {
    // Get the table and field name of the vocabulary being used for weblinks.
    $vocab_info = _weblinks_vocabulary_field_info();
    if ($tid === 0) {
      // Select just the unclassified links - those with no matching row.
      $query->addJoin('LEFT', $vocab_info['table_name'], 't', 't.entity_id = n.nid');
      $query->isNull('t.entity_id');
    }
    else {
      // Select the rows that match on the required term id(s).
      $query->addJoin('INNER', $vocab_info['table_name'], 't', 't.entity_id = n.nid');
      $query->where('t.' . $vocab_info['tid'] . ' IN (:tid)', array(':tid' => $tid));
    }
  }

  // Set the ORDER and various additional conditions depending on $sort.
  switch ($sort) {
    case 'standard':
      $query->orderBy('sticky', 'DESC');
      $query->orderBy('created', 'DESC');
      break;
    case 'title':
      $query->orderBy('sticky', 'DESC');
      $query->orderBy('title', 'ASC');
      break;
    case 'popular':
      $query->orderBy('click_count', 'DESC');
      $query->orderBy('last_click', 'DESC');
      // Popular links must have at least one click.
      $query->condition('click_count', 0, '>');
      break;
    case 'recent':
      $query->orderBy('changed', 'DESC');
      $query->orderBy('title', 'ASC');
      break;
    case 'random':
      $query->orderBy('RAND()');
      break;
    case 'user':
      $query->orderBy('sticky', 'DESC');
      $query->orderBy('created', 'DESC');
      // $tid is the user id in this case.
      $query->condition('uid', $tid);
      break;
    case 'count':
      // Convert the query into a count.
      $query = $query->countQuery();
      break;
    default:
      // The $sort text is not valid, so give a message. We need to return a
      // valid query object to avoid fatal errors, but make sure it is empty.
      drupal_set_message(t('Unexpected value "%sort" for parameter $sort in _weblinks_get_query()', array('%sort' => $sort)), 'error');
      $query->isNULL('n.nid');
      return $query->execute();
  }

  if ($sort != 'count') {
    $query->distinct();
  }

  if ($limit) {
    $query->range(0, $limit);
  }

  return $query->execute();
}

/**
 * Implements hook_form_alter().
 *
 * Alters the taxonomy term form to allow us to use it.
 * @TODO - check if necessary for this user and include. ** if (weblinks_group_access()) { **
 */
function weblinks_form_alter(&$form, &$form_state, $form_id) {
  switch ($form_id) {
    case 'taxonomy_form_term':
      // Is this for our vocabulary?
      if ($form['#vocabulary']->vid != _weblinks_get_vocid()) {
        return '';
      }
      $form['name']['#title'] = t('Group name');
      $form['name']['#description'] = t('The name of this group.');
      $form['description']['#title'] = t('Group description');
      $form['description']['#description'] = t('A description of the group, to be displayed on web links pages and forms.');

      $yesno = array(1 => t('Yes'), 0 => t('No'));
      $tid = $form['#term']['tid'];

      $form['weblinks'] = array(
        '#type' => 'fieldset',
        '#title' => t('Web Links group settings'),
        '#attributes' => array('id' => 'weblinks-page-settings'),
        '#collapsible' => TRUE,
        '#collapsed' => FALSE,
        '#prefix' => '<div class="weblinks-settings">',
        '#suffix' => '</div>',
        '#weight' => $form['relations']['#weight'],
        );

      // Set the default collapsed state for this group.
      $form['weblinks']['weblinks_collapse_' . $tid] = array(
        '#type' => 'radios',
        '#options' => $yesno,
        '#prefix' => '<div class="weblinks-radios">',
        '#suffix' => '</div>',
        '#title' => t('Collapse by default'),
        '#default_value' => variable_get('weblinks_collapse_' . $tid, 0),
        '#description' => t('Select "Yes" to collapse this group. This will only have an effect if "Collapse all groups" is "No".'),
        );

      // Set the maximum number of links to display for each group.
      $form['weblinks']['weblinks_maxdisp_' . $tid] = array(
        '#type' => 'textfield',
        '#title' => t('Maximum links to display'),
        '#size' => 10,
        '#default_value' => variable_get('weblinks_maxdisp_' . $tid, ''),
        '#description' => t('This controls the number of links displayed when shown as a child-group on the main pages. Leave blank for no limit.'),
      );

      $sort_options = array(
        '' => t('Default.'),
        'standard' => t('Normal Drupal - by sticky, weight, created date.'),
        'title' => t('Legacy - by sticky, weight, title.'),
        );
      $form['weblinks']['weblinks_group_sort_' . $tid] = array(
        '#type' => 'radios',
        '#options' => $sort_options,
        '#title' => t('Link sort order'),
        '#default_value' => variable_get('weblinks_group_sort_' . $tid, ''),
        '#description' => t('This determines how the links are display within thier group.'),
        '#required' => FALSE,
        '#prefix' => '<div class="weblinks-radios">',
        '#suffix' => '</div>',
      );

      $form['relations']['parent']['#description'] = t('Web Links parent groups.');
      $form['relations']['weight']['#description'] = t('Web Links groups are displayed in ascending order by weight.');

      // Add our submit handler before Taxonomy's own one.
      array_unshift($form['#submit'], 'weblinks_taxonomy_form_term_submit');

      break;

    case 'taxonomy_form_vocabulary':
      // Do not allow admins to change the machine name of the weblinks vocab.
      if ($form['machine_name']['#default_value'] == 'weblinks') {
        $form['machine_name']['#disabled'] = TRUE;
      }
      break;

    case 'user_admin_permissions':
      // Give a warning if any role has Edit Groups or Admin permissions but has
      // not been given basic access to the weblinks pages.
      if (!empty($form_state['input'])) {
        foreach ($form_state['input'] as $rid => $checkboxes) {
          foreach (array('edit group weblinks', 'administer weblinks') as $perm) {
            if (!empty($checkboxes[$perm]) && empty($checkboxes['access weblinks'])) {
              drupal_set_message(t('Warning: Role %role_name has %perm_desc permission, but does not have %access_desc permission.', array(
                '%role_name' => '"' . $form['role_names']['#value'][$rid] . '"',
                '%access_desc' => '"' . $form['permission']['access weblinks']['#markup'] . '"',
                '%perm_desc' => '"' . $form['permission'][$perm]['#markup'] . '"',
              )), 'warning');
            }
          }
        }
      }
      break;
  } // End switch form_id.
}

/**
 * Additional submit function for taxonomy form.
 */
function weblinks_taxonomy_form_term_submit($form, &$form_state) {
  // Save each of the 'weblinks_' values to their own external variable.
  // This will also save variables added in weblinks_blocks_form_alter().
  foreach ($form_state['values'] as $var_name => $value) {
    if (substr($var_name, 0, 9) == 'weblinks_') {
      // If group_sort value is '' then we want the default, so delete the variable.
      if (substr($var_name, 0, 19) == 'weblinks_group_sort' && $value == '') {
        variable_del($var_name);
      }
      else {
        variable_set($var_name, $value);
      }
    }
  }
}

/**
 * Implements hook_theme().
 */
function weblinks_theme() {
  return array(
    // In separate files.
    'weblinks_user_form' => array(
      'variables' => array('form' => NULL),
      'file' => 'weblinks.user.inc',
      ),
    // In template files.
    'weblinks_node_view' => array(
      'template' => 'weblinks_node_view',
      'variables' => array('node' => NULL, 'options' => NULL, 'status' => NULL),
      ),
    'weblinks_link' => array(
      'template' => 'weblinks-link',
      'variables' => array('node' => NULL, 'teaser' => NULL),
      ),
    // In this module.
    'weblinks_pagedesc' => array(
      'variables' => array(),
      ),
    'weblinks_user_link' => array(
      'variables' => array('acct_id' => NULL),
      ),
    );
}

/**
 *  Theme the page description.
 *
 *  @param none
 *
 *  @return
 *    String containing the formatted info.
 */
function theme_weblinks_pagedesc() {
  // Get the page description, if there is one.
  $pagedesc = variable_get('weblinks_pagedesc', NULL);
  if (empty($pagedesc)) {
    return NULL;
  }
  else {
    return '<div class="weblinks-pagedesc">' . check_markup($pagedesc, variable_get('weblinks_format', filter_fallback_format(), '',
     FALSE)) . '</div>'; // @TODO: What is this? variable_get() with four parameters?
  }
}

/**
 *  Theme the user link.
 *
 *  @param $acct_id
 *    User ID for the link to be made.
 *
 *  @return
 *    String containing the formatted info.
 */
function theme_weblinks_user_link($acct_id) {
  static $users = array();
  if (!isset($users[$acct_id])) {
    $account = user_load($acct_id);
    $users[$acct_id] = l($account->name . "'s links", 'user/' . $acct_id . '/weblinks');
  }
  return '<div class="weblinks-user-link">' . $users[$acct_id] . '</div>';
}

/**
 * Implements hook_views_api().
 */
function weblinks_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'weblinks'),
    );
}

/**
 * Implements hook_modules_installed().
 */
function weblinks_modules_installed($modules) {
  // Inform the user if they try to enable these sub-modules.
  foreach (array('pralexa', 'weblinks_convert_links', 'weblinks_convert_janode', 'weblinks_convert_linksdb') as $old_module) {
    if (in_array($old_module, $modules)) {
      drupal_set_message(t('The @old_module module is no longer available.', array('@old_module' => $old_module)));
      if ($old_module == 'pralexa') {
        weblinks_update_7003();
      }
      else {
        module_disable(array($old_module));
        drupal_uninstall_modules(array($old_module));
      }
    }
  }
}

/**
 * Implements hook_modules_enabled().
 */
function weblinks_modules_enabled($modules) {
  // Inform the user if they try to enable these sub-modules.
  foreach (array('pralexa', 'weblinks_convert_links', 'weblinks_convert_janode', 'weblinks_convert_linksdb') as $old_module) {
    if (in_array($old_module, $modules)) {
      drupal_set_message(t('The @old_module module is no longer available.', array('@old_module' => $old_module)));
      if ($old_module == 'pralexa') {
        weblinks_update_7003();
      }
      else {
        module_disable(array($old_module));
        drupal_uninstall_modules(array($old_module));
      }
    }
  }
}
