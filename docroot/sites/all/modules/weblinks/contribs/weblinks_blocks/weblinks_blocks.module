<?php

/**
 * @file
 * Enable display of categorized web links in blocks.
 * Drupal 7 Version
 */

/**
 * Produces a list of valid block types for the Web Links module.
 * @param none.
 * @return keyed array where the key is the block type,
 *   each element is a keyed array of block attributes:
 *     name => string: translated proper name for the block.
 *     group => boolean: whether the block can be by group.
 */
function weblinks_blocks_types() {
  return array(
    'random'       => array('name' => t('Random'), 'group' => TRUE),
    'recent'       => array('name' => t('Recent'), 'group' => TRUE),
    'popular'      => array('name' => t('Popular'), 'group' => TRUE),
    'related'      => array('name' => t('Related'), 'group' => FALSE),
    'contributors' => array('name' => t('Contributors'), 'group' => FALSE),
//    'unclassified'  => array('name' => t('Unclassified'), 'group' => FALSE),
    '0'            => array('name' => t('Unclassified'), 'group' => FALSE),
    'unpublished'  => array('name' => t('Unpublished'), 'group' => FALSE),
    'all'          => array('name' => t('All'), 'group' => FALSE),
    'user'         => array('name' => t('User'), 'group' => FALSE),
    'author'       => array('name' => t('Author'), 'group' => FALSE),
    );
}

/**
 * Implements hook_help().
 */
function weblinks_blocks_help($path, $args) {
  switch ($path) {
    case 'admin/modules#description':
    case 'admin/help#weblinks_blocks':
      return '<p>' . t('Enables the display of categorized links in blocks.') . '</p>';
  }
}

/**
 * Implements hook_theme().
 */
function weblinks_blocks_theme() {
  return array(
    'weblinks_block_item' => array(
      'variables' => array('node' => NULL, 'title_length' => 0, 'urlnode' => NULL, 'options' => '',
                           'show_image' => FALSE, 'desc' => ''),
      ),
    );
}

/**
 * Implements hook_cron().
 */
function weblinks_blocks_cron() {
  global $user;
  global $theme;
  // Let's see if we need to refresh the random block.
  $block_exists = (bool) db_query_range("SELECT 1 FROM {block} b WHERE b.theme=:theme AND b.module='weblinks_blocks' AND b.delta='weblink-random' AND b.status=1", 0, 1, array(':theme' => $theme))->fetchField();
  if ($block_exists) {
    $tid = 'random';  // Implicit
    $interval = variable_get('weblinks_blocks_update_interval_' . $tid, '');
    if ($interval > 0) {
      $step = variable_get('weblinks_blocks_update_step_' . $tid, 86400);
      $last = variable_get('weblinks_blocks_update_last_' . $tid, 0);
      $now = time();

      // Is it time to update yet?
      if (($last + ($interval * $step)) < $now) {
        // Clear the cached data and let the block regenerate.
        cache_clear_all('weblinks:weblink-random:', 'cache_block', TRUE);
      }
    }
  }
}

/**
 * Prepare block content.
 *
 * @param int/string $tid
 *   The term id or block type for which this request applies. Valid values are:
 *     a numeric term id for just that term (this is uid when $sort = author),
 *     'all' for all links,
 *     0 to display the unclassified links
 *     'unpublished'
 *     'random'
 *     'recent'
 *     'popular'
 * @param string $sort
 *   The sorting order for the block.
 * @param int $limit
 *   The maximum number of links to display.
 * @param int $group_id
 *   Optional term id when $tid is 'random', 'recent' or 'popular'. Allows these
 *   special blocks to be further qualified.
 *
 * @return
 *   The block contents, as a themed list.
 */
function _weblinks_blocks_content($tid = 0, $sort, $limit, $group_id = NULL) {
  $blktid = $tid . ($group_id ? '_' . $group_id : NULL);
  if ($sort == 'user' || $sort == 'author') {
    $blktid = $sort;
    $sort = 'user';
  }
  $urlnode = variable_get('weblinks_blocks_urlnode_' . $blktid, 'url');
  $more = variable_get('weblinks_blocks_more_' . $blktid, FALSE);
  $desc = variable_get('weblinks_blocks_description_' . $blktid, 'none');
  $title_length = variable_get('weblinks_trim_blocks', 0);
  $show_image = variable_get('weblinks_blocks_image_' . $blktid, FALSE);
  $classes = variable_get('weblinks_blocks_classes_' . $blktid, 'weblinks');
  $show_count = variable_get('weblinks_blocks_show_count_' . $blktid, FALSE);
  $show_last = variable_get('weblinks_blocks_show_last_' . $blktid, FALSE);

  $options = $items = array();
  if ($extra_classes = variable_get('weblinks_extra_classes', '')) {
    $options['attributes']['class'] = explode(' ', $extra_classes);
  }

  if (variable_get('weblinks_external', TRUE)) {
    $options['attributes']['target'] = '_blank';
  }
  if (variable_get('weblinks_nofollow', FALSE)) {
    $options['attributes']['rel'] = 'nofollow';
  }
  $options['image_style'] = variable_get('weblinks_blocks_image_style_' . $blktid, '');

  // $qtid identifies the filtering required in _weblinks_get_query(). It can be
  // be a single term id or comma-separated list of term ids. If the query
  // should not filter on any terms then 'all' is passed as the parameter.
  if ($group_id) {
    // Get the tree for this group (using "quick").
    $tree = weblinks_get_tree($group_id, TRUE);
    $tids = array();
    foreach ($tree as $term) {
      $tids[] = $term->tid;
    }
    $qtid = implode(',', $tids);
  }
  elseif ((string)$tid == $sort) {
    // The text string has been passed in both parameters, there are no terms to
    // filter on, so pass 'all' to the query.
    $qtid = 'all';
  }
  else {
    $qtid = $tid;
  }

  // Get enough links for one more than the limit.
  $result = _weblinks_get_query($qtid, $sort, ($limit ? $limit + $more : 0));
  $more_link = NULL;
  foreach ($result as $row) {
    $node = node_load($row->nid);
    $variables = array(
      'node' => $node,
      'title_length' => $title_length,
      'urlnode' => $urlnode,
      'options' => $options,
      'show_image' => $show_image,
      'desc' => $desc,
      'show_count' => $show_count,
      'show_last' => $show_last,
    );
    // Add links up to the limit if there is one.
    if ($limit == 0 || count($items) < $limit) {
      $items[] = theme('weblinks_block_item', $variables);
    }
    // Add a 'more' link if required, only if user has access to the full page.
    elseif ($more && user_access('access weblinks')) {
      $where = '';
      if ($sort == 'user') {
        $where = '/user/' . $tid;
      }
      elseif ($tid === 0) {
        $where = '/unclassified';
      }
      elseif ($tid !== 'all') {
        $where = '/' . $tid . ($group_id ? '/' . $group_id : NULL);
      }
      $more_link = '<div class="more-link">' . l(t('more') . ' &hellip;', 'weblinks' . $where, array('html' => TRUE)) . '</div>';
    }
  }

  $list_type = ($sort == 'popular') ? variable_get('weblinks_blocks_popular_list_type') : 'ul';
  $output = $items ? decode_entities(theme('item_list', array('items' => $items, 'title' => NULL,
                                        'type' => $list_type, 'attributes' => array('class' => $classes))) . $more_link) : NULL;
  return $output;
}

/**
 * Theme a block link.
 */
function theme_weblinks_block_item($variables) {
  $node = $variables['node'];
  $title_length = $variables['title_length'];
  $urlnode = $variables['urlnode'];
  $options = $variables['options'];
  $show_image = $variables['show_image'];
  $desc = $variables['desc'];
  $image = '';
  if ($show_image and module_exists('image')) {
    // The image field name could be anything the admin called it, so get all
    // the weblinks image fieldnames from the db, using core functions
    // field_read_fields() and field_read_instances(). Save the final answer in
    // a static variable $block_image_fieldname to avoid repeating this process
    // for every link on the page.
    static $block_image_fieldname;
    if (empty($block_image_fieldname)) {
      // Get the weblinks image fields. This does not return the labels.
      $image_fields = field_read_fields(array('type' => 'image', 'bundle' => 'weblinks'));
      if (empty($image_fields)) {
        // No image field has been assigned to the Weblinks content type. Set
        // the variable to 'none' so that (a) we do not continually try to find
        // the field_name for each link on the page and (b) the test checking
        // for !empty($node->$block_image_fieldname) will still work.
        $block_image_fieldname = 'none';
      }
      else {
        // We have at least one image field, so default to the first one.
        $image_field_names = array_keys($image_fields);
        $block_image_fieldname = $image_field_names[0];
        if (sizeof($image_fields) > 1) {
          // More than one image field, so get instances, to give label text.
          $image_field_instances = field_read_instances(array(
            'field_name' => $image_field_names,
            'bundle' => 'weblinks',
          ));
          foreach ($image_field_instances as $details) {
            if (stristr($details['field_name'], 'block')) {
              // Return the first field containing 'block' in the name.
              $block_image_fieldname = $details['field_name'];
              break;
            }
            if (stristr($details['label'], 'block') && empty($found_label)) {
              // Store the name if the label contains 'block' but do not stop
              // yet as there may be another field with 'block' in the field
              // name, and that one will take precedence. Use $found_label so
              // that we only store the first matching one.
              $block_image_fieldname = $details['field_name'];
              $found_label = TRUE;
            }
          }
        }
      }
    }
    if (!empty($node->$block_image_fieldname)) {
      // Get the first image using the preferred language if possible.
      $images = $node->$block_image_fieldname;
      $image_langcode = isset($images[$node->language]) ? $node->language : LANGUAGE_NONE;
      $weblink_image = reset($images[$image_langcode]);
      // Get the image style, defaulting to the standard one provided.
      $image_style = !empty($options['image_style']) ? $options['image_style'] : 'weblinks_blocks_image_style';
      // Theme the image using the required style.
      $image = theme('image_style',
        array(
          'path' => $weblink_image['uri'],
          'style_name' => $image_style,
          'alt' => $node->title,
          'title' => $node->title,
        )
      );
    }
  }

  $items = field_get_items('node', $node, 'body');
  // Get the body field instance data, but only once per call.
  static $body_info, $trim_length, $text_processing;
  if (!isset($body_info)) {
    if ($body_info = field_info_instance('node', 'body', 'weblinks')) {
      $trim_length = $body_info['display']['teaser']['settings']['trim_length'];
      $text_processing = $body_info['settings']['text_processing'];
    }
    else {
      // The body field has been removed from the weblinks content type.
      $desc = 'none';
    }
  }
  if ($desc != 'none') {
    $field_langcode = field_language('node', $node, 'body');
  }
  $node_format =  $text_processing ? $items[0]['format'] : NULL;

  switch ($desc) {
    case 'none':
      $description = NULL;
      break;
    case 'teaser':
      // If a separate 'summary' entry exists use it, otherwise use 'value'.
      $text = !empty($items[0]['summary']) ? $items[0]['summary'] : $items[0]['value'];
      // Create a temporary item array for use in _text_sanitize().
      $temp_item = array(
        'trimmed_text' => text_summary($text, $node_format, $trim_length),
        'format' => $items[0]['format'],
      );
      $description = _text_sanitize($body_info, $field_langcode, $temp_item, 'trimmed_text');
      break;
    case 'body':
      $description = _text_sanitize($body_info, $field_langcode, $items[0], 'value');
      break;
  }
  if ($description) {
    $description = '<div class="description">' . $description . '</div>';
  }

  $click_data = array();
  if (!empty($variables['show_count'])) {
    $click_data[] = format_plural($node->click_count, 'Clicked 1 time', 'Clicked @count times');
  }
  $last_click = strtotime($node->last_click);
  if (!empty($variables['show_last']) && $last_click > 0) {
    $click_data[] = t('Last clicked @date', array('@date' => format_date($last_click, 'small')));
  }
  if (sizeof($click_data)) {
    $click = '<div class="weblinks-click-stats">' . implode('. ', $click_data) . '</div>';
  }
  else {
    $click = NULL;
  }

  $output = array(
    'data' => weblinks_blocks_build_link($node, $title_length, $urlnode, $options) . $description . $click . $image,
    'class' => array('weblinks weblinks-item weblinks-link-' . $node->nid),
  );
  return $output;
}

/**
 * Build a link.
 *
 * @param object $node
 *   Node object for which to build the link.
 * @param int $show_url
 *   Length to trim title, 0 = full title, NULL = use 'weblinks_trim' variable.
 * @param string $urlnode
 *   'node', 'url' or 'goto' - indicating where the link should point.
 * @param array $options
 *   Optional atributes for the link.
 *
 * @return link
 *   The constructed html for the link.
 */
function weblinks_blocks_build_link($node, $show_url, $urlnode, $options) {
  // $options['attributes']['class'] should be an array, as this is expected
  // when passing $options to l().
  if (!isset($options['attributes']['class'])) {
    $options['attributes']['class'] = array();
  }
  elseif (is_string($options['attributes']['class'])) {
    $options['attributes']['class'] = explode(' ', $options['attributes']['class']);
  }
  $options['attributes']['class'][] = 'weblinks-link';

  switch ($urlnode) {
    // @TODO Handle "redirect."
    case 'node':
      $url = 'node/' . $node->nid;
      // Force target=_blank off.
      unset($options['attributes']['target']);
      break;
    case 'url':
      $url = $node->url;
      $options['attributes']['class'][] = 'previewlink';
      break;
    case 'goto':
      $url = 'weblinks/goto/' . $node->nid;
      break;
  }
  $url = drupal_get_path_alias($url);

  switch ($show_url) {
    case 0;
      $title = filter_xss($node->title);
      break;
    default:
      $title = _weblinks_trim(filter_xss($node->title), $show_url);
  }

  if (!isset($options['attributes']['title'])) {
    $options['attributes']['title'] = check_plain($node->title);
  }

  return '<div class="weblinks-link">' . l($title, $url, $options) . '</div>';
}

/**
 * Prepare the Related Links block.
 *
 * @param int/array $tids
 *   The term id or array of term ids for which to find links.
 * @param int $limit
 *   The maximum number of links to show. 0 indicates no limit.
 * @param string $show_current
 *   Controls what to do if the current node appears in the block.
 *   'no' will not show the block at all.
 *   'without' will omit this link from the block.
 *   'highlight' will highlight this link.
 *
 * @return html
 *   Rendered HTML list of links.
 */
function _weblinks_blocks_related_block($tids, $limit = 0, $show_current) {
  $urlnode = variable_get('weblinks_blocks_urlnode_related', 'url');
  $sort = variable_get('weblinks_blocks_sort_related', 'title');
  $more = variable_get('weblinks_blocks_more_related', FALSE);
  $desc = variable_get('weblinks_blocks_description_related', FALSE);
  $title_length = variable_get('weblinks_trim_blocks', 0);
  $show_image = variable_get('weblinks_blocks_image_related', FALSE);
  $classes = variable_get('weblinks_blocks_classes_related', 'weblinks');
  $current_nid = arg(1);

  $options = array();
  if ($extra_classes = variable_get('weblinks_extra_classes', '')) {
    $options['attributes']['class'] = explode(' ', $extra_classes);
  }
  if (variable_get('weblinks_external', TRUE)) {
    $options['attributes']['target'] = '_blank';
  }
  if (variable_get('weblinks_nofollow', FALSE)) {
    $options['attributes']['rel'] = 'nofollow';
  }
  $options['image_style'] = variable_get('weblinks_blocks_image_style_related', '');

  $content = NULL;
  $tids = is_array($tids) ? $tids : array($tids);
  foreach ($tids as $tid) {
    // Get all the terms starting from parent $tid.
    // Second parameter $quick is defined but not used in weblinks_get_tree().
    // Third parameter $ismainlinkspage should be FALSE as ths is a block.
    $tree = weblinks_get_tree($tid, TRUE, FALSE);
    $show_title = count($tree) > 1 || count($tids) > 1;
    foreach ($tree as $term) {
      // If a 'more' link is required then increase the query limit by one so we
      // can determine if there are any more links. Also if we do not want to
      // show the current node in the block then add a further one to the limit.
      $result = _weblinks_get_query($term->tid, $sort, ($limit ? $limit + $more + ($show_current == 'without') : 0));

      $more_link = NULL;
      $items = array();
      foreach ($result as $key => $row) {
        // If there is a limit, only add items up to this limit. This ensures we
        // get the correct number regardless of whether the current link
        // happened to be in the $result.
        if ($limit == 0 || count($items) < $limit) {
          // Is the item the one currently being viewed?
          if ($row->nid == $current_nid) {
            if ($show_current == 'no') {
              // Do not show the block at all.
              return NULL;
            }
            if ($show_current == 'without') {
              // Do not show this link.
              continue;
            }
            if ($show_current == 'highlight') {
              // Admin wants to highlight it.
              $options['attributes']['class']['highlight'] = 'weblinks-related-current';
            }
          }
          // Add the item to the list.
          $items[] = theme('weblinks_block_item', array('node' => node_load($row->nid), 'title_length' => $title_length,
                           'urlnode' => $urlnode, 'options' => $options, 'show_image' => $show_image,
                           'desc' => $desc));
        }
        elseif ($more && user_access('access weblinks')) {
          // The 'more' option is on, and there is at least one more row, so
          // create a 'more' link.
          $more_link = '<div class="more-link">'
            . l(t('more') . '&#8230;', 'weblinks/' . $tid)
            . '</div>';
        }
        // Remove the 'highlight' class that may have been set above.
        unset($options['attributes']['class']['highlight']);
      }
      if ($items) {
        if ($show_title) {
          $content .= '<h3>' . check_plain($term->name) . '</h3>';
        }
        $content .= decode_entities(theme('item_list', array('items' => $items, 'title' => NULL,
                                           'type' => 'ul', 'attributes' => array('class' => $classes))) . $more_link);
      }
    }
  }
  return $content;
}

/**
 * Implements hook_block_info().
 */
function weblinks_blocks_block_info() {
  $block = array();
  // Get the tree of terms.
  $tree = weblinks_get_tree(0, TRUE);
  $allow_groups = FALSE;
  if ($tree) {
    foreach ($tree as $term) {
      $term->blockname = $term->name ? $term->name : ($term->tid == 0 ? t('Unclassified') : $term->tid);
      $term->create_block = variable_get('weblinks_create_block_' . $term->tid, TRUE);
      // If the admin said "no" to this block, skip it.
      if (!$term->create_block) {
        continue;
      }

      $term->allow = 0;  // Initialize, might be not set.
      if ($term->depth == 0) {
        $allow_this_group = variable_get('weblinks_block_allow_groups_' . $term->tid, FALSE);
        if ($allow_this_group) {
          $allow_groups |= $allow_this_group;
          $term->allow = $allow_this_group;
        }
      }
      else {
        if ($term->parents[0] != 0) {
          // If a term is a child, show its parenthood.
          $parent_list = array();
          foreach ($term->parents as $ptid) {
            $parent = $tree[$ptid];
            $term->blockname = decode_entities($parent->blockname . " &raquo; " . $term->name);
            $term->allow = $parent->allow;
          }
        }
        else {
          $term->blockname = $term->name;
        }
      }
    }
  }

  // These blocks are not per group.
  $block['weblink-related'] = array(
    'info' => 'Web Links: Related',
    'cache' => DRUPAL_NO_CACHE,
    );
  $block['weblink-contributors'] = array(
    'info' => 'Web Links: Contributors',
    'cache' => DRUPAL_CACHE_GLOBAL,
    );
  $block['weblink-0'] = array(
    'info' => 'Web Links: Unclassified',
    'cache' => DRUPAL_CACHE_PER_ROLE,
    );
  $block['weblink-unpublished'] = array(
    'info' => 'Web Links: Unpublished',
    'cache' => DRUPAL_CACHE_PER_ROLE,
    );
  $block['weblink-user'] = array(
    'info' => 'Web Links: My Links',
    'cache' => DRUPAL_CACHE_PER_ROLE,
    );
  $block['weblink-author'] = array(
    'info' => 'Web Links: Author Links',
    'cache' => DRUPAL_CACHE_PER_ROLE,
    );
  $block['weblink-all'] = array(
    'info' => 'Web Links: All Links',
    'cache' => DRUPAL_CACHE_PER_ROLE,
    );

  // Even if we are doing blocks by group, generate the "catch-all" blocks.
  $block['weblink-random'] = array(
    'info' => 'Web Links: Random',
    'cache' => DRUPAL_CACHE_PER_ROLE,
    );
  $block['weblink-recent'] = array(
    'info' => 'Web Links: Recent',
    'cache' => DRUPAL_CACHE_PER_ROLE,
    );
  $block['weblink-popular'] = array(
    'info' => 'Web Links: Most Popular',
    'cache' => DRUPAL_NO_CACHE,
    );

  foreach ($tree as $term) {
    if ($term->create_block) {
      $block['weblink-' . $term->tid] = array(
        'info' => 'Web Links: ' . $term->blockname,
        'cache' => DRUPAL_CACHE_PER_ROLE,
        );
      if ($term->allow) {
        // Blocks by group.
        $block['weblink-random-' . $term->tid] = array(
          'info' => 'Web Links: ' . $term->blockname . ': Random',
          'cache' => DRUPAL_CACHE_PER_ROLE,
          );
        $block['weblink-recent-' . $term->tid] = array(
          'info' => 'Web Links: ' . $term->blockname . ': Recent',
          'cache' => DRUPAL_CACHE_PER_ROLE,
          );
        $block['weblink-popular-' . $term->tid] = array(
          'info' => 'Web Links: ' . $term->blockname . ': Most Popular',
          'cache' => DRUPAL_NO_CACHE,
          );
      }
    }
  }

  return $block;
}

/**
 * Implements hook_block_view().
 *
 * The second parameter is a custom flexible array of key/value options added
 * for weblinks.
 *
 */
function weblinks_blocks_block_view($delta, $options = array()) {
  $block = array();
  // $type : 'weblink'
  // $tid : a term id or a string 'popular', 'recent', 'user', 'author',
  // 'related', 'random', 'unclassified', 'unpublished', 'contributors', 'all'.
  // $group_id : optional term id when $tid = 'popular', 'recent' or 'random'
  // Add '-' to avoid notice in case of just two parts.
  list($type, $tid, $group_id) = explode('-', $delta . '-');

  $blktid = $tid . ($group_id ? '_' . $group_id : NULL);

  $vocid = _weblinks_get_vocid();
  // $term and $types are used only when building the $subject.
  if (function_exists('taxonomy_term_load')) {
    $term = is_numeric($tid) ? taxonomy_term_load($tid) : taxonomy_term_load($group_id);
    if (isset($term->vid) && $term->vid != $vocid) {
      // This term is from a vocabulary which is not the weblinks vocab. This
      // should only happen when blocks are added, then a different vocab is
      // selected for weblinks.
      return array();
    }
  }
  else {
    $term = _weblinks_unclassed();
  }
  $types = weblinks_blocks_types();

  // Build an array to hold the subject elements. We will have atleast the block
  // type name or the term name. For the special blocks 'random', 'popular' and
  // 'recent' we may have both.
  $blk_name_array = array();
  isset($types[$tid]['name']) ? $blk_name_array[] = $types[$tid]['name'] : NULL;
  isset($term->name) ? $blk_name_array[] = $term->name : NULL;
  $blk_name_array[] = t('Links');
  $subject = implode(' ', $blk_name_array);

  // If the limit is specified in the options use it, otherwise get it from the
  // stored variable for this block configuration.
  $limit = isset($options['limit']) ? $options['limit'] : variable_get('weblinks_maxdisp_blocks_' . $blktid, 10);

  $content = '';
  switch ($tid) {
    case 'popular':
    case 'recent':
      $content = _weblinks_blocks_content($tid, $tid, $limit, $group_id);
      break;

    case 'user':
      global $user;
      if (user_access('view my weblinks')) {
        $content = _weblinks_blocks_content($user->uid, 'user', $limit);
        $subject = t('My Links');
      }
      break;

    case 'author':
      $uid = 0;
      switch (arg(0)) {
        case 'node':
          if (!is_numeric(arg(1))) {
            return;
          }
          if ($node = menu_get_object()) {
            $uid = $node->uid;
          }
          break;

        // You can do other post-related user paths here.
        case 'blog';
          $uid = arg(1);
          if (!is_numeric($uid)) {
            return;
          }
          break;

        default:
          return;
      }
      $account = user_load($uid);
      $username = isset($account->realname) ? $account->realname : $account->name;

      $content = _weblinks_blocks_content($account->uid, 'author', $limit);
      $subject = t("@username's Links", array('@username' => $username));
      break;

    case 'related':
      // This is only for a node page.
      if (arg(0) != 'node' || !is_numeric(arg(1))) {
        return array();
      }
      // The concept of 'related' requires links to be grouped, so if there are
      // no taxonomy categories we cannot show the block.
      if (!$vocid) {
        return array();
      }
      $related_tids = array();
      // Look for a term in our vocabulary.
      if ($node = menu_get_object()) {
        // If the node has no webllinks taxonomy then we cannot pick any related
        // nodes, so return nothing.
        $related_tids = array();

        // Get the node field which contains the weblinks vocabulary. We use
        // _weblinks_vocabulary_field_info() as we cannot assume the field
        // will be the standard taxonomy_weblinks field.
        $vocab_info = _weblinks_vocabulary_field_info();
        if (!isset($node->$vocab_info['field_name'])) {
          return array();
        }
        $vocab_field = $node->$vocab_info['field_name'];
        if (!is_array($vocab_field)) {
          return array();
        }
        reset($vocab_field); // Get first item. ### Might need to do better than this. Maybe search for which langcode to use?
        $langcode = key($vocab_field);
        if (!empty($vocab_field[$langcode])) { // can this ever be empty?
          foreach ($vocab_field[$langcode] as $temp_term) {
            $related_tids[] = $temp_term['tid'];
          }
        }
      }
      // Did we find a term?
      if (count($related_tids) == 0) {
        return;
      }

      $show_current = variable_get('weblinks_blocks_current_related', 'no');
      $content = _weblinks_blocks_related_block($related_tids, $limit, $show_current);
      break;

    case 'random':
      $interval = variable_get('weblinks_blocks_update_interval_' . $blktid, '');
      if ($interval > 0) {
        $step = variable_get('weblinks_blocks_update_step_' . $blktid, 86400);
        $last = variable_get('weblinks_blocks_update_last_' . $blktid, 0);
        $now = time();

        // Is it time to update yet?
        if (($last + ($interval * $step)) < $now) {
          $content = _weblinks_blocks_content('random', 'random', $limit, $group_id);
          variable_set('weblinks_blocks_update_last_' . $blktid, $now);
          variable_set('weblinks_blocks_update_content_' . $blktid, $content);
        }
        else {
          $content = variable_get('weblinks_blocks_update_content_' . $blktid, '???');
        }
      }
      else {
        $content = _weblinks_blocks_content('random', 'random', $limit, $group_id);
      }
      break;

    case 'unclassified':
    case '0':
      $content = _weblinks_blocks_content(0, variable_get('weblinks_blocks_sort_' . $tid, 'title'), $limit);
      break;

    case 'unpublished':
      $content = _weblinks_blocks_content('unpublished', 'recent', $limit);
      break;

    case 'contributors':
      $rows = $header = array();
      $how_many = variable_get('weblinks_maxdisp_blocks_contributors', 10);
      $result = db_query_range("SELECT u.uid, u.name, COUNT(n.uid) as count FROM {node} n "
        . "LEFT JOIN {users} u USING(uid) WHERE n.type='weblinks' "
        . "GROUP BY u.name, u.uid ORDER BY count DESC", 0, $how_many);
      foreach ($result as $row) {
        $rows[] = array(
          theme('username', array('account' => $row, 'levels' => FALSE, 'plain' => TRUE)),
          l($row->count, 'weblinks/user/' . $row->uid),
          );
      }
      if ($rows) {
        $subject = t('Web Links Contributors');
        $content = theme('table', array('header' => $header, 'rows' => $rows));
      }
      break;

    case 'all':
    default:
      $content = _weblinks_blocks_content($tid, variable_get('weblinks_blocks_sort_' . $tid, 'title'), $limit);
  }

  // If we have content then create the block array.
  if ($content) {
    $block['content'] = array(
      '#markup' => $content,
      '#attached' => array(
        'css' => array(
          drupal_get_path('module', 'weblinks_blocks') . '/weblinks_blocks.css',
        ),
      ),
    );
    $block['subject'] = $subject;
  }

  return $block;
}

/**
 * Implements hook_block_configure().
 */
function weblinks_blocks_block_configure($delta = '') {
  drupal_add_css(drupal_get_path('module', 'weblinks') . '/weblinks.admin.css');
  $form = array();
  $yesno = array(t('No'), t('Yes'));
  list($type, $tid, $group_id) = explode('-', $delta . '-');
  $blktid = $tid . ($group_id ? '_' . $group_id : NULL);
  $form['#attributes'] = array('class' => 'weblinks-settings');

  $form['weblinks'] = array(
    '#type' => 'fieldset',
    '#title' => t('Web Links'),
    '#collapsible' => TRUE,
    '#collapsed' => FALSE,
    );

  if ($tid == 'contributors') {
    $form['weblinks']['weblinks_maxdisp_blocks'] = array(
      '#type' => 'textfield',
      '#title' => t('Maximum users to display'),
      '#size' => 3,
      '#default_value' => variable_get('weblinks_maxdisp_blocks_contributors', 10),
      '#description' => t('The number of users to show in this block.'),
      );
    return $form;  // That's all for this block.
  }

  $disp = variable_get('weblinks_maxdisp_blocks_' . $blktid, ($tid == 'random' ? 1 : 10));
  $disp = empty($disp) ? 10 : $disp;
  $form['weblinks']['weblinks_maxdisp_blocks'] = array(
    '#type' => 'textfield',
    '#title' => t('Maximum weblinks to display'),
    '#size' => 3,
    '#default_value' => $disp,
    '#description' => $tid == 'related' ? t('The number of links to show in each group in this block.') : t('The number of links to show in this block.'),
    );

  if ($tid == 'random') {
    $form['weblinks']['weblinks_blocks_more'] = array('#type' => 'value', '#value' => 0);
  }
  else {
    $form['weblinks']['weblinks_blocks_more'] = array(
      '#type' => 'radios',
      '#options' => $yesno,
      '#title' => t('"More..." link'),
      '#default_value' => (int) variable_get('weblinks_blocks_more_' . $blktid, 0),
      '#description' => t('If there are more links than the limit above, do you want a "more..." link?')
        . ' ' . t('This will only be shown for users who are allowed to access the full pages.'),
      '#prefix' => '<div class="weblinks-radios">',
      '#suffix' => '</div>',
      );
  }

  if ($tid == 'popular') {
    $form['weblinks']['weblinks_blocks_show_count'] = array(
      '#type' => 'radios',
      '#options' => $yesno,
      '#title' => t('Show click count'),
      '#default_value' => (int) variable_get('weblinks_blocks_show_count_' . $blktid, 0),
      '#description' => t('If this is selected, the number of times the link has been clicked will be shown.'),
      '#prefix' => '<div class="weblinks-radios">',
      '#suffix' => '</div>',
      );

    $fmt = variable_get('date_format_short', 'm/d/Y - H:i');
    $form['weblinks']['weblinks_blocks_show_last'] = array(
      '#type' => 'radios',
      '#options' => $yesno,
      '#title' => t('Show last click date'),
      '#default_value' => (int) variable_get('weblinks_blocks_show_last_' . $blktid, 0),
      '#description' => t('If this is selected, the last date/time the link was clicked will be shown in the site short date format ("%fmt").', array('%fmt' => $fmt)),
      '#prefix' => '<div class="weblinks-radios">',
      '#suffix' => '</div>',
      );
  }
  else {
    $form['weblinks']['weblinks_blocks_show_count'] = array('#type' => 'value', '#value' => 0);
    $form['weblinks']['weblinks_blocks_show_last'] = array('#type' => 'value', '#value' => 0);
  }

  $desc_opts = array(
    'none' => t('No description'),
    'teaser' => t('Teaser length'),
    'body' => t('Full length'),
    );
  $form['weblinks']['weblinks_blocks_description'] = array(
    '#type' => 'radios',
    '#options' => $desc_opts,
    '#title' => t('Show description'),
    '#default_value' => variable_get('weblinks_blocks_description_' . $blktid, 'none'),
    '#description' => t("If checked, the link's description will be shown."),
    '#prefix' => '<div class="weblinks-radios">',
    '#suffix' => '</div>',
    );

  $form['weblinks']['weblinks_blocks_image'] = array(
    '#type' => 'radios',
    '#options' => $yesno,
    '#title' => t('Show image'),
    '#default_value' => (int) variable_get('weblinks_blocks_image_' . $blktid, FALSE),
    '#description' => t("Display the link's image in this block."),
    '#prefix' => '<div class="weblinks-radios">',
    '#suffix' => '</div>',
    );
  // Provide a select field for choosing an image style to use when displaying
  // the image. If the Image module exists then we know the Field module and
  // and its functions will also be available.
  $image_fields = module_exists('image') ? field_read_fields(array('type' => 'image', 'bundle' => 'weblinks')) : FALSE;
  if ($image_fields) {
    $form['weblinks']['weblinks_blocks_image_style'] = array(
      '#title' => t('Image style'),
      '#type' => 'select',
      '#description' => t('Choose an image style to use when displaying this image. You can <a href="@image_styles_link">add or modify image styles</a>', array(
        '@image_styles_link' => url('admin/config/media/image-styles'),
      )),
      // The function image_style_options() returns an array of all available
      // image styles. The parameter indicates whether or not the array should
      // include a <none> option.
      '#options' => image_style_options(FALSE),
      '#default_value' => variable_get('weblinks_blocks_image_style_' . $blktid, 'weblinks_blocks_image_style'),
      // Hide this form item if 'show image' is not turned on.
      '#states' => array(
        'visible' => array(
          ':input[name="weblinks_blocks_image"]' => array('value' => 1),
        ),
      ),
    );
  }
  else {
    // Images are not available, so disable the radio and give a message.
    $form['weblinks']['weblinks_blocks_image']['#default_value'] = 0;
    $form['weblinks']['weblinks_blocks_image']['#disabled'] = 1;
    $form['weblinks']['weblinks_blocks_image']['#description'] = t('To display images with Web Links, enable the <a href="@modules_link">core Image module</a> and add an image field to the <a href="@content_type_link">Web Links content type</a>', array(
      '@modules_link' => url('admin/modules'),
      '@content_type_link' => url('admin/structure/types/manage/weblinks/fields')));
  }

  $form['weblinks']['weblinks_blocks_classes'] = array(
    '#type' => 'textfield',
    '#title' => t('Additional classes'),
    '#default_value' => variable_get('weblinks_blocks_classes_' . $blktid, 'weblinks'),
    '#description' => t("These classes will be applied to the list of items. Separate them with spaces (as it HTML)."),
    );

  switch ($tid) {
    case 'unpublished':
      // Force unpublished to the node.
      $form['weblinks']['weblinks_blocks_urlnode'] = array('#type' => 'value', '#value' => 'node');
      break;

    case 'related':
      $related_opts = array(
        'no' => t('Don\'t show block'),
        'without' => t('Show block without current link'),
        'highlight' => t('Show block with current link highlighted'),
        );
      $form['weblinks']['weblinks_blocks_current_related'] = array(
        '#type' => 'radios',
        '#options' => $related_opts,
        '#title' => t('Block contains related'),
        '#description' => t('What would you like to do if the currently viewed node is included in the block. "Highlighted" means the item will have the "weblinks-related-current" class added.'),
        '#default_value' => variable_get('weblinks_blocks_current_related', 'no'),
        '#prefix' => '<div class="weblinks-radios">',
        '#suffix' => '</div>',
        );
      // Note, this falls through.

    default:
      $lead_to_opts = array('url' => t('URL'), 'node' => t('node'));
      if (variable_get('weblinks_redirect', FALSE)) {
        $lead_to_opts['goto'] = t('click tracking');
      }

      $form['weblinks']['weblinks_blocks_urlnode'] = array(
        '#type' => 'radios',
        '#title' => t('Links lead to URL or Web Link node'),
        '#default_value' => variable_get('weblinks_blocks_urlnode_' . $blktid, 'url'),
        '#description' => t('Most people will want to leave this as URL. Specifying "node" makes it easier to edit the links, but requires an additional click to follow the link.'),
        '#options' => $lead_to_opts,
        '#prefix' => '<div class="weblinks-radios">',
        '#suffix' => '</div>',
        );
  }

  if ($tid == 'popular') {
    $form['weblinks']['weblinks_blocks_popular_list_type'] = array(
      '#type' => 'radios',
      '#title' => t('List type'),
      '#options' => array('ul' => t('Simple list'), 'ol' => t('Numbered list')),
      '#default_value' => variable_get('weblinks_blocks_popular_list_type', 'ul'),
      '#description' => t('This sets the way the list will be displayed.'),
      '#prefix' => '<div class="weblinks-radios">',
      '#suffix' => '</div>',
      );
  }

  if ($tid != 'recent' && $tid != 'popular' && $tid != 'random' && $tid != 'user') {
    $sort_options = array(
      'standard' => t('Normal Drupal - by sticky, weight, created date.'),
      'title' => t('Legacy - by sticky, weight, title.'),
      );
    $form['weblinks']['weblinks_blocks_sort'] = array(
      '#type' => 'radios',
      '#options' => $sort_options,
      '#title' => t('Sort order'),
      '#default_value' => variable_get('weblinks_blocks_sort_' . $blktid, 'title'),
      '#description' => t('This determines how the links blocks will sort the links.'),
      '#prefix' => '<div class="weblinks-radios">',
      '#suffix' => '</div>',
      );
  }

  if ($tid == 'random') {
    $form['weblinks']['cron_interval'] = array(
      '#type' => 'textfield',
      '#size' => 4,
      '#maxlength' => 3,
      '#default_value' => variable_get('weblinks_blocks_update_interval_' . $blktid, ''),
      '#field_prefix' => '<strong>' . t('Update every') . '</strong>',
      '#prefix' => '<div class="container-inline">',
      );

    $form['weblinks']['cron_step'] = array(
      '#type' => 'select',
      '#default_value' => variable_get('weblinks_blocks_update_step_' . $blktid, 86400),
      '#options' => array(
        1 => t('seconds'),
        60 => t('minutes'),
        3600 => t('hours'),
        86400 => t('days'),
        604800 => t('weeks'),
        ),
      '#suffix' => '</div>'
      );

    $form['weblinks']['description'] = array(
      '#type' => 'item',
      '#description' => t('If set, the link displayed in this block will get updated based on the interval specified (requires cron if page cache is enabled). Leave this value blank to have the link updated every time the block is viewed.'),
      '#prefix' => '<div style="display: block;">',
      '#suffix' => '</div>',
      );
  }

  return $form;
}

/**
 * Implements hook_block_save().
 */
function weblinks_blocks_block_save($delta = '', $edit = array()) {
  list($type, $tid, $group_id) = explode('-', $delta . '-');
  $blktid = $tid . ($group_id ? '_' . $group_id : NULL);

  variable_set('weblinks_maxdisp_blocks_' . $blktid, $edit['weblinks_maxdisp_blocks']);
  if ($tid == 'contributors') {
    return;
  }
  variable_set('weblinks_blocks_urlnode_' . $blktid, $edit['weblinks_blocks_urlnode']);
  variable_set('weblinks_blocks_more_' . $blktid, $edit['weblinks_blocks_more']);
  variable_set('weblinks_blocks_description_' . $blktid, $edit['weblinks_blocks_description']);
  variable_set('weblinks_blocks_image_' . $blktid, $edit['weblinks_blocks_image']);
  // The image style field may not exist in the form, so check before using it.
  if (isset($edit['weblinks_blocks_image_style'])) {
    variable_set('weblinks_blocks_image_style_' . $blktid, $edit['weblinks_blocks_image_style']);
  }
  variable_set('weblinks_blocks_classes_' . $blktid, $edit['weblinks_blocks_classes']);
  // Don't save sort for popular, recent, random or user.
  if ($tid != 'popular' && $tid != 'recent' && $tid != 'random' && $tid != 'user') {
    variable_set('weblinks_blocks_sort_' . $blktid, $edit['weblinks_blocks_sort']);
  }

  if ($tid == 'popular') {
    variable_set('weblinks_blocks_popular_list_type', $edit['weblinks_blocks_popular_list_type']);
    variable_set('weblinks_blocks_show_count_' . $blktid, $edit['weblinks_blocks_show_count']);
    variable_set('weblinks_blocks_show_last_' . $blktid, $edit['weblinks_blocks_show_last']);
  }

  if ($tid == 'related') {
    variable_set('weblinks_blocks_current_related',   $edit['weblinks_blocks_current_related']);
  }

  if ($tid == 'random') {
    variable_set('weblinks_blocks_update_interval_' . $blktid, $edit['cron_interval']);
    variable_set('weblinks_blocks_update_step_' . $blktid, $edit['cron_step']);
  }
}

/**
 * Implements hook_form_alter().
 */
function weblinks_blocks_form_alter(&$form, &$form_state, $form_id) {
  switch ($form_id) {
    // Alter the taxonomy term form to add block options.
    case 'taxonomy_form_term':
      // Is this for our vocabulary?
      if ($form['#vocabulary']->vid != _weblinks_get_vocid()) {
        return '';
      }
      // Don't show our fieldset if we're deleting this term.
      if (isset($form_state['confirm_delete'])) {
        return;
      }

      // The $form['weblinks'] fieldset is created in weblinks_form_alter() so
      // we can rely on it already existing at this point in the process.
      $yesno = array(1 => t('Yes'), 0 => t('No'));
      $tid = $form['#term']['tid'];

      $form['weblinks']['weblinks_create_block_' . $tid] = array(
        '#type' => 'radios',
        '#options' => $yesno,
        '#title' => t('Create block'),
        '#default_value' => (int) variable_get('weblinks_create_block_' . $tid, TRUE),
        '#description' => t('Select "Yes" to create a block for this group.'),
        '#prefix' => '<div class="weblinks-radios">',
        '#suffix' => '</div>',
        );

      $form['weblinks']['weblinks_block_allow_groups_' . $tid] = array(
        '#type' => 'radios',
        '#options' => $yesno,
        '#title' => t('Blocks by group'),
        '#default_value' => (int) variable_get('weblinks_block_allow_groups_' . $tid, FALSE),
        '#description' => t('Create Random, Recent, and Popular blocks for this group. Requires "Create block" above. Child groups will inherit this setting.'),
        '#prefix' => '<div class="weblinks-radios weblinks-indented">',
        '#suffix' => '</div>',
        '#states' => array(
          'visible' => array(
            ':input[name="weblinks_create_block_' . $tid . '"]' => array('value' => 1),
          ),
        ),
      );

      $form['weblinks']['weblinks_page_' . $tid] = array(
        '#type' => 'radios',
        '#options' => $yesno,
        '#title' => t('Show %name group on the main pages', array('%name' => $form['#term']['name'])),
        '#default_value' => (int) variable_get('weblinks_page_' . $tid, TRUE),
        '#description' => t('By default, all groups are displayed on the main pages. But when the Blocks sub-module is enabled they can be turned off and only displayed in a block.'),
        '#prefix' => '<div class="weblinks-radios">',
        '#suffix' => '</div>',
        '#states' => array(
          'visible' => array(
            ':input[name="weblinks_create_block_' . $tid . '"]' => array('value' => 1),
          ),
        ),
      );
      break;

  } // End switch form_id.
}

/**
 * Implements hook_image_default_styles().
 */
function weblinks_blocks_image_default_styles() {
  // Taken from Exmples for developemt image_example.module.
  $styles = array();
  // Each style array consists of an 'effects' array that is made up of
  // sub-arrays which define the individual image effects that are combined
  // together to create the image style.
  $styles['weblinks_blocks_image_style'] = array(
    'label' => 'Web Links image for blocks',
    'effects' => array(
      array(
        'name' => 'image_scale',
        'data' => array('width' => 150, 'height' => 150, 'upscale' => 1),
        'weight' => 0,
      ),
    ),
  );
  return $styles;
}
