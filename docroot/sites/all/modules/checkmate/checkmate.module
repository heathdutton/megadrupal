<?php
/**
 * @file
 * Checkmate module
 */

// Checkmate statuses.
define('CHECKMATE_STATUS_NOK', 0);
define('CHECKMATE_STATUS_OK', 1);
define('CHECKMATE_STATUS_NOT_CHECKED', -1);
define('CHECKMATE_STATUS_NA', -2);
define('CHECKMATE_STATUS_IN_PROGRESS', 2);


/**
 * Implements hook_entity_info().
 */
function checkmate_entity_info() {
  $return = array();

  // The checkmate item entity.
  $return['checkmate_item'] = array(
    'label' => t('Checkmate item'),
    'entity class' => 'CheckmateItem',
    'controller class' => 'CheckmateItemController',
    'base table' => 'checkmate_item',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'cid',
      'bundle' => 'type',
    ),
    'bundle keys' => array(
      'bundle' => 'type',
    ),
    'bundles' => array(),
    'load hook' => 'checkmate_item_load',
    'view modes' => array(
      'full' => array(
        'label' => t('Default'),
        'custom settings' => FALSE,
      ),
    ),
    'label callback' => 'entity_class_label',
    'module' => 'checkmate',
    'access callback' => 'checkmate_item_access',
  );

  // The checkmate item type entity.
  $return['checkmate_item_type'] = array(
    'label' => t('Checkmate item type'),
    'entity class' => 'CheckmateItemType',
    'controller class' => 'CheckmateItemTypeController',
    'base table' => 'checkmate_item_type',
    'fieldable' => FALSE,
    'bundle of' => 'checkmate_item',
    'exportable' => TRUE,
    'entity keys' => array(
      'id' => 'type',
      'name' => 'type',
      'label' => 'label',
    ),
    'module' => 'checkmate',
    // Enable the entity API's admin UI.
    'admin ui' => array(
      'path' => 'admin/structure/checkmate-item-types',
      'file' => 'checkmate.admin.inc',
      'controller class' => 'CheckmateItemTypeUIController',
    ),
    'access callback' => 'checkmate_item_type_access',
  );

  // The checkmate item status entity.
  $return['checkmate_item_status'] = array(
    'label' => t('Checkmate item status'),
    'entity class' => 'CheckmateItemStatus',
    'controller class' => 'CheckmateItemStatusController',
    'base table' => 'checkmate_item_status',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'csid',
      'bundle' => 'type',
    ),
    'bundle keys' => array(
      'bundle' => 'type',
    ),
    'bundles' => array(),
    'load hook' => 'checkmate_item_status_load',
    'view modes' => array(
      'full' => array(
        'label' => t('Default'),
        'custom settings' => FALSE,
      ),
    ),
    'label callback' => 'entity_class_label',
    'uri callback' => 'entity_class_uri',
    'module' => 'checkmate',
    'access callback' => 'checkmate_item_access',
  );

  return $return;
}

/**
 * Implements hook_menu_alter().
 */
function checkmate_menu_alter(&$items) {
  // Change the title and position of the tabs under checkmate_item_type.
  $items['admin/structure/checkmate-item-types/manage/%checkmate_item_type/status/fields']['title'] = 'Status fields';
  $items['admin/structure/checkmate-item-types/manage/%checkmate_item_type/status/fields']['weight'] = 3;
  $items['admin/structure/checkmate-item-types/manage/%checkmate_item_type/status/display']['title'] = 'Status display';
  $items['admin/structure/checkmate-item-types/manage/%checkmate_item_type/status/display']['weight'] = 4;
}

/**
 * Implements hook_entity_info_alter().
 */
function checkmate_entity_info_alter(&$entity_info) {
  foreach (checkmate_item_types() as $type => $info) {
    $entity_info['checkmate_item']['bundles'][$type] = array(
      'label' => $info->label,
      'admin' => array(
        'path' => 'admin/structure/checkmate-item-types/manage/%checkmate_item_type',
        'real path' => 'admin/structure/checkmate-item-types/manage/' . $type,
        'bundle argument' => 4,
      ),
    );
    $entity_info['checkmate_item_status']['bundles'][$type] = array(
      'label' => t('@node_type status', array('@node_type' => $info->label)),
      'admin' => array(
        'path' => 'admin/structure/checkmate-item-types/manage/%checkmate_item_type/status',
        'real path' => 'admin/structure/checkmate-item-types/manage/' . $type . '/status',
        'bundle argument' => 4,
      ),
    );
  }
}

/**
 * Implements hook_permission().
 */
function checkmate_permission() {
  $permissions = array(
    'administer checkmate_item types' => array(
      'title' => t('Administer checkmate-item types'),
      'restrict access' => TRUE,
    ),
    'administer checkmate_item entities' => array(
      'title' => t('Administer checkmate-item entities'),
      'restrict access' => TRUE,
    ),
    'create checkmate_item entities' => array(
      'title' => t('Create checkmate-item'),
      'restrict access' => FALSE,
    ),
    'view checkmate_item entity groups' => array(
      'title' => t('View checkmate-item entity groups'),
      'restrict access' => FALSE,
    ),
    'edit any checkmate_item entities' => array(
      'title' => t('Edit any checkmate-items'),
      'restrict access' => FALSE,
    ),
    'edit own checkmate_item entities' => array(
      'title' => t('Edit own checkmate-items'),
      'restrict access' => FALSE,
    ),
    'delete any checkmate_item entities' => array(
      'title' => t('Delete any checkmate-items'),
      'restrict access' => FALSE,
    ),
    'delete own checkmate_item entities' => array(
      'title' => t('Delete own checkmate-items'),
      'restrict access' => FALSE,
    ),
  );
  return $permissions;
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function checkmate_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  // Add the add checkmate-item button on the checkmate item overview.
  if ($root_path == 'admin/content/checkmate-item') {
    $item = menu_get_item('admin/content/checkmate-item/add');
    if ($item['access']) {
      $data['actions']['output'][] = array(
        '#theme' => 'menu_local_action',
        '#link' => $item,
      );
    }
  }
}

/**
 * Implements hook_menu().
 */
function checkmate_menu() {
  $items = array();

  // Add a new checkmate-item.
  $items['admin/content/checkmate-item/add'] = array(
    'title' => 'Add checkmate item',
    'page callback' => 'checkmate_item_admin_add_page',
    'access callback' => 'entity_access',
    'access arguments' => array('create', 'checkmate_item'),
    'file' => 'checkmate.admin.inc',
    'type' => MENU_LOCAL_ACTION,
    'tab_parent' => 'admin/content/checkmate-item',
    'tab_root' => 'admin/content/checkmate-item',
  );

  $check_uri = 'admin/content/checkmate-item/%checkmate_item';
  $check_uri_argument_position = 3;

  // Delete a checkmate item.
  $items[$check_uri . '/delete'] = array(
    'title' => 'Delete checkmate item',
    'title callback' => 'checkmate_item_label',
    'title arguments' => array($check_uri_argument_position),
    'page callback' => 'drupal_get_form',
    'page arguments' => array(
      'checkmate_item_delete_form',
      $check_uri_argument_position,
    ),
    'access callback' => 'entity_access',
    'access arguments' => array(
      'edit',
      'checkmate_item',
      $check_uri_argument_position,
    ),
    'file' => 'checkmate.admin.inc',
  );

  // Edit a checkmate-item
  $items[$check_uri . '/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'drupal_get_form',
    'page arguments' => array(
      'checkmate_item_form',
      $check_uri_argument_position,
    ),
    'access callback' => 'entity_access',
    'access arguments' => array(
      'edit',
      'checkmate_item',
      $check_uri_argument_position,
    ),
    'file' => 'checkmate.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
  );

  // Add checkmate item for each checkmate item type.
  foreach (checkmate_item_types() as $type => $info) {
    $items['admin/content/checkmate-item/add/' . $type] = array(
      'title' => 'Add ' . $info->label . ' Check item',
      'page callback' => 'checkmate_item_add',
      'page arguments' => array(4),
      'access callback' => 'entity_access',
      'access arguments' => array('create', 'checkmate_item', $type),
      'file' => 'checkmate.admin.inc',
    );
  }

  // Delete a checkmate item type.
  $items['admin/structure/checkmate-item-types/%checkmate_item_type/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('checkmate_item_type_form_delete_confirm', 4),
    'access arguments' => array('administer checkmate_item types'),
    'weight' => 1,
    'type' => MENU_NORMAL_ITEM,
    'file' => 'checkmate.admin.inc',
  );

  // Callback for autocomplete subgroups.
  $items['checkmate_subgroup/autocomplete'] = array(
    'title' => 'group autocomplete',
    'page callback' => 'checkmate_autocomplete_subgroup',
    'access arguments' => array('view checkmate_item entity groups'),
    'type' => MENU_CALLBACK,
  );

  // Callback for autocomplete groups.
  $items['checkmate_group/autocomplete'] = array(
    'title' => 'subgroup autocomplete',
    'page callback' => 'checkmate_autocomplete_subgroup',
    'access arguments' => array('view checkmate_item entity groups'),
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Autocomplete callback function for subgroups.
 */
function checkmate_autocomplete_subgroup($string) {
  $items = db_query('SELECT DISTINCT check_subgroup FROM {checkmate_item} WHERE check_subgroup LIKE :string', array(':string' => '%' . $string . '%'))->fetchAllKeyed(0, 0);
  print drupal_json_output($items);
  return NULL;
}

/**
 * Autocomplete callback function for subgroups.
 */
function checkmate_autocomplete_group($string) {
  $items = db_query('SELECT DISTINCT check_group FROM {checkmate_item} WHERE check_group LIKE :string', array(':string' => '%' . $string . '%'))->fetchAllKeyed(0, 0);
  print drupal_json_output($items);
  return NULL;
}

/**
 * Access callback for checkmate item.
 */
function checkmate_item_access($op, $checkmate_item, $account = NULL, $entity_type = NULL) {
  global $user;
  if (!isset($account)) {
    $account = $user;
  }
  switch ($op) {
    case 'create':
      return user_access('administer checkmate_item entities', $account)
      || user_access('create checkmate_item entities', $account);
    case 'delete':
      return user_access('administer checkmate_item entities', $account)
      || user_access('delete any checkmate_item entities', $account)
      || (user_access('delete own checkmate_item entities') && ($checkmate_item->uid == $account->uid));
    case 'edit':
      return user_access('administer checkmate_item entities')
      || user_access('edit any checkmate_item entities')
      || (user_access('edit own checkmate_item entities') && ($checkmate_item->uid == $account->uid));
  }
}

/**
 * Implements hook_admin_paths().
 */
function checkmate_admin_paths() {
  $paths = array(
    'checkmate-item' => TRUE,
    'checkmate-item/*' => TRUE,
    'checkmate-item/add/*' => TRUE,
  );
  return $paths;
}

/**
 * Implements hook_theme().
 */
function checkmate_theme() {
  return array(
    'checkmate_status' => array(
      'variables' => array('status' => CHECKMATE_STATUS_NA),
    ),
  );
}

/**
 * Get the status image.
 */
function theme_checkmate_status($variables) {
  $checkmate_path = '/' . drupal_get_path('module', 'checkmate');

  $statuses = checkmate_get_statuses();

  $path = '';
  switch ($variables['status']) {
    case CHECKMATE_STATUS_NOK:
      $path = $checkmate_path . '/img/checkmate_incorrect.png';
      break;

    case CHECKMATE_STATUS_NOT_CHECKED:
      $path = $checkmate_path . '/img/checkmate_unchecked.png';
      break;

    case CHECKMATE_STATUS_OK:
      $path = $checkmate_path . '/img/checkmate_checked.png';
      break;

    case CHECKMATE_STATUS_NA:
      $path = $checkmate_path . '/img/checkmate_notapplicable.png';
      break;

    case CHECKMATE_STATUS_IN_PROGRESS:
      $path = $checkmate_path . '/img/checkmate_inprogress.png';
      break;

  }
  return theme_image(array(
    'path' => $path,
    'alt' => $statuses[$variables['status']],
    'title' => $statuses[$variables['status']],
    'attributes' => array(),
  ));
}

/**
 * Retrieve the status of a checkmate-item.
 */
function checkmate_get_status_of_item($item, $params = array()) {
  static $statuses = NULL;
  if (count($params) || !isset($statuses[$item->callback][$item->cid])) {
    array_unshift($params, $item);
    // Call the supplied callback.
    $statuses[$item->callback][$item->cid] = call_user_func_array($item->callback, $params);
  }
  return $statuses[$item->callback][$item->cid];
}

/**
 * Returns the number of checkmate items with a given status.
 */
function checkmate_multilevel_status_count($items, $statuses_to_count) {
  $count = 0;
  foreach ($items as $key => $item) {
    if (!isset($item->title)) {
      // Not an item, so it's a subgroup.
      $count += checkmate_multilevel_status_count($item, $statuses_to_count);
    }
    else {
      // It's an item, get it's status and count it.
      $params = !empty($item->parameters) ? unserialize($item->parameters) : array();

      $status = checkmate_get_status_of_item($item, $params);
      if ($item->callback == 'checkmate_manual_check') {
        $current_status = end($status);
        if (in_array($current_status ? $current_status->checkmate_status->value() : CHECKMATE_STATUS_NOT_CHECKED, $statuses_to_count)) {
          $count++;
        }
      }
      else {
        if (in_array($status['status'], $statuses_to_count)) {
          $count++;
        }
      }

    }
  }
  return $count;
}

/**
 * Get all checkmate statuses.
 * TODO: This should be configurable in the user interface.
 */
function checkmate_get_statuses() {
  return array(
    CHECKMATE_STATUS_OK => t('Completed'),
    CHECKMATE_STATUS_NOK => t('Incorrect'),
    CHECKMATE_STATUS_IN_PROGRESS => t('In progress'),
    CHECKMATE_STATUS_NOT_CHECKED => t('Not checked'),
    CHECKMATE_STATUS_NA => t('Not applicable'),
  );
}

/**
 * Implements hook_entity_property_info_alter().
 */
function checkmate_entity_property_info_alter(&$info) {
  $properties = &$info['checkmate_item']['properties'];
  $properties['created'] = array(
    'label' => t("Date created"),
    'type' => 'date',
    'description' => t("The date the node was posted."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer nodes',
    'schema field' => 'created',
  );
  $properties['changed'] = array(
    'label' => t("Date changed"),
    'type' => 'date',
    'schema field' => 'changed',
    'description' => t("The date the node was most recently updated."),
  );
  $properties['uid'] = array(
    'label' => t("Author"),
    'type' => 'user',
    'description' => t("The author of the task."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer checkmate_item entities',
    'required' => TRUE,
    'schema field' => 'uid',
  );

  $properties = &$info['checkmate_item_status']['properties'];
  $properties['created'] = array(
    'label' => t("Date created"),
    'type' => 'date',
    'description' => t("The date the node was posted."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer checkmate_item_status entities',
    'schema field' => 'created',
  );
  $properties['changed'] = array(
    'label' => t("Date changed"),
    'type' => 'date',
    'schema field' => 'changed',
    'description' => t("The date the node was most recently updated."),
  );
  $properties['uid'] = array(
    'label' => t("Author"),
    'type' => 'user',
    'description' => t("The author of the task."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer checkmate_item_status entities',
    'required' => TRUE,
    'schema field' => 'uid',
  );
  $properties['cid'] = array(
    'label' => t("Checkmate item"),
    'type' => 'checkmate_item',
    'description' => t("The checkmate item."),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer checkmate_item_status entities',
    'required' => TRUE,
    'schema field' => 'cid',
  );
}

/**
 * Implements hook_views_api().
 */
function checkmate_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'checkmate'),
  );
}

/**
 * Load a checkmate item.
 */
function checkmate_item_load($cid, $reset = FALSE) {
  $checkmate_items = checkmate_item_load_multiple(array($cid), array(), $reset);
  return reset($checkmate_items);
}
/**
 * Load multiple checkmate items based on certain conditions.
 */
function checkmate_item_load_multiple($cids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('checkmate_item', $cids, $conditions, $reset);
}

/**
 * Save checkmate item.
 */
function checkmate_item_save($checkmate_item) {
  entity_save('checkmate_item', $checkmate_item);
  return $checkmate_item->cid;
}

/**
 * Delete single checkmate item.
 */
function checkmate_item_delete($checkmate_item) {
  entity_delete('checkmate_item', entity_id('checkmate_item', $checkmate_item));
}

/**
 * Delete multiple checkmate items.
 */
function checkmate_item_delete_multiple($checkmate_item_ids) {
  entity_delete_multiple('checkmate_item', $checkmate_item_ids);
}

/**
 * Access callback for checkmate item Type.
 */
function checkmate_item_type_access($op, $entity = NULL) {
  return user_access('administer checkmate_item types');
}

/**
 * Load checkmate item Type.
 */
function checkmate_item_type_load($checkmate_item_type) {
  return checkmate_item_types($checkmate_item_type);
}


/**
 * Save checkmate item type entity.
 */
function checkmate_item_type_save($checkmate_item_type) {
  entity_save('checkmate_item_type', $checkmate_item_type);
  checkmate_status_create_instance('checkmate_status', 'checkmate_item_status', $checkmate_item_type->type, t('Status'), 0, 'checkmate_item_status');
}

/**
 * Delete single checkmate item type.
 */
function checkmate_item_type_delete($checkmate_item_type) {
  entity_delete('checkmate_item_type', entity_id('checkmate_item_type', $checkmate_item_type));
}

/**
 * Delete multiple checkmate item types.
 */
function checkmate_item_type_delete_multiple($checkmate_item_type_ids) {
  entity_delete_multiple('checkmate_item_type', $checkmate_item_type_ids);
}

/**
 * Load a checkmate item status.
 */
function checkmate_item_status_load($csid, $reset = FALSE) {
  $checkmate_item_statuses = checkmate_item_status_load_multiple(array($csid), array(), $reset);
  return reset($checkmate_item_statuses);
}
/**
 * Load multiple checkmate item statuses based on certain conditions.
 */
function checkmate_item_status_load_multiple($csids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('checkmate_item_status', $csids, $conditions, $reset);
}


/**
 * Save checkmate item.
 */
function checkmate_item_status_save($checkmate_item_status) {
  entity_save('checkmate_item_status', $checkmate_item_status);
}

/**
 * Delete single checkmate item.
 */
function checkmate_item_status_delete($checkmate_item_status) {
  entity_delete('checkmate_item_status', entity_id('checkmate_item_status', $checkmate_item_status));
}

/**
 * Delete multiple checkmate items.
 */
function checkmate_item_status_delete_multiple($checkmate_item_status_ids) {
  entity_delete_multiple('checkmate_item_status', $checkmate_item_status_ids);
}


/**
 * Creates a required, locked instance of a status field on the specified bundle.
 *
 * @param string $field_name
 *   The name of the field.
 * @param string $entity_type
 *   The type of entity the field instance will be attached to.
 * @param string $bundle
 *   The bundle name of the entity the field instance will be attached to.
 * @param string $label
 *   The label of the field instance.
 * @param integer $weight
 *   The default weight of the field instance widget and display.
 */
function checkmate_status_create_instance($field_name, $entity_type, $bundle, $label, $weight = 0) {
  // Look for or add the specified status field to the requested entity bundle.
  $field = field_info_field($field_name);
  $instance = field_info_instance($entity_type, $field_name, $bundle);

  if (empty($field)) {
    $field = array(
      'field_name' => $field_name,
      'type' => 'list_text',
      'cardinality' => 1,
      'entity_types' => array($entity_type),
      'translatable' => FALSE,
      'locked' => TRUE,
      'settings' => array(
        'allowed_values_function' => 'checkmate_get_statuses',
      ),
    );
    $field = field_create_field($field);
  }

  if (empty($instance)) {
    $instance = array(
      'field_name' => $field_name,
      'entity_type' => $entity_type,
      'bundle' => $bundle,

      'label' => $label,
      'required' => TRUE,
      'settings' => array(),

      'widget' => array(
        'type' => 'options_select',
        'weight' => $weight,
      ),

      'display' => array(),
    );

    field_create_instance($instance);
  }
}

/**
 * List of checkmate item Types.
 */
function checkmate_item_types($type_name = NULL) {
  $types = entity_load_multiple_by_name('checkmate_item_type', isset($type_name) ? array($type_name) : FALSE);
  return isset($type_name) ? reset($types) : $types;
}

/**
 * Implements hook_checkmate_check_callbacks().
 */
function checkmate_checkmate_check_callbacks() {
  $items = array();
  $items['checkmate_manual_check'] = array(
    'label' => t('Manual check'),
    'callback' => 'checkmate_manual_check',
  );
  $items['checkmate_is_module_enabled'] = array(
    'label' => t('Is module enabled'),
    'callback' => 'checkmate_is_module_enabled',
    'arguments' => array(
      'checkmate_module_name' => array(
        '#type' => 'textfield',
        '#title' => t('Module'),
        '#description' => t('The name of the module that should be enabled.'),
        '#required' => TRUE,
      ),
    ),
  );
  $items['checkmate_is_module_disabled'] = array(
    'label' => t('Is module disabled'),
    'callback' => 'checkmate_is_module_disabled',
    'arguments' => array(
      'checkmate_module_name' => array(
        '#type' => 'textfield',
        '#title' => t('Module'),
        '#description' => t('The name of the module that should be disabled.'),
        '#required' => TRUE,
      ),
    ),
  );
  $items['checkmate_is_variable_not_empty'] = array(
    'label' => t('Is variable not empty'),
    'callback' => 'checkmate_is_variable_not_empty',
    'arguments' => array(
      'checkmate_variable_name' => array(
        '#type' => 'textfield',
        '#title' => t('Variable'),
        '#description' => t('The name of the variable that should not be empty.'),
        '#required' => TRUE,
      ),
    ),
  );
  $items['checkmate_is_cron_enabled'] = array(
    'label' => t('Is cron enabled'),
    'callback' => 'checkmate_is_cron_enabled',
  );
  return $items;
}

/**
 * Callback function for manual checks.
 * Loads the status from the variables.
 */
function checkmate_manual_check($checkmate_item, $checkmate_data = array()) {
  $statuses = checkmate_item_status_load_multiple(FALSE, array('cid' => $checkmate_item->cid) + $checkmate_data);
  foreach ($statuses as &$status) {
    $status = entity_metadata_wrapper('checkmate_item_status', $status);
  }
  return $statuses;
}

/**
 * Callback function to check if a module is enabled.
 */
function checkmate_is_module_enabled($checkmate_item, $module) {
  if (!module_exists($module)) {
    $status = CHECKMATE_STATUS_NOK;
    $message = t('Module is not enabled');
    $solution = t('Enable the module on the !settings_url page', array('!settings_url' => l(t('module'), 'admin/modules')));
  }
  else {
    $status = CHECKMATE_STATUS_OK;
    $message = t('Module is enabled');
    $solution = '';
  }

  return array(
    'status' => $status,
    'message' => $message,
    'solution' => $solution,
  );
}

/**
 * Callback function to check if a variable is empty.
 */
function checkmate_is_variable_not_empty($checkmate_item, $variable_name) {
  $variable = variable_get($variable_name, '');
  if (empty($variable)) {
    $message = t('Variable :name is empty.', array(':name' => $variable_name));
  }
  else {
    $variable_value = serialize($variable);
    if (drupal_strlen($variable_value) > 20) {
      $variable_value = drupal_substr($variable_value, 0, 20) . '...';
    }
    $message = t('Variable :name has value :value.', array(
      ':name' => $variable_name,
      ':value' => $variable_value,
    ));
  }
  return array(
    'message' => $message,
    'status' => empty($variable) ? CHECKMATE_STATUS_NOK : CHECKMATE_STATUS_OK,
  );
}

/**
 * Callback function to check if a module is enabled.
 */
function checkmate_is_module_disabled($checkmate_item, $module) {
  if (module_exists($module)) {
    $status = CHECKMATE_STATUS_NOK;
    $message = t('Module is still enabled');
    $solution = t('Disable the module on the !settings_url page', array('!settings_url' => l(t('module'), 'admin/modules')));
  }
  else {
    $status = CHECKMATE_STATUS_OK;
    $message = t('Module is disabled');
    $solution = '';
  }

  return array(
    'status' => $status,
    'message' => $message,
    'solution' => $solution,
  );
}

/**
 * Callback function for the cron check.
 */
function checkmate_is_cron_enabled($checkmate_item) {
  $status = CHECKMATE_STATUS_NOT_CHECKED;
  $now = time();

  $last_run = variable_get('cron_last', 0);
  if ($last_run < $now - (24 * 3600)) {
    $status = CHECKMATE_STATUS_NOK;
    $message = t('Cron has not run in the last 24 hours (@last)', array('@last' => format_date($last_run)));
    $solution = t('Ask the system administrator to enable the cron');
  }
  else {
    $status = CHECKMATE_STATUS_OK;
    $message = t('Cron has run at @last', array('@last' => format_date($last_run)));
    $solution = '';
  }

  return array(
    'status' => $status,
    'message' => $message,
    'solution' => $solution,
  );
}

/**
 * Deletes any field instance attached to entities of the specified type,
 */
function checkmate_delete_instances($entity_type) {
  // Prepare a parameters array to load the specified instances.
  $params = array(
    'entity_type' => $entity_type,
  );

  // Read and delete the matching field instances.
  foreach (field_read_instances($params, array('include_inactive' => TRUE)) as $instance) {
    checkmate_delete_instance($instance);
  }

  // Since this is a function called on uninstall, now is a good time
  // to clear bundle display settings.
  $settings = variable_get('field_bundle_settings', array());
  if (isset($settings[$entity_type])) {
    if (isset($bundle)) {
      unset($settings[$entity_type][$bundle]);
    }
    else {
      unset($settings[$entity_type]);
    }
    variable_set('field_bundle_settings', $settings);
  }
}

/**
 * Deletes the specified instance and handles field cleanup manually in case the
 * instance is of a disabled field.
 *
 * @param object $instance
 *   The field instance info array to be deleted.
 */
function checkmate_delete_instance($instance) {
  // First activate the instance's field if necessary.
  $field_name = $instance['field_name'];
  $activated = checkmate_activate_field($field_name);

  // Then delete the instance.
  field_delete_instance($instance, FALSE);

  // Now check to see if there are any other instances of the field left.
  $field = field_info_field($field_name);

  if (count($field['bundles']) == 0) {
    field_delete_field($field_name);
  }
  elseif ($activated) {
    // If there are remaining instances but the field was originally disabled,
    // disabled it again now.
    $field['active'] = 0;
    field_update_field($field);
  }
}

/**
 * Attempts to directly activate a field that was disabled due to its module
 * being disabled.
 *
 * The normal API function for updating fields, field_update_field(), will not
 * work on disabled fields. As a workaround, this function directly updates the
 * database and clears the field cache if necessary.
 *
 * @param string $field_name
 *   The name of the field to activate.
 *
 * @return boolean
 *   indicating whether or not the field was activated.
 */
function checkmate_activate_field($field_name) {
  // Set it to active via a query because field_update_field() does
  // not work on inactive fields.
  $updated = db_update('field_config')
  ->fields(array('active' => 1))
  ->condition('field_name', $field_name, '=')
  ->execute();

  // If a row was actually updated...
  if ($updated) {
    // Clear the field cache to refresh the field info data.
    field_cache_clear();
    return TRUE;
  }

  return FALSE;
}

/**
 * Enables and deletes fields of the specified type.
 *
 * @param string $type
 *   The type of fields to enable and delete.
 */
function checkmate_delete_fields($type) {
  // Read the fields for any active or inactive field of the specified type.
  foreach (field_read_fields(array('type' => $type), array('include_inactive' => TRUE)) as $field_name => $field) {
    checkmate_delete_field($field_name);
  }
}

/**
 * Enables and deletes the specified field.
 *
 * The normal API function for deleting fields, field_delete_field(), will not
 * work on disabled fields. As a workaround, this function first activates the
 * fields of the specified type and then deletes them.
 *
 * @param string $field_name
 *   The name of the field to enable and delete.
 */
function checkmate_delete_field($field_name) {
  // In case the field is inactive, first activate it.
  checkmate_activate_field($field_name);

  // Delete the field.
  field_delete_field($field_name);
}
