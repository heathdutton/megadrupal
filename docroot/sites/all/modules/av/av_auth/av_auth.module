<?php
/**
 * @file av_auth.module
 * Provides authentication against an AudienceView server which has WebAPI
 * enabled. Code adapted from:
 * http://yetanotherprogrammingblog.com/content/drupal-7-external-authentication-sample-code
 */

/**
 * Implement hook_help() to display a small help message if somebody clicks the "Help" link on the modules list.
 */
function av_auth_help($path, $arg) {
  switch ($path) {
    case 'admin/help#av_auth':
      return ('<p>' . t('This module allows users who login with e-mail addresses to authenticate using AudienceView.') . '</p>');
  }
}

/**
 * Implement hook_form_alter() to change the behaviour of the login form.
 *
 * Login validators are set in the user_login_default_validators() function in user.module.
 * They are normally set to array('user_login_name_validate',
 * 'user_login_authenticate_validate', 'user_login_final_validate').
 * We simply replace 'user_login_authenticate_validate' with 'av_auth_login_validate'.
 */
function av_auth_form_user_login_alter(&$form, $form_state) {
  unset($form['links']);
  $form['#validate'] = array( 'user_login_name_validate', 'av_auth_login_validate', 'user_login_final_validate' );
}

function av_auth_form_user_login_block_alter(&$form, $form_state) {
  return av_auth_form_user_login_alter($form, $form_state);
}

/**
* Implement hook_user_profile_form_alter() to disable the ability to change email address and
* password for externally authenticated users.
*/
function av_auth_form_user_profile_form_alter(&$form, $form_state) {
  if (strpos( $form['#user']->name, '@' ) !== FALSE) {
    $form['account']['name']['#disabled'] = TRUE;
    $form['account']['name']['#description'] = t('The username for this account cannot be changed');
    $form['account']['mail']['#disabled'] = TRUE;
    $form['account']['mail']['#description'] = t('This e-mail address for this account cannot be changed.');
    $form['account']['current_pass']['#disabled'] = TRUE;
    $form['account']['current_pass']['#description'] = t('Neither the email address or password for this account can be changed.');
    $form['account']['pass']['#disabled'] = TRUE;
    $form['account']['pass']['#description'] = t('The password for this account cannot be changed.');
  }
}

/**
* The av_auth_login_validate() function attempts to authenticate a user off the external system
* using their e-mail address.
*/
function av_auth_login_validate($form, &$form_state) {
  global $user;

  $username = $form_state['values']['name'];

  // In our case we're assuming that any username with an '@' sign is an e-mail address,
  // hence we're going to check the credentials against our external system.
  if (strpos( $username, '@' ) !== FALSE) {
    // Looks like we found them - now we need to check if the password is correct
    if ( av_login( $username, $form_state['values']['pass'] )) {
      user_external_login_register( $username, 'av_auth' );
      // I wish we didn't have to do this, but I couldn't find any other way to get the
      // uid at this point
      $form_state['uid'] = $user->uid;
      } // else drop through to the end and return nothing - Drupal will handle the rejection
  }
  else {
    // Username is not an e-mail address, so use standard Drupal authentication function
    user_login_authenticate_validate( $form, $form_state );
  }
}

/**
* The av_auth_user_insert() function gets called by Drupal AFTER a new user has been added.
* If the e-mail address has already been set then we don't want to overwrite it, as the user
* is probably being added manually. Thankfully the only time a user can be added without the
* e-mail being set is when an external user gets authenticated for the first time, at which
* point a user is inserted into the database without an e-mail address, which is the case we
* will deal with in this function.
*/
function av_auth_user_insert(&$edit, &$account, $category = NULL) {
  // Remember: this function gets called whenever a new user is added, not just when a new
  // user is being added as a result of them being externally authenticated. So we need to
  // avoid running the following checks if the user is being added by some other means (eg.
  // manually by the administrator). In this simple example we're assuming that any user ID
  // that is an email address is externally authenticated. However, there are possibly
  // better ways to do this, such as look up the authmaps table and see if there is a row
  // for this user where module is 'av_auth'.
  if ( strpos( $account->name, '@' ) !== FALSE ) {
    // This hook is called during the registration process, AFTER the new user has been
    // added to the users table but BEFORE the roles are written to the users_roles table
    if ( empty( $account->mail )) {
      db_update( 'users' )->fields( array( 'mail' => $account->name ))
                          ->condition( 'uid', $account->uid, '=' )
                          ->execute();
    }

    // Note: you can do other stuff here, like set the password to be the md5 hash of the
    // remote password. This might be handy if you wanted to allow people to log on when
    // the external system is unavailable, but, of course, it introduces the hassle of
    // keeping the passwords in sync.

    // This is where we set that additional role to indicate that the user is authenticated
    // externally. Note that EXTERNAL_AUTH_RID is defined as 3 in this sample code but you
    // should set it to whatever Role ID is appropriate in your case, eg. create the new
    // role, do a query to find the RID for that role and set EXTERNAL_AUTH_RID to that RID.
    // $account->roles[EXTERNAL_AUTH_RID] = 'external user';
  }
}
