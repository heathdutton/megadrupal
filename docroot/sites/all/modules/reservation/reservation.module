<?php

/**
 * @file
 * Defines the functionality of the Reservation module.
 */

/**
 * Reservation is not approved.
 */
define('RESERVATION_NOT_APPROVED', 0);

/**
 * Reservation is approved.
 */
define('RESERVATION_APPROVED', 1);

/**
 * Implements hook_entity_info().
 */
function reservation_entity_info() {
  $return = array(
    'reservation' => array(
      'label' => t('Reservation'),
      'plural label' => t('Reservations'),
      'entity class' => 'Reservation',
      'controller class' => 'ReservationController',
      'base table' => 'reservation',
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'reservation_id',
        'bundle' => 'unit',
        'label' => 'title',
      ),
      'bundle keys' => array(
        'bundle' => 'unit',
      ),
      'bundles' => array(),
      'label callback' => 'entity_class_label',
      'uri callback' => 'entity_class_uri',
      'access callback' => 'reservation_access',
      'module' => 'reservation',
      'admin ui' => array(
        'path' => 'admin/reservation',
        'file' => 'reservation.admin.inc',
        'controller class' => 'ReservationUIController',
        'menu wildcard' => '%reservation',
      ),
    ),
    'reservation_unit' => array(
      'label' => t('Reservation unit'),
      'plural label' => t('Reservation units'),
      'entity class' => 'ReservationUnit',
      'controller class' => 'ReservationUnitController',
      'base table' => 'reservation_unit',
      'exportable' => TRUE,
      'entity keys' => array(
        'id' => 'unit',
        'label' => 'name',
      ),
      'bundle of' => 'reservation',
      'access callback' => 'reservation_unit_access',
      'module' => 'reservation',
      'admin ui' => array(
        'path' => 'admin/reservation/units',
        'file' => 'reservation.admin.inc',
        //'controller class' => 'ReservationTypeUIController',
        'menu wildcard' => '%reservation_unit',
      ),
    ),
  );

  $units = db_select('reservation_unit', 'ru')
    ->fields('ru')
    ->execute()
    ->fetchAllAssoc('unit');

  foreach ($units as $id => $unit) {
    $return['reservation']['bundles'][$id] = array(
      'label' => $unit->name,
      'admin' => array(
        'path' => 'admin/reservation/units/manage/%reservation_unit',
        'real path' => 'admin/reservation/units/manage/' . $id,
        'bundle argument' => 4,
        'access arguments' => array('administer reservation units'),
      ),
    );
  }

  return $return;
}

function reservation_entity_property_info_alter(&$info) {
  // Update Reservation entity property descriptions.
  $properties = &$info['reservation']['properties'];

  $properties['unit']['description'] = t('The reserved unit.');
  $properties['title']['label'] = t('Title');
  $properties['title']['description'] = t('The title of the reservation.');
  $properties['uid']['description'] = t('The ID of the user who made the reservation.');
  $properties['status']['description'] = t('Whether the reservation is approved or not.');
  $properties['created']['description'] = t('The date the reservation was made.');
  $properties['changed']['description'] = t('The date the reservation was last changed.');
  $properties['url']['description'] = t('The URL of the reservation.');

  // Update Reservation Unit entity property descriptions.
  $properties = &$info['reservation_unit']['properties'];

  $properties['name']['label'] = t('Name');
  $properties['name']['description'] = t('The name of the reservation unit.');
  $properties['description']['description'] = t('The description of the reservation unit.');
  $properties['module']['description'] = t('The module that provides the reservation unit.');
  $properties['status']['description'] = t('The status of the reservation unit.');
}

/**
 * Implements hook_permission().
 */
function reservation_permission() {
  return array(
    'administer reservation units' => array(
      'title' => t('Administer reservation units'),
    ),
    'administer reservations' => array(
      'title' => t('Administer reservations'),
    ),
    'create reservations' => array(
      'title' => t('Create reservations'),
    ),
    'view any reservation' => array(
      'title' => t('View any reservation'),
    ),
    'view own reservations' => array(
      'title' => t('View own reservations'),
    ),
    'edit any reservation' => array(
      'title' => t('Edit any reservation'),
    ),
    'edit own reservations' => array(
      'title' => t('Edit own reservations'),
    ),
    'delete any reservation' => array(
      'title' => t('Delete any reservation'),
    ),
    'delete own reservations' => array(
      'title' => t('Delete own reservations'),
    ),
  );
}

/**
 * Implements hook_admin_paths().
 */
function reservation_admin_paths() {
  $paths = array(
    'reservation/*/edit' => TRUE,
    'reservation/*/reassign' => TRUE,
    'reservation/*/delete' => TRUE,
  );

  return $paths;
}

/**
 * Implements hook_admin_menu_output_build().
 */
function reservation_admin_menu_output_build(&$content) {
  $link = db_query("SELECT * FROM {menu_links} WHERE router_path = 'reservation/add' AND module = 'system'")->fetchAssoc();
  $conditions = array();
  for ($i = 1; $i < MENU_MAX_DEPTH; $i++) {
    if (!empty($link["p$i"])) {
      $conditions["p$i"] = $link["p$i"];
    }
  }
  $tree = menu_build_tree($link['menu_name'], array(
    'conditions' => $conditions,
    'min_depth' => $link['depth'],
  ));
  $links = admin_menu_links_menu($tree);

  $content['menu']['admin/reservation'] += $links;
}

/**
 * Implements hook_field_attach_create_bundle().
 */
function reservation_field_attach_create_bundle($entity_type, $bundle) {
  if ($entity_type = 'reservation') {
    $instance = field_info_instance($entity_type, 'reservation_date', $bundle);
    if (empty($instance)) {
      $instance = array(
        'field_name' => 'reservation_date',
        'entity_type' => $entity_type,
        'label' => t('Date'),
        'bundle' => $bundle,
        'widget' => array(
          'type' => 'date_select',
          'settings' => array(
            'year_range' => '-0:+1',
            'repeat_collapsed' => 0,
          ),
        ),
        'settings' => array(
          'default_value' => 'now',
          'default_value_code' => '',
          'default_value2' => 'strtotime',
          'default_value_code2' => '+1 hour',
        ),
        'required' => 1,
      );
      field_create_instance($instance);
    }
  }
}

/**
 * Implements hook_views_api().
 */
function reservation_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'reservation') . '/views',
  );
}

/**
 * Implement hook_theme().
 */
function reservation_theme() {
  return array(
    'reservation' => array(
      'render element' => 'elements',
      'template' => 'reservation',
    ),
    'reservation_add_list' => array(
      'variables' => array(
        'content' => array(),
      ),
    ),
  );
}

/**
 * Process variables for reservation.tpl.php.
 *
 * @see reservation.tpl.php
 */
function template_preprocess_reservation(&$variables) {
  $reservation = $variables['elements']['#reservation'];
  $variables['reservation'] = $reservation;
  $variables['view_mode'] = $variables['elements']['#view_mode'];
  $variables['title'] = check_plain($reservation->title);
  $uri = entity_uri('reservation', $reservation);
  $variables['reservation_url']  = url($uri['path'], $uri['options']);
  $variables['page'] = $variables['view_mode'] == 'full' && reservation_is_page($reservation);

  $variables['content'] = array();
  foreach (element_children($variables['elements']) as $key) {
    $variables['content'][$key] = $variables['elements'][$key];
  }

  field_attach_preprocess('reservation', $reservation, $variables['content'], $variables);

  $variables['classes_array'][] = drupal_html_class('reservation');
  $variables['classes_array'][] = drupal_html_class('reservation-' . $reservation->unit);

  $variables['theme_hook_suggestions'][] = 'reservation__' . $reservation->unit;
  $variables['theme_hook_suggestions'][] = 'reservation__' . $reservation->reservation_id;
}

/**
 * Determines if a reservation is the current page.
 *
 * @param  Reservation $reservation
 *   The reservation to check.
 *
 * @return boolean
 *   TRUE if the reservation is the current page, FALSE if it isn't.
 */
function reservation_is_page(Reservation $reservation) {
  $page_reservation = menu_get_object('reservation');
  if (empty($page_reservation)) {
    return FALSE;
  }
  elseif ($page_reservation->reservation_id == $reservation->reservation_id) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Access callback for Reservations.
 *
 * @param $op
 *   The operation being performed.
 * @param $reservation
 *   The reservation to check access for. If NULL, access for all reservations
 *   is returned.
 * @param $account
 *   The user to check for. If NULL, access is checked for the global user.
 *
 * @return boolean
 *   Whether access is allowed or not.
 *
 * @see user_access()
 */
function reservation_access($op, $reservation = NULL, $account = NULL) {
  if (!$account) {
    global $user;
    $account = $user;
  }

  if (user_access('administer reservations', $account)) {
    return TRUE;
  }

  if ($op == 'create' && user_access('create reservations', $account)) {
    return TRUE;
  }

  if (user_access("$op any reservation", $account)) {
    return TRUE;
  }

  if (isset($reservation) && $reservation->uid == $account->uid) {
    if (user_access("$op own reservations", $account)) {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Creates a reservation object.
 */
function reservation_create($values = array()) {
  return entity_get_controller('reservation')->create($values);
}

/**
 * Loads a single Reservation.
 *
 * @param $reservation_id
 *   Integer specifying the reservation id.
 * @param $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return
 *   A fully-loaded $reservation object or FALSE if it cannot be loaded.
 *
 * @see reservation_load_multiple()
 */
function reservation_load($reservation_id, $reset = FALSE) {
  $reservation = reservation_load_multiple(array($reservation_id), array(), $reset);

  return reset($reservation);
}


/**
 * Load multiple reservations.
 *
 * @param $reservation_ids
 *   An array of reservation IDs.
 * @param $conditions
 *   An array of conditions to match against the {reservation} table.
 * @param $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return
 *   An array of reservation objects, keyed by reservation_id.
 *
 * @see entity_load()
 * @see reservation_load()
 */
function reservation_load_multiple($reservation_ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('reservation', $reservation_ids, $conditions, $reset);
}

/**
 * Delete a single reservation.
 *
 * @param integer $reservation_id
 *   The reservation_id of the reservation to delete.
 */
function reservation_delete($reservation_id) {
  entity_delete_multiple('reservation', array($reservation_id));
}

/**
 * Delete multiple reservations.
 *
 * @param array $reservation_ids
 *   An array of reservation_ids to delete.
 */
function reservation_delete_multiple($reservation_ids) {
  entity_delete_multiple('reservation', $reservation_ids);
}

/**
 * Title callback for reservations.
 *
 * @param Reservation $reservation
 *   The reservation to set the title for.
 *
 * @return string
 *   The reservation title.
 */
function reservation_page_title(Reservation $reservation) {
  return $reservation->title;
}

/**
 * Renders content for a single reservation.
 *
 * @param Reservation $reservation
 *   The reservation to render.
 * @param $view_mode
 *   The view mode to use for rendering.
 *
 * @return
 *   The rendered reservation.
 */
function reservation_page_view(Reservation $reservation, $view_mode = 'full') {
  $reservation_arr = array($reservation->reservation_id => $reservation);
  $content = entity_get_controller('reservation')->view($reservation_arr);
  drupal_set_title($reservation->title);

  return $content;
}

/**
 * Access callback for Reservation units.
 *
 * @param $op
 *   The operation being performed.
 * @param $unit
 *   The unit to check access for. If NULL, access for all units is returned.
 * @param $account
 *   The user to check for. If NULL, access is checked for the global user.
 *
 * @return boolean
 *   Whether access is allowed or not.
 *
 * @see user_access()
 */
function reservation_unit_access($op, $unit = NULL, $account = NULL) {
  return user_access('administer reservation units', $account);
}

/**
 * Load a reservation unit by string.
 *
 * @param $unit
 *   The machine-readable name of the reservation unit to load.
 * @param $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return
 *   A fully-loaded $reservation_unit object or FALSE if it cannot be loaded.
 *
 * @see reservation_get_units()
 */
function reservation_unit_load($unit, $reset = FALSE) {
  return reservation_get_units($unit, $reset);
}

/**
 * Get all reservation units.
 *
 * @param $unit
 *   The reservation unit to  get. If NULL, all units are returned.
 * @param $reset
 *   A boolean indicating that the internal cache should be reset.
 *
 * @return array
 *   An array of reservation units keyed by unit.
 *
 * @see entity_load()
 */
function reservation_get_units($unit = NULL, $reset = FALSE) {
  if (!$reset) {
    $units = &drupal_static(__FUNCTION__);
  }

  if (empty($units)) {
    $units = entity_load_multiple_by_name('reservation_unit', isset($unit) ? array($unit) : FALSE);
  }

  return isset($unit) ? reset($units) : $units;
}

/**
 * Check if a reservation unit already exists.
 *
 * @param string $unit
 *   The machine name of a reservation unit.
 *
 * @return boolean
 *   A boolean indicating if the reservation unit already exists.
 */
function reservation_unit_exists($unit) {
  $exists = db_query_range('SELECT 1 FROM {reservation_unit} WHERE unit=:unit', 0, 1,
    array(':unit' => $unit))->fetchField();
  return (bool) $exists;
}

/**
 * Get a reservation unit name.
 *
 * @param string $unit
 *   The reservation unit to get the name of.
 *
 * @return string
 *   The name of the reservation unit.
 */
function reservation_unit_get_name($unit) {
  $name = db_query('SELECT name FROM {reservation_unit} WHERE unit=:unit',
    array(':unit' => $unit))->fetchField();

  return $name;
}

/**
 * Displays the list of available reservation units for reservation creation.
 *
 * @ingroup themeable
 */
function theme_reservation_add_list($variables) {
  $content = $variables['content'];
  $output = '';
  if ($content) {
    $output = '<ul class="admin-list">';
    foreach ($content as $item) {
      $output .= '<li>';
      $output .= '<span class="label">' . l($item['title'], $item['href']) . '</span>';
      $output .= '<div class="description">' . filter_xss_admin($item['description']) . '</div>';
      $output .= '</li>';
    }
    $output .= '</ul>';
  }
  else {
    if (user_access('administer reservation units')) {
      $output = '<p>' . t('Reservations cannot be added because you have not created any reservation units yet. Go to the <a href="@create-reservation-unit">reservation unit creation page</a> to add a new unit.', array('@create-reservation-unit' => url('admin/reservation/units/add'))) . '</p>';
    }
    else {
      $output = '<p>' . t('No reservation units have been created yet.') . '</p>';
    }
  }

  return $output;
}

/**
 * Checks if a unit is available to be reserved at the requested time.
 *
 * @param $reservation
 *   The reservation to check.
 * @param $date
 *   The date to check.
 * @param $field
 *   The date field to use to check the times.
 * @param $before
 *   The amount of time, in minutes, to add to the beginning of a reservation.
 * @param $after
 *   The amount of time, in minutes, to add to the end of a reservation.
 *
 * @return boolean
 *   TRUE if the unit is available, FALSE if it isn't.
 */
function reservation_available(Reservation $reservation, $date, $field, $before = 0, $after = 0) {
  $between = $before + $after;
  $start = strtotime("-$between minutes", $date['value']);
  $end = strtotime("+$after minutes", $date['value2']);

  $and1 = db_and()
    ->condition("d.{$field}_value", $start, '<=')
    ->condition("d.{$field}_value2", $start, '>');
  $and2 = db_and()
    ->condition("d.{$field}_value", $end, '<')
    ->condition("d.{$field}_value2", $end, '>=');
  $and3 = db_and()
    ->condition("d.{$field}_value", $start, '>=')
    ->condition("d.{$field}_value2", $end, '<=');

  $or = db_or()
    ->condition($and1)
    ->condition($and2)
    ->condition($and3);

  $query = db_select('reservation', 'r');
  $query->join("field_data_{$field}", 'd', 'd.entity_id = r.reservation_id');
  $query->fields('r', array('reservation_id'))
    ->condition('r.unit', $reservation->unit)
    ->condition('d.entity_type', 'reservation')
    ->condition('d.entity_id', $reservation->reservation_id, '!=')
    ->condition($or);
  $results = $query->execute();

  $reservations = array();
  foreach ($results as $result) {
    $reservations[] = $result->reservation_id;
  }

  if (empty($reservations)) {
    return TRUE;
  }

  return FALSE;
}

/**
 * Check if a user is allowed to make a reservation.
 *
 * @param Reservation $reservation
 *   The reservation being created.
 * @param object $accout
 *   The user object of the user making the reservation.
 *
 * @return boolean
 *   TRUE if the user is allowed to make the reservation, FALSE if not.
 */
function reservation_user_allowed(Reservation $reservation, $account = NULL) {
  if (empty($account)) {
    global $user;
    $account = $user;
  }

  $allowed = FALSE;

  if (reservation_access('create', $reservation, $account)) {
    $allowed = TRUE;
  }

  drupal_alter('reservation_user_allowed', $allowed, $reservation, $account);

  return $allowed;
}
