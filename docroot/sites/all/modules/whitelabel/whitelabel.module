<?php
/**
 * @file
 * Provides white label functionality.
 *
 * This module adds white label functionality to Drupal by allowing certain
 * roles to upload custom logo's and color schemes. Color schemes require a
 * theme that is compatible with core's color module.
 */

/**
 * Implements hook_boot().
 *
 * Set the session variable if we came in with a white labelled url, so the logo
 * persists across pages without the need to rewrite internal url's.
 */
function whitelabel_boot() {
  // See if there was a white label parameter provided.
  if (isset($_GET['wl'])) {
    $whitelabel = _whitelabel_get_whitelabel(0, check_plain($_GET['wl']));

    if (!empty($whitelabel)) {
      $_SESSION['whitelabel'] = $whitelabel['uid'];
    }
    else {
      unset($_SESSION['whitelabel']);
    }
  }
}

/**
 * Implements hook_preprocess_HOOK().
 *
 * Themes that are compatible with the color module call _color_page_alter() in
 * THEME_process_page() in order to load the right logo. Since we store the logo
 * in a different way, we do some logic to override the logo variable.
 *
 * @see hook_preprocess_HOOK()
 */
function whitelabel_preprocess_page(&$variables) {
  if (!empty($_SESSION['whitelabel'])) {
    $ref = $_SESSION['whitelabel'];

    // Check if wl is linked to a user that was allowed to use white labels.
    if ($u = user_load($ref)) {
      if (!user_access('serve white label pages', $u)) {
        unset($_SESSION['whitelabel']);
        return;
      }

      $whitelabel = _whitelabel_get_whitelabel($u->uid);

      if (!empty($whitelabel)) {
        if ($file = file_load($whitelabel['logo'])) {
          $variables['logo'] = file_create_url($file->uri);
        }
      }
    }
  }
}

/**
 * Implements hook_preprocess_HOOK().
 *
 * Themes that are compatible with the color module call _color_html_alter() in
 * THEME_process_html() to replace the color stylesheet. Since this is the
 * latest step in processing we can't change the css file there, thus we need to
 * append another css file at the end of the list of stylesheets.
 *
 * @see hook_theme()
 * @see _color_html_alter()
 */
function whitelabel_preprocess_html(&$variables) {
  if (!empty($_SESSION['whitelabel'])) {
    $ref = $_SESSION['whitelabel'];

    // Check if wl is linked to a user that was allowed to use white labels.
    if ($u = user_load($ref)) {
      if (!user_access('serve white label pages', $u)) {
        unset($_SESSION['whitelabel']);
        return;
      }

      $whitelabel = _whitelabel_get_whitelabel($u->uid);

      foreach (explode(',', $whitelabel['stylesheets']) as $stylesheet) {
        drupal_add_css(
          $stylesheet,
          array(
            'group' => CSS_THEME,
          )
        );
      }
    }
  }
}

/**
 * Implements hook_url_outbound_alter().
 *
 * Appends a 'wl' query parameter to all external (outbound) url's.
 */
function whitelabel_url_outbound_alter(&$path, &$options, $original_path) {
  // Get referral hash.
  global $user;

  $whitelabel = _whitelabel_get_whitelabel($user->uid);

  // Append referral token to all external non-admin url's.
  if (!empty($whitelabel) && $options['absolute'] && !stripos($path, 'admin/') && !stripos($path, 'ajax')) {
    $options['query']['wl'] = $whitelabel['hash'];
  }
}

/**
 * Implements hook_permission().
 */
function whitelabel_permission() {
  return array(
    'serve white label pages' => array(
      'title' => t('Serve white label pages'),
      'description' => t('Allows the user to append a white label token to urls to provide a customised website.'),
    ),
  );
}

/**
 * Implements hook_field_extra_fields().
 */
function whitelabel_field_extra_fields() {
  $extra['user']['user'] = array(
    'form' => array(
      'whitelabel' => array(
        'label' => t('White label settings'),
        'description' => t('White label logo and color scheme settings'),
        'weight' => 10,
      ),
    ),
  );
  return $extra;
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Appends the white label options to the user profile form.
 */
function whitelabel_form_user_profile_form_alter(&$form, &$form_state) {
  // Skip altering the form if we are not allowed to do this.
  if (user_access('serve white label pages')) {
    // Set default values.
    $whitelabel = _whitelabel_get_whitelabel(check_plain($form['#user']->uid));
    $form_state['#whitelabel_original'] = $whitelabel;

    $form['whitelabel'] = array(
      '#type' => 'fieldset',
      '#title' => t('White label settings'),
      '#collapsible' => TRUE,
      '#collapsed' => FALSE,
    );

    $form['whitelabel']['whitelabel_logo'] = array(
      '#type' => 'managed_file',
      '#title' => t('Choose a site logo'),
      '#description' => t("This logo will replace the default website logo for your white label url's."),
      '#default_value' => (!empty($whitelabel['logo'])) ? $whitelabel['logo'] : NULL,
      '#upload_validators' => array('file_validate_is_image'),
      '#upload_location' => 'public://whitelabel',
    );

    // Color settings here.
    if (module_exists('color')) {
      $theme = $form['#user']->theme ? check_plain($form['#user']->theme) : variable_get('theme_default', 'bartik');

      if (color_get_info($theme) && function_exists('gd_info')) {
        $form['whitelabel']['color'] = array(
          '#type' => 'fieldset',
          '#title' => t('Color scheme'),
          '#weight' => 10,
          '#attributes' => array('id' => 'color_scheme_form'),
          '#theme' => 'color_scheme_form',
        );
        $form['whitelabel']['color'] += color_scheme_form($form, $form_state, $theme);

        // Override color settings.
        $info = color_get_info($theme);

        $info['schemes'][''] = array('title' => t('Custom'), 'colors' => array());
        $color_sets = array();
        $schemes = array();
        foreach ($info['schemes'] as $key => $scheme) {
          $color_sets[$key] = $scheme['title'];
          $schemes[$key] = $scheme['colors'];
          $schemes[$key] += $info['schemes']['default']['colors'];
        }

        // See if we're using a predefined scheme.
        // Note: we use the original theme when the default scheme is chosen.
        $current_scheme = json_decode($whitelabel['palette'], TRUE);
        foreach ($schemes as $key => $scheme) {
          if ($current_scheme == $scheme) {
            $scheme_name = $key;
            break;
          }
        }
        if (empty($scheme_name)) {
          if (empty($current_scheme)) {
            $scheme_name = 'default';
          }
          else {
            $scheme_name = '';
          }
        }

        $form['whitelabel']['color']['scheme']['#options'] = $color_sets;
        $form['whitelabel']['color']['scheme']['#default_value'] = $scheme_name;

        $form['whitelabel']['color']['scheme']['#attached']['js'] = array(
          drupal_get_path('module', 'whitelabel') . '/whitelabel.js',
          array(
            'data' => array(
              'color' => array(
                'reference' => color_get_palette($theme, TRUE),
                'schemes' => $schemes,
              ),
              'gradients' => $info['gradients'],
            ),
            'type' => 'setting',
          ),
        );

        // Add palette fields.
        $palette = json_decode($whitelabel['palette'], TRUE);

        $names = $info['fields'];
        $form['whitelabel']['color']['palette']['#tree'] = TRUE;
        foreach ($palette as $name => $value) {
          if (isset($names[$name])) {
            $form['whitelabel']['color']['palette'][$name] = array(
              '#type' => 'textfield',
              '#title' => check_plain($names[$name]),
              '#value_callback' => 'color_palette_color_value',
              '#default_value' => $value,
              '#size' => 8,
            );
          }
        }

        $form['#validate'][] = 'color_scheme_form_validate';
      }
    }

    // Set additional submit handler.
    $form['#submit'][] = 'whitelabel_user_profile_form_submit';
  }
}

/**
 * Implements hook_form_submit().
 */
function whitelabel_user_profile_form_submit(&$form, &$form_state) {
  $account = $form_state['user'];
  $logo = $form_state['values']['whitelabel_logo'];
  $palette = $form_state['values']['palette'];
  $stylesheets = array();

  // If the logo is unchanged, do not preocess it.
  if ($logo != $form_state['#whitelabel_original']['logo']) {
    if (!empty($logo)) {
      // If a new logo was provided, save it permanently.
      $file = file_load($logo);
      $file->status = FILE_STATUS_PERMANENT;
      $file = file_save($file);
      file_usage_add($file, 'whitelabel', 'whitelabel_logo', $account->uid);
    }
    else {
      // In other cases handle the deletion of the old logo.
      if ($file = file_load($form_state['#whitelabel_original']['logo'])) {
        file_usage_delete($file, 'whitelabel', 'whitelabel_logo', $account->uid);
        file_delete($file);
      }
    }
  }

  if (!empty($palette)) {
    $stylesheets = _whitelabel_handle_stylesheets($account->uid, $palette, $form_state['values']['info'], $form_state['values']['theme']);
  }
  else {
    // TODO: Delete stylesheet(s).
  }

  // Save data in whitelabel table.
  db_merge('whitelabel')
    ->insertFields(array(
      'uid' => $account->uid,
      'hash' => md5($account->uid . drupal_get_hash_salt()),
      'logo' => $logo,
      'palette' => json_encode($palette),
      'stylesheets' => $stylesheets,
    ))
    ->updateFields(array(
      'logo' => $logo,
      'palette' => json_encode($palette),
      'stylesheets' => $stylesheets,
    ))
    ->key(array(
      'uid' => $account->uid,
    ))
    ->execute();
}

/**
 * Loads a whitelabel entry and stores it in static cache for quick serving.
 *
 * Since hook_boot also calls this function, this needs to be bootstrap safe!
 *
 * @param int $uid
 *   The user id to check for.
 * @param string $hash
 *   If we don't know the user, check for the hash instead.
 *
 * @return array|null
 *   Associative array of whitelabel properties from the db, NULL if none found.
 */
function _whitelabel_get_whitelabel($uid, $hash = NULL) {
  $whitelabel = &drupal_static(__FUNCTION__);

  if (!isset($whitelabel[$uid])) {
    // We are to lookup an entry by hash?
    if (!empty($hash)) {
      $result = db_query('SELECT * FROM {whitelabel} w WHERE w.hash = :hash',
        array(':hash' => check_plain($hash)));
      $entry = $result->fetchAssoc();
      if ($entry) {
        $uid = $entry['uid'];
        $whitelabel[$uid] = $entry;
      }
      else {
        return NULL;
      }
    }
    else {
      $result = db_query('SELECT * FROM {whitelabel} w WHERE w.uid = :uid',
        array(':uid' => check_plain($uid)));
      $entry = $result->fetchAssoc();
      if ($entry) {
        $whitelabel[$uid] = $entry;
      }
      else {
        return NULL;
      }
    }
  }
  return $whitelabel[$uid];
}

/**
 * Generates and saves the stylesheet(s) for individual users.
 *
 * @param int $uid
 *   The uid to save the stylesheet for.
 * @param array $palette
 *   The color palette from the form.
 * @param array $info
 *   The info from theme's color.inc.
 * @param string $theme
 *   The name of the current theme.
 *
 * @return string
 *   Comma separated list of generated stylesheets.
 */
function _whitelabel_handle_stylesheets($uid, array $palette, array $info, $theme) {
  $paths['whitelabel'] = 'public://whitelabel';
  $paths['target'] = $paths['whitelabel'] . '/' . $uid;
  foreach ($paths as $path) {
    file_prepare_directory($path, FILE_CREATE_DIRECTORY);
  }
  $paths['target'] = $paths['target'] . '/';
  $paths['source'] = drupal_get_path('theme', $theme) . '/';
  $paths['files'] = $paths['map'] = array();

  // Copy over neutral images.
  foreach ($info['copy'] as $file) {
    $base = drupal_basename($file);
    $source = $paths['source'] . $file;
    $filepath = file_unmanaged_copy($source, $paths['target'] . $base);
    $paths['map'][$file] = $base;
    $paths['files'][] = $filepath;
  }

  // Render new images, if image has been provided.
  if ($info['base_image']) {
    _color_render_images($theme, $info, $paths, $palette);
  }

  // Rewrite theme stylesheets.
  $css = array();
  foreach ($info['css'] as $stylesheet) {
    // Build a temporary array with LTR and RTL files.
    $files = array();
    if (file_exists($paths['source'] . $stylesheet)) {
      $files[] = $stylesheet;

      $rtl_file = str_replace('.css', '-rtl.css', $stylesheet);
      if (file_exists($paths['source'] . $rtl_file)) {
        $files[] = $rtl_file;
      }
    }

    foreach ($files as $file) {
      // Aggregate @imports recursively for each configured top level CSS file
      // without optimization. Aggregation and optimization will be handled by
      // drupal_build_css_cache() only.
      $style = drupal_load_stylesheet($paths['source'] . $file, FALSE);

      // Return the path to where this CSS file originated from, stripping
      // off the name of the file at the end of the path.
      $base = base_path() . dirname($paths['source'] . $file) . '/';
      _drupal_build_css_path(NULL, $base);

      // Prefix all paths within this CSS file, ignoring absolute paths.
      $style = preg_replace_callback('/url\([\'"]?(?![a-z]+:|\/+)([^\'")]+)[\'"]?\)/i', '_drupal_build_css_path', $style);

      // Rewrite stylesheet with new colors.
      $style = _color_rewrite_stylesheet($theme, $info, $paths, $palette, $style);
      $base_file = drupal_basename($file);
      $css[] = $paths['target'] . $base_file;
      _color_save_stylesheet($paths['target'] . $base_file, $style, $paths);
    }
  }

  return implode(',', $css);
}
