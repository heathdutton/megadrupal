<?php

/**
 * @file parse.module
 * Integrates posting to push notification service Parse depending on configurable
 * criteria.
 */

/**
 * Implements hook_menu().
 */
function parse_menu() {
  $items = array();
  $items['admin/config/services/parse'] = array(
    'title' => 'Parse',
    'description' => t('Configure Parse REST API settings.'),
    'page callback' => 'parse_menu_page',
    'access callback' => 'parse_can_administer',
    'file' => 'parse.admin.inc',
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/config/services/parse/settings'] = array(
    'title' => 'Settings',
    'description' => t('Configure Parse REST API settings.'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('parse_admin_settings'),
    'access callback' => 'user_access',
    'access arguments' => array('administer parse api settings'),
    'file' => 'parse.admin.inc',
    'type' => MENU_NORMAL_ITEM,
    'weight' => 0,
  );
  $items['admin/config/services/parse/rules'] = array(
    'title' => 'Content Based Rules',
    'description' => t('View configured Parse rules.'),
    'page callback' => 'parse_rules',
    'access callback' => 'user_access',
    'access arguments' => array('administer parse'),
    'file' => 'parse.admin.inc',
    'type' => MENU_NORMAL_ITEM,
    'weight' => 1,
  );
  $items['admin/config/services/parse/rules/add'] = array(
    'title' => 'Add A Rule',
    'description' => t('Add a push notification rule.'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('parse_add_rule_form'),
    'access arguments' => array('administer parse'),
    'file' => 'parse.admin.inc',
    'type' => MENU_LOCAL_ACTION,
  );
  $items['admin/config/services/parse/rules/edit/%'] = array(
    'title' => t('Modify An Existing Rule'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('parse_add_rule_form', 6),
    'access callback' => 'user_access',
    'access arguments' => array('administer parse'),
    'file' => 'parse.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/services/parse/rules/delete/%'] = array(
    'title' => 'Delete A Rule',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('parse_rule_delete_confirm_form', 6),
    'access callback' => 'user_access',
    'access arguments' => array('administer parse'),
    'file' => 'parse.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/services/parse/automated'] = array(
    'title' => 'Instant & Automated Rules',
    'description' => t('Upcoming automated pushes.'),
    'page callback' => 'parse_automated',
    'access callback' => 'user_access',
    'access arguments' => array('administer parse'),
    'file' => 'parse-automated.admin.inc',
    'type' => MENU_NORMAL_ITEM,
    'weight' => 1,
  );
  $items['admin/config/services/parse/automated/add'] = array(
    'title' => 'Add An Instant/Automated Push',
    'description' => t('Add an automated push notification rule.'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('parse_add_automated_form'),
    'access arguments' => array('administer parse'),
    'file' => 'parse-automated.admin.inc',
    'type' => MENU_LOCAL_ACTION,
  );
  $items['admin/config/services/parse/automated/edit/%'] = array(
    'title' => 'Modify An Instant/Automated Push',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('parse_add_automated_form', 6),
    'access callback' => 'user_access',
    'access arguments' => array('administer parse'),
    'file' => 'parse-automated.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/services/parse/automated/delete/%'] = array(
    'title' => 'Delete An Instant/Automated Push',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('parse_automated_delete_confirm_form', 6),
    'access callback' => 'user_access',
    'access arguments' => array('administer parse'),
    'file' => 'parse-automated.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/services/parse/automated/resend/%parse_rule_detail'] = array(
    'title' => 'Resend An Instant/Automated Push',
    'page callback' => 'parse_automated_send_push',
    'page arguments' => array(6, TRUE),
    'access callback' => 'user_access',
    'access arguments' => array('administer parse'),
    'file' => 'parse-automated.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/services/parse/automated/duplicate/%'] = array(
    'title' => 'Duplicate An Instant/Automated Push',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('parse_add_automated_form', 6, TRUE),
    'access callback' => 'user_access',
    'access arguments' => array('administer parse'),
    'file' => 'parse-automated.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/services/parse/automated/view/%'] = array(
    'title' => 'View Instant/Automated Details',
    'page callback' => 'parse_admin_view_rule_details',
    'page arguments' => array(6),
    'access callback' => 'user_access',
    'access arguments' => array('administer parse'),
    'file' => 'parse-automated.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/services/parse/automated/complete'] = array(
    'title' => 'Automated Processing Complete',
    'page callback' => 'parse_admin_push_complete',
    'access callback' => 'user_access',
    'access arguments' => array('administer parse'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Our administrative check to see if we can get through the front door on this module.
 *
 * Basically anyone with access to the API settings OR rules.
 *
 * @return bool $can_access
 *   A boolean state letting us know if we do or do not have access.
 */
function parse_can_administer() {
  return (user_access('administer parse') || user_access('administer parse api settings'));
}

/**
 * Callback for loading in the rule object for the id specified in the url.
 *
 * @param int $rid
 *   The rule id that we wish to load
 * @return mixed $data
 *   Return the rule data for the rule to be loaded or FALSE if rule could not be found.
 */
function parse_rule_detail_load($rid) {
  if ((int) $rid > 0) {
    $result = db_select('parse_automation', 'r')
      ->fields('r')
      ->condition('r.rid', $rid, '=')
      ->execute();
    if ($result->rowCount() > 0) {
      $data = $result->fetchObject();
      return $data;
    }
    else {
      return FALSE;
    }
  }
  return FALSE;
}

/**
 * Implements hook_permission().
 */
function parse_permission() {
  return array(
    'administer parse' => array(
      'title' => t('Administer Parse'),
      'description' => t('Configure Parse rules.'),
    ),
    'administer parse api settings' => array(
      'title' => t('Administer Parse API Settings'),
      'description' => t('Allow for the changing of parse API settings.'),
    ),
  );
}

/**
 * Implements hook_node_insert().
 */
function parse_node_insert($node) {
  parse_send_by_criteria('insert', $node);
}

/**
 * Implements hook_node_update().
 */
function parse_node_update($node) {
  parse_send_by_criteria('update', $node);
}

/**
 * Implements hook_comment_insert().
 *
 * This requires different send logic than our standard parse_send_by_criteria() function.
 * So we require our own function to handle comments.
 */
function parse_comment_insert($comment) {
  // Bring in our user object for the purposes of checking to see if this user is in the
  // proper role for issuing notifications.
  global $user;
    
  // Load in all of the rules.
  $rules = parse_load_rules();
  
  // If there are no rules to be acted upon, then we can short circuit here.
  if (count($rules) < 1) {
    return FALSE;
  }
  
  foreach ($rules as $rule) {
    // Check to be sure the role of the user is one of our selected roles. If it's not,
    // we cannot execute.
    $rule->roles = unserialize($rule->roles);
    $intersect = array_intersect($rule->roles, $user->roles);
    if (!empty($intersect)) {
      if (!empty($rule->comments)) {
        $response = parse_send_notification($rule, $node, $user);
        if ($response['success'] == TRUE) {
          // We are successful! Send a nice message to the user and log the action to
          // our watchdog table.
          drupal_set_message('Based on your account criteria and settings, a notification was pushed to mobile phone users.', 'status');
          watchdog('parse:comment', 'Push notification sent: :notification', array(':notification' => $rule->notification_message), WATCHDOG_INFO);
        }
        else {
          // display an error to our screen and also watchdog it so we can figure out
          // what our problem is without having to be there.
          drupal_set_message('Your account was configured to send a notification. Notification couuld not be sent at this time. (' . $response['error'] . '): ' . $response['message'], 'error');
          watchdog('parse:comment', 'Push notification not sent: :mail attempted message, could not be sent. (:error) - :message', array(':mail' => $user->mail, ':error' => $response['code'], ':message' => $response['message']), WATCHDOG_ERROR);
        }
      }
      else {
        // Comments not configured for send, so skip.
      }
    }
    else {
      // This role not configured to send notifications
    }
  }
}

/**
 * Determine which rule to follow based on the hook.
 *
 * @param string $criteria
 *   The node hook being called (insert/update)
 */
function parse_send_by_criteria($criteria, $node) {
  // Bring in our user object for the purposes of checking to see if this user is in the
  // proper role for issuing notifications.
  global $user;
    
  // Load in all of the rules.
  $rules = parse_load_rules();
  
  // If there are no rules to be acted upon, then we can short circuit here.
  if (count($rules) < 1) {
    return FALSE;
  }
    
  // We have to go through all of our rules here. Because while one rule might not match
  // our criteria, another might with a different message. Or we may be firing more than
  // one rule/message - but that might also be bad form.
  foreach ($rules as $rule) {
    // Determine which types to check depending on the hook that is calling us.
    switch ($criteria) {
      case 'insert':
        $allowed_types = unserialize($rule->node_create_types);
        break;
      case 'update':
        $allowed_types = unserialize($rule->node_update_types);
         break;
      default:
        $allowed_types = NULL;
        break;
    }
    
    // Check to be sure the role of the user is one of our selected roles. If it's not,
    // we cannot execute.
    $rule->roles = unserialize($rule->roles);
    $intersect = array_intersect($rule->roles, $user->roles);
    if (!empty($intersect)) {
      // If we are of the right node, then make sure we can do this on node inserts of this
      // variety.
      if (in_array($node->type, $allowed_types)) {
        $response = parse_send_notification($rule, $node, $user);
        if ($response['success'] == TRUE) {
          // We are successful! Send a nice message to the user and log the action to
          // our watchdog table.
          drupal_set_message('Based on your account criteria and settings, a notification was pushed to mobile phone users.', 'status');
          watchdog('parse:' . $criteria, 'Push notification sent: :notification', array(':notification' => $rule->notification_message), WATCHDOG_INFO);
        }
        else {
          // display an error to our screen and also watchdog it so we can figure out
          // what our problem is without having to be there.
          drupal_set_message('Your account was configured to send a notification. Notification couuld not be sent at this time. (' . $response['error'] . '): ' . $response['message'], 'error');
          watchdog('parse:' . $criteria, 'Push notification not sent: :mail attempted message, could not be sent. (:error) - :message', array(':mail' => $user->mail, ':error' => $response['code'], ':message' => $response['message']), WATCHDOG_ERROR);
        }
      }
      else {
        // The role is correct to send this message, but tbe node type was not one that we
        // send for.
      }
    }
    else {
      // User not in a role for which we consider sending out push notifications.
    }
  }
}

/**
 * Load the rule data and return it
 */
function parse_load_rules() {
  // Check for cached rules. If they are cached, then we can save ourselves the database
  // hit on performance.
  $cache = cache_get('parse:rules', 'cache');
  if (!empty($cache->data)) {
    return $cache->data;
  }

  // Initialize our rules array and prepare it for data.
  $rules = array();
  
  // Load in all of our rules from the rules database and add it to an array that can
  // be used by our other functions.
  $result = db_select('parse_rules', 'r')
    ->fields('r')
    ->execute();
  if (!empty($result)) {
    while ($rdata = $result->fetchObject()) {
      $rules[] = $rdata;
    }
  }

  // Set our cache with these rules.
  cache_set('parse:rules', $rules, 'cache', CACHE_TEMPORARY);
  
  // Return the rules.
  return $rules;
}

/**
 * Send a push notification to Parse.
 *
 * A helper function to simply send a text notification. When rules are validated, they
 * will be sent here to send the message.
 *
 * @param string $message
 *   The message we are sending. Prepare it for payload.
 * @param Node $node
 *   A complete node object with our node payload
 * @param User $user
 *   The complete user object for the logged in used.
 * @return bool
 *   Sucess or failure of the operation.
 */
function parse_send_notification($rule, $node = NULL, $user = NULL) {
  // We need to replace any tokens in our message provided we have a valid node and user.
  // Once we have that done, we deliver the message to our Parse API and off to the 
  // races we go.
  
  // Include all of the third party API libraries so we can parse things.
  module_load_include('php', 'parse', 'library/parse');
  module_load_include('php', 'parse', 'library/parseObject');
  module_load_include('php', 'parse', 'library/parseQuery');
  module_load_include('php', 'parse', 'library/parseUser');
  module_load_include('php', 'parse', 'library/parseFile');
  module_load_include('php', 'parse', 'library/parsePush');
  module_load_include('php', 'parse', 'library/parseGeoPoint');
  module_load_include('php', 'parse', 'library/parseACL');
  module_load_include('php', 'parse', 'library/parseCloud');
  
  // Replace the tokens in our message with their actual values.
  if (function_exists('token_replace') && !empty($node) && !empty($user)) {
    $message = token_replace($rule->notification_message, array('node' => $node, 'user' => $user));
  }
  else {
    $message = $rule->notification_message;
  }
  
  // Push the message to parse. Had to modify the API/Library code to do this the Drupal
  // way so we cannot use the API from the github account. If we plan to contrib this module,
  // we should get permission to do this. (note: we have permission)
  // https://github.com/apotropaic/parse.com-php-library/issues/171
  $push = new parsePush(
    variable_get('parse_application_id', NULL), 
    variable_get('parse_masterkey', NULL),
    variable_get('parse_restkey', NULL),
    variable_get('parse_url', 'https://api.parse.com/1/'));
  
  $push->where = array(
    'deviceType' => array('ios', 'android'),
    );
  
  // If we have a badge type, assign it to our message to send
  if (!empty($rule->badge_type) && $rule->badge_type != 'None') {
    $push->__set('badge', $rule->badge_type);
  }
  
  $push->__set('sound', 'default');
  $push->__set('alert', $message);
  $success = $push->send();
  
  // Deliver news based on the type of response we get
  $response = json_decode($push->response);

  // Get our response code
  $code = (!empty($push->response_code)) ? $push->response_code : NULL;
  
  // If the response code isn't what we want it to be, then throw an error
  if ($success === TRUE) {
    return array('success' => TRUE);
  }
  else {
    $error = (!empty($response->error)) ? $response->error : NULL;
    $message = (!empty($response->message)) ? $response->message : NULL;
    return array (
      'success' => FALSE,
      'error' => $error,
      'message' => $message,
      'code' => $code,
    );
  }
}

/**
 * Our batch sending function for automated pushes and those that go through the batch
 * process.
 *
 * @param string $object_id
 *   The Parse object ID of the installation/user to send to.
 * @param object $rule
 *   The rule object that we will apply to sending the message.
 */
function parse_automated_send_push($rule, $resend = FALSE) {
  
  // Include all of the third party API libraries so we can parse things.
  module_load_include('php', 'parse', 'library/parse');
  module_load_include('php', 'parse', 'library/parseObject');
  module_load_include('php', 'parse', 'library/parseQuery');
  module_load_include('php', 'parse', 'library/parseUser');
  module_load_include('php', 'parse', 'library/parseFile');
  module_load_include('php', 'parse', 'library/parsePush');
  module_load_include('php', 'parse', 'library/parseGeoPoint');
  module_load_include('php', 'parse', 'library/parseACL');
  module_load_include('php', 'parse', 'library/parseCloud');
  module_load_include('php', 'parse', 'library/parseInstallations');

  $push = new parsePush(
    variable_get('parse_application_id', NULL), 
    variable_get('parse_masterkey', NULL),
    variable_get('parse_restkey', NULL),
    variable_get('parse_url', 'https://api.parse.com/1/'));

  // If we have a badge type, assign it to our message to send
  if (!empty($rule->badge_type) && $rule->badge_type != 'None') {
    $push->__set('badge', $rule->badge_type);
  }
  
  // Add that we want to send to iOS and Android.
  $push->where = array(
    'deviceType' => array(
      '$in' => array('ios', 'android'),
    )
  );
  
  // If they are sending on a geographic basis, then we need to plug in the latitude
  // and longitude information.
  if (!empty($rule->geo_based)) {
    // Make sure our values are typecast to floats.
    $rule->latitude = floatval($rule->latitude);
    $rule->longitude = floatval($rule->longitude);
    $rule->radius = floatval($rule->radius);
    $push->where['currentLocation'] = array(
      '$nearSphere' => array(
        '__type' => 'GeoPoint',
        'latitude' => $rule->latitude,
        'longitude' => $rule->longitude,
      ),
      '$maxDistanceInMiles' => $rule->radius,
    );
  }
  
  $push->__set('sound', 'default');
  $push->__set('alert', $rule->message);
  $success = $push->send();
  
  $response = parse_check_error($push->response);
  if ($response !== TRUE) {
    drupal_set_message($response, 'error');
    if ($resend == TRUE) {
      drupal_goto('admin/config/services/parse/automated');
    }
    return FALSE;
  }
  else {
    if ($resend == TRUE) {
      drupal_set_message('Messags successfully re-sent', 'status');
      drupal_goto('admin/config/services/parse/automated');
    }
    return TRUE;
  }
}

/**
 * Evaluate the Parse response for errors
 *
 * @param string $response
 *   A json encoded string that contains the response of our call to Parse.
 * @return mixed $message
 *   Retruns TRUE for success or a text describing the error.
 */
function parse_check_error($response) {
  $response = json_decode($response);
  if (!empty($response->error)) {
    switch ($response->error) {
      case 'unauthorized':
        return t('The request could not be authorized. Please check our Parse key settings and make sure they are correct.');
        break;
      default:
        return t('Unregistered error: ') . $response->error;
        break;
    }
  }
  else {
    return TRUE;
  }
}

/**
 * Implements hook_cron().
 *
 * Check for rules that need to be executed. These are rules that have not been sent
 * but are scheduled before or equal to the current date and time.
 */
function parse_cron() {
  // Pull in the include for our administrative sending functions.
  module_load_include('inc', 'parse', 'parse-automated.admin');
  // Get the entries that are scheduled before the current time but not sent.
  $result = db_select('parse_automation', 'p')
    ->fields('p')
    ->condition('is_sent', '0')
    ->condition('rule_type', 'scheduled')
    ->condition('send_date_time', date('Y-m-d H:i:00'), '<=')
    ->execute();
  while($pdata = $result->fetchObject()) {
    $ok = parse_automated_send_push($pdata);
    if ($ok == TRUE) {
      // Set the rule to having been executed.
      db_update('parse_automation')
        ->fields(array('is_sent' => 1))
        ->condition('rid', $pdata->rid, '=')
        ->execute();
    }
  }
  // Update our last run variable time with the current time.
  variable_set('parse_cron_last_run', time());
}

/**
 * Administrative Portal
 *
 * When the root Tweet Feed option is selected, it presents a list of the tools available
 * to be configured.
 */
function parse_menu_page() {
  $all_blocks = array();
  $blocks = system_admin_menu_block(
    array('tab_root' => 'admin/config/services/parse',
          'path' => 'admin/config/services/parse')
  );
  foreach($blocks as $key => $block) {
    $new_block = $block;
    $new_block['show'] = TRUE;
    $all_blocks[] = $new_block;
  }
  $block_out['content'] = theme('admin_block_content', array('content' => $all_blocks));
  $block_out['description'] = t('Below are the options for administering Parse Push Notifications from Drupal.');
  $block_out['title'] = t('Parse');
  $block_out['show'] = TRUE;

  return theme('admin_page', array('blocks' => array($block_out)));
}
