<?php
/**
 * @file
 * Connects Feeds fetchers and mappers with Freebase API.
 *
 * Just hooks that declare the plugins.
 */

/**
 * Implements hook_ctools_plugin_api().
 */
function freebase_feeds_ctools_plugin_api($owner, $api) {
  if ($owner == 'feeds' && $api == 'plugins') {
    return array('version' => 1);
  }
  return NULL;
}

/**
 * Implements hook_feeds_plugins().
 */
function freebase_feeds_feeds_plugins() {
  $path = drupal_get_path('module', 'freebase_feeds') . '/plugins';
  $info['FeedsFreebaseFetcher'] = array(
    'name'        => 'Freebase Fetcher',
    'description' => 'Fetches data from Freebase.',
    'handler'     => array(
      'parent' => 'FeedsFetcher',
      'class'  => 'FeedsFreebaseFetcher',
    ),
  );
  $info['FeedsFreebaseJSONParser'] = array(
    'name'        => t('Freebase JSON Parser'),
    'description' => t('Parse JSON data as returned by Freebase.'),
    'handler'     => array(
      'parent' => 'FeedsParser',
      'class'  => 'FeedsFreebaseJSONParser',
    ),
  );
  $helptext = "
    Identical to core Feeds Node Processor, only it repects GUIDs as
    being unique no matter where they were imported from.
    Eliminates duplicates and allows multiple sources to update a single
    target.
  ";
  $info['FeedsUniqueNodeProcessor'] = array(
    'name'        => 'Node processor (Unique)',
    'description' => 'Create and update nodes.',
    'help' => $helptext,
    'handler'     => array(
      'parent' => 'FeedsProcessor',
      'class'  => 'FeedsUniqueNodeProcessor',
      'file'   => 'FeedsUniqueNodeProcessor.inc',
      'path'   => $path,
    ),
  );
  return $info;
}

/**
 * Find the expected data fields we should map to.
 *
 * Returns the RDF mappings,
 * using Freebase IDs and the Feeds mapping array structure.
 *
 * This can be displayed as diagnostic hints, or merged with the UI mappings.
 *
 * Utility used by both the fetcher and the parser.
 */
function freebase_feeds_entity_field_mappings(FeedsImporter $importer) {
  $rdf_mappings = freebase_feeds_entity_rdf_mapping_load($importer);

  $mappings = array();
  foreach ((array) $rdf_mappings as $field_id => $rdf_mapping) {
    foreach ((array) @$rdf_mapping['predicates'] as $predicate) {
      // The RDF mappings are stored as legal URIs or CURIES
      // Convert those back to Freebase IDs to use within MQL.
      $freebase_id = freebase_api_rdf_curie_to_freebase_id($predicate);
      // If that didn't turn out to be a fb_id, it's null.
      if ($freebase_id) {
        $mappings[$freebase_id] = array(
          'source' => $freebase_id,
          'target' => $field_id,
          'unique' => ($freebase_id == 'id') ? TRUE : FALSE,
        );
      }
    }
  }
  return $mappings;
}

/**
 * Guess the expected Freebase topic type, based on the importer settings.
 *
 * Utility lookup, provides hints to the fetcher configs.
 *
 * @param FeedsImporter $importer
 *   FeedsImporter.
 *
 * @return string
 *   ID.
 */
function freebase_feeds_topic_type(FeedsImporter $importer) {
  $rdf_mappings = freebase_feeds_entity_rdf_mapping_load($importer);
  foreach ($rdf_mappings['rdftype'] as $rdftype) {
    return freebase_api_rdf_curie_to_freebase_id($rdftype);
  }
  return NULL;
}

/**
 * Returns the RDF mapping rules for whichever entity the feeds importer uses.
 *
 * Matches core RDF mapping structure, with predicates and URIs.
 */
function freebase_feeds_entity_rdf_mapping_load(FeedsImporter $importer) {
  $rdf_mappings = array();
  $importer_config = $importer->getConfig();
  // We should be able to support other entities fine, but for now,
  switch ($importer_config['processor']['plugin_key']) {
    case 'FeedsNodeProcessor':
      $processor_config = $importer_config['processor']['config'];
      $all_rdf_mappings = rdf_mapping_load('node', $processor_config['bundle']);

      // Filter out the mappings to only active ones (RDFx may retain unused).
      $field_instances = field_info_instances('node', $processor_config['bundle']);
      foreach ($field_instances as $field_id => $field_instance) {
        $rdf_mappings[$field_id] = $all_rdf_mappings[$field_id];
      }
      // Let rdftype through too.
      $rdf_mappings['rdftype'] = $all_rdf_mappings['rdftype'];
      break;
  }
  return $rdf_mappings;
}
