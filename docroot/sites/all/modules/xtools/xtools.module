<?php

/**
 * Implements hook_hook_info().
 */
function xtools_hook_info() {
  $hooks['xtools_blueprint_info'] = array(
    'group' => 'xtools',
  );
  $hooks['xtools_callable_type_info'] = array(
    'group' => 'xtools',
  );
  $hooks['xtools_signature_info'] = array(
    'group' => 'xtools',
  );

  return $hooks;
}

/**
 * Get all defined variable blueprints.
 *
 * @return array
 *   Keys are blueprint names, values are XtoolsBlueprintInterface objects.
 */
function xtools_blueprints_info() {
  $blueprints = &drupal_static('xtools_blueprint_info');

  if (!isset($blueprints)) {
    $blueprints = module_invoke_all('xtools_blueprint_info');
    drupal_alter('xtools_blueprint_info', $blueprints);
  }

  return $blueprints;
}

/**
 * Return a variable blueprint.
 *
 * If you the desired blueprint is unable when setting it somewhere, but it
 * will be upon validation (when nesting blueprints in a
 * hook_xtools_blueprint_info() implementation, for instance), use
 * XtoolsBlueprintPlaceholder instead. The following example demonstrates the two ways
 * to get a blueprint. They are functionally identical, but only the object
 * approach will work if the blueprint is unavailable when setting it.
 * @code
 * $blueprint = xtools_blueprint_info('blueprint_name);
 * $blueprint = new XtoolsBlueprintPlaceholder('blueprint_name);
 * @endcode
 *
 * @param string $name
 *   The blueprint's name.
 *
 * @return false|XtoolsBlueprint
 */
function xtools_blueprint_info($name) {
  $blueprints = xtools_blueprints_info();

  return isset($blueprints[$name]) ? $blueprints[$name] : FALSE;
}

/**
 * Get information about types of callables
 *
 * @param string $module
 *   Optionally only return return results for callables owned by this module.
 *
 * @return array
 *   An array of XtoolsCallableType objects.
 */
function xtools_callable_types_info($module = NULL) {
  static $callable_types;

  // Gather all information.
  if (!isset($callable_types)) {
    $callable_types = array();

    foreach (module_implements('xtools_callable_type_info') as $module_implements) {
      $module_callable_types = module_invoke($module_implements, 'xtools_callable_type_info');
      // Set the module property.
      foreach ($module_callable_types as &$module_callable_type) {
        if (!$module_callable_type->module) {
          $module_callable_type->module = $module_implements;
        }
        $callable_types[$module_callable_type->module][] = $module_callable_type;
      }
    }
  }

  return isset($callable_types[$module]) ? $callable_types[$module] : array();
}

/**
 * Get all defined signatures.
 *
 * @return array
 *   Keys are signature names, values are XtoolsSignature objects.
 */
function xtools_signatures_info() {
  $signatures = &drupal_static('xtools_signature_info');

  if (!isset($signatures)) {
    $signatures = module_invoke_all('xtools_signature_info');
  }

  return $signatures;
}

/**
 * Return a callable signature.
 *
 * @see XtoolsSignaturePlaceholder
 *
 * The following example demonstrates the two ways to get a signature. They are
 * functionally identical, but only the object approach will work if the
 * signature is unavailable when setting it.
 * @code
 * $signature = xtools_signature_info('signature_name');
 * $signature = new XtoolsSignaturePlaceholder('signature_name');
 * @endcode
 *
 * @param string $signature_name
 *
 * @return false|XtoolsSignature
 */
function xtools_signature_info($signature_name) {
  $signatures = xtools_signatures_info();

  return isset($signatures[$signature_name]) ? $signatures[$signature_name] : FALSE;
}

/**
 * Get a reflection object for a callable.
 *
 * @see http://php.net/manual/language.types.callable.php
 *
 * @param callable $callable
 *
 * @return ReflectionFunctionAbstract|false
 */
function xtools_callable_reflection($callable) {
  try {
    // $callable is a function name or a closure
    if (is_string($callable) || is_object($callable) && is_a($callable, 'Closure')) {
      return new ReflectionFunction($callable);
    }
    // $callable is a method.
    elseif (is_array($callable)) {
      return new ReflectionMethod($callable[0], $callable[1]);
    }
  }
  // $callable is no callable;
  catch (ReflectionException $e) {
    return FALSE;
  }
  return FALSE;
}

/**
 * Make sure only required and passed on modules are enabled.
 *
 * @param array $modules
 *   Modules to (keep) enable(d).
 *
 * @return array|false
 *   FALSE if enabling the necessary modules failed, or an array with the
 *   following items in case of success:
 *   - enable: an array with the names of the modules that were enabled.
 *   - disable: an array with the names of the modules that were disabled.
 *   - reset: an array with the names of the modules that should have been
 *     enabled after finished the reset.
 */
function xtools_reset_modules(array $modules) {
  static $required = NULL;

  if (is_null($required)) {
    $required = drupal_required_modules();
  }

  if (is_array($dependencies = xtools_modules_dependencies($modules))) {
    $modules = array_unique(array_merge($modules, $dependencies, $required));
    $installed = array_values(module_list());
    $enable = array_diff($modules, $installed);
    $disable = array_diff($installed, $modules);
    if ($disable) {
      // Field.module does not allow modules to be disabled if any of their
      // fields are still in use, so delete them.
      $fields = field_read_fields(array(
        'module' => $disable,
      ));
      foreach (array_keys($fields) as $field_name) {
        field_delete_field($field_name);
      }

      module_disable($disable);
    }
    if ($disable || $enable) {
      drupal_static_reset();
      drupal_flush_all_caches();
      // _field_info_collate_types() does not use drupal_static(), nor does
      // Field clear its static cache in response to module activity.
      _field_info_collate_types(TRUE);
    }
    $enabled = TRUE;
    if ($enable) {
      $enabled = module_enable($enable);
    }
    return $enabled ? array(
      'enable' => $enable,
      'disable' => $disable,
      'reset' => $modules,
    ) : FALSE;
  }
  return FALSE;
}

/**
 * Undo (some of) the Standard profile configuration that remains.
 *
 * @return boolean
 *   Whether an attempt was made to reset any configuration.
 */
function xtools_reset_standard_profile() {
  $reset = FALSE;

  // Delete the "field_tags" field.
  if (field_info_field('field_tags')) {
    $reset = TRUE;
    field_delete_field('field_tags');
  }

  // Delete the "field_image" field.
  if (field_info_field('field_image')) {
    $reset = TRUE;
    field_delete_field('field_image');
  }

  return $reset;
}

/**
 * Return a module's dependencies.
 *
 * This is essentially a wrapper around _xtools_module_dependencies() that
 * applies static caching and checks multiple modules at once.
 *
 * @param array $modules
 *   The name modules that are available on this Drupal installation and
 *   whose dependencies need to be calculated.
 *
 * @return array|false
 *   The same return value as _xtools_module_dependencies(), but then for all
 *   $modules combined.
 */
function xtools_modules_dependencies(array $modules) {
  static $dependencies = array();

  // Process modules that haven't been processed before.
  foreach (array_diff($modules, array_keys($dependencies)) as $module) {
    $dependencies[$module] = _xtools_module_dependencies($module);
  }

  // Prepare the return value.
  $selection = array();
  foreach (array_intersect_key($dependencies, array_flip(array_values($modules))) as $module_dependencies) {
    if ($module_dependencies === FALSE) {
      return FALSE;
    }
    $selection = array_merge($selection, $module_dependencies);
  }
  return array_unique($selection);
}

/**
 * Helper for xtools_modules_dependencies().
 *
 * @param string $module
 *   The name of a module that is available on this Drupal installation.
 * @param array $trace
 *   A list of modules that has been checked already. Used to prevent circular
 *   dependencies. There is no need to set this manually.
 *
 * @return array|false
 *   An array with the module names of the dependencies if they are available
 *   on this Drupal installation. FALSE if at least one dependency is not
 *   available.
 */
function _xtools_module_dependencies($module, $trace = array()) {
  $trace[] = $module;
  $module_data = system_rebuild_module_data();
  if (isset($module_data[$module])) {
    $dependencies = array();
    foreach ($module_data[$module]->info['dependencies'] as $dependency) {
      $dependency = drupal_parse_dependency($dependency);
      // Check if the dependency is available.
      if (xtools_dependency_is_available($dependency)) {
        // Check for circular dependencies.
        if (array_search($dependency['name'], $trace)) {
          continue;
        }
        // And check if the dependency's dependencies are available too.
        elseif (($dependency_dependencies = _xtools_module_dependencies($dependency['name'], $trace)) !== FALSE) {
          $dependencies = array_merge($dependencies, array($dependency['name']), $dependency_dependencies);
        }
        // The dependency's dependencies were not checked before, not are they
        // available.
        else {
          return FALSE;
        }
      }
      // The dependency is not available.
      else {
        return FALSE;
      }
    }
    return array_unique($dependencies);
  }
  else {
    return FALSE;
  }
}

/**
 * Check if a dependency can be met.
 *
 * Modules that have no version set will always be marked as available, even if
 * they are a versioned dependency.
 *
 * @param array $dependency
 *   Dependency information as returned by drupal_parse_dependency().
 *
 * @return boolean
 */
function xtools_dependency_is_available(array $dependency) {
  $module_data = system_rebuild_module_data();
  // Check if there is any version of the dependency available.
  if (isset($module_data[$dependency['name']])) {
    // The dependency needs to be of a specific version.
    if (isset($dependency['versions'])) {
      foreach ($dependency['versions'] as $version_info) {
        // The dependency matches a specific version requirements.
        if (is_null($module_data[$dependency['name']]->info['version']) || version_compare($module_data[$dependency['name']]->info['version'], $version_info['version'], $version_info['op'])) {
          return TRUE;
        }
      }
      // The dependency does not match any of the version requirements.
      return FALSE;
    }
    // The dependency can be of any version.
    return TRUE;
  }
  // The dependency module is not available at all.
  return FALSE;
}

/**
 * Returns an array with the names of all Drupal core non-test modules.
 *
 * @return array
 */
function xtools_core_modules() {
  static $modules = NULL;

  if (!$modules) {
    $modules = array_keys(file_scan_directory('modules', '#\.module$#', array(
      'recurse' => TRUE,
      'key' => 'name',
    )));
    $modules = array_values(array_filter($modules, function($module) {
      return strpos($module, 'test_') === FALSE && strpos($module, '_test') === FALSE;
    }));
  }

  return $modules;
}