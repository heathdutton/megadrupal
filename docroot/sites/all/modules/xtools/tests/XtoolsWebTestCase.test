<?php

/**
 * Provides extra test case assertions.
 */
class XtoolsWebTestCase extends DrupalWebTestCase {

  function setUp(array $modules = array()) {
    $this->profile = 'testing';
    parent::setUp($modules);
  }

  protected function drupalCreateUser(array $permissions = array(), $uid = 0) {
    // Create a role with the given permission set, if any.
    $rid = FALSE;
    if ($permissions) {
      $rid = $this->drupalCreateRole($permissions);
      if (!$rid) {
        return FALSE;
      }
    }

    // Create a user assigned to that role.
    $edit = array();
    $edit['name']   = $this->randomName();
    $edit['mail']   = $edit['name'] . '@example.com';
    $edit['pass']   = user_password();
    $edit['status'] = 1;
    if ($rid) {
      $edit['roles'] = array($rid => $rid);
    }

    $account = drupal_anonymous_user();
    // The new user should have a specific UID.
    if ($uid) {
      $account->uid = $uid;
      $account->is_new = TRUE;
      user_delete($uid);
    }
    $account = user_save($account, $edit);

    $this->assertTrue(!empty($account->uid), 'User created with name ' . $edit['name'] . ' and pass ' . $edit['pass'], 'User login');
    if (empty($account->uid)) {
      return FALSE;
    }

    // Add the raw password so that we can log in as this user.
    $account->pass_raw = $edit['pass'];
    return $account;
  }

  /**
   * Return permissions' human-readable titles and their machine names.
   *
   * @param array $permissions
   *   The permissions' machine names.
   *
   * @return string
   */
  function XtoolsPermissionLabel(array $permissions) {
    $info = &drupal_static('xtools_permission');

    if (is_null($info)) {
      $info = module_invoke_all('permission');
    }

    $labels = array();
    foreach ($permissions as $permission) {
      $labels[] = '<strong>' . $info[$permission]['title'] . ' (' . $permission . ')</strong>';
    }

    return implode(', ', $labels);
  }

  /**
   * Test a URL path's permissions.
   *
   * @param string $path
   * @param array $permissions
   *   Permissions to grant authenticated users before testing their access.
   *   Defaults to an empty array.
   * @param array $access
   *   An array of arrays with the following items:
   *   - anonymous (boolean): Whether anonymous users should be able to view
   *     the page. Defaults to FALSE.
   *   - authenticated_with_permissions (boolean): Whether authenticated users
   *     that have all the required permissions should be able to view the
   *     page. Defaults to TRUE.
   *   - authenticated_without_permissions (boolean): Whether authenticated
   *     users that do not have all the required permissions should be able to
   *     view the page. Defaults to FALSE.
   * @param string $comment
   *
   * @return NULL
   */
  function XtoolsAssertMenuRouterItemPermission($path, array $permissions = array(), array $access = array(), $comment = NULL) {
    if ($comment) {
      $comment = " ($comment)";
    }

    // Merge in defaults.
    $access += array(
      'anonymous' => FALSE,
      'authenticated_with_permissions' => TRUE,
      'authenticated_without_permissions' => FALSE,
    );

    // Test anonymous users.
    $response = $access['anonymous'] ? 200 : 403;
    $can = $access['anonymous'] ? 'can' : 'cannot';
    $this->drupalLogout();
    $this->drupalGet($path);
    $this->assertResponse($response, "An anonymous user (UID 0) $can view <strong>$path</strong>$comment without permission(s) " . $this->XtoolsPermissionLabel($permissions));

    if ($permissions) {
      // Test authenticated users with all permissions.
      $response = $access['authenticated_with_permissions'] ? 200 : 403;
      $can = $access['authenticated_with_permissions'] ? 'can' : 'cannot';
      $this->drupalLogin($this->drupalCreateUser($permissions, 2));
      $this->drupalGet($path);
      $this->assertResponse($response, "An authenticated user (UID 2) $can view <strong>$path</strong>$comment with permission(s) " . $this->XtoolsPermissionLabel($permissions));

      // Test authenticated users without all permissions.
      foreach ($permissions as $i => $permission) {
        $response = $access['authenticated_without_permissions'] ? 200 : 403;
        $can = $access['authenticated_without_permissions'] ? 'can' : 'cannot';
        $assert_permissions = $permissions;
        unset($assert_permissions[$i]);
        $account = $this->drupalCreateUser($assert_permissions, 2);
        $this->drupalLogin($account);
        $this->drupalGet($path);
        $this->assertResponse($response, "An authenticated user (UID 2) $can view <strong>$path</strong>$comment without permission " . $this->XtoolsPermissionLabel(array($permissions[$i])));
      }
    }
    else {
      $response = $access['authenticated_without_permissions'] ? 200 : 403;
      $can = $access['authenticated_without_permissions'] ? 'can' : 'cannot';
      $this->drupalLogin($this->drupalCreateUser($permissions, 2));
      $this->drupalGet($path);
      $this->assertResponse($response, "An authenticated user (UID 2) $can view <strong>$path</strong>$comment without permissions");
    }
  }

  /**
   * Test an entity's permissions.
   *
   * @param object $entity
   *   This does not have to be a 'real' entity registered with
   *   hook_entity_info().
   * @param string $entity_type_title
   *   The entity's human-readable type.
   * @param string $callback
   *   The name of the access function, which must accept the operation, the
   *   entity and a user account as arguments.
   * @param string $operation
   *   The operation to perform on the entity.
   * @param array $permissions
   *   Permissions to grant authenticated users before testing their access.
   *   Defaults to an empty array.
   * @param array $access
   *   An array of arrays with the following items:
   *   - anonymous (boolean): Whether anonymous users should be able to perform
   *     the operation. Defaults to FALSE.
   *   - root (boolean): Whether the root user (with UID 1) should be able to
   *     perform the operation. Defaults to TRUE.
   *   - authenticated_with_permissions (boolean): Whether authenticated users
   *     that have all the required permissions should be able to perform the
   *     operation. Defaults to TRUE.
   *   - authenticated_without_permissions (boolean): Whether authenticated
   *     users that do not have all the required permissions should be able to
   *     perform the operation. Defaults to FALSE.
   *
   * @return NULL
   */
  function XtoolsAssertEntityPermission($entity, $entity_type_title, $callback, $operation, array $permissions = array(), array $access = array()) {
    $user_access_permissions = &drupal_static('user_access');

    // Create the user accounts.
    $anonymous = drupal_anonymous_user();
    $root = drupal_anonymous_user();
    $root->uid = 1;
    $authenticated = drupal_anonymous_user();
    $authenticated->uid = 2;

    $comment = $entity && isset($entity->uid) ? ' with UID ' . $entity->uid : NULL;

    // Merge in defaults.
    $access += array(
      'anonymous' => FALSE,
      'root' => TRUE,
      'authenticated_with_permissions' => TRUE,
      'authenticated_without_permissions' => FALSE,
    );

    // Test anonymous users.
    $can = $access['anonymous'] ? 'can' : 'cannot';
    $operation = $operation;
    $this->assertEqual($callback($operation, $entity, $anonymous), $access['anonymous'], "An anonymous user $can perform operation <strong>$operation</strong> on a <strong>$entity_type_title</strong>$comment without permission(s) " . $this->XtoolsPermissionLabel($permissions));

    // // Test UID 1.
    $can = $access['root'] ? 'can' : 'cannot';
    $operation = $operation;
    $this->assertEqual($callback($operation, $entity, $root), $access['root'], "The root user (UID 1) $can perform operation <strong>$operation</strong> on a <strong>$entity_type_title</strong>$comment without permission(s) " . $this->XtoolsPermissionLabel($permissions));

    // Test authenticated users with all permissions.
    if ($permissions) {
      $user_access_permissions[2] = array_fill_keys($permissions, TRUE);
      $with = $permissions ? 'with' : 'without';
      $can = $access['authenticated_with_permissions'] ? 'can' : 'cannot';
      $operation = $operation;
      $this->assertEqual($callback($operation, $entity, $authenticated), $access['authenticated_with_permissions'], "An authenticated user (UID 2) $can perform operation <strong>$operation</strong> on a <strong>$entity_type_title</strong>$comment with permission(s) " . $this->XtoolsPermissionLabel($permissions));
    }

    // Test authenticated users without all permissions.
    foreach ($permissions as $i => $permission) {
      $assert_permissions = $permissions;
      unset($assert_permissions[$i]);
      $user_access_permissions[2] = array_fill_keys($assert_permissions, TRUE);
      $can = $access['authenticated_without_permissions'] ? 'can' : 'cannot';
      $operation = $operation;
      $this->assertFalse($callback($operation, $entity, $authenticated), "An authenticated user (UID 2) $can perform operation <strong>$operation</strong> on a <strong>$entity_type_title</strong>$comment without permission " . $this->XtoolsPermissionLabel(array($permissions[$i])));
    }
  }

  /**
   * Test a module's callables.
   *
   * Every XtoolsCallableType that belongs to one of the modules in $owner that
   * has its XtoolsCallableType::blueprint set, also needs at least one value
   * for its XtoolsCallableType::argument_groups property in order for its
   * return value to be validated against the blueprint.
   *
   * @param array $subject
   *   The names of the modules whose callables to test. They are enabled
   *   automatically.
   * @param array $owners
   *   The names of the modules that defined the callable types to test. Use
   *   "drupal" as an alias for all Drupal core modules.
   *
   * @return NULL
   */
  function XtoolsAssertCallables(array $subjects, array $owners) {
     // Ensure Xtools is enabled, because we are using its code.
    module_enable(array('xtools'));

    if (xtools_reset_standard_profile()) {
      $this->assert('debug', "Resetting <em>Standard</em> profile's configuration", 'Debug');
    }

    // Process the "drupal" alias.
    $i = array_search('drupal', $owners);
    if ($i !== FALSE) {
      unset($owners[$i]);
      $owners += xtools_core_modules();
    }
    // Filter out duplicates.
    $subjects = array_unique($subjects);
    $owners = array_unique($owners);

    // Loop through the subjects.
    foreach ($subjects as $subject) {
      // Loop through the callable type owners.
      foreach ($owners as $owner) {
        if ($this->resetModules(array($subject, $owner, 'xtools'))) {
          foreach (xtools_callable_types_info($owner) as $callable_type) {
            foreach ($callable_type->getCallables($subject) as $callable) {
              $callable_name = xtools_callable_reflection($callable)->getName() . '()';
              $callable_asserts = array();

              // Test the callable's signature.
              if ($callable_type->signature) {
                $asserts = array();
                $callable_type->signature->validate($callable, $asserts);
                $callable_asserts = array_merge($callable_asserts, $asserts);
              }

              // Test the callable's return value.
              if ($callable_type->blueprint) {
                foreach ($callable_type->argument_groups as $arguments) {
                  $asserts = array();
                  $callable_type->blueprint->validate(call_user_func_array($callable, $arguments), $asserts, '$return_value');
                  $callable_asserts = array_merge($callable_asserts, $asserts);
                }
              }

              foreach ($callable_asserts as $assert) {
                $this->assert($assert->valid, "$callable_name: {$assert->message}", 'Other', $assert->caller);
              }
            }
          }
        }
      }
    }
  }

  /**
   * A wrapper for xtools_reset_modules().
   */
  function resetModules(array $modules) {
    // Ensure Xtools is enabled, because we are using its code.
    module_enable(array('xtools'));

    $reset = xtools_reset_modules($modules);
  	if ($reset) {
      sort($reset['reset']);
      sort($modules);
      $message_reset = implode(', ', $reset['reset']);
  	}
  	else {
      $message_reset = implode(', ', $modules);
  	}
    $this->assertTrue((bool) $reset, "Resetting modules to: <em>$message_reset</em>" . ($reset ? '' : ' (one or more dependencies are missing)'));
    if (is_array($reset)) {
      if ($reset['disable']) {
        sort($reset['disable']);
        $message_disable = implode(', ', $reset['disable']);
        $this->assert('debug', "Disabling modules: <em>$message_disable</em>", 'Debug');
      }
      if ($reset['enable']) {
        sort($reset['enable']);
        $message_enable = implode(', ', $reset['enable']);
        $this->assert('debug', "Enabling modules: <em>$message_enable</em>", 'Debug');
      }
    }

    return $reset;
  }
}