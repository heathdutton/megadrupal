<?php

/**
 * @file
 * Reservations - Managed Equipment Reservation Checkout and Inventory
 */

// Item default availability options.
define('RESERVATIONS_AVA_F', 1);
define('RESERVATIONS_UNA_F', 2);
define('RESERVATIONS_AVA_T', 3);
define('RESERVATIONS_UNA_S', 4);

// Reservation status options.
define('RESERVATIONS_STATUS_UNCONFIRMED', 1);
define('RESERVATIONS_STATUS_PENDING', 2);
define('RESERVATIONS_STATUS_CHECKED_OUT', 3);
define('RESERVATIONS_STATUS_CHECKED_IN', 4);
define('RESERVATIONS_STATUS_CANCELLED', 5);
define('RESERVATIONS_STATUS_DENIED', 6);
define('RESERVATIONS_STATUS_NO_SHOW', 7);

// Bucket/resource status options.
define('RESERVATIONS_STATUS_ACTIVE', 1);
define('RESERVATIONS_STATUS_INACTIVE', 2);

// Bucket/resource sub-types.
define('RESERVATIONS_SUB_TYPE_ITEM', 1);
define('RESERVATIONS_SUB_TYPE_RESERVATION', 2);

// Item status for reservations.
define('RESERVATIONS_ITEM_STATUS_CANCELED', -2);
define('RESERVATIONS_ITEM_STATUS_CHECKED_IN', -1);
define('RESERVATIONS_ITEM_STATUS_AVAILABLE', 0);
define('RESERVATIONS_ITEM_STATUS_RESERVED', 1);
define('RESERVATIONS_ITEM_STATUS_CHECKED_OUT', 2);

//Optional view to filter out available items for a bucket upon checkout
define('RESERVATIONS_AVAILABLE_BUCKET_ITEM_OVERRIDE_VIEW', 
       'reservations_available_bucket_item_override');

module_load_include('inc', 'reservations', 'includes/database');
module_load_include('inc', 'reservations', 'includes/api');

/**
 * Implements hook_permission().
 */
function reservations_permission() {
  //<em class="placeholder">Reservations</em>: Create new content
  //Edit own content
  //Edit any content
  //Delete own content
  //Delete any content
  return array(
    'view all reservations' => array(
      'title' => '<em class="placeholder">Reservations</em>: View all Reservations',
      'description' => t('Allows users to view Reservations. When Reservations nodes are unpublished, users can only access their own unpublished Reservations. This permission can be used to bypass that and create a public availability calendar of unpublished nodes without needing to allow access to unpublished nodes of other content types.'),
    ),
  // now uses the core 'create reservations_reservation content' permission for the content type
  /*
    'create reservations' => array(
      'title' => '<em class="placeholder">Reservations</em>: Create new content',
      'description' => t('Required to create a Reservation, but this permission alone is not enough.  To reserve items, a user must also have Edit Own and Delete Own permissions to at least one content type.  Without that, users will see empty select lists of the items available to them.'),
    ),
  */
    'create confirmed reservations' => array(
      'title' => '<em class="placeholder">Reservations</em>: Create new content (Confirmed status)',
      'description' => t('This permission allows users to create/edit reservations with a status of unconfirmed or confirmed. It does not allow the user to change the status.  Users without this permission can NOT adjust the dates, times, or items in a Reservation after it has been confirmed.'),
    ),
    'create reservations outside hours of operation' => array(
      'title' => '<em class="placeholder">Reservations</em>: Create new content (Outside Normal Hours of Operation)',
      'description' => t('Does what it says. Allows users to create reservations with start and end times outside of the hours of operation without needing to have the Manage Reservations permission.'),
    ),
    'push forward over closed days' => array(
      'title' => t('Push Forward Over Closed Days'),
      'description' => t('If you normally only allow an item to be checked for 24 hours and are closed on Sunday, users in a Role with this permission can extend the Reservation until Monday.'),
    ),
    'deduct fee free hours from cost' => array(
      'title' => t('Deduct Fee Free Hours from Cost'),
      'description' => t('This permission gives users a number of hours of use at no cost.  If a user is allowed to make reservations for 48 hours of an item with a per hour fee of $10, but and only 24 of those hours are "fee free" the cost of the Reservation would be $240.  A user without this permission would pay $480.'),
    ),
    'manage reservations' => array(
      'title' => t('Manage Reservations'),
      'description' => t('This permission grants users access to check equipment in and out and edit all existing reservations. Manage MERCI allows users to: Alter the status of a Reservation (Checked Out, Checked In, Canceled, and No Show), Assign item from Bucket to Reservation, Add Accessories to a Reservation.'),
      'restrict access' => TRUE,
    ),
    'administer reservations' => array(
      'title' => t('Administer Reservations'),
      'description' => t('Allows user to adjust hours of operation, bucket and resource settings and permissions to reserve items by type.'),
      'restrict access' => TRUE,
    ),
    'suspend reservations access' => array(
      'title' => t('Suspend Reservations Access'),
      'description' => t('This permission blocks users from creating new reservations or altering existing reservations. It is really a negative permission and was added for sites using modules like CiviCRM Role or Member Sync to keep users synchronized between CiviCRM and Drupal. Rather than try to fight with CiviCRM, suspend them from Reservations.  Adding this permission prevents users from being able to use Reservations until they are removed from the Role with this permission.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function reservations_menu() {

  // Callback for AJAX adding of item selectors.
  $items['reservations/js'] = array(
    'title' => 'Javascript Choice Form',
    'page callback' => 'reservations_choice_js',
    'access arguments' => array('access content'),
    'file' => 'includes/menu.inc',
    'type' => MENU_CALLBACK,
  );

  // Adds Reservations to Admin Interface
  $items['admin/config/reservations'] = array(
    'title' => 'Reservations',
    'description' => 'Configuration options for Reservations API',
    'position' => 'right',
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('administer reservations'),
    'file' => 'system.admin.inc',
    'file path' => drupal_get_path('module', 'system'),
    'weight' => -99,
  );
    
  // Standard Administration settings.
  $items['admin/config/reservations/reservations'] = array(
    'title' => 'Reservations API settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('reservations_admin_settings'),
    'access callback' => 'user_access',
    'access arguments' => array('administer reservations'),
    'description' => 'Configure system settings for Reservations API.',
    'file' => 'includes/reservations.admin.inc',
    'weight' => -99,
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * Implements hook_node_info().
 */
function reservations_node_info() {
  return array(
    // Reservation nodes.
    'reservations_reservation' => array(
      'name' => t('Reservation'),
      'base' => 'reservations',
      'has_body' => FALSE,
      'description' => t("A Reservation reserves one or many nodes of other content types using a Date field to define the start and end of the duration the items are reserved."),
    ),
  );
}


/**
 * Implements hook_node_access().
 */
function reservations_node_access($node, $op, $account) {
  global $user;

  $type = isset($node->type) ? $node->type : $node;
  $uid = isset($node->uid) ? $node->uid : FALSE;

  if ($type == 'reservations_reservation') {

    if (user_access('manage reservations')) {
      return TRUE;
    }
    elseif (user_access('view all reservations') && $op == 'view') {
      return TRUE;
    }
    elseif (user_access('create reservations_reservation content_reservation content') and !user_access('suspend reservations access')) {
      //users working with their own reservations access reservation
      //additional check in reservations_form permission to edit confirmed reservations
      // Users without administer or manage reservations permission can only alter their own Unconfirmed Reservations.
      if (($op == 'delete' or $op == 'update') && isset($node->reservations_reservation_status)
        && $node->reservations_reservation_status != RESERVATIONS_STATUS_UNCONFIRMED
        && !user_access('create confirmed reservations')) {
          return FALSE;
        }

      if ($uid === FALSE || $uid == $account->uid) {
        return TRUE;
      }
    }
    return FALSE;
  }
}

/**
 * Implements hook_init().
 */
function reservations_init() {
  drupal_add_css(drupal_get_path('module', 'reservations') . '/reservations.css');
  drupal_add_js(drupal_get_path('module', 'reservations') . '/reservations.js');
}


/**
 * Implements hook_prepare().
 */
function reservations_prepare(&$node) {
  if (!isset($node->reservations_reservation_status)) {
    $node->reservations_reservation_status = variable_get('reservations_default_reservation_status', strval(RESERVATIONS_STATUS_UNCONFIRMED));
        }
}

/**
 * Implements hook_validate().
 */
function reservations_reservation_node_validate($form, &$form_state) {

  if (!empty($form_state['ahah_submission'])) {
    return;
  }

  // No validation necessary on deletion.
  if (isset($form_state['clicked_button']['#id']) && $form_state['clicked_button']['#id'] == 'edit-delete') {
    return;
  }

  // Do not validation if their errors from the main validation function.
  if (form_get_errors()) {
    return;
  }

  reservations_validate_status($form, $form_state);
  reservations_validate_reservations_reservation_date($form, $form_state);

  // Tests for existing items.
  reservations_validate_empty_reservation_items($form, $form_state);
  reservations_validate_reservations_selected_items($form, $form_state);
}


/**
 * Implements hook_insert().
 */
function reservations_insert($node) {
  drupal_write_record("reservations_reservation", $node);
  reservations_add_reservation_items($node);
}

/**
 * Implements hook_update().
 */
function reservations_update($node) {
  if (isset($node->revision) && $node->revision) {
    drupal_write_record("reservations_reservation", $node);
      }
      else {
    drupal_write_record("reservations_reservation", $node, "vid");
  }
  reservations_add_reservation_items($node);

}

/**
 * Implements hook_delete().
 */
function reservations_delete($node) {

  foreach ($node->reservations_reservation_items as $item) {
    // Set the checked out item back to checked in.
    if ($node->reservations_reservation_status == RESERVATIONS_STATUS_CHECKED_OUT) {
      $update = array(
        'nid' => $item['reservations_item_nid'],
        'reservations_item_status' => RESERVATIONS_ITEM_STATUS_AVAILABLE,
      );
      drupal_write_record('reservations_reservation_item_node', $update, 'nid');
          }
    // Remove the placeholder node.
    node_delete($item['reservations_placeholder_nid']);
        }

  reservations_delete_record('reservations_reservation', $node, 'nid');
  reservations_delete_record('reservations_reservation_detail', $node, 'nid');

}


/**
 * Implements hook_form().
 */
function reservations_form($node, &$form_state) {
  
  $form = node_content_form($node, $form_state);
  $reservation_nid = isset($node->nid) ? $node->nid : NULL;
  

  // During initial form build, add the node entity to the form state for use
  // during form building and processing. During a rebuild, use what is in the
  // form state.
  if (!isset($form_state['node'])) {
    if (!isset($node->title)) {
      $node->title = NULL;
    }
    node_object_prepare($node);
    $form_state['node'] = $node;
  }
  else {
    $node = $form_state['node'];
  }
  
  // Add a wrapper for the choices and more button.
  $form['choice_wrapper'] = array(
    '#tree' => FALSE,
    '#prefix' => '<div class="clear-block" id="reservations-choice-wrapper">',
    '#suffix' => '</div>',
  );

  // Build existing reserved items table on existing reservations.
  $form['choice_wrapper']['reservations_reservation_items'] = reservations_build_reservation_table_form($form, $form_state, $node, TRUE);

  // Adds 12 items, then hides them if nothing is selected to support node_clone
  $choice_count = (isset($node->choice_count)) ? $node->choice_count : 12;

  //if (isset($form_state['post']['op']) && $form_state['post']['op'] == "Add more items") {
  //  $choice_count += 3;
  //}

  $form['choice_wrapper']['choice_count'] = array(
    '#type' => 'value',
    '#value' => $choice_count,
  );
  
  //$options = reservations_build_reservable_items($node, $form_state, NULL);
  
  //function reservations_build_reservable_items($node, $form_state, $reservation_nid = NULL) {
  
 
  //set inventory 
  $inventory = module_exists('reservations_inventory') ? reservations_inventory_set_inventory($node) : NULL;
  
  $langcode = $node->language;
  // Newly set dates take precedence.
  if (isset($form_state['values']['field_reservations_date'][$langcode][0]['value']['date'])) {
    
    $start_string = $form_state['values']['field_reservations_date'][$langcode][0]['value']['date'] . ' ' . $form_state['input']['field_reservations_date'][$langcode][0]['value']['time'];
    $end_string = $form_state['values']['field_reservations_date'][$langcode][0]['value2']['date'] . ' ' . $form_state['input']['field_reservations_date'][$langcode][0]['value2']['time'];
    
    $start_object = reservations_create_local_date_object($start_string);
    $end_object = reservations_create_local_date_object($end_string);
  
    if($start_object) {
      $start = date_format($start_object, DATE_FORMAT_DATETIME); 
      $end = date_format($end_object, DATE_FORMAT_DATETIME);
    } else {
      $start     = NULL;
      $end       = NULL;
    }
    
  }
  // Dates loaded from the reservation are next.
  elseif (isset($node->nid)) {
    $date_info = $node->field_reservations_date[$langcode][0];
    $start     = $date_info['value'];
    $end       = $date_info['value2'];
  }
  // New reservation, so no date filtering.
  else {
    $is_new = TRUE;
    $start     = NULL;
    $end       = NULL;
  }
    
  $options = array();
  $options_disabled = array();
  
  $options['options'][''] = '<' . t('Select') . '>';
  $default = NULL;
  
  $vid = variable_get('reservations_grouping_vid', 0);
  
  
  $terms = taxonomy_get_tree($vid);
  //add check to see if there are any terms
  foreach ($terms as $term) {
    $options['options'][$term->name] = array();
  }
  
  $reservable_types = reservations_content_types();
  
  // This array holds all reservable items the user may reserve.
  // Loop through each reserable type.
  foreach ($reservable_types as $reservable_type) {

    $include = FALSE;  // default to skipping the type unless 
    
    if ($inventory) {
      if (!empty($reservable_type['inventory_tids'])) {
        foreach ($reservable_type['inventory_tids'] as $tid) {
          if ($tid == $inventory) {
            $include = TRUE;
          }
        }
      }
    } else {
      // if there is no inventory, include everything
      $include = TRUE;
    }
    
    if ($include) {
     
	  if ($reservable_type['reservations_active_status'] != RESERVATIONS_STATUS_ACTIVE) {
	    continue;
	  }
	  
	  if (!reservations_check_content_type_user_permissions($reservable_type['type'])) {
	    continue;
	  }
	  
	  if (empty($is_new)) {
	    $restrictions = reservations_check_content_type_restrictions($reservable_type['type'], $start, $end);
		if (!empty($restrictions)) {
		  continue;
		}
	  }
	  
	  //set the grouping to Other if there isn't one
	  $grouping = isset($reservable_type['reservations_item_grouping']) ? $reservable_type['reservations_item_grouping'] : 'Other';
	  	
	  // if it's a bucket, add it to the select list
	  if ($reservable_type['reservations_type_setting'] == 'bucket') {
	    
	    	  
	    // Check for available items in the bucket at the time when time is included
	    $available_bucket_items = reservations_get_available_bucket_count($reservable_type['type'], $start, $end, $reservation_nid) - $reservable_type['reservations_spare_items'];
		  if ($available_bucket_items) {
		    $options['options'][$grouping][$reservable_type['type']] = $reservable_type['type_name'];
		  } else {
		    //disable item in list
		    $options_disabled['options'][$grouping][$reservable_type['type']] = $reservable_type['type_name'];
		    
		    
		  }
	
	   } 
	   //PROCESS RESOURCES
	   elseif ($reservable_type['reservations_type_setting'] == 'resource') {
	     // No date filtering for new reservations.
	     //dsm($reservable_type['type']);
		 $item_options = reservations_get_reservable_items($reservable_type['type'], $start, $end, $reservation_nid);
		 //dsm($item_options);
		 
		 if (!empty($item_options)) {
		   foreach ($item_options as $key => $item) {
		     
			 $options['options'][$grouping][$key] = $item;
		    }
		  } else {
		  
		     //$options_disabled['options'][$grouping][$key] = $item;

		    //disable item in list
		  }
	   }  
    } // $inventroy include
  }

  //dsm($options['options']);
  
  // Remove grouping keys with no items.
  foreach ($terms as $term) {
    if (empty($options['options'][$term->name])) {
      unset ($options['options'][$term->name]);
    }
  }
  
  //$alt_options = $options['options'];
  
  // Add the current choices to the form.
  for ($delta = 1; $delta <= $choice_count; $delta++) {
    $default = isset($node->reservations_reservation_items["choice_" . $delta]['reservations_item_nid']) ?
      $node->reservations_reservation_items["choice_" . $delta]['reservations_item_nid'] : '';

    //$form['choice_wrapper']['reservations_reservation_items']["choice_" . $delta]['reservations_item_nid'] = _reservations_choice_form($node, $form_state, $delta, $default);
    
    
    
    $form['choice_wrapper']['reservations_reservation_items']["choice_" . $delta]['reservations_item_nid'] = array(
      '#type' => 'select',
      '#options' => $options['options'],
      '#default_value' => $default,
      //'#parents' => array('choice', $delta, 'item'),
    );
    
    //$form['myboxes']['bar'] = array('#disabled' => TRUE,);

  }

  $options = array();
  for ($i = 1; $i < 13; $i++) {
    $options[$i] = $i;
  }

  $form['choice_wrapper']['reservations_more'] = array(
    '#markup' => '<input type="button" id="edit-reservations-more" class="form-submit" value="Add more items">',
  );


  if (user_access('manage reservations')) {
    $form['reservations_reservation_status'] = array(
      '#title' => t('Status'),
      '#type' => 'radios',
      '#options' => reservations_record_status(),
      '#default_value' => $node->reservations_reservation_status,
      '#description' => t('Finalized bookings can not have time conflicts with each other.'),
    );
  }
  else {
    $form['reservations_reservation_status'] = array(
      '#type' => 'value',
      '#value' => $node->reservations_reservation_status,
    );
  }
  $form['reservations_original_reservation_status'] = array(
    '#type' => 'value',
    '#value' => (isset($node->reservations_original_reservation_status)) ? $node->reservations_original_reservation_status : $node->reservations_reservation_status,
  );

  $form['#validate'][] = 'reservations_reservation_node_validate';
  //$form['#after_build'][] = '_reservations_after_build';

  $form['#cache'] = TRUE; // Make sure the form is cached.

  // Pull the correct action out of form_state if it's there to avoid AHAH+Validation action-rewrite.
  if (isset($form_state['action'])) {
    $form['#action'] = $form_state['action'];
  }
  
  $diffallowed = variable_get('reservations_diff_warning', '0');
  
  if ($reservation_nid && $diffallowed) {
    
    $timezone = variable_get('date_default_timezone', 0);
    
    $now = strtotime(format_date(time(), 'custom', 'Y-m-d h:i', $timezone));
            
    //if this reservation is being checked out and the start hours are 
    // > or < reservations_diff_warning hours from now
    // time zone/dst does NOT matter here
    if ($node->reservations_reservation_status == RESERVATIONS_STATUS_PENDING) {
      
      // only works with PHP5.3
      //$starttime = reservations_create_local_date_object($node->field_reservations_date['und'][0]['value'])->getTimestamp();
      
      $starttime = reservations_create_local_date_object($node->field_reservations_date['und'][0]['value'])->format('U');
      
      
      $diff = abs($starttime - $now) / 60;

      if ($diff > variable_get('reservations_diff_warning', '0')) {
        drupal_set_message(t('This Reservations is being checked out more than @minutes minutes before or after the Reservation was scheduled to start.  Please adjust the start time for accurate records', array('@minutes' => $diffallowed)), 'warning');
      }
    }
    
    if ($node->reservations_reservation_status == RESERVATIONS_STATUS_CHECKED_OUT) {
      
      //$endtime = reservations_create_local_date_object($node->field_reservations_date['und'][0]['value2'])->getTimestamp();
      
      $endtime = reservations_create_local_date_object($node->field_reservations_date['und'][0]['value2'])->format('U');
      
      $diff = abs($endtime - $now) / 60;
      if ($diff > variable_get('reservations_diff_warning', '0')) {
        drupal_set_message(t('This Reservations is being checked in more than @minutes minutes before or after the Reservation was scheduled to end.  Please adjust the end time for accurate records', array('@minutes' => $diffallowed)), 'warning');
      }
    }
  } 
  
  return $form;
}


/**
 * Implements hook_form_alter().
 */
function reservations_form_alter(&$form, $form_state, $form_id) {
  
  $type = (isset($form['#bundle'])) ? $form['#bundle'] : NULL;
  
  switch ($form_id) {
    
    // putting this here instead of reservations_form allows it to be run after the date fields are added
    case 'reservations_reservation_node_form':
      if (user_access('suspend reservations access') && !user_access('manage reservations')) {
        drupal_set_message(t('Your permission to make Reservations has been suspended.  Please contact a staff member.'), 'error');
        $form = NULL;
      }
      break;
      
    // Node settings form.
    case $type . '_node_form':

      if (reservations_is_reservations_type($type)) {

        $node = (object) $form['#node'];

        $sub_type = isset($node->reservations_sub_type) ? $node->reservations_sub_type : RESERVATIONS_SUB_TYPE_ITEM;
        $default_availability = isset($node->reservations_default_availability) ? $node->reservations_default_availability : RESERVATIONS_AVA_F;

        if ($sub_type == RESERVATIONS_SUB_TYPE_ITEM) {
          if (empty($form['reservations'])) {
            $form['reservations'] = array(
              '#type' => 'fieldset',
              '#title' => t('Reservations settings'),
              '#collapsible' => TRUE,
              '#collapsed' => TRUE,
              '#group' => 'additional_settings',
            );
          }
          $form['reservations']['reservations_default_availability'] = array(
            '#title' => t('Default booking availability'),
            '#type' => 'radios',
            '#options' => reservations_item_status(),
            '#description' => t('If no availability information is defined for a given time, the resource falls back onto this setting.'),
            '#default_value' => $default_availability,
            '#element_validate' => array('reservations_validate_default_availability'),
          );
        }
        $form['reservations_sub_type'] = array(
          '#type' => 'value',
          '#value' => $sub_type,
        );

        reservations_add_settings_form($form, $form_state);
      }
      break;

  }
}


/**
 * Implements hook_form_FORM_ID_alter().
 */
function reservations_form_node_type_delete_confirm_alter(&$form, &$form_state) {
  $type = str_replace('-', '_', arg(3));
  reservations_delete_node_type_validate($form);   
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function reservations_form_node_admin_content_alter(&$form, &$form_state) {
  if (!isset($form['#validate'])) {
    $form['#validate'] = array();
  }
  $form['#validate'][] = 'reservations_node_admin_delete_validate';      
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function reservations_form_node_delete_confirm_alter(&$form, &$form_state) {
  $node = node_load((int) arg(1));
  if (!reservations_delete_item_validate($node)) {
    unset($form['actions']['submit']);
  }      
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function reservations_form_node_type_form_alter(&$form, &$form_state) {

  // Reservation content type can't used for other Reservations functionality.
  if (isset($form['#node_type']->type) && $form['#node_type']->type == 'reservations_reservation') {
    return;
  }

  $type = $form['old_type']['#value'];

  // If any nodes have already been created, lock the type setting.
  if ($type) {
    $nodes = reservations_nodes_for_type_count($type);
    $settings = reservations_load_item_settings($type);
  }

  $form['reservations'] = array(
    '#type' => 'fieldset',
    '#title' => t('Reservations settings'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#group' => 'additional_settings',
    '#attached' => array(
    'js' => array(drupal_get_path('module', 'menu') . '/menu.admin.js'),
     ),
  );

  $warning  = '<div>' . t('<strong> WARNING:</strong> changing this setting has no effect on existing reserved items.') . '</div>';

  $options  = array(
    'disabled' => t('Disabled'),
    'bucket' => t('Bucket'),
    'resource' => t('Resource'),
  );

  $type_setting = isset($settings->reservations_type_setting) ? $settings->reservations_type_setting : 'disabled';

  // If any nodes have already been created, lock the type setting.
  if (isset($nodes) and $nodes) {

    $form['reservations']['reservations_type_setting'] = array(
      '#type' => 'value',
      '#value' => $type_setting,
    );

    $form['reservations']['reservations_type_setting_display'] = array(
      '#type' => 'item',
      '#title' => t('Reservable item type'),
      '#value' => $type_setting,
      '#description' => check_plain($type_setting . ' - ' . t('The setting can not be changed because content already exists for this type.')),
      '#weight' => -30,
     );

   } else {
   
     $description_items = array(
       'disabled' => t('This content type cannot be reserved'),
       'resource' => t('Use this content type to create unique items that can be reserved.'),
       'bucket' => t('Use this content type to create interchangeable items that can be reserved (ex. Camera). Buckets reference interchangeable items. The actual item does not have to be chosen until the reservation is checked out.'),
      );


      $form['reservations']['reservations_type_setting'] = array(
        '#type' => 'radios',
        '#title' => t('Reservable item type'),
        '#options' => $options,
        '#default_value' => isset($settings->reservations_type_setting) ? $settings->reservations_type_setting : 'disabled',
        '#description_items' => $description_items,
        '#after_build' => array('reservations_type_setting_after_build'),
        '#weight' => -30,
      );
    }

    if (isset($nodes) && $nodes && $type_setting == 'disabled') {
      return;
    }

    $status = array(
      RESERVATIONS_STATUS_ACTIVE => t('Active'),
      RESERVATIONS_STATUS_INACTIVE => t('Inactive'),
    );

    $form['reservations']['reservations_active_status'] = array(
      '#type' => 'radios',
      '#title' => t('Status'),
      '#options' => $status,
      '#default_value' => isset($settings->reservations_active_status) ? intval($settings->reservations_active_status) : RESERVATIONS_STATUS_ACTIVE,
      '#description' => t('Set to active to allow this type to be reserved.'),
      '#weight' => -20,
    );
    
    $vid = variable_get('reservations_grouping_vid', 0);    
    $tid = isset($settings->reservations_grouping) ? $settings->reservations_grouping : NULL;
      
    // weighted -9
    $grouping_array = reservations_taxonomy_term_select(t('Grouping'), NULL, $tid, $vid, t('This will alter order the content types are displayed to users reserving items from buckets. Terms added to the Reservations Groupings vocabulary will appear here.'), 0, '<' . t('Select') . '>');

    $form['reservations']['reservations_grouping'] = $grouping_array;
    
    
    


     $form['reservations']['rules'] = array(
        '#markup' => '<b>Reservation Rules</b>',
        '#weight' => -8,
     );
    
    
    $form['reservations']['reservations_max_hours_per_reservation'] = array(
        '#type' => 'textfield',
        '#title' => t('Maximum hours per reservation'),
        '#size' => 10,
        '#default_value' => isset($settings->reservations_max_hours_per_reservation) ? $settings->reservations_max_hours_per_reservation : 0,
        '#element_validate' => array('reservations_is_numeric_validate'),
        '#description' => filter_xss(t('The maximum hours the item can be reserved for in one reservation. Set to zero for no limit.') . $warning),
        '#weight' => -7,
     );
            
      
      $form['reservations']['reservations_allow_overnight'] = array(
        '#type' => 'checkbox',
        '#title' => t('Allow overnight reservation'),
        '#default_value' => isset($settings->reservations_allow_overnight) ? $settings->reservations_allow_overnight : 0,
        '#description' => filter_xss(t('Allow a reservation to continue over multiple days.  If this is not checked, items in this content type must be returned before the checkout closes.') . $warning),
      );

      $form['reservations']['reservations_push'] = array(
        '#type' => 'checkbox',
        '#title' => t('Push forward when item is due and checkout is closed'),
        '#default_value' => isset($settings->reservations_push) ? $settings->reservations_push : 0,
        '#description' => filter_xss(t('Allow a reservation with this type to push forward until checkout open if return falls on day configured to allow pushing.') . $warning),
      );
      
      // This setting is only valid for buckets.
      if (!isset($settings->reservations_type_setting) || $settings->reservations_type_setting == 'bucket') {
        
        $form['reservations']['bucket'] = array(
          '#markup' => '<b>Bucket Specific Settings</b>',
          '#weight' => 29,
        );
        
        $form['reservations']['reservations_auto_assign_bucket_item'] = array(
          '#type' => 'checkbox',
          '#title' => t('Automatically assign a bucket item when Reservation is created'),
          '#default_value' => isset($settings->reservations_auto_assign_bucket_item) ? $settings->reservations_auto_assign_bucket_item : 0,
          '#description' => t('Automatically assign the best fit bucket item when reserving a new bucket item.  This saves time when checking items out but can create problems when an item is not returned on time.'),
          '#weight' => 30,
        );
      }
      
      // This setting is only valid for buckets.
      if (!isset($settings->reservations_type_setting) || $settings->reservations_type_setting == 'bucket') {
        $form['reservations']['reservations_spare_items'] = array(
          '#type' => 'textfield',
          '#title' => t('Spare items'),
          '#size' => 10,
          '#default_value' => isset($settings->reservations_spare_items) ? $settings->reservations_spare_items : 0,
          '#element_validate' => array('reservations_is_numeric_validate'),
          '#description' => filter_xss(t("Set this to the number of items of this type that should always be unavailable and thus unreservable.  This way you'll still have enough items for future reservations in case something breaks.") . $warning),
          '#weight' => 31,
        ); 
      }

      
      //form fields shared with resouce nodes
      reservations_add_settings_form($form, $form_state);

      $form['#validate'][] = 'reservations_node_type_save_validate';
      //$form['#submit'][]   = 'reservations_node_type_save_submit';

}


/**
 * Implements hook_content_extra_fields().
 */
function reservations_content_extra_fields() {
  $extras['reservations'] = array(
    'label' => t('Reservations Settings'),
    'description' => t('Allows user to select Reservation status.'),
    'weight' => 100,
      );
  $extras['choice_wrapper'] = array(
    'label' => t('Reservations Choices'),
    'description' => t('Child items included in the Reservation.'),
    'weight' => 80,
  );
  return $extras;
}

/**
 * Implements hook_node_operations().
 */
function reservations_node_operations($return = NULL) {
  $operations = array(
    'reservations_update' => array(
      'label' => t('Confirm Reservation(s)'),
      'callback' => 'reservations_operations_update',
    ),
  );
  return $operations;
}

/**
 * Implements hook_token_list().
 *
 */
function reservations_token_list($type = 'all') {
  if ($type == 'node' || $type == 'all') {
    //@TODO: Fix This Token
    //$tokens['node']['reservations_resources'] = t('Reserved resource');
    return $tokens;
  }
}



/**
 * Implements hook_views_api().
 */
function reservations_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'reservations'),
  );
}

/**
 * Implements hook_views_handlers().
 */
function reservations_views_handlers() {
  return array(
    'info' => array(
      'path' => drupal_get_path('module', 'reservations') . '/handlers',
    ),
    'handlers' => array(
      'views_handler_field_item_node_nid' => array(
        'parent' => 'views_handler_field_prerender_list',
        'file' => 'views_handler_field_item_node_nid.inc',
      ),
      'reservations_handler_field_reservations_node_type_type_setting' => array(
        'parent' => 'views_handler_field',
        'file' => 'reservations_handler_field.inc',
      ),
      'reservations_handler_filter_reservations_node_type_type_setting' => array(
        'parent' => 'views_handler_filter_in_operator',
        'file' => 'reservations_handler_filter_in_operator.inc',
      ),
      'reservations_handler_field_reservations_node_type_status' => array(
        'parent' => 'views_handler_field',
        'file' => 'reservations_handler_field.inc',
      ),
      'reservations_handler_filter_reservations_node_type_status' => array(
        'parent' => 'views_handler_filter_in_operator',
        'file' => 'reservations_handler_filter_in_operator.inc',
      ),
      'reservations_handler_field_reservations_reservation_status' => array(
        'parent' => 'views_handler_field',
        'file' => 'reservations_handler_field.inc',
      ),
      'reservations_handler_filter_reservations_reservation_status' => array(
        'parent' => 'views_handler_filter_in_operator',
        'file' => 'reservations_handler_filter_in_operator.inc',
      ),
      'reservations_handler_field_reservations_bucket_resource_node_default_availability' => array(
        'parent' => 'views_handler_field',
        'file' => 'reservations_handler_field.inc',
      ),
      'reservations_handler_filter_reservations_bucket_resource_node_default_availability' => array(
        'parent' => 'views_handler_filter_in_operator',
        'file' => 'reservations_handler_filter_in_operator.inc',
      ),
      'reservations_handler_field_reservations_bucket_resource_node_sub_type' => array(
        'parent' => 'views_handler_field',
        'file' => 'reservations_handler_field.inc',
      ),
      'reservations_handler_filter_reservations_bucket_resource_node_sub_type' => array(
        'parent' => 'views_handler_filter_in_operator',
        'file' => 'reservations_handler_filter_in_operator.inc',
      ),
      // filter
      'reservations_views_handler_filter_reserved_item_nid' => array(
        'parent' => 'views_handler_filter_many_to_one',
      ),
      'reservations_handler_field_reservations_reservation_item_node_item_status' => array(
        'parent' => 'views_handler_field',
        'file' => 'reservations_handler_field.inc',
      ),
      'reservations_handler_filter_reservations_reservation_item_node_item_status' => array(
        'parent' => 'views_handler_filter_in_operator',
        'file' => 'reservations_handler_filter_in_operator.inc',
      ),
    ),
  );
}

/**
 * Implements hook_cron().
 */
function reservations_cron() {

  if (FALSE) {
  // 2009-05-22 20:45:00
  $time = gmdate('Y-m-j H:i:s');

  $nodes = reservations_db_reservations_by_status_in_timespan(array(RESERVATIONS_STATUS_UNCONFIRMED, RESERVATIONS_STATUS_PENDING), $time, $time);

  foreach (array_keys($nodes) as $reservation_nid) {

    $reservation = node_load($reservation_nid);

    //check child items of that reservations for autocheckout
    foreach ($reservaton->reservations_reservation_items as $item) {
      $node = node_load($item['reservations_item_nid']);
      if (!$node or !$node->reservations_autocheckout) {
        // skip out to the next reservation.
        continue 2;
      }
  }

    //after checking all of the autocheckout settings for all the child items, are they all autocheckout?
    watchdog('reservations', "Setting node " . $reservation_nid . " to checked out");
    $reservation->reservations_reservation_status = RESERVATIONS_STATUS_CHECKED_OUT;
    node_save($reservation);
  }

  $nodes = reservations_db_reservations_by_status_in_timespan(array(RESERVATIONS_STATUS_CHECKED_OUT), NULL, $time);

  foreach (array_keys($nodes) as $reservation_nid) {

    //check child items of that reservations for autocheckin
    $reservation = node_load($reservation_nid);

    foreach ($reservaton->reservations_reservation_items as $item) {
      $node = node_load($item['reservations_item_nid']);
      if (!$node or !$node->reservations_autocheckin) {
        // skip out to the next reservation.
        continue 2;
        }
      }

    //after checking all of the autocheckout settings for all the child items, are they all autocheckout?
    watchdog('reservations', "Setting node " . $reservation_nid . " to checked in");
    $reservation->reservations_reservation_status = RESERVATIONS_STATUS_CHECKED_IN;
    node_save($reservation);
  }

  // Give no shows a one hour grace period.
  // TODO: move grace period to admin option.
  // 2009-05-22 20:45:00
  $time = gmdate('Y-m-j H:i:s', time() + 3600);
  //find all pending reservations that have started and set their stauts to no show
  $nodes = reservations_db_reservations_by_status_in_timespan(array(RESERVATIONS_STATUS_PENDING), $time, NULL);

  foreach (array_keys($nodes) as $reservation_nid) {
    watchdog('reservations', "Setting node " . $reservation_nid . " to no show");
    $node = node_load($reservation_nid);
    $node->reservations_reservation_status = RESERVATIONS_STATUS_NO_SHOW;
    node_save($node);
  }
  }
}

/**
 * Implements hook_view().
 */
function reservations_view($node, $view_mode) {
  // TODO: should we fix node previews?
  if (!isset($node->preview)) {
    $node->content['reservations_reservation_status'] = reservations_display_reservation_status(reservations_record_status($node->reservations_reservation_status));
    if ($view_mode == 'full' && node_is_page($node)) {
      $reservation_table = drupal_get_form('reservations_build_reservation_table_form', $node);
      //$node = node_prepare($node, $teaser);
      $node->content['reservations_reservation_items'] = $reservation_table;
    }
  }
  return $node;
}

/**
 * Implements hook_load().
 */
function reservations_load($nodes) {
  //dsm('reservations_load');
  //dsm($nodes);
  foreach ($nodes as $nid => &$node) {
    $return = new stdClass();
    $return->reservations_reservation_status = reservations_reservation_status($node);

    // TODO get rid of reservations array.  should match form api post fields.
    $return->reservations_reservation_items = reservations_reservation_items($node);
    
    foreach ($return as $property => &$value) {
      //dsm($value);
      $node->$property = $value;
    }
  }
}

/**
 * Implements hook_node_load().
 */
function reservations_node_load($nodes, $types) {
  // Process active Reservations node types and reservation nodes.
  foreach ($nodes as $nid => $node) {
    if (reservations_is_reservations_type($node->type)) {
      $settings = reservations_load_item_settings($node);
      foreach ($settings as $key => $value) {
        $nodes[$nid]->{$key} = $value;
      }
    }
  }
}

/**
 * Implements hook_node_insert().
 */
function reservations_node_insert($node) {
  // Process active Reservations node types and reservation nodes.
  if (reservations_is_reservations_type($node->type)) {
    $reservations_type = reservations_type_setting($node->type);
    drupal_write_record('reservations_' . $reservations_type . '_node', $node);
    drupal_write_record('reservations_reservation_item_node', $node);
  }
}

/**
 * Implements hook_node_update().
 */
function reservations_node_update($node) {
  // Process active Reservations node types and reservation nodes.
  if (reservations_is_reservations_type($node->type)) {
    $reservations_type = reservations_type_setting($node->type);
    if ($node->revision) {
      drupal_write_record('reservations_' . $reservations_type . '_node', $node);
      drupal_write_record('reservations_reservation_item_node', $node);
    }
    else {
      drupal_write_record('reservations_' . $reservations_type . '_node', $node, 'vid');
      drupal_write_record('reservations_reservation_item_node', $node, 'vid');
    }
  }
}

/**
 * Implements hook_node_delete().
 */
function reservations_node_delete($node) {
  // Process active Reservations node types and reservation nodes.
  if (reservations_is_reservations_type($node->type)) {
    $reservations_type = reservations_type_setting($node->type);
    $node->reservations_placeholder_nid = $node->nid;
    reservations_delete_record('reservations_reservation_detail', $node, 'reservations_placeholder_nid');
    reservations_delete_record('reservations_' . $reservations_type . '_node', $node, 'nid');
    reservations_delete_record('reservations_reservation_item_node', $node, 'nid');
    }
}

/**
 * Implements hook_node_revision_delete().
 */
function reservations_node_revision_delete($node) {
  // Process active Reservations node types and reservation nodes.
  if (reservations_is_reservations_type($node->type)) {
    $reservations_type = reservations_type_setting($node->type);
    reservations_delete_record('reservations_' . $reservations_type . '_node', $node, 'vid');
    reservations_delete_record('reservations_reservation_item_node', $node, 'vid');
  }
  elseif ($type == 'reservations_reservation') {
    reservations_delete_record('reservations_reservation', $node, 'vid');
    reservations_delete_record('reservations_reservation_detail', $node, 'vid');
  }
}

/**
 * Implements hook_theme().
 */
function reservations_theme() {
  return array(
    'reservations_choices' => array(
      'render element' => array('form' => NULL),
      'path' => drupal_get_path('module', 'reservations') . '/theme',
      'file' => 'theme.inc',
    ),
    'reservations_build_reservation_table_display' => array(
      'render element' => 'form',
      'path' => drupal_get_path('module', 'reservations') . '/theme',
      'theme path' => drupal_get_path('module', 'reservations') . '/theme',
      'file' => 'theme.inc',
    ),
    'reservations_conflict_grid' => array(
      'template' => 'reservations_conflict_grid',
      'variables' => array('type' => NULL, 'title' => NULL, 'start' => NULL, 'end' => NULL, 'nid' => NULL, 'reservation_vid' => NULL),
      'path' => drupal_get_path('module', 'reservations') . '/theme',
      'file' => 'theme.inc',
    ),
    'reservations_reservation_table' => array(
      'template' => 'reservations_reservation_table',
      'path' => drupal_get_path('module', 'reservations') . '/theme',
      'variables' => array(
        'reservations' => NULL,
        'count' => NULL,
        'hours' => NULL,
        'title' => NULL,
      ),
    ),
  );
}

/**
 * Implements hook_simpletest().
 */
function reservations_simpletest() {
  $dir = drupal_get_path('module', 'reservations') . '/tests';
  $tests = file_scan_directory($dir, '/\.test$/');
  return array_keys($tests);
}


function _reservations_content_type_info($reset = FALSE) {
  static $info;
  if ($reset || !isset($info)) {
    if (!$reset && $cached = cache_get('reservations_content_type_info')) {
      $info = $cached->data;
    }
    else {
      $info = array();
      // Load Reservations node type settings.
      $reservations_settings = db_query("SELECT * FROM {reservations_node_type} mt INNER JOIN {node_type} nt ON mt.type = nt.type WHERE reservations_type_setting <> :reservations_type_setting", array(':reservations_type_setting' => 'disabled'));
      // with the correct stuff..
      foreach ($reservations_settings as $reservations_setting) {

        $reservations_setting = (array) $reservations_setting;
        $reservations_setting['type_name'] = $reservations_setting['name'];

        //$grouping = $reservations_setting['reservations_type_setting'] == 'resource' ? $reservations_setting['type_name'] : t('Buckets');

        $tid = $reservations_setting['reservations_grouping'];
        if ($tid) {
          $term = taxonomy_term_load($tid);

          if ($term) {
            $grouping = $term->name;
            $weight = $term->weight;
          }
        }
        
        $reservations_setting['reservations_item_grouping'] = isset($grouping) ? $grouping : NULL;
        $reservations_setting['reservations_item_grouping_weight'] = isset($weight) ? $weight : NULL;
        
        //@TODO: This needs to be a hook for both inventory and pricing
        if (module_exists('reservations_inventory')) {
          $reservations_setting['inventory_tids'] = reservations_inventory_get_inventory_tids($reservations_setting['type']);
        }
        
        if (module_exists('reservations_pricing')) {
          $reservations_setting['pricing_tids'] = reservations_pricing_get_pricing_tids($reservations_setting['type']);

        }

        unset($reservations_setting['name']);
        $info[$reservations_setting['type']] = $reservations_setting;
      }
      cache_set('reservations_content_type_info', $info);
    }
  }
  return $info;
}


/**
 * Validates if an item node can be deleted.
 *
 * @param $node
 *   The item node.
 * @param $single
 *   TRUE if a single item node deletion is being processed, FALSE otherwise.
 *
 * @return
 *   TRUE if the item can be deleted, FALSE otherwise.
 */
function reservations_delete_item_validate($node) {

  $type_setting = isset($node->reservations_type_setting) ? $node->reservations_type_setting : 'disabled';

  // Only validate bucket/resource items.
  if ($node->type != 'reservations_reservation' && $type_setting != 'disabled' && isset($node->reservations_sub_type) && $node->reservations_sub_type == RESERVATIONS_SUB_TYPE_ITEM) {
    // Determine CCK table and columns the date data is stored in.
    $field = field_info_field('field_reservations_date');
    $table           = key($field['storage']['details']['sql']['FIELD_LOAD_CURRENT']);

    // Join on nid here so that any version of the reservation that contain
    // the item is caught.
    // Pull any reservations that use the item in question
    // TODO Please convert this statement to the D7 database API syntax.
    $reservations = db_query("SELECT n.nid, n.title FROM {node} n INNER JOIN {" . $table . "} ct ON ct.revision_id = n.vid INNER JOIN {reservations_reservation_detail} md ON ct.revision_id = md.vid WHERE md.reservations_item_nid = :reservations_item_nid", array(':reservations_item_nid' => $node->nid));

    $bad_reservations = array();
    foreach ($reservations as $reservation) {
      // Key by nid to prevent duplicate revisions from appearing.
      $bad_reservations[$reservation->nid] = l($reservation->title, "node/$reservation->nid/edit", array('query' => drupal_get_destination()));
    }

    if (!empty($bad_reservations)) {
      drupal_set_message(t('%title can not be deleted, because it is associated with the following reservations:', array('%title' => $node->title)) . theme('item_list', array('items' => $bad_reservations)), 'error');
      // Lock out single deletion attempts here.
      return FALSE;
    }
  }

  return TRUE;
}

/**
 * Validates saving of Reservations node types.
 */
function reservations_node_type_save_validate($form, &$form_state) {
  $values = $form_state['values'];
  // Only validate node types set to an inactive status.
  if ($values['reservations_type_setting'] != 'disabled' && (int) $values['reservations_active_status'] == RESERVATIONS_STATUS_INACTIVE) {
    // Determine CCK table and columns the date data is stored in.
    $field = field_info_field('field_reservations_date');
    $table           = key($field['storage']['details']['sql']['FIELD_LOAD_CURRENT']);
    $column_end_date = $field['storage']['details']['sql']['FIELD_LOAD_CURRENT'][$table]['value2'];

    $time = gmdate('Y-m-d H:i:s');
    $type_setting = $values['reservations_type_setting'];
    
    //@TODO: FIX THIS vvv - Currently you can't disbale inventory items.
    
    // Pull all active reservations that use the node type.
    // TODO Please convert this statement to the D7 database API syntax.
    $reservations = db_query("SELECT ctn.nid, ctn.title FROM {" . $table . "} ct INNER JOIN {reservations_reservation_detail} md ON ct.revision_id = md.vid INNER JOIN {node} ctn ON ct.revision_id = ctn.vid INNER JOIN {reservations_{$type_setting}_node} m ON md.reservations_placeholder_nid = m.nid INNER JOIN {node} mn ON m.vid = mn.vid  WHERE mn.type = :type AND m.reservations_sub_type = :reservations_sub_type AND $column_end_date >= :end AND NOT (md.reservations_item_status <= :reservations_item_status)",
      array(
        ':type' => $values['old_type'],
        ':reservations_sub_type' => RESERVATIONS_SUB_TYPE_RESERVATION,
        ':end' => $time,
        ':reservations_item_status' => RESERVATIONS_ITEM_STATUS_CHECKED_IN
      )
    );

    $bad_reservations = array();
    foreach ($reservations as $reservation) {
      $bad_reservations[] = l($reservation->title, "node/$reservation->nid/edit", array('query' => drupal_get_destination()));
    }

    if (!empty($bad_reservations)) {
      form_set_error('reservations_active_status', t('@type_setting can not be set to an inactive status until all @type_setting items are removed from the following reservations:', array('@type_setting' => $type_setting)) . theme('item_list', array('items' => $bad_reservations)));
    }
  }
}

/**
 * Validates deletion of node types.
 *
 * @param $type
 *   The type being deleted.
 */
function reservations_delete_node_type_validate(&$form) {

  $type = $form['type']['#value'];
  // Only validate active Reservations node types.
  if (reservations_is_reservations_type($type)) {
    //$settings = reservations_load_item_settings($type);
    $reservations_type_setting = reservations_type_setting($type);

    // Determine CCK table and columns the date data is stored in.
    $field = field_info_field('field_reservations_date');
    $table           = key($field['storage']['details']['sql']['FIELD_LOAD_CURRENT']);

    // Join on nid here so that any version of the reservation that contain
    // the bucket/resource is caught.
    // TODO Please convert this statement to the D7 database API syntax.
    $reservations = db_query("SELECT ctn.nid, ctn.title FROM {" . $table . "} ct INNER JOIN {reservations_reservation_detail} md ON ct.revision_id = md.vid INNER JOIN {node} ctn ON ct.entity_id = ctn.nid INNER JOIN {reservations_{$reservations_type_setting}_node} m ON md.reservations_placeholder_nid = m.nid INNER JOIN {node} mn ON m.vid = mn.vid  WHERE mn.type = :type AND m.reservations_sub_type = :reservations_sub_type ORDER BY ct.entity_id, ct.revision_id",
      array(
        ':type' => $type,
        ':reservations_sub_type' => RESERVATIONS_SUB_TYPE_RESERVATION
      )
    );

    $bad_reservations = array();
    foreach ($reservations as $reservation) {
      $bad_reservations[$reservation->nid] = l($reservation->title, "node/$reservation->nid/edit", array('query' => drupal_get_destination()));
        }

    if (!empty($bad_reservations)) {
      $name = node_type_get_name($type);
      drupal_set_message(t('@type can not be deleted because it is associated with the following reservations:', array('@type' => $name)) . theme('item_list', array('items' => $bad_reservations)), 'error');
      unset($form['actions']['submit']);
      }
  }
}

/**
 * Does the very standard things that must be done in any normal callback.
 * Used by each callback in this example module.
 */
function reservations_ahah_get_form() {
  // The form is generated in an include file which we need to include manually.
  include_once DRUPAL_ROOT . '/' . 'modules/node/node.pages.inc';
  $form_state = array(
    'storage' => NULL,
    'submitted' => FALSE,
  );
  //$form_state = array('storage' => TRUE, 'submitted' => TRUE);
  $form_build_id = $_POST['form_build_id'];
  $form = form_get_cache($form_build_id, $form_state);
  $args = $form['#parameters'];
  $form_id = array_shift($args);
  $form_state['post'] = $form['#post'] = $_POST;
  // Enable the submit/validate handlers to determine whether AHAH-submittted.
  $form_state['ahah_submission'] = TRUE;
  $form['#programmed'] = $form_state['#redirect'] = FALSE;
  // Stash original form action to avoid overwriting with drupal_rebuild_form().
  $form_state['action'] = $form['#action'];

  // Ripped off from drupal_process_form.
  // We do the same except call validation.
  $form = form_builder($form_id, $form, $form_state);

  // We have to do this in order for the date_combo to be rebuilt properly.
  $element = $form['field_reservations_date'][0];
  date_combo_validate($element, $form_state);

  // Continue ripping off drupal_proecss_form
  drupal_clean_css_identifier(NULL, TRUE);
  $form_state['redirect'] = NULL;
  form_execute_handlers('submit', $form, $form_state);

  // We'll clear out the cached copies of the form and its stored data
  // here, as we've finished with them. The in-memory copies are still
  // here, though.
  if (variable_get('cache', CACHE_DISABLED) == CACHE_DISABLED && !empty($form_state['values']['form_build_id'])) {
    cache_clear_all('form_' . $form_state['values']['form_build_id'], 'cache_form');
    cache_clear_all('storage_' . $form_state['values']['form_build_id'], 'cache_form');
  }

  // END ripping drupal_process_form.
  $form = drupal_rebuild_form($form_id, $form_state, $args, $form_build_id);
  // Clear any validation errors.  Only the date field is validated so this will clear the error so it won't
  // be outlined in red.
  form_set_error(NULL, '', TRUE);
  return array($form, $form_state);
}

/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function reservations_ahah_output($selected_portion, $show_status = FALSE) {
  if ($show_status) {
    // TODO Please change this theme call to use an associative array for the $variables parameter.
    $output .= theme('status_messages');
  }
  // To avoid doubling-up the wrapper, we have to remove it here.
  if (is_array($selected_portion)) {
    unset($selected_portion['#prefix'], $selected_portion['#suffix']);

    //$output = theme('status_messages') . drupal_render($selected_portion);
    // BAD HACK to not show validation error messages for the date combo.  Not sure how to turn validation off for that.
    $output .= drupal_render($selected_portion);
  }
  elseif (is_string($selected_portion)) {
    $output .= $selected_portion;
  }

  // Final rendering callback.
  drupal_json_output(array('status' => TRUE, 'data' => $output));

}

// TODO: should not do theming in validation funcitons.
/**
 * @todo Please document this function.
 * @see http://drupal.org/node/1354
 */
function reservations_theme_conflict_grid($type, $title, $start, $end, $value, $vid) {
  return theme('reservations_conflict_grid', array('type' => $type, 'title' => $title, 'start' => $start, 'end' => $end, 'nid' => $value, 'reservation_vid' => $vid));
}

/**
 * Builds the form item for the status display.
 *
 * @param $form_state
 *   Current form state.
 * @param $status
 *   Current status
 *
 * @return
 *   The form array.
 */
function reservations_display_reservation_status($status) {
  return array(
    '#type' => 'item',
    '#title' => t('Status'),
    '#markup' => $status,
  );
}


/**
 * Builds the table of existing reserved items.
 *
 * @param $form_state
 *   Current form state.
 * @param $node
 *   The reservation node.
 * @param $edit_page
 *   TRUE if the table is on the edit page for the reservation, FALSE otherwise.
 *
 * @return
 *   The form array.
 */
function reservations_build_reservation_table_form($form, &$form_state, $node, $edit_page = FALSE) {
  global $user;

  $table            = array();
  $table['#theme']  = 'reservations_build_reservation_table_display';
  $table['#node']   = $node;
  $table['#tree']   = TRUE;
  $table['#table']  = array();
  $table['#header'] = array(
    t('Item'),
  );

  $reservation_items = array();
  $items = (isset($node->reservations_reservation_items)) ? $node->reservations_reservation_items : NULL;

  if (!$items) {
    return $table;
  }

  $table['#header'][] = t('Type');
  foreach ($items as $did => $item) {

    if (!is_numeric($did)) {
      continue;
    }
    $form = array();

    foreach ($item as $key => $value) {
      $form[$key] = array(
        '#type' => 'value',
        '#value' => $value,
      );
    }

    $form['display_name']['#markup'] = $form['name']['#value'];
    $form['display_item_title']['#markup'] = $form['item_title']['#value'];

    if (user_access('manage reservations')) {
      $placeholder_node = node_load($item['reservations_placeholder_nid']);
      /*
        TODO fix this.
      if (reservations_has_accessories($item['type'])) {

        if (!in_array(t('Accessories'), $table['#header'])) {
          $table['#header'][] = t('Accessories');
        }

        if ($edit_page) {
          if ($node->reservations_reservation_status == RESERVATIONS_STATUS_CHECKED_OUT) {
            $collapsed = FALSE;
          }
          else {
            $collapsed = TRUE;
          }

          // Container for just the item selector.
          $form['accessories'] = array(
            '#type' => 'fieldset',
            '#title' => t('Add accessories'),
            '#collapsible' => TRUE,
            '#collapsed' => $collapsed,
            '#prefix' => '<div id="reservations-accessories-' . $placeholder_node->nid . '">',
            '#suffix' => '</div>',
            'choices' => reservations_build_accessory_form($form_state, $placeholder_node, $did),
          );
        }
        else {
          $accessories = '';
          $terms = taxonomy_node_get_terms($placeholder_node);

          if (!empty($terms)) {
            foreach ($terms as $accessory) {
              $accessories .= $accessory->name . ', ';
            }
          }
          $form['accessories'] = array(
            '#type' => 'markup',
            '#title' => t('Accessories'),
            '#value' => $accessories,
          );

        }

        //$operations .= ' &nbsp;&nbsp;' . l(t('edit'), "node/$item->reservations_placeholder_nid/edit", array('query' => drupal_get_destination()));
        // Only allow editing or deletion if unconfirmed or confirmed.
        if ($edit_page && $node->reservations_reservation_status >= RESERVATIONS_STATUS_CHECKED_OUT) {
          foreach ($form['accessories']['choices'] as $vid => $values) {
            $form['accessories']['choices'][$vid]['#disabled'] = TRUE;
          }
          $form['accessories']['#title'] = t('Accessories');
        }
      }
      */
    }
    // Only allow editing or deletion if unconfirmed or confirmed.
    if ($edit_page && $node->reservations_reservation_status < RESERVATIONS_STATUS_CHECKED_OUT) {
      if (!in_array(t('Operations'), $table['#header'])) {
        $table['#header'][] = t('Operations');
      }

      if (user_access('manage reservations') || $node->uid == $user->uid) {
        if (!in_array(t('Operations'), $table['#header'])) {
          $table['#header'][] = t('Operations');
        }
        $operations = ' &nbsp;&nbsp;' . l(t('delete'), "node/" . $item['reservations_placeholder_nid'] . "/delete", array('query' => drupal_get_destination()));
      }
      $operations .= ' &nbsp;&nbsp;' . l(t('edit'), "node/" . $item['reservations_placeholder_nid'] . "/edit", array('query' => drupal_get_destination()));
    }
    $form['ops']['#markup'] = isset($operations) ? $operations : NULL;

    $type_setting = reservations_type_setting($item['type']);

    if ($edit_page && $type_setting == 'bucket') {
      // Only users with manage reservations permission can change the bucket item assignment.
      if (user_access('manage reservations')) {

        $options = array(0 => '<' . t('Select') . '>');

	//Fetch available bucket items
	$default_available_items = 
	  reservations_get_available_bucket_items($node, $item['type']);

	//see if there is a custom view to furthur filter the items
	if (module_exists('views') && views_get_view(RESERVATIONS_AVAILABLE_BUCKET_ITEM_OVERRIDE_VIEW)) {
	  //build and execute the view using the content type of the bucket
	  $view = views_get_view(RESERVATIONS_AVAILABLE_BUCKET_ITEM_OVERRIDE_VIEW);
	  $view->set_arguments(array($item['type']));
	  $view->execute('default');       
	  $results = $view->result;

	  //iterate over the results and create a new array of items that are
	  //in the defaullt_available list and add the new label
	  $available_items = array();
	  foreach($results as $bucket_item) {
	    if ($default_available_items[$bucket_item->nid]) {
	      $available_items[$bucket_item->nid] = $bucket_item->views_php_1;
	    }
	  }
	}
	else {
	  $available_items = $default_available_items;
	}

        $options += $available_items;

        $form['reservations_item_nid'] = array(
          '#type' => 'select',
          '#options' => $options,
          '#default_value' => $item['reservations_item_nid'],
        );
        if ($node->reservations_reservation_status >= RESERVATIONS_STATUS_CHECKED_OUT) {
          $form['reservations_item_nid']['#disabled'] = TRUE;
        }
      }
    }

    //$form['#table'][$did]['accessories'] = $accessories;
    $table[$did] = $form;
  }

  return $table;
}

function reservations_add_settings_form(&$form, $form_state) {

  // Only admin can edit these values.
  if (!user_access('administer reservations')) {
    return;
  }

  $type = array_key_exists('old_type', $form) ? $form['old_type']['#value'] : $form['type']['#value'];
  //$reservations_settings = mnerci_content_types($type);
  //if (!$reservations_settings) return;
  if ($form['#id'] == 'node-type-form') {
    $node = reservations_load_item_settings($type);
    $node = (object) $node;
  }
  else {
    $node = (object) $form['#node'];
  }
  //reservations_load_item_settings($node);
  // New nodes are always sub type item.
  $sub_type = isset($node->reservations_sub_type) ? $node->reservations_sub_type : RESERVATIONS_SUB_TYPE_ITEM;
  $type_setting = isset($node->reservations_type_setting) ? $node->reservations_type_setting : NULL;

  if (empty($form['reservations'])) {
    $form['reservations'] = array(
      '#type' => 'fieldset',
      '#title' => t('Reservations settings'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#group' => 'additional_settings',
      '#attached' => array(
        'js' => array(drupal_get_path('module', 'menu') . '/menu.admin.js'),
      ),
    );
  }

  // Bucket item nodes have no individual pricing, so just zero these values out.
  // Althought you can override them on the reserervation nodes.
  if ($type_setting == 'resource' or $form['#id'] == 'node-type-form' or $sub_type == RESERVATIONS_SUB_TYPE_RESERVATION ) {
    $form['reservations']['reservations_rate_per_hour'] = array(
      '#type' => 'textfield',
      '#title' => t('Rate per hour'),
      '#size' => 10,
      '#default_value' => isset($node->reservations_rate_per_hour) ? $node->reservations_rate_per_hour : NULL,
      '#element_validate' => array('reservations_is_numeric_validate'),
      '#description' => t('The per hour rental fee for the item.'),
    );
    $form['reservations']['reservations_late_fee_per_hour'] = array(
      '#type' => 'textfield',
      '#title' => t('Late fee per hour'),
      '#size' => 10,
      '#default_value' => isset($node->reservations_late_fee_per_hour) ? $node->reservations_late_fee_per_hour : NULL,
      '#element_validate' => array('reservations_is_numeric_validate'),
      '#description' => t('The per hour fee for returning the item late.'),
    );
    $form['reservations']['reservations_fee_free_hours'] = array(
      '#type' => 'textfield',
      '#title' => t('Fee free hours'),
      '#size' => 10,
      '#default_value' => isset($node->reservations_fee_free_hours) ? $node->reservations_fee_free_hours : NULL,
      '#element_validate' => array('reservations_is_numeric_validate'),
      '#description' => t('The number of hours the item can be used before fees are charged.'),
    );
  }

  if (($type_setting  == 'resource' and $sub_type == RESERVATIONS_SUB_TYPE_ITEM) or $form['#id'] == 'node-type-form') {

    $form['reservations']['reservations_min_cancel_hours'] = array(
      '#type' => 'textfield',
      '#title' => t('Minimum hours for cancelation without No Show'),
      '#size' => 10,
      '#default_value' => isset($node->reservations_min_cancel_hours) ? $node->reservations_min_cancel_hours : NULL,
      '#element_validate' => array('reservations_is_numeric_validate'),
      '#description' => t('Minimum number of hours before the start time a user may cancel a reservation for the item.'),
    );
//     $form['reservations']['reservations_autocheckout'] = array(
//       '#type' => 'checkbox',
//       '#title' => t('Auto checkout'),
//       '#default_value' => isset($node->reservations_autocheckout) ? $node->reservations_autocheckout : NULL,
//       '#description' => t('Automatically check this item out when the Reservation starts.'),
//     );
//     $form['reservations']['reservations_autocheckin'] = array(
//       '#type' => 'checkbox',
//       '#title' => t('Auto checkin'),
//       '#default_value' => isset($node->reservations_autocheckin) ? $node->reservations_autocheckin : NULL,
//       '#description' => t('Automatically check this item in when the Reservation ends.'),
//     );
//     $form['reservations']['reservations_selfcheckout'] = array(
//       '#type' => 'checkbox',
//       '#title' => t('Self checkout'),
//       '#default_value' => isset($node->reservations_selfcheckout) ? $node->reservations_selfcheckout : NULL,
//       '#description' => t('Manage checkout with additional code.'),
//     );
  }
}

/*
function _reservations_after_build($form, &$form_state) {

  $weight = ($form['field_reservations_date']['#weight'] + 1);
  $form['field_reservations_date'][0]['field_reservations_date_button'] = array(
    '#type' => 'submit',
    '#value' => t('Limit Lists to Available Items'),
    '#weight' => $weight,
    '#submit' => array('reservations_date_filter'),
    /* TODO Fix for D7
    '#ajax' => array(
      //'path' => 'reservations/js',
      'callback' => 'reservations_choice_js',
      'wrapper' => 'reservations-choice-wrapper',
      'method' => 'replace',
      'effect' => 'fade',
    ),

  );

  return $form;
}
 */




/**
 * Implements hook_node_type_insert().
 */
function reservations_node_type_insert($info) {
  reservations_node_type_update_variables($info, FALSE);
  cache_clear_all('reservations_' . $info->type . '_data', 'cache');
  cache_clear_all('reservations_content_type_info', 'cache');
}

/**
 * Implements hook_node_type_update().
 */
function reservations_node_type_update($info) {
  if (isset($info->old_type) && $info->type != $info->old_type) {
    // TODO Please review the conversion of this statement to the D7 database API syntax.
    /* db_query("UPDATE {reservations_node_type} SET type = '%s' WHERE type = '%s'", $info->type, $info->old_type) */
    db_update('reservations_node_type')
  ->fields(array(
      'type' => $info->type,
    ))
  ->condition('type', $info->old_type)
  ->execute();
  }
  reservations_node_type_update_variables($info, TRUE);
  cache_clear_all('reservations_' . $info->type . '_data', 'cache');
  cache_clear_all('reservations_content_type_info', 'cache');
}

// @TODO: date_convert no longer exist so I think this can be removed
function reservations_convert_date_popup($dates, $date_format   = 'm/d/Y g:ia') {
  module_load_include('inc', 'date_api', 'date_api_elements');

  $date_timezone = variable_get('date_default_timezone', 'UTC');
  $start = new DateObject($dates['value']['date'] . ' ' . $dates['value']['time'], $date_timezone, $date_format);
  $end = new DateObject($dates['value2']['date'] . ' ' . $dates['value2']['time'], $date_timezone, $date_format);
  date_timezone_set($start, timezone_open('UTC'));
  date_timezone_set($end, timezone_open('UTC'));

  //$start = $start->format(DATE_DATETIME);
  //$end = $end->format(DATE_DATETIME);

  $start = $start->format($date_format);
  $end = $end->format($date_format);

  return array('value' => $start, 'value2' => $end);

  //@TODO: Figure out why the rest of this even here?
  $start         = array(
    '#value' => array(
      'date' => $dates['value']['date'],
      'time' => $dates['value']['time'],
    ),
    '#date_timezone' => $date_timezone,
    '#date_format' => $date_format,
  );
  $end = array(
    '#value' => array(
      'date' => $dates['value2']['date'],
      'time' => $dates['value2']['time'],
    ),
    '#date_timezone' => $date_timezone,
    '#date_format' => $date_format,
  );
  $start = date_popup_input_value($start);
  $end = date_popup_input_value($end);
  $start = date_create($start);
  $end   = date_create($end);
  date_timezone_set($start, timezone_open('UTC'));
  date_timezone_set($end, timezone_open('UTC'));
  $start = date_convert($start, DATE_OBJECT, DATE_DATETIME);
  $end = date_convert($end, DATE_OBJECT, DATE_DATETIME);
  return array('value' => $start, 'value2' => $end);
}

function reservations_node_type_status($code = NULL) {
  $statuses = array(
    RESERVATIONS_STATUS_ACTIVE => t('Active'),
    RESERVATIONS_STATUS_INACTIVE => t('Inactive'),
  );
  if (isset($code)) {
    return $statuses[$code];
  }
  else {
    return $statuses;
  }
}

/**
 * Implements hook_token_values().
 * @see reservations_token_list()
 */
function reservations_token_values($type, $object = NULL, $options = array()) {
  switch ($type) {
    case 'node':
      $node = reservations_load($object);
      if ($node) {
        $values['reservations_resources'] = '';

        // We want these timestamps generated in UTC.
        $old_timezone = date_default_timezone_get();
        date_default_timezone_set('UTC');
        $starthour = strtotime($node->field_reservations_date[0]['value']);
        $endhour = strtotime($node->field_reservations_date[0]['value2']);
        date_default_timezone_set($old_timezone);
        $hours = round(($endhour - $starthour) / 3600, 2);
        $titles = array();
        foreach ($node->reservations_reservation_items as $item) {
          $item_node = node_load($item['reservations_placeholder_nid']);
          if ($item['item_title'] != '') {
            $titles[] = $item['item_title'];
  }
          else {
            $titles[] = $item['reservations_placeholder_title'];
    }
  }

        $values['reservations_resources'] = check_plain(implode(", ", $titles));
        return $values;
      }
  }
}


/**
 * Builds the list of all currently reservable items, filtered by date.
 *
 * @param $node
 *   The reservation node object.
 * @param $form_state
 *   Current form state array.
 * @param $reservation_nid
 *   (Optional) The nid of a reservation to ignore in the options exclusions.
 *
 * @return
 *   An associative array with the following key/value pairs:
 *     'options'      => An array of available items, in the format used
 *                       for the item selector.
 */
function reservations_build_reservable_items($node, $form_state, $reservation_nid = NULL) {
  //dsm('reservations_build_reservable_items');
    
  $inventory = module_exists('reservations_inventory') ? reservations_inventory_set_inventory($node) : NULL;
  
  $langcode = $node->language;
  // Newly set dates take precedence.
  if (isset($form_state['values']['field_reservations_date'])) {
    $start = $form_state['values']['field_reservations_date'][$langcode][0]['value'];
    $end = $form_state['values']['field_reservations_date'][$langcode][0]['value2'];
  }
  // Dates loaded from the reservation are next.
  elseif (isset($node->nid)) {
    $date_info = $node->field_reservations_date[$langcode][0];
    $start     = $date_info['value'];
    $end       = $date_info['value2'];
  }
  // New reservation, so no date filtering.
  else {
    $is_new = TRUE;
    $start     = NULL;
    $end       = NULL;
  }

  $options = array();
  
  //@TODO - Why is the select list selecting the last item?
  $options['options'][''] = '<' . t('Select') . '>';
  
  $vid = variable_get('reservations_grouping_vid', 0);
  
  $terms = taxonomy_get_tree($vid);
  foreach ($terms as $term) {
    $options['options'][$term->name] = array();
  }
  
  $reservable_types = reservations_content_types();
  
  // This array holds all reservable items the user may reserve.
  // Loop through each reserable type.
  foreach ($reservable_types as $reservable_type) {

    $include = FALSE;  // default to skipping the type unless 
    
    if ($inventory) {
      foreach ($reservable_type['inventory_tids'] as $tid) {
        
        if ($tid == $inventory) {
          $include = TRUE;
        }
      }
    } else {
      // if there is no inventory, include everything
      $include = TRUE;
    }
    
    if ($include) {
     
	  if ($reservable_type['reservations_active_status'] != RESERVATIONS_STATUS_ACTIVE) {
	    continue;
	  }
	  
	  if (!reservations_check_content_type_user_permissions($reservable_type['type'])) {
	    continue;
	  }
	  
	  if (empty($is_new)) {
	    $restrictions = reservations_check_content_type_restrictions($reservable_type['type'], $start, $end);
		if (!empty($restrictions)) {
		  continue;
		}
	  }
	
	  	
	  // if it's a bucket, add it to the select list
	  if ($reservable_type['reservations_type_setting'] == 'bucket') {
	    // Check for available items in the bucket at the time when time is included
	    $available_bucket_items = reservations_get_available_bucket_count($reservable_type['type'], $start, $end, $reservation_nid) - $reservable_type['reservations_spare_items'];
		  if ($available_bucket_items) {
		    $options['options'][$reservable_type['reservations_item_grouping']][$key] = $reservable_type['type_name'];
		  } else {
		    //disable item in list
		    //$options['options'][$reservable_type['reservations_item_grouping']][$key] = $reservable_type['type_name'];
		    
		    //dsm($options);
		    //$form['myboxes']['bar'] = array( '#disabled' => TRUE,);
		  }
	   } //
	   elseif ($reservable_type['reservations_type_setting'] == 'resource') {
	     // No date filtering for new reservations.
		 $item_options = reservations_get_reservable_items($reservable_type['type'], $start, $end, $reservation_nid);
		 
		 if (!empty($item_options)) {
		   foreach ($item_options as $key => $item) { 
			 $options['options'][$reservable_type['reservations_item_grouping']][$key] = $item;
		    }
		  } else {
		    //disable item in list
		  }
	   }  
    } // $inventroy include
  }

  //dsm($option);
  
  // Remove grouping keys with no items.
  foreach ($terms as $term) {
    if (empty($options['options'][$term->name])) {
      unset ($options['options'][$term->name]);
    }
  }
  
  return $options;
}

/**
 * POTENITALLY DEPRECATED FUNCTIONS
 */
 
function reservations_type_setting_after_build($element) {
  foreach ($element['#description_items'] as $key => $value) {
    $element[$key]['#description'] = $value;
  }
  return $element;
}

function reservations_taxonomy_term_select($title, $name, $value, $vocabulary_id, $description, $multiple, $blank, $exclude = array()) {
  $tree = taxonomy_get_tree($vocabulary_id);
  $options = array();

  if ($blank) {
    $options[''] = $blank;
  }
  if ($tree) {
    foreach ($tree as $term) {
      if (!in_array($term->tid, $exclude)) {
        $choice = new stdClass();
        $choice->option = array($term->tid => str_repeat('-', $term->depth) . $term->name);
        $options[] = $choice;
      }
    }
  }
  
  //dsm($value);
  
  return array(
    '#type' => 'select',
    '#title' => $title,
    '#default_value' => $value,
    '#options' => $options,
    '#description' => $description,
    '#multiple' => $multiple,
    '#size' => $multiple ? min(9, count($options)) : 0,
    '#weight' => -9,
  );
}

/**
 * POTENITALLY DEPRECATED FUNCTIONS
 */
 
 function reservations_build_accessory_form($form_state, $node, $did) {

  $vocabularies = taxonomy_get_vocabularies($node->type);

  $form = array();

  foreach ($node->taxonomy as $tid => $term) {
    $value[] = $tid;
  }
  foreach ($vocabularies as $vocabulary) {

    $taxonomy_form   = taxonomy_form($vocabulary->vid, $value);
    $taxonomy_form['#title'] = '';
    unset($taxonomy_form['#theme']);
    $taxonomy_form['#ajax'] = array(
      'path' => 'reservations/taxonomy/' . $node->nid . '/' . $vocabulary->vid . '/' . $did,
      'wrapper' => 'reservations-accessories-' . $node->nid,
      'method' => 'prepend',
      'effect' => 'fade',
    );
    $form[$vocabulary->vid] = $taxonomy_form;
  }
  return $form;
}



/*

  $items['reservations/taxonomy/%node/%/%'] = array(
    'title' => 'JSON interface for node taxonomy',
    'description' => 'Takes a node ID and returns taxonomy data as JSON',
    'page callback' => 'reservations_taxonomy_json',
    'access arguments' => array('manage reservations'),
    'page arguments' => array(2, 3, 4),
    'file' => 'includes/menu.inc',
    'type' => MENU_CALLBACK,
    );
  
*/


/**
 * Builds an individual item selector.
 *
 * @param $node
 *   The reservation node object.
 * @param $form_state
 *   Current form state array.
 * @param $delta
 *   Which selector number to build.
 * @param $default
 *   Default value for the select.
 *
 * @return
 *   The form array for the selector.
 */
function _reservations_choice_form($node, $form_state, $delta, $default = '', $reset = NULL) {

  static $options = array();

  // We'll manually set the #parents property of these fields so that
  // their values appear in the $form_state['values']['choice'] array.
  //$buckets = t('Buckets');
  if (empty($options) or $reset) {
    // NOTE: we don't filter by node here because we only want items not
    //reserved by any node including the node calling the function.
    $options = reservations_build_reservable_items($node, $form_state, NULL);

  }

  $form = array(
    '#type' => 'select',
    '#options' => $options['options'],
    '#default_value' => $default,
    //'#parents' => array('choice', $delta, 'item'),
  );

  return $form;
}

function _reservations_sort_array($a, $b) {
  return count($b) - count($a);
}
