<?php
/**
 * @file
 * Watchdog Messages module.
 *
 * This module provides a framework for capturing watchdog entries,
 * or display them on the page.
 */

/**
 * Implements hook_form_system_logging_settings_alter().
 */
function watchdog_messages_form_system_logging_settings_alter(&$form, &$form_state) {
  $form['watchdog_messages_capture_all'] = array(
    '#type' => 'checkbox',
    '#title' => 'Capture all watchdog entries and display as messages',
    '#default_value' => variable_get('watchdog_messages_capture_all', FALSE),
    '#weight' => -1,
  );
}

/**
 * Start capturing watchdog entries.
 */
function watchdog_messages_capture($options = array()) {
  $class = variable_get('watchdog_messages_default_class', 'WatchdogMessagesCapture');
  return new $class($options);
}

/**
 * Implements hook_watchdog().
 */
function watchdog_messages_watchdog(array $log_entry) {
  $class = variable_get('watchdog_messages_default_class', 'WatchdogMessagesCapture');
  $class::capture($log_entry);
}

/**
 * Watchdog Capturing class.
 */
class WatchdogMessagesCapture {
  public static $captured = array();
  public static $captureAll = NULL;
  public $options = array();
  public $entries = array();

  /**
   * Constructor. Begin capturing.
   */
  public function __construct(array $options = array()) {
    // Setup variables.
    $this->id = count(self::$captured);
    $this->options['object'] = $this;
    $this->options += $options + array(
      'render' => TRUE,
      'render callback' => variable_get('watchdog_messages_default_render_callback', NULL),
    );

    // Determine proper capture mode (to render or not to render).
    if (self::$captured) {
      $last_capture = end(self::$captured);
      $this->options['render'] |= $last_capture->options['render'];
    }
    self::$captured[$this->id] = $this;
  }

  /**
   * Capture watchdog log entry.
   */
  public static function capture(array $log_entry) {
    if (!self::$captured) {
      // Capture all if applicable.
      // (i.e. configured to do so, and this is not a cron run).
      if (
        variable_get('watchdog_messages_capture_all', FALSE) &&
        basename($_SERVER['PHP_SELF']) != 'cron.php'
      ) {
        self::$captureAll = watchdog_messages_capture();
      }
      else {
        return;
      }
    }

    // Propagate entry to all consumers.
    foreach (self::$captured as $capture) {
      $capture->entries[] = $log_entry;
    }

    // Display the message if applicable.
    if ($capture->options['render']) {
      $capture->render($log_entry);
    }
  }

  /**
   * Default render callback for displaying watchdog entries as messages.
   */
  public function render(array $log_entry) {
    if (!empty($this->options['render callback']) && is_callable($this->options['render callback'])) {
      return call_user_func($this->options['render callback'], $log_entry, $this);
    }

    // Filter if necessary.
    if (!empty($this->options['filter']) && !in_array($log_entry['type'], $this->options['filter'])) {
      return;
    }

    // Determine message status based on severity.
    if ($log_entry['severity'] >= WATCHDOG_INFO) {
      $severity = 'status';
    }
    elseif ($log_entry['severity'] >= WATCHDOG_WARNING) {
      $severity = 'warning';
    }
    else {
      $severity = 'error';
    }
    // The array log entry doesn't necessarily contain variables and t()
    // expects an array.
    if (is_array($log_entry['variables'])) {
      $vars = $log_entry['variables'];
    }
    else {
      $vars = array();
    }

    drupal_set_message(t($log_entry['message'], $vars), $severity);
  }


  /**
   * Destructor. Don't capture anymore.
   */
  public function __destruct() {
    unset(self::$captured[$this->id]);
  }
}
