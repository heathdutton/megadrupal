<?php
/**
 * @file
 * Debugging functions to be used with "tail -f".
 */

global $devel_ext_log_on;
$devel_ext_log_on = TRUE;

/**
 * Drupal debug with indents.
 *
 * Indents debug prints based on the depth of the function call stack. This
 * makes it easier to trace code where a lot of functions are calling a lot of
 * other functions and/or themselves. Very useful when debugging the core.
 *
 * @param Mixed $thing
 *   A string, an object or an array.
 * @param String $label
 *   An optional label to be printed before the data.
 * @param Array $options
 *   Options to alter the debug output.
 *   Set index 'show_pid' to any value:
 *     Print out the process id if this is set. Useful when there are multiple
 *     processes running on a single page load.
 *   Set index 'indent' to an integer value:
 *     Alter the indentation by the specified value. Used by ddf().
 *   Set no_indent to any value:
 *     Disables indenting. Used by ddt.
 */
function ddi($thing, $label = FALSE, $options = FALSE) {
  // Print out something useful even if something false was passed as the
  // argument.
  if (!$thing) {
    if (is_null($thing)) {
      $thing = '<null>';
    }
    elseif ($thing === FALSE) {
      $thing = '<false>';
    }
    elseif ($thing === '') {
      $thing = '<zero length string>';
    }
    elseif ($thing === array()) {
      $thing = '<empty array>';
    }
    elseif ($thing === 0 || $thing === (float) 0) {
      $thing = '0';
    }
    else {
      $thing = '<something that evaluates as false>';
    }
  }

  // Add the correct amount of indent.
  $indent = '';
  if (!isset($options['no_indent'])) {
    $c = count(debug_backtrace());
    isset($options['indent']) ? $indent_alter = $options['indent'] : $indent_alter = 0;
    for ($i = 0; $i < $c + $indent_alter; $i++) {
      $indent .= '..';
    }
  }

  // Turn arrays and objects into strings so we can handle them the same way.
  if (is_array($thing) || is_object($thing)) {
    $thing = print_r($thing, TRUE);
  }

  // Process each line, adding indents and pids as required.
  $out = explode("\n", $thing);
  foreach ($out as &$line) {
    $line = $indent . $line;
    if (isset($options['show_pid'])) {
      $line = getmypid() . ' ' . $line;
    }
  }
  $out = implode("\n", $out) . "\n";

  // Add the label so that it doesn't mess up the indenting. Print out only as
  // much of the label as there is room with the indents.
  if ($label) {
    if (!isset($options['no_indent'])) {
      $li = strlen($indent);
      $usable_label_length = $li - 2;
      $usable_label = substr($label, 0, $usable_label_length);
      $padded_label = str_pad($usable_label, $li, '.');
      $out = $padded_label . substr($out, $li);
    }
    else {
      $out = $label . ': ' . $out;
    }
  }

  // This allows us to use the debugging functions even before the temporary
  // wrapper is defined. To use the debugging function _really_ early,
  // add this to your index.php and cron.php , just after the define() for
  // DRUPAL_ROOT:
  // require_once(DRUPAL_ROOT . '/sites/all/modules/devel_ext_log/devel_ext_log.module');
  //
  // If you use drush, and want to use the debug functions early on, you also
  // need to add an include to drush code. One place to do so is in
  // _drush_bootstrap_select_drupal_site(), after $drupal_root has been
  // defined:
  // require_once($drupal_root . '/sites/all/modules/devel_ext_log/devel_ext_log.module');
  if (in_array('temporary', stream_get_wrappers())) {
    $file = 'temporary://drupal_debug.txt';
  }
  else {
    $file = '/tmp/drupal_debug.txt';
  }

  // In order to debug print from SimpleTests, you need to hardcode the
  // target file name. Do this by changing the following FALSE to TRUE.
  // Otherwise the temporary file used will be the temporary file of the
  // SimpleTest sandbox, and not the one you're looking at.
  if (TRUE) {
    $file = '/tmp/drupal_debug.txt';
  }

  // Final output.
  global $devel_ext_log_on;
  if ($devel_ext_log_on) {
    if (file_put_contents($file, $out, FILE_APPEND) === FALSE) {
      drupal_set_message(t('The file could not be written.'), 'error');
      return FALSE;
    }
  }
}


/**
 * Drupal debug shallow.
 *
 * Logs just the the keys of an array or the attributes of an object. Useful
 * when dumping a node object, for example, when you want to see what's
 * available in the object without scrolling through 500kB of data.
 *
 * @param mixed $thing
 *   The thing to dump.
 */
function dds($thing, $label = FALSE) {
  if (is_object($thing)) {
    $out = 'Object:';
  }
  elseif (is_array($thing)) {
    $out = "Array:";
  }
  else {
    $out = "String:";
  }

  if (is_object($thing) || is_array($thing)) {
    $out .= "\n(\n";
    foreach ($thing as $key => $value) {
      $out .= "\t[" . $key . "]";
      $out .= "\n";
    }
    $out .= ")";
  }
  else {
    $out .= $thing;
  }

  ddi($out, $label, array('indent' => -1));
}


/**
 * Drupal debug backtrace.
 *
 * Convenience function for printing the function names only from the function
 * call stack. Useful when tracing code execution.
 */
function ddb() {
  $deb = debug_backtrace();
  $functions = array();
  foreach ($deb as $key => $value) {
    $dbstr = '';
    if (isset($value['class'])) {
      $dbstr .= $value['class'] . '->';
    }
    $dbstr .= $value['function'];
    $functions[] = $dbstr;
  }
  ddi($functions, 'Function call stack');
}


/**
 * Drupal debug function name.
 *
 * Logs the name of the current function. If you add a call to this function
 * to the beginning of every function you add any logging in, it'll be easier
 * to find all the places where you've done some logging. We deduct one step
 * from the indent to take out the effect of calling _this_ function, so that
 * the output stays on the same indent level.
 */
function ddf($thing = '', $show_pid = FALSE) {
  $t = debug_backtrace();
  $str = '';
  if (isset($t[1]['class'])) {
    $str .= strtoupper($t[1]['class']) . '->';
  }
  $str .= strtoupper($t[1]['function']);
  $label = 'Function';
  if ($show_pid) {
    $label = getmypid() . ' ' . $label;
  }
  $str .= ' ' . $thing;
  ddi($str, $label, array('indent' => -1));
}


/**
 * Drupal debug up.
 *
 * Works only when viewing the debug log in a terminal window, for example
 * with "tail -f /tmp/drupal_debug.txt" . Sends control characters for "cursor
 * up" before printing. Allows debug printing inside large loops without
 * scrolling the interesting bits out of terminal history. Useful when debug
 * printing counters, mostly: "Now processing element N...".
 *
 * @param Mixed $thing
 *   The thing to dump, passed to ddi().
 * @param Array $options
 *   Options array, passed to ddi().
 */
function ddu($thing, $options = FALSE) {
  $file = 'temporary://drupal_debug.txt';
  file_put_contents($file, chr(27) . "[A", FILE_APPEND);
  ddi($thing, $options);
}


/**
 * Drupal debug with time.
 *
 * Adds code execution timer to the debug messages. If you're trying to figure
 * out what's taking so long in loading your Drupal instance, add calls to
 * ddt() into functions you found using ddb(). The resulting logs tell you
 * which part of code execution took the longest.
 *
 * Indenting is disabled by default, since the execution time report is much
 * easier to read without it.
 *
 * @param Mixed $thing
 *   The debug message. Dumping arrays here won't look very nice, but it's
 *   your call.
 * @param Boolean $indent
 *   Indenting on or off?
 * @param Array $options
 *   An options array that's passed to ddi().
 */
function ddt($thing = FALSE, $indent = FALSE, $options = FALSE) {
  $msg_pad = 65;
  $time_pad = 12;
  static $start_time;
  static $previous_lap;
  if (!$start_time) {
    $start_time = microtime(TRUE);
    if (!$thing) {
      $thing = 'Start debug timing...';
    }
    ddi($thing);
    $previous_lap = $start_time;
  }
  else {
    $now = microtime(TRUE);
    $lap = substr(round($now - $start_time, $time_pad), 0, $time_pad);
    $lap_time = substr(round($now - $previous_lap, $time_pad), 0, $time_pad);

    $previous_lap = $now;
    if ($thing) {
      $message = str_pad(print_r($thing, TRUE) . ' ', $msg_pad, '.') . ': ' . str_pad($lap, $time_pad, '0', STR_PAD_RIGHT) . ' / ' . str_pad($lap_time, $time_pad, '0', STR_PAD_RIGHT);
    }
    else {
      $message = str_pad('', $msg_pad, '.') . ': ' . str_pad($lap, $time_pad, '0', STR_PAD_RIGHT) . ' / ' . str_pad($lap_time, $time_pad, '0', STR_PAD_RIGHT);
    }
    ddi($message, 'Time', ($indent ? array() : array('no_indent' => TRUE)), $options);
  }
}

/**
 * Turns debug logging on.
 */
function ddon() {
  global $devel_ext_log_on;
  if (!$devel_ext_log_on) {
    // Show where the debug is turned on.
    $temp = debug_backtrace();
    ddi('ddon() @ ' . $temp[1]['function']);
  }
  $devel_ext_log_on = TRUE;
}

/**
 * Turns debug logging off.
 */
function ddoff() {
  global $devel_ext_log_on;
  if ($devel_ext_log_on) {
    // Show where the debug is turned off.
    $temp = debug_backtrace();
    ddi('ddoff() @ ' . $temp[1]['function']);
  }
  $devel_ext_log_on = FALSE;
}
