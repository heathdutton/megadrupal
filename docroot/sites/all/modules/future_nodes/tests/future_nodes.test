<?php

/**
 * @file
 * Contains tests for the Future Nodes module.
 */




abstract class FutureNodesTestCase extends DrupalWebTestCase {
  protected $admin_user;
  protected $nodes;


  /**
   * Implements setUp().
   */
  function setUp() {
    $this->profile = 'minimal';

    // Call the parent with an array of modules to enable for the test.
    parent::setUp(array('future_nodes'));

    $this->drupalCreateContentType(array('type' => 'page', 'name' => 'Basic page'));

    $this->admin_user = $this->drupalCreateUser(array(
      'create page content',
      'access content',
      'bypass future nodes access',
      'administer nodes',
    ));
    $this->drupalLogin($this->admin_user);

    $this->nodes = array();
    $this->addNode('unpublished', array(
      'status' => 0,
      'created' => REQUEST_TIME - 86400,
    ));
    $this->addNode('past', array(
      'created' => REQUEST_TIME - 86400,
    ));
    $this->addNode('now', array(
      'created' => REQUEST_TIME,
    ));
    $this->addNode('future', array(
      'created' => REQUEST_TIME + 86400,
    ));

    $this->verbose('<pre>' . print_r($this->nodes, TRUE) . '</pre>');
  }

  private function addNode($key, $params) {
    $this->nodes[$key] = array(
      'node-access' => FALSE,
      'list-access' => FALSE,
      'node' => $this->drupalCreateNode($params + array(
        'type' => 'page',
        'promote' => 1,
        'status' => 1,
        'uid' => $this->admin_user->uid,
      ))
    );
  }

  public function assertResponseCode($expectedResponseCode) {
    // Grab the headers from the request and debug them out.
    $headers = $this->drupalGetHeaders(TRUE);
    $this->verbose('<pre>' . print_r($headers, TRUE) . '</pre>');

    // Look for the expected response code in the header status.
    // If strpos() returns FALSE, that means it is not present.
    $this->assert(
      strpos($headers[0][':status'], $expectedResponseCode) !== FALSE,
      t('Looking for response code @expected, actual response code @header', array(
        '@expected' => $expectedResponseCode,
        '@header' => $headers[0][':status'],
      ))
    );
  }



  protected function commonGroupTest($extra_permissions) {
    $perms = array_merge(array(
      'access content',
    ), $extra_permissions);

    $user = $this->drupalCreateUser($perms);
    $this->verbose('<pre>' . print_r($user, TRUE) . '</pre>');
    $this->drupalLogin($user);

    $this->drupalGet('node');

    foreach ($this->nodes as $key => $node) {
      if ($node['list-access']) {
        $this->assertText($node['node']->title);
      }
      else {
        $this->assertNoText($node['node']->title);
      }
    }

    // Now try to access each node directly.
    foreach ($this->nodes as $node) {
      // Do a HEAD request (don't care about the body). The alias=>TRUE is to tell Drupal not to lookup the alias - this is a raw request.
      $this->drupalGet('node/' . $node['node']->nid, array('alias' => TRUE));


      if ($node['node-access']) {
        $this->assertResponseCode('200');
      }
      else {
        $this->assertResponseCode('403');
      }
    }
  }
}


class FutureNodesTestCaseWithNoBypass extends FutureNodesTestCase {

  /**
   * Implements getInfo().
   */
  public static function getInfo() {
    return array(
      'name' => t('User with no bypass permission'),
      'description' => t('Runs tests against the access control for Future Nodes with no bypass'),
      'group' => t('Future Nodes'),
    );
  }

  public function testGroup() {
    $this->nodes['past']['node-access'] = $this->nodes['past']['list-access'] = TRUE;
    $this->nodes['now' ]['node-access'] = $this->nodes['now' ]['list-access'] = TRUE;
    $this->commonGroupTest(array());
  }
}


class FutureNodesTestCaseWithFutureNodeBypass extends FutureNodesTestCase {
  /**
   * Implements getInfo().
   */
  public static function getInfo() {
    return array(
      'name' => t('User with module bypass permission'),
      'description' => t('Runs tests against the access control for Future Nodes with module bypass'),
      'group' => t('Future Nodes'),
    );
  }

  public function testGroup() {
    $this->nodes['past'   ]['node-access'] = $this->nodes['past'   ]['list-access'] = TRUE;
    $this->nodes['now'    ]['node-access'] = $this->nodes['now'    ]['list-access'] = TRUE;
    $this->nodes['future' ]['node-access'] = $this->nodes['future' ]['list-access'] = TRUE;

    $this->commonGroupTest(array('bypass future nodes access'));
  }
}



class FutureNodesTestCaseWithCoreNodeBypass extends FutureNodesTestCase {
  /**
   * Implements getInfo().
   */
  public static function getInfo() {
    return array(
      'name' => t('User with core bypass permission'),
      'description' => t('Runs tests against the access control for Future Nodes with core node bypass'),
      'group' => t('Future Nodes'),
    );
  }

  public function testGroup() {
    // "bypass node access" from core lets users access nodes, but they are not
    // listed by queries if they are unpublished.
    $this->nodes['unpublished']['node-access'] = TRUE;

    $this->nodes['past'   ]['node-access'] = $this->nodes['past'   ]['list-access'] = TRUE;
    $this->nodes['now'    ]['node-access'] = $this->nodes['now'    ]['list-access'] = TRUE;
    $this->nodes['future' ]['node-access'] = $this->nodes['future' ]['list-access'] = TRUE;

    $this->commonGroupTest(array('bypass node access'));
  }
}
