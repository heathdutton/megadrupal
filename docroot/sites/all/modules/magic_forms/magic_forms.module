<?php
/**
 * @file
 * The magic forms module.
 */

require_once 'magic_forms.defines.inc';

/**
 * Implements hook_menu().
 */
function magic_forms_menu() {
  $items = array();

  // The base menu.
  $items[MAGIC_FORMS_BASE_PATH] = array(
    'title' => 'Magic forms',
    'description' => 'Drupal magic forms.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('magic_forms_settings_form'),
    'access arguments' => array(MAGIC_FORMS_PERMISSION),
    'file' => 'ui/settings.ui.inc',
  );

  // The settings menu.
  $items[MAGIC_FORMS_BASE_PATH . '/settings'] = array(
    'title' => 'Settings',
    'description' => 'Administer the magic form settings.',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  // The validators list menu.
  $items[MAGIC_FORMS_BASE_PATH . '/validators'] = array(
    'title' => 'Validators',
    'description' => 'Available element validators.',
    'page callback' => 'magic_forms_validators_page',
    'access arguments' => array(MAGIC_FORMS_PERMISSION),
    'file' => 'ui/validators.ui.inc',
    'type' => MENU_LOCAL_TASK,
  );

  return $items;
}

/**
 * Implements hook_permissions().
 */
function magic_forms_permissions() {
  $items = array();

  // Permission to administer the magic form settings.
  $items[MAGIC_FORMS_PERMISSION] = array(
    'title' => 'Administer magic forms',
    'description' => 'Allow administration of the magic form settings.',
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function magic_forms_theme() {
  $items = array();

  // The overriden form element theme.
  $items['magic_forms_form_element'] = array(
    'render element' => 'element',
    'file' => 'magic_forms.theme.inc',
  );

  // Theme for the form errors grouped together.
  $items['magic_forms_errors'] = array(
    'arguments' => array(
      'config' => array(), 'element' => NULL, 'errors' => array(),
    ),
    'template' => 'tpls/magic-forms-errors',
  );

  // Theme for the grouped errors message.
  $items['magic_forms_grouped_errors'] = array(
    'arguments' => array(
      'anchor' => FALSE, 'element' => NULL, 'errors' => array(),
    ),
    'template' => 'tpls/magic-forms-grouped-errors',
  );

  return $items;
}

/**
 * Implements hook_form_alter().
 */
function magic_forms_form_alter(&$form, &$form_state, $form_id) {
  if (variable_get(MAGIC_FORMS_VARS_DEBUG_FORMID, MAGIC_FORMS_VARS_DEBUG_FORMID_DEFAULT)) {
    $msg = t("Form ID: '!id'.", array('!id' => $form_id));
    module_exists('devel') ? dpm($msg) : drupal_set_message($msg);
  }

  if (variable_get(MAGIC_FORMS_VARS_DEBUG_FORM, MAGIC_FORMS_VARS_DEBUG_FORM_DEFAULT) && module_exists('devel')) {
    dpm($form);
  }

  $apply_to = explode("\n", variable_get(MAGIC_FORMS_VARS_APPLYTO, MAGIC_FORMS_VARS_APPLYTO_DEFAULT));
  $modules = module_implements('magic_forms_apply_to');
  foreach ($modules as $module) {
    if (is_callable("{$module}_magic_forms_apply_to")) {
      call_user_func_array(
        "{$module}_magic_forms_apply_to",
        array(
          &$apply_to,
          &$form,
          &$form_state,
          $form_id,
        )
      );
    }
  }

  if (!isset($form['#magic-forms']) && in_array($form_id, $apply_to)) {
    $form['#magic-forms'] = array();
  }

  // Check if the form has a magic config.
  if (!isset($form['#magic-forms'])) {
    // The form does not have a config.
    return;
  }

  $form['#magic-forms'] = array_merge(array(
    MAGIC_FORMS_ERROR_HANDLING => variable_get(MAGIC_FORMS_VARS_ERROR_HANDLING, MAGIC_FORMS_VARS_ERROR_HANDLING_DEFAULT) == TRUE,
    MAGIC_FORMS_GROUP_ERRORS => variable_get(MAGIC_FORMS_VARS_GROUP_ERRORS, MAGIC_FORMS_VARS_GROUP_ERRORS_DEFAULT) == TRUE,
    MAGIC_FORMS_GROUP_ERRORS_ANCHOR => variable_get(MAGIC_FORMS_VARS_GROUP_ERRORS_ANCHOR, MAGIC_FORMS_VARS_GROUP_ERRORS_ANCHOR_DEFAULT) == TRUE,
    MAGIC_FORMS_FIELD_ERRORS => variable_get(MAGIC_FORMS_VARS_FIELD_ERRORS, MAGIC_FORMS_VARS_FIELD_ERRORS_DEFAULT) == TRUE,
    MAGIC_FORMS_FIELD_ERROR_ASPREFIX => variable_get(MAGIC_FORMS_VARS_FIELD_ERROR_ASPREFIX, MAGIC_FORMS_VARS_FIELD_ERROR_ASPREFIX_DEFAULT) == TRUE,
    MAGIC_FORMS_FIELD_ERRORS_WRAPPER => variable_get(MAGIC_FORMS_VARS_FIELD_ERRORS_WRAPPER, MAGIC_FORMS_VARS_FIELD_ERRORS_WRAPPER_DEFAULT) == TRUE,
    MAGIC_FORMS_FIELD_ERRORS_WRAPPER_CLASS => variable_get(MAGIC_FORMS_VARS_FIELD_ERRORS_WRAPPER_CLASS, MAGIC_FORMS_VARS_FIELD_ERRORS_WRAPPER_CLASS_DEFAULT),
    MAGIC_FORMS_PREVENT_VALIDATION_FIELDS => variable_get(MAGIC_FORMS_VARS_PREVENT_VALIDATION_FIELDS, MAGIC_FORMS_VARS_PREVENT_VALIDATION_FIELDS_DEFAULT),
  ), $form['#magic-forms']);

  // Allow for modules to alter the magic form config.
  drupal_alter(array('magic_forms_config', "magic_forms_{$form_id}_config"), $form['#magic-forms']);

  // Apply the magic on the form.
  magic_forms_form($form_id, $form, $form_state);
}

/**
 * A helper function to get a value of a property from the config.
 *
 * @param string $property
 *   The property name.
 * @param array $config
 *   The magic forms config array.
 * @param mixed $default
 *   The default value to return if the value has not been set.
 *
 * @return mixed
 *   The value of the property or the $default value.
 */
function magic_forms_config_property($property, array $config, $default = NULL) {
  $config = isset($config['config']) ? $config['config'] : $config;
  return isset($config[$property]) ? $config[$property] : $default;
}

/**
 * Implements hook_magic_forms_validators().
 */
function magic_forms_magic_forms_validators() {
  $items = array();

  // Define the email validator.
  $items['email'] = array(
    'title' => t('Email'),
    'description' => t('Simple email address validator.'),
    'file' => 'validators/email.inc',
    'callback' => 'magic_forms_validators_email_validate',
    'types' => array('textfield', 'emailfield'),
  );

  $items['email-domain'] = array(
    'title' => t('Email (domain)'),
    'description' => t('Email address and domain validator.'),
    'file' => 'validators/email.inc',
    'callback' => 'magic_forms_validators_email_domain_validate',
    'types' => array('textfield', 'emailfield'),
  );

  $items['url'] = array(
    'title' => t('URL'),
    'description' => t('Simple URL validator.'),
    'file' => 'validators/url.inc',
    'callback' => 'magic_forms_validators_url_validate',
    'types' => array('textfield', 'urlfield'),
  );

  $items['url-domain'] = array(
    'title' => t('URL (scheme and domain)'),
    'description' => t('URL, scheme and domain validator.'),
    'file' => 'validators/url.inc',
    'callback' => 'magic_forms_validators_url_domain_validate',
    'types' => array('textfield', 'urlfield'),
  );

  $items['number'] = array(
    'title' => t('Number'),
    'description' => t('Simple number and range validator.'),
    'file' => 'validators/number.inc',
    'callback' => 'magic_forms_validators_number_validate',
    'types' => array('textfield', 'numberfield'),
  );

  return $items;
}

/**
 * Build and return the validators JS file.
 *
 * @return string
 *   The filename to the built client validator file.
 */
function magic_forms_validators_js() {
  $code = &drupal_static(__FUNCTION__);
  if (!isset($code)) {
    $code = array();

    $code[] = file_get_contents(drupal_get_path('module', 'magic_forms') . '/assets/js/magic-forms-validators.js');
    $validators = magic_forms_validators();
    if ($validators && count($validators)) {
      foreach ($validators as $validator) {
        if (!isset($validator['js']) || !$validator['js']) {
          continue;
        }

        $filename = drupal_get_path('module', $validator['module']);
        if (file_exists($filename)) {
          $code[] = file_get_contents($filename);
        }
      }
    }

    $code = implode("\n\n", $code);
  }

  $dir = 'public://magic-forms';
  $filename = $dir . '/magic-forms-' . md5($code) . '.js';
  if (file_prepare_directory($dir, FILE_CREATE_DIRECTORY | FILE_MODIFY_PERMISSIONS) && !file_exists($filename)) {
    file_put_contents($filename, $code);
  }

  return $filename;
}

/**
 * Get a specific element from the form.
 *
 * @param array $form
 *   The form array.
 * @param string $xpath
 *   A string of element id's of parent and child separated with a '|'.
 * @param Callable $callback
 *   The callback to run when the element has been found.
 * @param array $arguments
 *   (optional) An array of arguments to pass to the closure.
 */
function _magic_forms_get_form_element(&$form, $xpath, $callback, array $arguments = array()) {
  $path = implode("']['", explode('|', trim($xpath)));
  eval("if (isset(\$form['{$path}'])) call_user_func_array(\$callback, array_merge(array(&\$form['{$path}']), \$arguments));");
}

/**
 * Process through each form element.
 *
 * @param array $form
 *   The form or element.
 * @param string $form_build_id
 *   The forms build id.
 */
function _magic_forms_form_element(&$form, $form_build_id, $config) {
  $container_types = array(
    'fieldset', 'actions', 'form', 'container',
  );

  $invalid_types = array(
    'button', 'submit', 'reset', 'hidden', 'token', 'value', 'vertical_tabs',
    'text_format',
  );

  $children = element_children($form);
  foreach ($children as $key) {
    if (!isset($form[$key]['#type']) || in_array($form[$key]['#type'], $container_types)) {
      if (isset($form[$key]['#collapsed']) && !isset($form[$key]['#collapsible'])) {
        $form[$key]['#collapsible'] = TRUE;
      }

      _magic_forms_form_element($form[$key], $form_build_id, $config);
    }
    elseif (isset($form[$key]['#type']) && !in_array($form[$key]['#type'], $invalid_types)) {
      $form[$key]['#magic-forms']['form_build_id'] = $form_build_id;
      $form[$key]['#pre_render'][] = 'magic_forms_element_prerender';

      $form[$key]['#old_theme'] = isset($form[$key]['#theme']) ? $form[$key]['#theme'] : '';
      $form[$key]['#theme'] = 'magic_forms_form_element';

      if (!isset($form[$key]['#element_validate']) || !in_array('magic_forms_element_validate', $form[$key]['#element_validate'])) {
        $form[$key]['#element_validate'][] = 'magic_forms_element_validate';
      }

      drupal_alter('magic_forms_element', $form[$key], $config);
    }
  }
}

/**
 * Set multiple error messages per field.
 *
 * @param array|string $name
 *   Either an array of names, a single name or an element.
 * @param array|string $messages
 *   Either an array of messages or a single message.
 *
 * @return array
 *   Returns the messages array.
 */
function magic_forms_set_errors($name, $messages) {
  if (is_array($name) && isset($name['#type'])) {
    $name = implode('][', $name['#parents']);
  }
  elseif (is_array($name)) {
    $r = array();

    foreach ($name as $n) {
      $r = magic_forms_set_error($n, $messages);
    }

    return $r;
  }

  $errors = &drupal_static('form_set_error');
  if (isset($errors[$name])) {
    $errors[$name] .= MAGIC_FORMS_ERROR_SEP;
  }
  else {
    $errors[$name] = '';
  }

  $errors[$name] .= implode(MAGIC_FORMS_ERROR_SEP, (array) $messages);

  return $errors;
}

/**
 * Process and apply any requirements to the form using the #magic-form config.
 *
 * @param string $form_id
 *   The form's id.
 * @param array $form
 *   A reference to the form array.
 * @param array $form_state
 *   A reference to the form state array.
 */
function magic_forms_form($form_id, &$form, &$form_state) {
  // Get the magic forms config from the form.
  $config = $form['#magic-forms'];
  $module_path = drupal_get_path('module', 'magic_forms');

  $form['#attributes']['class'][] = 'magic-form';

  // Cycle through the form elements and apply the configs.
  _magic_forms_form_element($form, $form['#build_id'], $config);
  $form['#validate'][] = 'magic_forms_form_validate';

  // Check for fields that need to skip form validation.
  $fields = explode("\n", magic_forms_config_property(MAGIC_FORMS_PREVENT_VALIDATION_FIELDS, $config));
  if (count($fields)) {
    foreach ($fields as $field) {
      _magic_forms_get_form_element($form, $field, function (&$element) {
        $element['#limit_validation_errors'] = array();
      });
    }
  }

  $form['#attached']['css'][] = $module_path . '/assets/css/magic-forms.css';

  // Update the forms config with the latest copy.
  $form['#magic-forms'] = $config;

  $form['#attached']['js'][] = $module_path . '/assets/js/magic-forms.js';
  $form['#attached']['js'][] = array(
    'data' => array('magic_forms' => array($form['#build_id'] => $config)),
    'type' => 'setting',
  );

  // Store the config statically so element callbacks have access to it.
  $magic_form = &drupal_static('magic_forms_form__' . $form['#build_id']);
  $magic_form['config'] = $config;
}

/**
 * A helprt function to get a reference to a specific element.
 *
 * @param string|array $name
 *   Either the element array or name.
 * @param array $form
 *   The form.
 *
 * @return array
 *   The element.
 */
function &_magic_forms_element($name, &$form) {
  $name = is_string($name) ? explode('][', $name) : $name;
  $item = $form;
  foreach ($name as $n) {
    $item = isset($item[$n]) ? $item[$n] : NULL;
    if ($item === NULL) {
      break;
    }
  }

  return $item;
}

/**
 * The form validate callback.
 *
 * @param array $form
 *   The form.
 * @param array $form_state
 *   The form state.
 */
function magic_forms_form_validate($form, &$form_state) {
  $magic_form = &drupal_static('magic_forms_form__' . $form['#build_id']);
  if (magic_forms_config_property(MAGIC_FORMS_ERROR_HANDLING, $magic_form)) {
    $errors = form_get_errors();
    if ($errors) {
      $magic_form['errors'] = array();

      $element_errors = array();
      foreach ($errors as $name => $error) {
        $errs = explode(MAGIC_FORMS_ERROR_SEP, $error);
        foreach ($errs as $err) {
          // Remove the error message from the session if they exist, we don't
          // want to just clear it just incase there are other errors not
          // related to the form validation.
          if (isset($_SESSION['messages']['error']) && count($_SESSION['messages']['error'])) {
            $idx = array_search($err, $_SESSION['messages']['error']);
            if ($idx !== FALSE) {
              // Array slice doesn't seem to always want to remove the only
              // element in an array, so we need to check if there is only one
              // and reset as an empty array.
              if (count($_SESSION['messages']['error']) === 1) {
                $_SESSION['messages']['error'] = array();
              }
              else {
                array_splice($_SESSION['messages']['error'], $idx, 1);
              }
            }
          }

          $array_name = implode('][', $magic_form['fields'][$name]);
          if (!isset($element_errors[$array_name])) {
            $element_errors[$array_name] = array(
              'id' => $name,
              'name' => $array_name,
              'errors' => array(),
            );
          }

          $element = _magic_forms_element($array_name, $form);

          if (
            $err == t('@field field is required.', array('@field' => $element['#title'])) &&
            isset($element['#magic-forms']['required-error'])
          ) {
            $err = $element['#magic-forms']['required-error'];
          }

          $element_errors[$array_name]['errors'][] = $err;
        }
      }

      // Store the elements that have errors in the form state.
      $magic_form['errors'] = $element_errors;

      // Check if there are any error messages left, if not then we need to
      // remove the error array from the session, or if there are no messages
      // at all clear the whole queue.
      if (empty($_SESSION['messages']['error'])) {
        // Unset the error messages array.
        unset($_SESSION['messages']['error']);
        if (empty($_SESSION['messages'])) {
          // No messages at all, so clear the queue.
          drupal_get_messages();
        }
      }

      // Check if error grouping is enabled.
      if (magic_forms_config_property(MAGIC_FORMS_GROUP_ERRORS, $magic_form)) {
        // Cycle through each error and add them to the message queue.
        foreach ($magic_form['errors'] as $name => $errors) {
          // Theme the grouped message.
          $element = _magic_forms_element($name, $form);
          $error = theme('magic_forms_grouped_errors', array(
            'anchor' => magic_forms_config_property(MAGIC_FORMS_GROUP_ERRORS_ANCHOR, $magic_form),
            'element' => $element,
            'errors' => $errors,
          ));

          drupal_set_message($error, 'error');
        }
      }
    }
  }
}

/**
 * A helper function to add a debug message to the watchdog.
 *
 * Apply all the usual arguments that you would to watchdog() except for the
 * first argument, as this is added here.
 */
function _magic_forms_watchdog() {
  if (variable_get(MAGIC_FORMS_VARS_DEBUGMODE, MAGIC_FORMS_VARS_DEBUGMODE_DEFAULT)) {
    $args = func_get_args();
    array_unshift($args, 'magic-forms');
    call_user_func_array('watchdog', $args);
  }
}

/**
 * The element validate callback.
 *
 * @param array $element
 *   The element to validate.
 * @param array $form_state
 *   The form state.
 * @param array $form
 *   The form.
 */
function magic_forms_element_validate($element, &$form_state, $form) {
  $name = implode('][', $element['#parents']);

  $magic_form = &drupal_static('magic_forms_form__' . $form['#build_id']);
  $magic_form['fields'][$name] = $element['#array_parents'];

  $config = isset($element['#magic-forms']) ? $element['#magic-forms'] : FALSE;
  if (($element['#value'] != '' && $element['#value'] != NULL) && $config && isset($config['validators'])) {
    $validators = magic_forms_validators();
    foreach ($config['validators'] as $rule) {
      if (!isset($rule['type']) || !isset($validators[$rule['type']])) {
        // @todo
        _magic_forms_watchdog('Failed to find the validators rule @rule defined in @form:@field.', array(
          '@rule' => isset($rule['type']) ? $rule['type'] : 'undefined',
          '@form' => $form['#id'],
          '@field' => $name,
        ), WATCHDOG_ERROR);

        continue;
      }

      $validator = $validators[$rule['type']];
      if (isset($validator['types']) && (!isset($element['#type']) || !in_array($element['#type'], $validator['types']))) {
        // @todo - watchdog log?
        _magic_forms_watchdog('The element @form:@field is not an allowed type of the validation rule @rule.', array(
          '@form' => $form['#id'],
          '@field' => $name,
          '@rule' => isset($rule['type']) ? $rule['type'] : 'undefined',
        ), WATCHDOG_ERROR);

        continue;
      }

      if (isset($validator['file'])) {
        $filename = drupal_get_path('module', $validator['module']) . '/' . $validator['file'];
        if (file_exists($filename)) {
          include_once $filename;
        }
        else {
          // @todo - watchdog log?
          _magic_forms_watchdog('Failed to find the file @file of the validation rule @rule.', array(
            '@file' => $validator['file'],
            '@rule' => isset($rule['type']) ? $rule['type'] : 'undefined',
          ), WATCHDOG_ERROR);

          continue;
        }
      }

      if (!is_callable($validator['callback'])) {
        // @todo - watchdog log?
        _magic_forms_watchdog('Failed to find the callback @callback of the validation rule @rule.', array(
          '@callback' => $validator['callback'],
          '@rule' => isset($rule['type']) ? $rule['type'] : 'undefined',
        ), WATCHDOG_ERROR);

        continue;
      }

      $valid = call_user_func_array($validator['callback'], array($element['#value'], isset($rule['config']) ? $rule['config'] : array()));
      if (!$valid) {
        magic_forms_set_errors(
          $element,
          isset($rule['message']) ? $rule['message'] : t('@field has failed validation.', array('@field' => isset($element['#title']) ? $element['#title'] : $element['#name']))
        );
      }
    }
  }
}

/**
 * Prerender the form elements.
 *
 * @param array $element
 *   The element to prerender.
 *
 * @return array
 *   The resulting prerendered element.
 */
function magic_forms_element_prerender($element) {
  // Get the elements magic-forms config.
  $config = isset($element['#magic-forms']) ? $element['#magic-forms'] : FALSE;

  // If the config is available...
  if ($config) {
    // Generate the elements name.
    $name = implode('][', $element['#array_parents']);

    // Get the forms magic-forms config.
    $magic_form = &drupal_static('magic_forms_form__' . $config['form_build_id']);
    $errors = isset($magic_form['errors'][$name]) ? $magic_form['errors'][$name] : array();

    // Check if error handling is enabled, and if there are any errors for this
    // element.
    if (magic_forms_config_property(MAGIC_FORMS_ERROR_HANDLING, $magic_form) && count($errors) > 0) {
      // Add the magic forms error class.
      $element['#attributes']['class'][] = 'magic-forms-error';

      // Check if field errors is enabled.
      if (magic_forms_config_property(MAGIC_FORMS_FIELD_ERRORS, $magic_form)) {
        // Theme the field errors.
        $errors_output = theme('magic_forms_errors', array(
          'config' => $magic_form['config'], 'element' => $element, 'errors' => $errors,
        ));

        // Should the errors be a prefix or suffix.
        if (magic_forms_config_property(MAGIC_FORMS_FIELD_ERROR_ASPREFIX, $magic_form)) {
          $element['#magic-forms']['prefix'] = $errors_output;
        }
        else {
          $element['#magic-forms']['suffix'] = $errors_output;
        }
      }
    }

    drupal_alter('magic_forms_element_prerender', $element, $magic_form);
  }

  return $element;
}

/**
 * Retireve any validator callbacks.
 *
 * @return array
 *   An array of found validators.
 */
function magic_forms_validators() {
  $validators = &drupal_static(__FUNCTION__);

  if (!isset($validators)) {
    $validators = array();

    // Cycle through each validators hook, and store the validators details.
    foreach (module_implements(MAGIC_FORMS_HOOK_VALIDATORS) as $module) {
      $function = "{$module}_" . MAGIC_FORMS_HOOK_VALIDATORS;
      if (function_exists($function)) {
        $result = call_user_func_array($function, array());

        if ($result && count($result)) {
          foreach ($result as $key => $item) {
            // Add the module name to the results.
            $validators[$key] = array_merge(array('module' => $module), $item);
          }
        }
      }
    }

    drupal_alter(MAGIC_FORMS_HOOK_VALIDATORS, $validators);
  }

  return $validators;
}
