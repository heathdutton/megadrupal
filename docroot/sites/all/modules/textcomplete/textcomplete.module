<?php

/**
 * @file
 * The Textcomplete module code.
 *
 * Allows the user to add autocomplete functionality to textareas.
 */

/**
 * Implements hook_init().
 */
function textcomplete_init() {
  // Display a warning if jquery_update isn't enabled.
  if ((!module_exists('jquery_update') || !version_compare(variable_get('jquery_update_jquery_version', 0), 1.7, '>='))) {
    drupal_set_message(t('jQuery Update is not enabled, Textcomplete requires a minimum jQuery version of 1.7 or higher.<br/>Please enable <a href="https://drupal.org/project/jquery_update">jQuery Update module</a> 7.x-2.3 or higher, you must manually set this in the configuration after it is installed.'), 'error', FALSE);
  }
  /*
   * Display a warning if entityreference is enabled but aet and token filter
   * isn't.
   */
  if (module_exists('entityreference') && (!module_exists('aet') || !module_exists('token_filter'))) {
    if (!module_exists('aet')) {
      drupal_set_message(t('Advanced Entity Tokens is not enabled, Textcomplete uses advanced entity tokens (AET) to render the links inside textareas. <a href="https://drupal.org/project/aet">Please enable AET</a> to utilise the full power of textcomplete.'), 'warning', FALSE);
    }
    if (!module_exists('token_filter')) {
      drupal_set_message(t('Token filter is not enabled, Textcomplete uses the token filter module, this module makes token replace a filter format. <a href="https://drupal.org/project/token_filter">Please enable token filter</a> to utilise the full power of textcomplete.'), 'warning', FALSE);
    }
  }
}

/**
 * Implements hook_filter_info().
 */
function textcomplete_filter_info() {
  $filters['textcomplete_emoji'] = array(
    'title' => t('Textcomplete - Emoji'),
    'process callback' => '_textcomplete_emoji_filter_process',
    'tips callback' => '_textcomplete_emoji_filter_tips',
  );
  return $filters;
}

/**
 * Implements hook_libraries_info().
 */
function textcomplete_libraries_info() {
  $libraries['textcomplete'] = array(
    'name' => 'Textcomplete',
    'vendor url' => 'https://github.com/yuku-t/jquery-textcomplete',
    'download url' => 'https://github.com/yuku-t/jquery-textcomplete/archive/master.zip',
    'version arguments' => array(
      'file' => 'jquery.textcomplete.min.js',
      'pattern' => '/v([0-9\.]+)/',
      'lines' => 2,
    ),
    'files' => array(
      'js' => array(
        'jquery.textcomplete.js' => array(
          'type' => 'file',
        ),
        'media/javascripts/emoji.js' => array(
          'type' => 'file',
        ),
      ),
      'css' => array(
        'jquery.textcomplete.css' => array(
          'type' => 'file',
        ),
        'media/stylesheets/main.css' => array(
          'type' => 'file',
        ),
      ),
    ),
    'variants' => array(
      'minified' => array(
        'files' => array(
          'js' => array(
            'jquery.textcomplete.min.js',
          ),
        ),
        'variant arguments' => array(
          'variant' => 'minified',
        ),
      ),
    ),
  );
  return $libraries;
}

/**
 * Implements hook_menu().
 */
function textcomplete_menu() {
  $items = array();
  $items['textcomplete/entityreference/autocomplete/single/%/%/%'] = array(
    'title' => 'Textcomplete Entity Reference Autocomplete',
    'page callback' => '_textcomplete_entityreference_autocomplete_callback',
    'page arguments' => array(3, 4, 5, 6),
    'access callback' => '_textcomplete_entityreference_autocomplete_access_callback',
    'access arguments' => array(3, 4, 5, 6),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implements hook_field_widget_info_alter().
 */
function textcomplete_field_widget_info_alter(&$info) {
  $settings = array(
    'textcomplete' => array(
      'emoji_status' => FALSE,
      'emoji' => array(
        'keycode' => ':',
      ),
      'html_status' => FALSE,
      'html' => array(
        'tags' => 'span div h1 h2 h3',
      ),
      'entityreference_status' => FALSE,
      'entityreference' => array(
        'match_operator' => 'STARTS_WITH',
        'keycode' => '@',
        'settings' => array(
          // Default to the core target entity type node.
          'target_type' => 'node',
          // The handler for this field.
          'handler' => 'base',
          // The handler settings.
          'handler_settings' => array(),
        ),
      ),
    ),
  );

  foreach ($info as &$instance) {
    if (count(array_intersect($instance['field types'], array('text_with_summary', 'text_long'))) > 0) {
      $instance['settings'] += $settings;
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function textcomplete_form_field_ui_field_edit_form_alter(&$form, &$form_state, $form_id) {
  $field = $form['#field'];
  $instance = $form['#instance'];

  if (in_array($field['type'], array('text_with_summary', 'text_long'))) {
    $settings = $instance['widget']['settings']['textcomplete'];
    $instance_form = &$form['instance']['widget']['settings'];
    $instance_form += array(
      'textcomplete' => array(
        '#type' => 'fieldset',
        '#title' => t('Textcomplete settings'),
        '#collapsible' => TRUE,
        '#collapsed' => TRUE,
        '#element_validate' => array('_textcomplete_settings_form_validate'),
        'emoji_status' => array(
          '#type' => 'checkbox',
          '#title' => t('Emoji enabled'),
          '#description' => t('Toggle the emoji emoticons functionality on and off'),
          '#default_value' => $settings['emoji_status'],
        ),
        'emoji' => array(
          '#type' => 'fieldset',
          '#title' => t('Emoji settings'),
          '#collapsible' => TRUE,
          '#collapsed' => FALSE,
          '#states' => array(
            'visible' => array(
              ':input[name*="[emoji_status]"]' => array('checked' => TRUE),
            ),
          ),
          'keycode' => array(
            '#type' => 'textfield',
            '#title' => t('Keycode'),
            '#description' => t('Choose the keycode to initialise the emoji dropdown.'),
            '#default_value' => $settings['emoji']['keycode'],
            '#states' => array(
              'required' => array(
                ':input[name*="[emoji_status]"]' => array('checked' => TRUE),
              ),
            ),
          ),
        ),
        'html_status' => array(
          '#type' => 'checkbox',
          '#title' => t('HTML enabled'),
          '#description' => t('Toggle the html autocomplete functionality on and off'),
          '#default_value' => $settings['html_status'],
        ),
        'html' => array(
          '#type' => 'fieldset',
          '#title' => t('HTML settings'),
          '#collapsible' => TRUE,
          '#collapsed' => FALSE,
          '#states' => array(
            'visible' => array(
              ':input[name*="[html_status]"]' => array('checked' => TRUE),
            ),
          ),
          'tags' => array(
            '#type' => 'textfield',
            '#title' => t('Tags'),
            '#description' => t('Choose the tags you wish to be available in the autocomplete. Separate each tag by a space. The tags in here must be allowed by your filter format otherwise they will not display on the page.'),
            '#default_value' => $settings['html']['tags'],
            '#states' => array(
              'required' => array(
                ':input[name*="[html_status]"]' => array('checked' => TRUE),
              ),
            ),
          ),
        ),
      ),
    );

    if (module_exists('entityreference')) {
      $instance_form['textcomplete'] += array(
        'entityreference_status' => array(
          '#type' => 'checkbox',
          '#title' => t('Entityreference enabled'),
          '#default_value' => $settings['entityreference_status'],
          '#description' => t('Toggle the textcomplete entityreference functionality on and off'),
        ),
        'entityreference' => array(
          '#type' => 'fieldset',
          '#title' => t('Entityreference settings'),
          '#collapsible' => TRUE,
          '#collapsed' => FALSE,
          '#states' => array(
            'visible' => array(
              ':input[name*="[entityreference_status]"]' => array('checked' => TRUE),
            ),
          ),
          'match_operator' => array(
            '#type' => 'select',
            '#title' => t('Autocomplete matching'),
            '#default_value' => $settings['entityreference']['match_operator'],
            '#options' => array(
              'STARTS_WITH' => t('Starts with'),
              'CONTAINS' => t('Contains'),
            ),
            '#description' => t('Select the method used to collect autocomplete suggestions. Note that <em>Contains</em> can cause performance issues on sites with thousands of nodes.'),
          ),
          'keycode' => array(
            '#type' => 'textfield',
            '#title' => t('Keycode'),
            '#description' => t('Choose the keycode to initialise the entityreference dropdown. If you leave this blank every time you type a word with more than two characters it will search the database, this may cause see a performance issue. Currently spaces need to be represented by an underscore.'),
            '#default_value' => $settings['entityreference']['keycode'],
          ),
          'settings' => array(
            '#type' => 'container',
            '#field' => $field,
            '#instance' => $instance,
            '#process' => array(
              '_textcomplete_entityreference_field_settings_process',
              '_entityreference_field_settings_ajax_process',
            ),
          ),
        ),
      );
    }
  }
}

/**
 * Implements hook_field_widget_form_alter().
 */
function textcomplete_field_widget_form_alter(&$element, &$form_state, $context) {
  $field = $context['field'];
  $instance = $context['instance'];
  if (in_array($field['type'], array('text_with_summary', 'text_long'))) {
    $path = drupal_get_path('module', 'textcomplete');
    $settings = $instance['widget']['settings']['textcomplete'];

    if ($settings['emoji_status'] || $settings['entityreference_status']) {
      $entity_type = $instance['entity_type'];
      $entity = isset($element['#entity']) ? $element['#entity'] : NULL;

      $autocomplete_path = '/textcomplete/entityreference/autocomplete/single';
      $autocomplete_path .= '/' . $field['field_name'] . '/' . $entity_type . '/' . $instance['bundle'] . '/';

      $id = 'NULL';
      if ($entity) {
        list($eid) = entity_extract_ids($entity_type, $entity);
        if ($eid) {
          $id = $eid;
        }
      }
      $autocomplete_path .= $id . '/';
      $settings['autocomplete_path'] = $autocomplete_path;

      $fields = &drupal_static(__FUNCTION__, array());
      $fields[$field['field_name']] = $settings;

      $js[$path . '/textcomplete.js'] = array(
        'type' => 'file',
        'weight' => 3,
      );
      $js[] = array(
        'data' => array(
          'textcomplete' => array(
            'library_path' => libraries_get_path('textcomplete', TRUE),
            'fields' => $fields,
          ),
        ),
        'type' => 'setting',
      );

      $element['#attached']['js'] = $js;
      $element['#attached']['libraries_load'][] = array('textcomplete');
    }
  }
}

/**
 * Menu callback: autocomplete the label of an entity.
 *
 * @param string $type
 *   The widget type (i.e. 'single' or 'tags').
 * @param string $field_name
 *   The name of the entity-reference field.
 * @param string $entity_type
 *   The entity type.
 * @param string $bundle_name
 *   The bundle name.
 * @param string $entity_id
 *   Optional; The entity ID the entity-reference field is attached to.
 *   Defaults to ''.
 * @param string $string
 *   The label of the entity to query by.
 *
 * @return json
 *   The json encoded array of matches.
 */
function _textcomplete_entityreference_autocomplete_callback($type, $field_name, $entity_type, $bundle_name, $entity_id = '', $string = '') {
  /*
   * If the request has a '/' in the search text, then the menu system will
   * have split it into multiple arguments and $string will only be a partial.
   * We want to make sure we recover the intended $string.
   */
  $args = func_get_args();
  /*
   * Shift off the $type, $field_name, $entity_type, $bundle_name, and
   * $entity_id args.
   */
  array_shift($args);
  array_shift($args);
  array_shift($args);
  array_shift($args);
  array_shift($args);
  $string = implode('/', $args);

  $field = field_info_field($field_name);
  $instance = field_info_instance($entity_type, $field_name, $bundle_name);

  $settings = $instance['widget']['settings']['textcomplete']['entityreference']['settings'];
  $field['settings'] = $settings;
  $widget_settings = &$instance['widget']['settings'];
  $widget_settings['match_operator'] = $widget_settings['textcomplete']['entityreference']['match_operator'];

  return entityreference_autocomplete_callback_get_matches($type, $field, $instance, $entity_type, $entity_id, $string);
}

/**
 * Menu Access callback for the autocomplete widget.
 *
 * @param string $type
 *   The widget type (i.e. 'single' or 'tags').
 * @param string $field_name
 *   The name of the entity-reference field.
 * @param string $entity_type
 *   The entity type.
 * @param string $bundle_name
 *   The bundle name.
 *
 * @return bool
 *   True if user can access this menu item.
 */
function _textcomplete_entityreference_autocomplete_access_callback($type, $field_name, $entity_type, $bundle_name) {
  $field = field_info_field($field_name);
  $instance = field_info_instance($entity_type, $field_name, $bundle_name);

  if (!$field || !$instance || !field_access('edit', $field, $entity_type)) {
    return FALSE;
  }
  return TRUE;
}

/**
 * Field settings form taken from entityreference module.
 *
 * This function is slightly altered to make use of it inside an instance
 * instead of the field settings form.
 *
 * @param array $form
 *   The current form array of the element, comes from
 *   textcomplete_form_field_ui_field_edit_form_alter.
 * @param array $form_state
 *   The current form state array of the element, comes from
 *   textcomplete_form_field_ui_field_edit_form_alter.
 *
 * @return array
 *   The settings form for entityreference.
 */
function _textcomplete_entityreference_field_settings_process(array $form, array $form_state) {
  $field = $form['#field'];
  $instance = isset($form_state['input']['instance']) ? $form_state['input']['instance'] : $form['#instance'];
  $settings = $instance['widget']['settings']['textcomplete']['entityreference']['settings'];
  $field['settings'] = $settings;

  if (!isset($instance['entity_type'])) {
    $instance['entity_type'] = $form['#instance']['entity_type'];
  }

  if (!isset($field['settings']['handler_settings'])) {
    $field['settings']['handler_settings'] = array();
  }

  // Select the target entity type.
  $entity_type_options = array();
  foreach (entity_get_info() as $entity_type => $entity_info) {
    $entity_type_options[$entity_type] = $entity_info['label'];
  }

  $form['target_type'] = array(
    '#type' => 'select',
    '#title' => t('Target type'),
    '#options' => $entity_type_options,
    '#default_value' => $settings['target_type'],
    '#required' => TRUE,
    '#description' => t('The entity type that can be referenced through this field.'),
    '#size' => 1,
    '#ajax' => TRUE,
    '#limit_validation_errors' => array(),
  );

  ctools_include('plugins');
  $handlers = ctools_get_plugins('entityreference', 'selection');
  uasort($handlers, 'ctools_plugin_sort');
  $handlers_options = array();
  foreach ($handlers as $handler => $handler_info) {
    $handlers_options[$handler] = check_plain($handler_info['title']);
  }

  $form['handler'] = array(
    '#type' => 'fieldset',
    '#title' => t('Entity selection'),
    '#tree' => TRUE,
    '#process' => array('_entityreference_form_process_merge_parent'),
  );

  $form['handler']['handler'] = array(
    '#type' => 'select',
    '#title' => t('Mode'),
    '#options' => $handlers_options,
    '#default_value' => $settings['handler'],
    '#required' => TRUE,
    '#ajax' => TRUE,
    '#limit_validation_errors' => array(),
  );
  $form['handler_submit'] = array(
    '#type' => 'submit',
    '#value' => t('Change handler'),
    '#limit_validation_errors' => array(),
    '#attributes' => array(
      'class' => array('js-hide'),
    ),
    '#submit' => array('entityreference_settings_ajax_submit'),
  );

  $form['handler']['handler_settings'] = array(
    '#type' => 'container',
    '#attributes' => array('class' => array('entityreference-settings')),
  );

  $handler = entityreference_get_selection_handler($field, $instance);
  $form['handler']['handler_settings'] += $handler->settingsForm($field, $instance);

  return $form;
}

/**
 * Element validation callback for widget settings form.
 */
function _textcomplete_settings_form_validate($element, &$form_state, $form) {
  if ($element['emoji_status']['#value'] && empty($element['emoji']['keycode']['#value'])) {
    form_error($element['emoji']['keycode'], t('The keycode field is required. When emoji icons are enabled.'));
  }

  if ($element['html_status']['#value'] && empty($element['html']['tags']['#value'])) {
    form_error($element['html']['tags'], t('The tags are required when html status is enabled.'));
  }

  if ($element['emoji_status']['#value'] && $element['entityreference_status']['#value']) {
    if ($element['emoji']['keycode']['#value'] == $element['entityreference']['keycode']['#value']) {
      form_error($element['entityreference']['keycode'], t('The keycodes for for emoji and entityreference can not be the same.'));
    }
  }

  if ($element['html_status']['#value'] && ($element['emoji_status']['#value'] || $element['entityreference_status']['#value'])) {
    if ($element['emoji']['keycode']['#value'] == '<') {
      form_error($element['emoji']['keycode'], t('The keycode can not be < when html tags are being used.'));
    }
    if ($element['entityreference']['keycode']['#value'] == '<') {
      form_error($element['entityreference']['keycode'], t('The keycode can not be < when html tags are being used.'));
    }
  }
}

/**
 * Filter process callback for emoji.
 */
function _textcomplete_emoji_filter_process($text, $filter, $format) {
  $matches = $emojis = array();
  $textcomplete_path = libraries_get_path('textcomplete', TRUE);
  preg_match_all('/\[textcomplete:emoji:([0-9a-zA-Z_\+\-]+)\]/', $text, $matches);

  if (isset($matches[1]) && count($matches[1]) > 0) {
    foreach ($matches[1] as $key => $emoji) {
      $file_path = $textcomplete_path . '/media/images/emoji/' . $emoji . '.png';
      if (file_exists(DRUPAL_ROOT . $file_path)) {
        $image = array(
          'path' => $file_path,
          'alt' => $emoji,
          'attributes' => array(
            'class' => array('emoji'),
          ),
        );
        $emojis['keys'][] = $matches[0][$key];
        $emojis['values'][] = theme('image', $image);
      }
    }
  }
  return $emojis ? str_replace($emojis['keys'], $emojis['values'], $text) : $text;
}

/**
 * Implement tips callback for emoji.
 */
function _textcomplete_emoji_filter_tips($filter, $format, $long = FALSE) {
  return t('Emoji keycodes that take the format [textcomplete:emoji:keycode] will be replaced.');
}
