<?php
/**
 * @file
 * Functions for media_theplatform_mpx.module.
 */

/**
 * Video is not available (but will be soon).
 */
define('MPX_VIDEO_UNAVAILABLE', 'unavailable');

/**
 * Video is available.
 */
define('MPX_VIDEO_AVAILABLE', 'available');

/**
 * Video is expired.
 */
define('MPX_VIDEO_EXPIRED', 'expired');

// Field API integration
include_once __DIR__ . '/media_theplatform_mpx.field.inc';

// Helper functions.
include_once __DIR__ . '/media_theplatform_mpx.player.php';
include_once __DIR__ . '/media_theplatform_mpx.video.php';

define('MEDIA_THEPLATFORM_MPX_LOGGING_LEVEL', variable_get('media_theplatform_mpx__watchdog_severity', WATCHDOG_INFO));
define('MEDIA_THEPLATFORM_MPX_MESSAGE_LEVEL', variable_get('media_theplatform_mpx__output_message_watchdog_severity', WATCHDOG_INFO));

/**
 * Implements hook_hook_info().
 */
function media_theplatform_mpx_hook_info() {
  return array_fill_keys(array(
    'media_theplatform_mpx_account_load',
    'media_theplatform_mpx_account_presave',
    'media_theplatform_mpx_account_insert',
    'media_theplatform_mpx_account_update',
    'media_theplatform_mpx_account_delete',
    'media_theplatform_mpx_api_request_alter',
    'media_theplatform_mpx_feed_request_alter',
    'media_theplatform_mpx_file_type',
    'media_theplatform_mpx_import_media',
    'media_theplatform_mpx_media_import_item_alter',
    'media_theplatform_mpx_player_iframe_alter',
    'media_theplatform_mpx_insert_video',
    'media_theplatform_mpx_update_video',
    'media_theplatform_mpx_set_video_inactive',
    'media_theplatform_mpx_account_status',
    'media_theplatform_mpx_account_status_alter',
  ), array('group' => 'mpx'));
}

/**
 * Implements hook_menu().
 */
function media_theplatform_mpx_menu() {
  $items = array();

  $items['admin/config/media/theplatform'] = array(
    'title' => 'Media: thePlatform mpx',
    'description' => 'Configure thePlatForm mpx integration accounts and settings.',
    'page callback' => 'media_theplatform_mpx_account_list',
    'access arguments' => array('administer mpx account'),
    'file' => 'media_theplatform_mpx.admin.inc',
  );
  $items['admin/config/media/theplatform/accounts'] = array(
    'title' => 'Accounts',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/config/media/theplatform/accounts/add'] = array(
    'title' => 'Add mpx account',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('media_theplatform_mpx_account_add_form'),
    'access arguments' => array('administer mpx account'),
    'file' => 'media_theplatform_mpx.admin.inc',
    'type' => MENU_LOCAL_ACTION,
  );
  $items['admin/config/media/theplatform/accounts/%media_theplatform_mpx_account'] = array(
    'title callback' => 'media_theplatform_mpx_account_title',
    'title arguments' => array(5),
    'page callback' => 'media_theplatform_mpx_account_status_report_page',
    'page arguments' => array(5),
    'access arguments' => array('administer mpx account'),
    'file' => 'media_theplatform_mpx.admin.inc',
  );
  $items['admin/config/media/theplatform/accounts/%media_theplatform_mpx_account/status'] = array(
    'title' => 'Status',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );
  $items['admin/config/media/theplatform/accounts/%media_theplatform_mpx_account/ingest'] = array(
    'title' => 'Ingest',
    'page callback' => 'media_theplatform_mpx_account_ingest',
    'page arguments' => array(5),
    'access arguments' => array('administer mpx account'),
    'file' => 'media_theplatform_mpx.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/media/theplatform/accounts/%media_theplatform_mpx_account/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('media_theplatform_mpx_account_edit_form', 5),
    'access arguments' => array('administer mpx account'),
    'file' => 'media_theplatform_mpx.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 10,
  );
  $items['admin/config/media/theplatform/accounts/%media_theplatform_mpx_account/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('media_theplatform_mpx_account_delete_form', 5),
    'access arguments' => array('administer mpx account'),
    'file' => 'media_theplatform_mpx.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 20,
  );
  $items['admin/config/media/theplatform/settings'] = array(
    'title' => 'Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('media_theplatform_mpx_settings_form'),
    'access arguments' => array('administer mpx account'),
    'file' => 'media_theplatform_mpx.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  if (!module_exists('media_theplatform_mpx_reports')) {
    $items['admin/config/media/theplatform/status'] = array(
      'title' => 'Status',
      'page callback' => 'media_theplatform_mpx_status_report_page',
      'access arguments' => array('administer mpx account'),
      'file' => 'media_theplatform_mpx.admin.inc',
      'type' => MENU_LOCAL_TASK,
      'weight' => 10,
    );
  }

  // @todo Replace these two menu items with Views
  $items['admin/content/file/mpxplayer'] = array(
    'title' => 'mpxPlayers',
    'page callback' => 'media_theplatform_mpx_page_mpx_players',
    'type' => MENU_LOCAL_TASK,
    'access arguments' => array('administer files'),
    'weight' => 30,
    'file' => 'media_theplatform_mpx.admin.inc',
  );
  $items['admin/content/file/mpxmedia'] = array(
    'title' => 'mpxMedia',
    'page callback' => 'media_theplatform_mpx_page_mpx_videos',
    'type' => MENU_LOCAL_TASK,
    'access arguments' => array('administer files'),
    'weight' => 40,
    'file' => 'media_theplatform_mpx.admin.inc',
  );
  return $items;
}

/**
 * Title callback: mpx account page.
 *
 * @param MpxAccount $account
 *   The mpx account.
 *
 * @return string
 */
function media_theplatform_mpx_account_title(MpxAccount $account) {
  return (string) $account;
}

/**
 * Implements hook_theme().
 */
function media_theplatform_mpx_theme($existing, $type, $theme, $path) {
  $info['media_theplatform_mpx_player_iframe'] = array(
    'variables' => array(
      'file' => NULL,
      'guid' => NULL,
      'attributes' => array(),
    ),
    'file' => 'media_theplatform_mpx.theme.inc',
  );

  return $info;
}

/**
 * Implements hook_stream_wrappers().
 */
function media_theplatform_mpx_stream_wrappers() {
  return array(
    'mpx' => array(
      'name' => t('mpx videos'),
      'class' => 'MediaThePlatformMpxStreamWrapper',
      'description' => t('Videos provided by ThePlatform.'),
      'type' => STREAM_WRAPPERS_READ_VISIBLE,
    ),
  );
}

/**
 * Implements hook_ctools_plugin_api().
 */
function media_theplatform_mpx_ctools_plugin_api($owner, $api) {
  if ($owner == 'file_entity' && $api == 'file_default_displays') {
    return array('version' => 1);
  }
}

/**
 * Implements hook_watchdog_alter().
 */
function media_theplatform_mpx_watchdog_alter(&$log_entry) {

  if ($log_entry['type'] != 'media_theplatform_mpx') {
    return;
  }

  // Output this message to the page if the site is configured to output
  // messages of this severity, and the message contains the necessary data.
  if ($log_entry['severity'] <= MEDIA_THEPLATFORM_MPX_MESSAGE_LEVEL
      && user_access('administer mpx account')
      && $log_entry['message'] && is_array($log_entry['variables'])) {
    $message_type = $log_entry['severity'] == WATCHDOG_ERROR ? 'error' : 'status';
    drupal_set_message(t($log_entry['message'], $log_entry['variables']), $message_type);
  }

  // If this mpx log entry exceeds the logging level severity, empty the log
  // entry array so it is not processed by other modules (syslog, dblog, etc).
  if ($log_entry['severity'] > MEDIA_THEPLATFORM_MPX_LOGGING_LEVEL) {
    $log_entry = array();
  }
}

/**
 * Helper that returns a description log string for an account if passed.
 *
 * @deprecated
 */
function _media_theplatform_mpx_account_log_string($account = NULL) {

  if (is_object($account) && !empty($account->account_id) && !empty($account->import_account)) {
    return 'account "' . $account->import_account . '" (' . basename($account->account_id) .')';
  }
  elseif (is_object($account) && !empty($account->import_account)) {
    return 'account "' . $account->import_account . '"';
  }
  elseif (is_object($account) && !empty($account->account_id)) {
    return 'account "' . urldecode($account->account_id) . '"';
  }
  elseif (is_object($account) && !empty($account->id)) {
    return 'account ' . urldecode($account->id);
  }

  return 'UNSPECIFIED ACCOUNT';
}

/**
 * Implements hook_cron().
 */
function media_theplatform_mpx_cron() {

  // Save last cron time to determine which videos were processed during the
  // last cron run.
  //   i.e. updated time > cron_next_to_last && updated time < cron_last
  if ($cron_last = variable_get('cron_last', 0)) {
    variable_set('media_theplatform_mpx__cron_next_to_last', $cron_last);
  }

  if (variable_get('media_theplatform_mpx__cron_players', 1)) {
    media_theplatform_mpx_import_all_players('via cron');
  }

  if (variable_get('media_theplatform_mpx__cron_videos', 1)) {
    media_theplatform_mpx_import_all_videos('via cron');
  }
}

/**
 * Implements hook_cron_queue_info().
 */
function media_theplatform_mpx_cron_queue_info($account_id = NULL) {
  $ids = $account_id ? array($account_id) : db_query("SELECT id FROM {mpx_accounts}")->fetchCol();
  foreach ($ids as $id) {
    $queues['media_theplatform_mpx_request_' . $id] = array(
      'worker callback' => '_media_theplatform_mpx_request_queue_process',
      'time' => variable_get('media_theplatform_mpx__cron_videos_timeout', 180),
    );
  }

  $queues['media_theplatform_mpx_video_cron_queue'] = array(
    'worker callback' => 'process_media_theplatform_mpx_video_cron_queue_item',
    'time' => variable_get('media_theplatform_mpx__cron_queue_processing_time', 30),
  );

  return $queues;
}

/**
 * Implements hook_permission().
 */
function media_theplatform_mpx_permission() {
  return array(
    'administer mpx account' => array(
      'title' => t('Administer mpx Account'),
      'description' => t('Can enter administrator login for thePlatform, set mpx Import Account'),
    ),
    'sync mpx_player' => array(
      'title' => t('Sync mpxPlayers manually'),
      'description' => t('Can access mpxPlayers Sync form.'),
    ),
    'sync mpx_video' => array(
      'title' => t('Sync mpxMedia manually'),
      'description' => t('Can access Sync mpxMedia form.'),
    ),
  );
}

/**
 * Helper for flattening a multi-dimensional array.
 * Found here: http://stackoverflow.com/questions/1319903/how-to-flatten-a-multidimensional-array
 */
function _media_theplatform_mpx_flatten_array(Array $array) {

  $return = array();
  array_walk_recursive($array, function($a) use (&$return) { $return[] = $a; });

  return $return;
}

/**
 * Helper to flatten multiple-value entity field to a single-dimensional array.
 */
function _media_theplatform_mpx_flatten_multiple_value_field($field, $data_key = 'value') {

  $values = array();
  if (!empty($field[ LANGUAGE_NONE ])) {
    foreach ($field[ LANGUAGE_NONE ] as $key => $data) {
      $values[ $key ] = $data[ $data_key ];
    }
  }

  return $values;
}

/**
 * Helper that converts shorthand memory limits to actual bytes.
 */
function _media_theplatform_mpx_convert_shorthand_to_bytes($shorthand) {

  $shorthand_amount = (int)$shorthand;
  $shorthand_size = strtoupper(preg_replace('|[0-9]+|', '', $shorthand));

  switch ($shorthand_size) {
    case '':
      return $shorthand_amount;
    case 'K':
      return $shorthand_amount * 1024;
    case 'M':
      return $shorthand_amount * 1048576;
    case 'G':
      return $shorthand_amount * 1073741824;
  }

  return NULL;
}

/**
 * Helper that retrieves and returns data from an mpx feed URL.
 *
 * @deprecated
 */
function _media_theplatform_mpx_retrieve_feed_data($url, $json_decode = TRUE, $options = array()) {
  $options += array(
    'timeout' => variable_get('media_theplatform_mpx__cron_videos_timeout', 180),
  );

  // Allow for altering the URL before making the request.
  drupal_alter('media_theplatform_mpx_feed_request', $url, $options);

  // Fetch the actual feed data.
  $result = drupal_http_request($url, $options);
  $response_time = round(timer_read('drupal_http_request') / 1000.0, 2);

  if (!is_object($result)) {
    watchdog('media_theplatform_mpx', 'Failed to retrieve mpx feed data. drupal_http_request() did not return an object.',
      array(), WATCHDOG_ERROR);

    return $json_decode ? array() : '';
  }
  if (empty($result->data)) {
    watchdog('media_theplatform_mpx', 'Failed to retrieve mpx feed data. No data returned from thePlatform after @time seconds from: @url
<br />Response information:
<br /><pre>@response</pre>',
      array(
        '@time' => $response_time,
        '@url' => $url,
        '@response' => print_r($result, TRUE),
      ),
      WATCHDOG_ERROR);

    return $json_decode ? array() : ''  ;
  }

  watchdog('media_theplatform_mpx', 'Request to retrieve mpx feed data took @time second(s).',
    array('@time' => $response_time), WATCHDOG_INFO);

  $memory_limit = ini_get('memory_limit');
  $memory_limit_in_bytes = _media_theplatform_mpx_convert_shorthand_to_bytes($memory_limit);
  $expensive_operation_min_memory = 536870912;

  if (variable_get('media_theplatform_mpx_debug', 0)) {
    // Increase memory if necessary beforehand, as this message can be
    // be extremely large and use up available memory if set lower than 512M.
    if ($memory_limit_in_bytes < $expensive_operation_min_memory) {
      ini_set('memory_limit', '512M');
    }
    media_theplatform_mpx_debug($result, "Request to retrieve mpx data with drupal_http_request()");
    if ($memory_limit_in_bytes < $expensive_operation_min_memory) {
      ini_set('memory_limit', $memory_limit);
    }
  }

  $result_data = $result->data;

  if ($json_decode) {

    if ($memory_limit_in_bytes < $expensive_operation_min_memory) {
      ini_set('memory_limit', '512M');
    }

    $result_data = drupal_json_decode($result_data);

    if ($memory_limit_in_bytes < $expensive_operation_min_memory) {
      ini_set('memory_limit', $memory_limit);
    }

    if (!empty($result->data) && $result_data === NULL && json_last_error() != JSON_ERROR_NONE) {
      watchdog('media_theplatform_mpx', 'Failed to decode JSON response data with drupal_json_decode() from the following URL: @url
<br />...and the following data returned from thePlatform:
<br /><pre>@response</pre>.', array('@url' => $url, '@response' => print_r($result, TRUE)), WATCHDOG_ERROR);
      return array();
    }
  }

  if (empty($result_data)) {
    watchdog('media_theplatform_mpx', 'Request to retrieve mpx feed data returned no data.', array(), WATCHDOG_INFO);
    return $json_decode ? array() : '';
  }

  if (isset($result_data['isException']) && $result_data['isException'] === TRUE) {
    watchdog('media_theplatform_mpx', 'Request to retrieve mpx feed data returned a(n) "@title" exception.  Description:  @description  --  Response Code:  @response_code  --  Correlation ID:  @correlation_id',
      array(
        '@title' => $result_data['title'],
        '@description' => $result_data['description'],
        '@response_code' => $result_data['responseCode'],
        '@correlation_id' => $result_data['correlationId'],
      ),
      WATCHDOG_ERROR);
    return $json_decode ? array() : '';
  }

  return $result_data;
}

/**
 * Implements hook_media_theplatform_mpx_feed_request_alter().
 */
function media_theplatform_mpx_media_theplatform_mpx_feed_request_alter(&$url, &$options) {
  // drupal_http_request will choke on protocol relative urls.
  if (strpos($url, '//') !== 0) {
    return;
  }
  global $is_https;
  $url_scheme = $is_https ? 'https' : 'http';
  $url = $url_scheme . $url;
}

/**
 * Helper that returns a specific rating value from media feed data.
 */
function _media_theplatform_mpx_get_rating_media_item_data($rating_type, $media_data) {

  $rating_feed_data = $media_data['media$ratings'];

  foreach ($rating_feed_data as $key => $data) {
    if ($data['scheme'] == 'urn:' . $rating_type) {
      return $data['rating'];
    }
  }

  return '';
}

/**
 * Helper that returns a specific sub-rating value from media feed data.
 */
function _media_theplatform_mpx_get_subrating_media_item_data($rating_type, $media_data) {

  $rating_feed_data = $media_data['media$ratings'];

  foreach ($rating_feed_data as $key => $data) {
    if ($data['scheme'] == 'urn:' . $rating_type) {
      return $data['subRatings'];
    }
  }

  return NULL;
}

/**
 * Helper that returns the default content release file pid from media feed data.
 */
function _media_theplatform_mpx_get_default_released_file_pid($media_data) {

  if (empty($media_data['media$content']) || !is_array($media_data['media$content'])) {
    return '';
  }

  $default_media_content_item = NULL;

  foreach ($media_data['media$content'] as $content_item) {
    if ($content_item['plfile$isDefault']) {
      $default_media_content_item = $content_item;
    }
  }

  // Use the media item with the highest bitrate as a fall-back.
  if (!$default_media_content_item && !empty($media_data['media$content'])) {
    $media_content_items_by_bitrate = array();
    foreach ($media_data['media$content'] as &$content_item) {
      $media_content_items_by_bitrate[$content_item['plfile$bitrate']] = $content_item;
    }
    ksort($media_content_items_by_bitrate);
    $default_media_content_item = array_pop($media_content_items_by_bitrate);
  }

  if (!$default_media_content_item
      || !is_array($default_media_content_item['plfile$releases'])
      || empty($default_media_content_item['plfile$releases'])) {
    return '';
  }

  // Get the most recently added public URL to use as the default.
  $public_url_pids = array();
  foreach ($default_media_content_item['plfile$releases'] as $public_url_data) {
    $public_url_pids[$public_url_data['added']] = $public_url_data['plrelease$pid'];
  }
  ksort($public_url_pids);

  return array_pop($public_url_pids);
}

/**
 * Helper function for getting data from thePlatform feed arrays.
 */
function _media_theplatform_mpx_get_media_item_data($path, $media_data) {

  $data = NULL;
  $path_parts = explode('/', $path);

  // Handle single-level value paths.
  if (count($path_parts) == 1) {
    $field_name = array_shift($path_parts);
    if (isset($media_data[ $field_name ])) {
      $data = $media_data[ $field_name ];
    }
    elseif (is_array($media_data)) {
      $data = array();
      foreach ($media_data as $key => $value) {
        if (is_array($value) && isset($value[ $field_name ])) {
          $data[ $key ] = $value[ $field_name ];
        }
      }
    }
    return $data;
  }

  // Otherwise, we're recursing.
  $first_path_part = array_shift($path_parts);

  if (isset($media_data[ $first_path_part ])) {
    $path = implode('/', $path_parts);
    $media_data = $media_data[ $first_path_part ];
    $data = _media_theplatform_mpx_get_media_item_data($path, $media_data);
  }
  // If the field can't be found in $media_data, this may be a recursive call,
  // and $media_data is an array of sub-values that we need to iterate, and
  // possibly recurse, over.
  elseif (is_array($media_data)) {
    $data = array();
    $path = implode('/', $path_parts);
    foreach ($media_data as $key => $value) {
      if (isset($value[ $first_path_part ])) {
        $media_data = $value[ $first_path_part ];
        $data[ $key ] = _media_theplatform_mpx_get_media_item_data($path, $media_data);
      }
    }
  }

  return $data;
}


/**
 * Helper that enforces field limits as defined in a database schema.
 */
function _media_theplatform_mpx_enforce_db_field_limits(&$fields, $module, $table) {

  // Enforce database schema defined field limits on inserted values.
  $schema = drupal_get_schema_unprocessed($module, $table);
  $schema = $schema['fields'];

  foreach ($fields as $field_name => $field_value) {

    if (!isset($schema[$field_name])) {
      unset($fields[$field_name]);
      continue;
    }

    $field_type = $schema[$field_name]['type'];
    $field_length = strlen($field_value);

    if ($field_type == 'varchar' || $field_type == 'char') {
      $char_limit = !empty($schema[$field_name]['length']) ? (int)$schema[$field_name]['length'] : 255;
      if ($field_length > $char_limit) {
        $fields[$field_name] = substr($field_value, 0, $char_limit);
      }
    }
    elseif ($field_type == 'blob' || $field_type == 'text') {
      $field_size = !empty($schema[$field_name]['size']) ? $schema[$field_name]['size'] : 'normal';
      switch ($field_size) {
        case 'tiny':
        case 'small':
          if ($field_length > 255) {
            $fields[$field_name] = substr($field_value, 0, 255);
          }
          break;
        case 'medium':
          if ($field_length > 16777215) {
            $fields[$field_name] = substr($field_value, 0, 16777215);
          }
          break;
        case 'big':
          if ($field_length > 4294967295) {
            $fields[$field_name] = substr($field_value, 0, 4294967295);
          }
          break;
        case 'normal':
          if ($field_length > 65535) {
            $fields[$field_name] = substr($field_value, 0, 65535);
          }
          break;
      }
    }
    elseif ($field_type == 'int') {
      $signed = empty($schema[$field_name]['unsigned']);
      $field_size = !empty($schema[$field_name]['size']) ? $schema[$field_name]['size'] : 'normal';
      switch ($field_size) {
        case 'tiny':
          if (!is_null($field_value) && $signed && $field_value < -128) {
            $fields[$field_name] = -128;
          }
          elseif ($signed && $field_value > 127) {
            $fields[$field_name] = 127;
          }
          elseif ($signed && $field_value > 255) {
            $fields[$field_name] = 255;
          }
          break;
        case 'small':
          if (!is_null($field_value) && $signed && $field_value < -32768) {
            $fields[$field_name] = -32768;
          }
          elseif ($signed && $field_value > 32767) {
            $fields[$field_name] = 32767;
          }
          elseif ($signed && $field_value > 65535) {
            $fields[$field_name] = 65535;
          }
          break;
        case 'medium':
          if (!is_null($field_value) && $signed && $field_value < -8388608) {
            $fields[$field_name] = -8388608;
          }
          elseif ($signed && $field_value > 8388607) {
            $fields[$field_name] = 8388607;
          }
          elseif ($signed && $field_value > 16777215) {
            $fields[$field_name] = 16777215;
          }
          break;
        case 'big':
          if (!is_null($field_value) && $signed && $field_value < -9223372036854775808) {
            $fields[$field_name] = -9223372036854775808;
          }
          elseif ($signed && $field_value > 9223372036854775807) {
            $fields[$field_name] = 9223372036854775807;
          }
          elseif ($signed && $field_value > 18446744073709551615) {
            $fields[$field_name] = 18446744073709551615;
          }
          break;
        case 'normal':
          if (!is_null($field_value) && $signed && $field_value < -2147483648) {
            $fields[$field_name] = -2147483648;
          }
          elseif ($signed && $field_value > 2147483647) {
            $fields[$field_name] = 2147483647;
          }
          elseif ($signed && $field_value > 4294967295) {
            $fields[$field_name] = 4294967295;
          }
          break;
      }
    }
  }
}

/**
 * Implements hook_libraries_info().
 *
 * @todo Remove this.
 */
function media_theplatform_mpx_libraries_info() {

  $libraries['zend_crypt'] = array(
    'title' => 'Zend Crypt',
    'vendor_url' => 'https://github.com',
    'download_url' => 'https://github.com/zendframework/zf2/tree/master/library/Zend/Crypt',
    'version arguments' => array(
      'file' => 'composer.json',
      'pattern' => '/"dev-master": "([0-9.]+)-dev"/',
      'lines' => 30,
    ),
    'path' => '',
    'files' => array(
      'php' => array(
        'vendor/autoload.php',
      ),
    ),
  );

  return $libraries;
}


/**
 * Helper that deletes an mpx account and all of its associated media and data.
 */
function _media_theplatform_mpx_delete_account($account_id, $progressive = TRUE) {
  // Turn off player and media sync.
  variable_set('media_theplatform_mpx__account_' . $account_id . '_cron_player_sync', 0);
  variable_set('media_theplatform_mpx__account_' . $account_id . '_cron_video_sync', 0);

  $delete_account_batch = array(
    'title' => t('Deleting MPX Account @id' , array('@id' => $account_id)),
    'operations' => array(
      array('_media_theplatform_mpx_delete_account_video_cron_queue', array($account_id)),
      array('_media_theplatform_mpx_delete_account_media', array($account_id, 'video')),
      array('_media_theplatform_mpx_delete_account_media', array($account_id, 'player')),
      array('_media_theplatform_mpx_delete_account_data', array($account_id)),
    ),
    'finished' => '_media_theplatform_mpx_delete_account_finished',
  );
  batch_set($delete_account_batch);

  // Because we are doing this on the back-end, we set progressive to false.
  if (!$progressive) {
    $batch =& batch_get();
    $batch['progressive'] = $progressive;
    batch_process();
  }
}

/**
 * Helper that delets the video cron queue items for a given account.
 */
function _media_theplatform_mpx_delete_account_video_cron_queue($account_id, &$context) {

  // We can't use the Drupal Queue API here. When we release a queue item, we
  // could very well get it right back when claiming an item.
  if (empty($context['sandbox'])) {
    $context['sandbox']['range_limit'] = 50;
    $context['sandbox']['total_queue_items_processed'] = 0;
    $context['sandbox']['last_processed_item_id'] = 0;
  }

  // If another account is in the process of ingesting videos, the cron queue
  // will continue to grow.  Make sure this value is up to date on each batch
  // iteration.
  $context['sandbox']['total_queue_items'] = db_select('queue')
    ->fields('queue')
    ->condition('name', 'media_theplatform_mpx_video_cron_queue', '=')
    ->condition('item_id', $context['sandbox']['last_processed_item_id'], '>')
    ->execute()
    ->rowCount();

  $video_queue_items = db_select('queue')
    ->fields('queue')
    ->condition('name', 'media_theplatform_mpx_video_cron_queue', '=')
    ->condition('expire', 0, '=')
    ->condition('item_id', $context['sandbox']['last_processed_item_id'], '>')
    ->range(0, $context['sandbox']['range_limit'])
    ->orderBy('item_id', 'ASC')
    ->execute()
    ->fetchAll();

  // Bail if we have no more results.
  if (empty($video_queue_items)) {
    $context['message'] = t('All video cron queue items have been deleted for account @account_id.',
      array(
        '@account_id' => $account_id,
      ));
    $context['finished'] = 1;
    watchdog('media_theplatform_mpx', 'Completed process of deleting video cron queue items for account @id.',
      array('@id' => $account_id), WATCHDOG_NOTICE);
    return;
  }

  // Mark all queue items we're about to process as claimed by setting the
  // expire column value to a timestamp 1 minute in the future.
  $queued_item_ids = array();
  foreach ($video_queue_items as $queue_item) {
    $queued_item_ids[] = $queue_item->item_id;
  }
  db_update('queue')
    ->fields(array('expire' => time() + 60))
    ->condition('item_id', $queued_item_ids, 'IN')
    ->execute();

  $queue_items_to_delete = array();
  $queue_items_to_keep = array();

  foreach ($video_queue_items as $queue_item) {
    $queue_item->data = unserialize($queue_item->data);
    // If a queue item has a non-zero expire value, then it has already been
    // claimed for processing.
    if (isset($queue_item->data['account_id']) && $queue_item->data['account_id'] == $account_id) {
      $queue_items_to_delete[] = $queue_item->item_id;
      $context['results'][] = $queue_item->item_id;
    }
    elseif (isset($queue_item->data['account']->id) && $queue_item->data['account']->id == $account_id) {
      $queue_items_to_delete[] = $queue_item->item_id;
      $context['results'][] = $queue_item->item_id;
    }
    else {
      $queue_items_to_keep[] = $queue_item->item_id;
    }
    $context['sandbox']['total_queue_items_processed']++;
  }

  // Delete items to delete.
  if (!empty($queue_items_to_delete)) {
    db_delete('queue')
      ->condition('name', 'media_theplatform_mpx_video_cron_queue', '=')
      ->condition('item_id', $queue_items_to_delete, 'IN')
      ->execute();
  }
  // Set expire to 0 for items not to delete - i.e. releasing the queue items.
  if (!empty($queue_items_to_keep)) {
    db_update('queue')
      ->fields(array('expire' => 0))
      ->condition('name', 'media_theplatform_mpx_video_cron_queue', '=')
      ->condition('item_id', $queue_items_to_keep, 'IN')
      ->execute();
  }


  $context['sandbox']['last_processed_item_id'] = max($queued_item_ids);
  $context['message'] = t('@remaining_queue_items video queue items remain to be processed.  It is normal for the number of items to increase if other accounts are in the process of ingesting media.',
    array(
      '@remaining_queue_items' => ($context['sandbox']['total_queue_items'] - count($video_queue_items)),
    ));
  $context['finished'] = 0;
}

/**
 * Helper that deletes all media for an account of a given type.
 */
function _media_theplatform_mpx_delete_account_media($account_id, $type, &$context) {

  $mpx_table = 'mpx_' . $type;
  $id_key = $type . '_id';

  if (!isset($context['sandbox']['count'])) {
    $context['sandbox']['last_id'] = 0;
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['total'] = db_select($mpx_table)
      ->condition('parent_account', $account_id)
      ->countQuery()->execute()->fetchField();
  }

  $mpx_ids = db_select($mpx_table)
    ->fields($mpx_table, array($id_key, 'fid'))
    ->condition('parent_account', $account_id)
    ->condition($id_key, $context['sandbox']['last_id'], '>')
    ->orderBy($id_key)
    ->range(0, 50)
    ->execute()
    ->fetchAllKeyed();

  if (empty($mpx_ids)) {
    $context['message'] = t('All data from @table has been deleted.', array('@table' => $mpx_table));
    $context['finished'] = 1;
    return;
  }

  file_delete_multiple($mpx_ids);
  $context['sandbox']['progress'] += count($mpx_ids);
  $context['sandbox']['last_id'] = max(array_keys($mpx_ids));

  // Inform batch engine about progress.
  if ($context['sandbox']['progress'] < $context['sandbox']['total']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['total'];
  }
}

/**
 * Helper that deletes all data for an mpx account after its media are deleted.
 */
function _media_theplatform_mpx_delete_account_data($account_id) {
  // Attempt to load the mpx account object. This will only work if the module
  // is not being uninstalled.
  $account = NULL;
  if (class_exists('MpxAccount')) {
    $account = MpxAccount::load($account_id);
  }

  // Delete the deprecated Drush request queue for the account.
  /** @var DrupalReliableQueueInterface $queue */
  $queue = DrupalQueue::get('media_theplatform_mpx_video_request_queue_' . $account_id, TRUE);
  $queue->deleteQueue();

  db_delete('mpx_accounts')->condition('id', $account_id)->execute();
  db_delete('mpx_account_data')->condition('account_id', $account_id)->execute();

  // Invoke the deletion hook.
  if (!empty($account)) {
    module_invoke_all('media_theplatform_mpx_account_delete', $account);
    // Only release the account's token if no other mpx accounts have the same
    // username.
    if (!db_query("SELECT 1 FROM {mpx_accounts} WHERE username = :username AND id <> :id", array(':username' => $account->username, ':id' => $account_id))->fetchField()) {
      $account->releaseToken();
    }

    // Delete the account's queues.
    MpxRequestQueue::get($account)->deleteQueue();
  }

  // Remove variables disabling video and player sync for this account.
  variable_del('media_theplatform_mpx__account_' . $account_id . '_cron_player_sync');
  variable_del('media_theplatform_mpx__account_' . $account_id . '_cron_video_sync');
}

/**
 * Finished callback for when an account has been deleted.
 */
function _media_theplatform_mpx_delete_account_finished($account_id) {
  drupal_flush_all_caches();
  watchdog('media_theplatform_mpx', 'Completed process of deleting account @id.',
    array('@id' => $account_id), WATCHDOG_NOTICE);
}

/**
 * Get the URI of the image for an mpx video.
 *
 * @param object $file
 *   An mpx video file object.
 *
 * @return string|bool
 *   The URI of the image, or FALSE if an image was not available.
 */
function media_theplatform_mpx_get_image_uri($file) {
  $uri = FALSE;
  if (file_uri_scheme($file->uri) === 'mpx') {
    /** @var MediaThePlatformMpxStreamWrapper $wrapper */
    $wrapper = file_stream_wrapper_get_instance_by_uri($file->uri);
    $local_uri = $wrapper->getLocalThumbnailPath();
    if (is_file($local_uri)) {
      $uri = $local_uri;
    }
    else {
      $uri = $wrapper->getOriginalThumbnailPath();
    }
    drupal_alter('media_theplatform_mpx_image_uri', $uri, $file);
  }
  return $uri;
}

/**
 * Implements hook_representative_image_ENTITY_TYPE_image_alter().
 */
function media_theplatform_mpx_representative_image_file_image_alter(&$image, $entity, $bundle_name) {
  if (!$image && $uri = media_theplatform_mpx_get_image_uri($entity)) {
    $image = file_create_url($uri);
  }
}

/**
 * Implements hook_representative_image_views_handler_render().
 */
function media_theplatform_mpx_representative_image_views_handler_render($type, $entity, $field, $bundle, $values, $options) {
  if ($type === 'file' && !$field && $uri = media_theplatform_mpx_get_image_uri($entity)) {
    if (!empty($options['image_style']) && (file_valid_uri($uri) || (url_is_external($uri) && module_exists('imagecache_external')))) {
      return array(
        '#theme' => 'image_style',
        '#style_name' => $options['image_style'],
        '#path' => $uri,
        '#attributes' => array(
          'class' => 'mpx-video-thumbnail',
        ),
      );
    }
    else {
      return array(
        '#theme' => 'image',
        '#path' => $uri,
        '#attributes' => array(
          'class' => 'mpx-video-thumbnail',
        ),
      );
    }
  }
}

/**
 * Implements hook_form_alter().
 */
function media_theplatform_mpx_form_alter(&$form, &$form_state, $form_id) {
  // Check if media: single file delete form.
  if ($form_id == 'file_delete_form') {
    $file = file_load($form['fid']['#value']);
    if ($file->filemime == 'player/mpx' && media_theplatform_mpx_get_files_by_player_fid($file->fid)) {
      drupal_set_message(t('@filename cannot be deleted because it is referenced by other mpxMedia Files.', array('@filename' => $file->filename)), 'error');
      unset($form['actions']['submit']);
      unset($form['description']);
    }
  }
  // Check if bulk media delete form.
  elseif ($form_id == 'file_entity_admin_files' && isset($form['operation']) && $form['operation']['#value'] == 'delete') {
    foreach ($form['files'] as $key => $data ) {
      if (is_numeric($key) && isset($data['#value'])) {
        $file = file_load($data['#value']);
        if ($file->filemime == 'player/mpx' && media_theplatform_mpx_get_files_by_player_fid($file->fid)) {
          drupal_set_message(t('@filename cannot be deleted because it is referenced by other mpxMedia Files.', array('@filename' => $file->filename)), 'error');
          unset($form['actions']['submit']);
          unset($form['description']);
        }
      }
    }
  }
}

/**
 * Loads an mpx account.
 *
 * @param int $id
 *   The mpx account ID to load.
 *
 * @return MpxAccount|object
 *   A loaded mpx account object, or FALSE if the account cannot be loaded.
 */
function media_theplatform_mpx_account_load($id) {
  return MpxAccount::load($id);
}

/**
 * @deprecated
 *
 * Use MpxAccount::acquireToken() instead.
 */
function media_theplatform_mpx_check_token($id) {
  if ($account = MpxAccount::load($id)) {
    return (string) $account->acquireToken();
  }
}

/**
 * @deprecated
 *
 * Use MpxAccount::load() or MpxAccount::loadAll() instead.
 */
function _media_theplatform_mpx_get_account_data($id = NULL) {
  if ($id) {
    return MpxAccount::load($id);
  }
  else {
    return MpxAccount::loadAll();
  }
}

/**
 * @deprecated
 *
 * Use variable_get() instead.
 */
function media_theplatform_mpx_variable_get($name, $default = NULL) {
  return variable_get('media_theplatform_mpx__' . $name, $default);
}

/**
 * @deprecated
 *
 * Use variable_set() instead.
 */
function media_theplatform_mpx_variable_set($name, $value) {
  variable_set('media_theplatform_mpx__' . $name, $value);
}

/**
 * @deprecated
 *
 * Use encrypt() instead.
 */
function _media_theplatform_mpx_encrypt_value($value) {
  if (empty($value)) {
    return NULL;
  }

  if (!extension_loaded('mcrypt')) {
    return base64_encode($value);
  }

  $library = libraries_load('zend_crypt');
  $key = md5($GLOBALS['drupal_hash_salt']);

  // If library doesn't exist, use a less secure means of encryption/decryption.
  if (!$library['loaded']) {
    $keysize = mcrypt_get_key_size(MCRYPT_DES, MCRYPT_MODE_ECB);
    $key = drupal_substr($key, 0, $keysize);
    $block = mcrypt_get_block_size(MCRYPT_DES, MCRYPT_MODE_ECB);
    $pad = $block - (strlen($value) % $block);
    $value .= str_repeat(chr($pad), $pad);
    $return = mcrypt_encrypt(MCRYPT_DES, $key, $value, MCRYPT_MODE_ECB);
    if (!$return) {
      trigger_error('Unable to encrypt MPX value.', E_USER_ERROR);
    }
    return base64_encode($return);
  }

  $blockCipher = Zend\Crypt\BlockCipher::factory('mcrypt', array('algo' => 'aes'));
  $blockCipher->setKey($key);
  $return = $blockCipher->encrypt($value);
  if ($return === FALSE) {
    trigger_error('Unable to encrypt MPX value.', E_USER_ERROR);
  }
  return $return;
}

/**
 * @deprecated
 *
 * Use decrypt() instead.
 */
function _media_theplatform_mpx_decrypt_value($value) {
  if (empty($value)) {
    return NULL;
  }

  if (!extension_loaded('mcrypt')) {
    return base64_decode($value);
  }

  $library = libraries_load('zend_crypt');
  $key = md5($GLOBALS['drupal_hash_salt']);

  // If library doesn't exist, use a less secure means of encryption/decryption.
  if (!$library['loaded']) {
    $value = base64_decode($value);
    $keysize = mcrypt_get_key_size(MCRYPT_DES, MCRYPT_MODE_ECB);
    $key = drupal_substr($key, 0, $keysize);
    $str = mcrypt_decrypt(MCRYPT_DES, $key, $value, MCRYPT_MODE_ECB);
    if (!$str) {
      trigger_error('Unable to decrypt MPX value.', E_USER_ERROR);
      return FALSE;
    }
    $block = mcrypt_get_block_size(MCRYPT_DES, MCRYPT_MODE_ECB);
    $pad = ord($str[($len = strlen($str)) - 1]);
    $return = substr($str, 0, strlen($str) - $pad);
    if ($return === FALSE) {
      trigger_error('Unable to decrypt MPX value.', E_USER_ERROR);
    }
    return $return;
  }

  $blockCipher = Zend\Crypt\BlockCipher::factory('mcrypt', array('algo' => 'aes'));
  $blockCipher->setKey($key);
  $return = $blockCipher->decrypt($value);
  if ($return === FALSE) {
    trigger_error('Unable to decrypt MPX value.', E_USER_ERROR);
  }
  return $return;
}

/**
 * @deprecated
 *
 * Stores a field value for a specified field and table by specified ID field and value.
 */
function _media_theplatform_mpx_set_field($id, $field_name, $field_value, $table = 'mpx_accounts', $id_field = 'id') {
  if ($table === 'mpx_accounts') {
    if ($id = db_select('mpx_accounts')
      ->addField('mpxa', array('id'))
      ->condition($id_field, $id)
      ->execute()->fetchField()) {
      return _media_theplatform_mpx_set_account_value($id, $field_name, $field_value);
    }
    else {
      return FALSE;
    }
  }
  else {
    return db_update($table)
      ->fields(array($field_name => $field_value))
      ->condition($id_field, $id, '=')
      ->execute();
  }
}

/**
 * @deprecated
 *
 * Sets a field value for a specified account.
 */
function _media_theplatform_mpx_set_account_value($account_id, $field_name, $field_value) {
  $account = MpxAccount::load($account_id);
  if (property_exists($account, $field_name)) {
    $account->{$field_name} = $field_value;
    $account->save();
  }
  else {
    $account->setDataValue($field_name, $field_value);
  }
  return TRUE;
}

/**
 * Fetch the iframe URL for the player of a specific mpx video.
 *
 * @param array $variables
 *   An associative array containing one of the following:
 *   - file: The mpx video file object.
 *   - guid: The mpx video guid string.
 *   - account_id: The mpx account ID if multiple videos share the same guid.
 *
 * @return string|null
 *   The iframe URL if available, or NULL if not available.
 */
function media_theplatform_mpx_get_player_iframe_url(array $variables) {
  if (!empty($variables['file']) && $variables['file']->filemime === 'video/mpx') {
    // If an mpx video file object was provided, fetch the guid, player_id,
    // account_id, and account_pid values.
    $data = db_query("SELECT mpxv.guid, COALESCE(mpxv.player_id, mpxa.default_player) AS player_id, mpxa.account_id, mpxa.account_pid FROM {mpx_video} mpxv INNER JOIN {mpx_accounts} mpxa ON mpxv.parent_account = mpxa.id WHERE fid = :fid", array(':fid' => $variables['file']->fid))->fetchAssoc();
    if ($data) {
      $variables += $data;
    }
  }
  elseif (!empty($variables['guid']) && !empty($variables['account_id'])) {
    // If a manual guid and account id values were provided, fetch the
    // player_id and account_pid values.
    $data = db_query("SELECT COALESCE(mpxv.player_id, mpxa.default_player) AS player_id, mpxa.account_pid FROM {mpx_video} mpxv INNER JOIN {mpx_accounts} mpxa ON mpxv.parent_account = mpxa.id WHERE guid = :guid AND mpxa.id = :account", array(':guid' => $variables['guid'], ':account' => $variables['account_id']))->fetchAssoc();
    if ($data) {
      $variables += $data;
    }
  }
  elseif (!empty($variables['guid'])) {
    // If a manual guid value was provided, fetch the player_id, account_id,
    // and account_pid values.
    $data = db_query("SELECT COALESCE(mpxv.player_id, mpxa.default_player) AS player_id, mpxa.account_id, mpxa.account_pid FROM {mpx_video} mpxv INNER JOIN {mpx_accounts} mpxa ON mpxv.parent_account = mpxa.id WHERE guid = :guid", array(':guid' => $variables['guid']))->fetchAssoc();
    if ($data) {
      $variables += $data;
    }
  }

  // Ensure the player_pid value is set if possible.
  if (empty($variables['player_pid']) && !empty($variables['player_id'])) {
    // Prefetch all player ID to pid mappings to save database queries if this
    // is run more than once.
    $pids = drupal_static(__FUNCTION__ . ':pids');
    if (!isset($pids)) {
      $pids = db_query("SELECT player_id, pid FROM {mpx_player}")->fetchAllKeyed();
    }

    if (!empty($pids[$variables['player_id']])) {
      $variables['player_pid'] = $pids[$variables['player_id']];
    }
  }

  if (!empty($variables['account_pid']) && !empty($variables['player_pid']) && !empty($variables['account_id']) && !empty($variables['guid'])) {
    return '//player.theplatform.com/p/' . $variables['account_pid'] . '/' . $variables['player_pid'] . '/embed/select/media/guid/' . basename($variables['account_id']) . '/' . $variables['guid'];
  }
}

/**
 * @deprecated
 *
 * Returns array of all accounts specified thePlatform account.
 */
function media_theplatform_mpx_get_accounts_select($account_id, $username = NULL, $password = NULL, MpxToken $token = NULL) {

  $for = '';
  if ($account_id) {
    $for = 'account ' . $account_id;
  }
  elseif ($username) {
    $for = 'user "' . $username . '"';
  }
  elseif ($token) {
    $for = 'token "' . $token . '"';
  }

  try {
    if (empty($token) && empty($account_id) && $username && $password) {
      $token = MpxToken::fetch($username, $password);
    }
    elseif (empty($token) && !empty($account_id)) {
      $account_data = MpxAccount::load($account_id);
      if (empty($account_data)) {
        watchdog('media_theplatform_mpx', 'Failed to retrieve all import accounts.  Account data unavailable for account @id.',
          array('@id' => $account_id), WATCHDOG_ERROR);

        return array();
      }
      $token = $account_data->acquireToken();
    }
    elseif (empty($token)) {
      watchdog('media_theplatform_mpx', 'Failed to retrieve all import accounts because a account ID, token or username and password were not available.',
        array(), WATCHDOG_ERROR);

      return array();
    }
  }
  catch (Exception $e) {
    drupal_set_message($e->getMessage(), 'error');
    watchdog_exception('media_theplatform_mpx', $e);
    return array();
  }

  // Get the list of accounts from thePlatform.
  $url = 'https://access.auth.theplatform.com/data/Account?schema=1.3.0&form=json&byDisabled=false&token=' . rawurlencode($token)
    . '&fields=id,title';

  $result_data = _media_theplatform_mpx_retrieve_feed_data($url);

  if (empty($account_id)) {
    $token->expire();
  }

  if (empty($result_data['entryCount']) || $result_data['entryCount'] == 0) {
    watchdog('media_theplatform_mpx', 'Failed to retrieve import accounts for @for.  The mpx user provided does not have the necessary administrative privileges.',
      array('@for' => $for), WATCHDOG_ERROR);

    return array();
  }

  $sub_accounts = array();
  foreach ($result_data['entries'] as $entry) {
    $title = $entry['title'];
    $sub_accounts[$title] = $title;
  }

  $query = db_select('mpx_accounts', 'mpxa')
    ->fields('mpxa', array('import_account'));
  if (!empty($account_id)) {
    $query->condition('id', $account_id, '<>');
  }
  if ($existing_sub_accounts = $query->execute()->fetchCol()) {
    $sub_accounts = array_diff($sub_accounts, $existing_sub_accounts);
  }

  // Sort accounts alphabetically.
  natcasesort($sub_accounts);

  return $sub_accounts;
}

/**
 * @deprecated
 *
 * Checks if file is active in its mpx datatable.
 *
 * @param Object $file
 *   A File Object.
 *
 * @return Boolean
 *   TRUE if the file is active, and FALSE if it isn't.
 */
function media_theplatform_mpx_is_file_active($file) {
  if ($file->filemime === 'video/mpx') {
    return (bool) db_query("SELECT status FROM {mpx_video} WHERE fid = :fid", array(':fid' => $file->fid))->fetchField();
  }
  elseif ($file->filemime === 'player/mpx') {
    return (bool) db_query("SELECT status FROM {mpx_player} WHERE fid = :fid", array(':fid' => $file->fid))->fetchField();
  }
}

/**
 * Wrapper for MpxRequestQueue::processItem() since queue workers cannot
 * be a callable in Drupal 7.
 *
 * @param $data
 * @return bool
 */
function _media_theplatform_mpx_request_queue_process($data) {
  return MpxRequestQueue::processItem($data);
}

/**
 * Implements hook_views_api().
 */
function media_theplatform_mpx_views_api() {
  return array(
    'api' => 3,
  );
}

/**
 * Checks if a video is available.
 *
 * @param int $available_date
 *   The UNIX timestamp of when the video will be available, or 0 if the video
 *   is available immediately.
 * @param int $expiration_date
 *   The UNIX timestamp of when the video will expire, or 0 if the video will
 *   not expire.
 *
 * @return string
 *   Either MPX_VIDEO_UNAVAILABLE, MPX_VIDEO_AVAILABLE, or MPX_VIDEO_EXPIRED.
 */
function media_theplatform_mpx_get_video_availability($available_date, $expiration_date) {
  if ($available_date && $available_date > REQUEST_TIME) {
    return MPX_VIDEO_UNAVAILABLE;
  }
  elseif ($expiration_date && $expiration_date <= REQUEST_TIME) {
    return MPX_VIDEO_EXPIRED;
  }
  else {
    return MPX_VIDEO_AVAILABLE;
  }
}

/**
 * Return an array of current mpx import accounts, for use in a select element.
 *
 * @return array
 */
function media_theplatform_mpx_get_account_options() {
  return drupal_map_assoc(db_query("SELECT import_account FROM {mpx_accounts}")->fetchCol());
}

/**
 * Implements hook_modules_installed().
 */
function media_theplatform_mpx_modules_installed($modules) {
  if (in_array('file_admin', $modules)) {
    // When file_admin is installed, ensure that file_managed.published values
    // match the mpx_video.status values. Here we only set values of 0 since
    // the default value for file_managed.published is 1.
    $unpublish_fids = db_query("SELECT fid FROM {mpx_video} WHERE status = 0")->fetchCol();
    db_update('file_managed')
      ->fields(array('published' => 0))
      ->condition('fid', $unpublish_fids)
      ->execute();
  }
}

/**
 * Outputs debug information.
 *
 * This is a copy of debug() that has nicer and more useful output.
 *
 * @param mixed $data
 *   The data to be output.
 * @param string $label
 *   Label to prefix the data.
 * @param bool $print_r
 *   Flag to switch between print_r() and var_export() for data conversion to
 *   string. Set $print_r to TRUE when dealing with a recursive data structure
 *   as var_export() will generate an error.
 */
function media_theplatform_mpx_debug($data, $label = NULL, $print_r = FALSE) {
  static $debugging;

  if (!isset($debugging)) {
    $debugging = variable_get('media_theplatform_mpx_debug', 0);
  }

  if ($debugging) {
    $value = $print_r ? print_r($data, TRUE) : var_export($data, TRUE);

    if (class_exists('Kint') || module_exists('kint')) {
      if (function_exists('kint_require')) {
        kint_require();
      }
      $message_string = trim($label ? "$label => !value" : "!value");
      drupal_set_message(format_string($message_string, array('!value' => @Kint::dump($data))));
    }
    elseif (module_exists('devel')) {
      $message_string = kprint_r($data, TRUE, $label);
      $message_string .= kprint_r(ddebug_backtrace(TRUE, 1), TRUE, 'Backtrace');
      drupal_set_message($message_string);
    }
    else {
      $message_string = trim($label ? "$label => <pre>@value</pre>" : "<pre>@value</pre>");
      drupal_set_message(format_string($message_string, array('@value' => $value)));
    }

    $watchdog_string = trim($label ? "$label => <pre>@value</pre>" : "<pre>@value</pre>");
    watchdog('media_theplatform_mpx', $watchdog_string, array('@value' => $value), WATCHDOG_DEBUG);
  }
}

/**
 * Finds and returns $media_data array key with a pl#$ namespace prefix.
 *
 * @param string $key
 * @param array $media_data
 *
 * @return mixed
 */
function _media_theplatform_mpx_get_pl_key($key, array $media_data) {
  $pl_key = preg_grep('/^pl\d+\$' . preg_quote($key, '/') . '$/', array_keys($media_data));
  return reset($pl_key);
}
