<?php

/**
 * @file
 * Extends File Entities to be revisionable.
 * @Author: Rick Tilley (pcrats33)
 */

/**
 * Implements hook_permission().
 * @return multitype:multitype:The Ambigous <The, string, A, Optional>
 */
function file_entity_revisions_permission() {
  return array(
      'administer file_entity_revisions' => array(
          'title' => t('Administer File Entity Revisions'),
          'description' => t('Configure File Entity Revisions to work with Workflow.'),
      ),
      'moderate file_entity_revisions' => array(
          'title' => t('View Unpublished File Revisions'),
          'description' => t('Moderators will need to be able to view '
              . 'unpublished file revisions.  Currently viewing private files '
              . 'only works on the current revision, this allows them to view '
              . 'other revisions as well.'),
      ),
  );
}

/**
 * Implements hook_file_download().
 * Give certain users access to all files in revisions://
 * @param string $uri
 * @return NULL or array of headers
 */
function file_entity_revisions_file_download($uri) {
  global $user;
  if ($user->uid == 0) {
    // Anonymous users should not be able to view unpublished revisions.
    return -1;
  }
  // Find file and if we have access return headers.
  $headers = NULL;
  $result = db_select('file_managed_revisions', 'r')
              ->fields('r', array('filemime', 'filesize', 'uid'))
              ->condition('r.uri', $uri, '=')
              ->execute()->fetchAssoc();
  if (isset($result) && isset($result['filemime']) && isset($result['filesize'])
   && ($user->uid == $result['uid'] 
   || user_access('moderate file_entity_revisions', $user))) {
    $headers = array(
        'Content-Type' => mime_header_encode($result['filemime']),
        'Content-Length' => $result['filesize'],
        'Cache-Control' => 'private',
    );
  }
  return $headers;
}

/**
 * Callback for URI file access within revisions://
 * Inits the stream, gets headers, and streams the file.
 * @param unknown $uri
 * @return NULL
 */
function _file_entity_revisions_file_access_uri() {
  // Get the URI.
  $args = func_get_args();
  //  $scheme = array_shift($args);
  $scheme = 'revisions';
  $target = implode('/', $args);
  $uri = $scheme . '://' . $target;
  // Now try to serve this file.
  if (file_stream_wrapper_valid_scheme($scheme) && file_exists($uri)) {
    $headers = _file_entity_revisions_file_download_headers($uri);
    if (count($headers)) {
      _file_entity_revisions_file_transfer($uri, $headers);
    }
    // DENY if no headers
    drupal_access_denied();
  }
  else {
    drupal_not_found();
  }
  drupal_exit();
}

/**
 * Implements hook_theme().
 * This is used for the revisions tab, borrowed from workflow, names have been
 * changed. It's used by the template functions that render rows[].
 */
function file_entity_revisions_theme() {
  return array(
      'file_er_table_row' => array(
          'variables' => array(
              'history' => NULL,
              'old_state_name' => NULL,
              'state_name' => NULL,
          ),
      ),
      'file_er_history_current_state' => array(
          'variables' => array(
              'state_name' => NULL,
              'state_system_name' => NULL,
              'sid' => NULL,
          ),
      ),
      'file_er_deleted_state' => array(
          'variables' => array(
              'state_name' => NULL,
              'state_system_name' => NULL,
              'sid' => NULL,
          ),
      ),
  );
}
/**
 * Our config screen for setting workflow values.
 * It is important because we don't know how workflow is setup in
 * a lot of ways.  This tells us the state values and fields needed.
 * @return Ambigous <The, string>
 */
function file_entity_revisions_admin() {
  $form = array();
  
  // Get list of file types.
  $types = db_select('file_type', 't')
           ->fields('t', array('type', 'label'))
           ->execute()->fetchAllAssoc('type');
  // Get list of workflow fields within file types.
  $fields = array();
  foreach ($types as $t => $tnull) {
    $info = field_info_instances('file', $t);
    $myinfo = array();
    foreach ($info as $i => $nfo) {
      $myinfo[$i] = t('@label [@mech]', array('@label' => $nfo['label'], '@mech' => $i));
    }
    $myinfo = array('none' => 'Nothing Selected') + $myinfo;
    $fields[$t] = $myinfo;
  }
  // Get list of all workflow states (key => label).
  $states = db_select('workflow_states', 'w')
            ->fields('w', array('sid', 'state'))
            ->execute()->fetchAllAssoc('sid');
  $statelist = array();
  foreach ($states as $s => $sdat) {
    $statelist[$s] = t('(@num) @label', array('@label' => $sdat->state, '@num' => $s));
  }
  $statelistboxes = $statelist;
  $statelist['none'] = 'Nothing Selected';
  
  // Select box for each file type pointing to a workflow field.
  $form['our_header'] = array(
  	  '#markup' => t('<h2>File Entity Revisions needs to understand how Workflow is set up.</h2>'),
  );
  $form['first_break'] = array(
      '#markup' => '<hr><br>',
  );
  foreach ($fields as $field => $fi) {
    if (count($fi) > 1) {
      $fieldvar = 'file_entity_revision_' . $field;
      $defaults = variable_get($fieldvar, 'none');
      $form[$fieldvar] = array(
          '#type' => 'select',
          '#title' => t($field),
          '#options' => $fi,
          '#default_value' => $defaults,
          '#description' => t('Select the active workflow field.'),
      );
      // Select box for default state when publishing.
      $defaults = variable_get($fieldvar . '_published', 'none');
      $form[$fieldvar . '_published'] = array(
          '#type' => 'select',
          '#title' => t('Publish fallback action'),
          '#options' => $statelist,
          '#default_value' => $defaults,
          '#description' => t('Select the default published state.'),
      );
      // Select box for default state when unpublishing.
      $defaults = variable_get($fieldvar . '_unpublished', 'none');
      $form[$fieldvar . '_unpublished'] = array(
          '#type' => 'select',
          '#title' => t('Unpublish fallback action'),
          '#options' => $statelist,
          '#default_value' => $defaults,
          '#description' => t('Select the default unpublished state.'),
      );
      $form[$fieldvar . '_break'] = array(
      	  '#markup' => '<br><hr><br>',
      );
    }
  }
  // Check boxes for all the valid published states.
  $defaults = variable_get('file_entity_revision_valid_published', array());
  $form['file_entity_revision_valid_published'] = array(
  	  '#type' => 'checkboxes',
      '#options' => $statelistboxes,
      '#default_value' => $defaults,
      '#title' => 'Check all states that are valid published states',
  );
  // Check boxes for all the valid unpublished states.
  $defaults = variable_get('file_entity_revision_valid_unpublished', array());
  $form['file_entity_revision_valid_unpublished'] = array(
  	  '#type' => 'checkboxes',
      '#options' => $statelistboxes,
      '#default_value' => $defaults,
      '#title' => 'Check all states that are valid unpublished states',
  );
  return system_settings_form($form);
}

function file_entity_revisions_admin_validate($form, &$form_state) {
  $a = 4;
  $b = 5000;
}

/**
 * Implements hook_entity_info_alter().
 * This was implemented in the 7.x-1.x-dev original module, and works
 * the magic that is file entity revisions.
 * 
 * Extends the core file entity to be revisionable.
 */
function file_entity_revisions_entity_info_alter(&$entity_info) {
  // Add revision table and revision key.
  $entity_info['file']['revision table'] = 'file_managed_revisions';
  $entity_info['file']['entity keys']['revision'] = 'vid';
  $entity_info['file']['deletion callback'] = 'file_entity_delete';
  $entity_info['file']['revision deletion callback'] = 'file_entity_revision_delete';

  // Drupal fails hard here.
  $entity_info['file']['schema_fields_sql']['revision table'] = drupal_schema_fields_sql($entity_info['file']['revision table']);
}

/**
 * Implements hook_menu().
 */
function file_entity_revisions_menu() {
  $items = array();
  $items['admin/config/workflow/file_entity_revisions'] = array(
      'title' => 'File Entity Revisions',
      'description' => 'Configure File Entity Revision for Workflow',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('file_entity_revisions_admin'),
      'access arguments' => array('administer file_entity_revisions'),
      'type' => MENU_NORMAL_ITEM,
  );
  // Not sure why we have a scheduler route??
  if (module_exists('revision_scheduler')) {
    $items['file/%file/schedule'] = array(
      'title' => 'Schedule',
      'page callback' => 'revision_scheduler_list_page',
      'page arguments' => array('file', 1),
      'access arguments' => array('schedule revisions'),
      'file' => 'revision_scheduler.pages.inc',
      'file path' => drupal_get_path('module', 'revision_scheduler'),
      'type' => MENU_LOCAL_TASK,
    );

    $items['file/%file/schedule/add'] = array(
      'title' => 'Add scheduled revision',
      'page callback' => 'drupal_get_form',
      'page arguments' => array('revision_scheduler_add_form', 'file', 1),
      'access arguments' => array('schedule revisions'),
      'file' => '/revision_scheduler.pages.inc',
      'file path' => drupal_get_path('module', 'revision_scheduler'),
      'type' => MENU_LOCAL_ACTION,
    );
  }

  $items['file/%file/revisions'] = array(
    'title' => 'Revisions Workflow',
    'page callback' => 'file_entity_revisions_overview',
    'page arguments' => array(1),
    'access callback' => '_file_entity_revisions_access',
    'access arguments' => array(1),
    'weight' => 2,
    'type' => MENU_LOCAL_TASK,
    'file' => 'file_entity_revisions.pages.inc',
  );
  $items['file/%file_entity_revision/revisions/%/view'] = array(
    'title' => 'Revisions',
    'load arguments' => array(3),
    'page callback' => 'file_entity_revisions_show',
    'page arguments' => array(1, TRUE),
    'access callback' => '_file_entity_revisions_access',
    'access arguments' => array(1),
  );
  $items['file/%file_entity_revision/revisions/%/revert'] = array(
    'title' => 'Change to current revision',
    'load arguments' => array(3),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('file_entity_revision_revert_confirm', 1),
    'access callback' => '_file_entity_revisions_access',
    'access arguments' => array(1, 'update'),
    'file' => 'file_entity_revisions.pages.inc',
  );
  $items['file/%file_entity_revision/revisions/%/delete'] = array(
    'title' => 'Delete this revision',
    'load arguments' => array(3),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('file_entity_revision_delete_confirm', 1),
    'access callback' => '_file_entity_revisions_access',
    'access arguments' => array(1, 'delete'),
    'file' => 'file_entity_revisions.pages.inc',
  );
  // Used for the revisions:// stream wrapper.
  $items['system/revisions'] = array(
      'title' => 'File download',
      'page callback' => '_file_entity_revisions_file_access_uri',
      'access callback' => TRUE,
      'access arguments' => array('view own files'),
      'type' => MENU_CALLBACK,
  );

  return $items;
}
/**
 * Implements hook_menu_alter().
 * Changes some of the file tab titles.
 * @param unknown $items
 */
function file_entity_revisions_menu_alter(&$items) {
  $items['file/%file/view']['title'] = 'View Current';
  $items['file/%file/edit']['title'] = 'New Draft';
  $items['file/%file/delete']['title'] = 'Delete File';
}
/**
 * Implements hook_action_info().
 * Adds publish routes for files.
 * Workflow uses triggers which call actions.  This creates the actions you
 * can choose from.
 * @return multitype:
 */
function file_entity_revisions_action_info() {
  $operations = array(
      'file_entity_revision_publish_action' => array(
          'type' => 'file',
          'label' => t('Publish File Entity'),
          'configurable' => FALSE,
          'triggers' => array('any'),
      ),
      'file_entity_revision_unpublish_action' => array(
          'type' => 'file',
          'label' => t('Unpublish File Entity'),
          'configurable' => FALSE,
          'triggers' => array('any'),
      ),
  );
  return $operations;
}
/**
 * Publishes nodes, called by hook_node_operations
 * @param unknown $files
 */
function file_entity_revision_publish_action($arg1, $info, $arg3 = null, $arg4 = null) {
  file_entity_revision_quick_publish($info, 1);
}
/**
 * UN-Publishes nodes, called by hook_node_operations
 * @param unknown $files
 */
function file_entity_revision_unpublish_action($arg1, $info, $arg3 = null, $arg4 = null) {
  file_entity_revision_quick_publish($info, 0);
  // @todo: should we make the current revision a previously published node??
}
/**
 * (un)Publishes nodes, called by hook_node_operations
 * $value = 0 / 1 for Unpublish / Publish. 
 *  * Publish unpublishes all other revisions.
 *  
 * Does this through the DB, no hooks are fired, file_save is not used.
 * 
 * @param unknown $info
 * @param unknown $value
 */
function file_entity_revision_quick_publish($info, $value) {
  if ($info['entity_type'] != 'file') {
    return;
  }
  $file = $info['node'];
  $vid = $file->vid;
  $fid = $file->fid;
  $uri = $file->uri;
  if ($fid && $vid) {
    // Publish value on file_managed, update it.
    $result1 = db_update('file_managed')
    ->fields(array('published' => $value))
    ->condition('fid', $fid, '=')
    ->execute();
    // Mark current revision $value.
    $result2 = db_update('file_managed_revisions')
    ->fields(array('published' => $value))
    ->condition('fid', $fid, '=')
    ->condition('vid', $vid, '=')
    ->execute();
    if ($value == 1) {
      // Update any public links to revisions:// (private).
      $bogeys = db_select('file_managed_revisions', 'r')
                ->fields('r', array('fid', 'vid', 'uri'))
                ->condition('r.fid', $fid, '=')
                ->condition('r.vid', $vid, '<>')
                ->condition('r.published', 1, '=')
                ->execute();
      foreach ($bogeys as $bogs) {
        if (isset($bogs->uri) && isset($bogs->fid) && isset($bogs->vid)) {
          $scheme = file_uri_scheme($bogs->uri);
          if ($scheme) {
            if (strpos($bogs->uri, $scheme) === 0) {
              $newspot = substr_replace($bogs->uri, 'revisions', 0, strlen($scheme));
              $newuri = file_unmanaged_copy($bogs->uri, $newspot, FILE_EXISTS_RENAME);
              if ($newuri) {
                // We moved the file, update the db location.
                db_update('file_managed_revisions')
                ->fields(array('uri' => $newuri))
                ->condition('fid', $bogs->fid, '=')
                ->condition('vid', $bogs->vid, '=')
                ->execute();
              }
            }
          }
        }
      }
      // Mark all other revisions as unpublished.
      $result3 = db_update('file_managed_revisions')
      ->fields(array('published' => 0))
      ->condition('fid', $fid, '=')
      ->condition('vid', $vid, '<>')
      ->execute();
      // Now move our published file to the desired location and update DB.
      $newpath = uploading_tax_paths_file_presave($file);
      if ($newpath) {
        db_update('file_managed')
        ->fields(array('uri' => $newpath))
        ->condition('fid', $fid, '=')
        ->execute();
        db_update('file_managed_revisions')
        ->fields(array('uri' => $newpath))
        ->condition('fid', $fid, '=')
        ->condition('vid', $vid, '=')
        ->execute();
      }
    }
    // Give a message of success if we were able to (un)publish.
    $actionmsg = $value ? 'published' : 'unpublished';
    drupal_set_message(t('File: @uri has been @publish!', 
      array('@uri' => $uri, '@publish' => $actionmsg)));
  }
}

/**
 * Re-implement file_load in order to support loading specific revision.
 * NOTE: We cannot call it file_entity_load because it collides with
 * hook_entity_load.
 *
 * @param $fid
 * @param $vid
 * @param $reset
 * @return bool|stdClass
 */
function _file_entity_load($fid = NULL, $vid = NULL, $reset = FALSE) {
  $fids = (isset($fid) ? array($fid) : array());
  $conditions = (isset($vid) ? array('vid' => $vid) : array());
  $file =  file_load_multiple($fids, $conditions, $reset);
  return $file ? reset($file) : FALSE;
}

/**
 * Implements hook_admin_paths().
 */
function file_entity_revisions_admin_paths() {
  $paths = array(
    'file/*/schedule' => TRUE,
    'file/*/schedule/add' => TRUE,
    'file/*/revisions' => TRUE,
    'file/*/revisions/*/revert' => TRUE,
    'file/*/revisions/*/delete' => TRUE,
  );

  return $paths;
}

/*
 * Implements hook_cron_queue_info().
 */
function file_entity_revisions_cron_queue_info() {
  $queues['file_entity_revisions_create'] = array(
    'worker callback' => 'file_entity_revisions_create',
  );

  return $queues;
}

/**
 * Make sure all File Entity get a Revision.
 *
 * @param $fid
 *   A file ID.
 */
function file_entity_revisions_create($record) {
  _file_save_revision($record);
}

/**
 * Delete file entity revisions.
 */
function file_entity_revision_delete($revision_id, $entity_type) {
  if ($revision = _file_entity_load(NULL, $revision_id)) {
    // Prevent deleting the current revision.
    $file = _file_entity_load($revision->fid);
    if ($revision_id == $file->vid) {
      return FALSE;
    }
   db_delete('file_managed_revisions')->condition('fid', $revision->fid)->condition('vid', $revision->vid)->execute();
   module_invoke_all('file_revision_delete', $revision);
   field_attach_delete_revision('file', $revision);
   file_unmanaged_delete($revision->uri);
   return TRUE;
  }

  return FALSE;
}

/**
 * Implements hook_file_presave();
 * It is important we set the published bit on/off depending on the
 * workflow value.
 * @param unknown $file
 */
function file_entity_revisions_file_presave($file) {
  file_entity_revision_align_workflow_published($file);
}

/**
 * Implements hook_file_insert().
 *
 * @param stdClass $file
 */
function file_entity_revisions_file_insert(stdClass $file) {
  _file_save_revision($file);
}

/**
 * Implements hook_file_file_update().
 *
 * @param stdClass $file
 */
function file_entity_revisions_file_update(stdClass $file) {
  _file_save_revision($file, 'vid');
}

/**
 * Implements hook_file_delete().
 * Deletes file and all revisions.
 *
 * @param stdClass $file
 */
function file_entity_revisions_file_delete(stdClass $file) {
  // Get revision file locations.
  $revisions = db_select('file_managed_revisions', 'r')
                 ->fields('r', array('uri', 'vid'))
                 ->condition('r.fid', $file->fid, '=')
                 ->execute();
  // Delete all information associated with the file.  
  db_delete('file_managed_revisions')->condition('fid', $file->fid)->execute();
  // Delete all the revisions from server.
  foreach ($revisions as $r) {
    if ($r->vid != $file->vid) {
      file_unmanaged_delete($r->uri);
    }
  }
}

/**
 * Helper function for saving file revisions.
 * This is a very important function, and is called by hook_file_update
 * or hook_file_insert immediately after the file_managed record is saved.
 * 
 * Creates a new revision or updates current revision.  Saves record in
 * file_managed_revisions
 * 
 * @param stdClass $file
 * @param null $update
 */
function _file_save_revision(stdClass $file, $update = NULL) {
  // @todo: check to see if file is in temporary:// scheme, don't unset vid.
  if (isset($update) && isset($file->vid) && empty($file->new_revision)) {
    drupal_write_record('file_managed_revisions', $file, $update);
  }
  else {
    // If this is a new revision for a $file that already has a vid we're going
    // reset that.
    unset($file->vid);
    drupal_write_record('file_managed_revisions', $file);
  }

  // Make sure to always update the VID on the file_manage_table.
  // TODO: Only do this when a new revision is set to "Default".
  _file_save_revision_vid($file);
}

/**
 * Helper function sets published bit to value of workflow status.
 * This is called in hook_file_presave().
 * @param stdClass $file
 */
function file_entity_revision_align_workflow_published(stdClass $file) {
  if (!isset($file->type)) {
    return;
  }
  $workflowfield = 'file_entity_revision_' . $file->type;
  $workflow = variable_get($workflowfield);
  if (isset($workflow) && isset($file->{$workflow})) {
    // Ensure published value and workflow state sync up, Absolutely!!
    $workflowval =& $file->{$workflow}['und'][0]['workflow']['workflow_sid'];
    $ispublished = (int) $file->published;
    _file_entity_revisions_flip_invalid('pubtoflow', $ispublished, $workflowval, $workflowfield);
  }
}

/**
 * This updates the file_managed vid to the current revision.
 * @param stdClass $file
 */
function _file_save_revision_vid(stdClass $file) {
  db_update('file_managed')->fields(array('vid' => $file->vid))->condition('fid', $file->fid)->execute();
}
/**
 * Implements hook_form_alter().
 *  -- Unfortunately workflow forms all have different unique IDs, so we use this hook.
 * Add a validation function to all workflow forms that sets the published bit
 * to match the workflow select value.
 * Otherwise the workflow value would be reset to the published value on 
 * hook_file_presave.
 * 
 * @param unknown $form
 * @param unknown $form_state
 * @param unknown $form_id
 */
function file_entity_revisions_form_alter(&$form, &$form_state, $form_id) {
  if (!(strpos($form_id, 'workflow_transition_form_file') === false)) {
    $form['#validate'][] = 'file_entity_revisions_workflow_transition_sync';
  }
}

/**
 * Validation function syncs published value to workflow value when you submit
 * any workflow transition widget.
 * 
 * @param unknown $form
 * @param unknown $form_state
 */
function file_entity_revisions_workflow_transition_sync($form, &$form_state) {
  // Grab ( &By-Reference!) Published value.
  $entitystate =& $form_state['values']['workflow_entity']->published;
  // Get workflow field name.
  $workflowfield = 'file_entity_revision_' . $form_state['values']['workflow_entity']->type;
  // Get workflow state value.
  $workflowstate = $form_state['values']['workflow_sid'];
  if (isset($workflowstate) && isset($entitystate)) {
    // Check to see if we need to change the published value of the file.
    _file_entity_revisions_flip_invalid('flowtopub', $entitystate, $workflowstate, $workflowfield);
  }
}
/**
 * Implements hook_form_FORMID_alter().
 * the form: file_entity_add_upload
 * is multistep, this applies to all steps.
 * Makes uploading a file always be unpublished to start.
 * Removes the revisions:// scheme from a list of optional schemes, and adds
 * a submit function that saves the chosen revision in permascheme DB field.
 * 
 * This is the only time public/private is selected with the way the module
 * is curently working.
 * 
 * @param unknown $form
 * @param unknown $form_state
 */
function file_entity_revisions_form_file_entity_add_upload_alter(&$form, &$form_state) {
  if (isset($form['options']['published'])) {
    $form['options']['published']['#default_value'] = 0;
    $form['options']['published']['#access'] = false;
  }
  if (isset($form['scheme']) && isset($form['scheme']['#options'])) {
    // Add submit function to save permascheme value.
    $form['#submit'][] = 'file_entity_revisions_remember_filescheme';
    if (isset($form['scheme']['#options']['revisions'])) {
      // Remove Revisions as an option for permascheme.
      unset($form['scheme']['#options']['revisions']);
    }
  }
}
/**
 * Submit function for saving file scheme into permascheme.
 * @param unknown $form
 * @param unknown $form_state
 */
function file_entity_revisions_remember_filescheme($form, &$form_state) {
  if (isset($form_state['values']['scheme']) && isset($form_state['storage']['upload']) && $form_state['values']['scheme'] != 'revisions') {
    db_update('file_managed')
      ->fields(array('permascheme' => $form_state['values']['scheme']))
      ->condition('fid', $form_state['storage']['upload'], '=')
      ->execute();
  }
}

/**
 * Implements hook_form_FORM_ID_alter() 
 * the form: file_entity_edit.
 * 
 * A lot of this was implemented in the 7.x-1.x-dev original module, and handles
 * setting entity variables and submit functions:
 * new_revision  // 0 or 1, signifying create a new revision, default should be 1
 * current_revision   // vid of the current file.
 * the main submit function   // file_entity_revisions_file_entity_form_submit
 * persist file revision   // new drafts don't become current revisions if the
 *                         // previous revision was published.
 *                         
 * And some new things:
 * Sets workflow value to new draft.
 * Sets unpublished by default, since this is a new revision.
 * Greys out new revision check box.
 * Removes delete button from this page.
 * Greys out the file schema since new drafts automatically go to revisions://
 * 
 */
function file_entity_revisions_form_file_entity_edit_alter(&$form, &$form_state) {
  if (isset($form['options'])) {
    // Load config.
    $file_options = variable_get('file_admin_file_options_' . $form['#bundle'], array('new_revision' => 'new_revision'));

    // Add new revision checkbox.
    $form['options']['new_revision'] = array(
      '#type' => 'checkbox',
      '#title' => t('Create new revision'),
      '#default_value' => ($file_options['new_revision'] === 'new_revision'),
    );
  }

  // Add our submit handler to the beginning so that it happens before any others.
  array_unshift($form['actions']['submit']['#submit'], 'file_entity_revisions_file_entity_form_submit');

  // Add a handler to persist the vid of the file in file_managed after a new file revision is uploaded.
  $form['actions']['submit']['#submit'][] = 'file_entity_revisions_persist_file_revision';
  // Add handler to ensure workflow field syncs with published value on submit
  $form['actions']['submit']['#validate'][] = 'file_entity_revisions_sync_publish_boxes';
  // Default workflow and published to draft.
//  $workflowfield = 'file_entity_revision_' . $form_state['file']->type;
  $workflowfield = _file_entity_revisions_get_workflowfield($form_state['file']->type);
  $workflow = variable_get($workflowfield, NULL);
  $unpubs = _file_entity_revisions_settings('pubtoflow', $workflowfield);
  if (isset($workflow) && isset($form[$workflow]) && isset($unpubs[0])) {
    $form[$workflow][LANGUAGE_NONE][0]['workflow']['workflow_sid']['#default_value'] = $unpubs[0];
  }
  if (isset($form['options']['published'])) {
    $form['options']['published']['#default_value'] = 0;
    $form['options']['published']['#access'] = false;
    $form['options']['new_revision']['#disabled'] = true;
  }
  $form['actions']['delete']['#access'] = false;
  if (!empty($form['preview']['#file'])) {
    $form['current_revision'] = array(
      '#type' => 'hidden',
      '#value' => $form['preview']['#file']->vid
    );
  }
  /* Don't let user change scheme on file, file_entity doesn't prepare the
     directory if the schema has changed.
   */
  if (isset($form['destination']['scheme'])) {
    $form['destination']['scheme']['#disabled'] = true;
  }  
}

/**
 * Validation hook for form_file_entity_edit
 * Ensures that published value and workflow state sync up when you submit the file form.
 * Should you decide to put workflow fields on the file edit form, this will
 * ensure that the published value syncs with the workflow value you select.
 * @param unknown $form
 * @param unknown $form_state
 */
function file_entity_revisions_sync_publish_boxes(&$form, &$form_state) {
  $workflowfield = 'file_entity_revision_' . $form_state['file']->type;
  $workflow = variable_get($workflowfield, NULL);
  if (isset($workflow)) {
    $ispublished =& $form_state['values']['published'];
    if (isset($form_state['values'][$workflow][LANGUAGE_NONE][0])) {
      $workflowval = $form_state['values'][$workflow][LANGUAGE_NONE][0]['workflow']['workflow_sid'];
      _file_entity_revisions_flip_invalid('flowtopub', $ispublished, $workflowval, $workflowfield);
    }
    else {
      $ispublished = 0;
    }
  }
}
/**
 * Add a handler to persist the current file revision within file_managed.
 *
 * Keep published current revision current even after new draft is uploaded.
 * Calls file_save on the published revision which fires a bunch of hooks.
 */
function file_entity_revisions_persist_file_revision(&$form, &$form_state) {
  if($form_state['values']['new_revision'] 
     && !empty($form_state['values']['current_revision']) 
     && !$form_state['values']['published'] 
     && !$form_state['storage']['new_current']) {
    $file = $form_state['storage']['new_current_original'];
    if ($file) {
      // Unset new revision so we don't create a new revision of the original.
      unset($file->new_revision);
      // Give its stashed URI back to it.
      $newuri = db_select('file_managed_revisions', 'r')
                  ->fields('r', array('uri'))
                  ->condition('r.vid', $file->vid, '=')
                  ->condition('r.fid', $file->fid, '=')
                  ->execute()->fetchField();
      if ($newuri) {
        $file->uri = $newuri;
        $file->current_revision = $file->vid;
        // Resave the current draft to update the file_managed table and entity field tables.
        file_save($file);
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 * the form: file_entity_file_type_form
 * 
 * Adds a new option
 */
function file_entity_revisions_form_file_entity_file_type_form_alter(&$form, &$form_state) {
  $form['workflow']['file_options']['#options']['new_revision'] = t('Create new revision');
}

/**
 * Submit handler for the file entity form to make sure we properly revision files.
 * Sets some entity variables such as new_current, new_current_original
 * This is not called the first time you upload and save a file.
 * Main case: replacing a current file
 *   Moves files that are currently in temporary:// file scheme into previous
 *   file's scheme.  Renames the file instead of replacing, so file names
 *   change a lot at this point.
 * Case two: saving an existing file without replacing it
 *   Renames over itself so there is two copies, one has an _0 type appendage.
 *   This makes the new revision have a unique copy of the same file.
 *   
 * Uploading Tax Paths acts later when the form calls file_save on it, fixing 
 * its location.
 * 
 * @param unknown $form
 * @param unknown $form_state
 */
function file_entity_revisions_file_entity_form_submit($form, &$form_state) {
  // No need to do anything if this isn't a new revision.
  if (empty($form_state['values']['new_revision'])) {
    return;
  }
  $file = $form_state['file'];
  $form_state['storage']['new_current'] = $file->published ^ 1;
  $form_state['storage']['new_current_original'] = clone $file;  
  // Check if a replacement file has been uploaded.
  if (!empty($form_state['values']['replace_upload'])) {
    $replacement = $form_state['values']['replace_upload'];
    if (strtoupper(file_uri_scheme($replacement->uri)) == 'TEMPORARY') {
      // Move file from temp to permanent home.
      $filename = file_uri_scheme($file->uri) . '://' . file_uri_target($replacement->uri);
      if ($filename = file_unmanaged_copy($replacement->uri, $filename, FILE_EXISTS_RENAME)) {
        $file->uri = $filename;
        file_delete($replacement);
      }
      // Prevent file_entity from copying it a second time.
      unset($form_state['values']['replace_upload']);
    } 
  }
  else {
    // If a replacement hasn't been uploaded, make a copy specifically for our new revision
    // so that a later attempt to replace it does not overwrite another revision's file.
    $file->uri = file_unmanaged_copy($file->uri, $file->uri, FILE_EXISTS_RENAME);
  }
}

/**
 * Access callback: Checks file revision access.
 *
 * @param object $file
 *   The file to check.
 * @param string $op
 *   (optional) The specific operation being checked. Defaults to 'view.'
 * @param object $account
 *   (optional) A user object representing the user for whom the operation is
 *   to be performed. Determines access for a user other than the current user.
 *
 * @return bool
 *   TRUE if the operation may be performed, FALSE otherwise.
 *
 * @see file_entity_revisions_menu()
 */
function _file_entity_revisions_access($file, $op = 'view', $account = NULL) {
  $access = &drupal_static(__FUNCTION__, array());

  $map = array(
    'view' => 'view revisions',
    'update' => 'revert revisions',
    'delete' => 'delete revisions',
  );

  if (!$file || !isset($map[$op])) {
    // If there was no file to check against, or the $op was not one of the
    // supported ones, we return access denied.
    return FALSE;
  }

  if (!isset($account)) {
    $account = $GLOBALS['user'];
  }

  // Statically cache access by revision ID, user account ID, and operation.
  $cid = $file->vid . ':' . $account->uid . ':' . $op;

  if (!isset($access[$cid])) {
    // Perform basic permission checks first.
    if (!user_access($map[$op], $account) && !user_access('administer files', $account)) {
      return $access[$cid] = FALSE;
    }

    $file_current_revision = file_load($file->fid);
    $is_current_revision = $file_current_revision->vid == $file->vid;

    // There should be at least two revisions. If the vid of the given file and
    // the vid of the current revision differ, then we already have two
    // different revisions so there is no need for a separate database check.
    // Also, if you try to revert to or delete the current revision, that's not
    // good.
    /*
    if ($is_current_revision && (db_query('SELECT COUNT(vid) FROM {file_managed_revisions} WHERE fid = :fid', array(':fid' => $file->fid))->fetchField() == 1 || $op == 'update' || $op == 'delete')) {
      $access[$cid] = FALSE;
    }
    else
    */
    if (user_access('administer files', $account)) {
      $access[$cid] = TRUE;
    }
    else {
      // First check the access to the current revision and finally, if the file
      // passed in is not the current revision then access to that, too.
      $access[$cid] = file_entity_access($op, $file_current_revision, $account) && ($is_current_revision || file_entity_access($op, $file, $account));
    }
  }

  return $access[$cid];
}

/**
 * Loads a file object from the database.
 *
 * @param int $fid
 *   The file ID.
 * @param int $vid
 *   The revision ID.
 * @param bool $reset
 *   Whether to reset the file_load_multiple cache.
 *
 * @return object
 *   A fully-populated file object, or FALSE if the file is not found.
 */
function file_entity_revision_load($fid = NULL, $vid = NULL, $reset = FALSE) {
  $fids = (isset($fid) ? array($fid) : array());
  $conditions = (isset($vid) ? array('vid' => $vid) : array());
  $file = file_load_multiple($fids, $conditions, $reset);
  return $file ? reset($file) : FALSE;
}

/**
 * Returns a list of all the existing revision numbers.
 *
 * @param object $file
 *   The file entity.
 *
 * @return array
 *   An associative array keyed by file revision number.
 */
function file_entity_revisions_list($file) {
  $revisions = array();
  
  // Get domain_access field name if applicable
  $current_bundle_instances = field_info_instances('file', $file->type);
  $domain_field = null;
  foreach ($current_bundle_instances as $field => $fdata) {
     if (isset($fdata['widget']) && isset($fdata['widget']['module'])
         && $fdata['widget']['module'] == 'domain_entity') {
       $domain_field = $field;
       break;
     }
  }
  $select = db_select('file_managed_revisions', 'r');
  $select->innerJoin('users', 'u', 'u.uid = r.uid');
  $select->leftJoin('file_managed', 'f', 'f.vid = r.vid');
  $select->fields('r', array('vid', 'filename', 'uid', 'timestamp', 'published', 'uri'))
         ->fields('u', array('name'));
  $select->addField('f', 'vid', 'current_vid');
  $select->condition('r.fid', $file->fid, '=')
         ->orderBy('r.vid', 'DESC');
  $result = $select->execute();
  /*
  $result = db_query('SELECT r.vid, r.filename, r.uid, f.vid AS current_vid, r.timestamp, u.name, r.published, r.uri 
  FROM {file_managed_revisions} r 
  LEFT JOIN {file_managed} f ON f.vid = r.vid 
  INNER JOIN {users} u ON u.uid = r.uid 
  WHERE r.fid = :fid 
  ORDER BY r.vid DESC', 
  array(':fid' => $file->fid));
  */
  foreach ($result as $revision) {
    $revisions[$revision->vid] = $revision;
    $revisions[$revision->vid]->domains = array();
  }
  // Add domain access info
  $dominfo = null;
  if (isset($domain_field)) {
    $domaindatafield = $domain_field . '_domain_id';
    $dominfo = db_select('field_revision_' . $domain_field, 'd')
        ->fields('d', array('revision_id', $domaindatafield))
        ->condition('d.entity_id', $file->fid, '=')
        ->execute();
    foreach ($dominfo as $dom) {
      if (isset($dom->{$domaindatafield}) && isset($dom->revision_id)) {
        $revisions[$dom->revision_id]->domains[] = $dom->{$domaindatafield};
      }
    }
  }
  
  return $revisions;
}

/**
 * Generates an array which displays a file detail page.
 *
 * @param object $file
 *   A file object.
 * @param string|FALSE $message
 *   A flag which sets a page title relevant to the revision being viewed.
 *
 * @return array
 *   A $page element suitable for use by drupal_render().
 */
function file_entity_revisions_show($file, $message = FALSE) {
  if ($message) {
    drupal_set_title(t('Revision of %filename from %date', array('%filename' => $file->filename, '%date' => format_date($file->timestamp))), PASS_THROUGH);
  }

  module_load_include('inc', 'file_entity', 'file_entity.file_api');

  // For markup consistency with other pages, use file_view_multiple() rather
  // than file_view().
  $files = file_view_multiple(array($file->fid => $file), 'full');

  return $files;
}

/**
 * Implements hook_module_implements_alter(&$implementations, $hook).
 * Reorder file_entity to be called after file_entity_revisions hooks.
 * This fixes an issue with revision fields being saved with the old vid
 * before a new vid can be assigned.  Basically it puts this module first
 * in the line of hook_file_update calls.  Also hook_file_insert is modified.
 * hook_file_presave is called early to ensure the publish bit/workflow
 * value is matching.
 * @param unknown $implementations
 * @param unknown $hook
 */
function file_entity_revisions_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'file_update' || $hook == 'file_insert' || $hook == 'file_presave') {
    $ourkey = 'file_entity_revisions';
    if (array_key_exists($ourkey, $implementations)) {
      $implementations = array($ourkey => $implementations[$ourkey]) + $implementations;
    }
  }
}
/**
 * Helper function that flips either the publish value or workflow value
 * to match the other.  Uses settings variables.
 * @param string $direction  // this function works two different ways
 * @param int $epub         // entity publish value
 * @param int $wpub        // workflow state value
 * @param string $wfield  // field name of workflow field
 */
function _file_entity_revisions_flip_invalid($direction, &$epub, &$wpub, $wfield) {
  $strpub = ($epub) ? 'validpub' : 'validunpub';
  $publishers = _file_entity_revisions_settings($strpub);
  if (!in_array($wpub, $publishers)) {
    $workflowtrans = _file_entity_revisions_settings($direction, $wfield);
    switch ($direction) {
    	case 'pubtoflow':
    	  if (isset($workflowtrans[$epub])) {
    	    $wpub = $workflowtrans[$epub];
    	  }
    	  break;
    	case 'flowtopub':
    	  if (isset($workflowtrans[$wpub])) {
    	    $epub = $workflowtrans[$wpub];
    	  }
    	  break;
    }
  }
}
/**
 * Simply generates the correct variable name from file->type.
 * @param unknown $type
 * @return string
 */
function _file_entity_revisions_get_workflowfield($type) {
  return 'file_entity_revision_' . $type;
}
/**
 * Helper function that returns settings variables as needed.
 * These values are set in our config page.
 *
 * $need:
 * pubtoflow: matches published bit to workflow value
 * flowtopub: matches workflow value to published bit
 * validpub: returns all valid published workflow states
 * validunpub: returns all valid unpublished workflow states
 * 
 * @param string $need       // this function works 4 different ways, see above
 * @param string $workflowfield
 * @return array of information
 */
function _file_entity_revisions_settings($need, $workflowfield = null) {
  $ret = array();
  switch ($need) {
  	case 'pubtoflow': if (isset($workflowfield)) {
  	  $ret = array(
  	      '0' => variable_get($workflowfield . '_unpublished', NULL),
  	      '1' => variable_get($workflowfield . '_published', NULL),
  	  );
  	} 
  	break;
  	case 'flowtopub': if (isset($workflowfield)) {
  	  $ret = array(
  	      variable_get($workflowfield . '_unpublished', NULL) => '0',
  	      variable_get($workflowfield . '_published', NULL) => '1',
  	  );
  	} 
  	break;
  	case 'validpub': $valid = variable_get('file_entity_revision_valid_published', NULL);
  	if ($valid) {
  	  foreach ($valid as $vkey => $val) {
  	    if ($val > 0) {
  	      $ret[] = $vkey;
  	    }
  	  }
  	}
  	break;
  	case 'validunpub': $valid = variable_get('file_entity_revision_valid_unpublished', NULL);
  	if ($valid) {
  	  foreach ($valid as $vkey => $val) {
  	    if ($val > 0) {
  	      $ret[] = $vkey;
  	    }
  	  }
  	}
  	break;
  }
  return $ret;
}


/**
 * Returns an array of headers from invoking hook_download
 *
 * Let other modules provide headers and controls access to the file.
 * module_invoke_all() uses array_merge_recursive() which merges header
 * values into a new array. To avoid that and allow modules to override
 * headers instead, use array_merge() to merge the returned arrays.
 *
 * @return
 *   An array of HTTP headers to send along with file.
 */
function _file_entity_revisions_file_download_headers($uri) {
  $headers = array();
  foreach (module_implements('file_download') as $module) {
    $function = $module . '_file_download';
    $result = $function($uri);
    if ($result == -1) {
      // Throw away the headers received so far and exit
      $headers = array();
      break;
    }
    if (isset($result) && is_array($result)) {
      $headers = array_merge($headers, $result);
    }
  }

  return $headers;
}

/**
 * Transfers a dynamic file to the client using HTTP.
 *
 * Pipes a dynamic file through Drupal to the client.
 *
 * @param $uri
 *   String specifying the file URI to transfer.
 * @param $headers
 *   An array of HTTP headers to send along with file.
 */
function _file_entity_revisions_file_transfer($uri, $headers) {
  if (ob_get_level()) {
    ob_end_clean();
  }

  // extract scheme
  $scheme = file_uri_scheme($uri);
  $stream_wrapper = _file_entity_revisions_get_wrappers($scheme);

  // add headers and send file headers
  foreach ($headers as $name => $value) {
    drupal_add_http_header($name, $value);
  }

  // send remaining headers
  drupal_send_headers();

  if ($scheme && file_stream_wrapper_valid_scheme($scheme)) {
    if ($fd = fopen($uri, 'rb')) {
      // Transfer file in 1024 byte chunks to save memory usage.
      while (!feof($fd)) {
        print fread($fd, 1024);
      }
      fclose($fd);
    }
  }
  else {
    drupal_not_found();
  }
  drupal_exit();
}
/**
 * Returns stream wrapper info for a specific scheme
 * 
 * @param unknown $scheme
 * @return NULL
 */
function _file_entity_revisions_get_wrappers($scheme) {
  $wrappers = file_get_stream_wrappers();
  return isset($wrappers[$scheme]) ? $wrappers[$scheme] : NULL;
}
