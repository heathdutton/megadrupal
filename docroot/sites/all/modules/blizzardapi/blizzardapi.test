<?php

/**
 * @file
 * Tests for the Blizzard API module.
 */

abstract class BlizzardApiTestCase extends DrupalWebTestCase {
  /**
   * Initializes the static variable used by blizzardapi_realm_slug() with
   * fake values in order to prevent an actual API call (which would fail
   * since the tests do not use actual authentication keys).
   */
  protected function setRealmStatus() {
    $medivh = array(
      'type' => 'pve',
      'population' => 'medium',
      'queue' => FALSE,
      'wintergrasp' => array(
        'area' => 1,
        'controlling-faction' => 0,
        'status' => 1,
        'next' => 1410527144177
      ),
      'tol-barad' => array(
        'area' => 21,
        'controlling-faction' => 1,
        'status' => 0,
        'next' => 1410534310422
      ),
      'status' => TRUE,
      'name' => 'Medivh',
      'slug' => 'medivh',
      'battlegroup' => 'Ruin',
      'locale' => 'en_US',
      'timezone' => 'America/Los_Angeles',
      'connectedRealms' => array('exodar', 'medivh')
    );
    //$azuregos_ru = array(
    //  'type' => 'pve',
    //  'population' => 'high',
    //  'queue' => FALSE,
    //  'name' => 'Азурегос',
    //  'slug' => 'азурегос',
    //  'battlegroup' => 'Vindication',
    //  'locale' => 'ru_RU',
    //  'timezone' => 'Europe/Paris',
    //  'connectedRealms' => array('азурегос')
    //);
    $realms = &drupal_static('blizzardapi_realm_slug');
    $realms['en-us'] = array($medivh);
  }
}

/**
 * Tests administration pages.
 */
class BlizzardApiAdminTestCase extends DrupalWebTestCase {
  protected $admin;
  
  public static function getInfo() {
    return array(
      'name' => 'API keys and settings',
      'description' => 'Tests administrative pages.',
      'group' => 'Blizzard API'
    );
  }
  
  protected function setUp() {
    parent::setUp('blizzardapi');
    $this->admin = $this->drupalCreateUser(array('administer site configuration'));
  }
  
  /**
   * Test admin pages.
   */
  public function testAdminPage() {
    $path = 'admin/config/services/blizzardapi';
    $this->drupalGet($path);
    $this->assertResponse(403);
    
    $this->drupalLogin($this->admin);
    $edit = array('blizzardapi_public_key' => 'client_id');
    $this->drupalPost($path, $edit, t('Save configuration'));
    $this->assertText('Authentication is not possible without both keys.', 'Detect missing private key.');
    $this->assertNotEqual(variable_get('blizzardapi_public_key', ''), 'client_id', 'Did not update key on validation failure.');
    $edit = array('blizzardapi_private_key' => 'client_secret');
    $this->drupalPost($path, $edit, t('Save configuration'));
    $this->assertText('Authentication is not possible without both keys.', 'Detect missing public key.');
    $this->assertNotEqual(variable_get('blizzardapi_private_key', ''), 'client_secret', 'Did not update key on validation failure.');
    $edit['blizzardapi_public_key'] = 'client_id';
    $this->drupalPost($path, $edit, t('Save configuration'));
    $this->assertText('The configuration options have been saved.', 'Authentication keys passed validation.');
    $this->assertEqual(variable_get('blizzardapi_public_key', ''), 'client_id', 'Successfully saved public key.');
    $this->assertEqual(variable_get('blizzardapi_private_key', ''), 'client_secret', 'Successfully saved private key.');
    $edit = array('blizzardapi_public_key' => 'updated_id');
    $this->drupalPost($path, $edit, t('Save configuration'));
    $this->assertText('The configuration options have been saved.', 'Updated public key passed validation.');
    $this->assertEqual(variable_get('blizzardapi_public_key', ''), 'updated_id', 'Successfully updated public key.');
    $this->assertEqual(variable_get('blizzardapi_private_key', ''), 'client_secret', 'Correctly replaced non-displayed private key.');
  }
}

/**
 * Tests auction file functions.
 */
class BlizzardApiAuctionFilesTestCase extends BlizzardApiTestCase {
  public static function getInfo() {
    return array(
      'name' => 'Auction file functions',
      'description' => 'Tests downloading of auction files and local file management functions.',
      'group' => 'Blizzard API',
    );
  }
  
  protected function setUp() {
    parent::setUp('blizzardapi', 'blizzardapi_test');
    variable_set('blizzardapi_public_key', 'public');
    variable_set('blizzardapi_private_key', 'private');
    $this->setRealmStatus();
  }
  
  /**
   * Returns a sample of the data in an auctions.json file.
   */
  protected function getAuctionData() {
    $realm = new stdClass();
    $realm->name = 'Medivh';
    $realm->slug = 'medivh';
    $item = new stdClass();
    $item->auc = 532103679;
    $item->item = 98873;
    $item->owner = 'Jaina';
    $item->ownerRealm = 'Medivh';
    $item->bid = 6499995;
    $item->buyout = 6499995;
    $item->quantity = 1;
    $item->timeLeft = 'LONG';
    $item->rand = 0;
    $item->seed = 1884396288;
    $pet = new stdClass();
    $pet->auc = 533424819;
    $pet->item = 82800;
    $pet->owner = 'Thrall';
    $pet->ownerRealm = 'Exodar';
    $pet->bid = 20157443;
    $pet->buyout = 22057443;
    $pet->quantity = 1;
    $pet->timeLeft = 'VERY_LONG';
    $pet->rand = 0;
    $pet->seed = 95949568;
    $pet->petSpeciesId = 1197;
    $pet->petBreedId = 17;
    $pet->petLevel = 25;
    $pet->petQualityId = 3;
    $auctions = array($item, $pet);
    $data = new stdClass();
    $data->realm = $realm;
    $data->alliance = $auctions;
    $data->horde = $auctions;
    $data->neutral = $auctions;
    return $data;
  }
  
  /**
   * Tests auction file functions.
   */
  public function testAuctionFiles() {
    $auction = new BlizzardApiWowAuctionTest('medivh');
    $data = json_encode($this->getAuctionData());
    
    $path = file_default_scheme() . '://' . $this->randomName();
    $this->assertTrue(drupal_mkdir($path), 'Directory for temporary files is writable.');
    
    file_put_contents($path . '/1410479203000.json', $data);
    file_put_contents($path . '/20140911234643.json', $data);  // yyyymmddhhmmss.json
    file_put_contents($path . '/dump-001.json', $data);
    $files = $auction->getAuctionFiles($path, 'name');
    $this->assert(count($files) == 1 && isset($files['1410479203000']), 'Default pattern only matches correct file.');
    $files = $auction->getAuctionFiles($path, 'name', '/^dump-\d+\.json$/');
    $this->assert(count($files) == 1 && isset($files['dump-001']), 'Custom pattern only matches correct file.');
    $files = $auction->getAuctionFiles($path, 'filename');
    $this->assert(isset($files['1410479203000.json']), 'Array keys set to correct file property.');
    
    $auction->clearAuctionFiles($path);
    $this->assertFalse(file_exists($path . '/1410479203000.json'), 'Auction file was deleted.');
    $this->assert(file_exists($path . '/20140911234643.json') && file_exists($path . '/dump-001.json'), 'Auction files not matching pattern were not deleted.');
    
    file_unmanaged_delete_recursive($path);
    
    // SSL-enabled test sites fail when drupal_http_request() is called without a valid certificate.
    $context = stream_context_create(array('ssl' => array('allow_self_signed' => TRUE)));
    $auction->sendRequest(FALSE, array('context' => $context));
    $destination = $auction->prepareDefaultPath();
    $this->assert($destination !== FALSE, 'Default destination path created successfully.');
    
    // Create a sample file to download.
    $source_dir = file_default_scheme() . '://auction-data';
    drupal_mkdir($source_dir);
    file_put_contents($source_dir . '/auctions.json', $data);
    $this->assert(file_exists($source_dir . '/auctions.json'), 'Sample file created successfully.');
    // Test download to another location.
    $file = $auction->downloadAuctionFile($destination, FALSE, FILE_EXISTS_REPLACE, array('context' => $context));
    $this->assertEqual($file, $destination, 'Sane path for downloaded file returned.');
    $this->assertTrue(file_exists($destination), 'Downloaded auction file exists.');
    file_unmanaged_delete($file);
    
    file_unmanaged_delete_recursive($source_dir);
  }
}

/**
 * Tests creation of API requests and error handling.
 */
class BlizzardApiRequestTestCase extends BlizzardApiTestCase {
  public static function getInfo() {
    return array(
      'name' => 'API requests',
      'description' => 'Checks API request formation and error handling.',
      'group' => 'Blizzard API',
    );
  }
  
  protected function setUp() {
    parent::setUp('blizzardapi', 'blizzardapi_test');
  }
  
  public function testRequestFormation() {
    $auction = new BlizzardApiWowAuctionTest('executus', array('region' => 'eu', 'language' => 'fr'));
    $this->assertEqual($auction->getRegion(), 'eu', 'Valid region set.');
    $this->assertEqual($auction->getLanguage(), 'fr', 'Valid language set.');
    $auction->setLocale('xx', 'en');
    $this->assertEqual($auction->getRegion(), 'us', 'Invalid region set to default.');
    $auction->setLocale('us', 'ru');
    $this->assertEqual($auction->getLanguage(), 'en', 'Invalid language set to default.');
    
    $url = '';
    try {
      $url = $auction->getUrl();
      $this->fail('Invalid URL generated, missing key not caught.');
    }
    catch (Exception $e) {
      $this->assertTrue(empty($url), 'Correctly failed to generate URL without public key.');
    }
    
    variable_set('blizzardapi_public_key', 'client_id');
    $url = $auction->getUrl();
    $this->assert(strpos($url, 'executus') !== FALSE, 'Placeholder added and replaced.');
    $url = $auction->setRealm('medivh')->getUrl();
    $this->assert(strpos($url, 'medivh') !== FALSE, 'Updated existing placeholder.');
    
    $url = $auction->setLocale('us', 'es')->getUrl();
    $this->assert(strpos($url, 'es_MX') !== FALSE, 'Custom locale parameter is present.');
    $this->assert(strpos($url, 'client_id') !== FALSE, 'URL contains public key.');
  }
  
  public function testErrorResponses() {
    variable_set('blizzardapi_public_key', 'client_id');
    $auction = new BlizzardApiWowAuctionTest('medivh');
    $context = stream_context_create(array('ssl' => array('allow_self_signed' => TRUE)));
    
    // First make sure that a valid request does not result in an exception.
    try {
      $data = $auction->sendRequest(FALSE, array('context' => $context))->getData();
      $this->assert(isset($data['lastModified']) && $data['lastModified'] == 1410479203000, 'Valid request did not throw exception.');
    }
    catch (Exception $e) {
      $this->fail('Exception thrown when making valid request.');
    }
    
    $auction->setRealm('notfound');
    try {
      $auction->sendRequest(FALSE, array('context' => $context));
      $this->fail('Invalid realm response failed to throw required exception.');
    }
    catch (BlizzardApiNotFoundException $e) {
      $data = $auction->getData();
      $this->assertEqual($data['reason'], 'Realm not found.', '404 (Not Found).');
    }
    
    $auction->setRealm('forbidden');
    try {
      $auction->sendRequest(FALSE, array('context' => $context));
      $this->fail('Access denied response failed to throw required exception.');
    }
    catch (BlizzardApiAuthenticationException $e) {
      $data = $auction->getData();
      $this->assertEqual($data['detail'], 'Account Inactive', '403 (Invalid Application).');
    }
    
    $auction->setRealm('ratelimit');
    try {
      $auction->sendRequest(FALSE, array('context' => $context));
      $this->fail('Rate limit response failed to throw required exception.');
    }
    catch (BlizzardApiTooManyRequestsException $e) {
      $data = $auction->getData();
      $this->assertEqual($data['detail'], 'Account Over Rate Limit', '403 (Rate Limit).');
    }
    
    $auction->setRealm('nodata');
    try {
      $auction->sendRequest(FALSE, array('context' => $context));
      $this->fail('No data response failed to throw required exception.');
    }
    catch (BlizzardApiException $e) {
      $this->assertEqual($e->getMessage(), 'A valid API request was made, but the response did not include data', 'Throw exception when data is empty.');
    }
  }
}

/**
 * These tests can not access the database nor files.
 */
class BlizzardApiUnitTest extends DrupalUnitTestCase {
  
}
