<?php

/**
 * @file
 * Provides access to the Blizzard Community Platform API.
 *
 * Additional information for developers:
 * - @link https://dev.battle.net/policy Third-Party API Usage Policy @endlink
 * - @link https://dev.battle.net/io-docs Interactive API reference @endlink
 */

/**
 * Implements hook_help().
 */
function blizzardapi_help($path, $arg) {
  switch ($path) {
    case 'admin/config/services/blizzardapi':
      return '<p>' . t('In order to access Battle.net APIs, you must <a href="@mashery-signup">create a Mashery account</a>. ' .
        'You do not need to provide a callback URL unless this site is also using a Battle.net login module. ' .
        'After registration, enter the generated key and secret into the fields below.',
        array('@mashery-signup' => 'https://dev.battle.net/member/register')) . '</p>' .
        '<p>' . t('If you would like to view your request limits and current usage, you may do so by selecting %report-label from your <a href="@mashery-profile">Mashery profile</a>.',
        array('%report-label' => 'View Report', '@mashery-profile' => 'https://dev.battle.net/apps/mykeys')) . '</p>';
  }
}

/**
 * Implements hook_menu().
 */
function blizzardapi_menu() {
  $items['admin/config/services/blizzardapi'] = array(
    'title' => 'Blizzard API',
    'description' => 'Configure Battle.net API authentication.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('blizzardapi_settings'),
    'access arguments' => array('administer site configuration')
  );
  
  $items['admin/config/services/blizzardapi/settings'] = array(
    'title' => 'Settings',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10
  );
  
  return $items;
}

/**
 * Implements hook_flush_caches().
 */
function blizzardapi_flush_caches() {
  return array('cache_blizzardapi');
}

/**
 * Form builder; Configure API settings.
 */
function blizzardapi_settings() {
  $form['authentication'] = array(
    '#type' => 'fieldset',
    '#title' => t('API Authentication'),
    '#collapsible' => FALSE
  );
  
  $form['authentication']['blizzardapi_public_key'] = array(
    '#type' => 'textfield',
    '#title' => t('Public key'),
    '#default_value' => variable_get('blizzardapi_public_key', '')
  );
  
  $form['authentication']['blizzardapi_private_key'] = array(
    '#type' => 'textfield',
    '#title' => t('Secret key'),
    '#description' => t('For additional security, this private key is never displayed.'),
    '#attributes' => array('autocomplete' => 'off'),  // Prevent browsers from remembering data entered in this field.
    '#default_value' => ''
  );
  
  return system_settings_form($form);
}

/**
 * Validates the submitted API settings form.
 */
function blizzardapi_settings_validate($form, &$form_state) {
  $values = $form_state['values'];
  
  // Missing public key.
  if (empty($values['blizzardapi_public_key']) && !empty($values['blizzardapi_private_key'])) {
    form_set_error('blizzardapi_public_key', t('Authentication is not possible without both keys.'));
  }
  
  // Missing private key.
  if (!empty($values['blizzardapi_public_key']) && empty($values['blizzardapi_private_key'])) {
    $private_key = variable_get('blizzardapi_private_key', '');
    
    // If a private key is already in storage then the field has intentionally
    // been left out and must be repopulated so that the submit handler does
    // not save an empty value.
    if (empty($private_key)) {
      form_set_error('blizzardapi_private_key', t('Authentication is not possible without both keys.'));
    }
    else {
      form_set_value($form['authentication']['blizzardapi_private_key'], $private_key, $form_state);
    }
  }
}

/**
 * Determines if both authentication keys have been set.
 *
 * This is a helper function for third-party modules.
 */
function blizzardapi_check_authentication() {
  $public_key = variable_get('blizzardapi_public_key', '');
  $private_key = variable_get('blizzardapi_private_key', '');
  if (!empty($public_key) && !empty($private_key) && extension_loaded('openssl')) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Performs an HTTP request using drupal_http_request(), but adds a header to
 * request compressed data if the PHP installation supports it.
 *
 * @return object
 *   Adds the following property to the response object:
 *   - data_decompressed: A string containing the decoded response body that
 *     was retrieved.
 */
function blizzardapi_http_request($url, $options = array()) {
  if (extension_loaded('zlib')) {
    $options += array('headers' => array('Accept-Encoding' => 'gzip'));
  }
  
  $response = drupal_http_request($url, $options);
  $encoding = isset($response->headers['content-encoding']) ? $response->headers['content-encoding'] : '';
  if (!empty($response->data) && $encoding == 'gzip') {
    $response->data_decompressed = gzinflate(substr($response->data, 10, -8));
  }
  
  return $response;
}

/**
 * Requests compressed data (if possible) using drupal_http_request(), then
 * decompresses it and saves the data to a local file.
 *
 * @see system_retrieve_file()
 */
function blizzardapi_retrieve_file($url, $destination = NULL, $managed = FALSE, $replace = FILE_EXISTS_RENAME, $options = array()) {
  $parsed_url = parse_url($url);
  if (!isset($destination)) {
    $path = file_build_uri(drupal_basename($parsed_url['path']));
  }
  else {
    if (is_dir(drupal_realpath($destination))) {
      $path = str_replace('///', '//', "$destination/") . drupal_basename($parsed_url['path']);
    }
    else {
      $path = $destination;
    }
  }
  
  // Make the request, preferably using compression.
  $result = blizzardapi_http_request($url, $options);
  if ($result->code != 200) {
    watchdog('blizzardapi', 'HTTP error @code occured when trying to fetch @remote.',
      array('@code' => $result->code, '@remote' => $url), WATCHDOG_ERROR);
    return FALSE;
  }
  
  // Don't save compressed data because:
  // - It may not always be available and there is no way to let the caller know.
  // - This function should save files the same way system_retrieve_file() does.
  //   It is only meant to save bandwidth.
  // - Disk space is cheap and decompressing again later is a hassle.
  $data = isset($result->data_decompressed) ? $result->data_decompressed : $result->data;
  
  $file = $managed ? file_save_data($data, $path, $replace) : file_unmanaged_save_data($data, $path, $replace);
  if ($file == FALSE) {
    watchdog('blizzardapi', '@remote could not be saved to @path.',
      array('@remote' => $url, '@path' => $path), WATCHDOG_ERROR);
  }
  
  return $file;
}

/**
 * Find the english language slug for the specified realm.
 *
 * @param string $realm
 *   A realm name or (non-english) slug.
 * @param array $options
 *   (optional) An array with additional options to use when finding realm
 *   information. Any combination of the following keys are supported:
 *   - region: The Battle.net region to request data from.
 *   - language: The language to request data in.
 * @param bool $prefix_region
 *   If TRUE, prefix the returned slug with the realm's Battle.net region
 *   (ex: 'us-medivh'). Useful for generating unique paths. Defaults to FALSE.
 *
 * @return mixed
 *   The english slug of the selected realm or an empty string if the realm
 *   could not be found. This function will additionally return FALSE if there
 *   was a problem retrieving the full list of realms.
 */
function blizzardapi_realm_slug($realm, $options = array(), $prefix_region = FALSE) {
  $options += array(
    'region' => BlizzardApi::REGION_US,
    'language' => BlizzardApi::LANGUAGE_DEFAULT
  );
  
  // Refresh the realm list every 30 days instead of every 10 minutes.
  $realms = new BlizzardApiWowRealm(array(), $options);
  $realms->setCacheLifetime(2592000)->setCachePrefix('blizzardapi:');
  
  $realm_list = &drupal_static(__FUNCTION__);
  $locale = $realms->getLanguage() . '-' . $realms->getRegion();
  
  // Prevent multiple database hits during a request.
  if (!isset($realm_list[$locale])) {
    try {
      $realm_list[$locale] = $realms->sendRequest()->getData();
    }
    catch (Exception $e) {
      return FALSE;
    }
  }
  
  // @todo Since the realm list is sorted, this search could probably be optimized.
  $slug = '';
  foreach ($realm_list[$locale] as $status) {
    if (strcmp($status['slug'], $realm) == 0 || strcmp($status['name'], $realm) == 0) {
      $slug = $status['slug'];
      break;
    }
  }
  
  // Not found.
  if (empty($slug)) {
    return '';
  }
  
  // "Translate" languages that use extended characters.
  if ($realms->getLanguage() != BlizzardApi::LANGUAGE_ENGLISH) {
    $realms->setLocale($options['region'], BlizzardApi::LANGUAGE_ENGLISH);
    
    try {
      // There is no actual local translation done, we simply take advantage of
      // the fact that Blizzard's API doesn't care what input language we use.
      $data = $realms->setRealms(array($slug))->sendRequest()->getData();
    }
    catch (Exception $e) {
      return FALSE;
    }
    
    // There should only be one.
    if (count($data) != 1) {
      watchdog('blizzardapi', 'Unable to determine the english slug of the %slug realm.',
        array('%slug' => $slug), WATCHDOG_ERROR);
      return '';
    }
    
    $slug = $data[0]['slug'];
  }
  
  $region = $realms->getRegion();
  return $prefix_region ? "$region-$slug" : $slug;
}
