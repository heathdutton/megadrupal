<?php

/**
 * @file
 * File Dropzone for every file or media field element.
 */

/**
 * Implements hook_menu().
 */
function file_dropzone_menu() {
  $items['file_dropzone/ajax'] = array(
    'page callback' => 'file_dropzone_ajax_upload',
    'delivery callback' => 'ajax_deliver',
    'access arguments' => array('access content'),
    'theme callback' => 'ajax_base_page_theme',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_library().
 */
function file_dropzone_library() {
  // Find the library path.
  $library_path = module_exists('libraries') ? libraries_get_path('dropzone') : 'sites/all/libraries/dropzone';

  // Add the dropzone library.
  $libraries['dropzone'] = array(
    'title' => 'Dropzone',
    'website' => 'https://github.com/enyo/dropzone',
    'version' => '4.2.0',
    'js' => array(
      $library_path . '/dropzone.js' => array(
        'group' => 'JS_LIBRARY',
      ),
    ),
    'css' => array(
      $library_path . '/dropzone.css' => array(),
    ),
    'dependencies' => array(),
  );

  $path = drupal_get_path('module', 'file_dropzone');

  $libraries['drupal_dropzone'] = array(
    'title' => 'Drupal Dropzone integration',
    'version' => '1.0.0',
    'js' => array(
      $path . '/js/file_dropzone.js' => array(
        'group' => 'JS_LIBRARY',
      ),
    ),
    'css' => array(
      $path . '/css/file_dropzone.css' => array(),
    ),
    'dependencies' => array(
      array('file_dropzone', 'dropzone'),
    ),
  );

  return $libraries;
}

/**
 * Menu callback; Shared Ajax callback for file uploads and deletions.
 *
 * This rebuilds the form element for a particular field item. As long as the
 * form processing is properly encapsulated in the widget element the form
 * should rebuild correctly using FAPI without the need for additional callbacks
 * or processing.
 */
function file_dropzone_ajax_upload() {
  $form_parents = func_get_args();
  $form_build_id = (string) array_pop($form_parents);

  $lock_name = __FUNCTION__ . '_' . $form_build_id;

  if (empty($_POST['form_build_id']) || $form_build_id != $_POST['form_build_id']) {
    return file_dropzone_error_exit(t('An unrecoverable error occurred. The uploaded file likely exceeded the maximum file size (@size) that this server supports.', array('@size' => format_size(file_upload_max_size()))));
  }

  // Unset HTML IDs to ensure element is correctly returned.
  unset($_POST['ajax_html_ids']);

  // Ensure parallel uploads are handled correctly.
  $retries = 0;
  while (!lock_acquire($lock_name, 30)) {
    $retries++;
    if ($retries > 5) {
      return file_dropzone_error_exit(t('An unrecoverable error occurred. There was a timeout while waiting for the upload lock. Please try again later.'), 'HTTP/1.0 500 Internal server error');
    }

    // Another request got the lock, wait for it to finish.
    lock_wait($lock_name, 60);
  }

  $results = array();

  if (empty($_POST['dropzone_actions'])) {
    $_POST['dropzone_actions'][] = array(
      'type' => 'legacy',
      'fid' => -1,
    );
  }

  // Collect all dropzone actions to be processed during this request. In the
  // most common case (where dropzone is configured to automatically process
  // items as soon as they are added to the queue) the only way to submit
  // multiple actions to the server in the same request is if the user uploads
  // several files at the same time. Since Drupal can process multiple file
  // uploads at once, the code in this function optimizes performance for that
  // case by ensuring they are all handled in the same drupal_process_form()
  // call.
  $dropzone_actions = array();
  $last_action_type = NULL;
  while (!empty($_POST['dropzone_actions'])) {
    $action = array_shift($_POST['dropzone_actions']);
    if (!is_array($action)) {
      $action = (array) json_decode($action);
    }
    if (empty($action)) {
      lock_release($lock_name);
      return file_dropzone_error_exit(t('Error: Found empty action when trying to process files.'));
    }
    if ($action['type'] == 'upload') {
      $action['upload_count'] = 1;
      // Handle the multiple upload case by combining them into one action.
      if ($last_action_type == 'upload') {
        $action = array_pop($dropzone_actions);
        $action['upload_count']++;
      }
    }
    $last_action_type = $action['type'];
    $dropzone_actions[] = $action;
  }

  // Process each action by submitting the form and collecting the results.
  foreach ($dropzone_actions as $action) {
    // Multiple uploads will get special handling throughout this function.
    $is_multiple_upload = $action['type'] == 'upload' && $action['upload_count'] > 1;

    drupal_static_reset('drupal_html_id');

    // Retrieve current form and form state.
    list($form, $form_state, $form_id, $form_build_id, $commands) = ajax_get_form();

    if (!$form) {
      lock_release($lock_name);
      return file_dropzone_error_exit(t('An unrecoverable error occurred. Use of this form has expired. Try reloading the page and submitting again.'));
    }

    // Get the current element and count the number of files.
    $current_element = $form;
    foreach ($form_parents as $parent) {
      $current_element = $current_element[$parent];
    }
    $current_file_count = isset($current_element['#file_upload_delta']) ? $current_element['#file_upload_delta'] : 0;

    // Get information about the current element being processed.
    $field_name = $current_element['#field_name'];
    $langcode = $current_element['#language'];

    // For multiple uploads, add extra fields to the form to handle the extra
    // files that are being uploaded. (Drupal file upload widgets normally only
    // contain one extra form element to allow a single file to be uploaded.)
    if ($is_multiple_upload) {
      for ($i = 1; $i < $action['upload_count']; $i++) {
        $form[$field_name][$langcode][$current_file_count + $i] = $form[$field_name][$langcode][$current_file_count +$i - 1];
        $form[$field_name][$langcode][$current_file_count + $i]['#weight']++;
      }
    }

    // Now we are ready for processing.
    $upload_name = implode('_', $form_parents);

    $file_upload_name = $upload_name . '_' . $current_file_count;
    $triggering_element_name = $file_upload_name . '_upload_button';

    // Get the list of file upload names, for areas of the code that need to
    // handle the possibility of multiple file uploads at once.
    $multiple_file_upload_names = array($file_upload_name);
    if ($is_multiple_upload) {
      for ($i = 1; $i < $action['upload_count']; $i++) {
        $multiple_file_upload_names[] = $upload_name . '_' . ($current_file_count + $i);
      }
    }

    $remove_fid = FALSE;
    $attach_fid = FALSE;

    switch ($action['type']) {
      case 'upload':
        if (!empty($_FILES['files'])) {
          // Move all uploaded files to the correct place in the $_FILES array.
          foreach ($_FILES['files'] as $key => $values) {
            foreach ($multiple_file_upload_names as $multiple_file_upload_name) {
              $_FILES['files'][$key][$multiple_file_upload_name] = array_shift($_FILES['files'][$key]['dropzone_files']);
            }
          }
        }
        break;

      case 'attach':
        $attach_fid = $action['fid'];
        break;

      case 'remove':
        $remove_fid = $action['fid'];
        break;

      case 'legacy':
        // Intentionally do nothing.
        break;

      default:
        lock_release($lock_name);
        return file_dropzone_error_exit(t('Unknown action type "@action" when trying to process files.', array('@action' => $action['type'])));
    }

    if ($action['type'] != 'legacy') {
      $_POST['_triggering_element_name'] = $triggering_element_name;

      // Make sure $_POST is up to date with the current list of items for this
      // field. For example, if one dropzone action is taken immediately after
      // another, the $_POST data sent with the second will not reflect the
      // additions or deletions made in the first, if the first submission is
      // not complete yet. The code here ensures the correct items are always
      // used.
      if (isset($form_state['file_dropzone']['submitted_values'][$field_name][$langcode])) {
        // If there was a previous submission of this form, use the list of
        // submitted items from that. But any properties of the item (for
        // example, drag-and-drop weights) should be based on the current form
        // submission. This means that a dropzone action followed by a
        // non-dropzone action (such as drag-and-drop) followed by another
        // dropzone action will preserve the changes made via the non-dropzone
        // action as well.
        $items = $form_state['file_dropzone']['submitted_values'][$field_name][$langcode];
        $input = $form_state['input'][$field_name][$langcode];
        foreach ($items as &$item) {
          if (is_array($item) && isset($item['fid'])) {
            foreach ($input as $key => $value) {
              if (is_array($value) && isset($value['fid']) && $value['fid'] == $item['fid']) {
                $item = $value;
                // Stop checking this item and unset it from the input once a
                // match has been found. If the same file is referenced more
                // than once, this allows each copy to have its own independent
                // properties (for example, drag-and-drop weight).
                unset($input[$key]);
                continue 2;
              }
            }
          }
        }
      }
      else {
        // Otherwise, this is the first submission, so use the values that were
        // submitted this time.
        $items = $form_state['input'][$field_name][$langcode];
      }
      if (!empty($items)) {
        // Normalize the weight.
        uasort($items, function($a, $b) {
          $a_weight = (is_array($a) && isset($a['_weight'])) ? $a['_weight'] : 0;
          $b_weight = (is_array($b) && isset($b['_weight'])) ? $b['_weight'] : 0;

          if ($a_weight == $b_weight) {
            return 0;
          }

          return ($a_weight < $b_weight) ? -1 : 1;
        });

        $items = array_filter($items, function($item) { if (empty($item['fid'])) { return FALSE; } return TRUE; });
        $items = array_values($items);

        foreach ($items as $delta => $item) {
          $items[$delta] = array_intersect_key($item, array_flip(array('_weight', 'fid', 'display')));
          $items[$delta]['_weight'] = $delta;
        }

        $items_to_add = $is_multiple_upload ? $action['upload_count'] : 1;
        for ($i = 0; $i < $items_to_add; $i++) {
          $items[] = array(
            '_weight' => $current_file_count + $i,
            'fid' => '',
            'display' => 1,
          );
        }

        $_POST[$field_name][$langcode] = $items;
      }

      if ($remove_fid) {
        foreach ($_POST[$field_name][$langcode] as $delta => $item) {
          if ($item['fid'] == $remove_fid) {
            $triggering_element_name = $upload_name . '_' . $delta . '_remove_button';
            $_POST['_triggering_element_name'] = $triggering_element_name;
            $_POST['_triggering_element_value'] = t('Remove');
            unset($_POST['files']);
            foreach (array('name', 'type', 'tmp_name', 'error', 'size', 'orig_name') as $key) {
              $_FILES['files'][$key][$file_upload_name] = '';
              if ($key == 'error') {
                $_FILES['files'][$key][$file_upload_name] = 4;
              }
              if ($key == 'size') {
                $_FILES['files'][$key][$file_upload_name] = 0;
              }
            }
          }
        }
      }

      if ($attach_fid) {
        $triggering_element_name = $file_upload_name . '_attach_button';

        $_POST['_triggering_element_name'] = $triggering_element_name;
        $_POST['_triggering_element_value'] = t('Attach');
        $_POST['media'][$file_upload_name] = $attach_fid;
      }
    }

    $input = $_POST;

    // Allow other modules to alter the form input before submission.
    drupal_alter('file_dropzone_process_form', $input, $form, $form_state, $form_parents);

    $_POST = $input;
    $_REQUEST = $input + $_GET;

    // Update the form input with the new post values.
    $form_state['input'] = $input;

    // Remove validation errors for the whole form and record them per file
    // instead.
    $form[$field_name]['#element_validate'][] = 'file_dropzone_remove_validation_errors';
    $form_state['file_dropzone_errors'] = [];
    $form_state['file_dropzone_multiple_file_upload_names'] = $multiple_file_upload_names;

    // Process user input. $form and $form_state are modified in the process.
    drupal_process_form($form['#form_id'], $form, $form_state);

    // Cache the submitted values for this field in $form_state so they can be
    // used the next time an Ajax request is made. Note that this cannot be
    // done before drupal_process_form() is called above since the values won't
    // be set yet at that point.
    $cache = cache_get('form_state_' . $form_build_id, 'cache_form');
    $cache->data['file_dropzone']['submitted_values'][$field_name][$langcode] = $form_state['values'][$field_name][$langcode];
    cache_set('form_state_' . $form_build_id, $cache->data, 'cache_form', $cache->expire);

    $messages = theme('status_messages', array('display' => 'error'));

    // If there are still messages left, then all files failed to upload.
    if (!empty($messages)) {
      $items_processed = $is_multiple_upload ? $action['upload_count'] : 1;
      for ($i = 0; $i < $items_processed; $i++) {
        $results[] = array(
          'status' => 400,
          'message' => $messages,
          'fid' => -1,
        );
      }
    }
    else {
      $items_processed = $is_multiple_upload ? $action['upload_count'] : 1;
      for ($i = 0; $i < $items_processed; $i++) {
        if (!empty($form_state['file_dropzone_errors'][$i])) {
          drupal_set_message($form_state['file_dropzone_errors'][$i], 'error');
          $message = theme('status_messages', array('display' => 'error'));
          $results[$i] = array(
            'status' => 400,
            'message' => $message,
            'fid' => -1,
          );
        }
        else {
          $results[$i] = array(
            'status' => 201,
            'message' => 'OK',
            'fid' => !empty($form_state['values'][$field_name][$langcode][$current_file_count + $i]['fid']) ? $form_state['values'][$field_name][$langcode][$current_file_count + $i]['fid'] : '',
          );
        }
      }
    }

    // Cleanup $_FILES and $_POST from current round values. This prevents
    // a file from being created again and again (though with the same fid).
    if ($action['type'] == 'upload') {
      foreach ($_FILES['files'] as $key => $values) {
        foreach ($multiple_file_upload_names as $multiple_file_upload_name) {
          unset($_FILES['files'][$key][$multiple_file_upload_name]);
        }
      }
    }
    elseif ($action['type'] == 'attach') {
      unset($_POST['media'][$file_upload_name]);
    }
  }

  lock_release($lock_name);

  // Retrieve the element to be rendered.
  foreach ($form_parents as $parent) {
    $form = $form[$parent];
  }

  // Add the special Ajax class if a new file was added.
  if (isset($form['#file_upload_delta']) && $current_file_count < $form['#file_upload_delta']) {
    $form[$current_file_count]['#attributes']['class'][] = 'ajax-new-content';
  }
  // Otherwise just add the new content class on a placeholder.
  else {
    $form['#suffix'] .= '<span class="ajax-new-content"></span>';
  }

  $output = theme('status_messages') . drupal_render($form);
  $js = drupal_add_js();
  $settings = call_user_func_array('array_merge_recursive', $js['settings']['data']);

  $commands[] = ajax_command_replace(NULL, $output, $settings);
  $commands[] = array( 'command' => 'dropzoneFiles', 'results' => $results );
  return array('#type' => 'ajax', '#commands' => $commands);
}

function file_dropzone_error_exit($message, $status_header = 'HTTP/1.0 400 Bad request') {
    header($status_header);
    print strip_tags($message);
    exit();
}

/**
 * Clears an error against one form element.
 *
 * @param $name
 *   The name of the form element.
 */
function _file_dropzone_form_unset_error($name) {
  $errors = &drupal_static('form_set_error', array());
  $removed_messages = array();
  if (isset($errors[$name])) {
    $removed_messages[] = $errors[$name];
    unset($errors[$name]);
  }
  $_SESSION['messages']['error'] = array_diff($_SESSION['messages']['error'], $removed_messages);
  if (empty($_SESSION['messages']['error'])) {
    unset($_SESSION['messages']['error']);
  }
}

/**
 * Element validation callback to remove errors related to file uploads.
 */
function file_dropzone_remove_validation_errors(&$elements, &$form_state, $form) {
  $errors = form_get_errors();
  foreach ($form_state['file_dropzone_multiple_file_upload_names'] as $index => $file_upload_name) {
    if (isset($errors[$file_upload_name])) {
      // Remove the error, so other files are attached properly.
      _file_dropzone_form_unset_error($file_upload_name);
      // Store the error in a special form state entry.
      $form_state['file_dropzone_errors'][$index] = $errors[$file_upload_name];
    }
  }
}

/**
 * Implements hook_field_widget_form_alter().
 */
function file_dropzone_field_widget_form_alter(&$element, &$form_state, $context) {
  $field = $context['field'];
  $instance = $context['instance'];

  $supported_widget_types = variable_get('file_dropzone_supported_widgets', array('file_generic', 'image_image'));

  if (!in_array($instance['widget']['type'], $supported_widget_types)) {
    return;
  }

  foreach (element_children($element) as $delta) {
    // Ensure all properties are available for merging.
    $element_info = element_info($element[$delta]['#type']);
    $element[$delta] += $element_info;

    $element[$delta] = drupal_array_merge_deep($element[$delta] + $element_info, array(
      '#file_value_callbacks' => array('file_dropzone_attach_file_value'),
      // Add our own process and pre_render callbacks.
      '#process' => array('file_dropzone_attach_widget_process', 'file_dropzone_file_field_widget_process'),
      '#pre_render' => array('file_dropzone_file_managed_element_pre_render'),
    ));
  }

  $element['#process'][] = 'file_dropzone_field_widget_process_multiple';
}

/**
 * The #value_callback for the added media file managed field element.
 */
function file_dropzone_attach_file_value(&$element, &$input = FALSE, $form_state) {
  if ($input !== FALSE) {
    // Uploads take priority over all other values.
    if ($file = _file_dropzone_attach_file($element)) {
      $input['fid'] = $file->fid;
    }
  }
}

/**
 * Attaches any files that have been referenced by a file element.
 *
 * @param $element
 *   The FAPI element whose files are being attached.
 *
 * @return
 *   The file object representing the file that was attached, or FALSE if no
 *   file was attached.
 */
function _file_dropzone_attach_file($element) {
  $upload_name = implode('_', $element['#parents']);
  if (empty($_POST['media'][$upload_name])) {
    return FALSE;
  }

  if (!$file = file_load($_POST['media'][$upload_name])) {
    watchdog('file', 'The file upload failed. %upload', array('%upload' => $upload_name));
    form_set_error($upload_name, t('The file in the !name field was unable to be uploaded.', array('!name' => $element['#title'])));
    return FALSE;
  }

  return $file;
}

/**
 * Process callback for the file field element.
 */
function file_dropzone_attach_widget_process($element, &$form_state, $form) {

  $element['upload_button']['#attributes']['class'][] = 'file-dropzone-upload-button';
  $element['remove_button']['#attributes']['class'][] = 'file-dropzone-remove-button';
  $element['fid']['#attributes']['class'][] = 'file-dropzone-fid';
  $element['upload']['#attributes']['class'][] = 'file-dropzone-upload-element';
  $element['upload']['#attributes']['class'][] = 'file-dropzone-browse-element';

  $ajax_settings = array(
    'path' => $element['upload_button']['#ajax']['path'],
    'wrapper' => $element['upload_button']['#ajax']['wrapper'],
    'effect' => 'fade',
  );

  if (!isset($element['attach_button'])) {
     // Set up the buttons first since we need to check if they were clicked.
    $element['attach_button'] = array(
      '#name' => implode('_', $element['#parents']) . '_attach_button',
      '#type' => 'submit',
      '#value' => t('Attach'),
      '#validate' => array(),
      '#submit' => array('media_file_submit'),
      '#limit_validation_errors' => array($element['#parents']),
      '#ajax' => $ajax_settings,
      '#attributes' => array('class' => array('attach', 'file-dropzone-attach-button', 'element-hidden')),
      '#weight' => -1,
    );

    // The file ID field itself.
    $element['upload_media'] = array(
      '#name' => 'media[' . implode('_', $element['#parents']) . ']',
      '#type' => 'textfield',
      '#title' => t('Enter the ID of an existing file'),
      '#title_display' => 'invisible',
      '#field_prefix' => t('File ID'),
      '#size' => $element['#size'],
      '#theme_wrappers' => array(),
      '#attributes' => array('class' => array('file-dropzone-upload-fid', 'element-hidden')),
      '#weight' => -9,
    );
  }

  // Add another submit handler to the upload button, to implement
  // functionality needed by the field widget. This submit handler, along with
  // the rebuild logic in media_field_widget_form() requires the entire field,
  // not just the individual item, to be valid.
  foreach (array('attach_button') as $key) {
    $element[$key]['#submit'][] = 'file_field_widget_submit';
    $element[$key]['#limit_validation_errors'] = array(array_slice($element['#parents'], 0, -1));
  }

  return $element;
}

/**
 * Process callback for the file managed field element.
 */
function file_dropzone_file_field_widget_process($element, &$form_state, $form) {
  $field = field_widget_field($element, $form_state);

  // Adjust the Ajax settings so that on upload and remove of any individual
  // file, the entire group of file fields is updated together.
  // Also add our file_dropzone menu callback.
  // @todo Make cardinality 1 work.
  if ($field['cardinality'] != 1) {
    $parents = array_slice($element['#array_parents'], 0, -1);
    $new_path = 'file_dropzone/ajax/' . implode('/', $parents) . '/' . $form['form_build_id']['#value'];
    $field_element = drupal_array_get_nested_value($form, $parents);
    $new_wrapper = $field_element['#id'] . '-ajax-wrapper';
    foreach (element_children($element) as $key) {
      if (isset($element[$key]['#ajax'])) {
        $element[$key]['#ajax']['path'] = $new_path;
        $element[$key]['#ajax']['wrapper'] = $new_wrapper;
      }
    }
    unset($element['#prefix'], $element['#suffix']);
  }

  // Pass scalar upload validators as data- attributes - if in the passed list.
  $passed_upload_validators = variable_get('file_dropzone_passed_upload_validators', array('file_validate_extensions', 'file_validate_size'));

  foreach ($element['#upload_validators'] as $key => $value) {
    if (!isset($value[0]) || !is_scalar($value[0])) {
      continue;
    }
    if (in_array($key, $passed_upload_validators)) {
      // Deliberately pass $value as is and not just index 0.
      $element['fid']['#attributes']['data-' . drupal_html_class($key)] = $value;
    }
  }

  return $element;
}



/**
 * An element #process callback for a group of media fields.
 *
 * Adds the drupal dropzone library and class.
 */
function file_dropzone_field_widget_process_multiple($element, &$form_state, $form) {
  $element['#attached']['library'][] = array('file_dropzone', 'drupal_dropzone');
  $element['#attributes']['class'][] = 'drupal-dropzone';

  return $element;
}

/**
 * #pre_render callback to hide display of the added upload controls.
 *
 * @see file_dropzone_attach_widget_process()
 * @see form_builder()
 */
function file_dropzone_file_managed_element_pre_render($element) {
  // If we already have a file, we don't want to show the attach and upload_media
  // controls.
  if (!empty($element['#value']['fid'])) {
    $element['attach_button']['#access'] = FALSE;
    $element['upload_media']['#access'] = FALSE;
  }

  return $element;
}
