<?php

/**
 * Returns bookable item's status for a specific calendar date.
 * TODO: Add static cache.
 */
function bookit_calendar_item_status($item_id, $date, $date_to = FALSE) {
  // Get the query for not bookable items.
  $query = bookit_calendar_not_bookable_query($date, $date_to);
  $query->condition('i.item_id', $item_id);

  // If current item is not in not bookable
  return ! (bool) $query->countQuery()->execute()->fetchField();
}

/**
 * Returns an alterable query for calendar status.
 * @see bookit_calendar/includes/views/handlers/bookit_item_views_handler_filter_date.inc
 */
function bookit_calendar_not_bookable_query($date, $date_to = FALSE) {
  // Select bookable item table.
  $query = db_select('bookit_item', 'i');

  // Join with calendar using date(s).
  if ($date_to) {
    $query->leftjoin('bookit_calendar', 'c', 'c.item_id = i.item_id AND c.date >= :date AND c.date < :date_to', array(':date' => $date, ':date_to' => $date_to));
  }
  else {
    $query->leftjoin('bookit_calendar', 'c', 'c.item_id = i.item_id AND c.date = :date', array(':date' => $date));
  }

  // We use or for conditions as we need need to select all the item_ids
  // that are NOT enabled for booking.
  $or = db_or();
  $or->condition('c.status', 0);
  $or->condition('i.status', 0);

  // Allow other modules to alter the not_bookable query.
  $context = array('date' => $date, 'date_to' => $date_to);
  drupal_alter('bookit_calendar_not_bookable_query', $query, $or, $context);

  // Add the conditions.
  $query->condition($or);

  // Select the item_id.
  $query->fields('i', array('item_id'));
  $query->distinct();

  return $query;
}

/**
 * Implements hook_entity_delete().
 */
function bookit_calendar_entity_delete($entity, $entity_type) {
  if ($entity_type == 'bookit_item') {
    list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);

    // If bookable item deleted then delete all calendar rows.
    db_delete('bookit_calendar')
      ->condition('item_id', $id)
      ->execute();
  }
}

/**
 * Creates date from year, month, day numbers.
 */
function _bookit_calendar_create_date($year, $month, $day) {
  $date = array();
  $date[] = $year;
  $date[] = str_pad($month, 2, "0", STR_PAD_LEFT);
  $date[] = str_pad($day, 2, "0", STR_PAD_LEFT);
  return implode('-', $date);
}

/**
 * Creates date from datetime.
 */
function _bookit_calendar_create_date_from_datetime($datetime) {
  $time = strtotime($datetime);
  return date('Y-m-d', $time);
}

/**
 * Implements hook_permission().
 */
function bookit_calendar_permission() {
  return array(
    'access bookit_item calendar' => array(
      'title' => t('Access bookable item\'s calendar'),
      'description' => t('Allows users to access the bookable item\'s calendar.'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_views_api().
 */
function bookit_calendar_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'bookit_calendar') . '/includes/views',
  );
}

/**
 * Returns the selected booking dates.
 */
function bookit_calendar_date_by_item_id($item_id) {
  // TODO: Find a way to handle single value.
  $node = bookit_item_get_referencing_node($item_id);
  return isset($_SESSION['booking_date']['node_' . $node->type]) ? $_SESSION['booking_date']['node_' . $node->type] : FALSE;
}

/**
 * Returns the selected booking dates.
 */
function bookit_calendar_date_by_view($view) {
  $booking_date = &drupal_static(__FUNCTION__);
  $view_id = $view->name . '|' . $view->current_display;

  // Get the calendar booking date by node type.
  if (!isset($booking_date[$view_id])) {
    $booking_date[$view_id] = FALSE;

    // If there is booking date filter in this view.
    if ($filter = bookit_calendar_views_get_date_filter($view)) {
      $booking_group = $filter->options['booking_group'];

      // If current booking_group exists in SESSION.
      if (!empty($booking_group) and isset($_SESSION['booking_date'][$booking_group])) {
        // Get operators.
        $operations = $filter->operators();
        $is_range = ($operations[$filter->options['operator']]['values'] > 1);

        // Get current booking_group's SESSION stored values.
        $session = $_SESSION['booking_date'][$booking_group];

        // If operator is range.
        if ($is_range and !empty($session['min']) and !empty($session['max'])) {
          $booking_date[$view_id] = array('min' => $session['min'], 'max' => $session['max']);
        }
        else if(!empty($session['value'])) {
          $booking_date[$view_id] = array('value' => $session['value']);
        }
      }
    }
  }

  return $booking_date[$view_id];
}

/**
 * Retrieve date filter of the view.
 */
function bookit_calendar_views_get_date_filter($view) {
  // Foreach view's filter.
  foreach ($view->filter as $name => $filter) {
    if (get_class($filter) == 'bookit_item_views_handler_filter_date') {
      return $filter;
    }
  }

  return FALSE;
}

/**
 * Implements hook_views_pre_build().
 */
function bookit_calendar_views_pre_build(&$view) {
  foreach ($view->filter as $name => &$filter) {
    // If there is date filter and it is not changed via request.
    if (get_class($filter) == 'bookit_item_views_handler_filter_date') {
      $booking_group = $filter->options['booking_group'];

      // Get filter values from SESSION.
      if (isset($_SESSION['booking_date'][$booking_group])) {
        foreach ($_SESSION['booking_date'][$booking_group] as $key => $value) {
          // If exposed always get values from session.
          if ($filter->options['exposed'] and !isset($_REQUEST[$name])) {
            $filter->value[$key] = $value;
            $view->exposed_input[$name][$key] = $value;
          }
          // If not exposed then get value from session only if
          // the initial value is empty.
          else if (empty($filter->value[$key])) {
            $filter->value[$key] = $value;
          }
        }
      }
    }
  }
}

/**
 * Implements hook_admin_paths().
 */
function bookit_calendar_admin_paths() {
  $paths = array(
    'node/*/calendar' => TRUE,
    'node/*/calendar/*' => TRUE,
  );
  return $paths;
}

/**
 * Implements hook_menu().
 */
function bookit_calendar_menu() {
  $items = array();

  $items['admin/bookit/items/%bookit_item/calendar'] = array(
    'title' => t('Calendar'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('bookit_calendar_admin_form', 3, 5, 6),
    'access arguments' => array('access bookit_item calendar'),
    'type' => MENU_LOCAL_TASK,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'file' => 'includes/bookit_calendar.admin.inc',
  );

  $items['node/%node/calendar'] = array(
    'title' => t('Calendar'),
    'page callback' => 'bookit_calendar_overview',
    'page arguments' => array(1, 3, 4),
    'access callback' => 'bookit_calendar_overview_access',
    'access arguments' => array(1),
    'type' => MENU_LOCAL_TASK,
    'weight' => 4,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'file' => 'includes/bookit_calendar.admin.inc',
  );

  $items['bookit_calendar/ajax'] = array(
    'title' => 'AHAH callback',
    'page callback' => 'bookit_calendar_status_ajax',
    'page arguments' => array(2, 3, 4),
    'delivery callback' => 'ajax_deliver',
    'access callback' => TRUE,
    'theme callback' => 'ajax_base_page_theme',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Access callback for overview form.
 */
function bookit_calendar_overview_access($node) {
  // Foreach field.
  foreach (field_info_fields() as $field) {
    // If field is entityreference, targets a bookit_item
    // and it belongs to a node.
    if ($field['type'] == 'entityreference' and $field['settings']['target_type'] == 'bookit_item' and isset($field['bundles']['node'])) {
      // If current node's type has this field.
      if (in_array($node->type, $field['bundles']['node'])) {
        return user_access('access bookit_item calendar');
      }
    }
  }

  return FALSE;
}

/**
 * Ajax callback for calendars.
 */
function bookit_calendar_status_ajax($item_id, $date, $status) {
  // Check token.
  if(!drupal_valid_token($_GET['token'], "bookit_calendar_{$item_id}_{$date}_{$status}")) {
    return MENU_ACCESS_DENIED;
  }

  // Save the calendar status.
  db_merge('bookit_calendar')
  ->key(array(
    'item_id' => $item_id,
    'date' => $date,
  ))
  ->fields(array(
    'item_id' => $item_id,
    'date' => $date,
    'status' => $status,
  ))
  ->execute();

  // Get the element.
  $commands = array();
  module_load_include('inc', 'bookit_calendar', 'includes/bookit_calendar.admin');
  $replace_content = _bookit_calendar_status_widget($item_id, $date);
  $commands[] = ajax_command_replace("#bookit-status-$item_id-$date", drupal_render($replace_content));
  return array('#type' => 'ajax', '#commands' => $commands);
}

/**
 * Implements hook_theme().
 */
function bookit_calendar_theme($existing, $type, $theme, $path) {
  return array(
    'form_bookit_calendar' => array(
      'render element' => 'element',
    ),
  );
}

/**
 * Returns HTML calendar table for a form element.
 */
function theme_form_bookit_calendar($variables) {
  $element = $variables['element'];
  $year = $element['#year'];
  $month = $element['#month'];

  // Create a datetime from the first day of the month.
  $datetime = strtotime("$year-$month-01 00:00:00");

  // Calculate month days.
  $days = date('j', strtotime('last day of this month', $datetime));

  $output = '<table' . drupal_attributes($element['#attributes']) . ">\n";

  // Header that displays the month.
  $output .= "<thead>\n";
  $output .= " <tr><th colspan=\"" . ($days + 1) . "\">" . format_date($datetime, 'custom', 'F') . "</th></tr>\n";
  $output .= "<thead>\n";

  // Display the month days.
  $output .= "<tbody>\n";
  $output .= " <tr class=\"calendar-days\">\n";
  $output .= " <td></td>\n";
  for ($i = 1; $i <= $days; $i++) {
    $output .= " <td>$i</td>\n";
  }
  $output .= " </tr>\n";

  // Foreach calendar type.
  $rows = array();

  // Foreach day.
  foreach (element_children($element) as $day) {

    // Foreach entity field.
    foreach (element_children($element[$day]) as $field_name) {
      // Get the field title and the field attributes to use them in table row.
      if(!isset($rows[$field_name]['#title'])) {
        $rows[$field_name]['#title'] = isset($element[$day][$field_name]['#title']) ? $element[$day][$field_name]['#title'] : '';
        $rows[$field_name]['#attributes'] = isset($element[$day][$field_name]['#attributes']) ? $element[$day][$field_name]['#attributes'] : array();

        // If this is an editable field add a class.
        if(strstr($element[$day][$field_name]['#children'], 'type="text"')) {
          $rows[$field_name]['#attributes']['class'][] = 'editable';
        }
      }

      // Build the column's content.
      $rows[$field_name][$day] = $element[$day][$field_name]['#children'];
      $rows[$field_name]['#heading'] = isset($element[$day][$field_name]['#heading']) ? $element[$day][$field_name]['#heading'] : FALSE;
    }
  }

  // Render rows.
  foreach ($rows as $row) {
    if ($row['#heading']) {
      $output .= " <tr class=\"calendar-option\"><td colspan=\"" . ($days + 1) . "\">" . $row['#heading'] . "</td></tr>\n";
    }

    $output .= " <tr" . drupal_attributes($row['#attributes']) . ">\n";
    $output .= " <td class=\"title\">" . $row['#title'] . "</td>\n";

    // Render columns.
    foreach (element_children($row) as $day) {
      $output .= " <td class=\"day\">" . $row[$day] . "</td>\n";
    }

    $output .= " </tr>\n";
  }

  $output .= "</tbody>\n";
  $output .= "</table>\n";
  return $output;
}
