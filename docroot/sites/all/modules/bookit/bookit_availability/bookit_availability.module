<?php

/**
 * Implements hook_commerce_line_item_insert().
 */
function bookit_availability_commerce_line_item_insert($line_item) {
  if ($line_item->type == 'bookit') {
    $wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
    $bookit_item = $wrapper->bookit_item->value();
    $bookit_date = $wrapper->bookit_date->value();
    $min = _bookit_calendar_create_date_from_datetime($bookit_date['value']);
    $max = _bookit_calendar_create_date_from_datetime($bookit_date['value2']);

    db_update('bookit_availability')
      ->expression('availability', 'availability - :quantity', array(':quantity' => $line_item->quantity))
      ->condition('date', $min, '>=')
      ->condition('date', $max, '<')
      ->condition('item_id', $bookit_item->item_id)
      ->execute();
  }
}

/**
 * Implements hook_commerce_line_item_update().
 */
function bookit_availability_commerce_line_item_update($line_item) {
  if ($line_item->type == 'bookit' and $line_item->quantity != $line_item->original->quantity) {
    $wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
    $bookit_item = $wrapper->bookit_item->value();
    $bookit_date = $wrapper->bookit_date->value();
    $min = _bookit_calendar_create_date_from_datetime($bookit_date['value']);
    $max = _bookit_calendar_create_date_from_datetime($bookit_date['value2']);

    if (($line_item->quantity - $line_item->original->quantity) > 0) {
      db_update('bookit_availability')
        ->expression('availability', 'availability - :quantity', array(':quantity' => $line_item->quantity - $line_item->original->quantity))
        ->condition('date', $min, '>=')
        ->condition('date', $max, '<')
        ->condition('item_id', $bookit_item->item_id)
        ->execute();
    }
    else {
      db_update('bookit_availability')
        ->expression('availability', 'availability + :quantity', array(':quantity' => abs($line_item->quantity - $line_item->original->quantity)))
        ->condition('date', $min, '>=')
        ->condition('date', $max, '<')
        ->condition('item_id', $bookit_item->item_id)
        ->execute();
    }
  }
}

/**
 * Implements hook_commerce_line_item_delete().
 */
function bookit_availability_commerce_line_item_delete($line_item) {
  if ($line_item->type == 'bookit') {
    $wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
    $bookit_item = $wrapper->bookit_item->value();
    $bookit_date = $wrapper->bookit_date->value();
    $min = _bookit_calendar_create_date_from_datetime($bookit_date['value']);
    $max = _bookit_calendar_create_date_from_datetime($bookit_date['value2']);

    db_update('bookit_availability')
      ->expression('availability', 'availability + :quantity', array(':quantity' => $line_item->quantity))
      ->condition('date', $min, '>=')
      ->condition('date', $max, '<')
      ->condition('item_id', $bookit_item->item_id)
      ->execute();
  }
}

/**
 * Implements hook_commerce_line_item_presave().
 * Validates the booking line item quantity.
 */
function bookit_availability_commerce_line_item_presave($line_item) {
  if($line_item->type == 'bookit') {
    $wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
    $bookit_item = $wrapper->bookit_item->value();
    $bookit_date = $wrapper->bookit_date->value();
    $min = _bookit_calendar_create_date_from_datetime($bookit_date['value']);
    $max = _bookit_calendar_create_date_from_datetime($bookit_date['value2']);

    // Get the current availability.
    $query = db_select('bookit_availability', 'a')
      ->condition('a.item_id', $bookit_item->item_id)
      ->condition('a.date', $min, '>=')
      ->condition('a.date', $max, '<');
    $query->addExpression('MIN(a.availability)');
    $availability = $query->execute()->fetchField();

    // Get the additional quantity.
    $add_quantity = isset($line_item->original) ? ($line_item->quantity - $line_item->original->quantity) : $line_item->quantity;

    // If additional quantity is more than the current availability
    // then throw an error and set the quantity to the maximum value.
    if ($add_quantity > $availability) {
      $line_item->quantity = isset($line_item->original) ? $line_item->original->quantity + $availability : $availability;
      drupal_set_message(t('You can\'t book more than @max_quantity items.', array('@max_quantity' => $line_item->quantity)), 'warning');
    }
  }
}

/**
 * Implements hook_bookit_calendar_not_bookable_query_alter().
 */
function bookit_availability_bookit_calendar_not_bookable_query_alter(&$query, &$conditions, $context) {
  $query->leftjoin('bookit_availability', 'a', 'a.item_id = i.item_id AND a.date = c.date');
  $conditions->condition('a.availability', 0);
  $conditions->isNull('a.availability');
}

/**
 * Implements hook_views_api().
 */
function bookit_availability_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'bookit_availability') . '/includes/views',
  );
}

/**
 * Implements hook_entity_delete().
 */
function bookit_availability_entity_delete($entity, $entity_type) {
  if ($entity_type == 'bookit_item') {
    list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);

    // If bookable item deleted then delete all availability rows.
    db_delete('bookit_availability')
      ->condition('item_id', $id)
      ->execute();
  }
}

/**
 * Implements hook_form_alter().
 */
function bookit_availability_form_bookit_calendar_admin_form_alter(&$form, &$form_state) {
  $bookit_item = $form_state['bookit_item'];

  foreach (element_children($form['calendar']) as $day) {
    $availability = db_select('bookit_availability', 'a')
      ->fields('a', array('availability'))
      ->condition('a.item_id', $bookit_item->item_id)
      ->condition('a.date', $form['calendar'][$day]['#date'])
      ->execute()
      ->fetchField();

    // Availability widget.
    $form['calendar'][$day]['bookit_availability'] = array(
      '#title' => t('Availability'),
      '#title_display' => 'invisible',
      '#type' => 'textfield',
      '#default_value' => $availability ? $availability : '',
      '#element_validate' => array('element_validate_number', 'bookit_availability_element_validate'),
      '#date' => $form['calendar'][$day]['#date'],
      '#size' => 4,
    );

    // TODO: Add booked information.
  }

  $form['#submit'][] = 'bookit_availability_bookit_calendar_admin_form_submit';
}

/**
 * Element validate callback. Validates the minimum integer value.
 */
function bookit_availability_element_validate($element, &$form_state) {
  $value = (int) $element['#value'];
  $datetime = strtotime($element['#date']);

  if ($value < 0) {
    form_error($element, t('%name at %date cannot be less than zero.', array('%name' => $element['#title'], '%date' => format_date($datetime, 'custom', 'd-m-Y'))));
  }
}

/**
 * Submit callback for bookit_calendar_admin_form.
 */
function bookit_availability_bookit_calendar_admin_form_submit($form, &$form_state) {
  $bookit_item = $form_state['bookit_item'];

  foreach ($form_state['values']['calendar'] as $day => $value) {
    // Save the availability.
    db_merge('bookit_availability')
    ->key(array(
      'item_id' => $bookit_item->item_id,
      'date' => $form['calendar'][$day]['#date'],
    ))
    ->fields(array(
      'item_id' => $bookit_item->item_id,
      'date' => $form['calendar'][$day]['#date'],
      'availability' => (int) $value['bookit_availability'],
    ))
    ->execute();
  }
}
