<?php

/**
 * Implements hook_modules_enabled().
 */
function bookit_option_modules_enabled($modules) {
  if (in_array('bookit_cart', $modules)) {
    // Create booking option field.
    commerce_activate_field('bookit_option');
    field_cache_clear();

    $field = field_info_field('bookit_option');
    $instance = field_info_instance('commerce_line_item', 'bookit_option', 'bookit');

    if (empty($field)) {
      $field = array(
        'field_name' => 'bookit_option',
        'type' => 'entityreference',
        'cardinality' => 1,
        'entity_types' => array('commerce_line_item'),
        'translatable' => FALSE,
        'locked' => TRUE,
        'settings' => array(
          'target_type' => 'bookit_option',
          'handler' => 'base',
        ),
      );
      $field = field_create_field($field);
    }

    if (empty($instance)) {
      $instance = array(
        'field_name' => 'bookit_option',
        'entity_type' => 'commerce_line_item',
        'bundle' => 'bookit',
        'label' => t('Booking Option'),
        'required' => FALSE,
        'settings' => array(),
        'display' => array(),
      );
      field_create_instance($instance);
    }
  }
}

/**
 * Implements hook_hook_info().
 */
function bookit_option_hook_info() {
  return array(
    'bookit_option_type_info' => array(
      'group' => 'bookit',
    ),
    'bookit_option_type_info_alter' => array(
      'group' => 'bookit',
    ),
  );
}

/**
 * Implements hook_entity_info().
 */
function bookit_option_entity_info() {
  $return = array(
    'bookit_option' => array(
      'label' => t('Booking Option'),
      'controller class' => 'BookitOptionEntityController',
      'base table' => 'bookit_option',
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'option_id',
        'bundle' => 'type',
        'label' => 'title',
        'language' => 'language',
      ),
      'bundle keys' => array(
        'bundle' => 'type',
      ),
      'bundles' => array(),
      'load hook' => 'bookit_option_load',
      'view modes' => array(
        'full' => array(
          'label' => t('Admin display'),
          'custom settings' => FALSE,
        ),
      ),
      'uri callback' => 'bookit_option_uri',
      'metadata controller class' => '',
      'token type' => 'bookit-option',
      'access callback' => 'bookit_option_access',
      'access arguments' => array(
        'user key' => 'uid',
      ),
      'permission labels' => array(
        'singular' => t('option'),
        'plural' => t('options'),
      ),
      'redirect' => FALSE,

      // Add translation support.
      'translation' => array(
        'locale' => TRUE,
        'entity_translation' => array(
          'base path' => 'admin/bookit/config/options/%bookit_option',
          'class' => 'EntityTranslationBookitOptionHandler',
          'bundle callback' => 'bookit_option_entity_translation_supported_type',
          'default settings' => array(
            'default_language' => LANGUAGE_NONE,
            'hide_language_selector' => FALSE,
          ),
        ),
      ),

      // Add title replacement support for translations.
      'field replacement' => array(
        'title' => array(
          'field' => array(
            'type' => 'text',
            'cardinality' => 1,
            'translatable' => TRUE,
          ),
          'instance' => array(
            'label' => t('Title'),
            'required' => TRUE,
            'settings' => array(
              'text_processing' => 0,
            ),
            'widget' => array(
              'weight' => -5,
            ),
          ),
        ),
      ),
    ),
  );

  $return['bookit_option']['bundles'] = array();
  foreach (bookit_option_type_get_name() as $type => $name) {
    $return['bookit_option']['bundles'][$type] = array(
      'label' => $name,
      'admin' => array(
        'path' => 'admin/bookit/config/options/types/' . strtr($type, '_', '-'),
        'access arguments' => array('administer bookit_option types'),
      ),
    );
  }

  return $return;
}

/**
 * Returns whether the given booking option type has supports translation.
 */
function bookit_option_entity_translation_supported_type($type) {
  return variable_get('language_bookit_option_type_' . $type, 0) == ENTITY_TRANSLATION_ENABLED;
}

/**
 * Implements hook_menu().
 */
function bookit_option_menu() {
  $items = array();

  $items['admin/bookit/config/options'] = array(
    'title' => t('Booking Options'),
    'page callback' => 'system_admin_menu_block_page',
    'access arguments' => array('administer bookit_option entities'),
    'file path' => drupal_get_path('module', 'system'),
    'file' => 'system.admin.inc',
  );

  $items['admin/bookit/config/options/add'] = array(
    'title' => 'Add a booking option',
    'description' => 'Add a new booking option.',
    'page callback' => 'bookit_option_add_page',
    'access callback' => 'bookit_option_add_any_access',
    'weight' => 10,
    'file' => 'includes/bookit_option.pages.inc',
  );

  foreach (bookit_option_types() as $type => $option_type) {
    $items['admin/bookit/config/options/add/' . strtr($type, array('_' => '-'))] = array(
      'title' => 'Create !name',
      'title arguments' => array('!name' => $option_type['name']),
      'description' => $option_type['description'],
      'page callback' => 'drupal_get_form',
      'page arguments' => array('bookit_option_option_form', bookit_option_new($type)),
      'access callback' => 'bookit_option_access',
      'access arguments' => array('create', bookit_option_new($type)),
      'file' => 'includes/bookit_option.pages.inc',
    );
  }

  $items['admin/bookit/config/options/%bookit_option'] = array(
    'title callback' => 'bookit_option_option_title',
    'title arguments' => array(4),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('bookit_option_option_form', 4),
    'access callback' => 'bookit_option_access',
    'access arguments' => array('update', 4),
    'weight' => 0,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
    'file' => 'includes/bookit_option.pages.inc',
  );

  $items['admin/bookit/config/options/%bookit_option/edit'] = array(
    'title' => 'Edit',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
    'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
  );

  $items['admin/bookit/config/options/%bookit_option/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('bookit_option_option_delete_form', 4),
    'access callback' => 'bookit_option_access',
    'access arguments' => array('delete', 4),
    'type' => MENU_LOCAL_TASK,
    'weight' => 20,
    'context' => MENU_CONTEXT_INLINE,
    'file' => 'includes/bookit_option.pages.inc',
  );

  $items['admin/bookit/config/options/types'] = array(
    'title' => 'Option types',
    'description' => 'Manage booking option types.',
    'page callback' => 'bookit_option_types_overview',
    'access arguments' => array('administer bookit_option types'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 0,
    'file' => 'includes/bookit_option.pages.inc',
  );

  $items['admin/bookit/config/options/types/add'] = array(
    'title' => 'Add option type',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('bookit_option_type_form', bookit_option_type_new()),
    'access arguments' => array('administer bookit_option types'),
    'type' => MENU_LOCAL_ACTION,
    'file' => 'includes/bookit_option.pages.inc',
  );

  foreach (bookit_option_types() as $type => $option_type) {
    $type_arg = strtr($type, '_', '-');

    $items['admin/bookit/config/options/types/' . $type_arg] = array(
      'title' => $option_type['name'],
      'page callback' => 'drupal_get_form',
      'page arguments' => array('bookit_option_type_form', $type),
      'access arguments' => array('administer bookit_option types'),
      'file' => 'includes/bookit_option.pages.inc',
    );

    if ($option_type['module'] == 'bookit_option') {
      $items['admin/bookit/config/options/types/' . $type_arg . '/edit'] = array(
        'title' => 'Edit',
        'access callback' => 'bookit_option_type_update_access',
        'access arguments' => array($type),
        'type' => MENU_DEFAULT_LOCAL_TASK,
        'context' => MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE,
      );
      $items['admin/bookit/config/options/types/' . $type_arg . '/delete'] = array(
        'title' => 'Delete',
        'page callback' => 'drupal_get_form',
        'page arguments' => array('bookit_option_type_delete_form', $type),
        'access callback' => 'bookit_option_type_update_access',
        'access arguments' => array($type),
        'type' => MENU_LOCAL_TASK,
        'context' => MENU_CONTEXT_INLINE,
        'weight' => 10,
        'file' => 'includes/bookit_option.pages.inc',
      );
    }
  }

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function bookit_option_menu_alter(&$items) {
  foreach (bookit_option_types() as $type => $option_type) {
    $type = strtr($type, '_', '-');
    $items['admin/bookit/config/options/types/' . $type . '/fields']['context'] = MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE;
    $items['admin/bookit/config/options/types/' . $type . '/display']['context'] = MENU_CONTEXT_PAGE | MENU_CONTEXT_INLINE;
  }
}

/**
 * Implements hook_menu_local_tasks_alter().
 */
function bookit_option_menu_local_tasks_alter(&$data, $router_item, $root_path) {
  if ($root_path == 'admin/bookit/config/options') {
    $item = menu_get_item('admin/bookit/config/options/add');
    if ($item['access']) {
      $data['actions']['output'][] = array(
        '#theme' => 'menu_local_action',
        '#link' => $item,
      );
    }
  }
}

/**
 * Implements hook_admin_menu_map().
 */
function bookit_option_admin_menu_map() {
  $type_args = array();

  foreach (array_keys(bookit_option_types()) as $type) {
    $type_args[] = strtr($type, '_', '-');
  }

  $map['admin/bookit/config/options/types/%'] = array(
    'parent' => 'admin/bookit/config/options/types',
    'arguments' => array(
      array('%' => $type_args),
    ),
  );

  return $map;
}

/**
 * Implements hook_permission().
 */
function bookit_option_permission() {
  $permissions = array(
    'administer bookit_option types' => array(
      'title' => t('Administer option types'),
      'description' => t('Allows users to configure option types and their fields.'),
      'restrict access' => TRUE,
    ),
  );

  // Use commerce entity access to create default View/Crete/Edit permissions.
  $permissions += commerce_entity_access_permissions('bookit_option');

  return $permissions;
}

/**
 * Returns an array of booking option types.
 */
function bookit_option_types() {
  $option_types = &drupal_static(__FUNCTION__);

  if (!isset($option_types)) {
    $option_types = array();

    // Find option types defined by hook_bookit_option_type_info().
    foreach (module_implements('bookit_option_type_info') as $module) {
      foreach (module_invoke($module, 'bookit_option_type_info') as $type => $option_type) {
        $option_type += array(
          'module' => $module,
          'revision' => 1,
        );
        $option_types[$type] = $option_type;
      }
    }

    // Last allow the info to be altered by other modules.
    drupal_alter('bookit_option_type_info', $option_types);
  }

  return $option_types;
}

/**
 * Resets the cached list of option types.
 */
function bookit_option_types_reset() {
  $option_types = &drupal_static('bookit_option_types');
  $option_types = NULL;
  entity_info_cache_clear();
}

/**
 * Loads an option type.
 */
function bookit_option_type_load($type) {
  $type = strtr($type, array('-' => '_'));
  $option_types = bookit_option_types();
  return !empty($option_types[$type]) ? $option_types[$type] : FALSE;
}

/**
 * Returns an initialized option type array.
 */
function bookit_option_type_new() {
  return array(
    'type' => '',
    'name' => '',
    'description' => '',
    'help' => '',
    'revision' => 1,
  );
}

/**
 * Saves a booking option type.
 */
function bookit_option_type_save($option_type, $configure = TRUE, $skip_reset = FALSE) {
  $op = drupal_write_record('bookit_option_type', $option_type, empty($option_type['is_new']) ? 'type' : array());

  // If this is a new option type and the insert did not fail...
  if (!empty($option_type['is_new']) && $op !== FALSE) {
    // Notify the field API that a new bundle has been created.
    field_attach_create_bundle('bookit_option', $option_type['type']);

    // Notify other modules that a new option type has been created.
    module_invoke_all('bookit_option_type_insert', $option_type, $skip_reset);
  }
  elseif ($op !== FALSE) {
    // Notify other modules that an existing option type has been updated.
    module_invoke_all('bookit_option_type_update', $option_type, $skip_reset);
  }

  // Rebuild the menu to add this option type's menu items.
  if (!$skip_reset) {
    bookit_option_types_reset();
    variable_set('menu_rebuild_needed', TRUE);
  }

  return $op;
}

/**
 * Deletes a booking option type.
 */
function bookit_option_type_delete($type, $skip_reset = FALSE) {
  $option_type = bookit_option_type_load($type);

  db_delete('bookit_option_type')
    ->condition('type', $type)
    ->execute();

  // Rebuild the menu to get rid of this product type's menu items.
  if (!$skip_reset) {
    bookit_option_types_reset();
    variable_set('menu_rebuild_needed', TRUE);
  }

  // Notify the field API that this bundle has been destroyed.
  field_attach_delete_bundle('bookit_option', $type);

  // Notify other modules that this option type has been deleted.
  module_invoke_all('bookit_option_type_delete', $option_type, $skip_reset);
}

/**
 * Returns the human readable name of any or all booking option types.
 */
function bookit_option_type_get_name($type = NULL) {
  $option_types = bookit_option_types();

  // Return a type name if specified and it exists.
  if (!empty($type)) {
    if (isset($option_types[$type])) {
      return $option_types[$type]['name'];
    }
    else {
      // Return FALSE if it does not exist.
      return FALSE;
    }
  }

  // Otherwise turn the array values into the type name only.
  $option_type_names = array();

  foreach ($option_types as $key => $value) {
    $option_type_names[$key] = $value['name'];
  }

  return $option_type_names;
}

/**
 * Entity uri callback.
 */
function bookit_option_uri($bookit_option) {
  // If user has access to update the option.
  if (bookit_option_access('update', $bookit_option)) {
    return array(
      'path' => 'admin/bookit/config/options/' . $bookit_option->option_id,
    );
  }

  return NULL;
}

/**
 * Returns an initialized booking option object.
 */
function bookit_option_new($type = '') {
  return entity_get_controller('bookit_option')->create(array('type' => $type));
}

/**
 * Saves a booking option.
 */
function bookit_option_save($bookit_option) {
  return entity_get_controller('bookit_option')->save($bookit_option);
}

/**
 * Deletes a booking option.
 */
function bookit_option_delete($option_id) {
  return bookit_option_delete_multiple(array($option_id));
}

/**
 * Deletes a booking option.
 */
function bookit_option_delete_multiple($option_ids) {
  return entity_get_controller('bookit_option')->delete($option_ids);
}

/**
 * Loads a booking option by ID.
 */
function bookit_option_load($option_id) {
  if (!isset($option_id)) {
    return FALSE;
  }

  $bookit_options = bookit_option_load_multiple(array($option_id), array());
  return $bookit_options ? reset($bookit_options) : FALSE;
}

/**
 * Loads multiple options by ID or based on a set of matching conditions.
 */
function bookit_option_load_multiple($option_ids = array(), $conditions = array(), $reset = FALSE) {
  if (empty($option_ids) && empty($conditions)) {
    return array();
  }

  return entity_load('bookit_option', $option_ids, $conditions, $reset);
}

/**
 * Checks booking option access for various operations.
 */
function bookit_option_access($op, $bookit_option = NULL, $account = NULL) {
  // Use commerce's entity access implementation.
  return commerce_entity_access($op, $bookit_option, $account, 'bookit_option');
}

/**
 * Implements hook_bookit_option_type_info().
 */
function bookit_option_bookit_option_type_info() {
  return db_query('SELECT * FROM {bookit_option_type}')->fetchAllAssoc('type', PDO::FETCH_ASSOC);
}

/**
 * Access callback.
 */
function bookit_option_add_any_access() {
  // Grant automatic access to users with administer options permission.
  if (user_access('administer bookit_option entities')) {
    return TRUE;
  }

  // Check the user's access on a booking option type basis.
  foreach (bookit_option_types() as $type => $option_type) {
    if (bookit_option_access('create', bookit_option_new($type))) {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Access callback: determines if the user can edit or delete an option type.
 */
function bookit_option_type_update_access($type) {
  $option_type = bookit_option_type_load($type);

  if ($option_type['module'] == 'bookit_option') {
    return user_access('administer bookit_option types');
  }

  return FALSE;
}

/**
 * Menu item title callback.
 */
function bookit_option_option_title($bookit_option) {
  return t('Booking Option: @title', array('@title' => $bookit_option->title));
}

/**
 * Implements hook_theme().
 */
function bookit_option_theme() {
  return array(
    'option_add_list' => array(
      'variables' => array('content' => array()),
      'file' => 'includes/bookit_option.pages.inc',
    ),
    'option_type_admin_overview' => array(
      'variables' => array('type' => NULL),
      'file' => 'includes/bookit_option.pages.inc',
    ),
  );
}

/**
 * Implements hook_field_extra_fields().
 */
function bookit_option_field_extra_fields() {
  $extra = &drupal_static(__FUNCTION__);

  if (!isset($extra)) {
    foreach (bookit_option_types() as $type => $option_type) {
      $extra['bookit_option'][$type] = array(
        'form' => array(
          'title' => array(
            'label' => t('Title'),
            'description' => t('Booking option title form element'),
            'weight' => -5,
          ),
        ),
        'display' => array(
          'title' => array(
            'label' => t('Title'),
            'description' => t('Full booking option title'),
            'weight' => -5,
          ),
          'status' => array(
            'label' => t('Status'),
            'description' => t('Whether the booking option is active or disabled'),
            'weight' => 5,
          ),
        ),
      );
    }
  }

  return $extra;
}

/**
 * Implements hook_views_api().
 */
function bookit_option_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'bookit_option') . '/includes/views',
  );
}

/**
 * Implementation of hook_entity_property_info().
 */
function bookit_option_entity_property_info() {
  $info = array();

  // Add meta-data about the basic bookit_option properties.
  $properties = &$info['bookit_option']['properties'];

  $properties['option_id'] = array(
    'label' => t('Option ID'),
    'description' => t('The primary identifier for a booking option.'),
    'type' => 'integer',
    'schema field' => 'option_id',
  );

  $properties['type'] = array(
    'label' => t('Type'),
    'description' => t('The type of this booking option.'),
    'type' => 'token',
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer bookit_option entities',
    'required' => TRUE,
    'schema field' => 'type',
  );
  $properties['title'] = array(
    'label' => t('Title'),
    'description' => t('The title of the option.'),
    'type' => 'text',
    'setter callback' => 'entity_property_verbatim_set',
    'required' => TRUE,
    'schema field' => 'title',
  );
  $properties['language'] = array(
    'label' => t('Language'),
    'type' => 'token',
    'description' => t('The language the booking option was created in.'),
    'setter callback' => 'entity_property_verbatim_set',
    'options list' => 'entity_metadata_language_list',
    'schema field' => 'language',
    'setter permission' => 'administer bookit_option entities',
  );
  $properties['created'] = array(
    'label' => t('Date created'),
    'description' => t('The date the booking option was created.'),
    'type' => 'date',
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer bookit_option entities',
    'schema field' => 'created',
  );
  $properties['changed'] = array(
    'label' => t('Date updated'),
    'description' => t('The date the booking option was most recently updated.'),
    'type' => 'date',
    'setter callback' => 'entity_property_verbatim_set',
    'query callback' => 'entity_metadata_table_query',
    'setter permission' => 'administer bookit_option entities',
    'schema field' => 'changed',
  );
  $properties['uid'] = array(
    'label' => t('Creator ID'),
    'type' => 'integer',
    'description' => t('The unique ID of the booking option creator.'),
    'setter callback' => 'entity_property_verbatim_set',
    'setter permission' => 'administer bookit_option entities',
    'clear' => array('creator'),
    'schema field' => 'uid',
  );
  $properties['creator'] = array(
    'label' => t('Creator'),
    'type' => 'user',
    'description' => t('The creator of the booking option.'),
    'setter permission' => 'administer bookit_option entities',
    'required' => TRUE,
    'computed' => TRUE,
    'clear' => array('uid'),
  );

  $info['bookit_option']['bundles'] = array();
  foreach (bookit_option_type_get_name() as $type => $name) {
    $info['bookit_option']['bundles'][$type] = array(
      'label' => $name,
    );
  }

  return $info;
}

/**
 * Implements hook_field_attach_update().
 */
function bookit_option_field_attach_update($entity_type, $entity) {
  if ($entity_type == 'bookit_item') {
    list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);

    $options_original = array();
    $options = array();
    foreach (field_info_instances($entity_type, $bundle) as $instance) {
      $field = field_info_field($instance['field_name']);

      // If references booking option.
      if ($field['type'] == 'entityreference' and $field['settings']['target_type'] == 'bookit_option') {
        $field_name = $instance['field_name'];

        if (!empty($entity->original->{$field_name})) {
          foreach ($entity->original->{$field_name}[LANGUAGE_NONE] as $item) {
            $options_original[] = $item['target_id'];
          }
        }

        if (!empty($entity->{$field_name})) {
          foreach ($entity->{$field_name}[LANGUAGE_NONE] as $item) {
            $options[] = $item['target_id'];
          }
        }
      }
    }

    if (!empty($options_original)) {
      // Get deleted options.
      $delete_options = array_diff($options_original, $options);

      // Delete option prices for the deleted options.
      foreach ($delete_options as $option_id) {
        db_delete('bookit_option_price')
          ->condition('option_id', $option_id)
          ->condition('item_id', $id)
          ->execute();
      }

      // If default option changed the reset the default prices.
      $default_option_id_original = reset($options_original);
      $default_option_id = reset($options);

      if ($default_option_id_original != $default_option_id) {
        // First delete the old default values.
        db_delete('bookit_price')
          ->condition('item_id', $id)
          ->execute();

        // Insert the new default option's values from the option_price table.
        $query = db_select('bookit_option_price', 'o')
          ->fields('o', array('item_id', 'date', 'amount', 'currency_code', 'data'))
          ->condition('o.item_id', $id)
          ->condition('o.option_id', $default_option_id);

        db_insert('bookit_price')
          ->from($query)
          ->execute();
      }
    }
  }
}

/**
 * Implements hook_entity_delete().
 */
function bookit_option_entity_delete($entity, $entity_type) {
  if ($entity_type == 'bookit_item') {
    list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);

    // If bookable item deleted then delete all bookit_option_price rows.
    db_delete('bookit_option_price')
      ->condition('item_id', $id)
      ->execute();
  }
}

/**
 * Implements hook_form_alter().
 */
function bookit_option_form_bookit_calendar_admin_form_alter(&$form, &$form_state) {
  $bookit_item = $form_state['bookit_item'];

  // Get default currency code.
  $currency_code = commerce_default_currency();

  // Load bookable item's option ids.
  $option_ids = array();
  foreach (commerce_info_fields('entityreference') as $field_name => $field) {
    if($field['settings']['target_type'] == 'bookit_option' and isset($bookit_item->{$field_name}) and !empty($bookit_item->{$field_name})) {
      foreach($bookit_item->{$field_name}[LANGUAGE_NONE] as $item) {
        $option_ids[] = $item['target_id'];
      }
    }
  }

  // Load options.
  $options = bookit_option_load_multiple($option_ids);

  foreach (element_children($form['calendar']) as $day) {
    foreach (array_values($options) as $i => $option) {
      // The first option is always the default price.
      if ($i == 0) {
        $form['calendar'][$day]['bookit_price']['#heading'] = t('@title (Default option)', array('@title' => $option->title));

        $form['calendar'][$day]['bookit_price']['option_id'] = array(
          '#type' => 'value',
          '#value' => $option->option_id,
        );
        continue;
      }

      // If not the first option then add price fields foreach options.
      $option_price_key = 'bookit_price_' . $option->option_id;

      // Price input.
      $form['calendar'][$day][$option_price_key]['#weight'] = $i + 10;
      $form['calendar'][$day][$option_price_key]['#element_validate'][] = 'commerce_price_field_widget_validate';
      $form['calendar'][$day][$option_price_key]['#title'] = t('Price (@currency_code)', array('@currency_code' => $currency_code));
      $form['calendar'][$day][$option_price_key]['#heading'] = $option->title;

      $form['calendar'][$day][$option_price_key]['amount'] = array(
        '#type' => 'textfield',
        '#date' => $form['calendar'][$day]['#date'],
        '#default_value' => '',
        '#size' => 4,
      );

      // Currency code.
      $form['calendar'][$day][$option_price_key]['currency_code'] = array(
        '#type' => 'value',
        '#value' => $currency_code,
      );

      // Option id.
      $form['calendar'][$day][$option_price_key]['option_id'] = array(
        '#type' => 'value',
        '#value' => $option->option_id,
      );

      // Get default price for a date.
      $price = db_select('bookit_option_price', 'o')
        ->fields('o', array('amount', 'currency_code'))
        ->condition('o.item_id', $bookit_item->item_id)
        ->condition('o.date', $form['calendar'][$day]['#date'])
        ->condition('o.option_id', $option->option_id)
        ->execute()
        ->fetchAssoc();

      if (!empty($price['amount'])) {
        $currency = commerce_currency_load($price['currency_code']);

        // Convert the price amount to a user friendly decimal value.
        $default_amount = commerce_currency_amount_to_decimal($price['amount'], $currency['code']);

        // Run it through number_format() to ensure it has the proper number of
        // decimal places.
        $default_amount = number_format($default_amount, $currency['decimals'], '.', '');

        $form['calendar'][$day][$option_price_key]['amount']['#default_value'] = $default_amount;
        $form['calendar'][$day][$option_price_key]['currency_code']['#value'] = $price['currency_code'];
      }
    }
  }

  $form['#submit'][] = 'bookit_option_bookit_calendar_admin_form_submit';
}

/**
 * Submit callback for bookit_calendar_admin_form.
 */
function bookit_option_bookit_calendar_admin_form_submit($form, &$form_state) {
  $bookit_item = $form_state['bookit_item'];
  $currency_code = commerce_default_currency();

  // Foreach day.
  foreach ($form_state['values']['calendar'] as $day => $values) {

    // Foreach option price field.
    foreach ($values as $field_name => $value) {

      // If booking option price fields.
      if (strstr($field_name, "bookit_price") and isset($value['option_id'])) {

        // Save the booking option price.
        db_merge('bookit_option_price')
        ->key(array(
          'item_id' => $bookit_item->item_id,
          'option_id' => $value['option_id'],
          'date' => $form['calendar'][$day]['#date'],
        ))
        ->fields(array(
          'item_id' => $bookit_item->item_id,
          'option_id' => $value['option_id'],
          'date' => $form['calendar'][$day]['#date'],
          'amount' => (int) $value['amount'],
          'currency_code' => isset($value['currency_code']) ? $value['currency_code'] : $currency_code,
          'data' => serialize(array()),
        ))
        ->execute();
      }
    }
  }
}

/**
 * Implements hook_commerce_cart_product_comparison_properties_alter().
 */
function bookit_option_commerce_cart_product_comparison_properties_alter(&$comparison_properties, $line_item) {
  if($line_item->type == 'bookit' and isset($line_item->bookit_option)) {
    $comparison_properties[] = 'bookit_option';
  }
}

/**
 * Calculates price by option.
 */
function bookit_option_price_calculate_amount($line_item) {
  module_load_include('inc', 'bookit_price', 'bookit_price.rules');

  // If line item has option selected.
  if (isset($line_item->bookit_option[LANGUAGE_NONE][0]['target_id'])) {
    $wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);

    $bookit_item = $wrapper->bookit_item->value();
    $date = $wrapper->bookit_date->value();
    $min = _bookit_calendar_create_date_from_datetime($date['value']);
    $max = _bookit_calendar_create_date_from_datetime($date['value2']);

    $query = db_select('bookit_option_price', 'p')
      ->condition('p.item_id', $bookit_item->item_id)
      ->condition('p.option_id', $line_item->bookit_option[LANGUAGE_NONE][0]['target_id'])
      ->condition('p.date', $min, '>=')
      ->condition('p.date', $max, '<');
    $query->addExpression('SUM(p.amount)');
    $price = $query->execute()->fetchField();

    $unit_price = $wrapper->commerce_unit_price->value();
    $unit_price['amount'] += $price;

    // Reset base price component.
    $unit_price['data'] = array();
    $unit_price['data'] = commerce_price_component_add($unit_price, 'base_price', $unit_price, TRUE);

    $wrapper->commerce_unit_price = $unit_price;
  }
  else {
    bookit_price_calculate_amount($line_item);
  }
}
