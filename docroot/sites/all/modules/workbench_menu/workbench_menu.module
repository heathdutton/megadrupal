<?php

/**
 * @file
 * Module file for the workbench menu project.
 */

/**
 * Implements hook_help().
 */
function workbench_menu_help($path, $arg) {
  $output = '';

  switch ($path) {
    case "admin/help#workbench_menu":
      $output .= '<p>' . t("This module provides an alternative menuing system to the one provided by drupal. This utilizes the access control system provided by workbench_access. The only access type supported at this time is taxonomy.") . '</p>';
      return $output;
  }
}

/**
 * Implements hook_permission().
 */
function workbench_menu_permission() {
  $permissions = array();

  $permissions['edit workbench menu'] = array(
    'title' => t("Edit Workbench Menu"),
    'description' => t("Grants permissions to alter any workbench menus in which a user is in the workbench access section associated with that menu."),
  );

  $permissions['change workbench menu path'] = array(
    'title' => t("Change Workbench Menu Path"),
    'description' => t("Grants permissions to alter the menu path or related settings for any workbench menus in which a user is able to edit."),
  );

  $permissions['change workbench menu breadcrumb'] = array(
    'title' => t("Change Workbench Menu Breadcrumb"),
    'description' => t("Grants permissions to alter the menu breadcrumb or related settings for any workbench menus in which a user is able to edit."),
  );

  $permissions['change workbench menu parent'] = array(
    'title' => t("Change Workbench Menu Parent"),
    'description' => t("Grants permissions to alter the menu parent related settings for any workbench menus in which a user is able to edit."),
  );

  $permissions['change workbench menu hidden'] = array(
    'title' => t("Change Workbench Menu Hidden"),
    'description' => t("Grants permissions to alter the menu hidden related settings for any workbench menus in which a user is able to edit."),
  );

  $permissions['change workbench menu alias'] = array(
    'title' => t("Change Workbench Menu Alias"),
    'description' => t("Grants permissions to alter the menu alias or related settings for any workbench menus in which a user is able to edit."),
  );

  $permissions['change workbench menu item active path'] = array(
    'title' => t("Change Workbench Menu Item Active Path"),
    'description' => t("Grants permissions to alter the active path for any menu item in which a user is able to edit."),
  );

  $permissions['administer workbench menu'] = array(
    'title' => t("Administer Workbench Menu"),
    'description' => t("Grants permissions to alter all workbench menus and perform administrative tasks."),
  );

  $permissions['use advanced workbench menu item types'] = array(
    'title' => t("Use Advanced Item Types"),
    'description' => t("Grants permissions to assign or unassign advanced item types used on a given menu."),
  );

  return $permissions;
}

/**
 * Implements hook_entity_info().
 */
function workbench_menu_entity_info() {
  $types = array();

  $types['workbench_menu'] = array(
    'label' => t('Workbench menu'),
    'base table' => 'workbench_menus',
    'controller class' => 'WorkbenchMenuController',
    'fieldable' => FALSE,
    'entity keys' => array(
      'id' => 'id',
    ),
  );

  $types['workbench_menu_item'] = array(
    'label' => t('Workbench menu item'),
    'base table' => 'workbench_menu_items',
    'controller class' => 'WorkbenchMenuItemController',
    'fieldable' => FALSE,
    'entity keys' => array(
      'id' => 'id',
    ),
  );

  return $types;
}

/**
 * Implements hook_menu().
 */
function workbench_menu_menu() {
  $items = array();

  $items['admin/config/workbench/access/menus'] = array(
    'title' => "Menus",
    'description' => "Settings for workbench menus.",
    'page callback' => 'workbench_menu_admin_settings',
    'file' => 'workbench_menu.admin.inc',
    'file path' => drupal_get_path('module', 'workbench_menu') . '/includes',
    'access callback' => 'user_access',
    'access arguments' => array('administer workbench menu'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 5,
  );

  $items['admin/config/workbench/access/menus/%/%/items'] = array(
    'title' => "Menu Items",
    'description' => "Settings for workbench menus items.",
    'page callback' => 'workbench_menu_admin_item_settings',
    'page arguments' => array(5, 6),
    'file' => 'workbench_menu.admin.inc',
    'file path' => drupal_get_path('module', 'workbench_menu') . '/includes',
    'access callback' => 'user_access',
    'access arguments' => array('administer workbench menu'),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 6,
  );

  $items['admin/workbench/menus'] = array(
    'title' => "My Menus",
    'description' => "Settings for workbench menus you have access to alter.",
    'page callback' => 'workbench_menu_edit_settings',
    'file' => 'workbench_menu.admin.inc',
    'file path' => drupal_get_path('module', 'workbench_menu') . '/includes',
    'access callback' => 'workbench_menu_edit_access',
    'access arguments' => array(3, 4),
    'type' => MENU_LOCAL_TASK,
    'weight' => 5,
  );

  $items['admin/workbench/menus/%/%/items'] = array(
    'title' => "Menu Items",
    'description' => "Settings for workbench menus items.",
    'page callback' => 'workbench_menu_edit_item_settings',
    'page arguments' => array(3, 4),
    'file' => 'workbench_menu.admin.inc',
    'file path' => drupal_get_path('module', 'workbench_menu') . '/includes',
    'access callback' => 'workbench_menu_edit_access',
    'access arguments' => array(3, 4),
    'type' => MENU_NORMAL_ITEM,
    'weight' => 6,
  );

  $items['workbench_menu/autocomplete_nid'] = array(
    'title' => '',
    'page callback' => 'workbench_menu_autocomplete_nid',
    'access callback' => 'workbench_menu_edit_access',
    'type' => MENU_CALLBACK,
  );

  $items['workbench_menu/autocomplete_fid'] = array(
    'title' => '',
    'page callback' => 'workbench_menu_autocomplete_fid',
    'access callback' => 'workbench_menu_edit_access',
    'type' => MENU_CALLBACK,
  );

  $items['workbench_menu/autocomplete_menu_id'] = array(
    'title' => '',
    'page callback' => 'workbench_menu_autocomplete_menu_id',
    'access callback' => 'workbench_menu_edit_access',
    'type' => MENU_CALLBACK,
  );

  $items['workbench_menu/autocomplete_menu_item_id'] = array(
    'title' => '',
    'page callback' => 'workbench_menu_autocomplete_menu_item_id',
    'access callback' => 'workbench_menu_edit_access',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements hook_workbench_access_save().
 */
function workbench_menu_workbench_access_save($section) {
  if (variable_get('workbench_access', 'taxonomy') != 'taxonomy') {
    return;
  }

  if (!cf_is_integer($section['access_id'])) {
    return;
  }

  $fields = array();
  $fields['access_id'] = $section['access_id'];
  $fields['path'] = '';

  // mysql does not assign defaults on text fields, so fix that.
  // @see: https://drupal.org/node/2063539
  if (db_driver() == 'mysql') {
    $fields['breadcrumb_name'] = '';
  }

  $query = db_insert('workbench_menus');
  $query->fields($fields);
  $query->execute();
}

/**
 * Implements hook_workbench_access_delete().
 */
function workbench_menu_workbench_access_delete($section) {
  if (variable_get('workbench_access', 'taxonomy') != 'taxonomy') {
    return;
  }

  if (!cf_is_integer($section['access_id'])) {
    return;
  }

  $query = db_select('workbench_menus', 'wm');
  $query->fields('wm', array('id', 'access_id'));
  $query->condition('wm.access_id', $section['access_id']);

  $records = (array) $query->execute()->fetchAll();

  if (empty($records)) {
    return;
  }

  foreach ($records as &$record) {
    $query = db_delete('workbench_menu_items');
    $query->condition('menu_id', $record->id);
    $query->execute();

    $query = db_delete('workbench_menus');
    $query->condition('id', $record->id);
    $query->execute();
  }
}

/**
 * Implements hook_theme().
 */
function workbench_menu_theme($existing, $type, $theme, $path) {
  $themes = array();

  $themes['workbench_menu_admin_settings_form'] = array(
    'render element' => 'form',
    'file' => 'workbench_menu.admin.inc',
    'path' => drupal_get_path('module', 'workbench_menu') . '/includes',
  );

  $themes['workbench_menu_settings_table'] = array(
    'file' => 'workbench_menu.admin.inc',
    'template' => 'workbench_menu_settings_table',
    'variables' => array(
      'table' => array(),
      'add_path' => '',
    ),
    'path' => drupal_get_path('module', 'workbench_menu') . '/includes',
  );

  $themes['workbench_menu_edit_settings_form'] = array(
    'render element' => 'form',
    'file' => 'workbench_menu.admin.inc',
    'path' => drupal_get_path('module', 'workbench_menu') . '/includes',
  );

  $list = array();
  $list['items'] = '';
  $list['title'] = '';
  $list['attributes'] = array();

  $themes['workbench_menu_list'] = array(
    'template' => 'workbench_menu_list',
    'variables' => array(
      'list' => $list,
      'data' => array(),
      'child' => FALSE,
    ),
    'path' => drupal_get_path('module', 'workbench_menu') . '/includes',
  );

  $data = array();
  $data['id'] = 0;
  $data['menu_id'] = 0;
  $data['menu_count'] = 0;
  $data['even_menu'] = FALSE;
  $data['settings'] = array();
  $data['even_item'] = TRUE;
  $data['count_item'] = 0;
  $data['even_item_local'] = TRUE;
  $data['count_item_local'] = 0;
  $data['depth'] = 0;
  $data['trail_is_active'] = FALSE;
  $data['path_current'] = array('original' => '', 'normal' => '', 'alias' => '');

  $themes['workbench_menu_item'] = array(
    'template' => 'workbench_menu_item',
    'variables' => array(
      'data' => $data,
    ),
    'path' => drupal_get_path('module', 'workbench_menu') . '/includes',
  );

  return $themes;
}

/**
 * Implements hook_block_info().
 */
function workbench_menu_block_info() {
  $blocks = array();

  $blocks['workbench_menu_block'] = array(
    'info' => t("Workbench Menu"),
    'weight' => -1,
    'status' => 1,
    'region' => 'sidebar_first',
    'cache' => DRUPAL_NO_CACHE,
  );

  return $blocks;
}

/**
 * Implements hook_block_view().
 *
 * @see workbench_menu_process_path()
 */
function workbench_menu_block_view($delta = '') {
  $path_current = request_path();
  $alter_breadcrumb = TRUE;
  return workbench_menu_process_path($path_current, $alter_breadcrumb);
}

/**
 * Process and build the menus for a given path.
 *
 * @param string $url_path
 *   A string containing the url path of the menu to generate.
 *   This is relative to the site url.
 * @param bool $alter_breadcrumb
 *   Enable/Disable altering of the drupal breadcrumb.
 *
 * @return bool
 *   TRUE on success, FALSE otherwise.
 *
 * @see workbench_menu_build_menus()
 */
function workbench_menu_process_path($url_path, $alter_breadcrumb = FALSE) {
  $path_alias = drupal_get_path_alias($url_path);

  if (empty($path_alias)) {
    return array();
  }

  // build menus based on the alias path.
  $parts = explode('/', $path_alias);
  $paths = array();

  if (count($parts) == 0) {
    return array();
  }


  // Load the cached menus or to do the initial processing.
  $markup = array();
  $menu_cache_id = 'workbench_menu-menus_at-' . $parts[0];
  $breadcrumb_cache_id = 'workbench_menu-breadcrumbs_at-' . $parts[0];
  $menus_cached = &drupal_static($menu_cache_id, array());
  $breadcrumbs_cached = &drupal_static($breadcrumb_cache_id, array());
  $menus_processed = array();
  $save_cache = FALSE;
  $path_tree = array();
  $menu_markup = array();
  $menu_depth = -1;
  $menu_count = 0;
  $breadcrumb_tree = array();
  $path_string = array('original' => '', 'normal' => '', 'alias' => '');

  if ($cached_menu = cache_get($menu_cache_id, 'cache_menu')) {
    $menus_cached = $cached_menu->data;
    unset($cached_menu);
  }

  if ($cached_breadcrumb = cache_get($breadcrumb_cache_id, 'cache_menu')) {
    $breadcrumbs_cached = $cached_breadcrumb->data;
    unset($cached_breadcrumb);
  }


  $last_alias = FALSE;
  $menus_in_path = array();
  $path_trail = array();
  $path_trail_last_alias = array();
  foreach ($parts as &$part) {
    $path_string['original'] .= $part;
    $path_string['normal'] = drupal_get_normal_path($path_string['original']);
    $path_string['alias'] = drupal_get_path_alias($path_string['original']);

    $router_item = menu_get_item($path_string['original']);

    if (empty($router_item['page_callback']) && $path_string['original'] != $path_string['normal']) {
      $router_item = menu_get_item($path_string['normal']);
    }

    if (empty($router_item['page_callback']) && $path_string['original'] != $path_string['alias']) {
      $router_item = menu_get_item($path_string['alias']);
    }

    if (!empty($router_item['page_callback'])) {
      $path_trail[] = $path_string;
      $path_trail_last_alias[] = $path_string;

      if ($path_string['normal'] != $path_string['alias']) {
        $last_alias = $path_string['alias'];
        $path_trail_last_alias = array();
      }

      if (empty($menus_cached[$path_string['alias']])) {
        $menus_cached[$path_string['alias']] = (array) workbench_menu_build_menus($path_string['alias'], $menus_processed, $breadcrumbs_cached);

        if (isset($menus_cached[$path_string['alias']]['total']) && $menus_cached[$path_string['alias']]['total'] > 0) {
          $save_cache = TRUE;
        }
      }

      if (isset($menus_cached[$path_string['alias']]) && isset($menus_cached[$path_string['alias']]['total'])) {
        if ($menus_cached[$path_string['alias']]['total'] > 0) {
          $menus_in_path[] = $menus_cached[$path_string['alias']];
          $path_trail = array();
        }

        if (!empty($menus_cached[$path_string['alias']]['structure'])) {
          $path_tree[] = $path_string['original'];
          $menu_depth++;
        }
      }
    }

    $path_string['original'] .= '/';
  }


  // if there is no menu found, try to find a menu for the last alias in the path.
  if ($last_alias && $last_alias != $path_string['alias']) {
    $parts = explode('/', $last_alias);
    $path_string = array('original' => '', 'normal' => '', 'alias' => '');
    $path_tree = array();
    $menu_depth = -1;
    $path_trail = array();

    foreach ($parts as &$part) {
      $path_string['original'] .= $part;
      $path_string['normal'] = drupal_get_normal_path($path_string['original']);
      $path_string['alias'] = drupal_get_path_alias($path_string['original']);

      $path_trail[] = $path_string;

      if (empty($menus_cached[$path_string['alias']])) {
        $menus_cached[$path_string['alias']] = (array) workbench_menu_build_menus($path_string['alias'], $menus_processed, $breadcrumbs_cached);

        if (!empty($menus_cached[$path_string['alias']]['structure'])) {
          $save_cache = TRUE;
        }
      }

      if (isset($menus_cached[$path_string['alias']])) {
        if ($menus_cached[$path_string['alias']]['total'] > 0) {
          $menus_in_path[] = $menus_cached[$path_string['alias']];
          $path_trail = array();
        }

        if (!empty($menus_cached[$path_string['alias']]['structure'])) {
          $path_tree[] = $path_string['original'];
          $menu_depth++;
        }
      }

      $path_string['original'] .= '/';
    }
  }

  if ($save_cache) {
    cache_set($menu_cache_id, $menus_cached, 'cache_menu');
    cache_set($breadcrumb_cache_id, $breadcrumbs_cached, 'cache_menu');
  }

  $path_string['original'] = preg_replace('|/$|', '', $path_string['original']);
  $path_string['normal'] = drupal_get_normal_path($path_string['original']);
  $path_string['alias'] = drupal_get_path_alias($path_string['original']);
  $show_parents = TRUE;


  // when menus exist in the path, but no structure is defined, then determine the breadcrumb based off of the path alias.
  if ($alter_breadcrumb && empty($path_tree) && !empty($menus_in_path)) {
    $last_menu = end($menus_in_path);
    $last_menu_keys = array_keys($last_menu['breadcrumbs']);
    $breadcrumb = end($last_menu['breadcrumbs']);
    $breadcrumb_key = end($last_menu_keys);
    $bc = array();
    $bc[] = '<a href="' . base_path() . '">' . t("Home") . '</a>';
    $bc = array_merge($bc, $breadcrumb['built']);
    $bc_paths = array_merge(array(''), $breadcrumb['path']);

    foreach ($path_trail as $key => &$pt) {
      $item = menu_get_item($pt['normal']);
      $last = end($bc_paths);

      if ($last == $item['href']) break;

      if (isset($item['title']) && isset($item['href'])) {
        $bc[] = '<a href="' . base_path() . $item['href'] . '">' . $item['title'] . '</a>';
        $bc_paths[] = $item['href'];
      }
    }

    foreach ($path_trail_last_alias as $key => &$pt) {
      $item = menu_get_item($pt['normal']);
      $last = end($bc_paths);

      if ($last == $item['href']) break;

      if (isset($item['title']) && isset($item['href'])) {
        $bc[] = '<a href="' . base_path() . $item['href'] . '">' . $item['title'] . '</a>';
        $bc_paths[] = $item['href'];
      }
    }

    drupal_set_breadcrumb($bc);
  }

  while (!empty($path_tree) && $show_parents) {
    $current_path = array();
    $current_path['original'] = array_pop($path_tree);
    $current_path['normal'] = drupal_get_normal_path($current_path['original']);
    $current_path['alias'] = drupal_get_path_alias($current_path['original']);

    $additional = array();
    $additional['menu_depth'] = $menu_depth;
    $additional['menu_count'] = $menu_count;
    $additional['path_trail'] = $path_trail;
    $additional['path_trail_last_alias'] = $path_trail_last_alias;
    $additional['alter_breadcrumb'] = $alter_breadcrumb;

    if (!empty($menus_cached[$current_path['alias']]['structure'])) {
      $data = workbench_menu_render_menus($menus_cached[$current_path['alias']], $path_string, $show_parents, $additional);

      foreach ($data as $key => &$value) {
        if (isset($menu_markup[$key])) {
          $menu_markup[$key] .= $value;
        }
        else {
          $menu_markup[$key] = $value;
        }
      }
    }

    $menu_depth--;
    $menu_count++;
  }

  if (empty($menu_markup)) {
    return array();
  }

  $module_path = drupal_get_path('module', 'workbench_menu');

  $block = array();
  $block['subject'] = '';
  $block['content'] = array(
    '#markup' => implode(' ', $menu_markup),
    '#attached' => array(
      'css' => array($module_path . '/includes/workbench_menu.css'),
      'js' => array($module_path . '/includes/workbench_menu.js'),
    ),
  );

  return $block;
}

/**
 * Process and build the menus for a given path.
 *
 * This is a recursive function.
 *
 * @param string $path_string
 *   A string containing the url path of the menu to generate.
 * @param array $menus_processed
 *   An array of menu ids defining which menus have already been
 *   processed.
 * @param array|false $breadcrumbs
 *   An array of breadcrumbs that will be auto populated by this
 *   function.
 *   Each array key will be the path in which a given array of
 *   breadcrumbs relate to.
 *   If FALSE, then breadcrumbs will not be populated.
 * @param bool $skip_hidden
 *   When set to TRUE (default), the hidden menus are skipped.
 *   When set to FALSE, hidden menus are built.
 *
 * @return array
 *   An array with the following structure:
 *   - structure: A nested array containing the weights and item ids.
 *   - settings: A flat array containing the properties of each item.
 *   - total: Number of menus found along the path.
 *   - breadcrumbs: A flat array of menu paths and their breadcrumbs.
 *
 * @see drupal_set_breadcrumb()
 */
function workbench_menu_build_menus($path_string, &$menus_processed, &$breadcrumbs, $skip_hidden = TRUE) {
  $menus = (array) workbench_menu_get_menus(array('path' => array($path_string)), 'id');

  $menu_even = TRUE;
  $menu_total = count($menus);
  $menu_current = 0;

  $built_menus = array();
  $built_menus['structure'] = array();
  $built_menus['menus'] = array();
  $built_menus['total'] = $menu_total;
  $built_menus['breadcrumbs'] = array('built' => array(), 'path' => array());

  foreach ($menus as $menu_id => &$menu) {
    if ($skip_hidden && $menu->hidden) {
      continue;
    }

    $menus_processed[$menu->id] = NULL;

    // replace the current menu with its menu alias.
    if (!empty($menu->alias) && cf_is_integer($menu->alias)) {
      $aliased_menus = workbench_menu_get_menus(array('id' => array($menu->alias)), 'id');

      $menu_id = $menu->alias;
      $menu = array_pop($aliased_menus);

      $menus_processed[$menu->id] = NULL;
    }

    $built_menu = array();
    $built_menu['structure'] = array();
    $built_menu['settings'] = array();
    $built_menu['id'] = $menu->id;
    $built_menu['access_id'] = $menu->access_id;
    $built_menu['path'] = $menu->path;
    $built_menu['weight'] = $menu->weight;
    $built_menu['show_parents'] = $menu->show_parents;
    $built_menu['breadcrumb_name'] = $menu->breadcrumb_name;

    $variables = array();
    $variables['menus_processed'] = &$menus_processed;
    $variables['use_normal_path'] = variable_get('workbench_menu_item_use_normal_path', FALSE);

    if ($breadcrumbs === FALSE) {
      $variables['breadcrumbs_all'] = FALSE;
    }
    else {
      $variables['breadcrumbs_all'] = &$breadcrumbs;
    }


    $menu_path_normal = drupal_get_normal_path($menu->path);
    $menu_path_alias = drupal_get_path_alias($menu->path);

    if ($variables['use_normal_path']) {
      $path_to_use = $menu_path_normal;
    }
    else {
      $path_to_use = $menu_path_alias;
    }

    $bc_path = check_plain($path_to_use);
    $top_level = array('<a href="' . base_path() . $bc_path . '" class="workbench_menu-breadcrumb">' . $menu->breadcrumb_name . '</a>');
    $breadcrumbs[$menu_path_normal] = array();
    $breadcrumbs[$menu_path_normal]['built'] = $top_level;
    $breadcrumbs[$menu_path_normal]['path'] = array($bc_path);
    unset($path_to_use);

    if (empty($menu->items['nested'])) {
      $built_menus['breadcrumbs'][$menu_path_normal] = $breadcrumbs[$menu_path_normal];
      $menu_total--;
      continue;
    }

    foreach ($menu->items['nested'] as &$item) {
      $variables['parent_path'] = array();
      $variables['parent_path']['original'] = $menu->path;
      $variables['parent_path']['normal'] = $menu_path_normal;
      $variables['parent_path']['alias'] = $menu_path_alias;
      $variables['menu_path'] = array();
      $variables['menu_path']['original'] = $menu->path;
      $variables['menu_path']['normal'] = $menu_path_normal;
      $variables['menu_path']['alias'] = $menu_path_alias;
      $variables['breadcrumbs'] = array();
      $variables['breadcrumbs']['built'] = $top_level;
      $variables['breadcrumbs']['path'] = array($bc_path);

      $data = workbench_menu_build_menu_item($menu, $item, $variables);

      foreach ($data['structure'] as $weight_id => &$weight_data) {
        foreach ($weight_data as $weight_data_id => $weight_data_data) {
          $built_menu['structure'][$weight_id][$weight_data_id] = $weight_data_data;
        }
      }

      foreach ($data['settings'] as $child_id => &$child_settings) {
        $built_menu['settings'][$child_id] = $child_settings;
      }

      $built_menus['structure'][$menu->weight][$menu->id] = $built_menu;
      $built_menus['breadcrumbs'][$menu_path_normal] = $breadcrumbs[$menu_path_normal];
    }
  }

  return $built_menus;
}

/**
 * Process and build the menu items.
 *
 * @param object $menu
 *   A menu object as returned by workbench_menu_get_menus().
 * @param array $item
 *   A menu item as stored in $menu->items['nested'].
 * @param array $variables
 *   An array containing the following keys:
 *   - 'menus_processed': An array containing menu access ids whose
 *   array keys are the menu ids.
 *   - 'breadcrumbs_all':
 *   An array of breadcrumbs whose keys are path strings or FALSE.
 *   If it is FALSE, then breadcrumbs will not be processed.
 *   - 'parent_path': An array of strings with the following structure:
 *     - 'original': the unchanged parent path string.
 *     - 'normal': the normalized parent path string.
 *     - 'alias': the alias for the parent path string.
 *     The 'normal' and 'alias' are created by this function.
 *   - 'breadcrumbs': A breadcrumb array associated with this menu
 *   item.
 *   It is structured such that it can be directly passed to
 *   drupal_set_breadcrumb().
 *
 * @return array
 *   An array with the following structure:
 *   - structure: A nested array containing the weights and item ids.
 *   - settings: A flat array containing the properties of each item.
 *
 * @see workbench_menu_get_menus()
 * @see drupal_set_breadcrumb()
 */
function workbench_menu_build_menu_item($menu, $item, &$variables) {
  $built_menu = array();
  $item_id = & $item['item']->id;

  // menu items with a null parent_id are disabled.
  if (is_null($item['item']->parent_id)) {
    return array('structure' => array(), 'settings' => array());
  }

  $structure = array();
  $structure[$item['item']->weight] = array($item_id => array());

  $settings = array();
  $settings[$item_id] = array();

  $item_settings = & $settings[$item_id];

  $item_settings['type'] = '';
  $item_settings['expand'] = 'expand_auto';
  $item_settings['label'] = check_plain($item['item']->human_name);
  $item_settings['attributes'] = array();
  $item_settings['attributes']['class'] = array();
  $item_settings['attributes']['class'][] = 'menu_item';
  $item_settings['attributes']['class'][] = 'menu_item-id-' . $item_id;
  $item_settings['prefix'] = '';
  $item_settings['postfix'] = '';
  $item_settings['outside_link'] = FALSE;
  $item_settings['top_link'] = FALSE;
  $item_settings['active_path'] = array('original' => '', 'normal' => '', 'alias' => '');
  $item_settings['breadcrumbs'] = array('built' => array(), 'path' => array());
  $item_settings['suppress_active'] = FALSE;

  $process_children = TRUE;
  $no_breadcrumb = FALSE;

  foreach ($item['item']->item_type as &$type) {
    $item_settings['type'] = $type->machine_name;
    $item_settings['attributes']['class'][] = 'menu_item-type-' . $type->machine_name;
    break;
  }

  foreach ($item['item']->expand as &$expand) {
    $item_settings['expand'] = $expand->machine_name;
    $item_settings['attributes']['class'][] = 'menu_item-expand-' . $expand->machine_name;
    break;
  }

  $active_path['original'] = preg_replace('/%20/', ' ', $item['item']->active_path);


  // initialize menu_path top as variable.
  $top_as = 'menu_path';
  if (isset($item['item']->properties['top_as'])) {
    $top_as = $item['item']->properties['top_as'];
  }


  $alter_settings = array();
  $alter_settings['menu'] = clone($menu);
  $alter_settings['item'] = $item;
  $alter_settings['settings'] = &$item_settings;
  $alter_settings['active_path']= &$active_path;
  $alter_settings['variables'] = &$variables;


  // menu item menus are other menus embedded inside the current menu.
  if ($item_settings['type'] == 'item_menu') {
    $field = & $item['item']->properties['menu'];
    $item_menus = array();

    // do not allow menu item types that point to its own menu.
    if ($item['item']->properties['menu'] == $menu->id) {
      return array('structure' => array(), 'settings' => array());
    }

    if (cf_is_integer($field)) {
      $item_menus = (array) workbench_menu_get_menus(array('id' => $field), 'id');
    }
    else {
      $matched = preg_match('@\[id: (\d+)\]\s*$@', $field, $matches);

      if ($matched > 0) {
        if (cf_is_integer($matches[1])) {
          $item_menus = (array) workbench_menu_get_menus(array('id' => $matches[1]), 'id');
        }
      }
    }

    if (empty($item_menus)) {
      if (class_exists('cf_error')) {
        cf_error::invalid_variable('item_menus', "Failed to find workbench menu with menu id of %id" , array('%id' => $field), WATCHDOG_WARNING);
      }

      return array('structure' => array(), 'settings' => array());
    }

    reset($item_menus);
    $item_menu = current($item_menus);

    // prevent infinite loops, only process menus once and do not process menus that point to self.
    if ($menu->id == $field || array_key_exists($item_menu->id, $variables['menus_processed'])) {
      return array('structure' => array(), 'settings' => array());
    }

    $variables['menus_processed'][$item_menu->id] = NULL;

    $breadcrumbs_temporary = FALSE;
    $built_menus = workbench_menu_build_menus($item_menu->path, $variables['menus_processed'], $breadcrumbs_temporary, FALSE);
    $data = array();

    if (isset($built_menus['structure'][$item_menu->weight][$item_menu->id])) {
      $data['structure'] = $built_menus['structure'][$item_menu->weight][$item_menu->id]['structure'];
      $data['settings'] = $built_menus['structure'][$item_menu->weight][$item_menu->id]['settings'];
    }
    else {
      $data['structure'] = array();
      $data['settings'] = array();
    }

    if ($item_settings['expand'] != "expand_auto") {
      foreach ($data['structure'] as $row_key => &$row_value) {
        foreach ($row_value as $key => &$value) {
          $data['settings'][$key]['expand'] = $item_settings['expand'];
        }
      }
    }

    return $data;
  }


  // menu item menu items are parts of another menu embeded inside of the current menu.
  if ($item_settings['type'] == 'item_menu_item') {
    $field_menu = & $item['item']->properties['menu'];
    $field_menu_item = & $item['item']->properties['menu_item'];
    $item_menus = array();

    if (cf_is_integer($field_menu)) {
      $item_menus = (array) workbench_menu_get_menus(array('id' => $field_menu), 'id');
    }
    else {
      $matches = array();
      $matched = preg_match('@\[id: (\d+)\]\s*$@', $field_menu, $matches);

      if ($matched > 0) {
        if (cf_is_integer($matches[1])) {
          $item_menus = (array) workbench_menu_get_menus(array('id' => $matches[1]), 'id');
        }
      }
    }

    // return if no items were found.
    if (empty($item_menus)) {
      return array('structure' => array(), 'settings' => array());
    }


    reset($item_menus);
    $item_menu = current($item_menus);
    $item_menu_item = NULL;
    $item_menu_item_id = NULL;

    if (cf_is_integer($field_menu_item)) {
      $item_menu_item_id = $field_menu_item;
    }
    else {
      $matches = array();
      $matched = preg_match('@\[id: (\d+)\]\s*$@', $field_menu_item, $matches);

      if ($matched > 0) {
        if (cf_is_integer($matches[1])) {
          $item_menu_item_id = $matches[1];
        }
      }
    }

    // Unable to determine the item menu item id.
    if (is_null($item_menu_item_id)) {
      return array('structure' => array(), 'settings' => array());
    }

    // do not allow menu item item types that point to its own menu.
    if ($item_menu->id == $menu->id) {
      return array('structure' => array(), 'settings' => array());
    }

    $process_children = FALSE;

    $item_menu_item_variables = array();
    $item_menu_item_variables['menus_processed'] = $variables['menus_processed'];
    $item_menu_item_variables['parent_path'] = array();
    $item_menu_item_variables['parent_path']['original'] = $item_menu->path;
    $item_menu_item_variables['parent_path']['normal'] = drupal_get_normal_path($item_menu_item_variables['parent_path']['original']);
    $item_menu_item_variables['parent_path']['alias'] = drupal_get_path_alias($item_menu_item_variables['parent_path']['original']);
    $item_menu_item_variables['menu_path'] = array();
    $item_menu_item_variables['menu_path']['original'] = $item_menu->path;
    $item_menu_item_variables['menu_path']['normal'] = drupal_get_normal_path($item_menu_item_variables['menu_path']['original']);
    $item_menu_item_variables['menu_path']['alias'] = drupal_get_path_alias($item_menu_item_variables['menu_path']['original']);
    $item_menu_item_variables['use_normal_path'] = $variables['use_normal_path'];

    if ($variables['use_normal_path']) {
      $bc_path = check_plain($item_menu_item_variables['parent_path']['normal']);
      $item_menu_item_variables['breadcrumbs']['built'] = array('<a href="' . base_path() . $bc_path . '" class="workbench_menu-breadcrumb">' . $item_menu->breadcrumb_name . '</a>');
      $item_menu_item_variables['breadcrumbs']['path'] = array($bc_path);
    }
    else {
      $bc_path = check_plain($item_menu_item_variables['parent_path']['alias']);
      $item_menu_item_variables['breadcrumbs']['built'] = array('<a href="' . base_path() . $bc_path . '" class="workbench_menu-breadcrumb">' . $item_menu->breadcrumb_name . '</a>');
      $item_menu_item_variables['breadcrumbs']['path'] = array($bc_path);
    }

    if ($variables['breadcrumbs_all'] === FALSE) {
      $item_menu_item_variables['breadcrumbs_all'] = FALSE;
    }
    else {
      $item_menu_item_variables['breadcrumbs_all'] = &$breadcrumbs;
    }

    $history_stack = array();
    $current_stack = array_reverse($item_menu->items['nested'], TRUE);

    while (!empty($current_stack)) {
      $nested_item = array_pop($current_stack);

      if ($nested_item['item']->id == $item_menu_item_id) {
        $item_menu_item = &$nested_item;
        array_push($item_menu->items['nested'], $nested_item);
        break;
      }

      if (!empty($nested_item['children'])) {
        array_push($history_stack, $current_stack);

        $current_stack = array_reverse($nested_item['children'], TRUE);
        continue;
      }

      if (empty($current_stack) && !empty($history_stack)) {
        $current_stack = array_pop($history_stack);
      }
    }

    unset($history_stack);
    unset($current_stack);

    if (is_null($item_menu_item)) {
      return array('structure' => array(), 'settings' => array());
    }

    // do not process item_menu and item_menu_item types
    if ($item_menu_item['item']->item_type[0]->machine_name == 'item_menu' || $item_menu_item['item']->item_type[0]->machine_name == 'item_menu_item') {
      return array('structure' => array(), 'settings' => array());
    }

    $data = workbench_menu_build_menu_item($item_menu, $item_menu_item, $item_menu_item_variables);

    // failed to find the menu item.
    if (empty($data['structure'])) {
      return array('structure' => array(), 'settings' => array());
    }

    $structure[$item['item']->weight][$item_id] = $data['structure'][$item_menu_item['item']->weight][$item_menu_item_id];

    $item_settings['prefix'] = $data['settings'][$item_menu_item_id]['prefix'];
    $item_settings['postfix'] = $data['settings'][$item_menu_item_id]['postfix'];
    $item_settings['outside_link'] = $data['settings'][$item_menu_item_id]['outside_link'];
    $item_settings['top_link'] = $data['settings'][$item_menu_item_id]['top_link'];
    $item_settings['active_path'] = $data['settings'][$item_menu_item_id]['active_path'];

    foreach ($data['settings'][$item_menu_item_id]['attributes'] as $attribute => &$value) {
      if ($attribute == 'id' || $attribute == 'class') continue;
      $item_settings['attributes'][$attribute] = $value;
    }

    $item_settings['attributes']['class'][] = 'menu_item-type-' . $data['settings'][$item_menu_item_id]['type'];

    unset($data['settings'][$item_menu_item_id]);

    foreach ($data['settings'] as $child_id => &$child_settings) {
      if (!isset($settings[$child_id])) {
        $settings[$child_id] = $child_settings;
      }
    }

    $built_menu['structure'] = $structure;
    $built_menu['settings'] = $settings;
    return $built_menu;
  }

  // menu item labels are parts of a menu that do not link to anything.
  if ($item_settings['type'] == 'item_label' || ($item_settings['type'] == 'item_top' && $top_as == 'label')) {
    if (isset($item['item']->properties['disabled']) && $item['item']->properties['disabled']) {
      $item_settings['attributes']['class'][] = 'disabled';
      $item_settings['clickable'] = FALSE;
    }
    elseif (isset($item['item']->properties['clickable']) && $item['item']->properties['clickable']) {
      $item_settings['attributes']['class'][] = 'clickable';
      $item_settings['attributes']['class'][] = 'noscript';
      $item_settings['attributes']['href'] = array('');
      $item_settings['clickable'] = TRUE;
    }

    if (isset($item['item']->properties['no_breadcrumb']) && $item['item']->properties['no_breadcrumb']) {
      $no_breadcrumb = TRUE;
    }
  }

  // menu item links are parts of a menu that link to some url, file, or id (local or remote).
  if ($item_settings['type'] == 'item_link' || $item_settings['type'] == 'item_node' || $item_settings['type'] == 'item_top') {
    $link_path = '';
    $process = TRUE;
    $parsed_url = array();
    $matches = array();
    $matched = FALSE;

    if (isset($item['item']->properties['always_suppress']) && $item['item']->properties['always_suppress']) {
      $item_settings['suppress_active'] = TRUE;
    }

    // top item types force active path and link path to be set to '<top>'.
    if ($item_settings['type'] == 'item_top') {
      $item['item']->active_path = '<top>';
      $item['item']->properties['url'] = '<top>';

      $item_settings['attributes']['class'][] = 'top_as-' . check_plain($top_as);
    }
    else if ($item_settings['type'] == 'item_link') {
      $matched = preg_match('@^/node/(\d+)(/.*|$|\?.*|#.*)@', $item['item']->properties['url'], $matches);
    }
    else {
      $matched = preg_match('@^(\d+)($|\?.*|#.*)@', $item['item']->properties['node_id'], $matches);

      if ($matched == 0) {
        $matched = preg_match('@\[nid: (\d+)\]\s*($|\?.*|#.*)@', $item['item']->properties['node_id'], $matches);
      }
    }

    if ($matched > 0) {
      if (isset($matches[2])) {
        $link_extras = $matches[2];
      }

      if (cf_is_integer($matches[1])) {
        if ($variables['use_normal_path']) {
          $path_alias = 'node/' . $matches[1] . $link_extras;
        }
        else {
          $path_alias = drupal_get_path_alias('node/' . $matches[1]) . $link_extras;
        }

        $parsed_url = parse_url($path_alias);

        if (!empty($parsed_url['path'])) {
          $link_path = '/' . $parsed_url['path'];
          $active_path['original'] = $parsed_url['path'];
        }

        if (!empty($parsed_url['query'])) {
          $link_path .= '?' . $parsed_url['query'];
        }

        if (!empty($parsed_url['fragment'])) {
          $link_path .= '#' . $parsed_url['fragment'];

          // suppress active links that have fragments.
          if ((isset($item['item']->properties['always_suppress']) && $item['item']->properties['always_suppress'])|| !(isset($item['item']->properties['never_suppress']) && $item['item']->properties['never_suppress'])) {
            $item_settings['suppress_active'] = TRUE;
          }
        }

        // check to see if the node still exists.
        $query = db_select('node', 'n');
        $query->fields('n', array('nid'));
        $query->condition('n.nid', $matches[1]);

        $results = $query->execute()->fetchAll();

        if (empty($results)) {
          $item_settings['attributes']['title'] = array(t("Page Not Found: !path_alias.", array('!path_alias' => check_plain($path_alias))));
          $process = FALSE;
          $link_path = '';
        }
      }
    }

    if ($process && empty($link_path)) {
      if ($item['item']->properties['url'] == '<top>') {
        $item_settings['attributes']['class'][] = 'menu_item-menu_top';
        $item_settings['top_link'] = TRUE;

        $active_path['original'] = $menu->path;
        $active_path['normal'] = drupal_get_normal_path($active_path['original']);
        $active_path['alias'] = drupal_get_path_alias($active_path['original']);

        if ($top_as == 'menu_path') {
          if ($variables['use_normal_path']) {
            $link_path = '/' . $active_path['normal'];
          }
          else {
            $link_path = '/' . $active_path['alias'];
          }
        }
      }
      else {
        $link_path = $item['item']->properties['url'];

        if (valid_url($link_path, TRUE)) {
          $parsed_url = parse_url($link_path);
          $remote_url = check_plain($parsed_url['host']);

          $item_settings['prefix'] .= '<div class="' . 'menu_item-icon ' . 'menu_item-icon_external"></div>';
          $item_settings['attributes']['title'] = array(t("This links to the external website: !remote_url.", array('!remote_url' => $remote_url)));
        }
        else {
          $matches = array();

          if (preg_match('/^mailto:(.*)/', $link_path, $matches) > 0) {
            $item_settings['prefix'] .= '<div class="' . 'menu_item-icon ' . 'menu_item-icon_mail"></div>';
            $item_settings['attributes']['title'] = array(t("Send an e-mail to: !email_address.", array('!email_address' => check_plain($matches[1]))));
          }
          elseif (preg_match('@^(/|#)@', $link_path) === 0) {
            $link_path = '/' . $menu->path . '/' . $link_path;
          }
        }
      }
    }

    if (!empty($link_path)) {
      $item_settings['attributes']['href'] = array($link_path);
    }

    $item_settings['outside_link'] = (preg_match('@^' . $menu->path . '/@', $link_path) > 0);

    unset($matches);
    unset($matched);
    unset($link_path);
  }

  if ($item_settings['type'] == 'item_file') {
    $icon = check_plain($item['item']->properties['file_type']);
    $filename = '';
    $link_path = '';
    $process = TRUE;
    $to_node = FALSE;


    if (isset($item['item']->properties['always_suppress']) && $item['item']->properties['always_suppress']) {
      $item_settings['suppress_active'] = TRUE;
    }

    $matches = array();
    $matched = preg_match('@\[fid: (\d+)\]\s*$@i', $item['item']->properties['file'], $matches);

    if ($matched > 0) {
      $match = array_pop($matches);

      if (cf_is_integer($match)) {
        $query = db_select('file_managed', 'fm');
        $query->fields('fm', array('uri', 'filename'));
        $query->condition('fm.fid', $match);
        $query->condition('fm.status', 1);

        $results = $query->execute()->fetchAll();

        if (!empty($results)) {
          $result = array_pop($results);
          $filename = $result->filename;
          $parts = explode('://', $result->uri, 2);
          $instance = file_stream_wrapper_get_instance_by_scheme($parts[0]);
          $instance->setUri($result->uri);
          $link_path = $instance->getExternalUrl();
        }

        $process = FALSE;
      }
    }

    if ($process) {
      // it is possible for a local node to generate/return itself as a file.
      $matches = array();
      $matched = preg_match('@^/node/(\d+)(/.*|$|\?.*|#.*)@', $item['item']->properties['file'], $matches);

      if ($matched > 0) {
        $to_node = TRUE;
        $path_alias = drupal_get_path_alias('node/' . $matches[1]);

        if (isset($matches[2])) {
          $path_alias .= $matches[2];
        }

        $parsed_url = parse_url($path_alias);

        if (!empty($parsed_url['path'])) {
          $link_path = '/' . $parsed_url['path'];
          $active_path['original'] = $parsed_url['path'];
          $process = FALSE;
        }

        if (!empty($parsed_url['query'])) {
          $link_path .= '?' . $parsed_url['query'];
        }

        if (!empty($parsed_url['fragment'])) {
          $link_path .= '#' . $parsed_url['fragment'];

          // suppress active links that have fragments.
          if ((isset($item['item']->properties['always_suppress']) && $item['item']->properties['always_suppress']) || !(isset($item['item']->properties['never_suppress']) && $item['item']->properties['never_suppress'])) {
            $item_settings['suppress_active'] = TRUE;
          }
        }

        // check to see if the node still exists and use the node title.
        $query = db_select('node', 'n');
        $query->fields('n', array('nid', 'title'));
        $query->condition('n.nid', $matches[1]);

        $results = $query->execute()->fetchAll();

        if (empty($results)) {
          $link_path = '';
          $filename = $path_alias;
        }
        else {
          $result = array_pop($results);
          $filename = $result->title;
        }
      }
    }

    if ($process) {
      $link_path = $item['item']->properties['file'];
      $filename = check_plain(rawurldecode(basename($link_path)));

      if (valid_url($link_path, TRUE)) {
        $parsed_url = parse_url($link_path);
        $remote_url = check_plain($parsed_url['host']);

        $item_settings['prefix'] = '<div class="' . 'menu_item-icon ' . 'menu_item-icon_' . $icon . '"></div>';
        $item_settings['attributes']['title'] = array(t("Download !filename from the external website: !remote_url.", array('!filename' => $filename, '!remote_url' => $remote_url)));
        $item_settings['attributes']['class'][] = 'menu_item-external_url';
      }
      else {
        $item_settings['prefix'] .= '<div class="' . 'menu_item-icon ' . 'menu_item-icon_' . $icon . '"></div>';
        $item_settings['attributes']['title'] = array(t("Download !filename.", array('!filename' => $filename)));
      }
    }
    else {
      $item_settings['prefix'] .= '<div class="' . 'menu_item-icon ' . 'menu_item-icon_' . $icon . '"></div>';

      if ($to_node) {
        $item_settings['attributes']['title'] = array(t("View or Download: !filename.", array('!filename' => $filename)));
      }
      else {
        $item_settings['attributes']['title'] = array(t("Download: !filename.", array('!filename' => $filename)));
      }

      if (empty($link_path)) {
        $item_settings['attributes']['title'] = array(t("File Not Found: !filename.", array('!filename' => $filename)));
      }
    }

    if (!empty($link_path)) {
      $item_settings['attributes']['href'] = array($link_path);
    }

    $item_settings['postfix'] = '';

    unset($icon);
    unset($filename);
    unset($matches);
    unset($matched);
    unset($link_path);
  }


  // process active paths.
  if ($item_settings['type'] == 'item_top') {
    $active_path = $variables['menu_path'];
  }
  else {
    if (empty($item_settings['active_path']['original']) && !empty($item['item']->active_path)) {
      if ($item['item']->active_path == '<top>') {
        $active_path = $variables['menu_path'];
      }
      elseif (preg_match('@^/@', $item['item']->active_path) == 0) {
        $active_path['original'] = $variables['parent_path']['original'] . '/' . $item['item']->active_path;
      }
      else {
        $active_path['original'] = $variables['menu_path']['original'] . $item['item']->active_path;
      }
    }
  }

  $active_path['normal'] = drupal_get_normal_path($active_path['original']);
  $active_path['alias'] = drupal_get_path_alias($active_path['original']);



  // @todo: include extra paths following active trail when building breadcrumb.
  // process breadcrumbs.
  if (!empty($active_path['original'])) {
    $item_settings['active_path'] = $active_path;

    $matched = FALSE;
    foreach (array('original', 'normal', 'alias') as $key) {
      switch ($active_path[$key]) {
        case $variables['menu_path']['original']:
        case $variables['menu_path']['normal']:
        case $variables['menu_path']['alias']:
          $matched = TRUE;

          // this breaks out of the for loop and not the switch, which is desired in this case.
          break;
      }
    }

    if (!$matched) {
      if ($variables['use_normal_path']) {
        $path_to_use = $active_path['normal'];
      }
      else {
        $path_to_use = $active_path['alias'];
      }

      if (!$no_breadcrumb) {
        $bc_path = check_plain($path_to_use);
        $variables['breadcrumbs']['built'][] = '<a href="' . base_path() . $bc_path . '" class="workbench_menu-breadcrumb">' . $item_settings['label'] . '</a>';
        $variables['breadcrumbs']['path'][] = $bc_path;
        unset($path_to_use);
        unset($bc_path);
      }
    }

    if ($variables['breadcrumbs_all'] !== FALSE) {
      $matched = FALSE;
      foreach (array('original', 'normal', 'alias') as $key) {
        if (preg_match('@^' . $variables['parent_path'][$key] . '/@', $active_path['original']) > 0) {
          $matched = TRUE;
          break;
        }
        elseif (preg_match('@^' . $variables['parent_path'][$key] . '/@', $active_path['normal']) > 0) {
          $matched = TRUE;
          break;
        }
        elseif (preg_match('@^' . $variables['parent_path'][$key] . '/@', $active_path['alias']) > 0) {
          $matched = TRUE;
          break;
        }
      }

      if ($matched) {
        $variables['breadcrumbs_all'][$active_path['normal']] = $variables['breadcrumbs'];
      }
    }

    unset($matched);
  }
  else {
    $variables['breadcrumbs']['built'][] = '<span>' . $item_settings['label'] . '</span>';
    $variables['breadcrumbs']['path'][] = '';
  }

  if ($variables['breadcrumbs_all'] === FALSE) {
    unset($item_settings['breadcrumbs']);
  }
  else {
    $item_settings['breadcrumbs'] = $variables['breadcrumbs'];
  }


  if ($process_children && !empty($item['children'])) {
    foreach ($item['children'] as &$child) {
      $child_variables = array();
      $child_variables['menus_processed'] = &$variables['menus_processed'];
      $child_variables['parent_path'] = $variables['parent_path'];
      $child_variables['menu_path'] = $variables['menu_path'];
      $child_variables['breadcrumbs'] = $variables['breadcrumbs'];
      $child_variables['use_normal_path'] = $variables['use_normal_path'];

      if ($variables['breadcrumbs_all'] === FALSE) {
        $child_variables['breadcrumbs_all'] = FALSE;
      }
      else {
        $child_variables['breadcrumbs_all'] = &$variables['breadcrumbs_all'];
      }

      if (!empty($active_path)) {
        $child_variables['parent_path'] = $active_path;
      }

      $data = workbench_menu_build_menu_item($menu, $child, $child_variables);

      foreach ($data['structure'] as $structure_id => &$structure_data) {
        foreach ($structure_data as $structure_data_id => $structure_data_data) {
          $structure[$item['item']->weight][$item_id][$structure_id][$structure_data_id] = $structure_data_data;
        }
      }

      foreach ($data['settings'] as $child_id => &$child_settings) {
        $settings[$child_id] = $child_settings;
      }
    }
  }

  // @todo: write the api for this alter function
  drupal_alter(__FUNCTION__, $alter_settings);

  $built_menu['structure'] = $structure;
  $built_menu['settings'] = $settings;
  return $built_menu;
}

/**
 * Render the contents of a pre-built menu into a html menus.
 *
 * @param array $built_menu
 *   An array with the following structure:
 *   - weight: A nested array containing the weights and item ids.
 *   - settings: A flat array containing the properties of each item.
 * @param array $path_current
 *   An array of strings containing the complete url path that is currently
 *   active.
 *   The array keys are:
 *   original: the original current path as defined by drupal.
 *   normal: the normalized current path.
 *   alias: the alias of the current path.
 * @param bool $show_parents
 *   A boolean representing whether or not the parent menus should be
 *   renderred.
 *   This is populated after renderring the given menu to tell the
 *   caller if it is okay to or not to render the parent menus.
 * @param array $additional
 *   An array of the following additional variables:
 *   - menu_depth: A number representing the recursive depth of a menu.
 *   - menu_count: An auto-incremented number assigned to the menu.
 *   - path_trail: Remaining trail path after the current path.
 *   - path_trail_last_alias: A path trail following the last path alias.
 *
 * @return array
 *   An array with the following structure:
 *   - markup: A string of the renderred html markup.
 *   - breadcrumb: An array as of breadcrumb data as needed by
 *   drupal_set_breadcrumb().
 *
 * @see workbench_menu_build_menus()
 * @see drupal_set_breadcrumb()
 */
function workbench_menu_render_menus($built_menus, $path_current, &$show_parents, $additional) {
  $even_menu = TRUE;
  $rendered = array();

  foreach ($built_menus['structure'] as $built_menus_weight => &$menus) {
    $rendered[$built_menus_weight] = '';

    foreach ($menus as $menu_id => &$menu_data) {
      $list = array();
      $list['items'] = array();
      $list['attributes'] = array();
      $list['attributes']['class'] = array();
      $list['attributes']['class'][] = 'workbench_menu';
      $list['attributes']['class'][] = 'workbench_menu-id-' . $menu_id;
      $list['attributes']['class'][] = 'workbench_menu-weight-' . $built_menus_weight;
      $list['attributes']['class'][] = 'workbench_menu-count-' . $additional['menu_count'];
      $list['attributes']['class'][] = 'workbench_menu-depth-' . $additional['menu_depth'];
      $list['attributes']['class'][] = 'menu';

      if (!$menu_data['show_parents']) $show_parents = FALSE;

      $variables = array();
      $variables['menu_id'] = &$menu_id;
      $variables['menu_depth'] = $additional['menu_depth'];
      $variables['menu_weight'] = $built_menus_weight;
      $variables['menu_count'] = $additional['menu_count'];
      $variables['path_trail'] = $additional['path_trail'];
      $variables['path_trail_last_alias'] = $additional['path_trail_last_alias'];
      $variables['even_menu'] = &$even_menu;
      $variables['settings'] = &$menu_data['settings'];
      $variables['even_item'] = TRUE;
      $variables['count_item'] = 0;
      $variables['even_item_local'] = TRUE;
      $variables['count_item_local'] = 0;
      $variables['depth'] = 0;
      $variables['trail_is_active'] = FALSE;
      $variables['path_current'] = $path_current;
      $variables['alter_breadcrumb'] = $additional['alter_breadcrumb'];

      foreach ($menu_data['structure'] as $weight => &$items) {
        foreach ($items as $id => &$children) {
          $variables['id'] = $id;
          $variables['children'] = &$children;

          $list['items'][] = theme('workbench_menu_item', array('data' => &$variables));
        }
      }

      $rendered[$built_menus_weight] .= theme('workbench_menu_list', array('list' => $list, 'data' => $variables));

      $even_menu = !$even_menu;
    }
  }

  return $rendered;
}

/**
 * Render the contents of a pre-built menu item into html menu items.
 */
function template_preprocess_workbench_menu_item(&$vars) {
  $variables = &$vars['data'];

  if (empty($variables['settings'])) {
    return;
  }

  $variables['even_item'] = !$variables['even_item'];
  $variables['count_item']++;
  $variables['even_item_local'] = !$variables['even_item_local'];
  $variables['count_item_local']++;
  $variables['trail_is_active'] = FALSE;
  $variables['invalid_trail_active'] = FALSE;
  $variables['clickable_label'] = FALSE;

  $settings = & $variables['settings'][$variables['id']];

  if ($settings['type'] == 'item_label') {
    if (!empty($settings['clickable'])) {
      $variables['clickable_label'] = TRUE;
    }
  }

  $variables['child_list'] = array();

  // provide an active text string for purposes of accessibility.
  $variables['active_text'] = '';

  $matched = FALSE;
  foreach (array('original', 'normal', 'alias') as $key) {
    switch ($variables['path_current'][$key]) {
      case $settings['active_path']['original']:
      case $settings['active_path']['normal']:
      case $settings['active_path']['alias']:
        $matched = TRUE;

        // this breaks out of the for loop and not the switch, which is desired in this case.
        break;
    }
  }

  if ($matched) {
    $variables['trail_is_active'] = TRUE;
    $variables['active_text'] =' <span class="element-invisible">' . t("(active menu item)") . '</span>';

    if ($settings['suppress_active']) {
      $settings['attributes']['class'][] = 'suppressed_active';
    }
    else {
      $settings['attributes']['class'][] = 'active';
    }
  }
  else {
    foreach (array('original', 'normal', 'alias') as $path_type) {
      $matched = FALSE;
      switch ($variables['path_current'][$path_type]) {
        case $settings['active_path']['original']:
        case $settings['active_path']['normal']:
        case $settings['active_path']['alias']:
          $matched = TRUE;
      }

      if (!$matched) {
        if (preg_match('@^' . $settings['active_path']['original'] . '/@', $variables['path_current'][$key])) {
          $matched = TRUE;
        }
        elseif (preg_match('@^' . $settings['active_path']['normal'] . '/@', $variables['path_current'][$key])) {
          $matched = TRUE;
        }
        elseif (preg_match('@^' . $settings['active_path']['alias'] . '/@', $variables['path_current'][$key])) {
          $matched = TRUE;
        }
      }

      if ($matched) {
        $variables['trail_is_active'] = TRUE;
        break;
      }
    }
  }

  if ($variables['alter_breadcrumb'] && $variables['trail_is_active'] && isset($settings['breadcrumbs'])) {
    $home_title = t("Home");
    $bc = array_merge(array('<a href="' . base_path() . '">' . $home_title . '</a>'), $settings['breadcrumbs']['built']);
    $bc_paths = array_merge(array(''), $settings['breadcrumbs']['path']);
    $last_path = end($settings['breadcrumbs']['path']);

    // when viewing sub-paths, such as node sub-paths, the last path part may become duplicated.
    if (!empty($variables['path_trail'])) {
      $first = reset($variables['path_trail']);

      if ($first['normal'] == $last_path || $first['alias'] == $last_path) {
        array_shift($variables['path_trail']);
      }
    }

    if (!empty($variables['path_trail_last_alias'])) {
      $first = reset($variables['path_trail_last_alias']);

      if ($first['normal'] == $last_path || $first['alias'] == $last_path) {
        array_shift($variables['path_trail_last_alias']);
      }
    }

    // only path trails that follow the active url alias will be appended to the breadcrumb.
    $bc_processed = $bc_paths;
    foreach ($variables['path_trail'] as $key => &$pt) {
      $item = menu_get_item($pt['normal']);
      if (!empty($item['title']) && !empty($item['href'])) {
        if (!in_array($item['href'], $bc_processed)) {
          $bc[] = '<a href="' . base_path() . $item['href'] . '">' . $item['title'] . '</a>';
          $bc_processed[] = $item['href'];
        }
      }
    }

    foreach ($variables['path_trail_last_alias'] as $key => &$pt) {
      $item = menu_get_item($pt['normal']);
      if (!empty($item['title']) && !empty($item['href'])) {
        if (!in_array($item['href'], $bc_processed)) {
          $bc[] = '<a href="' . base_path() . $item['href'] . '">' . $item['title'] . '</a>';
          $bc_processed[] = $item['href'];
        }
      }
    }

    drupal_set_breadcrumb($bc);
  }

  if (empty($variables['children'])) {
    $settings['attributes']['class'][] = 'leaf';
  }
  else {
    $child_variables = array();
    $child_variables['settings'] = &$variables['settings'];
    $child_variables['even_item'] = &$variables['even_item'];
    $child_variables['count_item'] = &$variables['count_item'];
    $child_variables['even_item_local'] = TRUE;
    $child_variables['count_item_local'] = 0;
    $child_variables['depth'] = $variables['depth'] + 1;
    $child_variables['trail_is_active'] = FALSE;
    $child_variables['invalid_trail_active'] = FALSE;
    $child_variables['clickable'] = FALSE;
    $child_variables['path_current'] = $variables['path_current'];

    $child_list = array();

    foreach ($variables['children'] as $weight => &$items) {
      foreach ($items as $id => &$children) {
        $child_variables['id'] = $id;
        $child_variables['children'] = &$children;
        $child_variables['path_trail'] = $variables['path_trail'];
        $child_variables['path_trail_last_alias'] = $variables['path_trail_last_alias'];
        $child_variables['alter_breadcrumb'] = $variables['alter_breadcrumb'];

        $child_list[] = theme('workbench_menu_item', array('data' => &$child_variables));

        if ($child_variables['trail_is_active']) {
          $variables['trail_is_active'] = TRUE;

          if ($child_variables['invalid_trail_active']) {
            $variables['invalid_trail_active'] = TRUE;
          }
        }
      }
    }

    if ($variables['trail_is_active'] || $variables['clickable_label']) {
      if ($settings['expand'] == 'expand_always' || $settings['expand'] == 'expand_auto') {
        $variables['child_list'] = &$child_list;

        if ($variables['clickable_label'] && !$variables['trail_is_active']) {
          $settings['attributes']['class'][] = 'collapsed';
        }
        else {
          $settings['attributes']['class'][] = 'expanded';
        }
      }
      elseif ($settings['expand'] == 'expand_never') {
        $settings['attributes']['class'][] = 'collapsed';

        if ($variables['invalid_trail_active']) {
          $settings['attributes']['class'][] = 'invalid_active';
        }
        else {
          $settings['attributes']['class'][] = 'active';
          $variables['active_text'] =' <span class="element-invisible">' . t("(active menu item)") . '</span>';
        }
      }
    }
    else {
      if ($settings['expand'] == 'expand_always') {
        $settings['attributes']['class'][] = 'expanded';
        $variables['child_list'] = &$child_list;
      }
      elseif ($settings['expand'] == 'expand_never' || $settings['expand'] == 'expand_auto') {
        $settings['attributes']['class'][] = 'collapsed';
      }
    }
  }

  if ($variables['trail_is_active']) {
    $settings['attributes']['class'][] = 'active-trail';

    if ($variables['clickable_label']) {
      $noscript_key = array_search('noscript', $settings['attributes']['class']);

      if ($noscript_key !== FALSE) {
        unset($settings['attributes']['class'][$noscript_key]);
      }

      unset($noscript_key);
    }
  }

  $settings['attributes']['class'][] = ($variables['even_item'] ? 'even' : 'odd') ;
  $settings['attributes']['class'][] = ($variables['even_item_local'] ? 'local_even' : 'local_odd') ;
  $settings['attributes']['class'][] = 'row-' . $variables['count_item'];
  $settings['attributes']['class'][] = 'local_row-' . $variables['count_item_local'];
  $settings['attributes']['class'][] = 'depth-' . $variables['depth'];

  // if href is empty for items that require href, then append a broken link css class.
  if ($settings['type'] != 'item_label') {
    if (!isset($settings['attributes']['href'])) {
      $settings['attributes']['class'][] = 'menu_item-broken_link';
    }
  }

  $variables['count_item']++;
  $variables['even_item_local'] = !$variables['even_item_local'];
  $variables['count_item_local']++;
}

/**
 * Obtain a list of available menus.
 *
 * @param bool $with_path
 *   When TRUE, this prepends the url path of the menu to help make names less ambiguous.
 * @param bool $with_id
 *   When TRUE, this prepends the id of the menu to help make names less ambiguous.
 *
 * @return array
 *  An array of options with the menus taxonomy id as the key and the
 *  taxonomy human name as the value.
 */
function workbench_menu_get_menus_options_list($with_path = FALSE, $with_id = FALSE) {
  // clear cache for all menus with a given alias.function workbench_menu_get_menus_options_list($with_path = FALSE, $with_id = FALSE) {
  $variation = $with_path ? 't' : 'f';
  $variation .= $with_id ? 't' : 'f';

  $options_list = &drupal_static(__FUNCTION__, NULL);

  if (isset($options_list[$variation])) {
    return $options_list[$variation];
  }

  $options_list = array();
  $menus = (array) workbench_menu_get_menus(array(), 'id');

  foreach ($menus as $id => &$menu) {
    $options_list[$variation][$menu->access_id] = $menu->breadcrumb_name;

    if ($with_path) {
      $options_list[$variation][$menu->access_id] .= " [url:" . $menu->path . "]";
    }

    if ($with_id) {
      $options_list[$variation][$menu->access_id] .= " [id:" . $menu->id . "]";
    }
  }

  asort($options_list[$variation]);

  return $options_list[$variation];
}

/**
 * Obtains the menus associated with a given path or paths.
 *
 * This matches against the menus that are the depest-level children
 * of a given path.
 * That is, if there exist menus at /a/, /a/b/, and /a/b/c/ and the
 * current path is /a/b/d, then only the menu at path /a/b/ is
 * returned.
 *
 * @param string|array $paths
 *   A path string or an array of path strings.
 *   If a string is passed, the string will be broken down into an
 *   array of parts like this: '/a/b/c/d' -> array('a', 'a/b',
 *   'a/b/c', 'a/b/c/d').
 *   If an array is passed, the strings will be used as is without
 *   being broken down.
 *
 * @return array
 *   An array of menu objects for the given path.
 */
function workbench_menu_get_menus_at_paths($paths) {
  if (is_string($paths)) {
    $parts = explode('/', $paths);
    $matches = array();
    $path_string = '';

    foreach ($parts as &$part) {
      $path_string .= $part;
      $matches[] = $path_string;
      $path_string .= '/';
    }
  }
  elseif (is_array($paths)) {
    $matches = &$paths;
  }
  else {
    if (class_exists('cf_error')) {
      cf_error::invalid_variable('paths', "Must be a string or an array of strings.");
    }

    return array();
  }

  return (array) workbench_menu_get_menus(array('path' => $matches, 'fast' => NULL), 'id');
}

/**
 * Obtains the menus associated with a given node or node id.
 *
 * @param $node_or_nid
 *   A node or a node id.
 *
 * @return
 *   An array of menu objects for the given node.
 */
function workbench_menu_get_menus_at_node($node_or_nid) {
  if (!is_object($node_or_nid) && !cf_is_integer($node_or_nid)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_variable('node_or_nid', "Must be either a node object or a number.");
    }

    return array();
  }

  if (cf_is_integer($node_or_nid)) {
    $node = node_load($node_or_nid);
  }
  else {
    $node = &$node_or_nid;
  }

  if (!property_exists($node, 'workbench_access') || empty($node->workbench_access)) {
    return array();
  }

  $path_node = 'node/' . $node->nid;
  $path_alias = drupal_get_path_alias($path_node);

  if ($path_alias == $path_node) {
    $menus = (array) workbench_menu_get_menus(array('access_id' => $node->workbench_access, 'fast' => NULL), 'id');

    return $menus;
  }

  return workbench_menu_get_menus_at_paths($path_alias);
}

/**
 * Obtains the menus for the given menu ids.
 *
 * @param array $conditions
 *   (optional) An array with the following possible keys:
 *   - id: A unique id representing a specific menu or an array of
 *   ids.
 *   - access_id: A unique access id representing a specific
 *   workbench access group or an array of access ids.
 *   - path: A path string associated with a given meny or an array
 *   of path strings.
 *   - alias: A unique id representing a specific menu or an array of
 *   ids. This applies only to menus with the specified id as their alias.
 *   - fast: An array key whose value should be NULL. When specified, this will
 *   perform a fast load. The fast load does not perform the additional
 *   (expensive) operations that build the menu.
 * @param string|null $keyed
 *   (optional) A string matching one of the following: 'id',
 *   'access_id'
 *   When this is NULL, the default behavior is to return the array
 *   exactly as it was returned by the database call.
 *   When this is a valid string, the key names of the returned array
 *   will use the specified key name.
 *
 * @return array
 *   An array of menu objects for the given node.
 */
function workbench_menu_get_menus($conditions = array(), $keyed = NULL) {
  if (!is_array($conditions)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_array('conditions');
    }

    return array();
  }

  $query = db_select('workbench_menus', 'wm');
  $query->innerjoin('workbench_access', 'wa', 'wm.access_id = wa.access_id');
  $query->fields('wm');

  $query->orderBy('weight', 'ASC');
  $query->orderBy('id', 'ASC');

  $and = db_and();
  $and->condition('wa.access_type', 'taxonomy');

  if (isset($conditions['id'])) {
    if (cf_is_integer($conditions['id'])) {
      $and->condition('id', $conditions['id']);
    }
    elseif (is_array($conditions['id']) && !empty($conditions['id'])) {
      $and->condition('id', $conditions['id'], 'IN');
    }
  }

  if (isset($conditions['access_id'])) {
    if (cf_is_integer($conditions['access_id'])) {
      $and->condition('wm.access_id', $conditions['access_id']);
    }
    elseif (is_array($conditions['access_id']) && !empty($conditions['access_id'])) {
      $and->condition('wm.access_id', $conditions['access_id'], 'IN');
    }
  }

  if (isset($conditions['path'])) {
    if (is_string($conditions['path'])) {
      $and->condition('path', $conditions['path']);
    }
    elseif (is_array($conditions['path']) && !empty($conditions['path'])) {
      $and->condition('path', $conditions['path'], 'IN');
    }
  }

  if (isset($conditions['alias'])) {
    if (cf_is_integer($conditions['alias'])) {
      $and->condition('alias', $conditions['alias']);
    }
    elseif (is_array($conditions['alias']) && !empty($conditions['alias'])) {
      $and->condition('alias', $conditions['alias'], 'IN');
    }
  }

  $query->condition($and);
  $menus = array();

  if ($keyed == 'id' || $keyed == 'access_id') {
    try {
      $records = $query->execute();
    }
    catch (Exception $e) {
      if (class_exists('cf_error')) {
        cf_error::on_query_execution($e);
      }

      return array();
    }

    foreach ($records as $record) {
      if (!is_object($record)) continue;

      $menus[$record->$keyed] = $record;
    }
  }
  else {
    try {
      $menus = (array) $query->execute()->fetchAll();
    }
    catch (Exception $e) {
      if (class_exists('cf_error')) {
        cf_error::on_query_execution($e);
      }
    }
  }

  // load all additional menu data
  if (!empty($menus) && !array_key_exists('fast', $conditions)) {
    $static_menus = &drupal_static(__FUNCTION__, NULL);

    if (is_null($static_menus)) {
      $static_menus = array('menu' => array(), 'access_id' => array());
    }

    foreach ($menus as &$menu) {
      if (isset($static_menus['menu'][$menu->id])) {
        $menu = $static_menus['menu'][$menu->id];
        continue;
      }
      else {
        $static_menus['menu'][$menu->id] = &$menu;
      }

      $menu->items = (array) workbench_menu_get_menu_items(array('menu_id' => $menu->id), 'id');

      // only load the taxonomy name to get the term name if one is not already defined in the breadcrumb name.
      if (empty($menu->breadcrumb_name)) {
        $taxonomy = taxonomy_term_load($menu->access_id);
        $menu->breadcrumb_name = $taxonomy->name;
      }

      $static_menus['menu'][$menu->id] = $menu;
      $static_menus['access_id'][$menu->access_id] = $menu->id;
    }
  }

  return $menus;
}

/**
 * Save the settings for one or more menus.
 *
 * This function clears the workbench_menu menu cache.
 *
 * @param array $item_ids
 *   An array of menu setting arrays with the following keys:
 *   - 'id': (optional) This is the primary key for a specific row in
 *   the workbench_menu table.
 *   - 'access_id': This is the unique access_id that represents the
 *   workbench access group to save.
 *   - 'path': This is the url path string of the menu.
 *
 * @return bool
 *   TRUE on success, FALSE otherwise.
 */
function workbench_menu_save_menus($menus) {
  if (!is_array($menus)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_array('menus');
    }

    return FALSE;
  }

  if (empty($menus)) {
    return TRUE;
  }

  $static_menus = &drupal_static('workbench_menu_get_menus', NULL);
  $transaction = db_transaction();

  try {
    foreach ($menus as $key => &$menu) {
      if (!is_array($menu)) {
        if (class_exists('cf_error')) {
          cf_error::invalid_array('menus[' . $key . ']');
        }

        continue;
      }

      $query = db_select('workbench_menus', 'wm');
      $query->fields('wm');

      $record = array();
      $record['path'] = $menu['path'];
      $record['weight'] = $menu['weight'];
      $record['show_parents'] = $menu['show_parents'];
      $record['hidden'] = $menu['hidden'];
      $record['breadcrumb_name'] = $menu['breadcrumb_name'];
      $record['alias'] = $menu['alias'];

      if (isset($menu['id'])) {
        $record['id'] = $menu['id'];

        $query->condition('id', $menu['id']);

        $existing = (array) $query->execute()->fetchAll();

        if (empty($existing)) {
          unset($record['id']);
        }

        unset($query);
      }
      elseif (isset($menu['access_id'])) {
        $record['access_id'] = $menu['access_id'];

        $query->condition('access_id', $menu['access_id']);

        $existing = (array) $query->execute()->fetchAll();

        if (!empty($existing)) {
          $row = array_pop($existing);
          $record['id'] = $row->id;
        }

        unset($query);
      }

      if (isset($record['id'])) {
        $rx = drupal_write_record('workbench_menus', $record, array('id'));
      }
      else {
        drupal_write_record('workbench_menus', $record);
      }

      foreach ($menu['items'] as &$menu_item) {
        $record = array();

        $record['menu_id'] = $menu_item['menu_id'];
        $record['parent_id'] = $menu_item['parent_id'];
        $record['properties'] = $menu_item['properties'];

        if (property_exists($menu_item, 'id')) {
          $record['id'] = $menu_item['id'];
          drupal_write_record('workbench_menu_items', $record, array('id'));
        }
        else {
          drupal_write_record('workbench_menu_items', $record);
        }
      }

      if (isset($menu['id'])) {
        $static_menus['menu'][$menu['id']] = $menu;
      }
      elseif (isset($menu['access_id'])) {
        $query = db_select('workbench_menus', 'wm');
        $query->fields('wm');
        $query->condition('access_id', $menu['access_id']);

        $records = (array) $query->execute()->fetchAll();

        if (!empty($records)) {
          $record = array_pop($records);
          $static_menus['menu'][$record->id] = $menu;
        }
      }
    }

    // enforce transaction execution
    unset($transaction);
  }
  catch (Exception $e) {
    $transaction->rollback();

    if (class_exists('cf_error')) {
      cf_error::on_query_execution($e);
    }

    return FALSE;
  }

  return TRUE;
}

/**
 * Loads menu items from the database based on the given conditions.
 *
 * @param array $conditions
 *   (optional) An array with the following possible keys:
 *   - 'id' A unique id representing a specific item or an array of
 *   ids.
 *   - 'menu_id' A unique menu id representing a specific menu or an
 *   array of menu ids.
 *   - 'parent_id' A unique parent id representing a specific parent
 *   or an array of parent ids.
 *   - 'human_name' A human name string of a menu item or an array of
 *   human name strings.
 *   - 'weight' A number representing the weight or an array of
 *   weight numbers.
 *   - 'active path' Active path of the items to load, may be set to.
 *   - 'item_type' The item type id or item type machine name of the items to
 *   load.
 *   - fast: An array key whose value should be NULL. When specified, this will
 *   perform a fast load. The fast load does not perform the additional
 *   (expensive) operations that build the menu items.
 * @param string|null $keyed
 *   (optional) A string matching one of the following: 'id',
 *   'menu_id'.
 *   When this is NULL, the default behavior is to return the array
 *   exactly as it was returned by the database call.
 *   When this is a valid string, the key names of the returned array
 *   will use the specified key name.
 *
 * @return array
 *   An array of menu items.
 *   Normally, this is a sorted array with the keys:
 *   - 'flat' An array of menu items using a single depth structure.
 *   - 'nested' An array of menu items using a parent child structure.
 *
 *   When 'fast' is specified, this is simply an unsorted array as returned
 *   by the database.
 */
function workbench_menu_get_menu_items($conditions = array(), $keyed = NULL) {
  $sorted_menu_items = array();
  $sorted_menu_items['flat'] = array();
  $sorted_menu_items['nested'] = array();

  if (!is_array($conditions)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_array('conditions');
    }

    return $sorted_menu_items;
  }

  $query = db_select('workbench_menu_items', 'wmi');
  $query->fields('wmi');

  $query->orderBy('wmi.parent_id', 'ASC');
  $query->orderBy('wmi.weight', 'ASC');
  $query->orderBy('wmi.human_name', 'ASC');
  $query->orderBy('wmi.id', 'ASC');

  foreach (array('e' => 'expand', 'it' => 'item_type') as $key => $name) {
    $results = array();
    $wmo = 'wmko' . $key;
    $wm = 'wmk' . $key;

    $query->leftjoin('workbench_menu_' . $name . 's',  $wm, 'wmi.id = ' . $wm . '.item_id');
    $query->leftjoin('workbench_menu_options_' . $name,  $wmo, $wm . '.' . $name . '_id = ' . $wmo . '.id');
    $query->addField($wmo, 'id', $name . '_id');
    $query->addField($wmo, 'machine_name', $name . '_machine_name');
    $query->addField($wmo, 'human_name', $name . '_human_name');
    $query->addField($wmo, 'description', $name . '_description');
  }

  $and = db_and();

  if (isset($conditions['id'])) {
    if (cf_is_integer($conditions['id'])) {
      $and->condition('wmi.id', $conditions['id']);
    }
    elseif (is_array($conditions['id']) && !empty($conditions['id'])) {
      $and->condition('wmi.id', $conditions['id'], 'IN');
    }
  }

  if (isset($conditions['menu_id'])) {
    if (cf_is_integer($conditions['menu_id'])) {
      $and->condition('wmi.menu_id', $conditions['menu_id']);
    }
    elseif (is_array($conditions['menu_id']) && !empty($conditions['menu_id'])) {
      $and->condition('wmi.menu_id', $conditions['menu_id'], 'IN');
    }
  }

  if (isset($conditions['parent_id'])) {
    if (cf_is_integer($conditions['parent_id'])) {
      $and->condition('wmi.parent_id', $conditions['parent_id']);
    }
    elseif (is_array($conditions['parent_id']) && !empty($conditions['parent_id'])) {
      $and->condition('wmi.parent_id', $conditions['parent_id'], 'IN');
    }
  }

  if (isset($conditions['weight'])) {
    if (cf_is_integer($conditions['weight'])) {
      $and->condition('wmi.weight', $conditions['weight']);
    }
    elseif (is_array($conditions['weight']) && !empty($conditions['weight'])) {
      $and->condition('wmi.weight', $conditions['weight'], 'IN');
    }
  }

  if (isset($conditions['human_name'])) {
    if (is_string($conditions['human_name'])) {
      $and->condition('wmi.human_name', $conditions['human_name']);
    }
    elseif (is_array($conditions['human_name']) && !empty($conditions['human_name'])) {
      $and->condition('wmi.human_name', $conditions['human_name'], 'IN');
    }
  }

  if (isset($conditions['active_path'])) {
    if (is_string($conditions['active_path'])) {
      $and->condition('wmi.active_path', $conditions['active_path']);
    }
  }

  if (isset($conditions['item_type'])) {
    if (cf_is_integer($conditions['item_type'])) {
      $and->condition('wmkoit.id', $conditions['item_type']);
    }
    elseif (is_string($conditions['item_type'])) {
      $and->condition('wmkoit.machine_name', $conditions['item_type']);
    }
    elseif (is_array($conditions['item_type']) && !empty($conditions['item_type'])) {
      $item_type_ids = array();
      $item_type_names = array();

      foreach ($conditions['item_type'] as $key => $item_type) {
        if (cf_is_integer($item_type)) {
          $item_type_ids[] = $item_type;
        }
        elseif (is_string($item_type)) {
          $item_type_names[] = $item_type;
        }
      }

      if (!empty($item_type_ids)) {
        $and->condition('wmkoit.id', $item_type_ids, 'IN');
      }

      if (!empty($item_type_names)) {
        $and->condition('wmkoit.machine_name', $item_type_names, 'IN');
      }
    }
  }

  $query->condition($and);
  $menu_items = array();

  if ($keyed == 'id' || $keyed == 'menu_id') {
    try {
      $records = $query->execute();
    }
    catch (Exception $e) {
      if (class_exists('cf_error')) {
        cf_error::on_query_execution($e);
      }

      if (array_key_exists('fast', $conditions)) {
        return $menu_items;
      }

      return $sorted_menu_items;
    }

    foreach ($records as $record) {
      if (!is_object($record)) continue;

      $menu_items[$record->$keyed] = $record;
    }
  }
  else {
    try {
      $menu_items = (array) $query->execute()->fetchAll();
    }
    catch (Exception $e) {
      if (class_exists('cf_error')) {
        cf_error::on_query_execution($e);
      }
    }
  }

  if (array_key_exists('fast', $conditions)) {
    return $menu_items;
  }

  if (!empty($menu_items)) {
    foreach ($menu_items as $menu_item_key => &$menu_item) {
      $id = $menu_item->id;

      if (isset($sorted_menu_items['flat'][$id]) && isset($sorted_menu_items['flat'][$id]['item']) && is_object($sorted_menu_items['flat'][$id]['item'])) {
        foreach (array('expand', 'item_type') as $name) {
          $results = new stdClass();
          $results->id = $menu_item->{$name . '_id'};
          $results->machine_name = $menu_item->{$name . '_machine_name'};
          $results->human_name = $menu_item->{$name . '_human_name'};
          $results->description = $menu_item->{$name . '_description'};

          unset($menu_item->{$name . '_id'});
          unset($menu_item->{$name . '_machine_name'});
          unset($menu_item->{$name . '_human_name'});
          unset($menu_item->{$name . '_description'});

          array_push($sorted_menu_items['flat'][$id]['item']->$name, $results);
        }

        continue;
      }

      foreach (array('expand', 'item_type') as $name) {
        $results = new stdClass();
        $results->id = $menu_item->{$name . '_id'};
        $results->machine_name = $menu_item->{$name . '_machine_name'};
        $results->human_name = $menu_item->{$name . '_human_name'};
        $results->description = $menu_item->{$name . '_description'};

        unset($menu_item->{$name . '_id'});
        unset($menu_item->{$name . '_machine_name'});
        unset($menu_item->{$name . '_human_name'});
        unset($menu_item->{$name . '_description'});

        $menu_item->$name = array($results);
      }

      if (!isset($sorted_menu_items['flat'][$id])) {
        $sorted_menu_items['flat'][$id] = array();
        $sorted_menu_items['flat'][$id]['children'] = array();
        $sorted_menu_items['flat'][$id]['item'] = $menu_item;
      }
      else {
        if (!isset($sorted_menu_items['flat'][$id]['children'])) {
          $sorted_menu_items['flat'][$id]['children'] = array();
        }
        if (!isset($sorted_menu_items['flat'][$id]['item'])) {
          $sorted_menu_items['flat'][$id]['item'] = $menu_item;
        }
      }

      if ($menu_item->parent_id == 0) {
        $sorted_menu_items['nested'][$id] = &$sorted_menu_items['flat'][$id];
      }
      else {
        if (!isset($sorted_menu_items['flat'][$menu_item->parent_id])) {
          $sorted_menu_items['flat'][$menu_item->parent_id] = array();
          $sorted_menu_items['flat'][$menu_item->parent_id]['children'] = array();
        }

        $sorted_menu_items['flat'][$menu_item->parent_id]['children'][$id] = &$sorted_menu_items['flat'][$id];
      }

      $menu_item->properties = unserialize($menu_item->properties);
    }
  }

  return $sorted_menu_items;
}

/**
 * Obtains a select list of for menu items loaded from the database.
 *
 * @param array $conditions
 *   (optional)An array that is passed directly to
 *   workbench_menu_get_menu_items().
 * @param string|null $keyed
 *   (optional) A string that is passed directly to
 *   workbench_menu_get_menu_items().
 *
 * @return array
 *   A processed array select list of menu objects for the given
 *   node.
 *
 * @see workbench_menu_get_menu_items()
 */
function workbench_menu_get_menu_items_select_list_options($conditions = array(), $keyed = NULL) {
  $options_list = &drupal_static(__FUNCTION__, NULL);

  if (is_null($options_list)) {
    $items = (array) workbench_menu_get_menu_items($conditions, $keyed);

    foreach ($items['flat'] as &$i) {
      $available_parents[$i['item']->id] = $i['item']->human_name;
    }

    $data = array();
    $data['options'] = array();
    $data['options']['-1'] = "<Disabled>";
    $data['options']['0'] = "<No Parent>";

    foreach ($items['nested'] as &$nested_item) {
      workbench_menu_get_menu_items_select_list_options_recursive_walk($nested_item, $data);
    }

    $options_list = $data['options'];
  }

  return $options_list;
}

/**
 * Load menu item children.
 *
 * This function is recursive.
 *
 * @param object $item
 *   The menu item object.
 * @param array $data
 *   An array of data globally shared between the different recursive calls.
 *
 * @see workbench_menu_get_menu_items_select_list_options()
 */
function workbench_menu_get_menu_items_select_list_options_recursive_walk(&$item, &$data) {
  if (!isset($data['depth'])) {
    $data['depth'] = 0;
  }

  $item_id = & $item['item']->id;

  if ($data['depth'] > 0) {
    $data['options'][$item_id] = str_repeat('- ', $data['depth']) . $item['item']->human_name;
  }
  else {
    $data['options'][$item_id] = $item['item']->human_name;
  }

  if (!empty($item['children'])) {
    $data['depth']++;

    foreach ($item['children'] as &$child) {
      workbench_menu_get_menu_items_select_list_options_recursive_walk($child, $data);
    }

    $data['depth']--;
  }
}

/**
 * Validate that a user has menu edit access.
 *
 * @param string|null $access_type
 *   The type of access requested (e.g. taxonomy).
 *   If NULL is passed, then this simply returnes whether or not the
 *   user has 'edit workbench menu' access.
 *
 * @param int|null $access_id
 *   The access_id to validate against.
 *   If NULL is passed, then this simply returnes whether or not the
 *   user has 'edit workbench menu' access.
 *
 * @see workbench_menu_access_menu()
 */
function workbench_menu_edit_access($access_type = NULL, $access_id = NULL) {
  if (user_access('admin workbench menu')) {
    return TRUE;
  }

  if ($access_type == NULL || $access_id == NULL) {
    return user_access('edit workbench menu');
  }

  if (!user_access('edit workbench menu')) return FALSE;

  if ($access_type == 'taxonomy') {
    return workbench_menu_access_menu($access_id);
  }

  return FALSE;
}

/**
 * Clears the given workbench menus by the access id.
 *
 * @param int $access_id
 *   The access id of the menu to clear.
 * @param array $processed
 *   A collection of menus whose cache has already been cleared.
 *   This prevents infinite recursion.
 */
function workbench_menu_clear_cache_by_access_id($access_id, &$processed) {
  if (!cf_is_integer($access_id)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_integer('access_id');
    }

    return;
  }

  if (!is_array($processed)) {
    $processed = array();
  }

  if (in_array($access_id, $processed)) {
    return;
  }

  $menus = (array) workbench_menu_get_menus(array('access_id' => $access_id, 'fast' => NULL), 'id');

  if (empty($menus)) {
    return;
  }

  reset($menus);
  $menu = current($menus);

  workbench_menu_clear_cache_by_menu_id($menu->id, $processed);
}

/**
 * Clears the given workbench menus by the menu id.
 *
 * @param int $id
 *   The menu id of the menu to clear.
 * @param array $processed
 *   A collection of menus whose cache has already been cleared.
 *   This prevents infinite recursion.
 */
function workbench_menu_clear_cache_by_menu_id($id, &$processed) {
  if (!cf_is_integer($id)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_integer('id');
    }

    return;
  }

  if (!is_array($processed)) {
    $processed = array();
  }

  if (array_key_exists($id, $processed)) {
    return;
  }

  $menus = (array) workbench_menu_get_menus(array('id' => $id, 'fast' => NULL), 'id');

  if (empty($menus)) {
    return;
  }

  reset($menus);
  $menu = current($menus);

  $menu_items = (array) workbench_menu_get_menus(array('menu_id' => $menu->id, 'fast' => NULL), 'id');

  workbench_menu_clear_cache_at_path($menu->path);
  $processed[$menu->id] = $menu->access_id;

  // recursively process each associated menu.
  $items = (array) workbench_menu_get_menu_items(array('item_type' => array('item_menu'), 'fast' => NULL), 'id');

  foreach ($items as $item) {
    $properties = unserialize($item->properties);
    if ($properties['menu'] == $menu->id) {
      workbench_menu_clear_cache_by_menu_id($item->menu_id, $processed);
    }
  }

  // recursively process each associated menu items.
  $items = (array) workbench_menu_get_menu_items(array('item_type' => array('item_menu_item'), 'fast' => NULL), 'id');

  foreach ($items as $item) {
    $properties = unserialize($item->properties);
    if (array_key_exists($properties['menu_item'], $menu_items)) {
      workbench_menu_clear_cache_by_menu_id($item->menu_id, $processed);
    }
  }

  // clear cache for all menus with a given alias.
  $menus = (array) workbench_menu_get_menus(array('alias' => $menu->id, 'fast' => NULL), 'id');

  if (empty($menus)) {
    return;
  }

  unset($menu);
  foreach ($menus as $menu) {
    if (!array_key_exists($menu->id, $processed)) {
      workbench_menu_clear_cache_by_menu_id($menu->id, $processed);
    }
  }
}

/**
 * Clears the workbench menu cache for the menu cache for some path.
 *
 * @param string $path
 *   A string representing the path to clear.
 */
function workbench_menu_clear_cache_at_path($path) {
  if (!is_string($path)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_string('path');
    }

    return;
  }

  $parts = explode('/', $path);
  $menu_cache_id = 'workbench_menu-menus_at-' . $parts[0];
  $breadcrumb_cache_id = 'workbench_menu-breadcrumbs_at-' . $parts[0];

  $cached_menu = cache_get($menu_cache_id, 'cache_menu');
  $cached_breadcrumb = cache_get($breadcrumb_cache_id, 'cache_menu');

  while (!empty($parts)) {
    $subpath = implode('/', $parts);
    $part = array_pop($parts);

    if (empty($part)) continue;

    if ($cached_menu) {
      $menus_cached = $cached_menu->data;
      unset($menus_cached[$subpath]);
    }

    if ($cached_breadcrumb) {
      $breadcrumbs_cached = $cached_breadcrumb->data;
      unset($breadcrumbs_cached[$subpath]);
    }
  }

  if ($cached_menu) {
    cache_set($menu_cache_id, $menus_cached, 'cache_menu');
  }

  if ($cached_breadcrumb) {
    cache_set($menu_cache_id, $breadcrumbs_cached, 'cache_menu');
  }
}

/**
 * Generates the JS array for workbench node id autocomplete fields.
 *
 * This pulls the first 15 results that match the specified string.
 *
 * @param string $string
 *   A string to match node titles against.
 * @return array
 *   An array of string matches.
 */
function workbench_menu_autocomplete_nid($string) {
  if (function_exists('devel_menu')) {
    $GLOBALS['devel_shutdown'] = FALSE;
  }

  if (!is_string($string)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_string('string');
    }

    drupal_json_output(array());
    return;
  }

  // do not allow anonymous to utilize this jquery search
  $user = cf_current_user();
  if ($user->uid == 0) {
    drupal_json_output(array());
    return;
  }

  $s = trim($string);

  $ilike = 'LIKE';
  if (db_driver() == 'pgsql') {
    $ilike = 'ILIKE';
  }

  try {
    $query = db_select('node', 'n');
    $query->fields('n', array('nid', 'title'));
    $query->addTag('workbench_menu_autocomplete_nid');
    $query->condition('title', '%' . db_like($s) . '%', $ilike);
    $query->orderBy('title');
    $query->range(0, 9);

    $executed = $query->execute();
    $results = $executed->fetchAll();
  }
  catch (Exception $e) {
    if (class_exists('cf_error')) {
      cf_error::on_query_execution($e);
    }

    drupal_json_output(array());
    return;
  }

  $nids = array();
  $matches = array();
  foreach ($results as $node) {
    $value = $node->title . ' [nid: ' . $node->nid . ']';
    $matches[$value] = check_plain($value);
    $nids[] = $node->nid;
  }

  $matched = count($matches);
  if ($matched < 9) {
    try {
      $query = db_select('node', 'n');
      $query->fields('n', array('nid', 'title'));
      $query->addTag('workbench_menu_autocomplete_nid');

      if (!empty($nids)) {
        $query->condition('n.nid', $nids, 'NOT IN');
      }

      $query->condition('title', '%' . db_like($s) . '%', $ilike);
      $query->orderBy('title');
      $query->range(0, 9 - $matched);

      $executed = $query->execute();
      $results = $executed->fetchAll();
    }
    catch (Exception $e) {
      if (class_exists('cf_error')) {
        cf_error::on_query_execution($e);
      }

      drupal_json_output($matches);
      return;
    }

    foreach ($results as $node) {
      $value = $node->title . ' [nid: ' . $node->nid . ']';
      $matches[$value] = check_plain($value);
    }
  }

  drupal_json_output($matches);
}

/**
 * Generates the JS array for workbench file id autocomplete fields.
 *
 * This pulls the first 9 results that match the specified string.
 *
 * @param string $string
 *   A string to match node titles against.
 * @return array
 *   An array of string matches.
 */
function workbench_menu_autocomplete_fid($string) {
  if (function_exists('devel_menu')) {
    $GLOBALS['devel_shutdown'] = FALSE;
  }

  if (!is_string($string)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_string('string');
    }

    drupal_json_output(array());
    return;
  }

  // do not allow anonymous to utilize this jquery search
  $user = cf_current_user();
  if ($user->uid == 0) {
    drupal_json_output(array());
    return;
  }

  // only allowed wrappers are processed
  $wrappers = file_get_stream_wrappers(STREAM_WRAPPERS_READ | STREAM_WRAPPERS_VISIBLE);
  if (empty($wrappers)) {
    drupal_json_output(array());
    return;
  }

  $s = trim($string);

  $ilike = 'LIKE';
  if (db_driver() == 'pgsql') {
    $ilike = 'ILIKE';
  }

  try {
    $or = db_or();
    foreach ($wrappers as $w => &$wrapper) {
      $or->condition('fm.uri', db_like($w) . '://%', $ilike);
    }

    $query = db_select('file_managed', 'fm');
    $query->fields('fm', array('fid', 'filename'));
    $query->addTag('workbench_menu_autocomplete_fid');
    $query->condition('fm.filename', db_like($s) . '%', $ilike);
    $query->condition('fm.status', 1);
    $query->condition($or);
    $query->range(0, 9);

    $results = $query->execute();

    $fids = array();
    $matches = array();
    foreach ($results as $result) {
      $value = $result->filename . ' [fid: ' . $result->fid . ']';
      $matches[$value] = check_plain($value);
      $fids[] = $result->fid;
    }

    $matched = count($matches);
    if ($matched < 9) {
      $query = db_select('file_managed', 'fm');
      $query->fields('fm', array('fid', 'filename'));
      $query->addTag('workbench_menu_autocomplete_fid');

      if (!empty($fids)) {
        $query->condition('fm.fid', $fids, 'NOT IN');
      }

      $query->condition('fm.filename', '%' . db_like($s) . '%', $ilike);
      $query->condition($or);
      $query->condition('fm.status', 1);
      $query->range(0, 9 - $matched);

      $results = $query->execute();

      foreach ($results as $result) {
        $value = $result->filename . ' [fid: ' . $result->fid . ']';
        $matches[$value] = check_plain($value);
      }
    }
  }
  catch (Exception $e) {
    if (class_exists('cf_error')) {
      cf_error::on_query_execution($e);
    }

    drupal_json_output($matches);
    return;
  }

  drupal_json_output($matches);
}

/**
 * Generates the JS array for workbench menu id autocomplete fields.
 *
 * This pulls the first 9 results that match the specified string.
 *
 * @param string $string
 *   A string to match node titles against.
 * @return array
 *   An array of string matches.
 */
function workbench_menu_autocomplete_menu_id($string) {
  if (function_exists('devel_menu')) {
    $GLOBALS['devel_shutdown'] = FALSE;
  }

  if (!is_string($string)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_string('string');
    }

    return array();
  }

  // do not allow anonymous to utilize this jquery search
  $user = cf_current_user();
  if ($user->uid == 0) {
    return array();
  }

  $s = trim($string);

  $ilike = 'LIKE';
  if (db_driver() == 'pgsql') {
    $ilike = 'ILIKE';
  }

  try {
    $query = db_select('taxonomy_term_data', 'ttd');
    $query->innerjoin('workbench_menus', 'wm', 'ttd.tid = CAST(wm.access_id as integer)');
    $query->fields('ttd', array('tid', 'name'));
    $query->fields('wm', array('id'));
    $query->addTag('workbench_menu_autocomplete_menu_id');
    $query->condition('ttd.name', '%' . db_like($s) . '%', $ilike);
    $query->orderBy('name');
    $query->range(0, 9);

    $executed = $query->execute();
    $results = $executed->fetchAll();
  }
  catch (Exception $e) {
    if (class_exists('cf_error')) {
      cf_error::on_query_execution($e);
    }

    drupal_json_output(array());
    return;
  }

  $tids = array();
  $matches = array();
  foreach ($results as $term) {
    $value = $term->name . ' [id: ' . $term->id . ']';
    $matches[$value] = check_plain($value);
    $tids[] = $term->tid;
  }

  $matched = count($matches);
  if ($matched < 9) {
    try {
      $query = db_select('taxonomy_term_data', 'ttd');
      $query->innerjoin('workbench_menus', 'wm', 'ttd.tid = CAST(wm.access_id as integer)');
      $query->fields('ttd', array('tid', 'name'));
      $query->fields('wm', array('id'));
      $query->addTag('workbench_menu_autocomplete_menu_id');

      if (!empty($tids)) {
        $query->condition('ttd.tid', $tids, 'NOT IN');
      }

      $query->condition('ttd.name', '%' . db_like($s) . '%', $ilike);
      $query->orderBy('name');
      $query->range(0, 9 - $matched);

      $executed = $query->execute();
      $results = $executed->fetchAll();
    }
    catch (Exception $e) {
      if (class_exists('cf_error')) {
        cf_error::on_query_execution($e);
      }

      drupal_json_output($matches);
      return;
    }

    foreach ($results as $term) {
      $value = $term->name . ' [id: ' . $term->id . ']';
      $matches[$value] = check_plain($value);
    }
  }

  drupal_json_output($matches);
}

/**
 * Generates the JS array for workbench menu item id autocomplete fields.
 *
 * This pulls the first 9 results that match the specified string.
 *
 * @param string $string
 *   A string to match node titles against.
 * @return array
 *   An array of string matches.
 */
function workbench_menu_autocomplete_menu_item_id($string) {
  if (function_exists('devel_menu')) {
    $GLOBALS['devel_shutdown'] = FALSE;
  }

  if (!is_string($string)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_string('string');
    }

    return array();
  }

  // do not allow anonymous to utilize this jquery search
  $user = cf_current_user();
  if ($user->uid == 0) {
    return array();
  }

  $s = trim($string);

  $ilike = 'LIKE';
  if (db_driver() == 'pgsql') {
    $ilike = 'ILIKE';
  }

  try {
    $query = db_select('workbench_menu_items', 'wmi');
    $query->innerjoin('workbench_menu_item_types', 'wmit', 'wmi.id = wmit.item_id');
    $query->leftjoin('workbench_menu_options_item_type', 'wmoit', 'wmit.item_type_id = wmoit.id ');
    $query->fields('wmi', array('id', 'human_name'));
    $query->addTag('workbench_menu_autocomplete_menu_item_id');

    $query->condition('wmi.human_name', '%' . db_like($s) . '%', $ilike);
    $query->condition('wmoit.machine_name', 'item_menu', '<>');
    $query->condition('wmoit.machine_name', 'item_menu_item', '<>');

    $query->orderBy('wmi.human_name');
    $query->range(0, 9);

    $executed = $query->execute();
    $results = $executed->fetchAll();

    $iids = array();
    foreach ($results as $item) {
      $value = $item->human_name . ' [id: ' . $item->id . ']';
      $matches[$value] = check_plain($value);
      $iids[] = $item->id;
    }

    $matched = count($matches);
    if ($matched < 9) {
      $query = db_select('workbench_menu_items', 'wmi');
      $query->innerjoin('workbench_menu_item_types', 'wmit', 'wmi.id = wmit.item_id');
      $query->leftjoin('workbench_menu_options_item_type', 'wmoit', 'wmit.item_type_id = wmoit.id ');
      $query->fields('wmi', array('id', 'human_name'));
      $query->addTag('workbench_menu_autocomplete_menu_item_id');

      $query->condition('wmi.human_name', '%' . db_like($s) . '%', $ilike);
      $query->condition('wmoit.machine_name', 'item_menu', '<>');
      $query->condition('wmoit.machine_name', 'item_menu_item', '<>');

      $query->orderBy('wmi.human_name');
      $query->range(0, 9);

      $executed = $query->execute();
      $results = $executed->fetchAll();

      foreach ($results as $item) {
        $value = $item->human_name . ' [id: ' . $item->id . ']';
        $matches[$value] = check_plain($value);
      }
    }
  }
  catch (Exception $e) {
    if (class_exists('cf_error')) {
      cf_error::on_query_execution($e);
    }

    return $matches;
  }

  drupal_json_output($matches);
}

/**
 * Perform a db check to see if a menu with the given id exists.
 *
 * @param int $menu_id
 *   The numeric id for the given menu.
 * @param int $is_access_id
 *   (optional) If set to TRUE, then the menu_id is instead an access_id.
 *
 * @return bool|null
 *   Returns TRUE/FALSE if the item exists and NULL on error.
 */
function workbench_menu_menu_exists($menu_id = NULL, $is_access_id = FALSE) {
  if (!cf_is_integer($menu_id)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_numeric('menu_id');
    }

    return NULL;
  }

  if (!is_bool($is_access_id)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_bool('is_access_id');
    }

    return NULL;
  }

  $query = db_select('workbench_menus', 'wm');

  $query->fields('wm');

  if ($is_access_id) {
    $query->condition('wm.access_id', $menu_id);
  }
  else {
    $query->condition('wm.id', $menu_id);
  }

  $executed = $query->execute();

  return $executed->rowCount() > 0;
}

/**
 * Perform a db check to see if a menu item with the given id exists.
 *
 * When a menu id is specified, then this returns TRUE/FALSE depending on
 * whether or not that item exists and is associated with the specified menu.
 *
 * @param int $item_id
 *   The numeric id for the given menu item.
 * @param int $menu_id
 *   (optional) numeric id for the given menu.
 * @param int $is_access_id
 *   (optional) If set to TRUE, then the menu_id is instead an access_id.
 *
 * @return bool|null
 *   Returns TRUE/FALSE if the item exists and NULL on error.
 */
function workbench_menu_menu_item_exists($item_id, $menu_id = NULL, $is_access_id = FALSE) {
  if (!cf_is_integer($item_id)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_numeric('item_id');
    }

    return NULL;
  }

  $query = db_select('workbench_menu_items', 'wmi');
  $query->fields('wmi');
  $query->condition('wmi.id', $item_id);

  if (!is_null($menu_id)) {
    if (!cf_is_integer($menu_id)) {
      if (class_exists('cf_error')) {
        cf_error::invalid_numeric('menu_id');
      }

      return NULL;
    }

    if (!is_bool($is_access_id)) {
      if (class_exists('cf_error')) {
        cf_error::invalid_bool('is_access_id');
      }

      return NULL;
    }

    if ($is_access_id) {
      $query->innerjoin('workbench_menus', 'wm', 'wm.id = wmi.menu_id');
      $query->condition('wm.access_id', $menu_id);
    }
    else {
      $query->condition('wmi.menu_id', $menu_id);
    }
  }

  $executed = $query->execute();

  return $executed->rowCount() > 0;
}

/**
 * Validate that a user has workbench access for a given access id.
 *
 * @param int $access_id
 *   The access_id to validate against.
 *
 * @param object $account
 *   The user account to test access for, defaults to current user.
 */
function workbench_menu_access_menu($access_id, $account = NULL) {
  if (!cf_is_integer($access_id)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_numeric('access_id');
    }

    return FALSE;
  }

  if (is_null($account)) {
    $account = cf_current_user();
  }
  else if (!is_object($account)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_object('account');
    }

    return FALSE;
  }

  try {
    $query = db_select('workbench_access', 'wa');
    $query->join('workbench_access_user', 'wau', 'wa.access_id = wau.access_id AND wa.access_scheme = wau.access_scheme');
    $query->join('users_roles', 'ur', 'ur.uid = wau.uid');
    $query->fields('wa', array('access_id', 'access_type', 'access_scheme', 'access_type_id'));
    $query->distinct();

    $query->condition('wa.access_id', $access_id);
    $query->condition('wau.uid', $account->uid);

    $field = $query->execute()->fetchField();

    if (!empty($field)) return TRUE;

    $query = db_select('workbench_access', 'wa');
    $query->join('workbench_access_role', 'war', 'wa.access_id = war.access_id AND wa.access_scheme = war.access_scheme');
    $query->join('users_roles', 'ur', 'ur.rid = war.rid');
    $query->fields('wa', array('access_id', 'access_type', 'access_scheme', 'access_type_id'));
    $query->distinct();

    $query->condition('wa.access_id', $access_id);
    $query->condition('war.rid', array_keys($account->roles), 'IN');

    $field = $query->execute()->fetchField();

    if (!empty($field)) return TRUE;
  }
  catch (Exception $e) {
    if (class_exists('cf_error')) {
      cf_error::on_query_execution($e);
    }
  }

  return FALSE;
}

/**
 * Return an array of default menu item settings/
 *
 * @param object|null $item
 *   (optional) An already loaded menu item object.
 *
 * @return array
 *   An array of default menu item settings.
 */
function workbench_menu_get_menu_item_defaults($item = NULL) {
  $defaults = array();
  $defaults['human_name'] = '';
  $defaults['parent_id'] = '0';
  $defaults['weight'] = '0';
  $defaults['active_path'] = '';
  $defaults['item_type'] = 'item_node';
  $defaults['expand'] = 'expand_auto';
  $defaults['properties'] = array();
  $defaults['properties']['url'] = '';
  $defaults['properties']['node_id'] = '';
  $defaults['properties']['top_as'] = 'menu_path';
  $defaults['properties']['disabled'] = FALSE;
  $defaults['properties']['clickable'] = FALSE;
  $defaults['properties']['no_breadcrumb'] = FALSE;
  $defaults['properties']['file'] = '';
  $defaults['properties']['file_type'] = 'file';
  $defaults['properties']['menu'] = NULL;
  $defaults['properties']['menu_item'] = NULL;
  $defaults['properties']['never_suppress'] = FALSE;
  $defaults['properties']['always_suppress'] = FALSE;

  if (is_object($item)) {
    if (property_exists($item, 'human_name') && is_string($item->human_name)) {
      $defaults['human_name'] = $item->human_name;
    }

    if (property_exists($item, 'parent_id')) {
      if (cf_is_integer($item->parent_id)) {
        $defaults['parent_id'] = $item->parent_id;
      }
      elseif (is_null($item->parent_id)) {
        $defaults['parent_id'] = -1;
      }
    }

    if (property_exists($item, 'weight') && cf_is_integer($item->weight)) {
      $defaults['weight'] = $item->weight;
    }

    if (property_exists($item, 'active_path') && is_string($item->active_path)) {
      $defaults['active_path'] = $item->active_path;

      // be user-friendly and show normal spaces instead of %20.
      $defaults['active_path'] = preg_replace('/%20/', ' ', $defaults['active_path']);
    }

    if (property_exists($item, 'item_type') && is_array($item->item_type)) {
      foreach ($item->item_type as &$type) {
        $defaults['item_type'] = $type->machine_name;
      }
    }

    if (property_exists($item, 'expand') && is_array($item->expand)) {
      foreach ($item->expand as &$expand) {
        $defaults['expand'] = $expand->machine_name;
      }
    }

    if (property_exists($item, 'properties') && is_array($item->properties)) {
      foreach ($item->properties as $key => &$value) {
        $defaults['properties'][$key] = $value;
      }
    }

    if (!empty($defaults['properties']['url'])) {
      // be user-friendly and show normal spaces instead of %20.
      $defaults['properties']['url'] = preg_replace('/%20/', ' ', $defaults['properties']['url']);
    }

    if (!empty($defaults['properties']['file'])) {
      // be user-friendly and show normal spaces instead of %20.
      $defaults['properties']['file'] = preg_replace('/%20/', ' ', $defaults['properties']['file']);
    }

    if (!empty($defaults['properties']['node_id'])) {
      $defaults['properties']['node_id'] = $defaults['properties']['node_id'];
    }

    if (isset($defaults['properties']['never_suppress']) && is_bool($defaults['properties']['never_suppress'])) {
      $defaults['properties']['never_suppress'] = $defaults['properties']['never_suppress'];
    }

    if (isset($defaults['properties']['always_suppress']) && is_bool($defaults['properties']['always_suppress'])) {
      $defaults['properties']['always_suppress'] = $defaults['properties']['always_suppress'];
    }
  }

  return $defaults;
}

/**
 * Adds or Updates a menu item.
 *
 * @param object menu
 *   The menu object that the item will be added to.
 * @param array settings
 *   An array containin the menu item settings.
 * @param int|null item_id
 *   Set this to null to add a new item.
 *   Set this to the numeric menu item id to update an existing item.
 *
 * @return bool
 *   TRUE on success, FALSE otherwise.
 */
function workbench_menu_update_menu_item($menu, $settings, $item_id = NULL) {
  if (!is_object($menu)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_object('menu');
    }
    return FALSE;
  }

  if (!is_array($settings)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_array('settings');
    }
    return FALSE;
  }

  if (!is_null($item_id) && !cf_is_integer($item_id)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_numeric('item_id');
    }
    return FALSE;
  }

  $transaction = db_transaction();
  $user = cf_current_user();
  $taxonomy_term = taxonomy_term_load($menu->access_id);

  if (is_null($item_id)) {
    watchdog('Workbench Menu', "The user %user has added a new item %item to the menu %menu (%menu_id)", array('%user' => $user->name, '%item' => $settings['human_name'], '%menu' => $taxonomy_term->name, '%menu_id' => $menu->id), WATCHDOG_INFO);
  }
  else {
    watchdog('Workbench Menu', "The user %user has changed the item %item (%item_id) from the menu %menu (%menu_id)", array('%user' => $user->name, '%item' => $settings['human_name'], '%item_id' => $item_id, '%menu' => $taxonomy_term->name, '%menu_id' => $menu->id), WATCHDOG_INFO);
  }

  try {
    if (is_null($item_id)) {
      $existing = NULL;
    }
    else {
      $query = db_select('workbench_menu_items', 'wmi');
      $query->fields('wmi');
      $query->condition('id', $item_id);
      $existing = $query->execute()->fetchAll();
    }

    $columns = array('menu_id', 'parent_id', 'human_name', 'weight', 'active_path', 'properties');
    $record = array();
    $record['menu_id'] = $menu->id;
    $record['parent_id'] = $settings['parent_id'];
    $record['human_name'] = $settings['human_name'];
    $record['weight'] = $settings['weight'];
    $record['active_path'] = $settings['active_path'];
    $record['properties'] = $settings['properties'];

    if (empty($existing)) {
      drupal_write_record('workbench_menu_items', $record);
      $item_id = $record['id'];
    }
    else {
      $primary_keys = array('id');
      $record['id'] = $item_id;
      drupal_write_record('workbench_menu_items', $record, $primary_keys);
    }

    foreach (array('expand', 'item_type') as $name) {
      if (!empty($existing)) {
        $query = db_delete('workbench_menu_' . $name . 's');
        $query->condition('item_id', $item_id);
        $query->execute();
      }

      $options = (array) cf_db_options_get_options('workbench_menu', $name);

      if (!empty($settings[$name]) && isset($options[$settings[$name]])) {
        $record = array();
        $record['item_id'] = $item_id;
        $record[$name . '_id'] = $options[$settings[$name]]->id;

        $query = db_insert('workbench_menu_' . $name . 's');
        $query->fields($record);
        $query->execute();
      }
    }

    // enforce transaction execution
    unset($transaction);
  }
  catch (Exception $e) {
    $transaction->rollback();

    if (class_exists('cf_error')) {
      cf_error::on_query_execution($e);
    }

    return FALSE;
  }

  return TRUE;
}

/**
 * Deletes an existing menu item.
 *
 * @param int item_id
 *   The numeric menu item id..
 *
 * @return bool
 *   TRUE on success, FALSE otherwise.
 */
function workbench_menu_delete_menu_item($item_id) {
  if (!cf_is_integer($item_id)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_numeric('item_id');
    }
    return FALSE;
  }

  // load the item settings.
  $items = (array) workbench_menu_get_menu_items(array('id' => $item_id, 'fast' => NULL), 'id');

  if (empty($items)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_variable('item_id', "There is no item with an id of %item_id", array('%item_id' => $item_id));
    }
    return FALSE;
  }

  reset($items);
  $item = current($items);

  $menus = (array) workbench_menu_get_menus(array('id' => $item->menu_id, 'fast' => NULL), 'id');

  if (empty($menus)) {
    if (class_exists('cf_error')) {
      cf_error::invalid_variable('item->menu_id', "There is no menu with an id of %menu_id", array('%menu_id' => $item->menu_id));
    }
    return FALSE;
  }

  reset($menus);
  $menu = current($menus);

  $user = cf_current_user();
  $taxonomy_term = taxonomy_term_load($menu->access_id);
  $child_items = array();

  try {
    $query = db_select('workbench_menu_items', 'wmi');
    $query->fields('wmi', array('parent_id'));
    $query->condition('wmi.id', $item_id);

    $parent_id = (int) $query->execute()->fetchField();

    $query = db_select('workbench_menu_items', 'wmi');
    $query->fields('wmi', array('id', 'human_name'));
    $query->condition('wmi.parent_id', $item_id);

    $menu_item_children = array();
    $results = (array) $query->execute()->fetchAll();
    foreach ($results as &$result) {
      $menu_item_children[$result->id] = $result->human_name;
    }
  }
  catch (Exception $e) {
    if (class_exists('cf_error')) {
      cf_error::on_query_execution($e);
    }

    watchdog('Workbench Menu', t("An unexpected error happened while trying to process child menu items with a parent id of %item_id."), array('%item_id' => $item_id), WATCHDOG_ERROR);
  }

  watchdog('Workbench Menu', "The user %user has deleted the item %item (%item_id) from the menu %menu (%menu_id)", array('%user' => $user->name, '%item' => $item->human_name, '%item_id' => $item_id, '%menu' => $taxonomy_term->name, '%menu_id' => $menu->id), WATCHDOG_INFO);
  watchdog('Workbench Menu', "Due to deletion of %item (%item_id), the following child items are being re-assigned to the item %parent_item_id: %child_items", array('%item' => $item->human_name, '%item_id' => $item_id, '%parent_item_id' => $parent_id, '%child_items' => print_r($menu_item_children, TRUE)), WATCHDOG_INFO);

  $transaction = db_transaction();

  try {
    $query = db_delete('workbench_menu_items');
    $query->condition('id', $item_id);
    $query->execute();

    foreach (array('expand', 'item_type') as $name) {
      $query = db_delete('workbench_menu_' . $name . 's');
      $query->condition('item_id', $item_id);
      $query->execute();
    }

    // re-attach all child menu items to the parent of the deleted menu item to prevent dangling items.
    $query = db_update('workbench_menu_items');
    $query->condition('parent_id', $item_id);
    $query->fields(array('parent_id' => $parent_id));
    $query->execute();

    // enforce transaction execution
    unset($transaction);
  }
  catch (Exception $e) {
    $transaction->rollback();

    if (class_exists('cf_error')) {
      cf_error::on_query_execution($e);
    }
  }
}
