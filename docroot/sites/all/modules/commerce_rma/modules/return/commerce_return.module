<?php

/**
 * @file
 * Defines the custom Commerce return entity and API functions to manage
 * order's returns and interact with them. Mostly stolen from commerce_order
 * module.
 */

/**
 * Implements hook_entity_info().
 */
function commerce_return_entity_info() {
  return array(
    'commerce_return' => array(
      'label' => t('Commerce Return', array(), array('context' => 'a drupal commerce return')),
      'controller class' => 'CommerceReturnEntityController',
      'entity class' => 'CommerceReturn',
      'metadata controller class' => 'CommerceReturnMetadataController',
      'views controller class' => 'CommerceReturnViewsController',
      'locking mode' => 'pessimistic',
      'base table' => 'commerce_return',
      'revision table' => 'commerce_return_revision',
      'load hook' => 'commerce_return_load',
      'uri callback' => 'commerce_return_uri',
      'label callback' => 'commerce_return_label',
      // Enable the entity API's admin UI.
      'admin ui' => array(
        'path' => 'admin/commerce/store/returns',
        'file' => 'includes/commerce_return.admin.inc',
        'controller class' => 'CommerceReturnUIController',
        'menu wildcard' => '%commerce_return',
      ),
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'return_id',
        'revision' => 'revision_id',
        'bundle' => 'type',
      ),
      'bundle keys' => array(
        'bundle' => 'type',
      ),
      'bundles' => array(
        'commerce_return' => array(
          'label' => t('Return', array(), array('context' => 'a drupal commerce return')),
          'admin' => array(
            'path' => 'admin/commerce/store/returns/manage',
            'access arguments' => array('administer commerce_return entities'),
          ),
        ),
      ),
      'view modes' => array(
        'administrator' => array(
          'label' => t('Administrator'),
          'custom settings' => FALSE,
        ),
        'customer' => array(
          'label' => t('Customer'),
          'custom settings' => FALSE,
        ),
      ),
      'token type' => 'commerce-return',
      'access callback' => 'commerce_entity_access',
      'access arguments' => array(
        'user key' => 'uid',
        'access tag' => 'commerce_return_access',
      ),
      'permission labels' => array(
        'singular' => t('return'),
        'plural' => t('returns'),
      ),
      // Prevent Redirect alteration of the return form.
      'redirect' => FALSE,
      'module' => 'commerce_return'
    ),
    'commerce_return_reason' => array(
      'label' => t('Return Reason', array(), array('context' => 'a return reason for a drupal commerce return')),
      'entity class' => 'CommerceReturnReason',
      'controller class' => 'CommerceReturnReasonEntityController',
      'locking mode' => 'pessimistic',
      'base table' => 'commerce_return_reason',
      'load hook' => 'commerce_return_reason_load',
      'uri callback' => 'commerce_return_reason_uri',
      'label callback' => 'commerce_return_reason_label',
      // Enable the entity API's admin UI. The default UI is plugged on the
      // settings page of the Commerce Return entity type.
      'admin ui' => array(
        'path' => 'admin/commerce/store/returns/reasons',
        'file' => 'includes/commerce_return.admin.inc',
        'controller class' => 'CommerceReturnReasonUIController',
        'menu wildcard' => '%commerce_return_reason',
      ),
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'return_reason_id',
        'bundle' => 'type',
      ),
      'bundle keys' => array(
        'bundle' => 'type',
      ),
      'bundles' => array(
        'product' => array(
          'label' => t('Return reason for products', array(), array('context' => 'a return reason displayed on product level.'))
        ),
        'product_type' => array(
          'label' => t('Return reason for product types', array(), array('context' => 'a return reason displayed on product type level.'))
        )
      ),
      'view modes' => array(
        'administrator' => array(
          'label' => t('Administrator'),
          'custom settings' => FALSE,
        ),
        'customer' => array(
          'label' => t('Customer'),
          'custom settings' => FALSE,
        ),
      ),
      'token type' => 'commerce-return-reason',
      'access callback' => 'commerce_entity_access',
      'access arguments' => array(
        'user key' => 'uid',
      ),
      'permission labels' => array(
        'singular' => t('return reason'),
        'plural' => t('return reasons'),
      ),
      // Prevent Redirect alteration of the return form.
      'redirect' => FALSE,
      'module' => 'commerce_return',
    ),
  );
}

/**
 * Implements hook_permission().
 */
function commerce_return_permission() {
  return commerce_entity_access_permissions('commerce_return') + array(
    'configure return settings' => array(
      'title' => t('Configure return settings'),
      'description' => t('Allows users to configure return settings for the store.'),
      'restrict access' => TRUE,
    ),
    'access return of goods' => array(
      'title' => t('Access return of goods'),
      'description' => t('Give a customer the opportunity to return purchased products.'),
    ),
  );
}

/**
 * Implements hook_theme().
 */
function commerce_return_theme() {
  return array(
    'commerce_return_line_item_manager_admin' => array(
      'render element' => 'form',
    ),
    'commerce_return_line_item_manager_customer' => array(
      'render element' => 'form',
    ),
  );
}

/**
 * Implements hook_preprocess_field().
 */
function commerce_return_preprocess_field(&$vars) {
  $element = $vars['element'];
  // Display link with path for customer on customer view mode.
  if ($element['#entity_type'] == 'commerce_return'
    && $element['#bundle'] == 'commerce_return'
    && $element['#field_name'] == 'commerce_order_reference'
    && $element['#view_mode'] == 'customer'
    && $element['#formatter'] == 'entityreference_label'){
    foreach ($vars['items'] as $i => &$item) {
      // A link in markup means link setting has been checked. So override it.
      if (strpos($item['#markup'], '<a href') !== FALSE) {
        $order_id = $element['#items'][$i]['target_id'];
        $path = 'user/' . $element['#object']->uid . '/order/' . $order_id;
        $item['#markup'] = l(t('Order @number', array('@number' => $order_id)), $path);
      }
    }
  }
}

/**
 * Entity uri callback: gives modules a chance to specify a path for a return.
 */
function commerce_return_uri($return) {
}

/*
 * Entity uri callback: gives modules a chance to specify a path for a return
 * reason.
 */
function commerce_return_reason_uri($return_reason) {

}

/**
 * Return RMA customer profile data.
 *
 * @return array.
 *   The RMA customer profile.
 */
function commerce_return_customer_profile() {
  return array(
    'type' => 'rma',
    'name' => t('Return information'),
    'description' => t('The profile used to collect return information when creating a new return.'),
    'help' => t(
      'Please, fill out your address information. These information can be required if you
                 ask for swapping a product or if your address has changed since you have placed an order with us.'
    ),
    'label_callback' => 'commerce_customer_profile_default_label',
  );
}

/**
 * Entity label callback: returns the label for an individual return.
 */
function commerce_return_label($entity, $entity_type) {
  return t('Return @number', array('@number' => $entity->return_number));
}

/**
 * Implements hook_entity_property_info_alter() on top of the Order module.
 */
function commerce_return_entity_property_info_alter(&$info) {
  // Move the line items and return total properties to the return by default; as
  // they are required default fields, this makes dealing with them more convenient.
  $properties = array();

  foreach ($info['commerce_return']['bundles'] as $bundle => $bundle_info) {
    $bundle_info += array('properties' => array());
    $properties += $bundle_info['properties'];
  }

  $info['commerce_return']['properties']['commerce_return_line_items'] = $properties['commerce_return_line_items'];
  $info['commerce_return']['properties']['commerce_return_total'] = $properties['commerce_return_total'];
}

/**
 * Implements hook_hook_info().
 */
function commerce_return_hook_info() {
  $hooks = array(
    'commerce_return_state_info' => array(
      'group' => 'commerce',
    ),
    'commerce_return_state_info_alter' => array(
      'group' => 'commerce',
    ),
    'commerce_return_status_info' => array(
      'group' => 'commerce',
    ),
    'commerce_return_status_info_alter' => array(
      'group' => 'commerce',
    ),
    'commerce_return_reason_info' => array(
      'group' => 'commerce',
    ),
    'commerce_return_reason_info_alter' => array(
      'group' => 'commerce',
    ),
    'commerce_return_line_item_status_info' => array(
      'group' => 'commerce',
    ),
    'commerce_return_line_item_status_info_alter' => array(
      'group' => 'commerce',
    ),
    'commerce_return_uri' => array(
      'group' => 'commerce',
    ),
    'commerce_return_view' => array(
      'group' => 'commerce',
    ),
    'commerce_return_presave' => array(
      'group' => 'commerce',
    ),
    'commerce_return_update' => array(
      'group' => 'commerce',
    ),
    'commerce_return_insert' => array(
      'group' => 'commerce',
    ),
    'commerce_return_delete' => array(
      'group' => 'commerce',
    ),
  );

  return $hooks;
}

/**
 * Implements hook_enable().
 */
function commerce_return_enable() {
  module_load_install('commerce_return');
  // Configure the return type.
  commerce_return_configure_return_type();
  // Configure the various bundles of commerce_return_reason entity type.
  commerce_return_reason_configure_return_reason_types();
}

/**
 * Implements hook_modules_installed().
 */
function commerce_return_modules_installed($modules) {
  // Reset the return state and status static caches in case a newly enabled
  // module has provided new states or statuses.
  drupal_static_reset('commerce_return_states');
  drupal_static_reset('commerce_return_statuses');
}

/**
 * Configure the customer profile reference fields for the specified return type.
 *
 * @param string $customer_profile_type
 *   The machine-name of the customer profile type to reference.
 * @param string $label
 *   The label to use for the profile type's reference field.
 * @param string $return_type
 *   The machine-name of the return type to add fields to.
 */
function commerce_return_configure_customer_profile_type($customer_profile_type, $label, $return_type = 'commerce_return') {
  // Add the customer profile reference fields for each profile type.
  $field_name = 'commerce_customer_' . $customer_profile_type;

  // First check to ensure this field doesn't already exist and was just inactive
  // because of the profile defining module being disabled previously.
  commerce_activate_field($field_name);
  field_cache_clear();

  $field = field_info_field($field_name);
  $instance = field_info_instance('commerce_return', $field_name, $return_type);

  if (empty($field)) {
    $field = array(
      'field_name' => $field_name,
      'type' => 'commerce_customer_profile_reference',
      'cardinality' => 1,
      'entity_types' => array('commerce_order', 'commerce_return'),
      'translatable' => FALSE,
      'settings' => array(
        'profile_type' => $customer_profile_type,
      ),
    );
    field_create_field($field);
  }

  if (empty($instance)) {
    $instance = array(
      'field_name' => $field_name,
      'entity_type' => 'commerce_return',
      'bundle' => $return_type,
      'label' => $label,
      'widget' => array(
        'type' => 'commerce_customer_profile_manager',
        'weight' => -5,
      ),
      'display' => array(),
    );

    // Set the default display formatters for various view modes.
    foreach (array('default', 'customer', 'administrator') as $view_mode) {
      $instance['display'][$view_mode] = array(
        'label' => 'above',
        'type' => 'commerce_customer_profile_reference_display',
        'weight' => -5,
      );
    }

    field_create_instance($instance);

    variable_set('commerce_customer_profile_' . $customer_profile_type . '_field', $field_name);
  }

  // Now attaching the postal address type field on the previously created
  // profile.
  $profile_type = commerce_return_customer_profile();
  $activated = FALSE;
  foreach (field_read_fields(
             array(
               'type' => 'commerce_customer_profile_reference',
               'active' => 0,
               'storage_active' => 1,
               'deleted' => 0
             ), array('include_inactive' => TRUE)
           ) as $field_name => $field) {
    // If this field references profiles of the re-enabled type...
    if ($field['settings']['profile_type'] == $profile_type['type']) {
      if (commerce_activate_field($field_name)) {
        $activated = TRUE;
      }
    }
  }

  // Clear the field cache if any profile reference fields were activated.
  if ($activated) {
    field_cache_clear();
  }

  // Default the addressfield property if it isn't set.
  $profile_type = array_merge(array('addressfield' => TRUE), $profile_type);
  commerce_customer_configure_customer_profile_type($profile_type);
}

/**
 * Helper: Try to copy customer profile information into a newly created RMA
 * customer profile.
 *
 * @param object $order
 *   A fully loaded commerce order object.
 *
 * @return object|bool
 *   Returns a fully loaded RMA customer profile, otherwise returns FALSE.
 */
function commerce_return_new_configure_customer_profile($order) {
  $order_wrapper = entity_metadata_wrapper('commerce_order', $order);

  // Create a new RMA customer profile.
  $profile = commerce_customer_profile_new('rma', $order_wrapper->uid->value());

  // Check if the shipping profile is available otherwise fallback on billing
  // profile.
  if (in_array('commerce_customer_shipping', array_keys($order_wrapper->getPropertyInfo()))) {
    $profile->commerce_customer_address = $order_wrapper->commerce_customer_shipping->value()->commerce_customer_address;
  }
  elseif (in_array('commerce_customer_billing', array_keys($order_wrapper->getPropertyInfo()))) {
    $profile->commerce_customer_address = $order_wrapper->commerce_customer_billing->value()->commerce_customer_address;
  }

  // Save the profile and return it if the postal address is fulfilled and
  // attached.
  if (property_exists($profile, 'commerce_customer_address') && !empty($profile->commerce_customer_address)) {
    commerce_customer_profile_save($profile);

    return $profile;
  }

  return FALSE;
}

/**
 * This function returns the product line items that can be returned from the
 * order passed as argument. Each line item will have a quantity equals to 1.
 *
 * @param object $order
 *   A fully loaded commerce order object.
 *
 * @return array.
 *   An array of line item objects keyed by primary identifier.
 */
function commerce_return_new_configure_line_items($order) {
  $delta = array();
  // Loop over order line items and build an array storing quantity and unit
  // price, keyed by product ID.
  foreach (entity_metadata_wrapper('commerce_order', $order)->commerce_line_items as $line_item_wrapper) {
    if (!in_array('commerce_product', array_keys($line_item_wrapper->getPropertyInfo()))) {
      continue;
    }

    if (!isset($delta[$line_item_wrapper->commerce_product->product_id->value()])) {
      $delta[$line_item_wrapper->commerce_product->product_id->value()] = array(
        'quantity' => (int) $line_item_wrapper->quantity->value(),
        'price' => array(
          'amount' => commerce_round(COMMERCE_ROUND_HALF_UP, $line_item_wrapper->commerce_total->amount->value() / (int) $line_item_wrapper->quantity->value()),
          'currency_code' => $line_item_wrapper->commerce_total->currency_code->value(),
        ),
        'product' => $line_item_wrapper->commerce_product->value(),
      );
    }
    else {
      $delta[$line_item_wrapper->commerce_product->product_id->value()]['quantity'] += $line_item_wrapper->quantity->value();
    }
  }
  // Loop over returns and calculate the product than can be returned.
  // Keyed by product Id.
  foreach (commerce_return_get_order_returns($order) as $return) {
    foreach (entity_metadata_wrapper('commerce_return', $return)->commerce_return_line_items as $line_item_wrapper) {
      if (isset($delta[$line_item_wrapper->commerce_product->product_id->value()])) {
        $delta[$line_item_wrapper->commerce_product->product_id->value()]['quantity'] -= $line_item_wrapper->quantity->value();
      }
    }
  }
  // The line items array is now populated, we are starting right away the line
  // items creation.
  $line_items = array();
  foreach ($delta as $product_id => $data) {
    for ($i = 1; $i <= $data['quantity']; $i++) {
      // Create the new line item.
      $line_item = entity_create(
        'commerce_line_item', array(
          'type' => 'product',
          'order_id' => 0,
          'quantity' => 1,
          'data' => array('context' => array('entity' => array('entity_type' => 'commerce_return'))),
        )
      );

      // Set the label to be the product SKU.
      $line_item->line_item_label = $data['product']->sku;

      // Wrap the line item and product to easily set field information.
      $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);

      // Add the product reference value to the line item for the right language.
      $line_item_wrapper->commerce_product = $data['product']->product_id;

      // Add the base price to the components array.
      if (!commerce_price_component_load($line_item_wrapper->commerce_unit_price->value(), 'base_price')) {
        $line_item_wrapper->commerce_unit_price->data = commerce_price_component_add($line_item_wrapper->commerce_unit_price->value(), 'base_price', $data['price'], TRUE);
        $line_item_wrapper->commerce_unit_price->amount->set($data['price']['amount']);
      }

      // Save the current line item.
      commerce_line_item_save($line_item);

      // Fulfill the line_items array with freshly created line item.
      $line_items[$line_item->line_item_id] = $line_item;
    }
  }

  return $line_items;
}

/**
 * Get the returns of the order given in parameter.
 *
 * @param object $order
 *   A fully qualified commerce_order object.
 *
 * @return array
 *   An array of fully loaded CommerceReturn entities keyed by primary
 *   identifier.
 */
function commerce_return_get_order_returns(stdClass $order) {
  $returns = array();

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_return')
    ->entityCondition('bundle', 'commerce_return')
    ->fieldCondition('commerce_order_reference', 'target_id', $order->order_id);
  $result = $query->execute();

  if (isset($result['commerce_return'])) {
    $returns = commerce_return_load_multiple(array_keys($result['commerce_return']));
  }

  return $returns;
}

/**
 * Implements hook_views_api().
 */
function commerce_return_views_api($module, $api) {
  if ($module == 'views') {
    return array(
      'version' => 3,
      'path' => drupal_get_path('module', 'commerce_return') . '/includes/views',
    );
  }
}

/**
 * Implements hook_commerce_return_state_info().
 */
function commerce_return_commerce_return_state_info() {
  $return_states = array();

  $return_states['canceled'] = array(
    'name' => 'canceled',
    'title' => t('Canceled'),
    'description' => t('returns in this state have been canceled through some user action.'),
    'weight' => -10,
    'default_status' => 'canceled',
  );
  $return_states['pending'] = array(
    'name' => 'pending',
    'title' => t('Pending'),
    'description' => t('returns in this state have been created and are awaiting further action.'),
    'weight' => 0,
    'default_status' => 'pending',
  );
  $return_states['completed'] = array(
    'name' => 'completed',
    'title' => t('Completed'),
    'description' => t('returns in this state have been completed as far as the customer is concerned.'),
    'weight' => 10,
    'default_status' => 'completed',
  );

  return $return_states;
}

/**
 * Implements hook_commerce_return_status_info().
 */
function commerce_return_commerce_return_status_info() {
  $return_statuses = array();

  $return_statuses['canceled'] = array(
    'name' => 'canceled',
    'title' => t('Canceled'),
    'state' => 'canceled',
  );

  $return_statuses['pending'] = array(
    'name' => 'pending',
    'title' => t('Pending'),
    'state' => 'pending',
  );
  $return_statuses['processing'] = array(
    'name' => 'processing',
    'title' => t('Processing'),
    'state' => 'pending',
    'weight' => 5,
  );

  $return_statuses['completed'] = array(
    'name' => 'completed',
    'title' => t('Completed'),
    'state' => 'completed',
  );

  return $return_statuses;
}

/**
 * Implements hook_commerce_return_line_item_status_info().
 */
function commerce_return_commerce_return_line_item_status_info() {
  $statuses = array();

  $statuses['received_waiting_for_refund'] = array(
    'name' => 'received_waiting_for_refund',
    'title' => t('Received and waiting for refund'),
    'description' => t('The product was received back by the seller'),
    'weight' => -10,
  );

  $statuses['received_refunds_made'] = array(
    'name' => 'received_refunds_made',
    'title' => t('Received and refunds made'),
    'description' => t('The seller has found the products as refundable and paid back the client'),
    'weight' => -9,
  );

  $statuses['return_not_comply'] = array(
    'name' => 'return_not_comply',
    'title' => t('Return does not comply'),
    'description' => t('Products are not refundable, the seller must indicate the reasons to the customer via email'),
    'weight' => -8,
  );

  $statuses['pending_reception'] = array(
    'name' => 'pending_reception',
    'title' => t('Pending receipt'),
    'description' => t('Product is pending reception'),
    'weight' => -11,
  );

  return $statuses;
}

/**
 * Implements hook_field_attach_form().
 *
 * This function adds a property to the customer profiles stored in a form array
 * on return edit forms. The return module will use this to bypass considering
 * that return when determining if the user should be able to delete a profile
 * from that return's edit form.
 */
function commerce_return_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode) {
  // If this is an return edit form...
  if ($entity_type == 'commerce_return') {
    // Get an array of customer profile reference fields attached to products.
    $fields = commerce_info_fields('commerce_customer_profile_reference', 'commerce_return');

    // Loop over each child element of the form.
    foreach (element_children($form) as $key) {
      // If the current element is for a customer profile reference field...
      if (in_array($key, array_keys($fields))) {
        // Loop over each of its child items...
        foreach (element_children($form[$key][$form[$key]['#language']]) as $delta) {
          foreach (element_children($form[$key][$form[$key]['#language']][$delta]) as $subdelta) {
            // Extract the customer profile from the widget form element.
            $profile = $form[$key][$form[$key]['#language']][$delta][$subdelta]['profile']['#value'];

            // Add the return context to the profile stored in the field element.
            $profile->entity_context = array(
              'entity_type' => 'commerce_return',
              'entity_id' => $entity->return_id,
            );

            // Add a uid if it is empty and the return has one.
            if (empty($profile->uid) && !empty($entity->uid)) {
              $profile->uid = $entity->uid;
            }

            // If this means this profile can now be deleted and the reference
            // field widget includes a remove element...
            if ($profile->profile_id && commerce_customer_profile_can_delete($profile) && !empty($form[$key][$form[$key]['#language']][$delta][$subdelta]['remove'])
            ) {
              // Update its remove element's title accordingly.
              $form[$key][$form[$key]['#language']][$delta][$subdelta]['remove']['#title'] = t('Delete this profile');
            }
          }
        }
      }
    }
  }
}


/**
 * Returns the name of the specified return type or all names keyed by type if
 * no type is specified.
 *
 * This function merely traverses the bundles array looking for data instead of
 * relying on a special hook.
 *
 * @param string $type
 *   The return type whose name should be returned; corresponds to the bundle
 *   key in the return entity definition.
 *
 * @return string
 *   Either the specified name, defaulting to the type itself if the name is not
 *   found, or an array of all names keyed by type if no type is passed in.
 */
function commerce_return_type_get_name($type = NULL) {
  $names = array();

  $entity = entity_get_info('commerce_return');

  foreach ($entity['bundles'] as $key => $value) {
    $names[$key] = $value['label'];
  }

  if (empty($type)) {
    return $names;
  }

  return empty($names[$type]) ? check_plain($type) : $names[$type];
}

/**
 * Wraps commerce_return_type_get_name() for the Entity module.
 */
function commerce_return_type_options_list() {
  return commerce_return_type_get_name();
}

/**
 * Returns an initialized return object.
 *
 * @param stdClass $order
 *   A fully loaded commerce_order entity type.
 * @param int $uid
 *   The uid of the owner of the return.
 * @param string $status
 *   Optionally the return status of the new return.
 * @param string $type
 *   The type of the return; defaults to the standard 'commerce_return' type.
 *
 * @return CommerceReturn
 *   A return object with all default fields initialized.
 */
function commerce_return_new(stdClass $order, $uid = 0, $status = NULL, $type = 'commerce_return') {
  // If no status was specified, use the default Pending status.
  if (!isset($status)) {
    $return_state = commerce_return_state_load('pending');
    $status = $return_state['default_status'];
  }

  return entity_get_controller('commerce_return')->create(
    array(
      'order' => $order,
      'uid' => $uid,
      'status' => $status,
      'type' => $type,
    )
  );
}

/**
 * Returns an initialized return_reason object.
 *
 * @param string $type
 *   The type of the return reason; defaults to product bundle.
 *
 * @return CommerceReturnReason
 *   A return reason object with all default fields initialized.
 */
function commerce_return_reason_new($type = 'product') {
  return entity_get_controller('commerce_return_reason')->create(
    array(
      'type' => $type,
    )
  );
}

/**
 * Returns the label for an initialized return_reason object.
 *
 * @param object $entity
 *   A fully loaded return reason object.
 * @param string $entity_type
 *   The entity type.
 *
 * @return string
 *   The label.
 */
function commerce_return_reason_label($entity, $entity_type) {
  return check_plain($entity->label());
}

/**
 * Saves an return.
 *
 * @param CommerceReturn $return
 *   The full return object to save. If $return->return_id is empty, a new return
 *     will be created.
 *
 * @return int
 *   SAVED_NEW or SAVED_UPDATED depending on the operation performed.
 */
function commerce_return_save(CommerceReturn $return) {
  return entity_get_controller('commerce_return')->save($return);
}

/**
 * Loads a return by ID.
 */
function commerce_return_load($return_id) {
  $returns = commerce_return_load_multiple(array($return_id), array());

  return $returns ? reset($returns) : FALSE;
}

/**
 * Loads an return by number.
 */
function commerce_return_load_by_number($return_number) {
  $returns = commerce_return_load_multiple(array(), array('return_number' => $return_number));

  return $returns ? reset($returns) : FALSE;
}

/**
 * Loads multiple returns by ID or based on a set of matching conditions.
 *
 * @see entity_load()
 *
 * @param array $return_ids
 *   An array of return IDs.
 * @param array $conditions
 *   An array of conditions to filter loaded returns by on the {commerce_return}
 *   table in the form 'field' => $value. Specifying a revision_id will load the
 *   requested revision of the return identified either by a similar condition or
 *   the $return_ids array assuming the revision_id is valid for the return_id.
 * @param boolean $reset
 *   Whether to reset the internal return loading cache.
 *
 * @return array
 *   An array of return objects indexed by return_id.
 */
function commerce_return_load_multiple($return_ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('commerce_return', $return_ids, $conditions, $reset);
}

/**
 * Loads a return reason by ID.
 *
 * @param int $return_reason_id
 *   A return reason identifier.
 *
 * @return object|bool
 *   Returns a fully loaded return_reason object. Otherwise FALSE.
 */
function commerce_return_reason_load($return_reason_id) {
  $return_reasons = commerce_return_reason_load_multiple(array($return_reason_id), array());

  return $return_reasons ? reset($return_reasons) : FALSE;
}

/**
 * Loads multiple return reasons by ID or based on a set of matching conditions.
 *
 * @see entity_load()
 *
 * @param array $return_reason_ids
 *   An array of return reasons IDs.
 * @param array $conditions
 *   An array of conditions to filter loaded returns by on the {commerce_return}
 *   table in the form 'field' => $value. Specifying a revision_id will load the
 *   requested revision of the return identified either by a similar condition or
 *   the $return_ids array assuming the revision_id is valid for the return_id.
 * @param boolean $reset
 *   Whether to reset the internal return loading cache.
 *
 * @return array
 *   An array of return objects indexed by return_reason_id.
 */
function commerce_return_reason_load_multiple($return_reason_ids = array(), $conditions = array(), $reset = FALSE) {
  return entity_load('commerce_return_reason', $return_reason_ids, $conditions, $reset);
}

/**
 * Determines whether or not the given return object represents the latest
 * revision of the return.
 *
 * @param CommerceReturn $return
 *   A fully loaded return object.
 *
 * @return
 *   Boolean indicating whether or not the return object represents the latest
 *   revision of the return.
 */
function commerce_return_is_latest_revision($return) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_return', '=')
    ->propertyCondition('return_id', $return->return_id, '=')
    ->propertyCondition('revision_id', $return->revision_id, '=');
  $result = $query->execute();

  return (!empty($result)) ? TRUE : FALSE;
}

/**
 * Deletes an return by ID.
 *
 * @param CommerceReturn $return_id
 *   The ID of the return to delete.
 *
 * @return
 *   TRUE on success, FALSE otherwise.
 */
function commerce_return_delete($return_id) {
  return commerce_return_delete_multiple(array($return_id));
}

/**
 * Deletes multiple returns by ID.
 *
 * @param CommerceReturn $return_ids
 *   An array of return IDs to delete.
 *
 * @return
 *   TRUE on success, FALSE otherwise.
 */
function commerce_return_delete_multiple($return_ids) {
  return entity_get_controller('commerce_return')->delete($return_ids);
}

/**
 * Checks return access for various operations.
 *
 * @param string $op
 *   The operation being performed. One of 'view', 'update', 'create' or
 *   'delete'.
 * @param CommerceReturn $return
 *   Optionally an return to check access for.
 * @param object $account
 *   The user to check for. Leave it to NULL to check for the current user.
 *
 * @return boolean
 *   True if access is granted, FALSE otherwise.
 */
function commerce_return_access($op, CommerceReturn $return = NULL, $account = NULL) {
  return commerce_entity_access($op, $return, $account, 'commerce_return');
}

/**
 * Implements hook_query_TAG_alter().
 *
 * Implement access control on line items. This is different from other entities
 * because the access to a line item is totally delegated to its return.
 */
function commerce_return_query_commerce_line_item_access_alter(QueryAlterableInterface $query) {
  // Read the meta-data from the query.
  if (!$account = $query->getMetaData('account')) {
    global $user;
    $account = $user;
  }

  // If the user can return their goods and the line items manager view is using
  // the return display.
  if (user_access('access return of goods', $account) && $query->alterMetaData['view']->current_display === "return") {
    // Removing the condition on order because it makes no sense in this case.
    // Indeed, returned line items have no relationship with commerce_order
    // entity type.
    $conditions =& $query->conditions();
    unset($conditions[1]);

    if (in_array('co', array_keys($query->getTables()))) {
      $tables =& $query->getTables();
      unset($tables['co']);
    }
  }
}


/**
 * Implements hook_query_TAG_alter().
 */
function commerce_return_query_commerce_return_access_alter(QueryAlterableInterface $query) {
  // Look for an return base table to pass to the query altering function or else
  // assume we don't have the tables we need to establish return related altering
  // right now.
  foreach ($query->getTables() as $table) {
    if ($table['table'] === 'commerce_return') {
      commerce_entity_access_query_alter($query, 'commerce_return', $table['alias']);
      break;
    }
  }
}

/**
 * Rules integration access callback.
 */
function commerce_return_rules_access($type, $name) {
  if ($type == 'event' || $type == 'condition') {
    return commerce_return_access('view');
  }
}

/**
 * Implements hook_commerce_return_insert().
 */
function commerce_return_commerce_return_insert($return) {
  // Save the return number.
  // TODO: Provide token support for return number patterns.

  if (empty($return->return_number)) {
    $return->return_number = $return->return_id;

    db_update('commerce_return')
      ->fields(array('return_number' => $return->return_number))
      ->condition('return_id', $return->return_id)->execute();
    db_update('commerce_return_revision')
      ->fields(array('return_number' => $return->return_number))
      ->condition('return_id', $return->return_id)->execute();
  }
}

/**
 * Implements hook_commerce_line_item_access().
 *
 * Line items have return_id properties, but since there is no dependency from
 * the Line Item module to return, we perform access checks for line items
 * attached to returns through this hook.
 */
function commerce_return_commerce_line_item_access($op, $line_item, $account) {
  // If the line item references an return...
  if ($return = commerce_return_load($line_item->return_id)) {
    // Return the account's access to update the return.
    return commerce_return_access('update', $return, $account);
  }
}

/**
 * Performs token replacement on an return number for valid tokens only.
 *
 * TODO: This function currently limits acceptable Tokens to return ID with no
 * ability to use Tokens for the Fields attached to the return. That might be
 * fine for a core Token replacement, but we should at least open the
 * $valid_tokens array up to other modules to enable various Tokens for use.
 *
 * @param int $return_number
 *   The raw return number string including any tokens as entered.
 * @param CommerceReturn $return
 *   An return object used to perform token replacement on the number.
 *
 * @return int|boolean
 *   The number with tokens replaced or FALSE if it included invalid tokens.
 */
function commerce_return_replace_number_tokens($return_number, CommerceReturn $return) {
  // Build an array of valid return number tokens.
  $valid_tokens = array('return-id');

  // Ensure that only valid tokens were used.
  $invalid_tokens = FALSE;

  foreach (token_scan($return_number) as $type => $token) {
    if ($type !== 'return') {
      $invalid_tokens = TRUE;
    }
    else {
      foreach (array_keys($token) as $value) {
        if (!in_array($value, $valid_tokens)) {
          $invalid_tokens = TRUE;
        }
      }
    }
  }

  // Register the error if an invalid token was detected.
  if ($invalid_tokens) {
    return FALSE;
  }

  return $return_number;
}

/**
 * Validates an return number string for acceptable characters.
 *
 * @param int $return_number
 *   The return number string to validate.
 *
 * @return boolean
 *   TRUE or FALSE indicating whether or not the return number contains valid
 *   characters.
 */
function commerce_return_validate_number_characters($return_number) {
  return preg_match('!^[A-Za-z0-9_-]+$!', $return_number);
}

/**
 * Checks to see if a given return number already exists for another return.
 *
 * @param int $return_number
 *   The string to match against existing return numbers.
 *
 * @return boolean
 *   TRUE or FALSE indicating whether or not the number exists for another
 *   return.
 */
function commerce_return_validate_number_unique($return_number) {
  return db_select('commerce_return', 'cr')->fields('cr', array('return_id'))
    ->condition('return_number', $return_number)->execute()->rowCount() === 0;
}

/**
 * Returns an array of all the return states keyed by name.
 *
 * return states can only be defined by modules but may have settings overridden
 * that are stored in the database (weight and the default status). When this
 * function is first called, it will load all the states as defined by
 * hook_commerce_return_state_info() and update them based on the data in the
 * database. The final array will be cached for subsequent calls.
 *
 * @return array
 *   An array of return states.
 */
function commerce_return_states() {
  // First check the static cache for an return states array.
  $return_states = & drupal_static(__FUNCTION__);

  // If it did not exist, fetch the statuses now.
  if (empty($return_states)) {
    $return_states = module_invoke_all('commerce_return_state_info');

    // Give other modules a chance to alter the return states.
    drupal_alter('commerce_return_state_info', $return_states);

    uasort($return_states, 'drupal_sort_weight');
  }

  return $return_states;
}

/**
 * Returns an return state object.
 *
 * @param string $name
 *   The machine readable name string of the state to return.
 *
 * @return boolean|string
 *   The fully loaded state object or FALSE if not found.
 */
function commerce_return_state_load($name) {
  $return_states = commerce_return_states();

  if (isset($return_states[$name])) {
    return $return_states[$name];
  }

  return FALSE;
}

/**
 * Returns the human readable title of any or all return states.
 *
 * @param string|null $name
 *   Optional parameter specifying the name of the return state whose title
 *     should be return.
 *
 * @return boolean|string
 *   Either an array of all return state titles keyed by name or a string
 *     containing the human readable title for the specified state. If a state
 *     is specified that does not exist, this function returns FALSE.
 */
function commerce_return_state_get_title($name = NULL) {
  $return_states = commerce_return_states();

  // Return a state title if specified and it exists.
  if (!empty($name)) {
    if (isset($return_states[$name])) {
      return $return_states[$name]['title'];
    }
    else {
      // Return FALSE if it does not exist.
      return FALSE;
    }
  }

  // Otherwise turn the array values into the status title only.
  foreach ($return_states as $key => $value) {
    $return_states[$key] = $value['title'];
  }

  return $return_states;
}

/**
 * Wraps commerce_return_state_get_title() for use by the Entity module.
 */
function commerce_return_state_options_list() {
  return commerce_return_state_get_title();
}

/**
 * Returns an array of some or all of the return statuses keyed by name.
 *
 * @param array $conditions
 *   An array of conditions to filter the returned list by; for example, if you
 *   specify 'state' => 'cart' in the array, then only return statuses in the
 *   cart state would be included.
 *
 * @return array
 *   The array of return status objects, keyed by status name.
 */
function commerce_return_statuses($conditions = array()) {
  // First check the static cache for an return statuses array.
  $return_statuses = & drupal_static(__FUNCTION__);

  // If it did not exist, fetch the statuses now.
  if (!isset($return_statuses)) {
    $return_statuses = module_invoke_all('commerce_return_status_info');

    // Merge in defaults.
    foreach ($return_statuses as $name => $return_status) {
      // Set some defaults for the checkout pane.
      $defaults = array(
        'cart' => FALSE,
        'weight' => 0,
        'status' => TRUE,
      );
      $return_status += $defaults;

      $return_statuses[$name] = $return_status;
    }

    // Give other modules a chance to alter the return statuses.
    drupal_alter('commerce_return_status_info', $return_statuses);

    uasort($return_statuses, 'drupal_sort_weight');
  }

  // Apply conditions to the returned statuses if specified.
  if (!empty($conditions)) {
    $matching_statuses = array();

    foreach ($return_statuses as $name => $return_status) {
      // Check the status against the conditions array to determine whether to
      // add it to the return array or not.
      $valid = TRUE;

      foreach ($conditions as $property => $value) {
        // If the current value for the specified property on the status does
        // not match the filter value...
        if ($return_status[$property] != $value) {
          // Do not add it to the temporary array.
          $valid = FALSE;
        }
      }

      if ($valid) {
        $matching_statuses[$name] = $return_status;
      }
    }

    return $matching_statuses;
  }

  return $return_statuses;
}

/**
 * Returns an return status object.
 *
 * @param string $name
 *   The machine readable name string of the status to return.
 *
 * @return string|boolean
 *   The fully loaded status object or FALSE if not found.
 */
function commerce_return_status_load($name) {
  $return_statuses = commerce_return_statuses();

  if (isset($return_statuses[$name])) {
    return $return_statuses[$name];
  }

  return FALSE;
}

/**
 * Returns the human readable title of any or all return statuses.
 *
 * @param string|null $name
 *   Optional parameter specifying the name of the return status whose title
 *     to return.
 *
 * @return string|boolean
 *   Either an array of all return status titles keyed by the status_id or a
 *     string containing the human readable title for the specified status. If a
 *     status is specified that does not exist, this function returns FALSE.
 */
function commerce_return_status_get_title($name = NULL) {
  $return_statuses = commerce_return_statuses();

  // Return a status title if specified and it exists.
  if (!empty($name)) {
    if (isset($return_statuses[$name])) {
      return $return_statuses[$name]['title'];
    }
    else {
      // Return FALSE if it does not exist.
      return FALSE;
    }
  }

  // Otherwise turn the array values into the status title only.
  foreach ($return_statuses as $key => $value) {
    $return_statuses[$key] = $value['title'];
  }

  return $return_statuses;
}

/**
 * Wraps commerce_return_status_get_title() for use by the Entity module.
 */
function commerce_return_status_options_list() {
  // Build an array of return status options grouped by return state.
  $options = array();

  foreach (commerce_return_state_get_title() as $name => $title) {
    foreach (commerce_return_statuses(array('state' => $name)) as $return_status) {
      $options[check_plain($title)][$return_status['name']] = check_plain($return_status['title']);
    }
  }

  return $options;
}

/**
 * Updates the status of an return to the specified status.
 *
 * While there is no explicit Rules event or hook devoted to an return status
 * being updated, you can use the commerce_return_updated event / hook to check
 * for a changed return status by comparing $return->original->status to the
 * $return->status. If they are different, this will alert you that the return
 * status for the given return was just changed.
 *
 * @param CommerceReturn $return
 *   The fully loaded return object to update.
 * @param string $name
 *   The machine readable name string of the status to update to.
 * @param boolean $skip_save
 *   TRUE to skip saving the return after updating the status; used when the
 *     return would be saved elsewhere after the update.
 * @param boolean|null $revision
 *   TRUE or FALSE indicating whether or not a new revision should be created
 *   for the return if it is saved as part of the status update. If missing or
 *   NULL, the value configured in "return settings" is used.
 * @param string $log
 *   If a new revision is created for the update, the log message that will be
 *     used for the revision.
 *
 * @return CommerceReturn
 *   The updated return.
 */
function commerce_return_status_update(CommerceReturn $return, $name, $skip_save = FALSE, $revision = NULL, $log = '') {
  if (!isset($revision)) {
    $revision = variable_get('commerce_return_auto_revision', TRUE);
  }

  // Do not update the status if the return is already at it.
  if ($return->status != $name) {
    $return->status = $name;

    if (!$skip_save) {
      // If the status update should create a new revision, update the return
      // object to reflect this and include a log message.
      if ($revision) {
        $return->revision = TRUE;
        $return->log = $log;
      }

      commerce_return_save($return);
    }
  }

  return $return;
}

/**
 * Returns an array of return reasons found in database keyed by name.
 *
 * @param object $line_item
 *   A fully loaded line item object.
 *
 * @return array
 *   An array of return reasons, keyed by name.
 */
function commerce_return_reasons($line_item = NULL) {
  $terms = array();

  if (!is_null($line_item)) {
    $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
    $return_reason_id = NULL;

    // Check if a "commerce_product" field is currently attached on the given
    // entity. If not, returns empty array.
    if (!array_key_exists('commerce_product', $line_item_wrapper->getPropertyInfo())) {
      return array();
    }

    $product = $line_item_wrapper->commerce_product->value();

    $query = new EntityFieldQuery();
    $query->entityCondition('entity_type', 'commerce_return_reason')
      ->entityCondition('bundle', 'product')
      ->fieldCondition('return_reason_product', 'product_id', $product->product_id, '=')
      ->entityOrderBy('entity_id', 'DESC')->range(0, 1);

    $result = $query->execute();

    if (isset($result['commerce_return_reason'])) {
      $return_reason_id = key($result['commerce_return_reason']);
    }

    // It means that the product level research has ended to nothing. We are now
    // seeking for a result on product type level.
    if (empty($return_reason_id)) {
      $query = new EntityFieldQuery();
      $query->entityCondition('entity_type', 'commerce_return_reason')
        ->entityCondition('bundle', 'product_type')
        ->fieldCondition('return_reason_product_type', 'value', $product->type, '=')
        ->entityOrderBy('entity_id', 'DESC')->range(0, 1);

      $result = $query->execute();

      if (isset($result['commerce_return_reason'])) {
        $return_reason_id = key($result['commerce_return_reason']);
      }
    }

    // If an ID has been found, returns the taxonomy terms.
    if (!empty($return_reason_id)) {
      return entity_metadata_wrapper('commerce_return_reason', commerce_return_reason_load($return_reason_id))
        ->return_reason_taxonomy_term->value();
    }
  }

  $vocabulary = taxonomy_vocabulary_machine_name_load('return_reason');

  if ($vocabulary) {
    $terms = taxonomy_term_load_multiple(array(), array('vid' => $vocabulary->vid));
  }

  return $terms;
}

/**
 * Wraps return reasons found from database into an array to be displayed as
 * an option list.
 *
 * @param object $line_item
 *   A fully loaded line item object.
 *
 * @return array
 *   An array of options to be displayed as a HTML List.
 */
function commerce_return_reasons_options_list($line_item = NULL) {
  $options = array();

  foreach (commerce_return_reasons($line_item) as $term) {
    $options[$term->tid] = $term->name;
  }

  return $options;
}

/**
 * Returns an array of line item return's statuses keyed by status name.
 *
 * @return array
 *   The array of line item return's statuses, keyed by status name.
 */
function commerce_return_line_item_statuses() {
  // First check the static cache for an return statuses array.
  $line_item_statuses = & drupal_static(__FUNCTION__);

  // If it did not exist, fetch the statuses now.
  if (!isset($line_item_statuses)) {
    $line_item_statuses = module_invoke_all('commerce_return_line_item_status_info');

    // Merge in defaults.
    foreach ($line_item_statuses as $name => $line_item_status) {
      $line_item_statuses[$name] = $line_item_status;
    }

    // Give other modules a chance to alter the return statuses.
    drupal_alter('commerce_return_line_item_status_info', $line_item_statuses);

    uasort($line_item_statuses, 'drupal_sort_weight');
  }

  return $line_item_statuses;
}

/**
 * Wraps returned line item statuses into an array to be rendered as an option
 * list.
 */
function commerce_return_line_item_statuses_options_list() {
  $options = array();

  foreach (commerce_return_line_item_statuses() as $name => $line_item_status) {
    $options[$name] = $line_item_status['title'];
  }

  return $options;
}

/**
 * Calculates the return total, updating the commerce_return_total field data in
 * the return object this function receives.
 *
 * @param CommerceReturn $return
 *   The return object whose return total should be calculated.
 *
 * @see commerce_line_items_total()
 */
function commerce_return_calculate_total(CommerceReturn $return) {
  $return_wrapper = entity_metadata_wrapper('commerce_return', $return);

  // First determine the currency to use for the return total.
  $currency_code = commerce_default_currency();
  $currencies = array();

  // Populate an array of how many line items on the return use each currency.
  foreach ($return_wrapper->commerce_return_line_items as $delta => $line_item_wrapper) {
    // If the current line item actually no longer exists...
    if (!$line_item_wrapper->value()) {
      // Remove the reference from the return and continue to the next value.
      $return_wrapper->commerce_return_line_items->offsetUnset($delta);
      continue;
    }

    $line_item_currency_code = $line_item_wrapper->commerce_total->currency_code->value();

    if (!in_array($line_item_currency_code, array_keys($currencies))) {
      $currencies[$line_item_currency_code] = 1;
    }
    else {
      $currencies[$line_item_currency_code]++;
    }
  }

  reset($currencies);

  // If only one currency is present on the return, use that to calculate the
  // return total.
  if (count($currencies) == 1) {
    $currency_code = key($currencies);
  }
  elseif (in_array(commerce_default_currency(), array_keys($currencies))) {
    // Otherwise use the site default currency if it's in the return.
    $currency_code = commerce_default_currency();
  }
  elseif (count($currencies) > 1) {
    // Otherwise use the first currency on the return. We do this instead of
    // trying to determine the most dominant currency for now because using the
    // first currency leaves the option open for a UI based module to let
    // customers rereturn the items in the cart by currency to get the return
    // total in a different currency. The currencies array still contains useful
    // data, though, should we decide to expand on the count by currency approach.
    $currency_code = key($currencies);
  }

  // Initialize the return total with the selected currency.
  $return_wrapper->commerce_return_total->amount = 0;
  $return_wrapper->commerce_return_total->currency_code = $currency_code;

  // Reset the data array of the return total field to only include a
  // base price component, set the currency code from any line item.
  $base_price = array(
    'amount' => 0,
    'currency_code' => $currency_code,
    'data' => array(),
  );

  $return_wrapper->commerce_return_total->data = commerce_price_component_add($base_price, 'base_price', $base_price, TRUE);

  // Then loop over each line item and add its total to the return total.
  $amount = 0;

  foreach ($return_wrapper->commerce_return_line_items as $delta => $line_item_wrapper) {
    // Convert the line item's total to the return's currency for totalling.
    $component_total = commerce_price_component_total($line_item_wrapper->commerce_total->value());

    // Add the totals.
    $amount += commerce_currency_convert($component_total['amount'], $component_total['currency_code'], $currency_code);

    // Combine the line item total's component prices into the return total.
    $return_wrapper->commerce_return_total->data = commerce_price_components_combine($return_wrapper->commerce_return_total->value(), $line_item_wrapper->commerce_total->value());
  }

  // Update the return total price field with the final total amount.
  $return_wrapper->commerce_return_total->amount = round($amount);
}

/**
 * Callback for getting return properties.
 *
 * @see CommerceReturnMetadataController.
 */
function commerce_return_get_properties(CommerceReturn $return, array $options, $name) {
  switch ($name) {
    case 'owner':
      return $return->uid;
    case 'view_url':
      return url('user/' . $return->uid . '/returns/' . $return->return_id, $options);
    case 'admin_url':
      return url('admin/commerce/returns/' . $return->return_id, $options);
    case 'edit_url':
      return url('admin/commerce/returns/' . $return->return_id . '/edit', $options);
    case 'state':
      $return_status = commerce_return_status_load($return->status);

      return $return_status['state'];
    case 'mail_username':
      // To prepare an e-mail address to be a username, we trim any potential
      // leading and trailing spaces and replace simple illegal characters with
      // hyphens. More could be done with additional illegal characters if
      // necessary, but those typically won't pass e-mail validation anyways.
      // We also limit the username to the maximum length for usernames.
      // @see user_validate_name()
      $username = preg_replace('/[^\x{80}-\x{F7} a-z0-9@_.\'-]/i', '-', trim($return->mail));
      $username = substr($username, 0, USERNAME_MAX_LENGTH);

      return commerce_return_unique_username($username);
  }
}

/**
 * Takes a base username and returns a unique version of the username.
 *
 * @param string $base
 *   The base from which to construct a unique username.
 *
 * @return string
 *   A unique version of the username using appended numbers to avoid duplicates
 *   if the base is already in use.
 */
function commerce_return_unique_username($base) {
  $username = $base;
  $i = 1;

  while (db_query('SELECT 1 FROM {users} WHERE name = :name', array(':name' => $username))->fetchField()) {
    // Ensure the username does not exceed the maximum character limit.
    if (strlen($base . $i) > USERNAME_MAX_LENGTH) {
      $base = substr($base, 0, strlen($base) - strlen($i));
    }

    $username = $base . $i++;
  }

  return $username;
}

/**
 * Callback for setting return properties.
 *
 * @see commerce_return_entity_property_info()
 */
function commerce_return_set_properties($return, $name, $value) {
  if ($name == 'owner') {
    $return->uid = $value;
  }
}

/**
 * Implements hook_entity_query_alter().
 */
function commerce_return_entity_query_alter($query) {
  // If we're performing an entity query to returns using a property condition on
  // the return state pseudo-column property, we need to alter the condition to
  // compare against the statuses in the specified state instead.
  if (isset($query->entityConditions['entity_type']) && $query->entityConditions['entity_type']['value'] == 'commerce_return') {
    foreach ($query->propertyConditions as &$condition) {
      // If the current condition was against the non-existent 'state' column...
      if ($condition['column'] == 'state' && !empty($condition['value'])) {
        // Get all the statuses available for this state.
        $statuses = commerce_return_statuses(array('state' => $condition['value']));
        $condition['column'] = 'status';

        if (count($statuses)) {
          $condition['value'] = array_keys($statuses);
          $condition['operator'] = (count($statuses) > 1) ? 'IN' : '=';
        }
        else {
          // Do not return any returns for a non-existent state.
          $condition['value'] = NULL;
        }
      }
    }
  }
}

/**
 * Implements hook_field_widget_info().
 */
function commerce_return_field_widget_info() {
  $widgets = array();

  // Define the creation / reference widget for line items.
  $widgets['commerce_return_line_item_manager'] = array(
    'label' => t('CommerceReturn Line item manager'),
    'description' => t('Use a complex widget to manager the line items referenced by a CommerceReturn entity.'),
    'field types' => array('commerce_line_item_reference'),
    'settings' => array(),
    'behaviors' => array(
      'multiple values' => FIELD_BEHAVIOR_CUSTOM,
      'default value' => FIELD_BEHAVIOR_NONE,
    ),
  );

  return $widgets;
}

/**
 * Implements hook_field_widget_form().
 */
function commerce_return_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  if ($instance['widget']['type'] == 'commerce_return_line_item_manager') {
    $line_item_ids = array();

    // Build an array of line item IDs from this field's values.
    foreach ($items as $item) {
      $line_item_ids[] = $item['line_item_id'];
    }

    // Get permissions of the user who is currently requesting the "update"
    // mode of the fields.
    $is_admin = commerce_return_access('update');

    // Load the line items for temporary storage in the form array.
    $line_items = commerce_line_item_load_multiple($line_item_ids);

    // Add javascript in order to activate the check/uncheck all checkboxes.
    if(!$is_admin) {
      $form['#attached']['js'] = array(
        drupal_get_path('module', 'commerce_return') . '/theme/commerce_return.line_item_manager.js',
      );
    }

    // Update the base form element array to use the proper theme and validate
    // functions and to include header information for the line item table.
    $element += array(
      '#theme' => $is_admin ? 'commerce_return_line_item_manager_admin' : 'commerce_return_line_item_manager_customer',
      '#element_validate' => $is_admin ? array('commerce_return_line_item_manager_admin_validate') : array('commerce_return_line_item_manager_customer_validate'),
      '#empty' => t('No line items found.'),
      'line_items' => array(),
    );

    if (!empty($form_state['line_item_save_warning'])) {
      drupal_set_message(t('New line items on this return will not be saved until the <em>Save return</em> button is clicked.'), 'warning');
    }

    // Add a set of elements to the form for each referenced line item.
    foreach ($line_items as $line_item_id => $line_item) {
      // Store the original line item for later comparison.
      $element['line_items'][$line_item_id]['line_item'] = array(
        '#type' => 'value',
        '#value' => $line_item,
      );

      $element['line_items'][$line_item_id]['selected'] = array(
        '#type' => 'checkbox',
        '#default_value' => FALSE,
      );

      $element['line_items'][$line_item_id]['title'] = array(
        '#markup' => commerce_line_item_title($line_item),
      );

      $element['line_items'][$line_item_id]['line_item_label'] = array(
        '#markup' => check_plain($line_item->line_item_label),
      );

      // Retrieve the widget form for just the unit price.
      $widget_form = _field_invoke_default('form', 'commerce_line_item', $line_item, $form, $form_state, array('field_name' => 'commerce_unit_price'));

      // Unset the title and description and add it to the line item form.
      $language = $widget_form['commerce_unit_price']['#language'];
      unset($widget_form['commerce_unit_price'][$language][0]['amount']['#title']);
      unset($widget_form['commerce_unit_price'][$language][0]['amount']['#description']);

      $element['line_items'][$line_item_id]['commerce_unit_price'] = $widget_form['commerce_unit_price'];

      $element['line_items'][$line_item_id]['commerce_return_reason'] = array(
        '#type' => 'select',
        '#options' => commerce_return_reasons_options_list($line_item),
        '#default_value' => isset($line_item->data['commerce_return']['reason_tid']) ? $line_item->data['commerce_return']['reason_tid'] : FALSE,
        '#element_validate' => array('_commerce_return_reason_validate'),
      );

      $element['line_items'][$line_item_id]['commerce_return_line_item_status'] = array(
        '#type' => 'select',
        '#options' => commerce_return_line_item_statuses_options_list(),
        '#default_value' => isset($line_item->data['commerce_return']['line_item_status']) ? $line_item->data['commerce_return']['line_item_status'] : FALSE,
        '#element_validate' => $is_admin ? array('_commerce_return_line_item_status_validate') : array(),
      );
    }

    // If the the form has been instructed to add a line item...
    if (!empty($form_state['line_item_add'])) {
      // Load the info object for the selected line item type.
      $line_item_type = commerce_line_item_type_load($form_state['line_item_add']);

      // Store the line item info object in the form array.
      $element['actions']['line_item_type'] = array(
        '#type' => 'value',
        '#value' => $line_item_type,
      );

      // If this type specifies a valid add form callback function...
      if ($callback = commerce_line_item_type_callback($line_item_type, 'add_form')) {
        // Load in the appropriate form elements to the actions array.
        $element['actions'] += call_user_func($callback, $element, $form_state);
      }

      // Add a default save button.
      $element['actions'] += array(
        'save_line_item' => array(
          '#type' => 'button',
          '#value' => !empty($line_item_type['add_form_submit_value']) ? $line_item_type['add_form_submit_value'] : t('Save'),
          '#limit_validation_errors' => array(array_merge($element['#field_parents'], array($field['field_name']))),
          '#ajax' => array(
            'callback' => 'commerce_line_item_manager_refresh',
            'wrapper' => 'line-item-manager',
          ),
        ),
      );

      $element['actions']['cancel'] = array(
        '#type' => 'button',
        '#value' => t('Cancel'),
        '#limit_validation_errors' => array(),
        '#ajax' => array(
          'callback' => 'commerce_line_item_manager_refresh',
          'wrapper' => 'line-item-manager',
        ),
      );
    }
    elseif ($is_admin) {
      // Otherwise display the select list to add a new line item.
      $options = commerce_line_item_type_get_name();

      // Only display the line item selector if line item types exist.
      if (!empty($options)) {
        $element['actions']['line_item_type'] = array(
          '#type' => 'select',
          '#options' => commerce_line_item_type_get_name(),
          '#prefix' => '<div class="add-line-item">',
        );
        $element['actions']['line_item_add'] = array(
          '#type' => 'button',
          '#value' => t('Add line item'),
          '#limit_validation_errors' => array(array_merge($element['#field_parents'], array($field['field_name']))),
          '#ajax' => array(
            'callback' => 'commerce_line_item_manager_refresh',
            'wrapper' => 'line-item-manager',
          ),
          '#suffix' => '</div>',
        );
      }
    }

    return $element;
  }
}

/**
 * Validation form callback: validate the return line item manager for
 * admin users.
 *
 * @param array $element
 *   The element array.
 * @param array $form_state
 *   The form state array.
 * @param array $form
 *   The form array.
 *
 * @return void
 */
function commerce_return_line_item_manager_admin_validate($element, &$form_state, $form) {
  $value = array();

  // Loop through the line items in the manager table.
  foreach (element_children($element['line_items']) as $line_item_id) {
    // If the line item has been marked for deletion...
    if ($element['line_items'][$line_item_id]['selected']['#value']) {
      // Delete the line item now and don't include it from the $value array.
      commerce_line_item_delete($line_item_id);
    }
    else {
      // Add the line item ID to the current value of the reference field.
      $value[] = array('line_item_id' => $line_item_id);

      // Update the line item based on the values in the additional elements.
      $line_item = clone($element['line_items'][$line_item_id]['line_item']['#value']);

      // Manually validate the unit price of each line item.
      $unit_price = $form_state['values'][$element['#field_name']][$element['#language']]['line_items'][$line_item_id]['commerce_unit_price'];
      $amount = $unit_price[$element['#language']][0]['amount'];
      $currency_code = $unit_price[$element['#language']][0]['currency_code'];

      // Display an error message for a non-numeric unit price.
      if (!is_numeric($amount)) {
        $name = implode(
          '][', array_merge(
            $element['line_items'][$line_item_id]['commerce_unit_price']['#parents'], array(
              $element['#language'],
              0,
              'amount'
            )
          )
        );
        form_set_error($name, 'You must enter a numeric value for the unit price.');
      }
      elseif ($amount <> $line_item->commerce_unit_price[$element['#language']][0]['amount'] || $currency_code <> $line_item->commerce_unit_price[$element['#language']][0]['currency_code']
      ) {
        // Otherwise update the unit price amount if it has changed.
        $line_item->commerce_unit_price = $unit_price;

        // Rebuild the price components array.
        commerce_line_item_rebase_unit_price($line_item);
      }

      // Injecting the return reasons and the line item status. Already
      // validated by their own validator callbacks.
      $line_item->data['commerce_return'] = array(
        'reason_tid' => $form_state['values'][$element['#field_name']][$element['#language']]['line_items'][$line_item_id]['commerce_return_reason'],
        'line_item_status' => $form_state['values'][$element['#field_name']][$element['#language']]['line_items'][$line_item_id]['commerce_return_line_item_status'],
      );

      // Only save if values were actually changed.
      if ($line_item != $element['line_items'][$line_item_id]['line_item']['#value']) {
        commerce_line_item_save($line_item);
      }
    }
  }

  // If the "Add line item" button was clicked, store the line item type in the
  // $form_state for the rebuild of the $form array.
  if (!empty($form_state['triggering_element'])) {
    if ($form_state['triggering_element']['#value'] == t('Add line item')) {
      $form_state['line_item_add'] = $element['actions']['line_item_type']['#value'];
      $form_state['rebuild'] = TRUE;
    }
    else {
      unset($form_state['line_item_add']);

      $parent = end($form_state['triggering_element']['#parents']);

      // If the save button was clicked from the line item type action form...
      if ($parent == 'save_line_item') {
        $line_item_type = $element['actions']['line_item_type']['#value'];

        // Create the new line item.
        if ($line_item_type['type'] == 'product') {
          $line_item = commerce_product_line_item_new(commerce_product_load_by_sku($element['actions']['product_sku']['#value']), 1, 0);
        }
        else {
          $line_item = commerce_line_item_new($line_item_type['type'], 0);
        }

        // If this type specifies a valid add form callback function...
        if ($callback = commerce_line_item_type_callback($line_item_type, 'add_form_submit')) {
          // Allow the callback to alter data onto the line item to be saved and
          // to return an error message if something goes wrong.
          $error = call_user_func($callback, $line_item, $element, $form_state, $form);
        }
        else {
          // Assume no error if the callback isn't specified.
          $error = FALSE;
        }

        // If we didn't end up with any errors...
        if (empty($error)) {
          // Save it and add it to the line item reference field's values array.
          commerce_line_item_save($line_item);

          // If the item is saved, we set a variable to notify the user the
          // need of saving the order.
          $form_state['line_item_save_warning'] = TRUE;

          $value[] = array('line_item_id' => $line_item->line_item_id);
        }
        else {
          // Otherwise display the error message; note this is not using
          // form_set_error() on purpose, because a failed addition of a line item
          // doesn't affect the rest of the form submission process.
          drupal_set_message($error, 'error');
        }

        $form_state['rebuild'] = TRUE;
      }
      elseif ($parent == 'cancel') {
        // If the cancel button was clicked refresh without action.
        $form_state['rebuild'] = TRUE;
      }
    }
  }

  // Set the form values.
  form_set_value($element, $value, $form_state);
}

/**
 * Element validation callback: Validates the return reasons option list.
 *
 * @param array $element
 *   The element to be validated.
 * @param array $form_state
 *   The form state array.
 * @param array $form ,
 *   The form array.
 *
 * @return void
 */
function _commerce_return_reason_validate($element, &$form_state, $form) {
  if (empty($element['#value'])) {
    form_error($element, t('A incorrect value has been submitted.'));
  }
}

/**
 * Element validation callback: Validates the return reasons option list.
 *
 * @param array $element
 *   The element to be validated.
 * @param array $form_state
 *   The form state array.
 * @param array $form ,
 *   The form array.
 *
 * @return void
 */
function _commerce_return_line_item_status_validate($element, &$form_state, $form) {
  if (empty($element['#value']) || !in_array($element['#value'], array_keys(commerce_return_line_item_statuses_options_list()))) {
    form_error($element, t('A incorrect value has been submitted.'));
  }
}

/**
 * Validation form callback: validate the return line item manager for
 * customers.
 *
 * @param array $element
 *   The element array.
 * @param array $form_state
 *   The form state array.
 * @param array $form
 *   The form array.
 *
 * @return void
 */
function commerce_return_line_item_manager_customer_validate($element, &$form_state, $form) {
  $value = array();

  // Loop through the line items in the manager table.
  foreach (element_children($element['line_items']) as $line_item_id) {
    // If the line item has been marked for deletion...
    if ($element['line_items'][$line_item_id]['selected']['#value']) {
      // Add the line item ID to the current value of the reference field.
      $value[] = array('line_item_id' => $line_item_id);

      // Update the line item based on the values in the additional elements.
      $line_item = clone($element['line_items'][$line_item_id]['line_item']['#value']);

      // Injecting the return reasons and the line item status. Already
      // validated by their own validator callbacks.
      $line_item->data['commerce_return'] = array(
        'reason_tid' => $form_state['values'][$element['#field_name']][$element['#language']]['line_items'][$line_item_id]['commerce_return_reason'],
        'line_item_status' => $form_state['values'][$element['#field_name']][$element['#language']]['line_items'][$line_item_id]['commerce_return_line_item_status'],
      );

      // Only save if values were actually changed.
      if ($line_item != $element['line_items'][$line_item_id]['line_item']['#value']) {
        commerce_line_item_save($line_item);
      }
    }
//    else {
//      // Delete the line item now and don't include it from the $value array.
//      commerce_line_item_delete($line_item_id);
//    }
  }

  // No product have been selected, so we are raising a form error.
  if (empty($value)) {
    form_error($element, t('You must select at least one product to be returned'));
  }

  // Set the form values.
  form_set_value($element, $value, $form_state);
}

/**
 * @file
 * Implements the various hooks exposed by Drupal commerce completing the
 * commerce_return entity type.
 */

/**
 * Implements hook_commerce_customer_profile_type_info_alter().
 *
 * Using the hook alter because we want to ensure that profile is not attached
 * to commerce_order entity type.
 */
function commerce_return_commerce_customer_profile_type_info_alter(&$profile_types){
  $profile_types['rma'] = commerce_return_customer_profile();
}

/**
 * Implements hook_commerce_checkout_pane_info_alter().
 *
 * Remove the checkout pane related to RMA customer profile implemented
 * by commerce_customer_commerce_checkout_pane_info function.
 */
function commerce_return_commerce_checkout_pane_info_alter(&$checkout_panes) {
  if (isset($checkout_panes['customer_profile_rma'])) {
    unset($checkout_panes['customer_profile_rma']);
  }
}

/**
 * Themes the return line item manager for granted users
 *
 * @param array $variables
 *   Variables storing the form elements
 *
 * @return string
 *   HTML to render.
 */
function theme_commerce_return_line_item_manager_admin($variables) {
  $rows = array();

  // Add each line item to the table.
  foreach (element_children($variables['form']['line_items']) as $line_item_id) {
    $row = array(
      drupal_render($variables['form']['line_items'][$line_item_id]['selected']),
      drupal_render($variables['form']['line_items'][$line_item_id]['title']),
      drupal_render($variables['form']['line_items'][$line_item_id]['line_item_label']),
      drupal_render($variables['form']['line_items'][$line_item_id]['commerce_unit_price']),
      drupal_render($variables['form']['line_items'][$line_item_id]['commerce_return_reason']),
      drupal_render($variables['form']['line_items'][$line_item_id]['commerce_return_line_item_status']),
    );

    $rows[] = $row;
  }

  // Setup the table's variables array and build the output.
  $table_variables = array(
    'header' => array(
      t('Remove'),
      t('Title'),
      t('SKU'),
      t('Unit price'),
      t('Customer reason'),
      t('Status')
    ),
    'rows' => $rows,
    'empty' => $variables['form']['#empty'],
    'sticky' => TRUE,
  );

  $output = theme('table', $table_variables) . drupal_render($variables['form']['actions']);

  return '<div id="line-item-manager" class="clearfix">' . $output . '</div>';
}

/**
 * Themes the return line item manager for customers.
 *
 * @param array $variables
 *   Variables storing the form elements
 *
 * @return string
 *   HTML to render.
 */
function theme_commerce_return_line_item_manager_customer($variables) {
  $rows = array();

  // Add each line item to the table.
  foreach (element_children($variables['form']['line_items']) as $line_item_id) {
    $row = array(
      drupal_render($variables['form']['line_items'][$line_item_id]['selected']),
      drupal_render($variables['form']['line_items'][$line_item_id]['title']),
      drupal_render($variables['form']['line_items'][$line_item_id]['line_item_label']),
      drupal_render($variables['form']['line_items'][$line_item_id]['commerce_return_reason']),
    );

    $rows[] = $row;
  }

  // Setup the table's variables array and build the output.
  $checkbox = array(
    '#type' => 'checkbox',
    '#attributes' => array('class' => array('select-all'))
  );
  $table_variables = array(
    'header' => array(
      drupal_render($checkbox),
      t('Title'),
      t('SKU'),
      t('Your reason'),
    ),
    'rows' => $rows,
    'empty' => $variables['form']['#empty'],
    'sticky' => TRUE,
  );

  $output = theme('table', $table_variables) . drupal_render($variables['form']['actions']);

  return '<div id="return-line-item-manager" class="clearfix">' . $output . '</div>';
}
