<?php

/**
 * Implements hook_filter_info().
 */
function path_corrector_filter_info() {
  return array(
    'path_corrector' => array(
      'title' => t('Path Corrector'),
      'description' => t('Allow links and URLs in the content to be rewritten'),
      'settings callback' => '_path_corrector_filter_settings',
      'default settings' => array(
        'tags' => drupal_map_assoc(array('a', 'img')),
        'string_replacements' => '',
      ),
      'prepare callback' => NULL,
      'process callback' => '_path_corrector_filter_process',
      'cache' => TRUE,
      'tips callback' => '_path_corrector_filter_tips',
      'weight' => 100,
    ),
  );
}


/**
 * Settings callback. Provides the configuration form for the filter.
 */
function _path_corrector_filter_settings($form, &$form_state, $filter, $format, $defaults, $filters) {
  $filter->settings += $defaults;
  $element = array();

  $element['tags'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Tags'),
    '#description' => t('Which tags (HTML Elements) should be corrected'),
    '#default_value' => $filter->settings['tags'],
    // NOTE: These are intentionally un-t()'d...
    '#options' => array(
      'a' => '&lt;a href="">',
      'img' => '&lt;img src="">',
    )
  );

  $element['string_replacements'] = array(
    '#type' => 'textarea',
    '#title' => t('String Replacements'),
    '#default_value' => $filter->settings['string_replacements'],
    '#description' => t('Enter a replacement "pairs", one replacement per line. <br />') .
      t('Each replacements should be in pipe-separated form: <code>example.com|example.org</code><br />'),
  );

  return $element;
}


/**
 * Convert the replacements string (newline separated pairs (of which are pipe
 * separated) of URL parts to replace.
 *
 * @param string $replacements   Replacement text
 * @return array                 Array of From => To pairs of replacements.
 */
function _path_corrector_get_string_replacement_pairs($replacements) {
  $str_replace_pairs = array();
  foreach (explode("\n", $replacements) as $replacement) {
    if (strpos($replacement, '|') !== FALSE) {
      list($from, $to) = explode('|', $replacement);
      $str_replace_pairs[trim($from)] = drupal_encode_path(trim($to));
    }
  }
  return $str_replace_pairs;
}


/**
 * Process callback for the input filter.
 */
function _path_corrector_filter_process($text, $filter, $format, $langcode, $cache, $cache_id) {
  // Bail early if there are no replacements.
  if (empty($filter->settings['string_replacements'])) {
    return $text;
  }
  $patterns = array();

  if (isset($filter->settings['tags']['a'])) {
    $patterns[] = '/<a.+?href=["\'][^\'"]+["\']/';
  }
  if (isset($filter->settings['tags']['img'])) {
    $patterns[] = '/<img.+?src=["\'][^\'"]+["\']/';
  }

  $filter_settings = $filter->settings;
  $callback = function ($matches) use ($filter_settings) {
    $string_replacement_pairs = _path_corrector_get_string_replacement_pairs($filter_settings['string_replacements']);
    return str_replace(array_keys($string_replacement_pairs), $string_replacement_pairs, $matches[0]);
  };

  $text = preg_replace_callback($patterns, $callback, $text);
  return $text;
}


/**
 * Tips Callback for the input format.
 */
function _path_corrector_filter_tips($filter, $format, $long) {
  $string_replacement_pairs = _path_corrector_get_string_replacement_pairs($filter->settings['string_replacements']);
  return t('Path Correcting: @source_paths', array('@source_paths' => implode(', ', array_keys($string_replacement_pairs))));
}