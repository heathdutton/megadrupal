<?php
/**
 * @file
 * Main module file for the Commons Correct Answer module.
 */

define('COMMONS_CORRECT_ANSWER_FLAG_NAME', 'commons_correct_answer');

/**
 * Implements hook_init().
 *
 * Adds the Default CSS for this module.
 */
function commons_correct_answer_init() {
  $css_path = drupal_get_path('module', 'commons_correct_answer') . '/css/commons_correct_answer.css';
  drupal_add_css($css_path);
}

/**
 * Implements hook_permission().
 */
function commons_correct_answer_permission() {
  return array(
    'commons_correct_answer_bypass_access_check' => array(
      'title' => t('Bypass Flag Access Check'),
      'description' => t('Allows the user to bypass the role/owner access checks on the Correct Answer Flag.'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * Modify the Flag Settings for to make it more appropriate for this flag.
 */
function commons_correct_answer_form_flag_form_alter(&$form, &$form_state) {
  $flag = NULL;
  if (isset($form['#flag'])) {
    $flag = $form['#flag'];
  }

  // Make sure we are only altering the correct answer flag form.
  if (empty($flag) || $flag->name != COMMONS_CORRECT_ANSWER_FLAG_NAME) {
    return;
  }

  // Disable/hide the Bundle/Content Type selection field.
  $form['access']['types']['#access'] = FALSE;

  // Modify the description of the user access permissions.
  $form['access']['access_author']['#options'][''] = t('Any user in an allowed role can flag the correct answer.');
  $form['access']['access_author']['#options']['own'] = t('Only the author of the question can flag the correct answer.<br />NOTE: User must still belong to one or more of the selected roles.');
  unset($form['access']['access_author']['#options']['others']);
}

/**
 * Implements hook_node_delete().
 *
 * Removes the correct answer flag if either the question or the answer
 * node has been deleted.
 */
function commons_correct_answer_node_delete($node) {
  if ($node->type == 'question') {
    commons_correct_answer_delete($node->nid);
  }
  if ($node->type == 'answer') {
    commons_correct_answer_delete(FALSE, $node->nid);
  }
}

/**
 * Implements hook_flag_default_flags().
 */
function commons_correct_answer_flag_default_flags() {
  $flags = array();
  $flags['commons_correct_answer'] = array(
    'content_type' => 'node',
    'title' => 'Correct Answer Flag',
    'global' => '1',
    'types' => array(
      0 => 'answer',
    ),
    'flag_short' => 'correct answer',
    'flag_long' => 'correct/best answer',
    'flag_message' => '',
    'unflag_short' => 'incorrect answer',
    'unflag_long' => 'not a correct/best answer',
    'unflag_message' => '',
    'unflag_denied_text' => '',
    'link_type' => 'normal',
    'roles' => array(
      'flag' => array(
        0 => '2',
      ),
      'unflag' => array(
        0 => '2',
      ),
    ),
    'weight' => 0,
    'show_on_form' => 0,
    'access_author' => 'own',
    'show_on_page' => 1,
    'show_on_teaser' => 0,
    'show_contextual_link' => FALSE,
    'i18n' => 0,
    'module' => 'commons_correct_answer',
    'locked' => array(
      0 => 'name',
      1 => 'show_on_form',
      2 => 'show_on_teaser',
      3 => 'types',
      4 => 'global',
    ),
    'api_version' => 2,
  );
  return $flags;
}

/**
 * Implements hook_flag().
 */
function commons_correct_answer_flag($op, $flag, $content_id, $account, $fcid) {
  if ($flag->name == COMMONS_CORRECT_ANSWER_FLAG_NAME) {
    $answer_node = node_load($content_id);
    $question_nid = $answer_node->field_related_question['und'][0]['target_id'];

    switch ($op) {
      case 'flag':
        commons_correct_answer_save($question_nid, $answer_node->nid, $fcid);
        break;

      case 'unflag':
        commons_correct_answer_delete($question_nid, $answer_node->nid);
        break;
    }
  }
}

/**
 * Implements hook_flag_access().
 *
 * Determines whether or not to display the fag according to the these rules:
 * 1. User already has permission to use the flag via the flag permissions.
 *    Handled by the default flag access checks.
 * 2. Only one answer per question can be flagged as the correct answer.
 * 3. Only the author of the question node can flag the correct answer.
 */
function commons_correct_answer_flag_access($flag, $content_id, $action, $account) {
  if ($flag->name == COMMONS_CORRECT_ANSWER_FLAG_NAME) {
    // Assume no access until proven otherwise.
    $allow_access = FALSE;

    // Get the question being displayed.
    $question_node = commons_correct_answer_get_question_node($content_id);

    if ($question_node && $question_node->type == 'question') {
      // See if the user has permission to flag/unflag this content.
      $allow_access = commons_correct_answer_access($flag, $action, $account, $question_node);

      if ($allow_access) {
        // See if this question has a correct answer already.
        $correct_answer_nid = commons_correct_answer_get_correct_answer($question_node->nid);

        // Make sure only one answer for this question can be flagged.
        if ($action == 'flag'
          && $correct_answer_nid !== FALSE
          && $correct_answer_nid != $content_id) {
          $allow_access = FALSE;
        }
      }
    }

    return $allow_access;
  }
}

/**
 * Implements hook_preprocess_HOOK().
 *
 * Modifies the node classes array to indicate if the node has been flagged
 * as a correct answer.
 */
function commons_correct_answer_preprocess_node(&$variables) {
  $nid = $variables['nid'];
  switch ($variables['type']) {
    case 'answer':
      $is_flagged = commons_correct_answer_is_answer_flagged($nid);
      if ($is_flagged) {
        $variables['classes_array'][] = 'flag--commons-correct-answer-answer';
      }
      break;

    case 'question':
      $is_flagged = commons_correct_answer_is_question_flagged($nid);
      if ($is_flagged) {
        $variables['classes_array'][] = 'flag--commons-correct-answer-question';
      }
      break;
  }
}

/**
 * Retrieves the nid of the answer node flagged as the correct answer.
 *
 * @param int $qnid
 *   The nid of the question node.
 *
 * @returns int|bool
 *   Returns the nid of the flagged answer node or FALSE if no answer has
 *   been flagged correct.
 */
function commons_correct_answer_get_correct_answer($qnid) {
  // We do static caching here because this will get called once
  // for every answer displayed on the page for a question.
  $result = &drupal_static(__FUNCTION__ . ':' . $qnid);

  if (!isset($result)) {
    $result = db_select('commons_correct_answer', 'cca')
      ->fields('cca', array('anid'))
      ->condition('qnid', $qnid, '=')
      ->execute()
      ->fetchField();
  }

  return $result;
}

/**
 * Saves the correct answer flag to the database.
 *
 * @param int $qnid
 *   The nid of the question node.
 *
 * @param int $anid
 *   The nid of the answer node.
 *
 * @param int $fcid
 *   The id of the flag in the flag_content table.
 */
function commons_correct_answer_save($qnid, $anid, $fcid) {
  db_insert('commons_correct_answer')
    ->fields(array(
      'qnid' => $qnid,
      'anid' => $anid,
      'fcid' => $fcid,
    ))
    ->execute();
}

/**
 * Deletes the flag for a correct answer from the database.
 *
 * @param int|bool $qnid
 *   Optional: The nid of the Question node to remove the flag for.
 *
 * @param int|bool $anid
 *   Optional: The nid of the Answer node to remove the flag for.
 *
 * @throws HttpInvalidParamException
 *   Occurs if both $qnid and $anid are FALSE.
 */
function commons_correct_answer_delete($qnid = FALSE, $anid = FALSE) {
  if ($qnid === FALSE && $anid === FALSE) {
    throw new HttpInvalidParamException('At least 1 parameter must be specified.');
  }

  $query = db_delete('commons_correct_answer');
  if ($qnid !== FALSE) {
    $query->condition('qnid', $qnid);
  }
  if ($anid !== FALSE) {
    $query->condition('anid', $anid);
  }
  $query->execute();
}

/**
 * Retrieves the related question that the flag is operating on.
 *
 * @param int $content_id
 *   The nid of the answer node being flagged.
 *
 * @return bool|object
 *  Returns the question node object.  FALSE if it cannot be found.
 */
function commons_correct_answer_get_question_node($content_id) {
  $question_node = menu_get_object();
  if (empty($question_node)) {
    // This can be empty during the flag/unflag callbacks.
    // Load the content manually.
    $entity = entity_load('node', array($content_id));
    if (isset($entity[$content_id])) {
      $node = $entity[$content_id];
      if ($node->type == 'question') {
        $question_node = $node;
        return $question_node;
      }
      elseif ($node->type == 'answer') {
        $question_node = node_load($node->field_related_question[LANGUAGE_NONE][0]['target_id']);
        return $question_node;
      }
      return $question_node;
    }
    return $question_node;
  }
  return $question_node;
}

/**
 * Determines if the user has permission to flag/unflag the content.
 *
 * @param object $flag
 *   The flag being set/unset.
 *
 * @param string $action
 *   The action being performed. Either "flag" or "unflag".
 *
 * @param object $account
 *   The user account performing the action.
 *
 * @param object $question_node
 *   The node object for the related question.
 *
 * @return bool
 *   TRUE if the user has permission to set the flag.  Otherwise FALSE.
 */
function commons_correct_answer_access($flag, $action, $account, $question_node) {
  // Assume the user does not have access until proven otherwise.
  $allow_access = FALSE;

  // See if the user has permission to bypass the access check.
  if (user_access('commons_correct_answer_bypass_access_check', $account)) {
    $allow_access = TRUE;
  }

  if (!$allow_access) {
    // Perform role based permission checks.
    $has_roles = $flag->user_access($action, $account);

    switch ($flag->access_author) {
      case '':
        // Only users in authorized roles may flag the correct answer.
        $allow_access = $has_roles;
        break;

      case 'own':
        // Only the user that posted the question
        // (and is in the correct role) can flag the correct answer.
        $allow_access = ($has_roles && $account->uid == $question_node->uid);
        break;
    }
  }
  return $allow_access;
}

/**
 * Determines if a user is in an allowed role.
 *
 * @param object $flag
 *   The flag being processed.
 *
 * @param string $action
 *   The action being performed.  Either "flag" or "unflag".
 *
 * @param array $user_roles
 *   An array of roles that the user should have.
 *
 * @return array|bool
 *   TRUE if the user has one or more of the listed roles.  Otherwise FALSE.
 */
function commons_correct_answer_user_has_allowed_role($flag, $action, $user_roles) {
  $has_roles = FALSE;
  switch ($action) {
    case 'flag':
      $flag_roles = array_values($flag->roles['flag']);
      $roles = array_intersect($flag_roles, $user_roles);
      $has_roles = !empty($roles);
      break;

    case 'unflag':
      $unflag_roles = array_values($flag->roles['unflag']);
      $roles = array_intersect($unflag_roles, $user_roles);
      $has_roles = !empty($roles);
      break;
  }
  return $has_roles;
}

/**
 * Determines if a piece of content has been flagged as the correct answer.
 *
 * @param int $content_id
 *   The id of the content being checked.
 *
 * @return bool
 *   TRUE if the content has been flagged as the correct answer.
 */
function commons_correct_answer_is_answer_flagged($content_id) {
  $is_flagged = _commons_correct_answer_is_flagged('anid', $content_id);

  return $is_flagged;
}

/**
 * Determines if a question has had an answer flagged as correct..
 *
 * @param int $content_id
 *   The id of the content being checked.
 *
 * @return bool
 *   TRUE if the content has been flagged as the correct answer.
 */
function commons_correct_answer_is_question_flagged($content_id) {
  $is_flagged = _commons_correct_answer_is_flagged('qnid', $content_id);

  return $is_flagged;
}

/**
 * Helper function to determine if a correct answer flag has been set.
 *
 * @param string $field
 *   The field name to check.  Either "qnid" or "anid".
 *
 * @param int $content_id
 *   The ID of the content being checked for a flag.
 *
 * @return bool
 *   TRUE if the correct answer flag is set for the content.
 *   FALSE if the correct answer flag has not been set for the content.
 */
function _commons_correct_answer_is_flagged($field, $content_id) {
  $result = db_select('commons_correct_answer', 'cca')
    ->fields('cca')
    ->condition($field, $content_id)
    ->countQuery()
    ->execute()
    ->fetchField();

  return $result > 0;
}
