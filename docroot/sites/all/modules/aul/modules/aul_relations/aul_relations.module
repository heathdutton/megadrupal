<?php

/**
 * @file
 * AUL relations grants main module file. Synchronizes grants of related nodes.
 * 
 * @todo: implement invert enrity reference relations.
 * @todo: implement comments to node relations.
 * @todo: implement bulk grants update.
 * @todo: Control access on child reference add/remove. Use entity insert or
 * update @see _erpal_docs_access_entity_handle().
 */

/**
 * React before node AUL deletion.
 *
 * @param int $nid
 *   Node id.
 */
function aul_relations_aul_node_pre_delete($nid) {
  $gids = aul_get_all_aul_of_node($nid);
  $query = db_delete('aul_relations');
  $query->condition('gid', $gids, 'IN');
  $query->execute();
}

/**
 * React before user AUL deletion.
 *
 * @param int $uid
 *   User id.
 */
function aul_relations_aul_user_pre_delete($uid) {
  if ($gids = aul_get_all_aul_of_user($uid)) {
    $query = db_delete('aul_relations');
    $query->condition('gid', $gids, 'IN');
    $query->execute();
  }
}

/**
 * Add AUL relation.
 * 
 * @param int $gid
 *   Node id.
 * @param int $limit
 *   Result items limit.
 * 
 * @return array
 *   AUL relations list.
 */
function aul_relations_get_sources($gid, $limit = 1) {
  
  $result = db_select('aul_relations', 'ar')
    ->fields('ar')
    ->condition('gid', $gid)
    ->range(0, $limit)
    ->execute();
  
  return $result->fetchAll();
}

/**
 * Check if AUL relation exists.
 * 
 * @param int $gid
 *   AUL grant id.
 * @param int $source_nid
 *   Node id.
 * 
 * @return boolean
 *   TRUE if exists, FALSE if doesn't.
 */
function aul_relations_exists($gid, $source_nid) {
  
  $result = db_select('aul_relations', 'ar')
    ->fields('ar')
    ->condition('gid', $gid)
    ->condition('source_nid', $source_nid)
    ->countQuery()
    ->execute();
  
  return $result->fetchField();
}

/**
 * Add AUL relation.
 * 
 * @param int $gid
 *   AUL grant id.
 * @param int $source_nid
 *   Node id.
 */
function aul_relations_add($gid, $source_nid) {
  if (!aul_relations_exists($gid, $source_nid)) {
    $fields = array(
      'gid' => $gid,
      'source_nid' => $source_nid,
    );

    $gid = db_insert('aul_relations')
     ->fields($fields)
     ->execute();
  }
}

/**
 * Add AUL relation.
 * 
 * @param int $gid
 *   AUL grant id.
 * @param int $source_nid
 *   Node id.
 */
function aul_relations_remove($gid, $source_nid) {
  $query = db_delete('aul_relations');
  $query->condition('gid', $gid);
  $query->condition('source_nid', $source_nid);
  $query->execute();
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function aul_relations_form_field_ui_field_edit_form_alter(&$form, $form_state) {

  if ($form['#field']['type'] == 'entityreference') {
    if (!empty($form['#field']['settings']['target_type']) && $form['#field']['settings']['target_type'] == 'node') {

      // Get setting value.
      $defaults = !empty($form['#field']['widget']['settings']['aul']['relations_sync']);

      // Sync grants with referenced node setting.
      $form['field']['widget']['settings']['aul'] = array(
        '#type' => 'fieldset',
        '#title' => t('AUL'),
        '#collapsed' => FALSE,
        '#collapsible' => FALSE,
      );

      $form['field']['widget']['settings']['aul']['relations_sync'] = array(
        '#type' => 'checkbox',
        '#title' => t('Sync grants with referenced node'),
        '#default_value' => $defaults,
      );

      return $form;
    }
  }
}

/**
 * Implements hook_aul_add().
 */
function aul_relations_aul_add($context) {

  if (!$node = node_load($context['nid'])) {
    return;
  }
  
  // Remember id of parent node as source_nid.
  $source_nid = &drupal_static(__FUNCTION__);
  if(empty($source_nid)) {
    $source_nid = $context['nid'];
  }

  $entity_type = 'node';
  $bundle = $node->type;

  // Helper function. Loop fields. Search for grants sync setting.
  _aul_relations_handle_aul_access($node, $entity_type, $bundle, $context);
  
  // Add relation between current node and grants source node.
  aul_relations_add($context['gid'], $source_nid);
}

/**
 * Implements hook_aul_pre_remove().
 */
function aul_relations_aul_pre_remove($context) {

  if (!$node = node_load($context['nid'])) {
    return;
  }
  
  // Remember id of parent node as source_nid.
  $source_nid = &drupal_static(__FUNCTION__);
  if(empty($source_nid)) {
    $source_nid = $context['nid'];
  }

  aul_relations_remove($context['gid'], $source_nid);
  
  $entity_type = 'node';
  $bundle = $node->type;
  
  // Helper function. Loop fields. Search for grants sync setting.
  _aul_relations_handle_aul_access($node, $entity_type, $bundle, $context);
  
  if (aul_relations_get_sources($context['gid'])) {
    return AUL_CANCEL_ACTION;
  }
}

/**
 * Helper function. Loop fields. Search for grants sync setting.
 */
function _aul_relations_handle_aul_access($entity, $entity_type, $bundle, &$context) {

  //static $processed = array();
  $processed = &drupal_static(__FUNCTION__, array());

  // Filter fields. Search for grants sync setting.
  foreach (array_keys(field_info_instances($entity_type, $bundle)) as $field_name) {

    if (!$field = field_info_field($field_name)) {
      continue;
    }

    // Handle field collection field fields.
    if ($field['type'] == 'field_collection') {

      $values = field_get_items($entity_type, $entity, $field_name);
      foreach ($values as $value) {

        $item_id = $value['value'];
        if (!$item = field_collection_item_load($item_id)) {
          continue;
        }

        // Check field_collection fields recurcive.
        $fc_bundle = $item->field_name;
        $fc_type = 'field_collection_item';
        _aul_relations_handle_aul_access($item, $fc_bundle, $fc_type, $context);
      }

      continue;
    }

    // Sync access with referenced node where sync access is enabled.
    if (aul_relations_field_sync_enabled($field)) {

      if (!$values = field_get_items($entity_type, $entity, $field_name)) {
        continue;
      }
      foreach ($values as $value) {
        
        // Load referenced node.
        $nid = $value['target_id'];
        if (!$node = node_load($nid)) {
          continue;
        }

        // Check if node was already processed.
        $action = $context['action'];
        if (!empty($processed[$context['gid']][$action])) {
          if (in_array($nid, $processed[$context['gid']][$action])) {
            continue;
          }
        }

        // Add node to processed list
        $processed[$context['gid']][$action][] = $nid;
        
        $callback = "aul_{$action}_aul";
        $callback($context['key_id'], $nid, $context['grants'], $context['source'], $context['key_name']);
        // Rebuild node grants.
        node_access_acquire_grants($node);
      }
    }
  }
}

/**
 * Check if fiels AUL relations sync setting is enabled correctly.
 * 
 * @param array $field
 *   Field info array from field_info_field().
 * 
 * @return boolean
 *   TRUE is sync is enabled. FALSE on failure.
 */
function aul_relations_field_sync_enabled($field) {
  
  // Field must reference nodes.
  if (empty($field['settings']['target_type']) || $field['settings']['target_type'] != 'node') {
    return FALSE;
  }
  
  // Sync access with referenced node must be enabled.
  if (empty($field['widget']['settings']['aul']['relations_sync'])) {
    return FALSE;
  }
  
  return TRUE;
}

/**
 * 
 * @todo: Not needed used yet. We just decrease of increase grants value. And 
 * we can use this number to get count of parrents.
 * 
 * Check if node is already related to other node current user has access to.
 * 
 * Usage:
 *   Before removing grants to the current node we need to check if this node
 *   is already referenced to other node. If this node is already related to 
 *   other node current user has access to, we need to cancel removing grants.
 *   @todo: check node relations usage. Use AUL_CANCEL_ACTION.
 *   if(aul_relations_parent_has_access($context['nid'], $context)) {
 *     return AUL_CANCEL_ACTION;
 *   }
 * 
 * @param object $nid
 *   Target node id
 * @param array $context
 *   Context of aul action.
 * @param object $user
 *   (optional) Target user.
 * 
 * @return boolean
 *   TRUE if node is already related to other node current user has access to.
 *   FALSE on failure.
 */
/*function aul_relations_parent_has_access($nid, $context, $user = NULL) {

  if (!$user) {
    $user = user_load($context['uid']);
  }
  
  $access_cache = array();
  $access = 0;

  // Get all entityreference field names.
  $query = db_select('field_config', 'fc');
  $query->fields('fc', array('field_name'));
  $query->fields('fi', array('entity_type'));
  $query->fields('fi', array('bundle'));
  $query->innerJoin('field_config_instance', 'fi', 'fi.field_id = fc.id');
  $query->condition('fc.type', 'entityreference');
  // @todo: make pluggable adding own entities, not only field_collection and 
  // node.
  $types = array(
    'node',
    'field_collection_item',
    // @todo: 'comment',
  );
  $query->condition('fi.entity_type', $types, 'IN');
  $fields = $query->execute()->fetchAll();
  
  // Process each field settings and parents.
  foreach ($fields as $value) {
    $field = field_info_field($value->field_name);

    // Sync access with referenced node must be enabled correctly.
    if (aul_relations_field_sync_enabled($field)) {
      continue;
    }

    $field_name = $value->field_name;
    $entity_type = $value->entity_type;
    $bundle = $value->bundle;

    // Get all parent nodes of our child node by references.
    if (!$parents = aul_relations_node_parent_nodes($field_name, $entity_type, $bundle, $nid)) {
      continue;
    }

    // Loop parents. Check parents access.
    foreach ($parents as $parent_id) {

      // Load parent entity.
      $entity_loaded = entity_load($entity_type, array($parent_id));
      if (!is_array($entity_loaded)) {
        continue;
      }
      if (!$parent_entity = array_shift($entity_loaded)) {
        continue;
      }

      // Parent entity is node.
      if ($entity_type == 'node') {

        $op = $context['op'];

        // Check parent entity access.
        if (node_access($op, $entity_type, $parent_entity, $user)) {
          
          // Cache entity access.
          //$access_cache[$entity_type][$parent_id][$op] = 1;
          
          $access++;
          
          // Returm match if some other entities reference our child node and 
          // user has access for current operation with parrent entities.
          if($access > 1) {
            // If access > 1 ( >= 2) that means we have found two parents of 
            // current node and user has access to these two parent nodes for 
            // current operation.
            // We need to find at least two entities because one entity is already 
            // referenced.
            // @todo:
            // What if entity paeernt removed or we just removed access of child 
            // entity. How to find a difference?
            return TRUE;
          }
        }
        else {
          // Cache entity access.
          //$access_cache[$entity_type][$parent_id][$op] = 0;
        }
      }
    }
  }
}*/

/**
 * @todo: Not needed used yet. We just decrease of increase grants value. And 
 * we can use this number to get count of parrents.
 * 
 * Get all parent entities in field
 * @param type $target_id
 * @param type $field_name
 * @param type $bundle
 * @return type
 */
/*function aul_relations_node_parent_nodes($field_name, $entity_type, $bundle, $nid) {

  // Parent entity is field collection.
  if ($entity_type == 'field_collection_item') {
    // @todo.
  }
  else

  // Parent entity is comment.
  if ($entity_type == 'comment') {
    // @todo.
  }
  // Parent entity is node.
  if ($entity_type == 'node') {
    
  }

  $results = array();
  $table = 'field_data_' . $field_name;
  $field = $field_name . '_target_id';
  if (empty($results) && db_field_exists($table, $field)) {
    $query = db_select($table, 'f');
    $query->fields('f', array('entity_id'));
    $query->condition('f.bundle', $bundle);
    $query->condition('f.entity_type', $entity_type);
    $query->condition('f.' . $field, $nid);
    $query->distinct();

    $references = $query->execute();
    $results = array();
    foreach ($references as $reference) {
      $results[$reference->entity_id] = $reference->entity_id;
    }
  }
  
  return $results;
}*/
