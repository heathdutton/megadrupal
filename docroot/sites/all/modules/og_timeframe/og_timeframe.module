<?php

/**
 * @file
 * The OG Time frame API.
 */

/**
 * Retrieve timeframe handler implementations.
 *
 * @return array
 *   Implementing time frame handlers.
 */
function og_timeframe_get_handler_info() {
  $handler_info = &drupal_static(__FUNCTION__, NULL);
  if (is_null($handler_info)) {
    $cache = cache_get('og_timeframe_handler_info');
    if ($cache) {
      $handler_info = $cache->data ?: array();
    }
    else {
      $handler_info = module_invoke_all('og_timeframe_handler_info');
      drupal_alter('og_timeframe_handler_info', $handler_info);
      cache_set('og_timeframe_handler_info', $handler_info);
    }
  }
  return $handler_info;
}

/**
 * Get the time frame handler for given group content bundle.
 *
 * @param string $og_type
 *   The group entity type.
 * @param string $og_bundle
 *   The group entity bundle.
 * @param string $ogc_type
 *   The group content entity type.
 * @param string $ogc_bundle
 *   The group content entity bundle.
 *
 * @return OgTimeframeHandler
 *   Handler object implementing OgTimeframeHandlerInterface.
 */
function og_timeframe_get_handler($og_type, $og_bundle, $ogc_type, $ogc_bundle) {
  $handlers = &drupal_static(__FUNCTION__, array());
  $path = array($og_type, $og_bundle, $ogc_type, $ogc_bundle);
  $handler_index = og_timeframe_hash($path);

  if (!isset($handlers[$handler_index])) {
    $handler_info = og_timeframe_get_handler_info();
    $info = og_timeframe_find_deepest($handler_info, $path);
    if ($info) {
      // Let's provide more context. We don't bother treating this in a FAPI way
      // prefixing it with '#', though we might should for the sake of
      // consistency.
      $info += array(
        'group_type' => $og_type,
        'group_bundle' => $og_bundle,
        'group_content_type' => $ogc_type,
        'group_content_bundle' => $ogc_bundle,
      );
      $class = $info['#class'];
      $handlers[$handler_index] = new $class($info);
    }
    else {
      $handlers[$handler_index] = FALSE;
    }
  }
  return $handlers[$handler_index];
}

/**
 * Find the deepest handler info in a nested array using given path.
 *
 * @param array $nested
 *   Nested array of members.
 * @param array $walk
 *   The path of indexes to walk.
 *
 * @return array
 *   The found array with its associated properties.
 */
function og_timeframe_find_deepest(array $nested, array $walk) {

  $inspected = $nested;
  $returned = isset($inspected['#class']) ? $inspected : array();
  foreach ($walk as $index) {
    if (!isset($inspected[$index])) {
      break;
    }
    $inspected = $inspected[$index];
    if (isset($inspected['#class'])) {
      $returned = $inspected;
    }
  }
  // Return only properties found in $returned.
  return $returned ? array_intersect_key($returned, drupal_map_assoc(element_properties($returned))) : $returned;
}

/**
 * Generate a single hash of all indexes used to lookup handler.
 *
 * @param array $indexes
 *   Strings to create hash of.
 *
 * @return string
 *   Generated hash.
 */
function og_timeframe_hash(array $indexes) {
  return hash('md5', implode(':', $indexes));
}


/**
 * Date API granularity to 'measure' conversion.
 *
 * @param string $granularity
 *   A single date granularity.
 *
 * @return string
 *   Precision as used in DateObject::difference()
 */
function og_timeframe_granularity_to_measure($granularity) {
  if ($granularity == 'timezone') {
    return 'seconds';
  }
  // Otherwise, it's 'second', 'minute', 'hour' ... and difference() wants it in
  // plural.
  return $granularity . 's';
}

/**
 * Implements hook_og_user_access_alter().
 *
 * This part only deals with $op == 'create' as we're given an actual group node
 * as context. hook_node_access() takes care of $op == 'update'.
 */
function og_timeframe_og_user_access_alter(&$perm, $context) {
  $perm_parts = explode(' ', $context['string']);
  $op = $perm_parts[0];
  if ($op !== 'create') {
    return;
  }

  $group_type = $context['group_type'];
  $group = $context['group'];
  list(, , $group_bundle) = entity_extract_ids($group_type, $group);
  $group_bundle = $group_bundle ?: $group_type;
  $member_bundle = $perm_parts[1];

  if (!$handler = og_timeframe_get_handler($group_type, $group_bundle, 'node', $member_bundle)) {
    return;
  }
  if (!$handler->isOpen($group, $member_bundle, $op)) {
    $perm[$context['string']] = FALSE;
  }
}

/**
 * Implements hook_node_access().
 */
function og_timeframe_node_access($node, $op, $account) {
  if ($op != 'update' || is_string($node)) {
    return NODE_ACCESS_IGNORE;
  }
  // Ignore anything but group content.
  if (!$entity_groups = og_get_entity_groups('node', $node)) {
    return NODE_ACCESS_IGNORE;
  }

  foreach ($entity_groups as $group_type => $group_ids) {
    foreach ($group_ids as $group_id) {
      $group = entity_load_single($group_type, $group_id);
      list(, , $group_bundle) = entity_extract_ids($group_type, $group);
      if (!$handler = og_timeframe_get_handler($group_type, $group_bundle, 'node', $node->type)) {
        continue;
      }
      if (!$handler->isOpen($group, $node, $op)) {
        return NODE_ACCESS_DENY;
      }
    }
  }
  return NODE_ACCESS_IGNORE;
}
