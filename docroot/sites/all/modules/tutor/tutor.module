<?php

/**
 * @file
 * Manages a framework for automatically generated questions.
 */

/**
 * Constants used for categorizing answer evaluations.
 *
 * Constants are defined so positive ones are ok or close to ok, while zero and
 * negative ones are wrong on one way or another.
 */
define('TUTOR_ANSWER_CORRECT', 1);
define('TUTOR_ANSWER_CLOSE', 2);
define('TUTOR_ANSWER_INCOMPLETE', 3);
define('TUTOR_ANSWER_WRONG', 0);
define('TUTOR_ANSWER_INVALID', -1);
define('TUTOR_ANSWER_QUIT', -2);

// Include functions like tutor_data_store(), stored elsewhere
include drupal_get_path('module', 'tutor') . '/tutor-data-storage.inc';

/**
 * Implements hook_ctools_plugin_type().
 *
 * Declares that the Tutor module makes use of 'question' plugins.
 */
function tutor_ctools_plugin_type() {
  return array(
    'question' => array(
      // This setting tells CTools that plugins can be declared by implementing
      // hook_tutor_question().
      'use hooks' => TRUE,
      // This declares a process function, that provides some default values for
      // question plugins.
      'process' => 'tutor_plugin_process',
    ),
  );
}

/**
 * Processes information about Tutor question plugins.
 *
 * This processing adds a default handler to question plugins, if one is not
 * already set.
 *
 * @param $plugin
 *   An array with information about the plugin being processed.
 * @param $plugin_info
 *   Information about the plugin type. Not used in this context, but by CTools
 *   framework for processing plugins.
 */
function tutor_plugin_process(&$plugin, $plugin_info) {
  if (!isset($plugin['handler'])) {
    // Make the class name default a CamelCase version of the question ID.
    // See http://drupal.org/node/608152 for Drupal coding standards for OOP.
    $handler = str_replace('_', ' ', $plugin['name']);
    $handler = ucwords($handler);
    $handler = str_replace(' ', '', $handler);
    $plugin['handler'] = $handler;
  }
}

/**
 * Loads the entire list of avaliable question plugins and returns their labels.
 *
 * This function is used when building an options list for all the available
 * scripted questions.
 *
 * @param $required
 *   TRUE if only scripted questions should be included in the list. If FALSE,
 *   an option '(none)' will be added on the top.
 * @return
 *   An array with question labels, keyed by the question machine names.
 */
function tutor_question_labels($required = TRUE) {
  ctools_include('plugins');
  $options = array();

  if ($required == FALSE) {
    $options[NULL] = t('(none)');
  }
  foreach (ctools_get_plugins('tutor', 'question') as $id => $info) {
    $options[$id] = tutor_question_load_raw($id, array())->labelGet();
  }

  return $options;
}

/**
 * Loads a raw question object.
 *
 * This function runs all dependencies required for creating the relevant
 * question object, and caches the results.
 *
 * @param $question_id
 *   The id of the question.
 * @return
 *   An object of the class described by the question plugin.
 */
function tutor_question_load_raw($question_id) {
  // drupal_static() is used for caching â€“ this function may be called several
  // times on the same page request.
  $instances = &drupal_static(__FUNCTION__);

  if (!isset($instances[$question_id])) {
    // Get an object of the relevant class.
    ctools_include('plugins');
    $info = ctools_get_plugins('tutor', 'question', $question_id);
    $class = ctools_plugin_load_class('tutor', 'question', $question_id, 'handler');
    if (!$class) {
      $instances[$question_id] = NULL;
      return $instances[$question_id];
    }

    if (!isset($info['settings'])) {
      $info['settings'] = NULL;
    }
    $instances[$question_id] = new $class($question_id, $info['settings']);

    // Check that plugin class has inherited the 'TutorQuestion' class.
    if (!is_subclass_of($instances[$question_id], 'TutorQuestion')) {
      $instances[$question_id] = NULL;
    }
  }

  return $instances[$question_id];
}

/**
 * Loads an instance of a question, with parameters fetched from storage.
 *
 * This is the function normally used when loading a question. It takes care of
 * loading the relevant type of question, and populating it with the proper
 * parameters. If no stored parameters are found, new ones are generated and
 * then stored.
 *
 * @param $question_id
 *   The ID of the question plugin.
 * @param $storage_id
 *   The ID used for the parameter storage. If no parameters are found, or the
 *   parameters don't match the given question plugin, new parameters are stored
 *   with this ID.
 * @return tutorQuestion
 *   A question object, populated with relevant parameters.
 */
function tutor_question_load($question_id, $storage_id) {
  $question = tutor_question_load_raw($question_id);
  $question->storageIdSet($storage_id);
  $parameters = tutor_parameters_load($storage_id);

  // Check if we have any stored parameters, and verify that the parameters
  // actually belong to a question with the requested ID.
  if ($parameters && tutor_data_load($storage_id, 'question_id') == $question_id) {
    $question->parametersSet($parameters);
  }
  // If no matching parameters were found, generate new ones.
  else {
    tutor_data_store($storage_id, 'question_id', $question_id);
    tutor_parameters_store($storage_id, $question->parametersGenerate()->parametersGet());
  }

  return $question;
}

/**
 * Builds common elements in question forms.
 *
 * This function is not used by itself to create forms, but is a helper function
 * for other form functions. It returns a form array with validation callback,
 * some environment data, a submit button, and the form generated by the
 * question plugin.
 *
 * @param $question
 *   The question object. Passed by reference.
 * @return
 *   A form array.
 */
function tutor_question_base_form($question) {
  // Build default form components, which can be overridden by the question.
  $form['#validate'] = array('tutor_question_form_process');
  $form['environment'] = array(
    '#type' => 'value',
    '#value' => array(
      'question' => $question,
      'question id' => $question->questionIdGet(),
      'storage id' => $question->storageIdGet(),
    ),
  );
  $form['submit'] = array(
    '#weight' => 90,
    '#type' => 'submit',
    '#value' => t('Submit'),
  );

  $form['quit'] = array(
    '#weight' => 100,
    '#type' => 'submit',
    '#value' => t('Enough'),
    '#submit' => array('tutor_enough'),
    '#limit_validation_errors' => array(),
    '#access' => variable_get('tutor_enough', FALSE),
  );

  // Check if there are any messages from the last submitted question to
  // display.
  $message = tutor_data_load($question->storageIdGet(), 'messages');
  if ($message !== FALSE) {
    $form['message'] = tutor_message_element($message);
    // Remove the message so it won't be repeated.
    tutor_data_reset($question->storageIdGet(), 'messages');
  }

  // Pass the form to the question builder for modifications.
  $question->buildQuestion($form);
  return $form;
}

/**
 * Performs basic validation of submissions to Tutor questions.
 *
 * This validation function evaluates the answer to a question and sets any
 * messages corresponding to the result. It does not, however, reset any
 * question parameters to spawn new questions. This should be taken care of by
 * additional validation (or submit) functions.
 */
function tutor_question_form_process(&$form, &$form_state) {
  // If any errors have been set by standard form checks, process them as a
  // warning (non-incorrect) message and shortcut any more complex validation.
  if (count(form_get_errors())) {
    $form['message'] = tutor_message_element(new TutorQuestionResponse(TUTOR_ANSWER_INCOMPLETE));
    return;
  }

  // Evaluate the answer to the question.
  $question = &$form['environment']['#value']['question'];
  $question
    ->extractAnswer($form)
    ->evaluateAnswer();
  // Store the result, to display a message on the next page load.
  tutor_data_store($question->storageIdGet(), 'messages', $question->response);
}

/**
 * Returns a form element for displaying a question response message.
 *
 * @param TutorQuestionResponse $response
 *   The question response to make a message from.
 * @return
 *   A markup element that can be injected into a form.
 */
function tutor_message_element(TutorQuestionResponse $response) {
  $css_classes = array(
    TUTOR_ANSWER_CORRECT => 'tutor-answer-correct',
    TUTOR_ANSWER_CLOSE => 'tutor-answer-close',
    TUTOR_ANSWER_INCOMPLETE => 'tutor-answer-incomplete',
    TUTOR_ANSWER_WRONG => 'tutor-answer-wrong',
    TUTOR_ANSWER_INVALID => 'tutor-answer-invalid',
    TUTOR_ANSWER_QUIT => 'tutor-answer-quit',
  );

  $form_element = array(
    '#type' => 'markup',
    '#weight' => '-100',
    '#markup' => $response->message,
    '#prefix' => '<div class="tutor-message ' . $css_classes[$response->response_type] . '">',
    '#suffix' => '</div>',
    // A much nicer way to add css classes and prefix/suffix would be to use the
    // #type => item and the #attributes property. But for some reason
    // attributes can't be applied to 'item' elements. Sorry.
    // '#type' => 'item',
    // '#attributes' => array('class' => array('tutor-message', $constant_names[$result->response_type])),
  );
  return $form_element;
}

/**
 * Stub function for quitting a question.
 *
 * This stub function allows failing a scripted question and loading a new one.
 * Or just aborting the question and go back to an overview.
 */
function tutor_enough($form, $form_state) {
  $environment = &$form['environemnt']['#value'];
  tutor_parameters_reset($environment['storage id']);

  // Load relevant data and fire a Rules event.
  if (module_exists('rules')) {
    global $user;
    $entity = entity_metadata_wrapper($environment['entity type'], $environment['entity']);
    rules_invoke_event('tutor_abort', $environment['question id'], $entity, $user);
  }

  tutor_data_store($environment['storage id'], 'messages', new TutorQuestionResponse(TUTOR_ANSWER_QUIT));
}

/**
 * Helper function to normalize strings before comparison.
 *
 * This function can be used to strip an answer for spaces, multiplication
 * asterisks, and more. It also turns the string to lowercase, for easier
 * comparison later on.
 *
 * @param $answer
 *   The string to process. Passed by reference.
 * @param $characters
 *   An array with characters/expressions to strip. Defaults to spaces and
 *   asterisks.
 */
function tutor_strip(&$answer, $characters = array(' ', '*')) {
  $answer = str_replace($characters, '', $answer);
  $answer = strtolower($answer);
}

/**
 * Helper function that returns a list of names, used for picking a random one.
 *
 * @return
 *   An array with names, keyed by the first letter of the name.
 */
function tutor_names() {
  $names = array(
    'a' => t('Alice'),
    'b' => t('Bob'),
    'c' => t('Cedric'),
    'd' => t('Daniel'),
    'e' => t('Eve'),
    'f' => t('Felicia'),
    'g' => t('George'),
    'h' => t('Harry'),
    'i' => t('Indira'),
    'j' => t('Joe'),
  );
  shuffle($names);
  return $names;
}
