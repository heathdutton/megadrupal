<?php
/**
 * @file
 * Commerce dressing room module.
 *
 * @ingroup commerce_dressing_room
 */

/**
 * Allow user to view dressing room page.
 *
 * If node is a product display type and there are two or more images.
 *
 * @param object $node
 *   Node object.
 *
 * @return bool
 *   Return TRUE or FALSE.
 */
function commerce_dressing_room_restriction_access($node) {
  $result = FALSE;

  $bundles = commerce_dressing_room_get_bundles_with_product_reference_field('node');
  foreach ($bundles['node'] as $bundle_list) {
    // $node is a product display.
    if (in_array($node->type, $bundle_list)) {
      $images_without_bg = commerce_dressing_room_get_image_without_background($node);
      // There are two or more images.
      if (!empty($images_without_bg)) {
        $result = TRUE;
      }
    }
  }

  return $result;
}

/**
 * Implements hook_menu().
 */
function commerce_dressing_room_menu() {
  // Page with virtual dressing room.
  $items['commerce_dressing_room/%node'] = array(
    'title' => 'Commerce dressing room',
    'description' => 'Page with virtual dressing room.',
    'page callback' => 'commerce_dressing_room_page',
    'page arguments' => array(1),
    'access callback' => 'commerce_dressing_room_restriction_access',
    'access arguments' => array(1),
    'file' => 'commerce_dressing_room.page.inc',
  );

  return $items;
}

/**
 * Implements hook_theme().
 */
function commerce_dressing_room_theme($existing, $type, $theme, $path) {
  global $base_url;
  return array(
    'commerce_dressing_room' => array(
      'path' => $path . '/theme',
      'template' => 'commerce-dressing-room',
      'variables' => array(
        'cdr_path' => $base_url . '/' . drupal_get_path('module', 'commerce_dressing_room'),
      ),
    ),
  );
}

/**
 * Ensures fields and field instances exist.
 */
function commerce_dressing_room_add_fields() {
  $fields = field_info_fields();
  $field_types = field_info_field_types();

  // Clear the field cache if the entityreference type field is not found.
  if (!$field_types['entityreference']) {
    field_cache_clear();
  }

  if (empty($fields['cdr_image_without_gb'])) {
    // Create a commerce_order_reference field in order to do a relationship
    // between a return and its order.
    $field = array(
      'active' => 1,
      'cardinality' => 1,
      'deleted' => 0,
      'entity_types' => array(),
      'field_name' => 'cdr_image_without_gb',
      'foreign keys' => array(
        'fid' => array(
          'columns' => array(
            'fid' => 'fid',
          ),
          'table' => 'file_managed',
        ),
      ),
      'indexes' => array(
        'fid' => array(
          0 => 'fid',
        ),
      ),
      'locked' => 0,
      'module' => 'image',
      'settings' => array(
        'default_image' => 0,
        'uri_scheme' => 'public',
      ),
      'translatable' => 0,
      'type' => 'image',
    );
    field_create_field($field);
  }

  commerce_dressing_room_field_instance('commerce_product');
}

/**
 * Create field instance.
 *
 * @param string $entity_type
 *   Entity type.
 * @param array $bundles_restrictive_list
 *   Array of bundles (restrictive list).
 */
function commerce_dressing_room_field_instance($entity_type, $bundles_restrictive_list = array()) {
  $instances = field_info_instances();

  $bundles = entity_get_info($entity_type);
  $bundles = $bundles['bundles'];

  if (!empty($bundles)) {
    // Add the cdr_image_without_gb field to all these bundles.
    foreach ($bundles as $bundle => $values) {
      if ((empty($bundles_restrictive_list) || _commerce_dressing_room_bundle_name_is_in_restrictive_list($entity_type, $bundle, $bundles_restrictive_list))
        && empty($instances[$entity_type][$bundle]['cdr_image_without_gb'])
      ) {
        $instance = array(
          'bundle' => $bundle,
          'deleted' => 0,
          'description' => '',
          'display' => array(
            'compare_page' => array(
              'label' => 'above',
              'settings' => array(),
              'type' => 'hidden',
              'weight' => 0,
            ),
            'default' => array(
              'label' => 'above',
              'module' => 'image',
              'settings' => array(
                'image_link' => '',
                'image_style' => '',
              ),
              'type' => 'image',
              'weight' => 2,
            ),
            'line_item' => array(
              'label' => 'above',
              'settings' => array(),
              'type' => 'hidden',
              'weight' => 0,
            ),
            'node_teaser' => array(
              'label' => 'above',
              'settings' => array(),
              'type' => 'hidden',
              'weight' => 0,
            ),
          ),
          'entity_type' => $entity_type,
          'field_name' => 'cdr_image_without_gb',
          'label' => 'Commerce dressing room image',
          'required' => 0,
          'settings' => array(
            'alt_field' => 0,
            'default_image' => 0,
            'file_directory' => '',
            'file_extensions' => 'png gif jpg jpeg',
            'max_filesize' => '',
            'max_resolution' => '',
            'min_resolution' => '',
            'title_field' => 0,
            'user_register_form' => FALSE,
          ),
          'widget' => array(
            'active' => 1,
            'module' => 'image',
            'settings' => array(
              'preview_image_style' => 'thumbnail',
              'progress_indicator' => 'throbber',
            ),
            'type' => 'image_image',
            'weight' => 37,
          ),
        );
        field_create_instance($instance);
      }
    }
  }
}

/**
 * Return TRUE if $bundle_name exist in $bundles_restrictive_list.
 *
 * @param string $entity_type
 *   Entity type.
 * @param string $bundle_name
 *   Bundle name.
 * @param array $bundles_restrictive_list
 *   List with bundles (Each bundle have product reference field).
 *
 * @return bool
 *   Return TRUE if $bundle_name exist in $bundles_restrictive_list else FALSE.
 */
function _commerce_dressing_room_bundle_name_is_in_restrictive_list($entity_type, $bundle_name, $bundles_restrictive_list) {
  $result = FALSE;

  if (!empty($bundles_restrictive_list[$entity_type])) {
    // For each field.
    foreach ($bundles_restrictive_list[$entity_type] as $bundles_list) {
      if (in_array($bundle_name, $bundles_list)) {
        $result = TRUE;
      }
    }
  }

  return $result;
}

/**
 * Implements hook_field_extra_fields().
 */
function commerce_dressing_room_field_extra_fields() {
  // Get bundles of commerce_product entity.
  $bundles = commerce_dressing_room_get_bundles_with_product_reference_field('node');

  $extra = array();
  // Add the commerce_dressing_room extra field to all these bundles.
  foreach ($bundles['node'] as $bundle_list) {
    foreach ($bundle_list as $bundle) {
      $extra['node'][$bundle]['display'] = array(
        'commerce_dressing_room' => array(
          'label' => t('Use virtual dressing room'),
          'description' => t('Displays a button to virtual dressing room page'),
          'weight' => 10,
        ),
      );
    }
  }
  return $extra;
}

/**
 * Return an array with bundles_name of a specific entity_type.
 *
 * @param string $entity_name
 *   Entity type.
 *
 * @return array
 *   Array with bundles_name.
 */
function commerce_dressing_room_get_bundles_with_product_reference_field($entity_name) {
  $fields = field_info_fields();
  $result = array();

  foreach ($fields as $field_name => $field) {
    if ($field['type'] == 'commerce_product_reference') {
      if (!empty($field['bundles'][$entity_name])) {
        $bundles = $field['bundles'][$entity_name];
        if ((!empty($bundles)) && (empty($result[$entity_name][$field_name]))) {
          $result[$entity_name][$field_name] = $bundles;
        }
      }
    }
  }

  return $result;
}

/**
 * Implements hook_node_view().
 */
function commerce_dressing_room_node_view($node, $view_mode, $langcode) {
  // Get bundles of commerce_product entity.
  $bundles = commerce_dressing_room_get_bundles_with_product_reference_field('node');
  foreach ($bundles['node'] as $bundle_list) {
    if ((in_array($node->type, $bundle_list))
      && commerce_dressing_room_restriction_access($node)
    ) {
      $node->content['commerce_dressing_room'] = drupal_get_form('commerce_dressing_room_form', $node);
    }
  }
}

/**
 * Form with submit button which redirects to dressing room page.
 *
 * @param array $form
 *   Array to build the form.
 * @param array $form_state
 *   Current state of the form.
 * @param object $node
 *   Node object.
 *
 * @return mixed
 *   Form to build.
 */
function commerce_dressing_room_form($form, &$form_state, $node) {
  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Open virtual dressing room',
  );
  return $form;
}

/**
 * Form submit: redirects to dressing room page.
 *
 * @param array $form
 *   Array to build the form.
 * @param array $form_state
 *   Current state of the form.
 */
function commerce_dressing_room_form_submit($form, &$form_state) {
  $nid = $form_state['build_info']['args'][0]->nid;
  $form_state['redirect'] = 'commerce_dressing_room/' . $nid;
}

/**
 * Get all images from cdr_image_without_gb (product) field for specific node.
 *
 * @param object $node
 *   Node object.
 *
 * @return bool|string
 *   Return html with images or FALSE.
 */
function commerce_dressing_room_get_image_without_background($node) {
  $count_image_without_bg = 0;
  $images_without_background = '';

  $node_wrapper = entity_metadata_wrapper('node', $node);
  // Get bundles of commerce_product entity.
  $bundles = commerce_dressing_room_get_bundles_with_product_reference_field('node');
  $field_product_reference = array_shift(array_keys($bundles['node']));

  if (!empty($node_wrapper->$field_product_reference)) {
    $products = $node_wrapper->$field_product_reference->value();

    foreach ($products as $product) {
      if (!empty($product->cdr_image_without_gb)) {
        $count_image_without_bg++;

        $uri = $product->cdr_image_without_gb[LANGUAGE_NONE][0]['uri'];
        $width = $product->cdr_image_without_gb[LANGUAGE_NONE][0]['width'];
        $height = $product->cdr_image_without_gb[LANGUAGE_NONE][0]['height'];
        $alt = $product->cdr_image_without_gb[LANGUAGE_NONE][0]['alt'];
        $title = $product->cdr_image_without_gb[LANGUAGE_NONE][0]['title'];

        $image = array(
          'style_name' => 'large',
          'path' => $uri,
          'width' => $width,
          'height' => $height,
          'alt' => $alt,
          'title' => $title,
          'attributes' => array('class' => array('cdr_product_id_' . $product->product_id)),
        );
        $images_without_background .=
          '<li>'
          . theme('image_style', $image)
          . '<p class="button-in-li">'
          . l(t('Buy this product'), 'node/' . $node->nid, array(
            'query' => array('id' => $product->product_id),
            'attributes' => array('class' => array('button')),
          ))
          . '</p></li>';
      }
    }
  }

  return ($count_image_without_bg > 1) ? $images_without_background : FALSE;
}

/**
 * Implements hook_image_default_styles().
 */
function commerce_dressing_room_image_default_styles() {
  $styles = array();

  // Exported image style: commerce_dressing_room.
  $styles['commerce_dressing_room_image_style'] = array(
    'name' => 'commerce_dressing_room_image_style',
    'effects' => array(
      3 => array(
        'label' => 'Scale and crop',
        'help' => 'Scale and crop will maintain the aspect-ratio of the original image, then crop the larger dimension. This is most useful for creating perfectly square thumbnails without stretching the image.',
        'effect callback' => 'image_scale_and_crop_effect',
        'dimensions callback' => 'image_resize_dimensions',
        'form callback' => 'image_resize_form',
        'summary theme' => 'image_resize_summary',
        'module' => 'image',
        'name' => 'image_scale_and_crop',
        'data' => array(
          'width' => 320,
          'height' => 330,
        ),
        'weight' => 1,
      ),
    ),
  );

  return $styles;
}
