<?php

/**
 * @file
 * The 'Just Redirect' module remembers old/deleted url aliases and redirects
 * them to the source. It also offers a way to set static 301 redirects.
 *
 * @author Bas van Meurs
 * @copyright Cipix Internet
 */

/**
 * Implements hook_page_delivery_callback_alter().
 *
 * @note We basically abuse this hook because it gets invoked on the right
 * moment: just before sending the headers!
 */
function just_redirect_page_delivery_callback_alter(&$callback) {
  // Check if a 404 is just about to happen.
  $menu_item = menu_get_item();
  if (empty($menu_item)) {
    global $language_url;

    // Check if the URL is known as a 301 redirect.
    $redirects = just_redirect_get_redirects();
    $absolute_url = "http" . (($_SERVER['SERVER_PORT'] == 443) ? "s://" : "://") . $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI'];
    $relative_url = $_SERVER['REQUEST_URI'];
    $target_url = NULL;
    if (array_key_exists($absolute_url, $redirects)) {
      // Absolute url redirect has preference over relative url.
      $target_url = $redirects[$absolute_url];
    } else if (array_key_exists($relative_url, $redirects)) {
      $target_url = $redirects[$relative_url];
    }
    if ($target_url) {
      // Redirect to the specified url.
      header('Location: ' . $target_url, TRUE, 301);
      drupal_exit();
    }

    // Check in the old_url_alias table if the current path is supported.
    $source = db_select('old_url_alias', 'a')
      ->fields('a', array('source'))
      ->condition('alias', $_GET['q'])
      ->condition('language', array($language_url->language, LANGUAGE_NONE))
      ->execute()
      ->fetchField();
    if (!empty($source)) {
      // An old url alias was found. Check if the original source path really
      // exists.
      $source_menu_item = menu_get_item($source);
      if (!empty($source_menu_item)) {
        // The original source does exist. Redirect to it!
        drupal_goto($source);
      }
    }
  }
}

/**
 * Stores the old url alias.
 *
 * @param array $path
 *   An Drupal core alias.
 */
function just_redirect_store_old_url_alias($path) {
  if (empty($path['alias'])) {
    return;
  }

  // Save the deleted path to the old_url_alias table. If another entry for the
  // same alias,language already exists, then overwrite that one.
  $fields = array(
    'alias' => $path['alias'],
    'language' => $path['language'],
    'source' => $path['source'],
  );

  $exists = db_select('old_url_alias', 'a')
    ->fields('a', array('alias'))
    ->condition('alias', $path['alias'])
    ->condition('language', $path['language'])
    ->execute()
    ->rowCount();
  if ($exists) {
    drupal_write_record('old_url_alias', $fields, array('alias', 'language'));
  }
  else {
    drupal_write_record('old_url_alias', $fields);
  }
}

/**
 * Implements hook_path_delete().
 */
function just_redirect_path_delete($path) {
  // Store the old url alias. This may seem unnecessary as the original path may
  // also be deleted, but this is not always the case and we can't be sure at
  // this point (@see path_node_update). The performance / storage penalty is
  // very low anyway.
  just_redirect_store_old_url_alias($path);
}

/**
 * Implements hook_path_update().
 */
function just_redirect_path_update($path) {
  // On update, the previous path is basically deleted. So we perform the same
  // action as on a 'pure' path delete.
  just_redirect_store_old_url_alias($path['original']);
}

/**
 * Implements hook_permission().
 */
function just_redirect_permission() {
  return array(
    'administer 301 redirects' =>  array(
      'title' => t('Administer 301 redirects'),
      'description' => t('Manage the 301 redirects.'),
    ),
  );
}

/**
 * Implements hook_menu().
 */
function just_redirect_menu() {
  $items['admin/config/system/301-redirects'] = array(
    'title' => '301 Redirects',
    'description' => t('Specify the 301 Redirects.'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('just_redirect_301_redirects'),
    'access arguments' => array('administer 301 redirects'),
    'type' => MENU_NORMAL_ITEM,
  );

  return $items;
}

/**
 * Returns the 301 redirects that are currently active.
 * @return array
 *   A hashmap from source to target.
 */
function just_redirect_get_redirects() {
  return variable_get('just_redirect_301_redirects', array());
}

/**
 * 301 redirects form.
 */
function just_redirect_301_redirects($form, &$form_state) {
  $redirects = just_redirect_get_redirects();

  // Combine current redirects.
  $redirects = just_redirect_get_redirects();
  $lines = array();
  foreach ($redirects as $source => $target) {
    $lines[] = $source . "|" . $target;
  }
  $combined = implode("\n", $lines);

  $form['redirects'] = array(
    '#type' => 'textarea',
    '#title' => t('301 Redirects'),
    '#description' => t('Format: {source-uri}|{target-uri}. You may use absolute and relative urls for source and/or target, but make sure to use proper encoding. Relative urls must start with a foreward slash. Omit query and hash tag. Example: /test-1|/test-2.'),
    '#default_value' => $combined,
    '#cols' => 60,
    '#rows' => 25,
    '#required' => FALSE,
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
    '#attributes' => array(),
  );

  return $form;
}

/**
 * 301 redirect form validation.
 */
function just_redirect_301_redirects_validate($form, &$form_state) {

  $redirects = array();

  // Strip windows-style carriage returns.
  $combined = $form_state['values']['redirects'];
  $combined = str_replace("\r", "", $combined);

  $errors = array();
  if (!empty($combined)) {
    // Split into lines.
    $lines = explode("\n", $combined);
    $index = 0;
    foreach ($lines as $line) {
      $index++;
      if (!empty($line)) {
        $components = explode('|', $line);
        if (count($components) != 2) {
          $errors[] = t('Expecting exactly 1 (one) occurrence of the pipe ( | ) character on line %line.', array('%line' => $index));
        } else {
          $redirects[$components[0]] = $components[1];

          if (!_just_redirect_valid_url($components[0])) {
            $errors[] = t('Source URL is invalid on line %line. Please use proper encoding.', array('%line' => $index));
          }

          if (!_just_redirect_valid_url($components[1])) {
            $errors[] = t('Target URL is invalid on line %line. Please use proper encoding.', array('%line' => $index));
          }
        }
      }
    }
  }

  if (!empty($errors)) {
    form_set_error('redirects', implode("\n", $errors));
  } else {
    $form_state['storage']['redirects'] = $redirects;
  }
}

/**
 * Returns TRUE if the specified url is a correct url.
 * An url is found to be correct if:
 *  - it starts with a forward slash and is relative
 *  - it is a valid absolute url
 * @param $url
 * @return boolean
 */
function _just_redirect_valid_url($url) {
  if ($url[0] == '/') {
    // Relative.
    return valid_url($url, FALSE);
  } else {
    // Absolute.
    return valid_url($url, TRUE);
  }
}

/**
 * 301 redirect form submit.
 */
function just_redirect_301_redirects_submit($form, &$form_state) {
  variable_set('just_redirect_301_redirects', $form_state['storage']['redirects']);
  drupal_set_message(t('Saved 301 redirects.'), 'status');
}
