<?php

/**
 * @file brick.module
 *
 * This module provides blocks that are made from ctools content.
 */

/**
 * Implementation of hook_permission().
 */
function brick_permission() {
  return array(
    'create brick' => array(
      'title' => t('Create brick'),
      'description' => t('Create new brick'),
    ),
    'administer brick' => array(
      'title' => t('Administer brick'),
      'description' => t('Edit and delete brick'),
    ),
  );
}

/**
 * Implementation of hook_block_list().
 */
function brick_block_info() {
  $blocks = array();

  ctools_include('export');
  $bricks = ctools_export_load_object('brick');
  foreach ($bricks as $brick) {
    if (empty($brick->disabled)) {
      $args = array('@category' => $brick->category, '@title' => $brick->admin_title);
      $blocks[$brick->name] = array(
        'info' => t('@category: "@title"', $args),
        'cache' => $brick->cache,
      );
    }
  }

  return $blocks;
}

/**
 * Implementation of hook_block_view().
 */
function brick_block_view($delta = 0) {
  ctools_include('export');
  ctools_include('context');
  ctools_include('content');

  $brick = ctools_export_crud_load('brick', $delta);
  $block = array();

  if (empty($brick)) {
    // Bail out early if the specified brick doesn't exist.
    return $block;
  }

  // When a task handler runs successfully, contexts and other useful things
  // are stored through page_manager_get_current_page() in
  // ctools_context_handler_render_handler().
  if ($page = page_manager_get_current_page()) {
    $contexts = $page['contexts'];
  }
  else {

    // If the task is enabled but no task handlers could be selected, contexts
    // are stashed when brick's implementation of hook_page_manager_override()
    // is invoked by the task's render function itself. Don't get the reference,
    // because this value will be modified.
    $contexts = drupal_static('brick_context', array());
  }

  // Compare contexts with required and remove mismatches.
  foreach ($brick->requiredcontexts as &$required) {
    foreach ($contexts as $id => $context) {
      if (!$context->is_type($required['name'])) {
        unset($contexts[$id]);
      }
    }
  }

  // Those contexts may match required contexts of these bricks.
  // TODO: Investigate mismatch of required contexts and arguments.
  // see http://api.lullabot.com/ctools_context_match_required_contexts/7
  if (!empty($contexts)) {
    $contexts = ctools_context_match_required_contexts($brick->requiredcontexts, $contexts);
  }

  // Load remaining contexts -- relationships and normal type.
  $brick->context = ctools_context_load_contexts($brick, FALSE, $contexts);

  if (ctools_access($brick->access, $brick->context)) {

    // Stash page title because ctools can render content that changes the page
    // title. For example, contact forms will change the page title.
    $page_title = drupal_get_title();
    $output = ctools_content_render($brick->content_type, $brick->subtype, $brick->conf, array(), array(), $brick->context);
    drupal_set_title($page_title, PASS_THROUGH);

    if ($output && !empty($output->content)) {
      $block['subject'] = isset($output->title) ? $output->title : NULL;
      if (is_array($output->content)) {
        $block['content'] = $output->content;
      }
      else {
        $block['content'] = array(
          '#markup' => $output->content,
        );
      }
      $block['content']['#contextual_links']['brick'] = array('admin/structure/brick/list', array($delta));
    }
  }

  return $block;
}

/**
 * Implementation of hook_block_configure().
 */
function brick_block_configure($delta = 0) {
  ctools_include('context');
  ctools_include('content');
  ctools_include('export');

  $form = array();
  $brick = ctools_export_crud_load('brick', $delta);
  if ($brick) {
    $brick->context = ctools_context_load_contexts($brick);

    $title = ctools_content_admin_title($brick->content_type, $brick->subtype, $brick->conf, $brick->context);
    $form['brick'] = array(
      '#type' => 'fieldset',
      '#title' => 'Brick',
      '#description' => $title,
    );

    $block = ctools_content_admin_info($brick->content_type, $brick->subtype, $brick->conf, $brick->context);
    if (!$block->title) {
      $block->title = t('No title');
    }
    $output = '<div class="pane-title">' . $block->title . '</div>';
    $output .= '<div class="pane-content">' . filter_xss_admin(render($block->content)) . '</div>';
    $form['brick']['info'] = array(
      '#markup' => $output,
    );

    $form['brick']['shortcut'] = array(
      '#prefix' => '<div>',
      '#markup' => l(t('Edit brick content'), 'admin/structure/brick/list/' . $delta . '/edit/content_type', array('query' => drupal_get_destination())),
      '#suffix' => '</div>',
    );
  }
  return $form;
}

/**
 * Implementation of hook_form_FORM_ID_alter().
 *
 * Hide the visibility settings for brick because ctools contexts are superior
 * and would be overridden by block visibility settings.
 */
function brick_form_block_admin_configure_alter(&$form, &$form_state) {
  if ($form_state['build_info']['args'][0] == 'brick') {
    $delta = $form_state['build_info']['args'][1];
    $form['visibility']['#access'] = FALSE;

    // Per-user visibility of blocks is not supported by ctools, so preserve it.
    $element = array(
      '#collapsible' => FALSE,
      '#collapsed' => FALSE,
      '#group' => NULL,
    );
    $form['visibility_user'] = array_merge($form['visibility']['user'], $element);
    unset($form['visibility']['user']);

    // Explain where visibility settings should be configured.
    $form['visibility_title']['#markup'] = l(t('Edit visibility rules'), 'admin/structure/brick/list/' . $delta . '/edit/rules', array('query' => drupal_get_destination()));
    $form['visibility_title']['#description'] = t('Visibility rules are part of the settings for the brick.');
  }
}

/**
 * Remove a mini panel.
 */
function brick_delete($brick) {
  db_delete('brick')
    ->condition('name', $brick->name)
    ->execute();

  if ($brick->type != t('Overridden')) {
    // Also remove from block table as long as there isn't a default that may
    // appear.
    db_delete('block')
      ->condition('delta', $brick->name)
      ->condition('module', 'brick')
      ->execute();
  }
}

/**
 * Submit handler for all brick to copy content type conf form into item.
 */
function brick_conf_submit(&$form, &$form_state) {

  // Set item configuration with reference because later submit handlers will
  // continue to modify $form_state['conf'].
  $form_state['item']->conf = &$form_state['conf'];
}

/**
 * Implementation of hook_ctools_plugin_directory() to let the system know
 * we implement task and task_handler plugins.
 */
function brick_ctools_plugin_directory($module, $plugin) {
  if (($module == 'ctools' && $plugin == 'export_ui') || ($module == 'page_manager' && $plugin == 'task_handlers')) {
    return 'plugins/' . $plugin;
  }
}

/**
 * Prevent all of this module's blocks from being available content types.
 */
function brick_ctools_block_info($module, $delta, &$info) {
  $info = NULL;
}

/**
 * Title callback for edit contextual links.
 */
function brick_menu_title($brick) {
  $args = array('@category' => $brick->category, '@title' => $brick->admin_title);
  return t('Edit @category: "@title"', $args);
}

/**
 * Implementation of hook_page_manager_override().
 *
 * This function captures the context from the page manager task. It does not
 * actually override the page manager handler, so this should have no impact.
 */
function brick_page_manager_override($task) {

  // Globalize the contexts so hook_block_view can have a look at them.
  drupal_static('brick_context', array(), TRUE);
  $contexts = &drupal_static('brick_context', array());

  // The plugin knows how to convert URL arguments into contexts.
  $plugin = page_manager_get_task($task);

  $item = menu_get_item();
  $args = $item['page_arguments'];

  switch ($task) {
    case 'search':
      // We have to remove the search type.
      array_shift($args);

      // And implode() it all back together.
      $keys = $args ? implode('/', $args) : '';
      $args = array($keys);
      break;

    case 'contact_user':
      // The first argument is the form ID of the user contact form.
      array_shift($args);
      break;

    default:
      // For most tasks, the page arguments feed directly to argument contexts.
      break;
  }

  // Load the contexts. ctools context was already loded in page manager.
  // TODO: Support keywords. Probably arguments should be passed in from menu
  // $item['map'].
  $contexts += ctools_context_handler_get_task_contexts($plugin, '', $args);

  // This override doesn't actually override the tasks' render function.
  return FALSE;
}
