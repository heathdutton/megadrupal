<?php
/**
 * Add rdf/html/xhtml-vocab rel="next" sort of meta tags describing menu
 * navigation when displaying nodes.
 *
 * Inserts rel links pointing up, down and sideways to give semantic scrapers
 * clues about the site structure.
 *
 * Refer to
 * http://www.w3.org/2011/rdfa-context/xhtml-rdfa-1.1
 *
 * This has no UI. Just enable it and you'll see some new (invisible) tags turn
 * up in node elements when the HTML is rendered. (full view & teaser)
 *
 * Each of the links can be toggled by setting Drupal variables
 * 'rel_links_up', 'rel_links_down', 'rel_links_next' (no UI for this)
 *
 * Links down to a nodes children are represented by rel='subsection'.
 *
 * Following RDFa style metadata annotations, the links are embedded within the
 * node elements themselves, and thus refer to the node content (not the page).
 * This is evident in teaser lists, where multiple nodes have multiple
 * relationships. RDFa Parsers are able to identify the correct relationships
 * from structural context.
 *
 * TODO - review performance. This invokes an extra menu-load in a few places
 * so if that's not cached already it may work a little harder than before.
 *
 * TODO - should this info (also) be added when rendering actual menu links?
 *
 * @author dman 2012 http://coders.co.nz/
 * Based on a request from 2005! http://drupal.org/node/35153
 */

/**
 * Add rel links to nodes when they are being displayed.
 *
 * These insertions go into node view displays (even teasers)
 * not the HTML HEAD as common, so that even
 * when listed out of context - their actual context can be deduced by
 * RDFa-scraping (eg with ARC2 parser)
 *
 * @param object $node
 * @param string $view_mode
 * @param string $langcode
 */
function rel_links_node_view($node, $view_mode, $langcode) {
  // An item may occur in more than one place in the menu, Deal with all.
  $links = rel_links_multiple_node_menu_load($node);

  foreach ($links as $link) {

    if (variable_get('rel_links_up', 'TRUE')) {
      // Find the menu parent(s) of this node if any.
      if ($parent_link_item = menu_link_load($link['plid'])) {
        // Add a rel='up' link tag to define that.
        $element = array(
          '#tag' => 'link',
          '#type' => 'html_tag',
          '#attributes' => array(
            'rel' => 'up',
            'href' => url($parent_link_item['link_path']),
            'title' => $parent_link_item['link_title'],
          ),
        );
        $node->content['menu_parent_link'][] = $element;
      }
    }

    if (variable_get('rel_links_down', 'TRUE')) {

      // Now make references to any children.
      foreach ((array)@$link['below'] as $child_item) {
        $child_link = $child_item['link'];
        $element = array(
          '#tag' => 'link',
          '#type' => 'html_tag',
          '#attributes' => array(
            // There is no reciprocal to 'up' in the xhtml vocab?
            // I'll use 'subsection to indicate menu children
            // Or is this where to use 'rev'?
            'rel' => 'subsection',
            'href' => url($child_link['link_path']),
            'title' => $child_link['link_title'],
          ),
        );
        $node->content['menu_child_link'][] = $element;
      }
    }

    if (variable_get('rel_links_next', 'TRUE')) {
      // For completion and HTML-spec (circa 1995 RFC 1866)
      // rel="next", rel="prev" may as well happen.
      // TODO does anyone really expect to use "first" and "last"?

      // So, get a list of siblings - aka parents children
      // and find my place among them.
      $parent_link = rel_links_menu_get_item($link['plid']);
      $siblings = (array)$parent_link['below'];

      // I'm going to assume those are sorted already.
      // So find before & after myself in that list.
      $prev = $next = $found = FALSE;
      foreach ($siblings as $sibling) {
        if ($sibling['link']['mlid'] == $link['mlid']) {
          // It's me!
          $found = TRUE;
        }
        if (!$found) {
          // The last one we looked at will be the previous.
          $prev = $sibling['link'];
        }
        if ($found && ! $next && ($sibling['link']['mlid'] != $link['mlid'])) {
          // The first one we find after me is the next.
          $next = $sibling['link'];
          break;
        }
      }
      // Now we should know the appropriate next and prev links.
      // Add them to the nodes render array if found.

      // Note, next and prev do NOT hop hierarchy like book nav does.
      // They remain in subsections and then stop at the end.

      // While it's unexpected and undefined if there are more than one 'next'
      // link in a navigation scheme - Drupal multi-parented menus make that
      // possible, and it's not illegal.
      // So we'll leave it to the agents to deal with.
      if ($prev) {
        $element = array(
          '#tag' => 'link',
          '#type' => 'html_tag',
          '#attributes' => array(
            'rel' => 'prev',
            'href' => url($prev['link_path']),
            'title' => $prev['link_title'],
          ),
        );
        $node->content['menu_prev_link'][] = $element;
      }
      if ($next) {
        $element = array(
          '#tag' => 'link',
          '#type' => 'html_tag',
          '#attributes' => array(
            'rel' => 'next',
            'href' => url($next['link_path']),
            'title' => $next['link_title'],
          ),
        );
        $node->content['menu_next_link'][] = $element;
      }
    }

  }
}


/**
 * Load all menu items associated with a node.
 *
 * Core API doesn't let us do that.
 * Stolen from multiple_node_menu.module
 *
 * Should not have to do this sort of stuff myself.
 *
 * @param $node
 *   The source path to look up.
 *
 * @return
 *   Array of paths or NULL if none found.
 */
function rel_links_multiple_node_menu_load($node) {
  $type_menus = variable_get('menu_options_' . $node->type, array('main-menu' => 'main-menu'));
  if (empty($type_menus)) {
    return NULL;
  }

  $links = db_select('menu_links')
  ->condition('module', 'menu')
  ->condition('router_path', 'node/%')
  ->condition('link_path', 'node/' . $node->nid)
  ->condition('menu_name', $type_menus, 'IN')
  ->fields('menu_links')
  ->execute()
  ->fetchAll(PDO::FETCH_ASSOC);

  foreach ($links as &$link) {
    $link = rel_links_menu_get_item($link['mlid']);
  }

  return $links;
}


/**
 * Wrapper around menu_link_load() that also loads the child items.
 *
 * menu.module does not provide a useful menu_get_item that loads children.
 * Huh?
 *
 * @param int mlid Menu link ID
 * @return Loaded menu item array, with 'below' items loaded on it.
 */
function rel_links_menu_get_item($mlid) {
  $item = menu_link_load($mlid);
  // Had to do extensive lookups here.
  // Based on the way submenutree does the same thing.
  $tree = menu_tree_all_data($item['menu_name'], $item);

  $my_tree = FALSE;
  $parent_tree = FALSE;
  list($key, $curr) = each($tree);
  while ($curr) {
    if ($curr['link']['href'] == $item['href']) {
      $my_tree = $curr['below'];
      $parent_tree = $tree;

      // Clear the children in the parent_tree if it is not an expanded menu item.
      if (empty($parent_tree[$key]['link']['expanded'])) {
        $parent_tree[$key]['below'] = array();
      }
      $curr = FALSE;
    }
    else {
      // Move to the child link if it's in the active trail.
      if ($curr['below'] && $curr['link']['in_active_trail']) {
        $tree = $curr['below'];
      }
      list($key, $curr) = each($tree);
    }
  }
  if ($my_tree) {
    $item['below'] = $my_tree;
  }
  return $item;
}
