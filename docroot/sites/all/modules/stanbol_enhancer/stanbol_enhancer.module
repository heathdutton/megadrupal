<?php

/**
 * @file
 * Module file for Stanbol Enhancer.
 */

define('STANBOL_ENHANCER_DEFAULT_STANBOL_ENDPOINT', 'stanbol_enhancer_default_stanbol_endpoint');

define('STANBOL_ENHANCER_FIELD_TYPE_LANGUAGE', 'LinguisticSystem');
define('STANBOL_ENHANCER_FIELD_TYPE_ORGANIZATION', 'Organisation');
define('STANBOL_ENHANCER_FIELD_TYPE_PERSON', 'Person');
define('STANBOL_ENHANCER_FIELD_TYPE_PLACE', 'Place');
define('STANBOL_ENHANCER_DEFAULT_MINIMUM_CONFIDENCE_LEVEL', 0.5);
define('STANBOL_ENHANCER_WATCHDOG_TYPE', 'stanbol_enhancer');
define('STANBOL_ENHANCER_QUEUE', 'stanbol_enhancer');
define('STANBOL_ENHANCER_ENHANCER_CURRENTLY_PROCESSED_ENTITY', 'stanbol_enhancer_queue_worker_currently_processed_entity');

/**
 * Implements hook_entity_info().
 */
function stanbol_enhancer_entity_info() {
  $return = [];

  $return['stanbol_enhancer'] = [
    'label' => t('Stanbol Enhancer'),
    'entity class' => 'Entity',
    'controller class' => 'EntityAPIControllerExportable',
    'label callback' => 'stanbol_enhancer_entity_label_callback',
    'load callback' => 'stanbol_enhancer_load',
    'base table' => 'stanbol_enhancer',
    'module' => 'stanbol_enhancer',
    'fieldable' => FALSE,
    'exportable' => TRUE,
    'entity keys' => [
      'id' => 'id',
    ],
  ];

  return $return;
}

/**
 * Return the label of the Stanbol Enhancer entity.
 *
 * @see callback_entity_info_label()
 */
function stanbol_enhancer_entity_label_callback($entity, $entity_type) {
  if ($assigned_entity = entity_get_info($entity->entity)) {
    if (isset($entity->bundle) && isset($assigned_entity['bundles'][$entity->bundle])) {
      return $assigned_entity['bundles'][$entity->bundle]['label'];
    }
    return $assigned_entity['label'];
  }

  return '';
}

/**
 * Load a Stanbol Enhancer entity based on its id.
 *
 * @param int $id
 *   Stanbol Enhancer id.
 *
 * @return mixed
 *   Return the Stanbol Enhancer entity if exists, else FALSE.
 */
function stanbol_enhancer_load($id) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'stanbol_enhancer');
  if ($id !== NULL) {
    $query->propertyCondition('id', $id);
    $query->range(0, 1);
    $result = $query->execute();
    if (!empty($result['stanbol_enhancer'])) {
      $entity = array_shift($result['stanbol_enhancer']);
      return entity_load_single('stanbol_enhancer', $entity->id);
    }
  }
  return FALSE;
}

/**
 * Load the Stanbol Enhancer entity which belongs to the this entity and bundle.
 *
 * @param string $entity_type
 *   Name of the entity type.
 * @param string $entity_bundle
 *   Filter to a bundle of this entity.
 *
 * @return mixed
 *   Return the Stanbol Enhancer entity if exists, else FALSE.
 */
function stanbol_enhancer_load_enhancer_of_entity($entity_type, $entity_bundle = NULL) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'stanbol_enhancer');
  $query->propertyCondition('entity', $entity_type);
  if (isset($entity_bundle)) {
    $query->propertyCondition('bundle', $entity_bundle);
  }
  $query->range(0, 1);
  $result = $query->execute();
  if (!empty($result['stanbol_enhancer'])) {
    $entity = array_shift($result['stanbol_enhancer']);
    return entity_load_single('stanbol_enhancer', $entity->id);
  }

  return FALSE;
}

/**
 * Save the Stanbol Enhancer entity, which belongs to this entity and bundle.
 *
 * Create or update a Stanbol Enhancer entity.
 *
 * @param string $entity
 *   The type of the entity.
 * @param string $bundle
 *   The bundle of the entity type.
 * @param array $settings
 *   Associative array of Stanbol Enhancer settings.
 *
 * @return bool|Entity
 *   SAVED_NEW or SAVED_UPDATED is returned depending on the operation
 *   performed successful, else FALSE.
 */
function stanbol_enhancer_save($entity, $bundle = NULL, array $settings) {
  if ($stanbol_enhancer = stanbol_enhancer_load_enhancer_of_entity($entity, $bundle)) {
    $stanbol_enhancer->settings = $settings;
    return entity_save('stanbol_enhancer', $stanbol_enhancer);
  }
  return entity_create('stanbol_enhancer', [
    'entity' => $entity,
    'bundle' => $bundle,
    'settings' => $settings,
  ])->save();
}

/**
 * Load multiple Stanbol Enhancer entities.
 *
 * @param array $ids
 *   Stanbol Enhancer ids.
 * @param array $conditions
 *   An associative array of EntityFieldQuery conditions.
 *
 * @return mixed
 *   An associative array of Stanbol Enhancer entities, or an empty array.
 */
function stanbol_enhancer_load_multiple(array $ids = [], array $conditions = []) {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'stanbol_enhancer');
  if (!empty($ids)) {
    $query->propertyCondition('id', $ids, 'IN');
  }
  if (!empty($conditions)) {
    foreach ($conditions as $prop_name => $prop_value) {
      $query->propertyCondition($prop_name, $prop_value);
    }
  }
  $result = $query->execute();
  if (!empty($result['stanbol_enhancer'])) {
    $entity_ids = array_keys($result['stanbol_enhancer']);
    return entity_load('stanbol_enhancer', $entity_ids);
  }

  return [];
}

/**
 * Implements hook_cron_queue_info().
 */
function stanbol_enhancer_cron_queue_info() {
  $queues = [];

  $queues[STANBOL_ENHANCER_QUEUE] = [
    'worker callback' => 'stanbol_enhancer_enhance_queue_worker',
    'time' => 15,
  ];

  return $queues;
}

/**
 * Queue worker callback for STANBOL_ENHANCER_QUEUE.
 *
 * @param array $entity_info
 *   An associative array which holds the following information:
 *   - entity_type: The type of the entity to process. (node, user, etc)
 *   - entity_id: The id of the entity.
 *
 * @throws \Exception
 *   If the entity could not be processed with the Apache Stanbol Enhancer for
 *   and encountered issue, then throw an exception to preserve this entity in
 *   the queue for later execution.
 */
function stanbol_enhancer_enhance_queue_worker(array $entity_info) {
  // Try to load the entity based on the entity type and the id.
  if ($entity = entity_load_single($entity_info['entity_type'], $entity_info['entity_id'])) {
    $entity_wrapper = entity_metadata_wrapper($entity_info['entity_type'], $entity);
    $bundle = NULL;
    if ($entity_bundle = $entity_wrapper->getBundle()) {
      $bundle = $entity_bundle;
    }
    // Try to load the associated Stanbol Enhancer of this entity and process
    // the entity with the enhancer.
    if ($stanbol_enhancer = stanbol_enhancer_load_enhancer_of_entity($entity_info['entity_type'], $bundle)) {
      if (!stanbol_enhancer_enhance_with_entity_wrapper($entity_wrapper, $stanbol_enhancer->settings)) {
        // We need to throw an exception the preserve this entity in the queue
        // for later execution.
        throw new Exception('Stanbol Enhancer was not able to enhance this entity.');
      }
    }
    else {
      watchdog(STANBOL_ENHANCER_WATCHDOG_TYPE, 'Queue worker: There is no Stanbol Enhancer belongs to this entity. (Probably which belongs to this one was deleted.) Type: @type ID: @id', [
        '@type' => $entity_info['entity_type'],
        '@id' => $entity_info['entity_id'],
      ], WATCHDOG_WARNING);
    }
  }
  else {
    watchdog(STANBOL_ENHANCER_WATCHDOG_TYPE, 'Queue worker: Entity can not be loaded! Type: @type ID: @id', [
      '@type' => $entity_info['entity_type'],
      '@id' => $entity_info['entity_id'],
    ], WATCHDOG_WARNING);
  }
}

/**
 * Add an entity to the STANBOL_ENHANCER_QUEUE.
 *
 * @param string $entity_type
 *   Type of the entity. Ex.: node, user, etc.
 * @param int $entity_id
 *   ID of the entity.
 */
function stanbol_enhancer_add_to_queue($entity_type, $entity_id) {
  $queue = DrupalQueue::get(STANBOL_ENHANCER_QUEUE);
  $queue->createItem([
    'entity_type' => $entity_type,
    'entity_id' => $entity_id,
  ]);
}

/**
 * Implements hook_entity_insert().
 */
function stanbol_enhancer_entity_insert($entity, $type) {
  stanbol_enhancer_enhance_entity($entity, $type);
}

/**
 * Implements hook_entity_update().
 */
function stanbol_enhancer_entity_update($entity, $type) {
  stanbol_enhancer_enhance_entity($entity, $type);
}

/**
 * Implements hook_entity_presave().
 */
function stanbol_enhancer_entity_presave($entity, $type) {
  $entity_wrapper = entity_metadata_wrapper($type, $entity);
  $enhancer_processed_entity = &drupal_static(STANBOL_ENHANCER_ENHANCER_CURRENTLY_PROCESSED_ENTITY, []);
  $saved_entity = [
    'entity_type' => $type,
    'bundle' => $entity_wrapper->getBundle(),
    'id' => $entity_wrapper->getIdentifier(),
  ];
  // To prevent errors on entity insert, we need to check here, if this
  // entity save was triggered by the
  // stanbol_enhancer_enhance_with_entity_wrapper() or not. If yes, then the
  // entity already exists, (since the hook_entity_insert() was called which
  // called the mentioned function,) so the is_new flag should be
  // removed from this entity.
  if ($enhancer_processed_entity === $saved_entity) {
    if ($entity_wrapper->getPropertyInfo('is_new')) {
      $entity->is_new = FALSE;
    }
  }
}

/**
 * Enhance and entity immediatelly or add it to the STANBOL_ENHANCER_QUEUE.
 *
 * @param object $entity
 *   Entity object.
 * @param string $type
 *   Type of the Entity.
 */
function stanbol_enhancer_enhance_entity($entity, $type) {
  $entity_wrapper = entity_metadata_wrapper($type, $entity);
  $bundle = NULL;
  if ($entity_bundle = $entity_wrapper->getBundle()) {
    $bundle = $entity_bundle;
  }
  if ($stanbol_enhancer = stanbol_enhancer_load_enhancer_of_entity($type, $bundle)) {
    // If the Stanbol Enhancer enabled.
    if ($stanbol_enhancer->settings['enabled']) {
      // If the stanbol_enhancer_enhance_with_entity_wrapper() (not directly)
      // called this function, then these two values are equals, which means
      // that we should not try to process this entity again with the
      // Stanbol Enhancer again, because it would cause an infinite loop.
      $enhancer_processed_entity = &drupal_static(STANBOL_ENHANCER_ENHANCER_CURRENTLY_PROCESSED_ENTITY, []);
      $saved_entity = [
        'entity_type' => $type,
        'bundle' => $entity_wrapper->getBundle(),
        'id' => $entity_wrapper->getIdentifier(),
      ];
      if ($enhancer_processed_entity !== $saved_entity) {
        if ($stanbol_enhancer->settings['process_immediately']) {
          stanbol_enhancer_enhance_with_entity_wrapper($entity_wrapper, $stanbol_enhancer->settings);
        }
        else {
          stanbol_enhancer_add_to_queue($type, $entity_wrapper->getIdentifier());
        }
      }
    }
  }
}

/**
 * Enhance the entity through an Entity Wrapper.
 *
 * @param \EntityMetadataWrapper $entity_wrapper
 *   Entity wrapper of the entity.
 * @param array $stanbol_enhancer_settings
 *   Settings from Stanbol Enhancer of the entity.
 *
 * @return bool
 *   Return TRUE on success, else FALSE.
 */
function stanbol_enhancer_enhance_with_entity_wrapper(EntityMetadataWrapper $entity_wrapper, array $stanbol_enhancer_settings) {
  if ($entity_wrapper->getPropertyInfo($stanbol_enhancer_settings['field_to_analyze'])) {
    $processors = stanbol_enhancer_result_processor_info();
    $enabled_processors = array_filter($stanbol_enhancer_settings['mapping'], function ($processor, $field) {
      return !empty($field);
    }, ARRAY_FILTER_USE_BOTH);
    $enabled_processors = array_intersect_key($processors, $enabled_processors);
    $config = [
      'endpoint' => variable_get(STANBOL_ENHANCER_DEFAULT_STANBOL_ENDPOINT, 'http://localhost:8080'),
      'minimum_confidence_level' => $stanbol_enhancer_settings['minimum_confidence_level'],
      'processors' => $enabled_processors,
    ];
    // Store the fact that this entity is currently processed by the Stanbol
    // Enhancer. We will use this fact to prevent us from infinitely
    // trying to save the same entity again and again. Without this,
    // the stanbol_enhancer_enhance_entity() would add the same item again
    // and again to the queue or try to process it, which would cause
    // infinite entity save loop on the same entity.
    $enhancer_processed_entity = &drupal_static(STANBOL_ENHANCER_ENHANCER_CURRENTLY_PROCESSED_ENTITY, []);
    $enhancer_processed_entity = [
      'entity_type' => $entity_wrapper->type(),
      'bundle' => $entity_wrapper->getBundle(),
      'id' => $entity_wrapper->getIdentifier(),
    ];
    $content = $entity_wrapper->{$stanbol_enhancer_settings['field_to_analyze']}->value();
    if (is_array($content) && isset($content['value'])) {
      $content = $content['value'];
    }
    if (!is_string($content)) {
      watchdog(STANBOL_ENHANCER_WATCHDOG_TYPE, 'Content can not be analyzed, because it is not a string! Content: <pre>@content</pre>', [
        '@content' => print_r($content, TRUE),
      ], WATCHDOG_WARNING);
      return FALSE;
    }
    if (is_array(($result = stanbol_enhancer_enhance_content($content, $config)))) {
      // Iterate throw the enabled result processors.
      foreach ($processors as $name => $processor) {
        if (!empty($result[$name])) {
          // Check, if the entity has the field which assigned to the
          // current processor.
          if ($field_prop = $entity_wrapper->getPropertyInfo($stanbol_enhancer_settings['mapping'][$name])) {
            // Check if the current processors's value callback exists.
            if (function_exists($processor['value callback'])) {
              $field_info = [];
              if (isset($field_prop['field']) && $field_prop['field']) {
                $field_info = field_info_field($stanbol_enhancer_settings['mapping'][$name]);
              }
              // Get the value from the value callback and set it on the field.
              $value = call_user_func($processor['value callback'], $result[$name], $field_info);
              // Validate the value, before setting it.
              if ($entity_wrapper->{$stanbol_enhancer_settings['mapping'][$name]}->validate($value)) {
                $entity_wrapper->{$stanbol_enhancer_settings['mapping'][$name]} = $value;
              }
              else {
                watchdog(STANBOL_ENHANCER_WATCHDOG_TYPE, "Returned value is invalid for the %field field, that is why, it can not be set! Returned value: <pre>@value</pre>", [
                  '%field' => $stanbol_enhancer_settings['mapping'][$name],
                  '@value' => print_r($value, TRUE),
                ], WATCHDOG_WARNING);
              }
            }
          }
          else {
            watchdog(STANBOL_ENHANCER_WATCHDOG_TYPE, "Selected %field field does not exists on the %entity %bundle entity anymore, that's why the returned data can not be saved.", [
              '%field' => $stanbol_enhancer_settings['mapping'][$name],
              '%entity' => $entity_wrapper->getBundle(),
              '%bundle' => isset($bundle) ? '(' . $bundle . ')' : '',
            ], WATCHDOG_WARNING);
          }
        }
      }
      $entity_wrapper->save();

      // Trigger the "Entity successfully enhanced" event, if the rules
      // sub-module is enabled.
      if (module_exists('stanbol_enhancer_rules')) {
        rules_invoke_event('stanbol_enhancer_entity_successfully_enhanced', $entity_wrapper->value());
      }

      return TRUE;
    }
    else {
      watchdog(STANBOL_ENHANCER_WATCHDOG_TYPE, 'Could not enhance the content of this entity, because of an issue with the Apache Stanbol Enhancer connection. Check the log for more details.', [], WATCHDOG_ERROR);
    }
  }
  else {
    watchdog(STANBOL_ENHANCER_WATCHDOG_TYPE, 'Selected %field field to analyze does not exists on the %entity %bundle anymore.', [
      '%field' => $stanbol_enhancer_settings['field_to_analyze'],
      '%entity' => $entity_wrapper->getBundle(),
      '%bundle' => isset($bundle) ? '(' . $bundle . ')' : '',
    ], WATCHDOG_ERROR);
  }

  // Trigger the "Entity enhancement failed" event, if the rules
  // sub-module is enabled.
  if (module_exists('stanbol_enhancer_rules')) {
    rules_invoke_event('stanbol_enhancer_entity_enhancement_failed', $entity_wrapper->value());
  }

  return FALSE;
}


/**
 * Analyze the content with the Apache Stanbol's Enhancer module.
 *
 * @param string $content
 *   Text to analyze with the Stanbol Enhancer.
 * @param array $config
 *   Associative array, which stores the Apache Stanbol connection informations
 *   and the enabled result processors with their settings.
 *
 * @return array|bool
 *   Array of processed result on success, else FALSE.
 */
function stanbol_enhancer_enhance_content($content, array $config) {
  if (!empty($config['endpoint'])) {
    $url = $config['endpoint'] . '/enhancer';
    $response = drupal_http_request($url, [
      'method' => 'POST',
      'data' => check_plain($content),
      'headers' => [
        'Accept' => 'application/json',
        'Content-type' => 'text/plain',
      ],
    ]);

    if ($response->code == 200) {
      $result = drupal_json_decode($response->data);
      return isset($result['@graph']) ? stanbol_enhancer_process_result($result['@graph'], $config) : [];
    }
    else {
      watchdog(STANBOL_ENHANCER_WATCHDOG_TYPE, 'Stanbol Enhancer returned with unexpected status code on the %endpoint endpoint. Details: <pre>@details</pre>', [
        '%endpoint' => $config['endpoint'],
        '@details' => print_r($response, TRUE),
      ],
        WATCHDOG_ERROR);
    }
  }
  else {
    watchdog(STANBOL_ENHANCER_WATCHDOG_TYPE, 'Stanbol endpoint url is not defined!', [], WATCHDOG_ERROR);
  }

  return FALSE;
}

/**
 * Implements hook_stanbol_enhancer_result_processor_info().
 */
function stanbol_enhancer_stanbol_enhancer_result_processor_info() {
  $processors = [];

  $processors['language'] = [
    'label' => t('Language'),
    'description' => t("Set the entity's language property to the detected language. Only works on those entities which have language attribute."),
    'type' => 'token',
    'conditions' => [
      'schema field' => 'language',
    ],
    'processor callback' => '_stanbol_enhancer_language_process_callback',
    'processor callback settings' => [
      'ignore confidence' => TRUE,
    ],
    'value callback' => '_stanbol_enhancer_language_value_callback',
  ];
  $processors['organizations_term'] = [
    'label' => t('Organizations'),
    'description' => t('Store the identified organizations in a taxonomy term field.'),
    'type' => 'list<taxonomy_term>',
    'group identifier' => STANBOL_ENHANCER_FIELD_TYPE_ORGANIZATION,
    'processor callback' => '_stanbol_enhancer_organizations_process_callback',
    'processor callback settings' => [
      'capitalize filter limit' => 4,
    ],
    'value callback' => '_stanbol_enhancer_term_reference_value_callback',
  ];
  $processors['people_term'] = [
    'label' => t('People'),
    'description' => t('Store the identified people in a taxonomy term field.'),
    'type' => 'list<taxonomy_term>',
    'group identifier' => STANBOL_ENHANCER_FIELD_TYPE_PERSON,
    'processor callback' => '_stanbol_enhancer_people_process_callback',
    'processor callback settings' => [
      'capitalize filter limit' => 4,
    ],
    'value callback' => '_stanbol_enhancer_term_reference_value_callback',
  ];
  $processors['places_geolocation'] = [
    'label' => t('Places'),
    'description' => t('Store the identified places in a <a href="@url">Geolocation</a> field.', ['@url' => url('http://drupal.org/project/geolocation', ['external' => TRUE])]),
    'type' => 'list<geolocation>',
    'group identifier' => STANBOL_ENHANCER_FIELD_TYPE_PLACE,
    'processor callback' => '_stanbol_enhancer_places_process_callback',
    'processor callback settings' => [
      'round digits' => 2,
    ],
    'value callback' => '_stanbol_enhancer_geolocation_value_callback',
  ];
  $processors['places_geofield'] = [
    'label' => t('Places'),
    'description' => t('Store the identified places in a <a href="@url">Geofield</a> field.', ['@url' => url('http://drupal.org/project/geofield', ['external' => TRUE])]),
    'type' => 'list<geofield>',
    'group identifier' => STANBOL_ENHANCER_FIELD_TYPE_PLACE,
    'processor callback' => '_stanbol_enhancer_places_process_callback',
    'processor callback settings' => [
      'round digits' => 2,
    ],
    'value callback' => '_stanbol_enhancer_geofield_value_callback',
  ];

  return $processors;
}

/**
 * Returns a list of all available Stanbol Enhancer's result processors.
 *
 * @return array
 *   An array of result processors.
 */
function stanbol_enhancer_result_processor_info() {
  $processors = &drupal_static(__FUNCTION__, []);

  if (empty($processors)) {
    foreach (module_implements('stanbol_enhancer_result_processor_info') as $module) {
      $info = module_invoke($module, 'stanbol_enhancer_result_processor_info');
      if (isset($info) && is_array($info)) {
        // Assign the name of the module that implementing the processor
        // and ensure some default values.
        foreach (array_keys($info) as $name) {
          $info[$name]['module'] = $module;
          $info[$name] += [
            'description' => '',
            'group identifier' => '',
            'conditions' => [],
            'processor callback settings' => [],
          ];
          $info[$name]['processor callback settings'] += ['ignore confidence' => FALSE];
        }
        $processors = array_merge($processors, $info);
      }
    }
    // Allow modules to alter filter definitions.
    drupal_alter('stanbol_enhancer_result_processor_info_alter', $processors);

    // Sort the processors based on their labels.
    uasort($processors, function ($a, $b) {
      return strcmp($a['label'], $b['label']);
    });
  }

  return $processors;
}

/**
 * Process the result, which returned by the Apache Stanbol Enhancer.
 *
 * @param array $result
 *   An associative array of result.
 * @param array $config
 *   Associative array of processor configuration settings.
 *
 * @return array
 *   Associative array of processed results, where the keys are the machine name
 *   of the processors, or an empty array.
 */
function stanbol_enhancer_process_result(array $result, array $config) {
  if (!empty($result)) {
    $result = _stanbol_enchancer_group_result_by_field_type($result);
    $processors = isset($config['processors']) ? $config['processors'] : [];
    $processed_result = [];

    // Call those processors which should be executed before the unsure
    // values will be removed from the results.
    array_walk($processors, function ($processor, $processor_name) use ($result, &$processed_result) {
      if ($processor['processor callback settings']['ignore confidence'] && function_exists($processor['processor callback'])) {
        if ($processor_result = call_user_func($processor['processor callback'], $result, $processor['processor callback settings'])) {
          $processed_result[$processor_name] = $processor_result;
        }
      }
    });

    // Ensure minimum confidence level is set.
    if (!isset($config['minimum_confidence_level'])) {
      $config['minimum_confidence_level'] = STANBOL_ENHANCER_DEFAULT_MINIMUM_CONFIDENCE_LEVEL;
      watchdog(STANBOL_ENHANCER_WATCHDOG_TYPE, 'Minimum confidence level was missing from the configuration, applying default minimum confidence level.', [], WATCHDOG_WARNING);
    }

    // Clean unsure values from the results based on the minimum confidence
    // level.
    $result = _stanbol_enchancer_clean_unsure_fields_from_result($result, $config['minimum_confidence_level']);

    // Call all processors callback again on the results.
    array_walk($processors, function ($processor, $processor_name) use ($result, &$processed_result) {
      if (!$processor['processor callback settings']['ignore confidence'] && function_exists($processor['processor callback'])) {
        if ($processor_result = call_user_func($processor['processor callback'], $result, $processor['processor callback settings'])) {
          $processed_result[$processor_name] = $processor_result;
        }
      }
    });

    return $processed_result;
  }

  return [];
}

/**
 * Returns the detected Language of the content.
 *
 * @param array $result
 *   Re-grouped result of the Stanbol Enhancer.
 * @param array $processor_settings
 *   Settings of the processor.
 *
 * @return string|bool
 *   The detected language's ISO2 code on success, else FALSE.
 */
function _stanbol_enhancer_language_process_callback(array $result, array $processor_settings) {
  if (!empty($result[STANBOL_ENHANCER_FIELD_TYPE_LANGUAGE])) {
    return _stanbol_enhancer_get_language($result[STANBOL_ENHANCER_FIELD_TYPE_LANGUAGE]);
  }

  return FALSE;
}

/**
 * Returns the detected Organizations from the content.
 *
 * @param array $result
 *   Re-grouped result of the Stanbol Enhancer.
 * @param array $processor_settings
 *   Settings of the processor.
 *
 * @return array|bool
 *   Array of detected organizations's names if any, else FALSE.
 */
function _stanbol_enhancer_organizations_process_callback(array $result, array $processor_settings) {
  if (!empty($result[STANBOL_ENHANCER_FIELD_TYPE_ORGANIZATION])) {
    // Ensure that the value exists.
    if (empty($processor_settings['capitalize filter limit'])) {
      $processor_settings['capitalize filter limit'] = 4;
    }
    return _stanbol_enhancer_get_organizations($result[STANBOL_ENHANCER_FIELD_TYPE_ORGANIZATION], $processor_settings['capitalize filter limit']);
  }

  return FALSE;
}

/**
 * Returns the detected People from the content.
 *
 * @param array $result
 *   Re-grouped result of the Stanbol Enhancer.
 * @param array $processor_settings
 *   Settings of the processor.
 *
 * @return array|bool
 *   Array of detected people's names if any, else FALSE.
 */
function _stanbol_enhancer_people_process_callback(array $result, array $processor_settings) {
  if (!empty($result[STANBOL_ENHANCER_FIELD_TYPE_PERSON])) {
    // Ensure that the value exists.
    if (empty($processor_settings['capitalize filter limit'])) {
      $processor_settings['capitalize filter limit'] = 4;
    }
    return _stanbol_enhancer_get_people($result[STANBOL_ENHANCER_FIELD_TYPE_PERSON], $processor_settings['capitalize filter limit']);
  }

  return FALSE;
}

/**
 * Returns the detected Places from the content.
 *
 * @param array $result
 *   Re-grouped result of the Stanbol Enhancer.
 * @param array $processor_settings
 *   Settings of the processor.
 *
 * @return array|bool
 *   Array of detected places's coordinates (lng/lat) if any, else FALSE.
 */
function _stanbol_enhancer_places_process_callback(array $result, array $processor_settings) {
  if (!empty($result[STANBOL_ENHANCER_FIELD_TYPE_PLACE])) {
    // Ensure that the value exists.
    if (empty($processor_settings['round digits'])) {
      $processor_settings['round digits'] = 2;
    }
    return _stanbol_enhancer_get_places($result[STANBOL_ENHANCER_FIELD_TYPE_PLACE], $processor_settings['round digits']);
  }

  return FALSE;
}

/**
 * Return the most probable language's ISO2 code of the analyzed content.
 *
 * @param array $languages
 *   Array of detected languages.
 *
 * @return string
 *   ISO2 code of the language.
 */
function _stanbol_enhancer_get_language(array $languages) {
  uasort($languages, '_stanbol_enchancer_sort_fields_by_confidence');
  $language = array_shift($languages);
  return $language['dc:language'];
}

/**
 * Returns the name of the (validated) Organizations.
 *
 * @param array $organizations
 *   Array of Organizations from the results.
 * @param int $capitalize_filter_limit
 *   In some cases the Stanbol returns false organization names.
 *   Example: Microsoft Windows.ASDDSA
 *   This filter is tries to remove this false values.
 *
 * @return array
 *   Array of the organization's names.
 */
function _stanbol_enhancer_get_organizations(array $organizations, $capitalize_filter_limit) {
  $organizations = _stanbol_enhancer_organization_and_people_name_filter($organizations, $capitalize_filter_limit);
  return array_values(array_unique($organizations));
}

/**
 * Returns the name of the (validated) People.
 *
 * @param array $people
 *   Array of People from the results.
 * @param int $capitalize_filter_limit
 *   In some cases the Stanbol returns false people names.
 *   Example: Brian Adams.ASDDSA
 *   This filter is tries to remove this false values.
 *
 * @return array
 *   Array of the people's names.
 */
function _stanbol_enhancer_get_people(array $people, $capitalize_filter_limit) {
  $people = _stanbol_enhancer_organization_and_people_name_filter($people, $capitalize_filter_limit);
  $people = array_unique($people);
  // Filter out those people from the list, whose names contains only one word
  // and the name occurs in the other names, which contains multiple words.
  $one_word_people = array_filter($people, function ($person) {
    return preg_match('/^[^\s]*$/', $person);
  });
  $non_one_word_people = array_diff($people, $one_word_people);
  $one_word_people = array_filter($one_word_people, function ($person) use ($non_one_word_people) {
    foreach ($non_one_word_people as $nperson) {
      if (strpos($nperson, $person) !== FALSE) {
        return FALSE;
      }
    }
    return TRUE;
  });
  $people = $one_word_people + $non_one_word_people;
  return array_values($people);
}

/**
 * Returns a filtered result of Organizations and People.
 *
 * @see _stanbol_enhancer_get_people()
 * @see _stanbol_enhancer_get_organizations()
 */
function _stanbol_enhancer_organization_and_people_name_filter(array $result, $capitalize_filter_limit) {
  // Filter out those organizations which name contains invalid characters.
  $invalid_regexp = "/^([0-9a-zA-Z]+[ '’-]*)+$/";
  $result = array_filter($result, function ($field) use ($invalid_regexp) {
    if (isset($field['enhancer:selected-text']['@value'])) {
      return preg_match($invalid_regexp, $field['enhancer:selected-text']['@value']);
    }
    elseif (isset($field['enhancer:entity-label']['@value'])) {
      return preg_match($invalid_regexp, $field['enhancer:entity-label']['@value']);
    }
    elseif (isset($field['selected-text']['@value'])) {
      return preg_match($invalid_regexp, $field['selected-text']['@value']);
    }
    return FALSE;
  });
  // Replace all-caps texts in the end of the strings after non-word
  // characters.
  $all_caps_regexp = '/([^a-zA-Z ])+([A-Z]{' . $capitalize_filter_limit . ',})+$/';
  return array_map(function ($field) use ($all_caps_regexp) {
    if (isset($field['enhancer:selected-text']['@value'])) {
      return preg_replace($all_caps_regexp, '', $field['enhancer:selected-text']['@value']);
    }
    elseif (isset($field['enhancer:entity-label']['@value'])) {
      return preg_replace($all_caps_regexp, '', $field['enhancer:entity-label']['@value']);
    }
    elseif (isset($field['selected-text']['@value'])) {
      return preg_replace($all_caps_regexp, '', $field['selected-text']['@value']);
    }
    return FALSE;
  }, $result);
}

/**
 * Return the coordinates of the detected Places.
 *
 * @param array $places
 *   Array of Places from the results.
 * @param int $round_digits
 *   To filter out those coordinates which points to the same places or very
 *   close places, we can specify the rounding precision, which should be
 *   applied on each coordinates to find the identical ones.
 *
 * @return array
 *   Array of coordinates (lng/lang).
 */
function _stanbol_enhancer_get_places(array $places, $round_digits) {
  $places = array_map(function ($field) {
    if (empty($field['geo:lat']) && empty($field['geo:long'])) {
      return FALSE;
    }
    $coordinates = [
      'lat' => _stanbol_enhancer_get_coordinates_average($field['geo:lat']),
      'lng' => _stanbol_enhancer_get_coordinates_average($field['geo:long']),
    ];
    return $coordinates;
  }, $places);
  $places = array_filter($places, 'is_array');

  // Filter out those coordinates which are too close to each other.
  $places_helper = array_map(function ($field) use ($round_digits) {
    return round($field['lat'], $round_digits) . ';' . round($field['lng'], $round_digits);
  }, $places);
  $places_helper = array_unique($places_helper);
  $places = array_intersect_key($places, $places_helper);

  return array_values($places);
}

/**
 * Helper function to get the geometric average of coordinates.
 *
 * @param array|double $coordinates
 *   Stanbol returned single coordinate or array.
 *
 * @return double
 *   Single coordinate.
 */
function _stanbol_enhancer_get_coordinates_average($coordinates) {
  if (is_array($coordinates)) {
    $coordinates = array_sum($coordinates) / count($coordinates);
  }

  return $coordinates;
}

/**
 * Group the raw result of the Stanbol Enhancer based on the enabled processors.
 *
 * @param array $result
 *   Raw result from the Apache Stanbol Enhancer.
 *
 * @return array
 *   Associative array, where the keys are the processors's group identifiers.
 *
 * @see stanbol_enhancer_stanbol_enhancer_result_processor_info()
 */
function _stanbol_enchancer_group_result_by_field_type(array $result) {
  $grouped_result = [];
  $processors = stanbol_enhancer_result_processor_info();

  array_walk($result, function ($field) use (&$grouped_result, $processors) {
    // By default, group the result based on the dc:type attribute.
    if (isset($field['dc:type'])) {
      $grouped_result[$field['dc:type']][] = $field;
    }
    // Group the results based on the enabled processors too.
    array_walk($processors, function ($processor) use (&$grouped_result, $field) {
      if (!empty($processor['group identifier'])) {
        if (_stanbol_enhancer_check_type_of_a_field_in_stanbol_results($processor['group identifier'], $field)) {
          $grouped_result[$processor['group identifier']][] = $field;
        }
      }
    });
  });

  return $grouped_result;
}

/**
 * Check if the given field type match for the field's type.
 *
 * Detecting type of a field (entity) amoung the Stanbol results isn't simple.
 * This information could be stored multiple places as you can see.
 *
 * @param string $field_type
 *   Type of the field we look for.
 * @param array $field
 *   A (entity) description field from Stanbol result.
 *
 * @return bool
 *   TRUE if the field type match, else FALSE.
 */
function _stanbol_enhancer_check_type_of_a_field_in_stanbol_results($field_type, array $field) {
  if (isset($field['type']) && $field['type'] == $field_type) {
    return TRUE;
  }
  if (isset($field['dc:type']) && strpos($field['dc:type'], $field_type) !== FALSE) {
    return TRUE;
  }
  if (isset($field['@type'])) {
    $matches = array_filter($field['@type'], function ($type) use ($field_type) {
      return strpos($type, $field_type) !== FALSE;
    });
    if (!empty($matches)) {
      return TRUE;
    }
  }
  if (isset($field['enhancer:entity-type'])) {
    $matches = array_filter($field['enhancer:entity-type'], function ($type) use ($field_type) {
      return strpos($type, $field_type) !== FALSE;
    });
    if (!empty($matches)) {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Filter out unsure values from the Stanbol Enhancer result.
 *
 * @param array $result
 *   Re-grouped result of the Stanbol Enhancer.
 * @param int $minimum_confidence_level
 *   Define the minimum confidence level.
 *
 * @return array
 *   Array of confident results.
 */
function _stanbol_enchancer_clean_unsure_fields_from_result(array $result, $minimum_confidence_level) {
  $confident_result = [];
  $field_types = array_keys($result);
  // It must be a float value.
  $minimum_confidence_level = (float) $minimum_confidence_level;

  array_walk($field_types, function ($field_type) use ($result, $minimum_confidence_level, &$confident_result) {
    $confident_result[$field_type] = array_filter($result[$field_type], function ($field) use ($minimum_confidence_level) {
      if (isset($field['enhancer:confidence'])) {
        return ($field['enhancer:confidence'] >= $minimum_confidence_level);
      }
      // If this field does not contain confidence level information,
      // then let it pass.
      return TRUE;
    });
  });

  return $confident_result;
}

/**
 * Function used by uasort to sort Stanbol Enhancer fields by confidence.
 */
function _stanbol_enchancer_sort_fields_by_confidence($field_a, $field_b) {
  $a_confidence = (is_array($field_a) && isset($field_a['confidence'])) ? $field_a['confidence'] : 0;
  $b_confidence = (is_array($field_b) && isset($field_b['confidence'])) ? $field_b['confidence'] : 0;
  if ($a_confidence == $b_confidence) {
    return 0;
  }
  return ($a_confidence < $b_confidence) ? -1 : 1;
}

/**
 * Value callback for the Language processor.
 *
 * @param string $language
 *   ISO2 code of the language.
 *
 * @return string
 *   ISO2 code of the language.
 */
function _stanbol_enhancer_language_value_callback($language) {
  return $language;
}

/**
 * Value callback for term. reference field.
 *
 * Value callback for those processors which stores their values on term.
 * reference field.
 *
 * @param array $term_names
 *   Name of the taxonomy terms.
 * @param array $field_info
 *   Info from the field which will store the values returned by the
 *   field_info_field().
 *
 * @return array|bool
 *   Array of taxonomy term reference field values, FALSE if the
 *   field type does not match.
 */
function _stanbol_enhancer_term_reference_value_callback(array $term_names, array $field_info) {
  // Ensure the field's type.
  if ($field_info['type'] !== 'taxonomy_term_reference') {
    return FALSE;
  }
  $vocabulary = $field_info['settings']['allowed_values'][0]['vocabulary'];
  // Check the field cardinality, limit the number of saved values based on it.
  if ($field_info['cardinality'] != '-1') {
    $term_names = array_slice($term_names, $field_info['cardinality']);
  }
  return array_map(function ($term_name) use ($vocabulary) {
    $term = taxonomy_get_term_by_name($term_name, $vocabulary);

    // If the term does not exists on the vocabulary, create it.
    if (!$term) {
      $vocabulary = taxonomy_vocabulary_machine_name_load($vocabulary);
      $term = new stdClass();
      $term->vid = $vocabulary->vid;
      $term->name = $term_name;
      taxonomy_term_save($term);
    }

    $term = is_array($term) ? array_shift($term) : $term;
    return $term->tid;
  }, $term_names);
}

/**
 * Value callback for geolocation fields.
 *
 * Value callback for those processors which stores their values on geolocation
 * fields.
 *
 * @param array $coordinates
 *   Array of lat/lng values.
 * @param array $field_info
 *   Info from the field which will store the values returned by the
 *   field_info_field().
 *
 * @return array|bool
 *   Array of geolocation field values, FALSE if the
 *   field type does not match.
 */
function _stanbol_enhancer_geolocation_value_callback(array $coordinates, array $field_info) {
  // Ensure the field's type.
  if ($field_info['type'] !== 'geolocation_latlng') {
    return FALSE;
  }
  // Check the field cardinality, limit the number of saved values based on it.
  if ($field_info['cardinality'] != '-1') {
    $coordinates = array_slice($coordinates, $field_info['cardinality']);
  }
  // @see geolocation_field_presave()
  $coordinates = array_map(function ($coordinate) {
    $coordinate['lat_sin'] = sin(deg2rad($coordinate['lat']));
    $coordinate['lat_cos'] = cos(deg2rad($coordinate['lat']));
    $coordinate['lng_rad'] = deg2rad($coordinate['lng']);
    return $coordinate;
  }, $coordinates);

  return $coordinates;
}

/**
 * Value callback for geofield fields.
 *
 * Value callback for those processors which stores their values on geofield
 * fields.
 *
 * @param array $coordinates
 *   Array of lat/lng values.
 * @param array $field_info
 *   Info from the field which will store the values returned by the
 *   field_info_field().
 *
 * @return array|bool
 *   Array of geofield field values, FALSE if the
 *   field type does not match.
 */
function _stanbol_enhancer_geofield_value_callback(array $coordinates, array $field_info) {
  // Ensure the field's type.
  if ($field_info['type'] !== 'geofield') {
    return FALSE;
  }
  // Check the field cardinality, limit the number of saved values based on it.
  if ($field_info['cardinality'] != '-1') {
    $coordinates = array_slice($coordinates, $field_info['cardinality']);
  }
  // @see http://cgit.drupalcode.org/geofield/plain/README.txt?id=7.x-1.x
  $coordinates = array_map(function ($coordinate) {
    return geofield_compute_values([
      'lat' => $coordinate['lat'],
      'lon' => $coordinate['lng'],
    ], 'latlon');
  }, $coordinates);

  return $coordinates;
}
