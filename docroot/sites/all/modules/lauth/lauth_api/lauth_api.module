<?php

define ('LAUTH_MAX_REQUEST_AGE', 300);
define ('LAUTH_DEFAULT_VERSION', 1);

/**
 * This is drupal_http_request slightly modified to support $options['lauth'].
 *
 * Perform a signed HTTP request.
 *
 * This is a flexible and powerful HTTP client implementation. Correctly
 * handles GET, POST, PUT or any other HTTP requests. Handles redirects.
 *
 * @param $url
 *   A string containing a fully qualified URI.
 * @param array $options
 *   (optional) An array that can have one or more of the following elements:
 *   - headers: An array containing request headers to send as name/value pairs.
 *   - method: A string containing the request method. Defaults to 'GET'.
 *   - data: A string containing the request body, formatted as
 *     'param=value&param=value&...'. Defaults to NULL.
 *   - max_redirects: An integer representing how many times a redirect
 *     may be followed. Defaults to 3.
 *   - timeout: A float representing the maximum number of seconds the function
 *     call may take. The default is 30 seconds. If a timeout occurs, the error
 *     code is set to the HTTP_REQUEST_TIMEOUT constant.
 *   - context: A context resource created with stream_context_create().
 *   - lauth: An array containing lauth credentials:
 *      - lauth_keyid: the lauth key id
 *      - lauth_secret: the lauth key secret
 *      - lauth_protocol_version: the version of the protocol to use (optional)
 *
 * @return object
 *   An object that can have one or more of the following components:
 *   - request: A string containing the request body that was sent.
 *   - code: An integer containing the response status code, or the error code
 *     if an error occurred.
 *   - protocol: The response protocol (e.g. HTTP/1.1 or HTTP/1.0).
 *   - status_message: The status message from the response, if a response was
 *     received.
 *   - redirect_code: If redirected, an integer containing the initial response
 *     status code.
 *   - redirect_url: If redirected, a string containing the URL of the redirect
 *     target.
 *   - error: If an error occurred, the error message. Otherwise not set.
 *   - headers: An array containing the response headers as name/value pairs.
 *     HTTP header names are case-insensitive (RFC 2616, section 4.2), so for
 *     easy access the array keys are returned in lower case.
 *   - data: A string containing the response body that was received.
 */
function lauth_api_http_request($url, array $options = array()) {
  module_load_include('inc', 'lauth_api', 'lauth_api_utils');

  // Save lauth options for redirects.
  if (isset($options['lauth'])) {
    $lauth = $options['lauth'];
  }

  $result = new stdClass();

  // Parse the URL and make sure we can handle the schema.
  $uri = @parse_url($url);

  if ($uri == FALSE) {
    $result->error = 'unable to parse URL';
    $result->code = -1001;
    return $result;
  }

  if (!isset($uri['scheme'])) {
    $result->error = 'missing schema';
    $result->code = -1002;
    return $result;
  }

  if (isset($uri['user'])) {
    $result->error = 'cannot used basic authentication together with lauth authentication';
    $result->code = -2000;
    return $result;
  }

  timer_start(__FUNCTION__);

  // Merge the default options.
  $options += array(
    'headers' => array(),
    'method' => 'GET',
    'data' => NULL,
    'max_redirects' => 3,
    'timeout' => 30.0,
    'context' => NULL,
  );
  // stream_socket_client() requires timeout to be a float.
  $options['timeout'] = (float) $options['timeout'];

  switch ($uri['scheme']) {
    case 'http':
    case 'feed':
      $port = isset($uri['port']) ? $uri['port'] : 80;
      $socket = 'tcp://' . $uri['host'] . ':' . $port;
      // RFC 2616: "non-standard ports MUST, default ports MAY be included".
      // We don't add the standard port to prevent from breaking rewrite rules
      // checking the host that do not take into account the port number.
      $options['headers']['Host'] = $uri['host'] . ($port != 80 ? ':' . $port : '');
      break;
    case 'https':
      // Note: Only works when PHP is compiled with OpenSSL support.
      $port = isset($uri['port']) ? $uri['port'] : 443;
      $socket = 'ssl://' . $uri['host'] . ':' . $port;
      $options['headers']['Host'] = $uri['host'] . ($port != 443 ? ':' . $port : '');
      break;
    default:
      $result->error = 'invalid schema ' . $uri['scheme'];
      $result->code = -1003;
      return $result;
  }

  if (empty($options['context'])) {
    $fp = @stream_socket_client($socket, $errno, $errstr, $options['timeout']);
  }
  else {
    // Create a stream with context. Allows verification of a SSL certificate.
    $fp = @stream_socket_client($socket, $errno, $errstr, $options['timeout'], STREAM_CLIENT_CONNECT, $options['context']);
  }

  // Make sure the socket opened properly.
  if (!$fp) {
    // When a network error occurs, we use a negative number so it does not
    // clash with the HTTP status codes.
    $result->code = -$errno;
    $result->error = trim($errstr) ? trim($errstr) : t('Error opening socket @socket', array('@socket' => $socket));

    // Mark that this request failed. This will trigger a check of the web
    // server's ability to make outgoing HTTP requests the next time that
    // requirements checking is performed.
    // See system_requirements()
    variable_set('drupal_http_request_fails', TRUE);

    return $result;
  }

  // Construct the path to act on.
  $path = isset($uri['path']) ? $uri['path'] : '/';
  if (isset($uri['query'])) {
    $path .= '?' . $uri['query'];
  }

  // Merge the default headers.
  $options['headers'] += array(
    'User-Agent' => 'Drupal (+http://drupal.org/)',
  );

  // Only add Content-Length if we actually have any content or if it is a POST
  // or PUT request. Some non-standard servers get confused by Content-Length in
  // at least HEAD/GET requests, and Squid always requires Content-Length in
  // POST/PUT requests.
  $content_length = strlen($options['data']);
  if ($content_length > 0 || $options['method'] == 'POST' || $options['method'] == 'PUT') {
    $options['headers']['Content-Length'] = $content_length;
  }

  // If the database prefix is being used by SimpleTest to run the tests in a copied
  // database then set the user-agent header to the database prefix so that any
  // calls to other Drupal pages will run the SimpleTest prefixed database. The
  // user-agent is used to ensure that multiple testing sessions running at the
  // same time won't interfere with each other as they would if the database
  // prefix were stored statically in a file or database variable.
  $test_info = &$GLOBALS['drupal_test_info'];
  if (!empty($test_info['test_run_id'])) {
    $options['headers']['User-Agent'] = drupal_generate_test_ua($test_info['test_run_id']);
  }

  if (isset($options['lauth'])) {
    $secret = $options['lauth']['lauth_secret'];
    unset($options['lauth']['lauth_secret']);

    $options['lauth']['lauth_timestamp'] = REQUEST_TIME;
    $options['lauth']['lauth_nonce'] = _lauth_api_generate_nonce();

    if (!isset($options['lauth']['lauth_protocol_version'])) {
      $options['lauth']['lauth_protocol_version'] = LAUTH_DEFAULT_VERSION;
    }

    // Compute signature
    _lauth_api_sign_request($url, $options, $options['lauth']['lauth_keyid'], $secret, $options['lauth']['lauth_protocol_version']);
  }

  $request = $options['method'] . ' ' . $path . " HTTP/1.0\r\n";
  foreach ($options['headers'] as $name => $value) {
    $request .= $name . ': ' . trim($value) . "\r\n";
  }
  $request .= "\r\n" . $options['data'];
  $result->request = $request;

  // Calculate how much time is left of the original timeout value.
  $timeout = $options['timeout'] - timer_read(__FUNCTION__) / 1000;
  if ($timeout > 0) {
    stream_set_timeout($fp, floor($timeout), floor(1000000 * fmod($timeout, 1)));
    fwrite($fp, $request);
  }

  // Fetch response. Due to PHP bugs like http://bugs.php.net/bug.php?id=43782
  // and http://bugs.php.net/bug.php?id=46049 we can't rely on feof(), but
  // instead must invoke stream_get_meta_data() each iteration.
  $info = stream_get_meta_data($fp);
  $alive = !$info['eof'] && !$info['timed_out'];
  $response = '';

  while ($alive) {
    // Calculate how much time is left of the original timeout value.
    $timeout = $options['timeout'] - timer_read(__FUNCTION__) / 1000;
    if ($timeout <= 0) {
      $info['timed_out'] = TRUE;
      break;
    }
    stream_set_timeout($fp, floor($timeout), floor(1000000 * fmod($timeout, 1)));
    $chunk = fread($fp, 1024);
    $response .= $chunk;
    $info = stream_get_meta_data($fp);
    $alive = !$info['eof'] && !$info['timed_out'] && $chunk;
  }
  fclose($fp);

  if ($info['timed_out']) {
    $result->code = HTTP_REQUEST_TIMEOUT;
    $result->error = 'request timed out';
    return $result;
  }
  // Parse response headers from the response body.
  // Be tolerant of malformed HTTP responses that separate header and body with
  // \n\n or \r\r instead of \r\n\r\n.
  list($response, $result->data) = preg_split("/\r\n\r\n|\n\n|\r\r/", $response, 2);
  $response = preg_split("/\r\n|\n|\r/", $response);

  // Parse the response status line.
  list($protocol, $code, $status_message) = explode(' ', trim(array_shift($response)), 3);
  $result->protocol = $protocol;
  $result->status_message = $status_message;

  $result->headers = array();

  // Parse the response headers.
  while ($line = trim(array_shift($response))) {
    list($name, $value) = explode(':', $line, 2);
    $name = strtolower($name);
    if (isset($result->headers[$name]) && $name == 'set-cookie') {
      // RFC 2109: the Set-Cookie response header comprises the token Set-
      // Cookie:, followed by a comma-separated list of one or more cookies.
      $result->headers[$name] .= ',' . trim($value);
    }
    else {
      $result->headers[$name] = trim($value);
    }
  }

  $responses = array(
    100 => 'Continue',
    101 => 'Switching Protocols',
    200 => 'OK',
    201 => 'Created',
    202 => 'Accepted',
    203 => 'Non-Authoritative Information',
    204 => 'No Content',
    205 => 'Reset Content',
    206 => 'Partial Content',
    300 => 'Multiple Choices',
    301 => 'Moved Permanently',
    302 => 'Found',
    303 => 'See Other',
    304 => 'Not Modified',
    305 => 'Use Proxy',
    307 => 'Temporary Redirect',
    400 => 'Bad Request',
    401 => 'Unauthorized',
    402 => 'Payment Required',
    403 => 'Forbidden',
    404 => 'Not Found',
    405 => 'Method Not Allowed',
    406 => 'Not Acceptable',
    407 => 'Proxy Authentication Required',
    408 => 'Request Time-out',
    409 => 'Conflict',
    410 => 'Gone',
    411 => 'Length Required',
    412 => 'Precondition Failed',
    413 => 'Request Entity Too Large',
    414 => 'Request-URI Too Large',
    415 => 'Unsupported Media Type',
    416 => 'Requested range not satisfiable',
    417 => 'Expectation Failed',
    500 => 'Internal Server Error',
    501 => 'Not Implemented',
    502 => 'Bad Gateway',
    503 => 'Service Unavailable',
    504 => 'Gateway Time-out',
    505 => 'HTTP Version not supported',
  );
  // RFC 2616 states that all unknown HTTP codes must be treated the same as the
  // base code in their class.
  if (!isset($responses[$code])) {
    $code = floor($code / 100) * 100;
  }
  $result->code = $code;

  switch ($code) {
    case 200: // OK
    case 304: // Not modified
      break;
    case 301: // Moved permanently
    case 302: // Moved temporarily
    case 307: // Moved temporarily
      $location = $result->headers['location'];
      $options['timeout'] -= timer_read(__FUNCTION__) / 1000;
      if ($options['timeout'] <= 0) {
        $result->code = HTTP_REQUEST_TIMEOUT;
        $result->error = 'request timed out';
      }
      elseif ($options['max_redirects']) {
        // Restore lauth options
        if (isset($lauth)) {
          $options['lauth'] = $lauth;
        }

        // Redirect to the new location.
        $options['max_redirects']--;
        $result = lauth_api_http_request($location, $options);
        $result->redirect_code = $code;
      }
      if (!isset($result->redirect_url)) {
        $result->redirect_url = $location;
      }
      break;
    default:
      $result->error = $status_message;
  }

  return $result;
}

/**
 * Verify lauth signature for current http request.
 *
 * FIXME: better return values; use exceptions?
 *
 * @param $secret_callback
 *   Function used to get the secret key.
 *   function secret_callback($key_id)
 */
function lauth_api_verify_request($secret_callback) {
  module_load_include('inc', 'lauth_api', 'lauth_api_utils');

  $options = array();

  // Preparations that has to be made if we're going to detect parameters
  $q = $_GET['q'];

  // Unset $_GET['q'] if it was created by a redirect
  if (isset($_SERVER['REDIRECT_URL'])) {
    $q = FALSE;
  }
  // Check that the q parameter hasn't been created or altered by drupal
  elseif (isset($_GET['q'])) {
    $get = array();
    parse_str($_SERVER['QUERY_STRING'], $get);
    // The q parameter was in the original request, make sure it hasn't been altered
    if (isset($get['q'])) {
      $q = $get['q'];
    }
    // The q parameter was set by drupal, unset it
    else {
      $q = FALSE;
    }
  }

  $parsed = array();
  parse_str($_SERVER['QUERY_STRING'], $parsed);
  if ($q === FALSE) {
    unset($parsed['q']);
  }
  else {
    $parsed['q'] = $q;
  }
  $qs = http_build_query($parsed, '', '&');

  $scheme = (!isset($_SERVER['HTTPS']) || $_SERVER['HTTPS'] != "on")
            ? 'http'
            : 'https';
  $http_url = $scheme .
              '://' . $_SERVER['HTTP_HOST'] .
              ':' .
              $_SERVER['SERVER_PORT'] .
              $_SERVER['REQUEST_URI'];
  $options['method'] = $_SERVER['REQUEST_METHOD'];

  // Find request headers
  $options['headers'] = _lauth_api_utils_get_headers();

  // Parse the query-string to find GET parameters
  $parameters = _lauth_api_utils_parse_parameters($qs);

  // If it's a POST request, parse POST
  // parameters and add those overriding any duplicates from GET
  $post_data = '';
  if ($options['method'] == "POST") {
    $options['data'] = file_get_contents('php://input');
  }

  // We have a Authorization-header with LAuth data. Parse the header
  // and add those overriding any duplicates from GET or POST
  if (isset($options['headers']['Authorization']) && (strcmp(substr($options['headers']['Authorization'], 0, 6), 'LAuth ') == 0)) {
    $options['lauth'] = _lauth_api_utils_split_header($options['headers']['Authorization']);
  }

  $timestamp = $options['lauth']['lauth_timestamp'];
  $nonce = $options['lauth']['lauth_nonce'];
  $key_id = $options['lauth']['lauth_keyid'];
  $protocol_version = $options['lauth']['lauth_protocol_version'];

  if (!$protocol_version) {
    return array(FALSE, 'Missing protocol version parameter. The parameter is required');
  }
  if (!$key_id) {
    return array(FALSE, 'Missing key id parameter. The parameter is required');
  }
  if (!$timestamp) {
    return array(FALSE, 'Missing timestamp parameter. The parameter is required');
  }
  else if (abs(REQUEST_TIME - $timestamp) > LAUTH_MAX_REQUEST_AGE) {
    return array(FALSE, "Expired timestamp, yours $timestamp, ours " . REQUEST_TIME );
  }
  if (!$nonce) {
    return array(FALSE, 'Missing nonce parameter. The parameter is required');
  }
  else {
    db_delete('lauth_api_nonces')
      ->condition('timestamp', REQUEST_TIME - LAUTH_MAX_REQUEST_AGE, '<')
      ->execute();

    $count = db_select('lauth_api_nonces', 'ln')
      ->condition('ln.nonce', $nonce)
      ->condition('ln.key_id', $key_id)
      ->countQuery()->execute()->fetchField();
    if ($count > 0) {
      return array(FALSE, "Nonce already used: $nonce");
    }
  }

  $signature = $options['lauth']['lauth_signature'];
  $secret = $secret_callback($key_id);
  if ($secret) {
    _lauth_api_sign_request($http_url, $options, $key_id, $secret, $protocol_version);
    if (strcmp($signature, $options['lauth']['lauth_signature']) == 0) {
      db_insert('lauth_api_nonces')
        ->fields(array(
          'nonce' => $nonce,
          'timestamp' => $timestamp,
          'key_id' => $key_id,
        ))
        ->execute();

      return array(TRUE, $key_id);
    }
    else {
      return array(FALSE, "Signature do not match: " . $signature . ' vs ' . $options['lauth']['lauth_signature']);
    }
  }
  else {
    return array(FALSE, 'Unknown key');
  }
}

/**
 * Build a signature for http request using $key_id.
 *
 * @param $url
 *   - request URL, possibly including a query string
 *
 * @param $options
 *   an array with these keys:
 *   - 'method': http method for request (GET, PUT, POST, ...)
 *   - 'lauth': lauth authorization parameters
 *   - 'headers': HTTP headers for request
 *   - 'data': POST data
 *
 * @param $key_id
 *   - key to use for signing
 *
 * @param $secret
 *   - secret key to use for signing
 *
 * @param $protocol_version
 *   - The protocol version specifies how to compute the signed string
 */
function _lauth_api_sign_request($url, &$options, $key_id, $secret, $protocol_version) {
  $http_method = strtoupper($options['method']);
  $post_data = '';

  // Compute parameters
  $parameters = $options['lauth'];

  $parameters = array_merge(_lauth_api_utils_parse_parameters(parse_url($url, PHP_URL_QUERY)), $parameters);

  if ($http_method == "POST") {
    // Encode POST data. If post data contains urlencoded parameters, merge them with the parameters from
    // the query string and leave $post_data empty.
    if (isset($options['headers']['Content-Type']) && strstr($options['headers']['Content-Type'], 'application/x-www-form-urlencoded')) {
      $post_data_parameters = _lauth_api_utils_parse_parameters($options['data']);
      $parameters = array_merge($parameters, $post_data_parameters);
    }
    else {
      $post_data = $options['data'];
    }
  }

  // Build header string.
  // Should we include all headers in signature?
  $header_string = '';
  $sorted_headers = $options['headers'];
  uksort($sorted_headers, 'strcmp');
  foreach ($sorted_headers as $name => $value) {
    $signed_headers = array('Cookie', 'Content-Length', 'Content-MD5', 'Content-Type', 'Date', 'Host');
    if (in_array($name, $signed_headers)) {
      $header_string .= $name . ': ' . trim($value) . "\r\n";
    }
  }

  // Build request string.
  $parts = array(
    $http_method,
    _lauth_api_get_normalized_url($url),
    _lauth_api_get_signable_parameters($parameters),
    $post_data,
    $header_string
  );
  $parts = _lauth_api_utils_urlencode_rfc3986($parts);
  $message = implode('&', $parts);

  // Sign it
  $options['lauth']['lauth_signature'] = _lauth_api_sign_message($message, $key_id, $secret);

  // Build Authorization header string
  // FIXME: support realm?
  $first = true;
  $auth_header = 'LAuth';
  foreach ($options['lauth'] as $k => $v) {
    $auth_header .= ($first) ? ' ' : ',';
    $auth_header .= _lauth_api_utils_urlencode_rfc3986($k) . '="' . _lauth_api_utils_urlencode_rfc3986($v) . '"';
    $first = false;
  }
  $options['headers']['Authorization'] = $auth_header;
}

/**
 * Return normalized URL for signature string construction.
 *
 * @param unknown_type $url
 */
function _lauth_api_get_normalized_url($url) {
  $parts = parse_url($url);

  $scheme = (isset($parts['scheme'])) ? $parts['scheme'] : 'http';
  $port = (isset($parts['port'])) ? $parts['port'] : (($scheme == 'https') ? '443' : '80');
  $host = (isset($parts['host'])) ? $parts['host'] : '';
  $path = (isset($parts['path'])) ? $parts['path'] : '';

  if (($scheme == 'https' && $port != '443')
      || ($scheme == 'http' && $port != '80')) {
    $host = "$host:$port";
  }
  return "$scheme://$host$path";
}

/**
 * Return parameters for signature string construction.
 *
 * @param $params
 */
function _lauth_api_get_signable_parameters($params) {
  // Remove oauth_signature if present
  // Ref: Spec: 9.1.1 ("The oauth_signature parameter MUST be excluded.")
  if (isset($params['lauth_signature'])) {
    unset($params['lauth_signature']);
  }

  return _lauth_api_utils_build_http_query($params);
}

/**
 * Sign a message using $key_id.
 *
 * @param unknown_type $message
 * @param unknown_type $key_id
 */
function _lauth_api_sign_message($message, $key_id, $secret) {
  return _lauth_api_hmac_base32('sha256', $message, $secret);
}

/**
 * Generate a number used once (nonce) for authorization purpose.
 */
function _lauth_api_generate_nonce() {
  return _lauth_api_hash_base32('md5', uniqid(mt_rand(), TRUE));
}

/**
 * Calculate a base-32 encoded, URL-safe hash.
 *
 * @param $algo
 *   Hash algorithm to use.
 *
 * @param $data
 *   String to be hashed.
 *
 * @return
 *   A base-32 encoded hmac without any = padding characters.
 */
function _lauth_api_hash_base32($algo, $data) {
  return _lauth_api_base32_encode(hash($algo, $data, TRUE));
}

/**
 * Calculate a base-32 encoded, URL-safe hmac.
 *
 * @param $data
 *   String to be validated with the hmac.
 * @param $key
 *   A secret string key.
 *
 * @return
 *   A base-32 encoded hmac without any = padding characters.
 */
function _lauth_api_hmac_base32($algo, $data, $key) {
  return _lauth_api_base32_encode(hash_hmac($algo, $data, $key, TRUE));
}

/**
 * Encode a string in base32.
 */
function _lauth_api_base32_encode($string, $pad = FALSE) {
  static $map = array(
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
    'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '2', '3', '4', '5', '6', '7',
    '='
  );

  $base32 = '';

  if(!empty($string)) {
    $binary_string = '';
    $string = str_split($string);
    for ($i = 0; $i < count($string); $i++) {
      $binary_char = base_convert(ord($string[$i]), 10, 2);
      $binary_string .= str_pad($binary_char, 8, '0', STR_PAD_LEFT);
    }

    $binary_array = str_split($binary_string, 5);
    for ($i = 0; $i < count($binary_array); $i++) {
      $five_bits = str_pad($binary_array[$i], 5, '0');
      $base32 .= $map[base_convert($five_bits, 2, 10)];
    }

    if ($pad) {
      // Add padding. See RFC4648.
      $x = strlen($binary_string) % 40;
      switch ($x) {
        case 8:
          $base32 .= str_repeat($map[32], 6);
          break;

        case 16:
          $base32 .= str_repeat($map[32], 4);
          break;

        case 24:
          $base32 .= str_repeat($map[32], 3);
          break;

        case 32:
          $base32 .= $map[32];
          break;
      }
    }
  }

  return $base32;
}
