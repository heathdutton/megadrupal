<?php

/**
 * Implements hook_module_implements_alter().
 */
function views_arguments_module_implements_alter(&$implementations, $hook) {
  $module = 'views_arguments';

  // Do these last.
  if (in_array($hook, array('menu_alter')) && isset($implementations[$module])) {
    $group = $implementations[$module];
    unset($implementations[$module]);
    $implementations[$module] = $group;
  }
}

/**
 * Implements hook_menu_alter().
 */
function views_arguments_menu_alter(&$items) {
  $callbacks = array();

  $views = views_get_applicable_views('uses hook menu');
  foreach ($views as $data) {
    list($view, $display_id) = $data;

    if (_views_arguments_has_display($view, $display_id, $arg)) {
      $result = $view->execute_hook_menu($display_id, $callbacks);
      $path = key($result);

      $item = &$items[$path];

      // Only override access if we have a uid index. Otherwise, access checks will be impossible from other pages. This means
      // you have to use % in the views path, not %user.
      if (isset($item['page arguments'][2])) {
        $item['access arguments'] = array(
          $item['access callback'],
          $item['access arguments'],
          @$arg['validate_options']['permission'],
          @$item['page arguments'][2] ?: '', // 3rd page arg is the uid arg index OR not in which case we have to call the Views Argument object for help
          array($view->name, $display_id, $arg['id']),
        );
        $item['access callback'] = 'views_arguments_views_page_access';
      }

      unset($item);
    }
  }
}

/**
 * Access callback for all Views with a Views Arguments argument extension.
 */
function views_arguments_views_page_access($original_callback, $original_arguments, $permission, $uid, $view_info) {
  $views_access = call_user_func_array($original_callback, $original_arguments);

  // Only do my own gangsta access check IF they have the normal Views access.
  if ($views_access) {
    // 0 is technically a valid uid, but we no want it.
    if (!$uid) {
      return FALSE;
    }

    // Global user is page user.
    global $user;
    if ($user->uid && $user->uid == $uid) {
      return TRUE;
    }

    // Has required permission.
    if ($permission && user_access($permission)) {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Helper to identify a given View as a Views Arguments extended view.
 */
function _views_arguments_has_display($view, $display_id, &$arg) {
  $display = $view->display[$display_id];
  $args = $display->handler->get_option('arguments');
  foreach ($args as $arg) {
    if (@$arg['validate']['type'] == 'user_specific' && @$arg['validate_options']['permission']) {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Implements hook_form_FORM_ID_alter() for views_ui_config_item_form().
 */
function views_arguments_form_views_ui_config_item_form_alter(&$form, &$form_state) {
  if (in_array($form_state['section'], array('fields', 'filters', 'relationships', 'arguments'))) {
    $access = $form_state['handler']->options['access'];
    $form['options']['access'] = array(
      '#type' => 'fieldset',
      '#title' => t('Access'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );
    _views_arguments_handler_access_form($form['options']['access'], $access);
  }
}

/**
 * Form callback for the 'access' element.
 *
 * @see views_arguments_form_views_ui_config_item_form_alter()
 * @see views_arguments_plugin_access_callback::options_form()
 */
function _views_arguments_handler_access_form(&$form, $defaults) {
  $form['#element_validate'][] = '_views_arguments_handler_access_form_validate';

  $callbacks = _views_arguments_access_callbacks();
  $form['callback'] = array(
    '#type' => 'select',
    '#title' => t('Callback function'),
    '#options' => array_map(function($callback) {
      return $callback['title'];
    }, $callbacks),
    '#default_value' => @$defaults['callback'],
    '#empty_option' => t('- Select -'),
  );

  $form['arguments'] = array(
    '#type' => 'fieldset',
    '#title' => t('Arguments'),
  );
  for ($i = 0; $i < 15; $i++) {
    $form['arguments'][$i] = array(
      '#type' => 'textfield',
      '#default_value' => @$defaults['arguments'][$i] ?: '',
      '#attributes' => array('class' => array('va-ac-arg-' . $i)),
    );
    if ($i && empty($defaults['arguments'][$i])) {
      $form['arguments'][$i]['#states']['visible'] = array(
        '.va-ac-arg-' . ($i-1) => array('empty' => FALSE),
      );
    }
  }
}

/**
 * Validation handler for the 'access' element.
 *
 * @see views_arguments_form_views_ui_config_item_form_alter()
 * @see views_arguments_plugin_access_callback::options_form()
 */
function _views_arguments_handler_access_form_validate($element, &$form_state) {
  $parents = $element['#parents'];
  $access = drupal_array_get_nested_value($form_state['values'], $parents);

  $access['callback'] = trim($access['callback']);
  $access['arguments'] = array_values(array_filter($access['arguments']));

  if ($access['callback']) {
    $callbacks = _views_arguments_access_callbacks();
    $callback = $callbacks[ $access['callback'] ];

    // Exclude flags, they don't count.
    $arguments = $access['arguments'];
    _views_arguments_access_check_flags($arguments);

    // Validate # arguments.
    if (count($arguments) < $callback['min arguments'] || count($arguments) > $callback['max arguments']) {
      return form_error($element['arguments'], t('This callback must have between @min and @max arguments, excluding flags.', array(
        '@min' => $callback['min arguments'],
        '@max' => $callback['max arguments'],
      )));
    }
  }
  else {
    $access['arguments'] = array();
  }

  drupal_array_set_nested_value($form_state['values'], $parents, $access);
}

/**
 * Implements hook_views_handler_option_definition_alter().
 *
 * This hook requires a Views patch: https://www.drupal.org/node/2610418#comment-10538690
 */
function views_arguments_views_handler_option_definition_alter(&$definition, $handler) {
  // Allow the 'access' element to be stored by Views.
  $definition['access'] = array('contains' => array(
    'callback' => array('default' => ''),
    'arguments' => array('default' => array()),
  ));
}

/**
 * Implements hook_views_plugins().
 */
function views_arguments_views_plugins() {
  $plugins['argument validator']['user_specific'] = array(
    'title' => t('Is user OR has permission'),
    'handler' => 'views_arguments_plugin_argument_validate_specific_user',
  );

  $plugins['argument default']['from_callback'] = array(
    'title' => t('From callback function'),
    'handler' => 'views_arguments_plugin_argument_default_from_callback',
  );

  $plugins['access']['callback'] = array(
    'title' => t('Callback'),
    'handler' => 'views_arguments_plugin_access_callback',
    'uses options' => TRUE,
  );

  return $plugins;
}

/**
 * Implements hook_views_data().
 */
function views_arguments_views_data() {
  // Filter: Booleanable anything.
  $data['views']['booleanable_anything'] = array(
    'title' => t('Booleanable anything'),
    'help' => t('Booleanize filters, relationships and arguments.'),
    'filter' => array(
      'handler' => 'views_arguments_handler_filter_booleanable_anything',
    ),
  );

  // Field: Combined menu items.
  $data['views']['combined_menu_items'] = array(
    'title' => t('Combined menu items'),
    'help' => t('Combine menu item fields into 1 field.'),
    'field' => array(
      'handler' => 'views_arguments_handler_field_combined_menu_items',
    ),
  );

  // Field: Accessible.
  $data['views']['accessible'] = array(
    'title' => t('Accessible'),
    'help' => t('A rewritable field, empty or not, depending on configured access.'),
    'field' => array(
      'handler' => 'views_arguments_handler_field_accessible',
    ),
  );

  // Fields: Any ENTITY.
  foreach (entity_get_info() as $entity_type => $entity_info) {
    if (!empty($entity_info['base table'])) {
      $data[ $entity_info['base table'] ]['any_objectified'] = TRUE;
      $data[ $entity_info['base table'] ]['any_' . $entity_type] = array(
        'title' => t('Any !type', array('!type' => $entity_info['label'])),
        'help' => t('Throws in an entity, pulls out anything you want. Code it.'),
        'real field' => $entity_info['entity keys']['id'],
        'field' => array(
          'handler' => 'views_arguments_handler_field_any_object',
          'entity type' => $entity_type,
        ),
      );
    }
  }

  // Relationship: Child terms.
  $data['taxonomy_term_data']['child_terms'] = array(
    'title' => t('Child terms'),
    'help' => t('All child terms of this term.'),
    'relationship' => array(
      'base' => 'taxonomy_term_data',
      'handler' => 'views_arguments_handler_relationship_child_terms',
      'real field' => 'tid',
      'label' => t('Child terms'),
    ),
  );

  return $data;
}

/**
 * Implements hook_views_data_alter().
 */
function views_arguments_views_data_alter(&$data) {
  foreach ($data as $table => $info) {
    if (!empty($info['table']['base']) && empty($data[$table]['any_objectified'])) {
      $data[$table]['any_' . $table] = array(
        'title' => t('Any !type', array('!type' => $info['table']['base']['title'])),
        'help' => t('Throws in a db record, pulls out anything you want. Code it.'),
        'real field' => $info['table']['base']['field'],
        'field' => array(
          'handler' => 'views_arguments_handler_field_any_object',
        ),
      );
    }
  }
}

/**
 * Collect argument callbacks from other modules.
 */
function _views_arguments_argument_callbacks() {
  $callbacks = &drupal_static(__FUNCTION__, FALSE);
  if ($callbacks === FALSE) {
    $callbacks = module_invoke_all('views_arguments_argument_callback_info');
    foreach ($callbacks as &$callback) {
      $callback += array(
        'arguments' => array(),
      );
      unset($callback);
    }
    drupal_alter('views_arguments_argument_callback_info', $callbacks);
  }

  return $callbacks;
}

/**
 * Implements hook_views_pre_build().
 */
function views_arguments_views_pre_build($view) {
  $callbacks = _views_arguments_access_callbacks();
  foreach ($view->display_handler->handlers as $type => $handlers) {
    foreach ($handlers as $id => $handler) {
      if (!empty($handler->options['access']['callback'])) {
        $access = $handler->options['access'];
        $callback = $callbacks[ $access['callback'] ];
        if (!call_user_func_array($callback['callback'], $access['arguments'])) {
          switch ($type) {
            case 'field':
            case 'filter':
            case 'arguments':
              unset($view->display_handler->handlers[$type][$id]);
              break;

            case 'relationship':
              $view->display_handler->handlers[$type][$id]->options['required'] = 0;
              break;
          }
        }
      }
    }
  }
}

/**
 * Collect access callbacks from other modules.
 */
function _views_arguments_access_callbacks() {
  $callbacks = &drupal_static(__FUNCTION__, FALSE);
  if ($callbacks === FALSE) {
    $callbacks = module_invoke_all('views_arguments_access_callback_info');
    foreach ($callbacks as &$callback) {
      $callback += array(
        'min arguments' => 0,
        'max arguments' => 3,
      );
      unset($callback);
    }
    drupal_alter('views_arguments_access_callback_info', $callbacks);
  }

  return $callbacks;
}

/**
 * Implements hook_views_arguments_access_callback_info().
 */
function views_arguments_views_arguments_access_callback_info() {
  $callbacks['check_roles'] = array(
    'title' => "Check current user's roles",
    'callback' => '_views_arguments_access_check_roles',
    'min arguments' => 1,
    'max arguments' => 9,
  );
  $callbacks['check_permissions'] = array(
    'title' => "Check current user's permissions",
    'callback' => '_views_arguments_access_check_permissions',
    'min arguments' => 1,
    'max arguments' => 9,
  );
  return $callbacks;
}

/**
 * Strip 'flags' from input arguments, and return them.
 *
 * Flags are static. Possible: 'all', 'reverse'.
 *
 * It is recommended access callback implementations use this function to extract above flags,
 * because they're useful in most contexts, especially 'reverse', because having NO ACCESS to a
 * handler sometimes means seeing MORE (e.g. the Published filter).
 */
function _views_arguments_access_check_flags(&$arguments) {
  $flags = array();
  while (isset($arguments[0]) && in_array($arguments[0], array('all', 'reverse'))) {
    $flags[ $arguments[0] ] = TRUE;
    array_shift($arguments);
  }

  return $flags;
}

/**
 * Views access callback for checking Permissions.
 *
 * Use "reverse" as first argument to reverse the result (not the process).
 *
 * Use "all" as second argument, to require all permissions in order to pass. The default
 * requires at least one permission in order to pass.
 */
function _views_arguments_access_check_permissions($permission1) {
  $permissions = func_get_args();

  $flags = _views_arguments_access_check_flags($permissions);
  $success = !isset($flags['reverse']);

  $need = isset($flags['all']) ? count($permissions) : 1;
  $have = count(array_filter(array_map('user_access', $permissions)));
  return $have >= $need ? $success : !$success;
}

/**
 * Views access callback for checking Roles.
 *
 * Use "reverse" as first argument to reverse the result (not the process).
 *
 * Use "all" as second argument, to require all roles in order to pass. The default
 * requires at least one role in order to pass.
 */
function _views_arguments_access_check_roles($role1) {
  global $user;

  $roles = func_get_args();

  $flags = _views_arguments_access_check_flags($roles);
  $success = !isset($flags['reverse']);

  $need = isset($flags['all']) ? count($roles) : 1;
  $have = count(array_intersect($roles, $user->roles));
  return $have >= $need ? $success : !$success;
}
