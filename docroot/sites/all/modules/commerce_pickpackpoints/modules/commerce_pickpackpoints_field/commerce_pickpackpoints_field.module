<?php

/**
 * @file
 * This module implements pick-pack pont field to drupal commerce shops.
 */

/**
 * Implements hook_field_info().
 */
function commerce_pickpackpoints_field_field_info() {
  return array(
    'pickpack' => array(
      'label' => t('Pick-pack pont field'),
      'description' => t("This field stores values from a list of pick-pack pont list"),
      'settings' => array('allowed_values' => commerce_pickpackpoints_get_option_list(), 'allowed_values_function' => ''),
      'default_widget' => 'options_select',
      'default_formatter' => 'pickpack_default',
    ),
  );
}

/**
 * Implements hook_field_update_forbid().
 */
function commerce_pickpackpoints_field_field_update_forbid($field, $prior_field, $has_data) {
  if ($field['module'] == 'pickpack' && $has_data) {
    // Forbid any update that removes allowed values with actual data.
    $lost_keys = array_diff(array_keys($prior_field['settings']['allowed_values']), array_keys($field['settings']['allowed_values']));
    if (_commerce_pickpackpoints_field_values_in_use($field, $lost_keys)) {
      throw new FieldUpdateForbiddenException(t('Cannot update a pickpack field to not include keys with existing data.'));
    }
  }
}

/**
 * Checks if a list of values are being used in actual field values.
 */
function _commerce_pickpackpoints_field_values_in_use($field, $values) {
  if ($values) {
    $query = new EntityFieldQuery();
    $found = $query
        ->fieldCondition($field['field_name'], 'value', $values)
        ->range(0, 1)
        ->execute();
    return !empty($found);
  }

  return FALSE;
}

/**
 * Implements hook_field_validate().
 *
 * Possible error codes:
 * - 'list_illegal_value': The value is not part of the list of allowed values.
 */
function commerce_pickpackpoints_field_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  $allowed_values = commerce_pickpackpoints_get_option_list();
  foreach ($items as $delta => $item) {
    if (!empty($item['value'])) {
      if (!empty($allowed_values) && !isset($allowed_values[$item['value']])) {
        $errors[$field['field_name']][$langcode][$delta][] = array(
          'error' => 'list_illegal_value',
          'message' => t('%name: illegal value.', array('%name' => $instance['label'])),
        );
      }
    }
  }
}

/**
 * Implements hook_field_is_empty().
 */
function commerce_pickpackpoints_field_field_is_empty($item, $field) {
  if (empty($item['value']) || (string) $item['value'] === '-1') {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implements hook_field_formatter_info().
 */
function commerce_pickpackpoints_field_field_formatter_info() {
  return array(
    'pickpack_default' => array(
      'label' => t('Shop data in table'),
      'field types' => array('pickpack'),
    ),
    'pickpack_id_address' => array(
      'label' => t('Shop id + address'),
      'field types' => array('pickpack'),
    ),
    'pickpack_address' => array(
      'label' => t('Address'),
      'field types' => array('pickpack'),
    ),
    'pickpack_key' => array(
      'label' => t('Shop id'),
      'field types' => array('pickpack'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function commerce_pickpackpoints_field_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();

  $data = commerce_pickpackpoints_get_data();
  switch ($display['type']) {
    case 'pickpack_default':
      foreach ($items as $delta => $item) {
        $value = commerce_pickpackpoints_get_rendered_data(field_filter_xss($item['value']), $data[field_filter_xss($item['value'])]);
        $element[$delta] = array('#markup' => $value);
      }
      break;

    case 'pickpack_id_address':
      $allowed_values = commerce_pickpackpoints_get_option_list();
      foreach ($items as $delta => $item) {
        $value = '<div class="pickpack-id">' . t('Shop code: %shop_id', array('%shop_id' => $data[$item['value']]['ShopCode'])) . '</div>';
        $value .= '<div class="pickpack-address">' . t('Address: %address', array('%address' => $allowed_values[$item['value']])) . '</div>';
        $element[$delta] = array('#markup' => $value);
      }
      break;

    case 'pickpack_address':
      $allowed_values = commerce_pickpackpoints_get_option_list();
      foreach ($items as $delta => $item) {
        if (isset($allowed_values[$item['value']])) {
          $output = $allowed_values[$item['value']];
        }
        else {
          // If no match was found in allowed values, fall back to the key.
          $output = field_filter_xss($item['value']);
        }
        $element[$delta] = array('#markup' => t('Address: %address', array('%address' => $output)));
      }
      break;

    case 'pickpack_key':
      foreach ($items as $delta => $item) {
        $element[$delta] = array('#markup' => t('Shop code: %id', array('%id' => $data[$item['value']]['ShopCode'])));
      }
      break;
  }

  return $element;
}

/**
 * Implements hook_field_widget_info_alter().
 *
 * The List module does not implement widgets of its own, but reuses the
 * widgets defined in options.module.
 *
 * @see list_options_list()
 */
function commerce_pickpackpoints_field_field_widget_info_alter(&$info) {
  $widgets = array(
    'options_select' => array('pickpack'),
  );

  foreach ($widgets as $widget => $field_types) {
    $info[$widget]['field types'] = array_merge($info[$widget]['field types'], $field_types);
  }
}

/**
 * Implements hook_field_widget_form_alter().
 */
function commerce_pickpackpoints_field_field_widget_form_alter(&$element, &$form_state, $context) {
  if ($context['field']['type'] == 'pickpack') {
    $element['#options'] = commerce_pickpackpoints_get_option_list();
    $element['#default_value'] = isset($element['#entity']->data['pick_pack_shop']) ? $element['#entity']->data['pick_pack_shop'] : '-1';
  }
}
