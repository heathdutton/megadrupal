<?php
/**
 * @file
 * The PHP layer of the Getty Images Drupal module.
 */

/**
 * Implements hook_filefield_sources_info().
 */
function getty_images_filefield_sources_info() {
  $source = array();
  $source['gettyimages'] = array(
    'label' => t("Getty Images"),
    'name' => t("Attach file from Getty Images"),
    'description' => t("Select a file from Getty Images."),
    'process' => 'getty_images_filefield_source_process',
    'value' => 'getty_images_filefield_source_value',
    'file' => 'sources/remote.inc',
  );
  return $source;
}

/**
 * Implements hook_menu().
 */
function getty_images_menu() {
  return array(
    'getty_images/templates' => array(
      'page callback' => 'getty_images_templates',
      'access arguments' => array('access content'),
      'type' => MENU_CALLBACK,
    ),
    'getty_images/ajax' => array(
      'page callback' => 'getty_images_ajax',
      'access arguments' => array('access content'),
      'type' => MENU_CALLBACK,
    ),
  );
}

/**
 * Emit templates.
 */
function getty_images_templates() {
  include drupal_get_path('module', 'getty_images') . '/getty-templates.php';
}

/**
 * Implements hook_filefield_sources_widgets().
 */
function getty_images_filefield_sources_widgets() {
  return array('image');
}

/**
 * Implements hook_filter_info().
 *
 * Register filter to use Getty Images embeds.
 */
function getty_images_filter_info() {
  $filters['getty_embed'] = array(
    'title' => t("Getty Images Embeds"),
    'description' => t("Enables Getty Images embed codes to be used"),
    'prepare callback' => '_getty_images_filter_prepare',
    'process callback' => '_getty_images_filter_process',
    'weight' => 200,
    'cache' => FALSE,
  );

  return $filters;
}

/**
 * Transform getty images oEmbed URLs into "shortcode" style chunks.
 */
function _getty_images_filter_prepare($text, $filter, $format, $langcode, $cache, $cache_id) {
  return preg_replace('#(?:^|\n)(?:<p>)?http://gty.im/([\w-]+)(?:</p>)?(\n|$)#i', '[getty-embed:$1]', $text);
}

/**
 * Turn getty images oembed links into embedded objects.
 */
function _getty_images_filter_process($text, $filter, $format, $langcode, $cache, $cache_id) {
  // Ignore format: do this for all format types.
  if (preg_match_all('/\[getty-embed:([\w-]+)\]/', $text, $matches, PREG_SET_ORDER)) {
    foreach ($matches as $match) {
      $embed = _getty_images_oembed_lookup('http://gty.im/' . $match[1]);

      $text = str_replace($match[0], $embed, $text);
    }
  }

  return $text;
}

/**
 * Look up oEmbed HTML.
 */
function _getty_images_oembed_lookup($url) {
  $cache_key = md5($url);
  $cache = cache_get($cache_key, 'getty_oembed');

  if ($cache) {
    return $cache;
  }

  $parameters = array(
    'url' => $url,
    'caller' => 'Drupal plugin',
  );

  $fetch_url = 'http://embed.gettyimages.com/oembed?' . http_build_query($parameters, NULL, '&');
  $response = drupal_http_request($fetch_url);

  if (!isset($response->error)) {
    // JSON or XML data might be returned, so be agnostic about decoding it.
    $result = json_decode($response->data, TRUE);
    $html = $result['html'];
    $cache_time = CACHE_PERMANENT;
  }
  else {
    $html = '<!-- oEmbed lookup failed --><a href="' . check_plain($url) . '">' . check_plain($url) . '</a>';
    $cache_time = 3600;
  }

  cache_set($cache_key, $html, 'getty_oembed', $cache_time);

  return $html;
}

/**
 * Implements hook_node_presave().
 *
 * Ensure nodes containing comp references are not published.
 */
function getty_images_node_presave($node) {
  if (!$node->status) {
    return;
  }

  foreach ($node->body[$node->language] as $body) {
    if (preg_match('|https?://cache\d+\.asset-cache\.net|', $body['value'])) {
      drupal_set_message(t("You may not publish nodes containing Getty Images comps. This node has been set to unpublished."), 'warning');
      $node->status = NODE_NOT_PUBLISHED;
      return;
    }
  }
}

/**
 * Implements hook_element_info().
 *
 * Re-use mostly the filefield_source_remote functionality.
 * but add some getty images layers.
 */
function getty_images_element_info() {
  return array(
    'getty_download' => array(
      '#input' => FALSE,
      '#process' => array('getty_images_attach_form',
        'filefield_source_remote_process', 'getty_images_download_process'),
      '#pre_render' => array('file_managed_file_pre_render'),
      '#theme_wrappers' => array('form_element'),
      '#progress_indicator' => 'throbber',
      '#progress_message' => NULL,
      '#upload_validators' => array(),
      '#upload_location' => NULL,
      '#extended' => FALSE,
    ));
}

/**
 * Fake field_attach_form.
 */
function getty_images_attach_form($element, &$form_state, $form) {
  list( , , $bundle) = entity_extract_ids($form['#entity_type'], $form['#entity']);

  $element['#bundle'] = $bundle;
  $element['#entity_type'] = $form['#entity_type'];
  $element['#field_name'] = 'getty_download';
  $element['#delta'] = 0;

  return $element;
}

/**
 * Flag whether or not we want to add our own callback command.
 */
function _getty_images_download_callback($callback_data = NULL) {
  static $download_callback;

  if ($callback_data) {
    $download_callback = $callback_data;
  }

  return $download_callback;
}

/**
 * Trigger a jQuery event, getty-download-finished on the body element.
 */
function getty_images_page_delivery_callback_alter(&$delivery_callback) {
  $callback_data = _getty_images_download_callback();

  if (!$callback_data) {
    return;
  }

  $delivery_callback = 'getty_images_delivery_callback';
}

/**
 * Getty Images Delivery Callback.
 */
function getty_images_delivery_callback($page_callback_result) {
  $callback_data = _getty_images_download_callback();

  $page_callback_result['#commands'][] = array('command' => 'gettyImagesDownloadComplete', 'data' => $callback_data);

  ajax_deliver($page_callback_result);
}

/**
 * Process download.
 */
function getty_images_process_download($form, &$form_state) {
  $element = $form['getty_images']['getty_images_download'];
  $image_url = $form_state['input']['url'];

  if (!valid_url($image_url)) {
    return FALSE;
  }

  $meta_json = $form_state['input']['getty-image-meta'];

  $meta = json_decode($meta_json, TRUE);

  if (!isset($meta['ImageId'])) {
    return FALSE;
  }

  // Check that the destination is writable.
  $temporary_directory = 'temporary://';
  if (!file_prepare_directory($temporary_directory, FILE_MODIFY_PERMISSIONS)) {
    watchdog('file', 'The directory %directory is not writable, because it does not have the correct permissions set.', array('%directory' => drupal_realpath($temporary_directory)));
    drupal_set_message(t('The file could not be transferred because the temporary directory is not writable.'), 'error');
    return FALSE;
  }

  // Check that the destination is writable.
  $directory = 'getty-images';
  $mode = variable_get('file_chmod_directory', 0775);

  // This first chmod check is for other systems such as S3, which don't work
  // with file_prepare_directory().
  if (!drupal_chmod($directory, $mode) && !file_prepare_directory($directory, FILE_CREATE_DIRECTORY)) {
    watchdog('file', 'File %file could not be copied, because the destination directory %destination is not configured correctly.', array('%file' => $image_url, '%destination' => drupal_realpath($directory)));
    drupal_set_message(t('The specified file %file could not be copied, because the destination directory is not properly configured. This may be caused by a problem with file or directory permissions. More information is available in the system log.', array('%file' => $image_url)), 'error');
    return;
  }

  // Check the headers to make sure it exists and is within the allowed size.
  $ch = curl_init();
  curl_setopt($ch, CURLOPT_URL, $image_url);
  curl_setopt($ch, CURLOPT_HEADER, TRUE);
  curl_setopt($ch, CURLOPT_NOBODY, TRUE);
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, TRUE);
  curl_setopt($ch, CURLOPT_HEADERFUNCTION, '_filefield_source_remote_parse_header');
  // Causes a warning if PHP safe mode is on.
  @curl_setopt($ch, CURLOPT_FOLLOWLOCATION, TRUE);
  curl_exec($ch);
  $info = curl_getinfo($ch);
  if ($info['http_code'] != 200) {
    curl_setopt($ch, CURLOPT_HTTPGET, TRUE);
    $file_contents = curl_exec($ch);
    $info = curl_getinfo($ch);
  }
  curl_close($ch);

  if ($info['http_code'] != 200) {
    switch ($info['http_code']) {
      case 403:
        form_error($element, t('The remote file could not be transferred because access to the file was denied.'));
        break;

      case 404:
        form_error($element, t('The remote file could not be transferred because it was not found.'));
        break;

      default:
        form_error($element, t('The remote file could not be transferred due to an HTTP error (@code).', array('@code' => $info['http_code'])));
    }
    return;
  }

  // Grab the new $url variable to reflect any redirects.
  $url = $info['url'];
  $url_info = parse_url($url);

  // Determine the proper filename by reading the filename given in the
  // Content-Disposition header. If the server fails to send this header,
  // fall back on the basename of the URL.
  //
  // We prefer to use the Content-Disposition header, because we can then
  // use URLs like http://example.com/get_file/23 which would otherwise be
  // rejected because the URL basename lacks an extension.
  $filename = _filefield_source_remote_filename();
  if (empty($filename)) {
    $filename = rawurldecode(basename($url_info['path']));
  }

  $pathinfo = pathinfo($filename);

  // Create the file extension from the MIME header if all else has failed.
  if (empty($pathinfo['extension'])) {
    $pathinfo['extension'] = _filefield_source_remote_mime_extension();
  }

  if (empty($pathinfo['extension'])) {
    form_error($element, t('The remote URL must be a file and have an extension.'));
    return;
  }

  // Figure out the correct download size.
  foreach ($meta['SizesDownloadableImages'] as $size_info) {
    if ($size_info['SizeKey'] == $meta['DownloadSizeKey']) {
      $download_size = $size_info;
    }
  }

  if (!isset($download_size)) {
    form_error($element, t("Couldn't determine proper download size"));
    return;
  }

  // Start building the file record.
  $record = array(
    'size_key' => $meta['DownloadSizeKey'],
    'image_id' => $meta['ImageId'],
    'width' => (int) $download_size['PixelWidth'],
    'height' => (int) $download_size['PixelHeight'],
  );

  // Make the filename {ImageId}-{PixelWidth}x{PixelHeight}.{extension}.
  $filename = $pathinfo['filename'] . '-' . $record['width'] . 'x' . $record['height'] . '.' . $pathinfo['extension'];

  // Validate, then create the file.
  $filename = filefield_sources_clean_filename($filename, '');
  $filepath = file_create_filename($filename, $temporary_directory);

  // Perform basic extension check on the file before trying to transfer.
  $extensions = 'jpg jpeg png';
  $regex = '/\.(' . preg_replace('/[ +]/', '|', preg_quote($extensions)) . ')$/i';
  if (!empty($extensions) && !preg_match($regex, $filename)) {
    form_error($element, t('Only files with the following extensions are allowed: %files-allowed.', array('%files-allowed' => $extensions)));
    return;
  }

  // Set transfer options.
  $options = array(
    'key' => $element['#entity_type'] . '_' . $element['#bundle'] . '_' . $element['#field_name'] . '_' . $element['#delta'],
    'filepath' => $filepath,
  );
  filefield_source_remote_set_transfer_options($options);

  $transfer_success = FALSE;
  // If we've already downloaded the entire file because the header-retrieval
  // failed, just save the contents we have.
  if (isset($file_contents)) {
    if ($fp = @fopen($filepath, 'w')) {
      fwrite($fp, $file_contents);
      fclose($fp);
      $transfer_success = TRUE;
    }
  }
  // If we don't have the file contents, download the actual file.
  else {
    $ch = curl_init();
    curl_setopt($ch, CURLOPT_URL, $url);
    curl_setopt($ch, CURLOPT_HEADER, FALSE);
    curl_setopt($ch, CURLOPT_WRITEFUNCTION, 'filefield_source_remote_curl_write');
    // Causes a warning if PHP safe mode is on.
    @curl_setopt($ch, CURLOPT_FOLLOWLOCATION, TRUE);
    $transfer_success = curl_exec($ch);
    curl_close($ch);
  }

  if (!$transfer_success) {
    return FALSE;
  }

  $file = filefield_sources_save_file($filepath, array(), 'public://getty-images');

  if (!$file) {
    return FALSE;
  }

  // Strip the meta down to invariant, pertinent bits.
  $stored_meta = array_intersect_key($meta, array_flip(array(
    'Artist', 'Caption', 'CollectionId', 'CollectionName', 'ColorType',
    'DateCreated', 'DateSubmitted', 'EditorialSegments', 'EditorialSourceName',
    'LicensingModel', 'GraphicStyle', 'Orientations', 'QualityRank', 'Title',
    'ReferralDestinations', 'MaxResolutionWidth', 'MaxResolutionHeight',
    'Copyright', 'Restrictions', 'Status', 'ArtistTitle', 'CreditLine', 'City',
    'StateProvince', 'Country')
  ));
  unset($size_info);

  // Fill out the rest of the file record and save it.
  $record['fid'] = $file->fid;
  $record['meta'] = json_encode($stored_meta);
  $record['downloaded'] = time();

  drupal_write_record('getty_images', $record);

  // Make sure our file sticks around.
  $file->status = FILE_STATUS_PERMANENT;
  file_save($file);

  // Make sure the usage information is stored.
  file_usage_add($file, 'file', $form['#entity_type'], 0);

  // And has some usage.
  @unlink($filepath);

  // Send back the file record via an AJAX command.
  _getty_images_download_callback(_getty_images_populate_file($record));

  return TRUE;
}

/**
 * Populate extra properties from the file ID.
 */
function _getty_images_populate_file($record) {
  // Use size key as primary.
  $record['id'] = $record['size_key'];
  $record['file'] = (array) file_load($record['fid']);
  $record['url'] = file_create_url($record['file']['uri']);

  return $record;
}

/**
 * Process form element for download form.
 */
function getty_images_download_process($element, &$form_state, $form) {
  $element['filefield_remote']['transfer']['#submit'] = array('filefield_sources_field_submit', 'getty_images_process_download');
  $element['filefield_remote']['transfer']['#ajax']['event'] = 'getty-images-download';
  $element['filefield_remote']['transfer']['#ajax']['callback'] = 'getty_images_after_download_callback';

  unset($element['filefield_remote']['transfer']['#ajax']['progress']);

  $element['getty-image-meta'] = array(
    '#type' => 'hidden',
  );

  return $element;
}

/**
 * Process form element for file field source.
 */
function getty_images_filefield_source_process($element, &$form_state, $form) {
  if (!getty_images_load_assets()) {
    return $element;
  }

  $element['getty_images'] = array(
    '#weight' => 100.6,
    // So this is hidden when a file is attached.
    '#filefield_source' => TRUE,
    '#theme' => 'getty_images_select_attach_element',
  );

  $element['getty_images']['select'] = array(
    '#name' => implode('_', $element['#array_parents']) . '_select',
    '#type' => 'submit',
    '#value' => t("Search using Getty Images"),
    '#validate' => array(),
    '#attributes' => array(
      'class' => array('getty-images-select'),
      'data-getty-images-context' => 'image_field',
      'data-getty-images-id' => $element['#id']),
    '#limit_validation_errors' => array($element['#parents']),
    '#submit' => array('filefield_sources_field_submit'),
    '#ajax' => array(
      // The UI will send this event when an image is selected.
      'event' => 'getty-images-select',
      'path' => 'file/ajax/' . implode('/', $element['#array_parents']) . '/' . $form['form_build_id']['#value'],
      'wrapper' => $element['#id'] . '-ajax-wrapper',
      'effect' => 'fade',
    ),
  );

  $element['getty_images']['fid'] = array(
    '#type' => 'hidden',
  );

  return $element;
}

/**
 * Simple selection AJAX callback.
 */
function getty_images_select_callback($form, $form_state) {
  return $form;
}

/**
 * Possibly attach a fid to this if an image is selected.
 */
function getty_images_filefield_source_value($element, &$item) {
  if (isset($item['getty_images']['fid']) && !empty($item['getty_images']['fid'])) {
    // Remove file size restrictions, since the file already exists on disk.
    if (isset($element['#upload_validators']['file_validate_size'])) {
      unset($element['#upload_validators']['file_validate_size']);
    }

    $file = file_load($item['getty_images']['fid']);

    if ($file && filefield_sources_element_validate($element, (object) $file)) {
      $item = array_merge($item, (array) $file);
    }
  }
}

/**
 * Implements hook_theme().
 */
function getty_images_theme() {
  return array(
    'getty_images_select_attach_element' => array(
      'render element' => 'element',
    ),
  );
}

/**
 * Render the selection widget for this module.
 */
function theme_getty_images_select_attach_element($variables) {
  $element = $variables['element'];

  return '<div class="filefield-source filefield-source-gettyimages clear-block">' . drupal_render($element['fid']) . '<span class="field-suffix">' . drupal_render($element['select']) . '</span></div>';
}

/**
 * Handle AJAX requests.
 *
 * Emits a JSON structure along with the proper HTTP Content-Type header.
 *
 * {
 *  success: bool,
 *  message: string,
 *  data: object
 * }
 */
function getty_images_ajax() {
  $components = func_get_args();

  if (empty($components)) {
    return;
  }

  $action = (string) array_shift($components);

  $result = array(
    'success' => FALSE,
    'message' => '',
    'data' => array(),
  );

  switch ($action) {
    case 'details':
      if (empty($components)) {
        $result['message'] = "Missing ImageId";
      }
      else {
        $image_id = array_shift($components);

        // Figure out which files we have.
        $image_records = db_select('getty_images', 'gi')->fields('gi')->condition('image_id', $image_id)->execute();

        // Populate 'data' with the result.
        while ($image_record = $image_records->fetchAssoc()) {
          $result['data'][] = _getty_images_populate_file($image_record);
          $result['success'] = TRUE;
        }
      }

      break;

  }

  drupal_add_http_header('Content-Type', 'application/json; charset=utf-8');
  echo json_encode($result);
}

/**
 * Getty Images Load Assets.
 */
function getty_images_load_assets() {
  static $scripts_added = FALSE;

  if ($scripts_added) {
    return TRUE;
  }

  if (!getty_images_detect_js_libraries()) {
    return FALSE;
  }

  $libraries = getty_images_libraries_info();

  foreach (array_keys($libraries) as $library_name) {
    libraries_load($library_name);
  }

  drupal_add_css(drupal_get_path('module', 'getty_images') . '/getty-images.css', 'file');

  $dependencies = array(
    // Omniture.
    'js/s_code.js',
    // Utility.
    'getty-images.js',
    // Models.
    'js/getty-models.js',
    // Views.
    'js/getty-views.js',
    // Data filters (Also views).
    'js/getty-filters.js',
    // Main.
    'js/getty-main.js',
  );

  foreach ($dependencies as $dependency) {
    drupal_add_js(drupal_get_path('module', 'getty_images') . '/' . $dependency, array(
      'type' => 'file',
      'scope' => 'footer',
    ));
  }

  drupal_add_js(array(
    'gettyImages' => array(
      'settings' => array(
        'templates' => base_path() . 'getty_images/templates',
        'ajax' => base_path() . 'getty_images/ajax',
      ),
      'text' => array(
        // Getty Images search field placeholder.
        'searchPlaceholder' => t("Enter keywords..."),
        // Search button text.
        'search' => t("Search"),
        // 'Refine' collapsible link.
        'refine' => t("Refine"),
        // Search refinement field placeholder.
        'refinePlaceholder' => t("Search within..."),
        // Search only within these categories.
        'refineCategories' => t("Refine categories"),
        // This will be used as the default button text.
        'title'  => t("Getty Images"),
        // This will be used as the default button text.
        'button' => t("Insert Image"),

        // Downloading...
        'authorizing' => t("Authorizing..."),
        'downloading' => t("Downloading..."),
        'remaining' => t("remaining"),
        'free' => t("free"),

        // Results.
        'oneResult' => t("%d result"),
        'results' => t("%d results"),
        'noResults' => t("Sorry, we found zero results matching your search."),

        // Full Sized images.
        'fullSize' => t('Full Size'),
        'recentlyViewed' => t("Recently Viewed"),

        // Image download.
        'downloadImage' => t("Download Image"),
        'reDownloadImage' => t("Download Again"),

        // Frame toolbar buttons.
        'copyComp' => t("Copy Comp HTML to clipboard"),
        'embedImage' => t("Copy Embed Image HTML to clipboard"),
        'insertImage' => t("Copy Image HTML to clipboard"),
        'selectImage' => t("Select Image"),
        'useImage' => t("Use this Image"),

        'embedCopied' => t("Getty Images embed code copied to clipboard. Paste in text field using Ctrl-v or Cmd-v."),
        'imageCopied' => t("Getty Images image HTML code copied to clipboard. Paste in text field using Ctrl-v or Cmd-v."),

        // Filters.
        'assetType' => t("Asset Type"),
        'editorial' => t("Editorial"),
        'creative' => t("Creative"),

        'imageType' => t("Image Type"),
        'photography' => t("Photography"),
        'illustration' => t("Illustration"),

        'orientation' => t("Orientation"),
        'horizontal' => t("Horizontal"),
        'vertical' => t("Vertical"),

        'excludeNudity' => t("Exclude Nudity?"),

        'sortOrder' => t("Sort Order"),
        'mostPopular' => t("Most Popular"),
        'mostRecent' => t("Most Recent"),

        'bestMatch' => t("Best Match"),
        'newest' => t("Newest"),
      ),
    ),
  ), array('group' => JS_LIBRARY, 'weight' => -5, 'type' => 'setting'));

  return $scripts_added = TRUE;
}

/**
 * Implements hook_libraries_info().
 *
 * For defining external libraries.
 */
function getty_images_libraries_info() {
  // Expected to be extracted into 'sites/all/libraries/underscore'.
  $libraries['underscore'] = array(
    'name' => 'Underscore.js',
    'vendor url' => 'http://underscorejs.org',
    'download url' => 'http://underscorejs.org',
    'version arguments' => array(
      // Could be any file with version info.
      'file' => 'underscore-min.js',
      'pattern' => '/Underscore\.js ([\d.]+)/',
      'lines' => 5,
    ),
    'files' => array(
      'js' => array('underscore-min.js'),
    ),
  );

  // Expected to be extracted into 'sites/all/libraries/backbone'.
  $libraries['backbone'] = array(
    'name' => 'Backbone.js',
    'vendor url' => 'http://backbonejs.org',
    'download url' => 'http://backbonejs.org',
    'version arguments' => array(
      // Could be any file with version info.
      'file' => 'backbone-min.js',
      'pattern' => '/e\.VERSION="([\d.]+)"/',
      'lines' => 5,
    ),
    'files' => array(
      'js' => array('backbone-min.js'),
    ),
  );

  // Expected to be extracted into 'sites/all/libraries/spinjs'.
  $libraries['spinjs'] = array(
    'name' => 'Spin.js',
    'vendor url' => 'http://fgnass.github.io/spin.js/',
    'download url' => 'http://fgnass.github.io/spin.js/',
    'version arguments' => array(
      'file' => 'spin.min.js',
      'pattern' => '/spin.js#v([\d.]+)/',
      'lines' => 2,
    ),
    'files' => array(
      'js' => array('spin.min.js'),
    ),
  );

  // Expected to be extracted into 'sites/all/libraries/jquery-cookie'.
  $libraries['jquery-cookie'] = array(
    'name' => 'jQuery Cookie',
    'vendor url' => 'https://github.com/carhartl/jquery-cookie',
    'download url' => 'http://plugins.jquery.com/cookie/',
    'version arguments' => array(
      'file' => 'jquery.cookie.js',
      'pattern' => '/jQuery Cookie Plugin v([\d.]+)/',
      'lines' => 5,
    ),
    'files' => array(
      'js' => array('jquery.cookie.js'),
    ),
  );

  return $libraries;
}

/**
 * Detect that required JS libraries are present. Set messages if not.
 *
 * @return bool
 *   Whether or not JS dependencies are present.
 */
function getty_images_detect_js_libraries() {
  $warned = &drupal_static(__FUNCTION__, FALSE);

  $result = TRUE;
  $libraries = getty_images_libraries_info();

  foreach ($libraries as $library_name => $info) {
    $library = libraries_detect($library_name);

    if (!$library || !$library['installed']) {
      if (!$warned) {
        drupal_set_message($info['name'] . " library required to use the Getty Images module.", 'warning');
      }

      $result = FALSE;
    }
    elseif ($library['name'] == 'Underscore.js' && $library['version'] != '1.6.0') {
      drupal_set_message($info['name'] . "  1.6.0 is required to use the Getty Images module.", 'warning');

      $result = FALSE;
    }
  }

  $warned = TRUE;

  return $result;
}

/**
 * Implements hook_form_alter().
 */
function getty_images_form_alter(&$form, &$form_state, $form_id) {
  if (!isset($form_state['build_info']['base_form_id'])) {
    return;
  }

  if ($form_state['build_info']['base_form_id'] == 'node_form') {
    if (getty_images_load_assets()) {
      $form['getty_images'] = array(
        '#type' => 'container',
        '#attributes' => array('class' => array('getty-images-tab')),
        '#field_name' => 'getty_images',
        '#language' => $form['language']['#value'],
        '#field_parents' => '',
        'getty_images_logo' => array(
          '#type' => 'markup',
          '#markup' => '<div class="getty-images-logo"><a href="javascript:void(0)" class="getty-images-select" title="Select and embed images from Getty Images"></a></div>',
        ),
      );

      $form['getty_images']['getty_images_download'] = array(
        '#type' => 'getty_download',
        '#file_upload_delta' => 0,
        '#suffix' => '',
      );
    }
  }
}
