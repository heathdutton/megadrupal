<?php

/**
 * @file
 * Implementation main functionalities of Mongodb indexer.
 *
 * Note: MongoDB server's settings must be configured in settings.php
 */

/**
 * Define some string to be used in index process.
 */
define("MONGODB_INDEXER_INDEX_TYPE_UPSERT", "upsert");
define("MONGODB_INDEXER_INDEX_TYPE_DELETE", "delete");

/**
 * Define default batch size.
 */
define("MONGODB_INDEXER_DEFAULT_BATCH_SIZE", 500);

/**
 * Implements hook_menu().
 */
function mongodb_indexer_menu() {
  $items = array();
  $items['admin/config/search/mongodb-indexer'] = array(
    'title'            => 'Mongodb Indexer',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('mongodb_indexer_settings'),
    'access arguments' => array('administer search'),
  );

  return $items;
}

/**
 * Setting form.
 */
function mongodb_indexer_settings($form, &$form_state) {
  $form = array();
  // Check if settings are fine.
  $mongo_client = mongodb_indexer_get_mongodb_client();
  if (!$mongo_client) {
    drupal_set_message(t("Unable to connect to mongdb. Please check your settings."), "error");
  }
  else {
    drupal_set_message(t("Connections to MongoDB are fine."));
  }

  // Mongodb settings.
  $form['mongodb_settings'] = array(
    '#type' => 'fieldset',
    '#title' => 'Mongodb settings',
    '#collapsible' => TRUE,
  );

  $form['mongodb_settings']['mongodb_indexer_index_immediately'] = array(
    '#type' => 'checkbox',
    '#title' => t('Index items immediately'),
    '#description' => t('Index items immediately or wait until next cron run. It might cause issues for large sites when this is checked.'),
    '#default_value' => variable_get('mongodb_indexer_index_immediately', FALSE),
  );
  $form['mongodb_settings']['mongodb_indexer_items_per_cron_run'] = array(
    '#type' => 'select',
    '#title' => 'Number of items to index per cron run',
    '#description' => t('Higher number could make index operation faster but could also cause timeout and memory limit error.'),
    '#options' => array(
      10 => 10,
      20 => 20,
      50 => 50,
      100 => 100,
      200 => 200,
      500 => 500,
    ),
    '#default_value' => variable_get('mongodb_indexer_items_per_cron_run', 50),
  );

  // Entity selector to select which entity should be indexed.
  $form['selected_entity'] = array(
    '#type' => 'fieldset',
    '#title' => t('Select contents to index'),
    '#description' => t('Different entity types are saved into separated collections.'),
    '#collapsible' => TRUE,
  );

  $options = mongodb_indexer_get_entity_options();
  $default_values = variable_get("mongodb_indexer_selected_entity_bundle", array());
  $form['selected_entity']['mongodb_indexer_selected_entity_bundle'] = array(
    '#type' => 'checkboxes',
    '#options' => $options,
    '#default_value' => $default_values,
  );

  return system_settings_form($form);
}

/**
 * Get the options for entity selector checkboxes.
 *
 * This function will format key of the return array as ENTITY_TYPE*BUNDLE.
 *
 * @return array
 *   list of entity to be used for entity_bundle checkboxes
 */
function mongodb_indexer_get_entity_options() {
  $entity_info = entity_get_info();
  $return_array = array();

  foreach ($entity_info as $key => $val) {
    // Some entity doesn't need bundle selector.
    if (in_array($key, mongodb_indexer_get_entity_without_bundle_support())) {
      $return_array[$key] = $val['label'];
      continue;
    }
    foreach ($val['bundles'] as $bundle_key => $bundle) {
      $return_key = $key . "*" . $bundle_key;
      $return_val = $bundle['label'] . " of entity type " . $val['label'];
      $return_array[$return_key] = $return_val;
    }
  }
  ksort($return_array);
  return $return_array;
}

/**
 * Get list of entities without bundle support.
 *
 * There is entity like comment that does not support bundle conditions.
 * And also Those that are ussually don't have many bundles.
 *
 * @return array
 *   list of entity to be excluded from bundle index selector.
 */
function mongodb_indexer_get_entity_without_bundle_support() {
  return array('comment', 'taxonomy_vocabulary', 'file', 'user');
}

/**
 * Get static mongodb client object.
 *
 * @return object
 *   The mongo client object or false if can't create the object
 */
function mongodb_indexer_get_mongodb_client() {
  static $mongodb_client_object;
  $mongodb_settings = variable_get('mongodb_indexer_settings', array());
  if (empty($mongodb_settings) || empty($mongodb_settings['hosts'])) {
    return FALSE;
  }

  $connection_string = "mongodb://" . implode(",", $mongodb_settings['hosts']);
  $options = !empty($mongodb_settings['options']) ? $mongodb_settings['options'] : array();

  try {
    if (!isset($mongodb_client_object)) {
      $mongodb_client = new MongoClient($connection_string, $options);
      $mongodb_client_object = $mongodb_client;
    }
  }
  catch (Exception $e) {
    watchdog("mongodb_indexer", $e->getMessage(), array(), WATCHDOG_ERROR);
    return FALSE;
  }
  return $mongodb_client_object;
}

/**
 * Get a mongodb collection object.
 *
 * @param string $collection_name
 *   Name of the collection.
 *
 * @return object
 *   Mongodb Collection object. False if can not connect.
 */
function mongodb_indexer_get_mongodb_collection($collection_name) {
  static $collection;
  if (!isset($collection[$collection_name])) {
    try {
      $mongodb_client = mongodb_indexer_get_mongodb_client();
      if (!$mongodb_client) {
        throw new Exception("Unable to connect to mongodb.");
      }
      // Get the db from settings.
      $mongodb_settings = variable_get('mongodb_indexer_settings', array());
      $db = isset($mongodb_settings['db']) ? $mongodb_settings['db'] : '';
      // Select the collection.
      $collection[$collection_name] = $mongodb_client->selectCollection($db, $collection_name);
    }
    catch (Exception $e) {
      watchdog("mongodb_indexer", $e->getMessage(), array(), WATCHDOG_ERROR);
      return FALSE;
    }
  }

  return $collection[$collection_name];
}

/**
 * Returns the name of the collection for the given entity type and bundle.
 *
 * @param string $entity_type
 *  Entity type.
 *
 * @param string $bundle
 *  Bundle name. Optional
 *
 * @return string
 *   Collection name of format entity_type.bundle or entity_type (if bundle not given).
 */
function _mongodb_indexer_get_collection_name($entity_type, $bundle = FALSE) {
  $collection_name = $entity_type;
  if ($bundle && !in_array($entity_type, mongodb_indexer_get_entity_without_bundle_support()) && $entity_type != $bundle) {
    $collection_name .= ".$bundle";
  }

  return $collection_name;
}

/**
 * Update or insert a document to mongodb.
 *
 * @param string $collection_name
 *   Name of the collection.
 * @param int $document_id
 *   Mongodb document _id.
 * @param array $document
 *   Array of fields data to be updated/inserted.
 *
 * @return Misc
 *   Result return by the operation. False if fail.
 */
function mongodb_indexer_upsert_document($collection_name, $document_id, array $document) {
  $collection = mongodb_indexer_get_mongodb_collection($collection_name);

  if (!$collection) {
    return FALSE;
  }

  // Construct options for mongodb operation.
  $options = array(
    "upsert" => TRUE,
  );

  try {
    $result = $collection->update(
      array("_id" => intval($document_id)),
      array('$set' => $document),
      $options
    );
    return $result;
  }
  catch (Exception $e) {
    $error_message = "Error indexing item id:" . $document_id . " of collection:" . $collection_name . ". The error message was:" . $e->getMessage();
    watchdog("mongodb_indexer", $error_message, array(), WATCHDOG_ERROR);
    return FALSE;
  }
}

/**
 * Delete a document from mongodb.
 *
 * @param string $collection_name
 *   Name of the collection.
 * @param int $document_id
 *   Mongodb document _id.
 *
 * @return Misc
 *   Result return by the operation. False if fail.
 */
function mongodb_indexer_delete_document($collection_name, $document_id) {
  $collection = mongodb_indexer_get_mongodb_collection($collection_name);
  if (!$collection) {
    return FALSE;
  }
  try {
    $result = $collection->remove(
      array(
        '_id' => intval($document_id),
      )
    );
    return $result;
  }
  catch (Exception $e) {
    $error_message = "Error deleting item id:" . $document_id . " of collection:" . $collection_name . ". The error message was:" . $e->getMessage();
    watchdog("mongodb_indexer", $error_message, array(), WATCHDOG_ERROR);
    return FALSE;
  }
}

/**
 * Create indexes for a collection.
 *
 * This function check which version of PHP MongoDB Driver is being used. Then
 * it will call to coresponding method.
 *
 * @param string $collection_name
 *   Name of the collection.
 * @param array $keys
 *   An array specifying the index's fields as its keys.
 * @param array $options
 *   An array of options for the index creation. Available options depend on
 *   your PHP MongoDB Driver. Check PHP.net for more info.
 */
function mongodb_indexer_create_indexes($collection_name, array $keys, array $options = array()) {
  $collection = mongodb_indexer_get_mongodb_collection($collection_name);
  if (version_compare(MongoClient::VERSION, '1.5.0') < 0) {
    // Use the deprecated method.
    // http://php.net/manual/en/mongocollection.ensureindex.php.
    $collection->ensureIndex($keys, $options);
  }
  else {
    // Use new method.
    // http://php.net/manual/en/mongocollection.createindex.php.
    $collection->createIndex($keys, $options);
  }
}

/**
 * Check if an entity is of selected entity bundle to index.
 *
 * @param object $entity
 *   The entity to check.
 * @param string $type
 *   The entity's type.
 *
 * @return bool
 *   True/False on valid/invalid.
 */
function mongodb_indexer_is_valid_to_index($entity, $type) {
  // Get a list of selected entity.
  $selected_entity_bundle = mongodb_indexer_get_selected_entity_bundle();
  if (empty($selected_entity_bundle)) {
    return FALSE;
  }
  // Get id and bundle.
  list(, , $bundle) = entity_extract_ids($type, $entity);

  $needle = array(
    "entity_type" => $type,
    "bundle" => $bundle,
  );

  $no_bundle_support_entity = mongodb_indexer_get_entity_without_bundle_support();
  if (in_array($type, $no_bundle_support_entity)) {
    $needle['bundle'] = FALSE;
  }

  // Now we start checking.
  if (!in_array($needle, $selected_entity_bundle)) {
    return FALSE;
  }
  else {
    return TRUE;
  }
}

/**
 * Mark an item as need to be indexed.
 *
 * This function add the item to the indexer queue.
 *
 * @param object $entity
 *   The entity to be marked as need to index.
 * @param string $type
 *   The entity's type.
 * @param string $queue_type
 *   The queue type:
 *   MONGODB_INDEXER_INDEX_TYPE_UPSERT.
 *   MONGODB_INDEXER_INDEX_TYPE_DELETE.
 *
 * @return boll
 *   True/False on success/error
 */
function mongodb_indexer_mark_item_change($entity, $type, $queue_type) {
  static $shutdown_registered = FALSE;
  static $enqueued = array();

  // Check if this item is valid to be indexed.
  if (!mongodb_indexer_is_valid_to_index($entity, $type)) {
    return FALSE;
  }

  // Contruct object to be saved as queue item
  // each queue should have information about the entity to be indexed
  // For example: entity_id, entity_type, bundle and queue_type
  list($entity_id, , $bundle) = entity_extract_ids($type, $entity);
  if (!isset($entity_id) || !isset($bundle)) {
    return FALSE;
  }

  // Enqueue items only once per page load.
  if (!empty($enqueued["$type-$entity_id-$queue_type"])) {
    return TRUE;
  }

  $item = new stdClass();
  $item->entity_type = $type;
  $item->bundle = $bundle;
  $item->entity_id = $entity_id;
  $item->queue_type = $queue_type;
  $queue = DrupalQueue::get("mongodb_indexer_items");
  $queue->createQueue();
  $result = $enqueued["$type-$entity_id-$queue_type"] = $queue->createItem($item);

  // Register a shutdown function to process
  // changed items after everything else is done.
  $index_immediately = variable_get('mongodb_indexer_index_immediately', FALSE);
  // Register shutdown if index immediately is TRUE
  // and do it once.
  if (!$shutdown_registered && $index_immediately) {
    drupal_register_shutdown_function("mongodb_indexer_index_queued_items");
    $shutdown_registered = TRUE;
  }

  return $result;
}

/**
 * Mark items as need to reindex.
 *
 * This function adds the items to the reindexer queue
 * mongodb_indexer_reindex_items
 *
 * @param array $items
 *   List of items to be reindexed.
 *   Each item must have entity_id and entity_type.
 *
 * @return bool
 *   True/False on success/error
 */
function mongodb_indexer_mark_items_reindex(array $items) {
  $items_to_reindex = array();
  foreach ($items as $item) {
    if (isset($item['entity_type']) && isset($item['entity_id'])) {
      // Now the item should be legit.
      $items_to_reindex[] = $item;
    }
  }

  // Create a queue.
  $item = new stdClass();
  $item->items = $items_to_reindex;
  $queue = DrupalQueue::get("mongodb_indexer_reindex_items");
  $queue->createQueue();
  $result = $queue->createItem($item);

  return $result;
}

/**
 * Index a single batch of items in the queue mongodb_indexer_reindex_items.
 *
 * Should be called from a cron or batch.
 *
 * @return Mixed
 *   Integer The number of items that were successfully reindexed.
 *   Boolean FALSE if no item could be claimed from the queue
 *   (possibly signifying that it is empty).
 */
function mongodb_indexer_index_queued_reindex_items() {
  // Get items from queue => convert to documents => then index them.
  // Get queue info.
  $queue = DrupalQueue::get("mongodb_indexer_reindex_items");

  // The return value will be FALSE if no item could be claimed
  // from the queue.
  $result = FALSE;

  // Claim an item from the queue.
  // A single queue item can contain multiple entities need to be reindexed.
  $item = $queue->claimItem();
  if ($item) {
    // If the queue item was claimed successfully, the return value should be
    // an integer showing the number of items successfully indexed.
    $result = 0;

    // Get the queue data.
    $data = $item->data;
    // Loop through data to process entities.
    if (!empty($data->items)) {
      foreach ($data->items as $row) {
        // Get some data to be used later.
        $entity_type = $row['entity_type'];
        $entity_id = $row['entity_id'];
        $bundle = $row['bundle'];

        //We use entity_type.bundle as collection name, usually.
        $collection_name = _mongodb_indexer_get_collection_name($entity_type, $bundle);

        // Load the entity.
        $entity = entity_load($entity_type, array($entity_id), array(), TRUE);
        $entity = $entity ? reset($entity) : FALSE;

        if (empty($entity)) {
          continue;
        }

        // Convert to mongodb document.
        $document = mongodb_indexer_convert_entity_to_mongodb_document($entity, $entity_type);
        // Save it.
        if ($document) {
          $document = mongodb_indexer_prepare_document_for_update($document);
          $update_index_result = mongodb_indexer_upsert_document($collection_name, $entity_id, $document);
          if ($update_index_result !== FALSE) {
            // This entity was indexed without an error.
            // Increase the number of successfully indexed entities.
            $result++;
          }
        }
      }
    }
    // Everything is done, remove item form queue.
    $queue->deleteItem($item);
  }

  return $result;
}


/**
 * Index predefined anount of items in the queue mongodb_indexer_items.
 *
 * This function should be called from a cron or shut down function.
 * The amount of items to be processed are based on setting variable
 * "mongodb_indexer_items".
 *
 * @return int
 *   Total items processed.
 */
function mongodb_indexer_index_queued_items() {
  // Get item from queue => convert to document => then index it.
  // Get queue info.
  $queue = DrupalQueue::get("mongodb_indexer_items");
  $limit_per_run = variable_get('mongodb_indexer_items_per_cron_run', 50);
  $total_processed = 0;
  // Loop and claim items until we've got nothing else todo
  // OR has reached the limit.
  while (($item = $queue->claimItem()) && $total_processed < $limit_per_run) {
    // Get the queue data.
    $data = $item->data;
    // Get some data to be used later.
    // Notes: we use entity type as collection name.
    $entity_type = $data->entity_type;
    $entity_id = $data->entity_id;
    $bundle = $data->bundle;

    $collection_name = _mongodb_indexer_get_collection_name($entity_type, $bundle);

    // When an item got deleted all we need to do is sending request
    // to delete it from mongodb.
    if ($data->queue_type == MONGODB_INDEXER_INDEX_TYPE_DELETE) {
      $success = mongodb_indexer_delete_document($collection_name, $entity_id);
      if ($success) {
        // Done deleting from mongodb, remove item form queue.
        $queue->deleteItem($item);
        $total_processed++;
      }
      continue;
    }

    // Continue if queue type is not delete.
    $entity = entity_load($entity_type, array($entity_id), array(), TRUE);
    $entity = $entity ? reset($entity) : FALSE;

    if (empty($entity)) {
      // Can't load entity, it must have been deleted.
      // Just delete from queue.
      $queue->deleteItem($item);
      continue;
    }

    // Convert to mongodb document.
    $document = mongodb_indexer_convert_entity_to_mongodb_document($entity, $entity_type);

    $success = FALSE;
    // Save it according to $data->queue_type.
    if ($document) {
      // Save it to it's own collection with the name is entity type.
      $document = mongodb_indexer_prepare_document_for_update($document);
      $success = mongodb_indexer_upsert_document($collection_name, $entity_id, $document);
    }

    // Done, remove item form queue if operation was a success.
    if ($success) {
      $queue->deleteItem($item);
      $total_processed++;
    }
  }

  return $total_processed;
}

/**
 * Convert mongo document object to array.
 *
 * To be used with MongoCollection::update. Any fields that are not changed
 * can be unset in this function to reduce data sending mongodb.
 *
 * @param object $document
 *   The document object to prepare.
 *
 * @return array
 *   The mongodb document array.
 *   False if the entity is not valid to be added as index.
 */
function mongodb_indexer_prepare_document_for_update($document) {
  // Remove _id.
  unset($document->_id);
  // Convert to array.
  $document = (array) $document;

  return $document;
}

/**
 * Convert an entity to mongo document.
 *
 * @param object $entity
 *   The entity to be converted.
 * @param string $entity_type
 *   The entity's type.
 *
 * @return object
 *   The mongodb document object.
 *   False if the entity is not valid to be added as index.
 */
function mongodb_indexer_convert_entity_to_mongodb_document($entity, $entity_type) {
  // Check if this item is valid to be indexed.
  if (!mongodb_indexer_is_valid_to_index($entity, $entity_type)) {
    // Return false to tell this entity is not valid to index.
    return FALSE;
  }

  // Convert entity to mongodb document.
  // Notes: only get fields and property.
  $document = new stdClass();
  // Get id, bundle to use later.
  list($entity_id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);
  if (!$entity_id) {
    return $document;
  }

  // Construct some initial data.
  $document->_id = intval($entity_id);
  $document->_bundle = $bundle;
  $document->_type = $entity_type;
  if (isset($vid)) {
    $document->revision_id = intval($vid);
  }
  $document->indexed_time = new MongoDate();

  // Get the entity properties and it's data.
  // Add the base table's fields to the new object.
  $entity_info = entity_get_info($entity_type);
  if (isset($entity_info['base table'])) {
    $table_schema = drupal_get_schema($entity_info['base table']);
    foreach ($table_schema['fields'] as $field_name => $column_definition) {
      if (isset($entity->$field_name)) {
        $document->$field_name = _mongodb_indexer_casting_storage_value($column_definition['type'], $entity->$field_name);
      }
    }
  }

  // Get the entity fields and their data.
  $fields_info = field_info_instances($entity_type, $bundle);
  foreach ($fields_info as $field_name => $value) {
    // Get field item to get value.
    $item = field_get_items($entity_type, $entity, $field_name);
    // Get field info to get field type.
    $field_info = field_info_field($field_name);
    $field_type = $field_info['type'];
    // Remove safe_value, we don't need it.
    // FIXME: find better way to do this.
    if (is_array($item)) {
      foreach ($item as $key => &$val) {
        if (isset($item[$key]['safe_value'])) {
          unset($item[$key]['safe_value']);
        }
        if (is_array($val)) {
          // Need to cast the field value to what it should be.
          foreach ($val as &$field_value) {
            $field_value = _mongodb_indexer_casting_storage_value($field_type, $field_value);
          }
        }
        else {
          $val = _mongodb_indexer_casting_storage_value($field_type, $val);
        }
      }
    }
    else {
      $item = _mongodb_indexer_casting_storage_value($field_type, $item);
    }

    if (isset($item) && !empty($item)) {
      $document->$field_name = $item;
    }
    else {
      $document->$field_name = NULL;
    }
  }

  // Notes: give change to other modules to act on this.
  module_invoke_all('mongodb_indexer_document_build', $document, $entity, $entity_type);
  return $document;
}

/**
 * Casting field storage value.
 *
 * @param string $type
 *   Type of field.
 * @param string $value
 *   Value of field.
 *
 * @return string
 *   Casted value
 */
function _mongodb_indexer_casting_storage_value($type, $value) {
  switch ($type) {
    case 'int':
    case 'serial':
    case 'entityreference':
    case 'number_integer':
    case 'list_boolean':
    case 'field_collection':
      return is_array($value) ? array_map('intval', $value) : intval($value);

    case 'float':
      return is_array($value) ? array_map('floatval', $value) : floatval($value);

    case NULL:
      return NULL;

    default:
      return $value;
  }
}

/**
 * Get selected entity and bundle to index in a more machine readable format.
 *
 * @return array
 *   List of entity and it's bundle that are valid to send to mongodb.
 */
function mongodb_indexer_get_selected_entity_bundle() {
  $selected_entity_bundle = variable_get("mongodb_indexer_selected_entity_bundle", array());
  if (empty($selected_entity_bundle)) {
    return array();
  }

  // The selected_entity_bundle is saved with key is ENTITY_TYPE*BUNDLE
  // OR just ENTITY_TYPE in some cases
  // Only pick those that are not 0
  $return_array = array();
  foreach ($selected_entity_bundle as $key => $val) {
    if ($val !== 0) {
      $entity_bundle_array = explode("*", $key);
      if (!empty($entity_bundle_array)) {
        $return_array[] = array(
          'entity_type' => array_shift($entity_bundle_array),
          'bundle' => !empty($entity_bundle_array) ? array_shift($entity_bundle_array) : FALSE,
        );
      }
    }
  }

  return $return_array;
}
/**
 * Creates and sets a batch for indexing items to mongodb.
 */
function _mongodb_indexer_batch_reindexing_create() {
  $batch = array(
    'title' => t('Reindexing items to mongodb'),
    'operations' => array(
      array('_mongodb_indexer_process_reindexing_batch', array()),
    ),
    'progress_message' => t('Completed: @current. Remaining approximately: @remaining.'),
    'finished' => '_mongodb_indexer_reindexing_batch_finished',
    'file' => drupal_get_path('module', 'mongodb_indexer') . '/mongodb_indexer.module',
  );
  batch_set($batch);
}

/**
 * Batch API callback for reindexing items to mongodb.
 *
 * @param array $context
 *   An array that will contain information about the
 *   status of the batch. The values in $context will retain their
 *   values as the batch progresses.
 */
function _mongodb_indexer_process_reindexing_batch(array &$context) {
  // Get the number of items remaining in the queue.
  $queue = DrupalQueue::get("mongodb_indexer_reindex_items");
  $queued_items_count = $queue->numberOfItems();

  if (!isset($context['sandbox']['current'])) {
    // This is the first time the batch operation is run.
    $context['sandbox']['current'] = 1;
    // Set the approximate number of total queued items to be processed.
    $context['sandbox']['total'] = $queued_items_count;
    // Set the approximate number of remaining items to be processed.
    // Count the current one assuming it will be processed successfully.
    $context['sandbox']['remaining'] = $queued_items_count - 1;
    // Store the total number of reindexed items.
    $context['results']['reindexed'] = 0;
  }
  else {
    // This is not the first time the batch operation is run.
    $context['sandbox']['current']++;
    // Set the new approximate number of remaining items.
    // Count the current one assuming it will be processed successfully.
    $context['sandbox']['remaining'] = $queued_items_count - 1;
  }

  // If the current batch process number is >= the total number of
  // queued items, perhaps the initial calculation is no longer valid.
  // It could be that new items have been added to the queue since
  // the batch was first started. Alternatively, this could be indeed
  // the last item to be processed but this cannot be guaranteed.
  // In these situations, increase the total number of items
  // to be more than the current item number.
  if ($context['sandbox']['current'] >= $context['sandbox']['total']) {
    $context['sandbox']['total'] = $context['sandbox']['current'] + 1;
  }

  // Claim a single item (containing an array of entities to be reindexed)
  // from the queue and reindex the entities.
  $reindex_result = mongodb_indexer_index_queued_reindex_items();

  // If there were no more items that could be claimed from the queue,
  // then the reindexing batch should stop.
  if ($reindex_result === FALSE) {
    $context['finished'] = 1;
  }
  else {
    // Increase the total number of reindexed items.
    $context['results']['reindexed'] += $reindex_result;

    $batch_message = '';
    if ($reindex_result == MONGODB_INDEXER_DEFAULT_BATCH_SIZE) {
      // The number of successfully indexed items is the maximum allowed one.
      $batch_message = "Successfully reindexed $reindex_result items.";
    }
    else {
      $batch_message = "Reindexed $reindex_result items, expected ";
      $batch_message .= MONGODB_INDEXER_DEFAULT_BATCH_SIZE . ". ";
      $batch_message .= "This is normal if this is the last batch of items to be reindexed.";
    }

    $context['message'] = $batch_message;

    // The operation needs to be repeated. There are probably more items
    // to be claimed from the queue. Provide an estimation about the progress.
    $context['finished'] = $context['sandbox']['current'] / $context['sandbox']['total'];
  }
}


/**
 * Batch API finishing callback for the mongodb reindexing functionality.
 *
 * @param bool $success
 *   Result of the batch operation.
 * @param array $results
 *   Results stored from the batch operations.
 * @param array $operations
 *   Remaining batch operation to process.
 */
function _mongodb_indexer_reindexing_batch_finished($success, array $results, array $operations) {
  if ($success) {
    if (!empty($results['reindexed'])) {
      drush_log("Successfully reindexed " . $results['reindexed'] . " items to mongodb.", "ok");
    }
    else {
      drush_log("Could not reindex any items to mongodb.", "warning");
    }
  }
  else {
    drush_log('An error occurred while reindexing items to mongodb.', "error");
  }
}

/**** Implements hooks starting from here ***/

/**
 * Implements hook_entity_insert().
 *
 * Marks the new item as to-index for all indexes on entities of the specified
 * type.
 */
function mongodb_indexer_entity_insert($entity, $type) {
  mongodb_indexer_mark_item_change($entity, $type, MONGODB_INDEXER_INDEX_TYPE_UPSERT);
}

/**
 * Implements hook_entity_update().
 *
 * Marks the item as changed for all indexes on entities of the specified type.
 */
function mongodb_indexer_entity_update($entity, $type) {
  mongodb_indexer_mark_item_change($entity, $type, MONGODB_INDEXER_INDEX_TYPE_UPSERT);
}

/**
 * Implements hook_entity_delete().
 *
 * Removes the item from the tracking table and deletes it from all indexes.
 */
function mongodb_indexer_entity_delete($entity, $type) {
  mongodb_indexer_mark_item_change($entity, $type, MONGODB_INDEXER_INDEX_TYPE_DELETE);
}

/**
 * Implements hook_field_attach_update().
 *
 * Marks the item as changed for all indexes on entities of the specified type.
 * Note that mark item changed function make sure no more than one queue of same
 * entity type can be created.
 */
function mongodb_indexer_field_attach_update($entity_type, $entity) {
  mongodb_indexer_mark_item_change($entity, $entity_type, MONGODB_INDEXER_INDEX_TYPE_UPSERT);
}

/**
 * Implements hook_cron().
 */
function mongodb_indexer_cron() {
  mongodb_indexer_index_queued_items();
  mongodb_indexer_index_queued_reindex_items();
}
