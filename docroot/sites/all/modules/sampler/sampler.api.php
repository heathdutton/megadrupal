<?php

/**
 * @file
 * API documentation for the Sampler API module.
 */

/**
 * An example of a plugin definition.
 *
 * This example shows a metric plugin.  The following approach is strongly
 * encouraged when writing a metric plugin:
 *
 *  - Design it to calculate results for samples generated by a specific sample
 *    method (eg, the 'periodic' method, or the 'random' method, but not both).
 *  - Note the method the plugin was written for in the documentation for the
 *    plugin.
 *  - Specify the method the metric should use in the plugin definition (eg.,
 *    'method' => 'random').  The API defaults to selecting the 'periodic'
 *    method if none is specified, so it's not strictly necessary to declare it
 *    in this case.
 *
 * For metrics, the main plugin should minimally contain the global variable
 * $plugin, which is an associative array containing some or all of the
 * following keys:
 *
 * - title:
 *     Human-readable title. Required.
 * - description:
 *     Human-readable description. Required.
 * - handler:
 *     An associative array describing the handler to CTools, with these keys:
 *     - class:
 *         The class name used to implement the metric. Required.
 *     - path:
 *         The path where the class file lives. Optional, defaults to the
 *         declared plugin directory.
 *     - file:
 *         The file where the class lives. Optional, defaults to
 *         [class_name].class.php.
 *     - parent:
 *         Only use this if you're extending the class of another plugin -- use
 *         the name of the parent plugin, not the name of the parent class.
 * - data_type:
 *     Schema API type used for storage. If not provided, defaults to a single
 *     integer value. Note that some storage plugins support passing an array
 *     of data types for multi-value storage. In this case, use an associative
 *     array, key is a single lower-case word describing the value, value is
 *     the Schema API data type, in the order you want the values stored.
 * - object_base_table:
 *     The table that the objects being tracked are primarily stored in. Used
 *     for views integration. Optional, defaults to 'node'. To declare the
 *     metric table itself as the base table, set this to FALSE.
 * - object_primary_key:
 *     The primary key that the objects being tracked use in the declared
 *     object_base_table. Used for views integration. Required if
 *     object_base_table is set to anything but FALSE. Defaults to 'nid'.
 * - default_options:
 *     An array of options to pass to the sampler. Available options will vary
 *     depending on the plugins being used, check the various plugins for
 *     specific details. For the default plugins, here are some common values:
 *     - time_unit:
 *         Unit of time used to sample for metrics. The strings 'day', 'week',
 *         and 'month' are supported, or for a custom time unit, pass an integer
 *         with the number of seconds in the unit. Defaults to week.
 *     - time_unit_interval:
 *         An integer representing the interval to count the time unit by,
 *         eg. if time_unit is week, and time_unit_interval is 2, sampling
 *         period would be every two weeks. Defaults to 1.
 *     - allow_single_sample_point:
 *         Boolean. If TRUE, allow a single sample point to proceed to
 *         calculation. Defaults to FALSE.
 *     - abort_timestamp:
 *         A timestamp. If set, and the last sample in the set is greater than
 *         time, the sample is aborted. Defaults to current time.
 * - non_metric:
 *     This special key can be set to indicate that a plugin in the plugin
 *     directory is not a metric -- useful for base class plugins that provide
 *     functionality for metric plugins.
 *
 * In order for the API to find your plugins, you must implement
 * hook_ctools_plugin_directory() properly -- see sampler.module and
 * sampler_example.module for example implementations of this hook.
 *
 * Note that can also implement adjustment, method, and storage plugins if
 * desired -- see the existing implementations for ideas on how to do this.
 */
$plugin = array(
  'title' => t('My metric'),
  'description' => t("Description for my metric."),
  'handler' => array(
    'class' => 'MyModuleMetricMyMetric',
    'path' => drupal_get_path('module', 'my_module') . '/metrics',
    'file' => 'MyModuleMetricMyMetric.class.php',
    'parent' => 'some_other_plugin_name',
  ),
  'data_type' => array(
    'terms' => 'int',
    'users' => 'int',
  ),
  'object_base_table' => 'taxonomy_vocabulary',
  'object_primary_key' => 'vid',
  'default_options' => array(
    'time_unit' => 'day',
    'time_unit_interval' => 15,
  ),
);

/**
 * An example implementation of a metric class.
 *
 * Unless you're extending another metric plugin, you must extend the
 * SamplerMetric class for your metric to work properly!
 *
 * See the existing metrics in sampler_example module for more examples of
 * how to build metrics.
 */
class MyModuleMetricMyMetric extends SamplerMetric {

  /**
   * Compute the values to store for a given sample of the metric.
   *
   * @see computeSamples()
   *
   * The function should calculate the values based on the method plugin
   * being used (default is periodic sampling), and is free to use any desired
   * calculation strategy (eg. sum of values between two sample points, total
   * count as of a single sample point, etc).
   *
   * The properties available in the sample object depend on the method being
   * used, check the documentation for the method plugin for more information.
   *
   * Calculated values are placed in $this->currentSample->values as an
   * associative array, keys are object IDs, values are an associative array of
   * calculated values, key = label, value = value, in the order they should be
   * stored.
   *
   * @return
   *   The metric can optionally return FALSE to skip the processing of the
   *   sample.  Otherwise, return nothing.
   */
  public function computeSample() {

    // Get the options for the sample.
    $options = $this->currentSample->options;

    // How to get the start and end points of the sample.
    $current = $this->currentSample;
    $previous = $this->getPreviousSample();
    $next = $this->getFollowingSample();

    // If a set of object IDs have been passed, they will be availabe here
    // as an array of IDs.
    $object_ids = $options['object_ids'];

    // ...some code to calcuate the values into an $objects array...

    // Finally, return an array of computed values to the current sample object
    // Returning FALSE will cause the API to quietly skip adding the sample to
    // the sample results.
    $samples = array();
    foreach ($objects as $object_id => $values) {
      $samples[$object_id] => array(
        'value_label1' => $value1,
        'value_label2' => $value2,
      );
    }
    $this->currentSample->values = $samples;
  }

  /**
   * Return a list of all objects to be tracked for this metric.
   *
   * If the Sampler API needs to get a list of all the objects you want
   * tracked for a given metric, it calls this function.
   *
   * @return
   *   An array of object IDs.
   */
  public function trackObjectIDs() {
    // Get all nodes of type 'foo'.
    $foo_nodes = db_select('node', 'n')
      ->fields('n', array('nid'))
      ->condition('type', 'foo')
      ->execute();
    $object_ids = array();
    foreach ($foo_nodes as $row) {
      $object_ids[] = $row->nid;
    }
    return $object_ids;
  }
}

/**
 * An example of how to do a custom sample programatically.
 *
 * @see SamplerMetric::computeSamples()
 * @see SamplerMetric::saveSamples()
 *
 * This takes samples and saves the results, sample period is every 3 days for
 * a month. Set one or all of the following options on a Sampler instance,
 * then compute and save the results.
 *
 * Options describe how the sample set should be built. The options
 * that can be passed to the API to control the sample depend on the plugins
 * being used. Here are the most common options for the default sampling
 * method (periodic):
 * - startstamp:
 *     A Unix timestamp specifying the start of the sample period. Defaults
 *     to the last sample time for the metric if provided, or 0.
 * - endstamp:
 *     A Unix timestamp specifying the end of the sample period. Defaults
 *     to the current time.
 * - time_unit: Unit of time used to sample for metrics. The strings 'day',
 *     'week', and 'month' are supported, or for a custom time unit, pass an
 *     integer with the number of seconds in the unit. Defaults to week.
 * - time_unit_interval: An integer representing the interval to count the
 *     time unit by, eg. if time_unit is week, and time_unit_interval is 2,
 *     sampling period would be every two weeks. Defaults to 1.
 * - single_sample:
 *     Boolean. If TRUE, all time_unit and time_unit_interval settings are
 *     ignored, and startstamp and endstamp are treated as the beginning
 *     and end of a single sample period.
 * - object_ids:
 *     An array of object IDs. If passed, metrics will only be calculated
 *     for these objects.
 *
 * Arbitrary additional options can also be set, and can be retrieved later in
 * calculation functions for added flexibility.
 */
function my_module_custom_sample() {
  // Required, performs necessary setup for the API.
  sampler_load_sampler();
  $sampler = new Sampler();

  // Add our customizations, and instantiate a new sampling object.
  $options = array(
    'startstamp' => '2010-07-26',
    'endstamp' => '2010-08-26',
    'time_unit' => 'day',
    'time_unit_interval' => 3,
  );
  $metric = $sampler->newSampler('my_module', 'my_metric', $options);


  // Pull the samples, and save the returned values to the database. Calling
  // the 'process' method on the sampling object is a shortcut way to do both
  // of these operations at once.
  $samples = $metric->computeSamples();
  $metric->saveSamples($samples);

  // Display the number of samples taken.
  return t('Sample points: %sample_points', array('%sample_points' => implode(', ', $metric->computed_samples)));
}

