<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE codetemplates PUBLIC "-//NetBeans//DTD Editor Code Templates settings 1.0//EN" "http://www.netbeans.org/dtds/EditorCodeTemplates-1_0.dtd">
<codetemplates>
	<codetemplate abbreviation="ann" xml:space="preserve">
		<code><![CDATA[/**
 * @file
 * ${cursor}
 * 
 *
 * @author ${user}
 */
 
/* ====================== */
/* ==== DRUPAL HOOKS ==== */
/* ====================== */


/* ====================== */
/* == MODULE FUNCTIONS == */
/* ====================== */]]></code>
	</codetemplate>
	<codetemplate abbreviation="annf" xml:space="preserve">
		<code><![CDATA[/**
 * @file ${file} - ${date}
 *
 * ${cursor}
 * 
 *
 * @author ${user}
 */
 
/* ====================== */
/* ==== DRUPAL HOOKS ==== */
/* ====================== */


/* ====================== */
/* == MODULE FUNCTIONS == */
/* ====================== */]]></code>
	</codetemplate>
	<codetemplate abbreviation="cck_import" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_install().
 */
function ${mymodule}_install() {
  // Create new content type
  $cck_content = file_get_contents(drupal_get_path('module', '${mymodule}') . '/${type}.cck');

  $form_state = array();
  
  $form_state['values']['type_name'] = t('<create>');
  $form_state['values']['macro'] = $cck_content;
  $form_state['values']['submit'] = t('Import');

  drupal_execute('content_copy_import_form', $form_state);
}

/**
 * Implementation of hook_install()
 */
function ${mymodule}_uninstall() {
  // Delete created nodes
  $result = db_query("SELECT nid FROM {node} WHERE type = '${type}'");

  while ($nid = db_fetch_array($result)) {
    node_delete($nid['nid']);
  }
  drupal_set_message(t('The created "${tyoename}" nodes are deleted.'));

  // Delete created node type
  node_type_delete('${type}');
  drupal_set_message(t('The created "${tyoename}" node type is deleted.'));

  // Delete menu cache
  menu_rebuild();
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="cln" remove="true"/>
	<codetemplate abbreviation="d6_access" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_access().
 *
 * @param $op Operation to be performed.
 * @param $node The node on which the operation is to be performed, or, if it does not yet exist, the type of node to be created. 
 * @param $account A user object representing the user for whom the operation is to be performed.
 * @return TRUE if the operation is to be allowed; FALSE if the operation is to be denied; NULL to not override the settings in the node_access table, or access control modules.
 */
function ${mymodule}_access($op, $node, $account) {

  switch ($op) {
    case "create" :
      return;
    case "delete" :
      return;
    case "update" :
      return;
    case "view" :
      return;
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_action_info_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_action_info_alter().
 *
 * @param $actions Array of action information.
 */
function ${mymodule}_action_info_alter(&$actions) {
  $actions['${cursor}'];
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_actions_delete" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_actions_delete().
 *
 * @param $aid The action ID.
 */
function ${mymodule}_actions_delete($aid) {
  ${cursor}db_query("DELETE FROM {actions_assignments} WHERE aid = '%s'", $aid);
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_block" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_block().
 *
 * @param $op What kind of information to retrieve about the block. Possible values: list, configure, save, view.
 * @param $delta Which block to return.
 * @param $edit Data from a configuration form, if submitted.
 */
function ${mymodule}_block($op = 'list', $delta = 0, $edit = array()) {
  switch ($op) {
    case 'list':
      $blocks = array();
      
      $blocks['${delta}'] = array(
        'info' => t('${info}'),
      );

      return $blocks;
      break;
      
    case 'view':
      $blocks = array();
      
      switch ($delta) {
        case '${delta}':
          $block['subject'] = t('${subject}');
          break;
      }
      
      $block['content'] = ${mymodule}_block_content($delta);
      
      return $block;
      break;
  }
}

/**
 * Generate block contents.
 * 
 * @param $delta The block id.
 * @return The generated block content.
 */
function ${mymodule}_block_content($delta) {
  switch ($delta) {
    case '${delta}':
      return;
      break;
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_boot" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_boot().
 */
function ${mymodule}_boot() {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_comment" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_comment().
 */
function ${mymodule}_comment(&$a1, $op) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_cron" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_cron().
 */
function ${mymodule}_cron() {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_db_rewrite_sql" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_db_rewrite_sql().
 */
function ${mymodule}_db_rewrite_sql($query, $primary_table, $primary_field, $args) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_delete" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_delete().
 *
 * @param $node The node being deleted.
 */
function ${mymodule}_delete(&$node) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_disable" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_disable().
 */
function ${mymodule}_disable() {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_elements" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_elements().
 */
function ${mymodule}_elements() {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_enable" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_enable().
 */
function ${mymodule}_enable() {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_exit" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_exit().
 */
function ${mymodule}_exit() {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_file_download" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_file_download().
 *
 * @param $filepath String of the file's path.
 */
function ${mymodule}_file_download($filepath) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_filter" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_filter().
 */
function ${mymodule}_filter($op, $delta = 0, $format = -1, $text = '', $cache_id = 0) {
  switch ($op) {
    case 'list':
      return array(${cursor});

    case 'description':
      return t('');

    case 'prepare':
      return $text;

    case "process":
      return $text;

    default:
      return $text;
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_filter_tips" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_filter_tips().
 *
 * @param $delta Which of this module's filters to use. Modules which only implement one filter can ignore this parameter.
 * @param $format Which format we are providing tips for.
 * @param $long If set to true, long tips are requested, otherwise short tips are needed.
 * @return string
 */
function ${mymodule}_filter_tips($delta, $format, $long = FALSE) {
  return t('${cursor}');
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_flush_caches" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_flush_caches().
 *
 * @return An array of cache table names.
 */
function ${mymodule}_flush_caches() {
  return array('${cursor}');
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_footer" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_footer().
 *
 * @param $main Whether the current page is the front page of the site.
 * @return The HTML to be inserted.
 */
function ${mymodule}_footer($main = 0) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_form" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_form().
 *
 * @param &$node The node being added or edited.
 * @param $form_state The form state array.
 * @return An array containing the form elements to be displayed in the node edit form.
 */
function ${mymodule}_form(&$node, $form_state) {
  $form = array();
  
  $form['${cursor}'] = array(
    '#type' => ''
  );
  
  return $form;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_form_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_form_alter().
 */
function ${mymodule}_form_alter(&$form, $form_state, $form_id) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_form_FORM_ID_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_form_${form_id}_alter().
 */
function ${mymodule}_form_${form_id}_alter(&$form, &$form_state) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_forms" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_forms().
 */
function ${mymodule}_forms() {
  $forms['${cursor}'] = array(
    'callback' => ''
  );
  return $forms;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_help" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_help().
 *
 * @param $path A Drupal menu router path the help is being requested.
 * @param $arg An array that corresponds to the return of the arg() function.
 * @return A localized string containing the help text.
 */
function ${mymodule}_help($path, $arg) {
  $output = '';
  switch ($path) {
    case "admin/help#${mymodule}":
      $output = '';
      break;
  }
  return $output;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_hook_info" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_hook_info().
 */
function ${mymodule}_hook_info() {
  return array(
    '${cursor}' => array(
    )
  );
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_imagecache_preset" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_imagecache_default_presets()
 */
function ${mymodule}_imagecache_default_presets() {
  $presets = array();
  ${code}

  return $presets;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_init" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_init().
 */
function ${mymodule}_init() {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_insert" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_insert().
 *
 * @param $node The node being inserted.
 */
function ${mymodule}_insert($node) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_install" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_install().
 */
function ${mymodule}_install() {
  drupal_install_schema('${mymodule}');${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_link" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_link().
 */
function ${mymodule}_link($type, $object, $teaser = FALSE) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_link_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_link_alter().
 */
function ${mymodule}_link_alter(&$links, $node) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_load" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_load().
 *
 * @param $node The node being loaded.
 */
function ${mymodule}_load($node) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_locale" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_locale().
 *
 * @param $op Type of operation. Currently, only supports 'groups'.
 */
function ${mymodule}_locale($op = 'groups') {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_mail" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_mail().
 *
 * @param $key An identifier of the mail.
 * @param $message An array to be filled in. Keys in this array include: id, to, subject, body, from, headers
 * @param $params An arbitrary array of parameters set by the caller to drupal_mail.
 */
function ${mymodule}_mail($key, &$message, $params) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_mail_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_mail_alter().
 *
 * @param $message A structured array containing the message to be altered. keys in this array include: id, to, subject, body, from, headers
 */
function ${mymodule}_mail_alter(&$message) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_menu" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_menu().
 *
 * @return An array of menu items.
 */
function ${mymodule}_menu() {
  $items = array();

  $items['${path}'] = array(
    'title' => '${title}',
    'description' => '${description}',
    'page callback' => '${callback}',
    'page arguments' => array('${callback_arg}'),
    'access arguments' => array('${access_arg}'),
    'file' => 'includes/${mymodule}.${type}.inc',
  );

  return $items;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_menu_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_menu_alter().
 *
 * @param $items Associative array of menu router definitions returned from hook_menu().
 */
function ${mymodule}_menu_alter(&$items) {
  $items['${cursor}'];
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_menu_link_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_menu_link_alter().
 *
 * @param $item Associative array defining a menu link as passed into menu_link_save().
 * @param $menu Associative array containg the menu router returned from menu_router_build().
 */
function ${mymodule}_menu_link_alter(&$item, $menu) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_node_access_records" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_node_access_records().
 */
function ${mymodule}_node_access_records($node) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_node_grants" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_node_grants().
 *
 * @param $account The user object whose grants are requested.
 * @param $op The node operation to be performed, such as "view", "update", or "delete".
 * @return An array whose keys are "realms" of grants such as "user" or "role", and whose values are linear lists of grant IDs.
 */
function ${mymodule}_node_grants($account, $op) {
  ${cursor}
  return $grants;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_node_info" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_node_info().
 *
 * @return An array of information on the ${mymodule}'s node types.
 */
function ${mymodule}_node_info() {
  return array(
    '${mymodule}' => array(
      'name' => t('${module_node_name}'),
      'module' => '${mymodule}',
      'description' => t("${module_node_description}"),
    )
  );
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_node_operations" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_node_operations().
 */
function ${mymodule}_node_operations() {
  $operations = array();
  
  if (user_access('${perm}')) {
    $operations['${name}'] = array(
      'label' => t('${label}'),
      'callback' => '${callback}',
      'callback arguments' => array(${cursor}),
    );
  }
  
  return $operations;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_node_type" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_node_type().
 *
 * @param $op What is being done to $info. Possible values: delete, insert, update.
 * @param $info The node type on which $op is being performed.
 */
function ${mymodule}_node_type($op, $info) {
${cursor}  switch ($op) {
    case 'delete':
      break;
    case 'insert':
      break;
    case 'update':
      break;
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_nodeapi" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_nodeapi().
 *
 * @param &$node The node the action is being performed on.
 * @param $op What kind of action is being performed. Possible values: alter, delete, delete revision, insert, load,
 *   prepare, prepare translation, print, rss item, search result, presave, update, update index, validate, view
 * @param $a3
 * @param $a4
 */
function ${mymodule}_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  switch ($op) {
    case '${op}':
      break;
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_perm" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_perm().
 *
 * @return array An array of valid permissions for the ${mymodule} module
 */
function ${mymodule}_perm() {
  return array('${cursor}');
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_ping" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_ping().
 *
 * @param $name The name of your Drupal site.
 * @param $url The URL of your Drupal site.
 */
function ${mymodule}_ping($name = '', $url = '') {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_pre_block" xml:space="preserve">
		<code><![CDATA[/**
 * 
 * Implementation of hook_preprocess_block().
 * 
 * Process variables for block.tpl.php
 * 
 * @param array $variables
 * @see block.tpl.php
 */
function ${mymodule}_preprocess_block(&$variables) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_prepare" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_prepare().
 *
 * @param &$node The node being saved.
 */
function ${mymodule}_prepare(&$node) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_profile_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_profile_alter().
 *
 * @param &$account A user object whose profile is being rendered. Profile items are stored in $account->content.
 */
function ${mymodule}_profile_alter(&$account) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_requirements" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_requirements().
 *
 * @param $phase The phase in which hook_requirements is run: install or runtime.
 */
function ${mymodule}_requirements($phase) {
  $requirements = array();
  
  $requirements['${name}'] = array(
    'title' =>  t('${title}'),
    'value' => t('${value}'),
    'severity' => REQUIREMENT_OK,
  );
  
  $requirements['name'] = array(
    'title' =>  t('title'),
    'value' => t('value'),
    'severity' => REQUIREMENT_ERROR,
  );
  
  $requirements['name'] = array(
    'title' =>  t('title'),
    'value' => t('value'),
    'severity' => REQUIREMENT_INFO,
  );
  
  $requirements['name'] = array(
    'title' =>  t('title'),
    'value' => t('value'),
    'severity' => REQUIREMENT_WARNING,
  );
  
  return $requirements;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_schema" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_schema().
 */
function ${mymodule}_schema() {
  $schema = array();
  
  $schema['${table}'] = array(
    'description' => '',
    'fields' => array(
      'serial' => array(
        'description' => '',
        'type' => 'serial',
        'unsigned' => TRUE,
        'not null' => TRUE,
      ),
      'int' => array(
        'description' => '',
        'type' => 'int',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'tiny' => array(
        'description' => '',
        'type' => 'int',
        'size' => 'tiny',
        'unsigned' => TRUE,
        'not null' => TRUE,
        'default' => 0,
      ),
      'varchar' => array(
        'description' => '',
        'type' => 'varchar',
        'length' => 255,
        'not null' => TRUE,
        'default' => '',
      ),
      'text' => array(
        'description' => '',
        'type' => 'text',
        'not null' => TRUE,
        'default' => '',
      ),
    ),
    'indexes' => array(
      'node_changed'  => array('changed'),
      'node_created'  => array('created'),
    ),
    'unique keys' => array(
      'nid_vid' => array('nid', 'vid'),
      'vid' => array('vid'),
    ),
    'primary key' => array('nid'),
  );

  return $schema;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_schema_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_schema_alter().
 *
 * @param &$schema Nested array describing the schemas for all modules.
 */
function ${mymodule}_schema_alter($schema) {
  $schema['${cursor}'];
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_search" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_search().
 *
 * @param $op A string defining which operation to perform: admin, name, reset, search, status
 * @param $keys The search keywords as entered by the user.
 */
function ${mymodule}_search($op = 'search', $keys = NULL) {
  switch ($op) {
    case 'name':
      return;

    case 'reset':
      return;

    case 'status':
      return;

    case 'admin':
      return;
      
    case 'search':
      return;
  );
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_search_preprocess" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_searcd6_preprocess().
 *
 * @param $text The text to split. This is a single piece of plain-text that was extracted from between two HTML tags.
 * @return The text after processing.
 */
function ${mymodule}_search_preprocess($text) {
  ${cursor}
  return $text;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_system_info_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_system_info_alter().
 *
 * @param &$info The .info file contents, passed by reference so that it can be altered.
 * @param $file Full information about the module or theme, including $file->name, and $file->filename.
 */
function ${mymodule}_system_info_alter(&$info, $file) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_taxonomy" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_taxonomy().
 *
 * @param $op What is being done to $array. Possible values: delete, insert, update.
 * @param $type What manner of item $array is. Possible values: term, vocabulary.
 * @param $array The item on which $op is being performed.
 */
function ${mymodule}_taxonomy($op, $type, $array = NULL) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_term_path" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_term_path().
 *
 * @param $term A term object.
 * @return An internal Drupal path.
 */
function ${mymodule}_term_path($term) {
  return '${cursor}';
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_theme" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_theme().
 * 
 * Define the following templates:
 *  - 
 *
 * @return Array of defined theme functions
 *
 * @see ${template}.tpl.php
 */
function ${mymodule}_theme($existing, $type, $theme, $path) {
  return array(
    '${function_name}' => array(
      'arguments' => array('${variable}' => NULL),
      'template' => '${template}',
      'path' => drupal_get_path('module', '${mymodule}') . '/theme',
    ),
  );
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_theme_registry_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_theme_registry_alter().
 *
 * @param $theme_registry The entire cache of theme registry information, post-processing.
 */
function ${mymodule}_theme_registry_alter(&$theme_registry) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_translated_menu_link_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_translated_menu_link_alter().
 *
 * @param $item Associative array defining a menu link after _menu_link_translate()
 * @param $map Associative array containing the menu $map (path parts and/or objects).
 */
function ${mymodule}_translated_menu_link_alter(&$item, $map) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_translation_link_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_translation_link_alter().
 *
 * @param $links Nested array of links keyed by language code.
 * @param $path The current path.
 */
function ${mymodule}_translation_link_alter(&$links, $path) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_uninstall" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_uninstall().
 */
function ${mymodule}_uninstall() {
  drupal_uninstall_schema('${mymodule}');${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_update" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_update().
 *
 * @param $node The node being updated.
 */
function ${mymodule}_update($node) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_update_index" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_update_index().
 */
function ${mymodule}_update_index() {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_update_last_removed" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_update_last_removed().
 */
function ${mymodule}_update_last_removed() {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_update_N" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_update_N().
 */
function ${mymodule}_update_${update_number}(&$sandbox = NULL) {
  $ret = array();
  ${cursor}
  return $ret;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_update_projects_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_update_projects_alter().
 *
 * @param $projects Reference to an array of the projects installed on the system.
 */
function ${mymodule}_update_projects_alter(&$projects) {
  $projects['${cursor}'];
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_update_status_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_update_status_alter().
 *
 * @param $projects Reference to an array of information about available updates to each project installed on the system.
 */
function ${mymodule}_update_status_alter(&$projects) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_user" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_user().
 *
 * @param $op What kind of actions is being performed. Possible values: after_update, categories, delete, form, insert, load, login, logout, register, submit, update, validate, view
 * @param &$edit The array of form values submitted by the user.
 * @param &$account The user object on which the operation is being performed.
 * @param $category The active category of user information being edited.
 */
function ${mymodule}_user($op, &$edit, &$account, $category = NULL) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_user_operations" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_user_operations().
 */
function ${mymodule}_user_operations() {
  $operations = array(
    '${cursor}' => array(
      'label' => t(''),
      'callback' => ''
    )
  );
  return $operations;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_validate" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_validate().
 *
 * Validate ${module_node} node type.
 *
 * @param $node Node to be validated.
 * @param &$form The node edit form array.
 */
function ${module_node}_validate($node, &$form) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_view" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_view().
 *
 * @param $node The node to be displayed.
 * @param $teaser Whether we are to generate a "teaser" or summary of the node, rather than display the whole thing.
 * @param $page Whether the node is being displayed as a standalone page.
 */
function ${mymodule}_view($node, $teaser = FALSE, $page = FALSE) {
  ${cursor}
  return $node;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_watchdog" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_watchdog().
 */
function ${mymodule}_watchdog($log_entry) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d6_xmlrpc" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_xmlrpc().
 */
function ${mymodule}_xmlrpc() {
  return array(
    ${cursor}
  );
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_aggregator_fetch" xml:space="preserve">
		<code><![CDATA[/**
 * Implement this hook to create an alternative fetcher for aggregator module.
 *
 * @param $feed
 *   The $feed object that describes the resource to be downloaded.
 *   $feed->url contains the link to the feed. Download the data at the URL
 *   and expose it to other modules by attaching it to $feed->source_string.
 *
 * @return
 *   TRUE if fetching was successful, FALSE otherwise.
 */
function ${mymodule}_aggregator_fetch($feed) {
  ${cursor};
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_aggregator_fetch_info" xml:space="preserve">
		<code><![CDATA[/**
 * Implement this hook to expose the title and a short description of your
 * fetcher.
 *
 * @return
 *   An associative array defining a title and a description string.
 */
function ${mymodule}_aggregator_fetch_info() {
  return array(
    'title' => t('${title}'),
    'description' => t('${description}'),
  );
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_aggregator_parse" xml:space="preserve">
		<code><![CDATA[/**
 * Implement this hook to create an alternative parser for aggregator module.
 *
 * @param $feed
 *   The $feed object that describes the resource to be parsed.
 *   $feed->source_string contains the raw feed data as a string. Parse data
 *   from $feed->source_string and expose it to other modules as an array of
 *   data items on $feed->items.
 *
 * @return
 *   TRUE if parsing was successful, FALSE otherwise.
 */
function ${mymodule}_aggregator_parse($feed) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_aggregator_parse_info" xml:space="preserve">
		<code><![CDATA[/**
 * Implement this hook to expose the title and a short description of your
 * parser.
 *
 * @return
 *   An associative array defining a title and a description string.
 */
function ${mymodule}_aggregator_parse_info() {
  return array(
    'title' => t('${title}'),
    'description' => t('${description}'),
  );
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_aggregator_process" xml:space="preserve">
		<code><![CDATA[/**
 * Implement this hook to create a processor for aggregator module.
 *
 * @param $feed
 *   The $feed object that describes the resource to be processed. $feed->items
 *   contains an array of feed items downloaded and parsed at the parsing
 *   stage. See hook_aggregator_parse() for the basic format of a single item
 *   in the $feed->items array. For the exact format refer to the particular
 *   parser in use.
 */
function ${mymodule}_aggregator_process($feed) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_aggregator_process_info" xml:space="preserve">
		<code><![CDATA[/**
 * Implement this hook to expose the title and a short description of your
 * processor.
 *
 * @return
 *   An associative array defining a title and a description string.
 */
function ${mymodule}_aggregator_process_info($feed) {
  return array(
    'title' => t('${title}'),
    'description' => t('${description}'),
  );
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_aggregator_remove" xml:space="preserve">
		<code><![CDATA[/**
 * Implement this hook to remove stored data if a feed is being deleted or a
 * feed's items are being removed.
 *
 * @param $feed
 *   The $feed object whose items are being removed.
 */
function ${mymodule}_aggregator_remove($feed) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_block_configure" xml:space="preserve">
		<code><![CDATA[/**
 * Define a configuration form for a block.
 *
 * @param $delta
 *   Which block is being configured. This is a unique identifier for the block
 *   within the module, defined in hook_block_info().
 *
 * @return
 *   A configuration form, if one is needed for your block beyond the standard
 *   elements that the block module provides (block title, visibility, etc.).
 */
function ${mymodule}_block_configure($delta = '') {
  $form = array();${cursor}
  return $form;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_block_info" xml:space="preserve">
		<code><![CDATA[/**
 * Define all blocks provided by the module.
 *
 * @return
 *   An associative array whose keys define the delta for each block and whose
 *   values contain the block descriptions. Each block description is itself an
 *   associative array, with the following key-value pairs:
 *   - 'info': (required)
 *   - 'cache': (optional)
 *   - 'properties': (optional)
 *   - 'weight': (optional)
 *   - 'status': (optional)
 *   - 'region': (optional)
 *   - 'visibility': (optional)
 *   - 'pages': (optional)
 */
function ${mymodule}_block_info() {
  $blocks = array();
  
  $blocks['${block}'] = array(
    'info' => t('${info}'),
    'cache' => DRUPAL_NO_CACHE,
  );

  return $blocks;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_block_info_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Change block definition before saving to the database.
 *
 * @param $blocks
 *   A multidimensional array of blocks keyed by the defining module and delta;
 *   the values are blocks returned by hook_block_info(). This hook is fired
 *   after the blocks are collected from hook_block_info() and the database,
 *   right before saving back to the database.
 * @param $theme
 *   The theme these blocks belong to.
 * @param $code_blocks
 *   The blocks as defined in hook_block_info() before being overwritten by the
 *   database data.
 */
function ${mymodule}_block_info_alter(&$blocks, $theme, $code_blocks) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_block_list_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Act on blocks prior to rendering.
 *
 * @param $blocks
 *   An array of $blocks, keyed by the block ID.
 */
function ${mymodule}_block_list_alter(&$blocks) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_block_save" xml:space="preserve">
		<code><![CDATA[/**
 * Save the configuration options from hook_block_configure().
 *
 * @param $delta
 *   Which block is being configured. This is a unique identifier for the block
 *   within the module, defined in hook_block_info().
 * @param $edit
 *   The submitted form data from the configuration form.
 */
function ${mymodule}_block_save($delta = '', $edit = array()) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_block_view" xml:space="preserve">
		<code><![CDATA[/**
 * Return a rendered or renderable view of a block.
 *
 * @param $delta
 *   Which block to render. This is a unique identifier for the block
 *   within the module, defined in hook_block_info().
 *
 * @return
 *   An array containing the following elements:
 *   - subject: The default localized title of the block. If the block does not
 *     have a default title, this should be set to NULL.
 *   - content: The content of the block's body. This may be a renderable array
 *     (preferable) or a string containing rendered HTML content.
 */
function ${mymodule}_block_view($delta = '') {
  $block = array();

  switch ($delta) {
    case '${delta}':
      $block['subject'] = t('${subject}');
      $block['content'] = ${cursor};
      break;
  }
  
  return $block;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_block_view_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Perform alterations to the content of a block.
 *
 * @param $data
 *   An array of data, as returned from the hook_block_view() implementation of
 *   the module that defined the block:
 *   - subject: The default localized title of the block.
 *   - content: Either a string or a renderable array representing the content
 *     of the block. You should check that the content is an array before trying
 *     to modify parts of the renderable structure.
 * @param $block
 *   The block object, as loaded from the database, having the main properties:
 *   - module: The name of the module that defined the block.
 *   - delta: The unique identifier for the block within that module, as defined
 *     in hook_block_info().
 */
function ${mymodule}_block_view_alter(&$data, $block) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_block_view_MODULE_DELTA_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Perform alterations to a specific block.
 *
 * @param $data
 *   An array of data, as returned from the hook_block_view() implementation of
 *   the module that defined the block:
 *   - subject: The localized title of the block.
 *   - content: Either a string or a renderable array representing the content
 *     of the block. You should check that the content is an array before trying
 *     to modify parts of the renderable structure.
 * @param $block
 *   The block object, as loaded from the database, having the main properties:
 *   - module: The name of the module that defined the block.
 *   - delta: The unique identifier for the block within that module, as defined
 *     in hook_block_info().
 */
function ${mymodule}_block_view_MODULE_DELTA_alter(&$data, $block) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_comment_delete" xml:space="preserve">
		<code><![CDATA[/**
 * The comment is being deleted by the moderator.
 *
 * @param $comment
 *   Passes in the comment the action is being performed on.
 * @return
 *   Nothing.
 */
function ${mymodule}_comment_delete($comment) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_comment_insert" xml:space="preserve">
		<code><![CDATA[/**
 * The comment is being inserted.
 *
 * @param $comment
 *   The comment object.
 */
function ${mymodule}_comment_insert($comment) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_comment_load" xml:space="preserve">
		<code><![CDATA[/**
 * Comments are being loaded from the database.
 *
 * @param $comments
 *  An array of comment objects indexed by cid.
 */
function ${mymodule}_comment_load($comments) {
  $result = db_query('SELECT cid, foo FROM {${mytable}} WHERE cid IN (:cids)', array(':cids' => array_keys($comments)));
  foreach ($result as $record) {
    $comments[$record->cid]->${myvar} = $record->${myvar};
  }${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_comment_presave" xml:space="preserve">
		<code><![CDATA[/**
 * The comment passed validation and is about to be saved.
 *
 * Modules may make changes to the comment before it is saved to the database.
 *
 * @param $comment
 *   The comment object.
 */
function ${mymodule}_comment_presave($comment) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_comment_publish" xml:space="preserve">
		<code><![CDATA[/**
 * The comment is being published by the moderator.
 *
 * @param $comment
 *   Passes in the comment the action is being performed on.
 * @return
 *   Nothing.
 */
function ${mymodule}_comment_publish($comment) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_comment_unpublish" xml:space="preserve">
		<code><![CDATA[/**
 * The comment is being unpublished by the moderator.
 *
 * @param $comment
 *   Passes in the comment the action is being performed on.
 * @return
 *   Nothing.
 */
function ${mymodule}_comment_unpublish($comment) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_comment_update" xml:space="preserve">
		<code><![CDATA[/**
 * The comment is being updated.
 *
 * @param $comment
 *   The comment object.
 */
function ${mymodule}_comment_update($comment) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_comment_view" xml:space="preserve">
		<code><![CDATA[/**
 * The comment is being viewed. This hook can be used to add additional data to the comment before theming.
 *
 * @param $comment
 *   Passes in the comment the action is being performed on.
 * @param $view_mode
 *   View mode, e.g. 'full', 'teaser'...
 * @param $langcode
 *   The language code used for rendering.
 *
 * @see hook_entity_view()
 */
function ${mymodule}_comment_view($comment, $view_mode, $langcode) {
  $comment->${myvar} = ${cursor};
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_comment_view_alter" xml:space="preserve">
		<code><![CDATA[/**
 * The comment was built; the module may modify the structured content.
 *
 * @param $build
 *   A renderable array representing the comment.
 */
function ${mymodule}_comment_view_alter(&$build) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_contextual_links_view_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Alter a contextual links element before it is rendered.
 *
 * @param $element
 *   A renderable array representing the contextual links.
 * @param $items
 *   An associative array containing the original contextual link items, as
 *   generated by menu_contextual_links(), which were used to build
 *   $element['#links'].
 */
function ${mymodule}_contextual_links_view_alter(&$element, $items) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_dashboard_regions" xml:space="preserve">
		<code><![CDATA[/**
 * Adds regions to the dashboard.
 *
 * @return
 *   An array whose keys are the names of the dashboard regions and whose
 *   values are the titles that will be displayed in the blocks administration
 *   interface. The keys are also used as theme wrapper functions.
 */
function $(name)_dashboard_regions() {
  return array('${mymodule_dashboard_region}' => "${title}");
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_dashboard_regions_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Alter dashboard regions provided by modules.
 *
 * @param $regions
 *   An array containing all dashboard regions, in the format provided by
 *   hook_dashboard_regions().
 */
function ${mymodule}_dashboard_regions_alter($regions) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_delete" xml:space="preserve">
		<code><![CDATA[/**
 * Respond to node deletion.
 *
 * @param $node
 *   The node that is being deleted.
 */
function ${mymodule}_delete($node) {
  db_delete('${mytable}')
    ->condition('nid', $nid->nid)
    ->execute();
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_attach_create_bundle" xml:space="preserve">
		<code><![CDATA[/**
 * Act on field_attach_create_bundle().
 *
 * This hook is invoked after the field module has performed the operation.
 *
 * See field_attach_create_bundle() for details and arguments.
 */
function ${name}_field_attach_create_bundle($entity_type, $bundle) {
  // When a new bundle is created, the menu needs to be rebuilt to add the
  // Field UI menu item tabs.
  variable_set('menu_rebuild_needed', TRUE);
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_attach_delete" xml:space="preserve">
		<code><![CDATA[/**
 * Act on field_attach_delete_bundle.
 *
 * This hook is invoked after the field module has performed the operation.
 *
 * @param $entity_type
 *   The type of entity; for example, 'node' or 'user'.
 * @param $bundle
 *   The bundle that was just deleted.
 * @param $instances
 *   An array of all instances that existed for the bundle before it was
 *   deleted.
 */
function ${name}_field_attach_delete_bundle($entity_type, $bundle, $instances) {
  // Remove the extra weights variable information for this bundle.
  $extra_weights = variable_get('field_extra_weights', array());
  if (isset($extra_weights[$entity_type][$bundle])) {
    unset($extra_weights[$entity_type][$bundle]);
    variable_set('field_extra_weights', $extra_weights);
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_attach_delete_bundle" xml:space="preserve">
		<code><![CDATA[/**
 * Act on field_attach_delete_bundle.
 *
 * This hook is invoked after the field module has performed the operation.
 *
 * @param $entity_type
 *   The type of entity; for example, 'node' or 'user'.
 * @param $bundle
 *   The bundle that was just deleted.
 * @param $instances
 *   An array of all instances that existed for the bundle before it was
 *   deleted.
 */
function ${name}_field_attach_delete_bundle($entity_type, $bundle, $instances) {
  // Remove the extra weights variable information for this bundle.
  $extra_weights = variable_get('field_extra_weights', array());
  if (isset($extra_weights[$entity_type][$bundle])) {
    unset($extra_weights[$entity_type][$bundle]);
    variable_set('field_extra_weights', $extra_weights);
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_attach_form" xml:space="preserve">
		<code><![CDATA[/**
 * Act on field_attach_form().
 *
 * This hook is invoked after the field module has performed the operation.
 * Implementing modules should alter the $form or $form_state parameters.
 *
 * @param $entity_type
 *   The type of $entity; for example, 'node' or 'user'.
 * @param $entity
 *   The entity for which an edit form is being built.
 * @param $form
 *   The form structure where field elements are attached to. This might be a
 *   full form structure, or a sub-element of a larger form. The
 *   $form['#parents'] property can be used to identify the corresponding part
 *   of $form_state['values']. Hook implementations that need to act on the
 *   top-level properties of the global form (like #submit, #validate...) can
 *   add a #process callback to the array received in the $form parameter, and
 *   act on the $complete_form parameter in the process callback.
 * @param $form_state
 *   An associative array containing the current state of the form.
 * @param $langcode
 *   The language the field values are going to be entered in. If no language
 *   is provided the default site language will be used.
 */
function ${name}_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode) {
  // Add a checkbox allowing a given field to be emptied.
  // See hook_field_attach_submit() for the corresponding processing code.
  $form['empty_field_foo'] = array(
    '#type' => 'checkbox',
    '#title' => t("Empty the 'field_foo' field"),
  );
}
]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_attach_prepare_translation_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Perform alterations on field_attach_prepare_translation().
 *
 * This hook is invoked after the field module has performed the operation.
 *
 * @param $entity
 *   The entity being prepared for translation.
 * @param $context
 *   An associative array containing:
 *   - entity_type: The type of $entity; e.g. 'node' or 'user'.
 *   - langcode: The language the entity has to be translated in.
 *   - source_entity: The entity holding the field values to be translated.
 *   - source_langcode: The source language from which translate.
 */
function ${name}_field_attach_prepare_translation_alter(&$entity, $context) {
  if ($context['entity_type'] == 'custom_entity_type') {
    $entity->custom_field = $context['source_entity']->custom_field;
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_attach_purge" xml:space="preserve">
		<code><![CDATA[/**
 * Act on field_purge_data().
 *
 * This hook is invoked in field_purge_data() and allows modules to act on
 * purging data from a single field pseudo-entity. For example, if a module
 * relates data in the field with its own data, it may purge its own data
 * during this process as well.
 *
 * @param $entity_type
 *   The type of $entity; for example, 'node' or 'user'.
 * @param $entity
 *   The pseudo-entity whose field data is being purged.
 * @param $field
 *   The (possibly deleted) field whose data is being purged.
 * @param $instance
 *   The deleted field instance whose data is being purged.
 *
 * @see @link field_purge Field API bulk data deletion @endlink
 * @see field_purge_data()
 */
function $(name)_field_attach_purge($entity_type, $entity, $field, $instance) {
  // find the corresponding data in mymodule and purge it
  if ($entity_type == 'node' && $field->field_name == 'my_field_name') {
    mymodule_remove_mydata($entity->nid);
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_attach_rename_bundle" xml:space="preserve">
		<code><![CDATA[/**
 * Act on field_attach_rename_bundle().
 *
 * This hook is invoked after the field module has performed the operation.
 *
 * See field_attach_rename_bundle() for details and arguments.
 */
function ${name}_field_attach_rename_bundle($entity_type, $bundle_old, $bundle_new) {
  // Update the extra weights variable with new information.
  if ($bundle_old !== $bundle_new) {
    $extra_weights = variable_get('field_extra_weights', array());
    if (isset($info[$entity_type][$bundle_old])) {
      $extra_weights[$entity_type][$bundle_new] = $extra_weights[$entity_type][$bundle_old];
      unset($extra_weights[$entity_type][$bundle_old]);
      variable_set('field_extra_weights', $extra_weights);
    }
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_attach_submit" xml:space="preserve">
		<code><![CDATA[/**
 * Act on field_attach_form().
 *
 * This hook is invoked after the field module has performed the operation.
 * Implementing modules should alter the $form or $form_state parameters.
 *
 * @param $entity_type
 *   The type of $entity; for example, 'node' or 'user'.
 * @param $entity
 *   The entity for which an edit form is being built.
 * @param $form
 *   The form structure where field elements are attached to. This might be a
 *   full form structure, or a sub-element of a larger form. The
 *   $form['#parents'] property can be used to identify the corresponding part
 *   of $form_state['values']. Hook implementations that need to act on the
 *   top-level properties of the global form (like #submit, #validate...) can
 *   add a #process callback to the array received in the $form parameter, and
 *   act on the $complete_form parameter in the process callback.
 * @param $form_state
 *   An associative array containing the current state of the form.
 * @param $langcode
 *   The language the field values are going to be entered in. If no language
 *   is provided the default site language will be used.
 */
function ${name}_field_attach_form($entity_type, $entity, &$form, &$form_state, $langcode) {
  // Add a checkbox allowing a given field to be emptied.
  // See hook_field_attach_submit() for the corresponding processing code.
  $form['empty_field_foo'] = array(
    '#type' => 'checkbox',
    '#title' => t("Empty the 'field_foo' field"),
  );
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_attach_view_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Perform alterations on field_attach_view() or field_view_field().
 *
 * This hook is invoked after the field module has performed the operation.
 *
 * @param $output
 *   The structured content array tree for all of the entity's fields.
 * @param $context
 *   An associative array containing:
 *   - entity_type: The type of $entity; for example, 'node' or 'user'.
 *   - entity: The entity with fields to render.
 *   - view_mode: View mode; for example, 'full' or 'teaser'.
 *   - display: Either a view mode string or an array of display settings. If
 *     this hook is being invoked from field_attach_view(), the 'display'
 *     element is set to the view mode string. If this hook is being invoked
 *     from field_view_field(), this element is set to the $display argument
 *     and the view_mode element is set to '_custom'. See field_view_field()
 *     for more information on what its $display argument contains.
 *   - language: The language code used for rendering.
 */
function ${name}_field_attach_view_alter(&$output, $context) {
  // Append RDF term mappings on displayed taxonomy links.
  foreach (element_children($output) as $field_name) {
    $element = &$output[$field_name];
    if ($element['#field_type'] == 'taxonomy_term_reference' && $element['#formatter'] == 'taxonomy_term_reference_link') {
      foreach ($element['#items'] as $delta => $item) {
        $term = $item['taxonomy_term'];
        if (!empty($term->rdf_mapping['rdftype'])) {
          $element[$delta]['#options']['attributes']['typeof'] = $term->rdf_mapping['rdftype'];
        }
        if (!empty($term->rdf_mapping['name']['predicates'])) {
          $element[$delta]['#options']['attributes']['property'] = $term->rdf_mapping['name']['predicates'];
        }
      }
    }
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_available_languages_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Alter field_available_languages() values.
 *
 * This hook is invoked from field_available_languages() to allow modules to
 * alter the array of available languages for the given field.
 *
 * @param $languages
 *   A reference to an array of language codes to be made available.
 * @param $context
 *   An associative array containing:
 *   - entity_type: The type of the entity the field is attached to.
 *   - field: A field data structure.
 */
function ${name}_field_available_languages_alter(&$languages, $context) {
  // Add an unavailable language.
  $languages[] = 'xx';

  // Remove an available language.
  $index = array_search('yy', $languages);
  unset($languages[$index]);
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_delete_revision" xml:space="preserve">
		<code><![CDATA[/**
 * Define custom revision delete behavior for this module's field types.
 *
 * This hook is invoked just before the data is deleted from field storage
 * in field_attach_delete_revision(), and will only be called for fieldable
 * types that are versioned.
 *
 * @param $entity_type
 *   The type of $entity.
 * @param $entity
 *   The entity for the operation.
 * @param $field
 *   The field structure for the operation.
 * @param $instance
 *   The instance structure for $field on $entity's bundle.
 * @param $langcode
 *   The language associated with $items.
 * @param $items
 *   $entity->{$field['field_name']}[$langcode], or an empty array if unset.
 */
function ${name}_field_delete_revision($entity_type, $entity, $field, $instance, $langcode, &$items) {
  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);
  foreach ($items as $delta => $item) {
    // For hook_file_references, remember that this file is being deleted.
    $item['file_field_name'] = $field['field_name'];
    if (file_field_delete_file($item, $field, $entity_type, $id)) {
      $items[$delta] = NULL;
    }
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_display_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Alters the display settings of a field before it gets displayed.
 *
 * Note that instead of hook_field_display_alter(), which is called for all
 * fields on all entity types, hook_field_display_ENTITY_TYPE_alter() may be
 * used to alter display settings for fields on a specific entity type only.
 *
 * This hook is called once per field per displayed entity. If the result of the
 * hook involves reading from the database, it is highly recommended to
 * statically cache the information.
 *
 * @param $display
 *   The display settings that will be used to display the field values, as
 *   found in the 'display' key of $instance definitions.
 * @param $context
 *   An associative array containing:
 *   - entity_type: The entity type; e.g., 'node' or 'user'.
 *   - field: The field being rendered.
 *   - instance: The instance being rendered.
 *   - entity: The entity being rendered.
 *   - view_mode: The view mode, e.g. 'full', 'teaser'...
 *
 * @see hook_field_display_ENTITY_TYPE_alter()
 */
function ${name}_field_display_alter(&$display, $context) {
  // Leave field labels out of the search index.
  // Note: The check against $context['entity_type'] == 'node' could be avoided
  // by using hook_field_display_node_alter() instead of
  // hook_field_display_alter(), resulting in less function calls when
  // rendering non-node entities.
  if ($context['entity_type'] == 'node' && $context['view_mode'] == 'search_index') {
    $display['label'] = 'hidden';
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_display_ENTITY_TYPE_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Alters the display settings of a field on a given entity type before it gets displayed.
 *
 * Modules can implement hook_field_display_ENTITY_TYPE_alter() to alter display
 * settings for fields on a specific entity type, rather than implementing
 * hook_field_display_alter().
 *
 * This hook is called once per field per displayed entity. If the result of the
 * hook involves reading from the database, it is highly recommended to
 * statically cache the information.
 *
 * @param $display
 *   The display settings that will be used to display the field values, as
 *   found in the 'display' key of $instance definitions.
 * @param $context
 *   An associative array containing:
 *   - entity_type: The entity type; e.g., 'node' or 'user'.
 *   - field: The field being rendered.
 *   - instance: The instance being rendered.
 *   - entity: The entity being rendered.
 *   - view_mode: The view mode, e.g. 'full', 'teaser'...
 *
 * @see hook_field_display_alter()
 */
function ${name}_field_display_ENTITY_TYPE_alter(&$display, $context) {
  // Leave field labels out of the search index.
  if ($context['view_mode'] == 'search_index') {
    $display['label'] = 'hidden';
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_extra_fields" xml:space="preserve">
		<code><![CDATA[/**
 * Alters the display settings of pseudo-fields before an entity is displayed.
 *
 * This hook is called once per displayed entity. If the result of the hook
 * involves reading from the database, it is highly recommended to statically
 * cache the information.
 *
 * @param $displays
 *   An array of display settings for the pseudo-fields in the entity, keyed
 *   by pseudo-field names.
 * @param $context
 *   An associative array containing:
 *   - entity_type: The entity type; e.g., 'node' or 'user'.
 *   - bundle: The bundle name.
 *   - view_mode: The view mode, e.g. 'full', 'teaser'...
 */
function ${name}_field_extra_fields_display_alter(&$displays, $context) {
  if ($context['entity_type'] == 'taxonomy_term' && $context['view_mode'] == 'full') {
    $displays['description']['visible'] = FALSE;
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_extra_fields_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Exposes "pseudo-field" components on fieldable entities.
 *
 * Field UI's "Manage fields" and "Manage display" pages let users re-order
 * fields, but also non-field components. For nodes, these include the title,
 * poll choices, and other elements exposed by modules through hook_form() or
 * hook_form_alter().
 *
 * Fieldable entities or modules that want to have their components supported
 * should expose them using this hook. The user-defined settings (weight,
 * visible) are automatically applied on rendered forms and displayed
 * entities in a #pre_render callback added by field_attach_form() and
 * field_attach_view().
 *
 * @see _field_extra_fields_pre_render()
 * @see hook_field_extra_fields_alter()
 *
 * @return
 *   A nested array of 'pseudo-field' components. Each list is nested within
 *   the following keys: entity type, bundle name, context (either 'form' or
 *   'display'). The keys are the name of the elements as appearing in the
 *   renderable array (either the entity form or the displayed entity). The
 *   value is an associative array:
 *   - label: The human readable name of the component.
 *   - description: A short description of the component contents.
 *   - weight: The default weight of the element.
 */
function ${name}_field_extra_fields() {
  $extra['node']['poll'] = array(
    'form' => array(
      'choice_wrapper' => array(
        'label' => t('Poll choices'),
        'description' => t('Poll choices'),
        'weight' => -4,
      ),
      'settings' => array(
        'label' => t('Poll settings'),
        'description' => t('Poll module settings'),
        'weight' => -3,
      ),
    ),
    'display' => array(
      'poll_view_voting' => array(
        'label' => t('Poll vote'),
        'description' => t('Poll vote'),
        'weight' => 0,
      ),
      'poll_view_results' => array(
        'label' => t('Poll results'),
        'description' => t('Poll results'),
        'weight' => 0,
      ),
    )
  );

  return $extra;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_extra_fields_display_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Alters the display settings of pseudo-fields before an entity is displayed.
 *
 * This hook is called once per displayed entity. If the result of the hook
 * involves reading from the database, it is highly recommended to statically
 * cache the information.
 *
 * @param $displays
 *   An array of display settings for the pseudo-fields in the entity, keyed
 *   by pseudo-field names.
 * @param $context
 *   An associative array containing:
 *   - entity_type: The entity type; e.g., 'node' or 'user'.
 *   - bundle: The bundle name.
 *   - view_mode: The view mode, e.g. 'full', 'teaser'...
 */
function ${name}_field_extra_fields_display_alter(&$displays, $context) {
  if ($context['entity_type'] == 'taxonomy_term' && $context['view_mode'] == 'full') {
    $displays['description']['visible'] = FALSE;
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_formatter_info" xml:space="preserve">
		<code><![CDATA[/**
 * Expose Field API formatter types.
 *
 * Formatters handle the display of field values. Formatter hooks are typically
 * called by the Field Attach API field_attach_prepare_view() and
 * field_attach_view() functions.
 *
 * @return
 *   An array describing the formatter types implemented by the module.
 *   The keys are formatter type names. To avoid name clashes, formatter type
 *   names should be prefixed with the name of the module that exposes them.
 *   The values are arrays describing the formatter type, with the following
 *   key/value pairs:
 *   - label: The human-readable name of the formatter type.
 *   - description: A short description for the formatter type.
 *   - field types: An array of field types the formatter supports.
 *   - settings: An array whose keys are the names of the settings available
 *     for the formatter type, and whose values are the default values for
 *     those settings.
 *
 * @see hook_field_formatter_info_alter()
 * @see hook_field_formatter_view()
 * @see hook_field_formatter_prepare_view()
 */
function ${name}_field_formatter_info() {
  return array(
    'text_default' => array(
      'label' => t('Default'),
      'field types' => array('text', 'text_long', 'text_with_summary'),
    ),
    'text_plain' => array(
      'label' => t('Plain text'),
      'field types' => array('text', 'text_long', 'text_with_summary'),
    ),

    // The text_trimmed formatter displays the trimmed version of the
    // full element of the field. It is intended to be used with text
    // and text_long fields. It also works with text_with_summary
    // fields though the text_summary_or_trimmed formatter makes more
    // sense for that field type.
    'text_trimmed' => array(
      'label' => t('Trimmed'),
      'field types' => array('text', 'text_long', 'text_with_summary'),
    ),

    // The 'summary or trimmed' field formatter for text_with_summary
    // fields displays returns the summary element of the field or, if
    // the summary is empty, the trimmed version of the full element
    // of the field.
    'text_summary_or_trimmed' => array(
      'label' => t('Summary or trimmed'),
      'field types' => array('text_with_summary'),
    ),
  );
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_formatter_info_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Perform alterations on Field API formatter types.
 *
 * @param $info
 *   An array of information on formatter types exposed by
 *   hook_field_formatter_info() implementations.
 */
function ${name}_field_formatter_info_alter(&$info) {
  // Add a setting to a formatter type.
  $info['text_default']['settings'] += array(
    'mymodule_additional_setting' => 'default value',
  );

  // Let a new field type re-use an existing formatter.
  $info['text_default']['field types'][] = 'my_field_type';
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_formatter_prepare_view" xml:space="preserve">
		<code><![CDATA[/**
 * Allow formatters to load information for field values being displayed.
 *
 * This should be used when a formatter needs to load additional information
 * from the database in order to render a field, for example a reference field
 * which displays properties of the referenced entities such as name or type.
 *
 * This hook is called after the field type's own hook_field_prepare_view().
 *
 * Unlike most other field hooks, this hook operates on multiple entities. The
 * $entities, $instances and $items parameters are arrays keyed by entity ID.
 * For performance reasons, information for all available entities should be
 * loaded in a single query where possible.
 *
 * @param $entity_type
 *   The type of $entity.
 * @param $entities
 *   Array of entities being displayed, keyed by entity ID.
 * @param $field
 *   The field structure for the operation.
 * @param $instances
 *   Array of instance structures for $field for each entity, keyed by entity
 *   ID.
 * @param $langcode
 *   The language the field values are to be shown in. If no language is
 *   provided the current language is used.
 * @param $items
 *   Array of field values for the entities, keyed by entity ID.
 * @param $displays
 *   Array of display settings to use for each entity, keyed by entity ID.
 *
 * @return
 *   Changes or additions to field values are done by altering the $items
 *   parameter by reference.
 */
function $(name)_field_formatter_prepare_view($entity_type, $entities, $field, $instances, $langcode, &$items, $displays) {
  $tids = array();

  // Collect every possible term attached to any of the fieldable entities.
  foreach ($entities as $id => $entity) {
    foreach ($items[$id] as $delta => $item) {
      // Force the array key to prevent duplicates.
      $tids[$item['tid']] = $item['tid'];
    }
  }

  if ($tids) {
    $terms = taxonomy_term_load_multiple($tids);

    // Iterate through the fieldable entities again to attach the loaded term
    // data.
    foreach ($entities as $id => $entity) {
      $rekey = FALSE;

      foreach ($items[$id] as $delta => $item) {
        // Check whether the taxonomy term field instance value could be loaded.
        if (isset($terms[$item['tid']])) {
          // Replace the instance value with the term data.
          $items[$id][$delta]['taxonomy_term'] = $terms[$item['tid']];
        }
        // Otherwise, unset the instance value, since the term does not exist.
        else {
          unset($items[$id][$delta]);
          $rekey = TRUE;
        }
      }

      if ($rekey) {
        // Rekey the items array.
        $items[$id] = array_values($items[$id]);
      }
    }
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_formatter_settings_form" xml:space="preserve">
		<code><![CDATA[/**
 * Returns form elements for a formatter's settings.
 *
 * @param $field
 *   The field structure being configured.
 * @param $instance
 *   The instance structure being configured.
 * @param $view_mode
 *   The view mode being configured.
 * @param $form
 *   The (entire) configuration form array, which will usually have no use here.
 * @param $form_state
 *   The form state of the (entire) configuration form.
 *
 * @return
 *   The form elements for the formatter settings.
 */
function ${mymodule}_field_formatter_settings_form($field, $instance, $view_mode, $form, &$form_state) {
  $element = array();
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];${cursor}
  return $element;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_formatter_settings_summary" xml:space="preserve">
		<code><![CDATA[/**
 * Returns a short summary for the current formatter settings of an instance.
 *
 * @param $field
 *   The field structure.
 * @param $instance
 *   The instance structure.
 * @param $view_mode
 *   The view mode for which a settings summary is requested.
 *
 * @return
 *   A string containing a short summary of the formatter settings.
 */
function ${mymodule}_field_formatter_settings_summary($field, $instance, $view_mode) {
  $summary = '';
  $display = $instance['display'][$view_mode];
  $settings = $display['settings'];${cursor}
  return $summary;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_formatter_view" xml:space="preserve">
		<code><![CDATA[/**
 * Build a renderable array for a field value.
 *
 * @param $entity_type
 *   The type of $entity.
 * @param $entity
 *   The entity being displayed.
 * @param $field
 *   The field structure.
 * @param $instance
 *   The field instance.
 * @param $langcode
 *   The language associated with $items.
 * @param $items
 *   Array of values for this field.
 * @param $display
 *   The display settings to use, as found in the 'display' entry of instance
 *   definitions. The array notably contains the following keys and values;
 *   - type: The name of the formatter to use.
 *   - settings: The array of formatter settings.
 *
 * @return
 *   A renderable array for the $items, as an array of child elements keyed
 *   by numeric indexes starting from 0.
 */
function ${name}_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  $settings = $display['settings'];

  switch ($display['type']) {
    case 'sample_field_formatter_simple':
      // Common case: each value is displayed individually in a sub-element
      // keyed by delta. The field.tpl.php template specifies the markup
      // wrapping each value.
      foreach ($items as $delta => $item) {
        $element[$delta] = array('#markup' => $settings['some_setting'] . $item['value']);
      }
      break;

    case 'sample_field_formatter_themeable':
      // More elaborate formatters can defer to a theme function for easier
      // customization.
      foreach ($items as $delta => $item) {
        $element[$delta] = array(
          '#theme' => 'mymodule_theme_sample_field_formatter_themeable',
          '#data' => $item['value'],
          '#some_setting' => $settings['some_setting'],
        );
      }
      break;

    case 'sample_field_formatter_combined':
      // Some formatters might need to display all values within a single piece
      // of markup.
      $rows = array();
      foreach ($items as $delta => $item) {
        $rows[] = array($delta, $item['value']);
      }
      $element[0] = array(
        '#theme' => 'table',
        '#header' => array(t('Delta'), t('Value')),
        '#rows' => $rows,
      );
      break;
  }

  return $element;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_info" xml:space="preserve">
		<code><![CDATA[/**
 * Returns the maximum weight for the entity components handled by the module.
 *
 * Field API takes care of fields and 'extra_fields'. This hook is intended for
 * third-party modules adding other entity components (e.g. field_group).
 *
 * @param $entity_type
 *   The type of entity; e.g. 'node' or 'user'.
 * @param $bundle
 *   The bundle name.
 * @param $context
 *   The context for which the maximum weight is requested. Either 'form', or
 *   the name of a view mode.
 * @return
 *   The maximum weight of the entity's components, or NULL if no components
 *   were found.
 */
function $(name)_field_info_max_weight($entity_type, $bundle, $context) {
  $weights = array();

  foreach (my_module_entity_additions($entity_type, $bundle, $context) as $addition) {
    $weights[] = $addition['weight'];
  }

  return $weights ? max($weights) : NULL;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_info_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Define Field API field types.
 *
 * @return
 *   An array whose keys are field type names and whose values are arrays
 *   describing the field type, with the following key/value pairs:
 *   - label: The human-readable name of the field type.
 *   - description: A short description for the field type.
 *   - settings: An array whose keys are the names of the settings available
 *     for the field type, and whose values are the default values for those
 *     settings.
 *   - instance_settings: An array whose keys are the names of the settings
 *     available for instances of the field type, and whose values are the
 *     default values for those settings. Instance-level settings can have
 *     different values on each field instance, and thus allow greater
 *     flexibility than field-level settings. It is recommended to put settings
 *     at the instance level whenever possible. Notable exceptions: settings
 *     acting on the schema definition, or settings that Views needs to use
 *     across field instances (for example, the list of allowed values).
 *   - default_widget: The machine name of the default widget to be used by
 *     instances of this field type, when no widget is specified in the
 *     instance definition. This widget must be available whenever the field
 *     type is available (i.e. provided by the field type module, or by a module
 *     the field type module depends on).
 *   - default_formatter: The machine name of the default formatter to be used
 *     by instances of this field type, when no formatter is specified in the
 *     instance definition. This formatter must be available whenever the field
 *     type is available (i.e. provided by the field type module, or by a module
 *     the field type module depends on).
 *   - no_ui: (optional) A boolean specifying that users should not be allowed
 *     to create fields and instances of this field type through the UI. Such
 *     fields can only be created programmatically with field_create_field()
 *     and field_create_instance(). Defaults to FALSE.
 *
 * @see hook_field_info_alter()
 */
function $(name)_field_info() {
  return array(
    'text' => array(
      'label' => t('Text'),
      'description' => t('This field stores varchar text in the database.'),
      'settings' => array('max_length' => 255),
      'instance_settings' => array('text_processing' => 0),
      'default_widget' => 'text_textfield',
      'default_formatter' => 'text_default',
    ),
    'text_long' => array(
      'label' => t('Long text'),
      'description' => t('This field stores long text in the database.'),
      'settings' => array('max_length' => ''),
      'instance_settings' => array('text_processing' => 0),
      'default_widget' => 'text_textarea',
      'default_formatter' => 'text_default',
    ),
    'text_with_summary' => array(
      'label' => t('Long text and summary'),
      'description' => t('This field stores long text in the database along with optional summary text.'),
      'settings' => array('max_length' => ''),
      'instance_settings' => array('text_processing' => 1, 'display_summary' => 0),
      'default_widget' => 'text_textarea_with_summary',
      'default_formatter' => 'text_summary_or_trimmed',
    ),
  );
}
]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_info_max_weight" xml:space="preserve">
		<code><![CDATA[/**
 * Returns the maximum weight for the entity components handled by the module.
 *
 * Field API takes care of fields and 'extra_fields'. This hook is intended for
 * third-party modules adding other entity components (e.g. field_group).
 *
 * @param $entity_type
 *   The type of entity; e.g. 'node' or 'user'.
 * @param $bundle
 *   The bundle name.
 * @param $context
 *   The context for which the maximum weight is requested. Either 'form', or
 *   the name of a view mode.
 * @return
 *   The maximum weight of the entity's components, or NULL if no components
 *   were found.
 */
function $(name)_field_info_max_weight($entity_type, $bundle, $context) {
  $weights = array();

  foreach (my_module_entity_additions($entity_type, $bundle, $context) as $addition) {
    $weights[] = $addition['weight'];
  }

  return $weights ? max($weights) : NULL;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_insert" xml:space="preserve">
		<code><![CDATA[/**
 * Define custom insert behavior for this module's field data.
 *
 * This hook is invoked from field_attach_insert() on the module that defines a
 * field, during the process of inserting an entity object (node, taxonomy term,
 * etc.). It is invoked just before the data for this field on the particular
 * entity object is inserted into field storage. Only field modules that are
 * storing or tracking information outside the standard field storage mechanism
 * need to implement this hook.
 *
 * @param $entity_type
 *   The type of $entity.
 * @param $entity
 *   The entity for the operation.
 * @param $field
 *   The field structure for the operation.
 * @param $instance
 *   The instance structure for $field on $entity's bundle.
 * @param $langcode
 *   The language associated with $items.
 * @param $items
 *   $entity->{$field['field_name']}[$langcode], or an empty array if unset.
 *
 * @see hook_field_update()
 * @see hook_field_delete()
 */
function $(name)_field_insert($entity_type, $entity, $field, $instance, $langcode, &$items) {
  if (variable_get('taxonomy_maintain_index_table', TRUE) && $field['storage']['type'] == 'field_sql_storage' && $entity_type == 'node' && $entity->status) {
    $query = db_insert('taxonomy_index')->fields(array('nid', 'tid', 'sticky', 'created', ));
    foreach ($items as $item) {
      $query->values(array(
        'nid' => $entity->nid,
        'tid' => $item['tid'],
        'sticky' => $entity->sticky,
        'created' => $entity->created,
      ));
    }
    $query->execute();
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_instance_settings_form" xml:space="preserve">
		<code><![CDATA[/**
 * Add settings to an instance field settings form.
 *
 * @param $field
 *   The field structure being configured.
 * @param $instance
 *   The instance structure being configured.
 *
 * @return
 *   The form definition for the field instance settings.
 */
function ${mymodule}_field_instance_settings_form($field, $instance) {
  $form = array();
  $settings = $instance['settings'];${cursor}

  return $form;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_is_empty" xml:space="preserve">
		<code><![CDATA[/**
 * Define what constitutes an empty item for a field type.
 *
 * @param $item
 *   An item that may or may not be empty.
 * @param $field
 *   The field to which $item belongs.
 *
 * @return
 *   TRUE if $field's type considers $item not to contain any data;
 *   FALSE otherwise.
 */
function $(name)_field_is_empty($item, $field) {
  if (empty($item['value']) && (string) $item['value'] !== '0') {
    return TRUE;
  }
  return FALSE;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_language_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Perform alterations on field_language() values.
 *
 * This hook is invoked to alter the array of display languages for the given
 * entity.
 *
 * @param $display_language
 *   A reference to an array of language codes keyed by field name.
 * @param $context
 *   An associative array containing:
 *   - entity_type: The type of the entity to be displayed.
 *   - entity: The entity with fields to render.
 *   - langcode: The language code $entity has to be displayed in.
 */
function $(name)_field_language_alter(&$display_language, $context) {
  // Do not apply core language fallback rules if they are disabled or if Locale
  // is not registered as a translation handler.
  if (variable_get('locale_field_language_fallback', TRUE) && field_has_translation_handler($context['entity_type'], 'locale')) {
    locale_field_language_fallback($display_language, $context['entity'], $context['language']);
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_load" xml:space="preserve">
		<code><![CDATA[/**
 * Define custom load behavior for this module's field types.
 *
 * Unlike most other field hooks, this hook operates on multiple entities. The
 * $entities, $instances and $items parameters are arrays keyed by entity ID.
 * For performance reasons, information for all available entity should be
 * loaded in a single query where possible.
 *
 * Note that the changes made to the field values get cached by the field cache
 * for subsequent loads. You should never use this hook to load fieldable
 * entities, since this is likely to cause infinite recursions when
 * hook_field_load() is run on those as well. Use
 * hook_field_formatter_prepare_view() instead.
 *
 * Make changes or additions to field values by altering the $items parameter by
 * reference. There is no return value.
 *
 * @param $entity_type
 *   The type of $entity.
 * @param $entities
 *   Array of entities being loaded, keyed by entity ID.
 * @param $field
 *   The field structure for the operation.
 * @param $instances
 *   Array of instance structures for $field for each entity, keyed by entity
 *   ID.
 * @param $langcode
 *   The language code associated with $items.
 * @param $items
 *   Array of field values already loaded for the entities, keyed by entity ID.
 *   Store your changes in this parameter (passed by reference).
 * @param $age
 *   FIELD_LOAD_CURRENT to load the most recent revision for all fields, or
 *   FIELD_LOAD_REVISION to load the version indicated by each entity.
 */
function $(name)_field_load($entity_type, $entities, $field, $instances, $langcode, &$items, $age) {
  // Sample code from text.module: precompute sanitized strings so they are
  // stored in the field cache.
  foreach ($entities as $id => $entity) {
    foreach ($items[$id] as $delta => $item) {
      // Only process items with a cacheable format, the rest will be handled
      // by formatters if needed.
      if (empty($instances[$id]['settings']['text_processing']) || filter_format_allowcache($item['format'])) {
        $items[$id][$delta]['safe_value'] = isset($item['value']) ? _text_sanitize($instances[$id], $langcode, $item, 'value') : '';
        if ($field['type'] == 'text_with_summary') {
          $items[$id][$delta]['safe_summary'] = isset($item['summary']) ? _text_sanitize($instances[$id], $langcode, $item, 'summary') : '';
        }
      }
    }
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_prepare_translation" xml:space="preserve">
		<code><![CDATA[/**
 * Define custom prepare_translation behavior for this module's field types.
 *
 * @param $entity_type
 *   The type of $entity.
 * @param $entity
 *   The entity for the operation.
 * @param $field
 *   The field structure for the operation.
 * @param $instance
 *   The instance structure for $field on $entity's bundle.
 * @param $langcode
 *   The language associated to $items.
 * @param $items
 *   $entity->{$field['field_name']}[$langcode], or an empty array if unset.
 * @param $source_entity
 *   The source entity from which field values are being copied.
 * @param $source_langcode
 *   The source language from which field values are being copied.
 */
function $(name)_field_prepare_translation($entity_type, $entity, $field, $instance, $langcode, &$items, $source_entity, $source_langcode) {
  // If the translating user is not permitted to use the assigned text format,
  // we must not expose the source values.
  $field_name = $field['field_name'];
  $formats = filter_formats();
  $format_id = $source_entity->{$field_name}[$source_langcode][0]['format'];
  if (!filter_access($formats[$format_id])) {
    $items = array();
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_prepare_view" xml:space="preserve">
		<code><![CDATA[/**
 * Allow formatters to load information for field values being displayed.
 *
 * This should be used when a formatter needs to load additional information
 * from the database in order to render a field, for example a reference field
 * which displays properties of the referenced entities such as name or type.
 *
 * This hook is called after the field type's own hook_field_prepare_view().
 *
 * Unlike most other field hooks, this hook operates on multiple entities. The
 * $entities, $instances and $items parameters are arrays keyed by entity ID.
 * For performance reasons, information for all available entities should be
 * loaded in a single query where possible.
 *
 * @param $entity_type
 *   The type of $entity.
 * @param $entities
 *   Array of entities being displayed, keyed by entity ID.
 * @param $field
 *   The field structure for the operation.
 * @param $instances
 *   Array of instance structures for $field for each entity, keyed by entity
 *   ID.
 * @param $langcode
 *   The language the field values are to be shown in. If no language is
 *   provided the current language is used.
 * @param $items
 *   Array of field values for the entities, keyed by entity ID.
 * @param $displays
 *   Array of display settings to use for each entity, keyed by entity ID.
 *
 * @return
 *   Changes or additions to field values are done by altering the $items
 *   parameter by reference.
 */
function $(name)_field_formatter_prepare_view($entity_type, $entities, $field, $instances, $langcode, &$items, $displays) {
  $tids = array();

  // Collect every possible term attached to any of the fieldable entities.
  foreach ($entities as $id => $entity) {
    foreach ($items[$id] as $delta => $item) {
      // Force the array key to prevent duplicates.
      $tids[$item['tid']] = $item['tid'];
    }
  }

  if ($tids) {
    $terms = taxonomy_term_load_multiple($tids);

    // Iterate through the fieldable entities again to attach the loaded term
    // data.
    foreach ($entities as $id => $entity) {
      $rekey = FALSE;

      foreach ($items[$id] as $delta => $item) {
        // Check whether the taxonomy term field instance value could be loaded.
        if (isset($terms[$item['tid']])) {
          // Replace the instance value with the term data.
          $items[$id][$delta]['taxonomy_term'] = $terms[$item['tid']];
        }
        // Otherwise, unset the instance value, since the term does not exist.
        else {
          unset($items[$id][$delta]);
          $rekey = TRUE;
        }
      }

      if ($rekey) {
        // Rekey the items array.
        $items[$id] = array_values($items[$id]);
      }
    }
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_presave" xml:space="preserve">
		<code><![CDATA[/**
 * Define custom presave behavior for this module's field types.
 *
 * Make changes or additions to field values by altering the $items parameter by
 * reference. There is no return value.
 *
 * @param $entity_type
 *   The type of $entity.
 * @param $entity
 *   The entity for the operation.
 * @param $field
 *   The field structure for the operation.
 * @param $instance
 *   The instance structure for $field on $entity's bundle.
 * @param $langcode
 *   The language associated with $items.
 * @param $items
 *   $entity->{$field['field_name']}[$langcode], or an empty array if unset.
 */
function $(name)_field_presave($entity_type, $entity, $field, $instance, $langcode, &$items) {
  if ($field['type'] == 'number_decimal') {
    // Let PHP round the value to ensure consistent behavior across storage
    // backends.
    foreach ($items as $delta => $item) {
      if (isset($item['value'])) {
        $items[$delta]['value'] = round($item['value'], $field['settings']['scale']);
      }
    }
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_purge_field" xml:space="preserve">
		<code><![CDATA[/**
 * Acts when a field record is being purged.
 *
 * In field_purge_field(), after the field configuration has been
 * removed from the database, the field storage module has had a chance to
 * run its hook_field_storage_purge_field(), and the field info cache
 * has been cleared, this hook is invoked on all modules to allow them to
 * respond to the field being purged.
 *
 * @param $field
 *   The field being purged.
 */
function $(name)_field_purge_field($field) {
  db_delete('my_module_field_info')
    ->condition('id', $field['id'])
    ->execute();
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_purge_instance" xml:space="preserve">
		<code><![CDATA[/**
 * Acts when a field instance is being purged.
 *
 * In field_purge_instance(), after the field instance has been
 * removed from the database, the field storage module has had a chance to
 * run its hook_field_storage_purge_instance(), and the field info cache
 * has been cleared, this hook is invoked on all modules to allow them to
 * respond to the field instance being purged.
 *
 * @param $instance
 *   The instance being purged.
 */
function $(name)_field_purge_instance($instance) {
  db_delete('my_module_field_instance_info')
    ->condition('id', $instance['id'])
    ->execute();
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_schema" xml:space="preserve">
		<code><![CDATA[/**
 * Define the Field API schema for a field structure.
 *
 * This hook MUST be defined in .install for it to be detected during
 * installation and upgrade.
 *
 * @param $field
 *   A field structure.
 *
 * @return
 *   An associative array with the following keys:
 *   - columns: An array of Schema API column specifications, keyed by column
 *     name. This specifies what comprises a value for a given field. For
 *     example, a value for a number field is simply 'value', while a value for
 *     a formatted text field is the combination of 'value' and 'format'. It is
 *     recommended to avoid having the column definitions depend on field
 *     settings when possible. No assumptions should be made on how storage
 *     engines internally use the original column name to structure their
 *     storage.
 *   - indexes: (optional) An array of Schema API indexes definitions. Only
 *     columns that appear in the 'columns' array are allowed. Those indexes
 *     will be used as default indexes. Callers of field_create_field() can
 *     specify additional indexes, or, at their own risk, modify the default
 *     indexes specified by the field-type module. Some storage engines might
 *     not support indexes.
 *   - foreign keys: (optional) An array of Schema API foreign keys
 *     definitions.
 */
function $(name)_field_schema($field) {
  if ($field['type'] == 'text_long') {
    $columns = array(
      'value' => array(
        'type' => 'text',
        'size' => 'big',
        'not null' => FALSE,
      ),
    );
  }
  else {
    $columns = array(
      'value' => array(
        'type' => 'varchar',
        'length' => $field['settings']['max_length'],
        'not null' => FALSE,
      ),
    );
  }
  $columns += array(
    'format' => array(
      'type' => 'varchar',
      'length' => 255,
      'not null' => FALSE,
    ),
  );
  return array(
    'columns' => $columns,
    'indexes' => array(
      'format' => array('format'),
    ),
    'foreign keys' => array(
      'format' => array(
        'table' => 'filter_format',
        'columns' => array('format' => 'format'),
      ),
    ),
  );
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_settings_form" xml:space="preserve">
		<code><![CDATA[/**
 * Add settings to a field settings form.
 *
 * @param $field
 *   The field structure being configured.
 * @param $instance
 *   The instance structure being configured.
 * @param $has_data
 *   TRUE if the field already has data, FALSE if not.
 *
 * @return
 *   The form definition for the field settings.
 */
function ${mymodule}_field_settings_form($field, $instance, $has_data) {
  $form = array();
  $settings = $field['settings'];${cursor}
  return $form;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_storage_create_field" xml:space="preserve">
		<code><![CDATA[/**
 * Act on creation of a new field.
 *
 * This hook is invoked from field_create_field() to ask the field storage
 * module to save field information and prepare for storing field instances.
 * If there is a problem, the field storage module should throw an exception.
 *
 * @param $field
 *   The field structure being created.
 */
function $(name)_field_storage_create_field($field) {
  $schema = _field_sql_storage_schema($field);
  foreach ($schema as $name => $table) {
    db_create_table($name, $table);
  }
  drupal_get_schema(NULL, TRUE);
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_storage_delete" xml:space="preserve">
		<code><![CDATA[/**
 * Act on deletion of a field.
 *
 * This hook is invoked from field_delete_field() to ask the field storage
 * module to mark all information stored in the field for deletion.
 *
 * @param $field
 *   The field being deleted.
 */
function $(name)_field_storage_delete_field($field) {
  // Mark all data associated with the field for deletion.
  $field['deleted'] = 0;
  $table = _field_sql_storage_tablename($field);
  $revision_table = _field_sql_storage_revision_tablename($field);
  db_update($table)
    ->fields(array('deleted' => 1))
    ->execute();

  // Move the table to a unique name while the table contents are being deleted.
  $field['deleted'] = 1;
  $new_table = _field_sql_storage_tablename($field);
  $revision_new_table = _field_sql_storage_revision_tablename($field);
  db_rename_table($table, $new_table);
  db_rename_table($revision_table, $revision_new_table);
  drupal_get_schema(NULL, TRUE);
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_storage_delete_field" xml:space="preserve">
		<code><![CDATA[/**
 * Act on deletion of a field.
 *
 * This hook is invoked from field_delete_field() to ask the field storage
 * module to mark all information stored in the field for deletion.
 *
 * @param $field
 *   The field being deleted.
 */
function $(name)_field_storage_delete_field($field) {
  // Mark all data associated with the field for deletion.
  $field['deleted'] = 0;
  $table = _field_sql_storage_tablename($field);
  $revision_table = _field_sql_storage_revision_tablename($field);
  db_update($table)
    ->fields(array('deleted' => 1))
    ->execute();

  // Move the table to a unique name while the table contents are being deleted.
  $field['deleted'] = 1;
  $new_table = _field_sql_storage_tablename($field);
  $revision_new_table = _field_sql_storage_revision_tablename($field);
  db_rename_table($table, $new_table);
  db_rename_table($revision_table, $revision_new_table);
  drupal_get_schema(NULL, TRUE);
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_storage_delete_instance" xml:space="preserve">
		<code><![CDATA[/**
 * Act on deletion of a field instance.
 *
 * This hook is invoked from field_delete_instance() to ask the field storage
 * module to mark all information stored for the field instance for deletion.
 *
 * @param $instance
 *   The instance being deleted.
 */
function $(name)_field_storage_delete_instance($instance) {
  $field = field_info_field($instance['field_name']);
  $table_name = _field_sql_storage_tablename($field);
  $revision_name = _field_sql_storage_revision_tablename($field);
  db_update($table_name)
    ->fields(array('deleted' => 1))
    ->condition('entity_type', $instance['entity_type'])
    ->condition('bundle', $instance['bundle'])
    ->execute();
  db_update($revision_name)
    ->fields(array('deleted' => 1))
    ->condition('entity_type', $instance['entity_type'])
    ->condition('bundle', $instance['bundle'])
    ->execute();
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_storage_delete_revision" xml:space="preserve">
		<code><![CDATA[/**
 * Delete a single revision of field data for an entity.
 *
 * This hook is invoked from field_attach_delete_revision() to ask the field
 * storage module to delete field revision data.
 *
 * Deleting the current (most recently written) revision is not
 * allowed as has undefined results.
 *
 * @param $entity_type
 *   The entity type of entity, such as 'node' or 'user'.
 * @param $entity
 *   The entity on which to operate. The revision to delete is
 *   indicated by the entity's revision ID property, as identified by
 *   hook_fieldable_info() for $entity_type.
 * @param $fields
 *   An array listing the fields to delete. The keys and values of the
 *   array are field IDs.
 */
function $(name)_field_storage_delete_revision($entity_type, $entity, $fields) {
  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);

  if (isset($vid)) {
    foreach ($fields as $field_id) {
      $field = field_info_field_by_id($field_id);
      $revision_name = _field_sql_storage_revision_tablename($field);
      db_delete($revision_name)
        ->condition('entity_type', $entity_type)
        ->condition('entity_id', $id)
        ->condition('revision_id', $vid)
        ->execute();
    }
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_storage_details" xml:space="preserve">
		<code><![CDATA[/**
 * Reveal the internal details about the storage for a field.
 *
 * For example, an SQL storage module might return the Schema API structure for
 * the table. A key/value storage module might return the server name,
 * authentication credentials, and bin name.
 *
 * Field storage modules are not obligated to implement this hook. Modules
 * that rely on these details must only use them for read operations.
 *
 * @param $field
 *   A field structure.
 *
 * @return
 *   An array of details.
 *    - The first dimension is a store type (sql, solr, etc).
 *    - The second dimension indicates the age of the values in the store
 *      FIELD_LOAD_CURRENT or FIELD_LOAD_REVISION.
 *    - Other dimensions are specific to the field storage module.
 *
 * @see hook_field_storage_details_alter()
 */
function $(name)_field_storage_details($field) {
  $details = array();

  // Add field columns.
  foreach ((array) $field['columns'] as $column_name => $attributes) {
    $real_name = _field_sql_storage_columnname($field['field_name'], $column_name);
    $columns[$column_name] = $real_name;
  }
  return array(
    'sql' => array(
      FIELD_LOAD_CURRENT => array(
        _field_sql_storage_tablename($field) => $columns,
      ),
      FIELD_LOAD_REVISION => array(
        _field_sql_storage_revision_tablename($field) => $columns,
      ),
    ),
  );
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_storage_details_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Perform alterations on Field API storage details.
 *
 * @param $details
 *   An array of storage details for fields as exposed by
 *   hook_field_storage_details() implementations.
 * @param $field
 *   A field structure.
 *
 * @see hook_field_storage_details()
 */
function $(name)_field_storage_details_alter(&$details, $field) {
  if ($field['field_name'] == 'field_of_interest') {
    $columns = array();
    foreach ((array) $field['columns'] as $column_name => $attributes) {
      $columns[$column_name] = $column_name;
    }
    $details['drupal_variables'] = array(
      FIELD_LOAD_CURRENT => array(
        'moon' => $columns,
      ),
      FIELD_LOAD_REVISION => array(
        'mars' => $columns,
      ),
    );
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_storage_info" xml:space="preserve">
		<code><![CDATA[/**
 * Expose Field API storage backends.
 *
 * @return
 *   An array describing the storage backends implemented by the module.
 *   The keys are storage backend names. To avoid name clashes, storage backend
 *   names should be prefixed with the name of the module that exposes them.
 *   The values are arrays describing the storage backend, with the following
 *   key/value pairs:
 *   - label: The human-readable name of the storage backend.
 *   - description: A short description for the storage backend.
 *   - settings: An array whose keys are the names of the settings available
 *     for the storage backend, and whose values are the default values for
 *     those settings.
 */
function $(name)_field_storage_info() {
  return array(
    'field_sql_storage' => array(
      'label' => t('Default SQL storage'),
      'description' => t('Stores fields in the local SQL database, using per-field tables.'),
      'settings' => array(),
    ),
  );
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_storage_info_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Perform alterations on Field API storage types.
 *
 * @param $info
 *   Array of informations on storage types exposed by
 *   hook_field_field_storage_info() implementations.
 */
function $(name)_field_storage_info_alter(&$info) {
  // Add a setting to a storage type.
  $info['field_sql_storage']['settings'] += array(
    'mymodule_additional_setting' => 'default value',
  );
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_storage_load" xml:space="preserve">
		<code><![CDATA[/**
 * Load field data for a set of entities.
 *
 * This hook is invoked from field_attach_load() to ask the field storage
 * module to load field data.
 *
 * Modules implementing this hook should load field values and add them to
 * objects in $entities. Fields with no values should be added as empty
 * arrays.
 *
 * @param $entity_type
 *   The type of entity, such as 'node' or 'user'.
 * @param $entities
 *   The array of entity objects to add fields to, keyed by entity ID.
 * @param $age
 *   FIELD_LOAD_CURRENT to load the most recent revision for all fields, or
 *   FIELD_LOAD_REVISION to load the version indicated by each entity.
 * @param $fields
 *   An array listing the fields to be loaded. The keys of the array are field
 *   IDs, and the values of the array are the entity IDs (or revision IDs,
 *   depending on the $age parameter) to add each field to.
 * @param $options
 *   An associative array of additional options, with the following keys:
 *   - deleted: If TRUE, deleted fields should be loaded as well as
 *     non-deleted fields. If unset or FALSE, only non-deleted fields should be
 *     loaded.
 */
function $(name)_field_storage_load($entity_type, $entities, $age, $fields, $options) {
  $field_info = field_info_field_by_ids();
  $load_current = $age == FIELD_LOAD_CURRENT;

  foreach ($fields as $field_id => $ids) {
    $field = $field_info[$field_id];
    $field_name = $field['field_name'];
    $table = $load_current ? _field_sql_storage_tablename($field) : _field_sql_storage_revision_tablename($field);

    $query = db_select($table, 't')
      ->fields('t')
      ->condition('entity_type', $entity_type)
      ->condition($load_current ? 'entity_id' : 'revision_id', $ids, 'IN')
      ->condition('language', field_available_languages($entity_type, $field), 'IN')
      ->orderBy('delta');

    if (empty($options['deleted'])) {
      $query->condition('deleted', 0);
    }

    $results = $query->execute();

    $delta_count = array();
    foreach ($results as $row) {
      if (!isset($delta_count[$row->entity_id][$row->language])) {
        $delta_count[$row->entity_id][$row->language] = 0;
      }

      if ($field['cardinality'] == FIELD_CARDINALITY_UNLIMITED || $delta_count[$row->entity_id][$row->language] < $field['cardinality']) {
        $item = array();
        // For each column declared by the field, populate the item
        // from the prefixed database column.
        foreach ($field['columns'] as $column => $attributes) {
          $column_name = _field_sql_storage_columnname($field_name, $column);
          $item[$column] = $row->$column_name;
        }

        // Add the item to the field values for the entity.
        $entities[$row->entity_id]->{$field_name}[$row->language][] = $item;
        $delta_count[$row->entity_id][$row->language]++;
      }
    }
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_storage_pre_insert" xml:space="preserve">
		<code><![CDATA[/**
 * Act before the storage backends insert field data.
 *
 * This hook allows modules to store data before the Field Storage API,
 * optionally preventing the field storage module from doing so.
 *
 * @param $entity_type
 *   The type of $entity; for example, 'node' or 'user'.
 * @param $entity
 *   The entity with fields to save.
 * @param $skip_fields
 *   An array keyed by field IDs whose data has already been written and
 *   therefore should not be written again. The values associated with these
 *   keys are not specified.
 * @return
 *   Saved field IDs are set set as keys in $skip_fields.
 */
function $(name)_field_storage_pre_insert($entity_type, $entity, &$skip_fields) {
  if ($entity_type == 'node' && $entity->status && _forum_node_check_node_type($entity)) {
    $query = db_insert('forum_index')->fields(array('nid', 'title', 'tid', 'sticky', 'created', 'comment_count', 'last_comment_timestamp'));
    foreach ($entity->taxonomy_forums as $language) {
      foreach ($language as $delta) {
        $query->values(array(
          'nid' => $entity->nid,
          'title' => $entity->title,
          'tid' => $delta['value'],
          'sticky' => $entity->sticky,
          'created' => $entity->created,
          'comment_count' => 0,
          'last_comment_timestamp' => $entity->created,
        ));
      }
    }
    $query->execute();
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_storage_pre_update" xml:space="preserve">
		<code><![CDATA[/**
 * Act before the storage backends update field data.
 *
 * This hook allows modules to store data before the Field Storage API,
 * optionally preventing the field storage module from doing so.
 *
 * @param $entity_type
 *   The type of $entity; for example, 'node' or 'user'.
 * @param $entity
 *   The entity with fields to save.
 * @param $skip_fields
 *   An array keyed by field IDs whose data has already been written and
 *   therefore should not be written again. The values associated with these
 *   keys are not specified.
 * @return
 *   Saved field IDs are set set as keys in $skip_fields.
 */
function $(name)_field_storage_pre_update($entity_type, $entity, &$skip_fields) {
  $first_call = &drupal_static(__FUNCTION__, array());

  if ($entity_type == 'node' && $entity->status && _forum_node_check_node_type($entity)) {
    // We don't maintain data for old revisions, so clear all previous values
    // from the table. Since this hook runs once per field, per entity, make
    // sure we only wipe values once.
    if (!isset($first_call[$entity->nid])) {
      $first_call[$entity->nid] = FALSE;
      db_delete('forum_index')->condition('nid', $entity->nid)->execute();
    }
    // Only save data to the table if the node is published.
    if ($entity->status) {
      $query = db_insert('forum_index')->fields(array('nid', 'title', 'tid', 'sticky', 'created', 'comment_count', 'last_comment_timestamp'));
      foreach ($entity->taxonomy_forums as $language) {
        foreach ($language as $delta) {
          $query->values(array(
            'nid' => $entity->nid,
            'title' => $entity->title,
            'tid' => $delta['value'],
            'sticky' => $entity->sticky,
            'created' => $entity->created,
            'comment_count' => 0,
            'last_comment_timestamp' => $entity->created,
          ));
        }
      }
      $query->execute();
      // The logic for determining last_comment_count is fairly complex, so
      // call _forum_update_forum_index() too.
      _forum_update_forum_index($entity->nid);
    }
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_storage_purge" xml:space="preserve">
		<code><![CDATA[/**
 * Remove field storage information when field data is purged.
 *
 * Called from field_purge_data() to allow the field storage
 * module to delete field data information.
 *
 * @param $entity_type
 *   The type of $entity; for example, 'node' or 'user'.
 * @param $entity
 *   The pseudo-entity whose field data to delete.
 * @param $field
 *   The (possibly deleted) field whose data is being purged.
 * @param $instance
 *   The deleted field instance whose data is being purged.
 */
function $(name)_field_storage_purge($entity_type, $entity, $field, $instance) {
  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);

  $table_name = _field_sql_storage_tablename($field);
  $revision_name = _field_sql_storage_revision_tablename($field);
  db_delete($table_name)
    ->condition('entity_type', $entity_type)
    ->condition('entity_id', $id)
    ->execute();
  db_delete($revision_name)
    ->condition('entity_type', $entity_type)
    ->condition('entity_id', $id)
    ->execute();
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_storage_purge_field" xml:space="preserve">
		<code><![CDATA[/**
 * Remove field storage information when a field record is purged.
 *
 * Called from field_purge_field() to allow the field storage module
 * to remove field information when a field is being purged.
 *
 * @param $field
 *   The field being purged.
 */
function $(name)_field_storage_purge_field($field) {
  $table_name = _field_sql_storage_tablename($field);
  $revision_name = _field_sql_storage_revision_tablename($field);
  db_drop_table($table_name);
  db_drop_table($revision_name);
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_storage_purge_field_instance" xml:space="preserve">
		<code><![CDATA[/**
 * Remove field storage information when a field instance is purged.
 *
 * Called from field_purge_instance() to allow the field storage module
 * to remove field instance information when a field instance is being
 * purged.
 *
 * @param $instance
 *   The instance being purged.
 */
function $(name)_field_storage_purge_field_instance($instance) {
  db_delete('my_module_field_instance_info')
    ->condition('id', $instance['id'])
    ->execute();
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_storage_query" xml:space="preserve">
		<code><![CDATA[/**
 * Execute an EntityFieldQuery.
 *
 * This hook is called to find the entities having certain entity and field
 * conditions and sort them in the given field order. If the field storage
 * engine also handles property sorts and orders, it should unset those
 * properties in the called object to signal that those have been handled.
 *
 * @param EntityFieldQuery $query
 *   An EntityFieldQuery.
 *
 * @return
 *   See EntityFieldQuery::execute() for the return values.
 */
function $(name)_field_storage_query($query) {
  $groups = array();
  if ($query->age == FIELD_LOAD_CURRENT) {
    $tablename_function = '_field_sql_storage_tablename';
    $id_key = 'entity_id';
  }
  else {
    $tablename_function = '_field_sql_storage_revision_tablename';
    $id_key = 'revision_id';
  }
  $table_aliases = array();
  // Add tables for the fields used.
  foreach ($query->fields as $key => $field) {
    $tablename = $tablename_function($field);
    // Every field needs a new table.
    $table_alias = $tablename . $key;
    $table_aliases[$key] = $table_alias;
    if ($key) {
      $select_query->join($tablename, $table_alias, "$table_alias.entity_type = $field_base_table.entity_type AND $table_alias.$id_key = $field_base_table.$id_key");
    }
    else {
      $select_query = db_select($tablename, $table_alias);
      $select_query->addTag('entity_field_access');
      $select_query->addMetaData('base_table', $tablename);
      $select_query->fields($table_alias, array('entity_type', 'entity_id', 'revision_id', 'bundle'));
      $field_base_table = $table_alias;
    }
    if ($field['cardinality'] != 1) {
      $select_query->distinct();
    }
  }

  // Add field conditions.
  foreach ($query->fieldConditions as $key => $condition) {
    $table_alias = $table_aliases[$key];
    $field = $condition['field'];
    // Add the specified condition.
    $sql_field = "$table_alias." . _field_sql_storage_columnname($field['field_name'], $condition['column']);
    $query->addCondition($select_query, $sql_field, $condition);
    // Add delta / language group conditions.
    foreach (array('delta', 'language') as $column) {
      if (isset($condition[$column . '_group'])) {
        $group_name = $condition[$column . '_group'];
        if (!isset($groups[$column][$group_name])) {
          $groups[$column][$group_name] = $table_alias;
        }
        else {
          $select_query->where("$table_alias.$column = " . $groups[$column][$group_name] . ".$column");
        }
      }
    }
  }

  if (isset($query->deleted)) {
    $select_query->condition("$field_base_table.deleted", (int) $query->deleted);
  }

  // Is there a need to sort the query by property?
  $has_property_order = FALSE;
  foreach ($query->order as $order) {
    if ($order['type'] == 'property') {
      $has_property_order = TRUE;
    }
  }

  if ($query->propertyConditions || $has_property_order) {
    if (empty($query->entityConditions['entity_type']['value'])) {
      throw new EntityFieldQueryException('Property conditions and orders must have an entity type defined.');
    }
    $entity_type = $query->entityConditions['entity_type']['value'];
    $entity_base_table = _field_sql_storage_query_join_entity($select_query, $entity_type, $field_base_table);
    $query->entityConditions['entity_type']['operator'] = '=';
    foreach ($query->propertyConditions as $property_condition) {
      $query->addCondition($select_query, "$entity_base_table." . $property_condition['column'], $property_condition);
    }
  }
  foreach ($query->entityConditions as $key => $condition) {
    $query->addCondition($select_query, "$field_base_table.$key", $condition);
  }

  // Order the query.
  foreach ($query->order as $order) {
    if ($order['type'] == 'entity') {
      $key = $order['specifier'];
      $select_query->orderBy("$field_base_table.$key", $order['direction']);
    }
    elseif ($order['type'] == 'field') {
      $specifier = $order['specifier'];
      $field = $specifier['field'];
      $table_alias = $table_aliases[$specifier['index']];
      $sql_field = "$table_alias." . _field_sql_storage_columnname($field['field_name'], $specifier['column']);
      $select_query->orderBy($sql_field, $order['direction']);
    }
    elseif ($order['type'] == 'property') {
      $select_query->orderBy("$entity_base_table." . $order['specifier'], $order['direction']);
    }
  }

  return $query->finishQuery($select_query, $id_key);
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_storage_update_field" xml:space="preserve">
		<code><![CDATA[/**
 * Update the storage information for a field.
 *
 * This is invoked on the field's storage module from field_update_field(),
 * before the new field information is saved to the database. The field storage
 * module should update its storage tables to agree with the new field
 * information. If there is a problem, the field storage module should throw an
 * exception.
 *
 * @param $field
 *   The updated field structure to be saved.
 * @param $prior_field
 *   The previously-saved field structure.
 * @param $has_data
 *   TRUE if the field has data in storage currently.
 */
function $(name)_field_storage_update_field($field, $prior_field, $has_data) {
  if (!$has_data) {
    // There is no data. Re-create the tables completely.
    $prior_schema = _field_sql_storage_schema($prior_field);
    foreach ($prior_schema as $name => $table) {
      db_drop_table($name, $table);
    }
    $schema = _field_sql_storage_schema($field);
    foreach ($schema as $name => $table) {
      db_create_table($name, $table);
    }
  }
  else {
    // There is data. See field_sql_storage_field_storage_update_field() for
    // an example of what to do to modify the schema in place, preserving the
    // old data as much as possible.
  }
  drupal_get_schema(NULL, TRUE);
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_storage_write" xml:space="preserve">
		<code><![CDATA[/**
 * Write field data for an entity.
 *
 * This hook is invoked from field_attach_insert() and field_attach_update(),
 * to ask the field storage module to save field data.
 *
 * @param $entity_type
 *   The entity type of entity, such as 'node' or 'user'.
 * @param $entity
 *   The entity on which to operate.
 * @param $op
 *   FIELD_STORAGE_UPDATE when updating an existing entity,
 *   FIELD_STORAGE_INSERT when inserting a new entity.
 * @param $fields
 *   An array listing the fields to be written. The keys and values of the
 *   array are field IDs.
 */
function $(name)_field_storage_write($entity_type, $entity, $op, $fields) {
  list($id, $vid, $bundle) = entity_extract_ids($entity_type, $entity);
  if (!isset($vid)) {
    $vid = $id;
  }

  foreach ($fields as $field_id) {
    $field = field_info_field_by_id($field_id);
    $field_name = $field['field_name'];
    $table_name = _field_sql_storage_tablename($field);
    $revision_name = _field_sql_storage_revision_tablename($field);

    $all_languages = field_available_languages($entity_type, $field);
    $field_languages = array_intersect($all_languages, array_keys((array) $entity->$field_name));

    // Delete and insert, rather than update, in case a value was added.
    if ($op == FIELD_STORAGE_UPDATE) {
      // Delete languages present in the incoming $entity->$field_name.
      // Delete all languages if $entity->$field_name is empty.
      $languages = !empty($entity->$field_name) ? $field_languages : $all_languages;
      if ($languages) {
        db_delete($table_name)
          ->condition('entity_type', $entity_type)
          ->condition('entity_id', $id)
          ->condition('language', $languages, 'IN')
          ->execute();
        db_delete($revision_name)
          ->condition('entity_type', $entity_type)
          ->condition('entity_id', $id)
          ->condition('revision_id', $vid)
          ->condition('language', $languages, 'IN')
          ->execute();
      }
    }

    // Prepare the multi-insert query.
    $do_insert = FALSE;
    $columns = array('entity_type', 'entity_id', 'revision_id', 'bundle', 'delta', 'language');
    foreach ($field['columns'] as $column => $attributes) {
      $columns[] = _field_sql_storage_columnname($field_name, $column);
    }
    $query = db_insert($table_name)->fields($columns);
    $revision_query = db_insert($revision_name)->fields($columns);

    foreach ($field_languages as $langcode) {
      $items = (array) $entity->{$field_name}[$langcode];
      $delta_count = 0;
      foreach ($items as $delta => $item) {
        // We now know we have someting to insert.
        $do_insert = TRUE;
        $record = array(
          'entity_type' => $entity_type,
          'entity_id' => $id,
          'revision_id' => $vid,
          'bundle' => $bundle,
          'delta' => $delta,
          'language' => $langcode,
        );
        foreach ($field['columns'] as $column => $attributes) {
          $record[_field_sql_storage_columnname($field_name, $column)] = isset($item[$column]) ? $item[$column] : NULL;
        }
        $query->values($record);
        if (isset($vid)) {
          $revision_query->values($record);
        }

        if ($field['cardinality'] != FIELD_CARDINALITY_UNLIMITED && ++$delta_count == $field['cardinality']) {
          break;
        }
      }
    }

    // Execute the query if we have values to insert.
    if ($do_insert) {
      $query->execute();
      $revision_query->execute();
    }
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_update" xml:space="preserve">
		<code><![CDATA[/**
 * Define custom update behavior for this module's field data.
 *
 * This hook is invoked from field_attach_update() on the module that defines a
 * field, during the process of updating an entity object (node, taxonomy term,
 * etc.). It is invoked just before the data for this field on the particular
 * entity object is updated into field storage. Only field modules that are
 * storing or tracking information outside the standard field storage mechanism
 * need to implement this hook.
 *
 * @param $entity_type
 *   The type of $entity.
 * @param $entity
 *   The entity for the operation.
 * @param $field
 *   The field structure for the operation.
 * @param $instance
 *   The instance structure for $field on $entity's bundle.
 * @param $langcode
 *   The language associated with $items.
 * @param $items
 *   $entity->{$field['field_name']}[$langcode], or an empty array if unset.
 *
 * @see hook_field_insert()
 * @see hook_field_delete()
 */
function $(name)_field_update($entity_type, $entity, $field, $instance, $langcode, &$items) {
  if (variable_get('taxonomy_maintain_index_table', TRUE) && $field['storage']['type'] == 'field_sql_storage' && $entity_type == 'node') {
    $first_call = &drupal_static(__FUNCTION__, array());

    // We don't maintain data for old revisions, so clear all previous values
    // from the table. Since this hook runs once per field, per object, make
    // sure we only wipe values once.
    if (!isset($first_call[$entity->nid])) {
      $first_call[$entity->nid] = FALSE;
      db_delete('taxonomy_index')->condition('nid', $entity->nid)->execute();
    }
    // Only save data to the table if the node is published.
    if ($entity->status) {
      $query = db_insert('taxonomy_index')->fields(array('nid', 'tid', 'sticky', 'created'));
      foreach ($items as $item) {
        $query->values(array(
          'nid' => $entity->nid,
          'tid' => $item['tid'],
          'sticky' => $entity->sticky,
          'created' => $entity->created,
        ));
      }
      $query->execute();
    }
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_update_field" xml:space="preserve">
		<code><![CDATA[/**
 * Act on a field being updated.
 *
 * This hook is invoked just after field is updated in field_update_field().
 *
 * @param $field
 *   The field as it is post-update.
 * @param $prior_field
 *   The field as it was pre-update.
 * @param $has_data
 *   Whether any data already exists for this field.
 */
function $(name)_field_update_field($field, $prior_field, $has_data) {
  // Reset the static value that keeps track of allowed values for list fields.
  drupal_static_reset('list_allowed_values');
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_update_forbid" xml:space="preserve">
		<code><![CDATA[/**
 * Forbid a field update from occurring.
 *
 * Any module may forbid any update for any reason. For example, the
 * field's storage module might forbid an update if it would change
 * the storage schema while data for the field exists. A field type
 * module might forbid an update if it would change existing data's
 * semantics, or if there are external dependencies on field settings
 * that cannot be updated.
 *
 * To forbid the update from occurring, throw a FieldUpdateForbiddenException.
 *
 * @param $field
 *   The field as it will be post-update.
 * @param $prior_field
 *   The field as it is pre-update.
 * @param $has_data
 *   Whether any data already exists for this field.
 */
function $(name)_field_update_forbid($field, $prior_field, $has_data) {
  // A 'list' field stores integer keys mapped to display values. If
  // the new field will have fewer values, and any data exists for the
  // abandoned keys, the field will have no way to display them. So,
  // forbid such an update.
  if ($has_data && count($field['settings']['allowed_values']) < count($prior_field['settings']['allowed_values'])) {
    // Identify the keys that will be lost.
    $lost_keys = array_diff(array_keys($field['settings']['allowed_values']), array_keys($prior_field['settings']['allowed_values']));
    // If any data exist for those keys, forbid the update.
    $query = new EntityFieldQuery();
    $found = $query
      ->fieldCondition($prior_field['field_name'], 'value', $lost_keys)
      ->range(0, 1)
      ->execute();
    if ($found) {
      throw new FieldUpdateForbiddenException("Cannot update a list field not to include keys with existing data");
    }
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_validate" xml:space="preserve">
		<code><![CDATA[/**
 * Validate this module's field data.
 *
 * If there are validation problems, add to the $errors array (passed by
 * reference). There is no return value.
 *
 * @param $entity_type
 *   The type of $entity.
 * @param $entity
 *   The entity for the operation.
 * @param $field
 *   The field structure for the operation.
 * @param $instance
 *   The instance structure for $field on $entity's bundle.
 * @param $langcode
 *   The language associated with $items.
 * @param $items
 *   $entity->{$field['field_name']}[$langcode], or an empty array if unset.
 * @param $errors
 *   The array of errors (keyed by field name, language code, and delta) that
 *   have already been reported for the entity. The function should add its
 *   errors to this array. Each error is an associative array with the following
 *   keys and values:
 *   - error: An error code (should be a string prefixed with the module name).
 *   - message: The human readable message to be displayed.
 */
function $(name)_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  foreach ($items as $delta => $item) {
    if (!empty($item['value'])) {
      if (!empty($field['settings']['max_length']) && drupal_strlen($item['value']) > $field['settings']['max_length']) {
        $errors[$field['field_name']][$langcode][$delta][] = array(
          'error' => 'text_max_length',
          'message' => t('%name: the value may not be longer than %max characters.', array('%name' => $instance['label'], '%max' => $field['settings']['max_length'])),
        );
      }
    }
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_widget_error" xml:space="preserve">
		<code><![CDATA[/**
 * Flag a field-level validation error.
 *
 * @param $element
 *   An array containing the form element for the widget. The error needs to be
 *   flagged on the right sub-element, according to the widget's internal
 *   structure.
 * @param $error
 *   An associative array with the following key-value pairs, as returned by
 *   hook_field_validate():
 *   - error: the error code. Complex widgets might need to report different
 *     errors to different form elements inside the widget.
 *   - message: the human readable message to be displayed.
 * @param $form
 *   The form structure where field elements are attached to. This might be a
 *   full form structure, or a sub-element of a larger form.
 * @param $form_state
 *   An associative array containing the current state of the form.
 */
function $(name)_field_widget_error($element, $error, $form, &$form_state) {
  form_error($element, $error['message']);
}
]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_widget_form" xml:space="preserve">
		<code><![CDATA[/**
 * Return the form for a single field widget.
 *
 * Field widget form elements should be based on the passed-in $element, which
 * contains the base form element properties derived from the field
 * configuration.
 *
 * Field API will set the weight, field name and delta values for each form
 * element. If there are multiple values for this field, the Field API will
 * invoke this hook as many times as needed.
 *
 * Note that, depending on the context in which the widget is being included
 * (regular entity form, field configuration form, advanced search form...),
 * the values for $field and $instance might be different from the "official"
 * definitions returned by field_info_field() and field_info_instance().
 * Examples: mono-value widget even if the field is multi-valued, non-required
 * widget even if the field is 'required'...
 *
 * Therefore, the FAPI element callbacks (such as #process, #element_validate,
 * #value_callback...) used by the widget cannot use the field_info_field()
 * or field_info_instance() functions to retrieve the $field or $instance
 * definitions they should operate on. The field_widget_field() and
 * field_widget_instance() functions should be used instead to fetch the
 * current working definitions from $form_state, where Field API stores them.
 *
 * Alternatively, hook_field_widget_form() can extract the needed specific
 * properties from $field and $instance and set them as ad-hoc
 * $element['#custom'] properties, for later use by its element callbacks.
 *
 * Other modules may alter the form element provided by this function using
 * hook_field_widget_form_alter().
 *
 * @param $form
 *   The form structure where widgets are being attached to. This might be a
 *   full form structure, or a sub-element of a larger form.
 * @param $form_state
 *   An associative array containing the current state of the form.
 * @param $field
 *   The field structure.
 * @param $instance
 *   The field instance.
 * @param $langcode
 *   The language associated with $items.
 * @param $items
 *   Array of default values for this field.
 * @param $delta
 *   The order of this item in the array of subelements (0, 1, 2, etc).
 * @param $element
 *   A form element array containing basic properties for the widget:
 *   - #entity_type: The name of the entity the field is attached to.
 *   - #bundle: The name of the field bundle the field is contained in.
 *   - #field_name: The name of the field.
 *   - #language: The language the field is being edited in.
 *   - #field_parents: The 'parents' space for the field in the form. Most
 *       widgets can simply overlook this property. This identifies the
 *       location where the field values are placed within
 *       $form_state['values'], and is used to access processing information
 *       for the field through the field_form_get_state() and
 *       field_form_set_state() functions.
 *   - #columns: A list of field storage columns of the field.
 *   - #title: The sanitized element label for the field instance, ready for
 *     output.
 *   - #description: The sanitized element description for the field instance,
 *     ready for output.
 *   - #required: A Boolean indicating whether the element value is required;
 *     for required multiple value fields, only the first widget's values are
 *     required.
 *   - #delta: The order of this item in the array of subelements; see $delta
 *     above.
 *
 * @return
 *   The form elements for a single widget for this field.
 *
 * @see field_widget_field()
 * @see field_widget_instance()
 * @see hook_field_widget_form_alter()
 * @see hook_field_widget_WIDGET_TYPE_form_alter()
 */
function $(name)_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $element += array(
    '#type' => $instance['widget']['type'],
    '#default_value' => isset($items[$delta]) ? $items[$delta] : '',
  );
  return $element;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_widget_form_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Alter forms for field widgets provided by other modules.
 *
 * @param $element
 *   The field widget form element as constructed by hook_field_widget_form().
 * @param $form_state
 *   An associative array containing the current state of the form.
 * @param $context
 *   An associative array containing the following key-value pairs, matching the
 *   arguments received by hook_field_widget_form():
 *   - form: The form structure to which widgets are being attached. This may be
 *     a full form structure, or a sub-element of a larger form.
 *   - field: The field structure.
 *   - instance: The field instance structure.
 *   - langcode: The language associated with $items.
 *   - items: Array of default values for this field.
 *   - delta: The order of this item in the array of subelements (0, 1, 2, etc).
 *
 * @see hook_field_widget_form()
 * @see hook_field_widget_WIDGET_TYPE_form_alter()
 */
function $(name)_field_widget_form_alter(&$element, &$form_state, $context) {
  // Add a css class to widget form elements for all fields of type mytype.
  if ($context['field']['type'] == 'mytype') {
    // Be sure not to overwrite existing attributes.
    $element['#attributes']['class'][] = 'myclass';
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_widget_info" xml:space="preserve">
		<code><![CDATA[/**
 * Expose Field API widget types.
 *
 * @return
 *   An array describing the widget types implemented by the module.
 *   The keys are widget type names. To avoid name clashes, widget type
 *   names should be prefixed with the name of the module that exposes them.
 *   The values are arrays describing the widget type, with the following
 *   key/value pairs:
 *   - label: The human-readable name of the widget type.
 *   - description: A short description for the widget type.
 *   - field types: An array of field types the widget supports.
 *   - settings: An array whose keys are the names of the settings available
 *     for the widget type, and whose values are the default values for those
 *     settings.
 *   - behaviors: (optional) An array describing behaviors of the widget, with
 *     the following elements:
 *     - multiple values: One of the following constants:
 *       - FIELD_BEHAVIOR_DEFAULT: (default) If the widget allows the input of
 *         one single field value (most common case). The widget will be
 *         repeated for each value input.
 *       - FIELD_BEHAVIOR_CUSTOM: If one single copy of the widget can receive
 *         several field values. Examples: checkboxes, multiple select,
 *         comma-separated textfield.
 *     - default value: One of the following constants:
 *       - FIELD_BEHAVIOR_DEFAULT: (default) If the widget accepts default
 *         values.
 *       - FIELD_BEHAVIOR_NONE: if the widget does not support default values.
 *   - weight: (optional) An integer to determine the weight of this widget
 *     relative to other widgets in the Field UI when selecting a widget for a
 *     given field instance.
 *
 * @see hook_field_widget_info_alter()
 * @see hook_field_widget_form()
 * @see hook_field_widget_form_alter()
 * @see hook_field_widget_WIDGET_TYPE_form_alter()
 * @see hook_field_widget_error()
 * @see hook_field_widget_settings_form()
 */
function $(name)_field_widget_info() {
  return array(
    'text_textfield' => array(
      'label' => t('Text field'),
      'field types' => array('text'),
      'settings' => array('size' => 60),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_DEFAULT,
        'default value' => FIELD_BEHAVIOR_DEFAULT,
      ),
    ),
    'text_textarea' => array(
      'label' => t('Text area (multiple rows)'),
      'field types' => array('text_long'),
      'settings' => array('rows' => 5),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_DEFAULT,
        'default value' => FIELD_BEHAVIOR_DEFAULT,
      ),
    ),
    'text_textarea_with_summary' => array(
      'label' => t('Text area with a summary'),
      'field types' => array('text_with_summary'),
      'settings' => array('rows' => 20, 'summary_rows' => 5),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_DEFAULT,
        'default value' => FIELD_BEHAVIOR_DEFAULT,
      ),
      // As an advanced widget, force it to sink to the bottom of the choices.
      'weight' => 2,
    ),
  );
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_widget_info_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Perform alterations on Field API widget types.
 *
 * @param $info
 *   Array of informations on widget types exposed by hook_field_widget_info()
 *   implementations.
 */
function $(name)_field_widget_info_alter(&$info) {
  // Add a setting to a widget type.
  $info['text_textfield']['settings'] += array(
    'mymodule_additional_setting' => 'default value',
  );

  // Let a new field type re-use an existing widget.
  $info['options_select']['field types'][] = 'my_field_type';
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_widget_properties_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Alters the widget properties of a field instance before it gets displayed.
 *
 * Note that instead of hook_field_widget_properties_alter(), which is called
 * for all fields on all entity types,
 * hook_field_widget_properties_ENTITY_TYPE_alter() may be used to alter widget
 * properties for fields on a specific entity type only.
 *
 * This hook is called once per field per added or edit entity. If the result
 * of the hook involves reading from the database, it is highly recommended to
 * statically cache the information.
 *
 * @param $widget
 *   The instance's widget properties.
 * @param $context
 *   An associative array containing:
 *   - entity_type: The entity type; e.g., 'node' or 'user'.
 *   - entity: The entity object.
 *   - field: The field that the widget belongs to.
 *   - instance: The instance of the field.
 *
 * @see hook_field_widget_properties_ENTITY_TYPE_alter()
 */
function $(name)_field_widget_properties_alter(&$widget, $context) {
  // Change a widget's type according to the time of day.
  $field = $context['field'];
  if ($context['entity_type'] == 'node' && $field['field_name'] == 'field_foo') {
    $time = date('H');
    $widget['type'] = $time < 12 ? 'widget_am' : 'widget_pm';
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_widget_properties_ENTITY_TYPE_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Alters the widget properties of a field instance on a given entity type
 * before it gets displayed.
 *
 * Modules can implement hook_field_widget_properties_ENTITY_TYPE_alter() to
 * alter the widget properties for fields on a specific entity type, rather than
 * implementing hook_field_widget_properties_alter().
 *
 * This hook is called once per field per displayed widget entity. If the result
 * of the hook involves reading from the database, it is highly recommended to
 * statically cache the information.
 *
 * @param $widget
 *   The instance's widget properties.
 * @param $context
 *   An associative array containing:
 *   - entity_type: The entity type; e.g., 'node' or 'user'.
 *   - entity: The entity object.
 *   - field: The field that the widget belongs to.
 *   - instance: The instance of the field.
 *
 * @see hook_field_widget_properties_alter()
 */
function $(name)_field_widget_properties_ENTITY_TYPE_alter(&$widget, $context) {
  // Change a widget's type according to the time of day.
  $field = $context['field'];
  if ($field['field_name'] == 'field_foo') {
    $time = date('H');
    $widget['type'] = $time < 12 ? 'widget_am' : 'widget_pm';
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_widget_settings_form" xml:space="preserve">
		<code><![CDATA[/**
 * Add settings to a widget settings form.
 *
 * @param $field
 *   The field structure being configured.
 * @param $instance
 *   The instance structure being configured.
 *
 * @return
 *   The form definition for the widget settings.
 */
function ${mymodule}_field_widget_settings_form($field, $instance) {
  $form = array();
  $widget = $instance['widget'];
  $settings = $widget['settings'];${cursor}
  return $form;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_field_widget_WIDGET_TYPE_form_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Alter widget forms for a specific widget provided by another module.
 *
 * Modules can implement hook_field_widget_WIDGET_TYPE_form_alter() to modify a
 * specific widget form, rather than using hook_field_widget_form_alter() and
 * checking the widget type.
 *
 * @param $element
 *   The field widget form element as constructed by hook_field_widget_form().
 * @param $form_state
 *   An associative array containing the current state of the form.
 * @param $context
 *   An associative array containing the following key-value pairs, matching the
 *   arguments received by hook_field_widget_form():
 *   - "form": The form structure where widgets are being attached to. This
 *     might be a full form structure, or a sub-element of a larger form.
 *   - "field": The field structure.
 *   - "instance": The field instance structure.
 *   - "langcode": The language associated with $items.
 *   - "items": Array of default values for this field.
 *   - "delta": The order of this item in the array of subelements (0, 1, 2,
 *     etc).
 *
 * @see hook_field_widget_form()
 * @see hook_field_widget_form_alter()
 */
function $(name)_field_widget_WIDGET_TYPE_form_alter(&$element, &$form_state, $context) {
  // Code here will only act on widgets of type WIDGET_TYPE.  For example,
  // hook_field_widget_mymodule_autocomplete_form_alter() will only act on
  // widgets of type 'mymodule_autocomplete'.
  $element['#autocomplete_path'] = 'mymodule/autocomplete_path';
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_fiels_access" xml:space="preserve">
		<code><![CDATA[/**
 * Determine whether the user has access to a given field.
 *
 * This hook is invoked from field_access() to let modules block access to
 * operations on fields. If no module returns FALSE, the operation is allowed.
 *
 * @param $op
 *   The operation to be performed. Possible values: 'edit', 'view'.
 * @param $field
 *   The field on which the operation is to be performed.
 * @param $entity_type
 *   The type of $entity; for example, 'node' or 'user'.
 * @param $entity
 *   (optional) The entity for the operation.
 * @param $account
 *   (optional) The account to check; if not given use currently logged in user.
 *
 * @return
 *   TRUE if the operation is allowed, and FALSE if the operation is denied.
 */
function ${name}_field_access($op, $field, $entity_type, $entity, $account) {
  if ($field['field_name'] == 'field_of_interest' && $op == 'edit') {
    return user_access('edit field of interest', $account);
  }
  return TRUE;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_file_download_access" xml:space="preserve">
		<code><![CDATA[/**
 * Control download access to files.
 *
 * @param $field
 *   The field to which the file belongs.
 * @param $entity_type
 *   The type of $entity; for example, 'node' or 'user'.
 * @param $entity
 *   The $entity to which $file is referenced.
 *
 * @return
 *   TRUE is access should be allowed by this entity or FALSE if denied. Note
 *   that denial may be overridden by another entity controller, making this
 *   grant permissive rather than restrictive.
 */
function ${mymodule}_file_download_access($field, $entity_type, $entity) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_file_download_access_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Alter the access rules applied to a file download.
 *
 * @param &$grants
 *   An array of grants gathered by hook_file_download_access(). The array is
 *   keyed by the module that defines the entity type's access control; the
 *   values are Boolean grant responses for each module.
 * @param $field
 *   The field to which the file belongs.
 * @param $entity_type
 *   The type of $entity; for example, 'node' or 'user'.
 * @param $entity
 *   The $entity to which $file is referenced.
 *
 * @return
 *   An array of grants, keyed by module name, each with a Boolean grant value.
 *   Return an empty array to assert FALSE. You may choose to return your own
 *   module's value in addition to other grants or to overwrite the values set by
 *   other modules.
 */
function ${mymodule}_file_download_access_alter(&$grants, $field, $entity_type, $entity) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_filter_FILTER_prepare" xml:space="preserve">
		<code><![CDATA[/**
 * Prepare callback for hook_filter_info().
 *
 * @param $text
 *   The text string to be filtered.
 * @param $filter
 *   The filter object containing settings for the given format.
 * @param $format
 *   The text format object assigned to the text to be filtered.
 * @param $langcode
 *   The language code of the text to be filtered.
 * @param $cache
 *   A Boolean indicating whether the filtered text is going to be cached in
 *   {cache_filter}.
 * @param $cache_id
 *   The ID of the filtered text in {cache_filter}, if $cache is TRUE.
 *
 * @return
 *   The prepared, escaped text.
 */
function ${mymodule}_filter_FILTER_prepare($text, $filter, $format, $langcode, $cache, $cache_id) {
  ${cursor}
  return $text;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_filter_FILTER_process" xml:space="preserve">
		<code><![CDATA[/**
 * Process callback for hook_filter_info().
 *
 * @param $text
 *   The text string to be filtered.
 * @param $filter
 *   The filter object containing settings for the given format.
 * @param $format
 *   The text format object assigned to the text to be filtered.
 * @param $langcode
 *   The language code of the text to be filtered.
 * @param $cache
 *   A Boolean indicating whether the filtered text is going to be cached in
 *   {cache_filter}.
 * @param $cache_id
 *   The ID of the filtered text in {cache_filter}, if $cache is TRUE.
 *
 * @return
 *   The filtered text.
 */
function ${mymodule}_filter_FILTER_process($text, $filter, $format, $langcode, $cache, $cache_id) {
  ${cursor}
  return $text;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_filter_FILTER_settings" xml:space="preserve">
		<code><![CDATA[/**
 * Settings callback for hook_filter_info().
 *
 * @param $form
 *   The prepopulated form array of the filter administration form.
 * @param $form_state
 *   The state of the (entire) configuration form.
 * @param $filter
 *   The filter object containing the current settings for the given format,
 *   in $filter->settings.
 * @param $format
 *   The format object being configured.
 * @param $defaults
 *   The default settings for the filter, as defined in 'default settings' in
 *   hook_filter_info(). These should be combined with $filter->settings to
 *   define the form element defaults.
 * @param $filters
 *   The complete list of filter objects that are enabled for the given format.
 *
 * @return
 *   An array of form elements defining settings for the filter. Array keys
 *   should match the array keys in $filter->settings and $defaults.
 */
function ${mymodule}_filter_FILTER_settings($form, &$form_state, $filter, $format, $defaults, $filters) {
  $filter->settings += $defaults;

  $elements = array();
  ${cursor}
  return $elements;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_filter_FILTER_tips" xml:space="preserve">
		<code><![CDATA[/**
 * Tips callback for hook_filter_info().
 *
 * @param $filter
 *   An object representing the filter.
 * @param $format
 *   An object representing the text format the filter is contained in.
 * @param $long
 *   Whether this callback should return a short tip to display in a form
 *   (FALSE), or whether a more elaborate filter tips should be returned for
 *   theme_filter_tips() (TRUE).
 *
 * @return
 *   Translated text to display as a tip.
 */
function ${mymodule}_filter_FILTER_tips($filter, $format, $long) {
 if ($long) {
    return t('${long_tips}');
  }
  else {
    return t('${short_tips}');
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_filter_format_disable" xml:space="preserve">
		<code><![CDATA[/**
 * Perform actions when a text format has been disabled.
 *
 * @param $format
 *   The format object of the format being disabled.
 */
function ${mymodule}_filter_format_disable($format) {
  ${mymodule}_cache_rebuild();
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_filter_format_insert" xml:space="preserve">
		<code><![CDATA[/**
 * Perform actions when a new text format has been created.
 *
 * @param $format
 *   The format object of the format being updated.
 */
function ${mymodule}_filter_format_insert($format) {
  ${mymodule}_cache_rebuild();
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_filter_format_update" xml:space="preserve">
		<code><![CDATA[/**
 * Perform actions when a text format has been updated.
 *
 * @param $format
 *   The format object of the format being updated.
 */
function ${mymodule}_filter_format_update($format) {
  ${mymodule}_cache_rebuild();
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_filter_info" xml:space="preserve">
		<code><![CDATA[/**
 * Define content filters.
 *
 * @return
 *   An associative array of filters, whose keys are internal filter names,
 *   which should be unique and therefore prefixed with the name of the module.
 *   Each value is an associative array describing the filter, with the
 *   following elements (all are optional except as noted):
 *   - title: (required) An administrative summary of what the filter does.
 *   - description: Additional administrative information about the filter's
 *     behavior, if needed for clarification.
 *   - settings callback: The name of a function that returns configuration form
 *     elements for the filter. See hook_filter_FILTER_settings() for details.
 *   - default settings: An associative array containing default settings for
 *     the filter, to be applied when the filter has not been configured yet.
 *   - prepare callback: The name of a function that escapes the content before
 *     the actual filtering happens. See hook_filter_FILTER_prepare() for
 *     details.
 *   - process callback: (required) The name the function that performs the
 *     actual filtering. See hook_filter_FILTER_process() for details.
 *   - cache (default TRUE): Specifies whether the filtered text can be cached.
 *     Note that setting this to FALSE makes the entire text format not
 *     cacheable, which may have an impact on the site's overall performance.
 *     See filter_format_allowcache() for details.
 *   - tips callback: The name of a function that returns end-user-facing filter
 *     usage guidelines for the filter. See hook_filter_FILTER_tips() for
 *     details.
 *   - weight: A default weight for the filter in new text formats.
 */
function ${mymodule}_filter_info() {
  $filters['${filter_name}'] = array(
    'title' => t('${filter_title}'),
    'description' => t('${filter_description}'),
    'process callback' => '_${filter_name}',
    'settings callback' => '_${filter_name}_settings',
    'default settings' => array(
      '${setting}' => ${setting_value},
    ),
    'tips callback' => '_${filter_name}_tips',
  );

  return $filters;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_filter_info_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Perform alterations on filter definitions.
 *
 * @param $info
 *   Array of information on filters exposed by hook_filter_info()
 *   implementations.
 */
function ${mymodule}_filter_info_alter(&$info) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_form" xml:space="preserve">
		<code><![CDATA[/**
 * Display a node editing form.
 *
 * @param $node
 *   The node being added or edited.
 * @param $form_state
 *   The form state array.
 *
 * @return
 *   An array containing the title and any custom form elements to be displayed
 *   in the node editing form.
 */
function ${mymodule}_form($node, &$form_state) {
  $form = array();
  $type = node_type_get_type($node);

  $form['title'] = array(
    '#type' => 'textfield',
    '#title' => check_plain($type->title_label),
    '#default_value' => !empty($node->title) ? $node->title : '',
    '#required' => TRUE, '#weight' => -5
  );${cursor}

  return $form;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_help" xml:space="preserve">
		<code><![CDATA[/**
 * Provide online user help.
 *
 * @param $path
 *   The router menu path, as defined in hook_menu(), for the help that is
 *   being requested; e.g., 'admin/people' or 'user/register'.  If the router
 *   path includes a wildcard, then this will appear in $path as %, even if it
 *   is a named %autoloader wildcard in the hook_menu() implementation; for
 *   example, node pages would have $path equal to 'node/%' or 'node/%/view'.
 *   To provide a help page for a whole module with a listing on admin/help,
 *   your hook implementation should match a path with a special descriptor
 *   after a "#" sign:
 *     'admin/help#modulename'
 *       The main module help text, displayed on the admin/help/modulename
 *       page and linked to from the admin/help page.
 * @param $arg
 *   An array that corresponds to the return value of the arg() function, for
 *   modules that want to provide help that is specific to certain values
 *   of wildcards in $path. For example, you could provide help for the path
 *   'user/1' by looking for the path 'user/%' and $arg[1] == '1'. This given
 *   array should always be used rather than directly invoking arg(), because
 *   your hook implementation may be called for other purposes besides building
 *   the current page's help. Note that depending on which module is invoking
 *   hook_help, $arg may contain only empty strings. Regardless, $arg[0] to
 *   $arg[11] will always be set.
 * @return
 *   A localized string containing the help text.
 */
function ${mymodule}_help($path, $arg) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_image_default_styles" xml:space="preserve">
		<code><![CDATA[/**
 * Provide module-based image styles for reuse throughout Drupal.
 *
 * This hook allows your module to provide image styles. This may be useful if
 * you require images to fit within exact dimensions. Note that you should
 * attempt to re-use the default styles provided by Image module whenever
 * possible, rather than creating image styles that are specific to your module.
 * Image provides the styles "thumbnail", "medium", and "large".
 *
 * You may use this hook to more easily manage your site's changes by moving
 * existing image styles from the database to a custom module. Note however that
 * moving image styles to code instead storing them in the database has a
 * negligible effect on performance, since custom image styles are loaded
 * from the database all at once. Even if all styles are pulled from modules,
 * Image module will still perform the same queries to check the database for
 * any custom styles.
 *
 * @return
 *   An array of image styles, keyed by the style name.
 * @see image_image_default_styles()
 */
function $(name)_image_default_styles() {
  $styles = array();

  $styles['mymodule_preview'] = array(
    'effects' => array(
      array(
        'name' => 'image_scale',
        'data' => array('width' => 400, 'height' => 400, 'upscale' => 1),
        'weight' => 0,
      ),
      array(
        'name' => 'image_desaturate',
        'data' => array(),
        'weight' => 1,
      ),
    ),
  );

  return $styles;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_image_effect_info" xml:space="preserve">
		<code><![CDATA[/**
 * Define information about image effects provided by a module.
 *
 * This hook enables modules to define image manipulation effects for use with
 * an image style.
 *
 * @return
 *   An array of image effects. This array is keyed on the machine-readable
 *   effect name. Each effect is defined as an associative array containing the
 *   following items:
 *   - "label": The human-readable name of the effect.
 *   - "effect callback": The function to call to perform this image effect.
 *   - "dimensions passthrough": (optional) Set this item if the effect doesn't
 *     change the dimensions of the image.
 *   - "dimensions callback": (optional) The function to call to transform
 *     dimensions for this effect.
 *   - "help": (optional) A brief description of the effect that will be shown
 *     when adding or configuring this image effect.
 *   - "form callback": (optional) The name of a function that will return a
 *     $form array providing a configuration form for this image effect.
 *   - "summary theme": (optional) The name of a theme function that will output
 *     a summary of this image effect's configuration.
 *
 * @see hook_image_effect_info_alter()
 */
function $(name)_image_effect_info() {
  $effects = array();

  $effects['mymodule_resize'] = array(
    'label' => t('Resize'),
    'help' => t('Resize an image to an exact set of dimensions, ignoring aspect ratio.'),
    'effect callback' => 'mymodule_resize_effect',
    'dimensions callback' => 'mymodule_resize_dimensions',
    'form callback' => 'mymodule_resize_form',
    'summary theme' => 'mymodule_resize_summary',
  );

  return $effects;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_image_effect_info_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Alter the information provided in hook_image_effect_info().
 *
 * @param $effects
 *   The array of image effects, keyed on the machine-readable effect name.
 *
 * @see hook_image_effect_info()
 */
function $(name)_image_effect_info_alter(&$effects) {
  // Override the Image module's crop effect with more options.
  $effects['image_crop']['effect callback'] = 'mymodule_crop_effect';
  $effects['image_crop']['dimensions callback'] = 'mymodule_crop_dimensions';
  $effects['image_crop']['form callback'] = 'mymodule_crop_form';
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_image_style_delete" xml:space="preserve">
		<code><![CDATA[/**
 * Respond to image style deletion.
 *
 * This hook enables modules to update settings when a image style is being
 * deleted. If a style is deleted, a replacement name may be specified in
 * $style['name'] and the style being deleted will be specified in
 * $style['old_name'].
 *
 * @param $style
 *   The image style array that being deleted.
 */
function $(name)_image_style_delete($style) {
  // Administrators can choose an optional replacement style when deleting.
  // Update the modules style variable accordingly.
  if (isset($style['old_name']) && $style['old_name'] == variable_get('mymodule_image_style', '')) {
    variable_set('mymodule_image_style', $style['name']);
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_image_style_flush" xml:space="preserve">
		<code><![CDATA[/**
 * Respond to image style flushing.
 *
 * This hook enables modules to take effect when a style is being flushed (all
 * images are being deleted from the server and regenerated). Any
 * module-specific caches that contain information related to the style should
 * be cleared using this hook. This hook is called whenever a style is updated,
 * deleted, or any effect associated with the style is update or deleted.
 *
 * @param $style
 *   The image style array that is being flushed.
 */
function $(name)_image_style_flush($style) {
  // Empty cached data that contains information about the style.
  cache_clear_all('*', 'cache_mymodule', TRUE);
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_image_style_save" xml:space="preserve">
		<code><![CDATA[/**
 * Respond to image style updating.
 *
 * This hook enables modules to update settings that might be affected by
 * changes to an image. For example, updating a module specific variable to
 * reflect a change in the image style's name.
 *
 * @param $style
 *   The image style array that is being updated.
 */
function $(name)_image_style_save($style) {
  // If a module defines an image style and that style is renamed by the user
  // the module should update any references to that style.
  if (isset($style['old_name']) && $style['old_name'] == variable_get('mymodule_image_style', '')) {
    variable_set('mymodule_image_style', $style['name']);
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_image_styles_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Modify any image styles provided by other modules or the user.
 *
 * This hook allows modules to modify, add, or remove image styles. This may
 * be useful to modify default styles provided by other modules or enforce
 * that a specific effect is always enabled on a style. Note that modifications
 * to these styles may negatively affect the user experience, such as if an
 * effect is added to a style through this hook, the user may attempt to remove
 * the effect but it will be immediately be re-added.
 *
 * The best use of this hook is usually to modify default styles, which are not
 * editable by the user until they are overridden, so such interface
 * contradictions will not occur. This hook can target default (or user) styles
 * by checking the $style['storage']]]><![CDATA[ property.
 *
 * If your module needs to provide a new style (rather than modify an existing
 * one) use hook_image_default_styles() instead.
 *
 * @see hook_image_default_styles()
 */
function $(name)_image_styles_alter(&$styles) {
  // Check that we only affect a default style.
  if ($styles['thumbnail']['storage'] == IMAGE_STORAGE_DEFAULT) {
    // Add an additional effect to the thumbnail style.
    $styles['thumbnail']['effects'][] = array(
      'name' => 'image_desaturate',
      'data' => array(),
      'weight' => 1,
      'effect callback' => 'image_desaturate_effect',
    );
  }
}
]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_insert" xml:space="preserve">
		<code><![CDATA[/**
 * Respond to creation of a new node.
 *
 * @param $node
 *   The node that is being created.
 */
function ${mymodule}_insert($node) {
  db_insert('${mytable}')
    ->fields(array(
      'nid' => $node->nid,
      '${extra}' => $node->${extra},
    ))
    ->execute();
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_load" xml:space="preserve">
		<code><![CDATA[/**
 * Act on nodes being loaded from the database.
 *
 * @param $nodes
 *   An array of the nodes being loaded, keyed by nid.
 */
function ${mymodule}_load($nodes) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_locale" xml:space="preserve">
		<code><![CDATA[/**
 * Allows modules to define their own text groups that can be translated.
 *
 * @param $op
 *   Type of operation. Currently, only supports 'groups'.
 */
function $(name)_locale($op = 'groups') {
  switch ($op) {
    case 'groups':
      return array('custom' => t('Custom'));
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_menu_delete" xml:space="preserve">
		<code><![CDATA[/**
 * Informs modules that a custom menu was deleted.
 *
 * @param $link
 *   An array representing a custom menu:
 *   - menu_name: The unique name of the custom menu.
 *   - title: The human readable menu title.
 *   - description: The custom menu description.
 */
function ${mymodule}_menu_delete($menu) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_menu_insert" xml:space="preserve">
		<code><![CDATA[/**
 * Informs modules that a custom menu was created.
 *
 * @param $menu
 *   An array representing a custom menu:
 *   - menu_name: The unique name of the custom menu.
 *   - title: The human readable menu title.
 *   - description: The custom menu description.
 */
function ${mymodule}_menu_insert($menu) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_menu_update" xml:space="preserve">
		<code><![CDATA[/**
 * Informs modules that a custom menu was updated.
 *
 * @param $menu
 *   An array representing a custom menu:
 *   - menu_name: The unique name of the custom menu.
 *   - title: The human readable menu title.
 *   - description: The custom menu description.
 *   - old_name: The current 'menu_name'. Note that internal menu names cannot
 *     be changed after initial creation.
 */
function ${mymodule}_menu_update($menu) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_node_access" xml:space="preserve">
		<code><![CDATA[/**
 * Control access to a node.
 *
 * @param $node
 *   The node on which the operation is to be performed, or, if it does
 *   not yet exist, the type of node to be created.
 * @param $op
 *   The operation to be performed. Possible values:
 *   - "create"
 *   - "delete"
 *   - "update"
 *   - "view"
 * @param $account
 *   A user object representing the user for whom the operation is to be
 *   performed.
 *
 * @return
 *   NODE_ACCESS_ALLOW if the operation is to be allowed;
 *   NODE_ACCESS_DENY if the operation is to be denied;
 *   NODE_ACCESSS_IGNORE to not affect this operation at all.
 */
function ${mymodule}_node_access($node, $op, $account) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_node_access_records" xml:space="preserve">
		<code><![CDATA[/**
 * Set permissions for a node to be written to the database.
 *
 * @param $node
 *   The node that has just been saved.
 *
 * @return
 *   An array of grants as defined above.
 */
function ${mymodule}_node_access_records($node) {
  $grants = array();${cursor}
  return $grants;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_node_access_records_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Alter permissions for a node before it is written to the database.
 *
 * @param &$grants
 *   The $grants array returned by hook_node_access_records().
 * @param $node
 *   The node for which the grants were acquired.
 */
function ${mymodule}_node_access_records_alter(&$grants, $node) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_node_delete" xml:space="preserve">
		<code><![CDATA[/**
 * Respond to node deletion.
 *
 * @param $node
 *   The node that is being deleted.
 */
function ${mymodule}_node_delete($node) {
  db_delete('${mytable}')
    ->condition('nid', $node->nid)
    ->execute();
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_node_grants" xml:space="preserve">
		<code><![CDATA[/**
 * Inform the node access system what permissions the user has.
 *
 * @param $account
 *   The user object whose grants are requested.
 * @param $op
 *   The node operation to be performed, such as "view", "update", or "delete".
 *
 * @return
 *   An array whose keys are "realms" of grants, and whose values are arrays of
 *   the grant IDs within this realm that this user is being granted.
 */
function ${mymodule}_node_grants($account, $op) {
  $grants = array();${cursor}
  return $grants;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_node_grants_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Alter user access rules when trying to view, edit or delete a node.
 *
 * @param &$grants
 *   The $grants array returned by hook_node_grants().
 * @param $account
 *   The user account requesting access to content.
 * @param $op
 *   The operation being performed, 'view', 'update' or 'delete'.
 */
function ${mymodule}_node_grants_alter(&$grants, $account, $op) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_node_info" xml:space="preserve">
		<code><![CDATA[/**
 * Define module-provided node types.
 *
 * @return
 *   An array of information defining the module's node types. The array
 *   contains a sub-array for each node type, with the machine-readable type
 *   name as the key. Each sub-array has up to 10 attributes. Possible
 *   attributes:
 *   - "name": the human-readable name of the node type. Required.
 *   - "base": the base string used to construct callbacks corresponding to
 *      this node type.
 *      (i.e. if base is defined as example_foo, then example_foo_insert will
 *      be called when inserting a node of that type). This string is usually
 *      the name of the module, but not always. Required.
 *   - "description": a brief description of the node type. Required.
 *   - "help": help information shown to the user when creating a node of
 *      this type.. Optional (defaults to '').
 *   - "has_title": boolean indicating whether or not this node type has a title
 *      field. Optional (defaults to TRUE).
 *   - "title_label": the label for the title field of this content type.
 *      Optional (defaults to 'Title').
 *   - "locked": boolean indicating whether the administrator can change the
 *      machine name of this type. FALSE = changeable (not locked),
 *      TRUE = unchangeable (locked). Optional (defaults to TRUE).
 */
function ${mymodule}_node_info() {
  return array(
    '${type}' => array(
      'name' => t('${name}'),
      'base' => '${base}',
      'description' => t('${description}'),
    ),
  );
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_node_insert" xml:space="preserve">
		<code><![CDATA[/**
 * Respond to creation of a new node.
 *
 * @param $node
 *   The node that is being created.
 */
function ${mymodule}_node_insert($node) {
  db_insert('${mytable}')
    ->fields(array(
      'nid' => $node->nid,
      '${extra}' => $node->${extra},
    ))
    ->execute();
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_node_load" xml:space="preserve">
		<code><![CDATA[/**
 * Act on nodes being loaded from the database.
 *
 * @param $nodes
 *   An array of the nodes being loaded, keyed by nid.
 * @param $types
 *   An array containing the types of the nodes.
 */
function ${mymodule}_node_load($nodes, $types) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_node_operations" xml:space="preserve">
		<code><![CDATA[/**
 * Add mass node operations.
 *
 * @return
 *   An array of operations. Each operation is an associative array that may
 *   contain the following key-value pairs:
 *   - 'label': Required. The label for the operation, displayed in the dropdown
 *     menu.
 *   - 'callback': Required. The function to call for the operation.
 *   - 'callback arguments': Optional. An array of additional arguments to pass
 *     to the callback function.
 */
function ${mymodule}_node_operations() {
  $operations = array(
    '${opname}' => array(
      'label' => t('${optitle}'),
      'callback' => '${opcallback}',
      'callback arguments' => array(${oparg}),
    ),
  );
  return $operations;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_node_prepare" xml:space="preserve">
		<code><![CDATA[/**
 * Act on a node object about to be shown on the add/edit form.
 *
 * @param $node
 *   The node that is about to be shown on the add/edit form.
 */
function ${mymodule}_node_prepare($node) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_node_presave" xml:space="preserve">
		<code><![CDATA[/**
 * Act on a node being inserted or updated.
 *
 * @param $node
 *   The node that is being inserted or updated.
 */
function ${mymodule}_node_presave($node) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_node_revision_delete" xml:space="preserve">
		<code><![CDATA[/**
 * Respond to deletion of a node revision.
 *
 * @param $node
 *   The node revision (node object) that is being deleted.
 */
function ${mymodule}_node_revision_delete($node) {
  db_delete('${mytable}')
    ->condition('vid', $node->vid)
    ->execute();
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_node_search_result" xml:space="preserve">
		<code><![CDATA[/**
 * Act on a node being displayed as a search result.
 *
 * @param $node
 *   The node being displayed in a search result.
 *
 * @return
 *   Extra information to be displayed with search result.
 */
function ${mymodule}_node_search_result($node) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_node_submit" xml:space="preserve">
		<code><![CDATA[/**
 * Act on a node after validated form values have been copied to it.
 *
 * @param $node
 *   The node being updated in response to a form submission.
 * @param $form
 *   The form being used to edit the node.
 * @param $form_state
 *   The form state array.
 */
function ${mymodule}_node_submit($node, $form, &$form_state) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_node_type_delete" xml:space="preserve">
		<code><![CDATA[/**
 * Respond to node type deletion.
 *
 * @param $info
 *   The node type object that is being deleted.
 */
function ${mymodule}_node_type_delete($info) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_node_type_insert" xml:space="preserve">
		<code><![CDATA[/**
 * Respond to node type creation.
 *
 * @param $info
 *   The node type object that is being created.
 */
function ${mymodule}_node_type_insert($info) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_node_type_update" xml:space="preserve">
		<code><![CDATA[/**
 * Respond to node type updates.
 *
 * @param $info
 *   The node type object that is being updated.
 */
function ${mymodule}_node_type_update($info) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_node_update" xml:space="preserve">
		<code><![CDATA[/**
 * Respond to updates to a node.
 *
 * @param $node
 *   The node that is being updated.
 */
function ${mymodule}_node_update($node) {
  db_update('${mytable}')
    ->fields(array('${extra}' => $node->${extra}))
    ->condition('nid', $node->nid)
    ->execute();
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_node_update_index" xml:space="preserve">
		<code><![CDATA[/**
 * Act on a node being indexed for searching.
 *
 * @param $node
 *   The node being indexed.
 *
 * @return
 *   Array of additional information to be indexed.
 */
function ${mymodule}_node_update_index($node) {
  $text = '';

  return $text;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_node_validate" xml:space="preserve">
		<code><![CDATA[/**
 * Perform node validation before a node is created or updated.
 *
 * @param $node
 *   The node being validated.
 * @param $form
 *   The form being used to edit the node.
 * @param $form_state
 *   The form state array.
 */
function ${mymodule}_node_validate($node, $form, &$form_state) {
  if (${condition}) {
    form_set_error('${field}', t('${message}'));
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_node_view" xml:space="preserve">
		<code><![CDATA[/**
 * Act on a node that is being assembled before rendering.
 *
 * @param $node
 *   The node that is being assembled for rendering.
 * @param $view_mode
 *   The $view_mode parameter from node_view().
 * @param $langcode
 *   The language code used for rendering.
 */
function ${mymodule}_node_view($node, $view_mode, $langcode) {
  $node->content['${my_additional_field}'] = array(
    '#markup' => ${additional_field},
    '#weight' => 10,
    '#theme' => '${mymodule_my_additional_field}',
  );
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_node_view_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Alter the results of node_view().
 *
 * @param $build
 *   A renderable array representing the node content.
 *
 * @see node_view()
 * @see hook_entity_view_alter()
 */
function ${mymodule}_node_view_alter(&$build) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_openid" xml:space="preserve">
		<code><![CDATA[/**
 * Allow modules to modify the OpenID request parameters.
 *
 * @param $op
 *   The operation to be performed.
 *   Possible values:
 *   - request: Modify parameters before they are sent to the OpenID provider.
 * @param $request
 *   An associative array of parameter defaults to which to modify or append.
 * @return
 *   An associative array of parameters to be merged with the default list.
 *
 */
function $(name)_openid($op, $request) {
  if ($op == 'request') {
    $request['openid.identity'] = 'http://myname.myopenid.com/';
  }
  return $request;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_openid_discovery_method_info" xml:space="preserve">
		<code><![CDATA[/**
 * Allow modules to declare OpenID discovery methods.
 *
 * The discovery function callbacks will be called in turn with an unique
 * parameter, the claimed identifier. They have to return an associative array
 * with array of services and claimed identifier in the same form as returned by
 * openid_discover(). The resulting array must contain following keys:
 *   - 'services' (required) an array of discovered services (including OpenID
 *   version, endpoint URI, etc).
 *   - 'claimed_id' (optional) new claimed identifer, found by following HTTP
 *   redirects during the services discovery.
 *
 * The first discovery method that succeed (return at least one services) will
 * stop the discovery process.
 *
 * @return
 *   An associative array which keys are the name of the discovery methods and
 *   values are function callbacks.
 *
 * @see hook_openid_discovery_method_info_alter()
 */
function $(name)_openid_discovery_method_info() {
  return array(
    'new_discovery_idea' => '_my_discovery_method',
  );
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_openid_discovery_method_info_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Allow modules to alter discovery methods.
 */
function $(name)_openid_discovery_method_info_alter(&$methods) {
  // Remove XRI discovery scheme.
  unset($methods['xri']);
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_openid_normalization_method_info" xml:space="preserve">
		<code><![CDATA[/**
 * Allow modules to declare OpenID normalization methods.
 *
 * The discovery function callbacks will be called in turn with an unique
 * parameter, the identifier to normalize. They have to return a normalized
 * identifier, or NULL if the identifier is not in a form they can handle.
 *
 * The first normalization method that succeed (return a value that is not NULL)
 * will stop the normalization process.
 *
 * @return
 *   An array with a set of function callbacks, that will be called in turn
 *   when normalizing an OpenID identifier. The normalization functions have
 *   to return a normalized identifier, or NULL if the identifier is not in
 *   a form they can handle.
 * @see hook_openid_normalization_method_info_alter()
 */
function $(name)_openid_normalization_method_info() {
  return array(
    'new_normalization_idea' => '_my_normalization_method',
  );
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_openid_normalization_method_info_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Allow modules to alter normalization methods.
 */
function $(name)_openid_normalization_method_info_alter(&$methods) {
  // Remove Google IDP normalization.
  unset($methods['google_idp']);
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_openid_response" xml:space="preserve">
		<code><![CDATA[/**
 * Allow modules to act upon a successful OpenID login.
 *
 * @param $response
 *   Response values from the OpenID Provider.
 * @param $account
 *   The Drupal user account that logged in
 *
 */
function $(name)_openid_response($response, $account) {
  if (isset($response['openid.ns.ax'])) {
    _mymodule_store_ax_fields($response, $account);
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_overlay_child_initialize" xml:space="preserve">
		<code><![CDATA[/**
 * Allow modules to act when an overlay child window is initialized.
 */
function ${mymodule}_overlay_child_initialize() {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_overlay_parent_initialize" xml:space="preserve">
		<code><![CDATA[/**
 * Allow modules to act when an overlay parent window is initialized.
 */
function ${mymodule}_overlay_parent_initialize() {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_path_delete" xml:space="preserve">
		<code><![CDATA[/**
 * Allow modules to respond to a path being deleted.
 *
 * @param $path
 *   An associative array containing the following keys:
 *   - source: The internal system path.
 *   - alias: The URL alias.
 *   - pid: Unique path alias identifier.
 *   - language: The language of the alias.
 */
function ${mymodule}_path_delete($path) {
  db_delete('${mytable}')
    ->condition('pid', $path['pid'])
    ->execute();
}
]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_path_insert" xml:space="preserve">
		<code><![CDATA[/**
 * Allow modules to respond to a path being inserted.
 *
 * @param $path
 *   An associative array containing the following keys:
 *   - source: The internal system path.
 *   - alias: The URL alias.
 *   - pid: Unique path alias identifier.
 *   - language: The language of the alias.
 */
function ${mymodule}_path_insert($path) {
  db_insert('${mytable}')
    ->fields(array(
      'alias' => $path['alias'],
      'pid' => $path['pid'],
    ))
    ->execute();
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_path_update" xml:space="preserve">
		<code><![CDATA[/**
 * Allow modules to respond to a path being updated.
 *
 * @param $path
 *   An associative array containing the following keys:
 *   - source: The internal system path.
 *   - alias: The URL alias.
 *   - pid: Unique path alias identifier.
 *   - language: The language of the alias.
 */
function ${mymodule}_path_update($path) {
  db_update('${mytable}')
    ->fields(array('alias' => $path['alias']))
    ->condition('pid', $path['pid'])
    ->execute();
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_prepare" xml:space="preserve">
		<code><![CDATA[/**
 * Act on a node object about to be shown on the add/edit form.
 *
 * @param $node
 *   The node that is about to be shown on the add/edit form.
 */
function ${mymodule}_prepare($node) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_ranking" xml:space="preserve">
		<code><![CDATA[/**
 * Provide additional methods of scoring for core search results for nodes.
 *
* @return
 *   An associative array of ranking data. The keys should be strings,
 *   corresponding to the internal name of the ranking mechanism, such as
 *   'recent', or 'comments'. The values should be arrays themselves, with the
 *   following keys available:
 *   - "title": the human readable name of the ranking mechanism. Required.
 *   - "join": part of a query string to join to any additional necessary
 *     table. This is not necessary if the table required is already joined to
 *     by the base query, such as for the {node} table. Other tables should use
 *     the full table name as an alias to avoid naming collisions. Optional.
 *   - "score": part of a query string to calculate the score for the ranking
 *     mechanism based on values in the database. This does not need to be
 *     wrapped in parentheses, as it will be done automatically; it also does
 *     not need to take the weighted system into account, as it will be done
 *     automatically. It does, however, need to calculate a decimal between
 *     0 and 1; be careful not to cast the entire score to an integer by
 *     inadvertently introducing a variable argument. Required.
 *   - "arguments": if any arguments are required for the score, they can be
 *     specified in an array here.
 */
function ${mymodule}_ranking() {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_rdf_mapping" xml:space="preserve">
		<code><![CDATA[/**
 * Allow modules to define RDF mappings for field bundles.
 *
 * @return
 *   A list of mapping structures, where each mapping is an associative array:
 *   - type: The name of an entity type (e.g., 'node', 'comment', and so on.)
 *   - bundle: The name of the bundle (e.g., 'page', 'blog', or
 *     RDF_DEFAULT_BUNDLE for default mappings.)
 *   - mapping: The mapping structure which applies to the entity type and
 *     bundle. A mapping structure is an array with keys corresponding to
 *     existing field instances in the bundle. Each field is then described in
 *     terms of the RDF mapping:
 *     - predicates: An array of RDF predicates which describe the relation
 *       between the bundle (RDF subject) and the value of the field (RDF
 *       object). This value is either some text, another bundle, or a URI in
 *       general.
 *     - datatype: Is used along with 'callback' to format data so that it is
 *       readable by machines. A typical example is a date which can be written
 *       in many different formats but should be translated into a uniform
 *       format for machine consumption.
 *     - callback: A function name to invoke for 'datatype'.
 *     - type: A string used to determine the type of RDFa markup which will be
 *       used in the final HTML output, depending on whether the RDF object is a
 *       literal text or another RDF resource.
 *     - rdftype: A special property used to define the type of the instance.
 *       Its value should be an array of RDF classes.
 */
function ${mymodule}_rdf_mapping() {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_rdf_namespaces" xml:space="preserve">
		<code><![CDATA[/**
 * Allow modules to define namespaces for RDF mappings.
 *
 * @return
 *   An associative array of namespaces where the key is the namespace prefix
 *   and the value is the namespace URI.
 */
function ${mymodule}_rdf_namespaces() {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_search_access" xml:space="preserve">
		<code><![CDATA[/**
 * Define access to a custom search routine.
 *
 * This hook allows a module to define permissions for a search tab.
 *
 * @ingroup search
 */
function $(name)_search_access() {
  return user_access('access content');
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_search_admin" xml:space="preserve">
		<code><![CDATA[/**
 * Add elements to the search settings form.
 *
 * @return
 *   Form array for the Search settings page at admin/config/search/settings.
 *
 * @ingroup search
 */
function $(name)_search_admin() {
  // Output form for defining rank factor weights.
  $form['content_ranking'] = array(
    '#type' => 'fieldset',
    '#title' => t('Content ranking'),
  );
  $form['content_ranking']['#theme'] = 'node_search_admin';
  $form['content_ranking']['info'] = array(
    '#value' => '<em>' . t('The following numbers control which properties the content search should favor when ordering the results. Higher numbers mean more influence, zero means the property is ignored. Changing these numbers does not require the search index to be rebuilt. Changes take effect immediately.') . '</em>'
  );

  // Note: reversed to reflect that higher number = higher ranking.
  $options = drupal_map_assoc(range(0, 10));
  foreach (module_invoke_all('ranking') as $var => $values) {
    $form['content_ranking']['factors']['node_rank_' . $var] = array(
      '#title' => $values['title'],
      '#type' => 'select',
      '#options' => $options,
      '#default_value' => variable_get('node_rank_' . $var, 0),
    );
  }
  return $form;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_search_execute" xml:space="preserve">
		<code><![CDATA[/**
 * Execute a search for a set of key words.
 *
 * Use database API with the 'PagerDefault' query extension to perform your
 * search.
 *
 * If your module uses hook_update_index() and search_index() to index its
 * items, use table 'search_index' aliased to 'i' as the main table in your
 * query, with the 'SearchQuery' extension. You can join to your module's table
 * using the 'i.sid' field, which will contain the $sid values you provided to
 * search_index(). Add the main keywords to the query by using method
 * searchExpression(). The functions search_expression_extract() and
 * search_expression_insert() may also be helpful for adding custom search
 * parameters to the search expression.
 *
 * See node_search_execute() for an example of a module that uses the search
 * index, and user_search_execute() for an example that doesn't use the search
 * index.
 *
 * @param $keys
 *   The search keywords as entered by the user.
 * @param $conditions
 *   An optional array of additional conditions, such as filters.
 *
 * @return
 *   An array of search results. To use the default search result
 *   display, each item should have the following keys':
 *   - 'link': Required. The URL of the found item.
 *   - 'type': The type of item (such as the content type).
 *   - 'title': Required. The name of the item.
 *   - 'user': The author of the item.
 *   - 'date': A timestamp when the item was last modified.
 *   - 'extra': An array of optional extra information items.
 *   - 'snippet': An excerpt or preview to show with the result (can be
 *     generated with search_excerpt()).
 *   - 'language': Language code for the item (usually two characters).
 *
 * @ingroup search
 */
function $(name)_search_execute($keys = NULL, $conditions = NULL) {
  // Build matching conditions
  $query = db_select('search_index', 'i', array('target' => 'slave'))->extend('SearchQuery')->extend('PagerDefault');
  $query->join('node', 'n', 'n.nid = i.sid');
  $query
    ->condition('n.status', 1)
    ->addTag('node_access')
    ->searchExpression($keys, 'node');

  // Insert special keywords.
  $query->setOption('type', 'n.type');
  $query->setOption('language', 'n.language');
  if ($query->setOption('term', 'ti.tid')) {
    $query->join('taxonomy_index', 'ti', 'n.nid = ti.nid');
  }
  // Only continue if the first pass query matches.
  if (!$query->executeFirstPass()) {
    return array();
  }

  // Add the ranking expressions.
  _node_rankings($query);

  // Load results.
  $find = $query
    ->limit(10)
    ->execute();
  $results = array();
  foreach ($find as $item) {
    // Build the node body.
    $node = node_load($item->sid);
    node_build_content($node, 'search_result');
    $node->body = drupal_render($node->content);

    // Fetch comments for snippet.
    $node->rendered .= ' ' . module_invoke('comment', 'node_update_index', $node);
    // Fetch terms for snippet.
    $node->rendered .= ' ' . module_invoke('taxonomy', 'node_update_index', $node);

    $extra = module_invoke_all('node_search_result', $node);

    $results[] = array(
      'link' => url('node/' . $item->sid, array('absolute' => TRUE)),
      'type' => check_plain(node_type_get_name($node)),
      'title' => $node->title,
      'user' => theme('username', array('account' => $node)),
      'date' => $node->changed,
      'node' => $node,
      'extra' => $extra,
      'score' => $item->calculated_score,
      'snippet' => search_excerpt($keys, $node->body),
    );
  }
  return $results;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_search_info" xml:space="preserve">
		<code><![CDATA[/**
 * Define a custom search type.
 *
 * This hook allows a module to tell search.module that it wishes to perform
 * searches on content it defines (custom node types, users, or comments for
 * example) when a site search is performed.
 *
 * In order for the search to do anything, your module must also implement
 * hook_search_execute(), which is called when someone requests a search
 * on your module's type of content. If you want to have your content
 * indexed in the standard search index, your module should also implement
 * hook_update_index(). If your search type has settings, you can implement
 * hook_search_admin() to add them to the search settings page. You can use
 * hook_form_FORM_ID_alter(), with FORM_ID set to 'search_form', to add fields
 * to the search form (see node_form_search_form_alter() for an example).
 * You can use hook_search_access() to limit access to searching,
 * and hook_search_page() to override how search results are displayed.
 *
 * @return
 *   Array with optional keys:
 *   - 'title': Title for the tab on the search page for this module. Defaults
 *     to the module name if not given.
 *   - 'path': Path component after 'search/' for searching with this module.
 *     Defaults to the module name if not given.
 *   - 'conditions_callback': Name of a callback function that is invoked by
 *     search_view() to get an array of additional search conditions to pass to
 *     search_data(). For example, a search module may get additional keywords,
 *     filters, or modifiers for the search from the query string. Sample
 *     callback function: sample_search_conditions_callback().
 *
 * @ingroup search
 */
function $(name)_search_info() {
  return array(
    'title' => 'Content',
    'path' => 'node',
    'conditions_callback' => 'sample_search_conditions_callback',
  );
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_search_page" xml:space="preserve">
		<code><![CDATA[/**
 * Override the rendering of search results.
 *
 * A module that implements hook_search_info() to define a type of search
 * may implement this hook in order to override the default theming of
 * its search results, which is otherwise themed using theme('search_results').
 *
 * Note that by default, theme('search_results') and theme('search_result')
 * work together to create an ordered list (OL). So your hook_search_page()
 * implementation should probably do this as well.
 *
 * @see search-result.tpl.php, search-results.tpl.php
 *
 * @param $results
 *   An array of search results.
 *
 * @return
 *   A renderable array, which will render the formatted search results with
 *   a pager included.
 */
function $(name)_search_page($results) {
  $output['prefix']['#markup'] = '<ol class="search-results">';

  foreach ($results as $entry) {
    $output[] = array(
      '#theme' => 'search_result',
      '#result' => $entry,
      '#module' => 'my_module_name',
    );
  }
  $output['suffix']['#markup'] = '</ol>' . theme('pager');

  return $output;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_search_preprocess" xml:space="preserve">
		<code><![CDATA[/**
 * Preprocess text for search.
 *
 * This hook is called to preprocess both the text added to the search index and
 * the keywords users have submitted for searching.
 *
 * Possible uses:
 * - Adding spaces between words of Chinese or Japanese text.
 * - Stemming words down to their root words to allow matches between, for
 *   instance, walk, walked, walking, and walks in searching.
 * - Expanding abbreviations and acronymns that occur in text.
 *
 * @param $text
 *   The text to preprocess. This is a single piece of plain text extracted
 *   from between two HTML tags or from the search query. It will not contain
 *   any HTML entities or HTML tags.
 *
 * @return
 *   The text after preprocessing. Note that if your module decides not to alter
 *   the text, it should return the original text. Also, after preprocessing,
 *   words in the text should be separated by a space.
 *
 * @ingroup search
 */
function $(name)_search_preprocess($text) {
  // Do processing on $text
  return $text;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_search_reset" xml:space="preserve">
		<code><![CDATA[/**
 * Take action when the search index is going to be rebuilt.
 *
 * Modules that use hook_update_index() should update their indexing
 * bookkeeping so that it starts from scratch the next time
 * hook_update_index() is called.
 *
 * @ingroup search
 */
function $(name)_search_reset() {
  db_update('search_dataset')
    ->fields(array('reindex' => REQUEST_TIME))
    ->condition('type', 'node')
    ->execute();
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_search_status" xml:space="preserve">
		<code><![CDATA[/**
 * Report the status of indexing.
 *
 * The core search module only invokes this hook on active modules.
 * Implementing modules do not need to check whether they are active when
 * calculating their return values.
 *
 * @return
 *  An associative array with the key-value pairs:
 *  - 'remaining': The number of items left to index.
 *  - 'total': The total number of items to index.
 *
 * @ingroup search
 */
function $(name)_search_status() {
  $total = db_query('SELECT COUNT(*) FROM {node} WHERE status = 1')->fetchField();
  $remaining = db_query("SELECT COUNT(*) FROM {node} n LEFT JOIN {search_dataset} d ON d.type = 'node' AND d.sid = n.nid WHERE n.status = 1 AND d.sid IS NULL OR d.reindex <> 0")->fetchField();
  return array('remaining' => $remaining, 'total' => $total);
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_shortcut_default_set" xml:space="preserve">
		<code><![CDATA[/**
 * Return the name of a default shortcut set for the provided user account.
 *
 * @param $account
 *   The user account whose default shortcut set is being requested.
 * @return
 *   The name of the shortcut set that this module recommends for that user, if
 *   there is one.
 */
function ${mymodule}_shortcut_default_set($account) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_simpletest_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Alter the list of tests.
 *
 * @param $groups
 *   A two dimension array, the first key is the test group (as defined in
 *   getInfo) the second is the name of the class and the value is the return
 *   value of the getInfo method.
 */
function ${mymodule}_simpletest_alter(&$groups) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_taxonomy_term_delete" xml:space="preserve">
		<code><![CDATA[/**
 * Respond to the deletion of taxonomy terms.
 *
 * Modules implementing this hook can respond to the deletion of taxonomy
 * terms from the database.
 *
 * @param $term
 *   A taxonomy term object.
 */
function $(name)_taxonomy_term_delete($term) {
  db_delete('term_synoynm')->condition('tid', $term->tid)->execute();
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_taxonomy_term_insert" xml:space="preserve">
		<code><![CDATA[/**
 * Act on taxonomy terms when inserted.
 *
 * Modules implementing this hook can act on the term object when saved to
 * the database.
 *
 * @param $term
 *   A taxonomy term object.
 */
function $(name)_taxonomy_term_insert($term) {
  if (!empty($term->synonyms)) {
    foreach (explode ("\n", str_replace("\r", '', $term->synonyms)) as $synonym) {
      if ($synonym) {
        db_insert('taxonomy_term_synonym')
        ->fields(array(
          'tid' => $term->tid,
          'name' => rtrim($synonym),
        ))
        ->execute();
      }
    }
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_taxonomy_term_load" xml:space="preserve">
		<code><![CDATA[/**
 * Act on taxonomy terms when loaded.
 *
 * Modules implementing this hook can act on the term objects returned by
 * taxonomy_term_load_multiple().
 *
 * For performance reasons, information to be added to term objects should be
 * loaded in a single query for all terms where possible.
 *
 * Since terms are stored and retrieved from cache during a page request, avoid
 * altering properties provided by the {taxonomy_term_data} table, since this
 * may affect the way results are loaded from cache in subsequent calls.
 *
 * @param $terms
 *   An array of term objects, indexed by tid.
 */
function $(name)_taxonomy_term_load($terms) {
  $result = db_query('SELECT tid, foo FROM {mytable} WHERE tid IN (:tids)', array(':tids' => array_keys($terms)));
  foreach ($result as $record) {
    $terms[$record->tid]->foo = $record->foo;
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_taxonomy_term_presave" xml:space="preserve">
		<code><![CDATA[/**
 * Act on taxonomy terms before they are saved.
 *
 * Modules implementing this hook can act on the term object before it is
 * inserted or updated.
 *
 * @param $term
 *   A term object.
 */
function $(name)_taxonomy_term_presave($term) {
  $term->foo = 'bar';
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_taxonomy_term_update" xml:space="preserve">
		<code><![CDATA[/**
 * Act on taxonomy terms when updated.
 *
 * Modules implementing this hook can act on the term object when updated.
 *
 * @param $term
 *   A taxonomy term object.
 */
function $(name)_taxonomy_term_update($term) {
  hook_taxonomy_term_delete($term);
  if (!empty($term->synonyms)) {
    foreach (explode ("\n", str_replace("\r", '', $term->synonyms)) as $synonym) {
      if ($synonym) {
        db_insert('taxonomy_term_synonym')
        ->fields(array(
          'tid' => $term->tid,
          'name' => rtrim($synonym),
        ))
        ->execute();
      }
    }
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_taxonomy_term_view" xml:space="preserve">
		<code><![CDATA[/**
 * Act on a taxonomy term that is being assembled before rendering.
 *
 * The module may add elements to $term->content prior to rendering. The
 * structure of $term->content is a renderable array as expected by
 * drupal_render().
 *
 * @param $term
 *   The term that is being assembled for rendering.
 * @param $view_mode
 *   The $view_mode parameter from taxonomy_term_view().
 * @param $langcode
 *   The language code used for rendering.
 *
 * @see hook_entity_view()
 */
function $(name)_taxonomy_term_view($term, $view_mode, $langcode) {
  $term->content['my_additional_field'] = array(
    '#markup' => $additional_field,
    '#weight' => 10,
    '#theme' => 'mymodule_my_additional_field',
  );
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_taxonomy_term_view_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Alter the results of taxonomy_term_view().
 *
 * This hook is called after the content has been assembled in a structured
 * array and may be used for doing processing which requires that the complete
 * taxonomy term content structure has been built.
 *
 * If the module wishes to act on the rendered HTML of the term rather than the
 * structured content array, it may use this hook to add a #post_render
 * callback. Alternatively, it could also implement
 * hook_preprocess_taxonomy_term(). See drupal_render() and theme()
 * documentation respectively for details.
 *
 * @param $build
 *   A renderable array representing the node content.
 *
 * @see hook_entity_view_alter()
 */
function $(name)_taxonomy_term_view_alter(&$build) {
  if ($build['#view_mode'] == 'full' && isset($build['an_additional_field'])) {
    // Change its weight.
    $build['an_additional_field']['#weight'] = -10;
  }

  // Add a #post_render callback to act on the rendered HTML of the term.
  $build['#post_render'][] = 'my_module_node_post_render';
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_taxonomy_vocabulary_delete" xml:space="preserve">
		<code><![CDATA[/**
 * Respond to the deletion of taxonomy vocabularies.
 *
 * Modules implementing this hook can respond to the deletion of taxonomy
 * vocabularies from the database.
 *
 * @param $vocabulary
 *   A taxonomy vocabulary object.
 */
function $(name)_taxonomy_vocabulary_delete($vocabulary) {
  if (variable_get('taxonomy_' . $vocabulary->vid . '_synonyms', FALSE)) {
    variable_del('taxonomy_' . $vocabulary->vid . '_synonyms');
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_taxonomy_vocabulary_insert" xml:space="preserve">
		<code><![CDATA[/**
 * Act on taxonomy vocabularies when inserted.
 *
 * Modules implementing this hook can act on the vocabulary object when saved
 * to the database.
 *
 * @param $vocabulary
 *   A taxonomy vocabulary object.
 */
function $(name)_taxonomy_vocabulary_insert($vocabulary) {
  if ($vocabulary->synonyms) {
    variable_set('taxonomy_' . $vocabulary->vid . '_synonyms', TRUE);
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_taxonomy_vocabulary_load" xml:space="preserve">
		<code><![CDATA[/**
 * Act on taxonomy vocabularies when loaded.
 *
 * Modules implementing this hook can act on the vocabulary objects before they
 * are returned by taxonomy_vocabulary_load_multiple().
 *
 * @param $vocabulary
 *   An array of taxonomy vocabulary objects.
 */
function $(name)_taxonomy_vocabulary_load($vocabularies) {
  foreach ($vocabularies as $vocabulary) {
    $vocabulary->synonyms = variable_get('taxonomy_' . $vocabulary->vid . '_synonyms', FALSE);
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_taxonomy_vocabulary_presave" xml:space="preserve">
		<code><![CDATA[/**
 * Act on taxonomy vocabularies before they are saved.
 *
 * Modules implementing this hook can act on the vocabulary object before it is
 * inserted or updated.
 *
 * @param $vocabulary
 *   A taxonomy vocabulary object.
 */
function $(name)_taxonomy_vocabulary_presave($vocabulary) {
  $vocabulary->foo = 'bar';
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_taxonomy_vocabulary_update" xml:space="preserve">
		<code><![CDATA[/**
 * Act on taxonomy vocabularies when updated.
 *
 * Modules implementing this hook can act on the vocabulary object when updated.
 *
 * @param $vocabulary
 *   A taxonomy vocabulary object.
 */
function $(name)_taxonomy_vocabulary_update($vocabulary) {
  $status = $vocabulary->synonyms ? TRUE : FALSE;
  if ($vocabulary->synonyms) {
    variable_set('taxonomy_' . $vocabulary->vid . '_synonyms', $status);
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_test_finished" xml:space="preserve">
		<code><![CDATA[/**
 * An individual test has finished.
 *
 * @param
 *   $results The results of the test as gathered by DrupalWebTestCase.
 */
function ${mymodule}_test_finished($results) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_test_group_finished" xml:space="preserve">
		<code><![CDATA[/**
 * A test group has finished.
 */
function ${mymodule}_test_group_finished() {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_test_group_started" xml:space="preserve">
		<code><![CDATA[/**
 * A test group has started.
 *
 * This hook is called just once at the beginning of a test group.
 */
function ${mymodule}_test_group_started() {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_trigger_info" xml:space="preserve">
		<code><![CDATA[/**
 * Declare triggers (events) for users to assign actions to.
 *
 * @return
 *   A nested associative array.
 *   - The outermost key is the name of the module that is defining the triggers.
 *     This will be used to create a local task (tab) in the trigger module's
 *     user interface. A contrib module may supply a trigger for a core module by
 *     giving the core module's name as the key. For example, you could use the
 *     'node' key to add a node-related trigger.
 *     - Within each module, each individual trigger is keyed by a hook name
 *       describing the particular trigger (this is not visible to the user, but
 *       can be used by your module for identification).
 *       - Each trigger is described by an associative array. Currently, the only
 *         key-value pair is 'label', which contains a translated human-readable
 *         description of the triggering event.
 *   For example, the trigger set for the 'node' module has 'node' as the
 *   outermost key and defines triggers for 'node_insert', 'node_update',
 *   'node_delete' etc. that fire when a node is saved, updated, etc.
 */
function ${mymodule}_trigger_info() {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_trigger_info_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Alter triggers declared by hook_trigger_info().
 *
 * @param $triggers
 *   Array of trigger information returned by hook_trigger_info()
 *   implementations. Modify this array in place. See hook_trigger_info()
 *   for information on what this might contain.
 */
function ${mymodule}_trigger_info_alter(&$triggers) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_update" xml:space="preserve">
		<code><![CDATA[/**
 * Respond to updates to a node.
 *
 * @param $node
 *   The node that is being updated.
 */
function ${mymodule}_update($node) {
  db_update('${mytable}')
    ->fields(array('${extra}' => $node->${extra}))
    ->condition('nid', $node->nid)
    ->execute();
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_update_projects_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Alter the list of projects before fetching data and comparing versions.
 *
 * @param $projects
 *   Reference to an array of the projects installed on the system. This
 *   includes all the metadata documented in the comments below for each
 *   project (either module or theme) that is currently enabled. The array is
 *   initially populated inside update_get_projects() with the help of
 *   _update_process_info_list(), so look there for examples of how to
 *   populate the array with real values.
 */
function ${mymodule}_update_projects_alter(&$projects) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_update_status_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Alter the information about available updates for projects.
 *
 * @param $projects
 *   Reference to an array of information about available updates to each
 *   project installed on the system.
 */
function ${mymodule}_update_status_alter(&$projects) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_user_cancel" xml:space="preserve">
		<code><![CDATA[/**
 * Act on user account cancellations.
 *
 * @param $edit
 *   The array of form values submitted by the user.
 * @param $account
 *   The user object on which the operation is being performed.
 * @param $method
 *   The account cancellation method.
 */
function ${mymodule}_user_cancel($edit, $account, $method) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_user_cancel_methods_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Modify account cancellation methods.
 *
 * @param $methods
 *   An array containing user account cancellation methods, keyed by method id.
 */
function ${mymodule}_user_cancel_methods_alter(&$methods) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_user_categories" xml:space="preserve">
		<code><![CDATA[/**
 * Retrieve a list of user setting or profile information categories.
 *
 * @return
 *   An array of associative arrays. Each inner array has elements:
 *   - "name": The internal name of the category.
 *   - "title": The human-readable, localized name of the category.
 *   - "weight": An integer specifying the category's sort ordering.
 *   - "access callback": Name of the access callback function to use to
 *     determine whether the user can edit the category. Defaults to using
 *     user_edit_access(). See hook_menu() for more information on access
 *     callbacks.
 *   - "access arguments": Arguments for the access callback function. Defaults
 *     to array(1).
 */
function ${mymodule}_user_categories() {
  return array(array(
    'name' => '${name}',
    'title' => t('${title}'),
    'weight' => ${weight},
  ));
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_user_delete" xml:space="preserve">
		<code><![CDATA[/**
 * Respond to user deletion.
 *
 * @param $account
 *   The account that is being deleted.
 */
function ${mymodule}_user_delete($account) {
  db_delete('${mytable}')
    ->condition('uid', $account->uid)
    ->execute();
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_user_insert" xml:space="preserve">
		<code><![CDATA[/**
 * A user account was created.
 *
 * @param $edit
 *   The array of form values submitted by the user.
 * @param $account
 *   The user object on which the operation is being performed.
 * @param $category
 *   The active category of user information being edited.
 */
function ${mymodule}_user_insert(&$edit, $account, $category) {
  db_insert('${mytable}')
    ->fields(array(
      '${myfield}' => $edit['${myfield}'],
      'uid' => $account->uid,
    ))
    ->execute();
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_user_load" xml:space="preserve">
		<code><![CDATA[/**
 * Act on user objects when loaded from the database.
 *
 * @param $users
 *   An array of user objects, indexed by uid.
 */
function ${mymodule}_user_load($users) {
  $result = db_query('SELECT uid, ${coll} FROM ${my_table} WHERE uid IN (:uids)', array(':uids' => array_keys($users)));
  foreach ($result as $record) {
    $users[$record->uid]->${coll} = $record->${coll};
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_user_login" xml:space="preserve">
		<code><![CDATA[/**
 * The user just logged in.
 *
 * @param $edit
 *   The array of form values submitted by the user.
 * @param $account
 *   The user object on which the operation was just performed.
 */
function ${mymodule}_user_login(&$edit, $account) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_user_logout" xml:space="preserve">
		<code><![CDATA[/**
 * The user just logged out.
 *
 * @param $account
 *   The user object on which the operation was just performed.
 */
function ${mymodule}_user_logout($account) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_user_operations" xml:space="preserve">
		<code><![CDATA[/**
 * Add mass user operations.
 *
 * @return
 *   An array of operations. Each operation is an associative array that may
 *   contain the following key-value pairs:
 *   - "label": Required. The label for the operation, displayed in the dropdown menu.
 *   - "callback": Required. The function to call for the operation.
 *   - "callback arguments": Optional. An array of additional arguments to pass to
 *     the callback function.
 */
function ${mymodule}_user_operations() {
  $operations = array(
    '${name}' => array(
      'label' => t('${label}'),
      'callback' => '${callback}',
    ),
  );
  return $operations;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_user_presave" xml:space="preserve">
		<code><![CDATA[/**
 * A user account is about to be created or updated.
 *
 * @param $edit
 *   The array of form values submitted by the user.
 * @param $account
 *   The user object on which the operation is performed.
 * @param $category
 *   The active category of user information being edited.
 */
function ${mymodule}_user_presave(&$edit, $account, $category) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_user_role_delete" xml:space="preserve">
		<code><![CDATA[/**
 * Inform other modules that a user role has been deleted.
 *
 * @param $role
 *   The $role object being deleted.
 */
function ${mymodule}_user_role_delete($role) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_user_role_insert" xml:space="preserve">
		<code><![CDATA[/**
 * Inform other modules that a user role has been added.
 *
 * @param $role
 *   A user role object.
 */
function ${mymodule}_user_role_insert($role) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_user_role_presave" xml:space="preserve">
		<code><![CDATA[/**
 * Inform other modules that a user role is about to be saved.
 *
 * @param $role
 *   A user role object.
 */
function ${mymodule}_user_role_presave($role) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_user_role_update" xml:space="preserve">
		<code><![CDATA[/**
 * Inform other modules that a user role has been updated.
 *
 * @param $role
 *   A user role object.
 */
function ${mymodule}_user_role_update($role) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_user_update" xml:space="preserve">
		<code><![CDATA[/**
 * A user account was updated.
 *
 * @param $edit
 *   The array of form values submitted by the user.
 * @param $account
 *   The user object on which the operation is performed.
 * @param $category
 *   The active category of user information being edited.
 */
function ${mymodule}_user_update(&$edit, $account, $category) {
  db_insert('${mytable}')
    ->fields(array(
      'uid' => $account->uid,
      'changed' => time(),
    ))
    ->execute();
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_user_view" xml:space="preserve">
		<code><![CDATA[/**
 * The user's account information is being displayed.
 *
 * @param $account
 *   The user object on which the operation is being performed.
 * @param $view_mode
 *   View mode, e.g. 'full'.
 * @param $langcode
 *   The language code used for rendering.
 */
function ${mymodule}_user_view($account, $view_mode, $langcode) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_user_view_alter" xml:space="preserve">
		<code><![CDATA[/**
 * The user was built; the module may modify the structured content.
 *
 * @param $build
 *   A renderable array representing the user.
 */
function ${mymodule}_user_view_alter(&$build) {
  ${cursor}
}
]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_validate" xml:space="preserve">
		<code><![CDATA[/**
 * Perform node validation before a node is created or updated.
 *
 * @param $node
 *   The node being validated.
 * @param $form
 *   The form being used to edit the node.
 * @param $form_state
 *   The form state array.
 */
function ${mymodule}_validate($node, $form, &$form_state) {
  if (${condition}) {
    form_set_error('${field}', t('${message}'));
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_verify_update_archive" xml:space="preserve">
		<code><![CDATA[/**
 * Verify an archive after it has been downloaded and extracted.
 *
 * @param string $project
 *   The short name of the project that has been downloaded.
 * @param string $archive_file
 *   The filename of the unextracted archive.
 * @param string $directory
 *   The directory that the archive was extracted into.
 *
 * @return
 *   If there are any problems, return an array of error messages. If there are
 *   no problems, return an empty array.
 */
function ${mymodule}_verify_update_archive($project, $archive_file, $directory) {
  $errors = array();${cursor}
  return $errors;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="d7_view" xml:space="preserve">
		<code><![CDATA[/**
 * Display a node.
 *
 * @param $node
 *   The node to be displayed, as returned by node_load().
 * @param $view_mode
 *   View mode, e.g. 'full', 'teaser', ...
 * @return
 *   $node. The passed $node parameter should be modified as necessary and
 *   returned so it can be properly presented. Nodes are prepared for display
 *   by assembling a structured array, formatted as in the Form API, in
 *   $node->content. As with Form API arrays, the #weight property can be
 *   used to control the relative positions of added elements. After this
 *   hook is invoked, node_view() calls field_attach_view() to add field
 *   views to $node->content, and then invokes hook_node_view() and
 *   hook_node_view_alter(), so if you want to affect the final
 *   view of the node, you might consider implementing one of these hooks
 *   instead.
 */
function ${mymodule}_view($node, $view_mode) {
  $node->content['${myfield}'] = array(
    '#markup' => theme('${mymodule_myfield}', $node->${myfield}),
    '#weight' => 1,
  );

  return $node;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="eiu" xml:space="preserve">
		<code><![CDATA[eiu_features]]></code>
	</codetemplate>
	<codetemplate abbreviation="f_submit" xml:space="preserve">
		<code><![CDATA[/**
 * Submit ${module_form} form
 *
 * @param $form form to submit
 * @param $form_state A keyed array containing the current state of the form.
 */
function ${module_form}_validate($form, &$form_state) {
  ${cursor}
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="form" xml:space="preserve">
		<code><![CDATA[/**
 * Build ${module_form} form.
 * 
 * @param array $form_state
 * @return array The created form. 
 */
function ${module_form}($form_state) {
  $form = array();
  
  return $form;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="form_item" xml:space="preserve">
		<code><![CDATA[$form[${form_item}] = array(
  '#type' => '${form_item_type}',
  '#title' => t('${form_item_title}'),
  '#description' => t('${form_item_description}'),
  '#attributes' => array(),
  '#required' => FALSE,
  '#tree' => FALSE,
  '#parents' => array(),
);]]></code>
	</codetemplate>
	<codetemplate abbreviation="form_validate" xml:space="preserve">
		<code><![CDATA[/**
 * Validate ${module_form} form
 *
 * @param $form form to validate
 * @param $form_state A keyed array containing the current state of the form.
 */
function ${module_form}_validate($form, &$form_state) {
  if (${form_field_test}) {
    form_set_error('${form_field_id}', t('${form_field_error}'));
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="h_action_info" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_action_info().
 */
function ${mymodule}_action_info() {
  return array(
    '${mymodule}_${cursor}' => array(
      'description' => t(''),
      'type' => '',
      'configurable' => ,
      'hooks' => array(
        '' => array(),
      )
    )
  );
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="if" contexts="php-code" uuid="org.netbeans.modules.php.editor.codetemplate.if" xml:space="preserve">
		<code><![CDATA[print '<pre>'; print_r(${VARIABLE variableFromPreviousAssignment default="$variable"}); print '</pre>';]]></code>
	</codetemplate>
	<codetemplate abbreviation="menu_item" xml:space="preserve">
		<code><![CDATA[$items['${menu_item_location}'] = array(
  'title' => '${menu_item_title}',
  'description' => '${menu_item_description}',
  'page callback' => '${menu_item_callback}',
  'page arguments' => array('${menu_item_arguments}'),
  'access arguments' => array('${menu_item_access}'),
  'type' => ${menu_item_type},
);]]></code>
	</codetemplate>
	<codetemplate abbreviation="my_fa" contexts="php-code" uuid="org.netbeans.modules.php.editor.codetemplate.mySql.fa" xml:space="preserve">
		<code><![CDATA[/**
 * Implementation of hook_locale()
 */
function ${cursor}_locale($op = 'groups') {

}]]></code>
	</codetemplate>
	<codetemplate abbreviation="pr" remove="true"/>
	<codetemplate abbreviation="prt" xml:space="preserve">
		<code><![CDATA[print '<pre>'; print_r(${VARIABLE variableFromPreviousAssignment default="$variable"}); print '</pre>';]]></code>
	</codetemplate>
	<codetemplate abbreviation="schema_field" xml:space="preserve">
		<code><![CDATA[${field_name}' => array(
  'description' => t('${field_description}'),
  'type' => '${field_type}',${cursor}
),]]></code>
	</codetemplate>
	<codetemplate abbreviation="schema_fields" xml:space="preserve">
		<code><![CDATA[$schema['${database_table}'] = array(
  'description' => t('${table_description}'),
  'fields' => array(
    '${primary_field}' => array(
      'description' => t('${field_description}'),
      'type' => '${field_type}', 
      'not null' => TRUE
    ),${cursor}
  ),
  'indexes' => array(),
  'unique keys' => array(),
  'primary key' => array('${primary_field}'),
);]]></code>
	</codetemplate>
	<codetemplate abbreviation="system_info_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Alter the information parsed from module and theme .info files
 *
 * This hook is invoked in _system_rebuild_module_data() and in
 * _system_rebuild_theme_data(). A module may implement this hook in order to
 * add to or alter the data generated by reading the .info file with
 * drupal_parse_info_file().
 *
 * @param $info
 *   The .info file contents, passed by reference so that it can be altered.
 * @param $file
 *   Full information about the module or theme, including $file->name, and
 *   $file->filename
 * @param $type
 *   Either 'module' or 'theme', depending on the type of .info file that was
 *   passed.
 */
function ${name}_system_info_alter(&$info, $file, $type) {
  // Only fill this in if the .info file does not define a 'datestamp'.
  if (empty($info['datestamp'])) {
    $info['datestamp'] = filemtime($file->filename);
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="system_theme_info" xml:space="preserve">
		<code><![CDATA[/**
 * Return additional themes provided by modules.
 *
 * Only use this hook for testing purposes. Use a hidden MYMODULE_test.module
 * to implement this hook. Testing themes should be hidden, too.
 *
 * This hook is invoked from _system_rebuild_theme_data() and allows modules to
 * register additional themes outside of the regular 'themes' directories of a
 * Drupal installation.
 *
 * @return
 *   An associative array. Each key is the system name of a theme and each value
 *   is the corresponding path to the theme's .info file.
 */
function ${name}_system_theme_info() {
  $themes['mymodule_test_theme'] = drupal_get_path('module', 'mymodule') . '/mymodule_test_theme/mymodule_test_theme.info';
  return $themes;
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="system_themes_page_alter" xml:space="preserve">
		<code><![CDATA[/**
 * Alters theme operation links.
 *
 * @param $theme_groups
 *   An associative array containing groups of themes.
 *
 * @see system_themes_page()
 */
function ${name}_system_themes_page_alter(&$theme_groups) {
  foreach ($theme_groups as $state => &$group) {
    foreach ($theme_groups[$state] as &$theme) {
      // Add a foo link to each list of theme operations.
      $theme->operations[] = array(
        'title' => t('Foo'),
        'href' => 'admin/appearance/foo',
        'query' => array('theme' => $theme->name)
      );
    }
  }
}]]></code>
	</codetemplate>
	<codetemplate abbreviation="test" xml:space="preserve">
		<code><![CDATA[${NAME TitleProperty}]]></code>
	</codetemplate>
</codetemplates>
