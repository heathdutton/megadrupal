<?php
/**
 * @file
 * The meat of the module.
 */

require_once "sclib_enkoder.help.inc";
require_once "sclib_enkoder.field.inc";

/**
 * Main entry point for PHP-based calls to enkode.
 *
 * @param string $to_enkode
 *   the arbitrary text to enkode
 *
 * @param string $placeholder_text
 *   text to show up when javascript can't be evaluated
 *
 * @return string
 *   $to_enkode after having been encoded (as self-evaluating javascript)
 */
function sclib_enkoder($to_enkode, $placeholder_text = NULL) {
  return _sclib_enkoder_enkode($to_enkode, $placeholder_text ? $placeholder_text : SCLEnkoder::getDefaultMessage());
}

/* This code was shamelessly refactored from PHPEnkoder at
http://www.weaselhat.com/phpenkoder/ */

/* LICENSE (Modified BSD)
Copyright (c) 2006-11, Michael Greenberg.  Derivative work of the
Hivelogic Enkoder, Copyright (c) 2006, Automatic Corp.  All rights
reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in
     the documentation and/or other materials provided with the
     distribution.

  3. Neither the name of Michael Greenberg, AUTOMATIC CORP. nor the
     names of its contributors may be used to endorse or promote
     products derived from this software without specific prior
     written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*/

define("SCLIB_ENKODE_MAX_PASSES", 20);
define("SCLIB_ENKODE_MAX_LENGTH", 1024);
define("SCLIB_ENKODE_JS_LEN", 1024);


/* encapsulates various globals needed for this module, due to how globals/files
are handled by drupal. */
class SCLEnkoder {
  protected static $enkoderUses = 0;

  protected static $defaultMessage = "text hidden; JavaScript is required";

  /**
   * Getter for number of times the enkoding has been used.
   */
  public static function getEnkoderUses() {
    return self::$enkoderUses;
  }

  /**
   * Setter for number of times the enkoding has been used.
   */
  public static function setEnkoderUses($val) {
    self::$enkoderUses = $val;
  }

  /**
   * Getter for the default message for people whose javascript is disabled.
   */
  public static function getDefaultMessage() {
    return self::$defaultMessage;
  }

  /**
   * Gets a list of all encodings.
   *
   * Each encoding pair should consist of a function and a Javascript string;
   * the function performs some scrambling of a string, and the Javascript
   * unscrambles that string (assuming that it's stored in a variable kode).
   * The listed enkodings are those used in the Hivelogic Enkoder.
   */
  public static function getEnkodings() {
    static $enkodings = NULL;
    if (!$enkodings) {
      $enkodings = array(
        array(array('SCLEnkoder', 'encReverse'), self::$decReverse),
        array(array('SCLEnkoder', 'encNum'), self::$decNum),
        array(array('SCLEnkoder', 'encSwap'), self::$decSwap),
      );
    }
    return $enkodings;
  }

  /**
   * Returns only the number-encoding enkoder.
   */
  public static function getNumEnkoder() {
    static $num_enkoder = NULL;
    if (!$num_enkoder) {
      $num_enkoder = array(
        array('SCLEnkoder', 'encNum'),
        self::$decNum,
      );
    }
    return $num_enkoder;
  }

  /**
   * Performs an encoding that reverses the entire string.
   */
  public static function encReverse($s) {
    // Note: strrev isn't multibyte friendly so do this ornery thing.
    return implode('', array_reverse(preg_split('/(?<!^)(?!$)/u', $s)));
  }

  protected static $decReverse = "kode=kode.split('').reverse().join('')";

  /**
   * Encodes a string into its unicode numeric equivalents (UCS-4BE).
   */
  public static function encNum($s) {
    $nums = "";

    $len = mb_strlen($s);
    for ($i = 0; $i < $len; $i++) {
      $x = unpack('N', mb_convert_encoding(mb_substr($s, $i, 1), 'UCS-4BE', 'UTF-8'));
      $nums .= $x[1] + 3;
      if ($i < $len - 1) {
        $nums .= ' ';
      }
    }

    return $nums;
  }

  protected static $decNum = "kode=kode.split(' ');x='';for(i=0;i<kode.length;i++){x+=String.fromCharCode(parseInt(kode[i])-3)}kode=x";

  /**
   * Performs an encoding that swaps adjacent letters by pairs.
   */
  public static function encSwap($s) {
    $swapped = strval($s);

    $len = mb_strlen($s);
    for ($i = 0; $i < $len - 1; $i += 2) {
      $right = mb_substr($swapped, $i + 1, 1);
      $left = mb_substr($swapped, $i, 1);
      $swapped = mb_substr($swapped, 0, $i)
        . $right . $left
        . mb_substr($swapped, $i + 2, $len - ($i + 2));
    }

    return $swapped;
  }

  protected static $decSwap = "x='';for(i=0;i<(kode.length-1);i+=2){x+=kode.charAt(i+1)+kode.charAt(i)}kode=x+(i<kode.length?kode.charAt(kode.length-1):'')";
}


/**
 * Encodes a string to be view-time written by obfuscated Javascript.
 *
 * The max passes parameter is a tight bound on the number of encodings
 * perormed.  The max length paramater is a loose bound on the length of
 * the generated Javascript.  Setting it to 0 will use a single pass of
 * enk_enc_num.
 *
 * The function works by selecting encodings at random from the array
 * enkodings, applying them to the given string, and then producing
 * Javascript to decode.  The Javascript works by recursive evaluation,
 * which should be nasty enough to stop anything but the most determined
 * spambots.
 *
 * The text parameter, if set, overrides the user-settable option
 * enk_msg.  This is the message overwritten by the JavaScript; if a
 * browser doesn't support JavaScript, this message will be shown to the
 * user.
 */
function _sclib_enkoder_enkode($content, $text = NULL, $max_passes = SCLIB_ENKODE_MAX_PASSES, $max_length = SCLIB_ENKODE_MAX_LENGTH) {
  /* our base case -- we'll eventually evaluate this code */
  $kode = "document.write(\""
    . addcslashes($content, "\\\'\"&\n\r<>")
    . "\");";

  $max_length = max($max_length, strlen($kode) + SCLIB_ENKODE_JS_LEN + 1);

  $result = "";

  /* build up as many encodings as we can */
  $enkodings = SCLEnkoder::getEnkodings();
  for ($passes = 0;
       $passes < $max_passes && strlen($kode) < $max_length;
       $passes++) {
    /* pick an encoding at random */
    $idx = rand(0, count($enkodings) - 1);
    $enc = $enkodings[$idx][0];
    $dec = $enkodings[$idx][1];
    $kode = _sclib_enkoder_enkode_pass($kode, $enc, $dec);
  }

  /* mandatory numerical encoding, prevents catching @ signs and
  interpreting neighboring characters as e-mail addresses */
  $num_enk = SCLEnkoder::getNumEnkoder();
  $kode = _sclib_enkoder_enkode_pass($kode, $num_enk[0], $num_enk[1]);

  return _sclib_enkoder_enk_build_js($kode, $text);
}

/**
 * One encoding pass.  $enc is a function pointer and $dec is the Javascript.
 *
 * chrislee: MODIFIED from original to use class context (self) for encoders
 */
function _sclib_enkoder_enkode_pass($kode, $enc, $dec) {
  /* first encode */
  if (is_array($enc)) {
    $kode = addslashes(call_user_func($enc, $kode));
  }
  else {
    $kode = addslashes($enc($kode));
  }

  // Then generate encoded code with decoding afterwards.
  $kode = "kode=\"$kode\";$dec;";

  return $kode;
}

/**
 * Generates the JS recursive evaluator: 269 characters of boilerplate.
 *
 * Unfortunately, <noscript> can't be used arbitrarily in XHTML.  A
 * <span> that we immediately overwrite, serves as an ad hoc <noscript>
 * tag.
 */
function _sclib_enkoder_enk_build_js($kode, $text = NULL) {
  $clean = addslashes($kode);

  $msg = is_null($text) ? SCLEnkoder::getDefaultMessage() : $text;

  $name = "enkoder_" . strval(SCLEnkoder::getEnkoderUses()) . "_" . strval(rand());
  SCLEnkoder::setEnkoderUses(SCLEnkoder::getEnkoderUses() + 1);
  $js = <<<EOT
<span id="$name">$msg</span><script type="text/javascript">
/* <!-- */
function sclib_enkoder_hivelogic_$name() {
var kode="$clean";var i,c,x;while(eval(kode));
}
sclib_enkoder_hivelogic_$name();
var span = document.getElementById('$name');
span.parentNode.removeChild(span);
/* --> */
</script>
EOT;

  return $js;
}
