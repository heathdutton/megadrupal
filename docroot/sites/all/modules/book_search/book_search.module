<?php

/**
 * @file
 * Adds a search page that lets users do a search with books.
 */

/**
 * Implements hook_form_alter().
 */
function book_search_form_alter(&$form, $form_state, $form_id) {
  // Alter the search form to add a book selection element to the book search.
  if ($form_id == 'search_form' && $form['module']['#value'] == 'book_search') {
    // Add a fieldset for the book search options.
    $form['book_search'] = array(
      '#type' => 'fieldset',
      '#title' => t('Book search options'),
      '#collapsible' => TRUE,
      '#collapsed' => arg(2) != '',
    );
    $form['book_search']['books'] = array(
      '#type' => 'checkboxes',
      '#title' => t('Only search these books'),
      '#description' => t('If no books are selected, all available books will be searched.'),
      '#options' => book_search_options(TRUE),
      '#default_value' => explode(',', search_expression_extract(arg(2), 'book')),
    );

    // Add the book search validate handler to the form.
    $form['#validate'][] = 'book_search_form_validate';

    // Remove the book key from the keys textfield.
    $form['basic']['keys']['#default_value'] = search_expression_insert($form['basic']['keys']['#default_value'], 'book');
  }
}

// Add book search information to the search keys if necessary.
function book_search_form_validate($form, &$form_state) {
  // Initialise using any existing basic search keywords.
  $keys = $form_state['values']['processed_keys'];

  // Look for any selected books.
  if (is_array($form_state['values']['books'])) {

    // Trim the books array down to selected books.
    $books = book_search_selected($form_state['values']['books']);

    if ($books != array()) {
      // Add the book key to the search keys.
      $keys = search_expression_insert($keys, 'book', implode(',', $books));
    }
  }

  // If we actually have search keys...
  if (!empty($keys)) {
    // Set the updated keys in the form state.
    form_set_value($form['basic']['processed_keys'], trim($keys), $form_state);
  }
}

/**
 * Implements hook_block_info()
 */
function book_search_block_info() {
  $blocks['current_book'] = array(
    'info' => t('Book search: Current book'),
  );
  return $blocks;
}

/**
 * Implements hook_block_view()
 */
function book_search_block_view($delta = '') {
  switch ($delta) {

    case 'current_book':
      $arg = arg();

      // If we're not on a valid book page, do not display the block.
      if ($arg[0] != 'node') {
        return;
      }

      $bid = db_query("SELECT bid FROM {book} WHERE nid = :nid", array(':nid' => $arg[1]))->fetchField();

      if (empty($bid) || !in_array($bid, book_search_selected())) {
        return;
      }

      $block = array();
      if (node_load($arg[1])) {
        $block = array(
          'subject' => t('Book search'),
          'content' => drupal_get_form('book_search_block_form', $bid),
        );
      }

      return $block;

  }

}

/**
 * Book search block form.
 */
function book_search_block_form($form, $form_state, $bid = '') {
  $form = array();

  $form['bid'] = array(
    '#type' => 'hidden',
    '#value' => $bid,
  );

  $form['keywords'] = array(
    '#type' => 'textfield',
    '#title' => t('Search this book'),
    '#size' => 15,
    '#maxlength' =>128,
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Search'),
  );

  return $form;
}

/**
 * Book search block form validation.
 */
function book_search_block_form_validate($form, &$form_state) {
  if (empty($form_state['values']['keywords'])) {
    form_set_error('keywords', t('Please enter some keywords.'));
  }
}

/**
 * Book search block form submit.
 */
function book_search_block_form_submit($form, &$form_state) {
  // Build the keys string for the search.
  $keys = search_expression_insert($form_state['values']['keywords'], 'book', $form_state['values']['bid']);

  $form_state['redirect'] = 'search/book_search/'. $keys;
}


/**
 * Implements hook_search_info().
 */
function book_search_search_info() {
  return array(
    'title' => 'Books',
    'path' => 'book_search',
  );
}

/**
 * Implements hook_search_admin().
 */
function book_search_search_admin() {
  $form = array();

  $form['book_search'] = array(
    '#type' => 'fieldset',
    '#title' => t('Book search options'),
  );
  $form['book_search']['searchable_books'] = array(
    '#type' => 'checkboxes',
    '#title' => t('Restrict book search to these books'),
    '#description' => t('If no books are selected, all books will be available in the book search options.'),
    '#options' => book_search_options(),
    '#default_value' => variable_get('searchable_books', array()),
  );

  return $form;
}

/**
 * Implements hook_update_index().
 */
function book_search_update_index() {
  $limit = (int)variable_get('search_cron_limit', 100);
  $content_type = variable_get('book_child_type');

  $result = db_query_range("SELECT n.nid FROM {node} n
    LEFT JOIN {search_dataset} d ON d.type = 'book_search' AND d.sid = n.nid
    WHERE d.sid IS NULL OR d.reindex <> 0
      AND n.type = :node_type
    ORDER BY d.reindex ASC, n.nid ASC", 0, $limit, array(':node_type' => $content_type));

  foreach ($result as $node) {
    $node = node_load($node->nid);

    // Save the changed time of the most recent indexed node, for the search
    // results half-life calculation.
    variable_set('node_cron_last', $node->changed);

    // Render the node.
    node_build_content($node, 'search_index');
    $node->rendered = drupal_render($node->content);

    $text = '<h1>' . check_plain($node->title) . '</h1>' . $node->rendered;

    // Fetch extra data normally not visible
    $extra = module_invoke_all('node_update_index', $node);
    foreach ($extra as $t) {
      $text .= $t;
    }

    // Update index
    search_index($node->nid, 'book_search', $text);
  }
}

/**
 * Implements hook_search_execute().
 */
function book_search_search_execute($keys = NULL, $conditions = NULL) {
  $content_type = variable_get('book_child_type');

  $query = db_select('search_index', 'i', array('target' => 'slave'))
    ->extend('SearchQuery')
    ->extend('PagerDefault');
  $query->join('book', 'b', 'b.nid = i.sid');
  $query->join('node', 'n', 'n.nid = i.sid');
  $query->condition('n.status', 1);
  $query->condition('n.type', $content_type);

  // If a specific book or set of books has been indicated...
  if ($book = search_expression_extract($keys, 'book')) {
    $books = explode(',', $book);

    $query->condition('b.bid', $books, 'IN');

    // Remove the book key from the keys string.
    $keys = search_expression_insert($keys, 'book');
  }
  else {
    // If no books were indicated, restrict the search to any book that has
    // been marked as searchable in the search settings.
    $valid = book_search_selected();

    if (!empty($valid)) {
      $query->condition('b.bid', $valid, 'IN');
    }
  }

  // only add $keys once bids have been unset
  $query->searchExpression($keys, 'book_search');

  // Only continue if the first pass query matches.
  if (!$query->executeFirstPass()) {
    return array();
  }

  // Add the ranking expressions.
  _node_rankings($query);

  // Load results.
  $find = $query
    ->limit(10)
    ->execute();

  $results = array();
  foreach ($find as $item) {
    // Build the node body.
    $node = node_load($item->sid);
    node_build_content($node, 'search_result');

    // Fetch comments for snippet.
    $node->rendered .= ' ' . module_invoke('comment', 'node_update_index', $node);
    // Fetch terms for snippet.
    $node->rendered .= ' ' . module_invoke('taxonomy', 'node_update_index', $node);

    $extra = module_invoke_all('node_search_result', $node);

    $results[] = array(
      'link' => url('node/' . $item->sid, array('absolute' => TRUE)),
      'type' => check_plain(node_type_get_name($node)),
      'title' => $node->title,
      'user' => theme('username', array('account' => $node)),
      'date' => $node->changed,
      'node' => $node,
      'extra' => $extra,
      'score' => $item->calculated_score,
      'snippet' => search_excerpt($keys, drupal_render($node->content))
    );
  }

  return $results;
}

/**
 * Build an array of extra information to include in book search results.
 *
 * @param $node
 *   The node object used to create the search result.
 * @return
 *   An array of extra information to include in the search result.
 */
function book_search_extra($node) {
  // Load all the book data.
  $books = book_get_books();

  // Extract the ID of the book for the current node.
  $bid = $node->book['bid'];

  // Add the book title link to the search result extra array.
  $extra = array(
    t('In book: !book_link', array('!book_link' => l($books[$bid]['link_title'], $books[$bid]['link_path']))),
  );

  // Return the array merged with the normal extra node information.
  return array_merge($extra, node_invoke_nodeapi($node, 'search result'));
}

/**
 * Implements hook_search_status().
 */
function book_search_search_status() {
  $content_type = variable_get('book_child_type');

  $total = db_query('SELECT COUNT(*) FROM {node} n WHERE n.type LIKE :node_type', array(':node_type' => $content_type))->fetchField();
  $remaining = db_query("SELECT COUNT(*) FROM {node} n
    LEFT JOIN {search_dataset} d ON d.type = 'book_search' AND d.sid = n.nid
    WHERE (d.sid IS NULL OR d.reindex <> 0)
      AND n.type LIKE :node_type", array(':node_type' => $content_type))->fetchField();
  return array(
    'remaining' => $remaining,
    'total' => $total,
  );
}

/**
 * Implements hook_search_reset().
 */
function book_search_search_reset() {
  db_update('search_dataset')
    ->fields(array('reindex' => REQUEST_TIME))
    ->condition('type', 'book_search')
    ->execute();
}

/**
 * Return an options array of books on the site.
 *
 * @param $restrict
 *   TRUE or FALSE to indicate whether or not the options array should only
 *     include books that may be searched.
 * @return
 *   An options array of bid => book title for use in a checkboxes element.
 */
function book_search_options($restrict = FALSE) {
  static $options;

  // If the options arrays haven't been built, build them now.
  if (empty($options)) {
    // Loop through all the books.
    foreach (book_get_books() as $bid => $book) {
      // Add every book to the unrestricted book array.
      $options['all'][$bid] = check_plain($book['title']);
    }

    // Get an array of all the books specified in the search settings form.
    $valid = book_search_selected();

    // Make a second array that only includes searchable books.
    if (empty($valid)) {
      $options['restricted'] = $options['all'];
    }
    else {
      $options['restricted'] = array_intersect_key($options['all'], drupal_map_assoc($valid));
    }
  }

  // Return the requested options array.
  return $restrict ? $options['restricted'] : $options['all'];
}

/**
 * Return a simple array of the options selected in a checkboxes element.
 *
 * @param $books
 *   The submitted form value or a checkboxes element; defaults to the books
 *     selected in the search settings form.
 * @return
 *   A simple array of values that were actually selected.
 */
function book_search_selected($books = NULL) {
  // If NULL, default to the books selected in the search settings form.
  if (is_null($books)) {
    $books = variable_get('searchable_books', array());
  }
  return array_intersect(array_values($books), array_keys($books));
}
