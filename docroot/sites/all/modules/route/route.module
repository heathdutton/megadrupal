<?php

/**
 * @file
 * Main Route module file. Implements related Drupal hooks and number of helper functions.
 */

module_load_include('inc', 'route', 'route.form');
module_load_include('inc', 'route', 'route.theme');

/**
 * Implementation of hook_ctools_plugin_directory() to let the system know
 * we implement CTools and panels plugins.
 */
function route_ctools_plugin_directory($module, $plugin) {
  if ($module == 'page_manager' || $module == 'panels' || $module == 'ctools') {
    return 'plugins/' . $plugin;
  }
}

/**
 * Implementation of hook_flush_cache
 */
function route_flush_caches() {
  return array('cache_route');
}

/**
 * Gets route object token currently associated with the given user
 *
 * @param $id
 *   Id of the token to fetch.
 * @param $reset
 *   TRUE to regenerate the token. This will cause rules object associated with this token to be dropped.
 * @param $subtask
 *   subtask to use eg. in AJAX callback when subtask can't be found using current_path()
 *
 * @return String
 */
function route_token($key = NULL, $reset = FALSE, $subtask = FALSE) {
  $token = FALSE;

  // First, get current task_name. This will be used as the key to store
  if ($key || ($subtask && ($key = $subtask)) || $key = route_get_current_page_subtask_name()) {
    // Get a token used to identify currently cached data.
    // We use SESSION here ONLY as a jar to store Cache token for current user.
    // We may try to find better way in the long run, i.e. passing it as part of URL string?
    if ($reset || !isset($_SESSION['route']) || !isset($_SESSION['route']['tokens'][$key]) || !$token = $_SESSION['route']['tokens'][$key]) {
      $token = md5(uniqid(time()));
      $_SESSION['route']['tokens'][$key] = $token;
    }
  }

  return $token;
}

/**
 * Implementation of hook_theme
 *
 * @param $existing
 * @param $type
 * @param $theme
 * @param $path
 * @return
 */
function route_theme($existing, $type, $theme, $path) {
  return array(
    'route_progress_indicator' => array(
      'variables' => array('route' => NULL),
    ),
  );
}

/**
 * Helper function that builds new route object for given subtask using ctools_context_create
 *
 * @param $subtask_name
 *   Name of the subtask to create route object for
 *
 * @param $storage
 *   Initial values to put inside route storage
 *
 * @return
 *   Route object
 */
function route_new($subtask_name, $data = array()) {
  module_load_include('inc', 'ctools', 'includes/context');
  $context = ctools_context_create('route', array(
    'subtask_name' => $subtask_name,
    'data' => $data,
    'reset' => TRUE,
  ));
  return $context->data;
}

/**
 * Main route object data getter. This gets route object from some kind of storage that persist between requests. In our case, it's Drupal cache. Correlation token is maintained within session.
 *
 * @param string $key
 * @param bool $reset
 * @return Route
 */
function route_get($key, $reset = FALSE) {
  $routes = &drupal_static(__FUNCTION__);

  if (!empty($routes[$key]) && !$reset) {
    return $routes[$key];
  }

  if ($route_cache = cache_get($key, 'cache_route')) {
    $routes[$key] = $route_cache->data;
    return $routes[$key];
  }

  return FALSE;
}

/**
 * Main route object data setter. This saves route object in some kind of storage that persist between requests. In our case, it's Drupal cache.
 *
 * @param String $key
 * @param String $data
 */
function route_set($key, $data) {
  $expire = variable_get('route_cache_ttl', 3600);

  // Store defaults in cache.
  cache_set($key, $data, 'cache_route', REQUEST_TIME + $expire);

  // Reset static cache of route_get please
  drupal_static_reset('route_get');
}

/**
 * Flushes the route object associated with the given token key.
 *
 * @param String $key
 */
function route_flush($key) {
  cache_clear_all($key, 'cache_route');
}

/**
 * Works like drupal_get_form but includes route to the form.
 * Also, automatically adds submit button that has necessary route submit handlers associated.
 * Main submit button also gets all necessary _submit functions defined for form and orders them before route handlers.
 *
 * Route object is stored inside $form_state['route'] and available in main form building function as well as validate and submit handlers
 *
 * @param $wrapper_form_id
 * @param $form_id
 * @return $form
 */
function route_get_form($wrapper_form_id, $form_id = NULL) {
  $form_state = array();
  $route = route_get(route_token());

  $args = func_get_args();
  array_shift($args);
  array_shift($args);
  $form_state['build_info']['args'] = $args;
  $form_state['wrapper_callback'] = $wrapper_form_id;
  $form_state['route'] = $route;

  return drupal_build_form($form_id, $form_state);
}

/**
 * Given the path, this function builds path string including current handler URL.
 *
 * @param String $subtask_name
 *   - name of the page_manager subtask to build the path for
 * @param String $step
 *   - Step to navigate to
 * @param array $extras
 *   - Arguments to add to the end of the path
 * @return String
 *   - Drupal path to the given subtask and step
 */
function route_build_path($subtask_name, $step = '', $extra = array()) {
  $task = page_manager_get_task('page');
  $subtasks = page_manager_get_task_subtasks($task);

  if (isset($subtasks[$subtask_name])) {
    $subtask = $subtasks[$subtask_name];
    $subtask_path = explode('/', $subtask['subtask']->path);

    // Extract arguments from subtask path and determine their position in the URL
    // After that, replace active_step parameters with passed step name
    foreach($subtask_path as $index => $element) {
      $type = substr($element, 0, 1);
      if($type == '%' || $type == '!') {
        $argument = substr($element, 1);
        if (isset($subtask['subtask']->arguments[$argument]['name']) && $subtask['subtask']->arguments[$argument]['name'] == 'route_active_step') {
          $subtask_path[$index] = $step;
        }
        else
          unset($subtask_path[$index]);
      }
    }
  }
  foreach ($extra as $argument => $value) {
    $subtask_path[] = $value;
  }

  return trim(implode('/', $subtask_path), '/');
}

/**
 * Return name of the currently loaded subtask
 * This doesn't work for node_view pages because they are not subtasks(!), so in
 * these cases the return value is hardcoded.
 *
 * @return
 *   Name of the active subtask or FALSE if no page is active.
 */
function route_get_current_page_subtask_name() {
  $name = &drupal_static(__FUNCTION__);

  // It's not possible that this function will ever return a different value inside single request, so we can statically cache it.
  if (!empty($name)) {
    return $name;
  }

  if ($subtask = _route_get_current_page_subtask()) {
    $name = $subtask['subtask']->name;
  }
  else if (preg_match('!node/*!', current_path())) {
    $name = 'node_view';
  }

  return $name;
}

/***************************************
 * Helper functions. Considered private.
 ***************************************/

/**
 * Returns information about all steps in the route journey.
 * This looks into the data defined in current page_manager task handler
 * and extracts configuration from the currently configured variants.
 *
 * This is used by route to figure list of steps that are available to the user
 * at any given time.
 *
 * @param $subtask_name
 *   - Name of the page_manager subtask to get steps for
 *
 * @return Array
 */
function _route_get_steps($subtask_name = NULL) {
  ctools_include('context-task-handler');
  $steps = array();

  // Get current subtask_id
  if ($subtask_name) {
    module_load_include('inc', 'ctools', 'page_manager/plugins/tasks/page');
    $page = page_manager_page_load($subtask_name);

    if(is_object($page)) {

      $task = page_manager_get_task($page->task);

      if ($handlers = page_manager_load_sorted_handlers($task, $subtask_name, TRUE)) {

        // Produce final step array.
        foreach($handlers as $handler) {
          if (_route_is_step($handler)) {
            $step_name = _route_get_step_name($handler);
            $steps[$step_name][] = $handler->conf;
            $steps[$step_name]['#indicator'] = TRUE;
          }
        }
      }
    }
  }

  return $steps;
}

/**
 * Given CTools handler, checks if handler provided is an active step.
 *
 * This function checks selection rules EXCEPT the route panels
 * selection rules. In this scenario we always want route panels
 * selection rules to be ignored.
 *
 * @param  $handler
 * @return
 *   - TRUE if the handler is an active step or FALSE otherwise
 */
function _route_is_step($handler) {
  $handler_conf = $handler->conf;

  // Get base contexts associated with the handler
  // We're only interested in base contexts here
  // because argument contexts are dependant on URL arugments
  // which are not present in here.
  $contexts = array();
  foreach($handler_conf['contexts'] as $data) {
    $key = implode('_', array($data['name'], $data['id']));
    $contexts[$key] = ctools_context_create($data['name'], $data, TRUE);
  }

  // For route purposes we're processing only variants that have active_step selection rule applied.
  // Also, we're ignoring route related selection rules in the access check later on, so in here we're unsetting them from access settings.
  if (isset($handler_conf['access']['plugins']) && !empty($handler_conf['access']['plugins'])) {
    $has_step_name = FALSE;
    foreach($handler_conf['access']['plugins'] as $key => $plugin) {
      // Make sure that step_name access rules is present in this handler
      if ($plugin['name'] == 'route_step_name') {
        $has_step_name = TRUE;
      }

      // Temporarily remove all route related access rules.
      // We don't want them applied in the ctools_access step
      $ignore_access_rules = array('route_step_name', 'route_status');
      if (in_array($plugin['name'], $ignore_access_rules)) {
        unset($handler_conf['access']['plugins'][$key]);
      }
    }

    // Check access on remainig selection rules.
    if ($has_step_name) {
      return ctools_access($handler_conf['access'], $contexts);
    }
  }

  return FALSE;
}


/**
 * Given CTools handler name, retrieves step name (if there is any)
 *
 * @param  $handler
 * @return
 *   - name of the step if the handler is an active step or FALSE otherwise
 */
function _route_get_step_name($handler) {
  $handler_conf = $handler->conf;

  if (isset($handler_conf['access']['plugins']) && !empty($handler_conf['access']['plugins'])) {
    foreach($handler_conf['access']['plugins'] as $key => $plugin) {
      // Extract step name from
      if ($plugin['name'] == 'route_step_name') {
        return $plugin['settings']['step_name'];
      }
    }
  }

  return FALSE;
}

/**
 * Returns information about currently active subtask. It's odd, but I can't find the functions that will do this for me in CTools API itself. :(
 *
 * @return Array
 */
function _route_get_current_page_subtask() {
  $task = page_manager_get_task('page');
  $subtasks = page_manager_get_task_subtasks($task);
  $path = explode('/', current_path());
  $matching_subtasks = array();

  // FIXME: this is dodgy, but currently I don't see an easy way of getting CURRENTLY active task than by comparing paths.
  // And we can't use menu_get_item here because of cyclic dependecies
  foreach($subtasks as $subtask) {
    $subtask_path = explode('/', $subtask['subtask']->path);
    $current_page_subtask = TRUE;

    // Loop through the subtask path and try to determine if it's matching the current URL
    // This will prepare the list of all matching subtasks
    foreach($subtask_path as $index => $element) {
      $type = substr($element, 0, 1);
      $argument = substr($element, 1);

      // If current path element is an argument, please skip the test below.
      if(($type == '%' || $type == '!') && isset($subtask['subtask']->arguments[$argument])) {
        continue;
      }

      // If the path element is not the same, then we're not on the same path.
      if ($path[$index] != $subtask_path[$index]) {
        $current_page_subtask = FALSE;
        break;
      }
    }

    // If test passed, please add to the list of matching subtasks.
    if ($current_page_subtask) {
      $matching_subtasks[count($subtask_path)] = $subtask;
    }
  }

  // If there are any matching subtasks, please return the one that has the longest matching path (most relevant one)
  if (!empty($matching_subtasks)) {
    return $matching_subtasks[max(array_keys($matching_subtasks))];
  }

  return FALSE;
}